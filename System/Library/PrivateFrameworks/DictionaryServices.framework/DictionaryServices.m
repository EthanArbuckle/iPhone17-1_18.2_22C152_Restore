CFMutableArrayRef DCSSearchFoundationCopyResultsWithOptions(const __CFString *a1, const __CFArray *a2, const __CFString *a3)
{
  uint64_t v6;
  CFIndex Length;
  CFIndex v8;
  CFIndex MaximumSizeForEncoding;
  uint64_t v10;
  const char *v11;
  CFIndex v12;
  Class Class;
  Class v14;
  __CFArray *v15;
  CFIndex v16;
  __CFString *v17;
  DCSDictionary **ValueAtIndex;
  CFArrayRef v19;
  const void *v20;
  id v21;
  CFStringRef v22;
  __CFString *v23;
  CFArrayRef v24;
  DCSDictionary **v25;
  const void *Value;
  const void *v27;
  const void *v28;
  __CFString *v29;
  __CFString *v30;
  CFStringRef Identifier;
  CFIndex v32;
  DCSRecord *Title;
  id v34;
  id v35;
  uint64_t v36;
  CFArrayRef v37;
  const void *v38;
  CFArrayRef v39;
  CFStringRef v40;
  id v41;
  id v42;
  id v43;
  id v44;
  CFStringRef v45;
  CFDictionaryRef v46;
  CFStringRef v47;
  const CFArrayCallBacks *v48;
  CFArrayRef v49;
  CFArrayRef v50;
  CFArrayRef v51;
  CFIndex v52;
  CFMutableArrayRef v53;
  CFIndex v54;
  __CFString *v55;
  const void *v56;
  __CFString *v57;
  CFDictionaryRef v58;
  const void *v59;
  unint64_t v60;
  CFMutableArrayRef v61;
  __CFArray *v62;
  uint64_t v63;
  CFStringRef v64;
  CFIndex v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  __CFString *v70;
  CFArrayRef v71;
  CFStringRef v72;
  uint64_t v73;
  __CFNumberFormatter *v74;
  CFIndex v75;
  CFNumberRef v76;
  CFStringRef StringWithNumber;
  CFStringRef v78;
  __CFNumberFormatter *v79;
  const void *v80;
  __CFString *v81;
  CFStringRef v82;
  id v83;
  CFStringRef v84;
  uint64_t v85;
  CFDictionaryRef Name;
  id v87;
  CFDictionaryRef v88;
  uint64_t v90;
  id v91;
  SEL v92;
  __CFString *v93;
  const void *v94;
  __CFString *v95;
  SEL v96;
  CFIndex v97;
  CFIndex v98;
  SEL v99;
  SEL v100;
  SEL v101;
  __CFString *v102;
  CFStringRef v103;
  CFArrayRef v104;
  SEL v105;
  SEL v106;
  SEL v107;
  SEL v108;
  SEL v109;
  SEL v110;
  __CFString *v111;
  SEL v112;
  SEL v113;
  SEL v114;
  SEL v115;
  Class v116;
  CFIndex v117;
  __CFArray *v118;
  CFMutableArrayRef Mutable;
  __CFString *v120;
  __CFString *v121;
  __CFString *v122;
  __CFString *v123;
  SEL v124;
  CFIndex Count;
  DCSDictionary **v126;
  CFArrayRef v127;
  id v128;
  DCSDictionary **v129;
  uint64_t v130;
  SEL v131;
  SEL v132;
  uint64_t v133;
  __CFArray *v134;
  unint64_t v135;
  __CFString *v136;
  CFIndex valuePtr;
  void *v138[2];
  void *values[7];
  CFRange v140;
  CFRange v141;

  values[6] = *(void **)MEMORY[0x1E4F143B8];
  if (_GetSearchFoundationFrameworkInfo__DispatchOnceToken != -1) {
    dispatch_once(&_GetSearchFoundationFrameworkInfo__DispatchOnceToken, &__block_literal_global_4);
  }
  v6 = _GetSearchFoundationFrameworkInfo__InfoPtr;
  if (!_GetSearchFoundationFrameworkInfo__InfoPtr) {
    return 0;
  }
  v91 = (id)NewAutoReleasePool();
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  Length = CFStringGetLength(@"com.apple.dictionary");
  if (a2) {
    Count = CFArrayGetCount(a2);
  }
  else {
    Count = 0;
  }
  v116 = *(Class *)v6;
  if (a3)
  {
    v8 = CFStringGetLength(a3);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v8, 0x8000100u);
    MEMORY[0x1F4188790](MaximumSizeForEncoding);
    v11 = (char *)&v90 - v10;
    if (CFStringGetCString(a3, (char *)&v90 - v10, v12, 0x8000100u))
    {
      Class = objc_getClass(v11);
      v14 = *(Class *)v6;
      v116 = Class;
      if (([(objc_class *)Class isSubclassOfClass:v14] & 1) == 0) {
        v116 = *(Class *)v6;
      }
    }
  }
  if (Count >= 1)
  {
    v15 = 0;
    v16 = 0;
    v124 = sel_setIdentifier_;
    v115 = sel_setType_;
    v114 = sel_setIsQuickGlance_;
    v113 = sel_setSectionBundleIdentifier_;
    v112 = sel_setResultBundleId_;
    v17 = @"DCSTextElementKeyRecordID";
    v120 = @"DCSTextElementKeyHeadword";
    v111 = @"DCSTextElementKeySyllabifiedHeadword";
    v123 = @"DCSTextElementKeyPartOfSpeech";
    v122 = @"DCSTextElementKeyPronunciation";
    v98 = Length + 1;
    v97 = ~Length;
    v121 = @"DCSTextElementKeySensesWithAttributes";
    v106 = sel_setText_;
    v101 = sel_setIsBold_;
    v100 = sel_setFormattedTextPieces_;
    v95 = @"DCSTextElementSenseKeyIsExplicit";
    v94 = (const void *)*MEMORY[0x1E4F1CFD0];
    v93 = @"DCSTextElementSenseKeyText";
    v105 = sel_setDescriptions_;
    v96 = sel_setTitle_;
    v110 = sel_setFootnote_;
    v109 = sel_setDictionaryID_;
    v108 = sel_setSearchString_;
    v107 = sel_setCard_;
    v99 = sel_textWithString_;
    v92 = sel_setMaxLines_;
    v104 = a2;
    v103 = a1;
    v102 = @"DCSTextElementKeyRecordID";
    while (1)
    {
      ValueAtIndex = (DCSDictionary **)CFArrayGetValueAtIndex(a2, v16);
      v140.length = CFStringGetLength(a1);
      v129 = ValueAtIndex;
      v140.location = 0;
      v19 = DCSCopyDefinitionRecords(ValueAtIndex, a1, v140, 2);
      if (v19) {
        break;
      }
LABEL_66:
      if (++v16 == Count) {
        goto LABEL_67;
      }
    }
    v127 = v19;
    v20 = CFArrayGetValueAtIndex(v19, 0);
    v21 = (id)objc_opt_new();
    v22 = CFStringCreateWithFormat(0, 0, @"local-dictionary-%d:%@", v15, a1);
    objc_msgSend(v21, v124, v22);
    CFRelease(v22);
    objc_msgSend(v21, v115, 2);
    objc_msgSend(v21, v114, 1);
    objc_msgSend(v21, v113, @"com.apple.dictionary");
    v128 = v21;
    objc_msgSend(v21, v112, @"com.apple.dictionary");
    values[0] = v17;
    values[1] = v120;
    v23 = v111;
    values[2] = v111;
    values[3] = v123;
    values[4] = v122;
    values[5] = v121;
    v24 = CFArrayCreate(0, (const void **)values, 6, MEMORY[0x1E4F1D510]);
    v25 = DCSRecordCopyTextElements((uint64_t)v20, v24);
    CFRelease(v24);
    if (!v25)
    {
      Title = DCSRecordGetTitle((uint64_t)v20);
      if (!Title) {
        Title = DCSRecordGetHeadword((uint64_t)v20);
      }
      v34 = objc_msgSend(*(id *)(v6 + 24), v99, Title);
      v35 = v128;
      objc_msgSend(v128, v96, v34);
      v36 = DCSRecordCopyDefinition((uint64_t)v20);
      v37 = v127;
      if (v36)
      {
        v38 = (const void *)v36;
        v138[0] = 0;
        v138[0] = objc_msgSend(*(id *)(v6 + 16), v99, v36);
        objc_msgSend(v138[0], v92, 3);
        v39 = CFArrayCreate(0, (const void **)v138, 1, MEMORY[0x1E4F1D510]);
        objc_msgSend(v35, v105, v39);
        CFRelease(v39);
        CFRelease(v38);
      }
      goto LABEL_65;
    }
    v117 = v16;
    Value = CFDictionaryGetValue((CFDictionaryRef)v25, v23);
    if (!Value) {
      Value = CFDictionaryGetValue((CFDictionaryRef)v25, v120);
    }
    v27 = CFDictionaryGetValue((CFDictionaryRef)v25, v122);
    v28 = CFDictionaryGetValue((CFDictionaryRef)v25, v123);
    v126 = v25;
    v29 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)v25, v17);
    if (v29) {
      v30 = v29;
    }
    else {
      v30 = &stru_1F2DE4460;
    }
    Identifier = (const __CFString *)DCSDictionaryGetIdentifier((uint64_t)v129);
    if (CFStringHasPrefix(Identifier, @"com.apple.dictionary"))
    {
      v32 = CFStringGetLength(Identifier);
      v141.length = v32 + v97;
      v141.location = v98;
      Identifier = CFStringCreateWithSubstring(0, Identifier, v141);
    }
    else
    {
      CFRetain(Identifier);
    }
    v40 = CFStringCreateWithFormat(0, 0, @"d:%@.%@", Identifier, v30);
    CFRelease(Identifier);
    v41 = v128;
    objc_msgSend(v128, v124, v40);
    CFRelease(v40);
    v42 = (id)objc_opt_new();
    v43 = (id)objc_opt_new();
    objc_msgSend(v43, v106, Value);
    objc_msgSend(v43, v101, 1);
    v44 = (id)objc_opt_new();
    if (v28 && v27)
    {
      v45 = CFStringCreateWithFormat(0, 0, @"  |  %@  |  %@", v27, v28);
      v46 = (const __CFDictionary *)v126;
      if (!v45) {
        goto LABEL_38;
      }
    }
    else
    {
      v46 = (const __CFDictionary *)v126;
      if (v27)
      {
        v47 = CFStringCreateWithFormat(0, 0, @"  |  %@", v27);
      }
      else
      {
        if (!v28) {
          goto LABEL_38;
        }
        v47 = CFStringCreateWithFormat(0, 0, @"  |  %@", v28);
      }
      v45 = v47;
      if (!v47)
      {
LABEL_38:
        v138[0] = v43;
        v138[1] = v44;
        v48 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
        v49 = CFArrayCreate(0, (const void **)v138, 2, MEMORY[0x1E4F1D510]);
        objc_msgSend(v42, v100, v49);
        CFRelease(v49);
        objc_msgSend(v41, sel_getUid("setTitle:"), v42);
        v50 = (const __CFArray *)CFDictionaryGetValue(v46, v121);
        v118 = v15;
        if (v50)
        {
          v51 = v50;
          v52 = CFArrayGetCount(v50);
          v53 = CFArrayCreateMutable(0, v52, v48);
          if (v52)
          {
            v54 = 0;
            v55 = v95;
            v56 = v94;
            v57 = v93;
            v15 = v53;
            do
            {
              v58 = (const __CFDictionary *)CFArrayGetValueAtIndex(v51, v54);
              if (CFDictionaryGetValue(v58, v55) != v56)
              {
                v59 = CFDictionaryGetValue(v58, v57);
                CFArrayAppendValue(v15, v59);
              }
              ++v54;
            }
            while (v52 != v54);
            goto LABEL_47;
          }
        }
        else
        {
          v53 = CFArrayCreateMutable(0, 0, v48);
        }
        v15 = v53;
LABEL_47:
        v60 = CFArrayGetCount(v15);
        v61 = CFArrayCreateMutable(0, 0, v48);
        v62 = v61;
        v135 = v60;
        if (v60 >= 2) {
          v63 = 2;
        }
        else {
          v63 = v60;
        }
        v64 = @"%@%@%@";
        if (v63)
        {
          v65 = 0;
          v131 = sel_setMaxLines_;
          v132 = sel_textWithString_;
          v66 = 2;
          if (v135 == 1) {
            v66 = 4;
          }
          v130 = v66;
          v67 = 1;
          v133 = v63;
          v134 = v61;
          do
          {
            v68 = v135;
            if (v135 > 2 && v67 == 0) {
              v70 = @"â€¦";
            }
            else {
              v70 = &stru_1F2DE4460;
            }
            v136 = v70;
            v71 = v15;
            v72 = v64;
            v73 = v6;
            v74 = CFNumberFormatterCreate(0, 0, kCFNumberFormatterDecimalStyle);
            v75 = v65 + 1;
            valuePtr = v65 + 1;
            v76 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
            StringWithNumber = CFNumberFormatterCreateStringWithNumber(0, v74, v76);
            CFRelease(v76);
            v78 = CFStringCreateWithFormat(0, 0, @"%@. ", StringWithNumber);
            CFRelease(StringWithNumber);
            v79 = v74;
            v6 = v73;
            v64 = v72;
            v15 = v71;
            CFRelease(v79);
            v80 = CFArrayGetValueAtIndex(v71, v65);
            if (v68 == 1) {
              v81 = &stru_1F2DE4460;
            }
            else {
              v81 = (__CFString *)v78;
            }
            v82 = CFStringCreateWithFormat(0, 0, v64, v81, v80, v136);
            v83 = objc_msgSend(*(id *)(v6 + 16), v132, v82);
            v84 = v82;
            v62 = v134;
            CFRelease(v84);
            CFRelease(v78);
            objc_msgSend(v83, v131, v130);
            CFArrayAppendValue(v62, v83);
            --v67;
            v65 = v75;
          }
          while (v75 != v133);
        }
        v35 = v128;
        objc_msgSend(v128, v105, v62);
        CFRelease(v62);
        CFRelease(v15);
        CFRelease(v126);
        a2 = v104;
        a1 = v103;
        LODWORD(v15) = v118;
        v16 = v117;
        v17 = v102;
        v37 = v127;
LABEL_65:
        v15 = (__CFArray *)(v15 + 1);
        v85 = (uint64_t)v129;
        Name = DCSDictionaryGetName((uint64_t)v129);
        objc_msgSend(v35, v110, Name);
        v87 = (id)objc_opt_new();
        v88 = DCSDictionaryGetIdentifier(v85);
        objc_msgSend(v87, v109, v88);
        objc_msgSend(v87, v108, a1);
        objc_msgSend(v35, v107, v87);
        CFArrayAppendValue(Mutable, v35);
        CFRelease(v37);
        goto LABEL_66;
      }
    }
    objc_msgSend(v44, v106, v45);
    CFRelease(v45);
    goto LABEL_38;
  }
LABEL_67:

  return Mutable;
}

uint64_t NewAutoReleasePool()
{
  if (_GetFoundationFrameworkInfo__DispatchOnceToken != -1) {
    dispatch_once(&_GetFoundationFrameworkInfo__DispatchOnceToken, &__block_literal_global_53);
  }
  if (!_GetFoundationFrameworkInfo__InfoPtr) {
    return 0;
  }

  return objc_opt_new();
}

__CFArray *DCSEnvironment::copyActiveDictionaries(DCSEnvironment *this, const __CFDictionary *a2)
{
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (a2)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a2, @"DCSFilterOptionAllowNetworkServices");
    if (Value) {
      BOOL v25 = CFBooleanGetValue(Value) != 0;
    }
    else {
      BOOL v25 = 0;
    }
    CFStringRef v5 = (const __CFString *)CFDictionaryGetValue(a2, @"DCSFilterOptionIndexLanguage");
    CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(a2, @"DCSFilterOptionDescriptionLanguage");
  }
  else
  {
    BOOL v25 = 0;
    CFStringRef v5 = 0;
    CFStringRef v6 = 0;
  }
  CFArrayRef ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(this);
  v22 = (pthread_mutex_t *)((char *)this + 264);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
  CFArrayRef theArray = ActiveDictionaries;
  if (ActiveDictionaries)
  {
    CFIndex Count = CFArrayGetCount(ActiveDictionaries);
    if (Count >= 1)
    {
      CFIndex v8 = 0;
      while (1)
      {
        ValueAtIndex = (DCSDictionary **)CFArrayGetValueAtIndex(theArray, v8);
        v10 = ValueAtIndex;
        if (ValueAtIndex) {
          v11 = ValueAtIndex[2];
        }
        else {
          v11 = 0;
        }
        if (!v25 && (DCSDictionary::isNetworkDictionary(v11) & 1) != 0) {
          goto LABEL_24;
        }
        if (!((unint64_t)v5 | (unint64_t)v6)) {
          goto LABEL_23;
        }
        CFArrayRef v12 = DCSDictionary::languages((CFDictionaryRef *)v11);
        if (v12) {
          break;
        }
LABEL_24:
        if (++v8 == Count) {
          goto LABEL_25;
        }
      }
      CFArrayRef v13 = v12;
      CFIndex v14 = CFArrayGetCount(v12);
      if (v14 >= 1)
      {
        CFIndex v15 = v14;
        CFIndex v16 = 0;
        while (1)
        {
          CFDictionaryRef v17 = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, v16);
          v18 = (DCSEnvironment *)CFDictionaryGetValue(v17, @"DCSDictionaryIndexLanguage");
          if (DCSEnvironment::checkLanguageMatch(v18, (CFStringRef)v18, v5))
          {
            v19 = (DCSEnvironment *)CFDictionaryGetValue(v17, @"DCSDictionaryDescriptionLanguage");
            if (DCSEnvironment::checkLanguageMatch(v19, (CFStringRef)v19, v6)) {
              break;
            }
          }
          if (v15 == ++v16) {
            goto LABEL_24;
          }
        }
      }
LABEL_23:
      CFArrayAppendValue(Mutable, v10);
      goto LABEL_24;
    }
  }
LABEL_25:
  pthread_mutex_unlock(v22);
  v20 = Mutable;
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return v20;
}

uint64_t DCSBaseDictionary::isNetworkDictionary(DCSBaseDictionary *this)
{
  return 0;
}

const __CFDictionary *DCSDictionary::isNetworkDictionary(DCSDictionary *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(*(void *)v2 + 208);
    return (const __CFDictionary *)v3();
  }
  else
  {
    CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 5);
    if (result)
    {
      CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"network");
      if (result) {
        return (const __CFDictionary *)(CFBooleanGetValue(result) != 0);
      }
    }
  }
  return result;
}

uint64_t DCSEnvironment::getActiveDictionaries(DCSEnvironment *this)
{
  uint64_t result = *((void *)this + 7);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
    if (*((void *)this + 7))
    {
      DCSLog(16, @"DCSEnvironment::getActiveDictionaries hit cache");
    }
    else
    {
      CFArrayRef Count = DCSDictionaryAssetCopyInstalledDictionaries();
      CFArrayRef v4 = Count;
      if (Count) {
        CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
      }
      DCSLog(16, @"DCSEnvironment::getActiveDictionaries queried and found %ld assets", Count);
      *((void *)this + 7) = v4;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
    return *((void *)this + 7);
  }
  return result;
}

__CFArray *DCSCopyActiveDictionaries(const __CFDictionary *a1)
{
  uint64_t v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();

  return DCSEnvironment::copyActiveDictionaries(v2, a1);
}

uint64_t SyncSingleton<DCSEnvironment>::instance()
{
  if (!SyncSingleton<DCSEnvironment>::_instantiated)
  {
    pthread_mutex_lock(&SyncSingleton<DCSEnvironment>::_mutex);
    if (!SyncSingleton<DCSEnvironment>::_instantiated) {
      operator new();
    }
    pthread_mutex_unlock(&SyncSingleton<DCSEnvironment>::_mutex);
  }
  return SyncSingleton<DCSEnvironment>::_instance;
}

void sub_1D5901F0C(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10E0C401AB056A1);
  _Unwind_Resume(a1);
}

void DCSDictionary::DCSDictionary(DCSDictionary *this, const __CFURL *a2, __CFDictionary *a3)
{
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 16) = 0;
  *((void *)this + 3) = 0;
  *((_WORD *)this + 16) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 7) = 0;
  *((_WORD *)this + 32) = 0;
  *((void *)this + 11) = -1;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 104), 0);
  *(void *)this = DCSDictionary::createDictionaryRef(this);
  if (a2) {
    CFURLRef v6 = CFURLCopyAbsoluteURL(a2);
  }
  else {
    CFURLRef v6 = 0;
  }
  *((void *)this + 6) = v6;
  if (a3)
  {
    CFTypeRef v7 = CFRetain(a3);
    CFURLRef v6 = (CFURLRef)*((void *)this + 6);
  }
  else
  {
    CFTypeRef v7 = 0;
  }
  *((void *)this + 12) = v7;
  if (v6)
  {
    CFIndex v8 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
    uint64_t v9 = DCSEnvironment::cachedDictionariesInfo(v8);
    if (v9)
    {
      CFDictionaryRef v10 = (const __CFDictionary *)v9;
      CFStringRef v11 = CFURLCopyFileSystemPath(*((CFURLRef *)this + 6), kCFURLPOSIXPathStyle);
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v10, @"dictionaries");
      if (Value)
      {
        CFArrayRef v13 = CFDictionaryGetValue(Value, v11);
        *((void *)this + 5) = v13;
        if (v13) {
          CFRetain(v13);
        }
      }
      else
      {
        *((void *)this + 5) = 0;
      }
      CFRelease(v11);
    }
  }
  if (!*((void *)this + 5) && DCSDictionary::createDictionaryObj(this))
  {
    CFIndex v14 = (DCSBaseDictionary *)*((void *)this + 1);
    if (v14)
    {
      if (!*((void *)this + 5))
      {
        *((void *)this + 5) = _CreateDictionaryCacheInfo(v14);
        *((unsigned char *)this + 33) = 1;
      }
    }
    uint64_t v15 = SyncSingleton<DCSEnvironment>::instance();
    DCSEnvironment::updateDictionaryCacheInfo(v15, a2, *((const __CFDictionary **)this + 5));
  }
}

uint64_t DCSDictionary::createDictionaryRef(DCSDictionary *this)
{
  pthread_once(&_DCSDictionaryClassID(void)::once_control, (void (*)(void))_DCSDictionaryInitialize);
  uint64_t result = _CFRuntimeCreateInstance();
  if (result) {
    *(void *)(result + 16) = this;
  }
  return result;
}

uint64_t DCSDictionary::createDictionaryObj(DCSDictionary *this)
{
  if (!*((unsigned char *)this + 16))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 104));
    if (*((unsigned char *)this + 16))
    {
LABEL_31:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 104));
      return *((void *)this + 1);
    }
    if (*((unsigned char *)this + 32))
    {
      uint64_t DictionaryObj = DCSDictionary::createDictionaryObj(*((DCSDictionary **)this + 3));
      if (DictionaryObj)
      {
        CFArrayRef v4 = (const __CFArray *)(*(uint64_t (**)(uint64_t))(*(void *)DictionaryObj + 144))(DictionaryObj);
        if (v4)
        {
          CFArrayRef v5 = v4;
          CFIndex Count = CFArrayGetCount(v4);
          if (Count >= 1)
          {
            CFIndex v7 = Count;
            CFIndex v8 = 0;
            while (1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v5, v8);
              CFStringRef v10 = (const __CFString *)DCSDictionary::identifier(this);
              CFStringRef v11 = (const __CFString *)(*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 24))(ValueAtIndex);
              if (CFEqual(v10, v11)) {
                break;
              }
              if (v7 == ++v8) {
                goto LABEL_20;
              }
            }
            *((void *)this + 1) = ValueAtIndex;
            *((void *)this + 9) = v8;
          }
        }
      }
      goto LABEL_20;
    }
    CFURLRef v12 = (const __CFURL *)*((void *)this + 6);
    if (*((void *)this + 12))
    {
      if (v12) {
        goto LABEL_15;
      }
      CFURLRef v12 = (const __CFURL *)DCSEnvironment::copyInactiveDictionaries(*((DCSEnvironment **)this + 12), v2);
      *((void *)this + 6) = v12;
    }
    if (!v12)
    {
LABEL_20:
      uint64_t v15 = *((void *)this + 1);
      if (v15)
      {
        *(void *)(v15 + 8) = this;
        *(unsigned char *)(v15 + 16) = 1;
        if (((*(uint64_t (**)(uint64_t))(*(void *)v15 + 200))(v15) & 1) == 0)
        {
          uint64_t v16 = *((void *)this + 1);
          if (v16) {
            (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
          }
          *((void *)this + 1) = 0;
        }
      }
      if (!*((unsigned char *)this + 32) && *((void *)this + 1))
      {
        CFDictionaryRef v17 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
        CFStringRef v18 = (const __CFString *)(*(uint64_t (**)(void))(**((void **)this + 1) + 24))(*((void *)this + 1));
        DictionaryPreference = DCSEnvironment::getDictionaryPreference(v17, v18);
        if (DictionaryPreference) {
          (*(void (**)(void, const void *))(**((void **)this + 1) + 184))(*((void *)this + 1), DictionaryPreference);
        }
        *((unsigned char *)this + 64) = 0;
        DCSDictionary::subDictionaries(this);
      }
      *((unsigned char *)this + 16) = *((void *)this + 6) != 0;
      goto LABEL_31;
    }
LABEL_15:
    CFStringRef v13 = CFURLCopyPathExtension(v12);
    if (v13)
    {
      CFStringRef v14 = v13;
      if (CFEqual(v13, @"dictionary")) {
        operator new();
      }
      CFRelease(v14);
    }
    goto LABEL_20;
  }
  return *((void *)this + 1);
}

void sub_1D5902374(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C40ECEE0193);
  _Unwind_Resume(a1);
}

__CFDictionary *DCSDictionary::dictionaryCacheInfo(DCSDictionary *this, int a2)
{
  if (!*((void *)this + 1)) {
    return 0;
  }
  uint64_t result = (__CFDictionary *)*((void *)this + 5);
  if (a2)
  {
    if (result)
    {
      CFRelease(result);
      *((void *)this + 5) = 0;
    }
  }
  else if (result)
  {
    return result;
  }
  uint64_t result = _CreateDictionaryCacheInfo(*((DCSBaseDictionary **)this + 1));
  *((void *)this + 5) = result;
  *((unsigned char *)this + 33) = 1;
  return result;
}

void DCSDictionary::DCSDictionary(DCSDictionary *this, CFURLRef *a2, const __CFDictionary *a3)
{
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 16) = 0;
  *((unsigned char *)this + 33) = 0;
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 64) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = -1;
  *((void *)this + 12) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 104), 0);
  *(void *)this = DCSDictionary::createDictionaryRef(this);
  *((void *)this + 6) = CFURLCopyAbsoluteURL(a2[6]);
  *((void *)this + 5) = CFRetain(a3);
  *((void *)this + 3) = a2;
  *((unsigned char *)this + 32) = 1;
}

void DCSDictionary::DCSDictionary(DCSDictionary *this, CFURLRef *a2, DCSBaseDictionary *a3)
{
  *((unsigned char *)this + 33) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 64) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = -1;
  *((void *)this + 12) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 104), 0);
  *(void *)this = DCSDictionary::createDictionaryRef(this);
  *((void *)this + 6) = CFURLCopyAbsoluteURL(a2[6]);
  *((void *)this + 3) = a2;
  *((unsigned char *)this + 32) = 1;
  *((void *)this + 1) = a3;
  *((unsigned char *)this + 16) = 1;
  *((void *)a3 + 1) = this;
  *((unsigned char *)a3 + 16) = 1;
  CFDictionaryRef v6 = a2[5];
  if (v6)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v6, @"sub dictionaries");
    if (Value)
    {
      CFArrayRef v8 = Value;
      CFIndex Count = CFArrayGetCount(Value);
      if (Count >= 1)
      {
        CFIndex v10 = Count;
        CFIndex v11 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v11);
          CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"identifier");
          CFStringRef v14 = (const __CFString *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a3 + 24))(a3);
          if (CFEqual(v13, v14)) {
            break;
          }
          if (v10 == ++v11) {
            return;
          }
        }
        *((void *)this + 5) = CFRetain(ValueAtIndex);
      }
    }
  }
}

void DCSDictionary::~DCSDictionary(DCSDictionary *this)
{
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 104));
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  v3 = (const void *)*((void *)this + 6);
  if (v3) {
    CFRelease(v3);
  }
  CFArrayRef v4 = (const void *)*((void *)this + 12);
  if (v4) {
    CFRelease(v4);
  }
  CFArrayRef v5 = (const void *)*((void *)this + 5);
  if (v5) {
    CFRelease(v5);
  }
  CFDictionaryRef v6 = (const void *)*((void *)this + 7);
  if (v6) {
    CFRelease(v6);
  }
  CFIndex v7 = (const void *)*((void *)this + 10);
  if (v7) {
    CFRelease(v7);
  }
}

uint64_t DCSDictionary::dictionaryRefClassID(DCSDictionary *this)
{
  return _DCSDictionaryID;
}

const __CFDictionary *DCSDictionary::identifier(DCSDictionary *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(*(void *)v2 + 24);
    return (const __CFDictionary *)v3();
  }
  else
  {
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)this + 5);
    if (v5)
    {
      CFDictionaryRef v6 = @"identifier";
    }
    else
    {
      CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 12);
      if (!result) {
        return result;
      }
      CFDictionaryRef v7 = (const __CFDictionary *)DCSMAGetAssetAttributes(result);
      CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(v7, @"DictionaryIdentifier");
      if (result) {
        return result;
      }
      CFDictionaryRef v6 = @"DictionaryPackageName";
      CFDictionaryRef v5 = v7;
    }
    return (const __CFDictionary *)CFDictionaryGetValue(v5, v6);
  }
}

const __CFDictionary *DCSDictionary::name(DCSDictionary *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(*(void *)v2 + 40);
    return (const __CFDictionary *)v3();
  }
  else
  {
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)this + 5);
    if (v5)
    {
      CFDictionaryRef v6 = @"name";
    }
    else
    {
      CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 12);
      if (!result) {
        return result;
      }
      CFDictionaryRef v5 = (const __CFDictionary *)DCSMAGetAssetAttributes(result);
      CFDictionaryRef v6 = @"DictionaryPackageDisplayName";
    }
    return (const __CFDictionary *)CFDictionaryGetValue(v5, v6);
  }
}

const __CFString *DCSDictionary::shortName(DCSDictionary *this)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(SyncSingleton<DCSEnvironment>::instance() + 192);
  CFIndex Count = CFDictionaryGetCount(v2);
  CFArrayRef v4 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  CFStringRef CurrentAppLocalization = DCSEnvironment::getCurrentAppLocalization(v4);
  uint64_t v6 = *((void *)this + 1);
  if (v6)
  {
    CFStringRef v7 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 88))(v6);
    if (Count > 1 || v7 == 0)
    {
      if (v7 && CFDictionaryGetValue(v2, v7) == (const void *)*MEMORY[0x1E4F1CFD0])
      {
        uint64_t v9 = (*(uint64_t (**)(void))(**((void **)this + 1) + 56))(*((void *)this + 1));
        goto LABEL_21;
      }
    }
    else if (CompareLanguageCode(v7, CurrentAppLocalization, 0))
    {
      CFStringRef v16 = (const __CFString *)(*(uint64_t (**)(void))(**((void **)this + 1) + 64))(*((void *)this + 1));
      if (v16) {
        return v16;
      }
      uint64_t v9 = (*(uint64_t (**)(void))(**((void **)this + 1) + 72))(*((void *)this + 1));
LABEL_21:
      CFStringRef v16 = (const __CFString *)v9;
      if (!v9) {
        goto LABEL_22;
      }
      return v16;
    }
LABEL_22:
    CFDictionaryRef v17 = *(uint64_t (**)(void))(**((void **)this + 1) + 48);
    return (const __CFString *)v17();
  }
  CFDictionaryRef v10 = (const __CFDictionary *)*((void *)this + 5);
  if (!v10) {
    return 0;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v10, @"primary language");
  CFStringRef v12 = Value;
  if (Count > 1 || Value == 0)
  {
    if (!Value)
    {
      CFStringRef v14 = 0;
      goto LABEL_29;
    }
  }
  else if (CompareLanguageCode(Value, CurrentAppLocalization, 0))
  {
    CFStringRef v16 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), @"native name");
    if (!v16) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  CFStringRef v14 = CFDictionaryGetValue(v2, v12);
LABEL_29:
  v20 = (const void *)*MEMORY[0x1E4F1CFD0];
  if (v14 == (const void *)*MEMORY[0x1E4F1CFD0]) {
    v21 = @"localized detailed names";
  }
  else {
    v21 = @"localized names";
  }
  CFDictionaryRef v22 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), v21);
  if (!v22) {
    goto LABEL_35;
  }
  CFStringRef v16 = (const __CFString *)CFDictionaryGetValue(v22, CurrentAppLocalization);
  if (v16) {
    goto LABEL_34;
  }
  if (!DCSDictionary::createDictionaryObj(this)) {
    return 0;
  }
  if (!*((unsigned char *)this + 33))
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *((CFDictionaryRef *)this + 5));
    CFRelease(*((CFTypeRef *)this + 5));
    *((void *)this + 5) = MutableCopy;
    *((unsigned char *)this + 33) = 1;
  }
  CFStringRef v16 = (const __CFString *)(*(uint64_t (**)(void))(**((void **)this + 1) + 48))(*((void *)this + 1));
  CFDictionaryRef v25 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), @"localized names");
  v26 = CFDictionaryCreateMutableCopy(0, 0, v25);
  CFDictionarySetValue(v26, CurrentAppLocalization, v16);
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 5), @"localized names", v26);
  CFRelease(v26);
  CFStringRef v27 = (const __CFString *)(*(uint64_t (**)(void))(**((void **)this + 1) + 56))(*((void *)this + 1));
  CFDictionaryRef v28 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), @"localized detailed names");
  if (v28)
  {
    if (v27)
    {
      v29 = CFDictionaryCreateMutableCopy(0, 0, v28);
      CFDictionarySetValue(v29, CurrentAppLocalization, v27);
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 5), @"localized detailed names", v29);
      CFRelease(v29);
      if (v14 == v20) {
        CFStringRef v16 = v27;
      }
    }
  }
  DictionaryCacheInfo = (__CFDictionary *)*((void *)this + 5);
  if (*((unsigned char *)this + 32))
  {
    v31 = (CFDictionaryRef *)*((void *)this + 3);
    if (v31)
    {
      CFStringRef v32 = (const __CFString *)DCSDictionary::identifier(this);
      DCSDictionary::enrollSubDictionaryCache(v31, v32);
      uint64_t v33 = *((void *)this + 3);
      v34 = *(DCSBaseDictionary **)(v33 + 8);
      if (v34)
      {
        DictionaryCacheInfo = *(__CFDictionary **)(v33 + 40);
        if (!DictionaryCacheInfo)
        {
          DictionaryCacheInfo = _CreateDictionaryCacheInfo(v34);
          *(void *)(v33 + 40) = DictionaryCacheInfo;
          *(unsigned char *)(v33 + 33) = 1;
        }
      }
      else
      {
        DictionaryCacheInfo = 0;
      }
    }
  }
  uint64_t v35 = SyncSingleton<DCSEnvironment>::instance();
  DCSEnvironment::updateDictionaryCacheInfo(v35, *((const __CFURL **)this + 6), DictionaryCacheInfo);
  if (!v16) {
    goto LABEL_35;
  }
LABEL_34:
  if (CFStringGetLength(v16)) {
    return v16;
  }
LABEL_35:
  CFDictionaryRef v23 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), @"localized names");

  return (const __CFString *)CFDictionaryGetValue(v23, CurrentAppLocalization);
}

void DCSDictionary::enrollSubDictionaryCache(CFDictionaryRef *this, const __CFString *a2)
{
  CFIndex v3 = DCSDictionary::indexOfSubDictionaryIdentifier((DCSDictionary *)this, a2);
  if (v3 != -1)
  {
    CFIndex v4 = v3;
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(this[7], v3);
    if (ValueAtIndex) {
      uint64_t v6 = ValueAtIndex[2];
    }
    else {
      uint64_t v6 = 0;
    }
    CFStringRef v7 = *(DCSBaseDictionary **)(v6 + 8);
    if (v7)
    {
      DictionaryCacheInfo = *(__CFDictionary **)(v6 + 40);
      if (!DictionaryCacheInfo)
      {
        DictionaryCacheInfo = _CreateDictionaryCacheInfo(v7);
        *(void *)(v6 + 40) = DictionaryCacheInfo;
        *(unsigned char *)(v6 + 33) = 1;
      }
    }
    else
    {
      DictionaryCacheInfo = 0;
    }
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(this[5], @"sub dictionaries");
    CFMutableDictionaryRef MutableCopy = CFArrayCreateMutableCopy(0, 0, Value);
    CFArraySetValueAtIndex(MutableCopy, v4, DictionaryCacheInfo);
    CFIndex v11 = this[5];
    if (!*((unsigned char *)this + 33))
    {
      CFIndex v11 = CFDictionaryCreateMutableCopy(0, 0, this[5]);
      CFRelease(this[5]);
      this[5] = v11;
      *((unsigned char *)this + 33) = 1;
    }
    CFDictionarySetValue(v11, @"sub dictionaries", MutableCopy);
    CFRelease(MutableCopy);
  }
}

const __CFDictionary *DCSDictionary::version(DCSDictionary *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    return (const __CFDictionary *)(*(uint64_t (**)(void))(*(void *)v2 + 80))();
  }
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 5);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, @"version");
  }
  return result;
}

__CFString *DCSDictionary::primaryLanguage(DCSDictionary *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    return (__CFString *)(*(uint64_t (**)(void))(*(void *)v2 + 88))();
  }
  CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 5);
  if (v4) {
    return (__CFString *)CFDictionaryGetValue(v4, @"primary language");
  }
  CFDictionaryRef result = (__CFString *)*((void *)this + 12);
  if (result) {
    return DCSMAGetAssetLanguage((const __CFDictionary *)result);
  }
  return result;
}

uint64_t DCSDictionary::subDictionaries(DCSDictionary *this)
{
  if (*((unsigned char *)this + 64)) {
    return *((void *)this + 7);
  }
  uint64_t v2 = *((void *)this + 1);
  if (!v2)
  {
    CFDictionaryRef v7 = (const __CFDictionary *)*((void *)this + 5);
    if (v7)
    {
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v7, @"sub dictionaries");
      if (Value)
      {
        CFArrayRef v9 = Value;
        CFIndex Count = CFArrayGetCount(Value);
        CFIndex v6 = Count;
        if (*((void *)this + 7) || Count < 1)
        {
          if (Count < 1) {
            goto LABEL_34;
          }
        }
        else
        {
          *((void *)this + 7) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
        }
        CFIndex v18 = 0;
        do
        {
          CFArrayGetValueAtIndex(v9, v18);
          CFStringRef v19 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), @"identifier");
          CFIndex v20 = DCSDictionary::indexOfSubDictionaryIdentifier(this, v19);
          if (v20 == -1) {
            operator new();
          }
          CFIndex v21 = v20;
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v20);
          if (ValueAtIndex) {
            uint64_t v23 = ValueAtIndex[2];
          }
          else {
            uint64_t v23 = 0;
          }
          if (v18 != v21) {
            CFArrayExchangeValuesAtIndices(*((CFMutableArrayRef *)this + 7), v21, v18);
          }
          *(void *)(v23 + 72) = v18++;
        }
        while (v6 != v18);
        goto LABEL_34;
      }
    }
    goto LABEL_12;
  }
  CFArrayRef v3 = (const __CFArray *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 144))(v2);
  if (!v3)
  {
LABEL_12:
    CFIndex v6 = 0;
    goto LABEL_34;
  }
  CFArrayRef v4 = v3;
  CFIndex v5 = CFArrayGetCount(v3);
  CFIndex v6 = v5;
  if (!*((void *)this + 7) && v5 >= 1)
  {
    *((void *)this + 7) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    goto LABEL_14;
  }
  if (v5 >= 1)
  {
LABEL_14:
    CFIndex v11 = 0;
    do
    {
      CFStringRef v12 = CFArrayGetValueAtIndex(v4, v11);
      CFStringRef v13 = (const __CFString *)(*(uint64_t (**)(void *))(*v12 + 24))(v12);
      CFIndex v14 = DCSDictionary::indexOfSubDictionaryIdentifier(this, v13);
      if (v14 == -1) {
        operator new();
      }
      CFIndex v15 = v14;
      CFStringRef v16 = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v14);
      if (v16) {
        uint64_t v17 = v16[2];
      }
      else {
        uint64_t v17 = 0;
      }
      v12[1] = v17;
      *((unsigned char *)v12 + 16) = 1;
      if (v11 != v15) {
        CFArrayExchangeValuesAtIndices(*((CFMutableArrayRef *)this + 7), v15, v11);
      }
      *(void *)(v17 + 72) = v11++;
    }
    while (v6 != v11);
  }
LABEL_34:
  CFArrayRef v24 = (const __CFArray *)*((void *)this + 7);
  if (v24) {
    CFIndex v25 = CFArrayGetCount(v24);
  }
  else {
    CFIndex v25 = 0;
  }
  while (v25 > v6)
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 7), --v25);
  *((unsigned char *)this + 64) = 1;
  return *((void *)this + 7);
}

void sub_1D5903118(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1060C40D262D689);
  _Unwind_Resume(a1);
}

CFIndex DCSDictionary::indexOfSubDictionaryIdentifier(DCSDictionary *this, const __CFString *a2)
{
  CFArrayRef v3 = (const __CFArray *)*((void *)this + 7);
  if (!v3) {
    return -1;
  }
  CFIndex Count = CFArrayGetCount(v3);
  if (Count < 1) {
    return -1;
  }
  CFIndex v6 = Count;
  CFIndex v7 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (DCSDictionary *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v7);
    if (ValueAtIndex) {
      CFDictionaryRef ValueAtIndex = (DCSDictionary *)*((void *)ValueAtIndex + 2);
    }
    CFStringRef v9 = (const __CFString *)DCSDictionary::identifier(ValueAtIndex);
    if (CFEqual(v9, a2)) {
      break;
    }
    if (v6 == ++v7) {
      return -1;
    }
  }
  return v7;
}

uint64_t DCSDictionary::parentDictionary(DCSDictionary *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

uint64_t DCSDictionary::validDictionary(DCSDictionary *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    return (*(uint64_t (**)(void))(*(void *)v2 + 200))();
  }
  if (*((void *)this + 5)) {
    return 1;
  }
  return *((void *)this + 12) != 0;
}

void DCSDictionary::setCustomHTMLHeader(DCSDictionary *this, const __CFString *key, uint64_t a3, int a4, const __CFString *a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t valuePtr = a3;
  CFDictionaryRef Mutable = (const __CFDictionary *)*((void *)this + 10);
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *((void *)this + 10) = Mutable;
  }
  CFArrayRef Value = (void *)CFDictionaryGetValue(Mutable, key);
  if (!Value)
  {
    CFArrayRef Value = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 10), key, Value);
    CFRelease(Value);
  }
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  if (a5)
  {
    CFStringRef v12 = (void **)MEMORY[0x1E4F1CFD0];
    *(_OWORD *)keys = xmmword_1E6A59148;
    if (!a4) {
      CFStringRef v12 = (void **)MEMORY[0x1E4F1CFC8];
    }
    values[0] = *v12;
    values[1] = (void *)a5;
    CFDictionaryRef v13 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue((CFMutableDictionaryRef)Value, v11, v13);
  }
  else
  {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)Value, v11);
  }
  CFRelease(v11);
}

DCSDictionary *DCSDictionary::customHTMLHeader(DCSDictionary *this, const __CFString *a2, uint64_t a3, BOOL *a4)
{
  uint64_t valuePtr = a3;
  CFDictionaryRef v7 = (const __CFDictionary *)*((void *)this + 10);
  if (v7
    && (CFDictionaryRef v8 = (const __CFDictionary *)CFDictionaryGetValue(v7, a2)) != 0
    && (CFDictionaryRef v9 = v8,
        CFNumberRef v10 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr),
        CFDictionaryRef v11 = (const __CFDictionary *)CFDictionaryGetValue(v9, v10),
        CFRelease(v10),
        v11))
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v11, @"append");
    *a4 = CFBooleanGetValue(Value) != 0;
    return (DCSDictionary *)CFDictionaryGetValue(v11, @"header");
  }
  else if (*((unsigned char *)this + 32))
  {
    CFDictionaryRef result = (DCSDictionary *)*((void *)this + 3);
    if (result) {
      return (DCSDictionary *)DCSDictionary::customHTMLHeader(result, a2, valuePtr, a4);
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t DCSDictionary::baseURL(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    (*(void (**)(void))(**((void **)this + 1) + 352))(*((void *)this + 1));
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 32);
    return v3();
  }
  return result;
}

const __CFArray *DCSDictionary::languages(CFDictionaryRef *this)
{
  if (this[12])
  {
    BOOL v5 = 0;
    CFArrayRef v2 = DCSDictionary::checkAssetLanguageInfo(this, &v5);
    if (!v5) {
      return v2;
    }
  }
  else
  {
    CFArrayRef v2 = 0;
  }
  if (!DCSDictionary::createDictionaryObj((DCSDictionary *)this)) {
    return v2;
  }
  CFArrayRef v3 = *(uint64_t (**)(void))(*(void *)this[1] + 96);

  return (const __CFArray *)v3();
}

const __CFArray *DCSDictionary::checkAssetLanguageInfo(CFDictionaryRef *this, BOOL *a2)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(this[12], @"Languages");
  if (Value)
  {
    CFArrayRef Mutable = Value;
    *a2 = 0;
LABEL_11:
    if (CFArrayGetCount(Mutable) >= 1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, 0);
      CFStringRef v18 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"DCSDictionaryIndexLanguage");
      if (v18)
      {
        if (CFEqual(v18, @"*")) {
          *a2 = 1;
        }
      }
    }
    return Mutable;
  }
  CFIndex v21 = (pthread_mutex_t *)(this + 13);
  CFDictionaryRef v22 = a2;
  pthread_mutex_lock((pthread_mutex_t *)(this + 13));
  CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFIndex v6 = DCSMAGetAssetLanguage(this[12]);
  CFIndex v20 = (DCSDictionary *)this;
  CFDictionaryRef v7 = (const __CFDictionary *)DCSMAGetAssetAttributes(this[12]);
  CFArrayRef v8 = (const __CFArray *)CFDictionaryGetValue(v7, @"IndexLanguages");
  if (v8)
  {
    CFArrayRef v9 = v8;
    CFIndex Count = CFArrayGetCount(v8);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      CFIndex v12 = 0;
      CFDictionaryRef v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      do
      {
        CFIndex v14 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], v13);
        CFIndex v15 = (__CFString *)CFArrayGetValueAtIndex(v9, v12);
        CFDictionarySetValue(v14, @"DCSDictionaryIndexLanguage", v15);
        if (v6) {
          CFStringRef v16 = v6;
        }
        else {
          CFStringRef v16 = v15;
        }
        CFDictionarySetValue(v14, @"DCSDictionaryDescriptionLanguage", v16);
        CFArrayAppendValue(Mutable, v14);
        CFRelease(v14);
        ++v12;
      }
      while (v11 != v12);
    }
  }
  CFDictionarySetValue(*((CFMutableDictionaryRef *)v20 + 12), @"Languages", Mutable);
  CFRelease(Mutable);
  pthread_mutex_unlock(v21);
  a2 = v22;
  BOOL *v22 = 0;
  if (Mutable) {
    goto LABEL_11;
  }
  return Mutable;
}

uint64_t DCSDictionary::styleSheetURLs(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 104);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::styleSheetContents(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 112);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::privateFontURLs(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 120);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::XSLTData(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 128);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::elementXPaths(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 136);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::preferenceHTML(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 160);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::preference(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 168);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::defaultPreference(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 176);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::setPreference(DCSDictionary *this, const __CFDictionary *a2)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v4 = *(uint64_t (**)(void))(**((void **)this + 1) + 184);
    return v4();
  }
  return result;
}

uint64_t DCSDictionary::migrateOldPreference(DCSDictionary *this, const __CFDictionary *a2)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v4 = *(uint64_t (**)(void))(**((void **)this + 1) + 192);
    return v4();
  }
  return result;
}

uint64_t DCSDictionary::isLocalizableDictionary(CFDictionaryRef *this)
{
  if (this[12])
  {
    BOOL v4 = 0;
    DCSDictionary::checkAssetLanguageInfo(this, &v4);
    return v4;
  }
  else
  {
    uint64_t result = DCSDictionary::createDictionaryObj((DCSDictionary *)this);
    if (result)
    {
      CFArrayRef v3 = *(uint64_t (**)(void))(*(void *)this[1] + 216);
      return v3();
    }
  }
  return result;
}

uint64_t DCSDictionary::isSortableDictionary(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 224);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::isAppearanceAwareDictionary(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 232);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::isLanguageDictionary(DCSDictionary *this)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 12);
  if (v2) {
    return DCSMAIsLanguageDictionaryAsset(v2) != 0;
  }
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    BOOL v4 = *(uint64_t (**)(void))(**((void **)this + 1) + 240);
    return v4();
  }
  return result;
}

uint64_t DCSDictionary::previewMarkupVersion(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 248);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::primaryLocale(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 256);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::createSessionInfo(DCSDictionary *this, DCSSearchSession *a2, const __CFString *a3)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    BOOL v5 = *(uint64_t (**)(void))(**((void **)this + 1) + 264);
    return v5();
  }
  return result;
}

uint64_t DCSDictionary::releaseSessionInfo(DCSDictionary *this, void *a2)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    BOOL v4 = *(uint64_t (**)(void))(**((void **)this + 1) + 272);
    return v4();
  }
  return result;
}

uint64_t DCSDictionary::scheduleSession(DCSDictionary *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFIndex v6 = *(uint64_t (**)(void))(**((void **)this + 1) + 280);
    return v6();
  }
  return result;
}

uint64_t DCSDictionary::unscheduleSession(DCSDictionary *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFIndex v6 = *(uint64_t (**)(void))(**((void **)this + 1) + 288);
    return v6();
  }
  return result;
}

uint64_t DCSDictionary::searchByString(DCSDictionary *this, const __CFString *a2)
{
  if (DCSDictionary::createDictionaryObj(this))
  {
    (*(void (**)(void))(**((void **)this + 1) + 352))(*((void *)this + 1));
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 296);
    return v3();
  }
  else
  {
    if (DCSMAPrepareMobileAssetQuery()
      && !*((void *)this + 6)
      && *((void *)this + 12)
      && DCSMAPrepareMobileAssetQuery() == 1)
    {
      DCSDictionary::startGlobalDictionariesEnvironment(*((DCSDictionary **)this + 12));
    }
    return 0;
  }
}

uint64_t DCSDictionary::searchByReference(DCSDictionary *this, const __CFString *a2)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    (*(void (**)(void))(**((void **)this + 1) + 352))(*((void *)this + 1));
    BOOL v4 = *(uint64_t (**)(void))(**((void **)this + 1) + 304);
    return v4();
  }
  return result;
}

uint64_t DCSDictionary::copyData(DCSDictionary *this, DCSRecord *a2)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    BOOL v4 = *(uint64_t (**)(void))(**((void **)this + 1) + 312);
    return v4();
  }
  return result;
}

uint64_t DCSDictionary::copyDataURL(DCSDictionary *this, DCSRecord *a2)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    BOOL v4 = *(uint64_t (**)(void))(**((void **)this + 1) + 320);
    return v4();
  }
  return result;
}

uint64_t DCSDictionary::hasRecord(DCSDictionary *this, const __CFString *a2, uint64_t a3, unsigned __int8 *a4)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFIndex v6 = *(uint64_t (**)(void))(**((void **)this + 1) + 328);
    return v6();
  }
  return result;
}

uint64_t DCSDictionary::isSupportedDefinitionStyle(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 336);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::purgeInactiveData(DCSDictionary *this)
{
  uint64_t result = DCSDictionary::createDictionaryObj(this);
  if (result)
  {
    CFArrayRef v3 = *(uint64_t (**)(void))(**((void **)this + 1) + 344);
    return v3();
  }
  return result;
}

uint64_t DCSDictionary::dictionaryFlag(DCSDictionary *this)
{
  if (*((void *)this + 11) == -1)
  {
    *((void *)this + 11) = 0;
    CFDictionaryRef v2 = DCSDictionary::primaryLanguage(this);
    if (v2)
    {
      CFStringRef v3 = v2;
      if (!CFStringHasPrefix(v2, @"zh"))
      {
        if (CFStringHasPrefix(v3, @"ko"))
        {
          uint64_t v4 = 48;
          goto LABEL_7;
        }
        if (!CFStringHasPrefix(v3, @"hi")) {
          return *((void *)this + 11);
        }
      }
      uint64_t v4 = 14;
LABEL_7:
      *((void *)this + 11) = v4;
    }
  }
  return *((void *)this + 11);
}

uint64_t DCSDictionary::languageDirectionOfFoundRecord(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 360))();
}

uint64_t DCSDictionary::resetSubDictionaries(uint64_t this)
{
  if (!*(unsigned char *)(this + 65))
  {
    uint64_t v1 = this;
    *(unsigned char *)(this + 65) = 1;
    if (!*(void *)(this + 40) || (this = DCSDictionary::updateSubDictionaryInfo((DCSDictionary *)this), this))
    {
      uint64_t v2 = SyncSingleton<DCSEnvironment>::instance();
      CFURLRef v3 = *(const __CFURL **)(v1 + 48);
      uint64_t v4 = *(DCSBaseDictionary **)(v1 + 8);
      if (v4)
      {
        DictionaryCacheInfo = *(__CFDictionary **)(v1 + 40);
        if (!DictionaryCacheInfo)
        {
          DictionaryCacheInfo = _CreateDictionaryCacheInfo(v4);
          *(void *)(v1 + 40) = DictionaryCacheInfo;
          *(unsigned char *)(v1 + 33) = 1;
        }
      }
      else
      {
        DictionaryCacheInfo = 0;
      }
      DCSEnvironment::updateDictionaryCacheInfo(v2, v3, DictionaryCacheInfo);
      *(unsigned char *)(v1 + 64) = 0;
      this = DCSDictionary::subDictionaries((DCSDictionary *)v1);
    }
    *(unsigned char *)(v1 + 65) = 0;
  }
  return this;
}

uint64_t DCSDictionary::updateSubDictionaryInfo(DCSDictionary *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    CFArrayRef v3 = (const __CFArray *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 144))(v2);
    if (v3 && (v4 = v3, (CFIndex Count = CFArrayGetCount(v3)) != 0))
    {
      uint64_t v6 = Count;
      CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      if (v6 >= 1)
      {
        char v8 = 0;
        for (CFIndex i = 0; i != v6; ++i)
        {
          CFDictionaryRef ValueAtIndex = (DCSBaseDictionary *)CFArrayGetValueAtIndex(v4, i);
          v8 |= *((void *)ValueAtIndex + 1) == 0;
          DictionaryCacheInfo = _CreateDictionaryCacheInfo(ValueAtIndex);
          CFArrayAppendValue(Mutable, DictionaryCacheInfo);
          CFRelease(DictionaryCacheInfo);
        }
LABEL_10:
        CFArrayRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), @"sub dictionaries");
        if ((Mutable != 0) != (Value != 0))
        {
LABEL_11:
          if (!*((unsigned char *)this + 33))
          {
            CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *((CFDictionaryRef *)this + 5));
            CFRelease(*((CFTypeRef *)this + 5));
            *((void *)this + 5) = MutableCopy;
            *((unsigned char *)this + 33) = 1;
          }
          CFIndex v14 = (__CFDictionary *)*((void *)this + 5);
          if (!Mutable)
          {
            CFDictionaryRemoveValue(v14, @"sub dictionaries");
            char v17 = 1;
            goto LABEL_23;
          }
          CFDictionarySetValue(v14, @"sub dictionaries", Mutable);
          char v15 = 1;
          goto LABEL_21;
        }
        if (Mutable && Value)
        {
          if (!CFEqual(Value, Mutable)) {
            goto LABEL_11;
          }
          char v15 = 0;
        }
        else
        {
          char v15 = 0;
          char v17 = 0;
          if (!Mutable)
          {
LABEL_23:
            char v16 = v17 | v8;
            return v16 & 1;
          }
        }
LABEL_21:
        CFRelease(Mutable);
        char v17 = v15;
        goto LABEL_23;
      }
    }
    else
    {
      CFArrayRef Mutable = 0;
    }
    char v8 = 0;
    goto LABEL_10;
  }
  char v16 = 0;
  return v16 & 1;
}

__CFDictionary *_CreateDictionaryCacheInfo(DCSBaseDictionary *a1)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFArrayRef v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  BOOL v5 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  CFStringRef CurrentAppLocalization = DCSEnvironment::getCurrentAppLocalization(v5);
  keys[0] = (void *)CurrentAppLocalization;
  values = (void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 48))(a1);
  CFDictionaryRef v7 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, v2, v3);
  CFDictionaryAddValue(Mutable, @"localized names", v7);
  CFRelease(v7);
  values = (void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 56))(a1);
  if (values)
  {
    CFDictionaryRef v8 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionaryAddValue(Mutable, @"localized detailed names", v8);
    CFRelease(v8);
  }
  CFStringRef v9 = (const __CFString *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 88))(a1);
  if (v9) {
    CFDictionaryAddValue(Mutable, @"primary language", v9);
  }
  uint64_t v10 = (*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 64))(a1);
  CFIndex v11 = (const void *)v10;
  if (v9) {
    BOOL v12 = v10 == 0;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12)
  {
    if (!CompareLanguageCode(v9, CurrentAppLocalization, 0)) {
      goto LABEL_14;
    }
    CFIndex v11 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 72))(a1);
  }
  if (v11) {
    CFDictionaryAddValue(Mutable, @"native name", v11);
  }
LABEL_14:
  int v13 = (*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 208))(a1);
  CFIndex v14 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!v13) {
    CFIndex v14 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionaryAddValue(Mutable, @"network", *v14);
  char v15 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 24))(a1);
  CFDictionaryAddValue(Mutable, @"identifier", v15);
  char v16 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 40))(a1);
  CFDictionaryAddValue(Mutable, @"name", v16);
  char v17 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 80))(a1);
  CFDictionaryAddValue(Mutable, @"version", v17);
  CFArrayRef v18 = (const __CFArray *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)a1 + 144))(a1);
  if (v18)
  {
    CFArrayRef v19 = v18;
    CFIndex Count = CFArrayGetCount(v18);
    if (Count)
    {
      uint64_t v21 = Count;
      CFDictionaryRef v22 = CFArrayCreateMutable(0, Count, MEMORY[0x1E4F1D510]);
      if (v21 >= 1)
      {
        for (CFIndex i = 0; i != v21; ++i)
        {
          CFDictionaryRef ValueAtIndex = (DCSBaseDictionary *)CFArrayGetValueAtIndex(v19, i);
          DictionaryCacheInfo = (const void *)_CreateDictionaryCacheInfo(ValueAtIndex);
          CFArrayAppendValue(v22, DictionaryCacheInfo);
          CFRelease(DictionaryCacheInfo);
        }
      }
      if (v22)
      {
        CFDictionarySetValue(Mutable, @"sub dictionaries", v22);
        CFRelease(v22);
      }
    }
  }
  return Mutable;
}

const void *DCSDictionaryManager::dictionary(DCSDictionaryManager *this, const __CFURL *a2, __CFDictionary *a3)
{
  if ((_initedCachedDictionaries & 1) == 0) {
    pthread_once(&DCSDictionaryManager::dictionary(__CFURL const*,__CFDictionary *,BOOL)::once_control, (void (*)(void))_InitializeCachedDictionaries);
  }
  if (a3)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)DCSMAGetAssetAttributes(a3);
    CFArrayRef Value = CFDictionaryGetValue(v5, @"DictionaryIdentifier");
    if (!Value) {
      CFArrayRef Value = CFDictionaryGetValue(v5, @"DictionaryPackageName");
    }
    CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"asset:/%@", Value);
  }
  else
  {
    if (!a2) {
      return 0;
    }
    CFStringRef v7 = CopyFileObjectIdentifierAtURL(a2);
  }
  CFStringRef v8 = v7;
  if (!v7) {
    return 0;
  }
  pthread_rwlock_rdlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  CFStringRef v9 = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedDictionaries + 8), v8);
  pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  if (v9)
  {
    CFRetain(v9);
  }
  else
  {
    uint64_t v10 = (pthread_rwlock_t *)(_cachedDictionaries + 16);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
    CFStringRef v9 = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedDictionaries + 8), v8);
    if (!v9) {
      operator new();
    }
    pthread_rwlock_unlock(v10);
  }
  CFRelease(v8);
  return v9;
}

void sub_1D5904EBC(_Unwind_Exception *a1)
{
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

void _InitializeCachedDictionaries(void)
{
}

{
  operator new();
}

void sub_1D5904FB4(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
}

void DCSDictionaryManager::remove(DCSDictionaryManager *this, const __DCSDictionary *a2)
{
  if (!a2) {
    return;
  }
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  uint64_t v3 = *((void *)a2 + 2);
  CFURLRef v4 = *(const __CFURL **)(v3 + 48);
  if (v4)
  {
    CFDictionaryRef v5 = (void *)CopyFileObjectIdentifierAtURL(v4);
LABEL_4:
    CFTypeRef v6 = v5;
    goto LABEL_5;
  }
  CFDictionaryRef v8 = *(const __CFDictionary **)(v3 + 96);
  if (!v8)
  {
    CFTypeRef v6 = 0;
    goto LABEL_5;
  }
  CFDictionaryRef v9 = (const __CFDictionary *)DCSMAGetAssetAttributes(v8);
  CFArrayRef Value = CFDictionaryGetValue(v9, @"DictionaryIdentifier");
  CFTypeRef v6 = CFRetain(Value);
  if (!v6)
  {
    CFIndex v11 = CFDictionaryGetValue(v9, @"DictionaryPackageName");
    CFDictionaryRef v5 = (void *)CFRetain(v11);
    goto LABEL_4;
  }
LABEL_5:
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(_cachedDictionaries + 8), v6)) {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(_cachedDictionaries + 8), v6);
  }
  CFRelease(v6);
  CFStringRef v7 = (pthread_rwlock_t *)(_cachedDictionaries + 16);

  pthread_rwlock_unlock(v7);
}

uint64_t DCSDictionaryManager::updateOrders(DCSDictionaryManager *this)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(_cachedDictionaries + 8));
  v18[0] = v18;
  MEMORY[0x1F4188790](Count);
  uint64_t v3 = (const void **)((char *)v18 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v2 >= 0x200) {
    size_t v4 = 512;
  }
  else {
    size_t v4 = v2;
  }
  bzero((char *)v18 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0), v4);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(_cachedDictionaries + 8), 0, v3);
  CFDictionaryRef v5 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  CFArrayRef ActiveDictionaryInfos = (const __CFArray *)DCSEnvironment::getActiveDictionaryInfos(v5);
  CFArrayRef v7 = ActiveDictionaryInfos;
  if (ActiveDictionaryInfos) {
    CFIndex v8 = CFArrayGetCount(ActiveDictionaryInfos);
  }
  else {
    CFIndex v8 = 0;
  }
  if (Count >= 1)
  {
    for (uint64_t i = 0; i != Count; ++i)
    {
      uint64_t v10 = v3[i];
      if (v10) {
        uint64_t v11 = v10[2];
      }
      else {
        uint64_t v11 = 0;
      }
      BOOL v12 = *(const void **)(v11 + 48);
      if (v12) {
        BOOL v13 = v8 < 1;
      }
      else {
        BOOL v13 = 1;
      }
      if (!v13)
      {
        CFIndex v14 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v14);
          CFArrayRef Value = CFDictionaryGetValue(ValueAtIndex, @"URL");
          if (Value)
          {
            if (CFEqual(Value, v12)) {
              break;
            }
          }
          if (v8 == ++v14) {
            goto LABEL_22;
          }
        }
        *(void *)(v11 + 72) = v14;
      }
LABEL_22:
      ;
    }
  }
  return pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
}

uint64_t DCSDictionaryManager::updatePreferences(DCSDictionaryManager *this)
{
  v11[1] = *MEMORY[0x1E4F143B8];
  pthread_rwlock_rdlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(_cachedDictionaries + 8));
  MEMORY[0x1F4188790](Count);
  uint64_t v3 = (const void **)((char *)v11 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v2 >= 0x200) {
    size_t v4 = 512;
  }
  else {
    size_t v4 = v2;
  }
  bzero((char *)v11 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0), v4);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(_cachedDictionaries + 8), 0, v3);
  if (Count >= 1)
  {
    do
    {
      if (*v3)
      {
        uint64_t v5 = *((void *)*v3 + 2);
        if (v5)
        {
          if (*(unsigned char *)(v5 + 16))
          {
            CFTypeRef v6 = *(void **)(v5 + 24);
            if (!v6 || !*v6)
            {
              CFArrayRef v7 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
              CFStringRef v8 = (const __CFString *)DCSDictionary::identifier((DCSDictionary *)v5);
              CFDictionaryRef DictionaryPreference = (const __CFDictionary *)DCSEnvironment::getDictionaryPreference(v7, v8);
              if (DictionaryPreference) {
                DCSDictionary::setPreference((DCSDictionary *)v5, DictionaryPreference);
              }
            }
          }
        }
      }
      ++v3;
      --Count;
    }
    while (Count);
  }
  return pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
}

void SyncMutableCFSpecificType<__CFDictionary *>::~SyncMutableCFSpecificType(SyncMutableCFRef *a1)
{
  SyncMutableCFRef::~SyncMutableCFRef(a1);

  JUMPOUT(0x1D94553C0);
}

void sub_1D590540C(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

uint64_t SyncMutableCFRef::get(SyncMutableCFRef *this)
{
  return *((void *)this + 1);
}

void SyncMutableCFRef::~SyncMutableCFRef(SyncMutableCFRef *this)
{
  SyncMutableCFRef::~SyncMutableCFRef(this);

  JUMPOUT(0x1D94553C0);
}

{
  const void *v2;

  *(void *)this = &unk_1F2DE2C80;
  pthread_rwlock_destroy((pthread_rwlock_t *)((char *)this + 16));
  unint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
}

void sub_1D5905484(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

uint64_t _DCSDictionaryInitialize(void)
{
  uint64_t result = _CFRuntimeRegisterClass();
  _DCSDictionaryID = result;
  return result;
}

void _DCSDictionaryFinalize(const __DCSDictionary *a1)
{
  unint64_t v2 = (DCSDictionary *)*((void *)a1 + 2);
  uint64_t v3 = (void *)*((void *)v2 + 3);
  if (!v3 || !*v3)
  {
    size_t v4 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
    DCSDictionaryManager::remove(v4, a1);
  }
  DCSDictionary::~DCSDictionary(v2);

  JUMPOUT(0x1D94553C0);
}

void sub_1D590558C(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1060C40D262D689);
  _Unwind_Resume(a1);
}

uint64_t _DCSDictionaryEqual(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a2[2];
  size_t v4 = *(const void **)(v2 + 48);
  if (v4)
  {
    uint64_t v5 = *(const void **)(v3 + 48);
    if (v5) {
      return CFEqual(v4, v5);
    }
  }
  uint64_t v7 = *(void *)(v2 + 96);
  return v7 && (uint64_t v8 = *(void *)(v3 + 96)) != 0 && v7 == v8;
}

CFStringRef _DCSDictionaryCopyFormattingDesc(void *a1, const __CFDictionary *a2)
{
  uint64_t v3 = (DCSDictionary *)a1[2];
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFDictionaryRef v5 = DCSDictionary::name(v3);
  return CFStringCreateWithFormat(v4, a2, @"<%@>", v5);
}

CFStringRef _DCSDictionaryCopyDebugDesc(void *a1)
{
  uint64_t v1 = (DCSDictionary *)a1[2];
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFURLRef v3 = (const __CFURL *)*((void *)v1 + 6);
  if (v3) {
    CFAllocatorRef v4 = (void *)CFURLGetString(v3);
  }
  else {
    CFAllocatorRef v4 = DCSDictionary::name(v1);
  }
  return CFStringCreateWithFormat(v2, 0, @"<DCSDictionaryRef %p>{URL = %@}", v1, v4);
}

uint64_t SyncSingleton<DCSDictionaryManager>::instance()
{
  if (!SyncSingleton<DCSDictionaryManager>::_instantiated)
  {
    pthread_mutex_lock(&SyncSingleton<DCSDictionaryManager>::_mutex);
    if (!SyncSingleton<DCSDictionaryManager>::_instantiated) {
      operator new();
    }
    pthread_mutex_unlock(&SyncSingleton<DCSDictionaryManager>::_mutex);
  }
  return SyncSingleton<DCSDictionaryManager>::_instance;
}

void DCSUsageTrackingCoreAnalyticsLogging::DCSUsageTrackingCoreAnalyticsLogging(DCSUsageTrackingCoreAnalyticsLogging *this)
{
  *(void *)this = &unk_1F2DE2D08;
  *((void *)this + 1) = 0;
  *((void *)this + 1) = xpc_dictionary_create(0, 0, 0);
}

void DCSUsageTrackingCoreAnalyticsLogging::~DCSUsageTrackingCoreAnalyticsLogging(DCSUsageTrackingCoreAnalyticsLogging *this)
{
  *(void *)this = &unk_1F2DE2D08;
  uint64_t v1 = (void *)*((void *)this + 1);
  if (v1) {
    xpc_release(v1);
  }
}

{
  void *v1;

  *(void *)this = &unk_1F2DE2D08;
  uint64_t v1 = (void *)*((void *)this + 1);
  if (v1) {
    xpc_release(v1);
  }
}

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F2DE2D08;
  uint64_t v1 = (void *)*((void *)this + 1);
  if (v1) {
    xpc_release(v1);
  }

  JUMPOUT(0x1D94553C0);
}

void sub_1D5905884(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x81C40803F642BLL);
  _Unwind_Resume(a1);
}

void DCSUsageTrackingCoreAnalyticsLogging::logApplicationName(xpc_object_t *this, const char *string)
{
}

void DCSUsageTrackingCoreAnalyticsLogging::logDictionaryIdentifier(xpc_object_t *this, const char *string)
{
}

void DCSUsageTrackingCoreAnalyticsLogging::logPrimaryLanguage(xpc_object_t *this, const char *string)
{
}

void DCSUsageTrackingCoreAnalyticsLogging::doLogging(DCSUsageTrackingCoreAnalyticsLogging *this)
{
  uint64_t v1 = kDCSUsageTrackingDoman;
  CFAllocatorRef v2 = (void *)*((void *)this + 1);
  if (_CallAnalyticsSendEventLazy(char const*,void *)::_OnceToken != -1) {
    dispatch_once(&_CallAnalyticsSendEventLazy(char const*,void *)::_OnceToken, &__block_literal_global);
  }
  if (_CallAnalyticsSendEventLazy(char const*,void *)::_AnalyticsSendEventLazyProc)
  {
    xpc_retain(v2);
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 0x40000000;
    v3[2] = ___ZL27_CallAnalyticsSendEventLazyPKcPv_block_invoke_2;
    v3[3] = &__block_descriptor_tmp_22;
    v3[4] = v2;
    _CallAnalyticsSendEventLazy(char const*,void *)::_AnalyticsSendEventLazyProc(v1, v3);
  }
}

void DCSUsageTrackingASLLogging::DCSUsageTrackingASLLogging(DCSUsageTrackingASLLogging *this)
{
  *(void *)this = &unk_1F2DE2D50;
  *((void *)this + 1) = 0;
  CFAllocatorRef v2 = asl_new(0);
  *((void *)this + 1) = v2;
  asl_set(v2, "com.apple.message.domain", (const char *)kDCSUsageTrackingDoman);
}

void DCSUsageTrackingASLLogging::~DCSUsageTrackingASLLogging(DCSUsageTrackingASLLogging *this)
{
  *(void *)this = &unk_1F2DE2D50;
  if (*((void *)this + 1)) {
    MEMORY[0x1D94554D0]();
  }
}

{
  *(void *)this = &unk_1F2DE2D50;
  if (*((void *)this + 1)) {
    MEMORY[0x1D94554D0]();
  }
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F2DE2D50;
  if (*((void *)this + 1)) {
    MEMORY[0x1D94554D0]();
  }

  JUMPOUT(0x1D94553C0);
}

void sub_1D5905B18(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t DCSUsageTrackingASLLogging::setSummarize(DCSUsageTrackingASLLogging *this, int a2)
{
  CFAllocatorRef v2 = (__asl_object_s *)*((void *)this + 1);
  if (a2) {
    CFURLRef v3 = "YES";
  }
  else {
    CFURLRef v3 = "NO";
  }
  return asl_set(v2, "com.apple.message.summarize", v3);
}

uint64_t DCSUsageTrackingASLLogging::logApplicationName(asl_object_t *this, const char *value)
{
  return asl_set(this[1], "com.apple.message.signature", value);
}

uint64_t DCSUsageTrackingASLLogging::logDictionaryIdentifier(asl_object_t *this, const char *value)
{
  return asl_set(this[1], "com.apple.message.signature2", value);
}

uint64_t DCSUsageTrackingASLLogging::logPrimaryLanguage(asl_object_t *this, const char *value)
{
  return asl_set(this[1], "com.apple.message.signature3", value);
}

uint64_t DCSUsageTrackingASLLogging::doLogging(asl_object_t *this)
{
  return asl_log(0, this[1], 5, "");
}

void DCSUsageTrackingAggregateLogging::DCSUsageTrackingAggregateLogging(DCSUsageTrackingAggregateLogging *this)
{
  *(void *)this = &unk_1F2DE2D98;
}

void DCSUsageTrackingAggregateLogging::~DCSUsageTrackingAggregateLogging(DCSUsageTrackingAggregateLogging *this)
{
}

void DCSUsageTrackingAggregateLogging::logApplicationName(DCSUsageTrackingAggregateLogging *this, const char *a2)
{
  CFStringRef v2 = CFStringCreateWithFormat(0, 0, @"%s.%s.%s", kDCSUsageTrackingDoman, "applicationName", a2);
  if (v2)
  {
    CFStringRef v3 = v2;
    ADClientAddValueForScalarKey();
    CFRelease(v3);
  }
}

uint64_t DCSUsageTrackingAggregateLogging::logKey(DCSUsageTrackingAggregateLogging *this, const __CFString *a2)
{
  return ADClientAddValueForScalarKey();
}

void DCSUsageTrackingAggregateLogging::logDictionaryIdentifier(DCSUsageTrackingAggregateLogging *this, const char *a2)
{
  CFStringRef v2 = CFStringCreateWithFormat(0, 0, @"%s.%s.%s", kDCSUsageTrackingDoman, "dictionaryIdentifier", a2);
  if (v2)
  {
    CFStringRef v3 = v2;
    ADClientAddValueForScalarKey();
    CFRelease(v3);
  }
}

void DCSUsageTrackingAggregateLogging::logPrimaryLanguage(DCSUsageTrackingAggregateLogging *this, const char *a2)
{
  CFStringRef v2 = CFStringCreateWithFormat(0, 0, @"%s.%s.%s", kDCSUsageTrackingDoman, "primaryLanguage", a2);
  if (v2)
  {
    CFStringRef v3 = v2;
    ADClientAddValueForScalarKey();
    CFRelease(v3);
  }
}

void *___ZL27_CallAnalyticsSendEventLazyPKcPv_block_invoke()
{
  uint64_t result = dlopen("/System/Library/PrivateFrameworks/CoreAnalytics.framework/CoreAnalytics", 1);
  if (result)
  {
    uint64_t result = dlsym(result, "analytics_send_event_lazy");
    _CallAnalyticsSendEventLazy(char const*,void *)::_AnalyticsSendEventLazyProc = (uint64_t (*)(void, void))result;
  }
  return result;
}

uint64_t ___ZL27_CallAnalyticsSendEventLazyPKcPv_block_invoke_2(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void DCSEnvironment::DCSEnvironment(DCSEnvironment *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((unsigned char *)this + 104) = 0;
  *(void *)((char *)this + 108) = -1;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((unsigned char *)this + 136) = 0;
  *((void *)this + 18) = -1;
  *((_WORD *)this + 76) = 0;
  *((unsigned char *)this + 154) = 0;
  *((void *)this + 20) = 0;
  *((unsigned char *)this + 168) = 0;
  *((void *)this + 22) = 0;
  *((_WORD *)this + 92) = 0;
  CFStringRef v2 = (CFStringRef *)((char *)this + 584);
  *((void *)this + 75) = 0;
  *(_OWORD *)((char *)this + 584) = 0u;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 200), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 264), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 328), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 392), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 456), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 520), 0);
  CFArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((void *)this + 24) = Mutable;
  DCSDictionary::startGlobalDictionariesEnvironment(Mutable);
  DCSMAPrepareMobileAssetQuery();
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
    *((unsigned char *)this + 185) = InfoDictionary == 0;
    if (InfoDictionary)
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"CFBundleIdentifier");
      if (Value)
      {
        CFStringRef v7 = Value;
        *((unsigned char *)this + 185) = CFEqual(Value, @"com.apple.lookupd");
        if (CFStringHasPrefix(v7, @"com.apple.")) {
          CFStringRef v8 = v7;
        }
        else {
          CFStringRef v8 = @"com.apple.lookupd";
        }
      }
      else
      {
        *((unsigned char *)this + 185) = 1;
        CFStringRef v8 = @"Unknown";
      }
      *CFStringRef v2 = CFStringCreateCopy(0, v8);
    }
  }
  else
  {
    *((unsigned char *)this + 185) = 1;
  }
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(DarwinNotifyCenter, this, (CFNotificationCallback)ActiveDictionaryChangedCallback, @"DCSActiveDictionariesChangedDistributedNotification", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, this, (CFNotificationCallback)_PurgeInactiveDataCallback, @"UIApplicationDidEnterBackgroundNotification", 0, CFNotificationSuspensionBehaviorDrop);
}

void ___ZN14DCSEnvironmentC2Ev_block_invoke(uint64_t a1, int a2)
{
  if (a2) {
    DCSEnvironment::resetActiveDictionaries(*(DCSEnvironment **)(a1 + 32), 0);
  }
}

void DCSEnvironment::resetActiveDictionaries(DCSEnvironment *this, int a2)
{
  if (*((void *)this + 6))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 200));
    CFAllocatorRef v4 = (const void *)*((void *)this + 6);
    if (v4)
    {
      CFRelease(v4);
      *((void *)this + 6) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 200));
  }
  if (*((void *)this + 7))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
    CFDictionaryRef v5 = (const void *)*((void *)this + 7);
    if (v5)
    {
      CFRelease(v5);
      *((void *)this + 7) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
  }
  if (a2)
  {
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterPostNotification(LocalCenter, @"DCSActiveDictionariesChangedNotification", 0, 0, 0);
  }
}

void ActiveDictionaryChangedCallback(__CFNotificationCenter *a1, DCSEnvironment *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
  DCSLog(16, @"kDCSActiveDictionariesChangedDistributedNotification caught", a3, a4, a5);

  DCSEnvironment::resetActiveDictionaries(a2, 1);
}

void _PurgeInactiveDataCallback(__CFNotificationCenter *a1, void *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
  CFDictionaryRef v5 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  CFTypeRef v6 = DCSEnvironment::copyActiveDictionaries(v5, 0);
  if (v6)
  {
    CFArrayRef v7 = v6;
    CFIndex Count = CFArrayGetCount(v6);
    if (Count >= 1)
    {
      CFIndex v9 = Count;
      for (CFIndex i = 0; i != v9; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v7, i);
        if (ValueAtIndex)
        {
          BOOL v12 = (DCSDictionary *)*((void *)ValueAtIndex + 2);
          if (v12) {
            DCSDictionary::purgeInactiveData(v12);
          }
        }
      }
    }
    CFRelease(v7);
  }
}

void DCSEnvironment::~DCSEnvironment(DCSEnvironment *this)
{
  CFStringRef v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  CFStringRef v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
  CFAllocatorRef v4 = (const void *)*((void *)this + 6);
  if (v4) {
    CFRelease(v4);
  }
  CFDictionaryRef v5 = (const void *)*((void *)this + 7);
  if (v5) {
    CFRelease(v5);
  }
  CFTypeRef v6 = (const void *)*((void *)this + 8);
  if (v6) {
    CFRelease(v6);
  }
  CFArrayRef v7 = (const void *)*((void *)this + 11);
  if (v7) {
    CFRelease(v7);
  }
  CFStringRef v8 = (const void *)*((void *)this + 15);
  if (v8) {
    CFRelease(v8);
  }
  CFIndex v9 = (const void *)*((void *)this + 16);
  if (v9) {
    CFRelease(v9);
  }
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
  uint64_t v10 = (const void *)*((void *)this + 2);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = (const void *)*((void *)this + 3);
  if (v11) {
    CFRelease(v11);
  }
  BOOL v12 = (const void *)*((void *)this + 24);
  if (v12) {
    CFRelease(v12);
  }
  BOOL v13 = (const void *)*((void *)this + 73);
  if (v13) {
    CFRelease(v13);
  }
  CFIndex v14 = (const void *)*((void *)this + 74);
  if (v14) {
    CFRelease(v14);
  }
  char v15 = (const void *)*((void *)this + 75);
  if (v15) {
    CFRelease(v15);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 200));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 264));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 328));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 392));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 520));
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(DarwinNotifyCenter, this, @"DCSActiveDictionariesChangedDistributedNotification", 0);
  DistributedCenter = CFNotificationCenterGetDistributedCenter();
  CFNotificationCenterRemoveObserver(DistributedCenter, this, @"UIApplicationDidEnterBackgroundNotification", 0);
}

uint64_t DCSEnvironment::getFrameworkBundle(DCSEnvironment *this)
{
  uint64_t result = *(void *)this;
  if (!result)
  {
    CFStringRef v3 = CFStringCreateWithCString(0, "/System/Library/PrivateFrameworks/DictionaryServices.framework", 0x8000100u);
    CFURLRef v4 = CFURLCreateWithFileSystemPath(0, v3, kCFURLPOSIXPathStyle, 1u);
    *(void *)this = CFBundleCreate(0, v4);
    CFRelease(v4);
    CFRelease(v3);
    return *(void *)this;
  }
  return result;
}

CFStringRef DCSEnvironment::getCurrentAppLocalization(DCSEnvironment *this)
{
  CFStringRef result = (CFStringRef)*((void *)this + 1);
  if (!result)
  {
    MainBundle = CFBundleGetMainBundle();
    CFArrayRef v4 = CFBundleCopyBundleLocalizations(MainBundle);
    if (v4)
    {
      CFArrayRef v5 = v4;
      CFArrayRef v6 = CFBundleCopyPreferredLocalizationsFromArray(v4);
      if (v6)
      {
        CFArrayRef v7 = v6;
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, 0);
        *((void *)this + 1) = CFStringCreateCopy(0, ValueAtIndex);
        CFRelease(v7);
      }
      else
      {
        *((void *)this + 1) = CFStringCreateCopy(0, @"English");
      }
      CFRelease(v5);
      return (CFStringRef)*((void *)this + 1);
    }
    else
    {
      CFStringRef result = CFStringCreateCopy(0, @"English");
      *((void *)this + 1) = result;
    }
  }
  return result;
}

CFStringRef DCSEnvironment::getCurrentSystemLanguage(DCSEnvironment *this)
{
  CFStringRef result = (CFStringRef)*((void *)this + 2);
  if (!result)
  {
    CFArrayRef v3 = CFLocaleCopyPreferredLanguages();
    if (!v3) {
      goto LABEL_8;
    }
    CFArrayRef v4 = v3;
    if (CFArrayGetCount(v3) >= 1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, 0);
      if (CFEqual(ValueAtIndex, @"en"))
      {
        CFStringRef FallbackEnglishLanguage = (const __CFString *)DCSEnvironment::getFallbackEnglishLanguage(0);
        CFAllocatorRef Copy = (const __CFAllocator *)CFStringCreateCopy(0, FallbackEnglishLanguage);
        *((void *)this + 2) = Copy;
        if (Copy) {
          goto LABEL_7;
        }
        goto LABEL_6;
      }
      CFAllocatorRef Copy = (const __CFAllocator *)*((void *)this + 2);
      if (!Copy) {
LABEL_6:
      }
        *((void *)this + 2) = CFStringCreateCopy(Copy, ValueAtIndex);
    }
LABEL_7:
    CFRelease(v4);
LABEL_8:
    CFStringRef result = (CFStringRef)*((void *)this + 2);
    if (!result)
    {
      CFStringRef result = CFStringCreateCopy(0, @"en_US");
      *((void *)this + 2) = result;
    }
  }
  return result;
}

CFTypeRef DCSEnvironment::getFallbackEnglishLanguage(DCSEnvironment *this)
{
  CFTypeRef result = (CFTypeRef)DCSEnvironment::getFallbackEnglishLanguage(void)::_FallbackEnglishLanguage;
  if (!DCSEnvironment::getFallbackEnglishLanguage(void)::_FallbackEnglishLanguage)
  {
    CFLocaleRef v2 = CFLocaleCopyCurrent();
    if (v2)
    {
      CFLocaleRef v3 = v2;
      CFStringRef v4 = (const __CFString *)MEMORY[0x1D9454B30]();
      DCSEnvironment::getFallbackEnglishLanguage(void)::_CFStringRef FallbackEnglishLanguage = (uint64_t)CopyPreferredEnglishLanguage(v4);
      CFRelease(v3);
      return (CFTypeRef)DCSEnvironment::getFallbackEnglishLanguage(void)::_FallbackEnglishLanguage;
    }
    else
    {
      CFTypeRef result = CopyPreferredEnglishLanguage(0);
      DCSEnvironment::getFallbackEnglishLanguage(void)::_CFStringRef FallbackEnglishLanguage = (uint64_t)result;
    }
  }
  return result;
}

uint64_t DCSEnvironment::getCurrentPreferredLanguages(DCSEnvironment *this, uint64_t *a2)
{
  if (!*((void *)this + 3))
  {
    *((void *)this + 3) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    *((void *)this + 4) = -1;
    CFArrayRef v4 = CFLocaleCopyPreferredLanguages();
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      for (CFIndex i = 0; i != v6; ++i)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, i);
        if (CFEqual(ValueAtIndex, @"en"))
        {
          CFStringRef ValueAtIndex = (const __CFString *)DCSEnvironment::getFallbackEnglishLanguage(0);
          *((void *)this + 4) = i;
        }
        CFArrayAppendValue(*((CFMutableArrayRef *)this + 3), ValueAtIndex);
      }
    }
    CFRelease(v4);
    if (!CFArrayGetCount(*((CFArrayRef *)this + 3))) {
      CFArrayAppendValue(*((CFMutableArrayRef *)this + 3), @"en_US");
    }
  }
  if (a2) {
    *a2 = *((void *)this + 4);
  }
  return *((void *)this + 3);
}

CFStringRef DCSEnvironment::getUserAgentName(DCSEnvironment *this)
{
  CFStringRef result = (CFStringRef)*((void *)this + 5);
  if (!result)
  {
    FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);
    CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(FrameworkBundle);
    CFStringRef Value = (__CFString *)CFDictionaryGetValue(InfoDictionary, @"CFBundleVersion");
    CFIndex v6 = @"0";
    if (Value) {
      CFIndex v6 = Value;
    }
    CFStringRef result = CFStringCreateWithFormat(0, 0, @"AppleDictionaryService/%@", v6);
    *((void *)this + 5) = result;
  }
  return result;
}

uint64_t DCSEnvironment::getActiveDictionaryInfos(DCSEnvironment *this)
{
  uint64_t result = *((void *)this + 6);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 200));
    if (!*((void *)this + 6))
    {
      CFArrayRef ActiveDictionaryInfoList = DCSEnvironment::loadActiveDictionaryInfoList((CFMutableDictionaryRef *)this);
      *((void *)this + 6) = ActiveDictionaryInfoList;
      if (!ActiveDictionaryInfoList) {
        *((void *)this + 6) = CFArrayCreateMutable(0, 0, 0);
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 200));
    return *((void *)this + 6);
  }
  return result;
}

const __CFArray *DCSEnvironment::loadActiveDictionaryInfoList(CFMutableDictionaryRef *this)
{
  CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFDictionaryRemoveAllValues(this[24]);
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    CFIndex v4 = Count;
    for (CFIndex i = 0; i != v4; ++i)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, i);
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, @"asset");
      if (Value)
      {
        CFStringRef v8 = DCSMAGetAssetLanguage(Value);
        DCSEnvironment::storeActiveDictionaryLanguage(this, v8);
      }
      else
      {
        CFIndex v9 = (DCSEnvironment *)CFDictionaryGetValue(ValueAtIndex, @"URL");
        if (v9)
        {
          CFStringRef v10 = (const __CFString *)DCSEnvironment::copyPrimaryLanguageOfDictionaryURL(v9, v9);
          DCSEnvironment::storeActiveDictionaryLanguage(this, v10);
          if (v10) {
            CFRelease(v10);
          }
        }
      }
    }
  }
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t DCSEnvironment::checkLanguageMatch(DCSEnvironment *this, CFStringRef theString1, const __CFString *a3)
{
  if (!a3 || CFEqual(theString1, @"*")) {
    return 1;
  }
  CFStringRef CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString(0, theString1);
  CFStringRef v6 = CFLocaleCreateCanonicalLanguageIdentifierFromString(0, a3);
  uint64_t v7 = 1;
  if (CFStringCompare(CanonicalLanguageIdentifierFromString, v6, 1uLL))
  {
    if (CFStringFind(v6, @"-", 0).location == -1) {
      uint64_t v7 = CompareLanguageCode(CanonicalLanguageIdentifierFromString, v6, 0);
    }
    else {
      uint64_t v7 = 0;
    }
  }
  CFRelease(CanonicalLanguageIdentifierFromString);
  CFRelease(v6);
  return v7;
}

uint64_t DCSEnvironment::setActiveDictionaries(DCSEnvironment *this, CFArrayRef theArray)
{
  CFIndex Count = CFArrayGetCount(theArray);
  DCSEnvironment::getActiveDictionaries(this);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
  CFIndex v5 = CFArrayGetCount(*((CFArrayRef *)this + 7));
  BOOL v6 = Count != v5;
  if (Count == v5 && Count >= 1)
  {
    CFIndex v8 = 0;
    do
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v8);
      CFStringRef v10 = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 7), v8);
      int v11 = CFEqual(ValueAtIndex, v10);
      BOOL v6 = v11 == 0;
      ++v8;
      if (v11) {
        BOOL v12 = v8 < Count;
      }
      else {
        BOOL v12 = 0;
      }
    }
    while (v12);
  }
  if (v6)
  {
    CFArrayRef Copy = CFArrayCreateCopy(0, theArray);
    CFIndex v14 = (const void *)*((void *)this + 7);
    if (v14) {
      CFRelease(v14);
    }
    *((void *)this + 7) = Copy;
  }

  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
}

uint64_t DCSEnvironment::copyInactiveDictionaries(DCSEnvironment *this, const __CFString *a2)
{
  return 0;
}

uint64_t DCSEnvironment::prepareDefaultAssets(DCSEnvironment *this)
{
  DCSEnvironment::getCurrentPreferredLanguages(this, 0);

  return DCSDictionary::startGlobalDictionariesEnvironment(0);
}

CFNumberRef DCSEnvironment::setServiceWindowType(DCSEnvironment *this, __int16 a2)
{
  __int16 valuePtr = a2;
  return CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
}

const void *DCSEnvironment::getDictionaryPreference(DCSEnvironment *this, const __CFString *key)
{
  if (!key) {
    return 0;
  }
  CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 11);
  if (!v4)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
    if (!*((void *)this + 11)) {
      *((void *)this + 11) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
    CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 11);
  }

  return CFDictionaryGetValue(v4, key);
}

uint64_t DCSEnvironment::setDictionaryPreference(DCSEnvironment *this, const __CFString *a2, const __CFDictionary *a3)
{
  DCSEnvironment::getDictionaryPreference(this, a2);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 11), a2, a3);

  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
}

uint64_t DCSEnvironment::resetDictionaryPreferences(DCSEnvironment *this)
{
  if (*((void *)this + 11))
  {
    CFLocaleRef v2 = (pthread_mutex_t *)((char *)this + 392);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
    CFLocaleRef v3 = (const void *)*((void *)this + 11);
    if (v3)
    {
      CFRelease(v3);
      *((void *)this + 11) = 0;
    }
    pthread_mutex_unlock(v2);
  }
  CFDictionaryRef v4 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();

  return DCSDictionaryManager::updatePreferences(v4);
}

uint64_t DCSEnvironment::parentalControlCensoringContents(DCSEnvironment *this)
{
  if (*((double *)this + 12) == 0.0)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 0x40000000;
    v3[2] = ___ZN14DCSEnvironment32parentalControlCensoringContentsEv_block_invoke;
    v3[3] = &__block_descriptor_tmp_52;
    v3[4] = this;
    *((unsigned char *)this + 104) = IsManagedConfigProfanityFilterForced();
    *((CFAbsoluteTime *)this + 12) = CFAbsoluteTimeGetCurrent();
    SetManagedConfigChangedCallback((uint64_t)v3);
  }
  return *((unsigned __int8 *)this + 104);
}

void ___ZN14DCSEnvironment32parentalControlCensoringContentsEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 104) = IsManagedConfigProfanityFilterForced();
  *(CFAbsoluteTime *)(v1 + 96) = CFAbsoluteTimeGetCurrent();
}

BOOL DCSEnvironment::networkDictionariesExcluded(DCSEnvironment *this)
{
  int v1 = *((_DWORD *)this + 27);
  if (v1 == -1)
  {
    *((_DWORD *)this + 27) = 1;
    MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, @"DCSUseNetworkDictionaries");
      if (ValueForInfoDictionaryKey) {
        BOOL v5 = ValueForInfoDictionaryKey == (CFTypeRef)*MEMORY[0x1E4F1CFC8];
      }
      else {
        BOOL v5 = 1;
      }
      int v1 = v5;
      *((_DWORD *)this + 27) = v1;
    }
    else
    {
      int v1 = *((_DWORD *)this + 27);
    }
  }
  return v1 != 0;
}

BOOL DCSEnvironment::orientationVerticalAllowed(DCSEnvironment *this)
{
  if (*((_DWORD *)this + 28) == -1)
  {
    *((_DWORD *)this + 28) = 0;
    MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      BOOL v3 = CFBundleGetValueForInfoDictionaryKey(MainBundle, @"DCSAllowOrientationVertical") == (CFTypeRef)*MEMORY[0x1E4F1CFD0];
      *((_DWORD *)this + 28) = v3;
      if (v3) {
        return *((_DWORD *)this + 28) > 0;
      }
    }
    else if (*((_DWORD *)this + 28))
    {
      return *((_DWORD *)this + 28) > 0;
    }
    CFDictionaryRef v4 = CFBundleGetMainBundle();
    if (v4)
    {
      CFStringRef Identifier = CFBundleGetIdentifier(v4);
      if (Identifier)
      {
        if (CFEqual(Identifier, @"com.apple.Dictionary")) {
          *((_DWORD *)this + 28) = 1;
        }
      }
    }
  }
  return *((_DWORD *)this + 28) > 0;
}

uint64_t DCSEnvironment::readyForFontActivation(DCSEnvironment *this)
{
  return 0;
}

uint64_t DCSEnvironment::getSubstituteCharactersTable(DCSEnvironment *this, const __CFCharacterSet **a2)
{
  if (!*((void *)this + 15))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
    if (!*((void *)this + 15))
    {
      CFDictionaryRef PropertyList = DCSEnvironment::loadPropertyList(this, @"SubstituteCharacters");
      if (PropertyList)
      {
        CFDictionaryRef v5 = PropertyList;
        uint64_t Count = CFDictionaryGetCount(PropertyList);
        uint64_t v7 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
        CFIndex v8 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
        CFIndex v9 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
        CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFArrayRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
        values = (void **)v8;
        CFDictionaryGetKeysAndValues(v5, v7, v8);
        uint64_t v11 = 0;
        if (Count >= 1)
        {
          while (1)
          {
            uint64_t Length = CFStringGetLength((CFStringRef)v7[v11]);
            if (Length > 2) {
              break;
            }
            uint64_t v13 = Length;
            v20.location = 0;
            v20.length = Length;
            CFStringGetCharacters((CFStringRef)v7[v11], v20, buffer);
            CFIndex v14 = (const void *)buffer[0];
            if (v13 == 2 && (buffer[0] & 0xFC00) == 55296) {
              CFIndex v14 = (const void *)(buffer[1] + (buffer[0] << 10) - 56613888);
            }
            v9[v11] = v14;
            CFCharacterSetAddCharactersInString(Mutable, (CFStringRef)v7[v11++]);
            if (Count == v11) {
              goto LABEL_15;
            }
          }
        }
        if (v11 == Count)
        {
LABEL_15:
          *((void *)this + 15) = CFDictionaryCreate(0, v9, (const void **)values, Count, 0, MEMORY[0x1E4F1D540]);
          *((void *)this + 16) = CFCharacterSetCreateInvertedSet(alloc, Mutable);
        }
        free(v7);
        free(values);
        free(v9);
        CFRelease(Mutable);
        CFRelease(v5);
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
  }
  if (a2) {
    *a2 = (const __CFCharacterSet *)*((void *)this + 16);
  }
  return *((void *)this + 15);
}

const __CFURL *DCSEnvironment::loadPropertyList(DCSEnvironment *this, const __CFString *a2)
{
  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);
  CFURLRef v4 = CFBundleCopyResourceURL(FrameworkBundle, a2, @"plist", 0);
  if (v4)
  {
    CFDataRef resourceData = 0;
    CFURLCreateDataAndPropertiesFromResource(0, v4, &resourceData, 0, 0, 0);
    CFRelease(v4);
    if (resourceData)
    {
      CFURLRef v4 = (const __CFURL *)CFPropertyListCreateFromXMLData(0, resourceData, 0, 0);
      CFRelease(resourceData);
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

CFMutableSetRef DCSEnvironment::copyAvailableDictionaries(DCSEnvironment *this)
{
  CFDictionaryRef v1 = (const __CFDictionary *)DCSEnvironment::cachedDictionariesInfo(this);
  CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v1, @"dictionaries");
  if (Value) {
    CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)CollectDictionariesInCacheCallback, Mutable);
  }
  if (!CFSetGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t DCSEnvironment::cachedDictionariesInfo(DCSEnvironment *this)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  CFLocaleRef v2 = (pthread_mutex_t *)((char *)this + 520);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 520));
  unsigned __int8 v3 = *((unsigned char *)this + 152);
  int v4 = *((unsigned __int8 *)this + 154);
  uint64_t Count = (uint64_t)DCSEnvironment::cachedDictionariesInfo_internal(this);
  BOOL v6 = (__CFDictionary *)Count;
  if (v4 | v3)
  {
    if (v4)
    {
LABEL_3:
      CFArrayRef DictionaryPathArray = DCSEnvironment::createDictionaryPathArray((DCSEnvironment *)Count);
      goto LABEL_4;
    }
    CFArrayRef DictionaryPathArray = 0;
LABEL_39:
    pthread_mutex_unlock(v2);
    if (!DictionaryPathArray) {
      return *((void *)this + 20);
    }
LABEL_40:
    CFRelease(DictionaryPathArray);
    return *((void *)this + 20);
  }
  CFDictionaryRef Value = (DCSEnvironment *)CFDictionaryGetValue((CFDictionaryRef)Count, @"directories");
  CFArrayRef DictionaryPathArray = DCSEnvironment::createDictionaryPathArray(Value);
  uint64_t Count = CFArrayGetCount(DictionaryPathArray);
  if (Count >= 1 && Value)
  {
    uint64_t v33 = Count;
    for (CFIndex i = 0; i != v33; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(DictionaryPathArray, i);
      CFDictionaryGetValue(Value, ValueAtIndex);
    }
    goto LABEL_39;
  }
  if (Value) {
    goto LABEL_39;
  }
  if (!DictionaryPathArray) {
    goto LABEL_3;
  }
LABEL_4:
  uint64_t v8 = CFArrayGetCount(DictionaryPathArray);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, v8, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v8 >= 1)
  {
    for (CFIndex j = 0; j != v8; ++j)
      CFArrayGetValueAtIndex(DictionaryPathArray, j);
  }
  CFDictionarySetValue(v6, @"directories", Mutable);
  CFRelease(Mutable);
  *((unsigned char *)this + 154) = 0;
  pthread_mutex_unlock(v2);
  uint64_t v11 = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
  CFSetRef v12 = v11;
  if (!DictionaryPathArray) {
    CFArrayRef DictionaryPathArray = DCSEnvironment::createDictionaryPathArray(v11);
  }
  CFIndex v13 = CFArrayGetCount(DictionaryPathArray);
  if (v13 >= 1)
  {
    CFIndex v14 = v13;
    for (CFIndex k = 0; k != v14; ++k)
    {
      CFStringRef v16 = (const __CFString *)CFArrayGetValueAtIndex(DictionaryPathArray, k);
      CFStringGetFileSystemRepresentation(v16, v39, 1024);
      IterateDirectory(v39, (unsigned int (*)(char *, uint64_t, uint64_t))CollectDictionariesOnDiskCallback, (uint64_t)v12);
    }
  }
  DCSEnvironment::checkSavedDictionaryPrefs(this, v12);
  CFDictionaryRef v17 = (const __CFDictionary *)CFDictionaryGetValue(v6, @"dictionaries");
  if (v17)
  {
    CFDictionaryRef v18 = v17;
    CFIndex v19 = CFDictionaryGetCount(v17);
    uint64_t v37 = (uint64_t)&v37;
    MEMORY[0x1F4188790](v19);
    unint64_t v20 = (8 * v19 + 15) & 0xFFFFFFFFFFFFFFF0;
    uint64_t v21 = (const __CFDictionary **)((char *)&v37 - v20);
    size_t v22 = (unint64_t)(8 * v19) >= 0x200 ? 512 : 8 * v19;
    bzero((char *)&v37 - v20, v22);
    MEMORY[0x1F4188790](v23);
    CFArrayRef v24 = (CFStringRef *)((char *)&v37 - v20);
    bzero((char *)&v37 - v20, v22);
    CFDictionaryGetKeysAndValues(v18, (const void **)((char *)&v37 - v20), (const void **)((char *)&v37 - v20));
    if (v19 >= 1)
    {
      v38 = (const void *)*MEMORY[0x1E4F1CFD0];
      while (1)
      {
        CFURLRef v25 = CFURLCreateWithFileSystemPath(0, *v24, kCFURLPOSIXPathStyle, 1u);
        if (!ItemExistsAtURL(v25)) {
          break;
        }
        v26 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
        uint64_t v27 = DCSDictionaryManager::dictionary(v26, v25, 0, 0);
        if (v27)
        {
          CFDictionaryRef v28 = (const void *)v27;
          v29 = DCSDictionary::dictionaryCacheInfo(*(DCSDictionary **)(v27 + 16), 1);
          if (v29) {
            CFDictionaryRef v30 = v29;
          }
          else {
            CFDictionaryRef v30 = *v21;
          }
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v30);
          if (CFSetContainsValue(v12, v28)) {
            CFDictionarySetValue(MutableCopy, @"scanned", v38);
          }
          CFRelease(v28);
          goto LABEL_27;
        }
LABEL_29:
        ++v21;
        ++v24;
        if (!--v19) {
          goto LABEL_30;
        }
      }
      CFMutableDictionaryRef MutableCopy = 0;
LABEL_27:
      DCSEnvironment::updateDictionaryCacheInfo((uint64_t)this, v25, MutableCopy);
      CFRelease(v25);
      if (MutableCopy) {
        CFRelease(MutableCopy);
      }
      goto LABEL_29;
    }
  }
LABEL_30:
  CFRelease(v12);
  if (DictionaryPathArray) {
    goto LABEL_40;
  }
  return *((void *)this + 20);
}

void CollectDictionariesInCacheCallback(const __CFString *a1, CFDictionaryRef theDict, __CFSet *a3)
{
  if (CFDictionaryContainsKey(theDict, @"scanned"))
  {
    CFURLRef v5 = CFURLCreateWithFileSystemPath(0, a1, kCFURLPOSIXPathStyle, 1u);
    CFStringRef v6 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
    uint64_t v7 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
    uint64_t v8 = DCSDictionaryManager::dictionary(v7, v5, 0);
    if (v8)
    {
      CFIndex v9 = v8;
      CFSetAddValue(a3, v8);
      CFRelease(v9);
    }
    CFRelease(v5);
    CFRelease(v6);
  }
}

__CFDictionary *DCSEnvironment::cachedDictionariesInfo_internal(DCSEnvironment *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = (__CFDictionary *)*((void *)this + 20);
  if (!Mutable)
  {
    if (*((unsigned char *)this + 152)) {
      return 0;
    }
    CFURLRef DictionariesCacheURL = DCSEnvironment::createDictionariesCacheURL(this);
    uint64_t v4 = _AcquireLockOfCacheFile(DictionariesCacheURL);
    if (v4 != -1)
    {
      resourceData[0].__pn_.__r_.__value_.__r.__words[0] = 0;
      CFURLCreateDataAndPropertiesFromResource(0, DictionariesCacheURL, (CFDataRef *)resourceData, 0, 0, 0);
      if (resourceData[0].__pn_.__r_.__value_.__r.__words[0])
      {
        CFDictionaryRef v5 = (const __CFDictionary *)CFPropertyListCreateFromXMLData(0, (CFDataRef)resourceData[0].__pn_.__r_.__value_.__l.__data_, 1uLL, 0);
        CFRelease(resourceData[0].__pn_.__r_.__value_.__l.__data_);
        if (v5)
        {
          LODWORD(resourceData[0].__pn_.__r_.__value_.__l.__data_) = 0;
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v5, @"cache version");
          CFNumberGetValue(Value, kCFNumberSInt32Type, resourceData);
          if (LODWORD(resourceData[0].__pn_.__r_.__value_.__l.__data_) == 8)
          {
            *((void *)this + 20) = v5;
            CFRelease(DictionariesCacheURL);
            _ReleaseLockOfCacheFile(v4);
            CFMutableDictionaryRef Mutable = (__CFDictionary *)*((void *)this + 20);
LABEL_11:
            *((unsigned char *)this + 152) = 1;
            return Mutable;
          }
          CFURLGetFileSystemRepresentation(DictionariesCacheURL, 1u, (UInt8 *)resourceData, 1024);
          remove(resourceData, v7);
          CFRelease(v5);
        }
      }
    }
    CFRelease(DictionariesCacheURL);
    _ReleaseLockOfCacheFile(v4);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    resourceData[0].__pn_.__r_.__value_.__r.__words[0] = 8;
    CFNumberRef v8 = CFNumberCreate(0, kCFNumberCFIndexType, resourceData);
    CFDictionaryAddValue(Mutable, @"cache version", v8);
    CFRelease(v8);
    *((void *)this + 20) = Mutable;
    goto LABEL_11;
  }
  return Mutable;
}

CFArrayRef DCSEnvironment::createDictionaryPathArray(DCSEnvironment *this)
{
  cf[1] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  cf[0] = CFStringCreateWithCString(0, "/Library/Dictionaries", 0x8000100u);
  CFArrayRef v1 = CFArrayCreate(0, cf, 1, MEMORY[0x1E4F1D510]);
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  return v1;
}

uint64_t DCSEnvironment::checkDirectoryTimeStamp(DCSEnvironment *this, const __CFString *a2, const __CFNumber *a3, const __CFNumber **a4)
{
  if (a4) {
    *a4 = 0;
  }
  return 1;
}

uint64_t CollectDictionariesOnDiskCallback(char *a1, int a2, __CFSet *a3)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  size_t v5 = strlen(a1);
  if (strrchr(a1, 46) && (v5 < 6 || strcmp(&a1[v5 - 6], ".lproj")))
  {
    MEMORY[0x1F4188790]();
    strlcpy((char *)v12 - ((v5 + 271) & 0xFFFFFFFFFFFFFFF0), a1, v5 + 256);
    strlcat((char *)v12 - ((v5 + 271) & 0xFFFFFFFFFFFFFFF0), "/Contents/Info.plist", v5 + 256);
    if (ItemExistsAtPath((const char *)v12 - ((v5 + 271) & 0xFFFFFFFFFFFFFFF0), 0))
    {
      CFURLRef v6 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)a1, v5, 1u);
      CFStringRef v7 = CFURLCopyFileSystemPath(v6, kCFURLPOSIXPathStyle);
      CFNumberRef v8 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
      CFIndex v9 = (const void *)DCSDictionaryManager::dictionary(v8, v6, 0, 0);
      if (v9)
      {
        CFStringRef v10 = v9;
        CFSetAddValue(a3, v9);
        CFRelease(v10);
      }
      CFRelease(v6);
      CFRelease(v7);
    }
    return 0;
  }
  return 1;
}

void DCSEnvironment::checkSavedDictionaryPrefs(DCSEnvironment *this, CFSetRef theSet)
{
  CFIndex Count = CFSetGetCount(theSet);
  size_t v5 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
  CFSetGetValues(theSet, v5);
  if (Count >= 1)
  {
    CFURLRef v6 = v5;
    do
    {
      if (*v6) {
        CFStringRef v7 = (DCSDictionary *)*((void *)*v6 + 2);
      }
      else {
        CFStringRef v7 = 0;
      }
      CFDictionaryRef v8 = (const __CFDictionary *)DCSDictionary::defaultPreference(v7);
      if (v8)
      {
        CFDictionaryRef v9 = v8;
        CFNumberRef Value = CFDictionaryGetValue(v8, @"version");
        if (Value)
        {
          uint64_t v11 = Value;
          CFStringRef v12 = (const __CFString *)DCSDictionary::identifier(v7);
          CFDictionaryRef DictionaryPreference = (const __CFDictionary *)DCSEnvironment::getDictionaryPreference(this, v12);
          if (DictionaryPreference)
          {
            CFDictionaryRef v14 = DictionaryPreference;
            char v15 = CFDictionaryGetValue(DictionaryPreference, @"version");
            if (v15)
            {
              if (!CFEqual(v11, v15))
              {
                CFStringRef v16 = (const void *)DCSDictionary::migrateOldPreference(v7, v14);
                pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
                CFDictionaryRef v17 = (__CFDictionary *)*((void *)this + 11);
                CFDictionaryRef v18 = DCSDictionary::identifier(v7);
                if (v16)
                {
                  CFDictionarySetValue(v17, v18, v16);
                  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
                  DCSDictionary::setPreference(v7, (const __CFDictionary *)v16);
                  CFRelease(v16);
                }
                else
                {
                  CFDictionaryRemoveValue(v17, v18);
                  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
                  DCSDictionary::setPreference(v7, v9);
                }
              }
            }
          }
        }
      }
      ++v6;
      --Count;
    }
    while (Count);
  }

  free(v5);
}

uint64_t DCSEnvironment::updateDictionaryCacheInfo(uint64_t this, const __CFURL *a2, const __CFDictionary *a3)
{
  if (a2)
  {
    size_t v5 = (CFDictionaryRef *)this;
    CFURLRef v6 = (pthread_mutex_t *)(this + 520);
    pthread_mutex_lock((pthread_mutex_t *)(this + 520));
    if (DCSEnvironment::updateDictionaryCacheInfo(__CFURL const*,__CFDictionary const*)::_CacheInfoModified == 1)
    {
      CFNumberRef Value = (__CFDictionary *)CFDictionaryGetValue(v5[20], @"dictionaries");
    }
    else
    {
      DCSEnvironment::cachedDictionariesInfo_internal((DCSEnvironment *)v5);
      CFDictionaryRef v8 = (const __CFDictionary *)CFDictionaryGetValue(v5[20], @"dictionaries");
      if (v8) {
        CFNumberRef Value = CFDictionaryCreateMutableCopy(0, 0, v8);
      }
      else {
        CFNumberRef Value = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
    }
    CFDictionaryRef v9 = Value;
    CFStringRef v10 = CFURLCopyFileSystemPath(a2, kCFURLPOSIXPathStyle);
    if (a3) {
      CFDictionarySetValue(v9, v10, a3);
    }
    else {
      CFDictionaryRemoveValue(v9, v10);
    }
    CFRelease(v10);
    if ((DCSEnvironment::updateDictionaryCacheInfo(__CFURL const*,__CFDictionary const*)::_CacheInfoModified & 1) == 0)
    {
      CFDictionarySetValue(v5[20], @"dictionaries", v9);
      CFRelease(v9);
      DCSEnvironment::updateDictionaryCacheInfo(__CFURL const*,__CFDictionary const*)::_CacheInfoModified = 1;
    }
    DCSEnvironment::setDelayedWriteCacheTask((DCSEnvironment *)v5);
    return pthread_mutex_unlock(v6);
  }
  return this;
}

void DCSEnvironment::setDelayedWriteCacheTask(DCSEnvironment *this)
{
  if (!*((unsigned char *)this + 153))
  {
    context.version = 0;
    context.info = this;
    memset(&context.retain, 0, 24);
    CFLocaleRef v2 = CFRunLoopObserverCreate(0, 0x20uLL, 0, 0, (CFRunLoopObserverCallBack)_DictionaryCacheChangedCallback, &context);
    Main = CFRunLoopGetMain();
    CFRunLoopAddObserver(Main, v2, (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
    *((unsigned char *)this + 153) = 1;
  }
}

uint64_t DCSEnvironment::delayedWriteDictionariesCache(DCSEnvironment *this)
{
  CFLocaleRef v2 = (pthread_mutex_t *)((char *)this + 520);
  unsigned __int8 v3 = (DCSEnvironment *)pthread_mutex_trylock((pthread_mutex_t *)((char *)this + 520));
  if (v3)
  {
    *((unsigned char *)this + 153) = 0;
    return DCSEnvironment::setDelayedWriteCacheTask(this);
  }
  else
  {
    CFURLRef DictionariesCacheURL = DCSEnvironment::createDictionariesCacheURL(v3);
    uint64_t v6 = _AcquireLockOfCacheFile(DictionariesCacheURL);
    if (v6 != -1)
    {
      uint64_t v7 = v6;
      CFDictionaryRef v8 = CFWriteStreamCreateWithFile(0, DictionariesCacheURL);
      if (v8)
      {
        CFDictionaryRef v9 = v8;
        if (CFWriteStreamOpen(v8))
        {
          CFPropertyListWriteToStream(*((CFPropertyListRef *)this + 20), v9, kCFPropertyListBinaryFormat_v1_0, 0);
          CFWriteStreamClose(v9);
        }
        CFRelease(v9);
      }
      _ReleaseLockOfCacheFile(v7);
    }
    CFRelease(DictionariesCacheURL);
    *((unsigned char *)this + 153) = 0;
    return pthread_mutex_unlock(v2);
  }
}

const __CFURL *DCSEnvironment::createDictionariesCacheURL(DCSEnvironment *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  CFArrayRef v1 = (const __CFArray *)CFCopySearchPathForDirectoriesInDomains();
  if (!CFArrayGetCount(v1)) {
    DCSEnvironment::createDictionariesCacheURL();
  }
  CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v1, 0);
  MainBundle = CFBundleGetMainBundle();
  CFStringRef Identifier = CFBundleGetIdentifier(MainBundle);
  CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"Caches/%@/com.apple.DictionaryServices/%@", Identifier, @"DictionaryCache.plist");
  CFURLRef v6 = CFURLCreateCopyAppendingPathComponent(0, ValueAtIndex, v5, 0);
  CFRelease(v1);
  CFRelease(v5);
  if (!ItemExistsAtURL(v6))
  {
    CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, v6);
    if (!ItemExistsAtURL(PathComponent))
    {
      CFURLGetFileSystemRepresentation(PathComponent, 1u, buffer, 1024);
      mkdir((const char *)buffer, 0x1FFu);
    }
    CFRelease(PathComponent);
  }
  return v6;
}

uint64_t _AcquireLockOfCacheFile(CFURLRef url)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, url);
  CFURLGetFileSystemRepresentation(PathComponent, 1u, buffer, 1024);
  strlcat((char *)buffer, "/.lockfile", 0x400uLL);
  CFRelease(PathComponent);
  uint64_t v2 = open((const char *)buffer, 514, 511);
  uint64_t v3 = v2;
  if (v2 != -1 && flock(v2, 2))
  {
    close(v3);
    return 0xFFFFFFFFLL;
  }
  return v3;
}

uint64_t _ReleaseLockOfCacheFile(uint64_t result)
{
  if (result != -1)
  {
    int v2 = result;
    flock(result, 8);
    return close(v2);
  }
  return result;
}

const __CFDictionary *DCSEnvironment::logUsageTrackingInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef result = (const __CFDictionary *)DCSRecord::dictionaryRef(*(DCSRecord **)(a2 + 16));
  if (result)
  {
    CFDictionaryRef result = DCSDictionaryGetIdentifier((uint64_t)result);
    if (result) {
      operator new();
    }
  }
  return result;
}

void sub_1D5908410(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x81C40803F642BLL);
  _Unwind_Resume(a1);
}

void ___ZN14DCSEnvironment20logUsageTrackingInfoEPK11__DCSRecord_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (char *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 600), *(const void **)(a1 + 40)) + 1;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(v2 + 600), *(const void **)(a1 + 40), v3);
  dispatch_time_t v4 = dispatch_time(0, 1000000000);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  v7[2] = ___ZN14DCSEnvironment20logUsageTrackingInfoEPK11__DCSRecord_block_invoke_2;
  v7[3] = &__block_descriptor_tmp_81;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  v7[4] = v2;
  v7[5] = v5;
  v7[6] = v3;
  v7[7] = v6;
  dispatch_after(v4, MEMORY[0x1E4F14428], v7);
}

uint64_t ___ZN14DCSEnvironment20logUsageTrackingInfoEPK11__DCSRecord_block_invoke_2(uint64_t a1)
{
  if (*(const void **)(a1 + 48) == CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 600), *(const void **)(a1 + 40)))(*(void (**)(void))(**(void **)(a1 + 56) + 48))(*(void *)(a1 + 56)); {
  uint64_t result = *(void *)(a1 + 56);
  }
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v3();
  }
  return result;
}

void DCSEnvironment::storeActiveDictionaryLanguage(CFDictionaryRef *this, CFStringRef theString1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (theString1 && CFStringCompare(theString1, @"*", 0) && !CFDictionaryGetValue(this[24], theString1))
  {
    CFIndex Count = CFDictionaryGetCount(this[24]);
    MEMORY[0x1F4188790](Count);
    uint64_t v6 = (const void **)&v10[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
    if (v5 >= 0x200) {
      size_t v7 = 512;
    }
    else {
      size_t v7 = v5;
    }
    bzero(&v10[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)], v7);
    CFDictionaryGetKeysAndValues(this[24], v6, 0);
    CFDictionaryRef v8 = (const void *)*MEMORY[0x1E4F1CFC8];
    if (Count >= 1)
    {
      CFDictionaryRef v9 = (const void *)*MEMORY[0x1E4F1CFD0];
      do
      {
        char v11 = 0;
        CompareLanguageCode(theString1, (CFStringRef)*v6, &v11);
        if (v11)
        {
          CFDictionarySetValue(this[24], *v6, v9);
          CFDictionaryRef v8 = v9;
        }
        ++v6;
        --Count;
      }
      while (Count);
    }
    CFDictionarySetValue(this[24], theString1, v8);
  }
}

const void *DCSEnvironment::copyPrimaryLanguageOfDictionaryURL(DCSEnvironment *this, const __CFURL *a2)
{
  uint64_t v2 = CFBundleCreate(0, a2);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(v2);
  CFNumberRef Value = CFDictionaryGetValue(InfoDictionary, @"DCSDictionaryPrimaryLanguage");
  uint64_t v6 = Value;
  if (Value) {
    CFRetain(Value);
  }
  CFRelease(v3);
  return v6;
}

__CFArray *DCSEnvironment::createDefaultDictionaryList(DCSEnvironment *this)
{
  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(FrameworkBundle);
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(InfoDictionary, @"DCSAppleDictionaries");

  return DCSEnvironment::createMatchedDictionariesForPreferredLanguages(this, Value, 0, 1);
}

__CFArray *DCSEnvironment::createMatchedDictionariesForPreferredLanguages(DCSEnvironment *this, const __CFArray *a2, int a3, int a4)
{
  int v50 = a4;
  int v45 = a3;
  v54[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFDictionaryRef v8 = CFArrayCreateMutable(0, 0, v6);
  CFIndex Count = CFArrayGetCount(a2);
  CFIndex v48 = Count;
  CFDictionaryRef v49 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Count >= 1)
  {
    CFIndex v10 = 0;
    char v11 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    do
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v10);
      CFURLRef v13 = CFURLCreateWithFileSystemPath(0, ValueAtIndex, kCFURLPOSIXPathStyle, 1u);
      if (v13)
      {
        CFURLRef v14 = v13;
        char v15 = (DCSEnvironment *)ItemExistsAtURL(v13);
        if (v15)
        {
          CFStringRef v16 = DCSEnvironment::copyPrimaryLanguageOfDictionaryURL(v15, v14);
          if (v16)
          {
            CFDictionaryRef v17 = v16;
            CFArrayRef Value = (void *)CFDictionaryGetValue(v49, v16);
            if (!Value)
            {
              CFArrayRef Value = CFArrayCreateMutable(0, 0, v11);
              CFDictionarySetValue(v49, v17, Value);
              CFRelease(Value);
            }
            CFArrayAppendValue((CFMutableArrayRef)Value, ValueAtIndex);
            CFRelease(v17);
            CFIndex Count = v48;
          }
          else
          {
            CFArrayAppendValue(v8, ValueAtIndex);
          }
        }
        CFRelease(v14);
      }
      ++v10;
    }
    while (Count != v10);
  }
  CFArrayRef v46 = v8;
  CFArrayRef v47 = a2;
  v54[0] = 0;
  CurrentPreferredLanguages = (const void *)DCSEnvironment::getCurrentPreferredLanguages(this, v54);
  CFArrayRef v20 = (const __CFArray *)CFRetain(CurrentPreferredLanguages);
  CFDictionaryRef v21 = v49;
  CFIndex v22 = CFDictionaryGetCount(v49);
  uint64_t v44 = (uint64_t)&v44;
  MEMORY[0x1F4188790](v22);
  unint64_t v23 = (8 * v22 + 15) & 0xFFFFFFFFFFFFFFF0;
  if ((unint64_t)(8 * v22) >= 0x200) {
    size_t v24 = 512;
  }
  else {
    size_t v24 = 8 * v22;
  }
  bzero((char *)&v44 - v23, v24);
  MEMORY[0x1F4188790](v25);
  bzero((char *)&v44 - v23, v24);
  v51 = (CFArrayRef *)((char *)&v44 - v23);
  v52 = (CFStringRef *)((char *)&v44 - v23);
  CFDictionaryGetKeysAndValues(v21, (const void **)((char *)&v44 - v23), (const void **)((char *)&v44 - v23));
  while (1)
  {
    CFIndex v26 = CFArrayGetCount(v20);
    if (v26 >= 1)
    {
      CFIndex v27 = v26;
      for (CFIndex i = 0; i != v27; ++i)
      {
        CFStringRef v29 = (const __CFString *)CFArrayGetValueAtIndex(v20, i);
        if ((i != v54[0] || i == 0) && v22 >= 1)
        {
          CFStringRef v32 = v29;
          uint64_t v33 = v51;
          v34 = v52;
          CFIndex v35 = v22;
          do
          {
            if (CompareLanguageCode(v32, *v34, 0))
            {
              CFArrayRef v36 = *v33;
              v56.length = CFArrayGetCount(*v33);
              v56.location = 0;
              CFArrayAppendArray(Mutable, v36, v56);
            }
            ++v33;
            ++v34;
            --v35;
          }
          while (v35);
        }
      }
    }
    if ((v50 & 1) == 0) {
      break;
    }
    uint64_t v37 = (DCSEnvironment *)CFArrayGetCount(Mutable);
    if ((uint64_t)v37 > 0) {
      break;
    }
    if (v20) {
      CFRelease(v20);
    }
    values = 0;
    values = (void *)DCSEnvironment::getFallbackEnglishLanguage(v37);
    CFArrayRef v20 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    int v50 = 0;
  }
  uint64_t v38 = v48;
  if (v20) {
    CFRelease(v20);
  }
  CFArrayRef v40 = v46;
  CFArrayRef v39 = v47;
  if (v45)
  {
    if (v38 >= 1)
    {
      for (CFIndex j = 0; j != v38; ++j)
      {
        v42 = CFArrayGetValueAtIndex(v39, j);
        v55.length = CFArrayGetCount(Mutable);
        v55.location = 0;
        if (!CFArrayContainsValue(Mutable, v55, v42)) {
          CFArrayAppendValue(Mutable, v42);
        }
      }
    }
  }
  else
  {
    v57.length = CFArrayGetCount(v46);
    v57.location = 0;
    CFArrayAppendArray(Mutable, v40, v57);
  }
  CFRelease(v40);
  CFRelease(v49);
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

const __CFArray *DCSEnvironment::appendNewReleasedDictionaries(DCSEnvironment *this, const __CFArray *a2, __CFArray *a3)
{
  updated = DCSMACopyAndUpdateDictionaryCompatibilityVersionHistory();
  if (updated)
  {
    CFArrayRef v6 = updated;
    FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);
    CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(FrameworkBundle);
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, @"DCSNewReleasedDictionaries");
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    CFIndex Count = CFArrayGetCount(v6);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
      {
        uint64_t valuePtr = 0;
        CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v6, i);
        if (CFNumberGetValue(ValueAtIndex, kCFNumberCFIndexType, &valuePtr))
        {
          CFStringRef v15 = CFStringCreateWithFormat(0, 0, @"%ld", valuePtr);
          if (Value)
          {
            CFArrayRef v16 = (const __CFArray *)CFDictionaryGetValue(Value, v15);
            if (v16)
            {
              CFArrayRef v17 = v16;
              v49.length = CFArrayGetCount(v16);
              v49.location = 0;
              CFArrayAppendArray(Mutable, v17, v49);
            }
          }
          CFRelease(v15);
        }
      }
    }
    CFRelease(v6);
    if (!CFArrayGetCount(Mutable))
    {
      v31 = Mutable;
      goto LABEL_40;
    }
    CFStringRef CurrentPreferredLanguages = (const __CFString *)DCSEnvironment::getCurrentPreferredLanguages(this, 0);
    CFArrayRef v19 = (const __CFArray *)DCSEnvironment::copyInactiveDictionaries(Mutable, CurrentPreferredLanguages);
    CFRelease(Mutable);
    if (v19)
    {
      uint64_t v20 = CFArrayGetCount(v19);
      CFArrayRef v21 = (const __CFArray *)DCSEnvironment::copyInactiveDictionaries(0, 0);
      if (v21)
      {
        CFArrayRef v22 = v21;
        CFIndex v23 = CFArrayGetCount(v21);
        if (v23 < 1)
        {
          CFIndex v26 = 0;
        }
        else
        {
          CFIndex v24 = v23;
          CFIndex v25 = 0;
          CFIndex v26 = 0;
          do
          {
            CFDictionaryRef v27 = (const __CFDictionary *)CFArrayGetValueAtIndex(v22, v25);
            v47.location = 0;
            v47.length = v20;
            if (!CFArrayContainsValue(v19, v47, v27))
            {
              CFDictionaryRef v28 = (const __CFDictionary *)DCSMAGetAssetAttributes(v27);
              CFStringRef v29 = (const __CFString *)CFDictionaryGetValue(v28, @"Language");
              CFStringRef CurrentSystemLanguage = DCSEnvironment::getCurrentSystemLanguage(this);
              v26 += CompareLanguageCode(v29, CurrentSystemLanguage, 0);
            }
            ++v25;
          }
          while (v24 != v25);
        }
        CFRelease(v22);
      }
      else
      {
        CFIndex v26 = 0;
      }
      CFArrayRef v44 = a2;
      if (a2) {
        CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(0, 0, a2);
      }
      else {
        CFMutableArrayRef MutableCopy = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      }
      CFArrayRef v33 = MutableCopy;
      if (v20 >= 1)
      {
        CFIndex v34 = 0;
        CFIndex v35 = v26;
        do
        {
          CFDictionaryRef v36 = (const __CFDictionary *)CFArrayGetValueAtIndex(v19, v34);
          v48.length = CFArrayGetCount(v33);
          v48.location = 0;
          if (!CFArrayContainsValue(v33, v48, v36))
          {
            CFDictionaryRef v37 = (const __CFDictionary *)DCSMAGetAssetAttributes(v36);
            uint64_t v38 = CFDictionaryGetValue(v37, @"DictionaryIdentifier");
            CFStringRef v39 = (const __CFString *)CFDictionaryGetValue(v37, @"Language");
            if (v26
              || (CFStringRef v40 = v39,
                  CFStringRef v41 = DCSEnvironment::getCurrentSystemLanguage(this),
                  !CompareLanguageCode(v40, v41, 0)))
            {
              CFArrayAppendValue(v33, v36);
              CFArrayAppendValue(a3, v38);
            }
            else
            {
              CFArrayInsertValueAtIndex(v33, v35, v36);
              CFArrayInsertValueAtIndex(a3, v35++, v38);
            }
          }
          ++v34;
        }
        while (v20 != v34);
      }
      CFRelease(v19);
      a2 = v44;
      if (v44)
      {
        CFIndex v42 = CFArrayGetCount(v44);
        if (CFArrayGetCount(v33) != v42)
        {
          CFRelease(v44);
          return v33;
        }
      }
      else if (CFArrayGetCount(v33))
      {
        return v33;
      }
      v31 = v33;
LABEL_40:
      CFRelease(v31);
    }
  }
  return a2;
}

void _DictionaryCacheChangedCallback(__CFRunLoopObserver *a1, unint64_t a2, DCSEnvironment *this)
{
  DCSEnvironment::delayedWriteDictionariesCache(this);
  CFRunLoopObserverInvalidate(a1);

  CFRelease(a1);
}

CFURLRef DCSEnvironment::copyWikipediaDictionaryURL(DCSEnvironment *this)
{
  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(this);

  return CFBundleCopyResourceURL(FrameworkBundle, @"Wikipedia", @"wikipediadictionary", 0);
}

void DCSIDXDictionary::DCSIDXDictionary(DCSIDXDictionary *this, const __CFURL *a2)
{
  DCSBaseDictionary::DCSBaseDictionary(this, a2);
  *(void *)uint64_t v3 = &unk_1F2DE2E58;
  *(void *)(v3 + 256) = 0;
  *(void *)(v3 + 264) = 0;
  *(void *)(v3 + 248) = 0;
  *(unsigned char *)(v3 + 272) = 0;
  *(void *)(v3 + 280) = 0;
  *(void *)(v3 + 288) = 0;
  *(void *)(v3 + 296) = 0;
  *(void *)(v3 + 304) = -1;
  *((void *)this + 39) = 0;
  *((void *)this + 40) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v3 + 328), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 392), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 456), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 520), 0);
}

void sub_1D5909078(_Unwind_Exception *a1)
{
  DCSBaseDictionary::~DCSBaseDictionary(v1);
  _Unwind_Resume(a1);
}

void DCSIDXDictionary::~DCSIDXDictionary(DCSIDXDictionary *this)
{
  *(void *)this = &unk_1F2DE2E58;
  uint64_t v2 = (const void *)*((void *)this + 37);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 31);
  if (v3) {
    CFRelease(v3);
  }
  dispatch_time_t v4 = (const void *)*((void *)this + 32);
  if (v4) {
    CFRelease(v4);
  }
  unint64_t v5 = (const void *)*((void *)this + 33);
  if (v5) {
    CFRelease(v5);
  }
  CFArrayRef v6 = (void *)*((void *)this + 36);
  if (v6) {
    free(v6);
  }
  size_t v7 = (const void *)*((void *)this + 39);
  if (v7) {
    CFRelease(v7);
  }
  CFDictionaryRef v8 = (const void *)*((void *)this + 38);
  if ((unint64_t)v8 + 1 >= 2) {
    CFRelease(v8);
  }
  uint64_t v9 = *((void *)this + 40);
  if (v9)
  {
    DCSDictionaryImageReplacement::~DCSDictionaryImageReplacement(*((DCSDictionaryImageReplacement **)this + 40));
    MEMORY[0x1D94553C0](v9, 0x10F0C403D00FC33);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 328));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 392));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 520));

  DCSBaseDictionary::~DCSBaseDictionary(this);
}

{
  uint64_t vars8;

  DCSIDXDictionary::~DCSIDXDictionary(this);

  JUMPOUT(0x1D94553C0);
}

void sub_1D5909188(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  MEMORY[0x1D94553C0](v3, 0x10F0C403D00FC33);
  DCSBaseDictionary::~DCSBaseDictionary(v1);
  _Unwind_Resume(a1);
}

void sub_1D5909210(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C40ECEE0193);
  _Unwind_Resume(a1);
}

void *DCSIDXDictionary::createSessionInfo(uint64_t a1, uint64_t a2)
{
  v6.version = 0;
  memset(&v6.retain, 0, 24);
  dispatch_time_t v4 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
  *dispatch_time_t v4 = a1;
  v4[1] = a2;
  v6.info = v4;
  v4[2] = CFRunLoopObserverCreate(0, 0x20uLL, 0, 0, (CFRunLoopObserverCallBack)_RunLoopObserverCallBack, &v6);
  return v4;
}

void _RunLoopObserverCallBack(__CFRunLoopObserver *a1, unint64_t a2, void *a3)
{
  uint64_t v3 = a3[1];
  CFArrayRef v4 = (const __CFArray *)(*(uint64_t (**)(void, void, void, void))(*(void *)*a3 + 296))(*a3, *(void *)(v3 + 56), *(void *)(v3 + 64), *(void *)(v3 + 72));
  CFTypeRef v5 = CFRetain(*(CFTypeRef *)v3);
  CFIndex v6 = CFGetRetainCount(v5);
  DCSSearchSession::didFindRecord((void *)v3, v4);
  if (v4) {
    CFRelease(v4);
  }
  if (CFGetRetainCount(v5) == v6) {
    DCSSearchSession::didFinishSearch((DCSSearchSession *)v3, 0);
  }

  CFRelease(v5);
}

void DCSIDXDictionary::releaseSessionInfo(DCSIDXDictionary *this, void *a2)
{
  uint64_t v3 = (const void *)a2[2];
  if (v3) {
    CFRelease(v3);
  }

  free(a2);
}

void DCSIDXDictionary::scheduleSession(DCSIDXDictionary *this, CFRunLoopObserverRef *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
}

void DCSIDXDictionary::unscheduleSession(DCSIDXDictionary *this, CFRunLoopObserverRef *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
}

__CFArray *DCSIDXDictionary::searchByString(DCSIDXDictionary *this, const __CFString *a2, unint64_t a3, uint64_t a4)
{
  int v5 = a3;
  CFStringRef v6 = a2;
  v79[0] = MEMORY[0x1E4F143A8];
  v79[1] = 0x40000000;
  v79[2] = ___ZN16DCSIDXDictionary14searchByStringEPK10__CFStringll_block_invoke;
  v79[3] = &__block_descriptor_tmp_1;
  v79[4] = this;
  v79[5] = (unsigned __int16)a3;
  BOOL v78 = 0;
  CFArrayRef v8 = ___ZN16DCSIDXDictionary14searchByStringEPK10__CFStringll_block_invoke((uint64_t)v79, a2, a3, a4, &v78);
  if (v78) {
    return v8;
  }
  CFArrayRef v10 = (const __CFArray *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 96))(this);
  if (!v10) {
    return v8;
  }
  CFArrayRef v11 = v10;
  CFIndex Count = CFArrayGetCount(v10);
  if (Count < 1) {
    return v8;
  }
  v61 = v8;
  CFIndex v12 = 0;
  CFStringRef v13 = 0;
  CFArrayRef theArray = 0;
  unint64_t v14 = *(void *)&v5 & 0x10000;
  CFStringRef v69 = v6;
  CFArrayRef v62 = v11;
  while (2)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v11, v12);
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"DCSDictionaryIndexLanguage");
    if (!Value)
    {
      CFStringRef v22 = v13;
      goto LABEL_78;
    }
    CFStringRef v17 = Value;
    CFStringRef v67 = v13;
    CFIndex v65 = v12;
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v6);
    CFComparisonResult v19 = CFStringCompare(v17, @"ar", 0);
    CFComparisonResult v66 = CFStringCompare(v17, @"he", 0);
    v71 = (__CFString *)v17;
    unsigned int v20 = _IsStopLemmatizeWordForLanguage(v6, v17);
    char v21 = 0;
    int v72 = v20 ^ 1;
    if (v19 == kCFCompareEqualTo && (v20 & 1) == 0)
    {
      if (ContainsLatinAlphabets(v6))
      {
        char v21 = 0;
        int v72 = 0;
      }
      else
      {
        CFMutableStringRef v23 = CFStringCreateMutableCopy(0, 0, v6);
        ExtraNormalizeStringForArabic(v23, 0);
        if (CFStringCompare(v6, v23, 0))
        {
          CFArrayRef theArray = DCSIDXDictionary::searchByString_internal(this, v23, v14, a4);
          BOOL v24 = theArray != 0;
          int v72 = theArray == 0;
        }
        else
        {
          BOOL v24 = 0;
        }
        CFRelease(v23);
        char v21 = v24;
      }
    }
    char v63 = v21;
    char v75 = v21;
    CFIndex v25 = theArray;
    CFStringRef v73 = v67;
    CFStringRef cf = v6;
    v70 = MutableCopy;
    while (1)
    {
      if (!v72)
      {
        CFStringRef v73 = v67;
        char v40 = v63;
        goto LABEL_49;
      }
      CFIndex v26 = v25;
      CFArrayRef v27 = DCSCopyLemmas((uint64_t)cf, v71);
      if (v27)
      {
        CFArrayRef v28 = v27;
        CFIndex v77 = CFArrayGetCount(v27);
        if (v77 < 1)
        {
          v76 = 0;
        }
        else
        {
          CFIndex v29 = 0;
          v76 = 0;
          do
          {
            CFStringRef v30 = (const __CFString *)CFArrayGetValueAtIndex(v28, v29);
            uint64_t v31 = 0;
            while (1)
            {
              CFStringRef v32 = CFStringCreateMutableCopy(0, 0, v30);
              CFStringRef v33 = v32;
              if (v31)
              {
                ExtraNormalizeStringForArabic(v32, 0);
              }
              else
              {
                CFLocaleRef v34 = (const __CFLocale *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 256))(this);
                DCSNormalizeSearchStringWithOptionsAndLocale(v33, 0, v34);
              }
              CFIndex v35 = DCSIDXDictionary::searchByString_internal(this, v33, v14, a4);
              CFRelease(v33);
              if (v35) {
                break;
              }
              if (v19 | v31++) {
                goto LABEL_35;
              }
            }
            if (v19) {
              CFStringRef v73 = (const __CFString *)CFRetain(cf);
            }
            if (v76)
            {
              v80.length = CFArrayGetCount(v35);
              v80.location = 0;
              CFArrayAppendArray(v76, v35, v80);
            }
            else
            {
              v76 = CFArrayCreateMutableCopy(0, 0, v35);
            }
            CFRelease(v35);
            char v75 = 1;
LABEL_35:
            ++v29;
          }
          while (v29 != v77);
        }
        CFRelease(v28);
        CFStringRef v6 = v69;
        CFMutableStringRef MutableCopy = v70;
        CFDictionaryRef v37 = v76;
      }
      else
      {
        CFMutableStringRef MutableCopy = v70;
        CFDictionaryRef v37 = v26;
      }
      if ((v75 & 1) != 0 || v19 || cf != v6)
      {
        char v40 = v75;
        CFArrayRef theArray = v37;
        goto LABEL_49;
      }
      uint64_t v38 = v37;
      ExtraNormalizeStringForArabic(MutableCopy, 1);
      if (CFEqual(v6, MutableCopy)) {
        break;
      }
      CFStringRef v39 = DCSIDXDictionary::searchByString_internal(this, MutableCopy, v14, a4);
      char v75 = 0;
      CFIndex v25 = 0;
      CFStringRef cf = MutableCopy;
      if (v39)
      {
        char v40 = 1;
        CFArrayRef theArray = v39;
        goto LABEL_49;
      }
    }
    char v40 = v75;
    CFArrayRef theArray = v38;
LABEL_49:
    if (v19) {
      BOOL v41 = v66 == kCFCompareEqualTo;
    }
    else {
      BOOL v41 = 1;
    }
    int v42 = v41;
    if ((v72 & !v78 & ~v40) != 1 || v42 == 0)
    {
      CFMutableStringRef v44 = MutableCopy;
LABEL_72:
      CFRelease(v44);
      CFArrayRef v11 = v62;
      CFIndex v12 = v65;
      goto LABEL_77;
    }
    int v45 = CFStringCreateMutableCopy(0, 0, v6);
    CFArrayRef v46 = v45;
    if (v19 == kCFCompareEqualTo) {
      ExtraNormalizeStringForArabic(v45, 0);
    }
    CFArrayRef v47 = _CopyPossibleArabicHebrewStemList(v46, v71);
    CFRelease(v46);
    if (!v47)
    {
      CFMutableStringRef v44 = v70;
      goto LABEL_72;
    }
    CFIndex v48 = CFArrayGetCount(v47);
    if (v48 < 1) {
      goto LABEL_76;
    }
    CFIndex v49 = v48;
    CFIndex v50 = 0;
    while (1)
    {
      CFStringRef v51 = (const __CFString *)CFArrayGetValueAtIndex(v47, v50);
      if (CFStringGetLength(v51) >= 3) {
        break;
      }
LABEL_69:
      if (v49 == ++v50) {
        goto LABEL_76;
      }
    }
    v52 = DCSIDXDictionary::searchByString_internal(this, v51, v14, a4);
    if (!v52)
    {
      CFArrayRef theArray = 0;
      goto LABEL_69;
    }
    CFArrayRef theArray = v52;
    if (v19) {
      CFStringRef v73 = (const __CFString *)CFRetain(v6);
    }
    char v40 = 1;
LABEL_76:
    CFArrayRef v11 = v62;
    CFIndex v12 = v65;
    CFRelease(v47);
    CFRelease(v70);
LABEL_77:
    CFStringRef v22 = v73;
    if ((v40 & 1) == 0)
    {
LABEL_78:
      ++v12;
      CFStringRef v13 = v22;
      if (v12 == Count) {
        break;
      }
      continue;
    }
    break;
  }
  if (theArray)
  {
    CFIndex v53 = CFArrayGetCount(theArray);
    v54 = theArray;
    uint64_t v55 = (uint64_t)v61;
    if (v53 >= 1)
    {
      CFIndex v56 = v53;
      for (CFIndex i = 0; i != v56; ++i)
      {
        v58 = (DCSRecord **)CFArrayGetValueAtIndex(theArray, i);
        v59 = v58;
        if (v22)
        {
          v60 = v58[2];
          DCSRecord::setHeadword(v60, v22);
          DCSRecord::setKeyString(v60, v22);
        }
        if (v61) {
          CFArrayAppendValue(v61, v59);
        }
      }
      v54 = theArray;
    }
    if (v22) {
LABEL_89:
    }
      CFRelease(v22);
  }
  else
  {
    v54 = 0;
    uint64_t v55 = (uint64_t)v61;
    if (v22) {
      goto LABEL_89;
    }
  }
  if (v55) {
    uint64_t result = (__CFArray *)v55;
  }
  else {
    uint64_t result = v54;
  }
  if (v55)
  {
    if (theArray)
    {
      CFRelease(v54);
      return (__CFArray *)v55;
    }
  }
  return result;
}

CFArrayRef ___ZN16DCSIDXDictionary14searchByStringEPK10__CFStringll_block_invoke(uint64_t a1, const __CFString *a2, unint64_t a3, uint64_t a4, BOOL *a5)
{
  CFArrayRef v8 = DCSIDXDictionary::searchByString_internal(*(DCSIDXDictionary **)(a1 + 32), a2, a3, a4);
  CFArrayRef v9 = v8;
  if (a5)
  {
    *a5 = v8 != 0;
    if (v8)
    {
      uint64_t v10 = *(void *)(a1 + 40);
      if ((unint64_t)(v10 - 1) <= 1)
      {
        if (v10 == 1) {
          CFIndex v11 = 0;
        }
        else {
          CFIndex v11 = CFArrayGetCount(v8) - 1;
        }
        CFIndex v12 = (DCSRecord *)*((void *)CFArrayGetValueAtIndex(v9, v11) + 2);
        CFIndex Length = CFStringGetLength(a2);
        CFStringRef v14 = DCSRecord::keyString(v12);
        if (Length != CFStringGetLength(v14)) {
          *a5 = 0;
        }
      }
    }
  }
  return v9;
}

__CFArray *DCSIDXDictionary::searchByString_internal(DCSIDXDictionary *this, const __CFString *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v49 = a4;
  v52[1] = *MEMORY[0x1E4F143B8];
  DCSIDXDictionary::prepareTrieIndex((uint64_t)this);
  if (!*((void *)this + 31)) {
    return 0;
  }
  size_t v7 = this;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  {
    DCSIDXDictionary::searchByString_internal(__CFString const*,long,long)::methodString[0] = @"IDXExactMatch";
    unk_1EB798FB0 = @"IDXPrefixMatch";
    qword_1EB798FB8 = @"IDXCommonPrefixMatch";
    unk_1EB798FC0 = @"IDXWildcardMatch";
  }
  CFArrayRef v9 = (pthread_mutex_t *)((char *)this + 328);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 328));
  if (IDXSetSearchString(*((void *)this + 31), a2, DCSIDXDictionary::searchByString_internal(__CFString const*,long,long)::methodString[(unsigned __int16)a3]))
  {
    CFArrayRef v46 = (pthread_mutex_t *)((char *)this + 328);
    uint64_t v10 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
    int v50 = DCSEnvironment::parentalControlCensoringContents(v10);
    uint64_t v11 = IDXSupportDataPtr(*((void *)this + 31));
    CFIndex v12 = (uint64_t *)this;
    if (v11)
    {
      CFArrayRef v47 = &v46;
      uint64_t v13 = 1024;
      if (v49) {
        uint64_t v13 = v49;
      }
      uint64_t v48 = v13;
      unint64_t v14 = 8 * v13;
      MEMORY[0x1F4188790](v11);
      unint64_t v15 = (v14 + 15) & 0xFFFFFFFFFFFFFFF0;
      if (v14 >= 0x200) {
        size_t v16 = 512;
      }
      else {
        size_t v16 = v14;
      }
      CFStringRef v17 = (char *)&v46 - v15;
      bzero((char *)&v46 - v15, v16);
      MEMORY[0x1F4188790](v18);
      CFComparisonResult v19 = (char *)&v46 - v15;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = (a3 >> 16) & 1;
      while (1)
      {
        uint64_t matched = IDXGetMatchDataPtr(v12[31], v48, (uint64_t)v17, (uint64_t)v19);
        if (!matched) {
          break;
        }
        uint64_t v24 = matched;
        if (matched >= 1)
        {
          uint64_t v25 = 0;
          do
          {
            RecordRef = (const void *)DCSIDXDictionary::createRecordRef((DCSIDXDictionary *)v12, *(const unsigned __int8 **)&v17[8 * v25], *(void *)&v19[8 * v25], 0, v50, v22, v20 + v25 + 1);
            if (RecordRef)
            {
              CFArrayRef v27 = RecordRef;
              CFArrayAppendValue(Mutable, RecordRef);
              CFRelease(v27);
              ++v21;
              if (v49) {
                BOOL v28 = v21 < v49;
              }
              else {
                BOOL v28 = 1;
              }
              char v29 = !v28;
            }
            else
            {
              char v29 = 0;
            }
            ++v25;
          }
          while ((v29 & 1) == 0 && v25 < v24);
          v20 += v25;
          if (v29) {
            break;
          }
        }
      }
    }
    else
    {
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      v52[0] = 0x20000;
      uint64_t v32 = (a3 >> 16) & 1;
      do
      {
        CFArrayRef v47 = &v46;
        MEMORY[0x1F4188790](v11);
        CFLocaleRef v34 = (char *)&v46 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
        uint64_t v48 = v35;
        if (!(_BYTE)v35) {
          CFLocaleRef v34 = (char *)malloc_type_malloc(v52[0], 0x8E56F5AAuLL);
        }
        uint64_t v51 = 0;
        while (1)
        {
          uint64_t v11 = IDXGetMatchData(v12[31], v49, v52[0], (uint64_t)v34, (uint64_t)&v51, v52);
          uint64_t v36 = v11;
          if (!v11) {
            break;
          }
          if (v11 >= 1)
          {
            CFDictionaryRef v37 = Mutable;
            uint64_t v38 = 0;
            uint64_t v39 = 1;
            do
            {
              uint64_t v11 = DCSIDXDictionary::createRecordRef(v7, (const unsigned __int8 *)&v34[*(void *)(v51 + v38)], *(void *)(v51 + v38 + 8), 1, v50, v32, v30 + v39);
              if (v11)
              {
                char v40 = (const void *)v11;
                CFArrayAppendValue(v37, (const void *)v11);
                CFRelease(v40);
                ++v31;
                if (v49) {
                  BOOL v41 = v31 < v49;
                }
                else {
                  BOOL v41 = 1;
                }
                char v42 = !v41;
              }
              else
              {
                char v42 = 0;
              }
              uint64_t v43 = v39 + 1;
              if (v42) {
                break;
              }
              v38 += 16;
              BOOL v28 = v39++ < v36;
            }
            while (v28);
            uint64_t v30 = v30 + v43 - 1;
            CFMutableDictionaryRef Mutable = v37;
            CFIndex v12 = (uint64_t *)v7;
            if (v42) {
              break;
            }
          }
        }
        if (!(_BYTE)v48) {
          free(v34);
        }
        if (v36) {
          BOOL v44 = 1;
        }
        else {
          BOOL v44 = v52[0] == 0;
        }
      }
      while (!v44);
    }
    CFArrayRef v9 = v46;
  }
  pthread_mutex_unlock(v9);
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

CFArrayRef _IsStopLemmatizeWordForLanguage(const __CFString *a1, const __CFString *key)
{
  if (_IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_OnceToken != -1) {
    dispatch_once(&_IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_OnceToken, &__block_literal_global_0);
  }
  CFArrayRef result = 0;
  if (a1 && _IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_StopWordDict)
  {
    CFArrayRef result = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_StopWordDict, key);
    if (result)
    {
      CFArrayRef v5 = result;
      v6.length = CFArrayGetCount(result);
      v6.location = 0;
      return (const __CFArray *)(CFArrayContainsValue(v5, v6, a1) != 0);
    }
  }
  return result;
}

CFArrayRef _CopyPossibleArabicHebrewStemList(__CFString *a1, const __CFString *a2)
{
  values = a1;
  uint64_t v3 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef Copy = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, v3);
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFIndex Count = CFArrayGetCount(Copy);
  CFAllocatorRef allocator = v6;
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    unsigned int v9 = 0;
    unint64_t v10 = 0x1EA724000uLL;
    unint64_t v11 = 0x1EA724000uLL;
    CFArrayRef theArray = Mutable;
    CFStringRef v50 = a2;
    while (1)
    {
      unsigned int v47 = v9;
      CFIndex v12 = 0;
      CFArrayRef v51 = Copy;
      CFIndex v52 = v8;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(Copy, v12);
        CFStringRef v14 = ValueAtIndex;
        if (*(void *)(v10 + 2968) == -1)
        {
          if (!ValueAtIndex) {
            goto LABEL_29;
          }
        }
        else
        {
          dispatch_once(&_CreateNextPossibleStems(__CFString const*,__CFString const*)::_OnceToken, &__block_literal_global_60);
          if (!v14) {
            goto LABEL_29;
          }
        }
        CFDictionaryRef v15 = *(const __CFDictionary **)(v11 + 2976);
        if (v15)
        {
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v15, a2);
          if (Value)
          {
            CFDictionaryRef v17 = Value;
            CFArrayRef v18 = (const __CFArray *)CFDictionaryGetValue(Value, @"prefix");
            CFArrayRef v19 = (const __CFArray *)CFDictionaryGetValue(v17, @"suffix");
            if (v18)
            {
              CFArrayRef v20 = v19;
              if (v19)
              {
                uint64_t v21 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
                CFIndex Length = CFStringGetLength(v14);
                CFIndex v23 = CFArrayGetCount(v20);
                if (v23 >= 1)
                {
                  CFIndex v24 = v23;
                  for (CFIndex i = 0; i != v24; ++i)
                  {
                    CFStringRef v26 = (const __CFString *)CFArrayGetValueAtIndex(v20, i);
                    CFIndex v27 = CFStringGetLength(v26);
                    CFIndex v28 = Length - v27;
                    if (Length > v27 && CFStringHasSuffix(v14, v26))
                    {
                      v55.location = 0;
                      v55.length = v28;
                      CFStringRef v29 = CFStringCreateWithSubstring(0, v14, v55);
                      CFArrayAppendValue(v21, v29);
                      CFRelease(v29);
                    }
                  }
                }
                CFIndex v30 = CFArrayGetCount(v18);
                if (v30 >= 1)
                {
                  CFIndex v31 = v30;
                  for (CFIndex j = 0; j != v31; ++j)
                  {
                    CFStringRef v33 = (const __CFString *)CFArrayGetValueAtIndex(v18, j);
                    CFIndex v34 = CFStringGetLength(v33);
                    CFIndex v35 = Length - v34;
                    if (Length > v34)
                    {
                      CFIndex v36 = v34;
                      if (CFStringHasPrefix(v14, v33))
                      {
                        v56.location = v36;
                        v56.length = v35;
                        CFStringRef v37 = CFStringCreateWithSubstring(0, v14, v56);
                        CFArrayAppendValue(v21, v37);
                        CFRelease(v37);
                      }
                    }
                  }
                }
                a2 = v50;
                CFArrayRef Copy = v51;
                unint64_t v10 = 0x1EA724000;
                unint64_t v11 = 0x1EA724000;
                CFIndex v8 = v52;
                if (v21)
                {
                  CFIndex v38 = CFArrayGetCount(v21);
                  if (v38 >= 1)
                  {
                    CFIndex v39 = v38;
                    for (CFIndex k = 0; k != v39; ++k)
                    {
                      BOOL v41 = CFArrayGetValueAtIndex(v21, k);
                      if (!CFDictionaryContainsKey(theDict, v41))
                      {
                        CFDictionaryAddValue(theDict, v41, @"1");
                        CFArrayAppendValue(theArray, v41);
                      }
                    }
                  }
                  CFRelease(v21);
                  unint64_t v11 = 0x1EA724000;
                  CFIndex v8 = v52;
                }
              }
            }
          }
        }
LABEL_29:
        ++v12;
      }
      while (v12 != v8);
      CFRelease(Copy);
      CFMutableArrayRef Mutable = theArray;
      CFArrayRef Copy = CFArrayCreateCopy(0, theArray);
      CFArrayRemoveAllValues(theArray);
      CFIndex v42 = CFArrayGetCount(Copy);
      if (v42 >= 1)
      {
        CFIndex v8 = v42;
        unsigned int v9 = v47 + 1;
        if (v47 < 3) {
          continue;
        }
      }
      break;
    }
  }
  CFRelease(Copy);
  CFRelease(Mutable);
  CFMutableArrayRef v43 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_AddKeyToArray, v43);
  CFRelease(theDict);
  v54.length = CFArrayGetCount(v43);
  v54.location = 0;
  CFArraySortValues(v43, v54, (CFComparatorFunction)_CompareStringLength, 0);
  CFArrayRef v44 = CFArrayCreateCopy(allocator, v43);
  CFRelease(v43);
  return v44;
}

uint64_t DCSIDXDictionary::prepareTrieIndex(uint64_t this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(this + 248))
  {
    uint64_t v1 = this;
    if (!*(unsigned char *)(this + 272))
    {
      pthread_mutex_lock((pthread_mutex_t *)(this + 328));
      if (!*(void *)(v1 + 248))
      {
        CFURLRef v2 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
        uint64_t v3 = IDXCreateIndexObject(0, v2, @"DCSKeywordIndex");
        *(void *)(v1 + 248) = v3;
        if (v3)
        {
          *(_OWORD *)values = xmmword_1E6A59238;
          long long v7 = *(_OWORD *)&off_1E6A59248;
          long long v8 = xmmword_1E6A59258;
          long long v9 = *(_OWORD *)off_1E6A59268;
          CFArrayRef v4 = CFArrayCreate(0, (const void **)values, 8, MEMORY[0x1E4F1D510]);
          IDXSetRequestFields(*(void *)(v1 + 248), v4);
          CFRelease(v4);
        }
        else
        {
          *(unsigned char *)(v1 + 272) = 1;
          CFURLRef v5 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
          CFURLGetString(v5);
          CFLog();
        }
      }
      return pthread_mutex_unlock((pthread_mutex_t *)(v1 + 328));
    }
  }
  return this;
}

uint64_t DCSIDXDictionary::createRecordRef(DCSIDXDictionary *this, const unsigned __int8 *a2, uint64_t a3, char a4, int a5, int a6, unint64_t a7)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)size_t v16 = 0u;
  *(_OWORD *)CFDictionaryRef v17 = 0u;
  *(_OWORD *)CFArrayRef v18 = 0u;
  long long v19 = 0u;
  IDXGetFieldDataPtrs(*((void *)this + 31), (uint64_t)a2, a3, &v20, v16);
  uint64_t v12 = 0;
  switch(LOBYTE(v16[0]))
  {
    case 1:
      uint64_t v12 = *(unsigned __int8 *)v20;
      break;
    case 2:
      uint64_t v12 = *(unsigned __int16 *)v20;
      break;
    case 4:
      uint64_t v12 = *(unsigned int *)v20;
      break;
    case 8:
      uint64_t v12 = *(void *)v20;
      break;
    default:
      break;
  }
  LOWORD(v13) = 0;
  switch(LOBYTE(v16[1]))
  {
    case 1:
      LOWORD(v13) = **((unsigned char **)&v20 + 1);
      if (a5) {
        goto LABEL_14;
      }
      goto LABEL_15;
    case 2:
      LOWORD(v13) = **((_WORD **)&v20 + 1);
      if (!a5) {
        goto LABEL_15;
      }
      goto LABEL_14;
    case 4:
      LODWORD(v13) = **((_DWORD **)&v20 + 1);
      if (!a5) {
        goto LABEL_15;
      }
      goto LABEL_14;
    case 8:
      uint64_t v13 = **((void **)&v20 + 1);
      if (!a5) {
        goto LABEL_15;
      }
LABEL_14:
      if (v13) {
        return 0;
      }
LABEL_15:
      if (a6 && (v13 & 0x1E) != 0) {
        return 0;
      }
LABEL_18:
      uint64_t result = 0;
      if (LOWORD(v17[0]))
      {
        if ((void)v21)
        {
          HIWORD(v15) = v13;
          BYTE4(v15) = a4;
          LODWORD(v15) = 335544576;
          return DCSRecord::createRecordRef(*((DCSRecord **)this + 1), (DCSDictionary *)v21, (const unsigned __int16 *)LOWORD(v17[0]), *((uint64_t *)&v21 + 1), (const unsigned __int16 *)LOWORD(v17[1]), v22, (const unsigned __int16 *)LOWORD(v18[0]), *((uint64_t *)&v22 + 1), (const unsigned __int16 *)LOWORD(v18[1]), v23, (const unsigned __int16 *)(unsigned __int16)v19, *((uint64_t *)&v23 + 1), (const unsigned __int16 *)WORD4(v19), v15, v12, SBYTE4(v12), HIWORD(v12), a7, 0,
                   0,
                   v16[0]);
        }
      }
      return result;
    default:
      goto LABEL_18;
  }
}

uint64_t DCSIDXDictionary::searchByReference(DCSIDXDictionary *this, __CFString *a2)
{
  values[64] = *(void **)MEMORY[0x1E4F143B8];
  if (!*((void *)this + 33))
  {
    if (*((unsigned char *)this + 272)) {
      return 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
    if (!*((void *)this + 33))
    {
      CFURLRef v6 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 16))(this);
      long long v7 = IDXCreateIndexObject(0, v6, @"DCSReferenceIndex");
      *((void *)this + 33) = v7;
      if (v7)
      {
        values[0] = @"DCSExternalBodyID";
        CFArrayRef v8 = CFArrayCreate(0, (const void **)values, 1, MEMORY[0x1E4F1D510]);
        IDXSetRequestFields(*((void *)this + 33), v8);
        CFRelease(v8);
      }
      else
      {
        *((unsigned char *)this + 272) = 1;
        CFURLRef v13 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 16))(this);
        CFURLGetString(v13);
        CFLog();
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
    if (!*((void *)this + 33)) {
      return 0;
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 392));
  if (!IDXSetSearchString(*((void *)this + 33), a2, @"IDXExactMatch"))
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
    return 0;
  }
  CFDictionaryRef v17 = 0;
  uint64_t v18 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  if (IDXSupportDataPtr(*((void *)this + 33)))
  {
    uint64_t matched = IDXGetMatchDataPtr(*((void *)this + 33), 1, (uint64_t)&v18, (uint64_t)&v16);
    if (matched >= 1)
    {
      IDXGetFieldDataPtrs(*((void *)this + 33), v18, v16, &v17, &v15);
      CFStringRef v5 = 0;
      switch((char)v15)
      {
        case 1:
          CFStringRef v5 = (const __CFString *)*(unsigned __int8 *)v17;
          break;
        case 2:
          CFStringRef v5 = (const __CFString *)*(unsigned __int16 *)v17;
          break;
        case 4:
          CFStringRef v5 = (const __CFString *)*(unsigned int *)v17;
          break;
        case 8:
          CFStringRef v5 = *v17;
          break;
        default:
          break;
      }
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
      return DCSRecord::createRecordRef(*((DCSRecord **)this + 1), (DCSDictionary *)a2, v5, 0, v11);
    }
    uint64_t v9 = matched;
    goto LABEL_16;
  }
  CFStringRef v14 = 0;
  uint64_t v9 = IDXGetMatchData(*((void *)this + 33), 1, 512, (uint64_t)values, (uint64_t)&v14, 0);
  if (v9 < 1)
  {
LABEL_16:
    CFStringRef v5 = 0;
    goto LABEL_17;
  }
  uint64_t v10 = v14[1];
  uint64_t v18 = (uint64_t)values + *v14;
  uint64_t v16 = v10;
  IDXGetFieldDataPtrs(*((void *)this + 33), v18, v10, &v17, &v15);
  CFStringRef v5 = 0;
  switch((char)v15)
  {
    case 1:
      CFStringRef v5 = (const __CFString *)*(unsigned __int8 *)v17;
      break;
    case 2:
      CFStringRef v5 = (const __CFString *)*(unsigned __int16 *)v17;
      break;
    case 4:
      CFStringRef v5 = (const __CFString *)*(unsigned int *)v17;
      break;
    case 8:
      CFStringRef v5 = *v17;
      break;
    default:
      break;
  }
LABEL_17:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 392));
  if (v9) {
    return DCSRecord::createRecordRef(*((DCSRecord **)this + 1), (DCSDictionary *)a2, v5, 0, v11);
  }
  return 0;
}

__CFString *DCSIDXDictionary::copyData(DCSIDXDictionary *this, DCSRecord *a2, unint64_t a3)
{
  CFURLRef v6 = (pthread_mutex_t *)((char *)this + 456);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
  int v7 = (*(uint64_t (**)(DCSIDXDictionary *, unint64_t))(*(void *)this + 336))(this, a3);
  CFArrayRef v8 = (void *)*((void *)this + 32);
  if (v8) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v7 == 0;
  }
  if (!v9)
  {
    CFURLRef v10 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 16))(this);
    CFArrayRef v8 = IDXCreateIndexObject(0, v10, @"DCSBodyDataIndex");
    *((void *)this + 32) = v8;
  }
  if (v8) {
    int v11 = v7;
  }
  else {
    int v11 = 0;
  }
  if (v11 != 1) {
    goto LABEL_28;
  }
  CFIndex length = 0;
  if (IDXSupportDataPtr((uint64_t)v8))
  {
    uint64_t v12 = (const UInt8 *)IDXGetDataPtrByID(*((void *)this + 32), *((void *)a2 + 26), (uint64_t)&length);
    CFDataRef v13 = CFDataCreateWithBytesNoCopy(0, v12, length, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  }
  else
  {
    CFStringRef v14 = (void *)*((void *)this + 36);
    if (!v14)
    {
      *((void *)this + 35) = 0x8000;
      CFStringRef v14 = malloc_type_malloc(0x8000uLL, 0xA4DFE211uLL);
      *((void *)this + 36) = v14;
    }
    uint64_t v15 = IDXGetDataByID(*((void *)this + 32), *((void *)a2 + 26), *((void *)this + 35), (uint64_t)v14);
    CFIndex length = v15;
    if (v15 > *((void *)this + 35))
    {
      free(*((void **)this + 36));
      *((void *)this + 35) = v15;
      uint64_t v16 = malloc_type_malloc(v15, 0xF4C92DF2uLL);
      *((void *)this + 36) = v16;
      uint64_t v15 = IDXGetDataByID(*((void *)this + 32), *((void *)a2 + 26), *((void *)this + 35), (uint64_t)v16);
      CFIndex length = v15;
    }
    if (!v15) {
      goto LABEL_28;
    }
    CFDataRef v13 = CFDataCreate(0, *((const UInt8 **)this + 36), v15);
  }
  CFDictionaryRef v17 = (__CFString *)v13;
  if (!v13 || a3 == 4) {
    goto LABEL_29;
  }
  BytePtr = CFDataGetBytePtr(v13);
  CFIndex v19 = CFDataGetLength((CFDataRef)v17);
  CFStringRef v20 = CFStringCreateWithBytes(0, BytePtr, v19, 0x8000100u, 0);
  CFRelease(v17);
  if (!v20)
  {
LABEL_28:
    CFDictionaryRef v17 = 0;
    goto LABEL_29;
  }
  if (a3 != 255)
  {
    CFStringRef v21 = (const __CFString *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 368))(this);
    if (CFEqual(v21, @"Korean"))
    {
      long long v22 = (const __CFURL **)*((void *)this + 40);
      if (!v22) {
        operator new();
      }
      SourceXMLByReplacingImage = DCSDictionaryImageReplacement::createSourceXMLByReplacingImage(v22, v20);
      if (SourceXMLByReplacingImage)
      {
        uint64_t v24 = SourceXMLByReplacingImage;
        CFRelease(v20);
        CFStringRef v20 = v24;
      }
    }
  }
  uint64_t v25 = (DCSDictionary *)*((void *)this + 1);
  DCSRecord::dataString(a2);
  CFDictionaryRef v17 = CopyTransformedTextFromXML(v20, v25, a3);
  CFRelease(v20);
LABEL_29:
  pthread_mutex_unlock(v6);
  return v17;
}

void sub_1D590AD98(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F0C403D00FC33);
  _Unwind_Resume(a1);
}

uint64_t DCSIDXDictionary::hasRecord(DCSIDXDictionary *this, const __CFString *a2, unsigned __int16 a3, unsigned __int8 *a4)
{
  unint64_t v4 = a3;
  if (a3 > 3uLL) {
    return 0;
  }
  CFStringRef v7 = a2;
  BOOL hasRecord_internal = DCSIDXDictionary::hasRecord_internal(this, a2, a3, a4);
  uint64_t v5 = hasRecord_internal;
  if (v4 <= 1 && !hasRecord_internal || v4 == 2 && a4)
  {
    CFIndex Length = CFStringGetLength(v7);
    CFArrayRef v11 = (const __CFArray *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 96))(this);
    if (v11)
    {
      CFArrayRef v12 = v11;
      CFIndex Count = CFArrayGetCount(v11);
      if (Count >= 1)
      {
        CFIndex v14 = Count;
        CFIndex v49 = Length;
        *(void *)&unsigned long long v50 = a4;
        *((void *)&v50 + 1) = v4;
        unsigned int v48 = v5;
        CFIndex v15 = 0;
        CFStringRef v56 = v7;
        CFIndex v51 = Count;
        CFArrayRef v52 = v12;
LABEL_10:
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v12, v15);
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"DCSDictionaryIndexLanguage");
        if (!Value) {
          goto LABEL_64;
        }
        CFStringRef v18 = Value;
        CFIndex v55 = v15;
        CFComparisonResult v19 = CFStringCompare(Value, @"ar", 0);
        CFComparisonResult v20 = CFStringCompare(v18, @"he", 0);
        unsigned __int8 v21 = _IsStopLemmatizeWordForLanguage(v7, v18);
        BOOL v22 = 0;
        char v23 = v21 ^ 1;
        CFComparisonResult v54 = v20;
        if ((v21 & 1) == 0 && v19 == kCFCompareEqualTo)
        {
          if (ContainsLatinAlphabets(v7))
          {
            BOOL v22 = 0;
            char v23 = 0;
          }
          else
          {
            CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v7);
            ExtraNormalizeStringForArabic(MutableCopy, 0);
            if (CFStringCompare(v7, MutableCopy, 0))
            {
              BOOL v22 = DCSIDXDictionary::hasRecord_internal(this, MutableCopy, 0, 0);
              char v23 = !v22;
            }
            else
            {
              BOOL v22 = 0;
            }
            CFRelease(MutableCopy);
          }
        }
        CFMutableStringRef v25 = 0;
        BOOL v53 = v22;
        int v26 = v22;
        uint64_t v27 = (uint64_t)v7;
        CFStringRef v58 = v18;
        char v57 = v23;
        while ((v23 & 1) != 0)
        {
          CFArrayRef v28 = DCSCopyLemmas(v27, v18);
          if (v28)
          {
            CFArrayRef v29 = v28;
            CFIndex v59 = CFArrayGetCount(v28);
            if (v59 >= 1)
            {
              CFIndex v30 = 0;
              while (2)
              {
                CFStringRef v31 = (const __CFString *)CFArrayGetValueAtIndex(v29, v30);
                uint64_t v32 = 0;
                do
                {
                  CFStringRef v33 = CFStringCreateMutableCopy(0, 0, v31);
                  CFStringRef v34 = v33;
                  if (v32)
                  {
                    ExtraNormalizeStringForArabic(v33, 0);
                  }
                  else
                  {
                    CFLocaleRef v35 = (const __CFLocale *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 256))(this);
                    DCSNormalizeSearchStringWithOptionsAndLocale(v34, 0, v35);
                  }
                  BOOL v36 = DCSIDXDictionary::hasRecord_internal(this, v34, 0, 0);
                  CFRelease(v34);
                  if (v36)
                  {
                    int v26 = 1;
                    goto LABEL_33;
                  }
                }
                while (!(v19 | v32++));
                if (++v30 != v59) {
                  continue;
                }
                break;
              }
              int v26 = 0;
LABEL_33:
              CFStringRef v7 = v56;
              CFStringRef v18 = v58;
              char v23 = v57;
            }
            CFRelease(v29);
          }
          if ((v26 & 1) != 0
            || v19
            || (const __CFString *)v27 != v7
            || (CFMutableStringRef v25 = CFStringCreateMutableCopy(0, 0, v7),
                ExtraNormalizeStringForArabic(v25, 1),
                CFEqual(v7, v25)))
          {
            if (v19) {
              BOOL v38 = v54 == kCFCompareEqualTo;
            }
            else {
              BOOL v38 = 1;
            }
            int v39 = v38;
            if (((v26 ^ 1) & v39) != 1)
            {
              CFIndex v15 = v55;
LABEL_61:
              if (!v25) {
                goto LABEL_63;
              }
LABEL_62:
              CFRelease(v25);
              goto LABEL_63;
            }
            char v40 = CFStringCreateMutableCopy(0, 0, v7);
            BOOL v41 = v40;
            if (v19 == kCFCompareEqualTo) {
              ExtraNormalizeStringForArabic(v40, 0);
            }
            CFArrayRef v42 = _CopyPossibleArabicHebrewStemList(v41, v18);
            CFRelease(v41);
            CFIndex v15 = v55;
            if (!v42) {
              goto LABEL_61;
            }
            CFIndex v43 = CFArrayGetCount(v42);
            if (v43 < 1) {
              goto LABEL_67;
            }
            CFIndex v44 = v43;
            CFIndex v45 = 0;
            while (2)
            {
              CFStringRef v46 = (const __CFString *)CFArrayGetValueAtIndex(v42, v45);
              if (CFStringGetLength(v46) < 3)
              {
LABEL_56:
                if (v44 == ++v45) {
                  goto LABEL_67;
                }
                continue;
              }
              break;
            }
            if (!DCSIDXDictionary::hasRecord_internal(this, v46, 0, 0))
            {
              LOBYTE(v26) = 0;
              goto LABEL_56;
            }
            LOBYTE(v26) = 1;
LABEL_67:
            CFRelease(v42);
            if (v25) {
              goto LABEL_62;
            }
LABEL_63:
            CFIndex v14 = v51;
            CFArrayRef v12 = v52;
            if (v26) {
              goto LABEL_71;
            }
LABEL_64:
            if (++v15 == v14) {
              return v48;
            }
            goto LABEL_10;
          }
          int v26 = 0;
          uint64_t v27 = (uint64_t)v25;
          if (DCSIDXDictionary::hasRecord_internal(this, v25, 0, 0))
          {
            if (v25) {
              CFRelease(v25);
            }
            goto LABEL_71;
          }
        }
        CFIndex v14 = v51;
        CFArrayRef v12 = v52;
        CFIndex v15 = v55;
        if (!v53) {
          goto LABEL_64;
        }
LABEL_71:
        uint64_t v5 = 1;
        if (v50 > __PAIR128__(2, 0)) {
          *(unsigned char *)(v49 + v50 - 1) = 1;
        }
      }
    }
  }
  return v5;
}

BOOL DCSIDXDictionary::hasRecord_internal(DCSIDXDictionary *this, const __CFString *a2, uint64_t a3, unsigned __int8 *a4)
{
  DCSIDXDictionary::prepareTrieIndex((uint64_t)this);
  if (!*((void *)this + 31)) {
    return 0;
  }
  {
    DCSIDXDictionary::hasRecord_internal(__CFString const*,long,unsigned char *)::methodString[0] = @"IDXExactMatch";
    *(void *)algn_1EA724B78 = @"IDXPrefixMatch";
    qword_1EA724B80 = @"IDXCommonPrefixMatch";
    unk_1EA724B88 = @"IDXWildcardMatch";
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 328));
  if (IDXSetSearchString(*((void *)this + 31), a2, DCSIDXDictionary::hasRecord_internal(__CFString const*,long,unsigned char *)::methodString[a3]))BOOL v8 = IDXContainsMatchData(*((void *)this + 31), (uint64_t)a4) != 0; {
  else
  }
    BOOL v8 = 0;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 328));
  return v8;
}

uint64_t DCSIDXDictionary::baseURL(DCSIDXDictionary *this)
{
  if (!*((void *)this + 37) && (*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 16))(this))
  {
    CFURLRef v2 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 16))(this);
    uint64_t v3 = IDXCopyIndexNames(v2, 1);
    CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v3, 0);
    *((void *)this + 37) = ValueAtIndex;
    if (ItemExistsAtURL(ValueAtIndex))
    {
      CFRetain(*((CFTypeRef *)this + 37));
    }
    else
    {
      uint64_t v5 = (const void *)DCSBaseDictionary::baseURL(this);
      *((void *)this + 37) = CFRetain(v5);
    }
    CFRelease(v3);
  }
  return *((void *)this + 37);
}

uint64_t DCSIDXDictionary::languages(DCSIDXDictionary *this)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t result = *((void *)this + 38);
  if (result == -1)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 520));
    if (*((void *)this + 38) == -1)
    {
      CFArrayRef v3 = (const __CFArray *)DCSBaseDictionary::languages(this);
      *((void *)this + 38) = v3;
      if (v3)
      {
        CFArrayRef v4 = v3;
        if (CFArrayGetCount(v3) == 2
          && (CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, 0),
              CFStringRef Value = CFDictionaryGetValue(ValueAtIndex, @"DCSDictionaryDescriptionLanguage"),
              CFStringRef v7 = CFDictionaryGetValue(ValueAtIndex, @"DCSDictionaryIndexLanguage"),
              !CFEqual(Value, v7)))
        {
          values = (void *)CFArrayGetValueAtIndex(v4, 1);
          unsigned __int8 v21 = (__CFString *)ValueAtIndex;
          CFArrayRef v4 = CFArrayCreate(0, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
        }
        else
        {
          CFRetain(v4);
        }
        *((void *)this + 38) = v4;
        goto LABEL_20;
      }
      if ((*(unsigned int (**)(DCSIDXDictionary *))(*(void *)this + 216))(this))
      {
        BOOL v8 = (__CFBundle *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 376))(this);
        CFArrayRef v9 = CFBundleCopyBundleLocalizations(v8);
        if (v9)
        {
          CFArrayRef v10 = v9;
          CFArrayRef v11 = CFBundleCopyPreferredLocalizationsFromArray(v9);
          CFRelease(v10);
          if (v11)
          {
            CFStringRef v12 = (const __CFString *)CFArrayGetValueAtIndex(v11, 0);
            if (v12)
            {
              CFStringRef v13 = v12;
              CFRetain(v12);
              CFRelease(v11);
              CFLocaleRef v14 = CFLocaleCreate(0, v13);
              CFRelease(v13);
              if (!v14) {
                goto LABEL_20;
              }
              CFTypeRef v15 = CFLocaleGetValue(v14, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
              CFTypeRef v16 = CFLocaleGetValue(v14, (CFLocaleKey)*MEMORY[0x1E4F1D1F0]);
              CFStringRef v17 = v16 ? CFStringCreateWithFormat(0, 0, @"%@-%@", v15, v16) : (CFStringRef)CFRetain(v15);
              CFArrayRef v11 = (const __CFArray *)v17;
              CFRelease(v14);
              if (!v11) {
                goto LABEL_20;
              }
              values = @"DCSDictionaryIndexLanguage";
              unsigned __int8 v21 = @"DCSDictionaryDescriptionLanguage";
              v19[0] = v11;
              v19[1] = v11;
              CFTypeRef cf = CFDictionaryCreate(0, (const void **)&values, (const void **)v19, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              *((void *)this + 38) = CFArrayCreate(0, &cf, 1, MEMORY[0x1E4F1D510]);
              CFRelease(cf);
            }
            CFRelease(v11);
          }
        }
      }
    }
LABEL_20:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 520));
    return *((void *)this + 38);
  }
  return result;
}

BOOL DCSIDXDictionary::validDictionary(DCSIDXDictionary *this)
{
  if (!(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 16))(this)) {
    return 0;
  }
  CFURLRef v2 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 16))(this);
  CFDictionaryRef v3 = CFBundleCopyInfoDictionaryInDirectory(v2);
  if (!v3) {
    return 0;
  }
  CFDictionaryRef v4 = v3;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v3, @"IDXDictionaryIndexes");
  BOOL v8 = Value
    && (CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, 0)) != 0
    && (CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"IDXIndexName")) != 0
    && CFEqual(v7, @"DCSKeywordIndex");
  CFRelease(v4);
  return v8;
}

BOOL DCSIDXDictionary::isLocalizableDictionary(DCSIDXDictionary *this)
{
  if (!(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 16))(this)) {
    return 0;
  }
  CFURLRef v2 = (const __CFURL *)(*(uint64_t (**)(DCSIDXDictionary *))(*(void *)this + 16))(this);
  CFDictionaryRef v3 = IDXCopyIndexNames(v2, 1);
  if (!v3) {
    return 0;
  }
  CFDictionaryRef v4 = v3;
  CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v3, 0);
  if (ValueAtIndex && (CFURLRef v6 = CFURLCreateCopyDeletingLastPathComponent(0, ValueAtIndex)) != 0)
  {
    CFURLRef v7 = v6;
    CFStringRef PathComponent = CFURLCopyLastPathComponent(v6);
    if (PathComponent)
    {
      CFStringRef v9 = PathComponent;
      BOOL v10 = CFStringHasSuffix(PathComponent, @".lproj") != 0;
      CFRelease(v7);
      CFURLRef v7 = (const __CFURL *)v9;
    }
    else
    {
      BOOL v10 = 0;
    }
    CFRelease(v7);
  }
  else
  {
    BOOL v10 = 0;
  }
  CFRelease(v4);
  return v10;
}

uint64_t DCSIDXDictionary::primaryLocale(DCSIDXDictionary *this)
{
  uint64_t result = *((void *)this + 39);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 520));
    if (!*((void *)this + 39))
    {
      CFStringRef v3 = (const __CFString *)DCSBaseDictionary::primaryLanguage(this);
      if (v3)
      {
        CFStringRef CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString(0, v3);
        if (CanonicalLanguageIdentifierFromString)
        {
          CFStringRef v5 = CanonicalLanguageIdentifierFromString;
          *((void *)this + 39) = CFLocaleCreate(0, CanonicalLanguageIdentifierFromString);
          CFRelease(v5);
        }
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 520));
    return *((void *)this + 39);
  }
  return result;
}

uint64_t DCSIDXDictionary::purgeInactiveData(DCSIDXDictionary *this)
{
  CFURLRef v2 = (pthread_mutex_t *)((char *)this + 456);
  uint64_t result = pthread_mutex_trylock((pthread_mutex_t *)((char *)this + 456));
  if (!result)
  {
    CFDictionaryRef v4 = (const void *)*((void *)this + 32);
    if (v4)
    {
      CFRelease(v4);
      *((void *)this + 32) = 0;
    }
    return pthread_mutex_unlock(v2);
  }
  return result;
}

uint64_t DCSIDXDictionary::languageDirectionOfFoundRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2) {
    return (*(unsigned __int16 *)(v2 + 192) >> 5) & 1;
  }
  else {
    return 0;
  }
}

uint64_t DCSBaseDictionary::URL(DCSBaseDictionary *this)
{
  return *((void *)this + 3);
}

uint64_t DCSBaseDictionary::subDictionaries(DCSBaseDictionary *this)
{
  return 0;
}

uint64_t DCSBaseDictionary::parentDictionary(DCSBaseDictionary *this)
{
  return 0;
}

uint64_t DCSBaseDictionary::migrateOldPreference(DCSBaseDictionary *this, const __CFDictionary *a2)
{
  return 0;
}

uint64_t DCSBaseDictionary::copyDataURL()
{
  return 0;
}

uint64_t DCSBaseDictionary::dictionaryFileName(DCSBaseDictionary *this)
{
  return *((void *)this + 4);
}

CFTypeRef ___ZL31_IsStopLemmatizeWordForLanguagePK10__CFStringS1__block_invoke()
{
  v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(v0);
  CFTypeRef result = CFBundleGetValueForInfoDictionaryKey(FrameworkBundle, @"DSCStopLemmatizeWordList");
  _IsStopLemmatizeWordForLanguage(__CFString const*,__CFString const*)::_StopWordDict = (uint64_t)result;
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

void _AddKeyToArray(const void *value, const void *a2, CFMutableArrayRef theArray)
{
}

uint64_t _CompareStringLength(const __CFString *a1, const __CFString *a2, void *a3)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetLength(a2);
  if (Length <= v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = -1;
  }
  if (Length < v5) {
    return 1;
  }
  else {
    return v6;
  }
}

CFTypeRef ___ZL24_CreateNextPossibleStemsPK10__CFStringS1__block_invoke()
{
  v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(v0);
  CFTypeRef result = CFBundleGetValueForInfoDictionaryKey(FrameworkBundle, @"DCSStemGuessData");
  _CreateNextPossibleStems(__CFString const*,__CFString const*)::_StemGuessData = (uint64_t)result;
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

void DCSDictionaryImageReplacement::DCSDictionaryImageReplacement(DCSDictionaryImageReplacement *this, CFTypeRef cf)
{
  *(void *)this = cf;
  *((unsigned char *)this + 8) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  CFRetain(cf);
}

void DCSDictionaryImageReplacement::~DCSDictionaryImageReplacement(DCSDictionaryImageReplacement *this)
{
  uint64_t v2 = *(const void **)this;
  if (v2) {
    CFRelease(v2);
  }
  CFStringRef v3 = (void *)*((void *)this + 2);
  if (v3) {
    munmap(v3, *((void *)this + 3));
  }
  uint64_t v4 = *((void *)this + 4);
  if (v4)
  {
    if (*(_DWORD *)(v4 + 48)) {
      free(*(void **)(v4 + 8));
    }
    free((void *)v4);
  }
}

void DCSDictionaryImageReplacement::openData(const __CFURL **this)
{
  CFURLRef DictionaryComponentURL = CreateDictionaryComponentURL(*this, @"Resources/ImageData.data");
  CFRelease(*this);
  *this = 0;
  FileSystemPath = CreateFileSystemPath(DictionaryComponentURL);
  CFRelease(DictionaryComponentURL);
  if (FileSystemPath)
  {
    int v4 = open(FileSystemPath, 0);
    free(FileSystemPath);
    if (v4 != -1)
    {
      fstat(v4, &v12);
      off_t st_size = v12.st_size;
      this[3] = (const __CFURL *)v12.st_size;
      this[2] = (const __CFURL *)mmap(0, st_size, 1, 1, v4, 0);
      close(v4);
      CFURLRef v6 = this[2];
      CFURLRef v7 = (unsigned int *)((char *)v6 + 8);
      uint64_t v8 = *(unsigned int *)v6;
      CFStringRef v9 = (char *)malloc_type_malloc(0x48uLL, 0x1090040DA38FBB1uLL);
      if (v9)
      {
        *((void *)v9 + 8) = 0;
        *((_OWORD *)v9 + 2) = 0u;
        *((_OWORD *)v9 + 3) = 0u;
        *(_OWORD *)CFStringRef v9 = 0u;
        *((_OWORD *)v9 + 1) = 0u;
        *((void *)v9 + 1) = v7;
        *((void *)v9 + 5) = v8;
        if (v8 >= 0x18)
        {
          *(_DWORD *)CFStringRef v9 = *((_DWORD *)v6 + 3);
          *((void *)v9 + 2) = (char *)v7 + *((unsigned int *)v6 + 5);
          uint64_t v10 = *((void *)v6 + 3);
          *(void *)&long long v11 = v10;
          *((void *)&v11 + 1) = HIDWORD(v10);
          *(_OWORD *)(v9 + 24) = v11;
        }
      }
      this[4] = (const __CFURL *)v9;
      this[5] = (const __CFURL *)((char *)v7 + v8);
    }
  }
}

__CFString *DCSDictionaryImageReplacement::createSourceXMLByReplacingImage(const __CFURL **this, CFStringRef theString)
{
  CFStringRef v3 = this;
  if (!*((unsigned char *)this + 8))
  {
    DCSDictionaryImageReplacement::openData(this);
    *((unsigned char *)v3 + 8) = 1;
  }
  if (!v3[4]) {
    return 0;
  }
  v53.CFIndex length = CFStringGetLength(theString);
  v53.CFIndex location = 0;
  CFArrayRef Results = CFStringCreateArrayWithFindResults(0, theString, @"<img src=\"", v53, 0);
  if (!Results) {
    return 0;
  }
  CFArrayRef v5 = Results;
  CFIndex Length = CFStringGetLength(theString);
  if (CFArrayGetCount(v5) < 1)
  {
    CFIndex v8 = 0;
    CFMutableArrayRef Mutable = 0;
    goto LABEL_61;
  }
  CFMutableArrayRef Mutable = 0;
  CFIndex v8 = 0;
  CFIndex v9 = 0;
  contentsDeCFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  do
  {
    CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v5, v9);
    CFIndex v11 = ValueAtIndex[1] + *ValueAtIndex;
    CFIndex location = v11 + 4;
    if (v11 >= Length || location >= Length) {
      break;
    }
    if (CFStringGetCharacterAtIndex(theString, v11 + 4) != 34) {
      goto LABEL_57;
    }
    v50.CFIndex location = v11;
    v50.CFIndex length = 4;
    if (CFStringGetBytes(theString, v50, 0x8000100u, 0, 0, (UInt8 *)&v49.length + 4, 4, 0) != 4)
    {
      CFIndex location = v8;
      goto LABEL_56;
    }
    v49.CFIndex location = v8;
    CFURLRef v15 = v3[4];
    unsigned int v16 = 4;
    CFStringRef v17 = (unsigned __int8 *)&v49.length + 4;
    CFStringRef v18 = (unsigned int *)v15;
    while (1)
    {
      unsigned int v19 = *v18;
      int v20 = v19 & 3;
      if (v20 != 2) {
        break;
      }
      uint64_t v22 = *((void *)v15 + 1);
      uint64_t v23 = v19 - 2;
      unsigned __int8 v21 = (char *)(v22 + v23);
      if (!v16) {
        goto LABEL_51;
      }
      unint64_t v24 = *v17;
      uint64_t v25 = v24 >> 5;
      unsigned int v26 = *(_DWORD *)&v21[4 * (v24 >> 5) + 4];
      if (((v26 >> v24) & 1) == 0) {
        goto LABEL_55;
      }
      if (v24 >= 0x20)
      {
        int v27 = 0;
        if (v25 <= 1) {
          uint64_t v25 = 1;
        }
        else {
          uint64_t v25 = v25;
        }
        CFArrayRef v28 = (unsigned int *)(v22 + v23 + 4);
        do
        {
          unsigned int v29 = *v28++;
          int8x8_t v14 = vcnt_s8((int8x8_t)v29);
          v14.i16[0] = vaddlv_u8((uint8x8_t)v14);
          v27 += v14.i32[0];
          --v25;
        }
        while (v25);
      }
      else
      {
        int v27 = 0;
      }
      v14.i32[0] = v26 & ~(-1 << (v24 & 0x1F));
      int8x8_t v14 = vcnt_s8(v14);
      v14.i16[0] = vaddlv_u8((uint8x8_t)v14);
      CFStringRef v18 = (unsigned int *)&v21[4 * (v27 + v14.i32[0]) + 40];
LABEL_29:
      --v16;
      ++v17;
    }
    if (v20 == 3)
    {
      unsigned __int8 v21 = (char *)(*((void *)v15 + 1) + v19 - 3);
      if (!v16) {
        goto LABEL_51;
      }
      CFStringRef v18 = (unsigned int *)&v21[4 * *v17 + 4];
      goto LABEL_29;
    }
    if (v20 != 1) {
      goto LABEL_55;
    }
    CFIndex v46 = Length;
    CFIndex v30 = (_DWORD *)(*((void *)v15 + 2) + v19 - 1);
    unsigned __int8 v21 = (char *)(v30 + 1);
    if (!v16)
    {
LABEL_50:
      CFIndex Length = v46;
LABEL_51:
      uint64_t v40 = *(unsigned int *)v21;
      if (v40)
      {
        CFIndex v41 = Length;
        if (!Mutable) {
          CFMutableArrayRef Mutable = CFStringCreateMutable(0, 0);
        }
        v51.CFIndex location = v49.location;
        v51.CFIndex length = v11 - v49.location;
        appendOriginalSubstring(Mutable, theString, v51);
        CFStringRef v42 = CFStringCreateWithBytesNoCopy(0, (const UInt8 *)v3[5] + v40, *(unsigned int *)((char *)v3[5] + v40 - 4), 0x8000100u, 0, contentsDeallocator);
        CFStringAppend(Mutable, v42);
        CFRelease(v42);
        CFIndex Length = v41;
        goto LABEL_56;
      }
LABEL_55:
      CFIndex location = v49.location;
      goto LABEL_56;
    }
    int v32 = *v30;
    CFStringRef v31 = (unsigned __int8 *)(v30 + 2);
    unsigned int v48 = (unsigned __int8 *)&v21[v32];
    if (v31 < v48)
    {
      CFIndex v44 = Mutable;
      CFIndex v45 = v3;
      while (1)
      {
        unsigned int v35 = *v31;
        CFStringRef v33 = (char *)(v31 + 1);
        uint64_t v34 = v35;
        int v36 = v35 - v16;
        size_t v37 = v35 >= v16 ? v16 : v34;
        int v38 = memcmp(v33, v17, v37);
        int v39 = v38 ? v38 : v36;
        if ((v39 & 0x80000000) == 0) {
          break;
        }
        CFStringRef v31 = (unsigned __int8 *)&v33[v34 + 4];
        if (v31 >= v48)
        {
          CFIndex location = v49.location;
          CFStringRef v3 = v45;
LABEL_47:
          CFMutableArrayRef Mutable = v44;
          goto LABEL_48;
        }
      }
      CFStringRef v3 = v45;
      if (v39)
      {
        CFIndex location = v49.location;
        goto LABEL_47;
      }
      unsigned __int8 v21 = &v33[v34];
      CFMutableArrayRef Mutable = v44;
      goto LABEL_50;
    }
    CFIndex location = v49.location;
LABEL_48:
    CFIndex Length = v46;
LABEL_56:
    CFIndex v8 = location;
LABEL_57:
    ++v9;
  }
  while (v9 < CFArrayGetCount(v5));
LABEL_61:
  CFRelease(v5);
  if (v8 && Length > v8)
  {
    v52.CFIndex location = v8;
    v52.CFIndex length = Length - v8;
    appendOriginalSubstring(Mutable, theString, v52);
  }
  return Mutable;
}

void appendOriginalSubstring(__CFString *a1, const __CFString *a2, CFRange a3)
{
  CFStringRef v4 = CFStringCreateWithSubstring(0, a2, a3);
  CFStringAppend(a1, v4);

  CFRelease(v4);
}

void DCSRecord::DCSRecord(DCSRecord *this, DCSDictionary *a2, const unsigned __int16 *a3, size_t a4, const unsigned __int16 *a5, size_t a6, const unsigned __int16 *a7, size_t a8, const unsigned __int16 *a9, size_t a10, const unsigned __int16 *a11, uint64_t a12, const unsigned __int16 *a13, size_t a14, unsigned int a15, BOOL a16, unsigned __int16 a17, unint64_t a18, uint64_t a19, const __CFURL *a20,const __CFString *a21)
{
  *(void *)this = a2;
  *((_DWORD *)this + 4) = a15;
  *((unsigned char *)this + 20) = a16;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = a4;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = a6;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = a8;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = a10;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = a12;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((void *)this + 20) = a14;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((_WORD *)this + 96) = a17;
  *((void *)this + 25) = a19;
  *((void *)this + 26) = a18;
  *(_OWORD *)((char *)this + 232) = 0u;
  if (a21) {
    *((void *)this + 27) = CFRetain(a21);
  }
  if (a20) {
    *((void *)this + 28) = CFRetain(a20);
  }
  unsigned int v26 = **(const void ***)this;
  *((void *)this + 1) = v26;
  CFRetain(v26);
  uint64_t v27 = DCSDictionary::dictionaryFlag(*(DCSDictionary **)this);
  *((void *)this + 3) = v27;
  BOOL v28 = 0;
  if ((v27 & 4) != 0)
  {
    if (a6 && a12 >= 1) {
      BOOL v28 = a4 != a6 || memcmp(a3, a5, a6) != 0;
    }
  }
  else if (a12 >= 1 && a4 == a12)
  {
    BOOL v28 = memcmp(a3, a11, a12) == 0;
  }
  *((unsigned char *)this + 21) = v28;
  if (a16)
  {
    if (a3)
    {
      unsigned int v29 = malloc_type_malloc(a4, 0xAB85F0BDuLL);
      *((void *)this + 4) = v29;
      memcpy(v29, a3, a4);
    }
    if (a5)
    {
      CFIndex v30 = malloc_type_malloc(a6, 0x201A078BuLL);
      *((void *)this + 7) = v30;
      memcpy(v30, a5, a6);
    }
    if (a7)
    {
      CFStringRef v31 = malloc_type_malloc(a8, 0xCA49E36uLL);
      *((void *)this + 10) = v31;
      memcpy(v31, a7, a8);
    }
    if (a9)
    {
      int v32 = malloc_type_malloc(a10, 0xA2DAD704uLL);
      *((void *)this + 13) = v32;
      memcpy(v32, a9, a10);
    }
    if (a11)
    {
      CFStringRef v33 = malloc_type_malloc(a12, 0x8AFF3782uLL);
      *((void *)this + 16) = v33;
      memcpy(v33, a11, a12);
    }
    if (a13)
    {
      uint64_t v34 = malloc_type_malloc(a14, 0xF4C854C8uLL);
      *((void *)this + 19) = v34;
      memcpy(v34, a13, a14);
    }
  }
  else
  {
    *((void *)this + 4) = a3;
    *((void *)this + 7) = a5;
    *((void *)this + 10) = a7;
    *((void *)this + 13) = a9;
    *((void *)this + 16) = a11;
    *((void *)this + 19) = a13;
  }
}

void DCSRecord::DCSRecord(DCSRecord *this, DCSDictionary *a2, const unsigned __int16 *a3, size_t a4, const unsigned __int16 *a5, size_t a6, const unsigned __int16 *a7, size_t a8, const unsigned __int16 *a9, size_t a10, const unsigned __int16 *a11, uint64_t a12, const unsigned __int16 *a13, size_t a14, unsigned int a15, BOOL a16, unsigned __int16 a17, unint64_t a18, uint64_t a19, const __CFURL *a20,const __CFString *a21,const __CFURL *a22,const __CFString *a23)
{
}

void DCSRecord::~DCSRecord(DCSRecord *this)
{
  uint64_t v2 = (const void *)*((void *)this + 6);
  if (v2) {
    CFRelease(v2);
  }
  CFStringRef v3 = (const void *)*((void *)this + 9);
  if (v3) {
    CFRelease(v3);
  }
  CFStringRef v4 = (const void *)*((void *)this + 12);
  if (v4) {
    CFRelease(v4);
  }
  CFArrayRef v5 = (const void *)*((void *)this + 15);
  if (v5) {
    CFRelease(v5);
  }
  CFURLRef v6 = (const void *)*((void *)this + 18);
  if (v6) {
    CFRelease(v6);
  }
  CFURLRef v7 = (const void *)*((void *)this + 21);
  if (v7) {
    CFRelease(v7);
  }
  CFIndex v8 = (const void *)*((void *)this + 27);
  if (v8) {
    CFRelease(v8);
  }
  CFIndex v9 = (const void *)*((void *)this + 22);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = (const void *)*((void *)this + 23);
  if (v10) {
    CFRelease(v10);
  }
  CFIndex v11 = (const void *)*((void *)this + 28);
  if (v11) {
    CFRelease(v11);
  }
  CFRelease(*((CFTypeRef *)this + 1));
  if (*((unsigned char *)this + 20))
  {
    stat v12 = (void *)*((void *)this + 4);
    if (v12) {
      free(v12);
    }
    CFStringRef v13 = (void *)*((void *)this + 7);
    if (v13) {
      free(v13);
    }
    int8x8_t v14 = (void *)*((void *)this + 10);
    if (v14) {
      free(v14);
    }
    CFURLRef v15 = (void *)*((void *)this + 13);
    if (v15) {
      free(v15);
    }
    unsigned int v16 = (void *)*((void *)this + 16);
    if (v16) {
      free(v16);
    }
    CFStringRef v17 = (void *)*((void *)this + 19);
    if (v17) {
      free(v17);
    }
  }
}

uint64_t DCSRecord::createRecordRef(DCSRecord *this, DCSDictionary *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int16 *a5, uint64_t a6, const unsigned __int16 *a7, uint64_t a8, const unsigned __int16 *a9, uint64_t a10, const unsigned __int16 *a11, uint64_t a12, const unsigned __int16 *a13, uint64_t a14, unsigned int a15, BOOL a16, unsigned __int16 a17, unint64_t a18, uint64_t a19, const __CFURL *a20,const __CFString *a21)
{
  if (_CFRuntimeCreateInstance()) {
    operator new();
  }
  return 0;
}

void sub_1D590C5F0(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F0C406EFE96A2);
  _Unwind_Resume(a1);
}

uint64_t DCSRecord::createRecordRef(DCSRecord *this, DCSDictionary *a2, const __CFString *a3, uint64_t a4, const __CFURL *a5)
{
  HIWORD(v6) = 0;
  BYTE4(v6) = 0;
  LODWORD(v6) = 256;
  return DCSRecord::createRecordRef(this, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, v6, a3, SBYTE4(a3), HIWORD(a3), 0, a4,
           a2,
           vars0);
}

uint64_t DCSRecord::recordRefClassID(DCSRecord *this)
{
  return _DCSRecordID;
}

CFStringRef DCSRecord::keyString(DCSRecord *this)
{
  CFStringRef result = (CFStringRef)*((void *)this + 6);
  if (!result)
  {
    CFStringRef v3 = (const UInt8 *)*((void *)this + 4);
    if (v3)
    {
      CFStringRef result = CFStringCreateWithBytes(0, v3, *((void *)this + 5), *((_DWORD *)this + 4), 0);
      *((void *)this + 6) = result;
    }
    else
    {
      return (CFStringRef)*((void *)this + 27);
    }
  }
  return result;
}

CFIndex DCSRecord::setKeyString(DCSRecord *this, CFStringRef theString)
{
  CFStringRef v4 = (const void *)*((void *)this + 6);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 6) = CFStringCreateCopy(0, theString);
  CFIndex result = CFStringGetLength(theString);
  *((void *)this + 5) = 2 * result;
  return result;
}

void *DCSRecord::headword(DCSRecord *this)
{
  CFIndex result = (void *)*((void *)this + 22);
  if (!result)
  {
    if (!*((void *)this + 4)) {
      return (void *)*((void *)this + 27);
    }
    if (*((void *)this + 17))
    {
      uint64_t v3 = *((void *)this + 3);
      if ((v3 & 1) != 0 || (v3 & 2) == 0 && *((unsigned char *)this + 21))
      {
        CFStringRef v4 = DCSRecord::yomiString(this);
        CFStringRef v5 = DCSRecord::dataString(this);
      }
      else
      {
        CFStringRef v4 = DCSRecord::dataString(this);
        CFStringRef v5 = DCSRecord::yomiString(this);
      }
      CFStringRef v7 = v5;
      if (CFStringCompare(v4, v5, 0))
      {
        uint64_t v8 = *((void *)this + 3);
        if ((v8 & 8) != 0)
        {
          CFIndex result = (void *)CFStringCreateWithFormat(0, 0, @"%@  %@", v4, v7);
        }
        else if ((v8 & 0x10) != 0)
        {
          CFIndex result = (void *)CFStringCreateWithFormat(0, 0, @"%@ (%@)", v4, v7);
        }
        else
        {
          CFIndex result = (void *)CFStringCreateWithFormat(0, 0, @"%@%C%@%C", v4, 12304, v7, 12305);
        }
        goto LABEL_19;
      }
      CFStringRef v6 = v4;
    }
    else
    {
      CFStringRef v6 = DCSRecord::dataString(this);
    }
    CFIndex result = (void *)CFRetain(v6);
LABEL_19:
    *((void *)this + 22) = result;
  }
  return result;
}

CFStringRef DCSRecord::dataString(DCSRecord *this)
{
  CFStringRef result = (CFStringRef)*((void *)this + 9);
  if (!result)
  {
    uint64_t v3 = (const UInt8 *)*((void *)this + 7);
    if (v3)
    {
      CFStringRef result = CFStringCreateWithBytes(0, v3, *((void *)this + 8), *((_DWORD *)this + 4), 0);
      *((void *)this + 9) = result;
    }
    else
    {
      return DCSRecord::keyString(this);
    }
  }
  return result;
}

CFStringRef DCSRecord::yomiString(DCSRecord *this)
{
  uint64_t v1 = (const UInt8 *)*((void *)this + 16);
  if (!v1) {
    return 0;
  }
  CFStringRef result = (CFStringRef)*((void *)this + 18);
  if (!result)
  {
    CFStringRef result = CFStringCreateWithBytes(0, v1, *((void *)this + 17), *((_DWORD *)this + 4), 0);
    *((void *)this + 18) = result;
  }
  return result;
}

CFStringRef DCSRecord::setHeadword(DCSRecord *this, CFStringRef theString)
{
  CFStringRef v4 = (const void *)*((void *)this + 22);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 22) = CFStringCreateCopy(0, theString);
  CFStringRef v5 = (const void *)*((void *)this + 9);
  if (v5) {
    CFRelease(v5);
  }
  CFStringRef result = CFStringCreateCopy(0, theString);
  *((void *)this + 9) = result;
  return result;
}

CFStringRef DCSRecord::titleString(DCSRecord *this)
{
  uint64_t v2 = (const UInt8 *)*((void *)this + 10);
  if (v2)
  {
    CFStringRef result = (CFStringRef)*((void *)this + 12);
    if (!result)
    {
      CFStringRef result = CFStringCreateWithBytes(0, v2, *((void *)this + 11), *((_DWORD *)this + 4), 0);
      *((void *)this + 12) = result;
    }
  }
  else if (*((uint64_t *)this + 17) < 1)
  {
    return 0;
  }
  else
  {
    return DCSRecord::dataString(this);
  }
  return result;
}

CFStringRef DCSRecord::anchorString(DCSRecord *this)
{
  uint64_t v1 = (const UInt8 *)*((void *)this + 13);
  if (!v1) {
    return 0;
  }
  CFStringRef result = (CFStringRef)*((void *)this + 15);
  if (!result)
  {
    CFStringRef result = CFStringCreateWithBytes(0, v1, *((void *)this + 14), *((_DWORD *)this + 4), 0);
    *((void *)this + 15) = result;
  }
  return result;
}

CFStringRef DCSRecord::sortkeyString(DCSRecord *this)
{
  uint64_t v1 = (const UInt8 *)*((void *)this + 19);
  if (!v1) {
    return 0;
  }
  CFStringRef result = (CFStringRef)*((void *)this + 21);
  if (!result)
  {
    CFStringRef result = CFStringCreateWithBytes(0, v1, *((void *)this + 20), *((_DWORD *)this + 4), 0);
    *((void *)this + 21) = result;
  }
  return result;
}

CFStringRef DCSRecord::headwordSortString(DCSRecord *this, int a2)
{
  if (!*((unsigned char *)this + 21) || a2 && (*((unsigned char *)this + 24) & 2) != 0)
  {
    CFStringRef result = (CFStringRef)*((void *)this + 23);
    if (!result)
    {
      CFStringRef v4 = DCSRecord::dataString(this);
      CFStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v4);
      CFLocaleRef v6 = (const __CFLocale *)DCSDictionary::primaryLocale(*(DCSDictionary **)this);
      DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 1, v6);
      *((void *)this + 23) = MutableCopy;
      CFStringRef v7 = DCSRecord::dataString(this);
      if (CFStringCompare(v7, MutableCopy, 0))
      {
        return (CFStringRef)*((void *)this + 23);
      }
      else
      {
        CFRelease(MutableCopy);
        CFStringRef v8 = DCSRecord::dataString(this);
        CFStringRef result = (CFStringRef)CFRetain(v8);
        *((void *)this + 23) = result;
      }
    }
  }
  else
  {
    CFStringRef result = DCSRecord::yomiString(this);
    if (!result)
    {
      if (!*((void *)this + 7) && (*((unsigned char *)this + 24) & 0x20) != 0)
      {
        return DCSRecord::keyString(this);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t DCSRecord::copyData(DCSDictionary **this)
{
  return DCSDictionary::copyData(*this, (DCSRecord *)this);
}

uint64_t DCSRecord::copyDataURL(DCSDictionary **this)
{
  return DCSDictionary::copyDataURL(*this, (DCSRecord *)this);
}

__CFDictionary *DCSRecord::copyKeyedElements(DCSDictionary **this, const __CFArray *a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (DCSDictionary::previewMarkupVersion(*this) == 1)
  {
    if (DCSRecord::copyKeyedElements(__CFArray const*)::_DispatchOnceToken != -1) {
      dispatch_once(&DCSRecord::copyKeyedElements(__CFArray const*)::_DispatchOnceToken, &__block_literal_global_1);
    }
    if (a2)
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E4F1D510]);
      CFIndex v6 = CFArrayGetCount(a2);
      if (v6 >= 1)
      {
        CFIndex v7 = v6;
        for (CFIndex i = 0; i != v7; ++i)
        {
          CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          v54.CFIndex location = 0;
          v54.CFIndex length = Count;
          FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue((CFArrayRef)DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray, v54, ValueAtIndex);
          if (FirstIndexOfValue != -1)
          {
            CFIndex v11 = CFArrayGetValueAtIndex((CFArrayRef)DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray, FirstIndexOfValue);
            CFArrayAppendValue(Mutable, v11);
          }
        }
      }
    }
    else
    {
      CFMutableArrayRef Mutable = (__CFArray *)CFRetain((CFTypeRef)DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray);
    }
    if (CFArrayGetCount(Mutable) < 1) {
      int8x8_t v14 = 0;
    }
    else {
      int8x8_t v14 = DCSRecord::copyElementsByMarkupText(this, Mutable);
    }
    CFArrayRef v17 = Mutable;
    goto LABEL_72;
  }
  CFRange v51 = this;
  if (a2)
  {
    CFIndex v12 = CFArrayGetCount(a2);
    CFDictionaryRef v13 = (const __CFDictionary *)DCSDictionary::elementXPaths(*this);
    CFRetain(a2);
  }
  else
  {
    CFDictionaryRef v15 = (const __CFDictionary *)DCSDictionary::elementXPaths(*this);
    CFDictionaryRef v13 = v15;
    if (v15)
    {
      CFDictionaryRef v15 = (const __CFDictionary *)CFDictionaryGetCount(v15);
      CFIndex v16 = (CFIndex)v15;
    }
    else
    {
      CFIndex v16 = 0;
    }
    CFIndex v12 = v16 + 3;
    MEMORY[0x1F4188790](v15);
    unsigned int v19 = (const void **)((char *)&v50 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v18 >= 0x200) {
      size_t v20 = 512;
    }
    else {
      size_t v20 = v18;
    }
    bzero((char *)&v50 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0), v20);
    unsigned __int8 v21 = CFArrayCreateMutable(0, v16, MEMORY[0x1E4F1D510]);
    if (v13)
    {
      CFDictionaryGetKeysAndValues(v13, v19, 0);
      if (v16 >= 1)
      {
        uint64_t v22 = (const __CFString **)v19;
        CFIndex v23 = v16;
        do
        {
          CFStringRef v24 = (const __CFString *)_CopyConvertedTextElementKey(*v22, 0);
          if (v24)
          {
            CFStringRef v25 = v24;
            __CFArray *v22 = v24;
            CFArrayAppendValue(v21, v24);
            CFRelease(v25);
          }
          ++v22;
          --v23;
        }
        while (v23);
      }
    }
    unsigned int v26 = &v19[v16];
    const void *v26 = @"DCSTextElementKeyRecordID";
    v26[1] = @"DCSTextElementKeyHeadword";
    v26[2] = @"DCSTextElementKeySensesWithAttributes";
    a2 = CFArrayCreate(0, v19, v16 + 3, MEMORY[0x1E4F1D510]);
    CFRelease(v21);
  }
  CFDictionaryRef v52 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v12 >= 1)
  {
    for (CFIndex j = 0; v12 != j; ++j)
    {
      CFStringRef v28 = (const __CFString *)CFArrayGetValueAtIndex(a2, j);
      CFStringRef v29 = v28;
      if (v13
        && (CFStringCompare(v28, @"DCSTextElementKeySensesWithAttributes", 0)
          ? (CFIndex v30 = (__CFString *)v29)
          : (CFIndex v30 = @"DCSTextElementKeySenses"),
            (CFArrayRef Value = (__CFString *)CFDictionaryGetValue(v13, v30)) != 0
         || (unsigned int v35 = _CopyConvertedTextElementKey(v30, 1)) != 0
         && (v36 = v35, CFArrayRef Value = (__CFString *)CFDictionaryGetValue(v13, v35), CFRelease(v36), Value)))
      {
        int v32 = v52;
        CFStringRef v33 = (__CFString *)v29;
        uint64_t v34 = Value;
      }
      else
      {
        if (CFStringCompare(v29, @"id", 0) && CFStringCompare(v29, @"DCSTextElementKeyRecordID", 0))
        {
          if (CFStringHasPrefix(v29, @"xpath_"))
          {
            CFRange v37 = CFStringFind(v29, @":", 0);
            if (v37.length)
            {
              v56.CFIndex length = CFStringGetLength(v29) - (v37.location + v37.length);
              v56.CFIndex location = v37.location + v37.length;
              CFStringRef v38 = CFStringCreateWithSubstring(0, v29, v56);
              v57.CFIndex location = 0;
              v57.CFIndex length = v37.location + v37.length;
              CFStringRef v39 = CFStringCreateWithSubstring(0, v29, v57);
              CFDictionarySetValue(v52, v39, v38);
              CFRelease(v38);
              CFRelease(v39);
            }
          }
          continue;
        }
        int v32 = v52;
        CFStringRef v33 = @"DCSTextElementKeyRecordID";
        uint64_t v34 = @"//d:entry/@id";
      }
      CFDictionarySetValue(v32, v33, v34);
    }
  }
  if (v13 && (CFDictionaryRef v40 = (const __CFDictionary *)CFDictionaryGetValue(v13, @"namespaces")) != 0) {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v40);
  }
  else {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFStringRef v42 = MutableCopy;
  int v43 = CFDictionaryContainsKey(MutableCopy, @"d");
  CFIndex v44 = v51;
  if (!v43) {
    CFDictionarySetValue(v42, @"d", @"http://www.apple.com/DTDs/DictionaryService-1.0.rng");
  }
  if (CFDictionaryGetCount(v52))
  {
    char v45 = 1;
    CFStringRef v46 = (const __CFString *)DCSDictionary::copyData(*v44, (DCSRecord *)v44);
    CFStringRef v47 = v46;
    if (v46)
    {
      int8x8_t v14 = CopyXPathElementsArray(v46, v52, v42);
      char v45 = 0;
    }
    else
    {
      int8x8_t v14 = 0;
    }
  }
  else
  {
    CFStringRef v47 = 0;
    int8x8_t v14 = 0;
    char v45 = 1;
  }
  v55.CFIndex length = CFArrayGetCount(a2);
  v55.CFIndex location = 0;
  if (CFArrayContainsValue(a2, v55, @"DCSTextElementKeyHeadword")
    && (!v14 || !CFDictionaryContainsKey(v14, @"DCSTextElementKeyHeadword")))
  {
    unsigned int v48 = DCSRecord::titleString((DCSRecord *)v44);
    if (v48 || (unsigned int v48 = DCSRecord::headword((DCSRecord *)v44)) != 0)
    {
      if (!v14) {
        int8x8_t v14 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      CFDictionarySetValue(v14, @"DCSTextElementKeyHeadword", v48);
    }
  }
  CFRelease(v42);
  CFRelease(v52);
  if ((v45 & 1) == 0) {
    CFRelease(v47);
  }
  if (a2)
  {
    CFArrayRef v17 = a2;
LABEL_72:
    CFRelease(v17);
  }
  return v14;
}

CFArrayRef ___ZN9DCSRecord17copyKeyedElementsEPK9__CFArray_block_invoke()
{
  v1[7] = *(const void **)MEMORY[0x1E4F143B8];
  v1[0] = @"DCSTextElementKeyRecordID";
  v1[1] = @"DCSTextElementKeyHeadword";
  v1[2] = @"DCSTextElementKeySyllabifiedHeadword";
  v1[3] = @"DCSTextElementKeyPartOfSpeech";
  v1[4] = @"DCSTextElementKeyPronunciation";
  v1[5] = @"DCSTextElementKeySenses";
  v1[6] = @"DCSTextElementKeySensesWithAttributes";
  CFArrayRef result = CFArrayCreate(0, v1, 7, MEMORY[0x1E4F1D510]);
  DCSRecord::copyKeyedElements(__CFArray const*)::_DefinedKeyArray = (uint64_t)result;
  return result;
}

__CFDictionary *DCSRecord::copyElementsByMarkupText(DCSDictionary **this, const __CFArray *a2)
{
  CFStringRef v3 = (const __CFString *)DCSDictionary::copyData(*this, (DCSRecord *)this);
  if (!v3) {
    return 0;
  }
  CFStringRef v4 = v3;
  CFIndex Length = CFStringGetLength(v3);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(Mutable, @"amp", @"&");
  CFDictionaryAddValue(Mutable, @"quot", @"\"");
  CFDictionaryAddValue(Mutable, @"lt", @"<");
  CFDictionaryAddValue(Mutable, @"gt", @">");
  CFDictionaryAddValue(Mutable, @"apos", @"'");
  CFStringRef theString = v4;
  uint64_t v108 = 0;
  CFIndex v109 = Length - 1;
  CharactersPtr = CFStringGetCharactersPtr(v4);
  CStringPtr = 0;
  v106 = (CFRange *)CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v4, 0x600u);
  }
  CFIndex v110 = 0;
  CFIndex v111 = 0;
  v107 = CStringPtr;
  CFIndex v9 = CFStringCreateMutable(0, 0);
  CFArrayRef v98 = a2;
  CFStringRef v100 = v9;
  if (Length >= 1)
  {
    CFIndex v10 = 0;
    CFIndex v11 = 0;
    v101 = Mutable;
    CFStringRef v102 = v4;
    while (1)
    {
      if (v11 < 0 || (CFIndex v12 = v109, v109 <= v11))
      {
        int64_t v16 = v11 + 1;
        goto LABEL_12;
      }
      CFDictionaryRef v13 = v106;
      if (v106) {
        break;
      }
      if (!v107)
      {
        if (v111 <= v11 || (CFIndex v22 = v110, v110 > v11))
        {
          CFIndex v23 = v11 - 4;
          if ((unint64_t)v11 < 4) {
            CFIndex v23 = 0;
          }
          if (v23 + 64 < v109) {
            CFIndex v12 = v23 + 64;
          }
          CFIndex v110 = v23;
          CFIndex v111 = v12;
          v112.CFIndex location = v108 + v23;
          v112.CFIndex length = v12 - v23;
          CFStringGetCharacters(theString, v112, (UniChar *)buffer);
          CFIndex v22 = v110;
        }
        CFIndex v14 = v11 - v22;
        CFDictionaryRef v13 = buffer;
        goto LABEL_10;
      }
      __int16 v15 = v107[v108 + v11];
LABEL_16:
      int64_t v16 = v11 + 1;
      if (v15 == 38)
      {
        if (v11 > v10)
        {
          v118.CFIndex location = v10;
          v118.CFIndex length = v11 - v10;
          CFStringRef v17 = CFStringCreateWithSubstring(0, v4, v118);
          CFStringAppend(v9, v17);
          CFRelease(v17);
        }
        CFIndex v18 = v109;
        if (v109 <= v16)
        {
          unsigned __int16 v21 = 0;
          int64_t v16 = v11 + 2;
        }
        else
        {
          unsigned int v19 = v106;
          if (v106)
          {
            int64_t v20 = v108 + v16;
            goto LABEL_22;
          }
          if (v107)
          {
            unsigned __int16 v21 = v107[v108 + v16];
          }
          else
          {
            if (v111 <= v16 || (CFIndex v39 = v110, v110 > v16))
            {
              CFIndex v40 = v11 - 3;
              if ((unint64_t)v11 < 3) {
                CFIndex v40 = 0;
              }
              if (v40 + 64 < v109) {
                CFIndex v18 = v40 + 64;
              }
              CFIndex v110 = v40;
              CFIndex v111 = v18;
              v114.CFIndex location = v108 + v40;
              v114.CFIndex length = v18 - v40;
              CFStringGetCharacters(theString, v114, (UniChar *)buffer);
              CFIndex v39 = v110;
            }
            int64_t v20 = v16 - v39;
            unsigned int v19 = buffer;
LABEL_22:
            unsigned __int16 v21 = *((_WORD *)&v19->location + v20);
          }
          int64_t v16 = v11 + 2;
          if (v21 == 35)
          {
            CFIndex v24 = v109;
            if (v109 <= v16)
            {
              char v38 = 0;
              unsigned __int16 v21 = 0;
              int64_t v16 = v11 + 3;
            }
            else
            {
              CFStringRef v25 = v106;
              if (v106)
              {
                int64_t v26 = v108 + v16;
                goto LABEL_38;
              }
              if (v107)
              {
                unsigned __int16 v21 = v107[v108 + v16];
              }
              else
              {
                if (v111 <= v16 || (CFIndex v64 = v110, v110 > v16))
                {
                  CFIndex v65 = v11 - 2;
                  if ((unint64_t)v11 < 2) {
                    CFIndex v65 = 0;
                  }
                  if (v65 + 64 < v109) {
                    CFIndex v24 = v65 + 64;
                  }
                  CFIndex v110 = v65;
                  CFIndex v111 = v24;
                  v116.CFIndex location = v108 + v65;
                  v116.CFIndex length = v24 - v65;
                  CFStringGetCharacters(theString, v116, (UniChar *)buffer);
                  CFIndex v64 = v110;
                }
                int64_t v26 = v16 - v64;
                CFStringRef v25 = buffer;
LABEL_38:
                unsigned __int16 v21 = *((_WORD *)&v25->location + v26);
              }
              int64_t v16 = v11 + 3;
              if (v21 == 120)
              {
                CFIndex v41 = v109;
                if (v109 <= v16)
                {
                  unsigned __int16 v21 = 0;
                }
                else
                {
                  CFStringRef v42 = v106;
                  if (v106)
                  {
                    int64_t v43 = v108 + v16;
                    goto LABEL_80;
                  }
                  if (v107)
                  {
                    unsigned __int16 v21 = v107[v108 + v16];
                  }
                  else
                  {
                    if (v111 <= v16 || (CFIndex v66 = v110, v110 > v16))
                    {
                      CFIndex v67 = v11 - 1;
                      if (!v11) {
                        CFIndex v67 = 0;
                      }
                      if (v67 + 64 < v109) {
                        CFIndex v41 = v67 + 64;
                      }
                      CFIndex v110 = v67;
                      CFIndex v111 = v41;
                      v117.CFIndex location = v108 + v67;
                      v117.CFIndex length = v41 - v67;
                      CFStringGetCharacters(theString, v117, (UniChar *)buffer);
                      CFIndex v66 = v110;
                    }
                    int64_t v43 = v16 - v66;
                    CFStringRef v42 = buffer;
LABEL_80:
                    unsigned __int16 v21 = *((_WORD *)&v42->location + v43);
                  }
                }
                int64_t v16 = v11 + 4;
                int v44 = 16;
                char v38 = 1;
LABEL_85:
                unsigned int v27 = 0;
                if (Length <= v16) {
                  int64_t v45 = v16;
                }
                else {
                  int64_t v45 = Length;
                }
                int64_t v46 = -v16;
                for (int64_t i = v16 + 64; ; ++i)
                {
                  if ((unint64_t)v16 >= 4) {
                    uint64_t v48 = 4;
                  }
                  else {
                    uint64_t v48 = v16;
                  }
                  if ((unsigned __int16)(v21 - 48) > 9u)
                  {
                    char v50 = v38 ^ 1;
                    if ((unsigned __int16)(v21 - 97) > 5u) {
                      char v51 = 1;
                    }
                    else {
                      char v51 = v38 ^ 1;
                    }
                    if (v51)
                    {
                      if ((unsigned __int16)(v21 - 65) > 5u) {
                        char v50 = 1;
                      }
                      if (v50)
                      {
                        a2 = v98;
                        CFIndex v9 = (__CFString *)v100;
                        CFMutableArrayRef Mutable = v101;
                        CFStringRef v4 = v102;
                        goto LABEL_40;
                      }
                      int v49 = 16 * v27 - 55;
                    }
                    else
                    {
                      int v49 = 16 * v27 - 87;
                    }
                  }
                  else
                  {
                    int v49 = v27 * v44 - 48;
                  }
                  unsigned int v27 = v49 + v21;
                  if (v45 == v16)
                  {
                    int64_t v16 = v45;
                    a2 = v98;
                    CFIndex v9 = (__CFString *)v100;
                    CFMutableArrayRef Mutable = v101;
                    CFStringRef v4 = v102;
                    goto LABEL_121;
                  }
                  if (v16 < 0 || (CFIndex v52 = v109, v109 <= v16))
                  {
                    unsigned __int16 v21 = 0;
                  }
                  else if (v106)
                  {
                    unsigned __int16 v21 = *((_WORD *)&v106->location + v16 + v108);
                  }
                  else if (v107)
                  {
                    unsigned __int16 v21 = v107[v108 + v16];
                  }
                  else
                  {
                    if (v111 <= v16 || (CFIndex v53 = v110, v110 > v16))
                    {
                      uint64_t v54 = v48 + v46;
                      CFIndex v55 = i - v48;
                      int64_t v56 = v16 - v48;
                      int64_t v57 = v56 + 64;
                      if (v56 + 64 >= v109) {
                        int64_t v57 = v109;
                      }
                      CFIndex v110 = v56;
                      CFIndex v111 = v57;
                      if (v109 >= v55) {
                        CFIndex v52 = v55;
                      }
                      v115.CFIndex length = v52 + v54;
                      v115.CFIndex location = v56 + v108;
                      CFStringGetCharacters(theString, v115, (UniChar *)buffer);
                      CFIndex v53 = v110;
                    }
                    unsigned __int16 v21 = *((_WORD *)&buffer[0].location + v16 - v53);
                  }
                  ++v16;
                  --v46;
                }
              }
              char v38 = 0;
            }
            int v44 = 10;
            goto LABEL_85;
          }
        }
        unsigned int v27 = 0xFFFF;
LABEL_40:
        if (v21 != 59 && v16 < Length)
        {
          int64_t v28 = -v16;
          int64_t v29 = v16 + 64;
          do
          {
            if ((unint64_t)v16 >= 4) {
              uint64_t v30 = 4;
            }
            else {
              uint64_t v30 = v16;
            }
            if (v16 < 0 || (CFIndex v31 = v109, v109 <= v16))
            {
              __int16 v32 = 0;
            }
            else if (v106)
            {
              __int16 v32 = *((_WORD *)&v106->location + v16 + v108);
            }
            else if (v107)
            {
              __int16 v32 = v107[v108 + v16];
            }
            else
            {
              if (v111 <= v16 || (CFIndex v33 = v110, v110 > v16))
              {
                uint64_t v34 = v30 + v28;
                CFIndex v35 = v29 - v30;
                int64_t v36 = v16 - v30;
                int64_t v37 = v36 + 64;
                if (v36 + 64 >= v109) {
                  int64_t v37 = v109;
                }
                CFIndex v110 = v36;
                CFIndex v111 = v37;
                if (v109 >= v35) {
                  CFIndex v31 = v35;
                }
                v113.CFIndex length = v31 + v34;
                v113.CFIndex location = v36 + v108;
                CFStringGetCharacters(theString, v113, (UniChar *)buffer);
                CFIndex v33 = v110;
              }
              __int16 v32 = *((_WORD *)&buffer[0].location + v16 - v33);
            }
            ++v16;
            if (v32 == 59) {
              break;
            }
            --v28;
            ++v29;
          }
          while (v16 < Length);
          a2 = v98;
        }
LABEL_121:
        if (v27 == 0xFFFF)
        {
          v119.CFIndex length = v16 - v11 - 2;
          v119.CFIndex location = v11 + 1;
          CFStringRef v58 = CFStringCreateWithSubstring(0, v4, v119);
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(Mutable, v58);
          if (Value)
          {
            CFStringRef v60 = Value;
            v61 = v9;
          }
          else
          {
            CFRelease(v58);
            v120.CFIndex location = v11;
            v120.CFIndex length = v16 - v11;
            CFStringRef v58 = CFStringCreateWithSubstring(0, v4, v120);
            v61 = v9;
            CFStringRef v60 = v58;
          }
          CFStringAppend(v61, v60);
          CFRelease(v58);
        }
        else
        {
          if (v27 < 0x10000)
          {
            LOWORD(range.length) = v27;
            CFArrayRef v62 = v9;
            CFIndex v63 = 1;
          }
          else
          {
            LOWORD(range.length) = ((v27 + 67043328) >> 10) - 10240;
            WORD1(range.length) = v27 & 0x3FF | 0xDC00;
            CFArrayRef v62 = v9;
            CFIndex v63 = 2;
          }
          CFStringAppendCharacters(v62, (const UniChar *)&range.length, v63);
        }
        CFIndex v10 = v16;
      }
LABEL_12:
      CFIndex v11 = v16;
      if (v16 >= Length) {
        goto LABEL_151;
      }
    }
    CFIndex v14 = v108 + v11;
LABEL_10:
    __int16 v15 = *((_WORD *)&v13->location + v14);
    goto LABEL_16;
  }
  int64_t v16 = 0;
  CFIndex v10 = 0;
LABEL_151:
  if (v10 < Length)
  {
    v121.CFIndex length = v16 - v10;
    v121.CFIndex location = v10;
    CFStringRef v68 = CFStringCreateWithSubstring(0, v4, v121);
    CFStringAppend(v9, v68);
    CFRelease(v68);
  }
  CFRelease(Mutable);
  if (v9) {
    CFRelease(v4);
  }
  else {
    CFStringRef v100 = v4;
  }
  uint64_t Count = CFArrayGetCount(a2);
  CFMutableDictionaryRef v70 = CFDictionaryCreateMutable(0, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  v71 = v70;
  if (Count >= 1)
  {
    CFIndex v72 = 0;
    v97 = v70;
    while (1)
    {
      CFURLRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(a2, v72);
      if (ValueAtIndex != @"DCSTextElementKeyRecordID") {
        break;
      }
      CFIndex v76 = CFStringGetLength(v100);
      CFStringRef v77 = CFStringCreateWithFormat(0, 0, @"<%@ ", @"d:entry");
      v122.CFIndex location = 0;
      v122.CFIndex length = v76;
      int v78 = CFStringFindWithOptions(v100, v77, v122, 0, buffer);
      CFRelease(v77);
      if (!v78) {
        goto LABEL_200;
      }
      CFIndex location = buffer[0].location;
      v123.CFIndex length = v76 - buffer[0].location;
      v123.CFIndex location = buffer[0].location;
      if (!CFStringFindWithOptions(v100, @">", v123, 0, buffer)) {
        goto LABEL_200;
      }
      CFIndex v80 = buffer[0].location - location;
      CFStringRef v81 = CFStringCreateWithFormat(0, 0, @"%@=\"", @"id");
      v124.CFIndex location = location;
      v124.CFIndex length = v80;
      if (!CFStringFindWithOptions(v100, v81, v124, 0, buffer)
        || (CFIndex v82 = buffer[0].length + buffer[0].location,
            v125.CFIndex length = v76 - (buffer[0].length + buffer[0].location),
            v125.CFIndex location = buffer[0].length + buffer[0].location,
            !CFStringFindWithOptions(v100, @"\"", v125, 0, buffer)))
      {
        CFRelease(v81);
        goto LABEL_200;
      }
      v126.CFIndex length = buffer[0].location - v82;
      buffer[0].CFIndex location = v82;
      buffer[0].CFIndex length = v126.length;
      v126.CFIndex location = v82;
      ExtractedStringsMarkedByTag = CFStringCreateWithSubstring(0, v100, v126);
      CFRelease(v81);
      if (ExtractedStringsMarkedByTag)
      {
        v84 = v71;
        v85 = @"DCSTextElementKeyRecordID";
LABEL_198:
        CFDictionarySetValue(v84, v85, ExtractedStringsMarkedByTag);
        CFRelease(ExtractedStringsMarkedByTag);
      }
LABEL_200:
      if (++v72 == Count) {
        goto LABEL_201;
      }
    }
    v74 = ValueAtIndex;
    if (ValueAtIndex != @"DCSTextElementKeyPartOfSpeech"
      && ValueAtIndex != @"DCSTextElementKeyPronunciation"
      && ValueAtIndex != @"DCSTextElementKeySenses"
      && ValueAtIndex != @"DCSTextElementKeySensesWithAttributes"
      && ValueAtIndex != @"DCSTextElementKeySyllabifiedHeadword")
    {
      if (ValueAtIndex == @"DCSTextElementKeyHeadword")
      {
        char v75 = DCSRecord::titleString((DCSRecord *)this);
        if (v75 || (char v75 = DCSRecord::headword((DCSRecord *)this)) != 0) {
          CFDictionarySetValue(v71, @"DCSTextElementKeyHeadword", v75);
        }
      }
      goto LABEL_200;
    }
    v86 = @"d:def";
    if (ValueAtIndex == @"DCSTextElementKeySyllabifiedHeadword") {
      v86 = @"d:syl";
    }
    if (ValueAtIndex == @"DCSTextElementKeyPronunciation") {
      v86 = @"d:prn";
    }
    if (ValueAtIndex == @"DCSTextElementKeyPartOfSpeech") {
      CFStringRef v87 = @"d:pos";
    }
    else {
      CFStringRef v87 = v86;
    }
    int v88 = ValueAtIndex == @"DCSTextElementKeySensesWithAttributes"
       || ValueAtIndex == @"DCSTextElementKeySenses";
    if (ValueAtIndex == @"DCSTextElementKeySensesWithAttributes")
    {
      range.CFIndex length = (CFIndex)@"d:prtl";
      buffer[0].CFIndex location = (CFIndex)@"DCSTextElementSenseKeyIsExplicit";
      CFDictionaryRef v90 = CFDictionaryCreate(0, (const void **)buffer, (const void **)&range.length, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      ExtractedStringsMarkedByTag = _CreateExtractedStringsMarkedByTag(v100, v87, @"1", v90, v88);
      if (v90) {
        CFRelease(v90);
      }
      if (!ExtractedStringsMarkedByTag) {
        goto LABEL_200;
      }
      CFIndex v91 = CFArrayGetCount((CFArrayRef)ExtractedStringsMarkedByTag);
      if (v91 >= 1)
      {
        CFIndex v92 = v91;
        for (CFIndex j = 0; j != v92; ++j)
        {
          CFDictionaryRef v94 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)ExtractedStringsMarkedByTag, j);
          v95 = CFDictionaryGetValue(v94, @"temp_text");
          CFDictionarySetValue(v94, @"DCSTextElementSenseKeyText", v95);
          CFDictionaryRemoveValue(v94, @"temp_text");
        }
        a2 = v98;
        v71 = v97;
      }
    }
    else
    {
      if (v88) {
        CFStringRef v89 = @"1";
      }
      else {
        CFStringRef v89 = 0;
      }
      ExtractedStringsMarkedByTag = _CreateExtractedStringsMarkedByTag(v100, v87, v89, 0, v88);
      if (!ExtractedStringsMarkedByTag) {
        goto LABEL_200;
      }
    }
    v84 = v71;
    v85 = v74;
    goto LABEL_198;
  }
LABEL_201:
  CFRelease(v100);
  if (!CFDictionaryGetCount(v71))
  {
    CFRelease(v71);
    return 0;
  }
  return v71;
}

const void *_CopyConvertedTextElementKey(const __CFString *key, int a2)
{
  if (_CopyConvertedTextElementKey(__CFString const*,BOOL)::_DispatchOnceToken != -1) {
    dispatch_once(&_CopyConvertedTextElementKey(__CFString const*,BOOL)::_DispatchOnceToken, &__block_literal_global_79);
  }
  CFStringRef v4 = &_CopyConvertedTextElementKey(__CFString const*,BOOL)::_NewToOldDict;
  if (!a2) {
    CFStringRef v4 = &_CopyConvertedTextElementKey(__CFString const*,BOOL)::_OldToNewDict;
  }
  CFDictionaryRef v5 = (const __CFDictionary *)*v4;

  return CFDictionaryGetValue(v5, key);
}

uint64_t DCSRecord::dictionaryRef(DCSRecord *this)
{
  return **(void **)this;
}

uint64_t DCSRecord::subDictionaryRef(DCSRecord *this)
{
  uint64_t v1 = *((void *)this + 29);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

__CFArray *_CreateExtractedStringsMarkedByTag(const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4, int a5)
{
  int v57 = a5;
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(a1);
  if (a3) {
    CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"%@=\"%@\"", a2, a3);
  }
  else {
    CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"%@=\"", a2);
  }
  CFStringRef v59 = v10;
  CFStringRef v58 = CFStringCreateWithFormat(0, 0, @"<%@></%@>", a2, a2);
  CFIndex Count = (CFIndex)CFStringCreateWithFormat(0, 0, @"<%@/>", a2);
  CFStringRef v12 = (const __CFString *)Count;
  if (a4)
  {
    CFIndex Count = CFDictionaryGetCount(a4);
    uint64_t v13 = Count;
  }
  else
  {
    uint64_t v13 = 0;
  }
  MEMORY[0x1F4188790](Count);
  unint64_t v15 = (v14 + 23) & 0xFFFFFFFFFFFFFFF0;
  int64_t v16 = (const void **)((char *)&v49 - v15);
  if ((unint64_t)(8 * v13 + 8) >= 0x200) {
    size_t v17 = 512;
  }
  else {
    size_t v17 = 8 * v13 + 8;
  }
  bzero((char *)&v49 - v15, v17);
  MEMORY[0x1F4188790](v18);
  unsigned int v19 = (char *)&v49 - v15;
  bzero(v19, v17);
  if (v13 >= 1) {
    CFDictionaryGetKeysAndValues(a4, v16, (const void **)v19);
  }
  CFIndex v55 = v16;
  CFStringRef v20 = v59;
  v65.CFIndex location = 0;
  v65.CFIndex length = Length;
  if (!CFStringFindWithOptions(a1, v59, v65, 0, &result))
  {
    CFMutableArrayRef Mutable = 0;
    CFStringRef v39 = 0;
LABEL_66:
    int v40 = v57;
    goto LABEL_67;
  }
  char v51 = (const __CFString **)v19;
  CFIndex v52 = &v49;
  uint64_t v53 = v13;
  CFStringRef v56 = v12;
  CFMutableArrayRef Mutable = 0;
  CFIndex v22 = 0;
  CFIndex v23 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFIndex v24 = (const void *)*MEMORY[0x1E4F1CFC8];
  CFIndex v25 = Length;
  CFIndex v54 = Length;
  while (2)
  {
    CFIndex location = result.location;
    v66.CFIndex location = 0;
    v66.CFIndex length = result.location;
    if (!CFStringFindWithOptions(a1, @"<", v66, 4uLL, &v62)) {
      goto LABEL_60;
    }
    v67.CFIndex location = 0;
    v67.CFIndex length = location;
    if (CFStringFindWithOptions(a1, @">", v67, 4uLL, &v61) && v62.location <= v61.location) {
      goto LABEL_60;
    }
    int64_t v28 = Mutable;
    v68.CFIndex length = CFStringGetLength(a1) - location;
    v68.CFIndex location = location;
    int v29 = CFStringFindWithOptions(a1, @">", v68, 0, &v61);
    if (v29) {
      CFIndex v30 = v61.location - v62.location;
    }
    else {
      CFIndex v30 = 0;
    }
    if (v29) {
      CFIndex v31 = v62.location;
    }
    else {
      CFIndex v31 = -1;
    }
    if (v29) {
      CFIndex v32 = v61.location + 1;
    }
    else {
      CFIndex v32 = 0;
    }
    v69.CFIndex location = v32;
    v69.CFIndex length = Length - v32;
    if (!CFStringFindWithOptions(a1, v58, v69, 0, &result))
    {
      v70.CFIndex location = v32;
      v70.CFIndex length = Length - v32;
      if (!CFStringFindWithOptions(a1, v56, v70, 0, &result))
      {
        CFStringRef v39 = 0;
        CFStringRef v12 = v56;
        int v40 = v57;
        CFMutableArrayRef Mutable = v28;
        CFStringRef v20 = v59;
        goto LABEL_67;
      }
    }
    CFIndex v33 = result.location - v32;
    uint64_t v34 = (UniChar *)malloc_type_malloc(2 * (result.location - v32), 0xC18A7B23uLL);
    v64.CFIndex location = v32;
    v64.CFIndex length = v33;
    CFStringGetCharacters(a1, v64, v34);
    CFMutableArrayRef Mutable = v28;
    CFStringRef v20 = v59;
    if (v33 < 1) {
      goto LABEL_62;
    }
    uint64_t v35 = 0;
    char v36 = 0;
    CFIndex v37 = 0;
    do
    {
      while (1)
      {
        int v38 = v34[v35];
        if (v38 == 60)
        {
          char v36 = 1;
          goto LABEL_41;
        }
        if (v36)
        {
          v36 &= v38 != 62;
          goto LABEL_41;
        }
        if (v37 || v38 != 32) {
          break;
        }
        char v36 = 0;
        CFIndex v37 = 0;
        if (++v35 == v33) {
          goto LABEL_62;
        }
      }
      char v36 = 0;
      v34[v37++] = v38;
LABEL_41:
      ++v35;
    }
    while (v35 != v33);
    if (v37 < 1)
    {
      if (v37) {
        goto LABEL_47;
      }
LABEL_62:
      free(v34);
      goto LABEL_63;
    }
    while (v34[v37 - 1] == 32)
    {
      if ((unint64_t)v37-- <= 1) {
        goto LABEL_62;
      }
    }
LABEL_47:
    CFStringRef v39 = CFStringCreateWithCharacters(0, v34, v37);
    free(v34);
    if (!v39)
    {
LABEL_64:
      CFStringRef v12 = v56;
      goto LABEL_66;
    }
    int v40 = v57;
    if (v57)
    {
      if (!Mutable) {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      }
      uint64_t v41 = v53;
      if (v53 < 1)
      {
        CFArrayAppendValue(Mutable, v39);
      }
      else
      {
        CFMutableArrayRef v50 = Mutable;
        CFStringRef v42 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        int64_t v43 = v51;
        int v44 = v55;
        do
        {
          CFStringRef v45 = *v43++;
          v71.CFIndex location = v31;
          v71.CFIndex length = v30;
          if (CFStringFindWithOptions(a1, v45, v71, 0, 0)) {
            int64_t v46 = v23;
          }
          else {
            int64_t v46 = v24;
          }
          CFStringRef v47 = *v44++;
          CFDictionarySetValue(v42, v47, v46);
          --v41;
        }
        while (v41);
        CFDictionarySetValue(v42, @"temp_text", v39);
        CFMutableArrayRef Mutable = v50;
        CFArrayAppendValue(v50, v42);
        CFRelease(v42);
        CFStringRef v20 = v59;
      }
      CFRelease(v39);
      CFIndex v22 = result.length + result.location;
      CFIndex Length = v54;
      CFIndex v25 = v54 - (result.length + result.location);
LABEL_60:
      v72.CFIndex location = v22;
      v72.CFIndex length = v25;
      if (!CFStringFindWithOptions(a1, v20, v72, 0, &result))
      {
LABEL_63:
        CFStringRef v39 = 0;
        goto LABEL_64;
      }
      continue;
    }
    break;
  }
  CFStringRef v12 = v56;
LABEL_67:
  CFRelease(v20);
  CFRelease(v58);
  CFRelease(v12);
  if (v40) {
    return Mutable;
  }
  else {
    return (__CFArray *)v39;
  }
}

CFDictionaryRef ___ZL28_CopyConvertedTextElementKeyPK10__CFStringb_block_invoke()
{
  keys[4] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"DCSTextElementKeySyllabifiedHeadword";
  keys[1] = @"DCSTextElementKeyPartOfSpeech";
  keys[2] = @"DCSTextElementKeyPronunciation";
  keys[3] = @"DCSTextElementKeySenses";
  v3[0] = xmmword_1E6A592F8;
  v3[1] = *(_OWORD *)off_1E6A59308;
  v0 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v1 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  _CopyConvertedTextElementKey(__CFString const*,BOOL)::_NewToOldDict = (uint64_t)CFDictionaryCreate(0, (const void **)keys, (const void **)v3, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryRef result = CFDictionaryCreate(0, (const void **)v3, (const void **)keys, 4, v0, v1);
  _CopyConvertedTextElementKey(__CFString const*,BOOL)::_OldToNewDict = (uint64_t)result;
  return result;
}

uint64_t _DCSRecordInitialize(void)
{
  uint64_t result = _CFRuntimeRegisterClass();
  _DCSRecordID = result;
  return result;
}

uint64_t _DCSRecordFinalize(uint64_t result)
{
  if (*(void *)(result + 16))
  {
    DCSRecord::~DCSRecord(*(DCSRecord **)(result + 16));
    JUMPOUT(0x1D94553C0);
  }
  return result;
}

void sub_1D590E680(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F0C406EFE96A2);
  _Unwind_Resume(a1);
}

BOOL _DCSRecordEqual(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a2[2];
  size_t v4 = *(void *)(v2 + 40);
  if (v4 != *(void *)(v3 + 40)) {
    return 0;
  }
  size_t v5 = *(void *)(v2 + 64);
  if (v5 != *(void *)(v3 + 64)) {
    return 0;
  }
  size_t v6 = *(void *)(v2 + 88);
  if (v6 != *(void *)(v3 + 88)) {
    return 0;
  }
  size_t v7 = *(void *)(v2 + 136);
  if (v7 != *(void *)(v3 + 136) || *(void *)v2 != *(void *)v3) {
    return 0;
  }
  CFStringRef v8 = *(void **)(v2 + 232);
  if (v8) {
    CFStringRef v8 = (void *)*v8;
  }
  CFIndex v9 = *(void **)(v3 + 232);
  if (v9) {
    CFIndex v9 = (void *)*v9;
  }
  if (v8 != v9) {
    return 0;
  }
  if (*(void *)(v2 + 208) != *(void *)(v3 + 208)) {
    return 0;
  }
  if (*(unsigned __int16 *)(v2 + 192) != *(unsigned __int16 *)(v3 + 192)) {
    return 0;
  }
  CFStringRef v10 = *(const void **)(v2 + 32);
  if (v10)
  {
    if (memcmp(v10, *(const void **)(v3 + 32), v4)) {
      return 0;
    }
  }
  CFIndex v11 = *(const void **)(v2 + 56);
  if (v11)
  {
    if (memcmp(v11, *(const void **)(v3 + 56), v5)) {
      return 0;
    }
  }
  CFStringRef v12 = *(const void **)(v2 + 80);
  if (v12)
  {
    if (memcmp(v12, *(const void **)(v3 + 80), v6)) {
      return 0;
    }
  }
  uint64_t v14 = *(const void **)(v2 + 128);
  return !v14 || memcmp(v14, *(const void **)(v3 + 128), v7) == 0;
}

CFStringRef _DCSRecordCopyFormattingDesc(void *a1, const __CFDictionary *a2)
{
  uint64_t v3 = (DCSRecord *)a1[2];
  CFAllocatorRef v4 = CFGetAllocator(a1);
  size_t v5 = DCSRecord::headword(v3);
  return CFStringCreateWithFormat(v4, a2, @"<%@>", v5);
}

CFStringRef _DCSRecordCopyDebugDesc(void *a1)
{
  uint64_t v1 = (DCSRecord *)a1[2];
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFStringRef v3 = DCSRecord::keyString(v1);
  CFAllocatorRef v4 = DCSRecord::headword(v1);
  return CFStringCreateWithFormat(v2, 0, @"<DCSRecordRef %p>{key = %@, headword = %@, bodyID = %d}", v1, v3, v4, *((void *)v1 + 26));
}

BOOL IsManagedConfigProfanityFilterForced()
{
  if (_GetManagedConfigFrameworkInfo__DispatchOnceToken != -1) {
    dispatch_once(&_GetManagedConfigFrameworkInfo__DispatchOnceToken, &__block_literal_global_59);
  }
  uint64_t v0 = _GetManagedConfigFrameworkInfo__InfoPtr;
  if (!_GetManagedConfigFrameworkInfo__InfoPtr) {
    return 0;
  }
  uint64_t v1 = (void *)NewAutoReleasePool();
  unsigned int v2 = objc_msgSend(objc_msgSend(*(id *)(v0 + 8), sel_sharedConnection), sel_effectiveBoolValueForSetting_, *(void *)(v0 + 16));

  return v2 == 1;
}

void SetManagedConfigChangedCallback(uint64_t a1)
{
  if (_GetManagedConfigFrameworkInfo__DispatchOnceToken != -1) {
    dispatch_once(&_GetManagedConfigFrameworkInfo__DispatchOnceToken, &__block_literal_global_59);
  }
  if (_GetManagedConfigFrameworkInfo__InfoPtr)
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __SetManagedConfigChangedCallback_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = _GetManagedConfigFrameworkInfo__InfoPtr;
    if (SetManagedConfigChangedCallback__DispatchOnceToken != -1) {
      dispatch_once(&SetManagedConfigChangedCallback__DispatchOnceToken, block);
    }
    if (SetManagedConfigChangedCallback__MyReceiverObj) {
      objc_msgSend((id)SetManagedConfigChangedCallback__MyReceiverObj, sel_setCallbackBlock_, a1);
    }
  }
}

IMP __SetManagedConfigChangedCallback_block_invoke(uint64_t a1)
{
  Class = objc_getClass("NSObject");
  SetManagedConfigChangedCallback__MyClass = (uint64_t)objc_allocateClassPair(Class, "DCSManagedConfigChangeReceiver", 0);
  BOOL v3 = class_addIvar((Class)SetManagedConfigChangedCallback__MyClass, "_callbackBlock", 8uLL, 3u, "@");
  objc_registerClassPair((Class)SetManagedConfigChangedCallback__MyClass);
  if (v3)
  {
    CFAllocatorRef v4 = imp_implementationWithBlock(&__block_literal_global_2);
    BOOL v5 = class_addMethod((Class)SetManagedConfigChangedCallback__MyClass, sel_setCallbackBlock_, v4, "v@:@");
    IMP result = imp_implementationWithBlock(&__block_literal_global_12);
    if (v5)
    {
      IMP result = (IMP)class_addMethod((Class)SetManagedConfigChangedCallback__MyClass, sel_profileConnectionDidReceiveEffectiveSettingsChangedNotification_userInfo_, result, "v@:@@");
      if (result)
      {
        SetManagedConfigChangedCallback__MyReceiverObCFIndex j = (uint64_t)objc_msgSend((id)SetManagedConfigChangedCallback__MyClass, sel_new);
        id v7 = objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), sel_sharedConnection);
        uint64_t v8 = SetManagedConfigChangedCallback__MyReceiverObj;
        return (IMP)objc_msgSend(v7, sel_addObserver_, v8);
      }
    }
  }
  else
  {
    if (SetManagedConfigChangedCallback__MyClass) {
      objc_disposeClassPair((Class)SetManagedConfigChangedCallback__MyClass);
    }
    SetManagedConfigChangedCallback__MyClass = 0;
    imp_implementationWithBlock(&__block_literal_global_2);
    return imp_implementationWithBlock(&__block_literal_global_12);
  }
  return result;
}

void __SetManagedConfigChangedCallback_block_invoke_2(uint64_t a1, void *a2, const void *a3)
{
  InstanceVariable = class_getInstanceVariable((Class)SetManagedConfigChangedCallback__MyClass, "_callbackBlock");
  id Ivar = object_getIvar(a2, InstanceVariable);
  if (Ivar) {

  }
  id v7 = _Block_copy(a3);

  object_setIvar(a2, InstanceVariable, v7);
}

id __SetManagedConfigChangedCallback_block_invoke_3(uint64_t a1, void *a2)
{
  InstanceVariable = class_getInstanceVariable((Class)SetManagedConfigChangedCallback__MyClass, "_callbackBlock");
  id result = object_getIvar(a2, InstanceVariable);
  if (result)
  {
    BOOL v5 = (uint64_t (*)(void))*((void *)result + 2);
    return (id)v5();
  }
  return result;
}

void AddLinguisticDataAssetion(uint64_t a1, const __CFArray *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  DCSLog(16, @"AddLinguisticDataAssetion_iOS for dictionary (%@) with languages (%@)", a1, a2);
  if (a1 && a2)
  {
    if (_GetTextInputFrameworkInfo__DispatchOnceToken != -1) {
      dispatch_once(&_GetTextInputFrameworkInfo__DispatchOnceToken, &__block_literal_global_68);
    }
    CFAllocatorRef v4 = (id *)_GetTextInputFrameworkInfo__InfoPtr;
    if (_GetTextInputFrameworkInfo__InfoPtr)
    {
      CFStringRef v12 = (void *)NewAutoReleasePool();
      id v5 = objc_msgSend(*v4, sel_new);
      *(_OWORD *)keys = xmmword_1E6A59378;
      int64_t v16 = @"City";
      *(_OWORD *)values = xmmword_1E6A59390;
      uint64_t v14 = &stru_1F2DE4460;
      CFDictionaryRef v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFIndex Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        CFIndex v8 = Count;
        for (CFIndex i = 0; i != v8; ++i)
        {
          CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          CFStringRef v11 = CFStringCreateWithFormat(0, 0, @"%@;%@;%@",
                  @"com.apple.DictionaryServices",
                  ValueAtIndex,
                  a1);
          DCSLog(16, @"AddLinguisticDataAssetion_iOS actually adding language (%@) to client (%@)", ValueAtIndex, v5);
          objc_msgSend(v5, sel_addLinguisticAssetsAssertionForLanguage_assertionID_region_clientID_withHandler_, ValueAtIndex, v11, v6, @"com.apple.DictionaryServices", &__block_literal_global_41);
          CFRelease(v11);
        }
      }
      CFRelease(v6);
    }
  }
}

void RemoveLinguisticDataAssetion(uint64_t a1, const __CFArray *a2)
{
  DCSLog(16, @"RemoveLinguisticDataAssetion_iOS for dictionary (%@) with languages (%@)", a1, a2);
  if (a1 && a2)
  {
    if (_GetTextInputFrameworkInfo__DispatchOnceToken != -1) {
      dispatch_once(&_GetTextInputFrameworkInfo__DispatchOnceToken, &__block_literal_global_68);
    }
    CFAllocatorRef v4 = (id *)_GetTextInputFrameworkInfo__InfoPtr;
    if (_GetTextInputFrameworkInfo__InfoPtr)
    {
      id v11 = (id)NewAutoReleasePool();
      id v5 = objc_msgSend(*v4, sel_new);
      CFIndex Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        CFIndex v7 = Count;
        for (CFIndex i = 0; i != v7; ++i)
        {
          CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"%@;%@;%@",
                  @"com.apple.DictionaryServices",
                  ValueAtIndex,
                  a1);
          DCSLog(16, @"RemoveLinguisticDataAssetion_iOS actually removing language (%@) from client (%@)", ValueAtIndex, v5);
          objc_msgSend(v5, sel_removeLinguisticAssetsAssertionWithIdentifier_forClientID_withHandler_, v10, @"com.apple.DictionaryServices", &__block_literal_global_51);
          CFRelease(v10);
        }
      }
    }
  }
}

CFMutableSetRef DCSCopyAvailableDictionaries()
{
  uint64_t v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();

  return DCSEnvironment::copyAvailableDictionaries(v0);
}

uint64_t DCSInvalidateDictionaryCache()
{
  uint64_t result = SyncSingleton<DCSEnvironment>::instance();
  *(unsigned char *)(result + 154) = 1;
  return result;
}

uint64_t DCSGetActiveDictionaries()
{
  uint64_t v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();

  return DCSEnvironment::getActiveDictionaries(v0);
}

uint64_t DCSCopyInactiveDictionaries(const __CFString *a1)
{
  unsigned int v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();

  return DCSEnvironment::copyInactiveDictionaries(v2, a1);
}

uint64_t DCSSetActiveDictionaries(const __CFArray *a1)
{
  unsigned int v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();

  return DCSEnvironment::setActiveDictionaries(v2, a1);
}

uint64_t DCSGetDefaultDictionary()
{
  return 0;
}

uint64_t DCSGetDefaultThesaurus()
{
  return 0;
}

CFRange DCSGetTermRangeInString(DCSDictionaryRef dictionary, CFStringRef textString, CFIndex offset)
{
  values = dictionary;
  if (dictionary)
  {
    CFArrayRef v5 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    uint64_t v6 = DCSGetTermRangeInStringWithOptions(v5, textString, offset, 1);
    CFIndex v8 = v7;
    if (v5) {
      CFRelease(v5);
    }
    CFIndex v9 = v6;
    CFIndex v10 = v8;
  }
  else
  {
    CFIndex v9 = DCSGetTermRangeInStringWithOptions(0, textString, offset, 1);
  }
  result.CFIndex length = v10;
  result.CFIndex location = v9;
  return result;
}

uint64_t DCSGetTermRangeInStringWithOptions(const __CFArray *ActiveDictionaries, CFStringRef theString, uint64_t a3, char a4)
{
  CFIndex Length = CFStringGetLength(theString);
  if (!ActiveDictionaries)
  {
    CFIndex v8 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
    CFArrayRef ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(v8);
  }
  if (a3 <= 25) {
    CFIndex v9 = 0;
  }
  else {
    CFIndex v9 = a3 - 25;
  }
  CFIndex v10 = v9 + 50;
  CFIndex v55 = v9;
  uint64_t v11 = Length - v9;
  BOOL v12 = v10 <= Length;
  uint64_t v13 = 50;
  if (!v12) {
    uint64_t v13 = v11;
  }
  CFIndex v54 = v13;
  CFIndex v49 = Length;
  uint64_t v50 = a3;
  CFArrayRef theArray = ActiveDictionaries;
  if (ActiveDictionaries) {
    uint64_t Count = CFArrayGetCount(ActiveDictionaries);
  }
  else {
    uint64_t Count = 0;
  }
  unint64_t v15 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  int64_t v16 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  theDict = CFDictionaryCreateMutable(0, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, v15, v16);
  if (Count >= 1)
  {
    CFIndex v18 = 0;
    uint64_t v51 = Count;
    do
    {
      CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v18);
      if (ValueAtIndex)
      {
        CFStringRef v20 = (CFDictionaryRef *)*((void *)ValueAtIndex + 2);
        if (v20)
        {
          if ((DCSDictionary::isNetworkDictionary(*((DCSDictionary **)ValueAtIndex + 2)) & 1) == 0)
          {
            CFArrayRef v21 = DCSDictionary::languages(v20);
            if (v21)
            {
              CFArrayRef v22 = v21;
              uint64_t v23 = CFArrayGetCount(v21);
              CFIndex v24 = CFArrayCreateMutable(0, v23, MEMORY[0x1E4F1D510]);
              if (v23 >= 1)
              {
                for (CFIndex i = 0; i != v23; ++i)
                {
                  CFDictionaryRef v26 = (const __CFDictionary *)CFArrayGetValueAtIndex(v22, i);
                  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v26, @"DCSDictionaryIndexLanguage");
                  if (Value)
                  {
                    ComponentsFromLocaleCFStringRef Identifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, Value);
                    if (ComponentsFromLocaleIdentifier)
                    {
                      CFDictionaryRef v29 = ComponentsFromLocaleIdentifier;
                      CFLocaleIdentifier LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents(0, ComponentsFromLocaleIdentifier);
                      if (LocaleIdentifierFromComponents)
                      {
                        CFLocaleIdentifier v31 = LocaleIdentifierFromComponents;
                        CFArrayAppendValue(v24, LocaleIdentifierFromComponents);
                        CFRelease(v31);
                      }
                      CFRelease(v29);
                    }
                  }
                }
              }
            }
            else
            {
              CFIndex v24 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
            }
            if (!CFArrayGetCount(v24)) {
              CFArrayAppendValue(v24, &stru_1F2DE4460);
            }
            CFIndex v32 = CFArrayGetCount(v24);
            if (v32 >= 1)
            {
              CFIndex v33 = v32;
              for (CFIndex j = 0; j != v33; ++j)
              {
                CFStringRef v35 = (const __CFString *)CFArrayGetValueAtIndex(v24, j);
                newValues = 0;
                newValues = (void *)CFDictionaryGetValue(Mutable, v35);
                if (!newValues)
                {
                  if (CFStringGetLength(v35)) {
                    CFLocaleRef v36 = CFLocaleCreate(0, v35);
                  }
                  else {
                    CFLocaleRef v36 = 0;
                  }
                  CFIndex v37 = CFDataCreateMutable(0, 408);
                  CFDataSetLength(v37, 408);
                  MutableBytePtr = (char *)CFDataGetMutableBytePtr(v37);
                  v57.CFIndex length = v54;
                  v57.CFIndex location = v55;
                  BuildWordBreakTable(theString, v57, v36, MutableBytePtr);
                  CFDictionarySetValue(Mutable, v35, v37);
                  if (v36) {
                    CFRelease(v36);
                  }
                  newValues = v37;
                  CFRelease(v37);
                }
                v58.CFIndex location = j;
                v58.CFIndex length = 1;
                CFArrayReplaceValues(v24, v58, (const void **)&newValues, 1);
              }
            }
            CFDictionaryRef v39 = DCSDictionary::identifier((DCSDictionary *)v20);
            CFDictionarySetValue(theDict, v39, v24);
            CFRelease(v24);
            uint64_t Count = v51;
          }
        }
      }
      ++v18;
    }
    while (v18 != Count);
  }
  CFRelease(Mutable);
  uint64_t v40 = 0;
  uint64_t v41 = v50 - v55;
  if (v50 - v55 < 0)
  {
    uint64_t v43 = -1;
  }
  else
  {
    uint64_t v42 = 0;
    uint64_t v43 = -1;
    do
    {
      CFIndex v44 = v42 + v55;
      v59.CFIndex length = v54 - v42;
      v59.CFIndex location = v42 + v55;
      CFIndex v45 = LongestRangeAroundOffset(theArray, theString, v59, v42, v41 - v42, theDict, a4 & 1);
      if (v46 > v40)
      {
        uint64_t v43 = v45;
        uint64_t v40 = v46;
      }
      if (v49 > v44 && (CFStringGetCharacterAtIndex(theString, v44) & 0xFC00) == 0xD800) {
        ++v42;
      }
      BOOL v12 = v42++ < v41;
    }
    while (v12);
  }
  CFRelease(theDict);
  return v43;
}

CFIndex LongestRangeAroundOffset(const __CFArray *a1, const __CFString *a2, CFRange a3, uint64_t a4, int64_t a5, const __CFDictionary *a6, int a7)
{
  int v59 = a7;
  CFDictionaryRef v64 = a6;
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  CFArrayRef v12 = a1;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount(a1);
  CFIndex v58 = location;
  v67.CFIndex location = location;
  v67.CFIndex length = length;
  CFStringRef v61 = CFStringCreateWithSubstring(0, a2, v67);
  if (Count >= 1)
  {
    uint64_t v60 = a4;
    int64_t v14 = 0;
    CFIndex v15 = 0;
    CFArrayRef v62 = v12;
    CFIndex v63 = Count;
    do
    {
      CFURLRef ValueAtIndex = (DCSDictionary **)CFArrayGetValueAtIndex(v12, v15);
      if (!ValueAtIndex) {
        goto LABEL_53;
      }
      uint64_t v17 = ValueAtIndex;
      CFIndex v18 = ValueAtIndex[2];
      if (!v18 || (DCSDictionary::isNetworkDictionary(ValueAtIndex[2]) & 1) != 0) {
        goto LABEL_53;
      }
      CFDictionaryRef v19 = DCSDictionary::identifier(v18);
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v64, v19);
      CFIndex v21 = CFArrayGetCount(Value);
      CFRange v65 = &v57;
      MEMORY[0x1F4188790](v21);
      CFIndex v24 = (char *)&v57 - v23;
      size_t v25 = v22 >= 0x200 ? 512 : v22;
      bzero((char *)&v57 - v23, v25);
      if (v21 < 1) {
        goto LABEL_53;
      }
      CFIndex v26 = 0;
      uint64_t v27 = v60;
      do
      {
        CFDataRef v28 = (const __CFData *)CFArrayGetValueAtIndex(Value, v26);
        CFDictionaryRef v29 = &CFDataGetBytePtr(v28)[8 * v27];
        uint64_t v30 = *(void *)v29;
        if (*(void *)v29 != 1) {
          CFDictionaryRef v29 = 0;
        }
        *(void *)&v24[8 * v26++] = v29;
      }
      while (v21 != v26);
      CFArrayRef v12 = v62;
      CFIndex Count = v63;
      if (v30 != 1) {
        goto LABEL_53;
      }
      CFLocaleIdentifier v31 = v17[2];
      if (v31 && (DCSDictionary::isNetworkDictionary(v31) & 1) != 0)
      {
        CFStringRef MutableCopy = (const __CFString *)CFRetain(v61);
        if (!v59) {
          goto LABEL_18;
        }
      }
      else
      {
        CFStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v61);
        CFLocaleRef v44 = (const __CFLocale *)DCSDictionary::primaryLocale(v18);
        DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v44);
        if ((v59 & 1) == 0)
        {
LABEL_18:
          CFIndex v33 = CFStringGetLength(MutableCopy);
          uint64_t v34 = MEMORY[0x1F4188790](v33);
          CFStringRef v35 = MutableCopy;
          CFLocaleRef v36 = (unsigned __int8 *)&v57 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
          CFIndex v37 = v18;
          CFStringRef v38 = v35;
          if (DCSDictionary::hasRecord(v37, v35, 2, v36))
          {
            uint64_t v39 = 0;
            uint64_t v40 = v36 - 1;
            CFStringRef MutableCopy = v38;
            do
            {
              uint64_t v41 = *(void *)&v24[8 * v39];
              if (v41) {
                BOOL v42 = v33 < 1;
              }
              else {
                BOOL v42 = 1;
              }
              if (!v42)
              {
                int64_t v43 = v33;
                while (v43 < a5 || !v40[v43] || !*(void *)(v41 + 8 * v43))
                {
                  if ((unint64_t)v43-- <= 1) {
                    goto LABEL_32;
                  }
                }
                if (v43 > v14) {
                  int64_t v14 = v43;
                }
              }
LABEL_32:
              ++v39;
            }
            while (v39 != v21);
          }
          else
          {
            CFStringRef MutableCopy = v38;
          }
          CFIndex Count = v63;
          goto LABEL_52;
        }
      }
      CFIndex v45 = v17[2];
      if (v45)
      {
        uint64_t v46 = DCSDictionary::searchByString(v45, MutableCopy);
        if (v46)
        {
          CFArrayRef v47 = (const __CFArray *)v46;
          CFStringRef v57 = MutableCopy;
          for (uint64_t i = 0; i != v21; ++i)
          {
            uint64_t v49 = *(void *)&v24[8 * i];
            if (v49)
            {
              CFIndex v50 = CFArrayGetCount(v47);
              if (v50 >= 1)
              {
                CFIndex v51 = v50;
                for (CFIndex j = 0; j != v51; ++j)
                {
                  uint64_t v53 = CFArrayGetValueAtIndex(v47, j);
                  int64_t v54 = *(void *)(v53[2] + 40) >> 1;
                  BOOL v55 = v54 <= v14 || v54 < a5;
                  if (!v55 && *(void *)(v49 + 8 * v54)) {
                    int64_t v14 = *(void *)(v53[2] + 40) >> 1;
                  }
                }
              }
            }
          }
          CFRelease(v47);
          CFArrayRef v12 = v62;
          CFIndex Count = v63;
          CFStringRef MutableCopy = v57;
        }
      }
LABEL_52:
      CFRelease(MutableCopy);
LABEL_53:
      ++v15;
    }
    while (v15 != Count);
  }
  CFRelease(v61);
  return v58;
}

BOOL DCSHasDefinitionForTerm(const void *ValueAtIndex, CFStringRef theString, CFRange range, uint64_t a4, void *a5)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  CFStringRef v9 = theString;
  if (a5) {
    *a5 = 0;
  }
  if (!theString) {
    return 0;
  }
  if (range.location || range.length != CFStringGetLength(theString))
  {
    v33.CFIndex location = location;
    v33.CFIndex length = length;
    CFStringRef v9 = CFStringCreateWithSubstring(0, v9, v33);
    if (!ValueAtIndex) {
      goto LABEL_7;
    }
  }
  else
  {
    CFRetain(v9);
    if (!ValueAtIndex)
    {
LABEL_7:
      uint64_t v11 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      CFArrayRef ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(v11);
      if (!ActiveDictionaries || (CFArrayRef v13 = ActiveDictionaries, Count = CFArrayGetCount(ActiveDictionaries), Count < 1))
      {
        BOOL v15 = 0;
        goto LABEL_37;
      }
      goto LABEL_12;
    }
  }
  CFArrayRef v13 = 0;
  CFIndex Count = 1;
LABEL_12:
  CFLocaleIdentifier v31 = a5;
  CFIndex v16 = 0;
  unint64_t v17 = a4 & 0xFFFFFFFFFFFFFFFELL;
  BOOL v15 = 1;
  unint64_t v32 = a4 & 0xFFFFFFFFFFFFFFFELL;
  while (1)
  {
    if (v13)
    {
      CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v13, v16);
      if (!DCSDictionaryIsSupportedDefinitionStyle((uint64_t)ValueAtIndex, a4)) {
        goto LABEL_32;
      }
    }
    if (ValueAtIndex)
    {
      CFIndex v18 = (DCSDictionary *)*((void *)ValueAtIndex + 2);
      if (v18 && (DCSDictionary::isNetworkDictionary(*((DCSDictionary **)ValueAtIndex + 2)) & 1) != 0)
      {
        CFStringRef MutableCopy = (const __CFString *)CFRetain(v9);
        if (v17 != 2) {
          goto LABEL_28;
        }
        goto LABEL_23;
      }
    }
    else
    {
      CFIndex v18 = 0;
    }
    CFLocaleRef v20 = (const __CFLocale *)DCSDictionary::primaryLocale(v18);
    CFStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v9);
    DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v20);
    if (v17 != 2) {
      break;
    }
    if (!ValueAtIndex) {
      goto LABEL_29;
    }
LABEL_23:
    CFIndex v21 = (DCSDictionary *)*((void *)ValueAtIndex + 2);
    if (!v21 || (CFArrayRef v22 = (const __CFArray *)DCSDictionary::searchByString(v21, MutableCopy)) == 0)
    {
LABEL_29:
      CFRelease(MutableCopy);
      goto LABEL_32;
    }
    CFArrayRef v23 = v22;
    CFStringRef v24 = v9;
    uint64_t v25 = a4;
    CFIndex v26 = CFArrayGetCount(v22);
    CFRelease(v23);
    CFRelease(MutableCopy);
    BOOL v27 = v26 <= 0;
    a4 = v25;
    CFStringRef v9 = v24;
    unint64_t v17 = v32;
    if (!v27) {
      goto LABEL_35;
    }
LABEL_32:
    BOOL v15 = ++v16 < Count;
    if (Count == v16) {
      goto LABEL_37;
    }
  }
  if (ValueAtIndex)
  {
LABEL_28:
    CFDataRef v28 = (DCSDictionary *)*((void *)ValueAtIndex + 2);
    goto LABEL_31;
  }
  CFDataRef v28 = 0;
LABEL_31:
  int hasRecord = DCSDictionary::hasRecord(v28, MutableCopy, 0, 0);
  CFRelease(MutableCopy);
  if (!hasRecord) {
    goto LABEL_32;
  }
LABEL_35:
  if (v31) {
    void *v31 = ValueAtIndex;
  }
LABEL_37:
  CFRelease(v9);
  return v15;
}

uint64_t DCSDictionaryIsSupportedDefinitionStyle(uint64_t result, uint64_t a2)
{
  if (result)
  {
    unsigned int v2 = *(DCSDictionary **)(result + 16);
    if (v2)
    {
      CFRange result = 1;
      if (a2)
      {
        if (a2 != 255) {
          return DCSDictionary::isSupportedDefinitionStyle(v2);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void DCSNormalizeSearchStringWithOptionsAndLocale(const __CFString *a1, uint64_t a2, const __CFLocale *a3)
{
  CFMutableStringRef v5 = (CFMutableStringRef)a1;
  v56[1] = *(__CFCharacterSet **)MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(a1);
  if (Length >= 256)
  {
    v57.CFIndex length = Length - 255;
    v57.CFIndex location = 255;
    CFStringDelete(v5, v57);
  }
  CFStringNormalize(v5, kCFStringNormalizationFormC);
  v56[0] = 0;
  CFIndex v7 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  uint64_t SubstituteCharactersTable = DCSEnvironment::getSubstituteCharactersTable(v7, v56);
  if (SubstituteCharactersTable)
  {
    CFDictionaryRef v9 = (const __CFDictionary *)SubstituteCharactersTable;
    if (!v56[0]
      || (CFCharacterSetRef v10 = CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5),
          int IsSupersetOfSet = CFCharacterSetIsSupersetOfSet(v56[0], v10),
          CFRelease(v10),
          !IsSupersetOfSet))
    {
      uint64_t v46 = a2;
      uint64_t v12 = CFStringGetLength(v5);
      CFIndex v45 = &v42;
      uint64_t v13 = MEMORY[0x1F4188790](v12);
      BOOL v15 = (const UniChar *)((char *)&v42 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
      CFStringRef v49 = v5;
      uint64_t v52 = 0;
      int64_t v53 = v13;
      CharactersPtr = CFStringGetCharactersPtr(v5);
      CStringPtr = 0;
      CFIndex v50 = (UniChar *)CharactersPtr;
      if (!CharactersPtr) {
        CStringPtr = CFStringGetCStringPtr(v5, 0x600u);
      }
      int64_t v54 = 0;
      int64_t v55 = 0;
      CFIndex v51 = CStringPtr;
      int64_t v47 = v12 - 1;
      if (v12 >= 1)
      {
        CFMutableStringRef v43 = v5;
        CFLocaleRef v44 = a3;
        int v18 = 0;
        CFIndex v19 = 0;
        int64_t v20 = 0;
        while (1)
        {
          int64_t v21 = v53;
          if (v53 <= v20)
          {
            unsigned int v25 = 0;
            CFIndex v26 = (UniChar *)&v15[v19];
            UniChar *v26 = 0;
LABEL_40:
            uint64_t v36 = 1;
            goto LABEL_41;
          }
          CFArrayRef v22 = v50;
          if (v50) {
            break;
          }
          if (!v51)
          {
            int64_t v33 = v54;
            if (v55 <= v20 || v54 > v20)
            {
              int64_t v35 = v20 - 4;
              if ((unint64_t)v20 < 4) {
                int64_t v35 = 0;
              }
              if (v35 + 64 < v53) {
                int64_t v21 = v35 + 64;
              }
              int64_t v54 = v35;
              int64_t v55 = v21;
              v58.CFIndex location = v52 + v35;
              v58.CFIndex length = v21 - v35;
              CFStringGetCharacters(v49, v58, buffer);
              int64_t v33 = v54;
            }
            int64_t v23 = v20 - v33;
            CFArrayRef v22 = buffer;
            goto LABEL_13;
          }
          UniChar v24 = v51[v52 + v20];
LABEL_17:
          unsigned int v25 = v24;
          CFIndex v26 = (UniChar *)&v15[v19];
          UniChar *v26 = v24;
          if (v24 >> 10 != 54 || v20 >= v47) {
            goto LABEL_40;
          }
          int64_t v28 = v20 + 1;
          int64_t v29 = v53;
          if (v53 <= v20 + 1) {
            goto LABEL_40;
          }
          uint64_t v30 = v50;
          if (v50)
          {
            int64_t v31 = v52 + v28;
LABEL_25:
            UniChar v32 = v30[v31];
            goto LABEL_38;
          }
          if (!v51)
          {
            if (v55 <= v28 || (int64_t v40 = v54, v54 > v28))
            {
              int64_t v41 = v20 - 3;
              if ((unint64_t)v20 < 3) {
                int64_t v41 = 0;
              }
              if (v41 + 64 < v53) {
                int64_t v29 = v41 + 64;
              }
              int64_t v54 = v41;
              int64_t v55 = v29;
              v60.CFIndex location = v52 + v41;
              v60.CFIndex length = v29 - v41;
              CFStringGetCharacters(v49, v60, buffer);
              int64_t v40 = v54;
            }
            int64_t v31 = v28 - v40;
            uint64_t v30 = buffer;
            goto LABEL_25;
          }
          UniChar v32 = v51[v52 + v28];
LABEL_38:
          if (v32 >> 10 != 55) {
            goto LABEL_40;
          }
          unsigned int v25 = (v25 << 10) + v32 - 56613888;
          v15[v19 + 1] = v32;
          uint64_t v36 = 2;
LABEL_41:
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v9, (const void *)v25);
          CFIndex v38 = v36;
          if (Value)
          {
            CFStringRef v39 = Value;
            CFIndex v38 = CFStringGetLength(Value);
            v59.CFIndex location = 0;
            v59.CFIndex length = v38;
            CFStringGetCharacters(v39, v59, v26);
            int v18 = 1;
          }
          v19 += v38;
          v20 += v36;
          if (v20 >= v12)
          {
            a3 = v44;
            CFMutableStringRef v5 = v43;
            if (v18)
            {
              v61.CFIndex location = 0;
              v61.CFIndex length = v12;
              CFStringDelete(v43, v61);
              CFStringAppendCharacters(v5, v15, v19);
            }
            goto LABEL_55;
          }
        }
        int64_t v23 = v52 + v20;
LABEL_13:
        UniChar v24 = v22[v23];
        goto LABEL_17;
      }
LABEL_55:
      LOBYTE(a2) = v46;
    }
    CFStringTrimWhitespace(v5);
    if ((a2 & 1) == 0) {
      CFStringLowercase(v5, a3);
    }
  }
}

__CFString *DCSCopyDefinitionMarkup(DCSDictionary **a1, CFStringRef theString, CFRange range, uint64_t a4, void *a5)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  CFStringRef v9 = theString;
  if (a5) {
    *a5 = 0;
  }
  if (theString)
  {
    if (range.location || range.length != CFStringGetLength(theString))
    {
      v21.CFIndex location = location;
      v21.CFIndex length = length;
      CFStringRef v9 = CFStringCreateWithSubstring(0, v9, v21);
    }
    else
    {
      CFRetain(v9);
    }
    CFTypeRef cf = 0;
    v22.CFIndex location = location;
    v22.CFIndex length = length;
    uint64_t v11 = CopyDefinitionsInternal(a1, v9, v22, a4, &cf);
    if (!v11)
    {
      CFDictionaryRef Mutable = 0;
LABEL_24:
      CFRelease(v9);
      return Mutable;
    }
    uint64_t v12 = v11;
    CFIndex Count = CFArrayGetCount(v11);
    if (Count < 1)
    {
      CFDictionaryRef Mutable = 0;
      if (!a5)
      {
LABEL_21:
        if (cf) {
          CFRelease(cf);
        }
        CFRelease(v12);
        goto LABEL_24;
      }
    }
    else
    {
      CFIndex v14 = Count;
      CFIndex v15 = 0;
      CFDictionaryRef Mutable = 0;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v15);
        if (!Mutable) {
          CFDictionaryRef Mutable = CFStringCreateMutable(0, 0);
        }
        CFStringAppend(Mutable, ValueAtIndex);
        ++v15;
      }
      while (v14 != v15);
      if (!a5) {
        goto LABEL_21;
      }
    }
    StyleSheetURL = DCSDictionaryGetStyleSheetURL((uint64_t)cf);
    *a5 = StyleSheetURL;
    if (StyleSheetURL) {
      CFRetain(StyleSheetURL);
    }
    goto LABEL_21;
  }
  return 0;
}

__CFArray *CopyDefinitionsInternal(DCSDictionary **a1, const __CFString *a2, CFRange a3, uint64_t a4, CFTypeRef *a5)
{
  if (a5)
  {
    *a5 = 0;
    CFArrayRef v6 = DCSCopyDefinitionRecords(a1, a2, a3, a4);
    if (v6)
    {
      CFArrayRef v7 = v6;
      CFIndex v8 = (DCSRecord *)*((void *)CFArrayGetValueAtIndex(v6, 0) + 2);
      if (v8) {
        CFIndex v8 = (DCSRecord *)DCSRecord::dictionaryRef(v8);
      }
      *a5 = CFRetain(v8);
      goto LABEL_7;
    }
    return 0;
  }
  CFArrayRef v7 = DCSCopyDefinitionRecords(a1, a2, a3, a4);
  if (!v7) {
    return 0;
  }
LABEL_7:
  CFIndex Count = CFArrayGetCount(v7);
  if (Count < 1)
  {
    CFDictionaryRef Mutable = 0;
  }
  else
  {
    CFIndex v10 = Count;
    CFDictionaryRef Mutable = 0;
    CFIndex v12 = 0;
    uint64_t v13 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v7, v12);
      uint64_t v15 = DCSRecordCopyDefinition((uint64_t)ValueAtIndex);
      if (v15)
      {
        CFIndex v16 = (const void *)v15;
        if (!Mutable) {
          CFDictionaryRef Mutable = CFArrayCreateMutable(0, 0, v13);
        }
        CFArrayAppendValue(Mutable, v16);
        CFRelease(v16);
      }
      ++v12;
    }
    while (v10 != v12);
  }
  CFRelease(v7);
  return Mutable;
}

const void *DCSDictionaryGetStyleSheetURL(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(DCSDictionary **)(a1 + 16);
  if (!v1) {
    return 0;
  }
  CFArrayRef v2 = (const __CFArray *)DCSDictionary::styleSheetURLs(v1);
  if (!v2) {
    return 0;
  }
  CFArrayRef v3 = v2;
  if (CFArrayGetCount(v2) < 1) {
    return 0;
  }

  return CFArrayGetValueAtIndex(v3, 0);
}

__CFArray *DCSCopyDefinitions(DCSDictionary **a1, const __CFString *a2, CFRange a3, uint64_t a4)
{
  return CopyDefinitionsInternal(a1, a2, a3, a4, 0);
}

CFArrayRef DCSCopyDefinitionRecords(DCSDictionary **a1, CFStringRef theString, CFRange range, uint64_t a4)
{
  if (!theString) {
    return 0;
  }
  CFIndex length = range.length;
  CFIndex location = range.location;
  CFStringRef v7 = theString;
  CFStringRef ValueAtIndex = a1;
  if (a1)
  {
    CFStringRef v9 = a1[2];
    if (!v9 || a4 && a4 != 255 && !DCSDictionary::isSupportedDefinitionStyle(v9)) {
      return 0;
    }
  }
  if (location || length != CFStringGetLength(v7))
  {
    v40.CFIndex location = location;
    v40.CFIndex length = length;
    CFStringRef v7 = CFStringCreateWithSubstring(0, v7, v40);
    if (!ValueAtIndex) {
      goto LABEL_10;
    }
  }
  else
  {
    CFRetain(v7);
    if (!ValueAtIndex)
    {
LABEL_10:
      CFIndex v10 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      CFArrayRef ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(v10);
      CFIndex Count = CFArrayGetCount(ActiveDictionaries);
      CFArrayRef v38 = 0;
      if (Count < 1)
      {
LABEL_30:
        CFArrayRef v14 = 0;
        goto LABEL_31;
      }
      uint64_t v13 = Count;
      goto LABEL_15;
    }
  }
  CFArrayRef ActiveDictionaries = 0;
  CFArrayRef v38 = 0;
  uint64_t v13 = 1;
LABEL_15:
  CFIndex v15 = 0;
  while (1)
  {
    if (ActiveDictionaries)
    {
      CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(ActiveDictionaries, v15);
      if (!DCSDictionaryIsSupportedDefinitionStyle((uint64_t)ValueAtIndex, a4)) {
        goto LABEL_29;
      }
    }
    if (ValueAtIndex)
    {
      CFIndex v16 = (DCSDictionary *)*((void *)ValueAtIndex + 2);
      if (v16)
      {
        if (DCSDictionary::isNetworkDictionary(v16))
        {
          CFStringRef MutableCopy = (const __CFString *)CFRetain(v7);
          goto LABEL_25;
        }
        CFIndex v16 = (DCSDictionary *)*((void *)ValueAtIndex + 2);
      }
    }
    else
    {
      CFIndex v16 = 0;
    }
    CFLocaleRef v18 = (const __CFLocale *)DCSDictionary::primaryLocale(v16);
    CFStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v7);
    DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v18);
    if (!ValueAtIndex) {
      goto LABEL_28;
    }
LABEL_25:
    CFIndex v19 = (DCSDictionary *)*((void *)ValueAtIndex + 2);
    if (!v19)
    {
LABEL_28:
      CFRelease(MutableCopy);
      goto LABEL_29;
    }
    CFArrayRef v14 = (const __CFArray *)DCSDictionary::searchByString(v19, MutableCopy);
    CFRelease(MutableCopy);
    if (v14) {
      break;
    }
LABEL_29:
    if (v13 == ++v15) {
      goto LABEL_30;
    }
  }
  CFArrayRef v38 = v14;
  CFRange v21 = (DCSDictionary *)*((void *)ValueAtIndex + 2);
  if (!v21)
  {
    uint64_t v24 = CFArrayGetCount(v14);
    if (v24 <= 1) {
      goto LABEL_31;
    }
LABEL_50:
    CFArrayRef Mutable = CFArrayCreateMutableCopy(0, v24, v14);
    DCSSortRecordsWithHeadword(Mutable, v7);
    goto LABEL_51;
  }
  CFRange v22 = DCSDictionary::primaryLanguage(v21);
  CFIndex v23 = CFArrayGetCount(v14);
  if (v23 <= 1) {
    goto LABEL_31;
  }
  uint64_t v24 = v23;
  if (!v22 || CFStringCompare(v22, @"ar", 1uLL)) {
    goto LABEL_50;
  }
  CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v26 = DCSCreateHeadwordList(1, (uint64_t)&v38, v7);
  if (v26)
  {
    CFArrayRef v27 = v26;
    CFIndex v28 = CFArrayGetCount(v26);
    if (v28 >= 1)
    {
      CFIndex v29 = v28;
      for (CFIndex i = 0; i != v29; ++i)
      {
        CFStringRef v31 = (const __CFString *)CFArrayGetValueAtIndex(v27, i);
        UniChar v32 = DCSCopyRecordsWithHeadword(1, (uint64_t)&v38, v31);
        if (v32)
        {
          CFArrayRef v33 = v32;
          CFIndex v34 = CFArrayGetCount(v32);
          if (v34 >= 1)
          {
            CFIndex v35 = v34;
            for (CFIndex j = 0; j != v35; ++j)
            {
              CFIndex v37 = CFArrayGetValueAtIndex(v33, j);
              v39.CFIndex length = CFArrayGetCount(Mutable);
              v39.CFIndex location = 0;
              if (!CFArrayContainsValue(Mutable, v39, v37)) {
                CFArrayAppendValue(Mutable, v37);
              }
            }
          }
          CFRelease(v33);
        }
      }
    }
    CFRelease(v27);
  }
LABEL_51:
  CFRelease(v14);
  CFArrayRef v14 = Mutable;
LABEL_31:
  CFRelease(v7);
  return v14;
}

__CFString *DCSDictionaryGetPrimaryLanguage(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(DCSDictionary **)(a1 + 16)) != 0) {
    return DCSDictionary::primaryLanguage(v1);
  }
  else {
    return 0;
  }
}

CFArrayRef DCSCreateHeadwordList(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  CFDictionaryKeyCallBacks keyCallBacks = *(CFDictionaryKeyCallBacks *)byte_1F2DE31B8;
  theDict = CFDictionaryCreateMutable(0, 0, &keyCallBacks, 0);
  uint64_t v35 = a1;
  if (a1 < 1)
  {
    CFMutableStringRef v5 = 0;
    CFStringRef v36 = 0;
    char isSortableDictionary = 1;
    char v8 = 1;
  }
  else
  {
    CFStringRef v36 = 0;
    CFMutableStringRef v5 = 0;
    uint64_t v6 = 0;
    char v7 = 1;
    char v8 = 1;
    char isSortableDictionary = 1;
    do
    {
      CFArrayRef v10 = *(const __CFArray **)(a2 + 8 * v6);
      if (v10)
      {
        CFIndex Count = CFArrayGetCount(v10);
        if (Count >= 1)
        {
          CFIndex v12 = Count;
          for (CFIndex i = 0; i != v12; ++i)
          {
            CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 8 * v6), i);
            CFIndex v15 = (DCSDictionary **)ValueAtIndex[2];
            CFDictionaryAddValue(theDict, v15, ValueAtIndex);
            if (!i && (v7 & 1) != 0)
            {
              EffectiveLanguageOfRecord = GetEffectiveLanguageOfRecord((uint64_t)ValueAtIndex);
              if (EffectiveLanguageOfRecord)
              {
                CFStringRef v17 = v36;
                if (v36)
                {
                  int v18 = CompareLanguageCode(v36, (CFStringRef)EffectiveLanguageOfRecord, 0);
                  char v7 = v18;
                  if (!v18) {
                    CFStringRef v17 = 0;
                  }
                  CFStringRef v36 = v17;
                }
                else
                {
                  char v7 = 1;
                  CFStringRef v36 = (const __CFString *)EffectiveLanguageOfRecord;
                }
              }
              else
              {
                char v7 = 1;
              }
            }
            CFIndex v19 = *v15;
            if (v5 != *v15)
            {
              if (v5) {
                CFIndex v19 = v5;
              }
              BOOL v20 = (v8 & 1) == 0 || v5 == 0;
              CFMutableStringRef v5 = v19;
              if (!v20) {
                char v8 = 0;
              }
              if (isSortableDictionary) {
                char isSortableDictionary = DCSDictionary::isSortableDictionary(v19);
              }
              else {
                char isSortableDictionary = 0;
              }
            }
          }
        }
      }
      ++v6;
    }
    while (v6 != v35);
  }
  CFIndex v21 = CFDictionaryGetCount(theDict);
  if (v21)
  {
    CFIndex v22 = v21;
    CFIndex v23 = (const void **)malloc_type_malloc(8 * v21, 0xC0040B8AA526DuLL);
    CFDictionaryGetKeysAndValues(theDict, 0, v23);
    CFRelease(theDict);
    if (isSortableDictionary)
    {
      CFArrayRef Mutable = CFArrayCreateMutable(0, v22, MEMORY[0x1E4F1D510]);
      v40.CFIndex location = 0;
      v40.CFIndex length = 0;
      CFArrayReplaceValues(Mutable, v40, v23, v22);
      if (v8) {
        unsigned int v25 = v5;
      }
      else {
        unsigned int v25 = 0;
      }
      InitSortStringInfo((uint64_t)context, a3, v25, v36, 1);
      if (!v36
        || (v8 & 1) == 0
        || (char v26 = CompareLanguageCode(v36, @"zh-Hans", 0),
            CFArrayRef v27 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingSCHeadword,
            (v26 & 1) == 0))
      {
        CFArrayRef v27 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingHeadword;
      }
      v41.CFIndex location = 0;
      v41.CFIndex length = v22;
      CFArraySortValues(Mutable, v41, v27, context);
      ReleaseSortStringInfo((uint64_t)context);
      if (v22 >= 1)
      {
        for (CFIndex j = 0; j != v22; ++j)
        {
          CFIndex v29 = (DCSRecord **)CFArrayGetValueAtIndex(Mutable, j);
          v23[j] = DCSRecord::headword(v29[2]);
        }
      }
      CFRelease(Mutable);
    }
    else if (v22 >= 1)
    {
      CFStringRef v31 = v23;
      CFIndex v32 = v22;
      do
      {
        void *v31 = DCSRecord::headword(*((DCSRecord **)*v31 + 2));
        ++v31;
        --v32;
      }
      while (v32);
    }
    CFArrayRef v30 = CFArrayCreate(0, v23, v22, MEMORY[0x1E4F1D510]);
    free(v23);
  }
  else
  {
    CFRelease(theDict);
    return 0;
  }
  return v30;
}

__CFArray *DCSCopyRecordsWithHeadword(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  CFArrayRef v3 = 0;
  if (a1 && a3)
  {
    uint64_t v5 = a1;
    CFArrayRef theArray = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (v5 >= 1)
    {
      uint64_t v6 = 0;
      uint64_t v26 = v5;
      uint64_t v27 = a2;
      while (1)
      {
        CFArrayRef v7 = *(const __CFArray **)(a2 + 8 * v6);
        if (!v7) {
          goto LABEL_26;
        }
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 8 * v6));
        if (!Count) {
          goto LABEL_26;
        }
        uint64_t v9 = Count;
        CFArrayRef v10 = (DCSRecord *)*((void *)CFArrayGetValueAtIndex(v7, 0) + 2);
        if (!v10) {
          break;
        }
        uint64_t v11 = DCSRecord::dictionaryRef(v10);
        CFIndex v12 = (DCSDictionary *)v11;
        if (!v11) {
          goto LABEL_13;
        }
        uint64_t v13 = *(DCSDictionary **)(v11 + 16);
        if (!v13) {
          break;
        }
        if ((DCSDictionary::isNetworkDictionary(v13) & 1) == 0)
        {
          CFIndex v12 = (DCSDictionary *)*((void *)v12 + 2);
          goto LABEL_13;
        }
        CFStringRef v14 = 0;
        CFLocaleRef v15 = 0;
LABEL_14:
        if (v9 >= 1)
        {
          CFIndex v16 = 0;
          while (1)
          {
            CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v7, v16);
            int v18 = (uint64_t *)ValueAtIndex[2];
            CFStringRef v19 = (const __CFString *)DCSRecord::headword((DCSRecord *)v18);
            if (v14) {
              break;
            }
            if (CFStringCompare(v19, a3, 0x121uLL) == kCFCompareEqualTo) {
              goto LABEL_22;
            }
LABEL_23:
            if (v9 == ++v16) {
              goto LABEL_24;
            }
          }
          CFStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v19);
          DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v15);
          v30.CFIndex length = CFStringGetLength(MutableCopy);
          v30.CFIndex location = 0;
          CFComparisonResult v21 = CFStringCompareWithOptionsAndLocale(MutableCopy, v14, v30, 0x121uLL, v15);
          CFRelease(MutableCopy);
          if (v21)
          {
            if (v18[17] < 1) {
              goto LABEL_23;
            }
            CFStringRef v22 = DCSRecord::dataString((DCSRecord *)v18);
            CFStringRef v23 = CFStringCreateMutableCopy(0, 0, v22);
            DCSNormalizeSearchStringWithOptionsAndLocale(v23, 0, v15);
            v31.CFIndex length = CFStringGetLength(v23);
            v31.CFIndex location = 0;
            CFComparisonResult v24 = CFStringCompareWithOptionsAndLocale(v23, v14, v31, 0x121uLL, v15);
            CFRelease(v23);
            if (v24) {
              goto LABEL_23;
            }
          }
LABEL_22:
          CFArrayAppendValue(theArray, ValueAtIndex);
          goto LABEL_23;
        }
LABEL_24:
        uint64_t v5 = v26;
        a2 = v27;
        if (v14) {
          CFRelease(v14);
        }
LABEL_26:
        if (++v6 == v5) {
          goto LABEL_29;
        }
      }
      CFIndex v12 = 0;
LABEL_13:
      DCSDictionary::primaryLanguage(v12);
      CFLocaleRef v15 = (const __CFLocale *)DCSDictionary::primaryLocale(v12);
      CFStringRef v14 = CFStringCreateMutableCopy(0, 0, a3);
      DCSNormalizeSearchStringWithOptionsAndLocale(v14, 0, v15);
      goto LABEL_14;
    }
LABEL_29:
    CFArrayRef v3 = theArray;
    if (CFArrayGetCount(theArray))
    {
      DCSSortRecordsWithHeadword(theArray, a3);
    }
    else
    {
      CFRelease(theArray);
      return 0;
    }
  }
  return v3;
}

void DCSSortRecordsWithHeadword(const __CFArray *a1, const __CFString *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 2) {
    return;
  }
  CFIndex v5 = Count;
  uint64_t v6 = 0;
  CFIndex v7 = 0;
  CFStringRef v8 = 0;
  char v9 = 1;
  char v10 = 1;
  char isSortableDictionary = 1;
  do
  {
    while (1)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a1, v7);
      uint64_t v13 = ValueAtIndex;
      if (v9)
      {
        EffectiveLanguageOfRecord = GetEffectiveLanguageOfRecord((uint64_t)ValueAtIndex);
        if (EffectiveLanguageOfRecord)
        {
          if (v8)
          {
            int v15 = CompareLanguageCode(v8, (CFStringRef)EffectiveLanguageOfRecord, 0);
            char v9 = v15;
            if (!v15) {
              CFStringRef v8 = 0;
            }
          }
          else
          {
            char v9 = 1;
            CFStringRef v8 = (const __CFString *)EffectiveLanguageOfRecord;
          }
        }
        else
        {
          char v9 = 1;
        }
      }
      else
      {
        char v9 = 0;
      }
      CFIndex v16 = (DCSDictionary *)**((void **)v13 + 2);
      if (v6 == v16) {
        break;
      }
      if (v6) {
        CFIndex v16 = v6;
      }
      BOOL v17 = (v10 & 1) == 0 || v6 == 0;
      uint64_t v6 = v16;
      if (!v17) {
        char v10 = 0;
      }
      if (isSortableDictionary)
      {
        char isSortableDictionary = DCSDictionary::isSortableDictionary(v16);
        break;
      }
      char isSortableDictionary = 0;
      if (++v7 == v5) {
        goto LABEL_35;
      }
    }
    ++v7;
  }
  while (v7 != v5);
  if (isSortableDictionary)
  {
    if (v10) {
      int v18 = v6;
    }
    else {
      int v18 = 0;
    }
    InitSortStringInfo((uint64_t)context, a2, v18, v8, 0);
    if (!v8
      || !v10
      || (char v19 = CompareLanguageCode(v8, @"zh-Hans", 0),
          BOOL v20 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingSCHeadword,
          (v19 & 1) == 0))
    {
      BOOL v20 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingRecord;
    }
    v28.CFIndex location = 0;
    v28.CFIndex length = v5;
    CFArraySortValues(a1, v28, v20, context);
    ReleaseSortStringInfo((uint64_t)context);
  }
LABEL_35:
  uint64_t v21 = v5 - 1;
  do
  {
    uint64_t v22 = v5--;
    CFStringRef v23 = (DCSRecord *)*((void *)CFArrayGetValueAtIndex(a1, v5) + 2);
    uint64_t v24 = v21;
    while (1)
    {
      unsigned int v25 = (DCSRecord *)*((void *)CFArrayGetValueAtIndex(a1, --v24) + 2);
      if (*(void *)v23 == *(void *)v25)
      {
        uint64_t v26 = DCSRecord::subDictionaryRef(v23);
        if (v26 == DCSRecord::subDictionaryRef(v25) && *((void *)v23 + 26) == *((void *)v25 + 26)) {
          break;
        }
      }
      if (v24 <= 0) {
        goto LABEL_41;
      }
    }
    CFArrayRemoveValueAtIndex(a1, v5);
LABEL_41:
    --v21;
  }
  while (v22 > 2);
}

CFStringRef DCSCopyTextDefinition(DCSDictionaryRef dictionary, CFStringRef textString, CFRange range)
{
  if (!textString) {
    return 0;
  }
  CFIndex length = range.length;
  CFIndex location = range.location;
  CFStringRef v5 = textString;
  if (range.location || range.length != CFStringGetLength(textString))
  {
    v32.CFIndex location = location;
    v32.CFIndex length = length;
    CFStringRef v5 = CFStringCreateWithSubstring(0, v5, v32);
    if (!dictionary) {
      goto LABEL_5;
    }
  }
  else
  {
    CFRetain(v5);
    if (!dictionary)
    {
LABEL_5:
      CFIndex v7 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      CFArrayRef ActiveDictionaries = (const __CFArray *)DCSEnvironment::getActiveDictionaries(v7);
      if (!ActiveDictionaries || (v9 = ActiveDictionaries, CFIndex Count = CFArrayGetCount(ActiveDictionaries), Count < 1))
      {
LABEL_24:
        CFStringRef v17 = 0;
        goto LABEL_36;
      }
      goto LABEL_10;
    }
  }
  CFArrayRef v9 = 0;
  CFIndex Count = 1;
LABEL_10:
  CFIndex v11 = 0;
  while (1)
  {
    if (v9) {
      dictionary = (DCSDictionaryRef)CFArrayGetValueAtIndex(v9, v11);
    }
    if (dictionary)
    {
      CFIndex v12 = (DCSDictionary *)*((void *)dictionary + 2);
      if (v12 && DCSDictionary::isNetworkDictionary(*((DCSDictionary **)dictionary + 2)))
      {
        CFStringRef MutableCopy = (const __CFString *)CFRetain(v5);
        goto LABEL_19;
      }
    }
    else
    {
      CFIndex v12 = 0;
    }
    CFLocaleRef v14 = (const __CFLocale *)DCSDictionary::primaryLocale(v12);
    CFStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v5);
    DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v14);
    if (!dictionary) {
      goto LABEL_22;
    }
LABEL_19:
    int v15 = (DCSDictionary *)*((void *)dictionary + 2);
    if (!v15)
    {
LABEL_22:
      CFRelease(MutableCopy);
      goto LABEL_23;
    }
    CFArrayRef v16 = (const __CFArray *)DCSDictionary::searchByString(v15, MutableCopy);
    CFRelease(MutableCopy);
    if (v16) {
      break;
    }
LABEL_23:
    if (Count == ++v11) {
      goto LABEL_24;
    }
  }
  CFIndex v18 = CFArrayGetCount(v16);
  if (v18 >= 2
    && (CFIndex v19 = v18,
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v16, 0),
        EffectiveLanguageOfRecord = GetEffectiveLanguageOfRecord((uint64_t)ValueAtIndex),
        uint64_t v22 = (DCSDictionary **)*((void *)ValueAtIndex + 2),
        (CFStringRef v23 = *v22) != 0)
    && (CFStringRef v24 = (const __CFString *)EffectiveLanguageOfRecord, DCSDictionary::isSortableDictionary(*v22)))
  {
    unsigned int v25 = CFArrayCreateMutableCopy(0, v19, v16);
    InitSortStringInfo((uint64_t)context, v5, v23, v24, 0);
    if (Count != 1
      || !v24
      || (char v26 = CompareLanguageCode(v24, @"zh-Hans", 0),
          uint64_t v27 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingSCHeadword,
          (v26 & 1) == 0))
    {
      uint64_t v27 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))ComparatorForSortingHeadword;
    }
    v31.CFIndex location = 0;
    v31.CFIndex length = v19;
    CFArraySortValues(v25, v31, v27, context);
    ReleaseSortStringInfo((uint64_t)context);
    CFRelease(v16);
  }
  else
  {
    unsigned int v25 = v16;
  }
  CFRange v28 = CFArrayGetValueAtIndex(v25, 0);
  CFStringRef v17 = (const __CFString *)DCSRecordCopyDefinition((uint64_t)v28);
  CFRelease(v25);
LABEL_36:
  CFRelease(v5);
  return v17;
}

DCSRecord *GetEffectiveLanguageOfRecord(uint64_t a1)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = DCSRecord::subDictionaryRef(result);
    if (v3
      || (CFRange result = *(DCSRecord **)(a1 + 16)) != 0
      && (CFRange result = (DCSRecord *)DCSRecord::dictionaryRef(result), (v3 = (uint64_t)result) != 0))
    {
      CFRange result = *(DCSRecord **)(v3 + 16);
      if (result)
      {
        CFRange result = (DCSRecord *)DCSDictionary::primaryLanguage(result);
        if (!result)
        {
          CFRange result = *(DCSRecord **)(v3 + 16);
          if (result)
          {
            CFRange result = DCSDictionary::languages((CFDictionaryRef *)result);
            if (result)
            {
              CFArrayRef v4 = result;
              if (CFArrayGetCount(result) < 1)
              {
                return 0;
              }
              else
              {
                CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, 0);
                return (DCSRecord *)CFDictionaryGetValue(ValueAtIndex, @"DCSDictionaryIndexLanguage");
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t InitSortStringInfo(uint64_t a1, const __CFString *a2, DCSDictionary *this, const __CFString *a4, char a5)
{
  if (this) {
    CFLocaleRef v10 = (const __CFLocale *)DCSDictionary::primaryLocale(this);
  }
  else {
    CFLocaleRef v10 = 0;
  }
  CFStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, a2);
  DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 1, v10);
  *(void *)(a1 + 8) = MutableCopy;
  if (CFEqual(a2, MutableCopy))
  {
    CFRelease(MutableCopy);
    *(void *)(a1 + 8) = CFRetain(a2);
  }
  CFStringRef v12 = CFStringCreateMutableCopy(0, 0, a2);
  DCSNormalizeSearchStringWithOptionsAndLocale(v12, 0, v10);
  *(void *)(a1 + 16) = v12;
  if (CFStringCompare(a2, v12, 0))
  {
    CFStringRef v13 = *(const __CFString **)(a1 + 16);
  }
  else
  {
    CFRelease(v12);
    CFStringRef v13 = (const __CFString *)CFRetain(a2);
    *(void *)(a1 + 16) = v13;
  }
  CFMutableStringRef v14 = CFStringCreateMutableCopy(0, 0, v13);
  CFStringUppercase(v14, 0);
  *(void *)(a1 + 24) = v14;
  if (CFEqual(a2, v14))
  {
    CFRelease(v14);
    *(void *)(a1 + 24) = CFRetain(a2);
  }
  *(void *)a1 = a2;
  *(void *)(a1 + 32) = 0;
  if (a4)
  {
    CFStringRef CanonicalLocaleIdentifierFromString = CFLocaleCreateCanonicalLocaleIdentifierFromString(0, a4);
    if (CanonicalLocaleIdentifierFromString)
    {
      CFStringRef v16 = CanonicalLocaleIdentifierFromString;
      *(void *)(a1 + 32) = CFLocaleCreate(0, CanonicalLocaleIdentifierFromString);
      CFRelease(v16);
    }
  }
  *(unsigned char *)(a1 + 41) = this != 0;
  if (this) {
    uint64_t result = DCSDictionary::dictionaryFlag(this);
  }
  else {
    uint64_t result = 0;
  }
  *(void *)(a1 + 48) = result;
  *(unsigned char *)(a1 + 40) = a5;
  return result;
}

CFComparisonResult ComparatorForSortingSCHeadword(void *a1, void *a2, void *a3)
{
  uint64_t v3 = (uint64_t *)a1[2];
  CFArrayRef v4 = (uint64_t *)a2[2];
  CFLocaleRef v5 = (const __CFLocale *)a3[4];
  CFStringRef v6 = (const __CFString *)a3[2];
  CFIndex Length = CFStringGetLength(v6);
  CFStringRef v8 = DCSRecord::keyString((DCSRecord *)v3);
  CFIndex v9 = CFStringGetLength(v8);
  CFStringRef v10 = DCSRecord::keyString((DCSRecord *)v4);
  CFIndex v11 = CFStringGetLength(v10);
  if (Length == v9)
  {
    CFStringRef v12 = DCSRecord::keyString((DCSRecord *)v3);
    v23.CFIndex location = 0;
    v23.CFIndex length = Length;
    int v13 = CFStringCompareWithOptionsAndLocale(v6, v12, v23, 0x121uLL, v5) == kCFCompareEqualTo;
  }
  else
  {
    int v13 = 0;
  }
  if (Length == v11)
  {
    CFStringRef v14 = DCSRecord::keyString((DCSRecord *)v4);
    v24.CFIndex location = 0;
    v24.CFIndex length = Length;
    int v15 = CFStringCompareWithOptionsAndLocale(v6, v14, v24, 0x121uLL, v5) == kCFCompareEqualTo;
  }
  else
  {
    int v15 = 0;
  }
  if (v15 == v13)
  {
    if (v3[20] < 1 || v4[20] < 1)
    {
      CFStringRef v19 = DCSRecord::headwordSortString((DCSRecord *)v3, 0);
      CFStringRef v20 = DCSRecord::headwordSortString((DCSRecord *)v4, 0);
      v21.CFIndex length = CFStringGetLength(v19);
      v21.CFIndex location = 0;
      return CFStringCompareWithOptionsAndLocale(v19, v20, v21, 0x121uLL, v5);
    }
    else
    {
      CFStringRef v16 = DCSRecord::sortkeyString((DCSRecord *)v3);
      CFStringRef v17 = DCSRecord::sortkeyString((DCSRecord *)v4);
      return CFStringCompare(v16, v17, 0);
    }
  }
  else if (v13)
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

uint64_t ComparatorForSortingHeadword(const void *a1, void *a2, unsigned char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = *((void *)a1 + 2);
  CFLocaleRef v5 = (DCSDictionary **)a2[2];
  if (a3) {
    BOOL v6 = a3[41] != 0;
  }
  else {
    BOOL v6 = 1;
  }
  CFStringRef v7 = DCSRecord::headwordSortString(*((DCSRecord **)a1 + 2), !v6);
  CFStringRef v8 = DCSRecord::headwordSortString((DCSRecord *)v5, !v6);
  if (v3)
  {
    BOOL v9 = (v3[48] & 0x20) != 0 && *(unsigned char *)(v4 + 21) && *((unsigned char *)v5 + 21) != 0;
    CFLocaleRef v10 = (const __CFLocale *)*((void *)v3 + 4);
    CFStringRef v11 = *(const __CFString **)v3;
  }
  else
  {
    CFLocaleRef v10 = 0;
    BOOL v9 = 0;
    CFStringRef v11 = 0;
  }
  CFStringRef v12 = *(DCSDictionary **)(v4 + 112);
  int v13 = v5[14];
  if (v12 != v13 && (!v12 || v13 == 0))
  {
    BOOL v15 = v12 == 0;
    goto LABEL_96;
  }
  if (v6 && *(uint64_t *)(v4 + 160) >= 1 && (uint64_t)v5[20] >= 1)
  {
    BOOL v16 = v9;
    CFStringRef v17 = DCSRecord::sortkeyString((DCSRecord *)v4);
    CFStringRef v18 = DCSRecord::sortkeyString((DCSRecord *)v5);
    CFStringRef v19 = v17;
    BOOL v9 = v16;
    uint64_t v20 = CFStringCompare(v19, v18, 0);
    if (v20) {
      return v20;
    }
  }
  if (v7) {
    CFStringRef v21 = v7;
  }
  else {
    CFStringRef v21 = &stru_1F2DE4460;
  }
  if (v8) {
    CFStringRef v22 = v8;
  }
  else {
    CFStringRef v22 = &stru_1F2DE4460;
  }
  if (!v10
    || (CFStringRef v23 = (const __CFString *)MEMORY[0x1D9454B30](v10)) == 0
    || CFStringCompare(v23, @"ar", 1uLL)
    || !v11)
  {
    BOOL theStringa = v9;
    if (v3) {
      char v45 = v9;
    }
    else {
      char v45 = 1;
    }
    if ((v45 & 1) != 0 || !v11) {
      goto LABEL_119;
    }
    if (CFStringCompare(v21, v22, 0x121uLL) == kCFCompareEqualTo)
    {
      unsigned __int16 v46 = *((_WORD *)v5 + 96);
      uint64_t v20 = (v46 & 1) != 0 ? -1 : 1;
      if ((*(_WORD *)(v4 + 192) ^ v46)) {
        return v20;
      }
    }
    CFStringRef theString2a = v11;
    CFStringRef v81 = v3;
    v83 = v5;
    CFStringRef v47 = (const __CFString *)*((void *)v3 + 1);
    CFIndex Length = CFStringGetLength(v21);
    CFIndex v49 = CFStringGetLength(v22);
    char v50 = 1;
    CFStringCompareFlags v51 = 32;
    do
    {
      char v52 = v50;
      v95.CFIndex location = 0;
      v95.CFIndex length = Length;
      CFComparisonResult v53 = CFStringCompareWithOptionsAndLocale(v21, v47, v95, v51, v10);
      v96.CFIndex location = 0;
      v96.CFIndex length = v49;
      if ((v53 == kCFCompareEqualTo) == (CFStringCompareWithOptionsAndLocale(v22, v47, v96, v51, v10) != kCFCompareEqualTo))
      {
        BOOL v15 = v53 == kCFCompareEqualTo;
        goto LABEL_96;
      }
      char v50 = 0;
      CFStringCompareFlags v51 = 33;
    }
    while ((v52 & 1) != 0);
    if (DCSDictionary::isNetworkDictionary(*(DCSDictionary **)v4))
    {
      v97.CFIndex location = 0;
      v97.CFIndex length = Length;
      CFLocaleRef v5 = v83;
      if (!CFStringFindWithOptionsAndLocale(v21, v47, v97, 0x1A1uLL, v10, &result))
      {
        uint64_t v3 = v81;
        if (DCSDictionary::isNetworkDictionary(*v83))
        {
          v102.CFIndex location = 0;
          v102.CFIndex length = v49;
          if (!CFStringFindWithOptionsAndLocale(v22, v47, v102, 0x1A1uLL, v10, &result))
          {
            CFStringRef v11 = theString2a;
            goto LABEL_119;
          }
          CFStringRef v11 = theString2a;
          if (result.location) {
            goto LABEL_119;
          }
        }
        return 1;
      }
      BOOL v54 = result.location == 0;
    }
    else
    {
      BOOL v54 = 1;
      CFLocaleRef v5 = v83;
    }
    uint64_t v3 = v81;
    if (DCSDictionary::isNetworkDictionary(*v5))
    {
      v101.CFIndex location = 0;
      v101.CFIndex length = v49;
      if (CFStringFindWithOptionsAndLocale(v22, v47, v101, 0x1A1uLL, v10, &result))
      {
        if (v54) {
          uint64_t v20 = -1;
        }
        else {
          uint64_t v20 = 1;
        }
        CFStringRef v11 = theString2a;
        if ((v54 ^ (result.location == 0))) {
          return v20;
        }
      }
      else
      {
        CFStringRef v11 = theString2a;
        if (v54) {
          return -1;
        }
      }
LABEL_119:
      v103.CFIndex length = CFStringGetLength(v21);
      v103.CFIndex location = 0;
      uint64_t v20 = CFStringCompareWithOptionsAndLocale(v21, v22, v103, 0x121uLL, v10);
      if (v20) {
        return v20;
      }
      if (!theStringa && (*(void *)(v4 + 136) || v5[17]))
      {
        CFStringRef v68 = (const __CFString *)DCSRecord::headword((DCSRecord *)v4);
        CFStringRef v69 = (const __CFString *)DCSRecord::headword((DCSRecord *)v5);
        CFStringRef v70 = (const __CFString *)DCSRecord::headword((DCSRecord *)v4);
        v104.CFIndex length = CFStringGetLength(v70);
        v104.CFIndex location = 0;
        uint64_t v20 = CFStringCompareWithOptionsAndLocale(v68, v69, v104, 0x121uLL, v10);
        if (v20) {
          return v20;
        }
      }
      if (v3)
      {
        CFStringRef v71 = (const __CFString *)*((void *)v3 + 3);
        int HasPrefix = CFStringHasPrefix(v21, v71);
        int v73 = CFStringHasPrefix(v22, v71);
        uint64_t v20 = HasPrefix ? 1 : -1;
        if (HasPrefix != v73) {
          return v20;
        }
      }
      if (DCSRecord::titleString((DCSRecord *)v4) || DCSRecord::titleString((DCSRecord *)v5))
      {
        uint64_t v74 = v4;
        CFStringRef v75 = DCSRecord::titleString((DCSRecord *)v4)
            ? DCSRecord::titleString((DCSRecord *)v4)
            : (CFStringRef)DCSRecord::headword((DCSRecord *)v4);
        CFStringRef v76 = v75;
        CFStringRef v77 = DCSRecord::titleString((DCSRecord *)v5)
            ? DCSRecord::titleString((DCSRecord *)v5)
            : (CFStringRef)DCSRecord::headword((DCSRecord *)v5);
        CFStringRef v78 = v77;
        CFComparisonResult v79 = CFStringCompare(v76, v11, 1uLL);
        CFComparisonResult v80 = CFStringCompare(v78, v11, 1uLL);
        uint64_t v20 = v79 ? 1 : -1;
        uint64_t v4 = v74;
        if (v79 != v80) {
          return v20;
        }
      }
      goto LABEL_142;
    }
    CFStringRef v11 = theString2a;
    if (v54) {
      goto LABEL_119;
    }
    return 1;
  }
  CFRange v24 = v3;
  CFStringRef v25 = (const __CFString *)DCSRecord::headword((DCSRecord *)v4);
  CFStringRef v26 = (const __CFString *)DCSRecord::headword((DCSRecord *)v5);
  CFComparisonResult v27 = CFStringCompare(v25, v11, 0);
  CFStringRef theString = v26;
  CFComparisonResult v28 = CFStringCompare(v26, v11, 0);
  CFComparisonResult v29 = v28;
  if (v27 != v28 && (v27 == kCFCompareEqualTo || v28 == kCFCompareEqualTo)) {
    goto LABEL_94;
  }
  CFStringRef theString2 = v11;
  CFStringRef v30 = (const __CFString *)*((void *)v24 + 2);
  v91.CFIndex length = CFStringGetLength(v25);
  CFStringRef theString1 = v25;
  v91.CFIndex location = 0;
  CFComparisonResult v31 = CFStringCompareWithOptionsAndLocale(v25, v30, v91, 0x121uLL, v10);
  v92.CFIndex length = CFStringGetLength(v26);
  v92.CFIndex location = 0;
  CFComparisonResult v32 = CFStringCompareWithOptionsAndLocale(v26, v30, v92, 0x121uLL, v10);
  CFComparisonResult v33 = v32;
  if (v31 != v32 && (v31 == kCFCompareEqualTo || v32 == kCFCompareEqualTo))
  {
LABEL_95:
    BOOL v15 = v31 == kCFCompareEqualTo;
LABEL_96:
    if (v15) {
      return -1;
    }
    else {
      return 1;
    }
  }
  if (CFEqual(theString1, v26))
  {
    CFStringRef v34 = DCSRecord::titleString((DCSRecord *)v4);
    CFStringRef v35 = DCSRecord::titleString((DCSRecord *)v5);
    if ((unint64_t)v34 | (unint64_t)v35)
    {
      CFStringRef v82 = v34;
      if (v34)
      {
        CFStringRef v36 = v35;
        CFComparisonResult v27 = CFStringCompare(v82, theString2, 0);
        CFStringRef v35 = v36;
        CFStringRef v34 = v82;
      }
      if (v35)
      {
        CFStringRef v37 = v35;
        CFComparisonResult v29 = CFStringCompare(v35, theString2, 0);
        CFStringRef v35 = v37;
        CFStringRef v34 = v82;
      }
      if (!(v27 | v29)) {
        goto LABEL_142;
      }
      if (v27 && v29)
      {
        if (v34)
        {
          CFStringRef v38 = v34;
          CFStringRef v39 = v35;
          v93.CFIndex length = CFStringGetLength(v38);
          v93.CFIndex location = 0;
          CFComparisonResult v31 = CFStringCompareWithOptionsAndLocale(v38, v30, v93, 0x121uLL, v10);
          CFStringRef v35 = v39;
          CFStringRef v34 = v38;
        }
        if (v35)
        {
          CFStringRef v40 = v35;
          v94.CFIndex length = CFStringGetLength(v35);
          v94.CFIndex location = 0;
          CFComparisonResult v33 = CFStringCompareWithOptionsAndLocale(v40, v30, v94, 0x121uLL, v10);
          CFStringRef v35 = v40;
        }
        if (v31 | v33)
        {
          if (v31 && v33)
          {
            if (v34 && v35)
            {
              CFStringRef v41 = v35;
              v42.CFIndex length = CFStringGetLength(v34);
              CFStringRef v43 = v34;
              CFStringRef v44 = v41;
LABEL_115:
              v42.CFIndex location = 0;
              return CFStringCompareWithOptionsAndLocale(v43, v44, v42, 0x121uLL, v10);
            }
            goto LABEL_74;
          }
          goto LABEL_95;
        }
LABEL_142:
        if (*(void *)(v4 + 200) > (uint64_t)v5[25]) {
          return 1;
        }
        else {
          return -1;
        }
      }
LABEL_94:
      BOOL v15 = v27 == kCFCompareEqualTo;
      goto LABEL_96;
    }
  }
LABEL_74:
  int64_t v55 = v24;
  if (!CFStringHasPrefix(v30, @"Ø§Ù„")) {
    goto LABEL_81;
  }
  CFIndex v56 = CFStringGetLength(v30);
  if (v56 < 3) {
    goto LABEL_81;
  }
  v98.CFIndex length = v56 - 2;
  v98.CFIndex location = 2;
  CFStringRef v57 = CFStringCreateWithSubstring(0, v30, v98);
  v99.CFIndex length = CFStringGetLength(theString1);
  v99.CFIndex location = 0;
  CFComparisonResult v58 = CFStringCompareWithOptionsAndLocale(theString1, v57, v99, 0x121uLL, v10);
  v100.CFIndex length = CFStringGetLength(theString);
  v100.CFIndex location = 0;
  CFComparisonResult v59 = CFStringCompareWithOptionsAndLocale(theString, v57, v100, 0x121uLL, v10);
  CFRelease(v57);
  uint64_t v20 = v58 ? 1 : -1;
  if (v58 && v59)
  {
LABEL_81:
    CFRange v60 = (DCSRecord *)v5;
    if (DCSRecord::titleString((DCSRecord *)v4) && !v55[40]) {
      CFStringRef v61 = DCSRecord::titleString((DCSRecord *)v4);
    }
    else {
      CFStringRef v61 = (const __CFString *)DCSRecord::headword((DCSRecord *)v4);
    }
    CFStringRef v62 = v61;
    if (DCSRecord::titleString(v60) && !v55[40]) {
      CFStringRef v63 = DCSRecord::titleString(v60);
    }
    else {
      CFStringRef v63 = (const __CFString *)DCSRecord::headword(v60);
    }
    CFStringRef v64 = v63;
    DistanceBetweenWords(v62, theString2);
    double v66 = v65;
    DistanceBetweenWords(v64, theString2);
    if (v66 != v67)
    {
      if (v66 >= v67) {
        return 1;
      }
      else {
        return -1;
      }
    }
    v42.CFIndex length = CFStringGetLength(theString1);
    CFStringRef v43 = theString1;
    CFStringRef v44 = theString;
    goto LABEL_115;
  }
  return v20;
}

void ReleaseSortStringInfo(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 8));
  CFRelease(*(CFTypeRef *)(a1 + 16));
  CFRelease(*(CFTypeRef *)(a1 + 24));
  CFArrayRef v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t DCSRecordCopyData(uint64_t a1, uint64_t a2)
{
  if (a2 == 4) {
    return 0;
  }
  else {
    return DCSRecordCopyDefinition(a1);
  }
}

uint64_t DCSCopyRecordsForSearchString(uint64_t a1, CFStringRef theString)
{
  if (theString)
  {
    CFStringRef v2 = theString;
    if (CFStringGetLength(theString) <= 100)
    {
      *(unsigned char *)(SyncSingleton<DCSEnvironment>::instance() + 136) = 1;
      if (a1 && (CFLocaleRef v5 = *(DCSDictionary **)(a1 + 16)) != 0)
      {
        if (DCSDictionary::isNetworkDictionary(v5))
        {
          CFStringRef MutableCopy = 0;
          goto LABEL_12;
        }
        CFStringRef v7 = *(DCSDictionary **)(a1 + 16);
      }
      else
      {
        CFStringRef v7 = 0;
      }
      CFStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v2);
      CFLocaleRef v8 = (const __CFLocale *)DCSDictionary::primaryLocale(v7);
      DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v8);
      if (!a1) {
        goto LABEL_15;
      }
      CFStringRef v2 = MutableCopy;
LABEL_12:
      BOOL v9 = *(DCSDictionary **)(a1 + 16);
      if (v9)
      {
        uint64_t v4 = DCSDictionary::searchByString(v9, v2);
        if (!MutableCopy) {
          return v4;
        }
        goto LABEL_16;
      }
LABEL_15:
      uint64_t v4 = 0;
      if (!MutableCopy) {
        return v4;
      }
LABEL_16:
      CFRelease(MutableCopy);
      return v4;
    }
  }
  return 0;
}

uint64_t DCSCopyRecordForReference(uint64_t a1, const __CFString *a2)
{
  if (a1 && (CFStringRef v2 = *(DCSDictionary **)(a1 + 16)) != 0) {
    return DCSDictionary::searchByReference(v2, a2);
  }
  else {
    return 0;
  }
}

void DCSSearchSessionCreate(uint64_t a1, const __CFString *a2)
{
  *(unsigned char *)(SyncSingleton<DCSEnvironment>::instance() + 136) = 1;
  if (a1 && *(void *)(a1 + 16))
  {
    if (DCSDictionary::isNetworkDictionary(*(DCSDictionary **)(a1 + 16))) {
LABEL_8:
    }
      operator new();
    uint64_t v4 = *(DCSDictionary **)(a1 + 16);
  }
  else
  {
    uint64_t v4 = 0;
  }
  CFStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, a2);
  CFLocaleRef v6 = (const __CFLocale *)DCSDictionary::primaryLocale(v4);
  DCSNormalizeSearchStringWithOptionsAndLocale(MutableCopy, 0, v6);
  goto LABEL_8;
}

void sub_1D591211C(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10E0C40DFD76AA2);
  _Unwind_Resume(a1);
}

uint64_t DCSSearchSessionScheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  return DCSSearchSession::scheduleRunLoop(*(DCSSearchSession **)(a1 + 16), a2, a3);
}

uint64_t DCSSearchSessionUnscheduleFromRunLoop(uint64_t a1, __CFRunLoop *a2, const __CFString *a3)
{
  return DCSSearchSession::unscheduleRunLoop(*(DCSSearchSession **)(a1 + 16), a2, a3);
}

uint64_t EqualHeadwordCallback(DCSRecord *a1, DCSRecord *a2)
{
  uint64_t v3 = DCSRecord::headword(a1);
  uint64_t v4 = DCSRecord::headword(a2);

  return CFEqual(v3, v4);
}

CFHashCode HashHeadwordCallback(DCSRecord *a1)
{
  uint64_t v1 = DCSRecord::headword(a1);

  return CFHash(v1);
}

__CFArray *DCSCopyRecordsForHeadword(uint64_t a1, const __CFString *a2)
{
  CFRange result = 0;
  uint64_t v4 = a1;
  if (a1)
  {
    if (a2) {
      return DCSCopyRecordsWithHeadword(1, (uint64_t)&v4, a2);
    }
  }
  return result;
}

DCSRecord *DCSRecordGetDictionary(uint64_t a1)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result) {
    return (DCSRecord *)DCSRecord::dictionaryRef(result);
  }
  return result;
}

uint64_t ComparatorForSortingRecord(void **a1, void **a2, unsigned char *a3)
{
  uint64_t v3 = *a1[2];
  uint64_t v4 = *a2[2];
  if (v3 == v4) {
    return ComparatorForSortingHeadword(a1, a2, a3);
  }
  if (*(void *)(v3 + 72) < *(void *)(v4 + 72)) {
    return -1;
  }
  return 1;
}

DCSRecord *DCSRecordGetString(uint64_t a1)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result) {
    return (DCSRecord *)DCSRecord::keyString(result);
  }
  return result;
}

DCSRecord *DCSRecordGetHeadword(uint64_t a1)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result) {
    return (DCSRecord *)DCSRecord::headword(result);
  }
  return result;
}

DCSRecord *DCSRecordSetHeadword(uint64_t a1, const __CFString *a2)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result) {
    return (DCSRecord *)DCSRecord::setHeadword(result, a2);
  }
  return result;
}

DCSRecord *DCSRecordGetRawHeadword(uint64_t a1)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result) {
    return (DCSRecord *)DCSRecord::dataString(result);
  }
  return result;
}

DCSRecord *DCSRecordGetSupplementalHeadword(uint64_t a1)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result) {
    return (DCSRecord *)DCSRecord::yomiString(result);
  }
  return result;
}

DCSRecord *DCSRecordGetTitle(uint64_t a1)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result) {
    return (DCSRecord *)DCSRecord::titleString(result);
  }
  return result;
}

DCSRecord *DCSRecordGetAnchor(uint64_t a1)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result) {
    return (DCSRecord *)DCSRecord::anchorString(result);
  }
  return result;
}

DCSRecord *DCSRecordGetSubDictionary(uint64_t a1)
{
  CFRange result = *(DCSRecord **)(a1 + 16);
  if (result) {
    return (DCSRecord *)DCSRecord::subDictionaryRef(result);
  }
  return result;
}

uint64_t DCSRecordGetDataURL(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    return *(void *)(v1 + 224);
  }
  else {
    return 0;
  }
}

uint64_t DCSRecordCopyDataURL(uint64_t a1)
{
  uint64_t v1 = *(DCSDictionary ***)(a1 + 16);
  if (!v1) {
    return 0;
  }
  uint64_t v3 = SyncSingleton<DCSEnvironment>::instance();
  DCSEnvironment::logUsageTrackingInfo(v3, a1);

  return DCSRecord::copyDataURL(v1);
}

uint64_t DCSRecordCopyDefinition(uint64_t a1)
{
  uint64_t v1 = *(DCSDictionary ***)(a1 + 16);
  if (!v1) {
    return 0;
  }
  uint64_t v3 = SyncSingleton<DCSEnvironment>::instance();
  DCSEnvironment::logUsageTrackingInfo(v3, a1);

  return DCSRecord::copyData(v1);
}

DCSDictionary **DCSRecordCopyTextElements(uint64_t a1, const __CFArray *a2)
{
  CFRange result = *(DCSDictionary ***)(a1 + 16);
  if (result) {
    return (DCSDictionary **)DCSRecord::copyKeyedElements(result, a2);
  }
  return result;
}

uint64_t DCSRecordSetAssociatedObj(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2) {
    *(void *)(v2 + 240) = a2;
  }
  return result;
}

uint64_t DCSRecordGetAssociatedObj(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1) {
    return *(void *)(v1 + 240);
  }
  else {
    return 0;
  }
}

const void *DCSDictionaryCreate(const __CFURL *a1)
{
  uint64_t v2 = (DCSDictionaryManager *)SyncSingleton<DCSDictionaryManager>::instance();
  uint64_t v3 = DCSDictionaryManager::dictionary(v2, a1, 0);
  StartDownloadDictionaryIfRequired((uint64_t)v3);
  return v3;
}

uint64_t StartDownloadDictionaryIfRequired(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 16);
    uint64_t v2 = v1 ? *(DCSDictionary **)(v1 + 96) : 0;
    CFRange result = DCSMAPrepareMobileAssetQuery();
    if (result == 1)
    {
      return DCSDictionary::startGlobalDictionariesEnvironment(v2);
    }
  }
  return result;
}

const void *DCSDictionaryCreateWithIdentifier(const __CFString *a1)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  CFSetRef v3 = DCSEnvironment::copyAvailableDictionaries(v2);
  if (!v3) {
    return 0;
  }
  CFSetRef v4 = v3;
  CFIndex Count = CFSetGetCount(v3);
  MEMORY[0x1F4188790](Count);
  CFStringRef v7 = (const void **)((char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v6 >= 0x200) {
    size_t v8 = 512;
  }
  else {
    size_t v8 = v6;
  }
  bzero((char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), v8);
  CFSetGetValues(v4, v7);
  if (Count < 1)
  {
LABEL_12:
    CFStringRef v11 = 0;
  }
  else
  {
    while (1)
    {
      if (*v7 && (BOOL v9 = (DCSDictionary *)*((void *)*v7 + 2)) != 0) {
        CFStringRef v10 = (const __CFString *)DCSDictionary::identifier(v9);
      }
      else {
        CFStringRef v10 = 0;
      }
      if (CFEqual(a1, v10)) {
        break;
      }
      ++v7;
      if (!--Count) {
        goto LABEL_12;
      }
    }
    CFStringRef v11 = *v7;
  }
  CFRelease(v4);
  StartDownloadDictionaryIfRequired((uint64_t)v11);
  return v11;
}

CFDictionaryRef DCSDictionaryGetIdentifier(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(DCSDictionary **)(a1 + 16)) != 0) {
    return DCSDictionary::identifier(v1);
  }
  else {
    return 0;
  }
}

uint64_t DCSDictionaryGetURL(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 16);
    if (v1) {
      return *(void *)(v1 + 48);
    }
    else {
      return 0;
    }
  }
  return result;
}

CFDictionaryRef DCSDictionaryGetName(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(DCSDictionary **)(a1 + 16)) != 0) {
    return DCSDictionary::name(v1);
  }
  else {
    return 0;
  }
}

CFStringRef DCSDictionaryGetShortName(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(DCSDictionary **)(a1 + 16)) != 0) {
    return DCSDictionary::shortName(v1);
  }
  else {
    return 0;
  }
}

uint64_t DCSDictionaryGetBaseURL(uint64_t a1)
{
  *(unsigned char *)(SyncSingleton<DCSEnvironment>::instance() + 136) = 1;
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(DCSDictionary **)(a1 + 16);
  if (!v2) {
    return 0;
  }

  return DCSDictionary::baseURL(v2);
}

uint64_t DCSDictionaryGetSubDictionaries(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(DCSDictionary **)(a1 + 16)) != 0) {
    return DCSDictionary::subDictionaries(v1);
  }
  else {
    return 0;
  }
}

uint64_t DCSDictionaryGetParentDictionary(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(DCSDictionary **)(a1 + 16)) != 0) {
    return DCSDictionary::parentDictionary(v1);
  }
  else {
    return 0;
  }
}

uint64_t DCSDictionaryGetPreferenceHTML(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(DCSDictionary **)(a1 + 16)) != 0) {
    return DCSDictionary::preferenceHTML(v1);
  }
  else {
    return 0;
  }
}

const void *DCSDictionaryGetPreference(const void *result)
{
  if (result)
  {
    uint64_t v1 = (DCSDictionary *)*((void *)result + 2);
    if (v1)
    {
      CFStringRef v2 = (const __CFString *)DCSDictionary::identifier(*((DCSDictionary **)result + 2));
      CFSetRef v3 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
      CFRange result = DCSEnvironment::getDictionaryPreference(v3, v2);
      if (!result)
      {
        return (const void *)DCSDictionary::preference(v1);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t DCSDictionarySetPreference(uint64_t result, const __CFDictionary *a2)
{
  if (result)
  {
    CFStringRef v2 = *(DCSDictionary **)(result + 16);
    if (v2)
    {
      Preference = DCSDictionaryGetPreference((const void *)result);
      if (!Preference || (CFRange result = CFEqual(Preference, a2), !result))
      {
        DCSDictionary::setPreference(v2, a2);
        CFDictionaryRef v5 = (const __CFDictionary *)DCSDictionary::preference(v2);
        unint64_t v6 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
        CFStringRef v7 = (const __CFString *)DCSDictionary::identifier(v2);
        return DCSEnvironment::setDictionaryPreference(v6, v7, v5);
      }
    }
  }
  return result;
}

CFArrayRef DCSDictionaryGetLanguages(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(CFDictionaryRef **)(a1 + 16)) != 0) {
    return DCSDictionary::languages(v1);
  }
  else {
    return 0;
  }
}

CFTypeRef DCSDictionaryCopyResourceURLsOfType(uint64_t a1, CFStringRef theString1)
{
  if (!a1) {
    return 0;
  }
  CFStringRef v2 = *(DCSDictionary **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  if (CFStringCompare(theString1, @"DCSResourceTypeStyleSheet", 0))
  {
    if (CFStringCompare(theString1, @"DCSResourceTypePrivateFont", 0)) {
      return 0;
    }
    CFSetRef v4 = (const void *)DCSDictionary::privateFontURLs(v2);
    if (!v4) {
      return 0;
    }
  }
  else
  {
    CFSetRef v4 = (const void *)DCSDictionary::styleSheetURLs(v2);
    if (!v4) {
      return 0;
    }
  }

  return CFRetain(v4);
}

void DCSDictionarySetDataHeader(uint64_t a1, const __CFString *a2, uint64_t a3, int a4, const __CFString *a5)
{
  if (a1)
  {
    CFDictionaryRef v5 = *(DCSDictionary **)(a1 + 16);
    if (v5) {
      DCSDictionary::setCustomHTMLHeader(v5, a2, a3, a4, a5);
    }
  }
}

CFDictionaryRef DCSDictionaryIsNetworkService(const __CFDictionary *result)
{
  if (result)
  {
    CFRange result = (const __CFDictionary *)*((void *)result + 2);
    if (result) {
      return DCSDictionary::isNetworkDictionary(result);
    }
  }
  return result;
}

DCSDictionary *DCSDictionaryIsLanguageDictionary(DCSDictionary *result)
{
  if (result)
  {
    CFRange result = (DCSDictionary *)*((void *)result + 2);
    if (result) {
      return (DCSDictionary *)DCSDictionary::isLanguageDictionary(result);
    }
  }
  return result;
}

CFDictionaryRef DCSDictionaryGetAssetObj(uint64_t a1)
{
  if (a1 && (v1 = *(void *)(a1 + 16)) != 0 && (CFDictionaryRef v2 = *(const __CFDictionary **)(v1 + 96)) != 0) {
    return DCSMAGetAssetObj(v2);
  }
  else {
    return 0;
  }
}

uint64_t DCSDictionaryDownloadFinished(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(DCSDictionary **)(a1 + 16);
    if (v1)
    {
      CFDictionaryRef v2 = (DCSDictionary *)*((void *)v1 + 12);
      if (v2) {
        DCSDictionary::startGlobalDictionariesEnvironment(v2);
      }
    }
  }
  else
  {
    uint64_t v1 = 0;
  }

  return DCSDictionary::baseURL(v1);
}

CFSetRef DCSCopyLanguagesOfPreparedDefaultDictionaries()
{
  values[1] = *(void **)MEMORY[0x1E4F143B8];
  if (!DCSMAPrepareMobileAssetQuery()) {
    return 0;
  }
  DCSDictionary::startGlobalDictionariesEnvironment((DCSDictionary *)1);
  CFArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v1 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  CFDictionaryRef v2 = DCSEnvironment::copyActiveDictionaries(v1, 0);
  if (v2)
  {
    CFArrayRef v3 = v2;
    CFIndex Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0;
      CFStringRef v7 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
      do
      {
        CFDictionaryRef ValueAtIndex = (DCSDictionary **)CFArrayGetValueAtIndex(v3, v6);
        values[0] = 0;
        if (!ValueAtIndex) {
          goto LABEL_27;
        }
        BOOL v9 = ValueAtIndex;
        CFStringRef v10 = ValueAtIndex[2];
        if (!v10) {
          goto LABEL_27;
        }
        CFStringRef v11 = DCSDictionary::primaryLanguage(v10);
        values[0] = v11;
        if (v11) {
          CFDictionarySetValue(Mutable, v11, &stru_1F2DE4460);
        }
        CFStringRef v12 = v9[2];
        if (!v12) {
          goto LABEL_27;
        }
        CFDictionaryRef v13 = DCSDictionary::identifier(v12);
        if (!v13) {
          goto LABEL_27;
        }
        uint64_t v14 = (uint64_t)v13;
        BOOL v15 = v9[2];
        if (!v15 || !DCSDictionary::isLanguageDictionary(v15)) {
          goto LABEL_27;
        }
        BOOL v16 = (CFDictionaryRef *)v9[2];
        if (v16 && (CFArrayRef v17 = DCSDictionary::languages(v16)) != 0)
        {
          CFArrayRef v18 = v17;
          CFStringRef v19 = CFArrayCreateMutable(0, 0, v7);
          CFIndex v20 = CFArrayGetCount(v18);
          if (v20 >= 1)
          {
            CFIndex v21 = v20;
            for (CFIndex i = 0; i != v21; ++i)
            {
              CFDictionaryRef v23 = (const __CFDictionary *)CFArrayGetValueAtIndex(v18, i);
              CFStringRef Value = CFDictionaryGetValue(v23, @"DCSDictionaryIndexLanguage");
              if (Value) {
                CFArrayAppendValue(v19, Value);
              }
            }
          }
          if (CFArrayGetCount(v19) <= 0)
          {
            CFRelease(v19);
            CFStringRef v7 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
            goto LABEL_27;
          }
          CFStringRef v7 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
          if (!v19) {
            goto LABEL_27;
          }
        }
        else
        {
          if (!values[0]) {
            goto LABEL_27;
          }
          CFStringRef v19 = CFArrayCreate(0, (const void **)values, 1, v7);
          if (!v19) {
            goto LABEL_27;
          }
        }
        DCSMAUpdateLinguisticData(v14, v19, 1);
        CFRelease(v19);
LABEL_27:
        ++v6;
      }
      while (v6 != v5);
    }
    CFRelease(v3);
  }
  CFIndex v25 = CFDictionaryGetCount(Mutable);
  if (v25 < 1)
  {
    CFSetRef v30 = 0;
  }
  else
  {
    CFIndex v26 = v25;
    MEMORY[0x1F4188790](v25);
    CFComparisonResult v28 = (const void **)((char *)values - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v27 >= 0x200) {
      size_t v29 = 512;
    }
    else {
      size_t v29 = v27;
    }
    bzero((char *)values - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0), v29);
    CFDictionaryGetKeysAndValues(Mutable, v28, 0);
    CFSetRef v30 = CFSetCreate(0, v28, v26, MEMORY[0x1E4F1D548]);
  }
  CFRelease(Mutable);
  DCSDictionary::startGlobalDictionariesEnvironment(0);
  return v30;
}

uint64_t DCSPrepareMobileAssetQuery()
{
  return DCSMAPrepareMobileAssetQuery();
}

uint64_t DCSGetServicePresentationType()
{
  uint64_t v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();

  return DCSEnvironment::copyInactiveDictionaries(v0, v1);
}

CFNumberRef DCSSetServicePresentationType(__int16 a1)
{
  CFDictionaryRef v2 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();

  return DCSEnvironment::setServiceWindowType(v2, a1);
}

void DCSActivateDictionaryPanel(CFDataRef theData)
{
  if (theData)
  {
    if (!CFDataGetLength(theData))
    {
      BOOL v2 = 0;
      goto LABEL_7;
    }
  }
  else if (DCSActivateDictionaryPanel::_PanelIsBeingShown)
  {
    return;
  }
  Remote = CFMessagePortCreateRemote(0, @"com.apple.DictionaryPanelHelper");
  if (!Remote) {
    return;
  }
  CFSetRef v4 = Remote;
  SInt32 v5 = CFMessagePortSendRequest(Remote, 1, theData, 5.0, 5.0, @"DCSActivateDictionaryPanelReplyModes", 0);
  CFRelease(v4);
  BOOL v2 = v5 == 0;
LABEL_7:
  DCSActivateDictionaryPanel::_PanelIsBeingShown = v2;
}

uint64_t DCSCreateAppleWordEquivalenceList(uint64_t a1)
{
  if (a1) {
    return (uint64_t)CreateWordEquivalenceList(a1);
  }
  return a1;
}

void DCSNormalizeSearchString(const __CFString *a1)
{
}

DIR *IterateDirectory(const char *a1, unsigned int (*a2)(char *, uint64_t, uint64_t), uint64_t a3)
{
  CFRange result = opendir(a1);
  if (result)
  {
    CFStringRef v7 = result;
    size_t v8 = strlen(a1) + 256;
    BOOL v9 = (char *)malloc_type_malloc(v8, 0x413E99EuLL);
    strlcpy(v9, a1, v8);
    size_t v10 = strlen(a1);
    *(_WORD *)&v9[v10] = 47;
    CFStringRef v11 = &v9[v10 + 1];
    memset(&v16, 0, sizeof(v16));
    CFStringRef v12 = readdir(v7);
    if (v12)
    {
      CFDictionaryRef v13 = v12;
      do
      {
        int v15 = v13->d_name[0];
        d_name = v13->d_name;
        if (v15 != 46)
        {
          strlcpy(v11, d_name, 0x100uLL);
          if ((stat(v9, &v16) & 0x80000000) == 0)
          {
            if ((v16.st_mode & 0xF000) == 0x4000)
            {
              if (a2(v9, 1, a3)) {
                IterateDirectory(v9, a2, a3);
              }
            }
            else
            {
              a2(v9, 0, a3);
            }
          }
        }
        CFDictionaryRef v13 = readdir(v7);
      }
      while (v13);
    }
    free(v9);
    return (DIR *)closedir(v7);
  }
  return result;
}

BOOL ItemExistsAtPath(const char *a1, int a2)
{
  if (a2)
  {
    memset(&v4, 0, sizeof(v4));
    return !stat(a1, &v4) && (v4.st_mode & 0xF000) == 0x4000;
  }
  else
  {
    return access(a1, 0) == 0;
  }
}

uint64_t ItemExistsAtURL(const __CFURL *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024);
  if (result)
  {
    int v3 = CFURLHasDirectoryPath(a1);
    return ItemExistsAtPath((const char *)buffer, v3);
  }
  return result;
}

CFStringRef CopyFileObjectIdentifierAtURL(const __CFURL *a1)
{
  CFURLRef v1 = CFURLCopyAbsoluteURL(a1);
  CFStringRef v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  CFRelease(v1);
  return v2;
}

void BuildWordBreakTable(CFStringRef str, CFRange range, const __CFLocale *a3, char *__b)
{
  CFIndex length = range.length;
  CFIndex location = range.location;
  if ((range.length & 0x8000000000000000) == 0) {
    memset(__b, 255, 8 * range.length + 8);
  }
  v12.CFIndex location = location;
  v12.CFIndex length = length;
  CFStringRef v9 = CFStringCreateWithSubstring(0, str, v12);
  v13.CFIndex location = 0;
  v13.CFIndex length = length;
  CFStringTokenizerRef v10 = CFStringTokenizerCreate(0, v9, v13, 0x80uLL, a3);
  if (v10)
  {
    CFStringTokenizerRef v11 = v10;
    while (_CFStringTokenizerTokenize())
    {
      *(void *)__b = 1;
      bzero(__b + 8, 0xFFFFFFFFFFFFFFF8);
    }
    CFRelease(v11);
    CFRelease(v9);
  }
}

CFTypeRef CopyPreferredEnglishLanguage(CFLocaleIdentifier localeID)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  CFLocaleIdentifier v23 = localeID;
  ComponentsFromLocaleCFStringRef Identifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, localeID);
  CFStringRef v2 = (void *)*MEMORY[0x1E4F1D1F0];
  int v3 = (const void **)MEMORY[0x1E4F1D218];
  if (ComponentsFromLocaleIdentifier)
  {
    CFDictionaryRef v4 = ComponentsFromLocaleIdentifier;
    if (CFDictionaryGetValue(ComponentsFromLocaleIdentifier, (const void *)*MEMORY[0x1E4F1D1F0]))
    {
      CFStringRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v4);
      CFDictionarySetValue(MutableCopy, *v3, @"en");
      CFLocaleIdentifier LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents(0, MutableCopy);
      CFRelease(MutableCopy);
      if (LocaleIdentifierFromComponents)
      {
        char v7 = 0;
        CFLocaleIdentifier v23 = LocaleIdentifierFromComponents;
LABEL_8:
        CFRelease(v4);
        goto LABEL_9;
      }
    }
    else
    {
      CFLocaleIdentifier LocaleIdentifierFromComponents = 0;
    }
    char v7 = 1;
    goto LABEL_8;
  }
  CFLocaleIdentifier LocaleIdentifierFromComponents = 0;
  char v7 = 1;
LABEL_9:
  uint64_t v8 = 0;
  keys[0] = (void *)*v3;
  keys[1] = v2;
  CFTypeRef cf = 0;
  CFTypeRef v26 = 0;
  char v9 = 1;
  CFStringTokenizerRef v10 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFStringTokenizerRef v11 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  do
  {
    CFRange v12 = off_1E6A59470[v8];
    char v13 = v9;
    values[0] = @"en";
    values[1] = v12;
    CFDictionaryRef v14 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, v10, v11);
    *(&cf + v8) = CFLocaleCreateLocaleIdentifierFromComponents(0, v14);
    CFRelease(v14);
    char v9 = 0;
    uint64_t v8 = 1;
  }
  while ((v13 & 1) != 0);
  int v15 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef v16 = CFArrayCreate(0, &cf, 2, MEMORY[0x1E4F1D510]);
  CFArrayRef v17 = CFArrayCreate(0, (const void **)&v23, 1, v15);
  CFArrayRef v18 = CFBundleCopyLocalizationsForPreferences(v16, v17);
  if (v18)
  {
    CFArrayRef v19 = v18;
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v18, 0);
    CFTypeRef v21 = CFRetain(ValueAtIndex);
    CFRelease(v19);
  }
  else
  {
    CFTypeRef v21 = 0;
  }
  CFRelease(v16);
  CFRelease(v17);
  CFRelease(cf);
  CFRelease(v26);
  if ((v7 & 1) == 0) {
    CFRelease(LocaleIdentifierFromComponents);
  }
  return v21;
}

uint64_t CompareLanguageCode(const __CFString *a1, CFStringRef theString2, unsigned char *a3)
{
  uint64_t CanonicalLocaleIdentifierFromString = 0;
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  CFStringRef v46 = 0;
  CFStringRef v47 = 0;
  CFStringRef theString1 = 0;
  CFStringRef theString2a = 0;
  long long v43 = 0uLL;
  if (!a1 || !theString2) {
    return CanonicalLocaleIdentifierFromString;
  }
  if (CFStringCompare(a1, theString2, 1uLL) == kCFCompareEqualTo
    || CFEqual(a1, @"*")
    || CFEqual(theString2, @"*"))
  {
    uint64_t CanonicalLocaleIdentifierFromString = 1;
    if (a3) {
      *a3 = 1;
    }
    return CanonicalLocaleIdentifierFromString;
  }
  if (a3) {
    *a3 = 0;
  }
  uint64_t CanonicalLocaleIdentifierFromString = (uint64_t)CFLocaleCreateCanonicalLocaleIdentifierFromString(0, a1);
  uint64_t v48 = CanonicalLocaleIdentifierFromString;
  if (!CanonicalLocaleIdentifierFromString) {
    return CanonicalLocaleIdentifierFromString;
  }
  if (!CFLocaleCreateCanonicalLocaleIdentifierFromString(0, theString2))
  {
    CFRelease((CFTypeRef)CanonicalLocaleIdentifierFromString);
    return 0;
  }
  CFStringRef v38 = a3;
  uint64_t v7 = 0;
  v42[0] = 0;
  v42[1] = 0;
  key = (void *)*MEMORY[0x1E4F1D218];
  CFStringRef v40 = (void *)*MEMORY[0x1E4F1D1F0];
  char v8 = 1;
  CFStringRef v39 = (void *)*MEMORY[0x1E4F1D220];
  do
  {
    char v9 = v8;
    ComponentsFromLocaleCFStringRef Identifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, (CFLocaleIdentifier)*(&v48 + v7));
    v42[v7] = ComponentsFromLocaleIdentifier;
    if (ComponentsFromLocaleIdentifier)
    {
      CFDictionaryRef v11 = ComponentsFromLocaleIdentifier;
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, key);
      CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(v11, v40);
      ComponentsFromLocaleCFStringRef Identifier = (const __CFDictionary *)CFDictionaryGetValue(v11, v39);
    }
    else
    {
      CFStringRef Value = 0;
      CFStringRef v13 = 0;
    }
    char v8 = 0;
    *(&v46 + v7) = Value;
    *(&theString1 + v7) = v13;
    *((void *)&v43 + v7) = ComponentsFromLocaleIdentifier;
    uint64_t v7 = 1;
  }
  while ((v9 & 1) != 0);
  uint64_t v14 = 0;
  char v15 = 1;
  CFStringRef v16 = @"en";
  CFStringRef v17 = @"nb";
  do
  {
    char v18 = v15;
    CFStringRef v19 = *(&v46 + v14);
    if (!v19) {
      goto LABEL_36;
    }
    if (CFStringCompare(*(&v46 + v14), @"zh", 0))
    {
      if (CFStringCompare(v19, v16, 0) || !*(&theString1 + v14))
      {
        if (CFEqual(v19, v17)
          || CFEqual(v19, @"nn"))
        {
          *(&v46 + v14) = @"no";
        }
      }
      else
      {
        CFStringRef v22 = v17;
        CFStringRef v23 = (const __CFString *)CopyPreferredEnglishLanguage((CFLocaleIdentifier)*(&v48 + v14));
        CFRange v24 = (const void *)v42[v14];
        if (v24) {
          CFRelease(v24);
        }
        CFStringRef v25 = v16;
        CFDictionaryRef v26 = CFLocaleCreateComponentsFromLocaleIdentifier(0, v23);
        v42[v14] = v26;
        if (v26)
        {
          CFDictionaryRef v27 = v26;
          CFStringRef v28 = (const __CFString *)CFDictionaryGetValue(v26, key);
          CFStringRef v29 = (const __CFString *)CFDictionaryGetValue(v27, v40);
          CFDictionaryRef v26 = (const __CFDictionary *)CFDictionaryGetValue(v27, v39);
        }
        else
        {
          CFStringRef v28 = 0;
          CFStringRef v29 = 0;
        }
        *(&v46 + v14) = v28;
        *(&theString1 + v14) = v29;
        *((void *)&v43 + v14) = v26;
        CFRelease(v23);
        CFStringRef v16 = v25;
        CFStringRef v17 = v22;
      }
    }
    else if (!*((void *)&v43 + v14))
    {
      CFStringRef v20 = *(&theString1 + v14);
      if (v20)
      {
        if (CFStringCompare(*(&theString1 + v14), @"CN", 1uLL))
        {
          if (CFStringCompare(v20, @"TW", 1uLL)) {
            goto LABEL_36;
          }
          CFTypeRef v21 = @"Hant";
        }
        else
        {
          CFTypeRef v21 = @"Hans";
        }
        *((void *)&v43 + v14) = v21;
      }
    }
LABEL_36:
    char v15 = 0;
    uint64_t v14 = 1;
  }
  while ((v18 & 1) != 0);
  if (v46) {
    BOOL v30 = v47 == 0;
  }
  else {
    BOOL v30 = 1;
  }
  if (v30 || CFStringCompare(v46, v47, 1uLL))
  {
    uint64_t CanonicalLocaleIdentifierFromString = 0;
  }
  else
  {
    if (v38) {
      unsigned char *v38 = 1;
    }
    CFStringRef v37 = (const __CFString *)*((void *)&v43 + 1);
    CFStringRef v36 = (const __CFString *)v43;
    if (v43 == 0)
    {
      CFStringRef v36 = theString1;
      uint64_t CanonicalLocaleIdentifierFromString = 1;
      if (!theString1) {
        goto LABEL_43;
      }
      CFStringRef v37 = theString2a;
    }
    else
    {
      uint64_t CanonicalLocaleIdentifierFromString = 0;
      if (!(void)v43) {
        goto LABEL_43;
      }
    }
    if (v37) {
      uint64_t CanonicalLocaleIdentifierFromString = CFStringCompare(v36, v37, 1uLL) == kCFCompareEqualTo;
    }
  }
LABEL_43:
  uint64_t v31 = 0;
  char v32 = 1;
  do
  {
    char v33 = v32;
    CFRelease((CFTypeRef)*(&v48 + v31));
    CFStringRef v34 = (const void *)v42[v31];
    if (v34) {
      CFRelease(v34);
    }
    char v32 = 0;
    uint64_t v31 = 1;
  }
  while ((v33 & 1) != 0);
  return CanonicalLocaleIdentifierFromString;
}

__CFString *GetScriptForLanguage(CFStringRef theString1)
{
  if (GetScriptForLanguage__DispatchOnceToken != -1) {
    dispatch_once(&GetScriptForLanguage__DispatchOnceToken, &__block_literal_global_3);
  }
  if (CFStringCompare(theString1, @"ja", 1uLL) == kCFCompareEqualTo) {
    return @"Jpan";
  }
  if (CFStringCompare(theString1, @"ko", 1uLL) == kCFCompareEqualTo) {
    return @"Kore";
  }
  if (CFStringCompare(theString1, @"zh-Hans", 1uLL) == kCFCompareEqualTo) {
    return @"Hans";
  }
  if (CFStringCompare(theString1, @"zh-Hant", 1uLL) == kCFCompareEqualTo) {
    return @"Hant";
  }
  CFArrayRef v2 = (const __CFArray *)GetScriptForLanguage__LatinLanguagesArray;
  v4.CFIndex length = CFArrayGetCount((CFArrayRef)GetScriptForLanguage__LatinLanguagesArray);
  v4.CFIndex location = 0;
  if (CFArrayContainsValue(v2, v4, theString1)) {
    return @"Latn";
  }
  else {
    return 0;
  }
}

CFArrayRef __GetScriptForLanguage_block_invoke()
{
  __dst[124] = *(const void **)MEMORY[0x1E4F143B8];
  memcpy(__dst, off_1E6A594A0, 0x3E0uLL);
  CFArrayRef result = CFArrayCreate(0, __dst, 124, MEMORY[0x1E4F1D510]);
  GetScriptForLanguage__LatinLanguagesArray = (uint64_t)result;
  return result;
}

uint64_t DetectEncodingOfStringData(const __CFData *a1)
{
  ucsdet_open();
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  ucsdet_setText();
  ucsdet_detect();
  Name = (const char *)ucsdet_getName();
  if (Name && (CFStringRef v5 = CFStringCreateWithCString(0, Name, 0x8000100u)) != 0)
  {
    CFStringRef v6 = v5;
    uint64_t v2 = CFStringConvertIANACharSetNameToEncoding(v5);
    CFRelease(v6);
  }
  else
  {
    uint64_t v2 = 0xFFFFFFFFLL;
  }
  ucsdet_close();
  return v2;
}

uint64_t ExtraNormalizeStringForArabic(__CFString *a1, int a2)
{
  CFStringNormalize(a1, kCFStringNormalizationFormD);
  v6.CFIndex location = 0;
  v6.CFIndex length = CFStringGetLength(a1);
  if (a2) {
    CFStringRef v4 = @"[\\u0610-\\u061A \\u064B-\\u065F \\u0670 \\u06D6-\\u06DC \\u06DF-\\u06E4 \\u06E7-\\u06E8 \\u06EA-\\u06ED] Remove";
  }
  else {
    CFStringRef v4 = @"[\\u0610-\\u061A \\u064B-\\u0652 \\u0656-\\u065F \\u0670 \\u06D6-\\u06DC \\u06E1-\\u06E3 \\u06E7-\\u06E8 \\u06EA-\\u06ED] Remove";
  }
  return CFStringTransform(a1, &v6, v4, 0);
}

BOOL ContainsLatinAlphabets(const __CFString *a1)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  uint64_t Length = CFStringGetLength(a1);
  MEMORY[0x1F4188790](Length);
  CFStringRef v4 = (UniChar *)((char *)v9 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  v10.CFIndex location = 0;
  v10.CFIndex length = Length;
  CFStringGetCharacters(a1, v10, v4);
  if (Length < 1) {
    return 0;
  }
  if ((*v4 & 0xFFDFu) - 65 < 0x1A) {
    return 1;
  }
  uint64_t v6 = 1;
  do
  {
    uint64_t v7 = v6;
    if (Length == v6) {
      break;
    }
    unsigned int v8 = (v4[v6++] & 0xFFDF) - 65;
  }
  while (v8 > 0x19);
  return v7 < Length;
}

void DistanceBetweenWords(CFStringRef theString, const __CFString *a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, theString);
  CFMutableStringRef v4 = CFStringCreateMutableCopy(0, 0, a2);
  CFStringNormalize(MutableCopy, kCFStringNormalizationFormD);
  CFStringNormalize(v4, kCFStringNormalizationFormD);
  CFIndex Length = CFStringGetLength(MutableCopy);
  MEMORY[0x1F4188790](Length);
  CFMutableStringRef v35 = MutableCopy;
  v42.CFIndex location = 0;
  v42.CFIndex length = Length;
  CFStringRef v38 = (char *)v33 - v6;
  CFStringGetCharacters(MutableCopy, v42, (UniChar *)((char *)v33 - v6));
  CFIndex v7 = CFStringGetLength(v4);
  MEMORY[0x1F4188790](v7);
  CFMutableStringRef v34 = v4;
  v43.CFIndex location = 0;
  v43.CFIndex length = v7;
  CFStringRef v37 = (char *)v33 - v8;
  CFStringGetCharacters(v4, v43, (UniChar *)((char *)v33 - v8));
  uint64_t v40 = v7;
  v33[1] = Length + 1 + (Length + 1) * v7;
  MEMORY[0x1F4188790](v9);
  CFRange v12 = (double *)((char *)v33 - v11);
  uint64_t v39 = Length;
  if ((Length & 0x8000000000000000) == 0)
  {
    uint64_t v13 = 0;
    do
    {
      v12[v13] = (double)v13;
      ++v13;
    }
    while (v10 != v13);
  }
  uint64_t v14 = v39;
  if ((v40 & 0x8000000000000000) == 0)
  {
    uint64_t v15 = 0;
    uint64_t v16 = v40 + 1;
    CFStringRef v17 = v12;
    do
    {
      *CFStringRef v17 = (double)v15++;
      CFStringRef v17 = (double *)((char *)v17 + v14 * 8 + 8);
    }
    while (v16 != v15);
  }
  CFStringRef v36 = v12;
  if (v39 >= 1)
  {
    char v18 = v36 + 1;
    uint64_t v19 = 1;
    do
    {
      if (v40 >= 1)
      {
        int v20 = *(unsigned __int16 *)&v38[2 * v19 - 2];
        BOOL isDiacritic = _isDiacritic(v20);
        if (isDiacritic) {
          double v22 = 0.1;
        }
        else {
          double v22 = 1.0;
        }
        CFStringRef v23 = (unsigned __int16 *)v37;
        CFRange v24 = v18;
        uint64_t v25 = v40;
        do
        {
          int v27 = *v23++;
          int v26 = v27;
          if (v20 == v27) {
            double v28 = 0.0;
          }
          else {
            double v28 = 2.0;
          }
          BOOL v29 = _isDiacritic(v26);
          if (isDiacritic && v29)
          {
            double v30 = v28 / 100.0;
          }
          else
          {
            double v30 = v28 * 0.5;
            if (!isDiacritic && !v29) {
              double v30 = v28;
            }
          }
          if (v29) {
            double v31 = 0.1;
          }
          else {
            double v31 = 1.0;
          }
          v24[v14 + 1] = fmin(v30 + *(v24 - 1), fmin(v22 + v24[v14], v31 + *v24));
          CFRange v24 = (double *)((char *)v24 + v14 * 8 + 8);
          --v25;
        }
        while (v25);
      }
      ++v18;
    }
    while (v19++ != v39);
  }
  CFRelease(v35);
  CFRelease(v34);
}

BOOL _isDiacritic(int a1)
{
  unsigned int v2 = a1 - 1552;
  BOOL result = 1;
  if (v2 >= 0xB
    && (a1 - 1611) >= 0x15
    && ((a1 - 1750) > 0x17 || ((1 << (a1 + 42)) & 0xF67E7F) == 0))
  {
    return a1 == 1648;
  }
  return result;
}

uint64_t IsWorkingInDictionaryApp()
{
  if (IsWorkingInDictionaryApp__OnceToken != -1) {
    dispatch_once(&IsWorkingInDictionaryApp__OnceToken, &__block_literal_global_421);
  }
  return IsWorkingInDictionaryApp__Flag;
}

void DCSLog(int a1, CFStringRef format, ...)
{
  va_start(va, format);
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (DCSLog__OnceToken != -1) {
    dispatch_once(&DCSLog__OnceToken, &__block_literal_global_427);
  }
  if (a1 > 15)
  {
    if (a1 == 16)
    {
      uint64_t v4 = 3;
      goto LABEL_13;
    }
    if (a1 == 17)
    {
      uint64_t v4 = 4;
      goto LABEL_13;
    }
  }
  else
  {
    if (a1 == 1)
    {
      uint64_t v4 = 1;
      goto LABEL_13;
    }
    if (a1 == 2)
    {
      uint64_t v4 = 2;
      goto LABEL_13;
    }
  }
  uint64_t v4 = 0;
LABEL_13:
  CFStringRef v5 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  if (v5)
  {
    CFStringRef v6 = v5;
    CFIndex v7 = DCSLog__LogObj[v4];
    if (os_log_type_enabled(v7, (os_log_type_t)a1))
    {
      *(_DWORD *)buf = 138543362;
      CFStringRef v9 = v6;
      _os_log_impl(&dword_1D58FF000, v7, (os_log_type_t)a1, "%{public}@", buf, 0xCu);
    }
    CFRelease(v6);
  }
}

os_log_t __DCSLog_block_invoke()
{
  for (uint64_t i = 0; i != 5; ++i)
  {
    os_log_t result = os_log_create("com.apple.DictionaryServices", off_1E6A598C0[i]);
    DCSLog__LogObj[i] = (uint64_t)result;
  }
  return result;
}

__CFArray *CreateWordEquivalenceList(uint64_t a1)
{
  CFStringRef v1 = (const __CFString *)MEMORY[0x1F4188790](a1);
  v47[1024] = *MEMORY[0x1E4F143B8];
  CFURLRef v2 = (const __CFURL *)_PrivateWEDictURL;
  if (!_PrivateWEDictURL)
  {
    pthread_once(&CreateWordEquivalenceList::once_control, (void (*)(void))InitializeDictionaryStuff);
    CFURLRef v2 = (const __CFURL *)_PrivateWEDictURL;
    if (!_PrivateWEDictURL) {
      return 0;
    }
  }
  uint64_t v40 = IDXCreateIndexObject(0, v2, 0);
  if (!v40) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(v1);
  uint64_t v35 = (uint64_t)&v35;
  uint64_t v4 = MEMORY[0x1F4188790](Length);
  CFStringRef v6 = (UniChar *)((char *)&v35 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v4);
  uint64_t v8 = (char *)&v35 - ((v7 + 23) & 0xFFFFFFFFFFFFFFF0);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v1);
  CFStringLowercase(MutableCopy, 0);
  v48.CFIndex location = 0;
  v48.CFIndex length = Length;
  CFStringGetCharacters(MutableCopy, v48, v6);
  CFRelease(MutableCopy);
  uint64_t v39 = v6;
  int v10 = v6[Length - 1];
  if (v10 == 42) {
    CFIndex v11 = Length - 1;
  }
  else {
    CFIndex v11 = Length;
  }
  v49.CFIndex location = 0;
  v49.CFIndex length = v11;
  CFRange v43 = v8;
  BuildWordBreakTable(v1, v49, 0, v8);
  int v38 = v10;
  if (v10 == 42) {
    *(void *)&v43[8 * Length - 8] = -1;
  }
  memset(v47, 0, 512);
  CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (v11 >= 1)
  {
    uint64_t v12 = 0;
    CFStringRef v36 = @"IDXPrefixMatch";
    CFStringRef v37 = @"IDXCommonPrefixMatch";
    uint64_t v13 = v43;
    do
    {
      if (*(void *)&v43[8 * v12] == 1)
      {
        uint64_t v14 = (uint64_t)v40;
        uint64_t v41 = v11 - v12;
        CFRange v42 = &v39[v12];
        IDXSetSearchCharacters((uint64_t)v40, (uint64_t)v42, v11 - v12, (uint64_t)v37);
        uint64_t matched = IDXGetMatchDataPtr(v14, 1024, (uint64_t)v47, (uint64_t)v46);
        uint64_t v16 = matched;
        if (matched)
        {
          if (matched >= 1)
          {
            CFStringRef v17 = v46;
            char v18 = v45;
            uint64_t v19 = (const unsigned __int8 **)v47;
            uint64_t v20 = matched;
            do
            {
              CFTypeRef v21 = *v19;
              unint64_t v22 = (unint64_t)*(unsigned __int16 *)*v19 >> 1;
              unint64_t *v18 = v22;
              __int16 v23 = v22 + v12;
              if (v11 >= v23 && *(void *)&v43[8 * v23]) {
                AddSynonymsToArray(Mutable, 0, 0, v21, *v17);
              }
              ++v17;
              ++v18;
              ++v19;
              --v20;
            }
            while (v20);
          }
        }
        else
        {
          uint64_t v24 = 1;
          do
          {
            CFIndex v25 = v24;
            if (v12 + v24 >= v11) {
              break;
            }
            ++v24;
          }
          while (!*(void *)&v13[8 * v25]);
          AddSynonymsToArray(Mutable, v42, v25, 0, 0);
        }
        if (v38 == 42)
        {
          uint64_t v26 = (uint64_t)v40;
          IDXSetSearchCharacters((uint64_t)v40, (uint64_t)v42, v41, (uint64_t)v36);
          uint64_t v27 = IDXGetMatchDataPtr(v26, 1024, (uint64_t)v47, (uint64_t)v46);
          if (v27 >= 1)
          {
            uint64_t v28 = v27;
            uint64_t v29 = 0;
            CFIndex v30 = v41 + 1;
            do
            {
              double v31 = (const unsigned __int8 *)v47[v29];
              if (v16 < 1)
              {
                uint64_t v32 = 0;
              }
              else
              {
                uint64_t v32 = 0;
                int v33 = 0;
                do
                {
                  if (v45[v32] == (unint64_t)*(unsigned __int16 *)v31 >> 1) {
                    break;
                  }
                  uint64_t v32 = (__int16)++v33;
                }
                while (v16 > (__int16)v33);
              }
              if (v16 == v32) {
                AddSynonymsToArray(Mutable, v42, v30, v31, v46[v29]);
              }
              ++v29;
            }
            while (v29 != v28);
          }
        }
      }
      ++v12;
      v13 += 8;
    }
    while (v12 != v11);
  }
  CFRelease(v40);
  return Mutable;
}

CFURLRef InitializeDictionaryStuff(void)
{
  uint64_t v0 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(v0);
  CFURLRef result = CFBundleCopyResourceURL(FrameworkBundle, @"WordEquivalence", @"dictionary", 0);
  _PrivateWEDictURL = (uint64_t)result;
  if (result)
  {
    return (const __CFURL *)IDXCreateIndexObject(0, result, 0);
  }
  return result;
}

void AddSynonymsToArray(__CFArray *a1, const unsigned __int16 *a2, CFIndex a3, const unsigned __int8 *a4, uint64_t a5)
{
  CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (a2)
  {
    CFStringRef v11 = CFStringCreateWithCharacters(0, a2, a3);
    CFArrayAppendValue(Mutable, v11);
    CFRelease(v11);
  }
  if (a5 >= 1)
  {
    uint64_t v12 = 0;
    do
    {
      CFIndex v14 = *(__int16 *)a4;
      uint64_t v13 = a4 + 2;
      CFStringRef v15 = CFStringCreateWithBytes(0, v13, v14, 0x14000100u, 0);
      a4 = &v13[v14];
      v12 += v14 + 2;
      CFArrayAppendValue(Mutable, v15);
      CFRelease(v15);
    }
    while (v12 < a5);
  }
  CFArrayAppendValue(a1, Mutable);

  CFRelease(Mutable);
}

__CFString *CopyTransformedTextFromXML(const __CFString *a1, DCSDictionary *a2, unint64_t a3)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  CFStringRef v6 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
  int v7 = DCSEnvironment::parentalControlCensoringContents(v6);
  CFDataRef v8 = (const __CFData *)DCSDictionary::XSLTData(a2);
  if (a3 != 255 || (v7 & 1) != 0)
  {
    mem = 0;
    int size = 0;
    pthread_mutex_lock(&CopyTransformedTextFromXML::gGlobalLock);
    UTF8CString = CreateUTF8CString(a1);
    CFStringRef v11 = xmlParseDoc(UTF8CString);
    free(UTF8CString);
    if (v11)
    {
      v64[0] = "parental-control";
      uint64_t v12 = (xsltStylesheet *)PredefinedCachedXSLTDoc(0);
      uint64_t v13 = "''";
      if (v7) {
        uint64_t v13 = "'1'";
      }
      CFStringRef v61 = v13;
      xmlDocPtr v14 = ApplyXSLT(v11, v12, 0, 1, (const char **)v64, (const char **)&v61);
      if (v8)
      {
        BytePtr = (const char *)CFDataGetBytePtr(v8);
        int Length = CFDataGetLength(v8);
        CFStringRef v17 = xmlParseMemory(BytePtr, Length);
        char v18 = xsltParseStylesheetDoc(v17);
        CFDictionaryRef Preference = (const __CFDictionary *)DCSDictionaryGetPreference(*(const void **)a2);
        uint64_t v20 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
        if (((a3 == 1) & DCSEnvironment::orientationVerticalAllowed(v20)) != 0) {
          CFTypeRef v21 = @"1";
        }
        else {
          CFTypeRef v21 = @"0";
        }
        if (Preference) {
          CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Preference);
        }
        else {
          CFMutableStringRef MutableCopy = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        }
        CFDictionaryRef v24 = MutableCopy;
        CFDictionarySetValue(MutableCopy, @"DCSAllowOrientationVertical", v21);
        xmlDocPtr v25 = ApplyXSLT(v14, v18, v24, 0, 0, 0);
        CFRelease(v24);
        xmlFreeDoc(v14);
        xsltFreeStylesheet(v18);
        xmlDocPtr v14 = v25;
      }
      if (a3 - 1 > 1)
      {
        CFArrayRef v27 = 0;
      }
      else
      {
        *(_OWORD *)CFStringRef v64 = xmmword_1E6A59920;
        long long v65 = *(_OWORD *)off_1E6A59930;
        double v66 = "''";
        if (a3 == 2 && BecomeEmptyBySimplification(v14)) {
          unint64_t v26 = 1;
        }
        else {
          unint64_t v26 = a3;
        }
        uint64_t v28 = (xsltStylesheet *)PredefinedCachedXSLTDoc(v26);
        CFStringRef v29 = DCSDictionary::shortName(a2);
        CFStringRef v30 = CFStringCreateWithFormat(0, 0, @"'%@'", v29);
        v64[0] = (char *)CreateUTF8CString(v30);
        CFRelease(v30);
        CFURLRef v31 = (const __CFURL *)DCSDictionary::baseURL(a2);
        if (v31)
        {
          CFStringRef v32 = CFURLGetString(v31);
          CFStringRef v33 = CFURLCreateStringByReplacingPercentEscapes(0, v32, &stru_1F2DE4460);
          CFStringRef v34 = CFURLCreateStringByAddingPercentEscapes(0, v33, 0, @"'", 0x8000100u);
          CFRelease(v33);
          CFStringRef v35 = CFStringCreateWithFormat(0, 0, @"'%@'", v34);
          CFRelease(v34);
          CFStringRef v36 = (char *)CreateUTF8CString(v35);
          CFRelease(v35);
        }
        else
        {
          CFStringRef v36 = (char *)CreateUTF8CString(@"''");
        }
        v64[1] = v36;
        if (DCSDictionary::isLocalizableDictionary((CFDictionaryRef *)a2))
        {
          CFArrayRef v37 = DCSDictionary::languages((CFDictionaryRef *)a2);
          if (v37)
          {
            CFArrayRef v38 = v37;
            if (CFArrayGetCount(v37))
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v38, 0);
              if (ValueAtIndex)
              {
                CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"DCSDictionaryDescriptionLanguage");
                if (Value)
                {
                  CFStringRef CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString(0, Value);
                  if (CanonicalLanguageIdentifierFromString)
                  {
                    CFStringRef v42 = CanonicalLanguageIdentifierFromString;
                    if (CFLocaleGetLanguageCharacterDirection(CanonicalLanguageIdentifierFromString) == kCFLocaleLanguageDirectionRightToLeft) {
                      *(void *)&long long v65 = "'1'";
                    }
                    CFRelease(v42);
                  }
                }
              }
            }
          }
        }
        int isAppearanceAwareDictionary = DCSDictionary::isAppearanceAwareDictionary(a2);
        CFStringRef v44 = "'apple_appearance-incompliant'";
        if (isAppearanceAwareDictionary) {
          CFStringRef v44 = "'apple_appearance-compliant'";
        }
        double v66 = v44;
        CFArrayRef v45 = (const __CFArray *)DCSDictionary::styleSheetContents(a2);
        CFArrayRef v27 = v45;
        if (v45 && (CFIndex Count = CFArrayGetCount(v45), Count >= 1))
        {
          CFIndex v47 = Count;
          for (CFIndex i = 0; i != v47; ++i)
          {
            CFArrayGetValueAtIndex(v27, i);
            *((void *)&v65 + 1) = "'<!-- embedded_css_placeholder -->'";
            xmlDocPtr v49 = ApplyXSLT(v14, v28, 0, 5, (const char **)&off_1E6A598F8, (const char **)v64);
            xmlFreeDoc(v14);
            if (!i)
            {
              free(v64[0]);
              v64[0] = "''";
              free(v64[1]);
              v64[1] = "''";
              *(void *)&long long v65 = "''";
            }
            xmlDocPtr v14 = v49;
          }
        }
        else
        {
          xmlDocPtr v49 = v14;
        }
        xmlDocPtr v14 = v49;
      }
      xmlDocDumpMemory(v14, &mem, &size);
      xmlFreeDoc(v11);
      xmlFreeDoc(v14);
      if (a3 == 3)
      {
        xmlDocPtr v50 = xmlParseDoc(mem);
        if (BecomeEmptyBySimplification(v50)) {
          unint64_t v51 = 4;
        }
        else {
          unint64_t v51 = 3;
        }
        char v52 = (xsltStylesheet *)PredefinedCachedXSLTDoc(v51);
        xmlDocPtr v53 = xsltApplyStylesheet(v52, v50, 0);
        SanitizedText = (__CFString *)ExtractSanitizedText(v53);
        xmlFreeDoc(v50);
        xmlFreeDoc(v53);
      }
      else
      {
        CFStringRef v54 = CFStringCreateWithBytes(0, mem, size, 0x8000100u, 0);
        SanitizedText = CFStringCreateMutableCopy(0, 0, v54);
        CFRelease(v54);
        if (v27)
        {
          CFIndex v55 = CFArrayGetCount(v27);
          if (v55 >= 1)
          {
            CFIndex v56 = v55;
            for (CFIndex j = 0; j != v56; ++j)
            {
              CFRange v58 = CFStringFind(SanitizedText, @"<!-- embedded_css_placeholder -->", 0);
              if (!v58.length) {
                break;
              }
              CFComparisonResult v59 = CFArrayGetValueAtIndex(v27, j);
              CFStringRef v60 = CFStringCreateWithFormat(0, 0, @"/*<![CDATA[*/ %@ /*]]>*/", v59);
              CFStringReplace(SanitizedText, v58, v60);
              CFRelease(v60);
            }
          }
        }
      }
      ((void (*)(xmlChar *))*MEMORY[0x1E4FBA9D0])(mem);
    }
    else
    {
      SanitizedText = 0;
    }
    pthread_mutex_unlock(&CopyTransformedTextFromXML::gGlobalLock);
    return SanitizedText;
  }
  else
  {
    return (__CFString *)CFRetain(a1);
  }
}

UInt8 *CreateUTF8CString(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex usedBufLen = 0;
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  uint64_t v4 = (UInt8 *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0x43FEC6C4uLL);
  v7.CFIndex location = 0;
  v7.CFIndex length = Length;
  CFStringGetBytes(a1, v7, 0x8000100u, 0, 0, v4, MaximumSizeForEncoding, &usedBufLen);
  v4[usedBufLen] = 0;
  return v4;
}

uint64_t PredefinedCachedXSLTDoc(unint64_t a1)
{
  if (a1 > 4) {
    return 0;
  }
  resourceData[5] = v1;
  resourceData[6] = v2;
  if (!PredefinedCachedXSLTDoc(long)::_XSLTDoc[a1])
  {
    CFStringRef v5 = CFStringCreateWithCString(0, PredefinedCachedXSLTDoc(long)::_FileNames[a1], 0);
    CFStringRef v6 = (DCSEnvironment *)SyncSingleton<DCSEnvironment>::instance();
    FrameworkBundle = (__CFBundle *)DCSEnvironment::getFrameworkBundle(v6);
    CFURLRef v8 = CFBundleCopyResourceURL(FrameworkBundle, v5, 0, 0);
    CFRelease(v5);
    if (v8)
    {
      resourceData[0] = 0;
      CFURLCreateDataAndPropertiesFromResource(0, v8, resourceData, 0, 0, 0);
      CFRelease(v8);
      if (resourceData[0])
      {
        BytePtr = (const char *)CFDataGetBytePtr(resourceData[0]);
        int Length = CFDataGetLength(resourceData[0]);
        CFStringRef v11 = xmlParseMemory(BytePtr, Length);
        PredefinedCachedXSLTDoc(long)::_XSLTDoc[a1] = xsltParseStylesheetDoc(v11);
        CFRelease(resourceData[0]);
      }
    }
  }
  return PredefinedCachedXSLTDoc(long)::_XSLTDoc[a1];
}

xmlDocPtr ApplyXSLT(xmlDocPtr doc, xsltStylesheetPtr style, CFDictionaryRef theDict, uint64_t a4, const char **a5, const char **a6)
{
  CFIndex Count = a4;
  v32[1] = *MEMORY[0x1E4F143B8];
  if (theDict || a4 >= 1)
  {
    if (theDict) {
      CFIndex Count = CFDictionaryGetCount(theDict);
    }
    uint64_t v13 = (const char **)malloc_type_malloc((16 * Count) | 8, 0x10040436913F5uLL);
    xmlDocPtr v14 = v13;
    if (theDict)
    {
      v32[0] = v32;
      MEMORY[0x1F4188790](v13);
      unint64_t v15 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
      uint64_t v16 = (const __CFString **)((char *)v32 - v15);
      if ((unint64_t)(8 * Count) >= 0x200) {
        size_t v17 = 512;
      }
      else {
        size_t v17 = 8 * Count;
      }
      bzero((char *)v32 - v15, v17);
      MEMORY[0x1F4188790](v18);
      uint64_t v19 = (const __CFString **)((char *)v32 - v15);
      bzero((char *)v32 - v15, v17);
      CFDictionaryGetKeysAndValues(theDict, (const void **)((char *)v32 - v15), (const void **)((char *)v32 - v15));
      if (Count >= 1)
      {
        uint64_t v20 = (UInt8 **)(v14 + 1);
        CFIndex v21 = Count;
        do
        {
          CFStringRef v22 = *v16++;
          *(v20 - 1) = CreateUTF8CString(v22);
          CFStringRef v23 = *v19++;
          DCSEnvironment *v20 = CreateUTF8CString(v23);
          v20 += 2;
          --v21;
        }
        while (v21);
      }
    }
    else
    {
      if (Count < 1)
      {
        v13[2 * Count] = 0;
        xmlDocPtr v28 = xsltApplyStylesheet(style, doc, v13);
LABEL_28:
        free(v14);
        return v28;
      }
      CFDictionaryRef v24 = v13 + 1;
      CFIndex v25 = Count;
      do
      {
        uint64_t v26 = (uint64_t)*a5++;
        *(v24 - 1) = v26;
        uint64_t v27 = (uint64_t)*a6++;
        *CFDictionaryRef v24 = v27;
        v24 += 2;
        --v25;
      }
      while (v25);
    }
    v14[2 * Count] = 0;
    xmlDocPtr v28 = xsltApplyStylesheet(style, doc, v14);
    if (theDict && Count >= 1)
    {
      if (2 * Count <= 1) {
        uint64_t v29 = 1;
      }
      else {
        uint64_t v29 = 2 * Count;
      }
      CFStringRef v30 = (void **)v14;
      do
      {
        CFURLRef v31 = *v30++;
        free(v31);
        --v29;
      }
      while (v29);
    }
    goto LABEL_28;
  }

  return xsltApplyStylesheet(style, doc, 0);
}

BOOL BecomeEmptyBySimplification(_xmlDoc *a1)
{
  CFDataRef v2 = (xsltStylesheet *)PredefinedCachedXSLTDoc(3uLL);
  uint64_t v3 = xsltApplyStylesheet(v2, a1, 0);
  if (!v3) {
    return 1;
  }
  uint64_t v4 = (xmlDoc *)v3;
  xmlNodePtr RootElement = xmlDocGetRootElement(v3);
  if (RootElement && (children = RootElement->children) != 0)
  {
    Content = xmlNodeGetContent(children);
    int64_t v8 = strlen((const char *)Content);
    if (v8 < 1)
    {
      BOOL v11 = 1;
    }
    else
    {
      CFStringRef v9 = CFStringCreateWithBytes(0, Content, v8, 0x8000100u, 0);
      CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, v9);
      CFRelease(v9);
      CFStringTrimWhitespace(MutableCopy);
      BOOL v11 = CFStringGetLength(MutableCopy) == 0;
      CFRelease(MutableCopy);
    }
    ((void (*)(xmlChar *))*MEMORY[0x1E4FBA9D0])(Content);
  }
  else
  {
    BOOL v11 = 1;
  }
  xmlFreeDoc(v4);
  return v11;
}

_xmlNode *ExtractSanitizedText(_xmlDoc *a1)
{
  CFURLRef result = xmlDocGetRootElement(a1)->children;
  if (result)
  {
    Content = xmlNodeGetContent(result);
    int v3 = strlen((const char *)Content);
    uint64_t v4 = (UInt8 *)malloc_type_malloc(v3, 0x75E9D989uLL);
    if (v3 < 1)
    {
      int v6 = 0;
    }
    else
    {
      int v5 = 0;
      int v6 = 0;
      int v7 = 1;
      BOOL v8 = 1;
      do
      {
        CFStringRef v9 = &Content[v5];
        unsigned int v10 = *v9;
        int v11 = v9[1];
        if (v3 - v5 >= 5 && v10 == 35 && v11 == 66 && Content[v5 + 2] == 82 && Content[v5 + 3] == 35)
        {
          if (v7) {
            int v7 = 0;
          }
          else {
            v4[v6++] = 10;
          }
          BOOL v8 = 1;
          v5 += 3;
        }
        else if (v8)
        {
          if (v10 > 0x20 || ((1 << v10) & 0x100000600) == 0)
          {
            BOOL v8 = 0;
            v4[v6++] = v10;
          }
          else
          {
            BOOL v8 = 1;
          }
        }
        else if (v10 == 9 || v10 == 32 && v11 == 32)
        {
          BOOL v8 = 0;
        }
        else
        {
          v4[v6++] = v10;
          BOOL v8 = v10 == 10;
        }
        ++v5;
      }
      while (v5 < v3);
    }
    CFStringRef v13 = CFStringCreateWithBytes(0, v4, v6, 0x8000100u, 0);
    ((void (*)(xmlChar *))*MEMORY[0x1E4FBA9D0])(Content);
    free(v4);
    return (_xmlNode *)v13;
  }
  return result;
}

xmlDoc *CopySimplifiedTextFromWikipediaResult(const __CFString *a1)
{
  pthread_mutex_lock(&CopySimplifiedTextFromWikipediaResult::gGlobalLock);
  UTF8CString = CreateUTF8CString(a1);
  SanitizedText = xmlParseDoc(UTF8CString);
  free(UTF8CString);
  if (SanitizedText)
  {
    xmlDocPtr v4 = xsltApplyStylesheet(0, SanitizedText, 0);
    xmlFreeDoc(SanitizedText);
    if (v4)
    {
      SanitizedText = (xmlDoc *)ExtractSanitizedText(v4);
      xmlFreeDoc(v4);
    }
    else
    {
      SanitizedText = 0;
    }
  }
  pthread_mutex_unlock(&CopySimplifiedTextFromWikipediaResult::gGlobalLock);
  return SanitizedText;
}

CFMutableDictionaryRef CopyXPathElementsArray(const __CFString *a1, const __CFDictionary *a2, const __CFDictionary *a3)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  pthread_mutex_lock(&CopyXPathElementsArray::gGlobalLock);
  if (a1
    && (UTF8CString = CreateUTF8CString(a1)) != 0
    && (v7 = UTF8CString, BOOL v8 = xmlParseDoc(UTF8CString), free(v7), v8))
  {
    xmlDocPtr v54 = v8;
    CFStringRef v9 = xmlXPathNewContext(v8);
    int v55 = 0;
  }
  else
  {
    xmlDocPtr v54 = 0;
    CFStringRef v9 = 0;
    int v55 = 1;
  }
  CFIndex Count = CFDictionaryGetCount(a2);
  MEMORY[0x1F4188790](Count);
  uint64_t v12 = (const void **)((char *)&v51 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v11 >= 0x200) {
    size_t v13 = 512;
  }
  else {
    size_t v13 = v11;
  }
  bzero((char *)&v51 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), v13);
  CFDictionaryGetKeysAndValues(a2, v12, 0);
  CFStringRef v61 = v12;
  CFIndex v62 = Count;
  if (a3)
  {
    if (v9)
    {
      CFIndex v14 = CFDictionaryGetCount(a3);
      if (v14 >= 1)
      {
        CFIndex v15 = v14;
        CFDictionaryRef v16 = a2;
        MEMORY[0x1F4188790](v14);
        uint64_t v18 = (const void **)((char *)&v51 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0));
        if (v17 >= 0x200) {
          size_t v19 = 512;
        }
        else {
          size_t v19 = v17;
        }
        bzero((char *)&v51 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0), v19);
        CFDictionaryGetKeysAndValues(a3, v18, 0);
        while (1)
        {
          CFStringRef v20 = (const __CFString *)*v18;
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a3, *v18);
          if (Value)
          {
            CFStringRef v22 = Value;
            CFStringRef v23 = CreateUTF8CString(v20);
            CFDictionaryRef v24 = CreateUTF8CString(v22);
            CFIndex v25 = v24;
            if (v23) {
              BOOL v26 = v24 == 0;
            }
            else {
              BOOL v26 = 1;
            }
            if (!v26)
            {
              xmlXPathRegisterNs(v9, v23, v24);
LABEL_27:
              free(v23);
              if (!v25) {
                goto LABEL_25;
              }
LABEL_24:
              free(v25);
              goto LABEL_25;
            }
            if (v23) {
              goto LABEL_27;
            }
            if (v24) {
              goto LABEL_24;
            }
          }
LABEL_25:
          ++v18;
          if (!--v15)
          {
            a2 = v16;
            uint64_t v12 = v61;
            CFIndex Count = v62;
            break;
          }
        }
      }
    }
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v9 || Count < 1) {
    goto LABEL_66;
  }
  CFIndex v27 = 0;
  CFStringRef v63 = @"DCSTextElementKeySensesWithAttributes";
  CFRange v58 = @"DCSTextElementSenseKeyIsExplicit";
  CFComparisonResult v59 = @"DCSTextElementSenseKeyText";
  CFStringRef v57 = (const void *)*MEMORY[0x1E4F1CFC8];
  CFStringRef v52 = @"DCSTextElementKeySenses";
  CFDictionaryRef v53 = a2;
  CFStringRef v60 = v9;
  do
  {
    CFStringRef v28 = (const __CFString *)v12[v27];
    CFComparisonResult v29 = CFStringCompare(v28, v63, 0);
    CFStringRef v30 = (const __CFString *)CFDictionaryGetValue(a2, v28);
    CFURLRef v31 = CreateUTF8CString(v30);
    if (!v31) {
      goto LABEL_65;
    }
    CFStringRef v32 = v31;
    CFStringRef v33 = (xmlXPathObject *)MEMORY[0x1D9455BF0](v31, v9);
    free(v32);
    if (!v33) {
      goto LABEL_65;
    }
    p_nodeNr = &v33->nodesetval->nodeNr;
    if (!p_nodeNr) {
      goto LABEL_64;
    }
    uint64_t v35 = *p_nodeNr;
    if (!v35) {
      goto LABEL_64;
    }
    if (!*((void *)p_nodeNr + 1) || (int)v35 < 1) {
      goto LABEL_64;
    }
    uint64_t v37 = 0;
    CFArrayRef v38 = 0;
    do
    {
      uint64_t v39 = *(void *)(*((void *)p_nodeNr + 1) + 8 * v37);
      int v40 = *(_DWORD *)(v39 + 8);
      if (v40 == 2)
      {
        Content = xmlNodeGetContent(*(const xmlNode **)(*((void *)p_nodeNr + 1) + 8 * v37));
        if (Content)
        {
          CFRange v43 = Content;
          size_t v44 = strlen((const char *)Content);
          CFMutableStringRef v41 = v44 ? (CFMutableStringRef)CFStringCreateWithBytes(0, v43, v44, 0x8000100u, 0) : 0;
          ((void (*)(const UInt8 *))*MEMORY[0x1E4FBA9D0])(v43);
          if (v41)
          {
LABEL_50:
            if (v38)
            {
              if (v29) {
                goto LABEL_52;
              }
LABEL_54:
              CFArrayRef v45 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              CFDictionarySetValue(v45, v59, v41);
              CFDictionarySetValue(v45, v58, v57);
              CFArrayAppendValue(v38, v45);
              CFRelease(v45);
            }
            else
            {
              CFArrayRef v38 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
              if (v29 == kCFCompareEqualTo) {
                goto LABEL_54;
              }
LABEL_52:
              CFArrayAppendValue(v38, v41);
            }
            CFRelease(v41);
          }
        }
      }
      else if (v40 == 1)
      {
        CFMutableStringRef v41 = CFStringCreateMutable(0, 0);
        _TraverseAndCollectStringInNode(*(void *)(v39 + 24), v41);
        CFStringTrimWhitespace(v41);
        if (v41) {
          goto LABEL_50;
        }
      }
      ++v37;
    }
    while (v35 != v37);
    a2 = v53;
    if (v38)
    {
      if (CFStringCompare(v28, v52, 0) && v29 && CFStringHasPrefix(v28, @"DCSTextElementKey"))
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v38, 0);
        CFIndex v47 = Mutable;
        CFStringRef v48 = v28;
      }
      else
      {
        CFIndex v47 = Mutable;
        CFStringRef v48 = v28;
        CFDictionaryRef ValueAtIndex = v38;
      }
      CFDictionarySetValue(v47, v48, ValueAtIndex);
      CFRelease(v38);
    }
LABEL_64:
    xmlXPathFreeObject(v33);
    CFStringRef v9 = v60;
    uint64_t v12 = v61;
    CFIndex Count = v62;
LABEL_65:
    ++v27;
  }
  while (v27 < Count);
LABEL_66:
  if ((v55 & 1) == 0) {
    xmlFreeDoc(v54);
  }
  CFMutableDictionaryRef v49 = Mutable;
  if (v9) {
    xmlXPathFreeContext(v9);
  }
  if (!CFDictionaryGetCount(v49))
  {
    CFRelease(v49);
    CFMutableDictionaryRef v49 = 0;
  }
  pthread_mutex_unlock(&CopyXPathElementsArray::gGlobalLock);
  return v49;
}

uint64_t _TraverseAndCollectStringInNode(uint64_t result, __CFString *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    xmlDocPtr v4 = (void (**)(const UInt8 *))MEMORY[0x1E4FBA9D0];
    do
    {
      if (*(_DWORD *)(v3 + 8) == 3)
      {
        Content = xmlNodeGetContent((const xmlNode *)v3);
        if (Content)
        {
          int v6 = Content;
          size_t v7 = strlen((const char *)Content);
          if (v7)
          {
            CFStringRef v8 = CFStringCreateWithBytes(0, v6, v7, 0x8000100u, 0);
            (*v4)(v6);
            if (v8)
            {
              CFStringAppend(a2, v8);
              CFRelease(v8);
            }
          }
          else
          {
            (*v4)(v6);
          }
        }
      }
      CFURLRef result = _TraverseAndCollectStringInNode(*(_xmlNode **)(v3 + 24), a2);
      uint64_t v3 = *(void *)(v3 + 48);
    }
    while (v3);
  }
  return result;
}

uint64_t IDXAccessContext::IDXAccessContext(uint64_t result, uint64_t a2)
{
  *(void *)CFURLRef result = &unk_1F2DE3258;
  *(void *)(result + 8) = a2;
  *(unsigned char *)(result + 16) = 0;
  return result;
}

void IDXAccessContext::~IDXAccessContext(IDXAccessContext *this)
{
  *(void *)this = &unk_1F2DE3258;
  if (*((unsigned char *)this + 16))
  {
    uint64_t v1 = *((void *)this + 1);
    if (v1)
    {
      IDXIndexInfo::~IDXIndexInfo(*((IDXIndexInfo **)this + 1));
      MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
    }
  }
}

void sub_1D5915B9C(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t IDXAccessContext::initialize(IDXAccessContext *this)
{
  pthread_mutex_lock((pthread_mutex_t *)(*((void *)this + 1) + 232));
  uint64_t v7 = 0;
  int v6 = (void *)IDXIndexInfo::accessContextData(*((IDXIndexInfo **)this + 1), &v7);
  uint64_t v2 = (*(uint64_t (**)(IDXAccessContext *, BOOL, void **))(*(void *)this + 96))(this, v7 == 0, &v6);
  uint64_t v3 = (IDXIndexInfo *)*((void *)this + 1);
  if (v2)
  {
    IDXIndexInfo::opened(v3, v6);
    xmlDocPtr v4 = (pthread_mutex_t *)(*((void *)this + 1) + 232);
  }
  else
  {
    xmlDocPtr v4 = (pthread_mutex_t *)((char *)v3 + 232);
  }
  pthread_mutex_unlock(v4);
  return v2;
}

uint64_t IDXAccessContext::finalize(IDXAccessContext *this)
{
  pthread_mutex_lock((pthread_mutex_t *)(*((void *)this + 1) + 232));
  BOOL v2 = IDXIndexInfo::closed(*((IDXIndexInfo **)this + 1)) == 0;
  (*(void (**)(IDXAccessContext *, BOOL))(*(void *)this + 104))(this, v2);
  uint64_t v3 = (pthread_mutex_t *)(*((void *)this + 1) + 232);

  return pthread_mutex_unlock(v3);
}

uint64_t openRawIndexFile(const char *a1, int a2, int a3)
{
  if (a2) {
    int v4 = 2;
  }
  else {
    int v4 = 0;
  }
  if (a3) {
    return open(a1, v4 | 0xA00, 438);
  }
  return open(a1, v4);
}

uint64_t mapIndexFile(int a1, int a2, off_t *a3)
{
  if (a2) {
    int v5 = 3;
  }
  else {
    int v5 = 1;
  }
  if (fstat(a1, &v8) == -1) {
    return -1;
  }
  int st_size = v8.st_size;
  if (a3) {
    *a3 = v8.st_size;
  }
  return (uint64_t)mmap(0, st_size, v5, 1, a1, 0);
}

uint64_t unmapIndexFile(void *a1, size_t a2)
{
  msync(a1, a2, 16);

  return munmap(a1, a2);
}

uint64_t flushIndexFile(void *a1, size_t a2)
{
  return msync(a1, a2, 16);
}

uint64_t IDXAccessContext::getDataPtrByID(IDXAccessContext *this, unint64_t a2, uint64_t *a3)
{
  return 0;
}

uint64_t IDXAccessContext::getDataByID(IDXAccessContext *this, unint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  return 0;
}

uint64_t IDXAccessContext::addRecord(IDXAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, uint64_t a5, unint64_t *a6)
{
  return 0;
}

uint64_t IDXAccessContext::deleteRecord(IDXAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4)
{
  return 0;
}

uint64_t IDXAccessContext::buildWithRecords(IDXAccessContext *this, void *a2, const __CFArray *a3, const __CFArray *a4, unint64_t *a5)
{
  return 0;
}

uint64_t IDXAccessContext::initializeSubclass(IDXAccessContext *this, BOOL a2, void **a3)
{
  return 1;
}

void IDXAccessMethodManager::IDXAccessMethodManager(IDXAccessMethodManager *this)
{
  *(void *)this = 1;
  *((void *)this + 1) = 1;
  *((void *)this + 2) = 1;
  *((void *)this + 3) = 1;
}

void IDXAccessMethodManager::~IDXAccessMethodManager(IDXAccessMethodManager *this)
{
  for (uint64_t i = 0; i != 32; i += 8)
  {
    uint64_t v3 = *(const void **)((char *)this + i);
    if ((unint64_t)v3 >= 2) {
      CFRelease(v3);
    }
  }
}

void *IDXAccessMethodManager::accessMethod(IDXAccessMethodManager *this, const __CFString *a2, IDXDictionaryPackage *a3)
{
  if (!a2) {
    return 0;
  }
  if ((_initedRegisteredAccessMethods & 1) == 0) {
    pthread_once(&IDXAccessMethodManager::assureSharedRegistrationList(void)::once_control, (void (*)(void))_InitializeRegisteredAcccessMethods);
  }
  pthread_rwlock_rdlock((pthread_rwlock_t *)(_registeredAccessMethods + 16));
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_registeredAccessMethods + 8), a2);
  pthread_rwlock_unlock((pthread_rwlock_t *)(_registeredAccessMethods + 16));
  if (!Value)
  {
    int v6 = (pthread_rwlock_t *)(_registeredAccessMethods + 16);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(_registeredAccessMethods + 16));
    CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_registeredAccessMethods + 8), a2);
    if (!Value)
    {
      CFArrayRef v7 = (const __CFArray *)IDXAccessMethodManager::activateBuiltInAccessMethod(0, a2);
      CFStringRef Value = v7;
      if (v7 || (v7 = IDXAccessMethodManager::searchPlugInAccessMethod(this, a2, v8), (CFStringRef Value = v7) != 0)) {
        IDXAccessMethodManager::registerAccessMethod((uint64_t)v7, Value);
      }
    }
    pthread_rwlock_unlock(v6);
  }
  return Value;
}

void sub_1D5915F90(_Unwind_Exception *a1)
{
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IDXAccessMethodManager::assureSharedRegistrationList(IDXAccessMethodManager *this)
{
  if ((_initedRegisteredAccessMethods & 1) == 0) {
    return pthread_once(&IDXAccessMethodManager::assureSharedRegistrationList(void)::once_control, (void (*)(void))_InitializeRegisteredAcccessMethods);
  }
  return result;
}

uint64_t IDXAccessMethodManager::activateBuiltInAccessMethod(IDXAccessMethodManager *this, CFStringRef theString1)
{
  if (theString1)
  {
    if (CFEqual(theString1, @"com.apple.TrieAccessMethod")) {
      operator new();
    }
    if (CFEqual(theString1, @"com.apple.HeapAccessMethod")) {
      operator new();
    }
    if (CFEqual(theString1, @"com.apple.TestAccessMethod-Inspector")) {
      operator new();
    }
  }
  return 0;
}

void sub_1D59160C4(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10E1C404BFD5011);
  _Unwind_Resume(a1);
}

const __CFArray *IDXAccessMethodManager::searchPlugInAccessMethod(IDXAccessMethodManager *this, const __CFString *a2, IDXDictionaryPackage *a3)
{
  CFArrayRef v4 = (const __CFArray *)*((void *)this + 2);
  if (v4 == (const __CFArray *)1)
  {
    CFURLRef v6 = CFURLCreateWithFileSystemPath(0, @"/System/Library/Dictionaries/", kCFURLPOSIXPathStyle, 1u);
    *((void *)this + 2) = CFBundleCreateBundlesFromDirectory(0, v6, @"dictionaryPlugin");
    CFRelease(v6);
    CFArrayRef v4 = (const __CFArray *)*((void *)this + 2);
    if (!v4) {
      return v4;
    }
  }
  else if (!v4)
  {
    return v4;
  }
  CFIndex Count = CFArrayGetCount(v4);
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    for (CFIndex i = 0; i != v8; ++i)
    {
      CFDictionaryRef ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v4, i);
      CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(ValueAtIndex);
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, @"IDXAccessMethodIDs");
      if (Value)
      {
        CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(Value, a2);
        if (v13)
        {
          CFUUIDCreateFromString(0, v13);
          CFBundleCopyBundleURL(ValueAtIndex);
          operator new();
        }
      }
    }
  }
  return 0;
}

void sub_1D5916238(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10E1C40777B8806);
  _Unwind_Resume(a1);
}

void IDXAccessMethodManager::registerAccessMethod(uint64_t a1, void *a2)
{
  if ((_initedRegisteredAccessMethods & 1) == 0) {
    pthread_once(&IDXAccessMethodManager::assureSharedRegistrationList(void)::once_control, (void (*)(void))_InitializeRegisteredAcccessMethods);
  }
  if (a2)
  {
    uint64_t v3 = *(__CFDictionary **)(_registeredAccessMethods + 8);
    CFArrayRef v4 = (const void *)a2[1];
    if (!CFDictionaryContainsKey(v3, v4))
    {
      CFDictionarySetValue(v3, v4, a2);
    }
  }
}

void _InitializeRegisteredAcccessMethods(void)
{
}

void sub_1D59163A4(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::IDXBuiltInAccessMethod(uint64_t a1, CFTypeRef cf)
{
  *(void *)a1 = &unk_1F2DE33B8;
  CFTypeRef v3 = CFRetain(cf);
  *(void *)a1 = &unk_1F2DE32E8;
  *(void *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 168) = 1;
  IDXBuiltInAccessMethod_SetBridgeFunctionPtrs((void *)(a1 + 32));
  *(void *)(a1 + 16) = a1 + 32;
  *(void *)(a1 + 24) = a1;
  return a1;
}

void sub_1D5916450(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  CFArrayRef v4 = (const void *)v1[1];
  if (v4) {
    CFRelease(v4);
  }
  _Unwind_Resume(exception_object);
}

void *IDXBuiltInAccessMethod<TrieAccessContext>::~IDXBuiltInAccessMethod(void *a1)
{
  *a1 = &unk_1F2DE33B8;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void IDXBuiltInAccessMethod<TrieAccessContext>::~IDXBuiltInAccessMethod(void *a1)
{
  *a1 = &unk_1F2DE33B8;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x1D94553C0);
}

void sub_1D5916528(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10E1C404BFD5011);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::queryInterface(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *a4 = a1 + 16;
  return 1;
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::retain(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 168) + 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::release(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 168) - 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

void IDXBuiltInAccessMethod<TrieAccessContext>::openIndexFile()
{
}

{
  operator new();
}

void sub_1D5916648(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C4043258D86);
  _Unwind_Resume(a1);
}

void sub_1D5916710(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C4043258D86);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::closeIndexFile(int a1, IDXAccessContext *this)
{
  uint64_t result = IDXAccessContext::finalize(this);
  if (this)
  {
    CFArrayRef v4 = *(uint64_t (**)(IDXAccessContext *))(*(void *)this + 8);
    return v4(this);
  }
  return result;
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::setSearchCharacters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::getMatchDataPtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::getMatchData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::containsMatchData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, a3);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::getDataPtrByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, a3, a4);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::getDataByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 56))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::supportDataPtr(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::addRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 72))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::deleteRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 80))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<TrieAccessContext>::buildWithRecords(uint64_t a1, TrieAccessContext *a2, const __CFArray *a3, const __CFArray *a4, unint64_t *a5)
{
  return TrieAccessContext::buildWithRecords(a2, a3, a4, a5);
}

void IDXBuiltInAccessMethod<TrieAccessContext>::createIndexFile()
{
}

void sub_1D5916A10(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t IDXAccessMethod::retain(IDXAccessMethod *this)
{
  return 0;
}

uint64_t IDXAccessMethod::release(IDXAccessMethod *this)
{
  return 0;
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::IDXBuiltInAccessMethod(uint64_t a1, CFTypeRef cf)
{
  *(void *)a1 = &unk_1F2DE33B8;
  CFTypeRef v3 = CFRetain(cf);
  *(void *)a1 = &unk_1F2DE3460;
  *(void *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 168) = 1;
  IDXBuiltInAccessMethod_SetBridgeFunctionPtrs((void *)(a1 + 32));
  *(void *)(a1 + 16) = a1 + 32;
  *(void *)(a1 + 24) = a1;
  return a1;
}

void sub_1D5916AD0(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  CFArrayRef v4 = (const void *)v1[1];
  if (v4) {
    CFRelease(v4);
  }
  _Unwind_Resume(exception_object);
}

void *IDXBuiltInAccessMethod<HeapAccessContext>::~IDXBuiltInAccessMethod(void *a1)
{
  *a1 = &unk_1F2DE33B8;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void IDXBuiltInAccessMethod<HeapAccessContext>::~IDXBuiltInAccessMethod(void *a1)
{
  *a1 = &unk_1F2DE33B8;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x1D94553C0);
}

void sub_1D5916BA8(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10E1C404BFD5011);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::queryInterface(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *a4 = a1 + 16;
  return 1;
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::retain(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 168) + 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::release(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 168) - 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

void IDXBuiltInAccessMethod<HeapAccessContext>::openIndexFile()
{
}

{
  operator new();
}

void sub_1D5916CC8(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C409CAD4C71);
  _Unwind_Resume(a1);
}

void sub_1D5916D90(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C409CAD4C71);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::closeIndexFile(int a1, IDXAccessContext *this)
{
  uint64_t result = IDXAccessContext::finalize(this);
  if (this)
  {
    CFArrayRef v4 = *(uint64_t (**)(IDXAccessContext *))(*(void *)this + 8);
    return v4(this);
  }
  return result;
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::setSearchCharacters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::getMatchDataPtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::getMatchData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::containsMatchData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, a3);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::getDataPtrByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, a3, a4);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::getDataByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 56))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::supportDataPtr(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::addRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 72))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<HeapAccessContext>::deleteRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 80))(a2, a3, a4, a5, a6, a7);
}

BOOL IDXBuiltInAccessMethod<HeapAccessContext>::buildWithRecords(int a1, HeapAccessContext *this, __CFArray *a3, CFArrayRef theArray, unint64_t *a5)
{
  return HeapAccessContext::buildWithRecords(this, a3, theArray, a5);
}

void IDXBuiltInAccessMethod<HeapAccessContext>::createIndexFile()
{
}

void sub_1D5917090(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::IDXBuiltInAccessMethod(uint64_t a1, CFTypeRef cf)
{
  *(void *)a1 = &unk_1F2DE33B8;
  CFTypeRef v3 = CFRetain(cf);
  *(void *)a1 = &unk_1F2DE3520;
  *(void *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 168) = 1;
  IDXBuiltInAccessMethod_SetBridgeFunctionPtrs((void *)(a1 + 32));
  *(void *)(a1 + 16) = a1 + 32;
  *(void *)(a1 + 24) = a1;
  return a1;
}

void sub_1D5917140(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  CFArrayRef v4 = (const void *)v1[1];
  if (v4) {
    CFRelease(v4);
  }
  _Unwind_Resume(exception_object);
}

void *IDXBuiltInAccessMethod<InspectorAccessContext>::~IDXBuiltInAccessMethod(void *a1)
{
  *a1 = &unk_1F2DE33B8;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void IDXBuiltInAccessMethod<InspectorAccessContext>::~IDXBuiltInAccessMethod(void *a1)
{
  *a1 = &unk_1F2DE33B8;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x1D94553C0);
}

void sub_1D5917218(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10E1C404BFD5011);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::queryInterface(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *a4 = a1 + 16;
  return 1;
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::retain(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 168) + 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::release(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 168) - 1);
  *(_DWORD *)(a1 + 168) = v1;
  return v1;
}

void IDXBuiltInAccessMethod<InspectorAccessContext>::openIndexFile()
{
}

{
  operator new();
}

void sub_1D5917338(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C40F8DAED6BLL);
  _Unwind_Resume(a1);
}

void sub_1D5917400(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C40F8DAED6BLL);
  _Unwind_Resume(a1);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::closeIndexFile(int a1, IDXAccessContext *this)
{
  uint64_t result = IDXAccessContext::finalize(this);
  if (this)
  {
    CFArrayRef v4 = *(uint64_t (**)(IDXAccessContext *))(*(void *)this + 8);
    return v4(this);
  }
  return result;
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::setSearchCharacters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::getMatchDataPtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::getMatchData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::containsMatchData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, a3);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::getDataPtrByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, a3, a4);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::getDataByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 56))(a2, a3, a4, a5);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::supportDataPtr(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::addRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 72))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::deleteRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 80))(a2, a3, a4, a5, a6, a7);
}

uint64_t IDXBuiltInAccessMethod<InspectorAccessContext>::buildWithRecords(int a1, DCSEnvironment *this)
{
  return DCSEnvironment::readyForFontActivation(this);
}

void IDXBuiltInAccessMethod<InspectorAccessContext>::createIndexFile()
{
}

void sub_1D5917700(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

void *IDXBuiltInAccessMethod_SetBridgeFunctionPtrs(void *result)
{
  result[4] = _OpenIndex_AcccessMethodBridge;
  result[5] = _CloseIndex_AcccessMethodBridge;
  result[6] = _SetSearchCharacters_AcccessMethodBridge;
  result[7] = _GetMatchDataPtr_AcccessMethodBridge;
  result[8] = _GetMatchData_AcccessMethodBridge;
  result[9] = _ContainsMatchData_AcccessMethodBridge;
  result[10] = _GetDataPtrByID_AcccessMethodBridge;
  result[11] = _GetDataByID_AcccessMethodBridge;
  result[12] = _SupportDataPtr_AcccessMethodBridge;
  result[13] = _AddRecord_AcccessMethodBridge;
  result[14] = _DeleteRecord_AcccessMethodBridge;
  result[15] = _BuildWithRecords_AcccessMethodBridge;
  result[16] = _CreateIndexFile_AcccessMethodBridge;
  result[1] = _QueryInterface_AcccessMethodBridge;
  result[2] = _AddRef_AcccessMethodBridge;
  result[3] = _Release_AcccessMethodBridge;
  return result;
}

uint64_t _OpenIndex_AcccessMethodBridge(void **a1, const __CFURL *a2, const __CFDictionary *a3)
{
  return (*(uint64_t (**)(void *, const __CFURL *, const __CFDictionary *))(*a1[1] + 40))(a1[1], a2, a3);
}

uint64_t _CloseIndex_AcccessMethodBridge(void **a1, void *a2)
{
  return (*(uint64_t (**)(void *, void *))(*a1[1] + 56))(a1[1], a2);
}

uint64_t _SetSearchCharacters_AcccessMethodBridge(void **a1, void *a2, const unsigned __int16 *a3, uint64_t a4, const __CFString *a5)
{
  return (*(uint64_t (**)(void *, void *, const unsigned __int16 *, uint64_t, const __CFString *))(*a1[1] + 64))(a1[1], a2, a3, a4, a5);
}

uint64_t _GetMatchDataPtr_AcccessMethodBridge(void **a1, void *a2, uint64_t a3, const unsigned __int8 **a4, uint64_t *a5)
{
  return (*(uint64_t (**)(void *, void *, uint64_t, const unsigned __int8 **, uint64_t *))(*a1[1] + 72))(a1[1], a2, a3, a4, a5);
}

uint64_t _GetMatchData_AcccessMethodBridge(void **a1, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, CFRange **a6, uint64_t *a7)
{
  return (*(uint64_t (**)(void *, void *, uint64_t, uint64_t, unsigned __int8 *, CFRange **, uint64_t *))(*a1[1] + 80))(a1[1], a2, a3, a4, a5, a6, a7);
}

uint64_t _ContainsMatchData_AcccessMethodBridge(void **a1, void *a2, unsigned __int8 *a3)
{
  return (*(uint64_t (**)(void *, void *, unsigned __int8 *))(*a1[1] + 88))(a1[1], a2, a3);
}

uint64_t _GetDataPtrByID_AcccessMethodBridge(void **a1, void *a2, uint64_t a3, uint64_t *a4)
{
  return (*(uint64_t (**)(void *, void *, uint64_t, uint64_t *))(*a1[1] + 96))(a1[1], a2, a3, a4);
}

uint64_t _GetDataByID_AcccessMethodBridge(void **a1, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  return (*(uint64_t (**)(void *, void *, uint64_t, uint64_t, unsigned __int8 *))(*a1[1] + 104))(a1[1], a2, a3, a4, a5);
}

uint64_t _SupportDataPtr_AcccessMethodBridge(void **a1, void *a2)
{
  return (*(uint64_t (**)(void *, void *))(*a1[1] + 112))(a1[1], a2);
}

uint64_t _AddRecord_AcccessMethodBridge(void **a1, void *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int8 *a5, uint64_t a6, unint64_t *a7)
{
  return (*(uint64_t (**)(void *, void *, const unsigned __int16 *, uint64_t, const unsigned __int8 *, uint64_t, unint64_t *))(*a1[1] + 120))(a1[1], a2, a3, a4, a5, a6, a7);
}

uint64_t _DeleteRecord_AcccessMethodBridge(void **a1, void *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int8 *a5)
{
  return (*(uint64_t (**)(void *, void *, const unsigned __int16 *, uint64_t, const unsigned __int8 *))(*a1[1] + 128))(a1[1], a2, a3, a4, a5);
}

uint64_t _BuildWithRecords_AcccessMethodBridge(void **a1, void *a2, const __CFArray *a3, const __CFArray *a4, unint64_t *a5)
{
  return (*(uint64_t (**)(void *, void *, const __CFArray *, const __CFArray *, unint64_t *))(*a1[1] + 136))(a1[1], a2, a3, a4, a5);
}

uint64_t _CreateIndexFile_AcccessMethodBridge(void **a1, const __CFURL *a2, const __CFDictionary *a3)
{
  return (*(uint64_t (**)(void *, const __CFURL *, const __CFDictionary *))(*a1[1] + 144))(a1[1], a2, a3);
}

uint64_t _QueryInterface_AcccessMethodBridge(void **a1, CFUUIDBytes a2, void **a3)
{
  return (*(uint64_t (**)(void *, void, void, void **))(*a1[1] + 16))(a1[1], *(void *)&a2.byte0, *(void *)&a2.byte8, a3);
}

uint64_t _AddRef_AcccessMethodBridge(void **a1)
{
  return (*(uint64_t (**)(void))(*a1[1] + 24))();
}

uint64_t _Release_AcccessMethodBridge(void **a1)
{
  return (*(uint64_t (**)(void))(*a1[1] + 32))();
}

const void *IDXDictionaryManager::dictionary(IDXDictionaryManager *this, CFURLRef relativeURL)
{
  if ((_initedCachedDictionaries & 1) == 0) {
    pthread_once(&IDXDictionaryManager::dictionary(__CFURL const*)::once_control, (void (*)(void))_InitializeCachedDictionaries);
  }
  CFURLRef v3 = CFURLCopyAbsoluteURL(relativeURL);
  CFStringRef v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  CFRelease(v3);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedDictionaries + 8), v4);
  pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  if (!Value)
  {
    CFURLRef v6 = (pthread_rwlock_t *)(_cachedDictionaries + 16);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
    CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedDictionaries + 8), v4);
    if (!Value) {
      operator new();
    }
    pthread_rwlock_unlock(v6);
  }
  CFRelease(v4);
  return Value;
}

void sub_1D5917CA0(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v2, 0x10E0C4030B049B9);
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1D5917D84(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

uint64_t IDXDictionaryManager::remove(IDXDictionaryManager *this, CFAbsoluteTime *a2)
{
  CFURLRef v3 = (pthread_rwlock_t *)(_cachedDictionaries + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  CFStringRef v4 = *(__CFDictionary **)(_cachedDictionaries + 8);
  CFURLRef v5 = (const __CFURL *)IDXDictionaryPackage::URL(a2);
  CFStringRef v6 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
  CFDictionaryRemoveValue(v4, v6);
  if (a2)
  {
    IDXDictionaryPackage::~IDXDictionaryPackage((IDXDictionaryPackage *)a2);
    MEMORY[0x1D94553C0](a2, 0x10E0C4030B049B9);
  }

  return pthread_rwlock_unlock(v3);
}

void sub_1D5917E40(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v2, 0x10E0C4030B049B9);
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IDXDictionaryManager::clearInactiveCaches(IDXDictionaryManager *this)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (pthread_rwlock_t *)(_cachedDictionaries + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedDictionaries + 16));
  CFDictionaryRef v2 = *(const __CFDictionary **)(_cachedDictionaries + 8);
  CFIndex Count = CFDictionaryGetCount(v2);
  if (Count >= 1)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    MEMORY[0x1F4188790](v5);
    unint64_t v6 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
    CFArrayRef v7 = (IDXDictionaryPackage **)((char *)v13 - v6);
    if ((unint64_t)(8 * Count) >= 0x200) {
      size_t v8 = 512;
    }
    else {
      size_t v8 = 8 * Count;
    }
    bzero((char *)v13 - v6, v8);
    MEMORY[0x1F4188790](v9);
    unsigned int v10 = (const void **)((char *)v13 - v6);
    bzero((char *)v13 - v6, v8);
    CFDictionaryGetKeysAndValues(v2, (const void **)((char *)v13 - v6), (const void **)((char *)v13 - v6));
    do
    {
      if (!*((_DWORD *)*v7 + 44) && Current > *((double *)*v7 + 40) + 300.0)
      {
        CFDictionaryRemoveValue(v2, *v10);
        unint64_t v11 = *v7;
        if (*v7)
        {
          IDXDictionaryPackage::~IDXDictionaryPackage(*v7);
          MEMORY[0x1D94553C0](v11, 0x10E0C4030B049B9);
        }
      }
      ++v10;
      ++v7;
      --Count;
    }
    while (Count);
  }
  return pthread_rwlock_unlock(v1);
}

void sub_1D5918018(_Unwind_Exception *exception_object)
{
}

__CFString *IDXDictionaryManager::templateProperty(IDXDictionaryManager *this, __CFString *a2)
{
  if (a2) {
    CFDictionaryRef v2 = a2;
  }
  else {
    CFDictionaryRef v2 = @"IDXDefaultProperty";
  }
  CFTypeID v3 = CFGetTypeID(v2);
  if (v3 == CFStringGetTypeID())
  {
    if ((_initedCachedProperties & 1) == 0) {
      pthread_once(&IDXDictionaryManager::templateProperty(void const*)::once_control, (void (*)(void))_InitializeCachedProperties);
    }
    pthread_rwlock_rdlock((pthread_rwlock_t *)(_cachedProperties + 16));
    CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedProperties + 8), v2);
    pthread_rwlock_unlock((pthread_rwlock_t *)(_cachedProperties + 16));
    if (!Value)
    {
      uint64_t v5 = (pthread_rwlock_t *)(_cachedProperties + 16);
      pthread_rwlock_wrlock((pthread_rwlock_t *)(_cachedProperties + 16));
      CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(_cachedProperties + 8), v2);
      if (!Value)
      {
        if (CFStringGetCharacterAtIndex(v2, 0) == 47)
        {
          CFURLRef v8 = CFURLCreateWithFileSystemPath(0, v2, kCFURLPOSIXPathStyle, 0);
        }
        else
        {
          BundleWithCFStringRef Identifier = CFBundleGetBundleWithIdentifier(@"com.apple.DictionaryServices");
          CFURLRef v8 = CFBundleCopyResourceURL(BundleWithIdentifier, v2, @"plist", 0);
        }
        CFURLRef v10 = v8;
        if (!v8)
        {
          CFDictionaryRef Value = 0;
          goto LABEL_10;
        }
        CFDataRef resourceData = 0;
        if (CFURLCreateDataAndPropertiesFromResource(0, v8, &resourceData, 0, 0, 0))
        {
          CFDictionaryRef Value = CFPropertyListCreateFromXMLData(0, resourceData, 0, 0);
          CFRelease(resourceData);
        }
        else
        {
          CFDictionaryRef Value = 0;
        }
        CFRelease(v10);
        if (!Value) {
          goto LABEL_10;
        }
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(_cachedProperties + 8), v2, Value);
      CFRelease(Value);
LABEL_10:
      pthread_rwlock_unlock(v5);
    }
  }
  else
  {
    CFTypeID v6 = CFGetTypeID(v2);
    if (v6 == CFDictionaryGetTypeID()) {
      return v2;
    }
    else {
      return 0;
    }
  }
  return (__CFString *)Value;
}

void sub_1D591824C(_Unwind_Exception *a1)
{
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

void _InitializeCachedProperties(void)
{
}

void sub_1D591831C(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

CFMutableArrayRef DCSSearchFoundationCopyResults(const __CFString *a1)
{
  CFDictionaryRef v2 = DCSCopyActiveDictionaries(0);
  CFMutableArrayRef v3 = DCSSearchFoundationCopyResultsWithOptions(a1, v2, 0);
  if (v2) {
    CFRelease(v2);
  }
  return v3;
}

void IDXDictionaryPackage::IDXDictionaryPackage(IDXDictionaryPackage *this, CFURLRef relativeURL)
{
  *(void *)this = -1;
  *((void *)this + 2) = 0;
  *((unsigned char *)this + 24) = 0;
  *((void *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *((unsigned char *)this + 108) = 0;
  *((_DWORD *)this + 44) = 0;
  *((void *)this + 31) = 0;
  *((void *)this + 1) = CFURLCopyAbsoluteURL(relativeURL);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 32), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 184), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 112), 0);
  pthread_mutex_init((pthread_mutex_t *)this + 4, 0);
  *((CFAbsoluteTime *)this + 40) = CFAbsoluteTimeGetCurrent();
}

void IDXDictionaryPackage::~IDXDictionaryPackage(IDXDictionaryPackage *this)
{
  CFDictionaryRef v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  CFMutableArrayRef v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  CFStringRef v4 = (const void *)*((void *)this + 31);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 12);
  if (v5)
  {
    int v6 = *((_DWORD *)this + 26);
    if (v6 >= 1)
    {
      for (uint64_t i = 0; i < v6; ++i)
      {
        uint64_t v8 = *((void *)this + 12);
        uint64_t v9 = *(void *)(v8 + 8 * i);
        if (v9)
        {
          IDXIndexInfo::~IDXIndexInfo(*(IDXIndexInfo **)(v8 + 8 * i));
          MEMORY[0x1D94553C0](v9, 0x1070C4063F6B07ELL);
          int v6 = *((_DWORD *)this + 26);
        }
      }
      uint64_t v5 = (void *)*((void *)this + 12);
    }
    free(v5);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 184));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 112));
  pthread_mutex_destroy((pthread_mutex_t *)this + 4);
}

void sub_1D59189C8(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t IDXDictionaryPackage::URL(CFAbsoluteTime *this)
{
  this[40] = CFAbsoluteTimeGetCurrent();
  return *((void *)this + 1);
}

CFDictionaryRef IDXDictionaryPackage::version(CFDictionaryRef *this)
{
  if (*this == (CFDictionaryRef)-1)
  {
    if (IDXDictionaryPackage::properties((IDXDictionaryPackage *)this))
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(this[2], @"IDXDictionaryVersion");
      if (Value) {
        CFNumberGetValue(Value, kCFNumberCFIndexType, this);
      }
    }
  }
  return *this;
}

uint64_t IDXDictionaryPackage::properties(IDXDictionaryPackage *this)
{
  if (!*((unsigned char *)this + 24))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    if (!*((unsigned char *)this + 24))
    {
      CFURLRef DictionaryComponentURL = CreateDictionaryComponentURL(*((const __CFURL **)this + 1), @"Info.plist");
      CFDataRef resourceData = 0;
      if (CFURLCreateDataAndPropertiesFromResource(0, DictionaryComponentURL, &resourceData, 0, 0, 0)) {
        BOOL v3 = resourceData == 0;
      }
      else {
        BOOL v3 = 1;
      }
      if (!v3)
      {
        *((void *)this + 2) = CFPropertyListCreateFromXMLData(0, resourceData, 0, 0);
        CFRelease(resourceData);
      }
      CFRelease(DictionaryComponentURL);
    }
    *((unsigned char *)this + 24) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 32));
  }
  *((CFAbsoluteTime *)this + 40) = CFAbsoluteTimeGetCurrent();
  return *((void *)this + 2);
}

uint64_t IDXDictionaryPackage::bundle(IDXDictionaryPackage *this)
{
  uint64_t result = *((void *)this + 31);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)this + 4);
    if (!*((void *)this + 31)) {
      *((void *)this + 31) = CFBundleCreate(0, *((CFURLRef *)this + 1));
    }
    pthread_mutex_unlock((pthread_mutex_t *)this + 4);
    return *((void *)this + 31);
  }
  return result;
}

BOOL IDXDictionaryPackage::validDictionary(CFDictionaryRef *this)
{
  CFDictionaryRef v2 = IDXDictionaryPackage::version(this);
  BOOL result = 0;
  if (v2 != (CFDictionaryRef)-1 && (uint64_t)v2 <= 3) {
    return IDXDictionaryPackage::indexInfoList(this, 0) != 0;
  }
  return result;
}

CFDictionaryRef IDXDictionaryPackage::indexInfoList(CFDictionaryRef *this, int *a2)
{
  if (!*((unsigned char *)this + 108) && IDXDictionaryPackage::properties((IDXDictionaryPackage *)this))
  {
    CFStringRef v4 = (pthread_mutex_t *)(this + 14);
    pthread_mutex_lock((pthread_mutex_t *)(this + 14));
    if (!*((unsigned char *)this + 108))
    {
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(this[2], @"IDXDictionaryIndexes");
      if (Value)
      {
        CFArrayRef v6 = Value;
        int Count = CFArrayGetCount(Value);
        *((_DWORD *)this + 26) = Count;
        this[12] = (CFDictionaryRef)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
        if (*((int *)this + 26) >= 1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, 0);
          CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"IDXIndexPath");
          uint64_t valuePtr = 1;
          CFNumberRef v10 = (const __CFNumber *)CFDictionaryGetValue(this[2], @"IDXDictionaryVersion");
          if (v10) {
            CFNumberGetValue(v10, kCFNumberCFIndexType, &valuePtr);
          }
          if (valuePtr >= 3 && !CFStringHasPrefix(v9, @"Resources/")) {
            CFStringRef v9 = CFStringCreateWithFormat(0, 0, @"Resources/%@", v9);
          }
          CreateDictionaryComponentURL(this[1], (uint64_t)v9);
          operator new();
        }
      }
      *((unsigned char *)this + 108) = 1;
      CFStringRef v4 = (pthread_mutex_t *)(this + 14);
    }
    pthread_mutex_unlock(v4);
  }
  if (a2) {
    *a2 = *((_DWORD *)this + 26);
  }
  return this[12];
}

void sub_1D5918E58(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

IDXIndexInfo *IDXDictionaryPackage::retainIndex(CFDictionaryRef *this, const __CFString *a2)
{
  CFStringRef v4 = (IDXIndexInfo **)IDXDictionaryPackage::indexInfoList(this, 0);
  int v5 = *((_DWORD *)this + 26);
  if (a2)
  {
    if (v5 >= 1)
    {
      uint64_t v6 = 0;
      while (1)
      {
        CFStringRef v7 = (const __CFString *)IDXIndexInfo::indexName(*v4);
        if (v7)
        {
          if (CFEqual(a2, v7)) {
            break;
          }
        }
        if (CFEqual(a2, *((CFStringRef *)*v4 + 4))) {
          break;
        }
        ++v6;
        ++v4;
        if (v6 >= *((int *)this + 26)) {
          return 0;
        }
      }
      goto LABEL_10;
    }
    return 0;
  }
  if (v5 <= 0) {
    return 0;
  }
LABEL_10:
  uint64_t v8 = *v4;
  if (v8) {
    IDXDictionaryPackage::retain((IDXDictionaryPackage *)this);
  }
  return v8;
}

void IDXDictionaryPackage::retain(IDXDictionaryPackage *this)
{
  CFDictionaryRef v2 = (pthread_mutex_t *)((char *)this + 184);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
  ++*((_DWORD *)this + 44);
  pthread_mutex_unlock(v2);
  *((CFAbsoluteTime *)this + 40) = CFAbsoluteTimeGetCurrent();
}

void IDXDictionaryPackage::releaseIndex(IDXDictionaryPackage *this, IDXIndexInfo *a2)
{
  if (a2) {
    IDXDictionaryPackage::release(this);
  }
}

void IDXDictionaryPackage::release(IDXDictionaryPackage *this)
{
  CFDictionaryRef v2 = (pthread_mutex_t *)((char *)this + 184);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
  int v3 = *((_DWORD *)this + 44);
  BOOL v4 = __OFSUB__(v3, 1);
  int v5 = v3 - 1;
  if (v5 < 0 == v4) {
    *((_DWORD *)this + 44) = v5;
  }
  pthread_mutex_unlock(v2);
  *((CFAbsoluteTime *)this + 40) = CFAbsoluteTimeGetCurrent();
}

uint64_t DCSMAGetDictionaryAssetCompatibilityVersion()
{
  return 14;
}

__CFString *DCSMAGetDictionaryAssetType()
{
  return @"com.apple.MobileAsset.DictionaryServices.dictionary2";
}

__CFArray *DCSMACopyAndUpdateDictionaryCompatibilityVersionHistory()
{
  uint64_t valuePtr = 5;
  CFNumberRef v0 = (const __CFNumber *)DCSCopySharedPreferenceValue(@"DCSLastUsedAssetCompatibilityVersion", 0, 0);
  if (v0)
  {
    CFNumberRef v1 = v0;
    CFNumberGetValue(v0, kCFNumberCFIndexType, &valuePtr);
    CFRelease(v1);
    if (valuePtr > 13) {
      return 0;
    }
  }
  uint64_t v8 = 14;
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberCFIndexType, &v8);
  DCSUpdateSharedPreferenceValue(@"DCSLastUsedAssetCompatibilityVersion", v4);
  CFRelease(v4);
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  for (uint64_t i = valuePtr; ; uint64_t i = v7)
  {
    uint64_t v7 = i + 1;
    if (i >= v8) {
      break;
    }
    CFNumberRef v6 = CFNumberCreate(0, kCFNumberCFIndexType, &v7);
    CFArrayAppendValue(Mutable, v6);
    CFRelease(v6);
  }
  return Mutable;
}

uint64_t DCSMAPrepareMobileAssetQuery()
{
  return 1;
}

const void *DCSMAGetAssetAttributes(const __CFDictionary *a1)
{
  return CFDictionaryGetValue(a1, @"attributes");
}

__CFString *DCSMAGetAssetLanguage(const __CFDictionary *a1)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"attributes");
  if (!Value) {
    return 0;
  }
  CFDictionaryRef v2 = Value;
  CFStringRef v3 = (const __CFString *)CFDictionaryGetValue(Value, @"Language");
  CFStringRef v4 = v3;
  if (v3)
  {
    if (CFStringCompare(v3, @"en", 1uLL) == kCFCompareEqualTo)
    {
      CFArrayRef v5 = (const __CFArray *)CFDictionaryGetValue(v2, @"Countries");
      if (v5)
      {
        CFArrayRef v6 = v5;
        v8.CFIndex length = CFArrayGetCount(v5);
        v8.CFIndex location = 0;
        if (CFArrayGetFirstIndexOfValue(v6, v8, @"US") == -1) {
          return @"en_GB";
        }
        else {
          return @"en_US";
        }
      }
    }
  }
  return (__CFString *)v4;
}

uint64_t DCSMAIsLanguageDictionaryAsset(const __CFDictionary *a1)
{
  if (DCSMAGetAssetLanguage(a1)) {
    return 1;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"attributes");
  CFArrayRef v4 = (const __CFArray *)CFDictionaryGetValue(Value, @"IndexLanguages");
  if (v4)
  {
    CFArrayRef v5 = v4;
    uint64_t Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v8.CFIndex location = 0;
      v8.CFIndex length = Count;
      BOOL v7 = CFArrayGetFirstIndexOfValue(v5, v8, @"*") == -1;
      return Count > 1 && v7;
    }
  }
  else
  {
    uint64_t Count = 0;
  }
  BOOL v7 = 1;
  return Count > 1 && v7;
}

uint64_t DCSMAPreferredOrderOfDictionaryAssetAttributesForLanguages(const void *a1, CFArrayRef theArray)
{
  if (!theArray) {
    return -1;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  uint64_t v5 = -1;
  if (a1)
  {
    uint64_t v6 = Count;
    if (Count)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(Mutable, @"attributes", a1);
      if (!DCSMAIsLanguageDictionaryAsset(Mutable))
      {
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, @"DictionaryIdentifier");
        if (Value)
        {
          if (CFStringCompare(Value, @"com.apple.dictionary.AppleDictionary", 0)) {
            uint64_t v5 = -1;
          }
          else {
            uint64_t v5 = 1000;
          }
        }
        goto LABEL_46;
      }
      CFRange v8 = DCSMAGetAssetLanguage(Mutable);
      if (!v8)
      {
        CFArrayRef v14 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, @"IndexLanguages");
        if (v14)
        {
          CFArrayRef v15 = v14;
          CFIndex v16 = CFArrayGetCount(v14);
          if (v16 >= 1)
          {
            CFIndex v17 = v16;
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
            CFStringRef v19 = (const __CFString *)CFArrayGetValueAtIndex(v15, 0);
            if (CompareLanguageCode(ValueAtIndex, v19, 0))
            {
              BOOL v20 = 1;
            }
            else
            {
              CFIndex v23 = 1;
              do
              {
                if (v17 == v23)
                {
LABEL_13:
                  uint64_t v5 = -1;
                  goto LABEL_46;
                }
                CFStringRef v24 = (const __CFString *)CFArrayGetValueAtIndex(v15, v23++);
              }
              while (!CompareLanguageCode(ValueAtIndex, v24, 0));
              BOOL v20 = v23 - 1 < v17;
            }
            uint64_t v5 = -1;
            if (v20 && v6 >= 2)
            {
              CFIndex v25 = 1;
              uint64_t v26 = 1;
              while (2)
              {
                CFStringRef v27 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v25);
                CFIndex v28 = 0;
                while (1)
                {
                  CFStringRef v29 = (const __CFString *)CFArrayGetValueAtIndex(v15, v28);
                  if (CompareLanguageCode(v27, v29, 0)) {
                    break;
                  }
                  if (v17 == ++v28) {
                    goto LABEL_41;
                  }
                }
                if (++v26 == v17)
                {
                  uint64_t v5 = 3;
                  goto LABEL_46;
                }
LABEL_41:
                ++v25;
                uint64_t v5 = -1;
                if (v25 != v6) {
                  continue;
                }
                break;
              }
            }
          }
        }
        goto LABEL_46;
      }
      if (v6 >= 1)
      {
        CFStringRef v9 = v8;
        uint64_t v5 = 0;
        CFIndex v10 = 0;
        while (1)
        {
          CFStringRef v11 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v10);
          if (CompareLanguageCode(v11, v9, 0)) {
            break;
          }
          int v12 = CompareLanguageCode(v11, @"hi", 0);
          if (!v10 && v12 && CompareLanguageCode(v9, @"en_GB", 0))
          {
            uint64_t v5 = 10;
            break;
          }
          ++v10;
          v5 += 20;
          if (v6 == v10) {
            goto LABEL_13;
          }
        }
        CFStringRef v21 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, @"DictionaryType");
        if (!v21)
        {
LABEL_28:
          v5 += 4;
          goto LABEL_46;
        }
        CFStringRef v22 = v21;
        if (CFStringCompare(v21, @"Monolingual", 1uLL))
        {
          if (CFStringCompare(v22, @"Bilingual", 1uLL) == kCFCompareEqualTo)
          {
            v5 += 2;
            goto LABEL_46;
          }
          if (CFStringCompare(v22, @"Thesaurus", 1uLL) == kCFCompareEqualTo)
          {
            v5 |= 1uLL;
            goto LABEL_46;
          }
          goto LABEL_28;
        }
      }
LABEL_46:
      CFRelease(Mutable);
    }
  }
  return v5;
}

CFDictionaryRef DCSMAGetAssetObj(const __CFDictionary *result)
{
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, @"asset");
  }
  return result;
}

void DCSMAUpdateLinguisticData(uint64_t a1, const __CFArray *a2, int a3)
{
  if (a1 && a2)
  {
    if (a3) {
      AddLinguisticDataAssetion(a1, a2);
    }
    else {
      RemoveLinguisticDataAssetion(a1, a2);
    }
  }
}

void DCSMAUpdateLinguisticDataForDictionaryAssetAttribute(const __CFDictionary *a1, int a2)
{
  if (a1)
  {
    CFStringRef Value = CFDictionaryGetValue(a1, @"DictionaryIdentifier");
    if (Value)
    {
      uint64_t v5 = (uint64_t)Value;
      CFArrayRef v6 = (const __CFArray *)CFDictionaryGetValue(a1, @"IndexLanguages");
      if (v6)
      {
        CFArrayRef v7 = v6;
        CFRetain(v6);
      }
      else
      {
        values = (void *)CFDictionaryGetValue(a1, @"Language");
        if (!values) {
          return;
        }
        CFArrayRef v7 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
        if (!v7) {
          return;
        }
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(Mutable, @"attributes", a1);
      if (DCSMAIsLanguageDictionaryAsset(Mutable))
      {
        if (a2) {
          AddLinguisticDataAssetion(v5, v7);
        }
        else {
          RemoveLinguisticDataAssetion(v5, v7);
        }
      }
      CFRelease(Mutable);
      CFRelease(v7);
    }
  }
}

id DCSMAIsInstalledAsset(const __CFDictionary *Value)
{
  if (Value) {
    CFStringRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"asset");
  }

  return [(__CFDictionary *)Value wasLocal];
}

id DCSMAIsDeletableAsset(const __CFDictionary *Value)
{
  if (Value) {
    CFStringRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"asset");
  }

  return [(__CFDictionary *)Value wasPurgeable];
}

CFMutableArrayRef DCSDictionaryAssetCopyInstalledDictionaries()
{
  valuePtr[1] = *MEMORY[0x1E4F143B8];
  if (_GetMobileAssetObjectInfo__DispatchOnceToken != -1) {
    dispatch_once(&_GetMobileAssetObjectInfo__DispatchOnceToken, &__block_literal_global_5);
  }
  CFMutableArrayRef v0 = (CFMutableArrayRef)_GetMobileAssetObjectInfo__ObjectInfoPtr;
  if (_GetMobileAssetObjectInfo__ObjectInfoPtr)
  {
    id v1 = objc_alloc_init(*(Class *)_GetMobileAssetObjectInfo__ObjectInfoPtr);
    id v2 = objc_msgSend(objc_alloc(*((Class *)v0 + 4)), sel_initWithType_, @"com.apple.MobileAsset.DictionaryServices.dictionary2");
    objc_msgSend(v2, sel_returnTypes_, 2);
    objc_msgSend(v2, sel_setDoNotBlockBeforeFirstUnlock_, 1);
    if (objc_msgSend(v2, sel_queryMetaDataSync))
    {
      CFMutableArrayRef v0 = 0;
LABEL_99:

      if (v0 && !CFArrayGetCount(v0))
      {
        CFRelease(v0);
        return 0;
      }
      return v0;
    }
    id v85 = v1;
    CFArrayRef v3 = (const __CFArray *)objc_msgSend(v2, sel_results);
    unint64_t v4 = 0x1E6A59000uLL;
    id v84 = v2;
    if (v3)
    {
      CFArrayRef v5 = v3;
      uint64_t Count = CFArrayGetCount(v3);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, Count, MEMORY[0x1E4F1D530], 0);
      CFDictionaryRef v8 = Mutable;
      if (Count >= 1)
      {
        CFDictionaryRef v92 = Mutable;
        CFIndex v9 = 0;
        CFRange v93 = sel_wasLocal;
        CFRange v91 = sel_purgeSync;
        do
        {
          CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v5, v9);
          unsigned int v11 = objc_msgSend(ValueAtIndex, sel_state);
          id v12 = objc_msgSend(ValueAtIndex, sel_attributes);
          if (v12)
          {
            CFStringRef v13 = v12;
            CFArrayRef v14 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CFArrayRef v15 = v14;
            if (ValueAtIndex) {
              CFDictionarySetValue(v14, @"asset", ValueAtIndex);
            }
            CFDictionarySetValue(v15, @"attributes", v13);
            if (v15) {
              CFStringRef Value = (void *)CFDictionaryGetValue(v15, @"asset");
            }
            else {
              CFStringRef Value = 0;
            }
            unsigned int v17 = objc_msgSend(Value, v93, v84);
            CFRelease(v15);
            if (v17)
            {
              CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v13, @"_CompatibilityVersion");
              valuePtr[0] = 0;
              if (v18)
              {
                CFNumberGetValue(v18, kCFNumberCFIndexType, valuePtr);
                if (valuePtr[0] == 14)
                {
                  CFStringRef v19 = CFDictionaryGetValue((CFDictionaryRef)v13, @"DictionaryIdentifier");
                  if (v19)
                  {
                    BOOL v20 = v19;
                    CFStringRef v21 = (void *)CFDictionaryGetValue(v92, v19);
                    if (!v21) {
                      goto LABEL_23;
                    }
                    CFStringRef v22 = v21;
                    CFNumberRef AssetContentVersion = _GetAssetContentVersion(ValueAtIndex);
                    BOOL v24 = (uint64_t)AssetContentVersion >= (uint64_t)_GetAssetContentVersion(v22) && v11 != 3;
                    if (!v24) {
                      CFStringRef v22 = ValueAtIndex;
                    }
                    [v22 v91];
                    CFNumberRef v25 = _GetAssetContentVersion(v22);
                    DCSLog(16, @"Purged duplicated old dictionary %@ (content ver = %ld)", v20, v25);
                    if (v24) {
LABEL_23:
                    }
                      CFDictionarySetValue(v92, v20, ValueAtIndex);
                  }
                }
              }
            }
          }
          ++v9;
        }
        while (Count != v9);
        unint64_t v4 = 0x1E6A59000;
        CFDictionaryRef v8 = v92;
      }
    }
    else
    {
      CFDictionaryRef v8 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], 0);
    }
    CFIndex v26 = CFDictionaryGetCount(v8);
    CFIndex v27 = v26;
    if (v26 <= 0)
    {
      CFArrayRef v30 = 0;
    }
    else
    {
      MEMORY[0x1F4188790](v26);
      CFStringRef v29 = (const void **)((char *)&v84 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0));
      CFDictionaryGetKeysAndValues(v8, 0, v29);
      CFArrayRef v30 = CFArrayCreate(0, v29, v27, 0);
    }
    CFRelease(v8);
    CFRange v91 = (char *)CFArrayCreateMutable(0, v27, MEMORY[0x1E4F1D510]);
    if (v27 >= 1)
    {
      CFIndex v31 = 0;
      CFStringRef v32 = *(const char **)(v4 + 3408);
      int v88 = sel_initWithLocaleIdentifier_;
      CFStringRef v89 = sel_localizedStringForLanguage_context_;
      CFRange v93 = (const char *)@"DCSDictionaryDescriptionLanguage";
      do
      {
        CFStringRef v33 = (void *)CFArrayGetValueAtIndex(v30, v31);
        CFDictionaryRef v34 = (const __CFDictionary *)[v33 v32];
        uint64_t v35 = DCSDictionaryCreateWithAssetAttributes(v34, (const __CFURL *)objc_msgSend(v33, sel_getLocalFileUrl));
        if (v35)
        {
          CFStringRef v36 = v35;
          uint64_t v37 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionarySetValue(v37, @"dictionaryRef", v36);
          CFRelease(v36);
          CFStringRef v38 = (const __CFString *)CFDictionaryGetValue(v34, @"DictionaryPackageName");
          if (CFStringCompare(v38, @"Apple Dictionary.dictionary", 0)
            && CFStringCompare(v38, @"TTY Abbreviations Dictionary.dictionary", 0))
          {
            if (_GetMobileAssetObjectInfo__DispatchOnceToken != -1) {
              dispatch_once(&_GetMobileAssetObjectInfo__DispatchOnceToken, &__block_literal_global_5);
            }
            uint64_t v39 = (Class *)_GetMobileAssetObjectInfo__ObjectInfoPtr;
            if (_GetMobileAssetObjectInfo__ObjectInfoPtr)
            {
              if (*(void *)(_GetMobileAssetObjectInfo__ObjectInfoPtr + 64))
              {
                CFArrayRef v40 = (const __CFArray *)CFDictionaryGetValue(v34, @"IndexLanguages");
                if (v40)
                {
                  CFArrayRef v41 = v40;
                  if (CFArrayGetCount(v40))
                  {
                    CFDictionaryRef v90 = (char *)CFArrayGetValueAtIndex(v41, 0);
                    CFIndex v42 = CFArrayGetCount(v41);
                    CFDictionaryRef v43 = 0;
                    if (v42 >= 2) {
                      CFDictionaryRef v43 = (const __CFDictionary *)CFArrayGetValueAtIndex(v41, 1);
                    }
                    CFDictionaryRef v92 = v43;
                    MainBundle = CFBundleGetMainBundle();
                    if (MainBundle)
                    {
                      CFArrayRef v45 = CFBundleCopyBundleLocalizations(MainBundle);
                      if (v45)
                      {
                        CFArrayRef v46 = v45;
                        if (CFArrayGetCount(v45) >= 1
                          && (CFStringRef v47 = (const __CFString *)CFArrayGetValueAtIndex(v46, 0)) != 0)
                        {
                          uint64_t CanonicalLanguageIdentifierFromString = (uint64_t)CFLocaleCreateCanonicalLanguageIdentifierFromString(0, v47);
                          CFRelease(v46);
                          if (CanonicalLanguageIdentifierFromString)
                          {
                            CFStringRef v48 = (const void *)CanonicalLanguageIdentifierFromString;
                            CFMutableArrayRef v86 = (CFMutableArrayRef)objc_alloc_init(*v39);
                            id v49 = objc_alloc(v39[8]);
                            id v50 = objc_msgSend(v49, v88, v48);
                            CFRelease(v48);
                            uint64_t CanonicalLanguageIdentifierFromString = (uint64_t)v50;
                            CFStringRef v51 = (const __CFString *)objc_msgSend(v50, v89, v90, 3);
                            if (v51) {
                              CFStringRef Copy = CFStringCreateCopy(0, v51);
                            }
                            else {
                              CFStringRef Copy = 0;
                            }
                            CFMutableArrayRef v58 = v86;
                            if (v92)
                            {
                              CFStringRef v59 = (const __CFString *)objc_msgSend((id)CanonicalLanguageIdentifierFromString, v89, v92, 3);
                              if (v59) {
                                CFStringRef v60 = CFStringCreateCopy(0, v59);
                              }
                              else {
                                CFStringRef v60 = 0;
                              }
                              CFDictionaryRef v92 = (const __CFDictionary *)CFStringCreateWithFormat(0, 0, @"%@-%@", Copy, v60);
                              CFRelease(Copy);
                              CFRelease(v60);
                              CFStringRef Copy = (CFStringRef)v92;
                              CFMutableArrayRef v58 = v86;
                            }

                            if (Copy) {
                              goto LABEL_53;
                            }
                          }
                        }
                        else
                        {
                          CFRelease(v46);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          CFDictionaryRef Name = DCSDictionaryGetName((uint64_t)v36);
          if (Name)
          {
            CFStringRef Copy = (CFStringRef)Name;
            CFRetain(Name);
LABEL_53:
            CFDictionarySetValue(v37, @"sortKey", Copy);
            CFRelease(Copy);
            xmlDocPtr v54 = CFDictionaryGetValue(v34, @"Language");
            if (v54
              || (CFArrayRef Languages = DCSDictionaryGetLanguages((uint64_t)v36)) != 0
              && (CFArrayRef v56 = Languages, CFArrayGetCount(Languages) >= 1)
              && (CFDictionaryRef v57 = (const __CFDictionary *)CFArrayGetValueAtIndex(v56, 0)) != 0
              && (xmlDocPtr v54 = CFDictionaryGetValue(v57, v93)) != 0)
            {
              CFDictionarySetValue(v37, @"language", v54);
            }
            CFArrayAppendValue((CFMutableArrayRef)v91, v37);
            CFRelease(v37);
          }
        }
        ++v31;
      }
      while (v27 != v31);
    }
    if (v30) {
      CFRelease(v30);
    }
    CFStringRef v61 = (__CFArray *)v91;
    v95.CFIndex length = CFArrayGetCount((CFArrayRef)v91);
    v95.CFIndex location = 0;
    CFArraySortValues(v61, v95, (CFComparatorFunction)_ComparatorForSortingDictionary, 0);
    CFIndex v62 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    CFMutableArrayRef v0 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    CFMutableArrayRef v63 = CFArrayCreateMutable(0, 0, v62);
    CFIndex v64 = CFArrayGetCount(v61);
    int v88 = (const char *)CFLocaleCopyPreferredLanguages();
    uint64_t CanonicalLanguageIdentifierFromString = CFArrayGetCount((CFArrayRef)v88);
    if (CanonicalLanguageIdentifierFromString < 1)
    {
LABEL_93:
      CFRelease(v88);
      CFRelease(v63);
      if (v64 >= 1)
      {
        for (CFIndex i = 0; i != v64; ++i)
        {
          CFDictionaryRef v81 = (const __CFDictionary *)CFArrayGetValueAtIndex(v61, i);
          CFStringRef v82 = CFDictionaryGetValue(v81, @"dictionaryRef");
          v98.CFIndex length = CFArrayGetCount(v0);
          v98.CFIndex location = 0;
          if (!CFArrayContainsValue(v0, v98, v82)) {
            CFArrayAppendValue(v0, v82);
          }
        }
      }
      CFRelease(v61);
      id v2 = v84;
      id v1 = v85;
      goto LABEL_99;
    }
    CFIndex v65 = 0;
    double v66 = (const void *)*MEMORY[0x1E4F1D218];
    CFDictionaryRef v92 = (const __CFDictionary *)*MEMORY[0x1E4F1D220];
    CFMutableArrayRef v86 = v0;
    while (1)
    {
      CFDictionaryRef v90 = (char *)v65;
      CFStringRef v67 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v88, v65);
      ComponentsFromLocaleCFStringRef Identifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, v67);
      CFStringRef v69 = (const __CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, v66);
      CFStringRef v89 = (const char *)ComponentsFromLocaleIdentifier;
      CFRange v93 = (const char *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, v92);
      if (v64 >= 1) {
        break;
      }
LABEL_92:
      CFRelease(v89);
      CFIndex v65 = (CFIndex)(v90 + 1);
      if (v90 + 1 == (char *)CanonicalLanguageIdentifierFromString) {
        goto LABEL_93;
      }
    }
    CFIndex v70 = 0;
    while (1)
    {
      CFDictionaryRef v71 = (const __CFDictionary *)CFArrayGetValueAtIndex(v61, v70);
      CFStringRef v72 = (const __CFString *)CFDictionaryGetValue(v71, @"language");
      if (v72) {
        break;
      }
LABEL_80:
      if (v64 == ++v70) {
        goto LABEL_92;
      }
    }
    CFDictionaryRef v73 = CFLocaleCreateComponentsFromLocaleIdentifier(0, v72);
    CFStringRef v74 = (const __CFString *)CFDictionaryGetValue(v73, v66);
    if (CFStringCompare(v74, v69, 0))
    {
LABEL_79:
      CFRelease(v73);
      goto LABEL_80;
    }
    CFStringRef v75 = CFDictionaryGetValue(v71, @"dictionaryRef");
    CFStringRef v76 = (const __CFString *)CFDictionaryGetValue(v73, v92);
    v96.CFIndex length = CFArrayGetCount(v0);
    v96.CFIndex location = 0;
    FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(v0, v96, v75);
    CFIndex v78 = FirstIndexOfValue;
    if (v76 && v93)
    {
      CFComparisonResult v79 = CFStringCompare(v76, (CFStringRef)v93, 0);
      CFStringRef v61 = (__CFArray *)v91;
      if (v79) {
        goto LABEL_79;
      }
      v97.CFIndex length = CFArrayGetCount(v63);
      v97.CFIndex location = 0;
      if (CFArrayContainsValue(v63, v97, v75))
      {
        CFMutableArrayRef v0 = v86;
        if (v78 != -1) {
          goto LABEL_79;
        }
      }
      else
      {
        CFArrayAppendValue(v63, v75);
        CFMutableArrayRef v0 = v86;
        if (v78 != -1) {
          CFArrayRemoveValueAtIndex(v86, v78);
        }
      }
    }
    else
    {
      CFStringRef v61 = (__CFArray *)v91;
      if (FirstIndexOfValue != -1) {
        goto LABEL_79;
      }
    }
    CFArrayAppendValue(v0, v75);
    goto LABEL_79;
  }
  return v0;
}

CFNumberRef _GetAssetContentVersion(void *a1)
{
  uint64_t valuePtr = 0;
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)objc_msgSend(a1, sel_attributes), @"_ContentVersion");
  if (result)
  {
    CFNumberGetValue(result, kCFNumberCFIndexType, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }
  return result;
}

CFComparisonResult _ComparatorForSortingDictionary(const __CFDictionary *a1, const __CFDictionary *a2)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"sortKey");
  CFStringRef v4 = (const __CFString *)CFDictionaryGetValue(a2, @"sortKey");

  return CFStringCompare(Value, v4, 0x20uLL);
}

__CFString *DCSMACopyDiagnosticLog()
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (_GetMobileAssetObjectInfo__DispatchOnceToken != -1) {
    dispatch_once(&_GetMobileAssetObjectInfo__DispatchOnceToken, &__block_literal_global_5);
  }
  uint64_t v0 = _GetMobileAssetObjectInfo__ObjectInfoPtr;
  if (!_GetMobileAssetObjectInfo__ObjectInfoPtr) {
    return 0;
  }
  id v1 = objc_alloc_init(*(Class *)_GetMobileAssetObjectInfo__ObjectInfoPtr);
  id v2 = objc_msgSend(*(id *)(v0 + 56), sel_processInfo);
  id v3 = objc_msgSend(v2, sel_operatingSystemVersionString);
  unsigned int has_internal_diagnostics = os_variant_has_internal_diagnostics();
  _LogMessage(@"System version: %@ (internal = %d)", v3, has_internal_diagnostics);
  _LogMessage(@"Current dictionary asset compatibility version: %d", 14);
  id v5 = objc_msgSend(v2, sel_processName);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle) {
    MainBundle = (__CFBundle *)CFBundleGetIdentifier(MainBundle);
  }
  CFArrayRef v7 = @"unknown identifier";
  if (MainBundle) {
    CFArrayRef v7 = (__CFString *)MainBundle;
  }
  _LogMessage(@"Caller application: %@ (%@)", v5, v7);
  CFErrorRef err = 0;
  CFURLRef v8 = (const __CFURL *)(*(uint64_t (**)(__CFString *, CFErrorRef *))(v0 + 72))(@"com.apple.MobileAsset.DictionaryServices.dictionary2", &err);
  CFURLRef v9 = v8;
  if (v8)
  {
    CFStringRef v10 = CFURLCopyHostName(v8);
    if (v10)
    {
      CFStringRef v11 = v10;
      if (CFStringGetCString(v10, buffer, 512, 0x8000100u))
      {
        id v12 = SCNetworkReachabilityCreateWithName(0, buffer);
        CFRelease(v11);
        if (!v12) {
          goto LABEL_40;
        }
        *(_DWORD *)buffer = 0;
        SCNetworkReachabilityGetFlags(v12, (SCNetworkReachabilityFlags *)buffer);
        CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
        CFArrayRef v14 = Mutable;
        if (buffer[0]) {
          CFStringRef v15 = @"T";
        }
        else {
          CFStringRef v15 = @"-";
        }
        CFStringAppend(Mutable, v15);
        if ((buffer[0] & 2) != 0) {
          CFStringRef v16 = @"R";
        }
        else {
          CFStringRef v16 = @"-";
        }
        CFStringAppend(v14, v16);
        if ((buffer[0] & 4) != 0) {
          CFStringRef v17 = @"C";
        }
        else {
          CFStringRef v17 = @"-";
        }
        CFStringAppend(v14, v17);
        if ((buffer[0] & 8) != 0) {
          CFStringRef v18 = @"A";
        }
        else {
          CFStringRef v18 = @"-";
        }
        CFStringAppend(v14, v18);
        if ((buffer[0] & 0x10) != 0) {
          CFStringRef v19 = @"I";
        }
        else {
          CFStringRef v19 = @"-";
        }
        CFStringAppend(v14, v19);
        if ((*(_DWORD *)buffer & 0x10000) != 0) {
          CFStringRef v20 = @"L";
        }
        else {
          CFStringRef v20 = @"-";
        }
        CFStringAppend(v14, v20);
        if ((*(_DWORD *)buffer & 0x20000) != 0) {
          CFStringRef v21 = @"D";
        }
        else {
          CFStringRef v21 = @"-";
        }
        CFStringAppend(v14, v21);
        if ((*(_DWORD *)buffer & 0x40000) != 0) {
          CFStringRef v22 = @"W";
        }
        else {
          CFStringRef v22 = @"-";
        }
        CFStringAppend(v14, v22);
        _LogMessage(@"Network reachability flags: %@", v14);
        CFRelease(v12);
        CFIndex v23 = v14;
      }
      else
      {
        CFIndex v23 = (__CFString *)v11;
      }
      CFRelease(v23);
    }
  }
LABEL_40:
  if (err)
  {
    CFURLRef v25 = (const __CFURL *)CFErrorCopyDescription(err);
    _LogMessage(@"Getting dictionary assets server failed due to error: %@", v25);
    goto LABEL_42;
  }
  _LogMessage(@"Dictionary assets server URL: %@", v9);
  *(void *)buffer = 0;
  BOOL v30 = _CheckURL(v9, (CFStringRef *)buffer);
  uint64_t v31 = *(void *)buffer;
  if (*(void *)buffer)
  {
    CFStringRef Copy = CFStringCreateWithFormat(0, 0, @"failed due to error: %@", *(void *)buffer);
    CFRelease(*(CFTypeRef *)buffer);
  }
  else
  {
    if (v30)
    {
      CFStringRef Copy = CFStringCreateCopy(0, @"OK");
      CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, @"com.apple.MobileAsset.DictionaryServices.dictionary2");
      v50.CFIndex length = CFStringGetLength(MutableCopy);
      v50.CFIndex location = 0;
      CFStringFindAndReplace(MutableCopy, @".", @"_", v50, 0);
      CFStringRef v35 = CFStringCreateWithFormat(0, 0, @"/%@/%@.xml", MutableCopy, MutableCopy);
      CFRelease(MutableCopy);
      CFURLRef v36 = CFURLCreateCopyAppendingPathComponent(0, v9, v35, 0);
      CFRelease(v35);
      BOOL v37 = _CheckURL(v36, (CFStringRef *)buffer);
      if (*(void *)buffer)
      {
        CFStringRef v38 = CFStringCreateWithFormat(0, 0, @"failed due to error: %@", *(void *)buffer);
        CFRelease(*(CFTypeRef *)buffer);
      }
      else
      {
        if (v37) {
          CFStringRef v45 = @"OK";
        }
        else {
          CFStringRef v45 = @"not exist";
        }
        CFStringRef v38 = CFStringCreateCopy(0, v45);
      }
      CFRelease(v36);
      _LogMessage(@"Checking access to the server and directory...%@", Copy);
      _LogMessage(@"Checking XML file existence in the server directory...%@", v38);
      if (!Copy) {
        goto LABEL_64;
      }
      goto LABEL_63;
    }
    CFStringRef Copy = CFStringCreateCopy(0, @"failed since the directory doesn't exist");
  }
  _LogMessage(@"Checking access to the server and directory...%@", Copy);
  CFStringRef v38 = 0;
  if (Copy) {
LABEL_63:
  }
    CFRelease(Copy);
LABEL_64:
  if (v38) {
    CFRelease(v38);
  }
  if (!v31) {
    goto LABEL_43;
  }
  CFURLRef v25 = CFURLCreateWithString(0, @"https://www.apple.com", 0);
  _CheckURL(v25, (CFStringRef *)buffer);
  if (*(void *)buffer)
  {
    _LogMessage(@"(accessing to www.apple.com was also failed due to error: %@)", *(void *)buffer);
    CFRelease(*(CFTypeRef *)buffer);
  }
  else
  {
    _LogMessage(@"(but accessing to www.apple.com was OK)", v46);
  }
LABEL_42:
  CFRelease(v25);
LABEL_43:
  id v26 = objc_msgSend(objc_alloc(*(Class *)(v0 + 32)), sel_initWithType_, @"com.apple.MobileAsset.DictionaryServices.dictionary2");
  objc_msgSend(v26, sel_returnTypes_, 2);
  objc_msgSend(v26, sel_setDoNotBlockBeforeFirstUnlock_, 1);
  id v27 = objc_msgSend(v26, sel_queryMetaDataSync);
  CFArrayRef v28 = (const __CFArray *)objc_msgSend(v26, sel_results);
  id v29 = v26;
  if (v27)
  {
    _LogMessage(@"Querying local dictionary assets (without network access)...failed due to error: %ld", v27);
  }
  else
  {
    _LogMessage(@"Querying local dictionary assets (without network access)...OK");
    if (v28) {
      CFIndex Count = CFArrayGetCount(v28);
    }
    else {
      CFIndex Count = 0;
    }
    _LogMessage(@"Local dictionary assets count: %ld", Count);
    _LogMessage(@"Local assets contains following NOAD dictionaries %@", @"{ ====");
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFDictionaryRef v40 = (const __CFDictionary *)objc_msgSend((id)CFArrayGetValueAtIndex(v28, i), sel_attributes);
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v40, @"DictionaryIdentifier");
        if (Value)
        {
          if (CFEqual(Value, @"com.apple.dictionary.NOAD"))
          {
            CFIndex v42 = CFDictionaryGetValue(v40, @"_CompatibilityVersion");
            CFDictionaryRef v43 = CFDictionaryGetValue(v40, @"_ContentVersion");
            size_t v44 = CFDictionaryGetValue(v40, @"_MasteredVersion");
            _LogMessage(@"    CompatibilityVersion:%@, ContentVersion:%@, MasteredVersion:%@", v42, v43, v44);
          }
        }
      }
    }
    _LogMessage(@"%@", @"==== }");
  }

  return _LogMessage(0);
}

__CFString *_LogMessage(CFStringRef format, ...)
{
  va_start(va, format);
  if (_LogMessage__OnceToken != -1)
  {
    dispatch_once(&_LogMessage__OnceToken, &__block_literal_global_289);
    if (format) {
      goto LABEL_3;
    }
LABEL_5:
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0, 0, (CFStringRef)_LogMessage__LogString);
    CFStringRef v4 = (__CFString *)_LogMessage__LogString;
    v11.CFIndex length = CFStringGetLength((CFStringRef)_LogMessage__LogString);
    v11.CFIndex location = 0;
    CFStringDelete(v4, v11);
    id v5 = CFDateFormatterCreate(0, 0, kCFDateFormatterShortStyle, kCFDateFormatterMediumStyle);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(0, v5, Current);
    CFRelease(v5);
    CFStringRef v8 = CFStringCreateWithFormat(0, 0, @"// ==== DictionaryServices Diagnostic Log (%@) ==== //\n", StringWithAbsoluteTime);
    CFRelease(StringWithAbsoluteTime);
    CFStringInsert(MutableCopy, 0, v8);
    CFRelease(v8);
    return MutableCopy;
  }
  if (!format) {
    goto LABEL_5;
  }
LABEL_3:
  CFStringRef v2 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  CFStringAppend((CFMutableStringRef)_LogMessage__LogString, v2);
  CFStringAppend((CFMutableStringRef)_LogMessage__LogString, @"\n");
  CFRelease(v2);
  return 0;
}

BOOL _CheckURL(const __CFURL *a1, CFStringRef *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a2) {
    *a2 = 0;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  Request = CFHTTPMessageCreateRequest(0, @"HEAD", a1, (CFStringRef)*MEMORY[0x1E4F18F90]);
  CFArrayRef v6 = CFReadStreamCreateForHTTPRequest(0, Request);
  CFArrayRef v7 = v6;
  if (v6 && CFReadStreamOpen(v6))
  {
    double v8 = Current + 10.0;
    CFIndex ResponseStatusCode = 404;
    while (!CFReadStreamHasBytesAvailable(v7))
    {
      if (CFAbsoluteTimeGetCurrent() > v8) {
        goto LABEL_8;
      }
    }
    CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F190D0];
    id v12 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v7, (CFStreamPropertyKey)*MEMORY[0x1E4F190D0]);
    if (v12)
    {
      CFStringRef v13 = v12;
      CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v12);
      CFRelease(v13);
      if (CFReadStreamRead(v7, buffer, 1024) > 0) {
        goto LABEL_21;
      }
    }
    else
    {
      if (CFReadStreamRead(v7, buffer, 1024) >= 1)
      {
        CFArrayRef v14 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v7, v11);
        if (v14)
        {
          CFStringRef v15 = v14;
          CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v14);
          CFRelease(v15);
        }
        else
        {
          CFIndex ResponseStatusCode = 404;
        }
        goto LABEL_21;
      }
      CFIndex ResponseStatusCode = 404;
    }
LABEL_8:
    if (a2) {
      *a2 = _CreateErrorDescriptionFromStream(v7);
    }
LABEL_21:
    BOOL v10 = ResponseStatusCode != 404;
    CFReadStreamClose(v7);
  }
  else
  {
    BOOL v10 = 0;
    if (a2) {
      *a2 = _CreateErrorDescriptionFromStream(v7);
    }
  }
  if (v7) {
    CFRelease(v7);
  }
  CFRelease(Request);
  return v10;
}

CFStringRef _CreateErrorDescriptionFromStream(__CFReadStream *a1)
{
  if (a1)
  {
    CFStringRef v2 = CFReadStreamCopyError(a1);
    if (v2)
    {
      id v3 = v2;
      CFStringRef v4 = CFErrorCopyDescription(v2);
      CFRelease(v3);
      return v4;
    }
    CFStreamError Error = CFReadStreamGetError(a1);
    if (Error.domain == *MEMORY[0x1E4F19010] && (Error.error & 0xFFFFFFFC) == 4294967292)
    {
      CFStringRef result = CFStringCreateCopy(0, *(__CFString **)((char *)off_1E6A59A38 + (((*(void *)&Error.error << 32) + 0x400000000) >> 29)));
      if (!Error.domain) {
        return result;
      }
    }
    else
    {
      CFStringRef result = 0;
      if (!Error.domain) {
        return result;
      }
    }
    if (!result) {
      return CFStringCreateWithFormat(0, 0, @"Stream error (domain=%d, error=%d)", Error.domain, *(void *)&Error.error);
    }
  }
  else
  {
    return CFStringCreateCopy(0, @"Could not create read stream");
  }
  return result;
}

void IDXIndexInfo::IDXIndexInfo(IDXIndexInfo *this, const __CFURL *a2, const __CFDictionary *a3, __CFBundle *a4)
{
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((void *)this + 10) = -1;
  *((void *)this + 11) = -1;
  *((unsigned char *)this + 96) = 0;
  *(void *)((char *)this + 100) = -1;
  *((_DWORD *)this + 27) = -1;
  *((unsigned char *)this + 160) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 168), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 232), 0);
  *((void *)this + 1) = CFRetain(a3);
  *((void *)this + 4) = CFURLCopyLastPathComponent(a2);
  if (a4)
  {
    DictionaryBundleFromComponentURL = (__CFBundle *)CFRetain(a4);
    *((void *)this + 5) = DictionaryBundleFromComponentURL;
    if (DictionaryBundleFromComponentURL) {
      goto LABEL_6;
    }
  }
  else
  {
    DictionaryBundleFromComponentURL = (__CFBundle *)*((void *)this + 5);
    if (DictionaryBundleFromComponentURL) {
      goto LABEL_6;
    }
  }
  DictionaryBundleFromComponentURL = CreateDictionaryBundleFromComponentURL(a2);
  *((void *)this + 5) = DictionaryBundleFromComponentURL;
  if (!DictionaryBundleFromComponentURL)
  {
    *(void *)this = CFURLCopyAbsoluteURL(a2);
    return;
  }
LABEL_6:
  CFURLRef v9 = CFBundleCopyResourceURL(DictionaryBundleFromComponentURL, *((CFStringRef *)this + 4), 0, 0);
  CFURLRef v10 = v9;
  if (!v9) {
    CFURLRef v9 = a2;
  }
  CFURLRef v11 = CFURLCopyAbsoluteURL(v9);
  *(void *)this = v11;
  CFStringRef v12 = CFURLCopyFileSystemPath(v11, kCFURLPOSIXPathStyle);
  *((void *)this + 2) = v12;
  CFRange v13 = CFStringFind(v12, @"Contents/", 0);
  v14.CFIndex length = CFStringGetLength(*((CFStringRef *)this + 2)) - (v13.location + v13.length);
  v14.CFIndex location = v13.location + v13.length;
  *((void *)this + 3) = CFStringCreateWithSubstring(0, *((CFStringRef *)this + 2), v14);
  if (v10) {
    CFRelease(v10);
  }
}

void IDXIndexInfo::~IDXIndexInfo(IDXIndexInfo *this)
{
  IDXIndexInfo::destructDataFields((void **)this);
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
  CFStringRef v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  id v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  CFStringRef v4 = (const void *)*((void *)this + 5);
  if (v4) {
    CFRelease(v4);
  }
  id v5 = (const void *)*((void *)this + 3);
  if (v5) {
    CFRelease(v5);
  }
  CFArrayRef v6 = (const void *)*((void *)this + 4);
  if (v6) {
    CFRelease(v6);
  }
  CFArrayRef v7 = (void *)*((void *)this + 6);
  if (v7) {
    free(v7);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 168));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 232));
}

void IDXIndexInfo::destructDataFields(void **this)
{
  if (*((unsigned char *)this + 160))
  {
    free(this[17]);
    free(this[18]);
    CFStringRef v2 = this[19];
    free(v2);
  }
}

const __CFDictionary *IDXIndexInfo::indexName(IDXIndexInfo *this)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 7);
  if (!result)
  {
    CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
    if (result)
    {
      CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"IDXIndexName");
      *((void *)this + 7) = result;
    }
  }
  return result;
}

const __CFDictionary *IDXIndexInfo::relativePath(IDXIndexInfo *this)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 3);
  if (!result)
  {
    CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
    if (result)
    {
      CFStringRef Value = CFDictionaryGetValue(result, @"IDXIndexPath");
      *((void *)this + 3) = Value;
      CFRetain(Value);
      return (const __CFDictionary *)*((void *)this + 3);
    }
  }
  return result;
}

CFStringRef IDXIndexInfo::fullPath(IDXIndexInfo *this)
{
  CFStringRef result = (CFStringRef)*((void *)this + 2);
  if (!result)
  {
    if (*((void *)this + 1))
    {
      CFStringRef result = CFURLCopyFileSystemPath(*(CFURLRef *)this, kCFURLPOSIXPathStyle);
      *((void *)this + 2) = result;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t IDXIndexInfo::POSIXPath(IDXIndexInfo *this)
{
  uint64_t result = *((void *)this + 6);
  if (!result)
  {
    if (*((void *)this + 1))
    {
      CFStringRef v3 = (const __CFString *)*((void *)this + 2);
      if (!v3)
      {
        CFStringRef v3 = CFURLCopyFileSystemPath(*(CFURLRef *)this, kCFURLPOSIXPathStyle);
        *((void *)this + 2) = v3;
      }
      CFIndex Length = CFStringGetLength(v3);
      CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
      CFArrayRef v6 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xECF878FAuLL);
      *((void *)this + 6) = v6;
      CFStringRef v7 = (const __CFString *)*((void *)this + 2);
      if (!v7)
      {
        if (*((void *)this + 1))
        {
          CFStringRef v7 = CFURLCopyFileSystemPath(*(CFURLRef *)this, kCFURLPOSIXPathStyle);
          *((void *)this + 2) = v7;
          CFArrayRef v6 = (char *)*((void *)this + 6);
        }
        else
        {
          CFStringRef v7 = 0;
        }
      }
      CFStringGetFileSystemRepresentation(v7, v6, MaximumSizeForEncoding);
      return *((void *)this + 6);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFDictionary *IDXIndexInfo::accessMethodName(IDXIndexInfo *this)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 8);
  if (!result)
  {
    CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
    if (result)
    {
      CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"IDXIndexAccessMethod");
      *((void *)this + 8) = result;
    }
  }
  return result;
}

const __CFDictionary *IDXIndexInfo::keyMatchingMethods(IDXIndexInfo *this)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 9);
  if (!result)
  {
    CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
    if (result)
    {
      CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"IDXIndexKeyMatchingMethods");
      *((void *)this + 9) = result;
    }
  }
  return result;
}

uint64_t IDXIndexInfo::dataSizeLength(IDXIndexInfo *this)
{
  id v1 = (char *)this + 80;
  if (*((void *)this + 10) == -1)
  {
    CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 1);
    if (v4)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v4, @"IDXIndexDataSizeLength");
      if (Value && CFNumberGetValue(Value, kCFNumberCFIndexType, v1))
      {
        if (*(void *)v1) {
          return *(void *)v1;
        }
      }
      else
      {
        *(void *)id v1 = 0;
      }
      IDXIndexInfo::dataFields(this);
      if (*((void *)this + 16) == 1 && !*((void *)this + 14) && !*((void *)this + 15)) {
        *((void *)this + 10) = *(void *)(*((void *)this + 19) + 8);
      }
    }
  }
  return *(void *)v1;
}

uint64_t IDXIndexInfo::dataFields(IDXIndexInfo *this)
{
  if (!*((unsigned char *)this + 160) && *((void *)this + 1))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
    if (!*((unsigned char *)this + 160))
    {
      IDXIndexInfo::constructDataFields((CFDictionaryRef *)this);
      *((unsigned char *)this + 160) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 168));
  }
  return (uint64_t)this + 112;
}

uint64_t IDXIndexInfo::fixedDataSize(IDXIndexInfo *this)
{
  if (!*((unsigned char *)this + 96))
  {
    IDXIndexInfo::dataFields(this);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
    if (!*((unsigned char *)this + 96))
    {
      *((void *)this + 11) = 0;
      if (!*((void *)this + 16))
      {
        uint64_t v2 = *((void *)this + 14);
        if (v2 < 1)
        {
          uint64_t v3 = 0;
        }
        else
        {
          uint64_t v3 = 0;
          CFDictionaryRef v4 = (uint64_t *)(*((void *)this + 17) + 16);
          do
          {
            uint64_t v5 = *v4;
            v4 += 3;
            v3 += v5;
            --v2;
          }
          while (v2);
          *((void *)this + 11) = v3;
        }
        uint64_t v6 = *((void *)this + 15);
        if (v6 >= 1)
        {
          CFStringRef v7 = (uint64_t *)(*((void *)this + 18) + 8);
          do
          {
            uint64_t v8 = *v7;
            v7 += 2;
            v3 += v8;
            --v6;
          }
          while (v6);
          *((void *)this + 11) = v3;
        }
      }
    }
    *((unsigned char *)this + 96) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 168));
  }
  return *((void *)this + 11);
}

BOOL IDXIndexInfo::writable(IDXIndexInfo *this)
{
  int v1 = *((_DWORD *)this + 25);
  if (v1 == -1)
  {
    CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 1);
    if (v4)
    {
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v4, @"IDXIndexWritable");
      int v6 = CFBooleanGetValue(Value);
      *((_DWORD *)this + 25) = v6;
      if (v6)
      {
        CFStringRef v7 = (const char *)IDXIndexInfo::POSIXPath(this);
        if (access(v7, 0))
        {
          int v1 = *((_DWORD *)this + 25);
        }
        else
        {
          uint64_t v8 = (const char *)IDXIndexInfo::POSIXPath(this);
          int v1 = access(v8, 2) == 0;
          *((_DWORD *)this + 25) = v1;
        }
      }
      else
      {
        int v1 = 0;
      }
    }
    else
    {
      int v1 = -1;
    }
  }
  return v1 != 0;
}

BOOL IDXIndexInfo::supportDataID(IDXIndexInfo *this)
{
  int v2 = *((_DWORD *)this + 26);
  if (v2 == -1)
  {
    CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 1);
    if (v3)
    {
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v3, @"IDXIndexSupportDataID");
      int v2 = CFBooleanGetValue(Value);
      *((_DWORD *)this + 26) = v2;
    }
    else
    {
      int v2 = -1;
    }
  }
  return v2 != 0;
}

BOOL IDXIndexInfo::bigEndian(IDXIndexInfo *this)
{
  int v2 = *((_DWORD *)this + 27);
  if (v2 == -1)
  {
    CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 1);
    if (v3)
    {
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v3, @"IDXIndexBigEndian");
      int v2 = CFBooleanGetValue(Value);
      *((_DWORD *)this + 27) = v2;
    }
    else
    {
      int v2 = -1;
    }
  }
  return v2 != 0;
}

const __CFDictionary *IDXIndexInfo::optionalProperty(IDXIndexInfo *this, const __CFString *a2)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

uint64_t IDXIndexInfo::constructDataFields(CFDictionaryRef *this)
{
  uint64_t result = (uint64_t)CFDictionaryGetValue(this[1], @"IDXIndexDataFields");
  if (!result) {
    return result;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)result;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)result, @"IDXExternalDataFields");
  if (!Value)
  {
    this[14] = 0;
    goto LABEL_9;
  }
  CFArrayRef v5 = Value;
  CFIndex Count = CFArrayGetCount(Value);
  this[14] = (CFDictionaryRef)Count;
  if (!Count)
  {
LABEL_9:
    this[17] = 0;
    goto LABEL_10;
  }
  uint64_t v7 = Count;
  this[17] = (CFDictionaryRef)malloc_type_malloc(24 * Count, 0x106004033AEC38CuLL);
  if (v7 >= 1)
  {
    uint64_t v8 = 0;
    for (CFIndex i = 0; i != v7; ++i)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v5, i);
      *(void *)((char *)this[17] + v8) = CFDictionaryGetValue(ValueAtIndex, @"IDXDataFieldName");
      *(void *)((char *)this[17] + v8 + 8) = CFDictionaryGetValue(ValueAtIndex, @"IDXIndexPath");
      CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"IDXDataSize");
      CFNumberGetValue(v11, kCFNumberCFIndexType, (char *)this[17] + v8 + 16);
      v8 += 24;
    }
  }
LABEL_10:
  CFArrayRef v12 = (const __CFArray *)CFDictionaryGetValue(v3, @"IDXFixedDataFields");
  if (!v12)
  {
    this[15] = 0;
    goto LABEL_17;
  }
  CFArrayRef v13 = v12;
  CFIndex v14 = CFArrayGetCount(v12);
  this[15] = (CFDictionaryRef)v14;
  if (!v14)
  {
LABEL_17:
    this[18] = 0;
    goto LABEL_18;
  }
  uint64_t v15 = v14;
  this[18] = (CFDictionaryRef)malloc_type_malloc(16 * v14, 0x1060040C2E02434uLL);
  if (v15 >= 1)
  {
    uint64_t v16 = 0;
    for (CFIndex j = 0; j != v15; ++j)
    {
      CFDictionaryRef v18 = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, j);
      *(void *)((char *)this[18] + v16) = CFDictionaryGetValue(v18, @"IDXDataFieldName");
      CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(v18, @"IDXDataSize");
      CFNumberGetValue(v19, kCFNumberCFIndexType, (char *)this[18] + v16 + 8);
      v16 += 16;
    }
  }
LABEL_18:
  uint64_t result = (uint64_t)CFDictionaryGetValue(v3, @"IDXVariableDataFields");
  if (!result)
  {
    this[16] = 0;
    goto LABEL_25;
  }
  CFArrayRef v20 = (const __CFArray *)result;
  uint64_t result = CFArrayGetCount((CFArrayRef)result);
  this[16] = (CFDictionaryRef)result;
  if (!result)
  {
LABEL_25:
    this[19] = 0;
    return result;
  }
  uint64_t v21 = result;
  uint64_t result = (uint64_t)malloc_type_malloc(16 * result, 0x1060040C2E02434uLL);
  this[19] = (CFDictionaryRef)result;
  if (v21 >= 1)
  {
    uint64_t v22 = 0;
    for (CFIndex k = 0; k != v21; ++k)
    {
      CFDictionaryRef v24 = (const __CFDictionary *)CFArrayGetValueAtIndex(v20, k);
      *(void *)((char *)this[19] + v22) = CFDictionaryGetValue(v24, @"IDXDataFieldName");
      CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(v24, @"IDXDataSizeLength");
      uint64_t result = CFNumberGetValue(v25, kCFNumberCFIndexType, (char *)this[19] + v22 + 8);
      v22 += 16;
    }
  }
  return result;
}

uint64_t IDXIndexInfo::openCount(IDXIndexInfo *this)
{
  if (!*((void *)this + 2)) {
    return 0;
  }
  int v2 = (pthread_rwlock_t *)(_allOpenedIndexes + 16);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(_allOpenedIndexes + 16));
  CFArrayRef Value = (unsigned int *)CFDictionaryGetValue(*(CFDictionaryRef *)(_allOpenedIndexes + 8), *((const void **)this + 2));
  if (Value) {
    uint64_t v4 = *Value;
  }
  else {
    uint64_t v4 = 0;
  }
  pthread_rwlock_unlock(v2);
  return v4;
}

void sub_1D591BBA4(_Unwind_Exception *a1)
{
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IDXIndexInfo::opened(IDXIndexInfo *this, void *a2)
{
  if ((_initedAllOpenedIndexes & 1) == 0) {
    pthread_once(&IDXIndexInfo::opened(void *)::once_control, (void (*)(void))_InitializeOpenedIndexes);
  }
  if (!*((void *)this + 2))
  {
    if (!*((void *)this + 1)) {
      return 0;
    }
    CFStringRef v8 = CFURLCopyFileSystemPath(*(CFURLRef *)this, kCFURLPOSIXPathStyle);
    *((void *)this + 2) = v8;
    if (!v8) {
      return 0;
    }
  }
  uint64_t v4 = (pthread_rwlock_t *)(_allOpenedIndexes + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_allOpenedIndexes + 16));
  CFDictionaryRef v5 = *(const __CFDictionary **)(_allOpenedIndexes + 8);
  CFArrayRef Value = CFDictionaryGetValue(v5, *((const void **)this + 2));
  if (!Value) {
    CFArrayRef Value = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  }
  ++*Value;
  Value[1] = a2;
  CFDictionarySetValue(v5, *((const void **)this + 2), Value);
  uint64_t v7 = *(unsigned int *)Value;
  pthread_rwlock_unlock(v4);
  return v7;
}

void sub_1D591BCC0(_Unwind_Exception *a1)
{
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

void _InitializeOpenedIndexes(void)
{
}

void sub_1D591BD80(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10C1C40412F3666);
  _Unwind_Resume(a1);
}

unsigned int *IDXIndexInfo::closed(IDXIndexInfo *this)
{
  if (!*((void *)this + 2)) {
    return 0;
  }
  int v2 = (pthread_rwlock_t *)(_allOpenedIndexes + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(_allOpenedIndexes + 16));
  CFDictionaryRef v3 = *(const __CFDictionary **)(_allOpenedIndexes + 8);
  CFArrayRef Value = (unsigned int *)CFDictionaryGetValue(v3, *((const void **)this + 2));
  CFDictionaryRef v5 = Value;
  if (Value)
  {
    int v6 = (const void *)*((void *)this + 2);
    if ((*(void *)Value)-- == 1)
    {
      CFDictionaryRemoveValue(v3, v6);
      free(v5);
      CFDictionaryRef v5 = 0;
    }
    else
    {
      CFDictionarySetValue(v3, v6, Value);
      CFDictionaryRef v5 = (unsigned int *)*v5;
    }
  }
  pthread_rwlock_unlock(v2);
  return v5;
}

void sub_1D591BE54(_Unwind_Exception *a1)
{
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t IDXIndexInfo::accessContextData(IDXIndexInfo *this, uint64_t *a2)
{
  if (*((void *)this + 2)) {
    BOOL v3 = _allOpenedIndexes == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    CFArrayRef Value = 0;
    uint64_t v4 = 0;
    uint64_t result = 0;
    if (!a2) {
      return result;
    }
  }
  else
  {
    uint64_t v7 = (pthread_rwlock_t *)(_allOpenedIndexes + 16);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(_allOpenedIndexes + 16));
    CFArrayRef Value = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(_allOpenedIndexes + 8), *((const void **)this + 2));
    pthread_rwlock_unlock(v7);
    if (!a2) {
      goto LABEL_13;
    }
    if (Value) {
      uint64_t v4 = *Value;
    }
    else {
      uint64_t v4 = 0;
    }
  }
  *a2 = v4;
LABEL_13:
  if (Value) {
    return Value[1];
  }
  else {
    return 0;
  }
}

void sub_1D591BF14(_Unwind_Exception *a1)
{
  pthread_rwlock_unlock(v1);
  _Unwind_Resume(a1);
}

__CFArray *DCSMACreateLocalDictionaryAssets_XPC()
{
  xpc_object_t v0 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v0, "command", "local_dictionary_assets");
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  if (DCSXPCConnection__ServiceConnection
    && (xpc_object_t v1 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)DCSXPCConnection__ServiceConnection, v0)) != 0)
  {
    int v2 = v1;
    value = (__CFArray *)xpc_dictionary_get_value(v1, "result");
    CFMutableDictionaryRef Mutable = value;
    if (value)
    {
      int64_t length = xpc_data_get_length(value);
      if (length >= 1
        && (CFIndex v6 = length,
            bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(Mutable),
            CFDataRef v8 = CFDataCreate(0, bytes_ptr, v6),
            CFArrayRef v9 = (const __CFArray *)CFPropertyListCreateWithData(0, v8, 0, 0, 0),
            CFRelease(v8),
            v9)
        && (CFIndex Count = CFArrayGetCount(v9), Count >= 1))
      {
        CFIndex v11 = Count;
        CFMutableDictionaryRef Mutable = 0;
        CFIndex v12 = 0;
        CFArrayRef v13 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
        do
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, v12);
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, ValueAtIndex);
          if (!Mutable) {
            CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, v13);
          }
          CFArrayAppendValue(Mutable, MutableCopy);
          CFRelease(MutableCopy);
          ++v12;
        }
        while (v11 != v12);
      }
      else
      {
        CFMutableDictionaryRef Mutable = 0;
      }
    }
    xpc_release(v2);
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
  }
  xpc_release(v0);
  return Mutable;
}

void DCSMACreateDictionaryAssetsAsync_XPC(uint64_t a1)
{
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  int v2 = (_xpc_connection_s *)DCSXPCConnection__ServiceConnection;
  if (DCSXPCConnection__ServiceConnection)
  {
    xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
    uint64_t v4 = v3;
    if (a1)
    {
      xpc_dictionary_set_string(v3, "command", "server_dictionary_assets");
      if (DCSXPCQueue__OnceToken != -1) {
        dispatch_once(&DCSXPCQueue__OnceToken, &__block_literal_global_38);
      }
      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 0x40000000;
      handler[2] = __DCSMACreateDictionaryAssetsAsync_XPC_block_invoke;
      handler[3] = &unk_1E6A59A60;
      handler[4] = a1;
      xpc_connection_send_message_with_reply(v2, v4, (dispatch_queue_t)DCSXPCQueue__XPCQueue, handler);
    }
    else
    {
      xpc_dictionary_set_string(v3, "command", "server_dictionary_assets_noreply");
      xpc_connection_send_message(v2, v4);
    }
    xpc_release(v4);
  }
  else if (a1)
  {
    CFDictionaryRef v5 = *(void (**)(uint64_t, void))(a1 + 16);
    v5(a1, 0);
  }
}

void DCSMADownloadDictionaryAsset_XPC(const __CFDictionary *a1, int a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v4, "command", "download_dictionary_asset");
  _SetDictionaryAssetIDToMessage(v4, a1);
  if (a2) {
    xpc_dictionary_set_BOOL(v4, "userInitiatedDownload", 1);
  }
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  if (DCSXPCConnection__ServiceConnection) {
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v4);
  }

  xpc_release(v4);
}

void _SetDictionaryAssetIDToMessage(void *a1, const __CFDictionary *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v3 = (const __CFDictionary *)DCSMAGetAssetAttributes(a2);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v3, @"DictionaryIdentifier");
  if (!Value) {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v3, @"DictionaryPackageName");
  }
  CFStringGetCString(Value, buffer, 255, 0x8000100u);
  xpc_dictionary_set_string(a1, "dictionaryID", buffer);
}

void DCSMAPurgeDictionaryAsset_XPC(const __CFDictionary *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "command", "purge_dictionary_asset");
  _SetDictionaryAssetIDToMessage(v2, a1);
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  if (DCSXPCConnection__ServiceConnection) {
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v2);
  }

  xpc_release(v2);
}

CFURLRef DCSMACreateAssetInstalledURL_XPC(const __CFDictionary *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "command", "copy_path_dictionary_asset");
  _SetDictionaryAssetIDToMessage(v2, a1);
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  if (DCSXPCConnection__ServiceConnection
    && (xpc_object_t v3 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)DCSXPCConnection__ServiceConnection, v2)) != 0)
  {
    xpc_object_t v4 = v3;
    CFURLRef value = (const __CFURL *)xpc_dictionary_get_value(v3, "result");
    CFURLRef v6 = value;
    if (value)
    {
      if (object_getClass(value) == (Class)MEMORY[0x1E4F145F0])
      {
        string_ptr = xpc_string_get_string_ptr(v6);
        CFStringRef v8 = CFStringCreateWithCString(0, string_ptr, 0x8000100u);
        CFURLRef v6 = CFURLCreateWithFileSystemPath(0, v8, kCFURLPOSIXPathStyle, 1u);
        CFRelease(v8);
      }
      else
      {
        CFURLRef v6 = 0;
      }
    }
    xpc_release(v4);
  }
  else
  {
    CFURLRef v6 = 0;
  }
  xpc_release(v2);
  return v6;
}

int64_t DCSMAGetAssetState_XPC(const __CFDictionary *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "command", "get_state_dictionary_asset");
  _SetDictionaryAssetIDToMessage(v2, a1);
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  if (DCSXPCConnection__ServiceConnection
    && (xpc_object_t v3 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)DCSXPCConnection__ServiceConnection, v2)) != 0)
  {
    xpc_object_t v4 = v3;
    int64_t int64 = xpc_dictionary_get_int64(v3, "result");
    xpc_release(v4);
  }
  else
  {
    int64_t int64 = 1;
  }
  xpc_release(v2);
  return int64;
}

void DCSMAPrepareDefaultDictionaryAssets_XPC(const __CFArray *a1, const __CFArray *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v4, "command", "prepare_default_assets");
  if (a1) {
    a2 = a1;
  }
  CFIndex Count = CFArrayGetCount(a2);
  xpc_object_t v6 = xpc_array_create(0, 0);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, i);
      CFStringGetCString(ValueAtIndex, buffer, 255, 0x8000100u);
      xpc_array_set_string(v6, 0xFFFFFFFFFFFFFFFFLL, buffer);
    }
  }
  if (a1) {
    CFArrayRef v9 = "dictionaryIDs";
  }
  else {
    CFArrayRef v9 = "languageIDs";
  }
  xpc_dictionary_set_value(v4, v9, v6);
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  if (DCSXPCConnection__ServiceConnection) {
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v4);
  }
  xpc_release(v4);
}

void *DCSCopySharedPreferenceValue(const __CFString *a1, uint64_t a2, int64_t *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a3) {
    *a3 = 0;
  }
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v6, "command", "read_preference");
  CFStringGetCString(a1, buffer, 255, 0x8000100u);
  xpc_dictionary_set_string(v6, "key", buffer);
  xpc_dictionary_set_uint64(v6, "currentVersion", a2);
  xpc_dictionary_set_BOOL(v6, "checkVersion", a3 != 0);
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  if (DCSXPCConnection__ServiceConnection
    && (xpc_object_t v7 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)DCSXPCConnection__ServiceConnection, v6)) != 0)
  {
    CFStringRef v8 = v7;
    if (a3)
    {
      xpc_object_t value = xpc_dictionary_get_value(v7, "savedVersion");
      if (value) {
        *a3 = xpc_int64_get_value(value);
      }
    }
    xpc_object_t v10 = xpc_dictionary_get_value(v8, "value");
    uint64_t v11 = v10;
    if (v10)
    {
      int64_t length = xpc_data_get_length(v10);
      if (length < 1)
      {
        uint64_t v11 = 0;
      }
      else
      {
        CFIndex v13 = length;
        bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v11);
        CFDataRef v15 = CFDataCreate(0, bytes_ptr, v13);
        uint64_t v11 = (void *)CFPropertyListCreateWithData(0, v15, 0, 0, 0);
        CFRelease(v15);
      }
    }
    xpc_release(v8);
  }
  else
  {
    uint64_t v11 = 0;
  }
  xpc_release(v6);
  return v11;
}

void DCSUpdateSharedPreferenceValue(const __CFString *a1, const void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v4, "command", "update_preference");
  if (a1)
  {
    CFStringGetCString(a1, buffer, 255, 0x8000100u);
    xpc_dictionary_set_string(v4, "key", buffer);
    CFDataRef Data = CFPropertyListCreateData(0, a2, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (Data)
    {
      CFDataRef v6 = Data;
      BytePtr = CFDataGetBytePtr(Data);
      size_t Length = CFDataGetLength(v6);
      xpc_dictionary_set_data(v4, "value", BytePtr, Length);
      CFRelease(v6);
    }
  }
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  if (DCSXPCConnection__ServiceConnection) {
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v4);
  }
  xpc_release(v4);
}

void DCSSynchronizeSharedPreference()
{
  xpc_object_t v0 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v0, "command", "sync_preference");
  if (DCSXPCConnection__OnceToken != -1) {
    dispatch_once(&DCSXPCConnection__OnceToken, &__block_literal_global_6);
  }
  if (DCSXPCConnection__ServiceConnection) {
    xpc_connection_send_message((xpc_connection_t)DCSXPCConnection__ServiceConnection, v0);
  }

  xpc_release(v0);
}

void __DCSXPCConnection_block_invoke()
{
  xpc_object_t v0 = xpc_connection_create("com.apple.DictionaryServiceHelper", 0);
  DCSXPCConnection__ServiceConnection = (uint64_t)v0;
  if (v0)
  {
    xpc_connection_set_event_handler(v0, &__block_literal_global_35);
    xpc_object_t v1 = (_xpc_connection_s *)DCSXPCConnection__ServiceConnection;
    if (DCSXPCConnection__ServiceConnection)
    {
      xpc_connection_resume(v1);
    }
  }
}

Class __DCSXPCConnection_block_invoke_2(int a1, id a2)
{
  return object_getClass(a2);
}

dispatch_queue_t __DCSXPCQueue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.DictionaryServiceHelper_queue", 0);
  DCSXPCQueue__XPCQueue = (uint64_t)result;
  return result;
}

void IDXPlugInAccessMethod::IDXPlugInAccessMethod(IDXPlugInAccessMethod *this, const __CFURL *a2, const __CFUUID *a3, CFTypeRef cf)
{
  *(void *)this = &unk_1F2DE33B8;
  CFTypeRef v7 = CFRetain(cf);
  *(void *)this = &unk_1F2DE3760;
  *((void *)this + 1) = v7;
  *((void *)this + 12) = 0;
  *((void *)this + 2) = CFPlugInCreate(0, a2);
  *((void *)this + 3) = CFRetain(a3);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 32), 0);
}

void sub_1D591CE68(_Unwind_Exception *exception_object)
{
  *xpc_object_t v1 = v2;
  xpc_object_t v4 = (const void *)v1[1];
  if (v4) {
    CFRelease(v4);
  }
  _Unwind_Resume(exception_object);
}

void IDXPlugInAccessMethod::~IDXPlugInAccessMethod(IDXPlugInAccessMethod *this)
{
  *(void *)this = &unk_1F2DE3760;
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  xpc_object_t v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  xpc_object_t v4 = (const void *)*((void *)this + 3);
  if (v4) {
    CFRelease(v4);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  *(void *)this = &unk_1F2DE33B8;
  CFDictionaryRef v5 = (const void *)*((void *)this + 1);
  if (v5) {
    CFRelease(v5);
  }
}

{
  uint64_t vars8;

  IDXPlugInAccessMethod::~IDXPlugInAccessMethod(this);

  JUMPOUT(0x1D94553C0);
}

void sub_1D591CF28(_Unwind_Exception *exception_object)
{
  *xpc_object_t v1 = &unk_1F2DE33B8;
  xpc_object_t v3 = (const void *)v1[1];
  if (v3) {
    CFRelease(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D591CFAC(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10E1C40777B8806);
  _Unwind_Resume(a1);
}

BOOL IDXPlugInAccessMethod::queryInterface(IDXPlugInAccessMethod *this, CFUUIDBytes a2, void **a3)
{
  uint64_t v4 = *(void *)&a2.byte8;
  uint64_t v5 = *(void *)&a2.byte0;
  uint64_t v6 = IDXPlugInAccessMethod::pluginInstance(this);
  BOOL v7 = v6 != 0;
  if (!v6)
  {
    if (!a3) {
      return 0;
    }
    CFStringRef v8 = 0;
    goto LABEL_7;
  }
  CFStringRef v8 = (void *)v6;
  *(void *)&v14.byte0 = v5;
  *(void *)&v14.byte8 = v4;
  CFUUIDRef v9 = CFUUIDCreateFromUUIDBytes(0, v14);
  CFUUIDRef v10 = CFUUIDGetConstantUUIDWithBytes(0, 0xA7u, 0xE7u, 0x9Eu, 0x44u, 0xCAu, 0x66u, 0x4Eu, 0xB0u, 0x88u, 0x56u, 0x8Cu, 0xDCu, 0x83u, 0x62u, 0x1Au, 0x80u);
  int v11 = CFEqual(v9, v10);
  BOOL v12 = v11 != 0;
  CFRelease(v9);
  if (a3 && v11)
  {
LABEL_7:
    *a3 = v8;
    return v7;
  }
  return v12;
}

uint64_t IDXPlugInAccessMethod::pluginInstance(IDXPlugInAccessMethod *this)
{
  xpc_object_t v3 = (char *)this + 96;
  uint64_t result = *((void *)this + 12);
  if (!result)
  {
    uint64_t v4 = (pthread_mutex_t *)((char *)this + 32);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    if (!*((void *)this + 12))
    {
      CFUUIDRef v5 = (const __CFUUID *)*((void *)this + 3);
      CFUUIDRef v6 = CFUUIDGetConstantUUIDWithBytes(0, 0x80u, 0x60u, 0x58u, 5u, 0x30u, 0x24u, 0x40u, 0x39u, 0xA3u, 0x62u, 0x10u, 0x4Cu, 0xEEu, 0x36u, 0x19u, 0x62u);
      BOOL v7 = CFPlugInInstanceCreate(0, v5, v6);
      if (v7)
      {
        CFStringRef v8 = v7;
        CFUUIDRef v9 = *(void (**)(void *, void, void, char *))(*(void *)v7 + 8);
        CFUUIDRef v10 = CFUUIDGetConstantUUIDWithBytes(0, 0xA7u, 0xE7u, 0x9Eu, 0x44u, 0xCAu, 0x66u, 0x4Eu, 0xB0u, 0x88u, 0x56u, 0x8Cu, 0xDCu, 0x83u, 0x62u, 0x1Au, 0x80u);
        CFUUIDBytes v11 = CFUUIDGetUUIDBytes(v10);
        v9(v8, *(void *)&v11.byte0, *(void *)&v11.byte8, v3);
        (*(void (**)(void *))(*(void *)v8 + 24))(v8);
      }
    }
    pthread_mutex_unlock(v4);
    return *(void *)v3;
  }
  return result;
}

uint64_t IDXPlugInAccessMethod::retain(IDXPlugInAccessMethod *this)
{
  uint64_t result = IDXPlugInAccessMethod::pluginInstance(this);
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 16);
    return v2();
  }
  return result;
}

uint64_t IDXPlugInAccessMethod::release(IDXPlugInAccessMethod *this)
{
  uint64_t result = IDXPlugInAccessMethod::pluginInstance(this);
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 24);
    return v2();
  }
  return result;
}

uint64_t IDXPlugInAccessMethod::openIndexFile(IDXPlugInAccessMethod *this, const __CFURL *a2, const __CFDictionary *a3)
{
  uint64_t result = IDXPlugInAccessMethod::pluginInstance(this);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 32);
    return v4();
  }
  return result;
}

uint64_t IDXPlugInAccessMethod::openIndexFile(IDXPlugInAccessMethod *this, IDXIndexInfo *a2)
{
  return (*(uint64_t (**)(IDXPlugInAccessMethod *, void, void))(*(void *)this + 40))(this, *(void *)a2, *((void *)a2 + 1));
}

uint64_t IDXPlugInAccessMethod::closeIndexFile(IDXPlugInAccessMethod *this, void *a2)
{
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)IDXPlugInAccessMethod::pluginInstance(this) + 40);

  return v2();
}

BOOL IDXPlugInAccessMethod::setSearchCharacters(IDXPlugInAccessMethod *this, void *a2, const unsigned __int16 *a3, uint64_t a4, const __CFString *a5)
{
  uint64_t v9 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, const unsigned __int16 *, uint64_t, const __CFString *))(*(void *)v9 + 48))(v9, a2, a3, a4, a5) != 0;
}

uint64_t IDXPlugInAccessMethod::getMatchDataPtr(IDXPlugInAccessMethod *this, void *a2, uint64_t a3, const unsigned __int8 **a4, uint64_t *a5)
{
  CFUUIDRef v5 = *(uint64_t (**)(void))(*(void *)IDXPlugInAccessMethod::pluginInstance(this) + 56);

  return v5();
}

uint64_t IDXPlugInAccessMethod::getMatchData(IDXPlugInAccessMethod *this, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, CFRange **a6, uint64_t *a7)
{
  BOOL v7 = *(uint64_t (**)(void))(*(void *)IDXPlugInAccessMethod::pluginInstance(this) + 64);

  return v7();
}

BOOL IDXPlugInAccessMethod::containsMatchData(IDXPlugInAccessMethod *this, void *a2, unsigned __int8 *a3)
{
  uint64_t v5 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, unsigned __int8 *))(*(void *)v5 + 72))(v5, a2, a3) != 0;
}

uint64_t IDXPlugInAccessMethod::getDataPtrByID(IDXPlugInAccessMethod *this, void *a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)IDXPlugInAccessMethod::pluginInstance(this) + 80);

  return v4();
}

uint64_t IDXPlugInAccessMethod::getDataByID(IDXPlugInAccessMethod *this, void *a2, unint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)IDXPlugInAccessMethod::pluginInstance(this) + 88);

  return v5();
}

BOOL IDXPlugInAccessMethod::supportDataPtr(IDXPlugInAccessMethod *this, void *a2)
{
  uint64_t v3 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *))(*(void *)v3 + 96))(v3, a2) != 0;
}

BOOL IDXPlugInAccessMethod::addRecord(IDXPlugInAccessMethod *this, void *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int8 *a5, uint64_t a6, unint64_t *a7)
{
  uint64_t v13 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, const unsigned __int16 *, uint64_t, const unsigned __int8 *, uint64_t, unint64_t *))(*(void *)v13 + 104))(v13, a2, a3, a4, a5, a6, a7) != 0;
}

BOOL IDXPlugInAccessMethod::deleteRecord(IDXPlugInAccessMethod *this, void *a2, const unsigned __int16 *a3, uint64_t a4, const unsigned __int8 *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, const unsigned __int16 *, uint64_t, const unsigned __int8 *, uint64_t, uint64_t))(*(void *)v13 + 112))(v13, a2, a3, a4, a5, a6, a7) != 0;
}

BOOL IDXPlugInAccessMethod::buildWithRecords(IDXPlugInAccessMethod *this, void *a2, const __CFArray *a3, const __CFArray *a4, unint64_t *a5)
{
  uint64_t v9 = IDXPlugInAccessMethod::pluginInstance(this);
  return (*(unsigned int (**)(uint64_t, void *, const __CFArray *, const __CFArray *, unint64_t *))(*(void *)v9 + 120))(v9, a2, a3, a4, a5) != 0;
}

uint64_t IDXPlugInAccessMethod::createIndexFile(IDXPlugInAccessMethod *this, const __CFURL *a2, const __CFDictionary *a3)
{
  uint64_t result = IDXPlugInAccessMethod::pluginInstance(this);
  if (result) {
    return (*(unsigned int (**)(uint64_t, const __CFURL *, const __CFDictionary *))(*(void *)result + 128))(result, a2, a3) != 0;
  }
  return result;
}

uint64_t IDXIndexGetTypeID()
{
  return _IDXIndexID;
}

__CFArray *IDXCopyIndexNames(const __CFURL *a1, int a2)
{
  uint64_t v4 = (IDXDictionaryManager *)SyncSingleton<IDXDictionaryManager>::instance();
  uint64_t v5 = (CFDictionaryRef *)IDXDictionaryManager::dictionary(v4, a1);
  if (!v5) {
    return 0;
  }
  LODWORD(capacity) = 0;
  CFDictionaryRef v6 = IDXDictionaryPackage::indexInfoList(v5, (int *)&capacity);
  if (!v6 || (int)capacity < 1) {
    return 0;
  }
  CFDictionaryRef v7 = v6;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, capacity, MEMORY[0x1E4F1D510]);
  if ((int)capacity >= 1)
  {
    for (uint64_t i = 0; i < (int)capacity; ++i)
    {
      CFUUIDRef v10 = (const __CFDictionary **)*((void *)v7 + i);
      if (!a2)
      {
        CFDictionaryRef v11 = IDXIndexInfo::indexName(*((IDXIndexInfo **)v7 + i));
        if (v11) {
          goto LABEL_9;
        }
        v10 += 4;
      }
      CFDictionaryRef v11 = *v10;
LABEL_9:
      CFArrayAppendValue(Mutable, v11);
    }
  }
  return Mutable;
}

uint64_t SyncSingleton<IDXDictionaryManager>::instance()
{
  if (!SyncSingleton<IDXDictionaryManager>::_instantiated)
  {
    pthread_mutex_lock(&SyncSingleton<IDXDictionaryManager>::_mutex);
    if (!SyncSingleton<IDXDictionaryManager>::_instantiated) {
      operator new();
    }
    pthread_mutex_unlock(&SyncSingleton<IDXDictionaryManager>::_mutex);
  }
  return SyncSingleton<IDXDictionaryManager>::_instance;
}

void sub_1D591D8C8(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0xC400A2AC0F1);
  _Unwind_Resume(a1);
}

void *IDXCreateIndexObject(uint64_t a1, const __CFURL *a2, const __CFString *a3)
{
  if (!a2) {
    return 0;
  }
  uint64_t v5 = (IDXDictionaryManager *)SyncSingleton<IDXDictionaryManager>::instance();
  CFDictionaryRef v6 = (CFDictionaryRef *)IDXDictionaryManager::dictionary(v5, a2);
  if (!v6) {
    return 0;
  }
  CFDictionaryRef v7 = (IDXDictionaryPackage *)v6;
  CFStringRef v8 = IDXDictionaryPackage::retainIndex(v6, a3);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = v8;
  CFUUIDRef v10 = (IDXAccessMethodManager *)SyncSingleton<IDXAccessMethodManager>::instance();
  CFStringRef v11 = (const __CFString *)IDXIndexInfo::accessMethodName(v9);
  BOOL v12 = IDXAccessMethodManager::accessMethod(v10, v11, v7);
  if (!v12 || (uint64_t v13 = v12, (v14 = (*(uint64_t (**)(void *, IDXIndexInfo *))(*v12 + 48))(v12, v9)) == 0))
  {
LABEL_9:
    IDXDictionaryPackage::releaseIndex(v7, v9);
    return 0;
  }
  uint64_t v15 = v14;
  pthread_once(&_IDXIndexClassID(void)::once_control, (void (*)(void))_IDXIndexInitialize);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    (*(void (**)(void *, uint64_t))(*v13 + 56))(v13, v15);
    goto LABEL_9;
  }
  CFStringRef v17 = (void *)Instance;
  uint64_t v18 = (void *)IDXIndexInfo::dataFields(v9);
  CFNumberRef v19 = malloc_type_malloc((32 * (v18[1] + *v18 + v18[2])) | 0x10, 0x2131404EuLL);
  v17[2] = v13;
  v17[3] = v7;
  v17[4] = v9;
  v17[5] = v15;
  v17[8] = v19;
  unsigned __int8 v20 = IDXIndexInfo::dataSizeLength(v9);
  uint64_t v21 = IDXIndexInfo::fixedDataSize(v9);
  BOOL v22 = IDXIndexInfo::bigEndian(v9);
  v17[6] = GetPreConfiguredGetDataSizeFunction(v20, v21, v22, v17 + 7);
  return v17;
}

uint64_t SyncSingleton<IDXAccessMethodManager>::instance()
{
  if (!SyncSingleton<IDXAccessMethodManager>::_instantiated)
  {
    pthread_mutex_lock(&SyncSingleton<IDXAccessMethodManager>::_mutex);
    if (!SyncSingleton<IDXAccessMethodManager>::_instantiated) {
      operator new();
    }
    pthread_mutex_unlock(&SyncSingleton<IDXAccessMethodManager>::_mutex);
  }
  return SyncSingleton<IDXAccessMethodManager>::_instance;
}

void sub_1D591DB1C(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x60C40902580DDLL);
  _Unwind_Resume(a1);
}

uint64_t IDXSetSearchCharacters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 16) + 64))(*(void *)(a1 + 16), *(void *)(a1 + 40), a2, a3, a4);
}

uint64_t IDXSetSearchString(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  unint64_t v8 = 0;
  uint64_t v5 = CreateCharactersFromString(a2, 0x100u, &v8);
  uint64_t v6 = (*(uint64_t (**)(void, void, UInt8 *, unint64_t, uint64_t))(**(void **)(a1 + 16) + 64))(*(void *)(a1 + 16), *(void *)(a1 + 40), v5, v8, a3);
  if (v5) {
    free(v5);
  }
  return v6;
}

void IDXPerformSearch(uint64_t a1, void (*a2)(uint64_t, char *, uint64_t, uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 112))(*(void *)(a1 + 16), *(void *)(a1 + 40));
  if (v6)
  {
    memset(v20, 0, 512);
    uint64_t v7 = (*(uint64_t (**)(void, void, uint64_t, _OWORD *, void *))(**(void **)(a1 + 16) + 72))(*(void *)(a1 + 16), *(void *)(a1 + 40), 128, v20, v19);
    if (v7)
    {
      uint64_t v8 = v7;
      do
      {
        if (v8 >= 1)
        {
          uint64_t v9 = v19;
          CFUUIDRef v10 = (char **)v20;
          do
          {
            BOOL v12 = *v10++;
            CFStringRef v11 = v12;
            uint64_t v13 = *v9++;
            a2(a1, v11, v13, 0, a3);
            --v8;
          }
          while (v8);
        }
        uint64_t v8 = (*(uint64_t (**)(void, void, uint64_t, _OWORD *, void *))(**(void **)(a1 + 16) + 72))(*(void *)(a1 + 16), *(void *)(a1 + 40), 128, v20, v19);
      }
      while (v8);
    }
  }
  else
  {
    *(void *)&v20[0] = 0x20000;
    BOOL v14 = 1;
    do
    {
      MEMORY[0x1F4188790](v6);
      uint64_t v16 = (char *)v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
      if (!v14) {
        uint64_t v16 = (char *)malloc_type_malloc(*(size_t *)&v20[0], 0x333A2437uLL);
      }
      v19[0] = 0;
      while (1)
      {
        uint64_t v6 = (*(uint64_t (**)(void, void, void, void, char *, void *, _OWORD *))(**(void **)(a1 + 16) + 80))(*(void *)(a1 + 16), *(void *)(a1 + 40), 0, *(void *)&v20[0], v16, v19, v20);
        if (!v6) {
          break;
        }
        uint64_t v17 = v6;
        if (v6 >= 1)
        {
          uint64_t v18 = 0;
          do
          {
            a2(a1, &v16[*(void *)(v19[0] + v18)], *(void *)(v19[0] + v18 + 8), 1, a3);
            v18 += 16;
            --v17;
          }
          while (v17);
        }
      }
      if (!v14) {
        free(v16);
      }
      BOOL v14 = *(void *)&v20[0] <= 0x20000;
    }
    while (*(void *)&v20[0]);
  }
}

uint64_t IDXSupportDataPtr(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 112))(*(void *)(a1 + 16), *(void *)(a1 + 40));
}

uint64_t IDXGetMatchDataPtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 16) + 72))(*(void *)(a1 + 16), *(void *)(a1 + 40), a2, a3, a4);
}

uint64_t IDXGetMatchData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  if (a6) {
    *a6 = a3;
  }
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 16) + 80))(*(void *)(a1 + 16), *(void *)(a1 + 40), a2, a3, a4, a5);
}

uint64_t IDXContainsMatchData(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(a1 + 16) + 88))(*(void *)(a1 + 16), *(void *)(a1 + 40), a2);
}

uint64_t IDXGetDataPtrByID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(**(void **)(a1 + 16) + 96))(*(void *)(a1 + 16), *(void *)(a1 + 40), a2, a3);
}

uint64_t IDXGetDataByID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 16) + 104))(*(void *)(a1 + 16), *(void *)(a1 + 40), a2, a3, a4);
}

CFIndex IDXSetRequestFields(uint64_t a1, const __CFArray *a2)
{
  CFArrayRef v41 = *(IDXIndexInfo **)(a1 + 32);
  uint64_t v3 = (uint64_t *)IDXIndexInfo::dataFields(v41);
  CFIndex result = CFArrayGetCount(a2);
  uint64_t v5 = result;
  uint64_t v38 = *v3;
  CFDictionaryRef v40 = v3;
  if (*v3 < 1)
  {
    uint64_t v8 = 0;
    CFIndex v7 = 0;
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    CFIndex v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = v3[3];
      if (v5 < 1)
      {
        CFIndex v11 = 0;
      }
      else
      {
        CFIndex v11 = 0;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v11);
          CFIndex result = CFStringCompare(ValueAtIndex, *(CFStringRef *)(v10 + 24 * v9), 0);
          if (!result) {
            break;
          }
          if (v5 == ++v11) {
            goto LABEL_11;
          }
        }
        uint64_t v13 = v8 + 1;
        BOOL v14 = (void *)(*(void *)(a1 + 64) + 32 * v8);
        v14[5] = v11 + 1;
        uint64_t v15 = *(void *)(v10 + 24 * v9 + 16);
        BOOL v16 = IDXIndexInfo::bigEndian(v41);
        CFIndex result = (CFIndex)GetPreConfiguredGetDataSizeFunction(0, v15, v16, v14 + 4);
        v14[2] = v7;
        v14[3] = result;
        uint64_t v3 = v40;
        ++v6;
        uint64_t v8 = v13;
        CFIndex v7 = 0;
      }
      if (v11 == v5) {
LABEL_11:
      }
        v7 += *(void *)(v10 + 24 * v9 + 16);
      ++v9;
    }
    while (v9 != v38);
  }
  uint64_t v17 = v3[1];
  if (v17 >= 1 && v6 < v5)
  {
    uint64_t v19 = 0;
    uint64_t v39 = v3[1];
    do
    {
      uint64_t v20 = v3[4];
      if (v5 < 1)
      {
        CFIndex v21 = 0;
      }
      else
      {
        CFIndex v21 = 0;
        while (1)
        {
          CFStringRef v22 = (const __CFString *)CFArrayGetValueAtIndex(a2, v21);
          CFIndex result = CFStringCompare(v22, *(CFStringRef *)(v20 + 16 * v19), 0);
          if (!result) {
            break;
          }
          if (v5 == ++v21)
          {
            uint64_t v17 = v39;
            goto LABEL_29;
          }
        }
        uint64_t v23 = v8 + 1;
        CFDictionaryRef v24 = (void *)(*(void *)(a1 + 64) + 32 * v8);
        v24[5] = v21 + 1;
        uint64_t v25 = *(void *)(v20 + 16 * v19 + 8);
        BOOL v26 = IDXIndexInfo::bigEndian(v41);
        CFIndex result = (CFIndex)GetPreConfiguredGetDataSizeFunction(0, v25, v26, v24 + 4);
        v24[2] = v7;
        v24[3] = result;
        uint64_t v17 = v39;
        uint64_t v3 = v40;
        ++v6;
        uint64_t v8 = v23;
        CFIndex v7 = 0;
      }
      if (v21 == v5) {
LABEL_29:
      }
        v7 += *(void *)(v20 + 16 * v19 + 8);
      ++v19;
    }
    while (v19 < v17 && v6 < v5);
  }
  uint64_t v27 = v3[2];
  if (v27 >= 1 && v6 < v5)
  {
    uint64_t v29 = 0;
    do
    {
      uint64_t v30 = v3[5] + 16 * v29;
      uint64_t v31 = *(void *)(a1 + 64) + 32 * v8;
      *(void *)(v31 + 40) = 0;
      CFStringRef v32 = (CFIndex *)(v31 + 40);
      int v33 = *(unsigned __int8 *)(v30 + 8);
      BOOL v34 = IDXIndexInfo::bigEndian(v41);
      CFIndex result = (CFIndex)GetPreConfiguredGetDataSizeFunction(v33, 0, v34, v32 - 1);
      *(v32 - 3) = v7;
      *(v32 - 2) = result;
      if (v5 >= 1)
      {
        CFIndex v35 = 0;
        while (1)
        {
          CFStringRef v36 = (const __CFString *)CFArrayGetValueAtIndex(a2, v35);
          CFIndex result = CFStringCompare(v36, *(CFStringRef *)v30, 0);
          ++v35;
          if (!result) {
            break;
          }
          if (v5 == v35) {
            goto LABEL_44;
          }
        }
        *CFStringRef v32 = v35;
        ++v6;
      }
LABEL_44:
      uint64_t v3 = v40;
      ++v8;
      if (++v29 >= v27) {
        break;
      }
      CFIndex v7 = 0;
    }
    while (v6 < v5);
  }
  BOOL v37 = *(uint64_t **)(a1 + 64);
  *BOOL v37 = v5;
  v37[1] = v8;
  return result;
}

uint64_t IDXGetFieldDataPtrs(uint64_t result, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  CFIndex v7 = *(uint64_t **)(result + 64);
  uint64_t v8 = *v7;
  if (*v7 >= 1)
  {
    uint64_t v9 = a4;
    uint64_t v10 = a5;
    do
    {
      *v9++ = 0;
      *v10++ = 0;
      --v8;
    }
    while (v8);
  }
  uint64_t v11 = v7[1];
  if (v11 >= 1 && a3 >= 1)
  {
    unint64_t v13 = a2 + a3;
    unsigned __int8 v20 = 0;
    BOOL v14 = v7 + 5;
    uint64_t v15 = 1;
    do
    {
      uint64_t v16 = a2 + *(v14 - 3);
      CFIndex result = ((uint64_t (*)(void, uint64_t, unsigned __int8 *))*(v14 - 2))(*(v14 - 1), v16, &v20);
      uint64_t v17 = v16 + v20;
      if (*v14)
      {
        if (result <= 0) {
          uint64_t v18 = 0;
        }
        else {
          uint64_t v18 = v16 + v20;
        }
        uint64_t v19 = 8 * *v14 - 8;
        *(void *)((char *)a4 + v19) = v18;
        *(void *)((char *)a5 + v19) = result;
      }
      if (v15 >= v11) {
        break;
      }
      v14 += 4;
      a2 = v17 + result;
      ++v15;
    }
    while (v17 + result < v13);
  }
  return result;
}

__CFData *IDXCreateFlattenData(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v3 = *(IDXIndexInfo **)(a1 + 32);
  uint64_t v4 = (uint64_t *)IDXIndexInfo::dataFields(v3);
  BOOL v5 = IDXIndexInfo::bigEndian(v3);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  uint64_t v7 = *v4;
  if (*v4 >= 1)
  {
    uint64_t v8 = 0;
    do
    {
      uint64_t v9 = v4[3];
      if (CFDictionaryContainsKey(a2, *(const void **)(v9 + v8)))
      {
        uint64_t v10 = v9 + v8;
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, *(const void **)v10);
        AppendFieldDataToData(Mutable, Value, *(unsigned __int8 *)(v10 + 16), 1, v5);
      }
      else
      {
        AppendNumberToData(Mutable, 0, *(unsigned __int8 *)(v9 + v8 + 16), v5);
      }
      v8 += 24;
      --v7;
    }
    while (v7);
  }
  uint64_t v12 = v4[1];
  if (v12 >= 1)
  {
    uint64_t v13 = 0;
    CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
    do
    {
      uint64_t v15 = v4[4];
      if (CFDictionaryContainsKey(a2, *(const void **)(v15 + v13)))
      {
        uint64_t v16 = v15 + v13;
        CFStringRef v17 = (const __CFString *)CFDictionaryGetValue(a2, *(const void **)v16);
        AppendFieldDataToData(Mutable, v17, *(unsigned __int8 *)(v16 + 8), 1, v5);
      }
      else
      {
        uint64_t v18 = v15 + v13;
        uint64_t v19 = (UInt8 *)malloc_type_calloc(1uLL, *(void *)(v15 + v13 + 8), 0x8E2BA5EDuLL);
        CFStringRef v20 = (const __CFString *)CFDataCreateWithBytesNoCopy(0, v19, *(void *)(v18 + 8), v14);
        AppendFieldDataToData(Mutable, v20, *(unsigned __int8 *)(v18 + 8), 1, v5);
        CFRelease(v20);
        free(v19);
      }
      v13 += 16;
      --v12;
    }
    while (v12);
  }
  uint64_t v21 = v4[2];
  if (v21 >= 1)
  {
    uint64_t v22 = 0;
    do
    {
      uint64_t v23 = v4[5];
      if (CFDictionaryContainsKey(a2, *(const void **)(v23 + v22)))
      {
        uint64_t v24 = v23 + v22;
        CFStringRef v25 = (const __CFString *)CFDictionaryGetValue(a2, *(const void **)v24);
        AppendFieldDataToData(Mutable, v25, *(unsigned __int8 *)(v24 + 8), 0, v5);
      }
      else
      {
        AppendNumberToData(Mutable, 0, *(unsigned __int8 *)(v23 + v22 + 8), v5);
      }
      v22 += 16;
      --v21;
    }
    while (v21);
  }
  return Mutable;
}

uint64_t IDXAddRecord(uint64_t a1, const __CFString *a2, const __CFData *a3, uint64_t a4)
{
  if (!a2 && IDXIndexInfo::keyMatchingMethods(*(IDXIndexInfo **)(a1 + 32))) {
    return 0;
  }
  unint64_t v16 = 0;
  uint64_t v8 = CreateCharactersFromString(a2, 0x100u, &v16);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(a1 + 40);
  unint64_t v11 = v16;
  BytePtr = CFDataGetBytePtr(a3);
  CFIndex Length = CFDataGetLength(a3);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, UInt8 *, unint64_t, const UInt8 *, CFIndex, uint64_t))(*(void *)v9 + 120))(v9, v10, v8, v11, BytePtr, Length, a4);
  free(v8);
  return v14;
}

uint64_t IDXDeleteRecord(uint64_t a1, const __CFString *a2, const __CFData *a3, uint64_t a4)
{
  if (!a2 && IDXIndexInfo::keyMatchingMethods(*(IDXIndexInfo **)(a1 + 32))) {
    return 0;
  }
  unint64_t v16 = 0;
  uint64_t v8 = CreateCharactersFromString(a2, 0x100u, &v16);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(a1 + 40);
  unint64_t v11 = v16;
  BytePtr = CFDataGetBytePtr(a3);
  CFIndex Length = CFDataGetLength(a3);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, UInt8 *, unint64_t, const UInt8 *, CFIndex, uint64_t))(*(void *)v9 + 128))(v9, v10, v8, v11, BytePtr, Length, a4);
  free(v8);
  return v14;
}

uint64_t IDXBuildIndexWithRecords(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 || !IDXIndexInfo::keyMatchingMethods(*(IDXIndexInfo **)(a1 + 32))) {
    return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 16) + 136))(*(void *)(a1 + 16), *(void *)(a1 + 40), a2, a3, a4);
  }
  else {
    return 0;
  }
}

uint64_t IDXCreateDictionaryPackage(const __CFURL *a1, __CFString *a2)
{
  uint64_t v4 = (IDXDictionaryManager *)SyncSingleton<IDXDictionaryManager>::instance();
  BOOL v5 = (IDXAccessMethodManager *)SyncSingleton<IDXAccessMethodManager>::instance();
  uint64_t result = (uint64_t)IDXDictionaryManager::templateProperty(v4, a2);
  if (result)
  {
    CFDictionaryRef v7 = (const __CFDictionary *)result;
    FileSystemPath = CreateFileSystemPath(a1);
    int v9 = mkdir(FileSystemPath, 0x1FFu);
    free(FileSystemPath);
    if (v9) {
      return 0;
    }
    CFURLRef DictionaryComponentURL = CreateDictionaryComponentURL(a1, 0);
    unint64_t v11 = (std::__fs::filesystem::path *)CreateFileSystemPath(DictionaryComponentURL);
    CFRelease(DictionaryComponentURL);
    LODWORD(DictionaryComponentURL) = mkdir((const char *)v11, 0x1FFu);
    free(v11);
    if (DictionaryComponentURL) {
      return 0;
    }
    uint64_t valuePtr = 1;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v7, @"IDXDictionaryVersion");
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
      if (valuePtr >= 3)
      {
        CFURLRef v13 = CreateDictionaryComponentURL(a1, @"Resources");
        unint64_t v11 = (std::__fs::filesystem::path *)CreateFileSystemPath(v13);
        CFRelease(v13);
        LODWORD(v13) = mkdir((const char *)v11, 0x1FFu);
        free(v11);
        if (v13) {
          return 0;
        }
      }
    }
    CFURLRef v14 = CreateDictionaryComponentURL(a1, @"Info.plist");
    uint64_t v15 = CFWriteStreamCreateWithFile(0, v14);
    if (v15)
    {
      unint64_t v16 = v15;
      if (CFWriteStreamOpen(v15))
      {
        CFIndex v17 = CFPropertyListWriteToStream(v7, v16, kCFPropertyListBinaryFormat_v1_0, 0);
        CFWriteStreamClose(v16);
        BOOL v18 = v17 > 0;
      }
      else
      {
        BOOL v18 = 0;
      }
      CFRelease(v16);
      if (!v14) {
        goto LABEL_15;
      }
    }
    else
    {
      BOOL v18 = 0;
      if (!v14)
      {
LABEL_15:
        if (v18)
        {
          uint64_t v19 = (CFDictionaryRef *)IDXDictionaryManager::dictionary(v4, a1);
          if (v19)
          {
            CFStringRef v20 = (CFAbsoluteTime *)v19;
            int v27 = 0;
            CFDictionaryRef v21 = IDXDictionaryPackage::indexInfoList(v19, &v27);
            if (v21)
            {
              if (v27 < 1) {
                return 1;
              }
              CFDictionaryRef v22 = v21;
              uint64_t v23 = 0;
              while (1)
              {
                uint64_t v24 = (IDXIndexInfo *)*((void *)v22 + v23);
                CFStringRef v25 = (const __CFString *)IDXIndexInfo::accessMethodName(v24);
                BOOL v26 = IDXAccessMethodManager::accessMethod(v5, v25, 0);
                if (!v26
                  || ((*(uint64_t (**)(void *, void, void))(*v26 + 144))(v26, *(void *)v24, *((void *)v24 + 1)) & 1) == 0)
                {
                  break;
                }
                if (++v23 >= v27) {
                  return 1;
                }
              }
            }
            IDXDictionaryManager::remove(v4, v20);
          }
        }
        DeleteDirectoryAtPath(v11);
        return 0;
      }
    }
    CFRelease(v14);
    goto LABEL_15;
  }
  return result;
}

void *IDXQueryAccessMethodInterface(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (IDXAccessMethodManager *)SyncSingleton<IDXAccessMethodManager>::instance();
  uint64_t result = IDXAccessMethodManager::accessMethod(v8, a1, 0);
  if (result) {
    return (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*result + 16))(result, a2, a3, a4);
  }
  return result;
}

uint64_t _IDXIndexInitialize(void)
{
  uint64_t result = _CFRuntimeRegisterClass();
  _IDXIndexID = result;
  return result;
}

void _IDXIndexFinalize(const void *a1)
{
  (*(void (**)(void, void))(**((void **)a1 + 2) + 56))(*((void *)a1 + 2), *((void *)a1 + 5));
  IDXDictionaryPackage::releaseIndex(*((IDXDictionaryPackage **)a1 + 3), *((IDXIndexInfo **)a1 + 4));
  uint64_t v2 = (void *)*((void *)a1 + 8);
  if (v2)
  {
    free(v2);
  }
}

BOOL _IDXIndexEqual(const void *a1, const void *a2)
{
  return a1 == a2;
}

CFStringRef _IDXIndexCopyFormattingDesc(CFURLRef **a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFStringRef PathComponent = CFURLCopyLastPathComponent(*a1[4]);
  if (PathComponent)
  {
    CFStringRef v6 = PathComponent;
    CFStringRef v7 = CFStringCreateWithFormat(v4, a2, @"<%@>", PathComponent);
    CFRelease(v6);
    return v7;
  }
  else
  {
    return CFStringCreateWithFormat(v4, a2, @"<#invalid index>");
  }
}

CFStringRef _IDXIndexCopyDebugDesc(CFURLRef **a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  uint64_t v3 = a1[4];
  CFStringRef v4 = CFURLCopyFileSystemPath(*v3, kCFURLPOSIXPathStyle);
  CFURLRef v5 = a1[2][1];
  if (!v4) {
    return CFStringCreateWithFormat(v2, 0, @"<IDXIndexRef %p>{access method = %@, #invalid index}", a1, v5);
  }
  CFStringRef v6 = v4;
  uint64_t v7 = IDXIndexInfo::openCount((IDXIndexInfo *)v3);
  CFStringRef v8 = CFStringCreateWithFormat(v2, 0, @"<IDXIndexRef %p>{access method = %@, index = %@, open# = %d}", a1, v5, v6, v7);
  CFRelease(v6);
  return v8;
}

uint64_t mtrie_open(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFStringRef v8 = malloc_type_malloc(0x48uLL, 0x10B004015DDB5A3uLL);
  if (v8)
  {
    v8[1] = 0u;
    v8[2] = 0u;
    *((void *)v8 + 6) = 0;
    *((void *)v8 + 7) = a1;
    *((void *)v8 + 8) = a2;
    *(void *)CFStringRef v8 = a3;
    *((void *)v8 + 1) = a4;
    operator new();
  }
  return 0;
}

void sub_1D591EEDC(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C40FE8A955FLL);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie *mtrie_exact_match_search(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t result = 0;
  if (a2 && a3)
  {
    if (!*(_DWORD *)(a1 + 24)) {
      return 0;
    }
    marisa::Agent::set_query(*(void **)(a1 + 40), a2, a3);
    uint64_t result = marisa::Trie::lookup(*(marisa::grimoire::trie::LoudsTrie ***)(a1 + 32), *(marisa::Agent **)(a1 + 40));
    if (!result) {
      return result;
    }
    uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 40) + 36);
    if (*(_DWORD *)(a1 + 24) > v5) {
      return (marisa::grimoire::trie::LoudsTrie *)*(unsigned int *)(*(void *)(a1 + 16) + 4 * v5);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t mtrie_build(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a2) {
    return 0;
  }
  marisa::Keyset::Keyset((marisa::Keyset *)v33);
  uint64_t v10 = 0;
  do
  {
    marisa::Keyset::push_back(v33, *(const char **)(a3 + 8 * v10), *(void *)(a4 + 8 * v10), 1.0);
    ++v10;
  }
  while (a2 != v10);
  marisa::Trie::build(*(marisa::grimoire::trie::LoudsTrie ***)(a1 + 32), (marisa::Keyset *)v33, 0x21203u);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v31);
  marisa::write(&v32, *(void *)(a1 + 32));
  std::stringbuf::str();
  uint64_t v11 = 4 * a2 + 28;
  if ((a2 & 1) == 0) {
    uint64_t v11 = 4 * a2 + 24;
  }
  uint64_t v12 = v30;
  if ((v30 & 0x80u) != 0) {
    uint64_t v12 = v29;
  }
  uint64_t v13 = v12 + v11;
  uint64_t v14 = (*(uint64_t (**)(void, uint64_t, void))(a1 + 56))(*(void *)a1, v12 + v11, *(void *)(a1 + 64));
  uint64_t v15 = v14;
  uint64_t v16 = 0;
  *(void *)a1 = v14;
  *(void *)(a1 + 8) = v13;
  *(void *)uint64_t v14 = 0x1800000001;
  int v17 = 4 * a2 + 28;
  if ((a2 & 1) == 0) {
    int v17 = 4 * a2 + 24;
  }
  *(_DWORD *)(v14 + 8) = a2;
  *(_DWORD *)(v14 + 12) = v17;
  int v18 = v30;
  if ((v30 & 0x80u) != 0) {
    int v18 = v29;
  }
  *(_DWORD *)(v14 + 16) = v18;
  *(_DWORD *)(v14 + 20) = v13;
  *(void *)(a1 + 16) = v14 + 24;
  *(_DWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 48) = v13;
  uint64_t v19 = *(void *)(a1 + 40);
  do
  {
    marisa::Agent::set_query((void *)v19, *(const char **)(a3 + 8 * v16), *(void *)(a4 + 8 * v16));
    if ((marisa::Trie::lookup(*(marisa::grimoire::trie::LoudsTrie ***)(a1 + 32), *(marisa::Agent **)(a1 + 40)) & 1) == 0)
    {
      uint64_t v24 = (FILE *)*MEMORY[0x1E4F143C8];
      CFStringRef v25 = "trie->_marisa_trie->lookup failed.\n";
      size_t v26 = 35;
LABEL_25:
      fwrite(v25, v26, 1uLL, v24);
      uint64_t v23 = 0xFFFFFFFFLL;
      goto LABEL_26;
    }
    uint64_t v19 = *(void *)(a1 + 40);
    unint64_t v20 = *(unsigned int *)(v19 + 36);
    if (v20 >= a2)
    {
      uint64_t v24 = (FILE *)*MEMORY[0x1E4F143C8];
      CFStringRef v25 = "wrong entry ID.\n";
      size_t v26 = 16;
      goto LABEL_25;
    }
    uint64_t v21 = *(void *)(a1 + 16);
    *(_DWORD *)(v21 + 4 * v20) = *(_DWORD *)(a5 + 4 * v16++);
  }
  while (a2 != v16);
  if (a2) {
    *(_DWORD *)(v21 + 4 * a2) = 0;
  }
  if ((v30 & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  memcpy((void *)(*(void *)a1 + *(unsigned int *)(v15 + 12)), p_p, *(unsigned int *)(v15 + 16));
  uint64_t v23 = 0;
LABEL_26:
  if ((char)v30 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)v31);
  marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array(v35);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(v34);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)v33);
  return v23;
}

void sub_1D591F1D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)(v15 - 192));
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  uint64_t v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  CFStringRef v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x1E4FBA488] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1D591F4F8(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x1D9455360](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA408];
  uint64_t v3 = *MEMORY[0x1E4FBA408];
  *(void *)a1 = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D9455360](a1 + 128);
  return a1;
}

void sub_1D591F65C(_Unwind_Exception *a1)
{
  MEMORY[0x1D9455360](v1 + 128);
  _Unwind_Resume(a1);
}

void marisa::Keyset::~Keyset(marisa::Keyset *this)
{
  marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array((uint64_t *)this + 6);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)this + 3);

  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)this);
}

void sub_1D591F6D0(_Unwind_Exception *a1)
{
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(v1);
  _Unwind_Resume(a1);
}

uint64_t mtrie_data(unsigned int *a1, void *a2)
{
  if (a2) {
    *a2 = a1[12];
  }
  return *(void *)a1;
}

void mtrie_close(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[4];
    if (v2)
    {
      marisa::Trie::~Trie((marisa::Trie *)a1[4]);
      MEMORY[0x1D94553C0](v2, 0x20C4093837F09);
    }
    uint64_t v3 = a1[5];
    if (v3)
    {
      marisa::Agent::~Agent((marisa::Agent *)a1[5]);
      MEMORY[0x1D94553C0](v3, 0x1070C40FE8A955FLL);
    }
    free(a1);
  }
}

void sub_1D591F7A0(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C40FE8A955FLL);
  _Unwind_Resume(a1);
}

uint64_t *marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v5 = *(void *)(v2 - 8);
    uint64_t v4 = v2 - 8;
    uint64_t v3 = v5;
    if (v5)
    {
      uint64_t v6 = 8 * v3;
      do
      {
        uint64_t v7 = *(void *)(v4 + v6);
        if (v7) {
          MEMORY[0x1D9455390](v7, 0x1050C80717B85FCLL);
        }
        v6 -= 8;
      }
      while (v6);
    }
    MEMORY[0x1D9455390](v4 - 8, 0x20C8093837F09);
  }
  return a1;
}

uint64_t *marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v5 = *(void *)(v2 - 8);
    uint64_t v4 = v2 - 8;
    uint64_t v3 = v5;
    if (v5)
    {
      uint64_t v6 = 8 * v3;
      do
      {
        uint64_t v7 = *(void *)(v4 + v6);
        if (v7) {
          MEMORY[0x1D9455390](v7, 0x1000C8077774924);
        }
        v6 -= 8;
      }
      while (v6);
    }
    MEMORY[0x1D9455390](v4 - 8, 0x10C80436913F5);
  }
  return a1;
}

UInt8 *CreateCharactersFromString(const __CFString *a1, CFStringEncoding a2, unint64_t *a3)
{
  if (a1)
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex usedBufLen = 0;
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, a2);
    CFStringRef v8 = (UInt8 *)malloc_type_malloc(MaximumSizeForEncoding, 0xFCECAB9AuLL);
    v11.CFIndex location = 0;
    v11.int64_t length = Length;
    CFStringGetBytes(a1, v11, a2, 0, 0, v8, MaximumSizeForEncoding, &usedBufLen);
    if (a3) {
      *a3 = (unint64_t)usedBufLen >> 1;
    }
  }
  else
  {
    CFStringRef v8 = 0;
    if (a3) {
      *a3 = 0;
    }
  }
  return v8;
}

char *CreateFileSystemPath(const __CFURL *a1)
{
  CFURLRef v1 = CFURLCopyAbsoluteURL(a1);
  CFStringRef v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  CFRelease(v1);
  if (!v2) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(v2);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  uint64_t v5 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0x31523115uLL);
  LODWORD(MaximumSizeForEncoding) = CFStringGetFileSystemRepresentation(v2, v5, MaximumSizeForEncoding);
  CFRelease(v2);
  if (!MaximumSizeForEncoding)
  {
    free(v5);
    return 0;
  }
  return v5;
}

CFURLRef CreateDictionaryComponentURL(const __CFURL *a1, uint64_t a2)
{
  if (a2) {
    CFStringRef v4 = CFStringCreateWithFormat(0, 0, @"Contents/%@", a2);
  }
  else {
    CFStringRef v4 = CFStringCreateWithFormat(0, 0, @"Contents");
  }
  CFStringRef v5 = v4;
  CFURLRef v6 = CFURLCreateCopyAppendingPathComponent(0, a1, v4, a2 == 0);
  CFRelease(v5);
  return v6;
}

CFBundleRef CreateDictionaryBundleFromComponentURL(const __CFURL *a1)
{
  CFStringRef PathComponent = CFURLCopyLastPathComponent(a1);
  if (CFStringCompare(PathComponent, @"/", 0))
  {
    CFURLRef v3 = a1;
    while (1)
    {
      CFComparisonResult v4 = CFStringCompare(PathComponent, @"Contents", 0);
      CFRelease(PathComponent);
      CFURLRef v5 = CFURLCreateCopyDeletingLastPathComponent(0, v3);
      if (v4 == kCFCompareEqualTo) {
        break;
      }
      if (v3 != a1) {
        CFRelease(v3);
      }
      CFStringRef PathComponent = CFURLCopyLastPathComponent(v5);
      CFURLRef v3 = v5;
      if (CFEqual(PathComponent, @"/"))
      {
        CFBundleRef v6 = 0;
        CFURLRef v3 = v5;
        goto LABEL_10;
      }
    }
    CFBundleRef v6 = CFBundleCreate(0, v5);
    CFStringRef PathComponent = (const __CFString *)v5;
  }
  else
  {
    CFBundleRef v6 = 0;
    CFURLRef v3 = a1;
  }
LABEL_10:
  CFRelease(PathComponent);
  if (v3 != a1) {
    CFRelease(v3);
  }
  return v6;
}

DIR *DeleteDirectoryAtPath(const std::__fs::filesystem::path *a1)
{
  memset(&v11, 0, sizeof(v11));
  if (lstat((const char *)a1, &v11) < 0) {
    return 0;
  }
  if ((v11.st_mode & 0xF000) != 0x4000) {
    return (DIR *)!remove(a1, v2);
  }
  uint64_t result = opendir((const char *)a1);
  if (result)
  {
    CFComparisonResult v4 = result;
    size_t v5 = strlen((const char *)a1) + 256;
    CFBundleRef v6 = (char *)malloc_type_malloc(v5, 0xABB69ADBuLL);
    strlcpy(v6, (const char *)a1, v5);
    size_t v7 = strlen((const char *)a1);
    *(_WORD *)&v6[v7] = 47;
    CFStringRef v8 = &v6[v7 + 1];
    while (1)
    {
      uint64_t v9 = readdir(v4);
      if (!v9) {
        break;
      }
      d_name = v9->d_name;
      if (strcmp(v9->d_name, "."))
      {
        if (strcmp(d_name, ".."))
        {
          strlcpy(v8, d_name, 0x100uLL);
          if (!DeleteDirectoryAtPath(v6))
          {
            free(v6);
            closedir(v4);
            return 0;
          }
        }
      }
    }
    free(v6);
    closedir(v4);
    return (DIR *)(rmdir((const char *)a1) >= 0);
  }
  return result;
}

DIR *DeleteDirectoryAtURL(const __CFURL *a1)
{
  FileSystemPath = (std::__fs::filesystem::path *)CreateFileSystemPath(a1);
  CFStringRef v2 = DeleteDirectoryAtPath(FileSystemPath);
  free(FileSystemPath);
  return v2;
}

void *GetPreConfiguredGetDataSizeFunction(int a1, uint64_t a2, int a3, void *a4)
{
  CFComparisonResult v4 = _GetDataSize_8bit;
  switch(a1)
  {
    case 0:
      size_t v5 = _GetDataSize_FixedLength;
      if (a4)
      {
        *a4 = a2;
        size_t v5 = _GetDataSize_FixedLength;
      }
      goto LABEL_6;
    case 1:
      return v4;
    case 2:
      BOOL v6 = a3 == 0;
      CFComparisonResult v4 = _GetDataSize_16bitBigEndian;
      size_t v7 = _GetDataSize_16bitLittleEndian;
      goto LABEL_9;
    case 4:
      BOOL v6 = a3 == 0;
      CFComparisonResult v4 = _GetDataSize_32bitBigEndian;
      size_t v7 = _GetDataSize_32bitLittleEndian;
      goto LABEL_9;
    case 8:
      BOOL v6 = a3 == 0;
      CFComparisonResult v4 = _GetDataSize_64bitBigEndian;
      size_t v7 = _GetDataSize_64bitLittleEndian;
LABEL_9:
      if (v6) {
        CFComparisonResult v4 = v7;
      }
      break;
    default:
      size_t v5 = _GetDataSize_Invalid;
LABEL_6:
      CFComparisonResult v4 = v5;
      break;
  }
  return v4;
}

void _GetDataSize_FixedLength(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *a3 = 0;
}

uint64_t _GetDataSize_8bit(uint64_t a1, unsigned __int8 *a2, unsigned char *a3)
{
  *a3 = 1;
  return *a2;
}

uint64_t _GetDataSize_16bitBigEndian(uint64_t a1, unsigned __int16 *a2, unsigned char *a3)
{
  *a3 = 2;
  return bswap32(*a2) >> 16;
}

uint64_t _GetDataSize_16bitLittleEndian(uint64_t a1, unsigned __int16 *a2, unsigned char *a3)
{
  *a3 = 2;
  return *a2;
}

uint64_t _GetDataSize_32bitBigEndian(uint64_t a1, unsigned int *a2, unsigned char *a3)
{
  *a3 = 4;
  return bswap32(*a2);
}

uint64_t _GetDataSize_32bitLittleEndian(uint64_t a1, unsigned int *a2, unsigned char *a3)
{
  *a3 = 4;
  return *a2;
}

unint64_t _GetDataSize_64bitBigEndian(uint64_t a1, unint64_t *a2, unsigned char *a3)
{
  *a3 = 8;
  return bswap64(*a2);
}

uint64_t _GetDataSize_64bitLittleEndian(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *a3 = 8;
  return *(void *)a2;
}

uint64_t _GetDataSize_Invalid(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *a3 = 0;
  return 0;
}

unsigned char *CreateSizeBytesEmbededData(const void *a1, size_t a2, unsigned int a3, int a4, size_t *a5)
{
  if (a3)
  {
    size_t v10 = a2 + a3;
    stat v11 = malloc_type_malloc(v10, 0x76EC069AuLL);
    memcpy(&v11[a3], a1, a2);
    *a5 = v10;
    EmbedSizeBytesToBuffer(v11, a2, a3, a4);
    return v11;
  }
  else
  {
    *a5 = a2;
  }
  return a1;
}

unsigned char *EmbedSizeBytesToBuffer(unsigned char *result, unint64_t a2, int a3, int a4)
{
  switch(a3)
  {
    case 1:
      *uint64_t result = a2;
      break;
    case 2:
      if (a4) {
        *(_WORD *)uint64_t result = bswap32(a2) >> 16;
      }
      else {
        *(_WORD *)uint64_t result = a2;
      }
      break;
    case 4:
      if (a4) {
        *(_DWORD *)uint64_t result = bswap32(a2);
      }
      else {
        *(_DWORD *)uint64_t result = a2;
      }
      break;
    case 8:
      if (a4) {
        *(void *)uint64_t result = bswap64(a2);
      }
      else {
        *(void *)uint64_t result = a2;
      }
      break;
    default:
      return result;
  }
  return result;
}

void AppendFieldDataToData(__CFData *a1, const __CFString *cf, int a3, int a4, int a5)
{
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 == CFNumberGetTypeID())
  {
    if (CFNumberIsFloatType((CFNumberRef)cf))
    {
      if (a3 == 8)
      {
        double valuePtr = 0.0;
        CFNumberGetValue((CFNumberRef)cf, kCFNumberFloat64Type, &valuePtr);
        unint64_t v23 = (unint64_t)valuePtr;
        unint64_t v24 = bswap64((unint64_t)valuePtr);
        if (a5) {
          unint64_t v23 = v24;
        }
        double valuePtr = (double)v23;
        uint64_t v13 = a1;
        CFIndex v14 = 8;
      }
      else
      {
        if (a3 != 4) {
          return;
        }
        LODWORD(valuePtr) = 0;
        CFNumberGetValue((CFNumberRef)cf, kCFNumberFloat32Type, &valuePtr);
        unsigned int v11 = *(float *)&valuePtr;
        unsigned int v12 = bswap32(*(float *)&valuePtr);
        if (a5) {
          unsigned int v11 = v12;
        }
        *(float *)&double valuePtr = (float)v11;
        uint64_t v13 = a1;
        CFIndex v14 = 4;
      }
      CFDataAppendBytes(v13, (const UInt8 *)&valuePtr, v14);
    }
    else
    {
      double valuePtr = 0.0;
      CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr);
      AppendNumberToData(a1, *(unint64_t *)&valuePtr, a3, a5);
    }
  }
  else
  {
    CFTypeID v15 = CFGetTypeID(cf);
    if (v15 == CFStringGetTypeID())
    {
      CFIndex Length = CFStringGetLength(cf);
      uint64_t v17 = 2 * Length;
      double valuePtr = 0.0;
      if (!a4) {
        AppendNumberToData(a1, v17, a3, a5);
      }
      if (a5) {
        CFStringEncoding v18 = 268435712;
      }
      else {
        CFStringEncoding v18 = 335544576;
      }
      uint64_t v19 = (UInt8 *)malloc_type_malloc(v17, 0x8F3C58B0uLL);
      v27.CFIndex location = 0;
      v27.int64_t length = Length;
      CFStringGetBytes(cf, v27, v18, 0, 0, v19, v17, (CFIndex *)&valuePtr);
      CFDataAppendBytes(a1, v19, *(CFIndex *)&valuePtr);
      free(v19);
    }
    else
    {
      CFTypeID v20 = CFGetTypeID(cf);
      if (v20 == CFDataGetTypeID())
      {
        CFIndex v21 = CFDataGetLength((CFDataRef)cf);
        if (!a4) {
          AppendNumberToData(a1, v21, a3, a5);
        }
        BytePtr = CFDataGetBytePtr((CFDataRef)cf);
        CFDataAppendBytes(a1, BytePtr, v21);
      }
    }
  }
}

void AppendNumberToData(__CFData *a1, unint64_t a2, int a3, int a4)
{
  switch(a3)
  {
    case 1:
      char v12 = a2;
      CFComparisonResult v4 = (const UInt8 *)&v12;
      CFIndex v5 = 1;
      goto LABEL_12;
    case 2:
      unsigned int v6 = bswap32(a2) >> 16;
      if (!a4) {
        LOWORD(v6) = a2;
      }
      __int16 v11 = v6;
      CFComparisonResult v4 = (const UInt8 *)&v11;
      CFIndex v5 = 2;
      goto LABEL_12;
    case 4:
      unsigned int v7 = bswap32(a2);
      if (!a4) {
        unsigned int v7 = a2;
      }
      unsigned int v10 = v7;
      CFComparisonResult v4 = (const UInt8 *)&v10;
      CFIndex v5 = 4;
      goto LABEL_12;
    case 8:
      unint64_t v8 = bswap64(a2);
      if (!a4) {
        unint64_t v8 = a2;
      }
      unint64_t v9 = v8;
      CFComparisonResult v4 = (const UInt8 *)&v9;
      CFIndex v5 = 8;
LABEL_12:
      CFDataAppendBytes(a1, v4, v5);
      break;
    default:
      return;
  }
}

void WriteLogFile(CFStringRef format, ...)
{
  va_start(va, format);
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFStringRef v1 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  if (v1)
  {
    CFStringRef v2 = v1;
    CFURLRef v3 = CFDateFormatterCreate(0, 0, kCFDateFormatterShortStyle, kCFDateFormatterMediumStyle);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(0, v3, Current);
    uint64_t v6 = getpid();
    CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"%@ [%d] %@\n", StringWithAbsoluteTime, v6, v2);
    CFRelease(v2);
    CFRelease(v3);
    CFRelease(StringWithAbsoluteTime);
    if (v7)
    {
      CFURLRef v8 = (const __CFURL *)CFCopyHomeDirectoryURLForUser();
      CFURLRef v9 = CFURLCreateCopyAppendingPathComponent(0, v8, @"Library/Logs/IndexedSearchLog.txt", 0);
      CFStringRef v10 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
      CFStringGetCString(v10, buffer, 512, 0x8000100u);
      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
      int v11 = open(buffer, 522, 438);
      if (v11 != -1)
      {
        int v12 = v11;
        CFStringGetCString(v7, buffer, 512, 0x8000100u);
        size_t v13 = strlen(buffer);
        write(v12, buffer, v13);
        close(v12);
      }
      CFRelease(v7);
    }
  }
}

void HeapAccessContext::HeapAccessContext(HeapAccessContext *this, IDXIndexInfo *a2)
{
  uint64_t v4 = IDXAccessContext::IDXAccessContext((uint64_t)this, (uint64_t)a2);
  *(void *)uint64_t v4 = &unk_1F2DE3880;
  *(void *)(v4 + 24) = 0;
  *((unsigned char *)this + 32) = IDXIndexInfo::fixedDataSize(*(IDXIndexInfo **)(v4 + 8)) != 0;
  *((unsigned char *)this + 33) = IDXIndexInfo::writable(*((IDXIndexInfo **)this + 1));
  *((unsigned char *)this + 34) = IDXIndexInfo::bigEndian(a2);
  unsigned __int8 v5 = IDXIndexInfo::dataSizeLength(a2);
  uint64_t v6 = IDXIndexInfo::fixedDataSize(a2);
  BOOL v7 = IDXIndexInfo::bigEndian(a2);
  DataSizeFunction = GetPreConfiguredGetDataSizeFunction(v5, v6, v7, (void *)this + 17);
  *((_WORD *)this + 18) = 0;
  *((void *)this + 16) = DataSizeFunction;
  CFDictionaryRef v9 = IDXIndexInfo::optionalProperty(a2, @"HeapDataCompressionType");
  if (v9) {
    CFNumberGetValue(v9, kCFNumberSInt16Type, (char *)this + 36);
  }
  int v10 = *((__int16 *)this + 18);
  *((unsigned char *)this + 35) = *((_WORD *)this + 18) != 0;
  *((unsigned char *)this + 38) = v10 > 3;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  if ((v10 & 0xFFFE) == 2)
  {
    *((void *)this + 11) = *((void *)this + 16);
    uint64_t v11 = IDXIndexInfo::dataSizeLength(a2);
    int v12 = GetPreConfiguredGetDataSizeFunction((v11 << (v11 < 4)), 0, *((unsigned __int8 *)this + 34), 0);
    uint64_t v13 = 0x2000;
    if (*((_WORD *)this + 18) == 2) {
      uint64_t v13 = 0x8000;
    }
    *((void *)this + 8) = v13;
    *((void *)this + 16) = v12;
    CFDictionaryRef v14 = IDXIndexInfo::optionalProperty(a2, @"HeapDataCompressionBlockSize");
    if (v14) {
      CFNumberGetValue(v14, kCFNumberCFIndexType, (char *)this + 64);
    }
    if (*((_WORD *)this + 18) == 2) {
      unint64_t v15 = 0xFFFFFFFFLL;
    }
    else {
      unint64_t v15 = 0xFFFFLL;
    }
    unint64_t valuePtr = v15;
    CFDictionaryRef v16 = IDXIndexInfo::optionalProperty(a2, @"HeapDataCompressionMaxBlockCount");
    if (v16)
    {
      CFNumberGetValue(v16, kCFNumberLongLongType, &valuePtr);
      unint64_t v15 = valuePtr;
    }
    if (*((_WORD *)this + 18) == 2) {
      uint64_t v17 = 64;
    }
    else {
      uint64_t v17 = 32;
    }
    uint64_t v18 = vcvtpd_s64_f64(log2((double)v15));
    uint64_t v19 = v17 - v18;
    *((void *)this + 12) = 0;
    unint64_t v20 = v18 - 1;
    if (v18 < 1)
    {
      uint64_t v30 = 0;
    }
    else
    {
      unint64_t v21 = (v18 + 1) & 0xFFFFFFFFFFFFFFFELL;
      int64x2_t v22 = (int64x2_t)xmmword_1D5944E30;
      uint64x2_t v23 = (uint64x2_t)vdupq_n_s64(v20);
      int8x16_t v24 = 0uLL;
      uint64x2_t v25 = (uint64x2_t)vdupq_n_s64(1uLL);
      int64x2_t v26 = vdupq_n_s64(2uLL);
      do
      {
        uint64x2_t v27 = (uint64x2_t)v22;
        int8x16_t v28 = v24;
        int8x16_t v24 = vorrq_s8(v24, (int8x16_t)vshlq_u64(v25, (uint64x2_t)v22));
        int64x2_t v22 = vaddq_s64(v22, v26);
        v21 -= 2;
      }
      while (v21);
      int8x16_t v29 = vbslq_s8((int8x16_t)vcgtq_u64(v27, v23), v28, v24);
      *(int8x8_t *)v29.i8 = vorr_s8(*(int8x8_t *)v29.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v29, v29, 8uLL));
      *((void *)this + 12) = v29.i64[0];
      uint64_t v30 = v29.i64[0];
    }
    *((void *)this + 14) = 0;
    if (v19 >= 1)
    {
      unint64_t v31 = (v19 + 1) & 0xFFFFFFFFFFFFFFFELL;
      int64x2_t v32 = (int64x2_t)xmmword_1D5944E30;
      uint64x2_t v33 = (uint64x2_t)vdupq_n_s64(v19 - 1);
      int8x16_t v34 = 0uLL;
      uint64x2_t v35 = (uint64x2_t)vdupq_n_s64(1uLL);
      int64x2_t v36 = vdupq_n_s64(2uLL);
      do
      {
        uint64x2_t v37 = (uint64x2_t)v32;
        int8x16_t v38 = v34;
        int8x16_t v34 = vorrq_s8(v34, (int8x16_t)vshlq_u64(v35, (uint64x2_t)v32));
        int64x2_t v32 = vaddq_s64(v32, v36);
        v31 -= 2;
      }
      while (v31);
      int8x16_t v39 = vbslq_s8((int8x16_t)vcgtq_u64(v37, v33), v38, v34);
      *((int8x8_t *)this + 14) = vorr_s8(*(int8x8_t *)v39.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL));
    }
    *((void *)this + 13) = v30 << v19;
    *((unsigned char *)this + 120) = v19;
  }
  *((unsigned char *)this + 121) = 0;
}

void sub_1D5920808(_Unwind_Exception *a1)
{
  IDXAccessContext::~IDXAccessContext(v1);
  _Unwind_Resume(a1);
}

void HeapAccessContext::~HeapAccessContext(HeapAccessContext *this)
{
  *(void *)this = &unk_1F2DE3880;
  CFStringRef v2 = (void *)*((void *)this + 6);
  if (v2) {
    free(v2);
  }

  IDXAccessContext::~IDXAccessContext(this);
}

{
  uint64_t vars8;

  HeapAccessContext::~HeapAccessContext(this);

  JUMPOUT(0x1D94553C0);
}

void sub_1D59208DC(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C409CAD4C71);
  _Unwind_Resume(a1);
}

uint64_t HeapAccessContext::getDataPtrByID(HeapAccessContext *this, unint64_t a2, uint64_t *a3)
{
  int v4 = *((unsigned __int16 *)this + 18);
  if ((v4 & 0xFFFE) == 2) {
    a2 = (*((void *)this + 13) & a2) >> *((unsigned char *)this + 120);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v4 != 3 && *((unsigned char *)this + 32) == 0)
  {
    CFURLRef v8 = (_DWORD *)(*(void *)(v5 + 16) + a2);
    if (!*v8)
    {
      uint64_t v10 = 0;
      uint64_t v9 = 0;
      if (!a3) {
        return v10;
      }
      goto LABEL_11;
    }
    uint64_t v7 = (uint64_t)(v8 + 1);
  }
  else
  {
    uint64_t v7 = *(void *)(v5 + 16) + (a2 - 1) * *(unsigned int *)(v5 + 36) + 8;
  }
  unsigned __int8 v12 = 0;
  uint64_t v9 = (*((uint64_t (**)(void, uint64_t, unsigned __int8 *))this + 16))(*((void *)this + 17), v7, &v12);
  uint64_t v10 = v7 + v12;
  if (a3) {
LABEL_11:
  }
    *a3 = v9;
  return v10;
}

uint64_t HeapAccessContext::getDataByID(HeapAccessContext *this, uint64_t a2, int64_t a3, unsigned __int8 *a4)
{
  unsigned int v6 = a2;
  uLong sourceLen = 0;
  uint64_t v8 = (*(uint64_t (**)(HeapAccessContext *, uint64_t, uLong *))(*(void *)this + 48))(this, a2, &sourceLen);
  unsigned __int8 v19 = 0;
  if (!v8) {
    return 0;
  }
  uint64_t v9 = (Bytef *)v8;
  if (*((unsigned char *)this + 121) || *((unsigned char *)this + 35))
  {
    int64_t v10 = (*((uint64_t (**)(void, uint64_t, unsigned __int8 *))this + 16))(0, v8, &v19);
    int64_t v11 = sourceLen - v19;
    uLong sourceLen = v11;
    v9 += v19;
  }
  else
  {
    int64_t v11 = sourceLen;
    int64_t v10 = sourceLen;
  }
  int v12 = *((unsigned __int16 *)this + 18);
  if ((v12 & 0xFFFE) == 2)
  {
    if (v10 > *((void *)this + 7))
    {
      uint64_t v13 = (void *)*((void *)this + 6);
      if (v13) {
        free(v13);
      }
      *((void *)this + 6) = malloc_type_malloc(v10, 0x80ED710CuLL);
      *((void *)this + 7) = v10;
    }
    if (v9 != *((Bytef **)this + 9))
    {
      uLongf destLen = v10;
      uncompress(*((Bytef **)this + 6), &destLen, v9, sourceLen);
      *((void *)this + 9) = v9;
    }
    uint64_t v14 = *((void *)this + 6) + (v6 & *((_DWORD *)this + 28));
    uLong v15 = (*((uint64_t (**)(void, uint64_t, unsigned __int8 *))this + 11))(0, v14, &v19);
    uLong sourceLen = v15;
    uint64_t v9 = (Bytef *)(v14 + v19);
    if (*((unsigned char *)this + 121))
    {
      int64_t v10 = (*((uint64_t (**)(void, Bytef *, unsigned __int8 *))this + 11))(0, v9, &v19);
      int64_t v11 = sourceLen - v19;
      uLong sourceLen = v11;
      v9 += v19;
    }
    else
    {
      int64_t v11 = v15;
      int64_t v10 = v15;
    }
    int v12 = *((unsigned __int16 *)this + 18);
  }
  if (v12 == 1)
  {
    if (v10 <= a3)
    {
      uLongf destLen = a3;
      uncompress(a4, &destLen, v9, v11);
    }
  }
  else if (a4)
  {
    if (v10 <= a3 && v11 <= a3) {
      memcpy(a4, v9, v11);
    }
  }
  if (*((unsigned char *)this + 121) && v10 <= a3) {
    free(v9);
  }
  if (!a4) {
    goto LABEL_35;
  }
  if (v10 > a3)
  {
    if (v10 < 268435457) {
      return v10;
    }
    goto LABEL_35;
  }
  if ((uint64_t)sourceLen > a3 || v10 > 0x10000000)
  {
LABEL_35:
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      HeapAccessContext::getDataByID((uint64_t *)&sourceLen, v10, a3);
    }
    return 0;
  }
  return v10;
}

BOOL HeapAccessContext::addRecord(HeapAccessContext *this, const unsigned __int16 *a2, uint64_t a3, unsigned __int8 *a4, size_t a5, unint64_t *a6)
{
  size_t __len = a5;
  if (!*((unsigned char *)this + 33)) {
    return 0;
  }
  uint64_t v71 = 0;
  unsigned __int8 v70 = 0;
  (*((void (**)(void, uint64_t *, unsigned __int8 *))this + 16))(*((void *)this + 17), &v71, &v70);
  if ((*((_WORD *)this + 18) & 0xFFFE) != 2)
  {
    if (*((unsigned char *)this + 35))
    {
      CompressedCFDataRef Data = HeapAccessContext::createCompressedData(this, a4, __len, v70, *((unsigned __int8 *)this + 121), (uint64_t *)&__len);
    }
    else
    {
      if (*((unsigned char *)this + 121))
      {
        uint64_t v18 = 0;
LABEL_29:
        uint64_t v30 = *((void *)this + 3);
        int v31 = __len;
        if (!*((unsigned char *)this + 32))
        {
          unint64_t v20 = vsheap_add_record(*((void *)this + 3), v18, __len);
          goto LABEL_93;
        }
        uint64_t v32 = *(unsigned int *)(v30 + 36);
        if (__len)
        {
          if (v32)
          {
            if (__len != v32) {
              goto LABEL_57;
            }
          }
          else
          {
            *(_DWORD *)(v30 + 36) = __len;
            LODWORD(v32) = v31;
          }
        }
        else if (!v32)
        {
          goto LABEL_57;
        }
        CFArrayRef v41 = *(_DWORD **)(v30 + 16);
        if (v41)
        {
          unint64_t v42 = *(void *)(v30 + 24);
          if (v42 >= (*(_DWORD *)(v30 + 32) + v32)) {
            goto LABEL_54;
          }
          unint64_t v43 = v42 + (v32 << 10);
        }
        else
        {
          unint64_t v43 = (v32 << 10) | 8u;
        }
        CFArrayRef v41 = (_DWORD *)(*(uint64_t (**)(void))v30)();
        if (!v41)
        {
LABEL_57:
          unint64_t v20 = 0;
          goto LABEL_93;
        }
        *(void *)(v30 + 16) = v41;
        *(void *)(v30 + 24) = v43;
LABEL_54:
        unsigned int v44 = *(_DWORD *)(v30 + 32);
        if (!v44)
        {
          *(_DWORD *)(v30 + 32) = 8;
          *CFArrayRef v41 = 8;
          v41[1] = *(_DWORD *)(v30 + 36);
          unsigned int v44 = *(_DWORD *)(v30 + 32);
        }
        uint64_t v45 = *(void *)(v30 + 40);
        memcpy((char *)v41 + v44, v18, *(unsigned int *)(v30 + 36));
        int v46 = *(_DWORD *)(v30 + 32) + *(_DWORD *)(v30 + 36);
        *(_DWORD *)(v30 + 32) = v46;
        **(_DWORD **)(v30 + 16) = v46;
        ++*(void *)(v30 + 40);
        unint64_t v20 = v45 + 1;
        goto LABEL_93;
      }
      CompressedCFDataRef Data = CreateSizeBytesEmbededData(a4, __len, v70, *((unsigned __int8 *)this + 34), &__len);
    }
    uint64_t v18 = CompressedData;
    goto LABEL_29;
  }
  unsigned __int8 v69 = 0;
  (*((void (**)(void, uint64_t *, unsigned __int8 *))this + 11))(0, &v71, &v69);
  int64_t v10 = 0;
  if (!*((unsigned char *)this + 121)) {
    int64_t v10 = CreateSizeBytesEmbededData(a4, __len, v69, *((unsigned __int8 *)this + 34), &__len);
  }
  uint64_t v11 = *((void *)this + 10);
  if (!v11) {
    goto LABEL_10;
  }
  uLong v68 = 0;
  uint64_t v12 = (*(uint64_t (**)(HeapAccessContext *, uint64_t, uLong *))(*(void *)this + 48))(this, v11, &v68);
  unint64_t v13 = (*((uint64_t (**)(void, uint64_t, unsigned __int8 *))this + 16))(0, v12, &v70);
  v68 -= v70;
  if (v13 >= *((void *)this + 14)) {
    goto LABEL_10;
  }
  unint64_t v14 = v13;
  uLong v15 = (const Bytef *)(v12 + v70);
  uLong sourceLen = __len + v13;
  CFDictionaryRef v16 = (Bytef *)malloc_type_malloc(__len + v13, 0xDBAACB80uLL);
  uLongf destLen = sourceLen;
  uncompress(v16, &destLen, v15, v68);
  memmove(&v16[v14], v10, __len);
  uint64_t v17 = HeapAccessContext::createCompressedData(this, v16, sourceLen, v70, 0, (uint64_t *)&sourceLen);
  uint64_t v18 = v17;
  if (*((_WORD *)this + 18) != 2 && (int64_t)sourceLen > *((void *)this + 8))
  {
    free(v17);
    free(v16);
LABEL_10:
    uint64_t v18 = HeapAccessContext::createCompressedData(this, v10, __len, v70, 0, (uint64_t *)&__len);
    if (v10 != a4) {
      free(v10);
    }
    unint64_t v14 = 0;
    goto LABEL_13;
  }
  if (v10 != a4) {
    free(v10);
  }
  size_t __len = sourceLen;
  free(v16);
  uint64_t v33 = *((void *)this + 3);
  unint64_t v34 = *((void *)this + 10) >> *((unsigned char *)this + 120);
  if (*((_WORD *)this + 18) == 2)
  {
    unint64_t v35 = *(unsigned int *)(v33 + 36);
    if (v34 < v35)
    {
      int64x2_t v36 = *(_DWORD **)(v33 + 16);
      uint64x2_t v37 = (_DWORD *)((char *)v36 + v34);
      uint64_t v38 = *(unsigned int *)((char *)v36 + v34);
      if (v38)
      {
        if (v34 + v38 + 4 == v35)
        {
          int v39 = v35 - v38 - 4;
          *(_DWORD *)(v33 + 36) = v39;
          *int64x2_t v36 = v39;
          if (*(int *)(v33 + 32) >= 1)
          {
            int v40 = *(_DWORD *)(v33 + 48) - 1;
            *(_DWORD *)(v33 + 48) = v40;
            v36[5] = v40;
          }
        }
        else
        {
          *uint64x2_t v37 = 0;
          if (v38 >= 4 && *(int *)(v33 + 32) >= 1)
          {
            v37[1] = v38;
            if (v38 >= 0x20 && v34 > *(unsigned int *)(v33 + 40))
            {
              unint64_t v65 = *(unsigned int *)(v33 + 44);
              if (!v65 || v34 < v65)
              {
                *(_DWORD *)(v33 + 44) = v34;
                v36[4] = v34;
              }
            }
          }
        }
      }
    }
  }
  else if (*(void *)(v33 + 40) == v34)
  {
    *(void *)(v33 + 40) = v34 - 1;
    int v64 = *(_DWORD *)(v33 + 32) - *(_DWORD *)(v33 + 36);
    *(_DWORD *)(v33 + 32) = v64;
    **(_DWORD **)(v33 + 16) = v64;
  }
LABEL_13:
  if (*((_WORD *)this + 18) == 2)
  {
    unint64_t v19 = vsheap_add_record(*((void *)this + 3), v18, __len) << *((unsigned char *)this + 120);
    unint64_t v20 = v19 + v14;
    if ((int64_t)__len >= *((void *)this + 8)) {
      unint64_t v19 = 0;
    }
    *((void *)this + 10) = v19;
    goto LABEL_93;
  }
  uint64_t v23 = *((void *)this + 8);
  uint64_t v24 = (uint64_t)__len / v23;
  if ((uint64_t)__len % v23) {
    ++v24;
  }
  uint64_t v25 = v24 * v23;
  int64x2_t v26 = (char *)malloc_type_calloc(1uLL, v24 * v23, 0x431B8ADAuLL);
  memmove(v26, v18, __len);
  free(v18);
  uint64_t v27 = *((void *)this + 3);
  uint64_t v28 = *((void *)this + 8);
  uint64_t v29 = *(unsigned int *)(v27 + 36);
  if (v28)
  {
    if (v29)
    {
      if (v28 != v29) {
        goto LABEL_72;
      }
    }
    else
    {
      *(_DWORD *)(v27 + 36) = v28;
      LODWORD(v29) = v28;
    }
  }
  else if (!v29)
  {
    goto LABEL_72;
  }
  CFStringRef v47 = *(_DWORD **)(v27 + 16);
  if (v47)
  {
    unint64_t v48 = *(void *)(v27 + 24);
    if (v48 >= (*(_DWORD *)(v27 + 32) + v29)) {
      goto LABEL_66;
    }
    unint64_t v49 = v48 + (v29 << 10);
  }
  else
  {
    unint64_t v49 = (v29 << 10) | 8u;
  }
  CFStringRef v47 = (_DWORD *)(*(uint64_t (**)(void))v27)();
  if (!v47)
  {
LABEL_72:
    unint64_t v20 = 0;
    uint64_t v25 = 0;
    *((void *)this + 10) = 0;
    goto LABEL_73;
  }
  *(void *)(v27 + 16) = v47;
  *(void *)(v27 + 24) = v49;
LABEL_66:
  unsigned int v50 = *(_DWORD *)(v27 + 32);
  if (!v50)
  {
    *(_DWORD *)(v27 + 32) = 8;
    *CFStringRef v47 = 8;
    v47[1] = *(_DWORD *)(v27 + 36);
    unsigned int v50 = *(_DWORD *)(v27 + 32);
  }
  unint64_t v51 = *(void *)(v27 + 40);
  memcpy((char *)v47 + v50, v26, *(unsigned int *)(v27 + 36));
  int v52 = *(_DWORD *)(v27 + 32) + *(_DWORD *)(v27 + 36);
  *(_DWORD *)(v27 + 32) = v52;
  **(_DWORD **)(v27 + 16) = v52;
  ++*(void *)(v27 + 40);
  *((void *)this + 10) = v51 + 1;
  if (v51 >= *((void *)this + 12))
  {
    if (v51 != -1) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Failed to add a new data since record count exceeds limit (%lld) defined in the current compaction-type.\n", *((void *)this + 12));
    }
    goto LABEL_72;
  }
  uint64_t v53 = (v51 + 1) << *((unsigned char *)this + 120);
  *((void *)this + 10) = v53;
  unint64_t v20 = v53 + v14;
LABEL_73:
  uint64_t v54 = *((void *)this + 8);
  uint64_t v55 = v25 - v54;
  if (v25 != v54)
  {
    CFArrayRef v56 = v26;
    do
    {
      v56 += v54;
      uint64_t v57 = *((void *)this + 3);
      uint64_t v58 = *(unsigned int *)(v57 + 36);
      if (v54)
      {
        if (v58)
        {
          if (v54 != v58) {
            goto LABEL_91;
          }
        }
        else
        {
          *(_DWORD *)(v57 + 36) = v54;
          LODWORD(v58) = v54;
        }
      }
      else if (!v58)
      {
        goto LABEL_91;
      }
      CFStringRef v59 = *(_DWORD **)(v57 + 16);
      if (v59)
      {
        unint64_t v60 = *(void *)(v57 + 24);
        if (v60 >= (*(_DWORD *)(v57 + 32) + v58)) {
          goto LABEL_88;
        }
        unint64_t v61 = v60 + (v58 << 10);
      }
      else
      {
        unint64_t v61 = (v58 << 10) | 8u;
      }
      CFStringRef v59 = (_DWORD *)(*(uint64_t (**)(void))v57)();
      if (v59)
      {
        *(void *)(v57 + 16) = v59;
        *(void *)(v57 + 24) = v61;
LABEL_88:
        uint64_t v62 = *(unsigned int *)(v57 + 32);
        if (!v62)
        {
          *(_DWORD *)(v57 + 32) = 8;
          *CFStringRef v59 = 8;
          v59[1] = *(_DWORD *)(v57 + 36);
          uint64_t v62 = *(unsigned int *)(v57 + 32);
        }
        memcpy((char *)v59 + v62, v56, *(unsigned int *)(v57 + 36));
        int v63 = *(_DWORD *)(v57 + 32) + *(_DWORD *)(v57 + 36);
        *(_DWORD *)(v57 + 32) = v63;
        **(_DWORD **)(v57 + 16) = v63;
        ++*(void *)(v57 + 40);
      }
LABEL_91:
      *((void *)this + 10) = 0;
      uint64_t v54 = *((void *)this + 8);
      v55 -= v54;
    }
    while (v55);
  }
  uint64_t v18 = (Bytef *)v26;
LABEL_93:
  if (*((unsigned char *)this + 35) || *((unsigned char *)this + 121) || __len != a5) {
    free(v18);
  }
  if (a6) {
    *a6 = v20;
  }
  return v20 != 0;
}

Bytef *HeapAccessContext::createCompressedData(HeapAccessContext *this, const unsigned __int8 *a2, uLong sourceLen, unsigned int a4, int a5, uint64_t *a6)
{
  size_t v12 = 2 * a4;
  uint64_t v13 = a4;
  uLongf destLen = compressBound(sourceLen) + v12;
  unint64_t v14 = (Bytef *)malloc_type_malloc(destLen, 0xCD8A67E8uLL);
  compress2(&v14[2 * a4], &destLen, a2, sourceLen, 9);
  if (a5)
  {
    uLong v15 = (Bytef *)malloc_type_malloc(v12, 0x7AAD00AFuLL);
    free(v14);
    uLongf destLen = 0;
    unint64_t v14 = v15;
  }
  EmbedSizeBytesToBuffer(&v14[v13], sourceLen, a4, *((unsigned __int8 *)this + 34));
  EmbedSizeBytesToBuffer(v14, destLen + v13, a4, *((unsigned __int8 *)this + 34));
  if (a6) {
    *a6 = destLen + v12;
  }
  return v14;
}

unint64_t vsheap_add_record(uint64_t a1, void *__src, size_t __n)
{
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6)
  {
    size_t v7 = *(void *)(a1 + 24);
    if (__n + 4 + *(unsigned int *)(a1 + 36) <= v7) {
      goto LABEL_11;
    }
    size_t v8 = (__n + 4) << 10;
    if (v8 >= __n + 262148) {
      size_t v8 = __n + 262148;
    }
    size_t v9 = v7 + v8;
  }
  else
  {
    size_t v10 = (__n << 10) + 4096;
    if (v10 >= __n + 262148) {
      size_t v10 = __n + 262148;
    }
    size_t v9 = v10 + 32;
  }
  uint64_t v6 = (*(uint64_t (**)(void))a1)();
  if (!v6) {
    return 0;
  }
  *(void *)(a1 + 16) = v6;
  *(void *)(a1 + 24) = v9;
LABEL_11:
  if (*(_DWORD *)(a1 + 36))
  {
    unsigned int v11 = *(_DWORD *)(a1 + 44);
    if (v11)
    {
      unsigned int v12 = *(_DWORD *)(a1 + 40);
      if (v11 < v12)
      {
        *(_DWORD *)(a1 + 44) = v12;
        unsigned int v11 = v12;
      }
      unint64_t v13 = *(unsigned int *)(a1 + 36);
      if (v11 < v13)
      {
        int v14 = 0;
        size_t v15 = __n + 4;
        unint64_t v16 = v11;
        while (1)
        {
          uint64_t v17 = *(void *)(a1 + 16);
          uint64_t v18 = (_DWORD *)(v17 + v16);
          unsigned int v19 = *(_DWORD *)(v17 + v16);
          if (!v19)
          {
            size_t v20 = v18[1];
            unsigned int v19 = v18[1];
            unint64_t v21 = (_DWORD *)((char *)v18 + v20 + 4);
            unint64_t v22 = v17 + v13;
            if ((unint64_t)v21 >= v22)
            {
              int v23 = 0;
            }
            else
            {
              int v23 = 0;
              do
              {
                if (*v21) {
                  break;
                }
                unsigned int v24 = v21[1];
                unint64_t v21 = (_DWORD *)((char *)v21 + v24 + 4);
                v19 += v24 + 4;
                ++v23;
              }
              while ((unint64_t)v21 < v22);
              size_t v20 = v19;
            }
            if (v20 != __n && __n + 8 >= v20)
            {
              unint64_t v27 = 0;
              if (v14) {
                goto LABEL_37;
              }
            }
            else
            {
              *(_DWORD *)(a1 + 48) -= v23;
              _DWORD *v18 = __n;
              memcpy(v18 + 1, __src, __n);
              if (v20 > __n)
              {
                int64x2_t v26 = (_DWORD *)((char *)v18 + v15);
                v19 -= v15;
                _DWORD *v26 = 0;
                v26[1] = v19;
                ++*(_DWORD *)(a1 + 48);
              }
              unint64_t v27 = v16;
              if (v14) {
                goto LABEL_37;
              }
            }
            if (v19 > 0x1F || v27)
            {
              *(_DWORD *)(a1 + 44) = v16;
LABEL_37:
              if (v27)
              {
                uint64_t v30 = *(_DWORD **)(a1 + 16);
                v30[4] = *(_DWORD *)(a1 + 44);
                goto LABEL_46;
              }
              int v14 = 1;
              goto LABEL_39;
            }
            int v14 = 0;
          }
LABEL_39:
          v16 += v19 + 4;
          unint64_t v13 = *(unsigned int *)(a1 + 36);
          if (v16 >= v13)
          {
            if (!v14) {
              break;
            }
            uint64_t v6 = *(void *)(a1 + 16);
            *(_DWORD *)(v6 + 16) = *(_DWORD *)(a1 + 44);
            goto LABEL_45;
          }
        }
      }
      *(_DWORD *)(a1 + 44) = 0;
      uint64_t v6 = *(void *)(a1 + 16);
      *(_DWORD *)(v6 + 16) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 32) = 0x2000000001;
    *(_DWORD *)(a1 + 40) = 32;
    *(void *)uint64_t v6 = 32;
    *(_DWORD *)(v6 + 8) = -*(_DWORD *)(a1 + 32);
    *(_DWORD *)(v6 + 12) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(v6 + 16) = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(v6 + 20) = *(_DWORD *)(a1 + 48);
    *(void *)(v6 + 24) = -1;
  }
LABEL_45:
  unint64_t v27 = *(unsigned int *)(a1 + 36);
  ++*(_DWORD *)(a1 + 48);
  *(_DWORD *)(v6 + v27) = __n;
  uint64_t v28 = (*(_DWORD *)(a1 + 36) + 4);
  *(_DWORD *)(a1 + 36) = v28;
  memcpy((void *)(*(void *)(a1 + 16) + v28), __src, __n);
  int v29 = *(_DWORD *)(a1 + 36) + __n;
  *(_DWORD *)(a1 + 36) = v29;
  uint64_t v30 = *(_DWORD **)(a1 + 16);
  *uint64_t v30 = v29;
LABEL_46:
  if (*(int *)(a1 + 32) >= 1)
  {
    unsigned int v31 = *(_DWORD *)(a1 + 48);
    if (v31 >= 0x1389)
    {
      unsigned int v32 = *(_DWORD *)(a1 + 40);
      uint64_t v33 = 500;
      do
      {
        unint64_t v34 = (_DWORD *)((char *)v30 + v32);
        int v35 = *v34;
        if (!*v34) {
          int v35 = v34[1];
        }
        v32 += v35 + 4;
        *(_DWORD *)(a1 + 40) = v32;
        --v33;
      }
      while (v33);
      v30[3] = v32;
      unsigned int v31 = 4501;
      *(_DWORD *)(a1 + 48) = 4501;
    }
    v30[5] = v31;
  }
  return v27;
}

uint64_t HeapAccessContext::deleteRecord(HeapAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, uint64_t a5, unint64_t a6)
{
  if (*((unsigned char *)this + 33) && (*((_WORD *)this + 18) & 0xFFFE) != 2)
  {
    uint64_t v6 = *((void *)this + 3);
    if (*((unsigned char *)this + 32))
    {
      unint64_t v7 = *(void *)(v6 + 40);
      if (v7 >= a6)
      {
        if (v7 == a6)
        {
          *(void *)(v6 + 40) = a6 - 1;
          int v8 = *(_DWORD *)(v6 + 32) - *(_DWORD *)(v6 + 36);
          *(_DWORD *)(v6 + 32) = v8;
          **(_DWORD **)(v6 + 16) = v8;
        }
        return 1;
      }
    }
    else
    {
      unint64_t v10 = *(unsigned int *)(v6 + 36);
      if (v10 > a6)
      {
        unsigned int v11 = *(_DWORD **)(v6 + 16);
        unsigned int v12 = (_DWORD *)((char *)v11 + a6);
        uint64_t v13 = *(unsigned int *)((char *)v11 + a6);
        if (v13)
        {
          if (a6 + v13 + 4 == v10)
          {
            int v14 = v10 - v13 - 4;
            *(_DWORD *)(v6 + 36) = v14;
            _DWORD *v11 = v14;
            if (*(int *)(v6 + 32) >= 1)
            {
              int v15 = *(_DWORD *)(v6 + 48) - 1;
              *(_DWORD *)(v6 + 48) = v15;
              v11[5] = v15;
            }
          }
          else
          {
            *unsigned int v12 = 0;
            if (v13 >= 4 && *(_DWORD *)(v6 + 32) >= 1)
            {
              v12[1] = v13;
              if (v13 >= 0x20 && *(unsigned int *)(v6 + 40) < a6)
              {
                unint64_t v18 = *(unsigned int *)(v6 + 44);
                if (!v18 || v18 > a6)
                {
                  *(_DWORD *)(v6 + 44) = a6;
                  v11[4] = a6;
                }
              }
            }
          }
          return 1;
        }
      }
    }
  }
  return 0;
}

BOOL HeapAccessContext::buildWithRecords(HeapAccessContext *this, const __CFArray *a2, CFArrayRef theArray, unint64_t *a4)
{
  CFArrayRef v5 = theArray;
  CFIndex Count = CFArrayGetCount(theArray);
  int v8 = (void **)malloc_type_malloc(8 * Count, 0x10040436913F5uLL);
  size_t v9 = malloc_type_malloc(8 * Count, 0x100004000313F17uLL);
  if (!*((unsigned char *)this + 33)) {
    return 0;
  }
  unint64_t v10 = v9;
  CFRange v112 = v8;
  if (!*((unsigned char *)this + 32))
  {
    CFIndex v109 = v9;
    CFIndex v110 = (size_t *)malloc_type_malloc(8 * Count, 0x100004000313F17uLL);
    uint64_t v121 = 0;
    uint64_t v120 = 0;
    unsigned __int8 v119 = 0;
    (*((void (**)(void, uint64_t *, unsigned __int8 *))this + 16))(*((void *)this + 17), &v120, &v119);
    if ((*((_WORD *)this + 18) & 0xFFFE) != 2)
    {
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v5, i);
          CFDataRef v63 = ValueAtIndex;
          if (*((unsigned char *)this + 35))
          {
            BytePtr = CFDataGetBytePtr(ValueAtIndex);
            uLong Length = CFDataGetLength(v63);
            SizeBytesEmbededCFDataRef Data = HeapAccessContext::createCompressedData(this, BytePtr, Length, v119, *((unsigned __int8 *)this + 121), &v121);
          }
          else
          {
            int v67 = *((unsigned __int8 *)this + 121);
            uLong v68 = CFDataGetBytePtr(ValueAtIndex);
            size_t v69 = CFDataGetLength(v63);
            if (v67) {
              SizeBytesEmbededCFDataRef Data = 0;
            }
            else {
              SizeBytesEmbededCFDataRef Data = CreateSizeBytesEmbededData(v68, v69, v119, *((unsigned __int8 *)this + 34), (size_t *)&v121);
            }
            int v8 = v112;
          }
          v8[i] = SizeBytesEmbededData;
          v110[i] = v121;
        }
      }
      if (!Count)
      {
        LODWORD(v29) = 0;
        int v30 = 0;
        unint64_t v10 = v109;
        goto LABEL_126;
      }
      uint64_t v70 = *((void *)this + 3);
      unint64_t v10 = v109;
      uint64_t v71 = v110;
      CFStringRef v72 = v109;
      CFIndex v73 = Count;
      while (1)
      {
        size_t v74 = *v71++;
        unint64_t v75 = vsheap_add_record(v70, *v8, v74);
        *CFStringRef v72 = v75;
        if (!v75) {
          break;
        }
        ++v72;
        ++v8;
        if (!--v73)
        {
          LODWORD(v29) = 0;
LABEL_91:
          if (Count >= 1)
          {
            CFMutableArrayRef v86 = v112;
            CFIndex v87 = Count;
            do
            {
              int v88 = *v86++;
              free(v88);
              --v87;
            }
            while (v87);
          }
          int v30 = 0;
          goto LABEL_126;
        }
      }
      LODWORD(v29) = -1;
      goto LABEL_91;
    }
    CFMutableDataRef Mutable = CFDataCreateMutable(0, 0);
    uint64_t v118 = 0;
    unsigned __int8 v117 = 0;
    (*((void (**)(void, uint64_t *, unsigned __int8 *))this + 11))(0, &v120, &v117);
    CFIndex v114 = Count - 1;
    if (Count < 1)
    {
      CFRelease(Mutable);
      if (*((_WORD *)this + 18) != 2) {
        *(_DWORD *)(*((void *)this + 3) + 36) = *((void *)this + 8);
      }
      LODWORD(v29) = 0;
      int v76 = a4 == 0;
      unint64_t v10 = v109;
      goto LABEL_125;
    }
    CFIndex v115 = Count;
    CFRange v116 = a4;
    uint64_t v33 = 0;
    uint64_t v113 = 0;
    CFIndex v34 = 0;
    do
    {
      int v35 = 0;
      CFIndex v111 = v34;
      CFIndex v36 = v34;
      while (1)
      {
        CFArrayRef v37 = v5;
        CFDataRef v38 = (const __CFData *)CFArrayGetValueAtIndex(v5, v36);
        int v39 = *((unsigned __int8 *)this + 121);
        int v40 = CFDataGetBytePtr(v38);
        size_t v41 = CFDataGetLength(v38);
        if (v39) {
          unint64_t v42 = 0;
        }
        else {
          unint64_t v42 = CreateSizeBytesEmbededData(v40, v41, v117, *((unsigned __int8 *)this + 34), (size_t *)&v121);
        }
        if (v116)
        {
          uint64_t v43 = v113 << *((unsigned char *)this + 120);
          v116[v36] = v43 + CFDataGetLength(Mutable);
        }
        CFDataAppendBytes(Mutable, v42, v121);
        if (CFDataGetBytePtr(v38) != v42) {
          free(v42);
        }
        unsigned int v44 = CFDataGetBytePtr(Mutable);
        uLong v45 = CFDataGetLength(Mutable);
        int v46 = HeapAccessContext::createCompressedData(this, v44, v45, v119, 0, &v118);
        CFStringRef v47 = v46;
        uint64_t v48 = v118;
        uint64_t v49 = *((void *)this + 8);
        CFArrayRef v5 = v37;
        if (v118 > v49 || v114 == v36) {
          break;
        }
        uint64_t v33 = v118;
        if (v35)
        {
          free(v35);
          uint64_t v33 = v118;
        }
        ++v36;
        int v35 = v47;
        CFIndex Count = v115;
        if (v36 >= v115)
        {
          int v50 = 0;
          CFIndex v34 = v111;
          goto LABEL_61;
        }
      }
      if (*((_WORD *)this + 18) == 2 || v118 <= v49 || !v35)
      {
        if (v35)
        {
          free(v35);
          uint64_t v48 = v118;
        }
        CFIndex v34 = v36 + 1;
        uint64_t v33 = v48;
        int v35 = v47;
      }
      else
      {
        free(v46);
        CFIndex v34 = v36;
      }
      uint64_t v51 = v113;
      if (*((_WORD *)this + 18) == 2)
      {
        int v50 = 0;
        v112[v113] = v47;
        v110[v113++] = v118;
      }
      else
      {
        if (v33 < 1)
        {
          int v50 = 0;
        }
        else
        {
          int64_t v52 = *((void *)this + 8);
          uint64_t v53 = v35;
          while (1)
          {
            uint64_t v54 = v51;
            uint64_t v55 = malloc_type_calloc(1uLL, v52, 0x38C337FCuLL);
            CFArrayRef v56 = v55;
            size_t v57 = v33 >= *((void *)this + 8) ? *((void *)this + 8) : v33;
            memmove(v55, v53, v57);
            uint64_t v51 = v54 + 1;
            v112[v54] = v56;
            unint64_t v58 = *((void *)this + 12);
            if (v54 + 1 > v58) {
              break;
            }
            int64_t v52 = *((void *)this + 8);
            v53 += v52;
            BOOL v59 = v33 <= v52;
            v33 -= v52;
            if (v59)
            {
              int v50 = 0;
              uint64_t v113 = v54 + 1;
              goto LABEL_59;
            }
          }
          uint64_t v113 = v54 + 1;
          fprintf((FILE *)*MEMORY[0x1E4F143C8], "Record count exceeds limit (%lld).\n", v58);
          int v50 = 1;
        }
LABEL_59:
        free(v35);
      }
      CFIndex Count = v115;
      CFDataSetLength(Mutable, 0);
LABEL_61:
      ;
    }
    while (v34 < Count && !v50);
    CFRelease(Mutable);
    if (v50)
    {
      BOOL v60 = 0;
      LODWORD(v29) = -1;
LABEL_115:
      a4 = v116;
      unint64_t v10 = v109;
      uint64_t v78 = v113;
      goto LABEL_116;
    }
    uint64_t v77 = *((void *)this + 3);
    CFComparisonResult v79 = (const void **)v112;
    uint64_t v78 = v113;
    unint64_t v10 = v109;
    if (*((_WORD *)this + 18) == 2)
    {
      if (v113)
      {
        CFComparisonResult v80 = v112;
        CFDictionaryRef v81 = v109;
        CFStringRef v82 = v110;
        uint64_t v83 = v113;
        while (1)
        {
          size_t v84 = *v82++;
          unint64_t v85 = vsheap_add_record(v77, *v80, v84);
          *CFDictionaryRef v81 = v85;
          BOOL v60 = v85 != 0;
          if (!v85) {
            break;
          }
          ++v81;
          ++v80;
          if (!--v83)
          {
            LODWORD(v29) = 0;
            goto LABEL_114;
          }
        }
        LODWORD(v29) = -1;
LABEL_114:
        CFIndex Count = v115;
        goto LABEL_115;
      }
LABEL_112:
      LODWORD(v29) = 0;
      int v50 = 0;
      BOOL v60 = 1;
      a4 = v116;
      goto LABEL_119;
    }
    *(_DWORD *)(v77 + 36) = *((void *)this + 8);
    if (!v113) {
      goto LABEL_112;
    }
    CFStringRef v89 = v109;
    uint64_t v29 = v113;
    while (1)
    {
      int v90 = *(_DWORD *)(v77 + 36);
      if (v90) {
        break;
      }
      uint64_t v96 = 0;
LABEL_110:
      *v89++ = v96;
      ++v79;
      if (!--v29)
      {
        BOOL v60 = 1;
        CFIndex Count = v115;
        a4 = v116;
LABEL_116:
        if (v78 >= 1)
        {
          CFRange v99 = v112;
          do
          {
            uint64_t v100 = v78;
            CFRange v101 = *v99++;
            free(v101);
            uint64_t v78 = v100 - 1;
          }
          while (v100 != 1);
        }
LABEL_119:
        int v102 = !v60;
        if (!a4) {
          int v102 = 1;
        }
        int v76 = v50 | v102;
        if ((v76 & 1) == 0)
        {
          char v103 = *((unsigned char *)this + 120);
          CFRange v104 = a4;
          CFIndex v105 = Count;
          do
          {
            *CFRange v104 = (*((void *)this + 14) & *v104)
                  + (v10[((*((void *)this + 13) & *v104) >> v103)] << v103);
            ++v104;
            --v105;
          }
          while (v105);
          int v76 = 0;
        }
LABEL_125:
        int v30 = v76 ^ 1;
LABEL_126:
        free(v110);
        goto LABEL_127;
      }
    }
    CFRange v91 = *v79;
    CFDictionaryRef v92 = *(_DWORD **)(v77 + 16);
    if (v92)
    {
      unsigned int v93 = *(_DWORD *)(v77 + 32);
      unint64_t v94 = *(void *)(v77 + 24);
      if (v94 >= v93 + v90) {
        goto LABEL_105;
      }
      unint64_t v95 = v94 + (v90 << 10);
    }
    else
    {
      unint64_t v95 = (v90 << 10) | 8u;
    }
    CFDictionaryRef v92 = (_DWORD *)(*(uint64_t (**)(void))v77)();
    if (!v92)
    {
      uint64_t v96 = 0;
LABEL_109:
      unint64_t v10 = v109;
      uint64_t v78 = v113;
      goto LABEL_110;
    }
    *(void *)(v77 + 16) = v92;
    *(void *)(v77 + 24) = v95;
    unsigned int v93 = *(_DWORD *)(v77 + 32);
LABEL_105:
    if (!v93)
    {
      *(_DWORD *)(v77 + 32) = 8;
      *CFDictionaryRef v92 = 8;
      v92[1] = *(_DWORD *)(v77 + 36);
      unsigned int v93 = *(_DWORD *)(v77 + 32);
    }
    uint64_t v97 = *(void *)(v77 + 40);
    memcpy((char *)v92 + v93, v91, *(unsigned int *)(v77 + 36));
    int v98 = *(_DWORD *)(v77 + 32) + *(_DWORD *)(v77 + 36);
    *(_DWORD *)(v77 + 32) = v98;
    **(_DWORD **)(v77 + 16) = v98;
    ++*(void *)(v77 + 40);
    uint64_t v96 = v97 + 1;
    goto LABEL_109;
  }
  CFDataRef v11 = (const __CFData *)CFArrayGetValueAtIndex(v5, 0);
  int v12 = CFDataGetLength(v11);
  if (Count >= 1)
  {
    for (CFIndex j = 0; j != Count; ++j)
    {
      CFDataRef v14 = (const __CFData *)CFArrayGetValueAtIndex(v5, j);
      v8[j] = (void *)CFDataGetBytePtr(v14);
    }
  }
  uint64_t v15 = *((void *)this + 3);
  *(_DWORD *)(v15 + 36) = v12;
  if (!Count)
  {
    LODWORD(v29) = 0;
    int v30 = 0;
    goto LABEL_127;
  }
  unint64_t v16 = (const void **)v112;
  uint64_t v17 = v10;
  unint64_t v18 = v10;
  CFIndex v19 = Count;
  do
  {
    int v20 = *(_DWORD *)(v15 + 36);
    if (!v20)
    {
LABEL_18:
      uint64_t v28 = 0;
      goto LABEL_19;
    }
    unint64_t v21 = *v16;
    unint64_t v22 = *(_DWORD **)(v15 + 16);
    if (v22)
    {
      unsigned int v23 = *(_DWORD *)(v15 + 32);
      unint64_t v24 = *(void *)(v15 + 24);
      if (v24 >= v23 + v20) {
        goto LABEL_15;
      }
      unint64_t v25 = v24 + (v20 << 10);
    }
    else
    {
      unint64_t v25 = (v20 << 10) | 8u;
    }
    unint64_t v22 = (_DWORD *)(*(uint64_t (**)(void))v15)();
    if (!v22) {
      goto LABEL_18;
    }
    *(void *)(v15 + 16) = v22;
    *(void *)(v15 + 24) = v25;
    unsigned int v23 = *(_DWORD *)(v15 + 32);
LABEL_15:
    if (!v23)
    {
      *(_DWORD *)(v15 + 32) = 8;
      _DWORD *v22 = 8;
      v22[1] = *(_DWORD *)(v15 + 36);
      unsigned int v23 = *(_DWORD *)(v15 + 32);
    }
    uint64_t v26 = *(void *)(v15 + 40);
    memcpy((char *)v22 + v23, v21, *(unsigned int *)(v15 + 36));
    int v27 = *(_DWORD *)(v15 + 32) + *(_DWORD *)(v15 + 36);
    *(_DWORD *)(v15 + 32) = v27;
    **(_DWORD **)(v15 + 16) = v27;
    ++*(void *)(v15 + 40);
    uint64_t v28 = v26 + 1;
LABEL_19:
    *v18++ = v28;
    ++v16;
    --v19;
  }
  while (v19);
  LODWORD(v29) = 0;
  int v30 = 0;
  unint64_t v10 = v17;
LABEL_127:
  BOOL v31 = v29 == 0;
  if (a4 && !v30 && Count >= 1 && !v29)
  {
    v106 = v10;
    do
    {
      unint64_t v107 = *v106++;
      *a4++ = v107;
      --Count;
    }
    while (Count);
  }
  free(v10);
  free(v112);
  return v31;
}

uint64_t HeapAccessContext::createIndexFile(HeapAccessContext *this, IDXIndexInfo *a2)
{
  CFURLRef v3 = (const char *)IDXIndexInfo::POSIXPath(this);
  BOOL v4 = IDXIndexInfo::writable(this);
  int v5 = openRawIndexFile(v3, v4, 1);
  if (v5 != -1)
  {
    int v6 = v5;
    if (lseek(v5, 63, 0) != -1 && write(v6, "", 1uLL) == 1)
    {
      close(v6);
      return 1;
    }
    close(v6);
    int v8 = (const std::__fs::filesystem::path *)IDXIndexInfo::POSIXPath(this);
    remove(v8, v9);
  }
  return 0;
}

uint64_t HeapAccessContext::compact(uint64_t this)
{
  if (*(unsigned char *)(this + 32) || *(_WORD *)(this + 36) == 3)
  {
    uint64_t v1 = *(void *)(this + 24);
    unint64_t v2 = *(unsigned int *)(v1 + 32);
    if (*(void *)(v1 + 24) > v2)
    {
      this = (*(uint64_t (**)(void, void, void))v1)(*(void *)(v1 + 16), *(unsigned int *)(v1 + 32), *(void *)(v1 + 8));
      if (this)
      {
        *(void *)(v1 + 16) = this;
        *(void *)(v1 + 24) = v2;
      }
    }
  }
  return this;
}

uint64_t HeapAccessContext::flush(HeapAccessContext *this)
{
  return flushIndexFile((void *)(*(void *)(*((void *)this + 3) + 16) - 64), *(void *)(*((void *)this + 5) + 16));
}

uint64_t HeapAccessContext::initializeSubclass(HeapAccessContext *this, int a2, void **a3)
{
  if (*((unsigned char *)this + 38)) {
    return 0;
  }
  if (!a2)
  {
    uint64_t v19 = (uint64_t)*a3;
    *((void *)this + 5) = *a3;
    *((void *)this + 3) = *(void *)(v19 + 8);
    return 1;
  }
  unint64_t v27 = 0;
  int v5 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
  int v6 = openRawIndexFile(v5, *((unsigned __int8 *)this + 33), 0);
  if (v6 == -1) {
    return 0;
  }
  int v7 = v6;
  int v8 = (_DWORD *)mapIndexFile(v6, *((unsigned __int8 *)this + 33), (off_t *)&v27);
  close(v7);
  if (v8 == (_DWORD *)-1) {
    return 0;
  }
  size_t v9 = v8 + 16;
  unint64_t v10 = v27 - 64;
  *((void *)this + 5) = malloc_type_malloc(0x18uLL, 0x80040B8603338uLL);
  CFDataRef v11 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
  size_t v12 = strlen(v11) + 1;
  uint64_t v13 = (char *)malloc_type_malloc(v12, 0xA779EF15uLL);
  CFDataRef v14 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
  strlcpy(v13, v14, v12);
  if (!*((unsigned char *)this + 32) && *((_WORD *)this + 18) != 3)
  {
    uint64_t v21 = *((void *)this + 5);
    unint64_t v16 = malloc_type_malloc(0x38uLL, 0x10900408C52C49CuLL);
    if (v16)
    {
      *unint64_t v16 = myReallocator;
      v16[1] = v21;
      v16[2] = v9;
      v16[3] = v10;
      *((_DWORD *)v16 + 8) = 0;
      v16[5] = 0;
      *((_DWORD *)v16 + 12) = 0;
      if (v10 >= 4 && (unint64_t v22 = *v9, v10 >= v22))
      {
        *((_DWORD *)v16 + 9) = v22;
        if (v22 >= 0x20 && !v8[17])
        {
          int v26 = -v8[18] & ((int)v8[18] >> 31);
          *((_DWORD *)v16 + 8) = v26;
          if (v26 >= 1)
          {
            *((_DWORD *)v16 + 10) = v8[19];
            *((_DWORD *)v16 + 11) = v8[20];
            *((_DWORD *)v16 + 12) = v8[21];
          }
        }
      }
      else
      {
        *((_DWORD *)v16 + 9) = 0;
      }
    }
    goto LABEL_13;
  }
  uint64_t v15 = *((void *)this + 5);
  unint64_t v16 = malloc_type_malloc(0x30uLL, 0x109004033C35484uLL);
  if (v16)
  {
    *unint64_t v16 = myReallocator;
    v16[1] = v15;
    v16[2] = v9;
    v16[3] = v10;
    if (v10 >= 4 && (unint64_t v17 = *v9, v10 >= v17))
    {
      *((_DWORD *)v16 + 8) = v17;
      BOOL v23 = v17 >= 8;
      unsigned int v24 = v17 - 8;
      if (v23)
      {
        unsigned int v25 = v8[17];
        *((_DWORD *)v16 + 9) = v25;
        if (!v25) {
          goto LABEL_13;
        }
        uint64_t v18 = v24 / v25;
        goto LABEL_12;
      }
    }
    else
    {
      *((_DWORD *)v16 + 8) = 0;
    }
    uint64_t v18 = 0;
    *((_DWORD *)v16 + 9) = 0;
LABEL_12:
    v16[5] = v18;
  }
LABEL_13:
  *((void *)this + 3) = v16;
  **((void **)this + 5) = v13;
  *(void *)(*((void *)this + 5) + 8) = *((void *)this + 3);
  *(void *)(*((void *)this + 5) + 16) = v27;
  *a3 = (void *)*((void *)this + 5);
  return 1;
}

uint64_t myReallocator(char *a1, uint64_t a2, const char **a3)
{
  int v6 = openRawIndexFile(*a3, 1, 0);
  if (v6 == -1) {
    return 0;
  }
  int v7 = v6;
  unint64_t v10 = 0;
  if (fstat(v6, &v11) == -1) {
    return 0;
  }
  unmapIndexFile(a1 - 64, v11.st_size);
  if (ftruncate(v7, a2 + 64) == -1) {
    return 0;
  }
  uint64_t v8 = mapIndexFile(v7, 1, (off_t *)&v10);
  a3[2] = (const char *)v10;
  close(v7);
  return v8 + 64;
}

{
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v10;
  stat v11;

  int v6 = openRawIndexFile(*a3, 1, 0);
  if (v6 == -1) {
    return 0;
  }
  int v7 = v6;
  unint64_t v10 = 0;
  if (fstat(v6, &v11) == -1) {
    return 0;
  }
  unmapIndexFile(a1 - 64, v11.st_size);
  if (ftruncate(v7, a2 + 64) == -1) {
    return 0;
  }
  uint64_t v8 = mapIndexFile(v7, 1, (off_t *)&v10);
  a3[2] = (const char *)v10;
  close(v7);
  return v8 + 64;
}

void HeapAccessContext::finalizeSubclass(HeapAccessContext *this, int a2)
{
  if (a2)
  {
    CFURLRef v3 = (void *)*((void *)this + 3);
    if (v3)
    {
      uint64_t v4 = v3[2];
      free(v3);
      unmapIndexFile((void *)(v4 - 64), *(void *)(*((void *)this + 5) + 16));
      free(**((void ***)this + 5));
      int v5 = (void *)*((void *)this + 5);
      free(v5);
    }
  }
}

uint64_t HeapAccessContext::setSearchCharacters(HeapAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const __CFString *a4)
{
  return 0;
}

uint64_t HeapAccessContext::getMatchDataPtr(HeapAccessContext *this, uint64_t a2, const unsigned __int8 **a3, uint64_t *a4)
{
  return 0;
}

uint64_t HeapAccessContext::getMatchData(HeapAccessContext *this, uint64_t a2, uint64_t a3, unsigned __int8 *a4, CFRange **a5, uint64_t *a6)
{
  return 0;
}

uint64_t HeapAccessContext::containsMatchData(HeapAccessContext *this, unsigned __int8 *a2)
{
  return 0;
}

BOOL HeapAccessContext::supportDataPtr(HeapAccessContext *this)
{
  return !*((unsigned char *)this + 35) && *((unsigned char *)this + 121) == 0;
}

void TrieAccessContext::TrieAccessContext(TrieAccessContext *this, IDXIndexInfo *a2)
{
  uint64_t v4 = IDXAccessContext::IDXAccessContext((uint64_t)this, (uint64_t)a2);
  *(void *)uint64_t v4 = &unk_1F2DE3918;
  *(void *)(v4 + 104) = 0;
  *(void *)(v4 + 136) = 0;
  *(void *)(v4 + 160) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v4 + 184), 0);
  *((unsigned char *)this + 72) = IDXIndexInfo::writable(a2);
  BOOL v5 = IDXIndexInfo::bigEndian(a2);
  *((_WORD *)this + 37) = 0;
  *((unsigned char *)this + 73) = v5;
  CFDictionaryRef v6 = IDXIndexInfo::optionalProperty(a2, @"TrieIndexCompressionType");
  if (v6) {
    CFNumberGetValue(v6, kCFNumberSInt16Type, (char *)this + 74);
  }
  unsigned __int8 v7 = IDXIndexInfo::dataSizeLength(a2);
  uint64_t v8 = IDXIndexInfo::fixedDataSize(a2);
  BOOL v9 = IDXIndexInfo::bigEndian(a2);
  *((void *)this + 21) = GetPreConfiguredGetDataSizeFunction(v7, v8, v9, (void *)this + 22);
}

void sub_1D5922704(_Unwind_Exception *a1)
{
  IDXAccessContext::~IDXAccessContext(v1);
  _Unwind_Resume(a1);
}

void TrieAccessContext::~TrieAccessContext(TrieAccessContext *this)
{
  *(void *)this = &unk_1F2DE3918;
  uint64_t v2 = *((void *)this + 10);
  if (v2) {
    MEMORY[0x1D9455390](v2, 0x1000C80BDFB0063);
  }
  uint64_t v3 = *((void *)this + 17);
  if (v3) {
    MEMORY[0x1D9455390](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 6);
  if (v4) {
    MEMORY[0x1D9455390](v4, 0x1000C8077774924);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 184));

  IDXAccessContext::~IDXAccessContext(this);
}

{
  uint64_t vars8;

  TrieAccessContext::~TrieAccessContext(this);

  JUMPOUT(0x1D94553C0);
}

void sub_1D59227D0(_Unwind_Exception *a1)
{
  IDXAccessContext::~IDXAccessContext(v1);
  _Unwind_Resume(a1);
}

void sub_1D5922834(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C4043258D86);
  _Unwind_Resume(a1);
}

uint64_t TrieAccessContext::setSearchCharacters(CFStringRef *this, const unsigned __int16 *__src, uint64_t a3, CFStringRef theString1)
{
  if (this[13] == theString1) {
    goto LABEL_14;
  }
  if (CFStringCompare(theString1, @"IDXExactMatch", 0))
  {
    if (CFStringCompare(theString1, @"IDXCommonPrefixMatch", 0))
    {
      if (CFEqual(theString1, @"IDXPrefixMatch"))
      {
LABEL_12:
        int v9 = 1;
        goto LABEL_13;
      }
      if (CFStringCompare(theString1, @"IDXWildcardMatch", 0))
      {
        if (CFStringCompare(theString1, @"IDXAllMatch", 0)) {
          return 0;
        }
        __src = 0;
        a3 = 0;
        goto LABEL_12;
      }
      int v9 = 3;
    }
    else
    {
      int v9 = 2;
    }
  }
  else
  {
    int v9 = 0;
  }
LABEL_13:
  *((_DWORD *)this + 28) = v9;
  this[13] = theString1;
LABEL_14:
  if (a3 > (uint64_t)this[11])
  {
    this[11] = (CFStringRef)(a3 + 128);
    CFStringRef v10 = this[10];
    if (v10) {
      MEMORY[0x1D9455390](v10, 0x1000C80BDFB0063);
    }
    operator new[]();
  }
  this[12] = (CFStringRef)(2 * a3);
  if (__src && a3 >= 1)
  {
    stat v11 = (__CFString *)this[10];
    if (*((unsigned char *)this + 73))
    {
      do
      {
        unsigned int v12 = *__src++;
        LOWORD(v11->isa) = bswap32(v12) >> 16;
        stat v11 = (__CFString *)((char *)v11 + 2);
        --a3;
      }
      while (a3);
    }
    else
    {
      memcpy(v11, __src, 2 * a3);
    }
  }
  *((unsigned char *)this + 116) = 0;
  this[15] = 0;
  uint64_t result = 1;
  this[20] = 0;
  return result;
}

uint64_t TrieAccessContext::supportDataPtr(TrieAccessContext *this)
{
  uint64_t result = TrieAccessContext::keyDataHeapContext(this);
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 64);
    return v2();
  }
  return result;
}

uint64_t TrieAccessContext::keyDataHeapContext(TrieAccessContext *this)
{
  uint64_t result = *((void *)this + 5);
  if (!result)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (!*((void *)this + 5)) {
      operator new();
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
    return *((void *)this + 5);
  }
  return result;
}

void sub_1D5922B5C(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C409CAD4C71);
  _Unwind_Resume(a1);
}

uint64_t TrieAccessContext::getMatchDataPtr(TrieAccessContext *this, uint64_t a2, const unsigned __int8 **a3, uint64_t *a4)
{
  return TrieAccessContext::getMatchDataCommon((uint64_t)this, a2, a3, a4, 0, 0, 0, 0, 0);
}

uint64_t TrieAccessContext::getMatchDataCommon(uint64_t this, uint64_t a2, const unsigned __int8 **a3, uint64_t *a4, BOOL a5, CFRange *a6, unsigned __int8 *a7, unsigned __int8 *a8, uint64_t *a9)
{
  int v9 = a7;
  CFStringRef v10 = a6;
  uint64_t v14 = this;
  v56[1] = *MEMORY[0x1E4F143B8];
  uint64_t v53 = 0;
  uint64_t v54 = a8;
  if (*(void *)(this + 96)) {
    uint64_t v15 = *(unsigned __int8 **)(this + 80);
  }
  else {
    uint64_t v15 = 0;
  }
  unint64_t v16 = a9;
  unint64_t v17 = *(const unsigned __int8 **)(this + 160);
  int64_t v52 = a3;
  if (v17)
  {
    this = TrieAccessContext::processHomographData((TrieAccessContext *)this, v17, 0, *(_DWORD *)(this + 144), *(void *)(this + 152), a2, a3, a4, a5, a6, a7, &v54, &v53);
    uint64_t v18 = this;
    a2 -= this;
    uint64_t v19 = v53;
  }
  else
  {
    uint64_t v19 = 0;
    uint64_t v18 = 0;
  }
  if (a2 >= 1 && !v19)
  {
    if (!*(unsigned char *)(v14 + 116))
    {
      uint64_t v48 = a4;
      MEMORY[0x1F4188790](this);
      unsigned int v24 = (signed int *)((char *)&v48 - v23);
      int v25 = *(_DWORD *)(v14 + 112);
      uint64_t v50 = v26;
      uint64_t v51 = a9;
      BOOL v49 = a5;
      switch(v25)
      {
        case 0:
          if (*(_WORD *)(v14 + 74) == 1)
          {
            signed int matched = btrie_exact_match_search(*(void *)(v14 + 24), v15, *(void *)(v14 + 96), v22);
          }
          else if (*(_WORD *)(v14 + 74))
          {
            signed int matched = mtrie_exact_match_search(*(void *)(v14 + 24), (const char *)v15, *(void *)(v14 + 96));
          }
          else
          {
            signed int matched = trie_exact_match_search(*(void *)(v14 + 24), v15, *(void *)(v14 + 96));
          }
          *unsigned int v24 = matched;
          int64_t v28 = matched > 0;
          goto LABEL_45;
        case 1:
          if (*(_WORD *)(v14 + 74) == 1)
          {
            BOOL v31 = *(int **)(v14 + 24);
            unsigned int v32 = *(_DWORD *)(v14 + 96);
            unint64_t v33 = *(void *)(v14 + 120);
            int64_t v55 = 0;
            v56[0] = v33;
            __btrie_find_prefix((uint64_t)v31, *v31, v15, v32, v56, a2, (unint64_t *)&v55, (uint64_t)v24, v22);
            int64_t v28 = v55;
            goto LABEL_41;
          }
          if (*(_WORD *)(v14 + 74)) {
            goto LABEL_31;
          }
          unint64_t v29 = trie_prefix_match_search(*(void *)(v14 + 24), v15, *(void *)(v14 + 96), *(void *)(v14 + 120), a2, (uint64_t)v24);
          goto LABEL_40;
        case 2:
          uint64_t v30 = *(void *)(v14 + 120);
          unsigned int v24 = *(signed int **)(v14 + 136);
          if (v30)
          {
            v24 += v30;
            int64_t v28 = *(void *)(v14 + 128) - v30;
          }
          else
          {
            if (*(_WORD *)(v14 + 74) == 1)
            {
              int v35 = *(int **)(v14 + 24);
              unint64_t v36 = *(void *)(v14 + 96);
              v56[0] = 0;
              __btrie_find_common_prefix((uint64_t)v35, *v35, v15, v36, v36, v56, (uint64_t)v24, 0, (uint64_t)v15);
              int64_t v28 = v56[0];
            }
            else if (*(_WORD *)(v14 + 74))
            {
              int64_t v28 = 0;
            }
            else
            {
              int64_t v28 = trie_common_prefix_search(*(void *)(v14 + 24), (uint64_t)v15, *(void *)(v14 + 96), *(void *)(v14 + 96), *(void *)(v14 + 136), 0);
            }
            *(void *)(v14 + 128) = v28;
          }
LABEL_45:
          BOOL v34 = 1;
          goto LABEL_46;
        case 3:
          if (*(_WORD *)(v14 + 74) == 1)
          {
            unint64_t v29 = btrie_wildcard_match_search(*(unsigned int **)(v14 + 24), v15, *(void *)(v14 + 96), 2u, *(void *)(v14 + 120), a2, (uint64_t)v24, v22);
          }
          else
          {
            if (*(_WORD *)(v14 + 74))
            {
LABEL_31:
              int64_t v28 = 0;
              goto LABEL_41;
            }
            unint64_t v29 = trie_wildcard_match_search(*(void *)(v14 + 24), (uint64_t)v15, *(void *)(v14 + 96), *(unsigned char *)(v14 + 73) == 0, 2u, *(void *)(v14 + 120), a2, (uint64_t)v24);
          }
LABEL_40:
          int64_t v28 = v29;
LABEL_41:
          BOOL v34 = v28 < a2;
LABEL_46:
          *(unsigned char *)(v14 + 116) = v34;
LABEL_47:
          uint64_t v19 = 0;
          int64_t v37 = 0;
          break;
        default:
          int64_t v28 = 0;
          goto LABEL_47;
      }
      do
      {
        CFDataRef v38 = v10;
        int v39 = v9;
        if (v37 <= v28) {
          int64_t v40 = v28;
        }
        else {
          int64_t v40 = v37;
        }
        int64_t v41 = v37;
        do
        {
          if (v40 == v41)
          {
            int64_t v37 = v40;
            goto LABEL_63;
          }
          int64_t v37 = v41 + 1;
          HeapCFDataRef Data = (unsigned int *)TrieAccessContext::getHeapData((TrieAccessContext *)v14, v24[v41], 0);
          int64_t v41 = v37;
        }
        while (!HeapData);
        if (*(unsigned char *)(v14 + 73)) {
          unsigned int v43 = bswap32(*HeapData);
        }
        else {
          unsigned int v43 = *HeapData;
        }
        int v9 = v39;
        CFStringRef v10 = v38;
        uint64_t v44 = TrieAccessContext::processHomographData((TrieAccessContext *)v14, (const unsigned __int8 *)HeapData, 4, v43, 0, a2, &v52[v18], &v48[v18], v49, &v38[v18], v9, &v54, &v53);
        a2 -= v44;
        v18 += v44;
        uint64_t v19 = v53;
        if (a2) {
          BOOL v45 = v53 < 1;
        }
        else {
          BOOL v45 = 0;
        }
      }
      while (v45);
LABEL_63:
      if (*(unsigned char *)(v14 + 116)) {
        BOOL v46 = v37 == v28;
      }
      else {
        BOOL v46 = 0;
      }
      char v47 = v46;
      *(unsigned char *)(v14 + 116) = v47;
      *(void *)(v14 + 120) += v37;
      unint64_t v16 = v51;
      if (!v51) {
        return v18;
      }
      goto LABEL_12;
    }
    uint64_t v19 = 0;
  }
  if (!a9) {
    return v18;
  }
LABEL_12:
  if (*(unsigned char *)(v14 + 116))
  {
    uint64_t v20 = *(void *)(v14 + 160);
    if (!v20) {
      goto LABEL_16;
    }
  }
  if (!v18)
  {
    uint64_t v20 = v19 + 16;
LABEL_16:
    *unint64_t v16 = v20;
  }
  return v18;
}

uint64_t TrieAccessContext::getMatchData(TrieAccessContext *this, uint64_t a2, uint64_t a3, CFRange *a4, CFRange **a5, uint64_t *a6)
{
  *a5 = a4;
  if (a6) {
    *a6 = a3;
  }
  if (!a2) {
    a2 = 1000;
  }
  return TrieAccessContext::getMatchDataCommon((uint64_t)this, a2, 0, 0, 1, a4, (unsigned __int8 *)a4, (unsigned __int8 *)a4 + a3, a6);
}

uint64_t TrieAccessContext::processHomographData(TrieAccessContext *this, const unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, const unsigned __int8 **a7, uint64_t *a8, BOOL a9, CFRange *a10, unsigned __int8 *a11, unsigned __int8 **a12, uint64_t *a13)
{
  uint64_t v14 = a3;
  uint64_t v15 = this;
  uint64_t v16 = 0;
  unint64_t v17 = &a2[a3];
  *((void *)this + 20) = 0;
  uint64_t v18 = a4;
  while (1)
  {
    unsigned __int8 v30 = 0;
    uint64_t v19 = (*((uint64_t (**)(void, const unsigned __int8 *, unsigned __int8 *))v15 + 21))(*((void *)v15 + 22), v17, &v30);
    size_t v20 = v19;
    if (!a9) {
      break;
    }
    uint64_t v21 = &(*a12)[-v19];
    if (&a10[v16 + 1] > (CFRange *)v21)
    {
      *a13 = v20;
      unint64_t v17 = &a2[v30 + v20 + v14];
      ++a5;
LABEL_11:
      uint64_t v15 = this;
      goto LABEL_13;
    }
    *a12 = v21;
    memmove(v21, &v17[v30], v20);
    uint8x8_t v22 = &a10[v16];
    v22->CFIndex location = *a12 - a11;
    v22->int64_t length = v20;
    v14 += v20 + v30;
    unint64_t v17 = &a2[v14];
    ++a5;
    if (v16 + 1 == a6)
    {
      uint64_t v16 = a6;
      goto LABEL_11;
    }
    ++v16;
    uint64_t v15 = this;
LABEL_7:
    if (a5 == v18) {
      return v16;
    }
  }
  a8[v16] = v19;
  uint64_t v23 = v30;
  a7[v16++] = &v17[v30];
  v14 += v19 + v23;
  unint64_t v17 = &a2[v14];
  ++a5;
  if (v16 != a6) {
    goto LABEL_7;
  }
  uint64_t v16 = a6;
LABEL_13:
  if (a5 < v18)
  {
    *((void *)v15 + 19) = a5;
    *((void *)v15 + 20) = v17;
    *((void *)v15 + 18) = v18;
  }
  return v16;
}

uint64_t trie_exact_match_search(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (*(void *)(a1 + 24) < 2uLL) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (a3)
  {
    unsigned int v5 = 1;
    while (1)
    {
      int v6 = *a2++;
      unsigned int v7 = *(_DWORD *)(v4 + 8 * v5) + v6 + 1;
      if (*(_DWORD *)(v4 + 8 * v7 + 4) != v5) {
        return 0xFFFFFFFFLL;
      }
      unsigned int v5 = v7;
      if (!--a3) {
        goto LABEL_9;
      }
    }
  }
  unsigned int v7 = 1;
LABEL_9:
  uint64_t v8 = *(unsigned int *)(v4 + 8 * v7);
  uint64_t result = 0xFFFFFFFFLL;
  if (*(_DWORD *)(v4 + 8 * v8 + 4) == v7)
  {
    int v9 = *(_DWORD *)(v4 + 8 * v8);
    if (v9 < 0) {
      return -v9;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t btrie_exact_match_search(uint64_t a1, unsigned __int8 *__s2, unsigned int a3, uint8x8_t a4)
{
  int v6 = (unsigned int *)a1;
  while (1)
  {
    unsigned int v7 = *v6;
    int v8 = v7 & 3;
    if (v8 != 2) {
      break;
    }
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v11 = v7 - 2;
    int v9 = (char *)(v10 + v11);
    if (!a3) {
      return *(unsigned int *)v9;
    }
    unint64_t v12 = *__s2;
    uint64_t v13 = v12 >> 5;
    unsigned int v14 = *(_DWORD *)&v9[4 * (v12 >> 5) + 4];
    if (((v14 >> v12) & 1) == 0) {
      return 0;
    }
    if (v12 >= 0x20)
    {
      int v15 = 0;
      if (v13 <= 1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v13;
      }
      uint64_t v16 = (unsigned int *)(v10 + v11 + 4);
      do
      {
        unsigned int v17 = *v16++;
        a4 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
        a4.i16[0] = vaddlv_u8(a4);
        v15 += a4.i32[0];
        --v13;
      }
      while (v13);
    }
    else
    {
      int v15 = 0;
    }
    a4.i32[0] = v14 & ~(-1 << (v12 & 0x1F));
    a4 = (uint8x8_t)vcnt_s8((int8x8_t)a4);
    a4.i16[0] = vaddlv_u8(a4);
    int v6 = (unsigned int *)&v9[4 * (v15 + a4.i32[0]) + 40];
LABEL_16:
    --a3;
    ++__s2;
  }
  if (v8 == 3)
  {
    int v9 = (char *)(*(void *)(a1 + 8) + v7 - 3);
    if (!a3) {
      return *(unsigned int *)v9;
    }
    int v6 = (unsigned int *)&v9[4 * *__s2 + 4];
    goto LABEL_16;
  }
  if (v8 != 1) {
    return 0;
  }
  uint64_t v18 = (_DWORD *)(*(void *)(a1 + 16) + v7 - 1);
  int v9 = (char *)(v18 + 1);
  if (a3)
  {
    int v20 = *v18;
    uint64_t v19 = (unsigned __int8 *)(v18 + 2);
    uint64_t v21 = (unsigned __int8 *)&v9[v20];
    while (v19 < v21)
    {
      unsigned int v24 = *v19;
      uint8x8_t v22 = (char *)(v19 + 1);
      uint64_t v23 = v24;
      int v25 = v24 - a3;
      if (v24 >= a3) {
        size_t v26 = a3;
      }
      else {
        size_t v26 = v23;
      }
      int v27 = memcmp(v22, __s2, v26);
      if (v27) {
        int v28 = v27;
      }
      else {
        int v28 = v25;
      }
      if ((v28 & 0x80000000) == 0)
      {
        if (v28) {
          return 0;
        }
        int v9 = &v22[v23];
        return *(unsigned int *)v9;
      }
      uint64_t v19 = (unsigned __int8 *)&v22[v23 + 4];
    }
    return 0;
  }
  return *(unsigned int *)v9;
}

unint64_t trie_prefix_match_search(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v6 = 0;
  unint64_t v12 = 0;
  uint64_t v13 = a4;
  if (*(void *)(a1 + 24) >= 2uLL)
  {
    unsigned int v7 = 1;
    if (a2 && a3)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      unsigned int v9 = 1;
      while (1)
      {
        int v10 = *a2++;
        unsigned int v7 = *(_DWORD *)(v8 + 8 * v9) + v10 + 1;
        if (*(_DWORD *)(v8 + 8 * v7 + 4) != v9) {
          return 0;
        }
        unsigned int v9 = v7;
        if (!--a3) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      __search_node_tree(a1, a5, &v13, &v12, a6, v7);
      return v12;
    }
  }
  return v6;
}

unint64_t trie_wildcard_match_search(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6, unint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0;
  uint64_t v11 = a6;
  unint64_t v10 = 0;
  if (*(void *)(a1 + 24) >= 2uLL)
  {
    __wildcard_match_str(a1, a7, &v11, &v10, a8, 1, a2, a3, a4, a5);
    return v10;
  }
  return v8;
}

unint64_t btrie_wildcard_match_search(unsigned int *a1, unsigned char *a2, int a3, unsigned int a4, uint64_t a5, unint64_t a6, uint64_t a7, uint8x8_t a8)
{
  uint64_t v14 = a5;
  uint64_t v11 = *a1;
  unint64_t v13 = 0;
  __btrie_wildcard_match((uint64_t)a1, v11, &v13, a2, a3, a4, &v14, a6, a8, a7, 0, 0);
  return v13;
}

uint64_t trie_common_prefix_search(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  if (*(void *)(a1 + 24) < 2uLL || a3 == 0) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v9 = 0;
  uint64_t v10 = *(void *)(a1 + 8);
  LODWORD(v11) = 1;
  do
  {
    int v12 = v11;
    uint64_t v11 = *(_DWORD *)(v10 + 8 * v11) + *(unsigned __int8 *)(a2 + v9) + 1;
    if (*(_DWORD *)(v10 + 8 * v11 + 4) != v12) {
      break;
    }
    uint64_t v13 = *(unsigned int *)(v10 + 8 * v11);
    if (*(_DWORD *)(v10 + 8 * v13 + 4) == v11)
    {
      int v14 = *(_DWORD *)(v10 + 8 * v13);
      if (v14 < 0)
      {
        if (a4)
        {
          *(_DWORD *)(a5 + 4 * result) = -v14;
          if (a6) {
            *(void *)(a6 + 8 * result) = v9 + 1;
          }
          if (++result >= a4) {
            return result;
          }
        }
        else
        {
          ++result;
        }
      }
    }
    ++v9;
  }
  while (a3 != v9);
  return result;
}

uint64_t TrieAccessContext::getHeapData(TrieAccessContext *this, uint64_t a2, uint64_t *a3)
{
  uint64_t result = TrieAccessContext::keyDataHeapContext(this);
  if (result)
  {
    uint64_t v7 = result;
    if ((*(unsigned int (**)(uint64_t))(*(void *)result + 64))(result))
    {
      uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v7 + 48);
      return v8(v7, a2, a3);
    }
    else
    {
      uint64_t v9 = *((void *)this + 6);
      if (!v9)
      {
        *((void *)this + 7) = 0x8000;
        operator new[]();
      }
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v7 + 56))(v7, a2, *((void *)this + 7), v9);
      if (v10 > *((void *)this + 7))
      {
        uint64_t v11 = *((void *)this + 6);
        if (v11) {
          MEMORY[0x1D9455390](v11, 0x1000C8077774924);
        }
        *((void *)this + 7) = v10;
        operator new[]();
      }
      if (a3) {
        *a3 = v10;
      }
      return *((void *)this + 6);
    }
  }
  return result;
}

BOOL TrieAccessContext::containsMatchData(TrieAccessContext *this, unsigned __int8 *a2, uint8x8_t a3)
{
  v67[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (char *)*((void *)this + 10);
  unint64_t v4 = *((void *)this + 12);
  if (v3) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    return 0;
  }
  int v9 = *((_DWORD *)this + 28);
  if (!a2 || v9 != 2) {
    goto LABEL_11;
  }
  if (v4 >= 2)
  {
    bzero(a2, v4 >> 1);
    int v9 = *((_DWORD *)this + 28);
LABEL_11:
    switch(v9)
    {
      case 0:
        if (*((_WORD *)this + 37) != 1)
        {
          if (*((_WORD *)this + 37))
          {
            BOOL v51 = mtrie_exact_match_search(*((void *)this + 3), v3, v4) == 0;
            return !v51;
          }
          uint64_t v10 = *((void *)this + 3);
          if (*(void *)(v10 + 24) < 2uLL) {
            return 0;
          }
          uint64_t v11 = *(void *)(v10 + 8);
          unsigned int v12 = 1;
          do
          {
            int v13 = *v3++;
            uint64_t v14 = (*(_DWORD *)(v11 + 8 * v12) + v13 + 1);
            if (*(_DWORD *)(v11 + 8 * v14 + 4) != v12) {
              return 0;
            }
            unsigned int v12 = v14;
            --v4;
          }
          while (v4);
          uint64_t v15 = *(unsigned int *)(v11 + 8 * v14);
          if (*(_DWORD *)(v11 + 8 * v15 + 4) == v14) {
            return *(_DWORD *)(v11 + 8 * v15) >> 31;
          }
          return 0;
        }
        uint64_t v38 = *((void *)this + 3);
        int v39 = (char *)v38;
        break;
      case 1:
        if (*((_WORD *)this + 37) == 1)
        {
          int64_t v52 = (int *)*((void *)this + 3);
          unint64_t v66 = 0;
          v67[0] = 0;
          __btrie_find_prefix((uint64_t)v52, *v52, (unsigned __int8 *)v3, v4, v67, 1uLL, &v66, (uint64_t)&v65 + 4, a3);
          goto LABEL_68;
        }
        if (*((_WORD *)this + 37)) {
          return 0;
        }
        uint64_t v22 = *((void *)this + 3);
        unint64_t v66 = 0;
        v67[0] = 0;
        if (*(void *)(v22 + 24) < 2uLL) {
          return 0;
        }
        uint64_t v23 = *(void *)(v22 + 8);
        unsigned int v24 = 1;
        do
        {
          unsigned int v25 = v24;
          int v26 = *v3++;
          unsigned int v24 = *(_DWORD *)(v23 + 8 * v24) + v26 + 1;
          if (*(_DWORD *)(v23 + 8 * v24 + 4) != v25) {
            return 0;
          }
          --v4;
        }
        while (v4);
        __search_node_tree(v22, 1uLL, v67, &v66, (uint64_t)&v65 + 4, v24);
        goto LABEL_68;
      case 2:
        goto LABEL_20;
      case 3:
        if (*((_WORD *)this + 37) == 1)
        {
          uint64_t v53 = (unsigned int *)*((void *)this + 3);
          unint64_t v66 = 0;
          v67[0] = 0;
          __btrie_wildcard_match((uint64_t)v53, *v53, &v66, v3, v4, 2u, v67, 1uLL, a3, (uint64_t)&v65 + 4, 0, 0);
        }
        else
        {
          if (*((_WORD *)this + 37)) {
            return 0;
          }
          uint64_t v27 = *((void *)this + 3);
          int v28 = *((unsigned __int8 *)this + 73);
          unint64_t v66 = 0;
          v67[0] = 0;
          if (*(void *)(v27 + 24) < 2uLL) {
            return 0;
          }
          __wildcard_match_str(v27, 1uLL, v67, &v66, (uint64_t)&v65 + 4, 1, (uint64_t)v3, v4, v28 == 0, 2u);
        }
LABEL_68:
        BOOL v51 = v66 == 0;
        return !v51;
      default:
        return 0;
    }
    while (1)
    {
      int v40 = *(_DWORD *)v39;
      int v41 = v40 & 3;
      switch(v41)
      {
        case 2:
          uint64_t v43 = *(void *)(v38 + 8);
          uint64_t v44 = (v40 - 2);
          unint64_t v42 = (char *)(v43 + v44);
          if (!v4) {
            goto LABEL_86;
          }
          unint64_t v45 = *v3;
          uint64_t v46 = v45 >> 5;
          unsigned int v47 = *(_DWORD *)&v42[4 * (v45 >> 5) + 4];
          if (((v47 >> v45) & 1) == 0) {
            return 0;
          }
          if (v45 >= 0x20)
          {
            int v48 = 0;
            if (v46 <= 1) {
              uint64_t v46 = 1;
            }
            else {
              uint64_t v46 = v46;
            }
            BOOL v49 = (unsigned int *)(v43 + v44 + 4);
            do
            {
              unsigned int v50 = *v49++;
              a3 = (uint8x8_t)vcnt_s8((int8x8_t)v50);
              a3.i16[0] = vaddlv_u8(a3);
              v48 += a3.i32[0];
              --v46;
            }
            while (v46);
          }
          else
          {
            int v48 = 0;
          }
          a3.i32[0] = v47 & ~(-1 << (v45 & 0x1F));
          a3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
          a3.i16[0] = vaddlv_u8(a3);
          int v39 = &v42[4 * (v48 + a3.i32[0]) + 40];
          break;
        case 3:
          unint64_t v42 = (char *)(*(void *)(v38 + 8) + (v40 - 3));
          if (!v4) {
            goto LABEL_86;
          }
          int v39 = &v42[4 * *v3 + 4];
          break;
        case 1:
          uint64_t v54 = (_DWORD *)(*(void *)(v38 + 16) + (v40 - 1));
          unint64_t v42 = (char *)(v54 + 1);
          if (!v4) {
            goto LABEL_86;
          }
          int v56 = *v54;
          int64_t v55 = (unsigned __int8 *)(v54 + 2);
          size_t v57 = (unsigned __int8 *)&v42[v56];
          if (v55 >= v57) {
            return 0;
          }
          while (1)
          {
            unsigned int v60 = *v55;
            unint64_t v58 = (char *)(v55 + 1);
            uint64_t v59 = v60;
            int v61 = v60 - v4;
            size_t v62 = v60 >= v4 ? v4 : v59;
            int v63 = memcmp(v58, v3, v62);
            int v64 = v63 ? v63 : v61;
            if ((v64 & 0x80000000) == 0) {
              break;
            }
            BOOL result = 0;
            int64_t v55 = (unsigned __int8 *)&v58[v59 + 4];
            if (v55 >= v57) {
              return result;
            }
          }
          if (!v64)
          {
            unint64_t v42 = &v58[v59];
LABEL_86:
            BOOL v51 = *(_DWORD *)v42 == 0;
            return !v51;
          }
          return 0;
        default:
          return 0;
      }
      LODWORD(v4) = v4 - 1;
      ++v3;
    }
  }
LABEL_20:
  uint64_t v16 = MEMORY[0x1F4188790](this);
  MEMORY[0x1F4188790](v16);
  uint64_t v19 = (unint64_t *)((char *)&v65 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (a2) {
    unint64_t v20 = v4;
  }
  else {
    unint64_t v20 = 1;
  }
  if (*((_WORD *)this + 37) == 1)
  {
    unint64_t v29 = (int *)*((void *)this + 3);
    v67[0] = 0;
    __btrie_find_common_prefix((uint64_t)v29, *v29, (unsigned __int8 *)v3, v4, v20, v67, v17, (uint64_t)v19, (uint64_t)v3);
    unint64_t v30 = v67[0];
  }
  else
  {
    if (*((_WORD *)this + 37)) {
      return 0;
    }
    uint64_t v21 = *((void *)this + 3);
    if (*(void *)(v21 + 24) < 2uLL) {
      return 0;
    }
    unint64_t v30 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = *(void *)(v21 + 8);
    LODWORD(v34) = *(_DWORD *)(v33 + 8);
    LODWORD(v35) = 1;
    do
    {
      int v36 = v35;
      uint64_t v35 = v34 + v3[v32] + 1;
      if (*(_DWORD *)(v33 + 8 * v35 + 4) != v36) {
        break;
      }
      uint64_t v34 = *(unsigned int *)(v33 + 8 * v35);
      if (*(_DWORD *)(v33 + 8 * v34 + 4) == v35)
      {
        int v37 = *(_DWORD *)(v33 + 8 * v34);
        if (v37 < 0)
        {
          *(_DWORD *)(v17 + 4 * v30) = -v37;
          v19[v30++] = v32 + 1;
          if (v30 >= v20) {
            break;
          }
        }
      }
      ++v32;
    }
    while (v4 != v32);
  }
  for (BOOL result = v30 != 0; v30; --v30)
  {
    unint64_t v31 = *v19++;
    a2[(v31 >> 1) - 1] = 1;
  }
  return result;
}

uint64_t TrieAccessContext::addRecord(TrieAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, size_t a5, unint64_t *a6)
{
  v40[1] = *MEMORY[0x1E4F143B8];
  v40[0] = a5;
  uint64_t result = TrieAccessContext::keyDataHeapContext(this);
  if (!result) {
    return result;
  }
  if (!*((unsigned char *)this + 72) || *((_WORD *)this + 37)) {
    return 0;
  }
  uint64_t v13 = result;
  unint64_t v14 = 2 * a3;
  MEMORY[0x1F4188790](result);
  if (*((unsigned char *)this + 73))
  {
    if (a3)
    {
      uint64_t v15 = 0;
      do
      {
        *(_WORD *)((char *)&v32 + 2 * v15 - ((2 * a3 + 15) & 0xFFFFFFFFFFFFFFF0)) = bswap32(a2[v15]) >> 16;
        ++v15;
      }
      while (a3 != v15);
    }
    a2 = (const unsigned __int16 *)((char *)&v32 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
  }
  uint64_t v39 = 0;
  unsigned __int8 v38 = 0;
  (*((void (**)(void, uint64_t *, unsigned __int8 *))this + 21))(*((void *)this + 22), &v39, &v38);
  SizeBytesEmbededCFDataRef Data = CreateSizeBytesEmbededData(a4, a5, v38, *((unsigned __int8 *)this + 73), v40);
  uint64_t v37 = 0;
  uint64_t v17 = *((void *)this + 3);
  if (*(void *)(v17 + 24) >= 2uLL)
  {
    uint64_t v18 = *(void *)(v17 + 8);
    if (v14)
    {
      unsigned int v19 = 1;
      unint64_t v20 = a2;
      uint64_t v21 = 2 * a3;
      while (1)
      {
        int v22 = *(unsigned __int8 *)v20;
        unint64_t v20 = (const unsigned __int16 *)((char *)v20 + 1);
        unsigned int v23 = *(_DWORD *)(v18 + 8 * v19) + v22 + 1;
        if (*(_DWORD *)(v18 + 8 * v23 + 4) != v19) {
          break;
        }
        unsigned int v19 = v23;
        if (!--v21) {
          goto LABEL_17;
        }
      }
    }
    else
    {
      unsigned int v23 = 1;
LABEL_17:
      uint64_t v24 = *(unsigned int *)(v18 + 8 * v23);
      if (*(_DWORD *)(v18 + 8 * v24 + 4) == v23)
      {
        int v25 = *(_DWORD *)(v18 + 8 * v24);
        if (v25 < 0)
        {
          uint64_t v30 = -v25;
          HeapCFDataRef Data = (_DWORD *)TrieAccessContext::getHeapData(this, v30, &v37);
          if (HeapData)
          {
            uint64_t v33 = v37;
            uint64_t v34 = v30;
            size_t v26 = v40[0] + v37;
            uint64_t v27 = malloc_type_malloc(v40[0] + v37, 0x61F944FuLL);
            memcpy(v27, HeapData, v37);
            memcpy((char *)v27 + v33, SizeBytesEmbededData, v40[0]);
            if (*((unsigned char *)this + 73)) {
              int v31 = bswap32(bswap32(*HeapData) + 1);
            }
            else {
              int v31 = *HeapData + 1;
            }
            *uint64_t v27 = v31;
            (*(void (**)(uint64_t, void, void, void, void, uint64_t))(*(void *)v13 + 80))(v13, 0, 0, 0, 0, v34);
            goto LABEL_23;
          }
        }
      }
    }
  }
  size_t v26 = v40[0] + 4;
  uint64_t v27 = malloc_type_malloc(v40[0] + 4, 0xBCD0B6ECuLL);
  memcpy(v27 + 1, SizeBytesEmbededData, v40[0]);
  if (*((unsigned char *)this + 73)) {
    int v28 = 0x1000000;
  }
  else {
    int v28 = 1;
  }
  *uint64_t v27 = v28;
LABEL_23:
  if (v40[0] != a5) {
    free(SizeBytesEmbededData);
  }
  uint64_t v36 = 0;
  int v29 = (*(uint64_t (**)(uint64_t, void, void, _DWORD *, size_t, uint64_t *))(*(void *)v13 + 72))(v13, 0, 0, v27, v26, &v36);
  free(v27);
  if (!v29) {
    return 0;
  }
  uint64_t result = trie_insert_key(*((void *)this + 3), (uint64_t)a2, v14, v36) == 0;
  if (a6) {
    *a6 = 0;
  }
  return result;
}

uint64_t trie_insert_key(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(void *)(a1 + 24);
  if (v8 <= 1 && __resize_array(a1, v8 + 0x2000)) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  if (!v9)
  {
    uint64_t v10 = *(void *)a1;
    *(void *)uint64_t v10 = 0x1074726965;
    *(_DWORD *)(v10 + 8) = 65793;
    *(void *)(*(void *)(a1 + 8) + 8) = 1;
    unsigned int v9 = 1;
    *(_DWORD *)(a1 + 16) = 1;
  }
  unint64_t v11 = 0;
  uint64_t v12 = 1;
  while (1)
  {
    if (a3 == v11)
    {
      uint64_t v13 = *(void *)(a1 + 8);
      if (v9 < v12)
      {
        uint64_t v14 = 0;
        goto LABEL_18;
      }
      uint64_t v14 = *(unsigned int *)(v13 + 8 * v12);
    }
    else
    {
      int v15 = v9 >= v12 ? *(_DWORD *)(*(void *)(a1 + 8) + 8 * v12) : 0;
      uint64_t v14 = v15 + *(unsigned __int8 *)(a2 + v11) + 1;
    }
    if (v9 < v14)
    {
      if (v12) {
        goto LABEL_22;
      }
      goto LABEL_20;
    }
    uint64_t v13 = *(void *)(a1 + 8);
LABEL_18:
    if (*(_DWORD *)(v13 + 8 * v14 + 4) != v12)
    {
LABEL_22:
      int v17 = -a4;
      while (1)
      {
        if (v11 == a3) {
          int v18 = 0;
        }
        else {
          int v18 = *(unsigned __int8 *)(a2 + v11) + 1;
        }
        unsigned int v19 = *(_DWORD *)(a1 + 16);
        if (v19 < v12 || !*(_DWORD *)(*(void *)(a1 + 8) + 8 * v12))
        {
          for (int i = 1; ; ++i)
          {
            unsigned int v21 = i + v18;
            int v22 = v19 >= i + v18 ? *(_DWORD *)(*(void *)(a1 + 8) + 8 * v21 + 4) : 0;
            if (v21 != 1 && v22 == 0) {
              break;
            }
          }
          __write_base(a1, v12, i);
          unsigned int v19 = *(_DWORD *)(a1 + 16);
        }
        int v24 = v19 >= v12 ? *(_DWORD *)(*(void *)(a1 + 8) + 8 * v12) : 0;
        uint64_t v25 = (v24 + v18);
        BOOL v26 = v19 >= v25 && *(_DWORD *)(*(void *)(a1 + 8) + 8 * v25 + 4) != 0;
        if (v25 == 1 || v26) {
          break;
        }
        int v27 = v12;
        uint64_t v12 = v25;
LABEL_59:
        if (v19 < v12 || !*(_DWORD *)(*(void *)(a1 + 8) + 8 * v12 + 4))
        {
          __write_check(a1, v12, v27);
          if (!v18) {
            __write_base(a1, v12, v17);
          }
        }
        if (++v11 > a3) {
          goto LABEL_67;
        }
      }
      uint64_t list = __get_list(a1, v12, (uint64_t)v44);
      if (v25 != 1)
      {
        if (v19 >= v25)
        {
          unsigned int v31 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * v25 + 4);
          unint64_t v32 = __get_list(a1, v31, (uint64_t)v43);
          if (list + 1 >= v32)
          {
            unint64_t v30 = v32;
            goto LABEL_54;
          }
        }
        else
        {
          unint64_t v29 = __get_list(a1, 0, (uint64_t)v43);
          if (list + 1 >= v29)
          {
            unint64_t v30 = v29;
            unsigned int v31 = 0;
LABEL_54:
            uint64_t v33 = v43;
            uint64_t v34 = a1;
            uint64_t v35 = v12;
            unsigned int v36 = v31;
            __int16 v37 = 0;
            int v38 = 0;
            goto LABEL_55;
          }
        }
      }
      uint64_t v33 = v44;
      uint64_t v34 = a1;
      uint64_t v35 = v12;
      unsigned int v36 = v12;
      unint64_t v30 = list;
      __int16 v37 = v18;
      int v38 = 1;
LABEL_55:
      unsigned int v39 = __modify_array(v34, v35, v36, (uint64_t)v33, v30, v37, v38);
      int v27 = v39;
      unsigned int v19 = *(_DWORD *)(a1 + 16);
      if (v19 >= v39) {
        int v40 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * v39);
      }
      else {
        int v40 = 0;
      }
      uint64_t v12 = (v40 + v18);
      goto LABEL_59;
    }
    int v16 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * v14);
    if (v16 < 0) {
      break;
    }
LABEL_20:
    ++v11;
    uint64_t v12 = v14;
    if (v11 > a3) {
      goto LABEL_67;
    }
  }
  if (v16 + a4) {
    __write_base(a1, v14, -a4);
  }
LABEL_67:
  uint64_t v41 = *(unsigned int *)(a1 + 16);
  *(_DWORD *)(*(void *)a1 + 12) = v41;
  if ((unint64_t)(*(void *)(a1 + 24) + ~v41) <= 0x101
    && __resize_array(a1, (v41 + 259)))
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 0;
  }
}

BOOL TrieAccessContext::deleteRecord(TrieAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, size_t a5)
{
  v55[1] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = TrieAccessContext::keyDataHeapContext(this);
  if (!v10 || !*((unsigned char *)this + 72) || *((_WORD *)this + 37)) {
    return 0;
  }
  uint64_t v13 = v10;
  MEMORY[0x1F4188790](v10);
  int v15 = (const unsigned __int16 *)((char *)v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (*((unsigned char *)this + 73))
  {
    if (!a3)
    {
      int v18 = (uint64_t *)((char *)this + 24);
      uint64_t v23 = *((void *)this + 3);
      if (*(void *)(v23 + 24) >= 2uLL)
      {
        uint64_t v19 = *(void *)(v23 + 8);
        goto LABEL_20;
      }
      return 0;
    }
    uint64_t v16 = 0;
    do
    {
      v15[v16] = bswap32(a2[v16]) >> 16;
      ++v16;
    }
    while (a3 != v16);
  }
  else
  {
    int v15 = a2;
  }
  int v18 = (uint64_t *)((char *)this + 24);
  uint64_t v17 = *((void *)this + 3);
  if (*(void *)(v17 + 24) < 2uLL) {
    return 0;
  }
  uint64_t v19 = *(void *)(v17 + 8);
  if (v14)
  {
    uint64_t v20 = 0;
    unsigned int v21 = 1;
    while (1)
    {
      unsigned int v22 = v21;
      unsigned int v21 = *(_DWORD *)(v19 + 8 * v21) + *((unsigned __int8 *)v15 + v20) + 1;
      if (*(_DWORD *)(v19 + 8 * v21 + 4) != v22) {
        return 0;
      }
      if (v14 == ++v20) {
        goto LABEL_21;
      }
    }
  }
LABEL_20:
  unsigned int v21 = 1;
LABEL_21:
  uint64_t v24 = *(unsigned int *)(v19 + 8 * v21);
  if (*(_DWORD *)(v19 + 8 * v24 + 4) != v21) {
    return 0;
  }
  int v25 = *(_DWORD *)(v19 + 8 * v24);
  if ((v25 & 0x80000000) == 0) {
    return 0;
  }
  v44[0] = v14;
  uint64_t v26 = -v25;
  v55[0] = 0;
  HeapCFDataRef Data = (unsigned int *)TrieAccessContext::getHeapData(this, v26, v55);
  if (!HeapData) {
    return 0;
  }
  v44[1] = (unint64_t)v44;
  int v27 = *((unsigned __int8 *)this + 73);
  uint64_t v46 = v13;
  unsigned int v47 = v18;
  if (v27) {
    unsigned int v28 = bswap32(*HeapData);
  }
  else {
    unsigned int v28 = *HeapData;
  }
  uint64_t v45 = v26;
  unsigned int v50 = (char *)malloc_type_malloc(v55[0] + 8 * v28, 0x79232F17uLL);
  if (v28)
  {
    int v48 = a4;
    size_t v49 = a5;
    uint64_t v52 = 4;
    uint64_t v53 = 0;
    uint64_t v29 = 4;
    do
    {
      unint64_t v30 = (char *)HeapData + v29;
      LOBYTE(v54) = 0;
      uint64_t v31 = (*((uint64_t (**)(void, char *, uint64_t *))this + 21))(*((void *)this + 22), (char *)HeapData + v29, &v54);
      uint64_t v32 = v54;
      if (v31 != a5 || memcmp(v48, &v30[v54], a5))
      {
        uint64_t v33 = v52;
        memcpy(&v50[v52], v30, v31 + v32);
        a5 = v49;
        uint64_t v52 = v31 + v32 + v33;
        ++v53;
      }
      v29 += v31 + v32;
      --v28;
    }
    while (v28);
  }
  else
  {
    uint64_t v52 = 4;
    uint64_t v53 = 0;
  }
  uint64_t v34 = v53;
  if (*((unsigned char *)this + 73)) {
    *(_DWORD *)unsigned int v50 = bswap32(v53);
  }
  else {
    *(_DWORD *)unsigned int v50 = v53;
  }
  uint64_t v36 = v46;
  uint64_t v35 = v47;
  (*(void (**)(uint64_t, void, void, void, void, uint64_t))(*(void *)v46 + 80))(v46, 0, 0, 0, 0, v45);
  if (v34 <= 0)
  {
    uint64_t v37 = *v35;
    unsigned int v38 = *(_DWORD *)(v37 + 16);
    uint64_t v39 = -2 * a3;
    unsigned int v40 = 1;
    while (1)
    {
      if (v39)
      {
        if (v38 >= v40) {
          int v41 = *(_DWORD *)(*(void *)(v37 + 8) + 8 * v40);
        }
        else {
          int v41 = 0;
        }
        unsigned int v43 = v41 + *(unsigned __int8 *)v15 + 1;
      }
      else
      {
        uint64_t v42 = *(void *)(v37 + 8);
        if (v38 < v40)
        {
          unsigned int v43 = 0;
          goto LABEL_55;
        }
        unsigned int v43 = *(_DWORD *)(v42 + 8 * v40);
      }
      if (v38 < v43)
      {
        if (v40) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
      uint64_t v42 = *(void *)(v37 + 8);
LABEL_55:
      if (*(_DWORD *)(v42 + 8 * v43 + 4) != v40) {
        goto LABEL_58;
      }
      if ((*(_DWORD *)(v42 + 8 * v43) & 0x80000000) != 0)
      {
        __write_base(v37, v43, 0);
        __write_check(v37, v43, 0);
        BOOL v11 = 1;
        goto LABEL_59;
      }
LABEL_57:
      ++v39;
      int v15 = (const unsigned __int16 *)((char *)v15 + 1);
      unsigned int v40 = v43;
      if (v39 == 1) {
        goto LABEL_58;
      }
    }
  }
  uint64_t v54 = 0;
  if ((*(unsigned int (**)(uint64_t, void, void, char *, uint64_t, uint64_t *))(*(void *)v36 + 72))(v36, 0, 0, v50, v52, &v54))
  {
    BOOL v11 = trie_insert_key(*v35, (uint64_t)v15, v44[0], v54) == 0;
  }
  else
  {
LABEL_58:
    BOOL v11 = 0;
  }
LABEL_59:
  free(v50);
  return v11;
}

uint64_t TrieAccessContext::buildWithRecords(TrieAccessContext *this, const __CFArray *a2, const __CFArray *a3, unint64_t *a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](this);
  v8[1034] = *MEMORY[0x1E4F143B8];
  CFArrayGetCount(v5);
  uint64_t result = TrieAccessContext::keyDataHeapContext((TrieAccessContext *)v4);
  if (result)
  {
    if (*(unsigned char *)(v4 + 72))
    {
      v8[0] = 0;
      v8[1] = 0;
      char v7 = 0;
      (*(void (**)(void, void *, char *))(v4 + 168))(*(void *)(v4 + 176), v8, &v7);
      operator new[]();
    }
    return 0;
  }
  return result;
}

uint64_t sortingComparator(const void ***a1, const void ***a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  uint64_t v4 = **a1;
  CFArrayRef v5 = v2[1];
  uint64_t v6 = **a2;
  char v7 = v3[1];
  if ((uint64_t)v5 >= (uint64_t)v7) {
    size_t v8 = (size_t)v3[1];
  }
  else {
    size_t v8 = (size_t)v2[1];
  }
  uint64_t result = memcmp(v4, v6, v8);
  if (!result)
  {
    uint64_t result = (v5 - v7);
    if (v5 == v7) {
      return (*((_DWORD *)v2 + 6) - *((_DWORD *)v3 + 6));
    }
  }
  return result;
}

void TrieAccessContext::addSeriesOfHomographData(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  if (a3 > 0)
  {
    uint64_t v5 = a4;
    uint64_t v6 = 4;
    uint64_t v7 = a3;
    size_t v8 = (uint64_t *)(a5 + 8 * a2);
    do
    {
      uint64_t v9 = *v8++;
      v6 += v5 + CFDataGetLength(*(CFDataRef *)(v9 + 16));
      --v7;
    }
    while (v7);
    operator new[]();
  }
  operator new[]();
}

uint64_t btrie_build(uint64_t a1, uint64_t a2, unsigned __int8 **a3, uint64_t *a4, _DWORD *a5)
{
  unsigned int v63 = 1024;
  size_t v49 = malloc_type_malloc(0x10000uLL, 0xE8DE09A0uLL);
  int v48 = 0;
  bzero(v49, 0x10000uLL);
  size_t __n = 0;
  uint64_t v52 = 0;
  size_t v50 = 0x10000;
  uint64_t v10 = (char *)malloc_type_malloc(0x10000uLL, 0xE8DE09A0uLL);
  __src = v10;
  int v53 = 0;
  bzero(v10, 0x10000uLL);
  size_t v56 = 0;
  size_t v57 = 0;
  unint64_t v11 = *(void *)(a1 + 40);
  size_t size = v11;
  uint64_t v12 = *(void **)(a1 + 8);
  long long v60 = *(_OWORD *)(a1 + 56);
  uint64_t v59 = (_DWORD *)(a1 + 48);
  ptr = v12;
  int v58 = 1;
  bzero(v12, v11);
  long long v46 = xmmword_1D5944E90;
  uint64_t v47 = 0;
  unint64_t v62 = 0x300000000;
  if (a2)
  {
    do
    {
      uint64_t v14 = *a4++;
      int v13 = v14;
      if ((unint64_t)(v14 - 257) < 0xFFFFFFFFFFFFFF00) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v16 = *a3++;
      int v15 = v16;
      LODWORD(v16) = *a5++;
      __btrie_insert_fat((uint64_t)&v46, v62, v15, v13, v16);
      --a2;
    }
    while (a2);
    uint64_t v17 = *((void *)&v46 + 1);
    unint64_t v11 = size;
    uint64_t v10 = (char *)__src;
    uint64_t v18 = v52 & 0xFFFFFFFC;
    size_t v19 = (v56 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  }
  else
  {
    size_t v19 = 0;
    uint64_t v18 = 0;
    uint64_t v17 = 1028;
  }
  *(void *)&long long v46 = v17;
  size_t v50 = v18 + *(unsigned int *)&v10[v18] + 4;
  size_t __n = v50;
  size_t v20 = v19 + 24;
  if (v19 + 24 > v11)
  {
    size_t v45 = v19;
    uint64_t v21 = *((void *)&v60 + 1);
    unsigned int v22 = (char *)ptr;
    uint64_t v23 = v59;
    uint64_t v24 = (uint64_t (*)(char *, size_t, uint64_t))v60;
    unint64_t v25 = size;
    while (1)
    {
      size_t v26 = v25;
      unint64_t v25 = 2 * v11;
      if (!v58) {
        break;
      }
      size_t v27 = 2 * v11;
      if (!v24)
      {
        unsigned int v22 = (char *)malloc_type_realloc(v22, v27, 0x44C5D969uLL);
        *uint64_t v23 = 1;
        uint64_t v29 = &v22[v11];
LABEL_14:
        bzero(v29, v11);
        goto LABEL_15;
      }
      unsigned int v22 = (char *)v24(v22, v27, v21);
LABEL_15:
      v11 *= 2;
      if (v20 <= v25)
      {
        ptr = v22;
        size_t size = v25;
        size_t v19 = v45;
        goto LABEL_17;
      }
    }
    unsigned int v28 = (char *)malloc_type_realloc(v22, 2 * v11, 0x20B045E2uLL);
    unsigned int v22 = v28;
    if (!v28)
    {
      ptr = 0;
      size_t size = v26;
      size_t v19 = -1;
      goto LABEL_18;
    }
    uint64_t v29 = &v28[v11];
    goto LABEL_14;
  }
LABEL_17:
  size_t v56 = v20;
  size_t v57 = v19;
LABEL_18:
  unint64_t v30 = __btrie_build_compact_trie((uint64_t)&v46, v62, (uint64_t)&size, 1);
  size_t v31 = size;
  int v32 = v56;
  size_t v33 = (v56 + 4095) & 0xFFFFFFFFFFFFF000;
  size_t v34 = __n;
  size_t v35 = v33 + __n;
  if (v33 + __n <= size)
  {
    size_t v57 = (v56 + 4095) & 0xFFFFFFFFFFFFF000;
    goto LABEL_29;
  }
  do
  {
    v31 *= 2;
    if (v58)
    {
      if ((void)v60)
      {
        ptr = (void *)((uint64_t (*)(void *, size_t, void))v60)(ptr, v31, *((void *)&v60 + 1));
        goto LABEL_26;
      }
      uint64_t v36 = (char *)malloc_type_realloc(ptr, v31, 0x44C5D969uLL);
      ptr = v36;
      *uint64_t v59 = 1;
    }
    else
    {
      uint64_t v36 = (char *)malloc_type_realloc(ptr, v31, 0x20B045E2uLL);
      ptr = v36;
      if (!v36)
      {
        uint64_t v44 = 0xFFFFFFFFLL;
        goto LABEL_34;
      }
    }
    bzero(&v36[size], v31 - size);
LABEL_26:
    size_t size = v31;
  }
  while (v35 > v31);
  size_t v57 = v33;
  size_t v34 = __n;
LABEL_29:
  size_t v56 = v35;
  memcpy((char *)ptr + v33, __src, v34);
  uint64_t v37 = ptr;
  unsigned int v38 = (char *)ptr + v19;
  int v39 = HIDWORD(v30) + 4 * v30;
  _DWORD *v38 = 1;
  v38[1] = v39;
  v38[2] = v32;
  v38[3] = v33;
  uint64_t v40 = __n;
  v38[4] = __n;
  uint64_t v41 = v63;
  v38[5] = v63;
  *(_DWORD *)a1 = v39;
  *(void *)(a1 + 24) = v40;
  *(void *)(a1 + 32) = v41;
  size_t size = v56;
  if ((void)v60) {
    uint64_t v42 = (char *)((uint64_t (*)(void))v60)();
  }
  else {
    uint64_t v42 = (char *)malloc_type_realloc(v37, v56, 0x2487FC11uLL);
  }
  uint64_t v44 = 0;
  ptr = v42;
  *(void *)(a1 + 8) = v42;
  *(void *)(a1 + 16) = &v42[v33];
LABEL_34:
  if (v49) {
    free(v49);
  }
  if (__src) {
    free(__src);
  }
  return v44;
}

uint64_t TrieAccessContext::createIndexFile(TrieAccessContext *this, IDXIndexInfo *a2)
{
  uint64_t v3 = (const char *)IDXIndexInfo::POSIXPath(this);
  BOOL v4 = IDXIndexInfo::writable(this);
  int v5 = openRawIndexFile(v3, v4, 1);
  if (v5 != -1)
  {
    int v6 = v5;
    if (lseek(v5, 4159, 0) != -1 && write(v6, "", 1uLL) == 1)
    {
      close(v6);
      TrieAccessContext::createIndexInfoForHeapAccess(this, v7);
    }
    close(v6);
    uint64_t v9 = (const std::__fs::filesystem::path *)IDXIndexInfo::POSIXPath(this);
    remove(v9, v10);
  }
  return 0;
}

void sub_1D59255AC(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

void TrieAccessContext::createIndexInfoForHeapAccess(TrieAccessContext *this, IDXIndexInfo *a2)
{
  CFDictionaryRef v3 = IDXIndexInfo::optionalProperty(this, @"TrieAuxiliaryDataOptions");
  if (v3)
  {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v3);
    CFMutableDataRef Mutable = MutableCopy;
    BOOL v6 = MutableCopy == 0;
    if (MutableCopy)
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(MutableCopy, @"IDXIndexPath");
      if (Value
        || (CFStringRef Value = (const __CFString *)IDXIndexInfo::optionalProperty(this, @"TrieAuxiliaryDataFile")) != 0)
      {
        CFStringRef v8 = Value;
        BOOL v6 = 1;
        goto LABEL_12;
      }
LABEL_18:
      CFDictionaryRef v25 = IDXIndexInfo::optionalProperty(this, @"TrieSubIndexPath");
      if (v25)
      {
        CFStringRef v8 = (CFStringRef)v25;
        BOOL v6 = 1;
        if (!Mutable) {
          goto LABEL_11;
        }
LABEL_12:
        CFDictionarySetValue(Mutable, @"IDXIndexAccessMethod", @"com.apple.HeapAccessMethod");
        CFStringRef v11 = (const __CFString *)IDXIndexInfo::relativePath(this);
        if (CFStringFind(v11, @"/", 0).location == -1)
        {
          uint64_t v17 = (__CFString *)CFRetain(v8);
        }
        else
        {
          CFStringRef v12 = (const __CFString *)IDXIndexInfo::relativePath(this);
          unint64_t v13 = (unint64_t)CFStringFind(v12, @"/", 4uLL).location + 1;
          CFStringRef v14 = (const __CFString *)IDXIndexInfo::relativePath(this);
          CFIndex v15 = CFStringGetLength(v14) - v13;
          CFStringRef v16 = (const __CFString *)IDXIndexInfo::relativePath(this);
          uint64_t v17 = CFStringCreateMutableCopy(0, 0, v16);
          v29.CFIndex location = v13;
          v29.int64_t length = v15;
          CFStringDelete(v17, v29);
          CFStringAppend(v17, v8);
        }
        CFDictionarySetValue(Mutable, @"IDXIndexPath", v17);
        if (!v6) {
          CFRelease(v8);
        }
        CFDictionarySetValue(Mutable, @"IDXIndexSupportDataID", (const void *)*MEMORY[0x1E4F1CFD0]);
        CFDictionaryRef v18 = IDXIndexInfo::optionalProperty(this, @"IDXIndexWritable");
        CFDictionarySetValue(Mutable, @"IDXIndexWritable", v18);
        CFDictionaryRef v19 = IDXIndexInfo::optionalProperty(this, @"IDXIndexBigEndian");
        CFDictionarySetValue(Mutable, @"IDXIndexBigEndian", v19);
        CFDictionaryRef FieldForHeapAccess = TrieAccessContext::createFieldForHeapAccess(v20);
        CFDictionarySetValue(Mutable, @"IDXIndexDataFields", FieldForHeapAccess);
        CFRelease(FieldForHeapAccess);
        CFStringRef v22 = CFURLCopyFileSystemPath(*(CFURLRef *)this, kCFURLPOSIXPathStyle);
        CFMutableStringRef v23 = CFStringCreateMutableCopy(0, 0, v22);
        CFRelease(v22);
        CFStringRef v24 = (const __CFString *)IDXIndexInfo::relativePath(this);
        CFStringTrim(v23, v24);
        CFStringAppend(v23, v17);
        CFURLCreateWithFileSystemPath(0, v23, kCFURLPOSIXPathStyle, 0);
        CFRelease(v23);
        CFRelease(v17);
        operator new();
      }
      goto LABEL_22;
    }
    CFDictionaryRef v9 = IDXIndexInfo::optionalProperty(this, @"TrieAuxiliaryDataFile");
    if (!v9) {
      goto LABEL_18;
    }
  }
  else
  {
    CFDictionaryRef v9 = IDXIndexInfo::optionalProperty(this, @"TrieAuxiliaryDataFile");
    if (!v9)
    {
      CFDictionaryRef v10 = IDXIndexInfo::optionalProperty(this, @"TrieSubIndexPath");
      BOOL v6 = 1;
      if (v10)
      {
        CFStringRef v8 = (CFStringRef)v10;
        goto LABEL_11;
      }
      CFMutableDataRef Mutable = 0;
LABEL_22:
      BOOL v26 = v6;
      CFURLRef v27 = CFURLCreateCopyDeletingPathExtension(0, *(CFURLRef *)this);
      CFStringRef PathComponent = CFURLCopyLastPathComponent(v27);
      CFRelease(v27);
      CFStringRef v8 = CFStringCreateWithFormat(0, 0, @"%@_aux.data", PathComponent);
      CFRelease(PathComponent);
      BOOL v6 = 0;
      if (!v26) {
        goto LABEL_12;
      }
LABEL_11:
      CFMutableDataRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      goto LABEL_12;
    }
  }
  CFStringRef v8 = (CFStringRef)v9;
  BOOL v6 = 1;
  goto LABEL_11;
}

void sub_1D5925978(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

uint64_t TrieAccessContext::initializeSubclass(TrieAccessContext *this, int a2, void **a3)
{
  if (*((unsigned __int16 *)this + 37) > 2u || *((_WORD *)this + 37) && *((unsigned char *)this + 73)) {
    return 0;
  }
  if (a2)
  {
    unint64_t v15 = 0;
    BOOL v4 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
    int v5 = openRawIndexFile(v4, *((unsigned __int8 *)this + 72), 0);
    if (v5 != -1)
    {
      int v6 = v5;
      uint64_t v7 = mapIndexFile(v5, *((unsigned __int8 *)this + 72), (off_t *)&v15);
      close(v6);
      if (v7 != -1)
      {
        *((void *)this + 8) = malloc_type_malloc(0x20uLL, 0x80040B8603338uLL);
        CFStringRef v8 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
        size_t v9 = strlen(v8) + 1;
        CFDictionaryRef v10 = (char *)malloc_type_malloc(v9, 0x4800EB06uLL);
        CFStringRef v11 = (const char *)IDXIndexInfo::POSIXPath(*((IDXIndexInfo **)this + 1));
        strlcpy(v10, v11, v9);
        TrieAccessContext::createIndexInfoForHeapAccess(*((TrieAccessContext **)this + 1), v12);
      }
    }
    return 0;
  }
  uint64_t v14 = (uint64_t)*a3;
  *((void *)this + 8) = *a3;
  *((void *)this + 3) = *(void *)(v14 + 8);
  *((void *)this + 4) = *(void *)(v14 + 24);
  return 1;
}

void TrieAccessContext::finalizeSubclass(TrieAccessContext *this, int a2)
{
  BOOL v4 = (IDXAccessContext *)*((void *)this + 5);
  if (v4)
  {
    IDXAccessContext::finalize(v4);
    uint64_t v5 = *((void *)this + 5);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    *((void *)this + 5) = 0;
  }
  if (a2)
  {
    size_t v10 = 0;
    if (*((_WORD *)this + 37) == 1)
    {
      int v6 = (void *)*((void *)this + 3);
      uint64_t v7 = (char *)v6[1];
      if (*((_DWORD *)v6 + 12)) {
LABEL_15:
      }
        free(v7);
    }
    else
    {
      if (*((_WORD *)this + 37))
      {
        uint64_t v7 = (char *)mtrie_data(*((unsigned int **)this + 3), &v10);
        mtrie_close(*((void **)this + 3));
        goto LABEL_18;
      }
      int v6 = (void *)*((void *)this + 3);
      uint64_t v7 = (char *)*v6;
      if (*((_DWORD *)v6 + 20)) {
        BOOL v8 = v7 == 0;
      }
      else {
        BOOL v8 = 1;
      }
      if (!v8) {
        goto LABEL_15;
      }
    }
    free(v6);
LABEL_18:
    size_t v10 = *(void *)(*((void *)this + 8) + 16);
    unmapIndexFile(v7 - 64, v10);
    uint64_t v9 = *((void *)this + 4);
    if (v9)
    {
      IDXIndexInfo::~IDXIndexInfo(*((IDXIndexInfo **)this + 4));
      MEMORY[0x1D94553C0](v9, 0x1070C4063F6B07ELL);
    }
    free(**((void ***)this + 8));
    free(*((void **)this + 8));
  }
}

void sub_1D5925E28(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x1070C4063F6B07ELL);
  _Unwind_Resume(a1);
}

CFDictionaryRef TrieAccessContext::createFieldForHeapAccess(TrieAccessContext *this)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"IDXDataFieldName";
  keys[1] = @"IDXDataSizeLength";
  __int16 valuePtr = 4;
  values = @"Packed Homograph";
  CFTypeRef cf = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  uint64_t v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFTypeRef v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(cf);
  CFArrayRef v3 = CFArrayCreate(0, &v6, 1, MEMORY[0x1E4F1D510]);
  CFRelease(v6);
  keys[0] = @"IDXVariableDataFields";
  values = v3;
  CFDictionaryRef v4 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, v1, v2);
  CFRelease(v3);
  return v4;
}

uint64_t TrieAccessContext::getDataPtrByID(TrieAccessContext *this, unint64_t a2, uint64_t *a3)
{
  return 0;
}

uint64_t TrieAccessContext::getDataByID(TrieAccessContext *this, unint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  return 0;
}

uint64_t __search_node_tree(uint64_t a1, unint64_t a2, void *a3, unint64_t *a4, uint64_t a5, unsigned int a6)
{
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *(unsigned int *)(v12 + 8 * a6);
  if (*(_DWORD *)(v12 + 8 * v13 + 4) == a6)
  {
    int v14 = *(_DWORD *)(v12 + 8 * v13);
    if (v14 < 0)
    {
      if (*a3)
      {
        --*a3;
      }
      else if (a2)
      {
        unint64_t v18 = *a4;
        unint64_t v19 = *a4 + 1;
        *a4 = v19;
        *(_DWORD *)(a5 + 4 * v18) = -v14;
        if (v19 >= a2) {
          return 1;
        }
      }
      else
      {
        ++*a4;
      }
    }
  }
  uint64_t v15 = (v13 + 1);
  int v16 = 257;
  while (*(_DWORD *)(*(void *)(a1 + 8) + 8 * v15 + 4) != a6
       || !__search_node_tree(a1, a2, a3, a4, a5, v15))
  {
    uint64_t v15 = (v15 + 1);
    if (--v16 <= 1) {
      return 0;
    }
  }
  return 1;
}

BOOL __btrie_find_prefix(uint64_t a1, int a2, unsigned __int8 *a3, unsigned int a4, void *a5, unint64_t a6, unint64_t *a7, uint64_t a8, uint8x8_t a9)
{
  int v16 = a2 & 3;
  switch(v16)
  {
    case 1:
      CFMutableStringRef v23 = (unsigned int *)(*(void *)(a1 + 16) + (a2 - 1));
      if (!a4)
      {
        unsigned int v44 = v23[1];
        if (v44)
        {
          if (*a5)
          {
            --*a5;
          }
          else
          {
            unint64_t v60 = *a7;
            unint64_t v61 = *a7 + 1;
            *a7 = v61;
            if (a6)
            {
              *(_DWORD *)(a8 + 4 * v60) = v44;
              if (v61 >= a6) {
                return 1;
              }
            }
          }
        }
      }
      CFStringRef v24 = (char *)(v23 + 2);
      unint64_t v25 = (unint64_t)v23 + *v23 + 4;
      if ((unint64_t)(v23 + 2) < v25)
      {
        do
        {
          unsigned int v28 = *v24;
          BOOL v26 = v24 + 1;
          uint64_t v27 = v28;
          if (v28 >= a4)
          {
            int v29 = memcmp(v26, a3, (int)a4);
            if (v29 > 0) {
              return 0;
            }
            if (!v29)
            {
              if (*a5)
              {
                --*a5;
              }
              else if (a6)
              {
                int v30 = *(_DWORD *)&v26[v27];
                unint64_t v31 = *a7;
                unint64_t v32 = *a7 + 1;
                *a7 = v32;
                *(_DWORD *)(a8 + 4 * v31) = v30;
                if (v32 >= a6) {
                  return 1;
                }
              }
              else
              {
                ++*a7;
              }
            }
          }
          CFStringRef v24 = &v26[v27 + 4];
        }
        while ((unint64_t)v24 < v25);
      }
      return 0;
    case 2:
      uint64_t v33 = *(void *)(a1 + 8);
      uint64_t v34 = (a2 - 2);
      size_t v35 = (int *)(v33 + v34);
      if (!a4)
      {
        int v45 = *v35;
        if (*v35)
        {
          if (*a5)
          {
            --*a5;
          }
          else
          {
            unint64_t v62 = *a7;
            unint64_t v63 = *a7 + 1;
            *a7 = v63;
            if (a6)
            {
              *(_DWORD *)(a8 + 4 * v62) = v45;
              if (v63 >= a6) {
                return 1;
              }
            }
          }
        }
        unint64_t v46 = 0;
        uint64_t v47 = v34 + v33 + 4;
        while (1)
        {
          uint64_t v48 = v46 >> 5 <= 1 ? 1 : v46 >> 5;
          unsigned int v49 = v35[(v46 >> 5) + 1];
          if ((v49 >> v46))
          {
            if ((v46 & 0xE0) != 0)
            {
              int v50 = 0;
              BOOL v51 = (unsigned int *)v47;
              do
              {
                unsigned int v52 = *v51++;
                a9 = (uint8x8_t)vcnt_s8((int8x8_t)v52);
                a9.i16[0] = vaddlv_u8(a9);
                v50 += a9.i32[0];
                --v48;
              }
              while (v48);
            }
            else
            {
              int v50 = 0;
            }
            a9.i32[0] = v49 & ~(-1 << (v46 & 0x1F));
            uint8x8_t v53 = (uint8x8_t)vcnt_s8((int8x8_t)a9);
            v53.i16[0] = vaddlv_u8(v53);
            if (__btrie_find_prefix(a1, v35[v50 + v53.i32[0] + 10], a3, 0, a5, a6, a7, a8))break; {
          }
            }
          if (++v46 == 256) {
            return 0;
          }
        }
        return 1;
      }
      unint64_t v36 = *a3;
      uint64_t v37 = v36 >> 5;
      unsigned int v38 = v35[(v36 >> 5) + 1];
      if (((v38 >> v36) & 1) == 0) {
        return 0;
      }
      char v39 = v36 & 0x1F;
      if (v36 >= 0x20)
      {
        int v40 = 0;
        if (v37 <= 1) {
          uint64_t v37 = 1;
        }
        else {
          uint64_t v37 = v37;
        }
        uint64_t v54 = (unsigned int *)(v34 + v33 + 4);
        do
        {
          unsigned int v55 = *v54++;
          a9 = (uint8x8_t)vcnt_s8((int8x8_t)v55);
          a9.i16[0] = vaddlv_u8(a9);
          v40 += a9.i32[0];
          --v37;
        }
        while (v37);
      }
      else
      {
        int v40 = 0;
      }
      a9.i32[0] = v38 & ~(-1 << v39);
      uint8x8_t v56 = (uint8x8_t)vcnt_s8((int8x8_t)a9);
      v56.i16[0] = vaddlv_u8(v56);
      uint64_t v20 = v35[v40 + v56.i32[0] + 10];
      CFStringRef v22 = a3 + 1;
      uint64_t v21 = a4 - 1;
      break;
    case 3:
      uint64_t v17 = *(void *)(a1 + 8);
      uint64_t v18 = (a2 - 3);
      unint64_t v19 = (int *)(v17 + v18);
      if (!a4)
      {
        int v41 = *v19;
        if (v41)
        {
          if (*a5)
          {
            --*a5;
          }
          else
          {
            unint64_t v58 = *a7;
            unint64_t v59 = *a7 + 1;
            *a7 = v59;
            if (a6)
            {
              *(_DWORD *)(a8 + 4 * v58) = v41;
              if (v59 >= a6) {
                return 1;
              }
            }
          }
        }
        uint64_t v42 = 0;
        uint64_t v43 = v18 + v17 + 4;
        while (!__btrie_find_prefix(a1, *(unsigned int *)(v43 + v42), a3, 0, a5, a6, a7, a8))
        {
          v42 += 4;
          if (v42 == 1024) {
            return 0;
          }
        }
        return 1;
      }
      uint64_t v20 = v19[*a3 + 1];
      uint64_t v21 = a4 - 1;
      CFStringRef v22 = a3 + 1;
      break;
    default:
      return 0;
  }
  return __btrie_find_prefix(a1, v20, v22, v21, a5, a6, a7, a8) != 0;
}

uint64_t __wildcard_match_str(uint64_t a1, unint64_t a2, void *a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10)
{
  if (!a8)
  {
    uint64_t v16 = *(void *)(a1 + 8);
    goto LABEL_32;
  }
  uint64_t v12 = 0;
  uint64_t v13 = a10;
  while (1)
  {
    if (a10 == 1)
    {
      int v15 = *(unsigned __int8 *)(a7 + v12);
      goto LABEL_12;
    }
    if (a10 == 2 && (v12 & 1) == 0)
    {
      int v14 = *(unsigned __int8 *)(a7 + v12);
      if (a9)
      {
        if (v14 == 63)
        {
          if (!*(unsigned char *)(a7 + v12 + 1)) {
            goto LABEL_20;
          }
        }
        else if (v14 == 42 && !*(unsigned char *)(a7 + v12 + 1))
        {
LABEL_38:
          uint64_t v28 = a7 + v13;
          uint64_t v29 = a8 - v13;
          return __wildcard_asterisk(a1, a2, (uint64_t)a3, (uint64_t)a4, a5, a6, v28, v29, a9, a10);
        }
        goto LABEL_14;
      }
      if (!*(unsigned char *)(a7 + v12)) {
        break;
      }
    }
LABEL_14:
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v17 = *(_DWORD *)(v16 + 8 * a6) + *(unsigned __int8 *)(a7 + v12) + 1;
    if (*(_DWORD *)(v16 + 8 * v17 + 4) != a6) {
      return 0;
    }
    ++v12;
    ++v13;
    a6 = v17;
    if (a8 == v12)
    {
      LODWORD(a6) = v17;
LABEL_32:
      uint64_t v25 = *(unsigned int *)(v16 + 8 * a6);
      if (*(_DWORD *)(v16 + 8 * v25 + 4) == a6)
      {
        int v26 = *(_DWORD *)(v16 + 8 * v25);
        if (v26 < 0)
        {
          if (*a3)
          {
            --*a3;
          }
          else if (a2)
          {
            unint64_t v30 = *a4;
            unint64_t v31 = *a4 + 1;
            *a4 = v31;
            *(_DWORD *)(a5 + 4 * v30) = -v26;
            if (v31 >= a2) {
              return 1;
            }
          }
          else
          {
            ++*a4;
          }
        }
      }
      return 0;
    }
  }
  int v15 = *(unsigned __int8 *)(a7 + v12 + 1);
LABEL_12:
  if (v15 == 42) {
    goto LABEL_38;
  }
  if (!(2 * (v15 == 63))) {
    goto LABEL_14;
  }
LABEL_20:
  int v18 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * a6);
  int v19 = 256;
  while (1)
  {
    uint64_t v20 = (_DWORD *)(*(void *)(a1 + 8) + 8 * ++v18);
    if (v20[1] == a6) {
      break;
    }
LABEL_29:
    BOOL v24 = v19-- != 0;
    if (v19 == 0 || !v24) {
      return 0;
    }
  }
  if (a10 != 2)
  {
    uint64_t v21 = 1;
    if (__wildcard_match_str(a1)) {
      return v21;
    }
    goto LABEL_29;
  }
  unsigned int v22 = *v20 + 1;
  int v23 = 257;
  while (*(_DWORD *)(*(void *)(a1 + 8) + 8 * v22 + 4) != v18 || !__wildcard_match_str(a1))
  {
    ++v22;
    if (--v23 <= 1) {
      goto LABEL_29;
    }
  }
  return 1;
}

uint64_t __wildcard_asterisk(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, int a10)
{
  if (!__wildcard_match_str(a1))
  {
    uint64_t v27 = a5;
    uint64_t v28 = a7;
    uint64_t v29 = a8;
    LODWORD(v20) = *(_DWORD *)(*(void *)(a1 + 8) + 8 * a6);
    int v21 = 256;
    while (1)
    {
      uint64_t v20 = (v20 + 1);
      unsigned int v22 = (_DWORD *)(*(void *)(a1 + 8) + 8 * v20);
      uint64_t v23 = a6;
      if (v22[1] == a6)
      {
        if (a10 == 2)
        {
          uint64_t v24 = (*v22 + 1);
          int v25 = 257;
          while (*(_DWORD *)(*(void *)(a1 + 8) + 8 * v24 + 4) != v20
               || !__wildcard_asterisk(a1, a2, a3, a4, v27, v24, v28, v29, a9 | 0x200000000))
          {
            uint64_t v24 = (v24 + 1);
            if (--v25 <= 1) {
              goto LABEL_14;
            }
          }
          return 1;
        }
        if (a10 == 1)
        {
          uint64_t v18 = 1;
          if (__wildcard_asterisk(a1, a2, a3, a4, v27, v20, v28, v29, a9 | 0x100000000)) {
            return v18;
          }
        }
      }
LABEL_14:
      BOOL v26 = v21-- != 0;
      a6 = v23;
      if (v21 == 0 || !v26) {
        return 0;
      }
    }
  }
  return 1;
}

uint64_t __btrie_wildcard_match(uint64_t a1, uint64_t a2, unint64_t *a3, unsigned char *a4, int a5, unsigned int a6, void *a7, unint64_t a8, uint8x8_t a9, uint64_t a10, int a11, int a12)
{
  uint64_t v15 = a10;
  int v16 = a2 & 3;
  if (v16 == 1)
  {
    int v19 = (unsigned int *)(*(void *)(a1 + 16) + (a2 - 1));
    if (!a5) {
      goto LABEL_29;
    }
    if (a5 == 2 && a6 == 2)
    {
      int v20 = *(unsigned __int16 *)a4;
    }
    else
    {
      if (a5 != 1 || a6 != 1) {
        goto LABEL_32;
      }
      int v20 = *a4;
    }
    if (v20 == 42)
    {
LABEL_29:
      unsigned int v26 = v19[1];
      if (v26)
      {
        if (*a7)
        {
          --*a7;
        }
        else
        {
          unint64_t v80 = *a3;
          unint64_t v81 = *a3 + 1;
          *a3 = v81;
          if (a8)
          {
            *(_DWORD *)(a10 + 4 * v80) = v26;
            if (v81 >= a8) {
              return 1;
            }
          }
        }
      }
    }
LABEL_32:
    if (a12) {
      unsigned int v27 = a6;
    }
    else {
      unsigned int v27 = 0;
    }
    if (a12) {
      uint64_t v28 = -(uint64_t)(int)a6;
    }
    else {
      uint64_t v28 = 0;
    }
    unsigned int v29 = v27 + a5;
    if (!(v27 + a5)) {
      return 0;
    }
    unint64_t v30 = (unsigned __int8 *)(v19 + 2);
    unint64_t v31 = (unint64_t)v19 + *v19 + 4;
    if ((unint64_t)(v19 + 2) >= v31) {
      return 0;
    }
    uint64_t v33 = &a4[v28];
    uint64_t v34 = &a4[v28 + (v29 & 0xFFFFFFFE)];
    size_t v35 = (const unsigned __int16 *)&a4[v28 + 1];
    uint64_t v36 = (v29 - 1) >> 1;
    uint64_t v37 = &a4[v28 + v29];
    while (1)
    {
      char v39 = v30 + 1;
      uint64_t v38 = *v30;
      if (a6 != 2)
      {
        if (a6 != 1) {
          goto LABEL_146;
        }
        int v40 = &v39[v38];
        int v41 = v33;
        uint64_t v42 = v39;
        if (v38)
        {
          uint64_t v42 = v39;
          int v41 = v33;
          do
          {
            int v43 = *v41;
            if (v43 == 42) {
              break;
            }
            if (v43 != 63 && v43 != *v42) {
              goto LABEL_146;
            }
            ++v41;
            ++v42;
          }
          while (v42 < v40);
        }
        if (v42 < v40)
        {
          int v45 = 0;
          unint64_t v46 = 0;
          do
          {
            if (v41 >= v37) {
              goto LABEL_64;
            }
            int v47 = *v41;
            if (v47 == 42)
            {
              if (++v41 == v37) {
                goto LABEL_134;
              }
              unint64_t v46 = v42 + 1;
              int v45 = v41;
              continue;
            }
            if (v47 == 63 || v47 == *v42)
            {
              ++v41;
              ++v42;
            }
            else
            {
LABEL_64:
              uint64_t v42 = v46++;
              int v41 = v45;
            }
          }
          while (v42 < v40);
        }
        if (v41 < v37)
        {
          uint64_t v49 = v37 - v41;
          while (*v41 == 42)
          {
            ++v41;
            if (!--v49)
            {
              int v41 = v37;
              break;
            }
          }
        }
        BOOL v50 = v41 == v37;
        goto LABEL_130;
      }
      if (a11)
      {
        if (v29 < 2 || (v38 & 1) == 0) {
          goto LABEL_146;
        }
        BOOL v51 = (unsigned __int16 *)(v30 + 2);
        unint64_t v52 = (unint64_t)&v30[((v38 - 1) & 0xFFFFFFFE) + 2];
        uint8x8_t v53 = v33;
        if ((v38 - 1) >= 2)
        {
          do
          {
            int v54 = (unsigned __int16)*v53;
            if (v54 == 42) {
              break;
            }
            if (v54 != 63 && v54 != *v51) {
              goto LABEL_146;
            }
            ++v53;
            ++v51;
          }
          while ((unint64_t)v51 < v52);
        }
        if ((unint64_t)v51 < v52)
        {
          uint8x8_t v56 = 0;
          size_t v57 = 0;
          do
          {
            if (v53 >= v34) {
              goto LABEL_95;
            }
            int v58 = (unsigned __int16)*v53;
            if (v58 == 42)
            {
              if (++v53 == v34) {
                goto LABEL_134;
              }
              size_t v57 = v51 + 1;
              uint8x8_t v56 = v53;
              continue;
            }
            if (v58 == 63 || v58 == *v51)
            {
              ++v53;
              ++v51;
            }
            else
            {
LABEL_95:
              BOOL v51 = v57++;
              uint8x8_t v53 = v56;
            }
          }
          while ((unint64_t)v51 < v52);
        }
        while (v53 < v34 && *v53 == 42)
          ++v53;
LABEL_129:
        BOOL v50 = v53 == v34;
LABEL_130:
        if (v50) {
          goto LABEL_134;
        }
        goto LABEL_146;
      }
      if ((v29 & 1) == 0) {
        break;
      }
      if ((v38 & 1) != 0 && *v33 == *v39)
      {
        if (v29 == 1 && v38 == 1) {
          goto LABEL_134;
        }
        unint64_t v87 = a8;
        uint64_t v88 = v36;
        uint64_t v86 = v15;
        unint64_t v85 = v35;
        BOOL v72 = __btrie_wildcardmatch_uint16(v35, v36, (const unsigned __int16 *)v30 + 1, (v38 - 1) >> 1);
        a8 = v87;
        uint64_t v36 = v88;
        size_t v35 = v85;
        a11 = 0;
        uint64_t v15 = v86;
        if (v72)
        {
LABEL_134:
          if (*a7)
          {
            --*a7;
          }
          else if (a8)
          {
            int v69 = *(_DWORD *)&v39[v38];
            unint64_t v70 = *a3;
            unint64_t v71 = *a3 + 1;
            *a3 = v71;
            *(_DWORD *)(v15 + 4 * v70) = v69;
            if (v71 >= a8) {
              return 1;
            }
          }
          else
          {
            ++*a3;
          }
        }
      }
LABEL_146:
      unint64_t v30 = &v39[v38 + 4];
      if ((unint64_t)v30 >= v31) {
        return 0;
      }
    }
    if (v29 < 2 || (v38 & 1) != 0) {
      goto LABEL_146;
    }
    unint64_t v60 = &v39[v38 & 0xFE];
    uint8x8_t v53 = v33;
    unint64_t v61 = (unsigned __int16 *)v39;
    if (v38 >= 2)
    {
      unint64_t v61 = (unsigned __int16 *)v39;
      uint8x8_t v53 = v33;
      do
      {
        int v62 = (unsigned __int16)*v53;
        if (v62 == 42) {
          break;
        }
        if (v62 != 63 && v62 != *v61) {
          goto LABEL_146;
        }
        ++v53;
        ++v61;
      }
      while (v61 < (unsigned __int16 *)v60);
    }
    if (v61 >= (unsigned __int16 *)v60)
    {
LABEL_126:
      while (v53 < v34 && *v53 == 42)
        ++v53;
      goto LABEL_129;
    }
    int v64 = 0;
    uint64_t v65 = 0;
    while (1)
    {
      if (v53 >= v34) {
        goto LABEL_124;
      }
      int v66 = (unsigned __int16)*v53;
      if (v66 == 42)
      {
        if (++v53 == v34) {
          goto LABEL_134;
        }
        uint64_t v65 = v61 + 1;
        int v64 = v53;
        goto LABEL_125;
      }
      if (v66 == 63 || v66 == *v61)
      {
        ++v53;
        ++v61;
      }
      else
      {
LABEL_124:
        unint64_t v61 = v65++;
        uint8x8_t v53 = v64;
      }
LABEL_125:
      if (v61 >= (unsigned __int16 *)v60) {
        goto LABEL_126;
      }
    }
  }
  if (v16 != 2)
  {
    if (v16 == 3)
    {
      uint64_t v17 = (int *)(*(void *)(a1 + 8) + (a2 - 3));
      if (a5)
      {
        if (a5 == 1 || a6 != 2)
        {
          int v18 = *a4;
          if (a6 == 1)
          {
LABEL_22:
            if (v18 != 42)
            {
              if (!(2 * (v18 == 63))) {
                goto LABEL_155;
              }
              return __btrie_wildcard_questionmark_search(a1, a2, a9, (uint64_t)a3, (uint64_t)&a4[a6], a5 - a6, a6);
            }
            return __btrie_wildcard_asterisk_search(a1, a2, (uint64_t)a3, (uint64_t)&a4[a6], a5 - a6, a6, (uint64_t)a7, a8, a10);
          }
        }
        else
        {
          if ((a5 & 1) == 0)
          {
            int v18 = *(unsigned __int16 *)a4;
            goto LABEL_22;
          }
          LOBYTE(v18) = *a4;
        }
LABEL_155:
        uint64_t v75 = v17[v18 + 1];
        goto LABEL_173;
      }
      goto LABEL_18;
    }
    return 0;
  }
  uint64_t v21 = *(void *)(a1 + 8);
  uint64_t v22 = (a2 - 2);
  uint64_t v17 = (int *)(v21 + v22);
  if (!a5)
  {
LABEL_18:
    int v24 = *v17;
    if (*v17)
    {
      if (*a7)
      {
        uint64_t result = 0;
        --*a7;
        return result;
      }
      unint64_t v73 = *a3;
      unint64_t v74 = *a3 + 1;
      *a3 = v74;
      if (a8)
      {
        *(_DWORD *)(a10 + 4 * v73) = v24;
        if (v74 >= a8) {
          return 1;
        }
      }
    }
    return 0;
  }
  if (a5 == 1 || a6 != 2)
  {
    int v23 = *a4;
    if (a6 != 1) {
      goto LABEL_159;
    }
  }
  else
  {
    if (a5)
    {
      LOBYTE(v23) = *a4;
      goto LABEL_159;
    }
    int v23 = *(unsigned __int16 *)a4;
  }
  if (v23 == 42) {
    return __btrie_wildcard_asterisk_search(a1, a2, (uint64_t)a3, (uint64_t)&a4[a6], a5 - a6, a6, (uint64_t)a7, a8, a10);
  }
  if (2 * (v23 == 63)) {
    return __btrie_wildcard_questionmark_search(a1, a2, a9, (uint64_t)a3, (uint64_t)&a4[a6], a5 - a6, a6);
  }
LABEL_159:
  LODWORD(v76) = v23 >> 5;
  unsigned int v77 = v17[(v23 >> 5) + 1];
  if (((v77 >> v23) & 1) == 0) {
    return 0;
  }
  char v78 = v23 & 0x1F;
  if (v23 >= 0x20u)
  {
    int v79 = 0;
    if (v76 <= 1) {
      uint64_t v76 = 1;
    }
    else {
      uint64_t v76 = v76;
    }
    CFStringRef v82 = (unsigned int *)(v22 + v21 + 4);
    do
    {
      unsigned int v83 = *v82++;
      a9 = (uint8x8_t)vcnt_s8((int8x8_t)v83);
      a9.i16[0] = vaddlv_u8(a9);
      v79 += a9.i32[0];
      --v76;
    }
    while (v76);
  }
  else
  {
    int v79 = 0;
  }
  a9.i32[0] = v77 & ~(-1 << v78);
  uint8x8_t v84 = (uint8x8_t)vcnt_s8((int8x8_t)a9);
  v84.i16[0] = vaddlv_u8(v84);
  uint64_t v75 = v17[v79 + v84.i32[0] + 10];
LABEL_173:
  uint64_t result = __btrie_wildcard_match(a1, v75);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t __btrie_wildcard_asterisk_search(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v15 = a2;
  uint64_t v17 = 1;
  HIDWORD(v60) = 1;
  if (__btrie_wildcard_match(a1, a2)) {
    return v17;
  }
  int v61 = a6;
  if ((v15 & 3) == 2)
  {
    unint64_t v34 = 0;
    uint64_t v63 = *(void *)(a1 + 8) + (v15 - 2);
    while (1)
    {
      if (v34 >> 5 <= 1) {
        uint64_t v35 = 1;
      }
      else {
        uint64_t v35 = v34 >> 5;
      }
      unsigned int v36 = *(_DWORD *)(v63 + 4 * (v34 >> 5) + 4);
      if ((v36 >> v34))
      {
        char v37 = v34 & 0x1F;
        if (v61 == 2)
        {
          if (v34 >= 0x20)
          {
            int v39 = 0;
            unsigned int v44 = (unsigned int *)(v63 + 4);
            do
            {
              unsigned int v45 = *v44++;
              int8x8_t v18 = vcnt_s8((int8x8_t)v45);
              v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
              v39 += v18.i32[0];
              --v35;
            }
            while (v35);
          }
          else
          {
            int v39 = 0;
          }
          v18.i32[0] = v36 & ~(-1 << v37);
          int8x8_t v18 = vcnt_s8(v18);
          v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
          uint64_t v46 = *(unsigned int *)(v63 + 4 * (v39 + v18.i32[0]) + 40);
          int v47 = *(_DWORD *)(v63 + 4 * (v39 + v18.i32[0]) + 40) & 3;
          switch(v47)
          {
            case 1:
              uint64_t v17 = 1;
              LODWORD(v60) = 1;
              int v43 = __btrie_wildcard_asterisk_search(a1, v46, a3, a4, a5, 2, a7, a8, a9, v60);
              goto LABEL_58;
            case 2:
              unint64_t v51 = 0;
              uint64_t v52 = *(void *)(a1 + 8) + (v46 - 2);
              do
              {
                if (v51 >> 5 <= 1) {
                  uint64_t v53 = 1;
                }
                else {
                  uint64_t v53 = v51 >> 5;
                }
                unsigned int v54 = *(_DWORD *)(v52 + 4 * (v51 >> 5) + 4);
                if ((v54 >> v51))
                {
                  if ((v51 & 0xE0) != 0)
                  {
                    int v55 = 0;
                    uint8x8_t v56 = (unsigned int *)(v52 + 4);
                    do
                    {
                      unsigned int v57 = *v56++;
                      int8x8_t v18 = vcnt_s8((int8x8_t)v57);
                      v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
                      v55 += v18.i32[0];
                      --v53;
                    }
                    while (v53);
                  }
                  else
                  {
                    int v55 = 0;
                  }
                  v18.i32[0] = v54 & ~(-1 << (v51 & 0x1F));
                  uint8x8_t v58 = (uint8x8_t)vcnt_s8(v18);
                  v58.i16[0] = vaddlv_u8(v58);
                  LODWORD(v60) = 0;
                  if (__btrie_wildcard_asterisk_search(a1, *(unsigned int *)(v52 + 4 * (v55 + v58.i32[0]) + 40), a3, a4, a5, 2, a7, a8, a9, v60))return 1; {
                }
                  }
                ++v51;
              }
              while (v51 != 256);
              break;
            case 3:
              uint64_t v48 = 0;
              uint64_t v49 = *(void *)(a1 + 8) + (v46 - 3) + 4;
              do
              {
                uint64_t v50 = *(unsigned int *)(v49 + v48);
                if ((v50 & 3) != 0)
                {
                  LODWORD(v60) = 0;
                  if (__btrie_wildcard_asterisk_search(a1, v50, a3, a4, a5, 2, a7, a8, a9, v60)) {
                    return 1;
                  }
                }
                v48 += 4;
              }
              while (v48 != 1024);
              break;
          }
        }
        else if (v61 == 1)
        {
          if (v34 >= 0x20)
          {
            int v38 = 0;
            int v40 = (unsigned int *)(v63 + 4);
            do
            {
              unsigned int v41 = *v40++;
              int8x8_t v18 = vcnt_s8((int8x8_t)v41);
              v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
              v38 += v18.i32[0];
              --v35;
            }
            while (v35);
          }
          else
          {
            int v38 = 0;
          }
          v18.i32[0] = v36 & ~(-1 << v37);
          uint8x8_t v42 = (uint8x8_t)vcnt_s8(v18);
          v42.i16[0] = vaddlv_u8(v42);
          LODWORD(v60) = 0;
          uint64_t v17 = 1;
          int v43 = __btrie_wildcard_asterisk_search(a1, *(unsigned int *)(v63 + 4 * (v38 + v42.i32[0]) + 40), a3, a4, a5, 1, a7, a8, a9, v60);
LABEL_58:
          if (v43) {
            return v17;
          }
        }
      }
      if (++v34 == 256) {
        return 0;
      }
    }
  }
  if ((v15 & 3) != 3) {
    return 0;
  }
  uint64_t v19 = 0;
  uint64_t v62 = *(void *)(a1 + 8) + (v15 - 3);
  while (1)
  {
    uint64_t v20 = *(unsigned int *)(v62 + 4 * v19 + 4);
    int v21 = *(_DWORD *)(v62 + 4 * v19 + 4) & 3;
    if ((v20 & 3) == 0) {
      goto LABEL_31;
    }
    if (v61 == 2) {
      break;
    }
    if (v61 == 1)
    {
      LODWORD(v60) = 0;
      uint64_t v17 = 1;
      int v22 = __btrie_wildcard_asterisk_search(a1, v20, a3, a4, a5, 1, a7, a8, a9, v60);
LABEL_30:
      if (v22) {
        return v17;
      }
    }
LABEL_31:
    if (++v19 == 256) {
      return 0;
    }
  }
  if (v21 != 2)
  {
    if (v21 == 3)
    {
      uint64_t v23 = 0;
      uint64_t v24 = *(void *)(a1 + 8) + (v20 - 3) + 4;
      while (1)
      {
        uint64_t v25 = *(unsigned int *)(v24 + v23);
        if ((v25 & 3) != 0)
        {
          LODWORD(v60) = 0;
          if (__btrie_wildcard_asterisk_search(a1, v25, a3, a4, a5, 2, a7, a8, a9, v60)) {
            return 1;
          }
        }
        v23 += 4;
        if (v23 == 1024) {
          goto LABEL_31;
        }
      }
    }
    uint64_t v17 = 1;
    LODWORD(v60) = 1;
    int v22 = __btrie_wildcard_asterisk_search(a1, v20, a3, a4, a5, 2, a7, a8, a9, v60);
    goto LABEL_30;
  }
  unint64_t v26 = 0;
  uint64_t v27 = *(void *)(a1 + 8) + (v20 - 2);
  while (1)
  {
    uint64_t v28 = v26 >> 5 <= 1 ? 1 : v26 >> 5;
    unsigned int v29 = *(_DWORD *)(v27 + 4 * (v26 >> 5) + 4);
    if ((v29 >> v26))
    {
      if ((v26 & 0xE0) != 0)
      {
        int v30 = 0;
        unint64_t v31 = (unsigned int *)(v27 + 4);
        do
        {
          unsigned int v32 = *v31++;
          int8x8_t v18 = vcnt_s8((int8x8_t)v32);
          v18.i16[0] = vaddlv_u8((uint8x8_t)v18);
          v30 += v18.i32[0];
          --v28;
        }
        while (v28);
      }
      else
      {
        int v30 = 0;
      }
      v18.i32[0] = v29 & ~(-1 << (v26 & 0x1F));
      uint8x8_t v33 = (uint8x8_t)vcnt_s8(v18);
      v33.i16[0] = vaddlv_u8(v33);
      LODWORD(v60) = 0;
      if (__btrie_wildcard_asterisk_search(a1, *(unsigned int *)(v27 + 4 * (v30 + v33.i32[0]) + 40), a3, a4, a5, 2, a7, a8, a9, v60))return 1; {
    }
      }
    if (++v26 == 256) {
      goto LABEL_31;
    }
  }
}

uint64_t __btrie_wildcard_questionmark_search(uint64_t a1, int a2, uint8x8_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  if ((a2 & 3) == 2)
  {
    unint64_t v24 = 0;
    uint64_t v51 = *(void *)(a1 + 8) + (a2 - 2);
    do
    {
      if (v24 >> 5 <= 1) {
        uint64_t v25 = 1;
      }
      else {
        uint64_t v25 = v24 >> 5;
      }
      unsigned int v26 = *(_DWORD *)(v51 + 4 * (v24 >> 5) + 4);
      if ((v26 >> v24))
      {
        char v27 = v24 & 0x1F;
        if (a7 == 2)
        {
          if (v24 >= 0x20)
          {
            int v29 = 0;
            uint8x8_t v33 = (unsigned int *)(v51 + 4);
            do
            {
              unsigned int v34 = *v33++;
              a3 = (uint8x8_t)vcnt_s8((int8x8_t)v34);
              a3.i16[0] = vaddlv_u8(a3);
              v29 += a3.i32[0];
              --v25;
            }
            while (v25);
          }
          else
          {
            int v29 = 0;
          }
          a3.i32[0] = v26 & ~(-1 << v27);
          a3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
          a3.i16[0] = vaddlv_u8(a3);
          uint64_t v35 = *(unsigned int *)(v51 + 4 * (v29 + a3.i32[0]) + 40);
          int v36 = *(_DWORD *)(v51 + 4 * (v29 + a3.i32[0]) + 40) & 3;
          switch(v36)
          {
            case 1:
              uint64_t v11 = 1;
              if (__btrie_wildcard_match(a1, v35)) {
                return v11;
              }
              break;
            case 2:
              unint64_t v40 = 0;
              uint64_t v41 = *(void *)(a1 + 8) + (v35 - 2);
              do
              {
                if (v40 >> 5 <= 1) {
                  uint64_t v42 = 1;
                }
                else {
                  uint64_t v42 = v40 >> 5;
                }
                unsigned int v43 = *(_DWORD *)(v41 + 4 * (v40 >> 5) + 4);
                if ((v43 >> v40))
                {
                  if ((v40 & 0xE0) != 0)
                  {
                    int v44 = 0;
                    unsigned int v45 = (unsigned int *)(v41 + 4);
                    do
                    {
                      unsigned int v46 = *v45++;
                      a3 = (uint8x8_t)vcnt_s8((int8x8_t)v46);
                      a3.i16[0] = vaddlv_u8(a3);
                      v44 += a3.i32[0];
                      --v42;
                    }
                    while (v42);
                  }
                  else
                  {
                    int v44 = 0;
                  }
                  a3.i32[0] = v43 & ~(-1 << (v40 & 0x1F));
                  uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
                  v47.i16[0] = vaddlv_u8(v47);
                  if (__btrie_wildcard_match(a1, *(unsigned int *)(v41 + 4 * (v44 + v47.i32[0]) + 40)))return 1; {
                }
                  }
                ++v40;
              }
              while (v40 != 256);
              break;
            case 3:
              uint64_t v37 = 0;
              uint64_t v38 = *(void *)(a1 + 8) + (v35 - 3) + 4;
              do
              {
                uint64_t v39 = *(unsigned int *)(v38 + v37);
                if ((v39 & 3) != 0 && __btrie_wildcard_match(a1, v39)) {
                  return 1;
                }
                v37 += 4;
              }
              while (v37 != 1024);
              break;
          }
        }
        else if (a7 == 1)
        {
          if (v24 >= 0x20)
          {
            int v28 = 0;
            int v30 = (unsigned int *)(v51 + 4);
            do
            {
              unsigned int v31 = *v30++;
              a3 = (uint8x8_t)vcnt_s8((int8x8_t)v31);
              a3.i16[0] = vaddlv_u8(a3);
              v28 += a3.i32[0];
              --v25;
            }
            while (v25);
          }
          else
          {
            int v28 = 0;
          }
          a3.i32[0] = v26 & ~(-1 << v27);
          uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
          v32.i16[0] = vaddlv_u8(v32);
          uint64_t v11 = 1;
          if (__btrie_wildcard_match(a1, *(unsigned int *)(v51 + 4 * (v28 + v32.i32[0]) + 40)))return v11; {
        }
          }
      }
      ++v24;
    }
    while (v24 != 256);
    return 0;
  }
  if ((a2 & 3) != 3) {
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t v50 = *(void *)(a1 + 8) + (a2 - 3);
  while (1)
  {
    uint64_t v9 = *(unsigned int *)(v50 + 4 * v8 + 4);
    int v10 = *(_DWORD *)(v50 + 4 * v8 + 4) & 3;
    if ((v9 & 3) == 0) {
      goto LABEL_30;
    }
    if (a7 == 2) {
      break;
    }
    if (a7 == 1)
    {
      uint64_t v11 = 1;
      uint64_t v12 = a1;
LABEL_29:
      if (__btrie_wildcard_match(v12, v9)) {
        return v11;
      }
    }
LABEL_30:
    if (++v8 == 256) {
      return 0;
    }
  }
  if (v10 != 2)
  {
    if (v10 == 3)
    {
      uint64_t v13 = 0;
      uint64_t v14 = *(void *)(a1 + 8) + (v9 - 3) + 4;
      while (1)
      {
        uint64_t v15 = *(unsigned int *)(v14 + v13);
        if ((v15 & 3) != 0)
        {
          if (__btrie_wildcard_match(a1, v15)) {
            return 1;
          }
        }
        v13 += 4;
        if (v13 == 1024) {
          goto LABEL_30;
        }
      }
    }
    uint64_t v11 = 1;
    uint64_t v12 = a1;
    goto LABEL_29;
  }
  unint64_t v16 = 0;
  uint64_t v17 = *(void *)(a1 + 8) + (v9 - 2);
  while (1)
  {
    uint64_t v18 = v16 >> 5 <= 1 ? 1 : v16 >> 5;
    unsigned int v19 = *(_DWORD *)(v17 + 4 * (v16 >> 5) + 4);
    if ((v19 >> v16))
    {
      if ((v16 & 0xE0) != 0)
      {
        int v20 = 0;
        int v21 = (unsigned int *)(v17 + 4);
        do
        {
          unsigned int v22 = *v21++;
          a3 = (uint8x8_t)vcnt_s8((int8x8_t)v22);
          a3.i16[0] = vaddlv_u8(a3);
          v20 += a3.i32[0];
          --v18;
        }
        while (v18);
      }
      else
      {
        int v20 = 0;
      }
      a3.i32[0] = v19 & ~(-1 << (v16 & 0x1F));
      uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
      v23.i16[0] = vaddlv_u8(v23);
      if (__btrie_wildcard_match(a1, *(unsigned int *)(v17 + 4 * (v20 + v23.i32[0]) + 40)))return 1; {
    }
      }
    if (++v16 == 256) {
      goto LABEL_30;
    }
  }
}

BOOL __btrie_wildcardmatch_uint16(const unsigned __int16 *a1, uint64_t a2, const unsigned __int16 *a3, uint64_t a4)
{
  if (!a2) {
    return 0;
  }
  CFDictionaryRef v4 = &a3[a4];
  uint64_t v5 = a1;
  if (a4 >= 1)
  {
    do
    {
      int v6 = *v5;
      if (v6 == 42) {
        break;
      }
      if (v6 != 63 && v6 != *a3) {
        return 0;
      }
      ++v5;
      ++a3;
    }
    while (a3 < v4);
  }
  uint64_t v8 = &a1[a2];
  if (a3 < v4)
  {
    uint64_t v9 = 0;
    int v10 = 0;
    while (v5 < v8)
    {
      int v11 = *v5;
      if (v11 == 42)
      {
        if (++v5 == v8) {
          return 1;
        }
        int v10 = a3 + 1;
        uint64_t v9 = v5;
      }
      else
      {
        if (v11 != 63 && v11 != *a3) {
          break;
        }
        ++v5;
        ++a3;
      }
LABEL_23:
      if (a3 >= v4) {
        goto LABEL_27;
      }
    }
    a3 = v10++;
    uint64_t v5 = v9;
    goto LABEL_23;
  }
LABEL_27:
  while (v5 < v8 && *v5 == 42)
    ++v5;
  return v5 == v8;
}

uint64_t __btrie_find_common_prefix(uint64_t a1, int a2, unsigned __int8 *a3, unsigned int a4, unint64_t a5, unint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v15 = a2 & 3;
  if (v15 == 1)
  {
    unsigned int v19 = (_DWORD *)(*(void *)(a1 + 16) + (a2 - 1));
    int v20 = v19 + 1;
    int v21 = v19[1];
    if (v21)
    {
      if (!a5)
      {
        ++*a6;
        if (!a4) {
          return 0;
        }
        goto LABEL_17;
      }
      if (a8) {
        *(void *)(a8 + 8 * *a6) = &a3[-a9];
      }
      unint64_t v22 = *a6;
      unint64_t v23 = *a6 + 1;
      *a6 = v23;
      *(_DWORD *)(a7 + 4 * v22) = v21;
      if (v23 >= a5) {
        return 1;
      }
    }
    if (!a4) {
      return 0;
    }
LABEL_17:
    unsigned int v25 = *v19;
    unint64_t v24 = (char *)(v19 + 2);
    unint64_t v26 = (unint64_t)v20 + v25;
    if ((unint64_t)v24 < v26)
    {
      char v27 = &a3[-a9];
      while (1)
      {
        unsigned int v30 = *v24;
        int v28 = v24 + 1;
        size_t v29 = v30;
        if (v30 <= a4)
        {
          int v31 = memcmp(v28, a3, v29);
          if (v31 > 0) {
            return 0;
          }
          if (!v31)
          {
            unint64_t v32 = *a6;
            if (a5)
            {
              if (a8)
              {
                *(void *)(a8 + 8 * v32) = &v27[v29];
                unint64_t v32 = *a6;
              }
              int v33 = *(_DWORD *)&v28[v29];
              *a6 = v32 + 1;
              *(_DWORD *)(a7 + 4 * v32) = v33;
              if (v32 + 1 >= a5) {
                return 1;
              }
            }
            else
            {
              *a6 = v32 + 1;
            }
          }
        }
        unint64_t v24 = &v28[v29 + 4];
        if ((unint64_t)v24 >= v26) {
          return 0;
        }
      }
    }
    return 0;
  }
  if (v15 == 2)
  {
    uint64_t v34 = *(void *)(a1 + 8);
    uint64_t v35 = (a2 - 2);
    int v36 = *(_DWORD *)(v34 + v35);
    if (v36)
    {
      if (!a5)
      {
        ++*a6;
        if (!a4) {
          return 0;
        }
LABEL_36:
        unint64_t v39 = *a3;
        uint64_t v40 = v39 >> 5;
        if (((*(_DWORD *)(v34 + v35 + 4 * (v39 >> 5) + 4) >> v39) & 1) == 0) {
          return 0;
        }
        if (v39 >= 0x20)
        {
          int v42 = 0;
          if (v40 <= 1) {
            uint64_t v40 = 1;
          }
          else {
            uint64_t v40 = v40;
          }
          unsigned int v43 = (unsigned int *)(v35 + v34 + 4);
          do
          {
            unsigned int v44 = *v43++;
            uint8x8_t v45 = (uint8x8_t)vcnt_s8((int8x8_t)v44);
            v45.i16[0] = vaddlv_u8(v45);
            v42 += v45.i32[0];
            --v40;
          }
          while (v40);
        }
LABEL_50:
        uint64_t result = __btrie_find_common_prefix(a1);
        if (!result) {
          return result;
        }
        return 1;
      }
      if (a8) {
        *(void *)(a8 + 8 * *a6) = &a3[-a9];
      }
      unint64_t v37 = *a6;
      unint64_t v38 = *a6 + 1;
      *a6 = v38;
      *(_DWORD *)(a7 + 4 * v37) = v36;
      if (v38 >= a5) {
        return 1;
      }
    }
    if (!a4) {
      return 0;
    }
    goto LABEL_36;
  }
  if (v15 != 3) {
    return 0;
  }
  int v16 = *(_DWORD *)(*(void *)(a1 + 8) + (a2 - 3));
  if (!v16)
  {
LABEL_9:
    if (a4) {
      goto LABEL_50;
    }
    return 0;
  }
  if (!a5)
  {
    ++*a6;
    if (!a4) {
      return 0;
    }
    goto LABEL_50;
  }
  if (a8) {
    *(void *)(a8 + 8 * *a6) = &a3[-a9];
  }
  unint64_t v17 = *a6;
  unint64_t v18 = *a6 + 1;
  *a6 = v18;
  *(_DWORD *)(a7 + 4 * v17) = v16;
  if (v18 < a5) {
    goto LABEL_9;
  }
  return 1;
}

uint64_t __resize_array(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef v4 = *(uint64_t (**)(void *, size_t, void))(a1 + 32);
  uint64_t v5 = *(void **)a1;
  size_t v6 = 8 * a2 + 16;
  if (v4)
  {
    uint64_t v7 = (char *)v4(v5, v6, *(void *)(a1 + 40));
    if (!v7) {
      return 0xFFFFFFFFLL;
    }
    *(void *)a1 = v7;
  }
  else
  {
    uint64_t v7 = (char *)malloc_type_realloc(v5, v6, 0x9FCAA123uLL);
    *(void *)a1 = v7;
    if (!*(_DWORD *)(a1 + 80)) {
      *(_DWORD *)(a1 + 80) = 1;
    }
  }
  *(void *)(a1 + 8) = v7 + 16;
  if (!*(void *)(a1 + 32)) {
    bzero(&v7[8 * *(void *)(a1 + 24) + 16], 8 * (a2 - *(void *)(a1 + 24)));
  }
  uint64_t result = 0;
  *(void *)(a1 + 24) = a2;
  return result;
}

uint64_t __write_base(uint64_t result, unsigned int a2, int a3)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(result + 24);
  if (v6 > a2 || (uint64_t result = __resize_array(result, v6 + 0x2000), !result))
  {
    if (*(_DWORD *)(v5 + 16) < a2) {
      *(_DWORD *)(v5 + 16) = a2;
    }
    *(_DWORD *)(*(void *)(v5 + 8) + 8 * a2) = a3;
  }
  return result;
}

uint64_t __get_list(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  if (v3 >= a2) {
    int v4 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * a2);
  }
  else {
    int v4 = 0;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  do
  {
    if (v3 >= v4 + (int)v5) {
      int v7 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * (v4 + v5) + 4);
    }
    else {
      int v7 = 0;
    }
    if (v7 == a2) {
      *(_WORD *)(a3 + 2 * v6++) = v5;
    }
    ++v5;
  }
  while (v5 != 257);
  return v6;
}

uint64_t __modify_array(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5, __int16 a6, int a7)
{
  unsigned int v12 = *(_DWORD *)(a1 + 16);
  if (v12 >= a3)
  {
    int v13 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * a3);
    if (a7)
    {
LABEL_3:
      unint64_t v14 = 0;
      *(_WORD *)(a4 + 2 * a5) = a6;
      int v15 = 1;
      do
      {
        unsigned int v16 = v15 + *(__int16 *)(a4 + 2 * v14);
        if (v12 >= v16) {
          int v17 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * v16 + 4);
        }
        else {
          int v17 = 0;
        }
        ++v14;
        if (v16 == 1 || v17 != 0)
        {
          ++v15;
          unint64_t v14 = 0;
        }
      }
      while (v14 < a5 + 1);
      goto LABEL_25;
    }
  }
  else
  {
    int v13 = 0;
    if (a7) {
      goto LABEL_3;
    }
  }
  unint64_t v19 = 0;
  int v15 = 1;
  do
  {
    unsigned int v20 = v15 + *(__int16 *)(a4 + 2 * v19);
    if (v12 >= v20) {
      int v21 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * v20 + 4);
    }
    else {
      int v21 = 0;
    }
    ++v19;
    if (v20 == 1 || v21 != 0)
    {
      ++v15;
      unint64_t v19 = 0;
    }
  }
  while (v19 < a5);
LABEL_25:
  __write_base(a1, a3, v15);
  if (a5)
  {
    uint64_t v23 = 0;
    do
    {
      unsigned int v24 = *(_DWORD *)(a1 + 16);
      if (v24 >= a3) {
        int v25 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * a3);
      }
      else {
        int v25 = 0;
      }
      int v26 = *(__int16 *)(a4 + 2 * v23);
      uint64_t v27 = (v13 + v26);
      if (v24 >= v27) {
        int v28 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * (v13 + v26));
      }
      else {
        int v28 = 0;
      }
      unsigned int v29 = v25 + v26;
      __write_base(a1, v25 + v26, v28);
      __write_check(a1, v29, a3);
      if (*(_DWORD *)(a1 + 16) >= v27 && *(int *)(*(void *)(a1 + 8) + 8 * v27) >= 1)
      {
        for (int i = 0; i != 257; ++i)
        {
          unsigned int v31 = *(_DWORD *)(a1 + 16);
          if (v31 >= v27) {
            int v32 = *(_DWORD *)(*(void *)(a1 + 8) + 8 * v27);
          }
          else {
            int v32 = 0;
          }
          unsigned int v33 = v32 + i;
          if (v32 + i > v31) {
            break;
          }
          if (*(_DWORD *)(*(void *)(a1 + 8) + 8 * v33 + 4) == v27) {
            __write_check(a1, v33, v29);
          }
        }
      }
      if (v27 != a2 || a2 == a3) {
        a2 = a2;
      }
      else {
        a2 = v29;
      }
      __write_base(a1, v27, 0);
      __write_check(a1, v27, 0);
      ++v23;
    }
    while (v23 != a5);
  }
  return a2;
}

uint64_t __write_check(uint64_t result, unsigned int a2, int a3)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(result + 24);
  if (v6 > a2 || (uint64_t result = __resize_array(result, v6 + 0x2000), !result))
  {
    if (*(_DWORD *)(v5 + 16) < a2) {
      *(_DWORD *)(v5 + 16) = a2;
    }
    *(_DWORD *)(*(void *)(v5 + 8) + 8 * a2 + 4) = a3;
  }
  return result;
}

uint64_t __get_children(uint64_t a1, void *a2, uint64_t a3)
{
  if ((*(_DWORD *)(a1 + 76) & 0x80000000) != 0) {
    return 0;
  }
  unint64_t v3 = a2[1];
  unint64_t v4 = a2[2];
  if (v3 >= v4) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = 0xFFFFLL;
  do
  {
    unint64_t v9 = *(void *)(v7 + 8 * v3);
    unint64_t v10 = a2[3];
    if (v9 >= v10)
    {
      if (v9 > v10) {
        uint64_t v11 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8 * v3) + v10) + 1;
      }
      else {
        uint64_t v11 = 0;
      }
      if ((__int16)v8 > (int)v11)
      {
        uint64_t result = 0;
        *(_DWORD *)(a1 + 76) = -1;
        return result;
      }
      if (v11 != (__int16)v8)
      {
        if (result) {
          *(void *)(a3 + 32 * result - 16) = v3;
        }
        uint64_t v12 = a3 + 32 * result;
        *(_WORD *)uint64_t v12 = v11;
        *(void *)(v12 + 8) = v3;
        *(void *)(v12 + 24) = v10 + 1;
        ++result;
        unint64_t v4 = a2[2];
      }
    }
    else
    {
      uint64_t v11 = v8;
    }
    ++v3;
    uint64_t v8 = v11;
  }
  while (v3 < v4);
  if (result) {
    *(void *)(a3 + 32 * result - 16) = v4;
  }
  return result;
}

uint64_t __insert_nodes(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  v30[1028] = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(v1 + 76) & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v5 = v4;
  unint64_t v6 = v3;
  int v7 = v2;
  uint64_t v8 = v1;
  int v9 = 0;
  unint64_t v10 = v3 - 1;
  uint64_t v11 = &v4[16 * v3 - 16];
  uint64_t v12 = *v4;
  uint64_t v13 = *v11 - v12;
  if (*(_DWORD *)(v1 + 72) <= (v12 + 1)) {
    unsigned int v14 = v12 + 1;
  }
  else {
    unsigned int v14 = *(_DWORD *)(v1 + 72);
  }
  int v15 = v4 + 16;
  while (1)
  {
    unint64_t v16 = *(void *)(v8 + 24);
    if (v13 + (unint64_t)v14 >= v16 && __resize_array(v8, v16 + 0x2000))
    {
LABEL_30:
      uint64_t v18 = 0;
      *(_DWORD *)(v8 + 76) = -2;
      return v18;
    }
    uint64_t v17 = *(void *)(v8 + 8);
    if (!*(_DWORD *)(v17 + 8 * v14 + 4)) {
      break;
    }
LABEL_16:
    ++v14;
  }
  if (!v9) {
    *(_DWORD *)(v8 + 72) = v14 + 1;
  }
  uint64_t v18 = v14 - *v5;
  unint64_t v19 = v15;
  unint64_t v20 = v10;
  if (v6 >= 2)
  {
    while (1)
    {
      int v21 = *v19;
      v19 += 16;
      if (*(_DWORD *)(v17 + 8 * ((int)v18 + v21) + 4)) {
        break;
      }
      if (!--v20) {
        goto LABEL_17;
      }
    }
    int v9 = 1;
    goto LABEL_16;
  }
LABEL_17:
  if (v6)
  {
    unint64_t v22 = v5;
    unint64_t v23 = v6;
    do
    {
      int v24 = *v22;
      v22 += 16;
      *(_DWORD *)(v17 + 8 * ((int)v18 + v24) + 4) = v7;
      --v23;
    }
    while (v23);
  }
  unsigned int v25 = v18 + *v11;
  if (*(_DWORD *)(v8 + 16) < v25) {
    *(_DWORD *)(v8 + 16) = v25;
  }
  for (; v6; --v6)
  {
    uint64_t v26 = (v18 + *v5);
    uint64_t children = __get_children(v8, v5, (uint64_t)v30);
    if (children)
    {
      int inserted = __insert_nodes(v8, v26, children, v30);
      if (inserted < 1) {
        goto LABEL_30;
      }
    }
    else
    {
      int inserted = -*(_DWORD *)(*(void *)(v8 + 64) + 4 * *((void *)v5 + 1));
    }
    *(_DWORD *)(*(void *)(v8 + 8) + 8 * v26) = inserted;
    v5 += 16;
  }
  return v18;
}

void __btrie_insert_fat(uint64_t a1, int a2, unsigned __int8 *a3, int a4, unsigned int a5)
{
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v6 = (4 * a2);
  int v7 = (unsigned int *)(v5 + v6);
  if (!a4) {
    goto LABEL_28;
  }
  int v8 = a4;
  while (1)
  {
    uint64_t v11 = *a3;
    uint64_t v12 = &v7[v11];
    unsigned int v14 = v12[1];
    uint64_t v13 = v12 + 1;
    int v15 = v14 & 3;
    unint64_t v16 = (unint64_t)v14 >> 2;
    if (v15 == 3)
    {
      LODWORD(v25) = v16;
      ++a3;
      LODWORD(v26) = v8 - 1;
      goto LABEL_27;
    }
    if (v15 == 1) {
      goto LABEL_22;
    }
    if (v15) {
      break;
    }
    uint64_t v17 = *(void *)(a1 + 80);
    if (v17 != *(void *)(a1 + 72))
    {
      uint64_t v17 = (*(void *)(a1 + 80) & 0xFFFFFFFCLL)
          + *(unsigned int *)(*(void *)(a1 + 120) + (*(void *)(a1 + 80) & 0xFFFFFFFCLL))
          + 4;
      *(void *)(a1 + 72) = v17;
    }
    unint64_t v18 = v17 + 3;
    unint64_t v19 = (v17 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    size_t v20 = v19 + *(unsigned int *)(a1 + 200);
    for (size_t i = *(void *)(a1 + 64); v20 > i; *(void *)(a1 + 64) = i)
    {
      i *= 2;
      if (*(_DWORD *)(a1 + 88))
      {
        unint64_t v22 = *(uint64_t (**)(void *, size_t, void))(a1 + 104);
        unint64_t v23 = *(void **)(a1 + 120);
        if (v22)
        {
          *(void *)(a1 + 120) = v22(v23, i, *(void *)(a1 + 112));
          continue;
        }
        int v24 = (char *)malloc_type_realloc(v23, i, 0x44C5D969uLL);
        *(void *)(a1 + 120) = v24;
        **(_DWORD **)(a1 + 96) = 1;
      }
      else
      {
        int v24 = (char *)malloc_type_realloc(*(void **)(a1 + 120), i, 0x20B045E2uLL);
        *(void *)(a1 + 120) = v24;
        if (!v24)
        {
          unint64_t v16 = 0;
          goto LABEL_21;
        }
      }
      bzero(&v24[*(void *)(a1 + 64)], i - *(void *)(a1 + 64));
    }
    *(void *)(a1 + 72) = v20;
    *(void *)(a1 + 80) = v19;
    unint64_t v16 = (v18 >> 2) | 0x100000000;
LABEL_21:
    *uint64_t v13 = HIDWORD(v16) | (4 * v16);
LABEL_22:
    uint64_t v27 = (int *)(*(void *)(a1 + 120) + (4 * v16));
    size_t v26 = (v8 - 1);
    if (v8 == 1)
    {
      v27[1] = a5;
      int v31 = 4;
LABEL_31:
      *uint64_t v27 = v31;
      return;
    }
    uint64_t v28 = *v27;
    if (!v28)
    {
      *(void *)uint64_t v27 = 4;
      uint64_t v28 = 4;
    }
    ++a3;
    uint64_t v29 = (v8 + 4);
    uint64_t v30 = v28 + 4;
    if (v30 + v29 < (unint64_t)*(unsigned int *)(a1 + 200))
    {
      *((unsigned char *)v27 + v30) = v26;
      int v32 = (char *)v27 + v30 + 1;
      memcpy(v32, a3, v26);
      *(_DWORD *)&v32[v26] = a5;
      int v31 = *v27 + v29;
      goto LABEL_31;
    }
    uint64_t v25 = __btrie_burst_flat(a1);
    uint64_t v5 = *(void *)(a1 + 56);
    *(_DWORD *)(v5 + v6 + 4 * v11 + 4) = HIDWORD(v25) | (4 * v25);
LABEL_27:
    uint64_t v6 = (4 * v25);
    int v7 = (unsigned int *)(v5 + v6);
    int v8 = v26;
    if (!v26)
    {
LABEL_28:
      *int v7 = a5;
      return;
    }
  }
}

uint64_t __btrie_burst_flat(uint64_t a1)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = MEMORY[0x1F4188790](a1);
  unint64_t v4 = (_DWORD *)((char *)v20 - ((v3 + 19) & 0x1FFFFFFF0));
  uint64_t v6 = (4 * v5);
  int v7 = (unsigned int *)(*(void *)(v2 + 120) + v6);
  size_t v8 = *v7;
  *unint64_t v4 = v8;
  memcpy(v4 + 1, v7 + 1, v8);
  if (*(void *)(a1 + 80) == v6)
  {
    bzero(v7, *(void *)(a1 + 72) - v6);
    *(void *)(a1 + 72) = *(void *)(a1 + 80);
  }
  size_t v9 = *(void *)a1;
  unint64_t v10 = *(void *)(a1 + 8) + 3;
  unint64_t v11 = (v10 & 0xFFFFFFFFFFFFFFFCLL) + 1028;
  if (v11 > *(void *)a1)
  {
    while (1)
    {
      v9 *= 2;
      if (!*(_DWORD *)(a1 + 24)) {
        break;
      }
      uint64_t v12 = *(uint64_t (**)(void *, size_t, void))(a1 + 40);
      uint64_t v13 = *(void **)(a1 + 56);
      if (!v12)
      {
        unsigned int v14 = (char *)malloc_type_realloc(v13, v9, 0x44C5D969uLL);
        *(void *)(a1 + 56) = v14;
        **(_DWORD **)(a1 + 32) = 1;
LABEL_10:
        bzero(&v14[*(void *)a1], v9 - *(void *)a1);
        goto LABEL_11;
      }
      *(void *)(a1 + 56) = v12(v13, v9, *(void *)(a1 + 48));
LABEL_11:
      *(void *)a1 = v9;
      if (v11 <= v9) {
        goto LABEL_12;
      }
    }
    unsigned int v14 = (char *)malloc_type_realloc(*(void **)(a1 + 56), v9, 0x20B045E2uLL);
    *(void *)(a1 + 56) = v14;
    if (!v14)
    {
      uint64_t v19 = 0;
      goto LABEL_13;
    }
    goto LABEL_10;
  }
LABEL_12:
  *(void *)(a1 + 8) = v11;
  *(void *)(a1 + 16) = v10 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v19 = (v10 >> 2) | 0x300000000;
LABEL_13:
  *(_DWORD *)(*(void *)(a1 + 56) + (4 * v19)) = v4[1];
  int v15 = (unsigned __int8 *)(v4 + 2);
  unint64_t v16 = (unint64_t)v4 + v8 + 4;
  if ((unint64_t)(v4 + 2) < v16)
  {
    do
    {
      unint64_t v17 = (unint64_t)&v15[*v15 + 5];
      __btrie_insert_fat(a1, v19);
      int v15 = (unsigned __int8 *)v17;
    }
    while (v17 < v16);
  }
  return v19;
}

unint64_t __btrie_build_compact_trie(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  LODWORD(v4) = a2;
  unint64_t v5 = HIDWORD(a2);
  if (HIDWORD(a2) != 3) {
    return v4 | ((unint64_t)v5 << 32);
  }
  uint64_t v8 = 0;
  uint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = (4 * a2);
  __n128 v11 = 0uLL;
  v12.i64[0] = 0x300000003;
  v12.i64[1] = 0x300000003;
  do
  {
    __n128 v11 = (__n128)vsubq_s32((int32x4_t)v11, vtstq_s32(*(int32x4_t *)(v10 + v9 + 4 + v8), v12));
    v8 += 16;
  }
  while (v8 != 1024);
  if (a4 || (v11.n128_u32[0] = vaddvq_s32((int32x4_t)v11), unsigned __int8 v13 = v11.n128_u8[0], v11.n128_u32[0] >= 0x21))
  {
    size_t v29 = *(void *)a3;
    unint64_t v30 = *(void *)(a3 + 8) + 3;
    unint64_t v31 = (v30 & 0xFFFFFFFFFFFFFFFCLL) + 1028;
    if (v31 <= *(void *)a3)
    {
LABEL_30:
      *(void *)(a3 + 8) = v31;
      *(void *)(a3 + 16) = v30 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v4 = (v30 >> 2) | 0x300000000;
LABEL_31:
      uint64_t v35 = 0;
      uint64_t v36 = (4 * v4);
      unint64_t v37 = (int *)(v9 + v10);
      int v39 = *v37;
      unint64_t v38 = v37 + 1;
      *(_DWORD *)(*(void *)(a3 + 56) + v36) = v39;
      uint64_t v40 = v36 + 4;
      do
      {
        uint64_t v41 = __btrie_build_compact_trie(a1, ((unint64_t)v38[v35] >> 2) | ((unint64_t)(v38[v35] & 3) << 32), a3, 0, v11);
        *(_DWORD *)(*(void *)(a3 + 56) + v40 + v35 * 4) = HIDWORD(v41) + 4 * v41;
        ++v35;
      }
      while (v35 != 256);
      goto LABEL_33;
    }
    while (1)
    {
      v29 *= 2;
      if (!*(_DWORD *)(a3 + 24)) {
        break;
      }
      int v32 = *(uint64_t (**)(void *, size_t, void, __n128))(a3 + 40);
      unsigned int v33 = *(void **)(a3 + 56);
      if (!v32)
      {
        uint64_t v34 = (char *)malloc_type_realloc(v33, v29, 0x44C5D969uLL);
        *(void *)(a3 + 56) = v34;
        **(_DWORD **)(a3 + 32) = 1;
LABEL_28:
        bzero(&v34[*(void *)a3], v29 - *(void *)a3);
        goto LABEL_29;
      }
      *(void *)(a3 + 56) = v32(v33, v29, *(void *)(a3 + 48), v11);
LABEL_29:
      *(void *)a3 = v29;
      if (v31 <= v29) {
        goto LABEL_30;
      }
    }
    uint64_t v34 = (char *)malloc_type_realloc(*(void **)(a3 + 56), v29, 0x20B045E2uLL);
    *(void *)(a3 + 56) = v34;
    if (!v34)
    {
      unint64_t v4 = 0;
      goto LABEL_31;
    }
    goto LABEL_28;
  }
  size_t v14 = *(void *)a3;
  unint64_t v15 = *(void *)(a3 + 8) + 3;
  unint64_t v16 = (v15 & 0xFFFFFFFFFFFFFFFCLL) + 4 * v11.n128_u32[0] + 40;
  if (v16 <= *(void *)a3)
  {
LABEL_15:
    *(void *)(a3 + 8) = v16;
    *(void *)(a3 + 16) = v15 & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v4 = (v15 >> 2) | 0x200000000;
    goto LABEL_16;
  }
  while (1)
  {
    v14 *= 2;
    if (!*(_DWORD *)(a3 + 24)) {
      break;
    }
    unint64_t v17 = *(uint64_t (**)(void *, size_t, void))(a3 + 40);
    unint64_t v18 = *(void **)(a3 + 56);
    if (!v17)
    {
      uint64_t v19 = (char *)malloc_type_realloc(v18, v14, 0x44C5D969uLL);
      *(void *)(a3 + 56) = v19;
      **(_DWORD **)(a3 + 32) = 1;
      goto LABEL_13;
    }
    *(void *)(a3 + 56) = v17(v18, v14, *(void *)(a3 + 48));
LABEL_14:
    *(void *)a3 = v14;
    if (v16 <= v14) {
      goto LABEL_15;
    }
  }
  uint64_t v19 = (char *)malloc_type_realloc(*(void **)(a3 + 56), v14, 0x20B045E2uLL);
  *(void *)(a3 + 56) = v19;
  if (v19)
  {
LABEL_13:
    bzero(&v19[*(void *)a3], v14 - *(void *)a3);
    goto LABEL_14;
  }
  unint64_t v4 = 0;
LABEL_16:
  uint64_t v20 = 0;
  uint64_t v21 = (4 * v4);
  unint64_t v22 = (int *)(v9 + v10);
  int v24 = *v22;
  unint64_t v23 = v22 + 1;
  uint64_t v25 = *(void *)(a3 + 56) + v21;
  *(_DWORD *)uint64_t v25 = v24;
  *(unsigned char *)(v25 + 37) = v13;
  do
  {
    unint64_t v26 = __btrie_build_compact_trie(a1, ((unint64_t)v23[v20] >> 2) | ((unint64_t)(v23[v20] & 3) << 32), a3, 0, v11);
    if (HIDWORD(v26))
    {
      uint64_t v27 = *(void *)(a3 + 56) + v21;
      uint64_t v28 = *(unsigned __int8 *)(v27 + 36);
      *(unsigned char *)(v27 + 36) = v28 + 1;
      *(_DWORD *)(v27 + 4 * v28 + 40) = HIDWORD(v26) + 4 * v26;
      *(_DWORD *)(v27 + 4 * (v20 >> 5) + 4) |= 1 << v20;
    }
    ++v20;
  }
  while (v20 != 256);
LABEL_33:
  unint64_t v5 = HIDWORD(v4);
  return v4 | ((unint64_t)v5 << 32);
}

uint64_t DCSSearchSession::DCSSearchSession(uint64_t a1, DCSDictionary *a2, const __CFString *a3, uint64_t a4, uint64_t a5, long long *a6)
{
  *(void *)a1 = DCSSearchSession::createSessionRef((DCSSearchSession *)a1);
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 56) = CFRetain(a3);
  *(void *)(a1 + 64) = a4;
  *(void *)(a1 + 72) = a5;
  if (*(void *)a6)
  {
    long long v12 = *a6;
    long long v13 = a6[1];
    *(void *)(a1 + 48) = *((void *)a6 + 4);
    *(_OWORD *)(a1 + 16) = v12;
    *(_OWORD *)(a1 + 32) = v13;
    CFStringRef v14 = *(const __CFString **)(a1 + 32);
    if (v14) {
      *(void *)(a1 + 32) = CFStringCreateCopy(0, v14);
    }
  }
  else
  {
    *(void *)(a1 + 32) = 0;
    uint64_t v15 = *((void *)a6 + 1);
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = v15;
    *(_OWORD *)(a1 + 40) = a6[1];
  }
  *(void *)(a1 + 80) = DCSDictionary::createSessionInfo(a2, (DCSSearchSession *)a1, a3);
  return a1;
}

uint64_t DCSSearchSession::createSessionRef(DCSSearchSession *this)
{
  pthread_once(&_DCSSearchSessionClassID(void)::once_control, (void (*)(void))_DCSSearchSessionInitialize);
  uint64_t result = _CFRuntimeCreateInstance();
  if (result) {
    *(void *)(result + 16) = this;
  }
  return result;
}

void DCSSearchSession::~DCSSearchSession(DCSSearchSession *this)
{
  uint64_t v2 = (const void *)*((void *)this + 7);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 10);
  if (v3) {
    DCSDictionary::releaseSessionInfo(*((DCSDictionary **)this + 1), v3);
  }
  unint64_t v4 = (const void *)*((void *)this + 4);
  if (v4) {
    CFRelease(v4);
  }
}

uint64_t DCSSearchSession::scheduleRunLoop(DCSSearchSession *this, __CFRunLoop *a2, const __CFString *a3)
{
  return DCSDictionary::scheduleSession(*((DCSDictionary **)this + 1), *((void **)this + 10), a2, a3);
}

uint64_t DCSSearchSession::unscheduleRunLoop(DCSSearchSession *this, __CFRunLoop *a2, const __CFString *a3)
{
  return DCSDictionary::unscheduleSession(*((DCSDictionary **)this + 1), *((void **)this + 10), a2, a3);
}

void *DCSSearchSession::didFindRecord(void *this, const __CFArray *a2)
{
  uint64_t v2 = (uint64_t (*)(void, const __CFArray *, void))this[5];
  if (v2) {
    return (void *)v2(*this, a2, this[3]);
  }
  return this;
}

void DCSSearchSession::didFinishSearch(DCSSearchSession *this, CFTypeRef cf)
{
  uint64_t v2 = (void (*)(void, CFTypeRef, void))*((void *)this + 6);
  if (v2)
  {
    v2(*(void *)this, cf, *((void *)this + 3));
  }
  else if (cf)
  {
    CFRelease(cf);
  }
}

uint64_t DCSSearchSession::sessionRefClassID(DCSSearchSession *this)
{
  return _DCSSearchSessionID;
}

uint64_t _DCSSearchSessionInitialize(void)
{
  uint64_t result = _CFRuntimeRegisterClass();
  _DCSSearchSessionID = result;
  return result;
}

uint64_t _DCSSearchSessionFinalize(uint64_t result)
{
  if (*(void *)(result + 16))
  {
    DCSSearchSession::~DCSSearchSession(*(DCSSearchSession **)(result + 16));
    JUMPOUT(0x1D94553C0);
  }
  return result;
}

void sub_1D5928EBC(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10E0C40DFD76AA2);
  _Unwind_Resume(a1);
}

BOOL _DCSSearchSessionEqual(const void *a1, const void *a2)
{
  return a1 == a2;
}

CFStringRef _DCSSearchSessionCopyFormattingDesc(void *a1, const __CFDictionary *a2)
{
  uint64_t v3 = a1[2];
  CFAllocatorRef v4 = CFGetAllocator(a1);
  CFDictionaryRef v5 = DCSDictionary::identifier(*(DCSDictionary **)(v3 + 8));
  return CFStringCreateWithFormat(v4, a2, @"<session for %@>", v5);
}

CFStringRef _DCSSearchSessionCopyDebugDesc(void *a1)
{
  uint64_t v1 = a1[2];
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFDictionaryRef v3 = DCSDictionary::identifier(*(DCSDictionary **)(v1 + 8));
  CFAllocatorRef v4 = *(__CFString **)(v1 + 32);
  if (!v4) {
    CFAllocatorRef v4 = &stru_1F2DE4460;
  }
  return CFStringCreateWithFormat(v2, 0, @"<DCSSearchSessionRef %p>{dict:%@, client:%@}", v1, v3, v4);
}

void DCSBaseDictionary::DCSBaseDictionary(DCSBaseDictionary *this, CFURLRef relativeURL)
{
  *(void *)this = &unk_1F2DE3A10;
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 16) = 0;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 72) = 0;
  *((void *)this + 10) = 0;
  *((unsigned char *)this + 88) = 0;
  *((void *)this + 12) = 0;
  *((unsigned char *)this + 104) = 0;
  *((void *)this + 14) = 0;
  *((unsigned char *)this + 120) = 0;
  *((void *)this + 16) = 0;
  *((unsigned char *)this + 136) = 0;
  *((void *)this + 18) = 0;
  *((unsigned char *)this + 152) = 0;
  *((void *)this + 20) = 0;
  *((unsigned char *)this + 168) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((unsigned char *)this + 56) = 0;
  *((void *)this + 22) = -1;
  CFURLRef v3 = CFURLCopyAbsoluteURL(relativeURL);
  *((void *)this + 3) = v3;
  CFURLRef v4 = CFURLCreateCopyDeletingPathExtension(0, v3);
  *((void *)this + 4) = CFURLCopyLastPathComponent(v4);
  CFRelease(v4);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 184), 0);
}

void DCSBaseDictionary::~DCSBaseDictionary(DCSBaseDictionary *this)
{
  *(void *)this = &unk_1F2DE3A10;
  CFRelease(*((CFTypeRef *)this + 3));
  CFRelease(*((CFTypeRef *)this + 4));
  CFAllocatorRef v2 = (const void *)*((void *)this + 5);
  if (v2) {
    CFRelease(v2);
  }
  CFURLRef v3 = (const void *)*((void *)this + 6);
  if (v3) {
    CFRelease(v3);
  }
  CFURLRef v4 = (const void *)*((void *)this + 8);
  if (v4) {
    CFRelease(v4);
  }
  CFDictionaryRef v5 = (const void *)*((void *)this + 10);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 12);
  if (v6) {
    CFRelease(v6);
  }
  int v7 = (const void *)*((void *)this + 14);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)*((void *)this + 16);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)*((void *)this + 18);
  if (v9) {
    CFRelease(v9);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 184));
}

CFStringRef DCSBaseDictionary::identifier(DCSBaseDictionary *this)
{
  CFStringRef result = (CFStringRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    return CFBundleGetIdentifier(v3);
  }
  return result;
}

uint64_t DCSBaseDictionary::baseURL(DCSBaseDictionary *this)
{
  uint64_t result = *((void *)this + 6);
  if (!result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    CFURLRef v4 = CFBundleCopyBundleURL(v3);
    *((void *)this + 6) = CFURLCreateCopyAppendingPathComponent(0, v4, @"Contents/Info.plist", 0);
    CFRelease(v4);
    return *((void *)this + 6);
  }
  return result;
}

CFTypeRef DCSBaseDictionary::name(DCSBaseDictionary *this)
{
  if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this)
    || (CFAllocatorRef v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this),
        (CFTypeRef result = CFBundleGetValueForInfoDictionaryKey(v2, @"CFBundleDisplayName")) == 0))
  {
    CFURLRef v4 = *(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 368);
    return (CFTypeRef)v4(this);
  }
  return result;
}

CFTypeRef DCSBaseDictionary::shortName(DCSBaseDictionary *this)
{
  if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this)
    || (CFAllocatorRef v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this),
        (CFTypeRef result = CFBundleGetValueForInfoDictionaryKey(v2, @"CFBundleName")) == 0))
  {
    CFURLRef v4 = *(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 368);
    return (CFTypeRef)v4(this);
  }
  return result;
}

CFTypeRef DCSBaseDictionary::detailedShortName(DCSBaseDictionary *this)
{
  CFTypeRef result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, @"DCSDictionaryDetailedDisplayName");
  }
  return result;
}

CFTypeRef DCSBaseDictionary::nativeShortName(DCSBaseDictionary *this)
{
  CFTypeRef result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, @"DCSDictionaryNativeDisplayName");
  }
  return result;
}

CFTypeRef DCSBaseDictionary::typeName(DCSBaseDictionary *this)
{
  CFTypeRef result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, @"DCSDictionaryTypeDisplayName");
  }
  return result;
}

CFTypeRef DCSBaseDictionary::version(DCSBaseDictionary *this)
{
  CFTypeRef result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, @"CFBundleShortVersionString");
  }
  return result;
}

CFTypeRef DCSBaseDictionary::primaryLanguage(DCSBaseDictionary *this)
{
  CFTypeRef result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, @"DCSDictionaryPrimaryLanguage");
  }
  return result;
}

CFTypeRef DCSBaseDictionary::languages(DCSBaseDictionary *this)
{
  CFTypeRef result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, @"DCSDictionaryLanguages");
  }
  return result;
}

uint64_t DCSBaseDictionary::styleSheetURLs(DCSBaseDictionary *this)
{
  if (!*((unsigned char *)this + 72))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (*((unsigned char *)this + 72))
    {
LABEL_18:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
      return *((void *)this + 10);
    }
    if ((*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this)
      && (CFAllocatorRef v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this),
          (CFArrayRef ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(v2, @"DCSDictionaryStyleSheets")) != 0))
    {
      CFArrayRef v4 = ValueForInfoDictionaryKey;
      CFRetain(ValueForInfoDictionaryKey);
    }
    else if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this) {
           || (CFDictionaryRef v5 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this),
    }
               (values = (void *)CFBundleGetValueForInfoDictionaryKey(v5, @"DCSDictionaryCSS")) == 0)
           || (CFArrayRef v4 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E4F1D510])) == 0)
    {
LABEL_17:
      *((unsigned char *)this + 72) = 1;
      goto LABEL_18;
    }
    *((void *)this + 10) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; i != v7; ++i)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, i);
        CFURLRef v10 = (const __CFURL *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 32))(this);
        CFURLRef v11 = CFURLCreateWithString(0, ValueAtIndex, v10);
        if (v11)
        {
          CFURLRef v12 = v11;
          CFArrayAppendValue(*((CFMutableArrayRef *)this + 10), v11);
          CFRelease(v12);
        }
      }
    }
    if (!CFArrayGetCount(*((CFArrayRef *)this + 10)))
    {
      CFRelease(*((CFTypeRef *)this + 10));
      *((void *)this + 10) = 0;
    }
    CFRelease(v4);
    goto LABEL_17;
  }
  return *((void *)this + 10);
}

uint64_t DCSBaseDictionary::styleSheetContents(DCSBaseDictionary *this)
{
  if (!*((unsigned char *)this + 88))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (*((unsigned char *)this + 88))
    {
LABEL_28:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
      return *((void *)this + 12);
    }
    if ((*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this)
      && (CFAllocatorRef v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this),
          (CFArrayRef ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(v2, @"DCSDictionaryStyleSheets")) != 0))
    {
      CFArrayRef v4 = ValueForInfoDictionaryKey;
      CFRetain(ValueForInfoDictionaryKey);
    }
    else if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this) {
           || (CFDictionaryRef v5 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this),
    }
               (values = (void *)CFBundleGetValueForInfoDictionaryKey(v5, @"DCSDictionaryCSS")) == 0)
           || (CFArrayRef v4 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E4F1D510])) == 0)
    {
LABEL_27:
      *((unsigned char *)this + 88) = 1;
      goto LABEL_28;
    }
    *((void *)this + 12) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; v7 != i; ++i)
      {
        CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v4, i);
        uint64_t v10 = (*(uint64_t (**)(DCSBaseDictionary *, const void *, uint64_t, void))(*(void *)this + 384))(this, ValueAtIndex, 1, 0);
        if (v10)
        {
          CFDataRef v11 = (const __CFData *)v10;
          CFStringRef v12 = (const __CFString *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 24))(this);
          if (v12 && CFStringHasPrefix(v12, @"com.apple.dictionary.")
            || (CFStringEncoding v13 = DetectEncodingOfStringData(v11), v13 == -1))
          {
            CFStringRef v14 = CFStringCreateFromExternalRepresentation(0, v11, 0x8000100u);
            if (v14)
            {
              CFStringRef v15 = v14;
              CFRelease(v11);
LABEL_19:
              if (CFStringGetLength(v15) >= 1)
              {
                if (CFStringGetCharacterAtIndex(v15, 0) == 65279)
                {
                  v19.int64_t length = CFStringGetLength(v15) - 1;
                  v19.CFIndex location = 1;
                  CFStringRef v16 = CFStringCreateWithSubstring(0, v15, v19);
                  CFRelease(v15);
                  CFStringRef v15 = v16;
                }
                CFArrayAppendValue(*((CFMutableArrayRef *)this + 12), v15);
                CFRelease(v15);
              }
              continue;
            }
            CFStringEncoding v13 = 256;
          }
          CFStringRef v15 = CFStringCreateFromExternalRepresentation(0, v11, v13);
          CFRelease(v11);
          if (v15) {
            goto LABEL_19;
          }
        }
      }
    }
    if (!CFArrayGetCount(*((CFArrayRef *)this + 12)))
    {
      CFRelease(*((CFTypeRef *)this + 12));
      *((void *)this + 12) = 0;
    }
    CFRelease(v4);
    goto LABEL_27;
  }
  return *((void *)this + 12);
}

uint64_t DCSBaseDictionary::privateFontURLs(DCSBaseDictionary *this)
{
  if (!*((unsigned char *)this + 104))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (!*((unsigned char *)this + 104))
    {
      if ((*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this))
      {
        CFAllocatorRef v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
        CFArrayRef ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(v2, @"DCSDictionaryPrivateFonts");
        if (ValueForInfoDictionaryKey)
        {
          CFArrayRef v4 = ValueForInfoDictionaryKey;
          *((void *)this + 14) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
          CFIndex Count = CFArrayGetCount(v4);
          if (Count >= 1)
          {
            CFIndex v6 = Count;
            for (CFIndex i = 0; i != v6; ++i)
            {
              CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v4, i);
              xpc_object_t value = 0;
              (*(void (**)(DCSBaseDictionary *, const void *, void, void **))(*(void *)this + 384))(this, ValueAtIndex, 0, &value);
              if (value)
              {
                CFArrayAppendValue(*((CFMutableArrayRef *)this + 14), value);
                CFRelease(value);
              }
            }
          }
          if (!CFArrayGetCount(*((CFArrayRef *)this + 14)))
          {
            CFRelease(*((CFTypeRef *)this + 14));
            *((void *)this + 14) = 0;
          }
        }
      }
      *((unsigned char *)this + 104) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
  }
  return *((void *)this + 14);
}

uint64_t DCSBaseDictionary::XSLTData(DCSBaseDictionary *this)
{
  if (!*((unsigned char *)this + 56))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (!*((unsigned char *)this + 56))
    {
      if ((*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this))
      {
        CFAllocatorRef v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
        CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v2, @"DCSDictionaryXSL");
        if (ValueForInfoDictionaryKey) {
          *((void *)this + 8) = (*(uint64_t (**)(DCSBaseDictionary *, CFTypeRef, uint64_t, void))(*(void *)this + 384))(this, ValueForInfoDictionaryKey, 1, 0);
        }
      }
      *((unsigned char *)this + 56) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
  }
  return *((void *)this + 8);
}

CFTypeRef DCSBaseDictionary::elementXPaths(DCSBaseDictionary *this)
{
  CFTypeRef result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, @"DCSElementXPath");
  }
  return result;
}

uint64_t DCSBaseDictionary::preferenceHTML(DCSBaseDictionary *this)
{
  if (!*((unsigned char *)this + 120))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 184));
    if (!*((unsigned char *)this + 120))
    {
      if ((*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this))
      {
        CFAllocatorRef v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
        CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v2, @"DCSDictionaryPrefsHTML");
        if (ValueForInfoDictionaryKey)
        {
          CFDataRef v4 = (const __CFData *)(*(uint64_t (**)(DCSBaseDictionary *, CFTypeRef, uint64_t, void))(*(void *)this + 384))(this, ValueForInfoDictionaryKey, 1, 0);
          if (v4)
          {
            CFDataRef v5 = v4;
            BytePtr = CFDataGetBytePtr(v4);
            CFIndex Length = CFDataGetLength(v5);
            *((void *)this + 16) = CFStringCreateWithBytes(0, BytePtr, Length, 0x8000100u, 0);
            CFRelease(v5);
          }
        }
      }
      *((unsigned char *)this + 120) = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 184));
  }
  return *((void *)this + 16);
}

uint64_t DCSBaseDictionary::preference(DCSBaseDictionary *this)
{
  if (!*((unsigned char *)this + 136))
  {
    if ((*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this))
    {
      CFAllocatorRef v2 = (const void *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 176))(this);
      *((void *)this + 18) = v2;
      if (v2) {
        CFRetain(v2);
      }
    }
    else
    {
      *((void *)this + 18) = 0;
    }
    *((unsigned char *)this + 136) = 1;
  }
  return *((void *)this + 18);
}

CFTypeRef DCSBaseDictionary::defaultPreference(DCSBaseDictionary *this)
{
  CFTypeRef result = (CFTypeRef)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    return CFBundleGetValueForInfoDictionaryKey(v3, @"DCSDictionaryDefaultPrefs");
  }
  return result;
}

void DCSBaseDictionary::setPreference(DCSBaseDictionary *this, CFTypeRef cf)
{
  *((unsigned char *)this + 136) = 1;
  CFRetain(cf);
  CFDataRef v4 = (const void *)*((void *)this + 18);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 18) = cf;
}

const __CFBoolean *DCSBaseDictionary::isSortableDictionary(DCSBaseDictionary *this)
{
  CFBooleanRef result = (const __CFBoolean *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  if (result)
  {
    CFURLRef v3 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    CFBooleanRef result = (const __CFBoolean *)CFBundleGetValueForInfoDictionaryKey(v3, @"DCSDictionarySortAllowed_iOS");
    if (result) {
      return (const __CFBoolean *)(CFBooleanGetValue(result) != 0);
    }
  }
  return result;
}

BOOL DCSBaseDictionary::isAppearanceAwareDictionary(DCSBaseDictionary *this)
{
  uint64_t v1 = this;
  if (*((unsigned char *)this + 168))
  {
    LODWORD(this) = *((unsigned __int8 *)this + 169);
  }
  else
  {
    *((unsigned char *)this + 168) = 1;
    this = (DCSBaseDictionary *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    if (this)
    {
      CFAllocatorRef v2 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)v1 + 376))(v1);
      this = (DCSBaseDictionary *)CFBundleGetValueForInfoDictionaryKey(v2, @"DCSDictionaryUseSystemAppearance");
      if (this) {
        LODWORD(this) = CFBooleanGetValue(this);
      }
    }
    *((unsigned char *)v1 + 169) = (_BYTE)this;
  }
  return this != 0;
}

BOOL DCSBaseDictionary::isLanguageDictionary(DCSBaseDictionary *this)
{
  CFArrayRef v2 = (const __CFArray *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 96))(this);
  if ((*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 88))(this)) {
    return 1;
  }
  if (v2) {
    return CFArrayGetCount(v2) > 1;
  }
  return 0;
}

uint64_t DCSBaseDictionary::previewMarkupVersion(DCSBaseDictionary *this)
{
  CFURLRef v3 = (void *)((char *)this + 176);
  uint64_t result = *((void *)this + 22);
  if (result == -1)
  {
    uint64_t result = (*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
    if (result)
    {
      CFDataRef v4 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
      uint64_t result = (uint64_t)CFBundleGetValueForInfoDictionaryKey(v4, @"DCSDictionaryPreviewMarkupVersion");
      if (result) {
        uint64_t result = CFNumberGetValue((CFNumberRef)result, kCFNumberCFIndexType, v3);
      }
    }
    void *v3 = result;
  }
  return result;
}

BOOL DCSBaseDictionary::isSupportedDefinitionStyle(DCSBaseDictionary *this, uint64_t a2)
{
  if (!*((void *)this + 20))
  {
    if (!(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this)
      || (CFDataRef v4 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this),
          (CFArrayRef ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(v4, @"DCSDictionaryDefinitionDataType")) == 0))
    {
      uint64_t v8 = 1;
      goto LABEL_9;
    }
    CFArrayRef v6 = ValueForInfoDictionaryKey;
    CFIndex Count = CFArrayGetCount(ValueForInfoDictionaryKey);
    v11.CFIndex location = 0;
    v11.int64_t length = Count;
    if (CFArrayGetFirstIndexOfValue(v6, v11, @"DCSDictionaryDefinitionDataXML") != -1) {
      *((void *)this + 20) |= 1uLL;
    }
    v12.CFIndex location = 0;
    v12.int64_t length = Count;
    if (CFArrayGetFirstIndexOfValue(v6, v12, @"DCSDictionaryDefinitionDataRTFD") != -1)
    {
      uint64_t v8 = *((void *)this + 20) | 2;
LABEL_9:
      *((void *)this + 20) = v8;
    }
  }
  uint64_t v9 = 1;
  if (a2 == 4) {
    uint64_t v9 = 2;
  }
  return (*((void *)this + 20) & v9) != 0;
}

CFBundleRef DCSBaseDictionary::bundle(DCSBaseDictionary *this)
{
  CFBundleRef result = (CFBundleRef)*((void *)this + 5);
  if (!result)
  {
    CFURLRef v3 = (const __CFURL *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 16))(this);
    CFBundleRef result = CFBundleCreate(0, v3);
    *((void *)this + 5) = result;
  }
  return result;
}

CFDataRef DCSBaseDictionary::resourceData(DCSBaseDictionary *this, const __CFString *a2, int a3, const __CFURL **a4)
{
  CFDataRef resourceData = 0;
  CFURLRef v8 = (const __CFURL *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 16))(this);
  CFURLRef v9 = CFURLCreateCopyAppendingPathComponent(0, v8, @"Contents", 1u);
  CFURLRef v10 = CFURLCreateCopyAppendingPathComponent(0, v9, a2, 0);
  CFRelease(v9);
  if (a3)
  {
    if (CFURLCreateDataAndPropertiesFromResource(0, v10, &resourceData, 0, 0, 0)) {
      goto LABEL_10;
    }
  }
  else if (ItemExistsAtURL(v10))
  {
    goto LABEL_10;
  }
  CFRelease(v10);
  CFRange v11 = (__CFBundle *)(*(uint64_t (**)(DCSBaseDictionary *))(*(void *)this + 376))(this);
  CFURLRef v12 = CFBundleCopyResourceURL(v11, a2, 0, 0);
  CFURLRef v10 = v12;
  if (!v12)
  {
LABEL_10:
    if (!a4) {
      goto LABEL_13;
    }
LABEL_11:
    *a4 = v10;
    return resourceData;
  }
  if (!a3)
  {
    if (!ItemExistsAtURL(v12)) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  if (CFURLCreateDataAndPropertiesFromResource(0, v12, &resourceData, 0, 0, 0)) {
    goto LABEL_10;
  }
LABEL_12:
  CFRelease(v10);
  CFURLRef v10 = 0;
  if (a4) {
    goto LABEL_11;
  }
LABEL_13:
  if (v10) {
    CFRelease(v10);
  }
  return resourceData;
}

uint64_t DCSBaseDictionary::isLocalizableDictionary(DCSBaseDictionary *this)
{
  return 0;
}

uint64_t DCSBaseDictionary::primaryLocale(DCSBaseDictionary *this)
{
  return 0;
}

uint64_t DCSBaseDictionary::languageDirectionOfFoundRecord()
{
  return 0;
}

void InspectorAccessContext::InspectorAccessContext(InspectorAccessContext *this, IDXIndexInfo *a2)
{
  uint64_t v3 = IDXAccessContext::IDXAccessContext((uint64_t)this, (uint64_t)a2);
  *(void *)uint64_t v3 = &unk_1F2DE3BB8;
  *(void *)(v3 + 56) = 0;
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 32) = 0;
  CFStringRef v4 = (const __CFString *)IDXIndexInfo::relativePath(*(IDXIndexInfo **)(v3 + 8));
  *((unsigned char *)this + 64) = CFEqual(v4, @"NumberValue.index");
}

void sub_1D592A9C4(_Unwind_Exception *a1)
{
  IDXAccessContext::~IDXAccessContext(v1);
  _Unwind_Resume(a1);
}

void InspectorAccessContext::~InspectorAccessContext(InspectorAccessContext *this)
{
  IDXAccessContext::~IDXAccessContext(this);

  JUMPOUT(0x1D94553C0);
}

void sub_1D592AA30(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553C0](v1, 0x10F1C40F8DAED6BLL);
  _Unwind_Resume(a1);
}

BOOL InspectorAccessContext::setSearchCharacters(InspectorAccessContext *this, const unsigned __int16 *__src, unint64_t a3, const __CFString *a4)
{
  CFURLRef v8 = (void *)*((void *)this + 4);
  if (!v8) {
    operator new[]();
  }
  if (a3 <= 0x80)
  {
    *((void *)this + 5) = a3;
    memcpy(v8, __src, 2 * a3);
    *((void *)this + 3) = CFRetain(a4);
    CFURLRef v9 = (const void *)*((void *)this + 7);
    if (v9) {
      CFRelease(v9);
    }
    CFStringRef v10 = CFStringCreateWithBytes(0, (const UInt8 *)__src, 2 * a3, 0x100u, 0);
    *((void *)this + 6) = 0;
    *((void *)this + 7) = v10;
  }
  return a3 < 0x81;
}

uint64_t InspectorAccessContext::getMatchDataPtr(InspectorAccessContext *this, uint64_t a2, const unsigned __int8 **a3, uint64_t *a4)
{
  return 0;
}

uint64_t InspectorAccessContext::getMatchData(InspectorAccessContext *this, uint64_t a2, uint64_t a3, CFRange *a4, CFRange **a5, uint64_t *a6)
{
  uint64_t result = 0;
  *a6 = 0;
  if (*((uint64_t *)this + 6) > 0) {
    return result;
  }
  if (*((unsigned char *)this + 64))
  {
    uint64_t v10 = a3 - 4;
    a4->CFIndex location = a3 - 4;
    a4->int64_t length = 4;
    if (CFEqual(*((CFStringRef *)this + 7), @"openCount"))
    {
      int v12 = IDXIndexInfo::openCount(*((IDXIndexInfo **)this + 1));
      goto LABEL_13;
    }
    if (CFEqual(*((CFStringRef *)this + 7), @"initiallyOpenedCallCount"))
    {
      int v12 = InspectorAccessContext::_initiallyOpenedCallCount;
      goto LABEL_13;
    }
    CFComparisonResult v11 = CFStringCompare(*((CFStringRef *)this + 7), @"lastlyClosedCallCount", 0);
    uint64_t result = 0;
    if (v11 == kCFCompareEqualTo)
    {
      int v12 = InspectorAccessContext::_lastlyClosedCallCount;
LABEL_13:
      *(_DWORD *)((char *)&a4->location + v10) = v12;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = *((void *)this + 5);
    uint64_t v14 = a3 - 2 * v13;
    a4->CFIndex location = v14 - 2;
    a4->int64_t length = 2 * v13 + 2;
    *(_WORD *)((char *)a4 + v14 - 2) = 2 * v13;
    uint64_t v15 = *((void *)this + 5);
    if (v15 < 1)
    {
LABEL_14:
      uint64_t result = 1;
      goto LABEL_15;
    }
    CFStringRef v16 = (unsigned __int8 *)a4 + v14;
    uint64_t v17 = *((void *)this + 4) - 2;
    uint64_t result = 1;
    do
    {
      *(_WORD *)CFStringRef v16 = *(_WORD *)(v17 + 2 * v15);
      v16 += 2;
      --v15;
    }
    while (v15);
  }
LABEL_15:
  if (a5) {
    *a5 = a4;
  }
  *((void *)this + 6) += result;
  return result;
}

uint64_t InspectorAccessContext::supportDataPtr(InspectorAccessContext *this)
{
  return 0;
}

uint64_t InspectorAccessContext::getDataPtrByID(InspectorAccessContext *this, unint64_t a2, uint64_t *a3)
{
  return 0;
}

CFIndex InspectorAccessContext::getDataByID(InspectorAccessContext *this, uint64_t a2, CFIndex a3, unsigned __int8 *a4)
{
  CFTimeZoneRef v7 = CFTimeZoneCopySystem();
  unint64_t v8 = *(_OWORD *)&CFAbsoluteTimeGetGregorianDate((double)a2, v7);
  CFRelease(v7);
  CFStringRef v9 = CFStringCreateWithFormat(0, 0, @"%02d/%02d/%04d", ((int)(v8 >> 8) >> 24), ((int)(v8 >> 16) >> 24), v8);
  CFIndex usedBufLen = 0;
  v12.int64_t length = CFStringGetLength(v9);
  v12.CFIndex location = 0;
  CFStringGetBytes(v9, v12, 0x8000100u, 0, 0, a4, a3, &usedBufLen);
  CFRelease(v9);
  return usedBufLen;
}

uint64_t InspectorAccessContext::addRecord(InspectorAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4, uint64_t a5, unint64_t *a6)
{
  return 0;
}

uint64_t InspectorAccessContext::deleteRecord(InspectorAccessContext *this, const unsigned __int16 *a2, uint64_t a3, const unsigned __int8 *a4)
{
  return 0;
}

BOOL InspectorAccessContext::createIndexFile(InspectorAccessContext *this, IDXIndexInfo *a2)
{
  uint64_t v3 = CFWriteStreamCreateWithFile(0, *(CFURLRef *)this);
  if (!v3) {
    return 0;
  }
  CFStringRef v4 = v3;
  if (CFWriteStreamOpen(v3))
  {
    CFIndex v5 = CFPropertyListWriteToStream(*((CFPropertyListRef *)this + 1), v4, kCFPropertyListXMLFormat_v1_0, 0);
    CFWriteStreamClose(v4);
    BOOL v6 = v5 > 0;
  }
  else
  {
    BOOL v6 = 0;
  }
  CFRelease(v4);
  return v6;
}

uint64_t InspectorAccessContext::initializeSubclass(InspectorAccessContext *this, int a2, void **a3)
{
  if (a2) {
    ++InspectorAccessContext::_initiallyOpenedCallCount;
  }
  return 1;
}

void InspectorAccessContext::finalizeSubclass(InspectorAccessContext *this, int a2)
{
  if (a2) {
    ++InspectorAccessContext::_lastlyClosedCallCount;
  }
}

uint64_t InspectorAccessContext::containsMatchData(InspectorAccessContext *this, unsigned __int8 *a2)
{
  return 0;
}

const void *DCSDictionaryCreateWithAssetAttributes(const __CFDictionary *a1, const __CFURL *a2)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"DictionaryPackageName");
  CFURLRef v4 = CFURLCreateCopyAppendingPathComponent(0, a2, Value, 1u);
  CFIndex v5 = DCSDictionaryCreate(v4);
  CFRelease(v4);
  return v5;
}

void DCSDictionaryAssetAttributesDownloaded(const __CFDictionary *a1)
{
  if (a1)
  {
    CFStringRef Value = CFDictionaryGetValue(a1, @"DictionaryPackageName");
    if (Value)
    {
      uint64_t v3 = Value;
      CFRetain(Value);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __DCSDictionaryAssetAttributesDownloaded_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v3;
      dispatch_async(MEMORY[0x1E4F14428], block);
      DCSMAUpdateLinguisticDataForDictionaryAssetAttribute(a1, 1);
    }
  }
}

void __DCSDictionaryAssetAttributesDownloaded_block_invoke(uint64_t a1)
{
  __DCSDictionaryAssetUpdatePreferences(*(const void **)(a1 + 32), 0);
  CFArrayRef v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

void __DCSDictionaryAssetUpdatePreferences(const void *a1, int a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v6 = (const __CFArray *)DCSCopySharedPreferenceValue(@"DCSAssetPreferenceKeyDownloadedDictionaries", 0, 0);
  if (v6)
  {
    CFArrayRef v7 = v6;
    v17.int64_t length = CFArrayGetCount(v6);
    v17.CFIndex location = 0;
    CFArrayAppendArray(Mutable, v7, v17);
    CFRelease(v7);
  }
  v8.int64_t length = CFArrayGetCount(Mutable);
  v8.CFIndex location = 0;
  if (a2)
  {
    FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(Mutable, v8, a1);
    if (FirstIndexOfValue == -1) {
      goto LABEL_9;
    }
    CFArrayRemoveValueAtIndex(Mutable, FirstIndexOfValue);
  }
  else
  {
    if (CFArrayContainsValue(Mutable, v8, a1)) {
      goto LABEL_9;
    }
    CFArrayAppendValue(Mutable, a1);
  }
  DCSUpdateSharedPreferenceValue(@"DCSAssetPreferenceKeyDownloadedDictionaries", Mutable);
LABEL_9:
  CFRelease(Mutable);
  uint64_t v10 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v11 = (const __CFArray *)DCSCopySharedPreferenceValue(@"DCSAssetPreferenceKeyRemovedDictionaries", 0, 0);
  if (v11)
  {
    CFArrayRef v12 = v11;
    v18.int64_t length = CFArrayGetCount(v11);
    v18.CFIndex location = 0;
    CFArrayAppendArray(v10, v12, v18);
    CFRelease(v12);
  }
  v13.int64_t length = CFArrayGetCount(v10);
  v13.CFIndex location = 0;
  if (a2)
  {
    if (CFArrayContainsValue(v10, v13, a1)) {
      goto LABEL_17;
    }
    CFArrayAppendValue(v10, a1);
  }
  else
  {
    CFIndex v14 = CFArrayGetFirstIndexOfValue(v10, v13, a1);
    if (v14 == -1) {
      goto LABEL_17;
    }
    CFArrayRemoveValueAtIndex(v10, v14);
  }
  DCSUpdateSharedPreferenceValue(@"DCSAssetPreferenceKeyRemovedDictionaries", v10);
LABEL_17:
  CFRelease(v10);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();

  CFNotificationCenterPostNotification(DarwinNotifyCenter, @"DCSActiveDictionariesChangedDistributedNotification", 0, 0, 0);
}

void DCSDictionaryAssetAttributesWillBePurged(const __CFDictionary *a1)
{
  if (a1)
  {
    CFStringRef Value = CFDictionaryGetValue(a1, @"DictionaryPackageName");
    if (Value)
    {
      uint64_t v3 = Value;
      CFRetain(Value);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __DCSDictionaryAssetAttributesWillBePurged_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v3;
      dispatch_async(MEMORY[0x1E4F14428], block);
      DCSMAUpdateLinguisticDataForDictionaryAssetAttribute(a1, 0);
    }
  }
}

void __DCSDictionaryAssetAttributesWillBePurged_block_invoke(uint64_t a1)
{
  __DCSDictionaryAssetUpdatePreferences(*(const void **)(a1 + 32), 1);
  CFArrayRef v2 = *(const void **)(a1 + 32);

  CFRelease(v2);
}

void *DCSDictionaryAssetCopyDownloadedDictionaryIdentifiers()
{
  return DCSCopySharedPreferenceValue(@"DCSAssetPreferenceKeyDownloadedDictionaries", 0, 0);
}

void *DCSDictionaryAssetCopyRemovedDictionaryIdentifiers()
{
  return DCSCopySharedPreferenceValue(@"DCSAssetPreferenceKeyRemovedDictionaries", 0, 0);
}

CFArrayRef DCSCopyLemmas(uint64_t a1, const void *a2)
{
  block[7] = *MEMORY[0x1E4F143B8];
  if (DCSCopyLemmas__OnceToken != -1)
  {
    dispatch_once(&DCSCopyLemmas__OnceToken, &__block_literal_global_7);
    if (!a1) {
      return 0;
    }
LABEL_3:
    if (_GetNLPFrameworkInfo__DispatchOnceToken != -1) {
      dispatch_once(&_GetNLPFrameworkInfo__DispatchOnceToken, &__block_literal_global_14);
    }
    uint64_t v4 = _GetNLPFrameworkInfo__InfoPtr;
    if (!_GetNLPFrameworkInfo__InfoPtr) {
      return 0;
    }
    pthread_mutex_lock(&DCSCopyLemmas__AnalyzersCacheMutex);
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)DCSCopyLemmas__AnalyzersForLanguage, a2);
    if (Value)
    {
      CFDictionaryRef v6 = Value;
      unint64_t v7 = (unint64_t)CFDictionaryGetValue(Value, @"MorphologicalAnalyzer");
      CFDictionaryRef v8 = v6;
    }
    else
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue((CFMutableDictionaryRef)DCSCopyLemmas__AnalyzersForLanguage, a2, Mutable);
      CFRelease(Mutable);
      pthread_mutex_unlock(&DCSCopyLemmas__AnalyzersCacheMutex);
      uint64_t v10 = dispatch_queue_create("dispatch_queue_for_analayzer", 0);
      CFArrayRef v11 = dispatch_group_create();
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __DCSCopyLemmas_block_invoke_2;
      block[3] = &__block_descriptor_56_e5_v8__0l;
      block[4] = v4;
      void block[5] = a2;
      block[6] = 0;
      dispatch_group_async(v11, v10, block);
      dispatch_time_t v12 = dispatch_time(0, 1000000000);
      dispatch_group_wait(v11, v12);
      dispatch_release(v11);
      dispatch_release(v10);
      pthread_mutex_lock(&DCSCopyLemmas__AnalyzersCacheMutex);
      CFDictionaryRef v13 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)DCSCopyLemmas__AnalyzersForLanguage, a2);
      if (!v13)
      {
        unint64_t v15 = 0;
        unint64_t v7 = 0;
LABEL_11:
        pthread_mutex_unlock(&DCSCopyLemmas__AnalyzersCacheMutex);
        if (!(v7 | v15)) {
          return 0;
        }
        if (v7)
        {
          CFArrayRef v16 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
          CFRange v18 = *(void (**)(unint64_t, uint64_t, void *))(v4 + 8);
          v26[0] = MEMORY[0x1E4F143A8];
          v26[1] = 3221225472;
          v26[2] = __DCSCopyLemmas_block_invoke_3;
          v26[3] = &__block_descriptor_40_e41_v32__0____CFString__8____CFString__16_B24l;
          v26[4] = v16;
          v18(v7, a1, v26);
          if (CFArrayGetCount(v16) > 0) {
            return v16;
          }
        }
        else
        {
          if (!v15) {
            return 0;
          }
          CFArrayRef v16 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          v25[1] = MEMORY[0x1E4F143A8];
          v25[2] = 3221225472;
          v25[3] = __DCSCopyLemmas_block_invoke_4;
          v25[4] = &__block_descriptor_48_e27_v28__0____CFString__8C16_20l;
          v25[5] = a1;
          v25[6] = v16;
          LXLemmatizerEnumerateLemmasforString();
          CFIndex Count = CFDictionaryGetCount(v16);
          if (Count >= 1)
          {
            CFIndex v20 = Count;
            MEMORY[0x1F4188790](Count);
            unint64_t v22 = (const void **)((char *)v25 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0));
            if (v21 >= 0x200) {
              size_t v23 = 512;
            }
            else {
              size_t v23 = v21;
            }
            bzero((char *)v25 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v23);
            CFDictionaryGetKeysAndValues(v16, v22, 0);
            CFArrayRef v24 = CFArrayCreate(0, v22, v20, MEMORY[0x1E4F1D510]);
            goto LABEL_24;
          }
        }
        CFArrayRef v24 = 0;
LABEL_24:
        CFRelease(v16);
        return v24;
      }
      CFDictionaryRef v14 = v13;
      unint64_t v7 = (unint64_t)CFDictionaryGetValue(v13, @"MorphologicalAnalyzer");
      CFDictionaryRef v8 = v14;
    }
    unint64_t v15 = (unint64_t)CFDictionaryGetValue(v8, @"Lemmatizer");
    goto LABEL_11;
  }
  if (a1) {
    goto LABEL_3;
  }
  return 0;
}

uint64_t __DCSCopyLemmas_block_invoke()
{
  DCSCopyLemmas__AnalyzersForLanguage = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);

  return pthread_mutex_init(&DCSCopyLemmas__AnalyzersCacheMutex, 0);
}

uint64_t __DCSCopyLemmas_block_invoke_2(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, *(const void **)(*(void *)(a1 + 32) + 16), *(const void **)(a1 + 40));
  uint64_t v3 = (const void *)(**(uint64_t (***)(__CFDictionary *))(a1 + 32))(Mutable);
  CFRelease(Mutable);
  uint64_t v4 = 0;
  if (!*(void *)(a1 + 48)) {
    uint64_t v4 = (const void *)LXLemmatizerCreate();
  }
  pthread_mutex_lock(&DCSCopyLemmas__AnalyzersCacheMutex);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)DCSCopyLemmas__AnalyzersForLanguage, *(const void **)(a1 + 40));
  if (!Value)
  {
    if (!v3) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  CFDictionaryRef v6 = Value;
  if (v3)
  {
    if (!CFDictionaryGetValue(Value, @"MorphologicalAnalyzer")) {
      CFDictionarySetValue(v6, @"MorphologicalAnalyzer", v3);
    }
LABEL_8:
    CFRelease(v3);
LABEL_9:
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (v4)
  {
    if (!CFDictionaryGetValue(Value, @"Lemmatizer")) {
      CFDictionarySetValue(v6, @"Lemmatizer", v4);
    }
LABEL_10:
    CFRelease(v4);
  }
LABEL_11:

  return pthread_mutex_unlock(&DCSCopyLemmas__AnalyzersCacheMutex);
}

void __DCSCopyLemmas_block_invoke_3(uint64_t a1, const void *a2)
{
}

void __DCSCopyLemmas_block_invoke_4(uint64_t a1, CFStringRef theString1)
{
  if (CFStringCompare(theString1, *(CFStringRef *)(a1 + 32), 1uLL))
  {
    uint64_t v4 = *(__CFDictionary **)(a1 + 40);
    CFDictionarySetValue(v4, theString1, &stru_1F2DE4460);
  }
}

double marisa::Agent::Agent(marisa::Agent *this)
{
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  return result;
}

void marisa::Agent::~Agent(marisa::Agent *this)
{
}

void *marisa::Agent::set_query(void *this, const char *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc";
    exception[2] = 0x20000000DLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc:13: MARISA_NULL_ERROR: str == NULL";
  }
  uint64_t v2 = this[5];
  if (v2) {
    *(_DWORD *)(v2 + 108) = 0;
  }
  uint64_t v3 = 0;
  while (a2[v3++])
    ;
  *this = a2;
  this[1] = v3 - 1;
  return this;
}

void *marisa::Agent::set_query(void *this, const char *a2, uint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc";
    exception[2] = 0x200000015;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc:21: MARISA_NULL_ERROR: (ptr == NULL)"
                   " && (length != 0)";
  }
  uint64_t v3 = this[5];
  if (v3) {
    *(_DWORD *)(v3 + 108) = 0;
  }
  *this = a2;
  this[1] = a3;
  return this;
}

uint64_t marisa::Agent::set_query(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(void *)(this + 40);
  if (v2) {
    *(_DWORD *)(v2 + 108) = 0;
  }
  *(void *)(this + 16) = a2;
  return this;
}

void *marisa::Agent::init_state(marisa::Agent *this)
{
  uint64_t v1 = (uint64_t *)((char *)this + 40);
  if (*((void *)this + 5))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc";
    exception[2] = 0x100000024;
    CFIndex v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc:36: MARISA_STATE_ERROR: state_.get() != NULL";
    goto LABEL_8;
  }
  uint64_t v2 = operator new(0x70uLL, MEMORY[0x1E4FBA2D0]);
  if (v2)
  {
    *(_OWORD *)((char *)v2 + 2marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
    *uint64_t v2 = 0u;
    v2[1] = 0u;
    v2[3] = 0u;
    v2[4] = 0u;
    *(_OWORD *)((char *)v2 + 73) = 0u;
    *((void *)v2 + 12) = 0;
    *((void *)v2 + 13) = 0;
  }
  double result = marisa::scoped_ptr<marisa::grimoire::trie::State>::reset(v1, (uint64_t)v2);
  if (!*v1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc";
    exception[2] = 0x800000026;
    CFIndex v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/agent.cc:38: MARISA_MEMORY_ERROR: state_.get() == NULL";
LABEL_8:
    exception[3] = v5;
  }
  return result;
}

void *marisa::scoped_ptr<marisa::grimoire::trie::State>::reset(uint64_t *a1, uint64_t a2)
{
  if (a2 && *a1 == a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/include/marisa/scoped-ptr.h";
    exception[2] = 0x600000013;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/include/marisa/scoped-ptr.h:19: MARISA_RESET_ERROR: (ptr"
                   " != NULL) && (ptr == ptr_)";
  }
  uint64_t v4 = *a1;
  *a1 = a2;
  return marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr(&v4);
}

void *marisa::Agent::clear(marisa::Agent *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  uint64_t v2 = *((void *)this + 5);
  *((void *)this + 4) = 0;
  *((void *)this + marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0;
  return marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr(&v2);
}

uint64_t *marisa::Agent::swap(uint64_t *this, marisa::Agent *a2)
{
  uint64_t v2 = *this;
  uint64_t v3 = this[1];
  uint64_t v4 = *((void *)a2 + 1);
  *this = *(void *)a2;
  this[1] = v4;
  *(void *)a2 = v2;
  *((void *)a2 + 1) = v3;
  uint64_t v5 = this[2];
  uint64_t v6 = this[3];
  uint64_t v7 = *((void *)a2 + 3);
  this[2] = *((void *)a2 + 2);
  this[3] = v7;
  *((void *)a2 + 2) = v5;
  *((void *)a2 + 3) = v6;
  LODWORD(vmarisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  *((_DWORD *)a2 + 8) = v5;
  LODWORD(vmarisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = *((_DWORD *)this + 9);
  *((_DWORD *)this + 9) = *((_DWORD *)a2 + 9);
  *((_DWORD *)a2 + 9) = v5;
  uint64_t v8 = this[5];
  this[5] = *((void *)a2 + 5);
  *((void *)a2 + marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = v8;
  return this;
}

void marisa::Exception::~Exception(std::exception *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x1D94553C0);
}

uint64_t marisa::Exception::what(marisa::Exception *this)
{
  return *((void *)this + 3);
}

void *marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr(void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    uint64_t v3 = v2[6];
    if (v3) {
      MEMORY[0x1D9455390](v3, 0x1000C8077774924);
    }
    if (*v2) {
      MEMORY[0x1D9455390](*v2, 0x1000C8077774924);
    }
    MEMORY[0x1D94553C0](v2, 0x1070C406A3FAA47);
  }
  return a1;
}

uint64_t marisa::grimoire::io::Mapper::Mapper(uint64_t this)
{
  *(void *)this = 0;
  *(void *)(this + 8) = -1;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = -1;
  return this;
}

void marisa::grimoire::io::Mapper::~Mapper(marisa::grimoire::io::Mapper *this)
{
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2 != (void *)-1) {
    munmap(v2, *((void *)this + 3));
  }
  int v3 = *((_DWORD *)this + 8);
  if (v3 != -1) {
    close(v3);
  }
}

void marisa::grimoire::io::Mapper::open(marisa::grimoire::io::Mapper *this, const char *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x200000037;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:55: MARISA_NULL_ERROR: "
                   "filename == NULL";
  }
  *(void *)&long long v8 = 0;
  *((void *)&v8 + 1) = -1;
  long long v9 = 0uLL;
  int v10 = -1;
  marisa::grimoire::io::Mapper::open_((marisa::grimoire::io::Mapper *)&v8, a2);
  long long v3 = v9;
  long long v4 = *(_OWORD *)this;
  long long v5 = *((_OWORD *)this + 1);
  *(_OWORD *)this = v8;
  *((_OWORD *)this + 1) = v3;
  long long v8 = v4;
  long long v9 = v5;
  int v6 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = v10;
  int v10 = v6;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)&v8);
}

void sub_1D592BF14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *marisa::grimoire::io::Mapper::open_(marisa::grimoire::io::Mapper *this, const char *a2)
{
  if (stat(a2, &v8))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x90000008DLL;
    uint64_t v7 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:141: MARISA_IO_ERROR: ::stat(filename, &st) != 0";
    goto LABEL_8;
  }
  *((void *)this + 3) = v8.st_size;
  int v4 = open(a2, 0);
  *((_DWORD *)this + 8) = v4;
  if (v4 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x900000092;
    uint64_t v7 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:146: MARISA_IO_ERROR: fd_ == -1";
    goto LABEL_8;
  }
  double result = mmap(0, *((void *)this + 3), 1, 1, v4, 0);
  *((void *)this + 1) = result;
  if (result == (void *)-1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x900000095;
    uint64_t v7 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:149: MARISA_IO_ERROR: origin_ == MAP_FAILED";
LABEL_8:
    exception[3] = v7;
  }
  *(void *)this = result;
  *((void *)this + 2) = *((void *)this + 3);
  return result;
}

uint64_t *marisa::grimoire::io::Mapper::swap(uint64_t *this, marisa::grimoire::io::Mapper *a2)
{
  uint64_t v2 = *this;
  *this = *(void *)a2;
  *(void *)a2 = v2;
  uint64_t v4 = this[1];
  uint64_t v3 = this[2];
  uint64_t v5 = *((void *)a2 + 2);
  this[1] = *((void *)a2 + 1);
  this[2] = v5;
  *((void *)a2 + 1) = v4;
  *((void *)a2 + 2) = v3;
  uint64_t v6 = this[3];
  this[3] = *((void *)a2 + 3);
  *((void *)a2 + 3) = v6;
  LODWORD(v6) = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  *((_DWORD *)a2 + 8) = v6;
  return this;
}

__n128 marisa::grimoire::io::Mapper::open(marisa::grimoire::io::Mapper *this, const void *a2, uint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x20000003FLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:63: MARISA_NULL_ERROR: "
                   "(ptr == NULL) && (size != 0)";
  }
  long long v3 = *(_OWORD *)this;
  long long v4 = *((_OWORD *)this + 1);
  *(void *)this = a2;
  *((void *)this + 1) = -1;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  v8[0] = v3;
  v8[1] = v4;
  int v5 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = -1;
  int v9 = v5;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)v8);
  return result;
}

void *marisa::grimoire::io::Mapper::open_(void *this, const void *a2, uint64_t a3)
{
  *this = a2;
  this[2] = a3;
  return this;
}

uint64_t marisa::grimoire::io::Mapper::seek(marisa::grimoire::io::Mapper *this, unint64_t a2)
{
  if (!*(void *)this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x100000047;
    long long v4 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:71: MARISA_STATE_ERROR: !is_open()";
    goto LABEL_8;
  }
  if (*((void *)this + 2) < a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x900000048;
    long long v4 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:72: MARISA_IO_ERROR: size > avail_";
LABEL_8:
    exception[3] = v4;
  }

  return marisa::grimoire::io::Mapper::map_data(this, a2);
}

BOOL marisa::grimoire::io::Mapper::is_open(marisa::grimoire::io::Mapper *this)
{
  return *(void *)this != 0;
}

uint64_t marisa::grimoire::io::Mapper::map_data(marisa::grimoire::io::Mapper *this, unint64_t a2)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x100000063;
    stat v8 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:99: MARISA_STATE_ERROR: !is_open()";
LABEL_6:
    exception[3] = v8;
  }
  unint64_t v3 = *((void *)this + 2);
  BOOL v4 = v3 >= a2;
  unint64_t v5 = v3 - a2;
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc";
    exception[2] = 0x900000064;
    stat v8 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/mapper.cc:100: MARISA_IO_ERROR: size > avail_";
    goto LABEL_6;
  }
  *(void *)this = v2 + a2;
  *((void *)this + 2) = v5;
  return v2;
}

__n128 marisa::grimoire::io::Mapper::clear(marisa::grimoire::io::Mapper *this)
{
  long long v1 = *(_OWORD *)this;
  long long v2 = *((_OWORD *)this + 1);
  *(void *)this = 0;
  *((void *)this + 1) = -1;
  v4[0] = v1;
  v4[1] = v2;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  int v5 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = -1;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)v4);
  return result;
}

uint64_t marisa::grimoire::io::Reader::Reader(uint64_t this)
{
  *(void *)this = 0;
  *(_DWORD *)(this + 8) = -1;
  *(void *)(this + 16) = 0;
  *(unsigned char *)(this + 24) = 0;
  return this;
}

void marisa::grimoire::io::Reader::~Reader(FILE **this)
{
  if (*((unsigned char *)this + 24)) {
    fclose(*this);
  }
}

FILE *marisa::grimoire::io::Reader::open(FILE **this, const char *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x20000001BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:27: MARISA_NULL_ERROR: "
                   "filename == NULL";
  }
  uint64_t v6 = 0;
  int v7 = -1;
  stat v8 = 0;
  char v9 = 0;
  marisa::grimoire::io::Reader::open_((marisa::grimoire::io::Reader *)&v6, a2);
  __n128 result = *this;
  *this = v6;
  *((_DWORD *)this + 2) = v7;
  this[2] = v8;
  int v4 = *((unsigned __int8 *)this + 24);
  *((unsigned char *)this + 24) = v9;
  if (v4)
  {
    return (FILE *)fclose(result);
  }
  return result;
}

void sub_1D592C4F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, FILE *a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a12) {
    fclose(a9);
  }
  _Unwind_Resume(exception_object);
}

FILE *marisa::grimoire::io::Reader::open_(marisa::grimoire::io::Reader *this, const char *__filename)
{
  __n128 result = fopen(__filename, "rb");
  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x90000005ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:94: MARISA_IO_ERROR: file == NULL";
  }
  *(void *)this = result;
  *((unsigned char *)this + 24) = 1;
  return result;
}

uint64_t *marisa::grimoire::io::Reader::swap(uint64_t *this, marisa::grimoire::io::Reader *a2)
{
  uint64_t v2 = *this;
  *this = *(void *)a2;
  *(void *)a2 = v2;
  LODWORD(v2) = *((_DWORD *)this + 2);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)a2 + 2) = v2;
  uint64_t v3 = this[2];
  this[2] = *((void *)a2 + 2);
  *((void *)a2 + 2) = v3;
  LOBYTE(v3) = *((unsigned char *)this + 24);
  *((unsigned char *)this + 24) = *((unsigned char *)a2 + 24);
  *((unsigned char *)a2 + 24) = v3;
  return this;
}

FILE *marisa::grimoire::io::Reader::open(FILE **this, __sFILE *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x200000023;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:35: MARISA_NULL_ERROR: file == NULL";
  }
  __n128 result = *this;
  *this = a2;
  *((_DWORD *)this + 2) = -1;
  this[2] = 0;
  int v4 = *((unsigned __int8 *)this + 24);
  *((unsigned char *)this + 24) = 0;
  if (v4)
  {
    return (FILE *)fclose(result);
  }
  return result;
}

void *marisa::grimoire::io::Reader::open_(void *this, __sFILE *a2)
{
  *this = a2;
  return this;
}

FILE *marisa::grimoire::io::Reader::open(FILE **this, int a2)
{
  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x50000002BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:43: MARISA_CODE_ERROR: fd == -1";
  }
  __n128 result = *this;
  *this = 0;
  *((_DWORD *)this + 2) = a2;
  this[2] = 0;
  int v4 = *((unsigned __int8 *)this + 24);
  *((unsigned char *)this + 24) = 0;
  if (v4)
  {
    return (FILE *)fclose(result);
  }
  return result;
}

uint64_t marisa::grimoire::io::Reader::open_(uint64_t this, int a2)
{
  *(_DWORD *)(this + 8) = a2;
  return this;
}

FILE *marisa::grimoire::io::Reader::open(uint64_t a1, uint64_t a2)
{
  __n128 result = *(FILE **)a1;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = -1;
  *(void *)(a1 + 16) = a2;
  int v4 = *(unsigned __int8 *)(a1 + 24);
  *(unsigned char *)(a1 + 24) = 0;
  if (v4) {
    return (FILE *)fclose(result);
  }
  return result;
}

uint64_t marisa::grimoire::io::Reader::open_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  return result;
}

FILE *marisa::grimoire::io::Reader::clear(FILE **this)
{
  __n128 result = *this;
  *this = 0;
  *((_DWORD *)this + 2) = -1;
  this[2] = 0;
  int v3 = *((unsigned __int8 *)this + 24);
  *((unsigned char *)this + 24) = 0;
  if (v3) {
    return (FILE *)fclose(result);
  }
  return result;
}

uint64_t marisa::grimoire::io::Reader::seek(uint64_t this, size_t __nitems)
{
  size_t v2 = __nitems;
  uint64_t v3 = this;
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (!*(void *)this && *(_DWORD *)(this + 8) == -1 && !*(void *)(this + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x100000044;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:68: MARISA_STATE_ERROR: !is_open()";
  }
  if (__nitems)
  {
    if (__nitems > 0x10)
    {
      do
      {
        if (v2 >= 0x400) {
          size_t v4 = 1024;
        }
        else {
          size_t v4 = v2;
        }
        this = marisa::grimoire::io::Reader::read_data(v3, v6, v4);
        v2 -= v4;
      }
      while (v2);
    }
    else
    {
      return marisa::grimoire::io::Reader::read_data(this, v6, __nitems);
    }
  }
  return this;
}

BOOL marisa::grimoire::io::Reader::is_open(marisa::grimoire::io::Reader *this)
{
  return *(void *)this || *((_DWORD *)this + 2) != -1 || *((void *)this + 2) != 0;
}

uint64_t marisa::grimoire::io::Reader::read_data(uint64_t this, char *a2, size_t __nitems)
{
  size_t v3 = __nitems;
  size_t v4 = a2;
  uint64_t v5 = this;
  uint64_t v6 = *(FILE **)this;
  if (!*(void *)this && *(_DWORD *)(this + 8) == -1 && !*(void *)(this + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
    exception[2] = 0x100000071;
    char v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:113: MARISA_STATE_ERROR: !is_open()";
    goto LABEL_19;
  }
  if (__nitems)
  {
    if (*(_DWORD *)(this + 8) != -1)
    {
      while (1)
      {
        size_t v7 = v3 >= 0x7FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v3;
        this = read(*(_DWORD *)(v5 + 8), v4, v7);
        if (this <= 0) {
          break;
        }
        v4 += this;
        v3 -= this;
        if (!v3) {
          return this;
        }
      }
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
      exception[2] = 0x900000081;
      char v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:129: MARISA_IO_ERROR: size_read <= 0";
LABEL_19:
      exception[3] = v9;
    }
    if (v6)
    {
      this = fread(a2, 1uLL, __nitems, v6);
      if (this != v3)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        void *exception = &unk_1F2DE3CA8;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
        exception[2] = 0x900000086;
        char v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:134: MARISA_IO_ERROR: ::fread"
             "(buf, 1, size, file_) != size";
        goto LABEL_19;
      }
    }
    else
    {
      this = *(void *)(this + 16);
      if (this)
      {
        this = std::istream::read();
        if ((*(unsigned char *)(this + *(void *)(*(void *)this - 24) + 32) & 5) != 0)
        {
          int v10 = __cxa_allocate_exception(0x20uLL);
          *int v10 = &unk_1F2DE3CA8;
          v10[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc";
          v10[2] = 0x90000008ALL;
          v10[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/reader.cc:138: MARISA_IO_ERROR: !"
                   "stream_->read(static_cast<char *>(buf), size)";
        }
      }
    }
  }
  return this;
}

void sub_1D592CB50()
{
}

void sub_1D592CBCC()
{
}

FILE *marisa::grimoire::io::Writer::open(FILE **this, const char *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x20000001BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:27: MARISA_NULL_ERROR: "
                   "filename == NULL";
  }
  uint64_t v6 = 0;
  int v7 = -1;
  stat v8 = 0;
  char v9 = 0;
  marisa::grimoire::io::Writer::open_((marisa::grimoire::io::Writer *)&v6, a2);
  __n128 result = *this;
  *this = v6;
  *((_DWORD *)this + 2) = v7;
  this[2] = v8;
  int v4 = *((unsigned __int8 *)this + 24);
  *((unsigned char *)this + 24) = v9;
  if (v4)
  {
    return (FILE *)fclose(result);
  }
  return result;
}

void sub_1D592CCD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, FILE *a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a12) {
    fclose(a9);
  }
  _Unwind_Resume(exception_object);
}

FILE *marisa::grimoire::io::Writer::open_(marisa::grimoire::io::Writer *this, const char *__filename)
{
  __n128 result = fopen(__filename, "wb");
  if (!result)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x90000005ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:94: MARISA_IO_ERROR: file == NULL";
  }
  *(void *)this = result;
  *((unsigned char *)this + 24) = 1;
  return result;
}

FILE *marisa::grimoire::io::Writer::open(FILE **this, __sFILE *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x200000023;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:35: MARISA_NULL_ERROR: file == NULL";
  }
  __n128 result = *this;
  *this = a2;
  *((_DWORD *)this + 2) = -1;
  this[2] = 0;
  int v4 = *((unsigned __int8 *)this + 24);
  *((unsigned char *)this + 24) = 0;
  if (v4)
  {
    return (FILE *)fclose(result);
  }
  return result;
}

FILE *marisa::grimoire::io::Writer::open(FILE **this, int a2)
{
  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x50000002BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:43: MARISA_CODE_ERROR: fd == -1";
  }
  __n128 result = *this;
  *this = 0;
  *((_DWORD *)this + 2) = a2;
  this[2] = 0;
  int v4 = *((unsigned __int8 *)this + 24);
  *((unsigned char *)this + 24) = 0;
  if (v4)
  {
    return (FILE *)fclose(result);
  }
  return result;
}

uint64_t marisa::grimoire::io::Writer::seek(uint64_t this, size_t __nitems)
{
  size_t v2 = __nitems;
  uint64_t v3 = this;
  __buf[128] = *MEMORY[0x1E4F143B8];
  if (!*(void *)this && *(_DWORD *)(this + 8) == -1 && !*(void *)(this + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x100000044;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:68: MARISA_STATE_ERROR: !is_open()";
  }
  if (__nitems)
  {
    if (__nitems > 0x10)
    {
      bzero(__buf, 0x400uLL);
      do
      {
        if (v2 >= 0x400) {
          size_t v4 = 1024;
        }
        else {
          size_t v4 = v2;
        }
        this = marisa::grimoire::io::Writer::write_data(v3, (char *)__buf, v4);
        v2 -= v4;
      }
      while (v2);
    }
    else
    {
      __buf[0] = 0;
      __buf[1] = 0;
      return marisa::grimoire::io::Writer::write_data(this, (char *)__buf, __nitems);
    }
  }
  return this;
}

uint64_t marisa::grimoire::io::Writer::write_data(uint64_t this, char *__buf, size_t __nitems)
{
  size_t v3 = __nitems;
  size_t v4 = __buf;
  uint64_t v5 = this;
  uint64_t v6 = *(FILE **)this;
  if (!*(void *)this && *(_DWORD *)(this + 8) == -1 && !*(void *)(this + 16))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
    exception[2] = 0x100000071;
    char v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:113: MARISA_STATE_ERROR: !is_open()";
    goto LABEL_20;
  }
  if (__nitems)
  {
    if (*(_DWORD *)(this + 8) != -1)
    {
      while (1)
      {
        size_t v7 = v3 >= 0x7FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v3;
        this = write(*(_DWORD *)(v5 + 8), v4, v7);
        if (this <= 0) {
          break;
        }
        v4 += this;
        v3 -= this;
        if (!v3) {
          return this;
        }
      }
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
      exception[2] = 0x900000081;
      char v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:129: MARISA_IO_ERROR: size_written <= 0";
LABEL_20:
      exception[3] = v9;
    }
    if (v6)
    {
      if (fwrite(__buf, 1uLL, __nitems, v6) != __nitems)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        void *exception = &unk_1F2DE3CA8;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
        exception[2] = 0x900000086;
        char v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:134: MARISA_IO_ERROR: ::fwrit"
             "e(data, 1, size, file_) != size";
        goto LABEL_20;
      }
      this = fflush(*(FILE **)v5);
      if (this)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        void *exception = &unk_1F2DE3CA8;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
        exception[2] = 0x900000087;
        char v9 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:135: MARISA_IO_ERROR: ::fflush(file_) != 0";
        goto LABEL_20;
      }
    }
    else
    {
      this = *(void *)(this + 16);
      if (this)
      {
        this = std::ostream::write();
        if ((*(unsigned char *)(this + *(void *)(*(void *)this - 24) + 32) & 5) != 0)
        {
          int v10 = __cxa_allocate_exception(0x20uLL);
          *int v10 = &unk_1F2DE3CA8;
          v10[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc";
          v10[2] = 0x90000008BLL;
          v10[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/io/writer.cc:139: MARISA_IO_ERROR: !"
                   "stream_->write(static_cast<const char *>(data), size)";
        }
      }
    }
  }
  return this;
}

void sub_1D592D2B4()
{
}

void sub_1D592D330()
{
}

marisa::grimoire::trie::LoudsTrie *marisa::grimoire::trie::LoudsTrie::LoudsTrie(marisa::grimoire::trie::LoudsTrie *this)
{
  *(_OWORD *)((char *)this + 2marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 137) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *(_OWORD *)((char *)this + 18marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 89) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *(_OWORD *)((char *)this + 233) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *(_OWORD *)((char *)this + 34marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 393) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 297) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *(_OWORD *)((char *)this + 441) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *(_OWORD *)((char *)this + 553) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_OWORD *)this + 34) = 0u;
  *(_OWORD *)((char *)this + 601) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *(_OWORD *)((char *)this + 50marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *(_OWORD *)((char *)this + 649) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 697) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((void *)this + 90) = 0;
  *((_DWORD *)this + 182) = 0;
  *((void *)this + 92) = 0;
  marisa::grimoire::trie::Tail::Tail((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744));
  *((unsigned char *)this + 1048) = 0;
  *(_OWORD *)((char *)this + 1016) = 0u;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *((_OWORD *)this + 66) = 0u;
  *((void *)this + 134) = 3;
  *((void *)this + 13marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0x100000000200;
  *((_DWORD *)this + 272) = 0x20000;
  marisa::grimoire::io::Mapper::Mapper((uint64_t)this + 1096);
  return this;
}

void sub_1D592D468(_Unwind_Exception *a1)
{
  uint64_t v9 = *((void *)v1 + 126);
  if (v9) {
    MEMORY[0x1D9455390](v9, 0x1000C8077774924);
  }
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(v5);
  marisa::grimoire::trie::Tail::~Tail(v4);
  if (*v7) {
    MEMORY[0x1D9455390](*v7, 0x1000C8077774924);
  }
  if (*v6) {
    MEMORY[0x1D9455390](*v6, 0x1000C8077774924);
  }
  marisa::grimoire::vector::BitVector::~BitVector(v3);
  marisa::grimoire::vector::BitVector::~BitVector(v2);
  marisa::grimoire::vector::BitVector::~BitVector(v1);
  _Unwind_Resume(a1);
}

void marisa::grimoire::trie::Tail::~Tail(marisa::grimoire::trie::Tail *this)
{
  uint64_t v2 = *((void *)this + 26);
  if (v2) {
    MEMORY[0x1D9455390](v2, 0x1000C8077774924);
  }
  uint64_t v3 = *((void *)this + 20);
  if (v3) {
    MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  uint64_t v4 = *((void *)this + 14);
  if (v4) {
    MEMORY[0x1D9455390](v4, 0x1000C8077774924);
  }
  uint64_t v5 = *((void *)this + 6);
  if (v5) {
    MEMORY[0x1D9455390](v5, 0x1000C8077774924);
  }
  if (*(void *)this) {
    MEMORY[0x1D9455390](*(void *)this, 0x1000C8077774924);
  }
}

void marisa::grimoire::vector::BitVector::~BitVector(marisa::grimoire::vector::BitVector *this)
{
  uint64_t v2 = *((void *)this + 20);
  if (v2) {
    MEMORY[0x1D9455390](v2, 0x1000C8077774924);
  }
  uint64_t v3 = *((void *)this + 14);
  if (v3) {
    MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  uint64_t v4 = *((void *)this + 8);
  if (v4) {
    MEMORY[0x1D9455390](v4, 0x1000C8077774924);
  }
  if (*(void *)this) {
    MEMORY[0x1D9455390](*(void *)this, 0x1000C8077774924);
  }
}

void marisa::grimoire::trie::LoudsTrie::~LoudsTrie(marisa::grimoire::trie::LoudsTrie *this)
{
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::trie::LoudsTrie *)((char *)this + 1096));
  uint64_t v2 = *((void *)this + 126);
  if (v2) {
    MEMORY[0x1D9455390](v2, 0x1000C8077774924);
  }
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)this + 125);
  uint64_t v3 = *((void *)this + 119);
  if (v3) {
    MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  uint64_t v4 = *((void *)this + 113);
  if (v4) {
    MEMORY[0x1D9455390](v4, 0x1000C8077774924);
  }
  uint64_t v5 = *((void *)this + 107);
  if (v5) {
    MEMORY[0x1D9455390](v5, 0x1000C8077774924);
  }
  uint64_t v6 = *((void *)this + 99);
  if (v6) {
    MEMORY[0x1D9455390](v6, 0x1000C8077774924);
  }
  uint64_t v7 = *((void *)this + 93);
  if (v7) {
    MEMORY[0x1D9455390](v7, 0x1000C8077774924);
  }
  uint64_t v8 = *((void *)this + 84);
  if (v8) {
    MEMORY[0x1D9455390](v8, 0x1000C8077774924);
  }
  uint64_t v9 = *((void *)this + 78);
  if (v9) {
    MEMORY[0x1D9455390](v9, 0x1000C8077774924);
  }
  uint64_t v10 = *((void *)this + 72);
  if (v10) {
    MEMORY[0x1D9455390](v10, 0x1000C8077774924);
  }
  uint64_t v11 = *((void *)this + 66);
  if (v11) {
    MEMORY[0x1D9455390](v11, 0x1000C8077774924);
  }
  uint64_t v12 = *((void *)this + 60);
  if (v12) {
    MEMORY[0x1D9455390](v12, 0x1000C8077774924);
  }
  uint64_t v13 = *((void *)this + 52);
  if (v13) {
    MEMORY[0x1D9455390](v13, 0x1000C8077774924);
  }
  uint64_t v14 = *((void *)this + 46);
  if (v14) {
    MEMORY[0x1D9455390](v14, 0x1000C8077774924);
  }
  uint64_t v15 = *((void *)this + 40);
  if (v15) {
    MEMORY[0x1D9455390](v15, 0x1000C8077774924);
  }
  uint64_t v16 = *((void *)this + 34);
  if (v16) {
    MEMORY[0x1D9455390](v16, 0x1000C8077774924);
  }
  uint64_t v17 = *((void *)this + 26);
  if (v17) {
    MEMORY[0x1D9455390](v17, 0x1000C8077774924);
  }
  uint64_t v18 = *((void *)this + 20);
  if (v18) {
    MEMORY[0x1D9455390](v18, 0x1000C8077774924);
  }
  uint64_t v19 = *((void *)this + 14);
  if (v19) {
    MEMORY[0x1D9455390](v19, 0x1000C8077774924);
  }
  uint64_t v20 = *((void *)this + 8);
  if (v20) {
    MEMORY[0x1D9455390](v20, 0x1000C8077774924);
  }
  if (*(void *)this) {
    MEMORY[0x1D9455390](*(void *)this, 0x1000C8077774924);
  }
}

void marisa::grimoire::trie::LoudsTrie::build(marisa::grimoire::trie::LoudsTrie *this, marisa::Keyset *a2, unsigned int a3)
{
  uint64_t v5 = 3;
  uint64_t v6 = 0x100000000200;
  int v7 = 0x20000;
  marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v5, a3);
  v8[0] = v5;
  v8[1] = v6;
  int v9 = v7;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie((marisa::grimoire::trie::LoudsTrie *)&v5);
  marisa::grimoire::trie::LoudsTrie::build_((marisa::grimoire::trie::LoudsTrie *)&v5, a2, (const marisa::grimoire::trie::Config *)v8);
  marisa::grimoire::trie::LoudsTrie::swap(this, (marisa::grimoire::trie::LoudsTrie *)&v5);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)&v5);
}

void sub_1D592D948(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)va);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_(marisa::grimoire::trie::LoudsTrie *this, marisa::Keyset *a2, const marisa::grimoire::trie::Config *a3)
{
  memset(v31, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::resize((uint64_t *)v31, *((void *)a2 + 11));
  if (*((void *)a2 + 11))
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      uint64_t v8 = *((void *)&v31[0] + 1) + v6;
      uint64_t v9 = *(void *)(*((void *)a2 + 6) + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v7;
      int v10 = *(_DWORD *)(v9 + 8);
      *(void *)uint64_t v8 = *(void *)v9;
      *(_DWORD *)(v8 + 8) = v10;
      *(_DWORD *)(v8 + 12) = *(_DWORD *)(v9 + 12);
      ++v7;
      v6 += 24;
    }
    while (v7 < *((void *)a2 + 11));
  }
  long long v29 = 0u;
  memset(v30, 0, 25);
  marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::Key>((uint64_t)this, (uint64_t *)v31, &v29, (uint64_t)a3, 1);
  memset(v28, 0, 41);
  marisa::grimoire::vector::Vector<std::pair<unsigned int,unsigned int>>::resize((uint64_t *)v28, v30[1]);
  unint64_t v11 = *((void *)&v28[1] + 1);
  if (*((void *)&v28[1] + 1))
  {
    uint64_t v12 = 0;
    uint64_t v13 = *((void *)&v29 + 1);
    uint64_t v14 = (_DWORD *)(*((void *)&v28[0] + 1) + 4);
    do
    {
      *(v14 - 1) = *(_DWORD *)(v13 + 4 * v12);
      *uint64_t v14 = v12++;
      v14 += 2;
    }
    while (v11 != v12);
  }
  uint64_t v15 = v29;
  long long v29 = 0u;
  memset(v30, 0, 25);
  if (v15)
  {
    MEMORY[0x1D9455390](v15, 0x1000C8077774924);
    unint64_t v11 = *((void *)&v28[1] + 1);
  }
  unint64_t v16 = 126 - 2 * __clz(v11);
  if (v11) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>(*((uint64_t *)&v28[0] + 1), (unsigned int *)(*((void *)&v28[0] + 1) + 8 * v11), (uint64_t)&v32, v17, 1);
  if (*((void *)&v28[1] + 1))
  {
    unint64_t v18 = 0;
    unint64_t v19 = 0;
    do
    {
      for (uint64_t i = *((void *)&v28[0] + 1); ; uint64_t i = *((void *)&v28[0] + 1))
      {
        unint64_t v21 = *(unsigned int *)(i + 8 * v18);
        if (v19 >= v21) {
          break;
        }
        marisa::grimoire::vector::BitVector::push_back((uint64_t *)this + 26, 0);
        ++v19;
      }
      if (v19 == v21)
      {
        marisa::grimoire::vector::BitVector::push_back((uint64_t *)this + 26, 1);
        ++v19;
      }
      ++v18;
    }
    while (v18 < *((void *)&v28[1] + 1));
  }
  else
  {
    unint64_t v19 = 0;
  }
  for (; v19 < *((void *)this + 81); ++v19)
    marisa::grimoire::vector::BitVector::push_back((uint64_t *)this + 26, 0);
  unint64_t v22 = (uint64_t *)((char *)this + 208);
  marisa::grimoire::vector::BitVector::push_back(v22, 0);
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)v22, 0, 1);
  if (*((void *)a2 + 11))
  {
    uint64_t v23 = 0;
    unint64_t v24 = 0;
    do
    {
      unint64_t v25 = *(unsigned int *)(*((void *)&v28[0] + 1) + v23 + 4);
      uint64_t v26 = *(void *)(*((void *)a2 + 6) + ((v25 >> 5) & 0x7FFFFF8));
      *(_DWORD *)(v26 + 16 * v25 + 12) = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::vector::BitVector *)v22, *(unsigned int *)(*((void *)&v28[0] + 1) + v23));
      ++v24;
      v23 += 8;
    }
    while (v24 < *((void *)a2 + 11));
  }
  if (*(void *)&v28[0]) {
    MEMORY[0x1D9455390](*(void *)&v28[0], 0x1000C8077774924);
  }
  if ((void)v29) {
    MEMORY[0x1D9455390](v29, 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v31[0];
  if (*(void *)&v31[0]) {
    return MEMORY[0x1D9455390](*(void *)&v31[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D592DC2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a15) {
    MEMORY[0x1D9455390](a15, 0x1000C8077774924);
  }
  if (a21) {
    MEMORY[0x1D9455390](a21, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *marisa::grimoire::trie::LoudsTrie::swap(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::trie::LoudsTrie *a2)
{
  marisa::grimoire::vector::BitVector::swap(this, a2);
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), (marisa::grimoire::trie::LoudsTrie *)((char *)a2 + 208));
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), (marisa::grimoire::trie::LoudsTrie *)((char *)a2 + 416));
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 78, (uint64_t *)a2 + 78);
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 84, (uint64_t *)a2 + 84);
  uint64_t v4 = *((void *)this + 90);
  *((void *)this + 90) = *((void *)a2 + 90);
  *((void *)a2 + 90) = v4;
  LODWORD(v4) = *((_DWORD *)this + 182);
  *((_DWORD *)this + 182) = *((_DWORD *)a2 + 182);
  *((_DWORD *)a2 + 182) = v4;
  uint64_t v5 = *((void *)this + 92);
  *((void *)this + 92) = *((void *)a2 + 92);
  *((void *)a2 + 92) = v5;
  marisa::grimoire::trie::Tail::swap((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), (marisa::grimoire::trie::LoudsTrie *)((char *)a2 + 744));
  uint64_t v6 = *((void *)this + 125);
  *((void *)this + 12marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = *((void *)a2 + 125);
  *((void *)a2 + 12marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = v6;
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 126, (uint64_t *)a2 + 126);
  uint64_t v7 = *((void *)this + 132);
  *((void *)this + 132) = *((void *)a2 + 132);
  *((void *)a2 + 132) = v7;
  uint64_t v8 = *((void *)this + 133);
  *((void *)this + 133) = *((void *)a2 + 133);
  *((void *)a2 + 133) = v8;
  uint64_t v9 = *((void *)this + 134);
  *((void *)this + 134) = *((void *)a2 + 134);
  *((void *)a2 + 134) = v9;
  uint64_t v10 = *((void *)this + 135);
  *((void *)this + 13marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = *((void *)a2 + 135);
  *((void *)a2 + 13marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = v10;
  LODWORD(v9) = *((_DWORD *)this + 272);
  *((_DWORD *)this + 272) = *((_DWORD *)a2 + 272);
  *((_DWORD *)a2 + 272) = v9;

  return marisa::grimoire::io::Mapper::swap((uint64_t *)this + 137, (marisa::grimoire::trie::LoudsTrie *)((char *)a2 + 1096));
}

void marisa::grimoire::trie::LoudsTrie::map(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::io::Mapper *a2)
{
  marisa::grimoire::trie::Header::map((marisa::grimoire::trie::Header *)v4, a2);
  marisa::grimoire::trie::LoudsTrie::LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v4);
  marisa::grimoire::trie::LoudsTrie::map_((marisa::grimoire::trie::LoudsTrie *)v4, a2);
  marisa::grimoire::io::Mapper::swap(v5, a2);
  marisa::grimoire::trie::LoudsTrie::swap(this, (marisa::grimoire::trie::LoudsTrie *)v4);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v4);
}

void sub_1D592DE3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unsigned char *marisa::grimoire::trie::Header::map(marisa::grimoire::trie::Header *this, marisa::grimoire::io::Mapper *a2)
{
  uint64_t result = (unsigned char *)marisa::grimoire::io::Mapper::map_data(a2, 0x10uLL);
  if (*result != 87) {
    goto LABEL_7;
  }
  uint64_t v3 = 1u;
  do
  {
    if (v3 == 16) {
      return result;
    }
    int v4 = result[v3];
    int v5 = marisa::grimoire::trie::Header::get_header(void)::buf[v3++];
  }
  while (v4 == v5);
  if ((unint64_t)(v3 - 2) <= 0xE)
  {
LABEL_7:
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/header.h";
    exception[2] = 0xA00000015;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/header.h:21: MARISA_FORMAT_ERRO"
                   "R: !test_header(ptr)";
  }
  return result;
}

double marisa::grimoire::trie::LoudsTrie::map_(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::io::Mapper *a2)
{
  marisa::grimoire::vector::BitVector::map(this, a2);
  marisa::grimoire::vector::BitVector::map((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), a2);
  marisa::grimoire::vector::BitVector::map((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), a2);
  marisa::grimoire::vector::Vector<unsigned char>::map((long long *)this + 39, a2);
  marisa::grimoire::vector::FlatVector::map((marisa::grimoire::trie::LoudsTrie *)((char *)this + 672), a2);
  marisa::grimoire::trie::Tail::map((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2);
  if (*((void *)this + 59) && !*((void *)this + 96))
  {
    int v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
    int v5 = v4;
    if (v4) {
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
    }
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset((marisa::grimoire::trie::LoudsTrie **)this + 125, v5);
    uint64_t v6 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
    if (!v6)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x80000021ELL;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:542: MARISA_MEM"
                     "ORY_ERROR: next_trie_.get() == NULL";
    }
    marisa::grimoire::trie::LoudsTrie::map_(v6, a2);
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::map((long long *)this + 63, a2);
  *((void *)this + 132) = *((void *)this + 129) - 1;
  *((void *)this + 133) = *(unsigned int *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  unsigned int v7 = *(_DWORD *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  uint64_t v10 = 3;
  *(void *)&double v11 = 0x100000000200;
  int v12 = 0x20000;
  marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v10, v7);
  *((void *)this + 134) = v10;
  double result = v11;
  *((double *)this + 13marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = v11;
  *((_DWORD *)this + 272) = v12;
  return result;
}

void sub_1D592E0AC(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553B0](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

void marisa::grimoire::trie::LoudsTrie::read(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::io::Reader *a2)
{
  marisa::grimoire::trie::Header::read((marisa::grimoire::trie::Header *)v4, a2);
  marisa::grimoire::trie::LoudsTrie::LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v4);
  marisa::grimoire::trie::LoudsTrie::read_((marisa::grimoire::trie::LoudsTrie *)v4, a2);
  marisa::grimoire::trie::LoudsTrie::swap(this, (marisa::grimoire::trie::LoudsTrie *)v4);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v4);
}

void sub_1D592E12C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t marisa::grimoire::trie::Header::read(marisa::grimoire::trie::Header *this, marisa::grimoire::io::Reader *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t result = marisa::grimoire::io::Reader::read_data((uint64_t)a2, v7, 0x10uLL);
  if (v7[0] != 87) {
    goto LABEL_7;
  }
  uint64_t v3 = 1u;
  do
  {
    if (v3 == 16) {
      return result;
    }
    int v4 = v7[v3];
    int v5 = marisa::grimoire::trie::Header::get_header(void)::buf[v3++];
  }
  while (v4 == v5);
  if ((unint64_t)(v3 - 2) <= 0xE)
  {
LABEL_7:
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/header.h";
    exception[2] = 0xA0000001ALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/header.h:26: MARISA_FORMAT_ERRO"
                   "R: !test_header(buf)";
  }
  return result;
}

double marisa::grimoire::trie::LoudsTrie::read_(marisa::grimoire::trie::LoudsTrie *this, marisa::grimoire::io::Reader *a2)
{
  marisa::grimoire::vector::BitVector::read(this, a2);
  marisa::grimoire::vector::BitVector::read((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), a2);
  marisa::grimoire::vector::BitVector::read((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), a2);
  marisa::grimoire::vector::Vector<unsigned char>::read((long long *)this + 39, a2);
  marisa::grimoire::vector::FlatVector::read((marisa::grimoire::trie::LoudsTrie *)((char *)this + 672), a2);
  marisa::grimoire::trie::Tail::read((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2);
  if (*((void *)this + 59) && !*((void *)this + 96))
  {
    int v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
    int v5 = v4;
    if (v4) {
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
    }
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset((marisa::grimoire::trie::LoudsTrie **)this + 125, v5);
    uint64_t v6 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
    if (!v6)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x800000238;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:568: MARISA_MEM"
                     "ORY_ERROR: next_trie_.get() == NULL";
    }
    marisa::grimoire::trie::LoudsTrie::read_(v6, a2);
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::read((long long *)this + 63, a2);
  *((void *)this + 132) = *((void *)this + 129) - 1;
  LODWORD(v10) = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v10, 4uLL);
  *((void *)this + 133) = v10;
  int v9 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v9, 4uLL);
  uint64_t v10 = 3;
  *(void *)&double v11 = 0x100000000200;
  int v12 = 0x20000;
  marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v10, v9);
  *((void *)this + 134) = v10;
  double result = v11;
  *((double *)this + 13marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = v11;
  *((_DWORD *)this + 272) = v12;
  return result;
}

void sub_1D592E3F0(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553B0](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::write(marisa::grimoire::trie::LoudsTrie **this, marisa::grimoire::io::Writer *a2)
{
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, "We love Marisa.", 0x10uLL);

  return marisa::grimoire::trie::LoudsTrie::write_(this, a2);
}

uint64_t marisa::grimoire::trie::LoudsTrie::write_(marisa::grimoire::trie::LoudsTrie **this, marisa::grimoire::io::Writer *a2)
{
  marisa::grimoire::vector::BitVector::write_((marisa::grimoire::vector::BitVector *)this, a2);
  marisa::grimoire::vector::BitVector::write_((marisa::grimoire::vector::BitVector *)(this + 26), a2);
  marisa::grimoire::vector::BitVector::write_((marisa::grimoire::vector::BitVector *)(this + 52), a2);
  marisa::grimoire::vector::Vector<unsigned char>::write_((uint64_t)(this + 78), a2);
  marisa::grimoire::vector::FlatVector::write_((marisa::grimoire::vector::FlatVector *)(this + 84), a2);
  marisa::grimoire::trie::Tail::write((marisa::grimoire::trie::Tail *)(this + 93), a2);
  int v4 = this[125];
  if (v4) {
    marisa::grimoire::trie::LoudsTrie::write_(v4, a2);
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::write_((uint64_t)(this + 126), a2);
  unsigned int __buf = this[133];
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 4uLL);
  int v6 = *((_DWORD *)this + 271) | *((_DWORD *)this + 268) | *((_DWORD *)this + 272);
  return marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&v6, 4uLL);
}

uint64_t marisa::grimoire::trie::LoudsTrie::lookup(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  uint64_t v4 = *((void *)a2 + 5);
  *(void *)(v4 + 96) = 0;
  *(_DWORD *)(v4 + 108) = 0;
  while (1)
  {
    unint64_t v5 = *((void *)a2 + 1);
    if (v5 <= *(unsigned int *)(v4 + 100)) {
      break;
    }
    if ((marisa::grimoire::trie::LoudsTrie::find_child(this, a2) & 1) == 0) {
      return 0;
    }
  }
  unint64_t v6 = *(unsigned int *)(v4 + 96);
  if ((*(void *)(*((void *)this + 28) + ((v6 >> 3) & 0x1FFFFFF8)) >> v6))
  {
    *((void *)a2 + 3) = *(void *)a2;
    *((_DWORD *)a2 + 8) = v5;
    *((_DWORD *)a2 + 9) = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), v6);
    return 1;
  }
  return 0;
}

uint64_t marisa::grimoire::trie::LoudsTrie::find_child(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  uint64_t v4 = *((void *)a2 + 5);
  unint64_t v5 = *(unsigned int *)(v4 + 96);
  uint64_t v6 = *(unsigned int *)(v4 + 100);
  unint64_t v7 = (*(unsigned __int8 *)(*(void *)a2 + v6) ^ (32 * v5) ^ v5) & *((void *)this + 132);
  uint64_t v8 = *((void *)this + 128);
  if (v5 != *(_DWORD *)(v8 + 12 * v7))
  {
    unint64_t v10 = marisa::grimoire::vector::BitVector::select0(this, v5);
    uint64_t v11 = *((void *)this + 2);
    if ((*(void *)(v11 + (((v10 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v10 + 1)))
    {
      unsigned int v12 = v10 - *(_DWORD *)(v4 + 96);
      *(_DWORD *)(v4 + 96) = v12;
      unint64_t v13 = v10 + 2;
      uint64_t v14 = 0xFFFFFFFFLL;
      while (1)
      {
        uint64_t v15 = v12;
        if ((*(void *)(*((void *)this + 54) + (((unint64_t)v12 >> 3) & 0x1FFFFFF8)) >> v12))
        {
          if (v14 == 0xFFFFFFFFLL)
          {
            uint64_t v14 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), v12);
            uint64_t v15 = *(unsigned int *)(v4 + 96);
          }
          else
          {
            ++v14;
          }
          int v17 = *(_DWORD *)(v4 + 100);
          uint64_t v18 = *((void *)this + 90);
          unint64_t v19 = (unint64_t)(v18 * v14) >> 6;
          uint64_t v20 = (v18 * v14) & 0x3F;
          unint64_t v21 = v20 + v18;
          uint64_t v22 = *((void *)this + 86);
          uint64_t v23 = *(void *)(v22 + 8 * v19) >> v20;
          if (v21 > 0x40) {
            v23 |= (2 * *(void *)(v22 + 8 * v19 + 8)) << (v20 ^ 0x3Fu);
          }
          unint64_t v24 = *(unsigned __int8 *)(*((void *)this + 80) + v15) | ((*((_DWORD *)this + 182) & v23) << 8);
          unint64_t v25 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
          if (v25)
          {
            if (marisa::grimoire::trie::LoudsTrie::match_(v25, a2, v24)) {
              return 1;
            }
          }
          else if (marisa::grimoire::trie::Tail::match((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2, v24))
          {
            return 1;
          }
          if (*(_DWORD *)(v4 + 100) != v17) {
            return 0;
          }
          unsigned int v12 = *(_DWORD *)(v4 + 96);
          uint64_t v11 = *((void *)this + 2);
        }
        else
        {
          uint64_t v16 = *(unsigned int *)(v4 + 100);
          if (*(unsigned __int8 *)(*((void *)this + 80) + v12) == *(unsigned __int8 *)(*(void *)a2 + v16))
          {
            *(_DWORD *)(v4 + 100) = v16 + 1;
            return 1;
          }
        }
        *(_DWORD *)(v4 + 96) = ++v12;
        uint64_t v26 = *(void *)(v11 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v13;
        ++v13;
        if ((v26 & 1) == 0) {
          return 0;
        }
      }
    }
    return 0;
  }
  unint64_t v9 = *(unsigned int *)(v8 + 12 * v7 + 8);
  if (v9 > 0xFFFFFEFF)
  {
    *(_DWORD *)(v4 + 100) = v6 + 1;
    goto LABEL_24;
  }
  uint64_t v27 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
  if (v27)
  {
    if (marisa::grimoire::trie::LoudsTrie::match_(v27, a2, v9)) {
      goto LABEL_24;
    }
    return 0;
  }
  if ((marisa::grimoire::trie::Tail::match((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2, v9) & 1) == 0) {
    return 0;
  }
LABEL_24:
  *(_DWORD *)(v4 + 96) = *(_DWORD *)(*((void *)this + 128) + 12 * v7 + 4);
  return 1;
}

unint64_t marisa::grimoire::trie::LoudsTrie::reverse_lookup(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  unint64_t v3 = *((void *)a2 + 2);
  if (v3 >= *((void *)this + 33))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x300000049;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:73: MARISA_BOUND_"
                   "ERROR: agent.query().id() >= size()";
  }
  uint64_t v5 = *((void *)a2 + 5);
  *(void *)(v5 + 24) = 0;
  unint64_t v6 = *(void *)(v5 + 32);
  if (v6 <= 0x1F)
  {
    if (v6 <= 0x10) {
      size_t v7 = 32;
    }
    else {
      size_t v7 = 2 * v6;
    }
    marisa::grimoire::vector::Vector<char>::realloc((uint64_t *)v5, v7);
    unint64_t v3 = *((void *)a2 + 2);
  }
  *(_DWORD *)(v5 + 108) = 0;
  unint64_t result = marisa::grimoire::vector::BitVector::select1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), v3);
  *(_DWORD *)(v5 + 96) = result;
  if (!result) {
    goto LABEL_30;
  }
  while (1)
  {
    if ((*(void *)(*((void *)this + 54) + ((result >> 3) & 0x1FFFFFF8)) >> result))
    {
      uint64_t v9 = *(void *)(v5 + 24);
      int v10 = *(unsigned __int8 *)(*((void *)this + 80) + result);
      uint64_t v11 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), result);
      uint64_t v12 = *((void *)this + 90);
      unint64_t v13 = (unint64_t)(v12 * v11) >> 6;
      uint64_t v14 = (v12 * v11) & 0x3F;
      unint64_t v15 = v14 + v12;
      uint64_t v16 = *((void *)this + 86);
      uint64_t v17 = *(void *)(v16 + 8 * v13) >> v14;
      if (v15 > 0x40) {
        v17 |= (2 * *(void *)(v16 + 8 * v13 + 8)) << (v14 ^ 0x3Fu);
      }
      unint64_t v18 = v10 | ((*((_DWORD *)this + 182) & v17) << 8);
      unint64_t v19 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
      if (v19) {
        unint64_t result = (unint64_t)marisa::grimoire::trie::LoudsTrie::restore_(v19, a2, v18);
      }
      else {
        unint64_t result = (unint64_t)marisa::grimoire::trie::Tail::restore((uint64_t *)this + 93, a2, v18);
      }
      uint64_t v20 = *(void *)(v5 + 24);
      if (v9 != v20)
      {
        uint64_t v21 = *(void *)(v5 + 8);
        uint64_t v22 = (unsigned char *)(v21 + v20 - 1);
        if ((unint64_t)v22 > v21 + v9)
        {
          unint64_t v23 = v21 + v9 + 1;
          do
          {
            char v24 = *(unsigned char *)(v23 - 1);
            *(unsigned char *)(v23 - 1) = *v22;
            *v22-- = v24;
            BOOL v25 = v23++ >= (unint64_t)v22;
          }
          while (!v25);
        }
      }
    }
    else
    {
      char v35 = *(unsigned char *)(*((void *)this + 80) + result);
      unint64_t result = (unint64_t)marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v5, &v35);
    }
    unint64_t v26 = *(unsigned int *)(v5 + 96);
    if (*((void *)this + 133) >= v26) {
      break;
    }
    unint64_t result = marisa::grimoire::vector::BitVector::select1(this, v26) + ~(unint64_t)*(unsigned int *)(v5 + 96);
    *(_DWORD *)(v5 + 96) = result;
  }
  unint64_t v27 = *(void *)(v5 + 8);
  uint64_t v28 = *(void *)(v5 + 24);
  long long v29 = (unsigned char *)(v27 + v28 - 1);
  if (v28) {
    BOOL v30 = (unint64_t)v29 > v27;
  }
  else {
    BOOL v30 = 0;
  }
  if (v30)
  {
    unint64_t v31 = v27 + 1;
    do
    {
      char v32 = *(unsigned char *)(v31 - 1);
      *(unsigned char *)(v31 - 1) = *v29;
      *v29-- = v32;
      BOOL v25 = v31++ >= (unint64_t)v29;
    }
    while (!v25);
LABEL_30:
    unint64_t v27 = *(void *)(v5 + 8);
    uint64_t v28 = *(void *)(v5 + 24);
  }
  *((void *)a2 + 3) = v27;
  uint64_t v33 = *((void *)a2 + 2);
  *((_DWORD *)a2 + 8) = v28;
  *((_DWORD *)a2 + 9) = v33;
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<char>::push_back(uint64_t *result, unsigned char *a2)
{
  unint64_t v3 = result;
  uint64_t v4 = result[3];
  uint64_t v5 = result[4];
  size_t v6 = v4 + 1;
  if (v5 < (unint64_t)(v4 + 1))
  {
    uint64_t v7 = 2 * v5;
    if (v5 < 0) {
      uint64_t v7 = -1;
    }
    if (v5 <= v6 >> 1) {
      size_t v8 = v6;
    }
    else {
      size_t v8 = v7;
    }
    unint64_t result = (uint64_t *)marisa::grimoire::vector::Vector<char>::realloc(result, v8);
    uint64_t v4 = v3[3];
  }
  *(unsigned char *)(v3[1] + v4) = *a2;
  ++v3[3];
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::common_prefix_search(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  uint64_t v4 = (unsigned int *)*((void *)a2 + 5);
  unsigned int v5 = v4[27];
  if (v5 == 1)
  {
LABEL_5:
    while (*((void *)a2 + 1) > (unint64_t)v4[25]
         && (marisa::grimoire::trie::LoudsTrie::find_child(this, a2) & 1) != 0)
    {
      unint64_t v7 = v4[24];
      if ((*(void *)(*((void *)this + 28) + ((v7 >> 3) & 0x1FFFFFF8)) >> v7))
      {
        size_t v8 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 208);
        unsigned int v9 = v4[25];
        *((void *)a2 + 3) = *(void *)a2;
        *((_DWORD *)a2 + 8) = v9;
        goto LABEL_11;
      }
    }
    uint64_t result = 0;
    v4[27] = 3;
  }
  else if (v5 == 3)
  {
    return 0;
  }
  else
  {
    *((void *)v4 + 12) = 0;
    v4[27] = 1;
    if ((**((unsigned char **)this + 28) & 1) == 0) {
      goto LABEL_5;
    }
    size_t v8 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 208);
    *((void *)a2 + 3) = *(void *)a2;
    *((_DWORD *)a2 + 8) = 0;
    unint64_t v7 = 0;
LABEL_11:
    *((_DWORD *)a2 + 9) = marisa::grimoire::vector::BitVector::rank1(v8, v7);
    return 1;
  }
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::predictive_search(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  uint64_t v4 = *((void *)a2 + 5);
  int v5 = *(_DWORD *)(v4 + 108);
  if (v5 == 2)
  {
    do
    {
      while (1)
      {
LABEL_10:
        uint64_t v10 = *(unsigned int *)(v4 + 104);
        if (*(void *)(v4 + 72) == v10)
        {
          uint64_t v11 = *(void *)(v4 + 56) + 20 * v10;
          *(_OWORD *)uint64_t v40 = xmmword_1D59450B0;
          *(_DWORD *)&v40[16] = -1;
          int v12 = marisa::grimoire::vector::BitVector::select0(this, *(unsigned int *)(v11 - 20));
          *(_DWORD *)&v40[4] = v12 + 1;
          *(_DWORD *)uint64_t v40 = v12 - *(_DWORD *)(v11 - 20);
          marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::push_back((uint64_t *)(v4 + 48), (__n128 *)v40);
          LODWORD(v10) = *(_DWORD *)(v4 + 104);
        }
        uint64_t v13 = *(void *)(v4 + 56);
        uint64_t v14 = (unsigned int *)(v13 + 20 * v10);
        unint64_t v15 = v14[1];
        unint64_t v16 = *(void *)(*((void *)this + 2) + ((v15 >> 3) & 0x1FFFFFF8));
        v14[1] = v15 + 1;
        if ((v16 >> v15)) {
          break;
        }
        if (v10 == 1)
        {
LABEL_7:
          uint64_t result = 0;
          *(_DWORD *)(v4 + 108) = 4;
          return result;
        }
        uint64_t v23 = v13 + 20 * v10;
        ++*(_DWORD *)(v23 - 20);
        marisa::grimoire::vector::Vector<char>::resize((uint64_t *)v4, *(unsigned int *)(v23 - 32));
        --*(_DWORD *)(v4 + 104);
      }
      *(_DWORD *)(v4 + 104) = v10 + 1;
      unint64_t v17 = *v14;
      if ((*(void *)(*((void *)this + 54) + ((v17 >> 3) & 0x1FFFFFF8)) >> v17))
      {
        uint64_t v18 = v13 + 20 * v10;
        int v21 = *(_DWORD *)(v18 + 12);
        uint64_t v20 = (unsigned int *)(v18 + 12);
        int v19 = v21;
        if (v21 == -1)
        {
          unsigned int v22 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), v17);
          unint64_t v17 = *v14;
        }
        else
        {
          unsigned int v22 = v19 + 1;
        }
        unsigned int *v20 = v22;
        uint64_t v24 = *((void *)this + 90);
        unint64_t v25 = v24 * v22;
        unint64_t v26 = v25 >> 6;
        uint64_t v27 = v25 & 0x3F;
        unint64_t v28 = v27 + v24;
        uint64_t v29 = *((void *)this + 86);
        unint64_t v30 = *(void *)(v29 + 8 * v26);
        if (v28 > 0x40) {
          uint64_t v31 = ((2 * *(void *)(v29 + 8 * v26 + 8)) << (v27 ^ 0x3Fu)) | (v30 >> v27);
        }
        else {
          uint64_t v31 = v30 >> v27;
        }
        unint64_t v32 = *(unsigned __int8 *)(*((void *)this + 80) + v17) | ((*((_DWORD *)this + 182) & v31) << 8);
        uint64_t v33 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
        if (v33) {
          marisa::grimoire::trie::LoudsTrie::restore_(v33, a2, v32);
        }
        else {
          marisa::grimoire::trie::Tail::restore((uint64_t *)this + 93, a2, v32);
        }
      }
      else
      {
        v40[0] = *(unsigned char *)(*((void *)this + 80) + v17);
        marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v4, v40);
      }
      int v34 = *(_DWORD *)(v4 + 24);
      *(_DWORD *)(v13 + 20 * v10 + 8) = v34;
      unint64_t v35 = *v14;
    }
    while (((*(void *)(*((void *)this + 28) + ((v35 >> 3) & 0x1FFFFFF8)) >> v35) & 1) == 0);
    uint64_t v36 = v13 + 20 * v10;
    int v39 = *(_DWORD *)(v36 + 16);
    unint64_t v38 = (_DWORD *)(v36 + 16);
    int v37 = v39;
    if (v39 == -1)
    {
      int v9 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), v35);
      int v34 = *(_DWORD *)(v4 + 24);
    }
    else
    {
      int v9 = v37 + 1;
    }
    _DWORD *v38 = v9;
    *((void *)a2 + 3) = *(void *)(v4 + 8);
    *((_DWORD *)a2 + 8) = v34;
  }
  else
  {
    if (v5 == 4) {
      return 0;
    }
    marisa::grimoire::trie::State::predictive_search_init(*((marisa::grimoire::trie::State **)a2 + 5));
    while (*((void *)a2 + 1) > (unint64_t)*(unsigned int *)(v4 + 100))
    {
      if ((marisa::grimoire::trie::LoudsTrie::predictive_find_child(this, a2) & 1) == 0) {
        goto LABEL_7;
      }
    }
    *(void *)&v40[12] = -1;
    *(void *)uint64_t v40 = *(unsigned int *)(v4 + 96);
    *(_DWORD *)&v40[8] = *(void *)(v4 + 24);
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::push_back((uint64_t *)(v4 + 48), (__n128 *)v40);
    *(_DWORD *)(v4 + 104) = 1;
    unint64_t v7 = *(unsigned int *)(v4 + 96);
    if (((*(void *)(*((void *)this + 28) + ((v7 >> 3) & 0x1FFFFFF8)) >> v7) & 1) == 0) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void *)(v4 + 24);
    *((void *)a2 + 3) = *(void *)(v4 + 8);
    *((_DWORD *)a2 + 8) = v8;
    int v9 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 208), v7);
  }
  *((_DWORD *)a2 + 9) = v9;
  return 1;
}

double marisa::grimoire::trie::State::predictive_search_init(marisa::grimoire::trie::State *this)
{
  *((void *)this + 3) = 0;
  unint64_t v2 = *((void *)this + 4);
  if (v2 <= 0x3F)
  {
    if (v2 <= 0x20) {
      size_t v3 = 64;
    }
    else {
      size_t v3 = 2 * v2;
    }
    marisa::grimoire::vector::Vector<char>::realloc((uint64_t *)this, v3);
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::resize((uint64_t *)this + 6, 0);
  unint64_t v4 = *((void *)this + 10);
  if (v4 <= 3)
  {
    if (v4 == 3) {
      uint64_t v5 = 6;
    }
    else {
      uint64_t v5 = 4;
    }
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc((uint64_t *)this + 6, v5);
  }
  double result = 0.0;
  *((_OWORD *)this + 6) = xmmword_1D59450C0;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::predictive_find_child(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2)
{
  uint64_t v4 = *((void *)a2 + 5);
  unint64_t v5 = *(unsigned int *)(v4 + 96);
  unint64_t v6 = (*(unsigned __int8 *)(*(void *)a2 + *(unsigned int *)(v4 + 100)) ^ (32 * v5) ^ v5) & *((void *)this + 132);
  uint64_t v7 = *((void *)this + 128);
  if (v5 != *(_DWORD *)(v7 + 12 * v6))
  {
    unint64_t v10 = marisa::grimoire::vector::BitVector::select0(this, v5);
    uint64_t v11 = *((void *)this + 2);
    if ((*(void *)(v11 + (((v10 + 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v10 + 1)))
    {
      unsigned int v12 = v10 - *(_DWORD *)(v4 + 96);
      *(_DWORD *)(v4 + 96) = v12;
      unint64_t v13 = v10 + 2;
      uint64_t v14 = 0xFFFFFFFFLL;
      while (1)
      {
        uint64_t v15 = v12;
        if ((*(void *)(*((void *)this + 54) + (((unint64_t)v12 >> 3) & 0x1FFFFFF8)) >> v12))
        {
          if (v14 == 0xFFFFFFFFLL)
          {
            uint64_t v14 = marisa::grimoire::vector::BitVector::rank1((marisa::grimoire::trie::LoudsTrie *)((char *)this + 416), v12);
            uint64_t v15 = *(unsigned int *)(v4 + 96);
          }
          else
          {
            ++v14;
          }
          int v16 = *(_DWORD *)(v4 + 100);
          uint64_t v17 = *((void *)this + 90);
          unint64_t v18 = (unint64_t)(v17 * v14) >> 6;
          uint64_t v19 = (v17 * v14) & 0x3F;
          unint64_t v20 = v19 + v17;
          uint64_t v21 = *((void *)this + 86);
          uint64_t v22 = *(void *)(v21 + 8 * v18) >> v19;
          if (v20 > 0x40) {
            v22 |= (2 * *(void *)(v21 + 8 * v18 + 8)) << (v19 ^ 0x3Fu);
          }
          unint64_t v23 = *(unsigned __int8 *)(*((void *)this + 80) + v15) | ((*((_DWORD *)this + 182) & v22) << 8);
          uint64_t v24 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
          if (v24)
          {
            if (marisa::grimoire::trie::LoudsTrie::prefix_match_(v24, a2, v23)) {
              return 1;
            }
          }
          else if (marisa::grimoire::trie::Tail::prefix_match((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2, v23))
          {
            return 1;
          }
          if (*(_DWORD *)(v4 + 100) != v16) {
            return 0;
          }
          unsigned int v12 = *(_DWORD *)(v4 + 96);
          uint64_t v11 = *((void *)this + 2);
        }
        else if (*(unsigned __int8 *)(*((void *)this + 80) + v12) == *(unsigned __int8 *)(*(void *)a2 {
                                                                                           + *(unsigned int *)(v4 + 100)))
        }
        {
          char v28 = *(unsigned char *)(*((void *)this + 80) + v12);
          marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v4, &v28);
          ++*(_DWORD *)(v4 + 100);
          return 1;
        }
        *(_DWORD *)(v4 + 96) = ++v12;
        uint64_t v25 = *(void *)(v11 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v13;
        ++v13;
        if ((v25 & 1) == 0) {
          return 0;
        }
      }
    }
    return 0;
  }
  uint64_t v8 = v7 + 12 * v6;
  unint64_t v9 = *(unsigned int *)(v8 + 8);
  if (v9 > 0xFFFFFEFF)
  {
    char v29 = *(_DWORD *)(v8 + 8);
    marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v4, &v29);
    ++*(_DWORD *)(v4 + 100);
    goto LABEL_24;
  }
  unint64_t v26 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
  if (v26)
  {
    if (marisa::grimoire::trie::LoudsTrie::prefix_match_(v26, a2, v9)) {
      goto LABEL_24;
    }
    return 0;
  }
  if (!marisa::grimoire::trie::Tail::prefix_match((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744), a2, v9)) {
    return 0;
  }
LABEL_24:
  *(_DWORD *)(v4 + 96) = *(_DWORD *)(*((void *)this + 128) + 12 * v6 + 4);
  return 1;
}

__n128 marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::push_back(uint64_t *a1, __n128 *a2)
{
  uint64_t v4 = a1[3];
  unint64_t v5 = a1[4];
  unint64_t v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    uint64_t v7 = 2 * v5;
    if (v5 > 0x666666666666666) {
      uint64_t v7 = 0xCCCCCCCCCCCCCCCLL;
    }
    if (v5 <= v6 >> 1) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = v7;
    }
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(a1, v8);
    uint64_t v4 = a1[3];
  }
  unint64_t v9 = (__n128 *)(a1[1] + 20 * v4);
  __n128 result = *a2;
  v9[1].n128_u32[0] = a2[1].n128_u32[0];
  *unint64_t v9 = result;
  ++a1[3];
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<char>::resize(uint64_t *result, size_t a2)
{
  size_t v2 = a2;
  size_t v3 = result;
  uint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 < 0) {
      uint64_t v5 = -1;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    __n128 result = (uint64_t *)marisa::grimoire::vector::Vector<char>::realloc(result, a2);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::total_size(marisa::grimoire::trie::LoudsTrie *this)
{
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = *((void *)this + 11);
  uint64_t v4 = *((void *)this + 17);
  uint64_t v5 = *((void *)this + 23);
  uint64_t v6 = *((void *)this + 29);
  uint64_t v7 = *((void *)this + 37);
  uint64_t v8 = *((void *)this + 43);
  uint64_t v9 = *((void *)this + 49);
  uint64_t v10 = *((void *)this + 55);
  uint64_t v11 = *((void *)this + 63);
  uint64_t v12 = *((void *)this + 69);
  uint64_t v13 = *((void *)this + 75);
  uint64_t v14 = *((void *)this + 81);
  uint64_t v15 = *((void *)this + 87);
  uint64_t v16 = *((void *)this + 96);
  uint64_t v17 = *((void *)this + 102);
  uint64_t v18 = *((void *)this + 110);
  uint64_t v19 = *((void *)this + 116);
  uint64_t v20 = *((void *)this + 122);
  uint64_t v21 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
  if (v21)
  {
    uint64_t v34 = v3;
    uint64_t v35 = v4;
    uint64_t v26 = v18;
    uint64_t v27 = v11;
    uint64_t v22 = v5;
    uint64_t v32 = v20;
    uint64_t v33 = v2;
    uint64_t v30 = v7;
    uint64_t v31 = v14;
    uint64_t v28 = v17;
    uint64_t v29 = v12;
    uint64_t v23 = v16;
    uint64_t v24 = v13;
    uint64_t v21 = (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::total_size(v21);
    uint64_t v12 = v29;
    uint64_t v7 = v30;
    uint64_t v14 = v31;
    uint64_t v20 = v32;
    uint64_t v2 = v33;
    uint64_t v3 = v34;
    uint64_t v13 = v24;
    uint64_t v16 = v23;
    uint64_t v11 = v27;
    uint64_t v17 = v28;
    uint64_t v5 = v22;
    uint64_t v18 = v26;
    uint64_t v4 = v35;
  }
  return (uint64_t)v21
       + 12 * *((void *)this + 129)
       + 12 * v18
       + 12 * v11
       + 12 * v3
       + 12 * v7
       + 8 * v2
       + 8 * v17
       + 8 * v15
       + 8 * v10
       + 8 * v6
       + 4 * v4
       + 4 * v8
       + 4 * v9
       + 4 * v12
       + 4 * v13
       + 4 * v19
       + 4 * v20
       + 4 * v5
       + v16
       + v14;
}

unint64_t marisa::grimoire::trie::LoudsTrie::io_size(marisa::grimoire::trie::LoudsTrie *this)
{
  uint64_t v2 = *((void *)this + 11);
  uint64_t v3 = *((void *)this + 17);
  uint64_t v4 = *((void *)this + 23);
  uint64_t v28 = *((void *)this + 29);
  uint64_t v29 = *((void *)this + 3);
  uint64_t v5 = *((void *)this + 37);
  uint64_t v6 = *((void *)this + 43);
  uint64_t v7 = *((void *)this + 49);
  uint64_t v25 = *((void *)this + 63);
  uint64_t v26 = *((void *)this + 69);
  uint64_t v27 = *((void *)this + 55);
  uint64_t v8 = *((void *)this + 75);
  uint64_t v9 = *((void *)this + 81);
  uint64_t v10 = *((void *)this + 87);
  unint64_t v11 = marisa::grimoire::trie::Tail::io_size((marisa::grimoire::trie::LoudsTrie *)((char *)this + 744));
  uint64_t v12 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
  if (v12)
  {
    uint64_t v24 = v8;
    uint64_t v13 = v5;
    uint64_t v14 = v6;
    uint64_t v15 = v7;
    uint64_t v16 = v10;
    uint64_t v17 = v2;
    uint64_t v18 = v3;
    uint64_t v19 = v4;
    unint64_t v20 = v11;
    uint64_t v21 = marisa::grimoire::trie::LoudsTrie::io_size(v12);
    unint64_t v11 = v20;
    uint64_t v4 = v19;
    uint64_t v3 = v18;
    uint64_t v2 = v17;
    uint64_t v10 = v16;
    uint64_t v7 = v15;
    uint64_t v6 = v14;
    uint64_t v5 = v13;
    uint64_t v8 = v24;
    uint64_t v22 = v21 - 16;
  }
  else
  {
    uint64_t v22 = 0;
  }
  return ((12 * v2 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v3 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v4 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((12 * v5 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v6 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v7 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((12 * v25 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v26 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((v9 + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * v8 + 7) & 0xFFFFFFFFFFFFFFF8)
       + v11
       + 8 * (v28 + v29 + v27 + v10)
       + v22
       + ((12 * *((void *)this + 129) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 184;
}

unint64_t marisa::grimoire::trie::Tail::io_size(marisa::grimoire::trie::Tail *this)
{
  return ((*((void *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 8 * *((void *)this + 9)
       + ((4 * *((void *)this + 23) + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((4 * *((void *)this + 29) + 7) & 0xFFFFFFFFFFFFFFF8)
       + ((12 * *((void *)this + 17) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 48;
}

void marisa::grimoire::trie::LoudsTrie::clear(marisa::grimoire::trie::LoudsTrie *this)
{
  marisa::grimoire::trie::LoudsTrie::LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v2);
  marisa::grimoire::trie::LoudsTrie::swap((marisa::grimoire::trie::LoudsTrie *)v2, this);
  marisa::grimoire::trie::LoudsTrie::~LoudsTrie((marisa::grimoire::trie::LoudsTrie *)v2);
}

void sub_1D592F680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *marisa::grimoire::vector::BitVector::swap(marisa::grimoire::vector::BitVector *this, marisa::grimoire::vector::BitVector *a2)
{
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this, (uint64_t *)a2);
  uint64_t v4 = *((void *)this + 6);
  *((void *)this + 6) = *((void *)a2 + 6);
  *((void *)a2 + 6) = v4;
  uint64_t v5 = *((void *)this + 7);
  *((void *)this + 7) = *((void *)a2 + 7);
  *((void *)a2 + 7) = v5;
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 8, (uint64_t *)a2 + 8);
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 14, (uint64_t *)a2 + 14);

  return marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this + 20, (uint64_t *)a2 + 20);
}

uint64_t *marisa::grimoire::vector::Vector<unsigned char>::swap(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *__n128 result = *a2;
  *a2 = v2;
  uint64_t v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  uint64_t v4 = result[2];
  uint64_t v5 = result[3];
  uint64_t v6 = a2[3];
  result[2] = a2[2];
  result[3] = v6;
  a2[2] = v4;
  a2[3] = v5;
  uint64_t v7 = result[4];
  result[4] = a2[4];
  a2[4] = v7;
  LOBYTE(v7) = *((unsigned char *)result + 40);
  *((unsigned char *)result + 40) = *((unsigned char *)a2 + 40);
  *((unsigned char *)a2 + 40) = v7;
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 > 0x555555555555555) {
      uint64_t v5 = 0xAAAAAAAAAAAAAAALL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    __n128 result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::realloc(result, a2);
  }
  unint64_t v6 = v3[3];
  unint64_t v7 = v2 - v6;
  if (v2 > v6)
  {
    uint64_t v8 = 24 * v6;
    do
    {
      uint64_t v9 = v3[1] + v8;
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      v8 += 24;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t *a2, long long *a3, uint64_t a4, uint64_t a5)
{
  marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::Key>((uint64_t *)a1, (uint64_t)a2, a3, a4, a5);
  memset(v17, 0, 41);
  if (a2[3]) {
    marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::Key>(a1, a2, v17, a4, a5);
  }
  uint64_t v9 = *(_DWORD **)(a1 + 1000);
  if (v9)
  {
    unsigned int v10 = (v9[268] + 1) | v9[271] | v9[272];
    uint64_t v18 = 3;
    uint64_t v19 = 0x100000000200;
    int v20 = 0x20000;
    marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v18, v10);
  }
  else
  {
    if (*(void *)(a1 + 840)) {
      int v11 = 0x2000;
    }
    else {
      int v11 = 4096;
    }
    unsigned int v12 = *(_DWORD *)(a4 + 16) | *(_DWORD *)(a4 + 8) | v11 | 1;
    uint64_t v18 = 3;
    uint64_t v19 = 0x100000000200;
    int v20 = 0x20000;
    marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v18, v12);
  }
  *(void *)(a1 + 1072) = v18;
  *(void *)(a1 + 1080) = v19;
  *(_DWORD *)(a1 + 1088) = v20;
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)(a1 + 416), 0, 0);
  if (*((void *)&v17[1] + 1))
  {
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      do
      {
        uint64_t v15 = *(void *)(*(void *)(a1 + 432) + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14;
        ++v14;
      }
      while ((v15 & 1) == 0);
      *(unsigned char *)(*(void *)(a1 + 632) + v14 - 1) = *(_DWORD *)(*((void *)&v17[0] + 1) + 4 * v13);
      *(_DWORD *)(*((void *)&v17[0] + 1) + 4 * v13++) >>= 8;
    }
    while (v13 < *((void *)&v17[1] + 1));
  }
  marisa::grimoire::vector::FlatVector::build((long long *)(a1 + 672), (uint64_t)v17);
  marisa::grimoire::trie::LoudsTrie::fill_cache(a1);
  uint64_t result = *(void *)&v17[0];
  if (*(void *)&v17[0]) {
    return MEMORY[0x1D9455390](*(void *)&v17[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D592F9A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void marisa::grimoire::vector::Vector<std::pair<unsigned int,unsigned int>>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  unint64_t v4 = a1[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 >> 60) {
      uint64_t v5 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    marisa::grimoire::vector::Vector<unsigned long long>::realloc(a1, a2);
  }
  unint64_t v6 = a1[3];
  if (v2 > v6) {
    bzero((void *)(a1[1] + 8 * v6), 8 * (v2 - v6));
  }
  a1[3] = v2;
}

uint64_t *marisa::grimoire::vector::BitVector::push_back(uint64_t *this, int a2)
{
  unint64_t v2 = this[6];
  if (v2 == 0xFFFFFFFF)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h";
    exception[2] = 0x700000034;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h:52: MARI"
                   "SA_SIZE_ERROR: size_ == MARISA_UINT32_MAX";
  }
  unint64_t v4 = this;
  uint64_t v5 = this[3];
  if (v2 == v5 << 6)
  {
    uint64_t v7 = 0;
    this = marisa::grimoire::vector::Vector<unsigned long long>::resize(this, v5 + 1, &v7);
    unint64_t v2 = v4[6];
  }
  if (a2)
  {
    *(void *)(v4[1] + ((v2 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v2;
    ++v4[7];
  }
  v4[6] = v2 + 1;
  return this;
}

uint64_t marisa::grimoire::vector::BitVector::build(marisa::grimoire::vector::BitVector *this, int a2, int a3)
{
  memset(v8, 0, 41);
  long long v11 = 0u;
  memset(v12, 0, sizeof(v12));
  long long v13 = 0u;
  memset(v14, 0, sizeof(v14));
  v8[3] = 0u;
  long long v9 = 0u;
  memset(v10, 0, sizeof(v10));
  marisa::grimoire::vector::BitVector::build_index((marisa::grimoire::vector::BitVector *)v8, this, a2, a3);
  marisa::grimoire::vector::Vector<unsigned long long>::shrink(this);
  long long v4 = v8[0];
  v8[0] = *(_OWORD *)this;
  *(_OWORD *)this = v4;
  uint64_t v5 = *(void *)&v8[1];
  *(void *)&v8[1] = *((void *)this + 2);
  *((void *)this + 2) = v5;
  long long v6 = *(_OWORD *)((char *)&v8[1] + 8);
  *(_OWORD *)((char *)&v8[1] + 8) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = v6;
  LOBYTE(vmarisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = BYTE8(v8[2]);
  BYTE8(v8[2]) = *((unsigned char *)this + 40);
  *((unsigned char *)this + 40) = v5;
  marisa::grimoire::vector::BitVector::swap(this, (marisa::grimoire::vector::BitVector *)v8);
  if ((void)v13) {
    MEMORY[0x1D9455390](v13, 0x1000C8077774924);
  }
  if ((void)v11) {
    MEMORY[0x1D9455390](v11, 0x1000C8077774924);
  }
  if ((void)v9) {
    MEMORY[0x1D9455390](v9, 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v8[0];
  if (*(void *)&v8[0]) {
    return MEMORY[0x1D9455390](*(void *)&v8[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D592FC6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t *a2, long long *a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)a4 == a5)
  {
    long long v26 = 0u;
    memset(v27, 0, sizeof(v27));
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::resize((uint64_t *)&v26, a2[3]);
    uint64_t v9 = a2[3];
    if (v9)
    {
      unsigned int v10 = (unsigned int *)(*((void *)&v26 + 1) + 8);
      long long v11 = (_DWORD *)(a2[1] + 8);
      do
      {
        uint64_t v12 = *((void *)v11 - 1);
        unsigned int v13 = *v11;
        v11 += 6;
        *((void *)v10 - 1) = v12 + v13 - 1;
        *unsigned int v10 = v13;
        v10 += 4;
        --v9;
      }
      while (v9);
    }
    marisa::grimoire::trie::Tail::build((long long *)(a1 + 744), (uint64_t)&v26, a3, *(_DWORD *)(a4 + 12));
  }
  else
  {
    long long v26 = 0u;
    memset(v27, 0, sizeof(v27));
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::resize((uint64_t *)&v26, a2[3]);
    if (a2[3])
    {
      uint64_t v15 = 0;
      unint64_t v16 = 0;
      do
      {
        uint64_t v17 = *((void *)&v26 + 1) + v15;
        uint64_t v18 = a2[1] + v15;
        uint64_t v19 = *(unsigned int *)(v18 + 8);
        *(void *)uint64_t v17 = *(void *)v18 + v19;
        *(_DWORD *)(v17 + 8) = v19;
        *(_DWORD *)(v17 + 12) = *(_DWORD *)(v18 + 12);
        ++v16;
        v15 += 24;
      }
      while (v16 < a2[3]);
    }
    uint64_t v20 = *a2;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_OWORD *)((char *)a2 + 2marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
    if (v20) {
      MEMORY[0x1D9455390](v20, 0x1000C8077774924);
    }
    uint64_t v21 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
    uint64_t v22 = v21;
    if (v21) {
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v21);
    }
    uint64_t v23 = (marisa::grimoire::trie::LoudsTrie **)(a1 + 1000);
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset(v23, v22);
    if (!*v23)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x8000001C3;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:451: MARISA_MEM"
                     "ORY_ERROR: next_trie_.get() == NULL";
    }
    marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::ReverseKey>((uint64_t)*v23, (uint64_t)&v26, a3, a4, a5 + 1);
  }
  uint64_t result = v26;
  if ((void)v26) {
    return MEMORY[0x1D9455390](v26, 0x1000C8077774924);
  }
  return result;
}

void sub_1D592FE98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MEMORY[0x1D94553B0](v9, MEMORY[0x1E4FBA2D0]);
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 >> 59) {
      uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    uint64_t result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::realloc(result, a2);
  }
  unint64_t v6 = v3[3];
  unint64_t v7 = v2 - v6;
  if (v2 > v6)
  {
    uint64_t v8 = 16 * v6;
    do
    {
      uint64_t v9 = (void *)(v3[1] + v8);
      *uint64_t v9 = 0;
      v9[1] = 0;
      v8 += 16;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

marisa::grimoire::trie::LoudsTrie **marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset(marisa::grimoire::trie::LoudsTrie **a1, marisa::grimoire::trie::LoudsTrie *a2)
{
  if (a2 && *a1 == a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/include/marisa/scoped-ptr.h";
    exception[2] = 0x600000013;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/include/marisa/scoped-ptr.h:19: MARISA_RESET_ERROR: (ptr"
                   " != NULL) && (ptr == ptr_)";
  }
  unint64_t v4 = *a1;
  *a1 = a2;
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v4);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5)
{
  marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::ReverseKey>((uint64_t *)a1, a2, a3, a4, a5);
  memset(v17, 0, 41);
  if (*(void *)(a2 + 24)) {
    marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::ReverseKey>(a1, a2, v17, a4, a5);
  }
  uint64_t v9 = *(_DWORD **)(a1 + 1000);
  if (v9)
  {
    unsigned int v10 = (v9[268] + 1) | v9[271] | v9[272];
    uint64_t v18 = 3;
    uint64_t v19 = 0x100000000200;
    int v20 = 0x20000;
    marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v18, v10);
  }
  else
  {
    if (*(void *)(a1 + 840)) {
      int v11 = 0x2000;
    }
    else {
      int v11 = 4096;
    }
    unsigned int v12 = *(_DWORD *)(a4 + 16) | *(_DWORD *)(a4 + 8) | v11 | 1;
    uint64_t v18 = 3;
    uint64_t v19 = 0x100000000200;
    int v20 = 0x20000;
    marisa::grimoire::trie::Config::parse_((marisa::grimoire::trie::Config *)&v18, v12);
  }
  *(void *)(a1 + 1072) = v18;
  *(void *)(a1 + 1080) = v19;
  *(_DWORD *)(a1 + 1088) = v20;
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)(a1 + 416), 0, 0);
  if (*((void *)&v17[1] + 1))
  {
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      do
      {
        uint64_t v15 = *(void *)(*(void *)(a1 + 432) + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14;
        ++v14;
      }
      while ((v15 & 1) == 0);
      *(unsigned char *)(*(void *)(a1 + 632) + v14 - 1) = *(_DWORD *)(*((void *)&v17[0] + 1) + 4 * v13);
      *(_DWORD *)(*((void *)&v17[0] + 1) + 4 * v13++) >>= 8;
    }
    while (v13 < *((void *)&v17[1] + 1));
  }
  marisa::grimoire::vector::FlatVector::build((long long *)(a1 + 672), (uint64_t)v17);
  marisa::grimoire::trie::LoudsTrie::fill_cache(a1);
  uint64_t result = *(void *)&v17[0];
  if (*(void *)&v17[0]) {
    return MEMORY[0x1D9455390](*(void *)&v17[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D59301B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_next_trie<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)a4 == a5)
  {
    memset(v19, 0, 41);
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::resize((uint64_t *)v19, *(void *)(a2 + 24));
    uint64_t v9 = *(void *)(a2 + 24);
    if (v9)
    {
      unsigned int v10 = (_DWORD *)(*((void *)&v19[0] + 1) + 8);
      int v11 = (_DWORD *)(*(void *)(a2 + 8) + 8);
      do
      {
        uint64_t v12 = *((void *)v11 - 1);
        int v13 = *v11;
        v11 += 6;
        *((void *)v10 - 1) = v12 - 1;
        *unsigned int v10 = v13;
        v10 += 4;
        --v9;
      }
      while (v9);
    }
    marisa::grimoire::trie::Tail::build((long long *)(a1 + 744), (uint64_t)v19, a3, *(_DWORD *)(a4 + 12));
    uint64_t result = *(void *)&v19[0];
    if (*(void *)&v19[0]) {
      return MEMORY[0x1D9455390](*(void *)&v19[0], 0x1000C8077774924);
    }
  }
  else
  {
    uint64_t v15 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
    unint64_t v16 = v15;
    if (v15) {
      marisa::grimoire::trie::LoudsTrie::LoudsTrie(v15);
    }
    uint64_t v17 = (marisa::grimoire::trie::LoudsTrie **)(a1 + 1000);
    marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::reset(v17, v16);
    if (!*v17)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
      exception[2] = 0x8000001D4;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:468: MARISA_MEM"
                     "ORY_ERROR: next_trie_.get() == NULL";
    }
    return marisa::grimoire::trie::LoudsTrie::build_trie<marisa::grimoire::trie::ReverseKey>();
  }
  return result;
}

void sub_1D593037C(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553B0](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::cache<marisa::grimoire::trie::Key>(uint64_t result, uint64_t a2, int a3, unsigned __int8 a4, float a5)
{
  unint64_t v5 = *(void *)(result + 1056) & (a4 ^ (unint64_t)(32 * a2) ^ a2);
  uint64_t v6 = *(void *)(result + 1016);
  uint64_t v7 = v6 + 12 * v5;
  float v9 = *(float *)(v7 + 8);
  uint64_t v8 = (float *)(v7 + 8);
  if (v9 < a5)
  {
    unsigned int v10 = (_DWORD *)(v6 + 12 * v5);
    *unsigned int v10 = a2;
    v10[1] = a3;
    *uint64_t v8 = a5;
  }
  return result;
}

uint64_t *marisa::grimoire::trie::LoudsTrie::reserve_cache(marisa::grimoire::trie::LoudsTrie *this, const marisa::grimoire::trie::Config *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5 = 256;
  if (a3 != 1) {
    uint64_t v5 = 1;
  }
  do
  {
    unint64_t v6 = v5;
    v5 *= 2;
  }
  while (v6 < a4 / *((unsigned int *)a2 + 2));
  uint64_t result = marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize((uint64_t *)this + 126, v6);
  *((void *)this + 132) = v6 - 1;
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 > 0xAAAAAAAAAAAAAAALL) {
      uint64_t v5 = 0x1555555555555555;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    uint64_t result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::realloc(result, a2);
  }
  unint64_t v6 = v3[3];
  unint64_t v7 = v2 - v6;
  if (v2 > v6)
  {
    uint64_t v8 = 12 * v6;
    do
    {
      uint64_t v9 = v3[1] + v8;
      *(void *)uint64_t v9 = 0;
      *(_DWORD *)(v9 + 8) = 0x800000;
      v8 += 12;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::cache<marisa::grimoire::trie::ReverseKey>(uint64_t result, int a2, uint64_t a3, float a4)
{
  uint64_t v4 = *(void *)(result + 1056) & a3;
  uint64_t v5 = *(void *)(result + 1016);
  uint64_t v6 = v5 + 12 * v4;
  float v8 = *(float *)(v6 + 8);
  unint64_t v7 = (float *)(v6 + 8);
  if (v8 < a4)
  {
    uint64_t v9 = (_DWORD *)(v5 + 12 * v4);
    *uint64_t v9 = a2;
    v9[1] = a3;
    *unint64_t v7 = a4;
  }
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::fill_cache(uint64_t this)
{
  unint64_t v1 = *(void *)(this + 1032);
  if (v1)
  {
    uint64_t v2 = this;
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    uint64_t v5 = (marisa::grimoire::vector::BitVector *)(this + 416);
    do
    {
      uint64_t v6 = *(void *)(v2 + 1016);
      unint64_t v7 = *(unsigned int *)(v6 + v3 + 4);
      if (v7)
      {
        *(unsigned char *)(v6 + v3 + 8) = *(unsigned char *)(*(void *)(v2 + 632) + v7);
        uint64_t v8 = *(void *)(v2 + 1016);
        if ((*(void *)(*(void *)(v2 + 432) + ((v7 >> 3) & 0x1FFFFFF8)) >> v7))
        {
          this = marisa::grimoire::vector::BitVector::rank1(v5, v7);
          uint64_t v9 = *(void *)(v2 + 720);
          unint64_t v10 = (unint64_t)(v9 * this) >> 6;
          uint64_t v11 = (v9 * this) & 0x3F;
          unint64_t v12 = v11 + v9;
          uint64_t v13 = *(void *)(v2 + 688);
          unint64_t v14 = *(void *)(v13 + 8 * v10);
          if (v12 > 0x40) {
            uint64_t v15 = ((2 * *(void *)(v13 + 8 * v10 + 8)) << (v11 ^ 0x3Fu)) | (v14 >> v11);
          }
          else {
            uint64_t v15 = v14 >> v11;
          }
          int v16 = *(_DWORD *)(v2 + 728) & v15;
        }
        else
        {
          int v16 = 0xFFFFFF;
        }
        *(_DWORD *)(v8 + v3 + 8) = *(unsigned __int8 *)(v8 + v3 + 8) | (v16 << 8);
        unint64_t v1 = *(void *)(v2 + 1032);
      }
      else
      {
        *(void *)(v6 + v3) = -1;
      }
      ++v4;
      v3 += 12;
    }
    while (v4 < v1);
  }
  return this;
}

uint64_t marisa::grimoire::vector::BitVector::map(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Mapper *a2)
{
  memset(v4, 0, 41);
  long long v7 = 0u;
  memset(v8, 0, sizeof(v8));
  long long v9 = 0u;
  memset(v10, 0, sizeof(v10));
  v4[3] = 0u;
  long long v5 = 0u;
  memset(v6, 0, sizeof(v6));
  marisa::grimoire::vector::BitVector::map_((marisa::grimoire::vector::BitVector *)v4, a2);
  marisa::grimoire::vector::BitVector::swap(this, (marisa::grimoire::vector::BitVector *)v4);
  if ((void)v9) {
    MEMORY[0x1D9455390](v9, 0x1000C8077774924);
  }
  if ((void)v7) {
    MEMORY[0x1D9455390](v7, 0x1000C8077774924);
  }
  if ((void)v5) {
    MEMORY[0x1D9455390](v5, 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v4[0];
  if (*(void *)&v4[0]) {
    return MEMORY[0x1D9455390](*(void *)&v4[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D5930700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::map(long long *a1, marisa::grimoire::io::Mapper *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned char>::map_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D59307AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::FlatVector::map(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Mapper *a2)
{
  memset(v9, 0, 41);
  uint64_t v10 = 0;
  int v11 = 0;
  uint64_t v12 = 0;
  marisa::grimoire::vector::FlatVector::map_((marisa::grimoire::vector::FlatVector *)v9, a2);
  long long v3 = *(_OWORD *)this;
  *(_OWORD *)this = v9[0];
  v9[0] = v3;
  uint64_t v4 = *((void *)this + 2);
  *((void *)this + 2) = *(void *)&v9[1];
  *(void *)&v9[1] = v4;
  long long v5 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)&v9[1] + 8);
  *(_OWORD *)((char *)&v9[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)this + 40);
  *((unsigned char *)this + 40) = BYTE8(v9[2]);
  BYTE8(v9[2]) = v4;
  uint64_t v6 = *((void *)this + 6);
  *((void *)this + 6) = v10;
  uint64_t v10 = v6;
  LODWORD(v6) = *((_DWORD *)this + 14);
  *((_DWORD *)this + 14) = v11;
  int v11 = v6;
  uint64_t v7 = *((void *)this + 8);
  *((void *)this + 8) = v12;
  uint64_t result = v3;
  uint64_t v12 = v7;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D59308A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::map(long long *a1, marisa::grimoire::io::Mapper *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5930968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::BitVector::read(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Reader *a2)
{
  memset(v4, 0, 41);
  long long v7 = 0u;
  memset(v8, 0, sizeof(v8));
  long long v9 = 0u;
  memset(v10, 0, sizeof(v10));
  v4[3] = 0u;
  long long v5 = 0u;
  memset(v6, 0, sizeof(v6));
  marisa::grimoire::vector::BitVector::read_((marisa::grimoire::vector::BitVector *)v4, a2);
  marisa::grimoire::vector::BitVector::swap(this, (marisa::grimoire::vector::BitVector *)v4);
  if ((void)v9) {
    MEMORY[0x1D9455390](v9, 0x1000C8077774924);
  }
  if ((void)v7) {
    MEMORY[0x1D9455390](v7, 0x1000C8077774924);
  }
  if ((void)v5) {
    MEMORY[0x1D9455390](v5, 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v4[0];
  if (*(void *)&v4[0]) {
    return MEMORY[0x1D9455390](*(void *)&v4[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D5930A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::read(long long *a1, marisa::grimoire::io::Reader *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned char>::read_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5930B14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::FlatVector::read(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Reader *a2)
{
  memset(v9, 0, 41);
  uint64_t v10 = 0;
  int v11 = 0;
  uint64_t v12 = 0;
  marisa::grimoire::vector::FlatVector::read_((marisa::grimoire::vector::FlatVector *)v9, a2);
  long long v3 = *(_OWORD *)this;
  *(_OWORD *)this = v9[0];
  v9[0] = v3;
  uint64_t v4 = *((void *)this + 2);
  *((void *)this + 2) = *(void *)&v9[1];
  *(void *)&v9[1] = v4;
  long long v5 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)&v9[1] + 8);
  *(_OWORD *)((char *)&v9[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)this + 40);
  *((unsigned char *)this + 40) = BYTE8(v9[2]);
  BYTE8(v9[2]) = v4;
  uint64_t v6 = *((void *)this + 6);
  *((void *)this + 6) = v10;
  uint64_t v10 = v6;
  LODWORD(v6) = *((_DWORD *)this + 14);
  *((_DWORD *)this + 14) = v11;
  int v11 = v6;
  uint64_t v7 = *((void *)this + 8);
  *((void *)this + 8) = v12;
  uint64_t result = v3;
  uint64_t v12 = v7;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5930C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::read(long long *a1, marisa::grimoire::io::Reader *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::read_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5930CD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *marisa::grimoire::trie::LoudsTrie::restore_(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2, unint64_t a3)
{
  uint64_t v6 = (uint64_t *)*((void *)a2 + 5);
  uint64_t v7 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 416);
  uint64_t v8 = (uint64_t *)((char *)this + 744);
  while (1)
  {
    while (1)
    {
      unint64_t v9 = *((void *)this + 132) & a3;
      uint64_t v10 = *((void *)this + 128);
      if (a3 != *(_DWORD *)(v10 + 12 * v9 + 4)) {
        break;
      }
      uint64_t v11 = v10 + 12 * v9;
      unint64_t v12 = *(unsigned int *)(v11 + 8);
      if (v12 <= 0xFFFFFEFF)
      {
        uint64_t v23 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
        if (v23) {
          uint64_t result = (uint64_t *)marisa::grimoire::trie::LoudsTrie::restore_(v23, a2, v12);
        }
        else {
          uint64_t result = marisa::grimoire::trie::Tail::restore(v8, a2, v12);
        }
      }
      else
      {
        char v27 = *(_DWORD *)(v11 + 8);
        uint64_t result = marisa::grimoire::vector::Vector<char>::push_back(v6, &v27);
      }
      a3 = *(unsigned int *)(*((void *)this + 128) + 12 * v9);
      if (!a3) {
        return result;
      }
    }
    if ((*(void *)(*((void *)this + 54) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3))
    {
      int v14 = *(unsigned __int8 *)(*((void *)this + 80) + a3);
      uint64_t v15 = marisa::grimoire::vector::BitVector::rank1(v7, a3);
      uint64_t v16 = *((void *)this + 90);
      unint64_t v17 = (unint64_t)(v16 * v15) >> 6;
      uint64_t v18 = (v16 * v15) & 0x3F;
      unint64_t v19 = v18 + v16;
      uint64_t v20 = *((void *)this + 86);
      unint64_t v21 = *(void *)(v20 + 8 * v17);
      uint64_t v22 = v19 > 0x40
          ? ((2 * *(void *)(v20 + 8 * v17 + 8)) << (v18 ^ 0x3Fu)) | (v21 >> v18)
          : v21 >> v18;
      unint64_t v24 = v14 | ((*((_DWORD *)this + 182) & v22) << 8);
      uint64_t v25 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
      uint64_t result = v25
             ? (uint64_t *)marisa::grimoire::trie::LoudsTrie::restore_(v25, a2, v24)
             : marisa::grimoire::trie::Tail::restore(v8, a2, v24);
    }
    else
    {
      char v26 = *(unsigned char *)(*((void *)this + 80) + a3);
      uint64_t result = marisa::grimoire::vector::Vector<char>::push_back(v6, &v26);
    }
    if (a3 <= *((void *)this + 133)) {
      break;
    }
    a3 = marisa::grimoire::vector::BitVector::select1(this, a3) + ~a3;
  }
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::match_(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2, unint64_t a3)
{
  uint64_t v6 = *((void *)a2 + 5);
  uint64_t v7 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 416);
  uint64_t v8 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 744);
  while (1)
  {
    while (1)
    {
      unint64_t v9 = *((void *)this + 132) & a3;
      uint64_t v10 = *((void *)this + 128);
      if (a3 == *(_DWORD *)(v10 + 12 * v9 + 4)) {
        break;
      }
      if ((*(void *)(*((void *)this + 54) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3))
      {
        uint64_t v13 = *((void *)this + 125);
        int v14 = *(unsigned __int8 *)(*((void *)this + 80) + a3);
        uint64_t v15 = marisa::grimoire::vector::BitVector::rank1(v7, a3);
        uint64_t v16 = *((void *)this + 90);
        unint64_t v17 = (unint64_t)(v16 * v15) >> 6;
        uint64_t v18 = (v16 * v15) & 0x3F;
        unint64_t v19 = v18 + v16;
        uint64_t v20 = *((void *)this + 86);
        unint64_t v21 = *(void *)(v20 + 8 * v17);
        if (v13)
        {
          unint64_t v22 = v21 >> v18;
          if (v19 > 0x40) {
            v22 |= (2 * *(void *)(v20 + 8 * v17 + 8)) << (v18 ^ 0x3Fu);
          }
          unint64_t v23 = v14 | ((*((_DWORD *)this + 182) & v22) << 8);
          unint64_t v24 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
          if (v24)
          {
            if ((marisa::grimoire::trie::LoudsTrie::match_(v24, a2, v23) & 1) == 0) {
              return 0;
            }
            goto LABEL_27;
          }
        }
        else
        {
          if (v19 > 0x40) {
            uint64_t v27 = ((2 * *(void *)(v20 + 8 * v17 + 8)) << (v18 ^ 0x3Fu)) | (v21 >> v18);
          }
          else {
            uint64_t v27 = v21 >> v18;
          }
          unint64_t v23 = v14 | ((*((_DWORD *)this + 182) & v27) << 8);
        }
        if ((marisa::grimoire::trie::Tail::match(v8, a2, v23) & 1) == 0) {
          return 0;
        }
      }
      else
      {
        uint64_t v26 = *(unsigned int *)(v6 + 100);
        if (*(unsigned __int8 *)(*((void *)this + 80) + a3) != *(unsigned __int8 *)(*(void *)a2 + v26)) {
          return 0;
        }
        *(_DWORD *)(v6 + 100) = v26 + 1;
      }
LABEL_27:
      if (a3 <= *((void *)this + 133)) {
        return 1;
      }
      if (*((void *)a2 + 1) <= (unint64_t)*(unsigned int *)(v6 + 100)) {
        return 0;
      }
      a3 = marisa::grimoire::vector::BitVector::select1(this, a3) + ~a3;
    }
    unint64_t v11 = *(unsigned int *)(v10 + 12 * v9 + 8);
    if (v11 <= 0xFFFFFEFF)
    {
      uint64_t v25 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
      if (v25)
      {
        if ((marisa::grimoire::trie::LoudsTrie::match_(v25, a2, v11) & 1) == 0) {
          return 0;
        }
      }
      else if ((marisa::grimoire::trie::Tail::match(v8, a2, v11) & 1) == 0)
      {
        return 0;
      }
    }
    else
    {
      uint64_t v12 = *(unsigned int *)(v6 + 100);
      if (*(unsigned __int8 *)(*(void *)a2 + v12) != v11) {
        return 0;
      }
      *(_DWORD *)(v6 + 100) = v12 + 1;
    }
    a3 = *(unsigned int *)(*((void *)this + 128) + 12 * v9);
    if (!a3) {
      return 1;
    }
    if (*((void *)a2 + 1) <= (unint64_t)*(unsigned int *)(v6 + 100)) {
      return 0;
    }
  }
}

uint64_t marisa::grimoire::trie::LoudsTrie::prefix_match_(marisa::grimoire::trie::LoudsTrie *this, marisa::Agent *a2, unint64_t a3)
{
  uint64_t v6 = *((void *)a2 + 5);
  uint64_t v7 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 416);
  uint64_t v8 = (marisa::grimoire::trie::LoudsTrie *)((char *)this + 744);
  while (1)
  {
    unint64_t v9 = *((void *)this + 132) & a3;
    uint64_t v10 = *((void *)this + 128);
    if (a3 != *(_DWORD *)(v10 + 12 * v9 + 4))
    {
      int v12 = *(unsigned __int8 *)(*((void *)this + 80) + a3);
      if ((*(void *)(*((void *)this + 54) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3))
      {
        uint64_t v13 = marisa::grimoire::vector::BitVector::rank1(v7, a3);
        uint64_t v14 = *((void *)this + 90);
        unint64_t v15 = (unint64_t)(v14 * v13) >> 6;
        uint64_t v16 = (v14 * v13) & 0x3F;
        unint64_t v17 = v16 + v14;
        uint64_t v18 = *((void *)this + 86);
        unint64_t v19 = *(void *)(v18 + 8 * v15);
        if (v17 > 0x40) {
          uint64_t v20 = ((2 * *(void *)(v18 + 8 * v15 + 8)) << (v16 ^ 0x3Fu)) | (v19 >> v16);
        }
        else {
          uint64_t v20 = v19 >> v16;
        }
        unint64_t v22 = v12 | ((*((_DWORD *)this + 182) & v20) << 8);
        unint64_t v23 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
        if (v23)
        {
          if ((marisa::grimoire::trie::LoudsTrie::prefix_match_(v23, a2, v22) & 1) == 0) {
            return 0;
          }
        }
        else if (!marisa::grimoire::trie::Tail::prefix_match(v8, a2, v22))
        {
          return 0;
        }
      }
      else
      {
        if (v12 != *(unsigned __int8 *)(*(void *)a2 + *(unsigned int *)(v6 + 100))) {
          return 0;
        }
        char v25 = *(unsigned char *)(*((void *)this + 80) + a3);
        marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, &v25);
        ++*(_DWORD *)(v6 + 100);
      }
      if (a3 <= *((void *)this + 133)) {
        return 1;
      }
      a3 = marisa::grimoire::vector::BitVector::select1(this, a3) + ~a3;
      goto LABEL_23;
    }
    unint64_t v11 = *(unsigned int *)(v10 + 12 * v9 + 8);
    if (v11 > 0xFFFFFEFF)
    {
      if (*(unsigned __int8 *)(*(void *)a2 + *(unsigned int *)(v6 + 100)) != v11) {
        return 0;
      }
      char v26 = *(_DWORD *)(v10 + 12 * v9 + 8);
      marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, &v26);
      ++*(_DWORD *)(v6 + 100);
      goto LABEL_22;
    }
    unint64_t v21 = (marisa::grimoire::trie::LoudsTrie *)*((void *)this + 125);
    if (!v21) {
      break;
    }
    if ((marisa::grimoire::trie::LoudsTrie::prefix_match_(v21, a2, v11) & 1) == 0) {
      return 0;
    }
LABEL_22:
    a3 = *(unsigned int *)(*((void *)this + 128) + 12 * v9);
    if (!a3) {
      return 1;
    }
LABEL_23:
    if (*((void *)a2 + 1) <= (unint64_t)*(unsigned int *)(v6 + 100))
    {
      marisa::grimoire::trie::LoudsTrie::restore_(this, a2, a3);
      return 1;
    }
  }
  if (marisa::grimoire::trie::Tail::prefix_match(v8, a2, v11)) {
    goto LABEL_22;
  }
  return 0;
}

uint64_t marisa::grimoire::trie::Config::parse_(marisa::grimoire::trie::Config *this, unsigned int a2)
{
  if (a2 >= 0x100000)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h";
    exception[2] = 0x50000003BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h:59: MARISA_CODE_ERROR:"
                   " (config_flags & ~MARISA_CONFIG_MASK) != 0";
  }
  if ((a2 & 0x7F) != 0) {
    *(void *)this = a2 & 0x7F;
  }
  marisa::grimoire::trie::Config::parse_cache_level((uint64_t)this, a2);
  marisa::grimoire::trie::Config::parse_tail_mode((uint64_t)this, a2);

  return marisa::grimoire::trie::Config::parse_node_order((uint64_t)this, a2);
}

uint64_t marisa::grimoire::trie::Config::parse_cache_level(uint64_t this, __int16 a2)
{
  unsigned int v2 = a2 & 0xF80;
  int v3 = 512;
  if (v2 > 0x1FF)
  {
    if (v2 == 512) {
      goto LABEL_11;
    }
    if (v2 != 1024)
    {
      int v3 = a2 & 0xF80;
      if (v2 != 2048) {
        goto LABEL_9;
      }
      goto LABEL_11;
    }
LABEL_10:
    int v3 = a2 & 0xF80;
    goto LABEL_11;
  }
  if ((a2 & 0xF80) == 0) {
    goto LABEL_11;
  }
  if (v2 == 128) {
    goto LABEL_10;
  }
  int v3 = a2 & 0xF80;
  if (v2 != 256)
  {
LABEL_9:
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h";
    exception[2] = 0x500000065;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h:101: MARISA_CODE_ERROR"
                   ": undefined cache level";
  }
LABEL_11:
  *(_DWORD *)(this + 8) = v3;
  return this;
}

uint64_t marisa::grimoire::trie::Config::parse_tail_mode(uint64_t this, __int16 a2)
{
  int v2 = 4096;
  int v3 = a2 & 0xF000;
  if ((a2 & 0xF000) != 0 && v3 != 4096)
  {
    if (v3 != 0x2000)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h";
      exception[2] = 0x500000079;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h:121: MARISA_CODE_ERR"
                     "OR: undefined tail mode";
    }
    int v2 = 0x2000;
  }
  *(_DWORD *)(this + 12) = v2;
  return this;
}

uint64_t marisa::grimoire::trie::Config::parse_node_order(uint64_t this, int a2)
{
  int v2 = 0x20000;
  int v3 = a2 & 0xF0000;
  if ((a2 & 0xF0000) != 0 && v3 != 0x20000)
  {
    if (v3 != 0x10000)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h";
      exception[2] = 0x50000008DLL;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/config.h:141: MARISA_CODE_ERR"
                     "OR: undefined node order";
    }
    int v2 = 0x10000;
  }
  *(_DWORD *)(this + 16) = v2;
  return this;
}

unsigned char *marisa::grimoire::vector::Vector<char>::realloc(uint64_t *a1, size_t __sz)
{
  uint64_t result = operator new[](__sz, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = (char *)a1[1];
    uint64_t v7 = result;
    do
    {
      char v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = __sz;
  if (v9)
  {
    JUMPOUT(0x1D9455390);
  }
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  int v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 > 0x666666666666666) {
      uint64_t v5 = 0xCCCCCCCCCCCCCCCLL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    uint64_t result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(result, a2);
  }
  unint64_t v6 = v3[3];
  unint64_t v7 = v2 - v6;
  if (v2 > v6)
  {
    char v8 = (_DWORD *)(v3[1] + 20 * v6 + 16);
    do
    {
      *((_OWORD *)v8 - 1) = xmmword_1D59450B0;
      *char v8 = -1;
      v8 += 5;
      --v7;
    }
    while (v7);
  }
  v3[3] = v2;
  return result;
}

_DWORD *marisa::grimoire::vector::Vector<marisa::grimoire::trie::History>::realloc(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new[](20 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    unint64_t v6 = (long long *)a1[1];
    unint64_t v7 = result;
    do
    {
      long long v8 = *v6;
      v7[4] = *((_DWORD *)v6 + 4);
      *(_OWORD *)unint64_t v7 = v8;
      v7 += 5;
      unint64_t v6 = (long long *)((char *)v6 + 20);
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x1D9455390);
  }
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<unsigned long long>::resize(uint64_t *result, unint64_t a2, void *a3)
{
  unint64_t v4 = a2;
  uint64_t v5 = result;
  unint64_t v6 = result[4];
  if (v6 < a2)
  {
    uint64_t v7 = 2 * v6;
    if (v6 >> 60) {
      uint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v6 > a2 >> 1) {
      a2 = v7;
    }
    uint64_t result = marisa::grimoire::vector::Vector<unsigned long long>::realloc(result, a2);
  }
  unint64_t v8 = v5[3];
  unint64_t v9 = v4 - v8;
  if (v4 > v8)
  {
    uint64_t v10 = (void *)(v5[1] + 8 * v8);
    do
    {
      *v10++ = *a3;
      --v9;
    }
    while (v9);
  }
  v5[3] = v4;
  return result;
}

void *marisa::grimoire::vector::Vector<unsigned long long>::realloc(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new[](8 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    unint64_t v6 = (uint64_t *)a1[1];
    uint64_t v7 = result;
    do
    {
      uint64_t v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x1D9455390);
  }
  return result;
}

void *marisa::grimoire::vector::Vector<unsigned long long>::shrink(void *result)
{
  if (*((unsigned char *)result + 40))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:100: MARISA_"
                   "STATE_ERROR: fixed_";
  }
  uint64_t v1 = result[3];
  if (v1 != result[4])
  {
    return marisa::grimoire::vector::Vector<unsigned long long>::realloc(result, v1);
  }
  return result;
}

uint64_t marisa::grimoire::vector::BitVector::map_(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Mapper *a2)
{
  marisa::grimoire::vector::Vector<unsigned long long>::map((long long *)this, a2);
  *((void *)this + 6) = *(unsigned int *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  unint64_t v4 = *(unsigned int *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  if (*((void *)this + 6) < v4)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h";
    exception[2] = 0xA00000087;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h:135: MAR"
                   "ISA_FORMAT_ERROR: temp_num_1s > size_";
  }
  *((void *)this + 7) = v4;
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map((long long *)this + 4, a2);
  marisa::grimoire::vector::Vector<unsigned int>::map((long long *)this + 7, a2);

  return marisa::grimoire::vector::Vector<unsigned int>::map((long long *)this + 10, a2);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::map(long long *a1, marisa::grimoire::io::Mapper *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned long long>::map_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5931ACC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map(long long *a1, marisa::grimoire::io::Mapper *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5931B8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::map(long long *a1, marisa::grimoire::io::Mapper *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::map_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5931C4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::map_(uint64_t a1, marisa::grimoire::io::Mapper *this)
{
  unint64_t v4 = *(void *)marisa::grimoire::io::Mapper::map_data(this, 8uLL);
  if ((v4 & 7) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000CALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:202: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::io::Mapper::map<unsigned long long>(this, (uint64_t *)(a1 + 16), v4 >> 3);
  marisa::grimoire::io::Mapper::seek(this, -(int)v4 & 7);
  *(void *)(a1 + 24) = v4 >> 3;

  return marisa::grimoire::vector::Vector<unsigned long long>::fix(a1);
}

uint64_t marisa::grimoire::io::Mapper::map<unsigned long long>(marisa::grimoire::io::Mapper *a1, uint64_t *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x20000001CLL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:28: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 61)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x70000001ELL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:30: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v6;
  }
  uint64_t result = marisa::grimoire::io::Mapper::map_data(a1, 8 * a3);
  *a2 = result;
  return result;
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::fix(uint64_t result)
{
  if (*(unsigned char *)(result + 40))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0x10000006BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:107: MARISA_"
                   "STATE_ERROR: fixed_";
  }
  *(unsigned char *)(result + 40) = 1;
  return result;
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::map_(uint64_t a1, marisa::grimoire::io::Mapper *this)
{
  unint64_t v4 = *(void *)marisa::grimoire::io::Mapper::map_data(this, 8uLL);
  unint64_t v5 = v4 / 0xC;
  if (v4 % 0xC)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000CALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:202: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::io::Mapper::map<marisa::grimoire::vector::RankIndex>(this, (uint64_t *)(a1 + 16), v5);
  marisa::grimoire::io::Mapper::seek(this, -(int)v4 & 7);
  *(void *)(a1 + 24) = v5;

  return marisa::grimoire::vector::Vector<unsigned long long>::fix(a1);
}

uint64_t marisa::grimoire::io::Mapper::map<marisa::grimoire::vector::RankIndex>(marisa::grimoire::io::Mapper *a1, uint64_t *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x20000001CLL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:28: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >= 0x1555555555555556)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x70000001ELL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:30: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v6;
  }
  uint64_t result = marisa::grimoire::io::Mapper::map_data(a1, 12 * a3);
  *a2 = result;
  return result;
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::map_(uint64_t a1, marisa::grimoire::io::Mapper *this)
{
  unint64_t v4 = *(void *)marisa::grimoire::io::Mapper::map_data(this, 8uLL);
  if ((v4 & 3) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000CALL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:202: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::io::Mapper::map<unsigned int>(this, (uint64_t *)(a1 + 16), v4 >> 2);
  marisa::grimoire::io::Mapper::seek(this, -(int)v4 & 7);
  *(void *)(a1 + 24) = v4 >> 2;

  return marisa::grimoire::vector::Vector<unsigned long long>::fix(a1);
}

uint64_t marisa::grimoire::io::Mapper::map<unsigned int>(marisa::grimoire::io::Mapper *a1, uint64_t *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x20000001CLL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:28: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_7;
  }
  if (a3 >> 62)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h";
    exception[2] = 0x70000001ELL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/mapper.h:30: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_7:
    exception[3] = v6;
  }
  uint64_t result = marisa::grimoire::io::Mapper::map_data(a1, 4 * a3);
  *a2 = result;
  return result;
}

void *marisa::grimoire::vector::FlatVector::map_(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Mapper *a2)
{
  marisa::grimoire::vector::Vector<unsigned long long>::map((long long *)this, a2);
  uint64_t v4 = *(unsigned int *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  if (v4 >= 0x21)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/flat-vector.h";
    exception[2] = 0xA00000086;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/flat-vector.h:134: MA"
                   "RISA_FORMAT_ERROR: temp_value_size > 32";
  }
  *((void *)this + 6) = v4;
  *((_DWORD *)this + 14) = *(_DWORD *)marisa::grimoire::io::Mapper::map_data(a2, 4uLL);
  uint64_t result = (void *)marisa::grimoire::io::Mapper::map_data(a2, 8uLL);
  *((void *)this + 8) = *result;
  return result;
}

uint64_t marisa::grimoire::vector::BitVector::read_(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Reader *a2)
{
  marisa::grimoire::vector::Vector<unsigned long long>::read((long long *)this, a2);
  unsigned int v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v7, 4uLL);
  *((void *)this + 6) = v7;
  unsigned int v6 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v6, 4uLL);
  if (*((void *)this + 6) < (unint64_t)v6)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h";
    exception[2] = 0xA00000099;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/bit-vector.h:153: MAR"
                   "ISA_FORMAT_ERROR: temp_num_1s > size_";
  }
  *((void *)this + 7) = v6;
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::read((long long *)this + 4, a2);
  marisa::grimoire::vector::Vector<unsigned int>::read((long long *)this + 7, a2);
  return marisa::grimoire::vector::Vector<unsigned int>::read((long long *)this + 10, a2);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::read(long long *a1, marisa::grimoire::io::Reader *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned long long>::read_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D59324B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::read(long long *a1, marisa::grimoire::io::Reader *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::read_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5932574(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::read(long long *a1, marisa::grimoire::io::Reader *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::read_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5932634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  unint64_t v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v7, 8uLL);
  if ((v7 & 7) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:213: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  unint64_t v4 = v7 >> 3;
  marisa::grimoire::vector::Vector<unsigned long long>::resize((uint64_t *)a1, v7 >> 3);
  marisa::grimoire::io::Reader::read<unsigned long long>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v7 & 7);
}

uint64_t *marisa::grimoire::vector::Vector<unsigned long long>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  long long v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 >> 60) {
      uint64_t v5 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    uint64_t result = marisa::grimoire::vector::Vector<unsigned long long>::realloc(result, a2);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::io::Reader::read<unsigned long long>(uint64_t a1, char *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x20000001FLL;
    unsigned int v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:31: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_9;
  }
  if (a3 >> 61)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x700000021;
    unsigned int v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:33: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_9:
    exception[3] = v6;
  }
  size_t v3 = 8 * a3;

  return marisa::grimoire::io::Reader::read_data(a1, a2, v3);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  unint64_t v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v7, 8uLL);
  unint64_t v4 = v7 / 0xC;
  if (v7 % 0xC)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:213: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::resize((uint64_t *)a1, v7 / 0xC);
  marisa::grimoire::io::Reader::read<marisa::grimoire::vector::RankIndex>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v7 & 7);
}

void marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  unint64_t v4 = a1[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 > 0xAAAAAAAAAAAAAAALL) {
      uint64_t v5 = 0x1555555555555555;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::realloc(a1, a2);
  }
  unint64_t v6 = a1[3];
  if (v2 > v6) {
    bzero((void *)(a1[1] + 12 * v6), 12 * (v2 - v6));
  }
  a1[3] = v2;
}

uint64_t marisa::grimoire::io::Reader::read<marisa::grimoire::vector::RankIndex>(uint64_t a1, char *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x20000001FLL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:31: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_9;
  }
  if (a3 >= 0x1555555555555556)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x700000021;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:33: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_9:
    exception[3] = v6;
  }
  size_t v3 = 12 * a3;

  return marisa::grimoire::io::Reader::read_data(a1, a2, v3);
}

_DWORD *marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::realloc(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new[](12 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    unint64_t v6 = (uint64_t *)a1[1];
    unint64_t v7 = result;
    do
    {
      uint64_t v8 = *v6;
      v7[2] = *((_DWORD *)v6 + 2);
      *(void *)unint64_t v7 = v8;
      v7 += 3;
      unint64_t v6 = (uint64_t *)((char *)v6 + 12);
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x1D9455390);
  }
  return result;
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  unint64_t v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v7, 8uLL);
  if ((v7 & 3) != 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:213: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  unint64_t v4 = v7 >> 2;
  marisa::grimoire::vector::Vector<unsigned int>::resize((uint64_t *)a1, v7 >> 2);
  marisa::grimoire::io::Reader::read<unsigned int>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v7 & 7);
}

uint64_t *marisa::grimoire::vector::Vector<unsigned int>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = a2;
  size_t v3 = result;
  unint64_t v4 = result[4];
  if (v4 < a2)
  {
    uint64_t v5 = 2 * v4;
    if (v4 >> 61) {
      uint64_t v5 = 0x3FFFFFFFFFFFFFFFLL;
    }
    if (v4 > a2 >> 1) {
      a2 = v5;
    }
    uint64_t result = (uint64_t *)marisa::grimoire::vector::Vector<unsigned int>::realloc(result, a2);
  }
  v3[3] = v2;
  return result;
}

uint64_t marisa::grimoire::io::Reader::read<unsigned int>(uint64_t a1, char *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x20000001FLL;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:31: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_9;
  }
  if (a3 >> 62)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x700000021;
    unint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:33: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_9:
    exception[3] = v6;
  }
  size_t v3 = 4 * a3;

  return marisa::grimoire::io::Reader::read_data(a1, a2, v3);
}

_DWORD *marisa::grimoire::vector::Vector<unsigned int>::realloc(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new[](4 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    unint64_t v6 = (int *)a1[1];
    unint64_t v7 = result;
    do
    {
      int v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x1D9455390);
  }
  return result;
}

uint64_t marisa::grimoire::vector::FlatVector::read_(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Reader *a2)
{
  marisa::grimoire::vector::Vector<unsigned long long>::read((long long *)this, a2);
  LODWORD(v6) = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v6, 4uLL);
  if (v6 >= 0x21)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/flat-vector.h";
    exception[2] = 0xA0000009BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/flat-vector.h:155: MA"
                   "RISA_FORMAT_ERROR: temp_value_size > 32";
  }
  *((void *)this + 6) = v6;
  LODWORD(v6) = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v6, 4uLL);
  *((_DWORD *)this + 14) = v6;
  uint64_t v6 = 0;
  uint64_t result = marisa::grimoire::io::Reader::read_data((uint64_t)a2, (char *)&v6, 8uLL);
  *((void *)this + 8) = v6;
  return result;
}

uint64_t marisa::grimoire::vector::BitVector::write_(marisa::grimoire::vector::BitVector *this, marisa::grimoire::io::Writer *a2)
{
  marisa::grimoire::vector::Vector<unsigned long long>::write_((uint64_t)this, a2);
  int __buf = *((void *)this + 6);
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 4uLL);
  int v5 = *((void *)this + 7);
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&v5, 4uLL);
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::write_((uint64_t)this + 64, a2);
  marisa::grimoire::vector::Vector<unsigned int>::write_((uint64_t)this + 112, a2);
  return marisa::grimoire::vector::Vector<unsigned int>::write_((uint64_t)this + 160, a2);
}

uint64_t marisa::grimoire::vector::Vector<unsigned long long>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf = 8 * *(void *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<unsigned long long>((uint64_t)this, *(char **)(a1 + 16), *(void *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, 0);
}

uint64_t marisa::grimoire::io::Writer::write<unsigned long long>(uint64_t a1, char *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x20000001ELL;
    uint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:30: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_9;
  }
  if (a3 >> 61)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x700000020;
    uint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:32: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_9:
    exception[3] = v6;
  }
  size_t v3 = 8 * a3;

  return marisa::grimoire::io::Writer::write_data(a1, a2, v3);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf = 12 * *(void *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<marisa::grimoire::vector::RankIndex>((uint64_t)this, *(char **)(a1 + 16), *(void *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, 4 * (*(_DWORD *)(a1 + 24) & 1));
}

uint64_t marisa::grimoire::io::Writer::write<marisa::grimoire::vector::RankIndex>(uint64_t a1, char *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x20000001ELL;
    uint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:30: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_9;
  }
  if (a3 >= 0x1555555555555556)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x700000020;
    uint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:32: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_9:
    exception[3] = v6;
  }
  size_t v3 = 12 * a3;

  return marisa::grimoire::io::Writer::write_data(a1, a2, v3);
}

uint64_t marisa::grimoire::vector::Vector<unsigned int>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf = 4 * *(void *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<unsigned int>((uint64_t)this, *(char **)(a1 + 16), *(void *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, 4 * (*(_DWORD *)(a1 + 24) & 1));
}

uint64_t marisa::grimoire::io::Writer::write<unsigned int>(uint64_t a1, char *a2, unint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x20000001ELL;
    uint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:30: MARISA_NULL_ERROR: (ob"
         "js == NULL) && (num_objs != 0)";
    goto LABEL_9;
  }
  if (a3 >> 62)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x700000020;
    uint64_t v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:32: MARISA_SIZE_ERROR: num"
         "_objs > (MARISA_SIZE_MAX / sizeof(T))";
LABEL_9:
    exception[3] = v6;
  }
  size_t v3 = 4 * a3;

  return marisa::grimoire::io::Writer::write_data(a1, a2, v3);
}

uint64_t marisa::grimoire::vector::FlatVector::write_(marisa::grimoire::vector::FlatVector *this, marisa::grimoire::io::Writer *a2)
{
  marisa::grimoire::vector::Vector<unsigned long long>::write_((uint64_t)this, a2);
  LODWORD(__buf) = *((void *)this + 6);
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 4uLL);
  LODWORD(__buf) = *((_DWORD *)this + 14);
  marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 4uLL);
  uint64_t __buf = *((void *)this + 8);
  return marisa::grimoire::io::Writer::write_data((uint64_t)a2, (char *)&__buf, 8uLL);
}

marisa::grimoire::trie::LoudsTrie **marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(marisa::grimoire::trie::LoudsTrie **a1)
{
  unint64_t v2 = *a1;
  if (v2)
  {
    marisa::grimoire::trie::LoudsTrie::~LoudsTrie(v2);
    MEMORY[0x1D94553C0]();
  }
  return a1;
}

char *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::realloc(uint64_t *a1, uint64_t a2)
{
  uint64_t result = (char *)operator new[](24 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = (_DWORD *)(a1[1] + 16);
    unint64_t v7 = result + 16;
    do
    {
      *((void *)v7 - 2) = *((void *)v6 - 2);
      *(v7 - 2) = *(v6 - 2);
      *(v7 - 1) = *(v6 - 1);
      int v8 = *v6;
      v6 += 6;
      *unint64_t v7 = v8;
      v7 += 6;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x1D9455390);
  }
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::Key>(uint64_t *a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a2 + 24);
  unint64_t v10 = *(void *)(a2 + 8);
  if (v9)
  {
    uint64_t v11 = 0;
    int v12 = (_DWORD *)(v10 + 16);
    do
    {
      *int v12 = v11;
      v12 += 6;
      ++v11;
    }
    while (v9 != v11);
  }
  unint64_t v13 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v10, v10 + 24 * v9, 0);
  uint64_t v14 = 256;
  if (a5 != 1) {
    uint64_t v14 = 1;
  }
  do
  {
    unint64_t v15 = v14;
    v14 *= 2;
  }
  while (v15 < v13 / *(unsigned int *)(a4 + 8));
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize(a1 + 126, v15);
  a1[132] = v15 - 1;
  marisa::grimoire::vector::BitVector::push_back(a1, 1);
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  uint64_t v16 = a1 + 78;
  LOBYTE(v84[0]) = 0;
  marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, v84);
  unsigned int v77 = a1 + 52;
  marisa::grimoire::vector::BitVector::push_back(a1 + 52, 0);
  uint64_t v72 = a5;
  memset(v84, 0, 41);
  long long v83 = 0u;
  memset(v82, 0, sizeof(v82));
  long long v80 = 0u;
  memset(v81, 0, 25);
  v78.n128_u64[0] = *(void *)(a2 + 24) << 32;
  v78.n128_u32[2] = 0;
  std::deque<marisa::grimoire::trie::Range>::push_back(v82, (uint64_t *)&v78);
  uint64_t v17 = *((void *)&v83 + 1);
  if (*((void *)&v83 + 1))
  {
    unint64_t v73 = a1 + 78;
    do
    {
      uint64_t v18 = a1[58];
      unint64_t v19 = (unsigned int *)(*(void *)(*((void *)&v82[0] + 1) + 8 * ((unint64_t)v83 / 0x155))
                           + 12 * ((unint64_t)v83 % 0x155));
      uint64_t v20 = *v19;
      unint64_t v21 = v19[1];
      uint64_t v22 = v19[2];
      *(void *)&long long v83 = v83 + 1;
      *((void *)&v83 + 1) = v17 - 1;
      if ((unint64_t)v83 >= 0x2AA)
      {
        uint64_t v23 = v18;
        operator delete(**((void ***)&v82[0] + 1));
        uint64_t v18 = v23;
        *((void *)&v82[0] + 1) += 8;
        *(void *)&long long v83 = v83 - 341;
      }
      uint64_t v76 = v17;
      uint64_t v24 = v18 - v17;
      if (v20 < v21)
      {
        while (1)
        {
          uint64_t v25 = *(void *)(a2 + 8);
          if (*(_DWORD *)(v25 + 24 * v20 + 8) != v22) {
            break;
          }
          *(_DWORD *)(v25 + 24 * v20 + 12) = v24;
          uint64_t v20 = (v20 + 1);
          if (v21 == v20) {
            goto LABEL_49;
          }
        }
      }
      if (v20 != v21)
      {
        uint64_t v75 = v18;
        uint64_t v26 = v80;
        long long v80 = 0u;
        memset(v81, 0, 25);
        if (v26) {
          MEMORY[0x1D9455390](v26, 0x1000C8077774924);
        }
        uint64_t v27 = *(void *)(a2 + 8);
        double v28 = *(float *)(v27 + 24 * v20 + 12);
        uint64_t v29 = v20 + 1;
        if (v20 + 1 < v21)
        {
          uint64_t v30 = 24 * v20;
          uint64_t v31 = (v20 << 32) + 0x100000000;
          do
          {
            if (*(unsigned __int8 *)(*(void *)(v27 + v30) + v22) != *(unsigned __int8 *)(*(void *)(v27 + v30 + 24)
                                                                                          + v22))
            {
              *(float *)&unsigned int v32 = v28;
              v78.n128_u64[0] = v31 + v20;
              v78.n128_u64[1] = v22 | ((unint64_t)v32 << 32);
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back((uint64_t *)&v80, &v78);
              uint64_t v27 = *(void *)(a2 + 8);
              double v28 = 0.0;
              LODWORD(v20) = v29;
            }
            double v28 = v28 + *(float *)(v27 + v30 + 36);
            ++v29;
            v30 += 24;
            v31 += 0x100000000;
          }
          while (v21 != v29);
        }
        *(float *)&unsigned int v33 = v28;
        v78.n128_u32[0] = v20;
        v78.n128_u32[1] = v21;
        v78.n128_u64[1] = v22 | ((unint64_t)v33 << 32);
        __n128 v34 = marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back((uint64_t *)&v80, &v78);
        uint64_t v16 = a1 + 78;
        uint64_t v35 = v75;
        if (*(_DWORD *)(a4 + 16) == 0x20000)
        {
          uint64_t v36 = (__n128 *)*((void *)&v80 + 1);
          unint64_t v37 = v81[1];
          if (v81[1] < 129)
          {
            unint64_t v38 = 0;
            uint64_t v40 = 0;
          }
          else
          {
            unint64_t v38 = (__n128 *)std::get_temporary_buffer[abi:ne180100]<marisa::grimoire::trie::WeightedRange>(v81[1]);
            uint64_t v40 = v39;
          }
          std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v36, &v36[v37], (uint64_t)&v78, v37, v38, v40, v34);
          if (v38) {
            operator delete(v38);
          }
          uint64_t v35 = v75;
        }
        uint64_t v41 = v81[1];
        if (v35 == v76) {
          a1[133] = v81[1];
        }
        if (v41)
        {
          unint64_t v42 = 0;
          do
          {
            unsigned int v43 = (unsigned int *)(*((void *)&v80 + 1) + 16 * v42);
            unsigned int v44 = (uint64_t *)v43;
            uint64_t v45 = v43[2];
            unsigned int v46 = *v43;
            uint64_t v47 = *(void *)(a2 + 8);
            unint64_t v48 = *(unsigned int *)(v47 + 24 * *v43 + 8);
            unint64_t v49 = v45 + 1;
            if (v45 + 1 >= v48)
            {
              unint64_t v50 = v43[2];
              LODWORD(v48) = v45 + 1;
            }
            else
            {
              unint64_t v50 = v48 - 1;
              unint64_t v51 = v43[2];
              do
              {
                unint64_t v52 = v51;
                unint64_t v51 = v49;
                uint64_t v53 = (uint64_t *)(v47 + 24 * v46);
                uint64_t v54 = *v43;
                while (++v54 < (unint64_t)v43[1])
                {
                  uint64_t v55 = *v53;
                  uint64_t v56 = v53[3];
                  v53 += 3;
                  if (*(unsigned __int8 *)(v55 + v51) != *(unsigned __int8 *)(v56 + v51))
                  {
                    unint64_t v50 = v52;
                    LODWORD(v48) = v51;
                    goto LABEL_43;
                  }
                }
                unint64_t v49 = v51 + 1;
              }
              while (v51 + 1 != v48);
            }
LABEL_43:
            float v58 = *((float *)v43 + 3);
            unsigned int v57 = v43 + 3;
            float v59 = v58;
            uint64_t v60 = ((32 * v24) ^ v24 ^ *(unsigned __int8 *)(*(void *)(v47 + 24 * v46) + v45)) & a1[132];
            uint64_t v61 = a1[127];
            uint64_t v62 = v61 + 12 * v60;
            float v64 = *(float *)(v62 + 8);
            uint64_t v63 = (float *)(v62 + 8);
            if (v64 < v59)
            {
              uint64_t v65 = a1[81];
              int v66 = (_DWORD *)(v61 + 12 * v60);
              *int v66 = v24;
              v66[1] = v65;
              *uint64_t v63 = v59;
              uint64_t v45 = *((unsigned int *)v44 + 2);
            }
            if (v50 == v45)
            {
              v78.n128_u8[0] = *(unsigned char *)(*(void *)(*(void *)(a2 + 8) + 24 * *(unsigned int *)v44) + v50);
              marisa::grimoire::vector::Vector<char>::push_back(v73, &v78);
              marisa::grimoire::vector::BitVector::push_back(v77, 0);
            }
            else
            {
              v78.n128_u8[0] = 0;
              marisa::grimoire::vector::Vector<char>::push_back(v73, &v78);
              marisa::grimoire::vector::BitVector::push_back(v77, 1);
              __n128 v78 = 0uLL;
              int v79 = 0;
              uint64_t v67 = *((unsigned int *)v44 + 2);
              v78.n128_u64[0] = *(void *)(*(void *)(a2 + 8) + 24 * *(unsigned int *)v44) + v67;
              v78.n128_u64[1] = (v48 - v67);
              v78.n128_u32[3] = *v57;
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::push_back((uint64_t *)v84, (uint64_t)&v78);
            }
            *((_DWORD *)v44 + 2) = v48;
            std::deque<marisa::grimoire::trie::Range>::push_back(v82, v44);
            marisa::grimoire::vector::BitVector::push_back(a1, 1);
            ++v42;
          }
          while (v42 < v81[1]);
        }
      }
LABEL_49:
      marisa::grimoire::vector::BitVector::push_back(a1, 0);
      uint64_t v17 = *((void *)&v83 + 1);
    }
    while (*((void *)&v83 + 1));
  }
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)a1, v72 == 1, 1);
  marisa::grimoire::vector::Vector<unsigned char>::shrink(v16);
  marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::Key>((uint64_t)a1, a2, a3);
  long long v68 = *(_OWORD *)a2;
  *(_OWORD *)a2 = v84[0];
  v84[0] = v68;
  uint64_t v69 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = *(void *)&v84[1];
  *(void *)&v84[1] = v69;
  long long v70 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)&v84[1] + 8);
  *(_OWORD *)((char *)&v84[1] + 8) = v70;
  LOBYTE(v69) = *(unsigned char *)(a2 + 40);
  *(unsigned char *)(a2 + 40) = BYTE8(v84[2]);
  BYTE8(v84[2]) = v69;
  if ((void)v80) {
    MEMORY[0x1D9455390](v80, 0x1000C8077774924);
  }
  std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100](v82);
  uint64_t result = *(void *)&v84[0];
  if (*(void *)&v84[0]) {
    return MEMORY[0x1D9455390](*(void *)&v84[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D5933B38(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, ...)
{
  va_start(va, a18);
  if (a13) {
    MEMORY[0x1D9455390](a13, 0x1000C8077774924);
  }
  std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100]((uint64_t *)va);
  uint64_t v21 = *(void *)(v18 - 144);
  if (v21) {
    MEMORY[0x1D9455390](v21, 0x1000C8077774924);
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x8000001ACLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:428: MARISA_MEMOR"
                   "Y_ERROR: std::bad_alloc";
  }
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::vector::FlatVector::build(long long *a1, uint64_t a2)
{
  memset(v9, 0, 41);
  uint64_t v10 = 0;
  int v11 = 0;
  uint64_t v12 = 0;
  marisa::grimoire::vector::FlatVector::build_((uint64_t)v9, a2);
  long long v3 = *a1;
  *a1 = v9[0];
  v9[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v9[1];
  *(void *)&v9[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v9[1] + 8);
  *(_OWORD *)((char *)&v9[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v9[2]);
  BYTE8(v9[2]) = v4;
  uint64_t v6 = *((void *)a1 + 6);
  *((void *)a1 + 6) = v10;
  uint64_t v10 = v6;
  LODWORD(v6) = *((_DWORD *)a1 + 14);
  *((_DWORD *)a1 + 14) = v11;
  int v11 = v6;
  uint64_t v7 = *((void *)a1 + 8);
  *((void *)a1 + 8) = v12;
  uint64_t result = v3;
  uint64_t v12 = v7;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5933D2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

__n128 marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back(uint64_t *a1, __n128 *a2)
{
  uint64_t v4 = a1[3];
  unint64_t v5 = a1[4];
  unint64_t v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    uint64_t v7 = 2 * v5;
    if (v5 >> 59) {
      uint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
    }
    if (v5 <= v6 >> 1) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = v7;
    }
    marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::realloc(a1, v8);
    uint64_t v4 = a1[3];
  }
  __n128 result = *a2;
  *(__n128 *)(a1[1] + 16 * v4) = *a2;
  ++a1[3];
  return result;
}

uint64_t *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::push_back(uint64_t *result, uint64_t a2)
{
  long long v3 = result;
  uint64_t v4 = result[3];
  unint64_t v5 = result[4];
  unint64_t v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    uint64_t v7 = 2 * v5;
    if (v5 > 0x555555555555555) {
      uint64_t v7 = 0xAAAAAAAAAAAAAAALL;
    }
    if (v5 <= v6 >> 1) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = v7;
    }
    __n128 result = (uint64_t *)marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::realloc(result, v8);
    uint64_t v4 = v3[3];
  }
  uint64_t v9 = v3[1] + 24 * v4;
  *(void *)uint64_t v9 = *(void *)a2;
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v9 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(v9 + 16) = *(_DWORD *)(a2 + 16);
  ++v3[3];
  return result;
}

unsigned char *marisa::grimoire::vector::Vector<unsigned char>::shrink(unsigned char *result)
{
  if (result[40])
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:100: MARISA_"
                   "STATE_ERROR: fixed_";
  }
  size_t v1 = *((void *)result + 3);
  if (v1 != *((void *)result + 4))
  {
    return marisa::grimoire::vector::Vector<char>::realloc((uint64_t *)result, v1);
  }
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t a2, long long *a3)
{
  memset(v13, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::resize((uint64_t *)v13, *(void *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = *((void *)&v13[0] + 1);
    uint64_t v7 = (unsigned int *)(*(void *)(a2 + 16) + 16);
    do
    {
      *(_DWORD *)(v6 + 4 * *v7) = *(v7 - 1);
      v7 += 6;
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v6 = *((void *)&v13[0] + 1);
  }
  long long v8 = *a3;
  uint64_t v9 = *(void *)&v13[1];
  *(void *)a3 = *(void *)&v13[0];
  *((void *)a3 + 1) = v6;
  v13[0] = v8;
  uint64_t v10 = *((void *)a3 + 2);
  *((void *)a3 + 2) = v9;
  *(void *)&v13[1] = v10;
  long long v11 = *(long long *)((char *)a3 + 24);
  *(long long *)((char *)a3 + 24) = *(_OWORD *)((char *)&v13[1] + 8);
  *(_OWORD *)((char *)&v13[1] + 8) = v11;
  LOBYTE(v10) = *((unsigned char *)a3 + 40);
  *((unsigned char *)a3 + 40) = BYTE8(v13[2]);
  uint64_t result = v8;
  BYTE8(v13[2]) = v10;
  if ((void)v8) {
    return MEMORY[0x1D9455390](v8, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5933FD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = a2;
  unint64_t v5 = a1;
  uint64_t v6 = a2 - a1;
  if ((uint64_t)(a2 - a1) < 241)
  {
    uint64_t v7 = 0;
    goto LABEL_69;
  }
  uint64_t v7 = 0;
  do
  {
    int v8 = marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Key>(v5, v5 + 24 * (v6 / 0x30uLL), v4 - 24, a3);
    int v9 = v8;
    unint64_t v10 = v5;
    unint64_t v11 = v4;
    unint64_t v12 = v5;
    unint64_t v13 = v4;
    while (v10 < v11)
    {
      unint64_t v14 = *(unsigned int *)(v10 + 8);
      int v15 = a3 >= v14 ? -1 : *(unsigned __int8 *)(*(void *)v10 + a3);
      if (v15 > v8) {
        break;
      }
      if (v15 == v8)
      {
        uint64_t v16 = *(void *)v10;
        *(void *)unint64_t v10 = *(void *)v12;
        *(_DWORD *)(v10 + 8) = *(_DWORD *)(v12 + 8);
        uint64_t v17 = *(void *)(v10 + 12);
        *(_DWORD *)(v10 + 12) = *(_DWORD *)(v12 + 12);
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v12 + 16);
        *(void *)unint64_t v12 = v16;
        *(_DWORD *)(v12 + 8) = v14;
        *(void *)(v12 + 12) = v17;
        v12 += 24;
      }
LABEL_11:
      v10 += 24;
    }
    if (v10 < v11)
    {
      unint64_t v18 = v11 - 24;
      do
      {
        unint64_t v11 = v18;
        unint64_t v19 = *(unsigned int *)(v18 + 8);
        if (a3 >= v19) {
          int v20 = -1;
        }
        else {
          int v20 = *(unsigned __int8 *)(*(void *)v11 + a3);
        }
        if (v20 < v8) {
          break;
        }
        if (v20 == v8)
        {
          uint64_t v21 = *(void *)(v13 - 24);
          v13 -= 24;
          uint64_t v22 = *(void *)v11;
          *(void *)unint64_t v11 = v21;
          *(_DWORD *)(v11 + 8) = *(_DWORD *)(v13 + 8);
          uint64_t v23 = *(void *)(v11 + 12);
          *(_DWORD *)(v11 + 12) = *(_DWORD *)(v13 + 12);
          *(_DWORD *)(v11 + 16) = *(_DWORD *)(v13 + 16);
          *(void *)unint64_t v13 = v22;
          *(_DWORD *)(v13 + 8) = v19;
          *(void *)(v13 + 12) = v23;
        }
        unint64_t v18 = v11 - 24;
      }
      while (v10 < v11);
    }
    if (v10 < v11)
    {
      uint64_t v24 = *(void *)v10;
      int v25 = *(_DWORD *)(v10 + 16);
      *(void *)unint64_t v10 = *(void *)v11;
      uint64_t v26 = *(void *)(v10 + 8);
      *(_DWORD *)(v10 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v10 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v10 + 16) = *(_DWORD *)(v11 + 16);
      *(void *)unint64_t v11 = v24;
      *(void *)(v11 + 8) = v26;
      *(_DWORD *)(v11 + 16) = v25;
      goto LABEL_11;
    }
    uint64_t v44 = v7;
    if (v12 > v5)
    {
      uint64_t v27 = 0;
      do
      {
        uint64_t v28 = v12 + v27;
        uint64_t v29 = v10 + v27;
        uint64_t v30 = *(void *)(v12 + v27 - 24);
        int v31 = *(_DWORD *)(v12 + v27 - 8);
        *(void *)(v28 - 24) = *(void *)(v10 + v27 - 24);
        uint64_t v32 = *(void *)(v12 + v27 - 16);
        *(_DWORD *)(v28 - 16) = *(_DWORD *)(v10 + v27 - 16);
        *(_DWORD *)(v28 - 12) = *(_DWORD *)(v10 + v27 - 12);
        *(_DWORD *)(v28 - 8) = *(_DWORD *)(v10 + v27 - 8);
        *(void *)(v29 - 24) = v30;
        *(void *)(v29 - 16) = v32;
        *(_DWORD *)(v29 - 8) = v31;
        v27 -= 24;
      }
      while (v12 + v27 > v5);
      v10 += v27;
    }
    while (v13 < v4)
    {
      uint64_t v33 = *(void *)v13;
      int v34 = *(_DWORD *)(v13 + 16);
      *(void *)unint64_t v13 = *(void *)v11;
      uint64_t v35 = *(void *)(v13 + 8);
      *(_DWORD *)(v13 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v13 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v13 + 16) = *(_DWORD *)(v11 + 16);
      *(void *)unint64_t v11 = v33;
      *(void *)(v11 + 8) = v35;
      *(_DWORD *)(v11 + 16) = v34;
      v11 += 24;
      v13 += 24;
    }
    uint64_t v36 = v10 - v5;
    int64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v5) >> 3);
    uint64_t v38 = v11 - v10;
    int64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v10) >> 3);
    if (v37 <= v39)
    {
      uint64_t v40 = v4 - v11;
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)) <= v39)
      {
        if (v36 == 24)
        {
          uint64_t v41 = v44 + 1;
        }
        else
        {
          if (v36 < 25) {
            goto LABEL_53;
          }
          uint64_t v41 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v5, v10, a3) + v44;
        }
        uint64_t v44 = v41;
LABEL_53:
        if (v40 == 24)
        {
          uint64_t v7 = v44 + 1;
        }
        else if (v40 < 25)
        {
          uint64_t v7 = v44;
        }
        else
        {
          uint64_t v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v11, v4, a3) + v44;
        }
        if (v38 == 24)
        {
          ++v7;
        }
        else if (v38 >= 25)
        {
          if (v9 == -1)
          {
            ++v7;
            unint64_t v5 = v11;
            goto LABEL_64;
          }
          ++a3;
        }
        unint64_t v5 = v10;
LABEL_64:
        unint64_t v4 = v11;
        goto LABEL_65;
      }
    }
    if (v38 == 24) {
      goto LABEL_32;
    }
    if (v38 < 25)
    {
      uint64_t v7 = v44;
    }
    else if (v8 == -1)
    {
LABEL_32:
      uint64_t v7 = v44 + 1;
    }
    else
    {
      uint64_t v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v10, v11, a3 + 1) + v44;
    }
    uint64_t v42 = v4 - v11;
    if (v37 >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)))
    {
      if (v42 == 24)
      {
        ++v7;
      }
      else if (v42 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v11, v4, a3);
      }
      unint64_t v4 = v10;
    }
    else
    {
      if (v36 == 24)
      {
        ++v7;
      }
      else if (v36 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Key *>(v5, v10, a3);
      }
      unint64_t v5 = v11;
    }
LABEL_65:
    uint64_t v6 = v4 - v5;
  }
  while ((uint64_t)(v4 - v5) > 240);
LABEL_69:
  if (v6 >= 25) {
    v7 += marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Key *>(v5, v4, a3);
  }
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(unsigned int *)(a1 + 8) <= a4) {
    int v4 = -1;
  }
  else {
    int v4 = *(unsigned __int8 *)(*(void *)a1 + a4);
  }
  if (*(unsigned int *)(a2 + 8) <= a4) {
    int v5 = -1;
  }
  else {
    int v5 = *(unsigned __int8 *)(*(void *)a2 + a4);
  }
  if (*(unsigned int *)(a3 + 8) <= a4) {
    int v6 = -1;
  }
  else {
    int v6 = *(unsigned __int8 *)(*(void *)a3 + a4);
  }
  if (v4 <= v5) {
    int v7 = v5;
  }
  else {
    int v7 = v4;
  }
  if (v4 >= v5) {
    int v4 = v5;
  }
  if (v4 <= v6) {
    int v4 = v6;
  }
  if (v7 >= v6) {
    return v4;
  }
  else {
    return v7;
  }
}

uint64_t marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Key *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a1 + 24;
  if (a1 + 24 >= a2) {
    return 1;
  }
  uint64_t v7 = 1;
  do
  {
    uint64_t v8 = v3;
    if (v3 <= a1)
    {
      int v10 = 0;
    }
    else
    {
      while (1)
      {
        unint64_t v9 = v8 - 24;
        int v10 = marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Key>(v8 - 24, v8, a3);
        if (v10 < 1) {
          break;
        }
        uint64_t v11 = *(void *)(v8 - 24);
        int v12 = *(_DWORD *)(v8 - 8);
        *(void *)(v8 - 24) = *(void *)v8;
        uint64_t v13 = *(void *)(v8 + 8);
        *(_DWORD *)(v8 - 8) = *(_DWORD *)(v8 + 16);
        *(void *)uint64_t v8 = v11;
        uint64_t v14 = *(void *)(v8 - 16);
        *(void *)(v8 - 16) = v13;
        *(void *)(v8 + 8) = v14;
        *(_DWORD *)(v8 + 16) = v12;
        v8 -= 24;
        if (v9 <= a1)
        {
          int v10 = 1;
          break;
        }
      }
    }
    if (v10) {
      ++v7;
    }
    v3 += 24;
  }
  while (v3 < a2);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Key>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  unint64_t v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v3 == v4) {
      return 0;
    }
    else {
      return v12;
    }
  }
  else
  {
    uint64_t v6 = v4 - a3;
    uint64_t v7 = (unsigned __int8 *)(*(void *)a1 + a3);
    uint64_t v8 = (unsigned __int8 *)(*(void *)a2 + a3);
    while (v6)
    {
      int v9 = *v7;
      int v10 = *v8;
      uint64_t result = (v9 - v10);
      if (v9 != v10) {
        return result;
      }
      --v6;
      ++v7;
      ++v8;
      if (!--v5) {
        goto LABEL_6;
      }
    }
    return 1;
  }
}

void std::deque<marisa::grimoire::trie::Range>::push_back(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 341 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<marisa::grimoire::trie::Range>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x155)) + 12 * (v7 % 0x155);
  uint64_t v9 = *a2;
  *(_DWORD *)(v8 + 8) = *((_DWORD *)a2 + 2);
  *(void *)unint64_t v8 = v9;
  ++a1[5];
}

void std::deque<marisa::grimoire::trie::Range>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x155;
  unint64_t v4 = v2 - 341;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      int v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      int64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    unint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFFCuLL);
      std::__split_buffer<marisa::grimoire::trie::Range *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFFCuLL);
    std::__split_buffer<marisa::grimoire::trie::Range *>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      int v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      int64_t v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      unsigned int v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0xFFCuLL);
  std::__split_buffer<marisa::grimoire::trie::Range *>::push_back(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<marisa::grimoire::trie::Range *>::push_front((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1D59349C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::__split_buffer<marisa::grimoire::trie::Range *>::push_back(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    unint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v18 = 1;
      }
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      unint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      uint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        uint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      uint64_t v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        uint64_t v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        uint64_t v6 = (char *)a1[1];
      }
      uint64_t v17 = &v6[8 * v13];
      uint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)uint64_t v6 = *a2;
  a1[2] += 8;
}

{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        int64_t v16 = 1;
      }
      else {
        int64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(a1[4], v16);
      unint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      unint64_t v7 = v6 >> 3;
      uint64_t v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        BOOL v10 = v9;
      }
      else {
        BOOL v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      uint64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }
      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<marisa::grimoire::trie::Range *>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    unint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

{
  char *v4;
  char *v5;
  unsigned char *v6;
  unsigned char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    unint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = (v7 - v4) >> 2;
      }
      unint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      int64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        int64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  size_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<marisa::grimoire::trie::Range *>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

_OWORD *marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::realloc(uint64_t *a1, uint64_t a2)
{
  uint64_t result = operator new[](16 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = (long long *)a1[1];
    unint64_t v7 = result;
    do
    {
      long long v8 = *v6++;
      *v7++ = v8;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x1D9455390);
  }
  return result;
}

void *std::get_temporary_buffer[abi:ne180100]<marisa::grimoire::trie::WeightedRange>(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  if (a1 >= 0x7FFFFFFFFFFFFFFLL) {
    unint64_t v1 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v1 = a1;
  }
  unint64_t v2 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
  while (1)
  {
    uint64_t result = operator new(16 * v1, v2);
    if (result) {
      break;
    }
    BOOL v4 = v1 > 1;
    v1 >>= 1;
    if (!v4) {
      return 0;
    }
  }
  return result;
}

double std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5, uint64_t a6, __n128 a7)
{
  if (a4 >= 2)
  {
    if (a4 == 2)
    {
      a7.n128_u32[0] = a2[-1].n128_u32[3];
      if (a7.n128_f32[0] > a1->n128_f32[3])
      {
        a7 = *a1;
        *a1 = a2[-1];
        a2[-1] = a7;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      unint64_t v13 = a4 >> 1;
      uint64_t v14 = &a1[a4 >> 1];
      unint64_t v15 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        v17.n128_f64[0] = std::__stable_sort_move<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, v14, a3, v15, a5, a7);
        v18.n128_f64[0] = std::__stable_sort_move<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), &a5[v13], v17);
        a7.n128_u64[0] = std::__merge_move_assign[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*>(a5, &a5[v13], &a5[v13], &a5[a4], a1, v18).n128_u64[0];
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, v14, a3, v15, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), a5, a6);
        a7.n128_u64[0] = std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>((long long *)a1, (long long *)&a1[a4 >> 1], (long long *)a2, a3, a4 >> 1, a4 - (a4 >> 1), (char *)a5, a6, v16).n128_u64[0];
      }
    }
    else
    {
      std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>((uint64_t)a1, (uint64_t)a2);
    }
  }
  return a7.n128_f64[0];
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 16;
    if (result + 16 != a2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = result;
      do
      {
        float v5 = *(float *)(v4 + 28);
        float v6 = *(float *)(v4 + 12);
        uint64_t v4 = v2;
        if (v5 > v6)
        {
          uint64_t v10 = *(void *)v2;
          int v11 = *(_DWORD *)(v2 + 8);
          uint64_t v7 = v3;
          while (1)
          {
            *(_OWORD *)(result + v7 + 16) = *(_OWORD *)(result + v7);
            if (!v7) {
              break;
            }
            float v8 = *(float *)(result + v7 - 4);
            v7 -= 16;
            if (v5 <= v8)
            {
              uint64_t v9 = result + v7 + 16;
              goto LABEL_10;
            }
          }
          uint64_t v9 = result;
LABEL_10:
          *(void *)uint64_t v9 = v10;
          *(_DWORD *)(v9 + 8) = v11;
          *(float *)(v9 + 12) = v5;
        }
        uint64_t v2 = v4 + 16;
        v3 += 16;
      }
      while (v4 + 16 != a2);
    }
  }
  return result;
}

double std::__stable_sort_move<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5, __n128 a6)
{
  if (a4)
  {
    if (a4 == 2)
    {
      uint64_t v10 = a2 - 1;
      if (a2[-1].n128_f32[3] <= a1->n128_f32[3])
      {
        *a5 = *a1;
        a6 = *v10;
      }
      else
      {
        *a5 = *v10;
        a6 = *a1;
      }
      a5[1] = a6;
    }
    else if (a4 == 1)
    {
      a6 = *a1;
      *a5 = *a1;
    }
    else if ((uint64_t)a4 > 8)
    {
      std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, &a1[a4 >> 1], a3, a4 >> 1, a5, a4 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(&a1[a4 >> 1], a2, a3, a4 - (a4 >> 1), &a5[a4 >> 1], a4 - (a4 >> 1));
      a6.n128_u64[0] = std::__merge_move_assign[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*>(a1, &a1[a4 >> 1], &a1[a4 >> 1], a2, a5, v12).n128_u64[0];
    }
    else
    {
      a6.n128_u64[0] = std::__insertion_sort_move[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, a2, a5).n128_u64[0];
    }
  }
  return a6.n128_f64[0];
}

__n128 std::__merge_move_assign[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, __n128 result)
{
  while (1)
  {
    if (a1 == a2)
    {
      while (a3 != a4)
      {
        __n128 v8 = *a3++;
        result.n128_u64[0] = v8.n128_u64[0];
        *a5++ = v8;
      }
      return result;
    }
    if (a3 == a4) {
      break;
    }
    if (a3->n128_f32[3] <= a1->n128_f32[3])
    {
      __n128 v7 = *a1++;
      uint64_t result = v7;
    }
    else
    {
      __n128 v6 = *a3++;
      uint64_t result = v6;
    }
    *a5++ = result;
  }
  if (a1 != a2)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t result = a1[v9];
      a5[v9++] = result;
    }
    while (&a1[v9] != a2);
  }
  return result;
}

__n128 std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(long long *a1, long long *a2, long long *a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8, __n128 result)
{
  if (a6)
  {
    uint64_t v10 = a6;
    while (v10 > a8 && a5 > a8)
    {
      if (!a5) {
        return result;
      }
      uint64_t v12 = 0;
      result.n128_u32[0] = *((_DWORD *)a2 + 3);
      uint64_t v13 = -a5;
      while (1)
      {
        uint64_t v14 = &a1[v12];
        if (result.n128_f32[0] > *((float *)&a1[v12] + 3)) {
          break;
        }
        ++v12;
        if (__CFADD__(v13++, 1)) {
          return result;
        }
      }
      uint64_t v16 = -v13;
      uint64_t v39 = a3;
      uint64_t v40 = a8;
      if (-v13 >= v10)
      {
        if (v13 == -1)
        {
          __n128 v43 = (__n128)a1[v12];
          a1[v12] = *a2;
          uint64_t result = v43;
          *a2 = (__int128)v43;
          return result;
        }
        if (v13 > 0) {
          uint64_t v16 = 1 - v13;
        }
        uint64_t v26 = v16 >> 1;
        uint64_t v20 = &a1[(v16 >> 1) + v12];
        uint64_t v19 = a3;
        if (a3 != a2)
        {
          unint64_t v27 = a3 - a2;
          uint64_t v19 = a2;
          do
          {
            unint64_t v28 = v27 >> 1;
            uint64_t v29 = &v19[v27 >> 1];
            float v30 = *((float *)v29 + 3);
            long long v31 = v29 + 1;
            v27 += ~(v27 >> 1);
            if (v30 > *((float *)v20 + 3)) {
              uint64_t v19 = v31;
            }
            else {
              unint64_t v27 = v28;
            }
          }
          while (v27);
        }
        uint64_t v18 = v19 - a2;
      }
      else
      {
        if (v10 >= 0) {
          uint64_t v17 = v10;
        }
        else {
          uint64_t v17 = v10 + 1;
        }
        uint64_t v18 = v17 >> 1;
        uint64_t v19 = &a2[v17 >> 1];
        uint64_t v20 = a2;
        if (v14 != a2)
        {
          unint64_t v21 = ((char *)a2 - (char *)a1 - v12 * 16) >> 4;
          uint64_t v20 = &a1[v12];
          do
          {
            unint64_t v22 = v21 >> 1;
            uint64_t v23 = &v20[v21 >> 1];
            float v24 = *((float *)v23 + 3);
            unint64_t v25 = v23 + 1;
            v21 += ~(v21 >> 1);
            if (*((float *)v19 + 3) > v24) {
              unint64_t v21 = v22;
            }
            else {
              uint64_t v20 = v25;
            }
          }
          while (v21);
        }
        uint64_t v26 = ((char *)v20 - (char *)a1 - v12 * 16) >> 4;
      }
      a5 = -(v26 + v13);
      uint64_t v32 = v10 - v18;
      uint64_t v33 = v18;
      int v34 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *,marisa::grimoire::trie::WeightedRange *>((char *)v20, (char *)a2, (char *)v19);
      uint64_t v35 = v33;
      uint64_t v36 = (long long *)v34;
      if (v26 + v35 >= v10 - (v26 + v35) - v13)
      {
        uint64_t v38 = v35;
        std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v34, v19, v39, a4, a5, v32, a7, v40);
        uint64_t v19 = v20;
        uint64_t v32 = v38;
        a5 = v26;
        a8 = v40;
        a3 = v36;
      }
      else
      {
        uint64_t v37 = v26;
        a8 = v40;
        std::__inplace_merge<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v14, v20, v34, a4, v37, v35, a7, v40);
        uint64_t v14 = v36;
        a3 = v39;
      }
      uint64_t v10 = v32;
      a1 = v14;
      a2 = v19;
      if (!v32) {
        return result;
      }
    }
    std::__buffered_inplace_merge[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(a1, a2, a3, a4, a5, v10, a7);
  }
  return result;
}

__n128 std::__insertion_sort_move[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(__n128 *a1, __n128 *a2, __n128 *a3)
{
  if (a1 != a2)
  {
    __n128 result = *a1;
    *a3 = *a1;
    uint64_t v4 = a1 + 1;
    if (&a1[1] != a2)
    {
      uint64_t v5 = 0;
      __n128 v6 = a3;
      do
      {
        __n128 v7 = a1;
        __n128 v8 = v6;
        a1 = v4;
        uint64_t v9 = ++v6;
        if (v7[1].n128_f32[3] > v8->n128_f32[3])
        {
          *__n128 v6 = *v8;
          uint64_t v9 = a3;
          if (v8 != a3)
          {
            uint64_t v10 = v5;
            while (1)
            {
              uint64_t v9 = (__n128 *)((char *)a3 + v10);
              if (v7[1].n128_f32[3] <= *(float *)((char *)&a3->n128_f32[-1] + v10)) {
                break;
              }
              *uint64_t v9 = v9[-1];
              v10 -= 16;
              if (!v10)
              {
                uint64_t v9 = a3;
                break;
              }
            }
          }
        }
        __n128 result = *a1;
        *uint64_t v9 = *a1;
        uint64_t v4 = a1 + 1;
        v5 += 16;
      }
      while (&a1[1] != a2);
    }
  }
  return result;
}

long long *std::__buffered_inplace_merge[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(long long *result, long long *a2, long long *a3, int a4, uint64_t a5, uint64_t a6, char *__src)
{
  if (a5 <= a6)
  {
    if (result != a2)
    {
      unint64_t v13 = 0;
      do
      {
        *(_OWORD *)&__src[v13] = result[v13 / 0x10];
        v13 += 16;
      }
      while (&result[v13 / 0x10] != a2);
      if (v13)
      {
        uint64_t v14 = (float *)__src;
        while (a2 != a3)
        {
          if (*((float *)a2 + 3) <= v14[3])
          {
            long long v17 = *(_OWORD *)v14;
            v14 += 4;
            long long v16 = v17;
          }
          else
          {
            long long v15 = *a2++;
            long long v16 = v15;
          }
          *result++ = v16;
          if (&__src[v13] == (char *)v14) {
            return result;
          }
        }
        return (long long *)memmove(result, v14, __src - (char *)v14 + v13);
      }
    }
  }
  else if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      *(_OWORD *)&__src[v7 * 16] = a2[v7];
      ++v7;
    }
    while (&a2[v7] != a3);
    if (v7 * 16)
    {
      __n128 v8 = (float *)&__src[v7 * 16];
      uint64_t v9 = a3 - 1;
      while (a2 != result)
      {
        float v10 = *(v8 - 1);
        float v11 = *((float *)a2 - 1);
        if (v10 <= v11) {
          uint64_t v12 = (char *)(v8 - 4);
        }
        else {
          uint64_t v12 = (char *)(a2 - 1);
        }
        if (v10 <= v11) {
          v8 -= 4;
        }
        else {
          --a2;
        }
        *v9-- = *(_OWORD *)v12;
        if (v8 == (float *)__src) {
          return result;
        }
      }
      unint64_t v18 = 0;
      do
      {
        v9[v18 / 4] = *(_OWORD *)&v8[v18 - 4];
        v18 -= 4;
      }
      while (&v8[v18] != (float *)__src);
    }
  }
  return result;
}

char *std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *,marisa::grimoire::trie::WeightedRange *>(char *__src, char *a2, char *a3)
{
  uint64_t v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 16 == a2)
    {
      long long v9 = *(_OWORD *)__src;
      int64_t v6 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      uint64_t v4 = &__src[v6];
      *(_OWORD *)uint64_t v4 = v9;
    }
    else if (a2 + 16 == a3)
    {
      uint64_t v4 = __src + 16;
      long long v10 = *((_OWORD *)a3 - 1);
      size_t v7 = a3 - 16 - __src;
      if (a3 - 16 != __src) {
        memmove(__src + 16, __src, v7);
      }
      *(_OWORD *)__src = v10;
    }
    else
    {
      return (char *)std::__rotate_gcd[abi:ne180100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *>(__src, a2, a3);
    }
  }
  return v4;
}

_OWORD *std::__rotate_gcd[abi:ne180100]<std::_ClassicAlgPolicy,marisa::grimoire::trie::WeightedRange *>(_OWORD *a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t v3 = a2 - a1;
  if (v3 == a3 - a2)
  {
    if (a1 != a2 && a2 != a3)
    {
      uint64_t v4 = 0;
      do
      {
        long long v5 = a1[v4];
        a1[v4] = a2[v4];
        uint64_t v6 = (uint64_t)&a1[v4 + 1];
        a2[v4] = v5;
        uint64_t v7 = (uint64_t)&a2[++v4];
      }
      while ((_OWORD *)v6 != a2 && v7 != (void)a3);
    }
  }
  else
  {
    uint64_t v9 = a3 - a2;
    uint64_t v10 = a2 - a1;
    do
    {
      uint64_t v11 = v10;
      uint64_t v10 = v9;
      uint64_t v9 = v11 % v9;
    }
    while (v9);
    if (v10)
    {
      uint64_t v12 = &a1[v10];
      do
      {
        long long v13 = *--v12;
        uint64_t v14 = &v12[v3];
        long long v15 = v12;
        do
        {
          long long v16 = v15;
          long long v15 = v14;
          *long long v16 = *v14;
          BOOL v17 = __OFSUB__(v3, a3 - v14);
          uint64_t v19 = v3 - (a3 - v14);
          char v18 = (v19 < 0) ^ v17;
          uint64_t v14 = &a1[v19];
          if (v18) {
            uint64_t v14 = &v15[v3];
          }
        }
        while (v14 != v12);
        *long long v15 = v13;
      }
      while (v12 != a1);
    }
    return &a1[a3 - a2];
  }
  return a2;
}

uint64_t std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 170;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 341;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return std::__split_buffer<marisa::grimoire::trie::Range *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<marisa::grimoire::trie::Range *>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

uint64_t marisa::grimoire::vector::FlatVector::build_(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  if (!v4) {
    goto LABEL_10;
  }
  unsigned int v5 = 0;
  uint64_t v6 = *(unsigned int **)(a2 + 16);
  uint64_t v7 = *(void *)(a2 + 24);
  do
  {
    unsigned int v9 = *v6++;
    unsigned int v8 = v9;
    if (v9 > v5) {
      unsigned int v5 = v8;
    }
    --v7;
  }
  while (v7);
  if (v5)
  {
    uint64_t v10 = 0;
    do
    {
      ++v10;
      BOOL v11 = v5 > 1;
      v5 >>= 1;
    }
    while (v11);
  }
  else
  {
LABEL_10:
    uint64_t v10 = 0;
  }
  BOOL v12 = v4 != 0;
  unint64_t v13 = (unint64_t)(v10 * v4 + 63) >> 6;
  if (v10) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = v12;
  }
  uint64_t result = (uint64_t)marisa::grimoire::vector::Vector<unsigned long long>::resize((uint64_t *)a1, v14);
  if (v14) {
    *(void *)(*(void *)(a1 + 8) + 8 * *(void *)(a1 + 24) - 8) = 0;
  }
  *(void *)(a1 + 48) = v10;
  if (v10) {
    *(_DWORD *)(a1 + 56) = 0xFFFFFFFF >> -(char)v10;
  }
  uint64_t v16 = *(void *)(a2 + 24);
  *(void *)(a1 + 64) = v16;
  if (v16)
  {
    unint64_t v17 = 0;
    do
    {
      uint64_t result = marisa::grimoire::vector::FlatVector::set(a1, v17, *(_DWORD *)(*(void *)(a2 + 16) + 4 * v17));
      ++v17;
    }
    while (v17 < *(void *)(a2 + 24));
  }
  return result;
}

uint64_t marisa::grimoire::vector::FlatVector::set(uint64_t this, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(this + 48);
  unint64_t v4 = (unint64_t)(v3 * a2) >> 6;
  uint64_t v5 = (v3 * a2) & 0x3F;
  unint64_t v6 = *(unsigned int *)(this + 56);
  uint64_t v7 = *(void *)(this + 8);
  unint64_t v8 = v6 & a3;
  *(void *)(v7 + 8 * v4) = *(void *)(v7 + 8 * v4) & ~(v6 << (v3 * a2)) | (v8 << (v3 * a2));
  if ((unint64_t)(v5 + v3) >= 0x41) {
    *(void *)(v7 + 8 * v4 + 8) = *(void *)(v7 + 8 * v4 + 8) & ~(v6 >> -(char)v5) | (v8 >> -(char)v5);
  }
  return this;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v10 = (unsigned int *)result;
LABEL_2:
  BOOL v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = ((char *)a2 - (char *)v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unsigned int v23 = *(a2 - 2);
          unsigned int v24 = *v11;
          if (v23 < *v11 || v24 >= v23 && *(a2 - 1) < v11[1])
          {
            unsigned int *v11 = v23;
            *(a2 - 2) = v24;
            unsigned int v25 = v11[1];
            v11[1] = *(a2 - 1);
            *(a2 - 1) = v25;
          }
          break;
        case 3uLL:
          uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v11, v11 + 2, v11 + 4, a2 - 2);
          break;
        case 5uLL:
          uint64_t result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v11, v11 + 2, v11 + 4, v11 + 6, a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,std::pair<unsigned int,unsigned int> *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v11, &v11[2 * (v15 >> 1)], a2 - 2);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v11 + 2, v17 - 2, a2 - 4);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v11 + 4, &v11[2 * v16 + 2], a2 - 6);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v17 - 2, v17, &v11[2 * v16 + 2]);
      uint64_t v18 = *(void *)v11;
      *(void *)BOOL v11 = *(void *)v17;
      *(void *)unint64_t v17 = v18;
      if (a5) {
        goto LABEL_16;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_16;
      }
    }
    unsigned int v19 = *(v11 - 2);
    if (v19 >= *v11 && (*v11 < v19 || *(v11 - 1) >= v11[1]))
    {
      uint64_t result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(v11, a2);
      BOOL v11 = (unsigned int *)result;
      goto LABEL_21;
    }
LABEL_16:
    uint64_t v20 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(v11, a2);
    if ((v21 & 1) == 0) {
      goto LABEL_19;
    }
    BOOL v22 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v11, v20);
    BOOL v11 = v20 + 2;
    uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v20 + 2, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v20;
      if (v22) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v22)
    {
LABEL_19:
      uint64_t result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>(v10, v20, a3, -v13, a5 & 1);
      BOOL v11 = v20 + 2;
LABEL_21:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v11, a2);
  }
  else
  {
    return (uint64_t)std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(v11, a2);
  }
}

unsigned int *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *result, unsigned int *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = 0;
      unint64_t v4 = result;
      do
      {
        char v5 = v4;
        unint64_t v4 = v2;
        unsigned int v6 = v5[2];
        unsigned int v7 = *v5;
        if (v6 < *v5 || v7 >= v6 && v5[3] < v5[1])
        {
          unsigned int v9 = v5[2];
          unsigned int v8 = v5[3];
          unsigned int v10 = v5[1];
          v5[2] = v7;
          v4[1] = v10;
          BOOL v11 = result;
          if (v5 != result)
          {
            uint64_t v12 = v3;
            do
            {
              unsigned int v13 = *(unsigned int *)((char *)result + v12 - 8);
              if (v13 <= v9)
              {
                if (v13 < v9)
                {
                  BOOL v11 = v5;
                  goto LABEL_17;
                }
                BOOL v11 = (unsigned int *)((char *)result + v12);
                unsigned int v14 = *(unsigned int *)((char *)result + v12 - 4);
                if (v14 <= v8) {
                  goto LABEL_17;
                }
              }
              else
              {
                unsigned int v14 = *(unsigned int *)((char *)result + v12 - 4);
              }
              v5 -= 2;
              unint64_t v15 = (unsigned int *)((char *)result + v12);
              *unint64_t v15 = v13;
              v15[1] = v14;
              v12 -= 8;
            }
            while (v12);
            BOOL v11 = result;
          }
LABEL_17:
          unsigned int *v11 = v9;
          v11[1] = v8;
        }
        uint64_t v2 = v4 + 2;
        v3 += 8;
      }
      while (v4 + 2 != a2);
    }
  }
  return result;
}

unsigned int *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *result, unsigned int *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = result + 1;
      do
      {
        unint64_t v4 = result;
        uint64_t result = v2;
        unsigned int v5 = v4[2];
        unsigned int v6 = *v4;
        if (v5 < *v4 || v6 >= v5 && v4[3] < v4[1])
        {
          unsigned int v7 = *result;
          unsigned int v8 = result[1];
          for (uint64_t i = v3; ; i -= 2)
          {
            unsigned int v10 = *i;
            i[1] = v6;
            i[2] = v10;
            unsigned int v6 = *(i - 3);
            if (v6 <= v7 && (v6 < v7 || *(i - 2) <= v8)) {
              break;
            }
          }
          *(i - 1) = v7;
          *uint64_t i = v8;
        }
        uint64_t v2 = result + 2;
        v3 += 2;
      }
      while (result + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a1;
  if (*a2 >= *a1 && (v4 < v3 || a2[1] >= a1[1]))
  {
    unsigned int v9 = *a3;
    if (*a3 >= v3 && (v3 < v9 || a3[1] >= a2[1])) {
      return 0;
    }
    *a2 = v9;
    *a3 = v3;
    BOOL v11 = (int *)(a2 + 1);
    unsigned int v10 = a2[1];
    a2[1] = a3[1];
    a3[1] = v10;
    unsigned int v12 = *a2;
    unsigned int v13 = *a1;
    if (*a2 >= *a1 && (v13 < v12 || *v11 >= a1[1])) {
      return 1;
    }
    *a1 = v12;
    unsigned int v6 = (int *)(a1 + 1);
    *a2 = v13;
    uint64_t v8 = 2;
  }
  else
  {
    unsigned int v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *a1 = v5;
      unsigned int v6 = (int *)(a1 + 1);
      *a3 = v4;
      unsigned int v7 = (int *)(a3 + 1);
      uint64_t v8 = 1;
    }
    else
    {
      *a1 = v3;
      *a2 = v4;
      unsigned int v14 = a1[1];
      a1[1] = a2[1];
      a2[1] = v14;
      unsigned int v15 = *a3;
      unsigned int v16 = *a2;
      if (*a3 >= *a2 && (v16 < v15 || a3[1] >= v14)) {
        return 1;
      }
      *a2 = v15;
      *a3 = v16;
      unsigned int v7 = (int *)(a3 + 1);
      uint64_t v8 = 2;
      unsigned int v6 = (int *)(a2 + 1);
    }
    BOOL v11 = v7;
  }
  int v17 = *v6;
  *unsigned int v6 = *v11;
  int *v11 = v17;
  return v8;
}

unsigned int *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  unsigned int v3 = *a1;
  unsigned int v2 = a1[1];
  unsigned int v4 = *(a2 - 2);
  if (v4 <= *a1 && (v4 < v3 || *(a2 - 1) <= v2))
  {
    for (uint64_t i = a1 + 2; i < a2 && *i <= v3 && (*i < v3 || i[1] <= v2); i += 2)
      ;
  }
  else
  {
    uint64_t i = a1;
    do
    {
      unsigned int v7 = i[2];
      i += 2;
      unsigned int v6 = v7;
    }
    while (v7 <= v3 && (v6 < v3 || i[1] <= v2));
  }
  if (i < a2)
  {
    for (a2 -= 2; v4 > v3 || v4 >= v3 && a2[1] > v2; a2 -= 2)
    {
      unsigned int v8 = *(a2 - 2);
      unsigned int v4 = v8;
    }
  }
  if (i < a2)
  {
    unsigned int v9 = *i;
    unsigned int v10 = *a2;
    do
    {
      *uint64_t i = v10;
      *a2 = v9;
      unsigned int v11 = i[1];
      i[1] = a2[1];
      a2[1] = v11;
      do
      {
        unsigned int v12 = i[2];
        i += 2;
        unsigned int v9 = v12;
      }
      while (v12 <= v3 && (v9 < v3 || i[1] <= v2));
      do
      {
        do
        {
          unsigned int v13 = *(a2 - 2);
          a2 -= 2;
          unsigned int v10 = v13;
          BOOL v14 = v13 >= v3;
        }
        while (v13 > v3);
      }
      while (v14 && a2[1] > v2);
    }
    while (i < a2);
  }
  if (i - 2 != a1)
  {
    *a1 = *(i - 2);
    a1[1] = *(i - 1);
  }
  *(i - 2) = v3;
  *(i - 1) = v2;
  return i;
}

unsigned int *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,unsigned int> *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v2 = 0;
  unsigned int v3 = *a1;
  unsigned int v4 = a1[1];
  while (1)
  {
    unsigned int v5 = a1[v2 + 2];
    if (v5 >= v3 && (v5 > v3 || a1[v2 + 3] >= v4)) {
      break;
    }
    v2 += 2;
  }
  unint64_t v6 = (unint64_t)&a1[v2 + 2];
  if (v2 * 4)
  {
    do
    {
      unsigned int v8 = *(a2 - 2);
      a2 -= 2;
      unsigned int v7 = v8;
    }
    while (v8 >= v3 && (v7 > v3 || a2[1] >= v4));
  }
  else
  {
LABEL_19:
    if (v6 < (unint64_t)a2)
    {
      do
      {
        unsigned int v10 = *(a2 - 2);
        a2 -= 2;
        unsigned int v9 = v10;
        if (v10 < v3) {
          break;
        }
        if (v9 > v3) {
          goto LABEL_19;
        }
      }
      while (a2[1] >= v4 && v6 < (unint64_t)a2);
    }
  }
  if (v6 >= (unint64_t)a2)
  {
    unsigned int v13 = (unsigned int *)v6;
  }
  else
  {
    unsigned int v12 = *a2;
    unsigned int v13 = (unsigned int *)v6;
    BOOL v14 = a2;
    do
    {
      *unsigned int v13 = v12;
      *BOOL v14 = v5;
      unsigned int v15 = v13[1];
      v13[1] = v14[1];
      v14[1] = v15;
      do
      {
        do
        {
          unsigned int v16 = v13[2];
          v13 += 2;
          unsigned int v5 = v16;
          BOOL v17 = v16 > v3;
        }
        while (v16 < v3);
      }
      while (!v17 && v13[1] < v4);
      do
      {
        unsigned int v18 = *(v14 - 2);
        v14 -= 2;
        unsigned int v12 = v18;
      }
      while (v18 >= v3 && (v12 > v3 || v14[1] >= v4));
    }
    while (v13 < v14);
  }
  if (v13 - 2 != a1)
  {
    *a1 = *(v13 - 2);
    a1[1] = *(v13 - 1);
  }
  *(v13 - 2) = v3;
  *(v13 - 1) = v4;
  return v13 - 2;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 2);
      unsigned int v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        unsigned int v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      unsigned int v9 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a1 + 2, a1 + 4);
      unsigned int v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  do
  {
    unsigned int v13 = *v9;
    if (*v10 >= *v9 && (v13 < *v10 || v10[1] >= v9[1])) {
      goto LABEL_22;
    }
    unsigned int v14 = *v10;
    unsigned int v15 = v10[1];
    *unsigned int v10 = v13;
    v10[1] = v9[1];
    unsigned int v16 = a1;
    if (v9 == a1) {
      goto LABEL_21;
    }
    uint64_t v17 = v11;
    while (1)
    {
      unsigned int v18 = (char *)a1 + v17;
      unsigned int v19 = *(unsigned int *)((char *)a1 + v17 + 8);
      if (v19 <= v14) {
        break;
      }
      unsigned int v20 = *((_DWORD *)v18 + 3);
LABEL_18:
      v9 -= 2;
      *((_DWORD *)v18 + 4) = v19;
      *(unsigned int *)((char *)a1 + v17 + 20) = v20;
      v17 -= 8;
      if (v17 == -16)
      {
        unsigned int v16 = a1;
        goto LABEL_21;
      }
    }
    if (v19 < v14)
    {
      unsigned int v16 = v9;
      goto LABEL_21;
    }
    unsigned int v20 = *(unsigned int *)((char *)a1 + v17 + 12);
    if (v20 > v15) {
      goto LABEL_18;
    }
    unsigned int v16 = (unsigned int *)((char *)a1 + v17 + 16);
LABEL_21:
    *unsigned int v16 = v14;
    v16[1] = v15;
    if (++v12 == 8) {
      return v10 + 2 == a2;
    }
LABEL_22:
    unsigned int v9 = v10;
    v11 += 8;
    v10 += 2;
  }
  while (v10 != a2);
  return 1;
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a2, a3);
  unsigned int v9 = *a4;
  unsigned int v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    unsigned int v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    unsigned int v12 = *a3;
    unsigned int v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      unsigned int v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      unsigned int v15 = *a2;
      unsigned int v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        unsigned int v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a2, a3, a4);
  unsigned int v11 = *a5;
  unsigned int v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    unsigned int v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    unsigned int v14 = *a4;
    unsigned int v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      unsigned int v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      unsigned int v17 = *a3;
      unsigned int v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        unsigned int v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        unsigned int v20 = *a2;
        unsigned int v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          unsigned int v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }
  return result;
}

unsigned int *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,std::pair<unsigned int,unsigned int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 3;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      unsigned int v12 = &a1[2 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    unsigned int v13 = a2;
    if (a2 != a3)
    {
      unsigned int v14 = a2;
      do
      {
        unsigned int v15 = *v14;
        unsigned int v16 = *a1;
        if (*v14 < *a1 || v16 >= v15 && v14[1] < a1[1])
        {
          *unsigned int v14 = v16;
          *a1 = v15;
          unsigned int v17 = v14[1];
          v14[1] = a1[1];
          a1[1] = v17;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      unsigned int v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v18 = (unint64_t)v8 >> 3;
      unsigned int v19 = a2 - 2;
      do
      {
        unsigned int v21 = *a1;
        unsigned int v20 = a1[1];
        unsigned int v22 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(a1, a4, v18);
        if (v19 == v22)
        {
          unsigned int *v22 = v21;
          v22[1] = v20;
        }
        else
        {
          unsigned int *v22 = *v19;
          v22[1] = v19[1];
          unsigned int *v19 = v21;
          v19[1] = v20;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>((uint64_t)a1, (uint64_t)(v22 + 2), a4, ((char *)(v22 + 2) - (char *)a1) >> 3);
        }
        v19 -= 2;
      }
      while (v18-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(uint64_t result, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) + 1;
      uint64_t v8 = (unsigned int *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3)
      {
        unsigned int v10 = v8[2];
        if (*v8 < v10 || v10 >= *v8 && *(_DWORD *)(result + 8 * v7 + 4) < v8[3])
        {
          v8 += 2;
          uint64_t v7 = v9;
        }
      }
      unsigned int v11 = *v8;
      if (*v8 >= *a4 && (*a4 < v11 || v8[1] >= a4[1]))
      {
        unsigned int v12 = *a4;
        unsigned int v13 = a4[1];
        *a4 = v11;
        a4[1] = v8[1];
        if (v5 >= v7)
        {
          while (1)
          {
            uint64_t v15 = 2 * v7;
            uint64_t v7 = (2 * v7) | 1;
            unsigned int v14 = (unsigned int *)(result + 8 * v7);
            uint64_t v16 = v15 + 2;
            if (v16 < a3)
            {
              unsigned int v17 = v14[2];
              if (*v14 < v17 || v17 >= *v14 && *(_DWORD *)(result + 8 * v7 + 4) < v14[3])
              {
                v14 += 2;
                uint64_t v7 = v16;
              }
            }
            unsigned int v18 = *v14;
            if (*v14 < v12 || v18 <= v12 && v14[1] < v13) {
              break;
            }
            *uint64_t v8 = v18;
            v8[1] = v14[1];
            uint64_t v8 = v14;
            if (v5 < v7) {
              goto LABEL_22;
            }
          }
        }
        unsigned int v14 = v8;
LABEL_22:
        *unsigned int v14 = v12;
        v14[1] = v13;
      }
    }
  }
  return result;
}

unsigned int *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(unsigned int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = result;
    uint64_t v7 = v3 + 1;
    result += 2 * v3 + 2;
    uint64_t v8 = 2 * v3;
    uint64_t v3 = (2 * v3) | 1;
    uint64_t v9 = v8 + 2;
    if (v9 < a3)
    {
      unsigned int v10 = result[2];
      if (*result < v10 || v10 >= *result && v6[2 * v7 + 1] < result[3])
      {
        result += 2;
        uint64_t v3 = v9;
      }
    }
    *uint64_t v6 = *result;
    v6[1] = result[1];
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    uint64_t v6 = (unsigned int *)(result + 8 * (v4 >> 1));
    unsigned int v7 = *v6;
    unsigned int v8 = *(_DWORD *)(a2 - 8);
    if (*v6 < v8 || v8 >= v7 && *(_DWORD *)(result + 8 * v5 + 4) < *(_DWORD *)(a2 - 4))
    {
      unsigned int v9 = *(_DWORD *)(a2 - 8);
      unsigned int v10 = *(_DWORD *)(a2 - 4);
      *(_DWORD *)(a2 - 8) = v7;
      *(_DWORD *)(a2 - 4) = v6[1];
      if (v4 >= 2)
      {
        while (1)
        {
          unint64_t v12 = v5 - 1;
          unint64_t v5 = (v5 - 1) >> 1;
          unsigned int v11 = (unsigned int *)(result + 8 * v5);
          unsigned int v13 = *v11;
          if (*v11 >= v9)
          {
            if (v13 > v9) {
              break;
            }
            unsigned int v14 = *(_DWORD *)(result + 8 * v5 + 4);
            if (v14 >= v10) {
              break;
            }
          }
          else
          {
            unsigned int v14 = v11[1];
          }
          *uint64_t v6 = v13;
          v6[1] = v14;
          uint64_t v6 = (unsigned int *)(result + 8 * v5);
          if (v12 <= 1) {
            goto LABEL_12;
          }
        }
      }
      unsigned int v11 = v6;
LABEL_12:
      unsigned int *v11 = v9;
      v11[1] = v10;
    }
  }
  return result;
}

char *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Entry>::realloc(uint64_t *a1, uint64_t a2)
{
  uint64_t result = (char *)operator new[](16 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(a1[1] + 8);
    unsigned int v7 = result + 8;
    do
    {
      *(v7 - 1) = *(v6 - 1);
      uint64_t v8 = *v6;
      v6 += 2;
      *unsigned int v7 = v8;
      v7 += 2;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x1D9455390);
  }
  return result;
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_current_trie<marisa::grimoire::trie::ReverseKey>(uint64_t *a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a2 + 24);
  unint64_t v9 = *(void *)(a2 + 8);
  if (v8)
  {
    uint64_t v10 = 0;
    unsigned int v11 = (_DWORD *)(v9 + 16);
    do
    {
      _DWORD *v11 = v10;
      v11 += 6;
      ++v10;
    }
    while (v8 != v10);
  }
  unint64_t v12 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v9, v9 + 24 * v8, 0);
  uint64_t v13 = 256;
  if (a5 != 1) {
    uint64_t v13 = 1;
  }
  do
  {
    unint64_t v14 = v13;
    v13 *= 2;
  }
  while (v14 < v12 / *(unsigned int *)(a4 + 8));
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize(a1 + 126, v14);
  a1[132] = v14 - 1;
  marisa::grimoire::vector::BitVector::push_back(a1, 1);
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  uint64_t v15 = a1 + 78;
  LOBYTE(v84[0]) = 0;
  marisa::grimoire::vector::Vector<char>::push_back(a1 + 78, v84);
  marisa::grimoire::vector::BitVector::push_back(a1 + 52, 0);
  memset(v84, 0, 41);
  long long v83 = 0u;
  memset(v82, 0, sizeof(v82));
  long long v80 = 0u;
  memset(v81, 0, 25);
  v78.n128_u64[0] = *(void *)(a2 + 24) << 32;
  v78.n128_u32[2] = 0;
  std::deque<marisa::grimoire::trie::Range>::push_back(v82, (uint64_t *)&v78);
  uint64_t v16 = *((void *)&v83 + 1);
  if (*((void *)&v83 + 1))
  {
    uint64_t v72 = a1 + 52;
    unint64_t v73 = a1 + 78;
    do
    {
      uint64_t v17 = a1[58];
      unsigned int v18 = (unsigned int *)(*(void *)(*((void *)&v82[0] + 1) + 8 * ((unint64_t)v83 / 0x155))
                           + 12 * ((unint64_t)v83 % 0x155));
      uint64_t v19 = *v18;
      unint64_t v20 = v18[1];
      uint64_t v21 = v18[2];
      *(void *)&long long v83 = v83 + 1;
      *((void *)&v83 + 1) = v16 - 1;
      if ((unint64_t)v83 >= 0x2AA)
      {
        uint64_t v22 = v17;
        uint64_t v23 = v16;
        operator delete(**((void ***)&v82[0] + 1));
        uint64_t v16 = v23;
        uint64_t v17 = v22;
        *((void *)&v82[0] + 1) += 8;
        *(void *)&long long v83 = v83 - 341;
      }
      if (v19 < v20)
      {
        while (1)
        {
          uint64_t v24 = *(void *)(a2 + 8);
          if (*(_DWORD *)(v24 + 24 * v19 + 8) != v21) {
            break;
          }
          *(_DWORD *)(v24 + 24 * v19 + 12) = v17 - v16;
          uint64_t v19 = (v19 + 1);
          if (v20 == v19) {
            goto LABEL_49;
          }
        }
      }
      if (v19 != v20)
      {
        uint64_t v76 = v16;
        int v77 = v17 - v16;
        uint64_t v25 = v80;
        long long v80 = 0u;
        memset(v81, 0, 25);
        if (v25) {
          MEMORY[0x1D9455390](v25, 0x1000C8077774924);
        }
        uint64_t v75 = v17;
        uint64_t v26 = *(void *)(a2 + 8);
        double v27 = *(float *)(v26 + 24 * v19 + 12);
        uint64_t v28 = v19 + 1;
        if (v19 + 1 < v20)
        {
          uint64_t v29 = 24 * v19;
          uint64_t v30 = (v19 << 32) + 0x100000000;
          do
          {
            if (*(unsigned __int8 *)(*(void *)(v26 + v29) - v21 - 1) != *(unsigned __int8 *)(*(void *)(v26 + v29 + 24)
                                                                                              - v21
                                                                                              - 1))
            {
              *(float *)&unsigned int v31 = v27;
              v78.n128_u64[0] = v30 + v19;
              v78.n128_u64[1] = v21 | ((unint64_t)v31 << 32);
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back((uint64_t *)&v80, &v78);
              uint64_t v26 = *(void *)(a2 + 8);
              double v27 = 0.0;
              LODWORD(v19) = v28;
            }
            double v27 = v27 + *(float *)(v26 + v29 + 36);
            ++v28;
            v29 += 24;
            v30 += 0x100000000;
          }
          while (v20 != v28);
        }
        *(float *)&unsigned int v32 = v27;
        v78.n128_u32[0] = v19;
        v78.n128_u32[1] = v20;
        v78.n128_u64[1] = v21 | ((unint64_t)v32 << 32);
        __n128 v33 = marisa::grimoire::vector::Vector<marisa::grimoire::trie::WeightedRange>::push_back((uint64_t *)&v80, &v78);
        uint64_t v15 = a1 + 78;
        uint64_t v34 = v76;
        if (*(_DWORD *)(a4 + 16) == 0x20000)
        {
          uint64_t v35 = (__n128 *)*((void *)&v80 + 1);
          unint64_t v36 = v81[1];
          if (v81[1] < 129)
          {
            uint64_t v37 = 0;
            uint64_t v39 = 0;
          }
          else
          {
            uint64_t v37 = (__n128 *)std::get_temporary_buffer[abi:ne180100]<marisa::grimoire::trie::WeightedRange>(v81[1]);
            uint64_t v39 = v38;
          }
          std::__stable_sort<std::_ClassicAlgPolicy,std::greater<marisa::grimoire::trie::WeightedRange> &,marisa::grimoire::trie::WeightedRange*>(v35, &v35[v36], (uint64_t)&v78, v36, v37, v39, v33);
          if (v37) {
            operator delete(v37);
          }
          uint64_t v34 = v76;
        }
        uint64_t v40 = v81[1];
        if (v75 == v34) {
          a1[133] = v81[1];
        }
        if (v40)
        {
          unint64_t v41 = 0;
          do
          {
            uint64_t v42 = (unsigned int *)(*((void *)&v80 + 1) + 16 * v41);
            __n128 v43 = (uint64_t *)v42;
            uint64_t v44 = v42[2];
            uint64_t v45 = *(void *)(a2 + 8);
            unint64_t v46 = *(unsigned int *)(v45 + 24 * *v42 + 8);
            unint64_t v47 = v44 + 1;
            if (v44 + 1 >= v46)
            {
              unint64_t v48 = v42[2];
              LODWORD(v46) = v44 + 1;
            }
            else
            {
              unint64_t v48 = v46 - 1;
              uint64_t v49 = (uint64_t *)(v45 + 24 * *v42);
              unint64_t v50 = v42[2];
              do
              {
                unint64_t v51 = v50;
                unint64_t v50 = v47;
                uint64_t v52 = v49;
                uint64_t v53 = *v42;
                while (++v53 < (unint64_t)v42[1])
                {
                  uint64_t v54 = *v52;
                  uint64_t v55 = v52[3];
                  v52 += 3;
                  if (*(unsigned __int8 *)(v54 + ~v51 - 1) != *(unsigned __int8 *)(v55 + ~v51 - 1))
                  {
                    unint64_t v48 = v51;
                    LODWORD(v46) = v47;
                    goto LABEL_43;
                  }
                }
                ++v47;
              }
              while (v50 + 1 != v46);
            }
LABEL_43:
            uint64_t v56 = a1[81];
            float v58 = *((float *)v42 + 3);
            unsigned int v57 = v42 + 3;
            float v59 = v58;
            uint64_t v60 = a1[132] & v56;
            uint64_t v61 = a1[127];
            uint64_t v62 = v61 + 12 * v60;
            float v64 = *(float *)(v62 + 8);
            uint64_t v63 = (float *)(v62 + 8);
            if (v64 < v59)
            {
              uint64_t v65 = (_DWORD *)(v61 + 12 * v60);
              *uint64_t v65 = v77;
              v65[1] = v56;
              *uint64_t v63 = v59;
              uint64_t v44 = *((unsigned int *)v43 + 2);
            }
            if (v48 == v44)
            {
              v78.n128_u8[0] = *(unsigned char *)(~v48 + *(void *)(*(void *)(a2 + 8) + 24 * *(unsigned int *)v43));
              marisa::grimoire::vector::Vector<char>::push_back(v73, &v78);
              marisa::grimoire::vector::BitVector::push_back(v72, 0);
            }
            else
            {
              v78.n128_u8[0] = 0;
              marisa::grimoire::vector::Vector<char>::push_back(v73, &v78);
              marisa::grimoire::vector::BitVector::push_back(v72, 1);
              __n128 v78 = 0uLL;
              int v79 = 0;
              uint64_t v66 = *((unsigned int *)v43 + 2);
              v78.n128_u64[0] = *(void *)(*(void *)(a2 + 8) + 24 * *(unsigned int *)v43) - v66;
              v78.n128_u64[1] = (v46 - v66);
              v78.n128_u32[3] = *v57;
              marisa::grimoire::vector::Vector<marisa::grimoire::trie::Key>::push_back((uint64_t *)v84, (uint64_t)&v78);
            }
            *((_DWORD *)v43 + 2) = v46;
            std::deque<marisa::grimoire::trie::Range>::push_back(v82, v43);
            marisa::grimoire::vector::BitVector::push_back(a1, 1);
            ++v41;
          }
          while (v41 < v81[1]);
        }
      }
LABEL_49:
      marisa::grimoire::vector::BitVector::push_back(a1, 0);
      uint64_t v16 = *((void *)&v83 + 1);
    }
    while (*((void *)&v83 + 1));
  }
  marisa::grimoire::vector::BitVector::push_back(a1, 0);
  marisa::grimoire::vector::BitVector::build((marisa::grimoire::vector::BitVector *)a1, a5 == 1, 1);
  marisa::grimoire::vector::Vector<unsigned char>::shrink(v15);
  marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::ReverseKey>((uint64_t)a1, a2, a3);
  long long v67 = *(_OWORD *)a2;
  *(_OWORD *)a2 = v84[0];
  v84[0] = v67;
  uint64_t v68 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = *(void *)&v84[1];
  *(void *)&v84[1] = v68;
  long long v69 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)&v84[1] + 8);
  *(_OWORD *)((char *)&v84[1] + 8) = v69;
  LOBYTE(v68) = *(unsigned char *)(a2 + 40);
  *(unsigned char *)(a2 + 40) = BYTE8(v84[2]);
  BYTE8(v84[2]) = v68;
  if ((void)v80) {
    MEMORY[0x1D9455390](v80, 0x1000C8077774924);
  }
  std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100](v82);
  uint64_t result = *(void *)&v84[0];
  if (*(void *)&v84[0]) {
    return MEMORY[0x1D9455390](*(void *)&v84[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D5937508(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a21) {
    MEMORY[0x1D9455390](a21, 0x1000C8077774924);
  }
  std::deque<marisa::grimoire::trie::Range>::~deque[abi:ne180100](&a27);
  uint64_t v30 = *(void *)(v27 - 144);
  if (v30) {
    MEMORY[0x1D9455390](v30, 0x1000C8077774924);
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc";
    exception[2] = 0x8000001ACLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/louds-trie.cc:428: MARISA_MEMOR"
                   "Y_ERROR: std::bad_alloc";
  }
  _Unwind_Resume(a1);
}

uint64_t marisa::grimoire::trie::LoudsTrie::build_terminals<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, long long *a3)
{
  memset(v13, 0, 41);
  marisa::grimoire::vector::Vector<unsigned int>::resize((uint64_t *)v13, *(void *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = *((void *)&v13[0] + 1);
    unsigned int v7 = (unsigned int *)(*(void *)(a2 + 16) + 16);
    do
    {
      *(_DWORD *)(v6 + 4 * *v7) = *(v7 - 1);
      v7 += 6;
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v6 = *((void *)&v13[0] + 1);
  }
  long long v8 = *a3;
  uint64_t v9 = *(void *)&v13[1];
  *(void *)a3 = *(void *)&v13[0];
  *((void *)a3 + 1) = v6;
  v13[0] = v8;
  uint64_t v10 = *((void *)a3 + 2);
  *((void *)a3 + 2) = v9;
  *(void *)&v13[1] = v10;
  long long v11 = *(long long *)((char *)a3 + 24);
  *(long long *)((char *)a3 + 24) = *(_OWORD *)((char *)&v13[1] + 8);
  *(_OWORD *)((char *)&v13[1] + 8) = v11;
  LOBYTE(v10) = *((unsigned char *)a3 + 40);
  *((unsigned char *)a3 + 40) = BYTE8(v13[2]);
  uint64_t result = v8;
  BYTE8(v13[2]) = v10;
  if ((void)v8) {
    return MEMORY[0x1D9455390](v8, 0x1000C8077774924);
  }
  return result;
}

void sub_1D59376F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = a2;
  unint64_t v5 = a1;
  uint64_t v6 = a2 - a1;
  if ((uint64_t)(a2 - a1) < 241)
  {
    uint64_t v7 = 0;
    goto LABEL_69;
  }
  uint64_t v7 = 0;
  do
  {
    int v8 = marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::ReverseKey>(v5, v5 + 24 * (v6 / 0x30uLL), v4 - 24, a3);
    int v9 = v8;
    unint64_t v10 = v5;
    unint64_t v11 = v4;
    unint64_t v12 = v5;
    unint64_t v13 = v4;
    while (v10 < v11)
    {
      unint64_t v14 = *(unsigned int *)(v10 + 8);
      int v15 = a3 >= v14 ? -1 : *(unsigned __int8 *)(*(void *)v10 - a3 - 1);
      if (v15 > v8) {
        break;
      }
      if (v15 == v8)
      {
        uint64_t v16 = *(void *)v10;
        *(void *)unint64_t v10 = *(void *)v12;
        *(_DWORD *)(v10 + 8) = *(_DWORD *)(v12 + 8);
        uint64_t v17 = *(void *)(v10 + 12);
        *(_DWORD *)(v10 + 12) = *(_DWORD *)(v12 + 12);
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v12 + 16);
        *(void *)unint64_t v12 = v16;
        *(_DWORD *)(v12 + 8) = v14;
        *(void *)(v12 + 12) = v17;
        v12 += 24;
      }
LABEL_11:
      v10 += 24;
    }
    if (v10 < v11)
    {
      unint64_t v18 = v11 - 24;
      do
      {
        unint64_t v11 = v18;
        unint64_t v19 = *(unsigned int *)(v18 + 8);
        if (a3 >= v19) {
          int v20 = -1;
        }
        else {
          int v20 = *(unsigned __int8 *)(*(void *)v11 - a3 - 1);
        }
        if (v20 < v8) {
          break;
        }
        if (v20 == v8)
        {
          uint64_t v21 = *(void *)(v13 - 24);
          v13 -= 24;
          uint64_t v22 = *(void *)v11;
          *(void *)unint64_t v11 = v21;
          *(_DWORD *)(v11 + 8) = *(_DWORD *)(v13 + 8);
          uint64_t v23 = *(void *)(v11 + 12);
          *(_DWORD *)(v11 + 12) = *(_DWORD *)(v13 + 12);
          *(_DWORD *)(v11 + 16) = *(_DWORD *)(v13 + 16);
          *(void *)unint64_t v13 = v22;
          *(_DWORD *)(v13 + 8) = v19;
          *(void *)(v13 + 12) = v23;
        }
        unint64_t v18 = v11 - 24;
      }
      while (v10 < v11);
    }
    if (v10 < v11)
    {
      uint64_t v24 = *(void *)v10;
      int v25 = *(_DWORD *)(v10 + 16);
      *(void *)unint64_t v10 = *(void *)v11;
      uint64_t v26 = *(void *)(v10 + 8);
      *(_DWORD *)(v10 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v10 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v10 + 16) = *(_DWORD *)(v11 + 16);
      *(void *)unint64_t v11 = v24;
      *(void *)(v11 + 8) = v26;
      *(_DWORD *)(v11 + 16) = v25;
      goto LABEL_11;
    }
    uint64_t v44 = v7;
    if (v12 > v5)
    {
      uint64_t v27 = 0;
      do
      {
        uint64_t v28 = v12 + v27;
        uint64_t v29 = v10 + v27;
        uint64_t v30 = *(void *)(v12 + v27 - 24);
        int v31 = *(_DWORD *)(v12 + v27 - 8);
        *(void *)(v28 - 24) = *(void *)(v10 + v27 - 24);
        uint64_t v32 = *(void *)(v12 + v27 - 16);
        *(_DWORD *)(v28 - 16) = *(_DWORD *)(v10 + v27 - 16);
        *(_DWORD *)(v28 - 12) = *(_DWORD *)(v10 + v27 - 12);
        *(_DWORD *)(v28 - 8) = *(_DWORD *)(v10 + v27 - 8);
        *(void *)(v29 - 24) = v30;
        *(void *)(v29 - 16) = v32;
        *(_DWORD *)(v29 - 8) = v31;
        v27 -= 24;
      }
      while (v12 + v27 > v5);
      v10 += v27;
    }
    while (v13 < v4)
    {
      uint64_t v33 = *(void *)v13;
      int v34 = *(_DWORD *)(v13 + 16);
      *(void *)unint64_t v13 = *(void *)v11;
      uint64_t v35 = *(void *)(v13 + 8);
      *(_DWORD *)(v13 + 8) = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v13 + 12) = *(_DWORD *)(v11 + 12);
      *(_DWORD *)(v13 + 16) = *(_DWORD *)(v11 + 16);
      *(void *)unint64_t v11 = v33;
      *(void *)(v11 + 8) = v35;
      *(_DWORD *)(v11 + 16) = v34;
      v11 += 24;
      v13 += 24;
    }
    uint64_t v36 = v10 - v5;
    int64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v5) >> 3);
    uint64_t v38 = v11 - v10;
    int64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v10) >> 3);
    if (v37 <= v39)
    {
      uint64_t v40 = v4 - v11;
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)) <= v39)
      {
        if (v36 == 24)
        {
          uint64_t v41 = v44 + 1;
        }
        else
        {
          if (v36 < 25) {
            goto LABEL_53;
          }
          uint64_t v41 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v5, v10, a3) + v44;
        }
        uint64_t v44 = v41;
LABEL_53:
        if (v40 == 24)
        {
          uint64_t v7 = v44 + 1;
        }
        else if (v40 < 25)
        {
          uint64_t v7 = v44;
        }
        else
        {
          uint64_t v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v11, v4, a3) + v44;
        }
        if (v38 == 24)
        {
          ++v7;
        }
        else if (v38 >= 25)
        {
          if (v9 == -1)
          {
            ++v7;
            unint64_t v5 = v11;
            goto LABEL_64;
          }
          ++a3;
        }
        unint64_t v5 = v10;
LABEL_64:
        unint64_t v4 = v11;
        goto LABEL_65;
      }
    }
    if (v38 == 24) {
      goto LABEL_32;
    }
    if (v38 < 25)
    {
      uint64_t v7 = v44;
    }
    else if (v8 == -1)
    {
LABEL_32:
      uint64_t v7 = v44 + 1;
    }
    else
    {
      uint64_t v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v10, v11, a3 + 1) + v44;
    }
    uint64_t v42 = v4 - v11;
    if (v37 >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v11) >> 3)))
    {
      if (v42 == 24)
      {
        ++v7;
      }
      else if (v42 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v11, v4, a3);
      }
      unint64_t v4 = v10;
    }
    else
    {
      if (v36 == 24)
      {
        ++v7;
      }
      else if (v36 >= 25)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::ReverseKey *>(v5, v10, a3);
      }
      unint64_t v5 = v11;
    }
LABEL_65:
    uint64_t v6 = v4 - v5;
  }
  while ((uint64_t)(v4 - v5) > 240);
LABEL_69:
  if (v6 >= 25) {
    v7 += marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::ReverseKey *>(v5, v4, a3);
  }
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(unsigned int *)(a1 + 8) <= a4) {
    int v4 = -1;
  }
  else {
    int v4 = *(unsigned __int8 *)(~a4 + *(void *)a1);
  }
  if (*(unsigned int *)(a2 + 8) <= a4) {
    int v5 = -1;
  }
  else {
    int v5 = *(unsigned __int8 *)(~a4 + *(void *)a2);
  }
  if (*(unsigned int *)(a3 + 8) <= a4) {
    int v6 = -1;
  }
  else {
    int v6 = *(unsigned __int8 *)(~a4 + *(void *)a3);
  }
  if (v4 <= v5) {
    int v7 = v5;
  }
  else {
    int v7 = v4;
  }
  if (v4 >= v5) {
    int v4 = v5;
  }
  if (v4 <= v6) {
    int v4 = v6;
  }
  if (v7 >= v6) {
    return v4;
  }
  else {
    return v7;
  }
}

uint64_t marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::ReverseKey *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a1 + 24;
  if (a1 + 24 >= a2) {
    return 1;
  }
  uint64_t v7 = 1;
  do
  {
    uint64_t v8 = v3;
    if (v3 <= a1)
    {
      int v10 = 0;
    }
    else
    {
      while (1)
      {
        unint64_t v9 = v8 - 24;
        int v10 = marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::ReverseKey>(v8 - 24, v8, a3);
        if (v10 < 1) {
          break;
        }
        uint64_t v11 = *(void *)(v8 - 24);
        int v12 = *(_DWORD *)(v8 - 8);
        *(void *)(v8 - 24) = *(void *)v8;
        uint64_t v13 = *(void *)(v8 + 8);
        *(_DWORD *)(v8 - 8) = *(_DWORD *)(v8 + 16);
        *(void *)uint64_t v8 = v11;
        uint64_t v14 = *(void *)(v8 - 16);
        *(void *)(v8 - 16) = v13;
        *(void *)(v8 + 8) = v14;
        *(_DWORD *)(v8 + 16) = v12;
        v8 -= 24;
        if (v9 <= a1)
        {
          int v10 = 1;
          break;
        }
      }
    }
    if (v10) {
      ++v7;
    }
    v3 += 24;
  }
  while (v3 < a2);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::ReverseKey>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  unint64_t v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v3 == v4) {
      return 0;
    }
    else {
      return v12;
    }
  }
  else
  {
    uint64_t v6 = v4 - a3;
    uint64_t v7 = (unsigned __int8 *)(*(void *)a2 + ~a3);
    uint64_t v8 = (unsigned __int8 *)(*(void *)a1 + ~a3);
    while (v6)
    {
      int v9 = *v8;
      int v10 = *v7;
      uint64_t result = (v9 - v10);
      if (v9 != v10) {
        return result;
      }
      --v6;
      --v7;
      --v8;
      if (!--v5) {
        goto LABEL_6;
      }
    }
    return 1;
  }
}

char *marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::realloc(uint64_t *a1, uint64_t a2)
{
  uint64_t result = (char *)operator new[](12 * a2, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = a1[3];
  if (v5)
  {
    uint64_t v6 = (_DWORD *)(a1[1] + 8);
    uint64_t v7 = result + 8;
    do
    {
      *((void *)v7 - 1) = *((void *)v6 - 1);
      int v8 = *v6;
      v6 += 3;
      *uint64_t v7 = v8;
      v7 += 3;
      --v5;
    }
    while (v5);
  }
  uint64_t v9 = *a1;
  *a1 = (uint64_t)result;
  a1[1] = (uint64_t)result;
  a1[2] = (uint64_t)result;
  a1[4] = a2;
  if (v9)
  {
    JUMPOUT(0x1D9455390);
  }
  return result;
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::map_(uint64_t a1, marisa::grimoire::io::Mapper *this)
{
  unint64_t v4 = *(void *)marisa::grimoire::io::Mapper::map_data(this, 8uLL);
  *(void *)(a1 + 16) = marisa::grimoire::io::Mapper::map_data(this, v4);
  marisa::grimoire::io::Mapper::seek(this, -(int)v4 & 7);
  *(void *)(a1 + 24) = v4;

  return marisa::grimoire::vector::Vector<unsigned long long>::fix(a1);
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  size_t v6 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v6, 8uLL);
  size_t v4 = v6;
  marisa::grimoire::vector::Vector<char>::resize((uint64_t *)a1, v6);
  marisa::grimoire::io::Reader::read<unsigned char>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v6 & 7);
}

uint64_t marisa::grimoire::io::Reader::read<unsigned char>(uint64_t a1, char *a2, size_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h";
    exception[2] = 0x20000001FLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/reader.h:31: MARISA_NULL_"
                   "ERROR: (objs == NULL) && (num_objs != 0)";
  }
  return marisa::grimoire::io::Reader::read_data(a1, a2, a3);
}

uint64_t marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  unint64_t v7 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v7, 8uLL);
  unint64_t v4 = v7 / 0xC;
  if (v7 % 0xC)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h";
    exception[2] = 0xA000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/vector.h:213: MARISA_"
                   "FORMAT_ERROR: (total_size % sizeof(T)) != 0";
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::trie::Cache>::resize((uint64_t *)a1, v7 / 0xC);
  marisa::grimoire::io::Reader::read<marisa::grimoire::vector::RankIndex>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v7 & 7);
}

uint64_t marisa::grimoire::vector::Vector<unsigned char>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf = *(void *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<unsigned char>((uint64_t)this, *(char **)(a1 + 16), *(void *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, -*(_DWORD *)(a1 + 24) & 7);
}

uint64_t marisa::grimoire::io::Writer::write<unsigned char>(uint64_t a1, char *a2, size_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h";
    exception[2] = 0x20000001ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../io/writer.h:30: MARISA_NULL_"
                   "ERROR: (objs == NULL) && (num_objs != 0)";
  }
  return marisa::grimoire::io::Writer::write_data(a1, a2, a3);
}

double marisa::grimoire::trie::Tail::Tail(marisa::grimoire::trie::Tail *this)
{
  double result = 0.0;
  *(_OWORD *)((char *)this + 2marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 73) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *(_OWORD *)((char *)this + 18marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *(_OWORD *)((char *)this + 233) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 137) = 0u;
  return result;
}

uint64_t marisa::grimoire::trie::Tail::build(long long *a1, uint64_t a2, long long *a3, int a4)
{
  if (!a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
    exception[2] = 0x20000000DLL;
    uint64_t v17 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:13: MARISA_NULL_ERROR: offsets == NULL";
    goto LABEL_28;
  }
  if (a4 == 0x2000) {
    goto LABEL_15;
  }
  if (a4 != 4096)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
    exception[2] = 0x500000024;
    uint64_t v17 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:36: MARISA_CODE_ERROR: undefined tail mode";
LABEL_28:
    exception[3] = v17;
  }
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = 0;
    a4 = 4096;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + 8) + 16 * v6;
      uint64_t v8 = *(unsigned int *)(v7 + 8);
      if (v8) {
        break;
      }
LABEL_11:
      if (++v6 == v5) {
        goto LABEL_15;
      }
    }
    uint64_t v9 = -v8;
    uint64_t v10 = *(void *)v7 + 1;
    while (*(unsigned char *)(v10 + v9))
    {
      if (__CFADD__(v9++, 1)) {
        goto LABEL_11;
      }
    }
    a4 = 0x2000;
  }
  else
  {
    a4 = 4096;
  }
LABEL_15:
  memset(v18, 0, 41);
  memset(v19, 0, 41);
  long long v22 = 0u;
  memset(v23, 0, sizeof(v23));
  long long v24 = 0u;
  memset(v25, 0, sizeof(v25));
  _OWORD v19[3] = 0u;
  long long v20 = 0u;
  memset(v21, 0, sizeof(v21));
  marisa::grimoire::trie::Tail::build_((uint64_t)v18, a2, a3, a4);
  long long v12 = *a1;
  *a1 = v18[0];
  v18[0] = v12;
  uint64_t v13 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v18[1];
  *(void *)&v18[1] = v13;
  long long v14 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v18[1] + 8);
  *(_OWORD *)((char *)&v18[1] + 8) = v14;
  LOBYTE(v13) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v18[2]);
  BYTE8(v18[2]) = v13;
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::vector::BitVector *)(a1 + 3), (marisa::grimoire::vector::BitVector *)v19);
  if ((void)v24) {
    MEMORY[0x1D9455390](v24, 0x1000C8077774924);
  }
  if ((void)v22) {
    MEMORY[0x1D9455390](v22, 0x1000C8077774924);
  }
  if ((void)v20) {
    MEMORY[0x1D9455390](v20, 0x1000C8077774924);
  }
  if (*(void *)&v19[0]) {
    MEMORY[0x1D9455390](*(void *)&v19[0], 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v18[0];
  if (*(void *)&v18[0]) {
    return MEMORY[0x1D9455390](*(void *)&v18[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D5938400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t marisa::grimoire::trie::Tail::build_(uint64_t a1, uint64_t a2, long long *a3, int a4)
{
  uint64_t v8 = *(void *)(a2 + 24);
  unint64_t v9 = *(void *)(a2 + 8);
  if (v8)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (_DWORD *)(v9 + 12);
    do
    {
      _DWORD *v11 = v10;
      v11 += 4;
      ++v10;
    }
    while (v8 != v10);
  }
  marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v9, v9 + 16 * v8, 0);
  memset(v34, 0, 41);
  unint64_t v12 = *(void *)(a2 + 24);
  LODWORD(v33[0]) = 0;
  marisa::grimoire::vector::Vector<unsigned int>::resize((uint64_t *)v34, v12, v33);
  v33[0] = 0;
  v33[1] = 0;
  uint64_t v13 = *(void *)(a2 + 24);
  if (v13)
  {
    long long v14 = v33;
    do
    {
      --v13;
      uint64_t v15 = *(void *)(a2 + 8);
      uint64_t v16 = v15 + 16 * v13;
      unint64_t v18 = (unsigned int *)(v16 + 8);
      uint64_t v17 = *(unsigned int *)(v16 + 8);
      if (!*(_DWORD *)(v16 + 8))
      {
        exception = __cxa_allocate_exception(0x20uLL);
        void *exception = &unk_1F2DE3CA8;
        exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
        exception[2] = 0x4000000AALL;
        exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:170: MARISA_RANGE_E"
                       "RROR: current.length() == 0";
      }
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = *((unsigned int *)v14 + 2);
      while (v21 != v20)
      {
        if (*(unsigned __int8 *)(*v14 + v19) != *(unsigned __int8 *)(*(void *)v16 + v19)) {
          goto LABEL_13;
        }
        ++v20;
        --v19;
        if (v17 == v20) {
          goto LABEL_14;
        }
      }
      uint64_t v20 = *((unsigned int *)v14 + 2);
LABEL_13:
      if (v20 != v17)
      {
        uint64_t v22 = *((void *)&v34[0] + 1);
        goto LABEL_17;
      }
LABEL_14:
      uint64_t v22 = *((void *)&v34[0] + 1);
      if (v21)
      {
        *(_DWORD *)(*((void *)&v34[0] + 1) + 4 * *(unsigned int *)(v15 + 16 * v13 + 12)) = v21
                                                                                             - v17
                                                                                             + *(_DWORD *)(*((void *)&v34[0] + 1) + 4 * *((unsigned int *)v14 + 3));
        goto LABEL_29;
      }
LABEL_17:
      *(_DWORD *)(v22 + 4 * *(unsigned int *)(v15 + 16 * v13 + 12)) = *(void *)(a1 + 24);
      unint64_t v23 = *v18;
      if (v23)
      {
        for (unint64_t i = 0; i < v23; ++i)
        {
          char v32 = *(unsigned char *)(*(void *)v16 - v23 + i + 1);
          marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)a1, &v32);
          unint64_t v23 = *v18;
        }
        if (a4 != 4096)
        {
          if (v23 >= 2)
          {
            unint64_t v25 = 1;
            do
            {
              marisa::grimoire::vector::BitVector::push_back((uint64_t *)(a1 + 48), 0);
              ++v25;
            }
            while (v25 < *v18);
          }
LABEL_27:
          marisa::grimoire::vector::BitVector::push_back((uint64_t *)(a1 + 48), 1);
          goto LABEL_28;
        }
      }
      else if (a4 != 4096)
      {
        goto LABEL_27;
      }
      char v32 = 0;
      marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)a1, &v32);
LABEL_28:
      if (*(_DWORD *)(a1 + 28))
      {
        int v31 = __cxa_allocate_exception(0x20uLL);
        void *v31 = &unk_1F2DE3CA8;
        v31[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc";
        v31[2] = 0x7000000C0;
        _OWORD v31[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/tail.cc:192: MARISA_SIZE_ERROR: b"
                 "uf_.size() > MARISA_UINT32_MAX";
      }
LABEL_29:
      long long v14 = (void *)v16;
    }
    while (v13);
  }
  marisa::grimoire::vector::Vector<unsigned char>::shrink((unsigned char *)a1);
  long long v26 = *a3;
  *a3 = v34[0];
  v34[0] = v26;
  uint64_t v27 = *((void *)a3 + 2);
  *((void *)a3 + 2) = *(void *)&v34[1];
  *(void *)&v34[1] = v27;
  long long v28 = *(long long *)((char *)a3 + 24);
  *(long long *)((char *)a3 + 24) = *(_OWORD *)((char *)&v34[1] + 8);
  *(_OWORD *)((char *)&v34[1] + 8) = v28;
  LOBYTE(v27) = *((unsigned char *)a3 + 40);
  *((unsigned char *)a3 + 40) = BYTE8(v34[2]);
  uint64_t result = v26;
  BYTE8(v34[2]) = v27;
  if ((void)v26) {
    return MEMORY[0x1D9455390](v26, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5938740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    MEMORY[0x1D9455390](a13, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *marisa::grimoire::trie::Tail::swap(marisa::grimoire::trie::Tail *this, marisa::grimoire::trie::Tail *a2)
{
  marisa::grimoire::vector::Vector<unsigned char>::swap((uint64_t *)this, (uint64_t *)a2);

  return marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::Tail *)((char *)this + 48), (marisa::grimoire::trie::Tail *)((char *)a2 + 48));
}

uint64_t marisa::grimoire::trie::Tail::map(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Mapper *a2)
{
  memset(v8, 0, 41);
  memset(v9, 0, 41);
  long long v12 = 0u;
  memset(v13, 0, sizeof(v13));
  long long v14 = 0u;
  memset(v15, 0, sizeof(v15));
  _OWORD v9[3] = 0u;
  long long v10 = 0u;
  memset(v11, 0, sizeof(v11));
  marisa::grimoire::vector::Vector<char>::map(v8, a2);
  marisa::grimoire::vector::BitVector::map((marisa::grimoire::vector::BitVector *)v9, a2);
  long long v4 = *(_OWORD *)this;
  *(_OWORD *)this = v8[0];
  v8[0] = v4;
  uint64_t v5 = *((void *)this + 2);
  *((void *)this + 2) = *(void *)&v8[1];
  *(void *)&v8[1] = v5;
  long long v6 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(long long *)((char *)&v8[1] + 8);
  *(long long *)((char *)&v8[1] + 8) = v6;
  LOBYTE(vmarisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = *((unsigned char *)this + 40);
  *((unsigned char *)this + 40) = BYTE8(v8[2]);
  BYTE8(v8[2]) = v5;
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::Tail *)((char *)this + 48), (marisa::grimoire::vector::BitVector *)v9);
  if ((void)v14) {
    MEMORY[0x1D9455390](v14, 0x1000C8077774924);
  }
  if ((void)v12) {
    MEMORY[0x1D9455390](v12, 0x1000C8077774924);
  }
  if ((void)v10) {
    MEMORY[0x1D9455390](v10, 0x1000C8077774924);
  }
  if (*(void *)&v9[0]) {
    MEMORY[0x1D9455390](*(void *)&v9[0], 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v8[0];
  if (*(void *)&v8[0]) {
    return MEMORY[0x1D9455390](*(void *)&v8[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D593891C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t marisa::grimoire::trie::Tail::map_(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Mapper *a2)
{
  marisa::grimoire::vector::Vector<char>::map((long long *)this, a2);

  return marisa::grimoire::vector::BitVector::map((marisa::grimoire::trie::Tail *)((char *)this + 48), a2);
}

uint64_t marisa::grimoire::trie::Tail::read(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Reader *a2)
{
  memset(v8, 0, 41);
  memset(v9, 0, 41);
  long long v12 = 0u;
  memset(v13, 0, sizeof(v13));
  long long v14 = 0u;
  memset(v15, 0, sizeof(v15));
  _OWORD v9[3] = 0u;
  long long v10 = 0u;
  memset(v11, 0, sizeof(v11));
  marisa::grimoire::vector::Vector<char>::read(v8, a2);
  marisa::grimoire::vector::BitVector::read((marisa::grimoire::vector::BitVector *)v9, a2);
  long long v4 = *(_OWORD *)this;
  *(_OWORD *)this = v8[0];
  v8[0] = v4;
  uint64_t v5 = *((void *)this + 2);
  *((void *)this + 2) = *(void *)&v8[1];
  *(void *)&v8[1] = v5;
  long long v6 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 24) = *(long long *)((char *)&v8[1] + 8);
  *(long long *)((char *)&v8[1] + 8) = v6;
  LOBYTE(vmarisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = *((unsigned char *)this + 40);
  *((unsigned char *)this + 40) = BYTE8(v8[2]);
  BYTE8(v8[2]) = v5;
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::trie::Tail *)((char *)this + 48), (marisa::grimoire::vector::BitVector *)v9);
  if ((void)v14) {
    MEMORY[0x1D9455390](v14, 0x1000C8077774924);
  }
  if ((void)v12) {
    MEMORY[0x1D9455390](v12, 0x1000C8077774924);
  }
  if ((void)v10) {
    MEMORY[0x1D9455390](v10, 0x1000C8077774924);
  }
  if (*(void *)&v9[0]) {
    MEMORY[0x1D9455390](*(void *)&v9[0], 0x1000C8077774924);
  }
  uint64_t result = *(void *)&v8[0];
  if (*(void *)&v8[0]) {
    return MEMORY[0x1D9455390](*(void *)&v8[0], 0x1000C8077774924);
  }
  return result;
}

void sub_1D5938AC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t marisa::grimoire::trie::Tail::read_(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Reader *a2)
{
  marisa::grimoire::vector::Vector<char>::read((long long *)this, a2);

  return marisa::grimoire::vector::BitVector::read((marisa::grimoire::trie::Tail *)((char *)this + 48), a2);
}

uint64_t marisa::grimoire::trie::Tail::write(marisa::grimoire::trie::Tail *this, marisa::grimoire::io::Writer *a2)
{
  marisa::grimoire::vector::Vector<char>::write_((uint64_t)this, a2);

  return marisa::grimoire::vector::BitVector::write_((marisa::grimoire::trie::Tail *)((char *)this + 48), a2);
}

uint64_t *marisa::grimoire::trie::Tail::restore(uint64_t *this, marisa::Agent *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  long long v4 = this;
  uint64_t v5 = (uint64_t *)*((void *)a2 + 5);
  if (this[12])
  {
    do
    {
      this = marisa::grimoire::vector::Vector<char>::push_back(v5, (unsigned char *)(v4[2] + v3));
      uint64_t v6 = *(void *)(v4[8] + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3;
      ++v3;
    }
    while ((v6 & 1) == 0);
  }
  else
  {
    uint64_t v7 = (unsigned char *)(this[2] + a3);
    if (*v7)
    {
      do
        this = marisa::grimoire::vector::Vector<char>::push_back(v5, v7);
      while (*++v7);
    }
  }
  return this;
}

uint64_t marisa::grimoire::trie::Tail::match(marisa::grimoire::trie::Tail *this, marisa::Agent *a2, unint64_t a3)
{
  uint64_t v3 = *((void *)a2 + 5);
  uint64_t v4 = *((void *)this + 2);
  if (*((void *)this + 12))
  {
    unsigned int v5 = *(_DWORD *)(v3 + 100);
    uint64_t v6 = *(void *)a2;
    unint64_t v7 = *((void *)a2 + 1);
    do
    {
      if (*(unsigned __int8 *)(v4 + a3) != *(unsigned __int8 *)(v6 + v5)) {
        break;
      }
      *(_DWORD *)(v3 + 100) = ++v5;
      if ((*(void *)(*((void *)this + 8) + ((a3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> a3)) {
        return 1;
      }
      ++a3;
    }
    while (v7 > v5);
  }
  else
  {
    unint64_t v12 = v4 + a3;
    uint64_t v8 = v4 + a3 - *(unsigned int *)(v3 + 100);
    uint64_t v9 = *(void *)a2;
    unint64_t v10 = *((void *)a2 + 1);
    int v11 = *(unsigned __int8 *)v12;
    LODWORD(v12) = *(_DWORD *)(v3 + 100);
    while (v11 == *(unsigned __int8 *)(v9 + v12))
    {
      unint64_t v12 = (v12 + 1);
      *(_DWORD *)(v3 + 100) = v12;
      int v11 = *(unsigned __int8 *)(v8 + v12);
      if (!*(unsigned char *)(v8 + v12)) {
        return 1;
      }
      if (v10 <= v12) {
        return 0;
      }
    }
  }
  return 0;
}

BOOL marisa::grimoire::trie::Tail::prefix_match(marisa::grimoire::trie::Tail *this, marisa::Agent *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v6 = *((void *)a2 + 5);
  if (*((void *)this + 12))
  {
    unsigned int v7 = *(_DWORD *)(v6 + 100);
    while (1)
    {
      uint64_t v8 = (unsigned char *)(*((void *)this + 2) + v3);
      int v9 = *v8;
      int v10 = *(unsigned __int8 *)(*(void *)a2 + v7);
      BOOL v11 = v9 == v10;
      if (v9 != v10) {
        break;
      }
      marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, v8);
      unsigned int v7 = *(_DWORD *)(v6 + 100) + 1;
      *(_DWORD *)(v6 + 100) = v7;
      if ((*(void *)(*((void *)this + 8) + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3)) {
        break;
      }
      ++v3;
      if (*((void *)a2 + 1) <= (unint64_t)v7)
      {
        do
        {
          marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, (unsigned char *)(*((void *)this + 2) + v3));
          uint64_t v12 = *(void *)(*((void *)this + 8) + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v3;
          ++v3;
        }
        while ((v12 & 1) == 0);
        return 1;
      }
    }
  }
  else
  {
    unint64_t v15 = *((void *)this + 2) + a3;
    uint64_t v13 = (unsigned __int8 *)(v15 - *(unsigned int *)(v6 + 100));
    int v14 = *(unsigned __int8 *)v15;
    LODWORD(v1marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = *(_DWORD *)(v6 + 100);
    while (1)
    {
      int v16 = *(unsigned __int8 *)(*(void *)a2 + v15);
      BOOL v11 = v14 == v16;
      if (v14 != v16) {
        break;
      }
      marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, &v13[v15]);
      unint64_t v15 = (*(_DWORD *)(v6 + 100) + 1);
      *(_DWORD *)(v6 + 100) = v15;
      int v14 = v13[v15];
      if (!v13[v15]) {
        break;
      }
      if (*((void *)a2 + 1) <= v15)
      {
        uint64_t v17 = &v13[v15];
        do
          marisa::grimoire::vector::Vector<char>::push_back((uint64_t *)v6, v17);
        while (*++v17);
        return 1;
      }
    }
  }
  return v11;
}

uint64_t marisa::grimoire::trie::Tail::clear(marisa::grimoire::trie::Tail *this)
{
  memset(v3, 0, 41);
  long long v6 = 0u;
  memset(v7, 0, sizeof(v7));
  long long v8 = 0u;
  memset(v9, 0, sizeof(v9));
  v3[3] = 0u;
  long long v4 = 0u;
  memset(v5, 0, sizeof(v5));
  long long v2 = *(_OWORD *)this;
  *(_OWORD *)this = 0u;
  *((void *)this + 2) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((unsigned char *)this + 40) = 0;
  marisa::grimoire::vector::BitVector::swap((marisa::grimoire::vector::BitVector *)v3, (marisa::grimoire::trie::Tail *)((char *)this + 48));
  if ((void)v8) {
    MEMORY[0x1D9455390](v8, 0x1000C8077774924);
  }
  if ((void)v6) {
    MEMORY[0x1D9455390](v6, 0x1000C8077774924);
  }
  if ((void)v4) {
    MEMORY[0x1D9455390](v4, 0x1000C8077774924);
  }
  if (*(void *)&v3[0]) {
    MEMORY[0x1D9455390](*(void *)&v3[0], 0x1000C8077774924);
  }
  uint64_t result = v2;
  if ((void)v2) {
    return MEMORY[0x1D9455390](v2, 0x1000C8077774924);
  }
  return result;
}

void sub_1D5938EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *marisa::grimoire::vector::Vector<unsigned int>::resize(uint64_t *result, unint64_t a2, _DWORD *a3)
{
  unint64_t v4 = a2;
  unsigned int v5 = result;
  unint64_t v6 = result[4];
  if (v6 < a2)
  {
    uint64_t v7 = 2 * v6;
    if (v6 >> 61) {
      uint64_t v7 = 0x3FFFFFFFFFFFFFFFLL;
    }
    if (v6 > a2 >> 1) {
      a2 = v7;
    }
    uint64_t result = (uint64_t *)marisa::grimoire::vector::Vector<unsigned int>::realloc(result, a2);
  }
  unint64_t v8 = v5[3];
  unint64_t v9 = v4 - v8;
  if (v4 > v8)
  {
    int v10 = (_DWORD *)(v5[1] + 4 * v8);
    do
    {
      *v10++ = *a3;
      --v9;
    }
    while (v9);
  }
  v5[3] = v4;
  return result;
}

uint64_t marisa::grimoire::vector::Vector<char>::map(long long *a1, marisa::grimoire::io::Mapper *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<unsigned char>::map_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D593902C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::vector::Vector<char>::read(long long *a1, marisa::grimoire::io::Reader *a2)
{
  memset(v7, 0, 41);
  marisa::grimoire::vector::Vector<char>::read_((uint64_t)v7, a2);
  long long v3 = *a1;
  *a1 = v7[0];
  v7[0] = v3;
  uint64_t v4 = *((void *)a1 + 2);
  *((void *)a1 + 2) = *(void *)&v7[1];
  *(void *)&v7[1] = v4;
  long long v5 = *(long long *)((char *)a1 + 24);
  *(long long *)((char *)a1 + 24) = *(_OWORD *)((char *)&v7[1] + 8);
  *(_OWORD *)((char *)&v7[1] + 8) = v5;
  LOBYTE(v4) = *((unsigned char *)a1 + 40);
  *((unsigned char *)a1 + 40) = BYTE8(v7[2]);
  uint64_t result = v3;
  BYTE8(v7[2]) = v4;
  if ((void)v3) {
    return MEMORY[0x1D9455390](v3, 0x1000C8077774924);
  }
  return result;
}

void sub_1D59390EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1D9455390](a9, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = a2;
  unint64_t v5 = a1;
  uint64_t v6 = a2 - a1;
  if ((uint64_t)(a2 - a1) < 161)
  {
    uint64_t v7 = 0;
    goto LABEL_68;
  }
  uint64_t v7 = 0;
  do
  {
    int v8 = marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Entry>(v5, v5 + 16 * ((unint64_t)v6 >> 5), v4 - 16, a3);
    int v9 = v8;
    unint64_t v10 = v5;
    unint64_t v11 = v4;
    unint64_t v12 = v5;
    unint64_t v13 = v4;
    while (v10 < v11)
    {
      unint64_t v14 = *(unsigned int *)(v10 + 8);
      int v15 = a3 >= v14 ? -1 : *(unsigned __int8 *)(*(void *)v10 - a3);
      if (v15 > v8) {
        break;
      }
      if (v15 == v8)
      {
        uint64_t v16 = *(void *)v10;
        int v17 = *(_DWORD *)(v10 + 12);
        *(void *)unint64_t v10 = *(void *)v12;
        *(void *)(v10 + 8) = *(void *)(v12 + 8);
        *(void *)unint64_t v12 = v16;
        *(_DWORD *)(v12 + 8) = v14;
        *(_DWORD *)(v12 + 12) = v17;
        v12 += 16;
      }
LABEL_11:
      v10 += 16;
    }
    if (v10 < v11)
    {
      unint64_t v18 = v11 - 16;
      do
      {
        unint64_t v11 = v18;
        unint64_t v19 = *(unsigned int *)(v18 + 8);
        if (a3 >= v19) {
          int v20 = -1;
        }
        else {
          int v20 = *(unsigned __int8 *)(*(void *)v11 - a3);
        }
        if (v20 < v8) {
          break;
        }
        if (v20 == v8)
        {
          uint64_t v21 = *(void *)(v13 - 16);
          v13 -= 16;
          uint64_t v22 = *(void *)v11;
          int v23 = *(_DWORD *)(v11 + 12);
          *(void *)unint64_t v11 = v21;
          *(void *)(v11 + 8) = *(void *)(v13 + 8);
          *(void *)unint64_t v13 = v22;
          *(_DWORD *)(v13 + 8) = v19;
          *(_DWORD *)(v13 + 12) = v23;
        }
        unint64_t v18 = v11 - 16;
      }
      while (v10 < v11);
    }
    if (v10 < v11)
    {
      uint64_t v24 = *(void *)v10;
      *(void *)unint64_t v10 = *(void *)v11;
      uint64_t v25 = *(void *)(v11 + 8);
      *(void *)unint64_t v11 = v24;
      uint64_t v26 = *(void *)(v10 + 8);
      *(void *)(v10 + 8) = v25;
      *(void *)(v11 + 8) = v26;
      goto LABEL_11;
    }
    uint64_t v42 = v7;
    while (v12 > v5)
    {
      uint64_t v28 = *(void *)(v12 - 16);
      v12 -= 16;
      uint64_t v27 = v28;
      uint64_t v29 = *(void *)(v10 - 16);
      v10 -= 16;
      *(void *)unint64_t v12 = v29;
      uint64_t v30 = *(void *)(v10 + 8);
      *(void *)unint64_t v10 = v27;
      uint64_t v31 = *(void *)(v12 + 8);
      *(void *)(v12 + 8) = v30;
      *(void *)(v10 + 8) = v31;
    }
    while (v13 < v4)
    {
      uint64_t v32 = *(void *)v13;
      *(void *)unint64_t v13 = *(void *)v11;
      uint64_t v33 = *(void *)(v11 + 8);
      *(void *)unint64_t v11 = v32;
      uint64_t v34 = *(void *)(v13 + 8);
      *(void *)(v13 + 8) = v33;
      *(void *)(v11 + 8) = v34;
      v11 += 16;
      v13 += 16;
    }
    uint64_t v35 = v10 - v5;
    uint64_t v36 = (uint64_t)(v10 - v5) >> 4;
    uint64_t v37 = v11 - v10;
    if (v36 <= (uint64_t)(v11 - v10) >> 4)
    {
      uint64_t v38 = v4 - v11;
      if (v37 >> 4 >= (uint64_t)(v4 - v11) >> 4)
      {
        if (v35 == 16)
        {
          uint64_t v39 = v42 + 1;
        }
        else
        {
          if (v35 < 17) {
            goto LABEL_52;
          }
          uint64_t v39 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v5, v10, a3) + v42;
        }
        uint64_t v42 = v39;
LABEL_52:
        if (v38 == 16)
        {
          uint64_t v7 = v42 + 1;
        }
        else if (v38 < 17)
        {
          uint64_t v7 = v42;
        }
        else
        {
          uint64_t v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v11, v4, a3) + v42;
        }
        if (v37 == 16)
        {
          ++v7;
        }
        else if (v37 >= 17)
        {
          if (v9 == -1)
          {
            ++v7;
            unint64_t v5 = v11;
            goto LABEL_63;
          }
          ++a3;
        }
        unint64_t v5 = v10;
LABEL_63:
        unint64_t v4 = v11;
        goto LABEL_64;
      }
    }
    if (v37 == 16) {
      goto LABEL_31;
    }
    if (v37 < 17)
    {
      uint64_t v7 = v42;
    }
    else if (v8 == -1)
    {
LABEL_31:
      uint64_t v7 = v42 + 1;
    }
    else
    {
      uint64_t v7 = marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v10, v11, a3 + 1) + v42;
    }
    uint64_t v40 = v4 - v11;
    if (v36 >= (uint64_t)(v4 - v11) >> 4)
    {
      if (v40 == 16)
      {
        ++v7;
      }
      else if (v40 >= 17)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v11, v4, a3);
      }
      unint64_t v4 = v10;
    }
    else
    {
      if (v35 == 16)
      {
        ++v7;
      }
      else if (v35 >= 17)
      {
        v7 += marisa::grimoire::algorithm::details::sort<marisa::grimoire::trie::Entry *>(v5, v10, a3);
      }
      unint64_t v5 = v11;
    }
LABEL_64:
    uint64_t v6 = v4 - v5;
  }
  while ((uint64_t)(v4 - v5) > 160);
LABEL_68:
  if (v6 >= 17) {
    v7 += marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Entry *>(v5, v4, a3);
  }
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::median<marisa::grimoire::trie::Entry>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(unsigned int *)(a1 + 8) <= a4) {
    int v4 = -1;
  }
  else {
    int v4 = *(unsigned __int8 *)(*(void *)a1 - a4);
  }
  if (*(unsigned int *)(a2 + 8) <= a4) {
    int v5 = -1;
  }
  else {
    int v5 = *(unsigned __int8 *)(*(void *)a2 - a4);
  }
  if (*(unsigned int *)(a3 + 8) <= a4) {
    int v6 = -1;
  }
  else {
    int v6 = *(unsigned __int8 *)(*(void *)a3 - a4);
  }
  if (v4 <= v5) {
    int v7 = v5;
  }
  else {
    int v7 = v4;
  }
  if (v4 >= v5) {
    int v4 = v5;
  }
  if (v4 <= v6) {
    int v4 = v6;
  }
  if (v7 >= v6) {
    return v4;
  }
  else {
    return v7;
  }
}

uint64_t marisa::grimoire::algorithm::details::insertion_sort<marisa::grimoire::trie::Entry *>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  long long v3 = (void *)(a1 + 16);
  if (a1 + 16 >= a2) {
    return 1;
  }
  uint64_t v7 = 1;
  do
  {
    int v8 = v3;
    if ((unint64_t)v3 <= a1)
    {
      int v10 = 0;
    }
    else
    {
      while (1)
      {
        int v9 = v8 - 2;
        int v10 = marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Entry>((uint64_t)(v8 - 2), (uint64_t)v8, a3);
        if (v10 < 1) {
          break;
        }
        uint64_t v11 = *(v8 - 2);
        *(v8 - 2) = *v8;
        uint64_t v12 = v8[1];
        *int v8 = v11;
        uint64_t v13 = *(v8 - 1);
        *(v8 - 1) = v12;
        v8[1] = v13;
        v8 -= 2;
        if ((unint64_t)v9 <= a1)
        {
          int v10 = 1;
          break;
        }
      }
    }
    if (v10) {
      ++v7;
    }
    v3 += 2;
  }
  while ((unint64_t)v3 < a2);
  return v7;
}

uint64_t marisa::grimoire::algorithm::details::compare<marisa::grimoire::trie::Entry>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  unint64_t v5 = v3 - a3;
  if (v3 <= a3)
  {
LABEL_6:
    if (v3 < v4) {
      unsigned int v12 = -1;
    }
    else {
      unsigned int v12 = 1;
    }
    if (v3 == v4) {
      return 0;
    }
    else {
      return v12;
    }
  }
  else
  {
    uint64_t v6 = v4 - a3;
    uint64_t v7 = (unsigned __int8 *)(*(void *)a2 - a3);
    int v8 = (unsigned __int8 *)(*(void *)a1 - a3);
    while (v6)
    {
      int v9 = *v8;
      int v10 = *v7;
      uint64_t result = (v9 - v10);
      if (v9 != v10) {
        return result;
      }
      --v6;
      --v7;
      --v8;
      if (!--v5) {
        goto LABEL_6;
      }
    }
    return 1;
  }
}

uint64_t marisa::grimoire::vector::Vector<char>::read_(uint64_t a1, marisa::grimoire::io::Reader *this)
{
  size_t v6 = 0;
  marisa::grimoire::io::Reader::read_data((uint64_t)this, (char *)&v6, 8uLL);
  size_t v4 = v6;
  marisa::grimoire::vector::Vector<char>::resize((uint64_t *)a1, v6);
  marisa::grimoire::io::Reader::read<char>((uint64_t)this, *(char **)(a1 + 8), v4);
  return marisa::grimoire::io::Reader::seek((uint64_t)this, -(int)v6 & 7);
}

uint64_t marisa::grimoire::io::Reader::read<char>(uint64_t a1, char *a2, size_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/../io/reader.h";
    exception[2] = 0x20000001FLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/../io/reader.h:31: MA"
                   "RISA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
  }
  return marisa::grimoire::io::Reader::read_data(a1, a2, a3);
}

uint64_t marisa::grimoire::vector::Vector<char>::write_(uint64_t a1, marisa::grimoire::io::Writer *this)
{
  uint64_t __buf = *(void *)(a1 + 24);
  marisa::grimoire::io::Writer::write_data((uint64_t)this, (char *)&__buf, 8uLL);
  marisa::grimoire::io::Writer::write<char>((uint64_t)this, *(char **)(a1 + 16), *(void *)(a1 + 24));
  return marisa::grimoire::io::Writer::seek((uint64_t)this, -*(_DWORD *)(a1 + 24) & 7);
}

uint64_t marisa::grimoire::io::Writer::write<char>(uint64_t a1, char *a2, size_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/../io/writer.h";
    exception[2] = 0x20000001ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/trie/../vector/../io/writer.h:30: MA"
                   "RISA_NULL_ERROR: (objs == NULL) && (num_objs != 0)";
  }
  return marisa::grimoire::io::Writer::write_data(a1, a2, a3);
}

uint64_t marisa::grimoire::vector::BitVector::rank1(marisa::grimoire::vector::BitVector *this, unint64_t a2)
{
  unint64_t v2 = a2 >> 9;
  uint64_t v3 = *((void *)this + 10);
  uint64_t v4 = *(unsigned int *)(v3 + 12 * (a2 >> 9));
  switch((a2 >> 6) & 7)
  {
    case 1uLL:
      unint64_t v5 = *(_DWORD *)(v3 + 12 * v2 + 4) & 0x7F;
      goto LABEL_10;
    case 2uLL:
      unint64_t v6 = (unint64_t)*(unsigned int *)(v3 + 12 * v2 + 4) >> 7;
      goto LABEL_5;
    case 3uLL:
      unint64_t v6 = (unint64_t)*(unsigned int *)(v3 + 12 * v2 + 4) >> 15;
LABEL_5:
      v4 += v6;
      break;
    case 4uLL:
      v4 += (unint64_t)*(unsigned int *)(v3 + 12 * v2 + 4) >> 23;
      break;
    case 5uLL:
      unint64_t v5 = *(_DWORD *)(v3 + 12 * v2 + 8) & 0x1FF;
      goto LABEL_10;
    case 6uLL:
      unint64_t v5 = ((unint64_t)*(unsigned int *)(v3 + 12 * v2 + 8) >> 9) & 0x1FF;
      goto LABEL_10;
    case 7uLL:
      unint64_t v5 = ((unint64_t)*(unsigned int *)(v3 + 12 * v2 + 8) >> 18) & 0x1FF;
LABEL_10:
      v4 += v5;
      break;
    default:
      break;
  }
  unint64_t v7 = *(void *)(*((void *)this + 2) + 8 * (a2 >> 6)) & ~(-1 << a2);
  unint64_t v8 = (((((v7 >> 1) & 0x5555555555555555) + (v7 & 0x5555555555555555)) >> 2) & 0x3333333333333333)
     + ((((v7 >> 1) & 0x5555555555555555) + (v7 & 0x5555555555555555)) & 0x3333333333333333);
  return v4 + ((0x101010101010101 * (((v8 >> 4) & 0x707070707070707) + (v8 & 0x707070707070707))) >> 56);
}

unint64_t marisa::grimoire::vector::BitVector::select0(marisa::grimoire::vector::BitVector *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 16);
  if ((a2 & 0x1FF) == 0) {
    return *(unsigned int *)(v2 + 4 * (a2 >> 9));
  }
  unint64_t v3 = *(_DWORD *)(v2 + 4 * (a2 >> 9)) >> 9;
  unint64_t v4 = (*(_DWORD *)(v2 + 4 * (a2 >> 9) + 4) + 511) >> 9;
  uint64_t v5 = *((void *)this + 10);
  if (v3 + 10 >= v4)
  {
    uint64_t v7 = v5 + 12 * v3;
    unint64_t v8 = v3-- << 9;
    int v9 = (unsigned int *)(v7 + 12);
    do
    {
      unsigned int v10 = *v9;
      v9 += 3;
      ++v3;
      v8 += 512;
    }
    while (v8 - v10 <= a2);
  }
  else
  {
    do
    {
      if (((v4 + v3) >> 1 << 9) - *(unsigned int *)(v5 + 12 * ((v4 + v3) >> 1)) > a2) {
        unint64_t v4 = (v4 + v3) >> 1;
      }
      else {
        unint64_t v3 = (v4 + v3) >> 1;
      }
    }
    while (v3 + 1 < v4);
  }
  uint64_t v11 = (unsigned int *)(v5 + 12 * v3);
  unint64_t v12 = v11[1];
  uint64_t v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)(a2 - (v3 << 9) + *v11);
  uint64_t v14 = 8 * v3;
  if ((unint64_t)v13 >= 256 - (v12 >> 23))
  {
    unint64_t v15 = *(unsigned int *)(v5 + 12 * v3 + 8);
    uint64_t v16 = (v15 >> 9) & 0x1FF;
    if ((unint64_t)v13 >= 384 - v16)
    {
      uint64_t v18 = (v15 >> 18) & 0x1FF;
      if ((unint64_t)v13 >= 448 - v18)
      {
        v14 |= 7uLL;
        uint64_t v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + v18 - 448);
      }
      else
      {
        v14 |= 6uLL;
        uint64_t v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + v16 - 384);
      }
    }
    else if ((unint64_t)v13 >= 320 - (v15 & 0x1FF))
    {
      v14 |= 5uLL;
      uint64_t v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + (v15 & 0x1FF) - 320);
    }
    else
    {
      v14 |= 4uLL;
      uint64_t v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + (v12 >> 23) - 256);
    }
  }
  else if ((unint64_t)v13 >= 128 - (unint64_t)(v12 >> 7))
  {
    uint64_t v17 = (v12 >> 15);
    if ((unint64_t)v13 >= 192 - v17)
    {
      v14 |= 3uLL;
      uint64_t v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + v17 - 192);
    }
    else
    {
      v14 |= 2uLL;
      uint64_t v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + (v12 >> 7) - 128);
    }
  }
  else if ((unint64_t)v13 >= 64 - (v12 & 0x7F))
  {
    v14 |= 1uLL;
    uint64_t v13 = (marisa::grimoire::vector::_anonymous_namespace_ *)((char *)v13 + (v12 & 0x7F) - 64);
  }
}

unint64_t marisa::grimoire::vector::anonymous namespace'::select_bit(marisa::grimoire::vector::_anonymous_namespace_ *this, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = (((a3 - ((a3 >> 1) & 0x5555555555555555)) >> 2) & 0x3333333333333333)
     + ((a3 - ((a3 >> 1) & 0x5555555555555555)) & 0x3333333333333333);
  uint64_t v4 = (v3 + (v3 >> 4)) & 0xF0F0F0F0F0F0F0FLL;
  unint64_t v5 = __clz(__rbit64(((((0x101010101010101 * v4) | 0x8080808080808080)
                      - 0x101010101010101 * (void)this
                      - 0x101010101010101) >> 7) & 0x101010101010101));
  return v5
       + a2
                                                                     * ((void)this
                                                                      - ((unint64_t)(0x101010101010100 * v4) >> v5))
                                                                     + (a3 >> v5)];
}

unint64_t marisa::grimoire::vector::BitVector::select1(marisa::grimoire::vector::BitVector *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 22);
  if ((a2 & 0x1FF) == 0) {
    return *(unsigned int *)(v2 + 4 * (a2 >> 9));
  }
  unint64_t v3 = *(_DWORD *)(v2 + 4 * (a2 >> 9)) >> 9;
  unint64_t v4 = (*(_DWORD *)(v2 + 4 * (a2 >> 9) + 4) + 511) >> 9;
  uint64_t v5 = *((void *)this + 10);
  if (v3 + 10 >= v4)
  {
    uint64_t v7 = v5 + 12 * v3--;
    unint64_t v8 = (unsigned int *)(v7 + 12);
    do
    {
      unsigned int v9 = *v8;
      v8 += 3;
      ++v3;
    }
    while (v9 <= a2);
  }
  else
  {
    do
    {
      if (*(unsigned int *)(v5 + 12 * ((v4 + v3) >> 1)) > a2) {
        unint64_t v4 = (v4 + v3) >> 1;
      }
      else {
        unint64_t v3 = (v4 + v3) >> 1;
      }
    }
    while (v3 + 1 < v4);
  }
  unsigned int v10 = (unsigned int *)(v5 + 12 * v3);
  unint64_t v11 = v10[1];
  unint64_t v12 = a2 - *v10;
  uint64_t v13 = 8 * v3;
  if (v12 >= v11 >> 23)
  {
    unint64_t v23 = v11 >> 23;
    unint64_t v24 = *(unsigned int *)(v5 + 12 * v3 + 8);
    unint64_t v25 = (v24 >> 9) & 0x1FF;
    unint64_t v26 = (v24 >> 18) & 0x1FF;
    uint64_t v27 = v13 | 7;
    BOOL v28 = v12 >= v26;
    if (v12 < v26) {
      uint64_t v29 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v25);
    }
    else {
      uint64_t v29 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v26);
    }
    if (!v28) {
      uint64_t v27 = v13 | 6;
    }
    unint64_t v30 = v24 & 0x1FF;
    uint64_t v31 = v13 | 5;
    uint64_t v32 = v13 | 4;
    uint64_t v33 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v23);
    BOOL v34 = v12 >= v30;
    if (v12 < v30) {
      uint64_t v21 = v33;
    }
    else {
      uint64_t v21 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v30);
    }
    if (v34) {
      uint64_t v32 = v31;
    }
    if (v12 < v25)
    {
      uint64_t v22 = v32;
    }
    else
    {
      uint64_t v21 = v29;
      uint64_t v22 = v27;
    }
  }
  else
  {
    unint64_t v14 = v11 >> 7;
    unint64_t v15 = (v11 >> 15);
    uint64_t v16 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - (v11 >> 7));
    if (v12 < v15)
    {
      uint64_t v17 = v13 | 2;
    }
    else
    {
      uint64_t v16 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v15);
      uint64_t v17 = v13 | 3;
    }
    unint64_t v18 = v11 & 0x7F;
    BOOL v20 = v12 >= v18;
    unint64_t v19 = (marisa::grimoire::vector::_anonymous_namespace_ *)(v12 - v18);
    if (v20) {
      v13 |= 1uLL;
    }
    else {
      unint64_t v19 = (marisa::grimoire::vector::_anonymous_namespace_ *)v12;
    }
    BOOL v20 = v12 >= v14;
    if (v12 < v14) {
      uint64_t v21 = v19;
    }
    else {
      uint64_t v21 = v16;
    }
    if (v20) {
      uint64_t v22 = v17;
    }
    else {
      uint64_t v22 = v13;
    }
  }
}

void marisa::grimoire::vector::BitVector::build_index(marisa::grimoire::vector::BitVector *this, const marisa::grimoire::vector::BitVector *a2, int a3, int a4)
{
  unint64_t v8 = (uint64_t *)((char *)this + 64);
  unint64_t v9 = *((void *)a2 + 6);
  if ((v9 & 0x1FF) != 0) {
    uint64_t v10 = (v9 >> 9) + 1;
  }
  else {
    uint64_t v10 = v9 >> 9;
  }
  marisa::grimoire::vector::Vector<marisa::grimoire::vector::RankIndex>::resize(v8, v10 + 1);
  unint64_t v11 = *((void *)a2 + 6);
  if (v11)
  {
    unint64_t v12 = 0;
    int v13 = 0;
    __int16 v14 = 0;
    do
    {
      if ((v12 & 0x3F) == 0)
      {
        unint64_t v15 = v12 >> 9;
        switch((v12 >> 6) & 7)
        {
          case 1uLL:
            uint64_t v16 = (_DWORD *)(*((void *)this + 9) + 12 * v15);
            unsigned int v17 = v16[1] & 0xFFFFFF80 | (v13 - *v16) & 0x7F;
            goto LABEL_13;
          case 2uLL:
            uint64_t v16 = (_DWORD *)(*((void *)this + 9) + 12 * v15);
            unsigned int v17 = v16[1] & 0xFFFF807F | ((v13 - *(unsigned char *)v16) << 7);
            goto LABEL_13;
          case 3uLL:
            uint64_t v16 = (_DWORD *)(*((void *)this + 9) + 12 * v15);
            unsigned int v17 = v16[1] & 0xFF807FFF | ((v13 - *(unsigned char *)v16) << 15);
            goto LABEL_13;
          case 4uLL:
            uint64_t v16 = (_DWORD *)(*((void *)this + 9) + 12 * v15);
            unsigned int v17 = v16[1] & 0x7FFFFF | ((unsigned __int16)(v13 - *(_WORD *)v16) << 23);
LABEL_13:
            v16[1] = v17;
            break;
          case 5uLL:
            unint64_t v18 = (_DWORD *)(*((void *)this + 9) + 12 * v15);
            unsigned int v19 = v18[2] & 0xFFFFFE00 | (v13 - *v18) & 0x1FF;
            goto LABEL_17;
          case 6uLL:
            unint64_t v18 = (_DWORD *)(*((void *)this + 9) + 12 * v15);
            unsigned int v19 = v18[2] & 0xFFFC01FF | (((v13 - *v18) & 0x1FF) << 9);
            goto LABEL_17;
          case 7uLL:
            unint64_t v18 = (_DWORD *)(*((void *)this + 9) + 12 * v15);
            unsigned int v19 = v18[2] & 0xF803FFFF | (((v13 - *v18) & 0x1FF) << 18);
LABEL_17:
            void v18[2] = v19;
            break;
          default:
            *(_DWORD *)(*((void *)this + 9) + 12 * v1marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = v13;
            break;
        }
      }
      if ((*(void *)(*((void *)a2 + 2) + 8 * (v12 >> 6)) >> (v12 & 0x3F)))
      {
        if (a4 && (v13 & 0x1FF) == 0)
        {
          int v36 = v12;
          marisa::grimoire::vector::Vector<unsigned int>::push_back((uint64_t *)this + 20, &v36);
        }
        ++v13;
      }
      else
      {
        if (a3 && (v14 & 0x1FF) == 0)
        {
          int v36 = v12;
          marisa::grimoire::vector::Vector<unsigned int>::push_back((uint64_t *)this + 14, &v36);
        }
        ++v14;
      }
      ++v12;
      unint64_t v11 = *((void *)a2 + 6);
    }
    while (v12 < v11);
    if ((v11 & 0x1FF) != 0)
    {
      unint64_t v20 = (v11 - 1) >> 9;
      switch(((unint64_t)(v11 - 1) >> 6) & 7)
      {
        case 0uLL:
          uint64_t v21 = *((void *)this + 9);
          uint64_t v22 = (_DWORD *)(v21 + 12 * v20);
          int v23 = v13 - *v22;
          unsigned int v24 = v22[1] & 0xFFFFFF80 | v23 & 0x7F;
          v22[1] = v24;
          goto LABEL_33;
        case 1uLL:
          uint64_t v21 = *((void *)this + 9);
          unint64_t v25 = (_DWORD *)(v21 + 12 * v20);
          unsigned int v24 = v25[1];
          int v23 = v13 - *v25;
LABEL_33:
          unsigned int v26 = v24 & 0xFFFF807F | (v23 << 7);
          *(_DWORD *)(v21 + 12 * v20 + 4) = v26;
          goto LABEL_35;
        case 2uLL:
          uint64_t v21 = *((void *)this + 9);
          uint64_t v27 = (_DWORD *)(v21 + 12 * v20);
          unsigned int v26 = v27[1];
          int v23 = v13 - *v27;
LABEL_35:
          unsigned int v28 = v26 & 0xFF807FFF | (v23 << 15);
          *(_DWORD *)(v21 + 12 * v20 + 4) = v28;
          goto LABEL_37;
        case 3uLL:
          uint64_t v21 = *((void *)this + 9);
          uint64_t v29 = (_DWORD *)(v21 + 12 * v20);
          unsigned int v28 = v29[1];
          int v23 = v13 - *v29;
LABEL_37:
          *(_DWORD *)(v21 + 12 * v20 + 4) = v28 & 0x7FFFFF | ((unsigned __int16)v23 << 23);
          goto LABEL_39;
        case 4uLL:
          uint64_t v21 = *((void *)this + 9);
          int v23 = v13 - *(_DWORD *)(v21 + 12 * v20);
LABEL_39:
          uint64_t v30 = v21 + 12 * v20;
          unsigned int v31 = *(_DWORD *)(v30 + 8) & 0xFFFFFE00 | v23 & 0x1FF;
          *(_DWORD *)(v30 + 8) = v31;
          goto LABEL_40;
        case 5uLL:
          uint64_t v21 = *((void *)this + 9);
          BOOL v34 = (_DWORD *)(v21 + 12 * v20);
          unsigned int v31 = v34[2];
          int v23 = v13 - *v34;
LABEL_40:
          unsigned int v32 = v31 & 0xFFFC01FF | ((v23 & 0x1FF) << 9);
          *(_DWORD *)(v21 + 12 * v20 + 8) = v32;
          goto LABEL_41;
        case 6uLL:
          uint64_t v21 = *((void *)this + 9);
          uint64_t v35 = (_DWORD *)(v21 + 12 * v20);
          unsigned int v32 = v35[2];
          int v23 = v13 - *v35;
LABEL_41:
          *(_DWORD *)(v21 + 12 * v20 + 8) = v32 & 0xF803FFFF | ((v23 & 0x1FF) << 18);
          break;
        default:
          break;
      }
    }
  }
  else
  {
    int v13 = 0;
  }
  *((void *)this + 6) = v11;
  *((void *)this + 7) = *((void *)a2 + 7);
  *(_DWORD *)(*((void *)this + 9) + 12 * *((void *)this + 11) - 12) = v13;
  if (a3)
  {
    int v36 = *((void *)a2 + 6);
    marisa::grimoire::vector::Vector<unsigned int>::push_back((uint64_t *)this + 14, &v36);
    marisa::grimoire::vector::Vector<unsigned int>::shrink((_DWORD *)this + 28);
  }
  if (a4)
  {
    uint64_t v33 = (uint64_t *)((char *)this + 160);
    int v36 = *((void *)a2 + 6);
    marisa::grimoire::vector::Vector<unsigned int>::push_back(v33, &v36);
    marisa::grimoire::vector::Vector<unsigned int>::shrink(v33);
  }
}

uint64_t *marisa::grimoire::vector::Vector<unsigned int>::push_back(uint64_t *result, _DWORD *a2)
{
  unint64_t v3 = result;
  uint64_t v4 = result[3];
  unint64_t v5 = result[4];
  unint64_t v6 = v4 + 1;
  if (v5 < v4 + 1)
  {
    uint64_t v7 = 2 * v5;
    if (v5 >> 61) {
      uint64_t v7 = 0x3FFFFFFFFFFFFFFFLL;
    }
    if (v5 <= v6 >> 1) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = v7;
    }
    uint64_t result = (uint64_t *)marisa::grimoire::vector::Vector<unsigned int>::realloc(result, v8);
    uint64_t v4 = v3[3];
    unint64_t v6 = v4 + 1;
  }
  *(_DWORD *)(v3[1] + 4 * v4) = *a2;
  v3[3] = v6;
  return result;
}

_DWORD *marisa::grimoire::vector::Vector<unsigned int>::shrink(_DWORD *result)
{
  if (*((unsigned char *)result + 40))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/vector/vector.h";
    exception[2] = 0x100000064;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/grimoire/vector/vector.h:100: MARISA_STATE_ERROR: fixed_";
  }
  uint64_t v1 = *((void *)result + 3);
  if (v1 != *((void *)result + 4))
  {
    return marisa::grimoire::vector::Vector<unsigned int>::realloc((uint64_t *)result, v1);
  }
  return result;
}

double marisa::Keyset::Keyset(marisa::Keyset *this)
{
  *((void *)this + 12) = 0;
  double result = 0.0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

size_t marisa::Keyset::push_back(size_t *a1, uint64_t a2)
{
  size_t result = marisa::Keyset::reserve(a1, *(unsigned int *)(a2 + 8));
  if (*(_DWORD *)(a2 + 8))
  {
    unint64_t v5 = 0;
    do
    {
      *(unsigned char *)(result + vmarisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = *(unsigned char *)(*(void *)a2 + v5);
      ++v5;
      unint64_t v6 = *(unsigned int *)(a2 + 8);
    }
    while (v5 < v6);
    int v7 = *(_DWORD *)(a2 + 8);
  }
  else
  {
    int v7 = 0;
    unint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(a1[6] + ((a1[11] >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * a1[11];
  *(void *)uint64_t v8 = result;
  *(_DWORD *)(v8 + 8) = v7;
  *(_DWORD *)(v8 + 12) = *(_DWORD *)(a2 + 12);
  size_t v9 = a1[12] + v6;
  ++a1[11];
  a1[12] = v9;
  return result;
}

size_t marisa::Keyset::reserve(size_t *this, size_t __sz)
{
  if (this[7] == this[11] >> 8) {
    marisa::Keyset::append_key_block((marisa::Keyset *)this);
  }
  if (__sz < 0x401)
  {
    size_t v5 = this[10];
    if (v5 < __sz)
    {
      marisa::Keyset::append_base_block((uint64_t *)this);
      size_t v5 = this[10];
    }
    size_t result = this[9];
    this[9] = result + __sz;
    this[10] = v5 - __sz;
  }
  else
  {
    marisa::Keyset::append_extra_block((marisa::Keyset *)this, __sz);
    return *(void *)(this[3] + 8 * this[4] - 8);
  }
  return result;
}

size_t marisa::Keyset::push_back(marisa::Keyset *this, uint64_t a2, char a3)
{
  if (*((void *)this + 7) == *((void *)this + 11) >> 8) {
    marisa::Keyset::append_key_block(this);
  }
  size_t result = marisa::Keyset::reserve((size_t *)this, *(unsigned int *)(a2 + 8) + 1);
  if (*(_DWORD *)(a2 + 8))
  {
    unint64_t v7 = 0;
    do
    {
      *(unsigned char *)(result + v7) = *(unsigned char *)(*(void *)a2 + v7);
      ++v7;
      unint64_t v8 = *(unsigned int *)(a2 + 8);
    }
    while (v7 < v8);
  }
  else
  {
    unint64_t v8 = 0;
  }
  *(unsigned char *)(result + v8) = a3;
  uint64_t v9 = *(void *)(*((void *)this + 6) + ((*((void *)this + 11) >> 5) & 0x7FFFFFFFFFFFFF8))
     + 16 * *((void *)this + 11);
  uint64_t v10 = *(unsigned int *)(a2 + 8);
  *(void *)uint64_t v9 = result;
  *(_DWORD *)(v9 + 8) = v10;
  *(_DWORD *)(v9 + 12) = *(_DWORD *)(a2 + 12);
  uint64_t v11 = *((void *)this + 12) + v10;
  ++*((void *)this + 11);
  *((void *)this + 12) = v11;
  return result;
}

uint64_t marisa::Keyset::append_key_block(marisa::Keyset *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2 == *((void *)this + 8))
  {
    if (v2) {
      unint64_t v3 = 2 * v2;
    }
    else {
      unint64_t v3 = 1;
    }
    BOOL v4 = v3 >> 61 != 0;
    if (8 * v3 >= 0xFFFFFFFFFFFFFFF0) {
      BOOL v4 = 1;
    }
    if (v4) {
      size_t v5 = -1;
    }
    else {
      size_t v5 = 8 * v3 + 16;
    }
    unint64_t v6 = operator new[](v5, MEMORY[0x1E4FBA2D0]);
    if (!v6)
    {
      uint64_t v20 = 0;
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      exception[2] = 0x8000000A9;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:169: MARISA_MEMORY_ERROR: new_blo"
                     "cks.get() == NULL";
    }
    *unint64_t v6 = 8;
    v6[1] = v3;
    uint64_t v7 = (uint64_t)(v6 + 2);
    if (v3) {
      bzero(v6 + 2, 8 * v3);
    }
    uint64_t v20 = v7;
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
      {
        uint64_t v9 = *((void *)this + 6);
        uint64_t v10 = v20;
        uint64_t v11 = *(void *)(v9 + 8 * i);
        *(void *)(v9 + 8 * i) = *(void *)(v20 + 8 * i);
        *(void *)(v10 + 8 * i) = v11;
      }
      uint64_t v7 = v20;
    }
    uint64_t v12 = *((void *)this + 6);
    *((void *)this + 6) = v7;
    uint64_t v20 = v12;
    *((void *)this + 8) = v3;
    marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array(&v20);
  }
  int v13 = operator new[](0x1000uLL, MEMORY[0x1E4FBA2D0]);
  if (!v13)
  {
    unint64_t v18 = __cxa_allocate_exception(0x20uLL);
    void *v18 = &unk_1F2DE3CA8;
    v18[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    void v18[2] = 0x8000000B1;
    _OWORD v18[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:177: MARISA_MEMORY_ERROR: new_block.get() == NULL";
  }
  __int16 v14 = v13;
  bzero(v13, 0x1000uLL);
  uint64_t v16 = *((void *)this + 6);
  uint64_t v15 = *((void *)this + 7);
  *((void *)this + 7) = v15 + 1;
  uint64_t result = *(void *)(v16 + 8 * v15);
  *(void *)(v16 + 8 * v1marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = v14;
  if (result) {
    return MEMORY[0x1D9455390](result, 0x1050C80717B85FCLL);
  }
  return result;
}

void sub_1D593A67C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array((uint64_t *)va);
  _Unwind_Resume(a1);
}

size_t marisa::Keyset::push_back(size_t *this, const char *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    exception[2] = 0x200000032;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:50: MARISA_NULL_ERROR: str == NULL";
  }
  uint64_t v2 = 0;
  while (a2[v2++])
    ;

  return marisa::Keyset::push_back(this, a2, v2 - 1, 1.0);
}

size_t marisa::Keyset::push_back(size_t *this, const char *a2, size_t __sz, float a4)
{
  unint64_t v6 = a2;
  if (!a2 && __sz)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    exception[2] = 0x20000003DLL;
    uint64_t v15 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:61: MARISA_NULL_ERROR: (ptr == NULL) && (length != 0)";
    goto LABEL_10;
  }
  if (HIDWORD(__sz))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    exception[2] = 0x70000003ELL;
    uint64_t v15 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:62: MARISA_SIZE_ERROR: length > MARISA_UINT32_MAX";
LABEL_10:
    exception[3] = v15;
  }
  size_t result = marisa::Keyset::reserve(this, __sz);
  if (__sz)
  {
    uint64_t v9 = (unsigned char *)result;
    size_t v10 = __sz;
    do
    {
      char v11 = *v6++;
      *v9++ = v11;
      --v10;
    }
    while (v10);
  }
  uint64_t v12 = *(void *)(this[6] + ((this[11] >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * this[11];
  *(void *)uint64_t v12 = result;
  *(_DWORD *)(v12 + 8) = __sz;
  *(float *)(v12 + 12) = a4;
  size_t v13 = this[12] + __sz;
  ++this[11];
  this[12] = v13;
  return result;
}

double marisa::Keyset::reset(marisa::Keyset *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  return result;
}

uint64_t *marisa::Keyset::clear(marisa::Keyset *this)
{
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  memset(v2, 0, sizeof(v2));
  marisa::Keyset::swap((uint64_t *)v2, this);
  marisa::scoped_array<marisa::scoped_array<marisa::Key>>::~scoped_array((uint64_t *)v3);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)&v2[1] + 1);
  return marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)v2);
}

uint64_t *marisa::Keyset::swap(uint64_t *this, marisa::Keyset *a2)
{
  uint64_t v2 = *this;
  uint64_t v3 = this[1];
  uint64_t v4 = *((void *)a2 + 1);
  *this = *(void *)a2;
  this[1] = v4;
  *(void *)a2 = v2;
  *((void *)a2 + 1) = v3;
  uint64_t v5 = this[2];
  uint64_t v6 = this[3];
  uint64_t v7 = *((void *)a2 + 3);
  this[2] = *((void *)a2 + 2);
  this[3] = v7;
  *((void *)a2 + 2) = v5;
  *((void *)a2 + 3) = v6;
  uint64_t v8 = this[4];
  this[4] = *((void *)a2 + 4);
  *((void *)a2 + 4) = v8;
  uint64_t v9 = this[5];
  uint64_t v10 = this[6];
  uint64_t v11 = *((void *)a2 + 6);
  this[5] = *((void *)a2 + 5);
  this[6] = v11;
  *((void *)a2 + marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = v9;
  *((void *)a2 + 6) = v10;
  uint64_t v12 = this[7];
  this[7] = *((void *)a2 + 7);
  *((void *)a2 + 7) = v12;
  uint64_t v13 = this[8];
  uint64_t v14 = this[9];
  uint64_t v15 = *((void *)a2 + 9);
  this[8] = *((void *)a2 + 8);
  this[9] = v15;
  *((void *)a2 + 8) = v13;
  *((void *)a2 + 9) = v14;
  uint64_t v16 = this[10];
  this[10] = *((void *)a2 + 10);
  *((void *)a2 + 10) = v16;
  uint64_t v17 = this[11];
  this[11] = *((void *)a2 + 11);
  *((void *)a2 + 11) = v17;
  uint64_t v18 = this[12];
  this[12] = *((void *)a2 + 12);
  *((void *)a2 + 12) = v18;
  return this;
}

void *marisa::Keyset::append_extra_block(marisa::Keyset *this, size_t __sz)
{
  uint64_t v4 = *((void *)this + 4);
  if (v4 == *((void *)this + 5))
  {
    if (v4) {
      unint64_t v5 = 2 * v4;
    }
    else {
      unint64_t v5 = 1;
    }
    BOOL v6 = v5 >> 61 != 0;
    if (8 * v5 >= 0xFFFFFFFFFFFFFFF0) {
      BOOL v6 = 1;
    }
    if (v6) {
      size_t v7 = -1;
    }
    else {
      size_t v7 = 8 * v5 + 16;
    }
    uint64_t v8 = operator new[](v7, MEMORY[0x1E4FBA2D0]);
    if (!v8)
    {
      uint64_t v21 = 0;
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      exception[2] = 0x800000097;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:151: MARISA_MEMORY_ERROR: new_blo"
                     "cks.get() == NULL";
    }
    *uint64_t v8 = 8;
    v8[1] = v5;
    uint64_t v9 = (uint64_t)(v8 + 2);
    if (v5) {
      bzero(v8 + 2, 8 * v5);
    }
    uint64_t v21 = v9;
    if (v4)
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        uint64_t v11 = *((void *)this + 3);
        uint64_t v12 = v21;
        uint64_t v13 = *(void *)(v11 + 8 * i);
        *(void *)(v11 + 8 * i) = *(void *)(v21 + 8 * i);
        *(void *)(v12 + 8 * i) = v13;
      }
      uint64_t v9 = v21;
    }
    uint64_t v14 = *((void *)this + 3);
    *((void *)this + 3) = v9;
    uint64_t v21 = v14;
    *((void *)this + marisa::scoped_ptr<marisa::grimoire::trie::State>::~scoped_ptr((void *)this + 5) = v5;
    marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(&v21);
  }
  double result = operator new[](__sz, MEMORY[0x1E4FBA2D0]);
  if (!result)
  {
    unsigned int v19 = __cxa_allocate_exception(0x20uLL);
    void *v19 = &unk_1F2DE3CA8;
    v19[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
    v19[2] = 0x80000009FLL;
    _OWORD v19[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:159: MARISA_MEMORY_ERROR: new_block.get() == NULL";
  }
  uint64_t v17 = *((void *)this + 3);
  uint64_t v16 = *((void *)this + 4);
  *((void *)this + 4) = v16 + 1;
  uint64_t v18 = *(void *)(v17 + 8 * v16);
  *(void *)(v17 + 8 * v16) = result;
  if (v18) {
    return (void *)MEMORY[0x1D9455390](v18, 0x1000C8077774924);
  }
  return result;
}

void sub_1D593AB84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *marisa::Keyset::append_base_block(uint64_t *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[1];
  if (v2 == this[2])
  {
    if (v2) {
      unint64_t v3 = 2 * v2;
    }
    else {
      unint64_t v3 = 1;
    }
    BOOL v4 = v3 >> 61 != 0;
    if (8 * v3 >= 0xFFFFFFFFFFFFFFF0) {
      BOOL v4 = 1;
    }
    if (v4) {
      size_t v5 = -1;
    }
    else {
      size_t v5 = 8 * v3 + 16;
    }
    BOOL v6 = operator new[](v5, MEMORY[0x1E4FBA2D0]);
    if (!v6)
    {
      uint64_t v16 = 0;
      exception = __cxa_allocate_exception(0x20uLL);
      void *exception = &unk_1F2DE3CA8;
      exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      exception[2] = 0x800000081;
      exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:129: MARISA_MEMORY_ERROR: new_blo"
                     "cks.get() == NULL";
    }
    *BOOL v6 = 8;
    v6[1] = v3;
    uint64_t v7 = (uint64_t)(v6 + 2);
    if (v3) {
      bzero(v6 + 2, 8 * v3);
    }
    uint64_t v16 = v7;
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
      {
        uint64_t v9 = v16;
        uint64_t v10 = *(void *)(*v1 + 8 * i);
        *(void *)(*v1 + 8 * i) = *(void *)(v16 + 8 * i);
        *(void *)(v9 + 8 * i) = v10;
      }
      uint64_t v7 = v16;
    }
    uint64_t v11 = *v1;
    *uint64_t v1 = v7;
    uint64_t v16 = v11;
    v1[2] = v3;
    this = marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array(&v16);
    uint64_t v2 = v1[1];
  }
  uint64_t v12 = *v1;
  uint64_t v13 = *(void *)(*v1 + 8 * v2);
  if (!v13)
  {
    this = (uint64_t *)operator new[](0x1000uLL, MEMORY[0x1E4FBA2D0]);
    if (!this)
    {
      uint64_t v15 = __cxa_allocate_exception(0x20uLL);
      *uint64_t v15 = &unk_1F2DE3CA8;
      v15[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc";
      v15[2] = 0x80000008ALL;
      v15[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/keyset.cc:138: MARISA_MEMORY_ERROR: new_block.get() == NULL";
    }
    *(void *)(v12 + 8 * v2) = this;
    uint64_t v13 = *(void *)(*v1 + 8 * v2);
  }
  v1[1] = v2 + 1;
  v1[9] = v13;
  v1[10] = 4096;
  return this;
}

void sub_1D593AD88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  marisa::scoped_array<marisa::scoped_array<char>>::~scoped_array((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *marisa::Trie::Trie(void *this)
{
  *this = 0;
  return this;
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::build(marisa::grimoire::trie::LoudsTrie **this, marisa::Keyset *a2, unsigned int a3)
{
  BOOL v6 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
  if (!v6)
  {
    uint64_t v11 = 0;
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x80000000ELL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:14: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  uint64_t v7 = v6;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v6);
  uint64_t v11 = v7;
  marisa::grimoire::trie::LoudsTrie::build(v7, a2, a3);
  uint64_t v8 = *this;
  *this = v7;
  uint64_t v11 = v8;
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
}

void sub_1D593AE90(_Unwind_Exception *a1)
{
  MEMORY[0x1D94553B0](v1, MEMORY[0x1E4FBA2D0]);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::mmap(marisa::grimoire::trie::LoudsTrie **this, const char *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x200000015;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:21: MARISA_NULL_ERROR: filename == NULL";
  }
  BOOL v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
  if (!v4)
  {
    uint64_t v11 = 0;
    uint64_t v9 = __cxa_allocate_exception(0x20uLL);
    *uint64_t v9 = &unk_1F2DE3CA8;
    v9[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    void v9[2] = 0x800000018;
    _OWORD v9[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:24: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  size_t v5 = v4;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
  uint64_t v11 = v5;
  marisa::grimoire::io::Mapper::Mapper((uint64_t)v10);
  marisa::grimoire::io::Mapper::open((marisa::grimoire::io::Mapper *)v10, a2);
  marisa::grimoire::trie::LoudsTrie::map(v11, (marisa::grimoire::io::Mapper *)v10);
  BOOL v6 = *this;
  *this = v11;
  uint64_t v11 = v6;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)v10);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
}

void sub_1D593B01C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::map(marisa::grimoire::trie::LoudsTrie **this, const void *a2, uint64_t a3)
{
  if (!a2 && a3)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x200000021;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:33: MARISA_NULL_ERROR: (ptr == NULL) && (size != 0)";
  }
  BOOL v6 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
  if (!v6)
  {
    uint64_t v13 = 0;
    uint64_t v11 = __cxa_allocate_exception(0x20uLL);
    void *v11 = &unk_1F2DE3CA8;
    v11[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    void v11[2] = 0x800000024;
    v11[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:36: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  uint64_t v7 = v6;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v6);
  uint64_t v13 = v7;
  marisa::grimoire::io::Mapper::Mapper((uint64_t)v12);
  marisa::grimoire::io::Mapper::open((marisa::grimoire::io::Mapper *)v12, a2, a3);
  marisa::grimoire::trie::LoudsTrie::map(v13, (marisa::grimoire::io::Mapper *)v12);
  uint64_t v8 = *this;
  *this = v13;
  uint64_t v13 = v8;
  marisa::grimoire::io::Mapper::~Mapper((marisa::grimoire::io::Mapper *)v12);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v13);
}

void sub_1D593B1C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::load(marisa::grimoire::trie::LoudsTrie **this, const char *a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x20000002DLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:45: MARISA_NULL_ERROR: filename == NULL";
  }
  BOOL v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
  if (!v4)
  {
    uint64_t v11 = 0;
    uint64_t v9 = __cxa_allocate_exception(0x20uLL);
    *uint64_t v9 = &unk_1F2DE3CA8;
    v9[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    void v9[2] = 0x800000030;
    _OWORD v9[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:48: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  size_t v5 = v4;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
  uint64_t v11 = v5;
  marisa::grimoire::io::Reader::Reader((uint64_t)v10);
  marisa::grimoire::io::Reader::open(v10, a2);
  marisa::grimoire::trie::LoudsTrie::read(v11, (marisa::grimoire::io::Reader *)v10);
  BOOL v6 = *this;
  *this = v11;
  uint64_t v11 = v6;
  marisa::grimoire::io::Reader::~Reader(v10);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
}

void sub_1D593B368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::read(marisa::grimoire::trie::LoudsTrie **this, int a2)
{
  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x500000039;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:57: MARISA_CODE_ERROR: fd == -1";
  }
  BOOL v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
  if (!v4)
  {
    uint64_t v11 = 0;
    uint64_t v9 = __cxa_allocate_exception(0x20uLL);
    *uint64_t v9 = &unk_1F2DE3CA8;
    v9[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    void v9[2] = 0x80000003CLL;
    _OWORD v9[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:60: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  size_t v5 = v4;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
  uint64_t v11 = v5;
  marisa::grimoire::io::Reader::Reader((uint64_t)v10);
  marisa::grimoire::io::Reader::open(v10, a2);
  marisa::grimoire::trie::LoudsTrie::read(v11, (marisa::grimoire::io::Reader *)v10);
  BOOL v6 = *this;
  *this = v11;
  uint64_t v11 = v6;
  marisa::grimoire::io::Reader::~Reader(v10);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
}

void sub_1D593B50C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

void marisa::Trie::save(marisa::grimoire::trie::LoudsTrie ***this, const char *a2)
{
  if (!*this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000045;
    size_t v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:69: MARISA_STATE_ERROR: trie_.get() == NULL";
    goto LABEL_6;
  }
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x200000046;
    size_t v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:70: MARISA_NULL_ERROR: filename == NULL";
LABEL_6:
    exception[3] = v5;
  }
  marisa::grimoire::io::Reader::Reader((uint64_t)v6);
  marisa::grimoire::io::Writer::open(v6, a2);
  marisa::grimoire::trie::LoudsTrie::write(*this, (marisa::grimoire::io::Writer *)v6);
  marisa::grimoire::io::Reader::~Reader(v6);
}

void sub_1D593B650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, FILE *a9)
{
}

void marisa::Trie::write(marisa::grimoire::trie::LoudsTrie ***this, int a2)
{
  if (!*this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x10000004ELL;
    size_t v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:78: MARISA_STATE_ERROR: trie_.get() == NULL";
    goto LABEL_6;
  }
  if (a2 == -1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x50000004FLL;
    size_t v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:79: MARISA_CODE_ERROR: fd == -1";
LABEL_6:
    exception[3] = v5;
  }
  marisa::grimoire::io::Reader::Reader((uint64_t)v6);
  marisa::grimoire::io::Writer::open(v6, a2);
  marisa::grimoire::trie::LoudsTrie::write(*this, (marisa::grimoire::io::Writer *)v6);
  marisa::grimoire::io::Reader::~Reader(v6);
}

void sub_1D593B76C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, FILE *a9)
{
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::lookup(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  double result = *this;
  if (result)
  {
    if (!*((void *)a2 + 5))
    {
      marisa::Agent::init_state(a2);
      double result = *this;
    }
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::lookup(result, a2);
  }
  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::reverse_lookup(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  double result = *this;
  if (result)
  {
    if (!*((void *)a2 + 5))
    {
      marisa::Agent::init_state(a2);
      double result = *this;
    }
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::reverse_lookup(result, a2);
  }
  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::common_prefix_search(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  double result = *this;
  if (result)
  {
    if (!*((void *)a2 + 5))
    {
      marisa::Agent::init_state(a2);
      double result = *this;
    }
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::common_prefix_search(result, a2);
  }
  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::predictive_search(marisa::grimoire::trie::LoudsTrie **this, marisa::Agent *a2)
{
  double result = *this;
  if (result)
  {
    if (!*((void *)a2 + 5))
    {
      marisa::Agent::init_state(a2);
      double result = *this;
    }
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::predictive_search(result, a2);
  }
  return result;
}

uint64_t marisa::Trie::num_tries(marisa::Trie *this)
{
  if (*(void *)this) {
    return *(void *)(*(void *)this + 1072);
  }
  else {
    return 0;
  }
}

uint64_t marisa::Trie::num_keys(marisa::Trie *this)
{
  if (*(void *)this) {
    return *(void *)(*(void *)this + 264);
  }
  else {
    return 0;
  }
}

uint64_t marisa::Trie::num_nodes(marisa::Trie *this)
{
  if (*(void *)this) {
    return (*(void *)(*(void *)this + 48) >> 1) - 1;
  }
  else {
    return 0;
  }
}

uint64_t marisa::Trie::tail_mode(marisa::Trie *this)
{
  if (!*(void *)this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x100000086;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:134: MARISA_STATE_ERROR: trie_.get() == NULL";
  }
  return *(unsigned int *)(*(void *)this + 1084);
}

uint64_t marisa::Trie::node_order(marisa::Trie *this)
{
  if (!*(void *)this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x10000008BLL;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:139: MARISA_STATE_ERROR: trie_.get() == NULL";
  }
  return *(unsigned int *)(*(void *)this + 1088);
}

BOOL marisa::Trie::empty(marisa::Trie *this)
{
  return !*(void *)this || *(void *)(*(void *)this + 264) == 0;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::total_size(marisa::grimoire::trie::LoudsTrie **this)
{
  double result = *this;
  if (result) {
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::total_size(result);
  }
  return result;
}

marisa::grimoire::trie::LoudsTrie *marisa::Trie::io_size(marisa::grimoire::trie::LoudsTrie **this)
{
  double result = *this;
  if (result) {
    return (marisa::grimoire::trie::LoudsTrie *)marisa::grimoire::trie::LoudsTrie::io_size(result);
  }
  return result;
}

marisa::grimoire::trie::LoudsTrie **marisa::Trie::clear(marisa::grimoire::trie::LoudsTrie **this)
{
  uint64_t v2 = *this;
  *this = 0;
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v2);
}

uint64_t *marisa::Trie::swap(uint64_t *this, marisa::Trie *a2)
{
  uint64_t v2 = *this;
  *this = *(void *)a2;
  *(void *)a2 = v2;
  return this;
}

marisa::grimoire::trie::LoudsTrie **marisa::fread(__sFILE *this, __sFILE *a2, marisa::Trie *a3)
{
  if (!this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000DELL;
    size_t v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:222: MARISA_NULL_ERROR: file == NULL";
    goto LABEL_8;
  }
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000DFLL;
    size_t v5 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:223: MARISA_NULL_ERROR: trie == NULL";
LABEL_8:
    exception[3] = v5;
  }

  return marisa::TrieIO::fread(this, a2, a3);
}

marisa::grimoire::trie::LoudsTrie **marisa::TrieIO::fread(__sFILE *this, __sFILE *a2, marisa::Trie *a3)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000B4;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:180: MARISA_NULL_ERROR: trie == NULL";
  }
  size_t v5 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
  if (!v5)
  {
    uint64_t v12 = 0;
    uint64_t v10 = __cxa_allocate_exception(0x20uLL);
    *uint64_t v10 = &unk_1F2DE3CA8;
    v10[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    v10[2] = 0x8000000B8;
    v10[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:184: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  BOOL v6 = v5;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v5);
  uint64_t v12 = v6;
  marisa::grimoire::io::Reader::Reader((uint64_t)v11);
  marisa::grimoire::io::Reader::open(v11, this);
  marisa::grimoire::trie::LoudsTrie::read(v12, (marisa::grimoire::io::Reader *)v11);
  p = a2->_p;
  a2->_p = (unsigned __int8 *)v12;
  uint64_t v12 = (marisa::grimoire::trie::LoudsTrie *)p;
  marisa::grimoire::io::Reader::~Reader(v11);
  return marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v12);
}

void sub_1D593BD04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

void marisa::fwrite(__sFILE *this, __sFILE *a2, const marisa::Trie *a3)
{
  if (!this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000E4;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:228: MARISA_NULL_ERROR: file == NULL";
  }
  marisa::TrieIO::fwrite(this, a2, a3);
}

void marisa::TrieIO::fwrite(__sFILE *this, __sFILE *a2, const marisa::Trie *a3)
{
  if (!this)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000C0;
    BOOL v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:192: MARISA_NULL_ERROR: file == NULL";
    goto LABEL_6;
  }
  if (!a2->_p)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x1000000C1;
    BOOL v6 = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:193: MARISA_STATE_ERROR: trie.trie_.get() == NULL";
LABEL_6:
    exception[3] = v6;
  }
  marisa::grimoire::io::Reader::Reader((uint64_t)v7);
  marisa::grimoire::io::Writer::open(v7, this);
  marisa::grimoire::trie::LoudsTrie::write((marisa::grimoire::trie::LoudsTrie **)a2->_p, (marisa::grimoire::io::Writer *)v7);
  marisa::grimoire::io::Reader::~Reader(v7);
}

void sub_1D593BEC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, FILE *a9)
{
}

uint64_t marisa::read(uint64_t a1, marisa::grimoire::trie::LoudsTrie **a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000E9;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:233: MARISA_NULL_ERROR: trie == NULL";
  }
  return marisa::TrieIO::read(a1, a2);
}

uint64_t marisa::TrieIO::read(uint64_t a1, marisa::grimoire::trie::LoudsTrie **a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x2000000C8;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:200: MARISA_NULL_ERROR: trie == NULL";
  }
  BOOL v4 = (marisa::grimoire::trie::LoudsTrie *)operator new(0x470uLL, MEMORY[0x1E4FBA2D0]);
  if (!v4)
  {
    uint64_t v11 = 0;
    uint64_t v9 = __cxa_allocate_exception(0x20uLL);
    *uint64_t v9 = &unk_1F2DE3CA8;
    v9[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    void v9[2] = 0x8000000CCLL;
    _OWORD v9[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:204: MARISA_MEMORY_ERROR: temp.get() == NULL";
  }
  size_t v5 = v4;
  marisa::grimoire::trie::LoudsTrie::LoudsTrie(v4);
  uint64_t v11 = v5;
  marisa::grimoire::io::Reader::Reader((uint64_t)v10);
  marisa::grimoire::io::Reader::open((uint64_t)v10, a1);
  marisa::grimoire::trie::LoudsTrie::read(v11, (marisa::grimoire::io::Reader *)v10);
  BOOL v6 = *a2;
  *a2 = v11;
  uint64_t v11 = v6;
  marisa::grimoire::io::Reader::~Reader(v10);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr(&v11);
  return a1;
}

void sub_1D593C0C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  marisa::scoped_ptr<marisa::grimoire::trie::LoudsTrie>::~scoped_ptr((marisa::grimoire::trie::LoudsTrie **)va);
  _Unwind_Resume(a1);
}

uint64_t marisa::TrieIO::write(uint64_t a1, marisa::grimoire::trie::LoudsTrie ***a2)
{
  if (!*a2)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &unk_1F2DE3CA8;
    exception[1] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc";
    exception[2] = 0x1000000D5;
    exception[3] = "/Library/Caches/com.apple.xbs/Sources/Marisa/lib/marisa/trie.cc:213: MARISA_STATE_ERROR: trie.trie_.get() == NULL";
  }
  marisa::grimoire::io::Reader::Reader((uint64_t)v6);
  marisa::grimoire::io::Reader::open((uint64_t)v6, a1);
  marisa::grimoire::trie::LoudsTrie::write(*a2, (marisa::grimoire::io::Writer *)v6);
  marisa::grimoire::io::Reader::~Reader(v6);
  return a1;
}

void sub_1D593C1C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, FILE *a9)
{
}

void DCSEnvironment::createDictionariesCacheURL()
{
  __assert_rtn("createDictionariesCacheURL", "DCSEnvironment.cpp", 2194, "CFArrayGetCount(pathArray) != 0");
}

void HeapAccessContext::getDataByID(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  int v4 = 134218496;
  uint64_t v5 = a2;
  __int16 v6 = 2048;
  uint64_t v7 = v3;
  __int16 v8 = 2048;
  uint64_t v9 = a3;
  _os_log_error_impl(&dword_1D58FF000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "HeapAccessContext: Error: originalDataSize: %ld, dataSize: %ld, maxLength: %ld", (uint8_t *)&v4, 0x20u);
}

uint64_t ADClientAddValueForScalarKey()
{
  return MEMORY[0x1F41071E0]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

CFGregorianDate CFAbsoluteTimeGetGregorianDate(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  uint64_t v2 = MEMORY[0x1F40D70D8](tz, at);
  result.second = v3;
  result.year = v2;
  result.month = BYTE4(v2);
  result.day = BYTE5(v2);
  result.hour = BYTE6(v2);
  result.minute = HIBYTE(v2);
  return result;
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D7160](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7178](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7198](allocator, capacity, theArray);
}

void CFArrayExchangeValuesAtIndices(CFMutableArrayRef theArray, CFIndex idx1, CFIndex idx2)
{
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D71C8](theArray, range.location, range.length, value);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

CFArrayRef CFBundleCopyBundleLocalizations(CFBundleRef bundle)
{
  return (CFArrayRef)MEMORY[0x1F40D7448](bundle);
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1F40D7450](bundle);
}

CFDictionaryRef CFBundleCopyInfoDictionaryInDirectory(CFURLRef bundleURL)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7480](bundleURL);
}

CFArrayRef CFBundleCopyLocalizationsForPreferences(CFArrayRef locArray, CFArrayRef prefArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7490](locArray, prefArray);
}

CFArrayRef CFBundleCopyPreferredLocalizationsFromArray(CFArrayRef locArray)
{
  return (CFArrayRef)MEMORY[0x1F40D74C0](locArray);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1F40D74D0](bundle, resourceName, resourceType, subDirName);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x1F40D7528](allocator, bundleURL);
}

CFArrayRef CFBundleCreateBundlesFromDirectory(CFAllocatorRef allocator, CFURLRef directoryURL, CFStringRef bundleType)
{
  return (CFArrayRef)MEMORY[0x1F40D7530](allocator, directoryURL, bundleType);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1F40D7538](bundleID);
}

void *__cdecl CFBundleGetDataPointerForName(CFBundleRef bundle, CFStringRef symbolName)
{
  return (void *)MEMORY[0x1F40D7548](bundle, symbolName);
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  return (void *)MEMORY[0x1F40D7558](bundle, functionName);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1F40D7568](bundle);
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7578](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1F40D7598]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40D75D0](bundle, key);
}

Boolean CFBundleIsExecutableLoaded(CFBundleRef bundle)
{
  return MEMORY[0x1F40D75E0](bundle);
}

Boolean CFBundleLoadExecutable(CFBundleRef bundle)
{
  return MEMORY[0x1F40D75E8](bundle);
}

void CFCharacterSetAddCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
}

CFCharacterSetRef CFCharacterSetCreateInvertedSet(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7710](alloc, theSet);
}

CFMutableCharacterSetRef CFCharacterSetCreateMutable(CFAllocatorRef alloc)
{
  return (CFMutableCharacterSetRef)MEMORY[0x1F40D7718](alloc);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7738](alloc, theString);
}

Boolean CFCharacterSetIsSupersetOfSet(CFCharacterSetRef theSet, CFCharacterSetRef theOtherset)
{
  return MEMORY[0x1F40D7780](theSet, theOtherset);
}

uint64_t CFCopyHomeDirectoryURLForUser()
{
  return MEMORY[0x1F40D77B8]();
}

uint64_t CFCopySearchPathForDirectoriesInDomains()
{
  return MEMORY[0x1F40D77C0]();
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7808](allocator, capacity);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1F40D7818](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1F40D7858](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x1F40D78B0](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  return (CFStringRef)MEMORY[0x1F40D78D8](allocator, formatter, at);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1F40D7A80](err);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1F40D7B60](cf);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B68](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  return (CFHTTPMessageRef)MEMORY[0x1F40D52D8](alloc, requestMethod, url, httpVersion);
}

CFIndex CFHTTPMessageGetResponseStatusCode(CFHTTPMessageRef response)
{
  return MEMORY[0x1F40D52E8](response);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1F40D7BA0](cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BB8]();
}

CFArrayRef CFLocaleCopyPreferredLanguages(void)
{
  return (CFArrayRef)MEMORY[0x1F40D7BD8]();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BE0](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLanguageIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7BE8](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7BF8](allocator, localeIdentifier);
}

CFDictionaryRef CFLocaleCreateComponentsFromLocaleIdentifier(CFAllocatorRef allocator, CFLocaleIdentifier localeID)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7C00](allocator, localeID);
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromComponents(CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7C10](allocator, dictionary);
}

CFLocaleIdentifier CFLocaleGetIdentifier(CFLocaleRef locale)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7C20](locale);
}

CFLocaleLanguageDirection CFLocaleGetLanguageCharacterDirection(CFStringRef isoLangCode)
{
  return MEMORY[0x1F40D7C28](isoLangCode);
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)MEMORY[0x1F40D7C48](locale, key);
}

uint64_t CFLog()
{
  return MEMORY[0x1F40D7C50]();
}

CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
{
  return (CFMessagePortRef)MEMORY[0x1F40D7CB8](allocator, name);
}

SInt32 CFMessagePortSendRequest(CFMessagePortRef remote, SInt32 msgid, CFDataRef data, CFTimeInterval sendTimeout, CFTimeInterval rcvTimeout, CFStringRef replyMode, CFDataRef *returnData)
{
  return MEMORY[0x1F40D7CE0](remote, *(void *)&msgid, data, replyMode, returnData, sendTimeout, rcvTimeout);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D08]();
}

CFNotificationCenterRef CFNotificationCenterGetDistributedCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D18]();
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D20]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  return (CFNumberFormatterRef)MEMORY[0x1F40D7D98](allocator, locale, style);
}

CFStringRef CFNumberFormatterCreateStringWithNumber(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberRef number)
{
  return (CFStringRef)MEMORY[0x1F40D7DA8](allocator, formatter, number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E30](number);
}

CFPlugInRef CFPlugInCreate(CFAllocatorRef allocator, CFURLRef plugInURL)
{
  return (CFPlugInRef)MEMORY[0x1F40D7E40](allocator, plugInURL);
}

void *__cdecl CFPlugInInstanceCreate(CFAllocatorRef allocator, CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  return (void *)MEMORY[0x1F40D7E70](allocator, factoryUUID, typeUUID);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40D7F18](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateFromXMLData(CFAllocatorRef allocator, CFDataRef xmlData, CFOptionFlags mutabilityOption, CFStringRef *errorString)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F40](allocator, xmlData, mutabilityOption, errorString);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

CFIndex CFPropertyListWriteToStream(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFStringRef *errorString)
{
  return MEMORY[0x1F40D7F78](propertyList, stream, format, errorString);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFErrorRef CFReadStreamCopyError(CFReadStreamRef stream)
{
  return (CFErrorRef)MEMORY[0x1F40D7F98](stream);
}

CFTypeRef CFReadStreamCopyProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1F40D7FA0](stream, propertyName);
}

CFReadStreamRef CFReadStreamCreateForHTTPRequest(CFAllocatorRef alloc, CFHTTPMessageRef request)
{
  return (CFReadStreamRef)MEMORY[0x1F40D5380](alloc, request);
}

CFStreamError CFReadStreamGetError(CFReadStreamRef stream)
{
  CFIndex v1 = MEMORY[0x1F40D7FD0](stream);
  result.error = v2;
  result.domain = v1;
  return result;
}

Boolean CFReadStreamHasBytesAvailable(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF0](stream);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF8](stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1F40D8000](stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B8]();
}

CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context)
{
  return (CFRunLoopObserverRef)MEMORY[0x1F40D80D8](allocator, activities, repeats, order, callout, context);
}

void CFRunLoopObserverInvalidate(CFRunLoopObserverRef observer)
{
}

void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1F40D81F8](theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return (CFSetRef)MEMORY[0x1F40D8200](allocator, values, numValues, callBacks);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptionsAndLocale(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions, CFLocaleRef locale)
{
  return MEMORY[0x1F40D8398](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions, locale);
}

CFStringEncoding CFStringConvertIANACharSetNameToEncoding(CFStringRef theString)
{
  return MEMORY[0x1F40D83B8](theString);
}

CFArrayRef CFStringCreateArrayWithFindResults(CFAllocatorRef alloc, CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return (CFArrayRef)MEMORY[0x1F40D83D8](alloc, theString, stringToFind, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8400](alloc, data, *(void *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8410](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8440](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1F40D8460](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1F40D8498](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.int64_t length = v4;
  result.CFIndex location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D84D0](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84E0](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptionsAndLocale(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFLocaleRef locale, CFRange *result)
{
  return MEMORY[0x1F40D84E8](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, locale, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1F40D8500](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1F40D8528](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return (const UniChar *)MEMORY[0x1F40D8540](theString);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8558](string, buffer, maxBufLen);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1F40D8608](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

void CFStringNormalize(CFMutableStringRef theString, CFStringNormalizationForm theForm)
{
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringTokenizerRef)MEMORY[0x1F40D8698](alloc, string, range.location, range.length, options, locale);
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  return MEMORY[0x1F40D86C0](string, range, transform, reverse);
}

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D86F8]();
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1F40D8740](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1F40D8758](anURL, pathStyle);
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8768](anURL);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8770](url);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8798](url);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D87F8](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1F40D8808](allocator, url);
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1F40D8810](allocator, url);
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  return MEMORY[0x1F40D8828](alloc, url, resourceData, properties, desiredProperties, errorCode);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D8848](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8870](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(void *)&encoding);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1F40D8878](allocator, originalString, charactersToLeaveEscaped);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88C0](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8918](anURL);
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  return MEMORY[0x1F40D8938](anURL);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return (CFUUIDRef)MEMORY[0x1F40D8998](alloc, uuidStr);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1F40D89A0](alloc, *(void *)&bytes.byte0, *(void *)&bytes.byte8);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x1F40D89D0](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1 = MEMORY[0x1F40D89E8](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)MEMORY[0x1F40D8AB0](alloc, fileURL);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x1F40D8AD0](stream);
}

uint64_t LXLemmatizerCreate()
{
  return MEMORY[0x1F412A718]();
}

uint64_t LXLemmatizerEnumerateLemmasforString()
{
  return MEMORY[0x1F412A720]();
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithName(CFAllocatorRef allocator, const char *nodename)
{
  return (SCNetworkReachabilityRef)MEMORY[0x1F4101EF8](allocator, nodename);
}

Boolean SCNetworkReachabilityGetFlags(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags *flags)
{
  return MEMORY[0x1F4101F08](target, flags);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

uint64_t _CFStringTokenizerTokenize()
{
  return MEMORY[0x1F40D9198]();
}

uint64_t _CFStringTokenizerTokenizeCompoundWord()
{
  return MEMORY[0x1F40D91A0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1F417E3A8]();
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

uint64_t std::istream::read()
{
  return MEMORY[0x1F417E768]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x1F417E840]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1F417E940]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete(void *__p, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new[](size_t __sz, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1F40CA210](a1, *(void *)&a2);
}

void asl_free(asl_object_t obj)
{
}

int asl_log(asl_object_t client, asl_object_t msg, int level, const char *format, ...)
{
  return MEMORY[0x1F40CA408](client, msg, *(void *)&level, format);
}

asl_object_t asl_new(uint32_t type)
{
  return (asl_object_t)MEMORY[0x1F40CA410](*(void *)&type);
}

int asl_set(asl_object_t obj, const char *key, const char *value)
{
  return MEMORY[0x1F40CA428](obj, key, value);
}

void bzero(void *a1, size_t a2)
{
}

BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)
{
  return MEMORY[0x1F41814C0](cls, name, size, alignment, types);
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  return MEMORY[0x1F41814C8](cls, name, imp, types);
}

Ivar class_getInstanceVariable(Class cls, const char *name)
{
  return (Ivar)MEMORY[0x1F4181538](cls, name);
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1F40CB400](a1);
}

int compress2(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level)
{
  return MEMORY[0x1F4182BB0](dest, destLen, source, sourceLen, *(void *)&level);
}

uLong compressBound(uLong sourceLen)
{
  return MEMORY[0x1F4182BB8](sourceLen);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1F40CC0C8](a1);
}

int flock(int a1, int a2)
{
  return MEMORY[0x1F40CC160](*(void *)&a1, *(void *)&a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC200](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1F40CC2F0](*(void *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

IMP imp_implementationWithBlock(id block)
{
  return (IMP)MEMORY[0x1F4181598](block);
}

long double log2(long double __x)
{
  MEMORY[0x1F40CC8A8](__x);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1F40CC8F8](*(void *)&a1, a2, *(void *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CC900](a1, a2);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1F40CCDD0](a1, a2);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int msync(void *a1, size_t a2, int a3)
{
  return MEMORY[0x1F40CCE78](a1, a2, *(void *)&a3);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x1F4181650](superclass, name, extraBytes);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

void objc_disposeClassPair(Class cls)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F4181798](a1, a2);
}

id objc_msgSendSuper(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A0](a1, a2);
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

void objc_registerClassPair(Class cls)
{
}

void objc_release(id a1)
{
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x1F4181A58](a1);
}

Ivar object_getInstanceVariable(id obj, const char *name, void **outValue)
{
  return (Ivar)MEMORY[0x1F4181A70](obj, name, outValue);
}

id object_getIvar(id a1, Ivar a2)
{
  return (id)MEMORY[0x1F4181A78](a1, a2);
}

Ivar object_setInstanceVariableWithStrongDefault(id obj, const char *name, void *value)
{
  return (Ivar)MEMORY[0x1F4181AA0](obj, name, value);
}

void object_setIvar(id obj, Ivar ivar, id value)
{
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1F40CD120](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1F40CD650]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA78](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1F40CDA80](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_trylock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA90](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1F40CDAC8](a1, a2);
}

int pthread_rwlock_destroy(pthread_rwlock_t *a1)
{
  return MEMORY[0x1F40CDAE8](a1);
}

int pthread_rwlock_init(pthread_rwlock_t *a1, const pthread_rwlockattr_t *a2)
{
  return MEMORY[0x1F40CDAF0](a1, a2);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1F40CDAF8](a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1F40CDB10](a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1F40CDB18](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1F40CDC50](*(void *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1F40CDC60](a1);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return MEMORY[0x1F40CDD10](__p, __ec);
}

int rmdir(const char *a1)
{
  return MEMORY[0x1F40CDD90](a1);
}

SEL sel_getUid(const char *str)
{
  return (SEL)MEMORY[0x1F4181B30](str);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1A8](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE230](__s, *(void *)&__c);
}

uint64_t ucsdet_close()
{
  return MEMORY[0x1F417FDF0]();
}

uint64_t ucsdet_detect()
{
  return MEMORY[0x1F417FDF8]();
}

uint64_t ucsdet_getName()
{
  return MEMORY[0x1F417FE18]();
}

uint64_t ucsdet_open()
{
  return MEMORY[0x1F417FE28]();
}

uint64_t ucsdet_setText()
{
  return MEMORY[0x1F417FE30]();
}

int uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
{
  return MEMORY[0x1F4182CF8](dest, destLen, source, sourceLen);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}

void xmlDocDumpMemory(xmlDocPtr cur, xmlChar **mem, int *size)
{
}

xmlNodePtr xmlDocGetRootElement(const xmlDoc *doc)
{
  return (xmlNodePtr)MEMORY[0x1F4182678](doc);
}

void xmlFreeDoc(xmlDocPtr cur)
{
}

xmlChar *__cdecl xmlNodeGetContent(const xmlNode *cur)
{
  return (xmlChar *)MEMORY[0x1F41827B8](cur);
}

xmlDocPtr xmlParseDoc(const xmlChar *cur)
{
  return (xmlDocPtr)MEMORY[0x1F41827F0](cur);
}

xmlDocPtr xmlParseMemory(const char *buffer, int size)
{
  return (xmlDocPtr)MEMORY[0x1F4182808](buffer, *(void *)&size);
}

xmlXPathObjectPtr xmlXPathEvalExpression(const xmlChar *str, xmlXPathContextPtr ctxt)
{
  return (xmlXPathObjectPtr)MEMORY[0x1F4182A78](str, ctxt);
}

void xmlXPathFreeContext(xmlXPathContextPtr ctxt)
{
}

void xmlXPathFreeObject(xmlXPathObjectPtr obj)
{
}

xmlXPathContextPtr xmlXPathNewContext(xmlDocPtr doc)
{
  return (xmlXPathContextPtr)MEMORY[0x1F4182A98](doc);
}

int xmlXPathRegisterNs(xmlXPathContextPtr ctxt, const xmlChar *prefix, const xmlChar *ns_uri)
{
  return MEMORY[0x1F4182AB0](ctxt, prefix, ns_uri);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEA30](objects, count);
}

void xpc_array_set_string(xpc_object_t xarray, size_t index, const char *string)
{
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBA8](name, targetq);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1F40CEC68](connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x1F40CEDB0](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x1F40CEDC0](xdata);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEE20](keys, values, count);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEC8](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1F40CEF10](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1F40CF148](object);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return MEMORY[0x1F40CF190](xint);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1F40CF248](object);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x1F40CF2C8](xstring);
}

xmlDocPtr xsltApplyStylesheet(xsltStylesheetPtr style, xmlDocPtr doc, const char **params)
{
  return (xmlDocPtr)MEMORY[0x1F4182AC0](style, doc, params);
}

void xsltFreeStylesheet(xsltStylesheetPtr style)
{
}

xsltStylesheetPtr xsltParseStylesheetDoc(xmlDocPtr doc)
{
  return (xsltStylesheetPtr)MEMORY[0x1F4182B40](doc);
}