uint64_t sub_1DC2FF464(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  float v10;
  uint64_t v11;
  _DWORD *v13;
  int *v14;
  unint64_t v15;
  uint64_t v16;
  int *v17;
  _DWORD *v18;
  uint64_t v19;
  int v20;

  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a4 + 8) = 0;
  *(void *)a4 = 0;
  v5 = a5;
  do
  {
    v6 = v5--;
    v7 = result + 12 * v5;
    v8 = 4;
    v9 = 3;
    do
    {
      v10 = *(float *)(v7 + 4 * (v9 - 1));
      v11 = v8;
      do
      {
        *(float *)(a3 + 12 * (v9 - 1) + 4 * (v11 - 2)) = *(float *)(a3
                                                                                  + 12 * (v9 - 1)
                                                                                  + 4 * (v11 - 2))
                                                                       + (float)(*(float *)(v7
                                                                                          + 4
                                                                                          * (v11 - 2))
                                                                               * v10);
        --v11;
      }
      while (v11 > 1);
      *(float *)(a4 + 4 * (v9 - 1)) = *(float *)(a4 + 4 * (v9 - 1)) + (float)(v10 * *(float *)(a2 + 4 * v5));
      --v8;
    }
    while (v9-- > 1);
  }
  while (v6 > 1);
  v13 = (_DWORD *)(a3 + 36);
  v14 = (int *)(a3 + 44);
  v15 = 3;
  v16 = 4;
  do
  {
    if (v15 <= 2)
    {
      v17 = v14;
      v18 = v13;
      v19 = v16;
      do
      {
        v20 = *v17;
        v17 += 3;
        *v18++ = v20;
      }
      while (v19++ != 3);
    }
    --v16;
    v13 -= 4;
    v14 -= 4;
  }
  while (v15-- >= 2);
  return result;
}

atomic_uint **sub_1DC2FF548(atomic_uint **a1)
{
  v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

atomic_uint *sub_1DC2FF57C(atomic_uint *result)
{
  atomic_uint v1 = result[2];
  if (v1 == 800000 || v1 == 0) {
    abort();
  }
  if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1)
  {
    result[2] = -559026175;
    v3 = *(uint64_t (**)(void))(*(void *)result + 8);
    return (atomic_uint *)v3();
  }
  return result;
}

char ***sub_1DC2FF604(char ***a1, uint64_t a2)
{
  v4 = *a1;
  v6 = (*a1)[1];
  unint64_t v5 = (unint64_t)(*a1)[2];
  if ((unint64_t)v6 >= v5)
  {
    v8 = *v4;
    uint64_t v9 = (v6 - *v4) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_1DC2FF97C();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        sub_1DC2FF994();
      }
      v13 = (char *)operator new(8 * v12);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v9];
    *(void *)v14 = a2;
    v7 = v14 + 8;
    if (v6 != v8)
    {
      do
      {
        uint64_t v15 = *((void *)v6 - 1);
        v6 -= 8;
        *((void *)v14 - 1) = v15;
        v14 -= 8;
      }
      while (v6 != v8);
      v6 = *v4;
    }
    *v4 = v14;
    v4[1] = v7;
    v4[2] = &v13[8 * v12];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *(void *)v6 = a2;
    v7 = v6 + 8;
  }
  v4[1] = v7;
  return a1;
}

uint64_t sub_1DC2FF700(uint64_t result)
{
  atomic_uint v1 = (unsigned __int8 *)result;
  v2 = (_OWORD *)(result + 40);
  v3 = (_OWORD *)(result + 24);
  unint64_t v4 = *(void *)(result + 80);
  if (v4 <= *(void *)(result + 88)) {
    uint64_t v5 = *(void *)(result + 88);
  }
  else {
    uint64_t v5 = *(void *)(result + 80);
  }
  while (1)
  {
    uint64_t v6 = 0;
    *((void *)v1 + 8) = *((void *)v1 + 2);
    uint64_t v7 = *((void *)v1 + 5);
    do
    {
      *(_DWORD *)&v1[v6 + 16] += *(_DWORD *)(v7 + v6);
      v6 += 4;
    }
    while (v6 != 8);
    *((void *)v1 + 5) = v7 + 8;
    if (v7 + 8 == *((void *)v1 + 6)) {
      _OWORD *v2 = *v3;
    }
    if (v4 == v5) {
      break;
    }
    result = sub_1DC2FF8BC((uint64_t)v1);
    if (!result) {
      break;
    }
    *((void *)v1 + 10) = ++v4;
    result = sub_1DC2FF924(*((void **)v1 + 1), *((int *)v1 + 4), *((int *)v1 + 5));
    int v8 = *v1;
    if (v8 == result)
    {
      int v9 = 0;
    }
    else
    {
      unsigned int v10 = *((_DWORD *)v1 + 18);
      if (v10)
      {
        if (v10 >= *((_DWORD *)v1 + 19))
        {
          *atomic_uint v1 = v8 ^ 1;
          *((_DWORD *)v1 + 18) = 0;
          return result;
        }
        int v9 = v10 + 1;
      }
      else
      {
        unint64_t v11 = *((void *)v1 + 2);
        *((void *)v1 + 7) = v11;
        int v12 = *((_DWORD *)v1 + 16);
        if (v12 > (int)v11) {
          *((_DWORD *)v1 + 14) = v12;
        }
        unint64_t v13 = HIDWORD(v11);
        int v14 = *((_DWORD *)v1 + 17);
        if (v14 > (int)v13) {
          *((_DWORD *)v1 + 15) = v14;
        }
        int v9 = 1;
      }
    }
    *((_DWORD *)v1 + 18) = v9;
  }
  return result;
}

void sub_1DC2FF82C(void ***a1)
{
  atomic_uint v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (char *)v1[1];
      do
      {
        int v8 = (void *)*((void *)v6 - 3);
        v6 -= 24;
        uint64_t v7 = v8;
        if (v8)
        {
          *((void *)v4 - 2) = v7;
          operator delete(v7);
        }
        unint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

BOOL sub_1DC2FF8BC(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if ((v1 & 0x80000000) != 0) {
    return 0;
  }
  BOOL result = 0;
  if ((v1 & 0x8000000000000000) == 0)
  {
    unint64_t v4 = *(void **)(a1 + 8);
    uint64_t v5 = v4[7];
    uint64_t v6 = -v5;
    uint64_t v7 = v4[4];
    uint64_t v8 = v7 & -v5;
    uint64_t v9 = v5 - 1;
    uint64_t v10 = v4[2];
    if ((v10 & v9 | (unint64_t)v8) > v1) {
      return (v7 & v9 | v10 & (unint64_t)v6) > HIDWORD(v1);
    }
  }
  return result;
}

uint64_t sub_1DC2FF924(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = ((a1[2] + ~a3) & -a1[7] | (a1[7] - 1) & a2) + ((a1[4] + ~a2) & -a1[7] | (a1[7] - 1) & a3) * a1[3];
  return (*(_DWORD *)(a1[6] + ((v3 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v3) & 1;
}

void sub_1DC2FF97C()
{
}

void sub_1DC2FF994()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  unint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

void sub_1DC2FF9C8(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1DC2FFA24(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6C39910, MEMORY[0x1E4FBA1C8]);
}

void sub_1DC2FFA10(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1DC2FFA24(std::logic_error *a1, const char *a2)
{
  BOOL result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void sub_1DC2FFA58(void *a1)
{
}

double sub_1DC2FFA6C(int a1, int a2, uint64_t a3)
{
  v3.f64[0] = (double)a1;
  v3.f64[1] = (double)a2;
  v4.i64[0] = (int)*(void *)a3;
  v4.i64[1] = (int)HIDWORD(*(void *)a3);
  float64x2_t v5 = vcvtq_f64_s64(v4);
  float64x2_t v6 = vmulq_f64(v3, v5);
  return (double)a1
       - (v6.f64[0] + 0.0 + v6.f64[1] + (double)*(int *)(a3 + 8))
       / (vmulq_f64(v5, v5).f64[0] + vmuld_lane_f64(v5.f64[1], v5, 1))
       * v5.f64[0];
}

double sub_1DC2FFAE0(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = 0; i != 3; ++i)
    *(&v8 + i) = (double)*(int *)(a1 + 4 * i);
  uint64_t v3 = 0;
  double v4 = v8;
  double v5 = v9;
  double v6 = v10;
  do
  {
    *(&v8 + v3) = (double)*(int *)(a2 + 4 * v3);
    ++v3;
  }
  while (v3 != 3);
  return (v5 * v10 - v6 * v9) / (v4 * v9 - v5 * v8);
}

atomic_uint *sub_1DC2FFB5C(atomic_uint *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    double v6 = result;
    BOOL result = (atomic_uint *)sub_1DC2FFD3C(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    if (a2 != a3)
    {
      uint64_t v8 = 0;
      do
      {
        double v9 = (atomic_uint **)(v7 + v8);
        *(void *)(v7 + v8) = 0;
        double v10 = *(atomic_uint **)(a2 + v8);
        if (v10)
        {
          atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
          BOOL result = *v9;
          if (*v9) {
            BOOL result = sub_1DC2FF57C(result);
          }
        }
        *double v9 = v10;
        v8 += 8;
      }
      while (a2 + v8 != a3);
      v7 += v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1DC2FFC0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_1DC2FFC48(void ***a1)
{
  unint64_t v1 = *a1;
  v2 = (atomic_uint **)**a1;
  if (v2)
  {
    double v4 = (atomic_uint **)v1[1];
    double v5 = v2;
    if (v4 != v2)
    {
      do
        double v4 = sub_1DC2FFD08(v4 - 1);
      while (v4 != v2);
      double v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DC2FFCCC(uint64_t a1)
{
  sub_1DC34E850(a1);
  JUMPOUT(0x1E019CE90);
}

atomic_uint **sub_1DC2FFD08(atomic_uint **a1)
{
  v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

char *sub_1DC2FFD3C(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_1DC2FF97C();
  }
  BOOL result = (char *)sub_1DC2FFD7C(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *sub_1DC2FFD7C(unint64_t a1)
{
  if (a1 >> 61) {
    sub_1DC2FF994();
  }
  return operator new(8 * a1);
}

uint64_t sub_1DC2FFDB4(uint64_t a1, atomic_uint *a2, uint64_t *a3, char a4, char a5, int a6, int a7)
{
  if (a2) {
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  }
  int v14 = a2;
  memset(v13, 0, sizeof(v13));
  sub_1DC2FFB5C((atomic_uint *)v13, *a3, a3[1], (a3[1] - *a3) >> 3);
  sub_1DC34E908(a1, (uint64_t *)&v14, v13, a4);
  uint64_t v15 = (void **)v13;
  sub_1DC2FFC48(&v15);
  sub_1DC2FF548(&v14);
  *(void *)a1 = &unk_1F3661510;
  *(unsigned char *)(a1 + 88) = a5;
  *(_DWORD *)(a1 + 92) = a6;
  *(_DWORD *)(a1 + 96) = a7;
  return a1;
}

void sub_1DC2FFE7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  double v6 = va_arg(va1, atomic_uint *);
  sub_1DC2FFC48((void ***)va1);
  sub_1DC2FF548((atomic_uint **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1DC2FFEA4(_DWORD *a1, double a2)
{
  if ((LODWORD(a2) & 0x80000000) != 0
    || (uint64_t v3 = *(int32x4_t **)a1, *(void *)(*(void *)a1 + 8) <= (unint64_t)LODWORD(a2))
    || (HIDWORD(a2) & 0x80000000) != 0
    || v3[1].i64[0] <= (unint64_t)HIDWORD(a2))
  {
    int v4 = -1;
  }
  else
  {
    int v4 = sub_1DC3A8728(v3, a2);
  }
  return v4 == a1[6];
}

BOOL sub_1DC2FFF08(int32x2_t *a1, float a2)
{
  int v3 = 0;
  signed int v4 = (int)(float)(a2 + a2);
  int v5 = (int)(float)(a2 - a2);
  double v6 = *(double *)&a1[1];
  char v7 = 1;
  while (2)
  {
    uint64_t v8 = 0;
    signed int v9 = 0;
    char v10 = 1;
    do
    {
      char v11 = v10;
      *(double *)&a1[1] = v6;
      a1[2] = qword_1DC3FE0B0[2 * (v7 & 1) + v8];
      int v12 = sub_1DC300B80(a1, 1, v4, 0, 1);
      if (v12 == -1) {
        return 0;
      }
      char v10 = 0;
      v9 += v12;
      uint64_t v8 = 1;
    }
    while ((v11 & 1) != 0);
    if (v3 && (v9 + 1 < v5 || v9 >= v4)) {
      return 0;
    }
    v7 ^= 1u;
    double v14 = *(double *)&a1[1];
    *(_DWORD *)((unint64_t)&v14 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v7 & 1))) -= (v9 + 1) / 2;
    double v6 = v14;
    *(double *)&a1[1] = v14;
    if (++v3 != 4) {
      continue;
    }
    break;
  }
  return sub_1DC2FFEA4(a1, v6);
}

void *sub_1DC300068(unint64_t a1)
{
  if (a1 >> 60) {
    sub_1DC2FF994();
  }
  return operator new(16 * a1);
}

uint64_t sub_1DC3000A0(uint64_t result, int32x4_t *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  char v10 = (int32x4_t *)v9;
  while (1)
  {
    unint64_t v9 = (unint64_t)v10;
    uint64_t v11 = (char *)a2 - (char *)v10;
    unint64_t v12 = a2 - v10;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          int32x4_t v73 = a2[-1];
          int32x4_t v74 = *v10;
          if (vmovn_s32(vcgtq_s32(*v10, v73)).i32[1])
          {
            *char v10 = v73;
            a2[-1] = v74;
          }
          return result;
        case 3uLL:
          int32x4_t v75 = *v10;
          int32x4_t v76 = v10[1];
          int32x4_t v77 = a2[-1];
          __int8 v78 = vmovn_s32(vcgtq_s32(v76, v77)).i8[4];
          if ((vmovn_s32(vcgtq_s32(*v10, v76)).i32[1] & 1) == 0)
          {
            if ((v78 & 1) == 0) {
              return result;
            }
            v10[1] = v77;
            a2[-1] = v76;
            int32x4_t v128 = v10[1];
            goto LABEL_201;
          }
          if (v78)
          {
            *char v10 = v77;
          }
          else
          {
            *char v10 = v76;
            v10[1] = v75;
            int32x4_t v134 = a2[-1];
            if ((vmovn_s32(vcgtq_s32(v75, v134)).i32[1] & 1) == 0) {
              return result;
            }
            v10[1] = v134;
          }
          a2[-1] = v75;
          return result;
        case 4uLL:
          v87 = v10 + 1;
          int32x4_t v88 = v10[1];
          v89 = v10 + 2;
          int32x4_t v90 = v10[2];
          int32x4_t v91 = *v10;
          __int8 v92 = vmovn_s32(vcgtq_s32(v88, v90)).i8[4];
          if (vmovn_s32(vcgtq_s32(*v10, v88)).i32[1])
          {
            if (v92)
            {
              *char v10 = v90;
            }
            else
            {
              *char v10 = v88;
              v10[1] = v91;
              if ((vmovn_s32(vcgtq_s32(v91, v90)).i32[1] & 1) == 0) {
                goto LABEL_186;
              }
              int32x4_t *v87 = v90;
            }
            v129 = v10 + 2;
            int32x4_t v88 = v91;
            goto LABEL_184;
          }
          if ((v92 & 1) == 0) {
            goto LABEL_186;
          }
          int32x4_t *v87 = v90;
          int32x4_t *v89 = v88;
          if (vmovn_s32(vcgtq_s32(v91, v90)).i32[1])
          {
            *char v10 = v90;
            v129 = v10 + 1;
LABEL_184:
            int32x4_t *v129 = v91;
          }
          int32x4_t v90 = v88;
LABEL_186:
          int32x4_t v136 = a2[-1];
          if ((vmovn_s32(vcgtq_s32(v90, v136)).i32[1] & 1) == 0) {
            return result;
          }
          int32x4_t *v89 = v136;
          a2[-1] = v90;
          int32x4_t v128 = *v89;
          int32x4_t v137 = *v87;
          goto LABEL_199;
        case 5uLL:
          v79 = v10 + 1;
          int32x4_t v80 = v10[1];
          v81 = v10 + 2;
          int32x4_t v82 = v10[2];
          int32x4_t v83 = *v10;
          __int8 v84 = vmovn_s32(vcgtq_s32(v80, v82)).i8[4];
          if (vmovn_s32(vcgtq_s32(*v10, v80)).i32[1])
          {
            if (v84)
            {
              *char v10 = v82;
              v85 = v10 + 2;
              int32x4_t v86 = v80;
            }
            else
            {
              *char v10 = v80;
              v10[1] = v83;
              if ((vmovn_s32(vcgtq_s32(v83, v82)).i32[1] & 1) == 0)
              {
                int32x4_t v135 = v80;
LABEL_191:
                int32x4_t v138 = v10[3];
                if (vmovn_s32(vcgtq_s32(v82, v138)).i32[1])
                {
                  v10[2] = v138;
                  v10[3] = v82;
                  if (vmovn_s32(vcgtq_s32(v83, v138)).i32[1])
                  {
                    int32x4_t *v79 = v138;
                    int32x4_t *v81 = v83;
                    if (vmovn_s32(vcgtq_s32(v135, v138)).i32[1])
                    {
                      *char v10 = v138;
                      v10[1] = v135;
                    }
                  }
                }
                else
                {
                  int32x4_t v82 = v10[3];
                }
                int32x4_t v139 = a2[-1];
                if ((vmovn_s32(vcgtq_s32(v82, v139)).i32[1] & 1) == 0) {
                  return result;
                }
                v10[3] = v139;
                a2[-1] = v82;
                int32x4_t v140 = v10[2];
                int32x4_t v128 = v10[3];
                if ((vmovn_s32(vcgtq_s32(v140, v128)).i32[1] & 1) == 0) {
                  return result;
                }
                v10[2] = v128;
                v10[3] = v140;
                int32x4_t v137 = v10[1];
LABEL_199:
                if (vmovn_s32(vcgtq_s32(v137, v128)).i32[1])
                {
                  v10[1] = v128;
                  v10[2] = v137;
LABEL_201:
                  int32x4_t v141 = *v10;
                  if (vmovn_s32(vcgtq_s32(*v10, v128)).i32[1])
                  {
                    *char v10 = v128;
                    v10[1] = v141;
                  }
                }
                return result;
              }
              int32x4_t v86 = v82;
              int32x4_t *v79 = v82;
              v85 = v10 + 2;
              int32x4_t v82 = v80;
            }
            int32x4_t v80 = v83;
          }
          else
          {
            if ((v84 & 1) == 0)
            {
              int32x4_t v135 = *v10;
              int32x4_t v83 = v10[1];
              goto LABEL_191;
            }
            int32x4_t *v79 = v82;
            int32x4_t *v81 = v80;
            if ((vmovn_s32(vcgtq_s32(v83, v82)).i32[1] & 1) == 0)
            {
              int32x4_t v135 = v83;
              int32x4_t v83 = v82;
              goto LABEL_190;
            }
            *char v10 = v82;
            v85 = v10 + 1;
            int32x4_t v86 = v83;
          }
          int32x4_t *v85 = v83;
          int32x4_t v135 = v82;
          int32x4_t v83 = v86;
LABEL_190:
          int32x4_t v82 = v80;
          goto LABEL_191;
        default:
          JUMPOUT(0);
      }
    }
    if (v11 <= 383) {
      break;
    }
    if (!a3)
    {
      if (v10 != a2)
      {
        int64_t v103 = (v12 - 2) >> 1;
        int64_t v104 = v103;
        do
        {
          int64_t v105 = v104;
          if (v103 >= v104)
          {
            uint64_t v106 = (2 * v104) | 1;
            v107 = &v10[v106];
            if (2 * v105 + 2 < (uint64_t)v12)
            {
              BOOL v108 = v107->i32[2] < v107[1].i32[2];
              v107 += v108;
              if (v108) {
                uint64_t v106 = 2 * v105 + 2;
              }
            }
            v109 = &v10[v105];
            int32x4_t v110 = *v109;
            int v111 = v109->i64[1];
            if (v107->i32[2] >= v111)
            {
              do
              {
                v112 = v107;
                int32x4_t *v109 = *v107;
                if (v103 < v106) {
                  break;
                }
                uint64_t v113 = (2 * v106) | 1;
                v107 = &v10[v113];
                uint64_t v114 = 2 * v106 + 2;
                if (v114 < (uint64_t)v12)
                {
                  BOOL v108 = v107->i32[2] < v107[1].i32[2];
                  v107 += v108;
                  if (v108) {
                    uint64_t v113 = v114;
                  }
                }
                BOOL result = v107->u32[2];
                v109 = v112;
                uint64_t v106 = v113;
              }
              while ((int)result >= v111);
              int32x4_t *v112 = v110;
            }
          }
          int64_t v104 = v105 - 1;
        }
        while (v105);
        uint64_t v115 = (unint64_t)v11 >> 4;
        do
        {
          uint64_t v116 = 0;
          int32x4_t v117 = *v10;
          v118 = v10;
          do
          {
            uint64_t v119 = (uint64_t)&v118[v116 + 1];
            uint64_t v120 = (2 * v116) | 1;
            uint64_t v121 = 2 * v116 + 2;
            if (v121 < v115)
            {
              BOOL v108 = *(_DWORD *)(v119 + 8) < *(_DWORD *)(v119 + 24);
              v119 += 16 * v108;
              if (v108) {
                uint64_t v120 = v121;
              }
            }
            _OWORD *v118 = *(_OWORD *)v119;
            v118 = (_OWORD *)v119;
            uint64_t v116 = v120;
          }
          while (v120 <= (uint64_t)((unint64_t)(v115 - 2) >> 1));
          if ((int32x4_t *)v119 == --a2)
          {
            *(int32x4_t *)uint64_t v119 = v117;
          }
          else
          {
            *(int32x4_t *)uint64_t v119 = *a2;
            *a2 = v117;
            uint64_t v122 = v119 - (void)v10 + 16;
            if (v122 >= 17)
            {
              unint64_t v123 = (((unint64_t)v122 >> 4) - 2) >> 1;
              v124 = &v10[v123];
              int32x4_t v125 = *(int32x4_t *)v119;
              __int32 v126 = *(void *)(v119 + 8);
              if (v124->i32[2] < v126)
              {
                do
                {
                  v127 = v124;
                  *(int32x4_t *)uint64_t v119 = *v124;
                  if (!v123) {
                    break;
                  }
                  unint64_t v123 = (v123 - 1) >> 1;
                  v124 = &v10[v123];
                  uint64_t v119 = (uint64_t)v127;
                }
                while (v124->i32[2] < v126);
                int32x4_t *v127 = v125;
              }
            }
          }
          BOOL v108 = v115-- <= 2;
        }
        while (!v108);
      }
      return result;
    }
    unint64_t v13 = v12 >> 1;
    double v14 = &v10[v12 >> 1];
    int32x4_t v15 = a2[-1];
    if ((unint64_t)v11 >= 0x801)
    {
      int32x4_t v16 = *v14;
      int32x4_t v17 = *v10;
      __int8 v18 = vmovn_s32(vcgtq_s32(*v14, v15)).i8[4];
      if (vmovn_s32(vcgtq_s32(*v10, *v14)).i32[1])
      {
        if (v18)
        {
          *char v10 = v15;
          goto LABEL_22;
        }
        *char v10 = v16;
        int32x4_t *v14 = v17;
        int32x4_t v24 = a2[-1];
        if (vmovn_s32(vcgtq_s32(v17, v24)).i32[1])
        {
          int32x4_t *v14 = v24;
LABEL_22:
          a2[-1] = v17;
        }
      }
      else if (v18)
      {
        int32x4_t *v14 = v15;
        a2[-1] = v16;
        int32x4_t v22 = *v10;
        if (vmovn_s32(vcgtq_s32(*v10, *v14)).i32[1])
        {
          *char v10 = *v14;
          int32x4_t *v14 = v22;
        }
      }
      unint64_t v25 = v13 - 1;
      int32x4_t v26 = v10[v13 - 1];
      int32x4_t v27 = v10[1];
      int32x4_t v28 = a2[-2];
      __int8 v29 = vmovn_s32(vcgtq_s32(v26, v28)).i8[4];
      if (vmovn_s32(vcgtq_s32(v27, v26)).i32[1])
      {
        if (v29)
        {
          v10[1] = v28;
          goto LABEL_34;
        }
        v10[1] = v26;
        v10[v25] = v27;
        int32x4_t v33 = a2[-2];
        if (vmovn_s32(vcgtq_s32(v27, v33)).i32[1])
        {
          v10[v25] = v33;
LABEL_34:
          a2[-2] = v27;
        }
      }
      else if (v29)
      {
        v10[v25] = v28;
        a2[-2] = v26;
        int32x4_t v30 = v10[v25];
        int32x4_t v31 = v10[1];
        if (vmovn_s32(vcgtq_s32(v31, v30)).i32[1])
        {
          v10[1] = v30;
          v10[v25] = v31;
        }
      }
      v34 = &v10[v13];
      int32x4_t v36 = v34[1];
      v35 = v34 + 1;
      int32x4_t v37 = v36;
      int32x4_t v38 = v10[2];
      int32x4_t v39 = a2[-3];
      __int8 v40 = vmovn_s32(vcgtq_s32(v36, v39)).i8[4];
      if (vmovn_s32(vcgtq_s32(v38, v36)).i32[1])
      {
        if (v40)
        {
          v10[2] = v39;
          goto LABEL_43;
        }
        v10[2] = v37;
        int32x4_t *v35 = v38;
        int32x4_t v42 = a2[-3];
        if (vmovn_s32(vcgtq_s32(v38, v42)).i32[1])
        {
          int32x4_t *v35 = v42;
LABEL_43:
          a2[-3] = v38;
        }
      }
      else if (v40)
      {
        int32x4_t *v35 = v39;
        a2[-3] = v37;
        int32x4_t v41 = v10[2];
        if (vmovn_s32(vcgtq_s32(v41, *v35)).i32[1])
        {
          v10[2] = *v35;
          int32x4_t *v35 = v41;
        }
      }
      int32x4_t v43 = *v14;
      int32x4_t v44 = v10[v25];
      int32x4_t v45 = *v35;
      __int8 v46 = vmovn_s32(vcgtq_s32(*v14, *v35)).i8[4];
      if (vmovn_s32(vcgtq_s32(v44, *v14)).i32[1])
      {
        if (v46)
        {
          v10[v25] = v45;
          goto LABEL_52;
        }
        v10[v25] = v43;
        int32x4_t *v14 = v44;
        if (vmovn_s32(vcgtq_s32(v44, v45)).i32[1])
        {
          int32x4_t *v14 = v45;
          int32x4_t v43 = v45;
LABEL_52:
          int32x4_t *v35 = v44;
        }
        else
        {
          int32x4_t v43 = v44;
        }
      }
      else if (v46)
      {
        int32x4_t *v14 = v45;
        int32x4_t *v35 = v43;
        if (vmovn_s32(vcgtq_s32(v44, v45)).i32[1])
        {
          v10[v25] = v45;
          v35 = &v10[v12 >> 1];
          int32x4_t v43 = v44;
          goto LABEL_52;
        }
        int32x4_t v43 = v45;
      }
      int32x4_t v47 = *v10;
      *char v10 = v43;
      int32x4_t *v14 = v47;
      goto LABEL_54;
    }
    int32x4_t v19 = *v10;
    int32x4_t v20 = *v14;
    __int8 v21 = vmovn_s32(vcgtq_s32(*v10, v15)).i8[4];
    if ((vmovn_s32(vcgtq_s32(*v14, *v10)).i32[1] & 1) == 0)
    {
      if (v21)
      {
        *char v10 = v15;
        a2[-1] = v19;
        int32x4_t v23 = *v14;
        if (vmovn_s32(vcgtq_s32(*v14, *v10)).i32[1])
        {
          int32x4_t *v14 = *v10;
          *char v10 = v23;
        }
      }
      goto LABEL_54;
    }
    if (v21)
    {
      int32x4_t *v14 = v15;
LABEL_31:
      a2[-1] = v20;
      goto LABEL_54;
    }
    int32x4_t *v14 = v19;
    *char v10 = v20;
    int32x4_t v32 = a2[-1];
    if (vmovn_s32(vcgtq_s32(v20, v32)).i32[1])
    {
      *char v10 = v32;
      goto LABEL_31;
    }
LABEL_54:
    --a3;
    int32x4_t v48 = *v10;
    if (a4)
    {
      __int32 v49 = v10->i64[1];
LABEL_57:
      v50 = v10;
      do
        v51 = v50++;
      while (v51[1].i32[2] < v49);
      v52 = a2;
      if (v51 == v10)
      {
        v55 = a2;
        while (v50 < v55)
        {
          v53 = v55 - 1;
          __int32 v56 = v55[-1].i32[2];
          --v55;
          if (v56 < v49) {
            goto LABEL_66;
          }
        }
        v53 = v55;
      }
      else
      {
        do
        {
          v53 = v52 - 1;
          __int32 v54 = v52[-1].i32[2];
          --v52;
        }
        while (v54 >= v49);
      }
LABEL_66:
      if (v50 < v53)
      {
        v57 = v50;
        v58 = v53;
        do
        {
          int32x4_t v59 = *v57;
          int32x4_t *v57 = *v58;
          int32x4_t *v58 = v59;
          do
            v51 = v57++;
          while (v51[1].i32[2] < v49);
          do
          {
            __int32 v60 = v58[-1].i32[2];
            --v58;
          }
          while (v60 >= v49);
        }
        while (v57 < v58);
      }
      if (v51 != v10) {
        *char v10 = *v51;
      }
      int32x4_t *v51 = v48;
      if (v50 < v53) {
        goto LABEL_77;
      }
      BOOL v61 = sub_1DC301A44(v10, v51);
      char v10 = v51 + 1;
      BOOL result = sub_1DC301A44(v51 + 1, a2);
      if (result)
      {
        a2 = v51;
        if (v61) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v61)
      {
LABEL_77:
        BOOL result = sub_1DC3000A0(v9, v51, a3, a4 & 1);
        a4 = 0;
        char v10 = v51 + 1;
      }
    }
    else
    {
      __int32 v49 = v10->i64[1];
      if (v10[-1].i32[2] < v48.i32[2]) {
        goto LABEL_57;
      }
      if (v48.i32[2] < a2[-1].i32[2])
      {
        v62 = v10;
        do
        {
          char v10 = v62 + 1;
          int v63 = v62[1].i32[2];
          ++v62;
        }
        while (v48.i32[2] >= v63);
      }
      else
      {
        unint64_t v64 = (unint64_t)&v10[1];
        do
        {
          char v10 = (int32x4_t *)v64;
          if (v64 >= (unint64_t)a2) {
            break;
          }
          int v65 = *(_DWORD *)(v64 + 8);
          v64 += 16;
        }
        while (v48.i32[2] >= v65);
      }
      v66 = a2;
      if (v10 < a2)
      {
        v67 = a2;
        do
        {
          v66 = v67 - 1;
          int v68 = v67[-1].i32[2];
          --v67;
        }
        while (v48.i32[2] < v68);
      }
      while (v10 < v66)
      {
        int32x4_t v69 = *v10;
        *char v10 = *v66;
        int32x4_t *v66 = v69;
        do
        {
          int v70 = v10[1].i32[2];
          ++v10;
        }
        while (v48.i32[2] >= v70);
        do
        {
          int v71 = v66[-1].i32[2];
          --v66;
        }
        while (v48.i32[2] < v71);
      }
      v72 = v10 - 1;
      BOOL v4 = (unint64_t)&v10[-1] >= v9;
      BOOL v5 = &v10[-1] == (int32x4_t *)v9;
      if (&v10[-1] != (int32x4_t *)v9) {
        *(int32x4_t *)unint64_t v9 = *v72;
      }
      a4 = 0;
      int32x4_t *v72 = v48;
    }
  }
  v93 = v10 + 1;
  BOOL v95 = v10 == a2 || v93 == a2;
  if (a4)
  {
    if (!v95)
    {
      uint64_t v96 = 0;
      v97 = v10;
      do
      {
        int32x4_t v98 = v97[1];
        int v99 = v97->i32[2];
        v97 = v93;
        if (v98.i32[2] < v99)
        {
          uint64_t v100 = v96;
          while (1)
          {
            *(int32x4_t *)((char *)&v10[1] + v100) = *(int32x4_t *)((char *)v10 + v100);
            if (!v100) {
              break;
            }
            int v101 = *(__int32 *)((char *)&v10->i32[-2] + v100);
            v100 -= 16;
            if (v98.i32[2] >= v101)
            {
              v102 = (int32x4_t *)((char *)v10 + v100 + 16);
              goto LABEL_127;
            }
          }
          v102 = v10;
LABEL_127:
          int32x4_t *v102 = v98;
        }
        v93 = v97 + 1;
        v96 += 16;
      }
      while (&v97[1] != a2);
    }
  }
  else if (!v95)
  {
    do
    {
      int32x4_t v130 = *(int32x4_t *)(v9 + 16);
      int v131 = *(_DWORD *)(v9 + 8);
      unint64_t v9 = (unint64_t)v93;
      if (v130.i32[2] < v131)
      {
        do
        {
          v132 = v93;
          int32x4_t v133 = v93[-1];
          --v93;
          int32x4_t *v132 = v133;
        }
        while (v130.i32[2] < v132[-2].i32[2]);
        int32x4_t *v93 = v130;
      }
      v93 = (int32x4_t *)(v9 + 16);
    }
    while ((int32x4_t *)(v9 + 16) != a2);
  }
  return result;
}

uint64_t sub_1DC300B80(int32x2_t *a1, int a2, signed int a3, int a4, int a5)
{
  if (a2 <= 1) {
    int v8 = 1;
  }
  else {
    int v8 = a2;
  }
  if (a5 <= 1) {
    unsigned int v9 = 1;
  }
  else {
    unsigned int v9 = a5;
  }
  double v10 = *(double *)&a1[1];
  if ((LODWORD(v10) & 0x80000000) != 0
    || (uint64_t v11 = (int32x4_t *)*a1, *(void *)(*(void *)a1 + 8) <= (unint64_t)LODWORD(v10))
    || (HIDWORD(v10) & 0x80000000) != 0
    || v11[1].i64[0] <= (unint64_t)HIDWORD(v10))
  {
    int v12 = -1;
  }
  else
  {
    int v12 = sub_1DC3A8728(v11, v10);
  }
  signed int v13 = 0;
  int v14 = 0;
  do
  {
    int v15 = v12;
    if (a3)
    {
      uint64_t result = 0xFFFFFFFFLL;
      if (v13 >= a3 || v12 == -1) {
        return result;
      }
    }
    else if (v12 == -1)
    {
      return 0xFFFFFFFFLL;
    }
    v13 += v9;
    double v17 = COERCE_DOUBLE(vmla_s32(a1[1], a1[2], vdup_n_s32(v13)));
    if ((LODWORD(v17) & 0x80000000) != 0
      || (__int8 v18 = (int32x4_t *)*a1, *(void *)(*(void *)a1 + 8) <= (unint64_t)LODWORD(v17))
      || (HIDWORD(v17) & 0x80000000) != 0
      || v18[1].i64[0] <= (unint64_t)HIDWORD(v17))
    {
      int v12 = -1;
    }
    else
    {
      int v12 = sub_1DC3A8728(v18, v17);
    }
    int v19 = v15 != v12 && (int)(v14 + v9) >= a4;
    if (v15 != v12 && (int)(v14 + v9) >= a4) {
      int v14 = 0;
    }
    else {
      v14 += v9;
    }
    v8 -= v19;
  }
  while (v8);
  if (v9 < 2)
  {
LABEL_43:
    int v23 = 1;
  }
  else
  {
    v13 -= v9;
    int v20 = v12;
    if (!a3) {
      goto LABEL_32;
    }
LABEL_31:
    if (v13 < a3)
    {
LABEL_32:
      while (v20 != -1)
      {
        double v21 = COERCE_DOUBLE(vmla_s32(a1[1], a1[2], vdup_n_s32(v13)));
        if ((LODWORD(v21) & 0x80000000) != 0
          || (int32x4_t v22 = (int32x4_t *)*a1, *(void *)(*(void *)a1 + 8) <= (unint64_t)LODWORD(v21))
          || (HIDWORD(v21) & 0x80000000) != 0
          || v22[1].i64[0] <= (unint64_t)HIDWORD(v21))
        {
          int v20 = -1;
        }
        else
        {
          int v20 = sub_1DC3A8728(v22, v21);
        }
        if (v20 == v12) {
          goto LABEL_43;
        }
        ++v13;
        if (a3) {
          goto LABEL_31;
        }
      }
    }
    int v23 = 0;
  }
  a1[1] = vmla_s32(a1[1], vdup_n_s32(v13 - 1), a1[2]);
  if (v23) {
    return (v13 - 1);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void sub_1DC300D68(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      sub_1DC2FF97C();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    BOOL v4 = (char *)sub_1DC2FFD7C(a2);
    BOOL v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    char v7 = &v4[8 * v6];
    unsigned int v9 = (char *)*a1;
    int v8 = (char *)a1[1];
    double v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        uint64_t v11 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v8 != v9);
      int v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void sub_1DC300E10(void *a1, char **a2, float32x2_t a3)
{
  uint64_t v129 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  char v7 = a2[1];
  if (*a2 == v7 || (int v8 = (float32x2_t *)(v6 + 8), v6 + 8 == v7))
  {
    double v10 = *a2;
  }
  else
  {
    float32x2_t v9 = *(float32x2_t *)v6;
    double v10 = *a2;
    uint64_t v11 = (float32x2_t *)(v6 + 8);
    do
    {
      float32x2_t v12 = *v11++;
      int8x8_t v13 = (int8x8_t)v12;
      float32x2_t v14 = vsub_f32(v9, a3);
      int32x2_t v15 = (int32x2_t)vmul_f32(v14, v14);
      float32x2_t v16 = vsub_f32(v12, a3);
      int32x2_t v17 = (int32x2_t)vmul_f32(v16, v16);
      float32x2_t v18 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v15, v17), (float32x2_t)vzip2_s32(v15, v17)));
      unsigned __int8 v19 = vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v18, 1), v18).u8[0];
      if (v19) {
        unsigned int v20 = -1;
      }
      else {
        unsigned int v20 = 0;
      }
      float32x2_t v9 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v20), v13, (int8x8_t)v9);
      if (v19) {
        double v10 = (char *)v8;
      }
      int v8 = v11;
    }
    while (v11 != (float32x2_t *)v7);
  }
  sub_1DC301684(v6, v10, v7);
  int32x4_t v22 = (float32x2_t *)*a2;
  double v21 = a2[1];
  int v23 = operator new(0x20uLL);
  int32x4_t v24 = v23;
  unint64_t v25 = (v21 - (char *)v22) >> 3;
  v23[2] = 0;
  v23[3] = 0;
  *int v23 = v22;
  v23[1] = 0;
  unint64_t v26 = (3 * v25) >> 3;
  int32x4_t v27 = &v22[v26];
  unint64_t v28 = (5 * v25) >> 3;
  __int8 v29 = v27 + 1;
  if (v26 == v28 || v29 == &v22[v28])
  {
    int32x4_t v33 = &v22[v26];
  }
  else
  {
    float32x2_t v31 = *v27;
    uint64_t v32 = 8 * v28 - 8 * v26 - 8;
    int32x4_t v33 = &v22[v26];
    v34 = v27 + 1;
    do
    {
      float32x2_t v35 = *v34++;
      int8x8_t v36 = (int8x8_t)v35;
      float32x2_t v37 = vsub_f32(v31, a3);
      int32x2_t v38 = (int32x2_t)vmul_f32(v37, v37);
      float32x2_t v39 = vsub_f32(v35, a3);
      int32x2_t v40 = (int32x2_t)vmul_f32(v39, v39);
      float32x2_t v41 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v38, v40), (float32x2_t)vzip2_s32(v38, v40)));
      unsigned __int8 v42 = vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v41, 1), v41).u8[0];
      if (v42) {
        unsigned int v43 = -1;
      }
      else {
        unsigned int v43 = 0;
      }
      float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v43), v36, (int8x8_t)v31);
      if (v42) {
        int32x4_t v33 = v29;
      }
      __int8 v29 = v34;
      v32 -= 8;
    }
    while (v32);
  }
  v23[2] = v33;
  float32x2_t v44 = *v22;
  float32x2_t v45 = *v33;
  long long v120 = 0u;
  *(_OWORD *)uint64_t v121 = 0u;
  *(int32x2_t *)&v121[16] = vdup_n_s32(0x7FC00000u);
  __int32 v122 = 2143289344;
  v123[0] = v44;
  v123[1] = v45;
  sub_1DC301880((float32x2_t *)&v120, v123, 2uLL);
  uint64_t v116 = 0;
  uint64_t v117 = 0;
  __p = 0;
  long long v46 = v120;
  unint64_t v47 = (uint64_t)(*((void *)&v120 + 1) - v120) >> 3;
  sub_1DC3017D0(&__p, (const void *)v120, *((uint64_t *)&v120 + 1), v47);
  int32x4_t v48 = &v22[v25 >> 3];
  long long v118 = *(_OWORD *)&v121[8];
  v119.i32[0] = v122;
  if (v25 >> 3 != v26)
  {
    __int32 v49 = v48 + 1;
    if (&v48[1] != v27)
    {
      float32x2_t v50 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vorr_s8((int8x8_t)vcgt_f32(0, *(float32x2_t *)((char *)&v118 + 8)), (int8x8_t)vcge_f32(*(float32x2_t *)((char *)&v118 + 8), 0)), 0), *(int8x8_t *)((char *)&v118 + 8), *(int8x8_t *)&v118);
      float32x2_t v51 = *v48;
      float32x2_t v52 = (float32x2_t)vdup_lane_s32(v119, 0);
      uint64_t v53 = 8 * v26 - 8 * (v25 >> 3) - 8;
      __int32 v54 = v48 + 1;
      do
      {
        float32x2_t v55 = *v54++;
        int8x8_t v56 = (int8x8_t)v55;
        int32x2_t v57 = (int32x2_t)vmul_f32(v50, v51);
        int32x2_t v58 = (int32x2_t)vmul_f32(v50, v55);
        float32x2_t v59 = vabd_f32(vadd_f32((float32x2_t)vzip1_s32(v57, v58), (float32x2_t)vzip2_s32(v57, v58)), v52);
        unsigned __int8 v60 = vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v59, 1), v59).u8[0];
        if (v60) {
          unsigned int v61 = -1;
        }
        else {
          unsigned int v61 = 0;
        }
        float32x2_t v51 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v61), v56, (int8x8_t)v51);
        if (v60) {
          int32x4_t v48 = v49;
        }
        __int32 v49 = v54;
        v53 -= 8;
      }
      while (v53);
    }
  }
  v24[1] = v48;
  if (__p)
  {
    uint64_t v116 = __p;
    operator delete(__p);
  }
  v62 = *a2;
  int v111 = 0;
  uint64_t v112 = 0;
  int32x4_t v110 = 0;
  sub_1DC3017D0(&v110, (const void *)v46, *((uint64_t *)&v46 + 1), v47);
  int v63 = (float32x2_t *)&v62[8 * v28];
  unint64_t v64 = (7 * v25) >> 3;
  long long v113 = *(_OWORD *)&v121[8];
  v114.i32[0] = v122;
  if (v28 != v64)
  {
    int v65 = v63 + 1;
    if (&v63[1] != (float32x2_t *)&v62[8 * v64])
    {
      float32x2_t v66 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vorr_s8((int8x8_t)vcgt_f32(0, *(float32x2_t *)((char *)&v113 + 8)), (int8x8_t)vcge_f32(*(float32x2_t *)((char *)&v113 + 8), 0)), 0), *(int8x8_t *)((char *)&v113 + 8), *(int8x8_t *)&v113);
      float32x2_t v67 = *v63;
      float32x2_t v68 = (float32x2_t)vdup_lane_s32(v114, 0);
      uint64_t v69 = 8 * v64 - 8 * v28 - 8;
      int v70 = v63 + 1;
      do
      {
        float32x2_t v71 = *v70++;
        int8x8_t v72 = (int8x8_t)v71;
        int32x2_t v73 = (int32x2_t)vmul_f32(v66, v67);
        int32x2_t v74 = (int32x2_t)vmul_f32(v66, v71);
        float32x2_t v75 = vabd_f32(vadd_f32((float32x2_t)vzip1_s32(v73, v74), (float32x2_t)vzip2_s32(v73, v74)), v68);
        unsigned __int8 v76 = vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v75, 1), v75).u8[0];
        if (v76) {
          unsigned int v77 = -1;
        }
        else {
          unsigned int v77 = 0;
        }
        float32x2_t v67 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v77), v72, (int8x8_t)v67);
        if (v76) {
          int v63 = v65;
        }
        int v65 = v70;
        v69 -= 8;
      }
      while (v69);
    }
  }
  v24[3] = v63;
  if (v110)
  {
    int v111 = v110;
    operator delete(v110);
  }
  uint64_t v78 = 0;
  uint64_t v79 = 0;
  int32x2_t v80 = vdup_n_s32(0x7FC00000u);
  do
  {
    v81 = &v123[v78];
    *(_OWORD *)v81->f32 = 0u;
    *(_OWORD *)v81[2].f32 = 0u;
    v81[4] = (float32x2_t)v80;
    v81[5].i32[0] = 2143289344;
    sub_1DC300D68((void **)&v123[v78], 0x10uLL);
    ++v79;
    v78 += 6;
  }
  while (v78 != 24);
  int32x4_t v82 = (float32x2_t *)v24[3];
  unint64_t v83 = (a2[1] - (char *)v82) >> 3;
  *(_OWORD *)v107 = 0u;
  *(_OWORD *)BOOL v108 = 0u;
  *(int32x2_t *)&v108[16] = vdup_n_s32(0x7FC00000u);
  int v109 = 2143289344;
  sub_1DC301880((float32x2_t *)v107, v82, v83);
  if ((void)v125)
  {
    *((void *)&v125 + 1) = v125;
    operator delete((void *)v125);
  }
  long long v125 = *(_OWORD *)v107;
  uint64_t v126 = *(void *)v108;
  long long v127 = *(_OWORD *)&v108[8];
  int v128 = v109;
  __int8 v84 = v123;
  uint64_t v85 = 1;
  int32x2_t v86 = vdup_n_s32(0x7FC00000u);
  while (v85 != 4)
  {
    v87 = (float32x2_t *)v24[v85 - 1];
    unint64_t v88 = (uint64_t)(v24[v85] - (void)v87) >> 3;
    *(_OWORD *)v107 = 0u;
    *(_OWORD *)BOOL v108 = 0u;
    *(int32x2_t *)&v108[16] = v86;
    int v109 = 2143289344;
    sub_1DC301880((float32x2_t *)v107, v87, v88);
    v89 = (void *)*v84;
    if (*v84)
    {
      v84[1] = (float32x2_t)v89;
      operator delete(v89);
    }
    *(_OWORD *)v84->f32 = *(_OWORD *)v107;
    v84[2] = *(float32x2_t *)v108;
    *(_OWORD *)v84[3].f32 = *(_OWORD *)&v108[8];
    v84[5].i32[0] = v109;
    ++v85;
    v84 += 6;
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int32x4_t v90 = (char *)operator new(0x20uLL);
  uint64_t v92 = 0;
  a1[1] = v90 + 32;
  a1[2] = v90 + 32;
  *(_OWORD *)int32x4_t v90 = 0u;
  *((_OWORD *)v90 + 1) = 0u;
  *a1 = v90;
  v93 = (float32x2_t *)&v124;
  do
  {
    float v94 = v93[-1].f32[1];
    BOOL v95 = &v123[6 * (((int)v92 + 1) & 3)];
    float32x2_t v96 = *v93;
    v93 += 6;
    float32x2_t v97 = vneg_f32(v96);
    float32x2_t v98 = *(float32x2_t *)((char *)v95 + 36);
    *(float *)v91.i32 = vmlas_n_f32(v95[4].f32[0] * v97.f32[0], v94, v98.f32[0]);
    v99.i32[0] = vdup_lane_s32((int32x2_t)v98, 1).u32[0];
    v99.i32[1] = v95[4].i32[0];
    v100.i32[0] = vdup_lane_s32((int32x2_t)v96, 1).u32[0];
    v100.f32[1] = v94;
    *(float32x2_t *)&v90[8 * v92++] = vdiv_f32(vmla_f32(vmul_f32(v99, v97), v98, v100), (float32x2_t)vdup_lane_s32(v91, 0));
  }
  while (v92 != 4);
  float32x2_t v101 = vsub_f32(*(float32x2_t *)v90, *(float32x2_t *)(v90 + 24));
  float v102 = sqrtf(vaddv_f32(vmul_f32(v101, v101)));
  uint64_t v103 = 8;
  float32x2_t v104 = *(float32x2_t *)v90;
  do
  {
    float32x2_t v105 = *(float32x2_t *)&v90[v103];
    float32x2_t v106 = vsub_f32(v104, v105);
    float v102 = v102 + sqrtf(vaddv_f32(vmul_f32(v106, v106)));
    v103 += 8;
    float32x2_t v104 = v105;
  }
  while (v103 != 32);
  sub_1DC353CE0();
}

void sub_1DC301524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,atomic_uint *a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  if (__p) {
    operator delete(__p);
  }
  sub_1DC30184C(&a39);
  *(void *)(a14 + 8) = v63;
  operator delete(v63);
  uint64_t v65 = 0;
  while (1)
  {
    float32x2_t v66 = *(void **)((char *)&a60 + v65);
    if (v66)
    {
      *(uint64_t *)((char *)&a61 + v65) = (uint64_t)v66;
      operator delete(v66);
    }
    v65 -= 48;
    if (v65 == -192)
    {
      if (v62) {
        operator delete(v62);
      }
      operator delete(v61);
      _Unwind_Resume(a1);
    }
  }
}

BOOL sub_1DC3015FC(float32x2_t *a1, uint64_t a2, int a3)
{
  if ((unint64_t)(a2 - (void)a1) < 0x20) {
    return 0;
  }
  float32x2_t v4 = *a1;
  float32x2_t v5 = vsub_f32(a1[3], a1[1]);
  float v6 = sqrtf(vaddv_f32(vmul_f32(v5, v5)));
  uint64_t v7 = 1;
  float v8 = v6;
  do
  {
    float32x2_t v9 = a1[v7];
    float32x2_t v10 = vsub_f32(v4, v9);
    float v11 = sqrtf(vaddv_f32(vmul_f32(v10, v10)));
    if (v11 < v6) {
      float v6 = v11;
    }
    if (v8 < v11) {
      float v8 = v11;
    }
    ++v7;
    float32x2_t v4 = v9;
  }
  while (v7 != 4);
  return v6 > (float)(v8 / 3.0) && v6 >= (float)a3;
}

char *sub_1DC301684(char *__src, char *a2, char *a3)
{
  if (__src != a2 && a2 != a3)
  {
    int64_t v3 = __src;
    if (__src + 8 == a2)
    {
      uint64_t v9 = *(void *)__src;
      int64_t v10 = a3 - a2;
      __src = (char *)memmove(__src, a2, a3 - a2);
      *(void *)((char *)v3 + v10) = v9;
    }
    else if (a2 + 8 == a3)
    {
      uint64_t v11 = *((void *)a3 - 1);
      if (a3 - 8 != __src) {
        __src = (char *)memmove(__src + 8, __src, a3 - 8 - __src);
      }
      void *v3 = v11;
    }
    else
    {
      uint64_t v4 = (a2 - __src) >> 3;
      if (v4 == (a3 - a2) >> 3)
      {
        float32x2_t v5 = __src + 8;
        float v6 = a2 + 8;
        do
        {
          uint64_t v7 = *((void *)v5 - 1);
          *((void *)v5 - 1) = *((void *)v6 - 1);
          *((void *)v6 - 1) = v7;
          if (v5 == a2) {
            break;
          }
          v5 += 8;
          BOOL v8 = v6 == a3;
          v6 += 8;
        }
        while (!v8);
      }
      else
      {
        uint64_t v12 = (a3 - a2) >> 3;
        uint64_t v13 = (a2 - __src) >> 3;
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = v12;
          uint64_t v12 = v14 % v12;
        }
        while (v12);
        if (v13)
        {
          int32x2_t v15 = &__src[8 * v13];
          do
          {
            uint64_t v16 = *((void *)v15 - 1);
            v15 -= 8;
            uint64_t v17 = v16;
            float32x2_t v18 = &v15[8 * v4];
            unsigned __int8 v19 = v15;
            do
            {
              unsigned int v20 = v18;
              *(void *)unsigned __int8 v19 = *(void *)v18;
              double v21 = &v18[8 * v4];
              BOOL v22 = __OFSUB__(v4, (a3 - v18) >> 3);
              uint64_t v24 = v4 - ((a3 - v18) >> 3);
              char v23 = (v24 < 0) ^ v22;
              float32x2_t v18 = &__src[8 * v24];
              if (v23) {
                float32x2_t v18 = v21;
              }
              unsigned __int8 v19 = v20;
            }
            while (v18 != v15);
            *(void *)unsigned int v20 = v17;
          }
          while (v15 != __src);
        }
      }
    }
  }
  return __src;
}

void *sub_1DC3017D0(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    float v6 = result;
    uint64_t result = sub_1DC2FFD3C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1DC301830(_Unwind_Exception *exception_object)
{
  int64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

atomic_uint **sub_1DC30184C(atomic_uint **a1)
{
  v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

float sub_1DC301880(float32x2_t *a1, float32x2_t *a2, unint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = 8 * a3;
    float32x2_t v4 = 0;
    uint64_t v5 = 8 * a3;
    float v6 = a2;
    do
    {
      float32x2_t v7 = *v6++;
      v8.i32[1] = v7.i32[1];
      float32x2_t v4 = vadd_f32(v4, v7);
      v5 -= 8;
    }
    while (v5);
    *(float *)v8.i32 = (float)a3;
    float32x2_t v9 = vdiv_f32(v4, (float32x2_t)vdup_lane_s32(v8, 0));
    float v10 = 0.0;
    _D1.i32[1] = 0;
    float v12 = 0.0;
    do
    {
      float32x2_t v13 = *a2++;
      _D4 = vsub_f32(v13, v9);
      float v10 = vmlas_n_f32(v10, _D4.f32[0], _D4.f32[0]);
      _S5 = _D4.i32[1];
      __asm { FMLA            S1, S5, V4.S[1] }
      float v12 = vmlas_n_f32(v12, _D4.f32[1], _D4.f32[0]);
      v3 -= 8;
    }
    while (v3);
    if (_D1.f32[0] < v10)
    {
      float v20 = sqrtf((float)(v12 * v12) + (float)(v10 * v10));
      _D1.f32[0] = v12 / v20;
      goto LABEL_10;
    }
  }
  else
  {
    float32x2_t v9 = (float32x2_t)vdup_n_s32(0x7FC00000u);
    _D1 = 0;
    float v12 = 0.0;
  }
  float v20 = sqrtf((float)(v12 * v12) + (float)(_D1.f32[0] * _D1.f32[0]));
  _D1.f32[0] = _D1.f32[0] / v20;
  float v10 = v12;
LABEL_10:
  float v21 = (float)-v10 / v20;
  a1[4].i32[0] = _D1.i32[0];
  a1[4].f32[1] = v21;
  float32x2_t v22 = a1[3];
  int8x8_t v23 = (int8x8_t)__PAIR64__(LODWORD(v21), _D1.u32[0]);
  if (vaddv_f32(vmul_f32(v22, (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vorr_s8((int8x8_t)vcgt_f32(0, _D1), (int8x8_t)vcge_f32(_D1, 0)), 0), (int8x8_t)__PAIR64__(LODWORD(v21), _D1.u32[0]), (int8x8_t)v22))) < 0.0)
  {
    _D1.f32[1] = v21;
    int8x8_t v23 = (int8x8_t)vneg_f32(_D1);
    a1[4] = (float32x2_t)v23;
    _D1.i32[0] = v23.i32[0];
  }
  float result = vaddv_f32(vmul_f32(v9, (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vorr_s8((int8x8_t)vcgt_f32(0, _D1), (int8x8_t)vcge_f32(_D1, 0)), 0), v23, (int8x8_t)v22)));
  a1[5].f32[0] = result;
  return result;
}

uint64_t sub_1DC301990(uint64_t a1, int32x2_t a2)
{
  double v4 = *(double *)(a1 + 8);
  uint64_t v5 = *(int32x4_t **)a1;
  if ((LODWORD(v4) & 0x80000000) != 0
    || v5->i64[1] <= (unint64_t)LODWORD(v4)
    || (HIDWORD(v4) & 0x80000000) != 0
    || v5[1].i64[0] <= (unint64_t)HIDWORD(v4))
  {
    unsigned int v6 = -1;
  }
  else
  {
    unsigned int v6 = sub_1DC3A8728(v5, v4);
    double v4 = *(double *)(a1 + 8);
    uint64_t v5 = *(int32x4_t **)a1;
  }
  double v7 = COERCE_DOUBLE(vadd_s32(*(int32x2_t *)&v4, a2));
  if ((LODWORD(v7) & 0x80000000) != 0
    || v5->i64[1] <= (unint64_t)LODWORD(v7)
    || (HIDWORD(v7) & 0x80000000) != 0
    || v5[1].i64[0] <= (unint64_t)HIDWORD(v7))
  {
    int v8 = -1;
  }
  else
  {
    int v8 = sub_1DC3A8728(v5, v7);
  }
  if (v8 == v6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v6;
  }
}

BOOL sub_1DC301A44(int32x4_t *a1, int32x4_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      int32x4_t v3 = a2[-1];
      int32x4_t v4 = *a1;
      if (vmovn_s32(vcgtq_s32(*a1, v3)).i32[1])
      {
        *a1 = v3;
        a2[-1] = v4;
      }
      return 1;
    case 3:
      int32x4_t v11 = *a1;
      int32x4_t v12 = a1[1];
      int32x4_t v13 = a2[-1];
      __int8 v14 = vmovn_s32(vcgtq_s32(v12, v13)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v12)).i32[1] & 1) == 0)
      {
        if ((v14 & 1) == 0) {
          return 1;
        }
        a1[1] = v13;
        a2[-1] = v12;
        int32x4_t v29 = a1[1];
        goto LABEL_70;
      }
      if (v14)
      {
        *a1 = v13;
      }
      else
      {
        *a1 = v12;
        a1[1] = v11;
        int32x4_t v39 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v11, v39)).i32[1] & 1) == 0) {
          return 1;
        }
        a1[1] = v39;
      }
      a2[-1] = v11;
      return 1;
    case 4:
      int8x8_t v23 = a1 + 1;
      int32x4_t v24 = a1[1];
      unint64_t v25 = a1 + 2;
      int32x4_t v26 = a1[2];
      int32x4_t v27 = *a1;
      __int8 v28 = vmovn_s32(vcgtq_s32(v24, v26)).i8[4];
      if (vmovn_s32(vcgtq_s32(*a1, v24)).i32[1])
      {
        if (v28)
        {
          *a1 = v26;
        }
        else
        {
          *a1 = v24;
          a1[1] = v27;
          if ((vmovn_s32(vcgtq_s32(v27, v26)).i32[1] & 1) == 0) {
            goto LABEL_54;
          }
          *int8x8_t v23 = v26;
        }
        int32x4_t v30 = a1 + 2;
        int32x4_t v24 = v27;
        goto LABEL_52;
      }
      if ((v28 & 1) == 0) {
        goto LABEL_54;
      }
      *int8x8_t v23 = v26;
      *unint64_t v25 = v24;
      if (vmovn_s32(vcgtq_s32(v27, v26)).i32[1])
      {
        *a1 = v26;
        int32x4_t v30 = a1 + 1;
LABEL_52:
        *int32x4_t v30 = v27;
      }
      int32x4_t v26 = v24;
LABEL_54:
      int32x4_t v41 = a2[-1];
      if ((vmovn_s32(vcgtq_s32(v26, v41)).i32[1] & 1) == 0) {
        return 1;
      }
      *unint64_t v25 = v41;
      a2[-1] = v26;
      int32x4_t v29 = *v25;
      int32x4_t v42 = *v23;
      goto LABEL_68;
    case 5:
      int32x2_t v15 = a1 + 1;
      int32x4_t v16 = a1[1];
      uint64_t v17 = a1 + 2;
      int32x4_t v18 = a1[2];
      int32x4_t v19 = *a1;
      __int8 v20 = vmovn_s32(vcgtq_s32(v16, v18)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v16)).i32[1] & 1) == 0)
      {
        if ((v20 & 1) == 0)
        {
          int32x4_t v40 = *a1;
          int32x4_t v19 = a1[1];
          goto LABEL_60;
        }
        *int32x2_t v15 = v18;
        *uint64_t v17 = v16;
        if ((vmovn_s32(vcgtq_s32(v19, v18)).i32[1] & 1) == 0)
        {
          int32x4_t v40 = v19;
          int32x4_t v19 = v18;
          goto LABEL_59;
        }
        *a1 = v18;
        float v21 = a1 + 1;
        int32x4_t v22 = v19;
LABEL_48:
        *float v21 = v19;
        int32x4_t v40 = v18;
        int32x4_t v19 = v22;
LABEL_59:
        int32x4_t v18 = v16;
        goto LABEL_60;
      }
      if (v20)
      {
        *a1 = v18;
        float v21 = a1 + 2;
        int32x4_t v22 = v16;
LABEL_47:
        int32x4_t v16 = v19;
        goto LABEL_48;
      }
      *a1 = v16;
      a1[1] = v19;
      if (vmovn_s32(vcgtq_s32(v19, v18)).i32[1])
      {
        int32x4_t v22 = v18;
        *int32x2_t v15 = v18;
        float v21 = a1 + 2;
        int32x4_t v18 = v16;
        goto LABEL_47;
      }
      int32x4_t v40 = v16;
LABEL_60:
      int32x4_t v43 = a1[3];
      if (vmovn_s32(vcgtq_s32(v18, v43)).i32[1])
      {
        a1[2] = v43;
        a1[3] = v18;
        if (vmovn_s32(vcgtq_s32(v19, v43)).i32[1])
        {
          *int32x2_t v15 = v43;
          *uint64_t v17 = v19;
          if (vmovn_s32(vcgtq_s32(v40, v43)).i32[1])
          {
            *a1 = v43;
            a1[1] = v40;
          }
        }
      }
      else
      {
        int32x4_t v18 = a1[3];
      }
      int32x4_t v44 = a2[-1];
      if (vmovn_s32(vcgtq_s32(v18, v44)).i32[1])
      {
        a1[3] = v44;
        a2[-1] = v18;
        int32x4_t v45 = a1[2];
        int32x4_t v29 = a1[3];
        if (vmovn_s32(vcgtq_s32(v45, v29)).i32[1])
        {
          a1[2] = v29;
          a1[3] = v45;
          int32x4_t v42 = a1[1];
LABEL_68:
          if (vmovn_s32(vcgtq_s32(v42, v29)).i32[1])
          {
            a1[1] = v29;
            a1[2] = v42;
LABEL_70:
            int32x4_t v46 = *a1;
            if (vmovn_s32(vcgtq_s32(*a1, v29)).i32[1])
            {
              *a1 = v29;
              a1[1] = v46;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v5 = a1 + 2;
      int32x4_t v6 = a1[2];
      double v7 = a1 + 1;
      int32x4_t v8 = a1[1];
      int32x4_t v9 = *a1;
      __int8 v10 = vmovn_s32(vcgtq_s32(v8, v6)).i8[4];
      if (vmovn_s32(vcgtq_s32(*a1, v8)).i32[1])
      {
        if (v10)
        {
          *a1 = v6;
        }
        else
        {
          *a1 = v8;
          a1[1] = v9;
          if ((vmovn_s32(vcgtq_s32(v9, v6)).i32[1] & 1) == 0) {
            goto LABEL_31;
          }
          int32x4_t *v7 = v6;
        }
        double v7 = a1 + 2;
        goto LABEL_30;
      }
      if (v10)
      {
        int32x4_t *v7 = v6;
        *uint64_t v5 = v8;
        if (vmovn_s32(vcgtq_s32(v9, v6)).i32[1])
        {
          *a1 = v6;
LABEL_30:
          int32x4_t *v7 = v9;
        }
      }
LABEL_31:
      float32x2_t v31 = a1 + 3;
      if (&a1[3] == a2) {
        return 1;
      }
      uint64_t v32 = 0;
      int v33 = 0;
      while (1)
      {
        int32x4_t v34 = *v31;
        __int32 v35 = v31->i64[1];
        if (v35 < v5->i32[2])
        {
          uint64_t v36 = v32;
          while (1)
          {
            *(int32x4_t *)((char *)&a1[3] + v36) = *(int32x4_t *)((char *)&a1[2] + v36);
            if (v36 == -32) {
              break;
            }
            __int32 v37 = *(__int32 *)((char *)&a1[1].i32[2] + v36);
            v36 -= 16;
            if (v35 >= v37)
            {
              int32x2_t v38 = (int32x4_t *)((char *)a1 + v36 + 48);
              goto LABEL_39;
            }
          }
          int32x2_t v38 = a1;
LABEL_39:
          *int32x2_t v38 = v34;
          if (++v33 == 8) {
            return &v31[1] == a2;
          }
        }
        uint64_t v5 = v31;
        v32 += 16;
        if (++v31 == a2) {
          return 1;
        }
      }
  }
}

BOOL sub_1DC301E70(unsigned __int8 *a1, int a2, double a3)
{
  if ((LODWORD(a3) & 0x80000000) != 0
    || *((void *)a1 + 1) <= (unint64_t)LODWORD(a3)
    || (HIDWORD(a3) & 0x80000000) != 0
    || *((void *)a1 + 2) <= (unint64_t)HIDWORD(a3))
  {
    int v4 = -1;
  }
  else
  {
    int v4 = *a1 != sub_1DC2FF924(*((void **)a1 + 3), LODWORD(a3), HIDWORD(a3));
  }
  return v4 == a2;
}

BOOL sub_1DC301EE0(int32x2_t *a1, float a2)
{
  int v3 = 0;
  signed int v4 = (int)(float)((float)(a2 * 3.0) + a2);
  int v5 = (int)(float)((float)(a2 * 3.0) - a2);
  double v6 = *(double *)&a1[1];
  char v7 = 1;
  while (2)
  {
    uint64_t v8 = 0;
    signed int v9 = 0;
    char v10 = 1;
    do
    {
      char v11 = v10;
      *(double *)&a1[1] = v6;
      a1[2] = qword_1DC3FE0B0[2 * (v7 & 1) + v8];
      int v12 = sub_1DC302B2C(a1, 1, v4, 0, 1);
      if (v12 == -1) {
        return 0;
      }
      char v10 = 0;
      v9 += v12;
      uint64_t v8 = 1;
    }
    while ((v11 & 1) != 0);
    if (v3 && (v9 + 1 < v5 || v9 >= v4)) {
      return 0;
    }
    v7 ^= 1u;
    double v16 = *(double *)&a1[1];
    *(_DWORD *)((unint64_t)&v16 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v7 & 1))) -= (v9 + 1) / 2;
    double v6 = v16;
    *(double *)&a1[1] = v16;
    if (++v3 != 4) {
      continue;
    }
    break;
  }
  int32x4_t v13 = (unsigned __int8 *)*a1;
  int v14 = a1[3].i32[0];
  return sub_1DC301E70(v13, v14, v6);
}

uint64_t sub_1DC30204C(uint64_t result, int32x4_t *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  char v10 = (int32x4_t *)v9;
  while (1)
  {
    unint64_t v9 = (unint64_t)v10;
    uint64_t v11 = (char *)a2 - (char *)v10;
    unint64_t v12 = a2 - v10;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          int32x4_t v73 = a2[-1];
          int32x4_t v74 = *v10;
          if (vmovn_s32(vcgtq_s32(*v10, v73)).i32[1])
          {
            *char v10 = v73;
            a2[-1] = v74;
          }
          return result;
        case 3uLL:
          int32x4_t v75 = *v10;
          int32x4_t v76 = v10[1];
          int32x4_t v77 = a2[-1];
          __int8 v78 = vmovn_s32(vcgtq_s32(v76, v77)).i8[4];
          if ((vmovn_s32(vcgtq_s32(*v10, v76)).i32[1] & 1) == 0)
          {
            if ((v78 & 1) == 0) {
              return result;
            }
            v10[1] = v77;
            a2[-1] = v76;
            int32x4_t v128 = v10[1];
            goto LABEL_201;
          }
          if (v78)
          {
            *char v10 = v77;
          }
          else
          {
            *char v10 = v76;
            v10[1] = v75;
            int32x4_t v134 = a2[-1];
            if ((vmovn_s32(vcgtq_s32(v75, v134)).i32[1] & 1) == 0) {
              return result;
            }
            v10[1] = v134;
          }
          a2[-1] = v75;
          return result;
        case 4uLL:
          v87 = v10 + 1;
          int32x4_t v88 = v10[1];
          v89 = v10 + 2;
          int32x4_t v90 = v10[2];
          int32x4_t v91 = *v10;
          __int8 v92 = vmovn_s32(vcgtq_s32(v88, v90)).i8[4];
          if (vmovn_s32(vcgtq_s32(*v10, v88)).i32[1])
          {
            if (v92)
            {
              *char v10 = v90;
            }
            else
            {
              *char v10 = v88;
              v10[1] = v91;
              if ((vmovn_s32(vcgtq_s32(v91, v90)).i32[1] & 1) == 0) {
                goto LABEL_186;
              }
              int32x4_t *v87 = v90;
            }
            uint64_t v129 = v10 + 2;
            int32x4_t v88 = v91;
            goto LABEL_184;
          }
          if ((v92 & 1) == 0) {
            goto LABEL_186;
          }
          int32x4_t *v87 = v90;
          int32x4_t *v89 = v88;
          if (vmovn_s32(vcgtq_s32(v91, v90)).i32[1])
          {
            *char v10 = v90;
            uint64_t v129 = v10 + 1;
LABEL_184:
            int32x4_t *v129 = v91;
          }
          int32x4_t v90 = v88;
LABEL_186:
          int32x4_t v136 = a2[-1];
          if ((vmovn_s32(vcgtq_s32(v90, v136)).i32[1] & 1) == 0) {
            return result;
          }
          int32x4_t *v89 = v136;
          a2[-1] = v90;
          int32x4_t v128 = *v89;
          int32x4_t v137 = *v87;
          goto LABEL_199;
        case 5uLL:
          uint64_t v79 = v10 + 1;
          int32x4_t v80 = v10[1];
          v81 = v10 + 2;
          int32x4_t v82 = v10[2];
          int32x4_t v83 = *v10;
          __int8 v84 = vmovn_s32(vcgtq_s32(v80, v82)).i8[4];
          if (vmovn_s32(vcgtq_s32(*v10, v80)).i32[1])
          {
            if (v84)
            {
              *char v10 = v82;
              uint64_t v85 = v10 + 2;
              int32x4_t v86 = v80;
            }
            else
            {
              *char v10 = v80;
              v10[1] = v83;
              if ((vmovn_s32(vcgtq_s32(v83, v82)).i32[1] & 1) == 0)
              {
                int32x4_t v135 = v80;
LABEL_191:
                int32x4_t v138 = v10[3];
                if (vmovn_s32(vcgtq_s32(v82, v138)).i32[1])
                {
                  v10[2] = v138;
                  v10[3] = v82;
                  if (vmovn_s32(vcgtq_s32(v83, v138)).i32[1])
                  {
                    int32x4_t *v79 = v138;
                    int32x4_t *v81 = v83;
                    if (vmovn_s32(vcgtq_s32(v135, v138)).i32[1])
                    {
                      *char v10 = v138;
                      v10[1] = v135;
                    }
                  }
                }
                else
                {
                  int32x4_t v82 = v10[3];
                }
                int32x4_t v139 = a2[-1];
                if ((vmovn_s32(vcgtq_s32(v82, v139)).i32[1] & 1) == 0) {
                  return result;
                }
                v10[3] = v139;
                a2[-1] = v82;
                int32x4_t v140 = v10[2];
                int32x4_t v128 = v10[3];
                if ((vmovn_s32(vcgtq_s32(v140, v128)).i32[1] & 1) == 0) {
                  return result;
                }
                v10[2] = v128;
                v10[3] = v140;
                int32x4_t v137 = v10[1];
LABEL_199:
                if (vmovn_s32(vcgtq_s32(v137, v128)).i32[1])
                {
                  v10[1] = v128;
                  v10[2] = v137;
LABEL_201:
                  int32x4_t v141 = *v10;
                  if (vmovn_s32(vcgtq_s32(*v10, v128)).i32[1])
                  {
                    *char v10 = v128;
                    v10[1] = v141;
                  }
                }
                return result;
              }
              int32x4_t v86 = v82;
              int32x4_t *v79 = v82;
              uint64_t v85 = v10 + 2;
              int32x4_t v82 = v80;
            }
            int32x4_t v80 = v83;
          }
          else
          {
            if ((v84 & 1) == 0)
            {
              int32x4_t v135 = *v10;
              int32x4_t v83 = v10[1];
              goto LABEL_191;
            }
            int32x4_t *v79 = v82;
            int32x4_t *v81 = v80;
            if ((vmovn_s32(vcgtq_s32(v83, v82)).i32[1] & 1) == 0)
            {
              int32x4_t v135 = v83;
              int32x4_t v83 = v82;
              goto LABEL_190;
            }
            *char v10 = v82;
            uint64_t v85 = v10 + 1;
            int32x4_t v86 = v83;
          }
          int32x4_t *v85 = v83;
          int32x4_t v135 = v82;
          int32x4_t v83 = v86;
LABEL_190:
          int32x4_t v82 = v80;
          goto LABEL_191;
        default:
          JUMPOUT(0);
      }
    }
    if (v11 <= 383) {
      break;
    }
    if (!a3)
    {
      if (v10 != a2)
      {
        int64_t v103 = (v12 - 2) >> 1;
        int64_t v104 = v103;
        do
        {
          int64_t v105 = v104;
          if (v103 >= v104)
          {
            uint64_t v106 = (2 * v104) | 1;
            v107 = &v10[v106];
            if (2 * v105 + 2 < (uint64_t)v12)
            {
              BOOL v108 = v107->i32[2] < v107[1].i32[2];
              v107 += v108;
              if (v108) {
                uint64_t v106 = 2 * v105 + 2;
              }
            }
            int v109 = &v10[v105];
            int32x4_t v110 = *v109;
            int v111 = v109->i64[1];
            if (v107->i32[2] >= v111)
            {
              do
              {
                uint64_t v112 = v107;
                int32x4_t *v109 = *v107;
                if (v103 < v106) {
                  break;
                }
                uint64_t v113 = (2 * v106) | 1;
                v107 = &v10[v113];
                uint64_t v114 = 2 * v106 + 2;
                if (v114 < (uint64_t)v12)
                {
                  BOOL v108 = v107->i32[2] < v107[1].i32[2];
                  v107 += v108;
                  if (v108) {
                    uint64_t v113 = v114;
                  }
                }
                float result = v107->u32[2];
                int v109 = v112;
                uint64_t v106 = v113;
              }
              while ((int)result >= v111);
              int32x4_t *v112 = v110;
            }
          }
          int64_t v104 = v105 - 1;
        }
        while (v105);
        uint64_t v115 = (unint64_t)v11 >> 4;
        do
        {
          uint64_t v116 = 0;
          int32x4_t v117 = *v10;
          long long v118 = v10;
          do
          {
            uint64_t v119 = (uint64_t)&v118[v116 + 1];
            uint64_t v120 = (2 * v116) | 1;
            uint64_t v121 = 2 * v116 + 2;
            if (v121 < v115)
            {
              BOOL v108 = *(_DWORD *)(v119 + 8) < *(_DWORD *)(v119 + 24);
              v119 += 16 * v108;
              if (v108) {
                uint64_t v120 = v121;
              }
            }
            _OWORD *v118 = *(_OWORD *)v119;
            long long v118 = (_OWORD *)v119;
            uint64_t v116 = v120;
          }
          while (v120 <= (uint64_t)((unint64_t)(v115 - 2) >> 1));
          if ((int32x4_t *)v119 == --a2)
          {
            *(int32x4_t *)uint64_t v119 = v117;
          }
          else
          {
            *(int32x4_t *)uint64_t v119 = *a2;
            *a2 = v117;
            uint64_t v122 = v119 - (void)v10 + 16;
            if (v122 >= 17)
            {
              unint64_t v123 = (((unint64_t)v122 >> 4) - 2) >> 1;
              int v124 = &v10[v123];
              int32x4_t v125 = *(int32x4_t *)v119;
              __int32 v126 = *(void *)(v119 + 8);
              if (v124->i32[2] < v126)
              {
                do
                {
                  long long v127 = v124;
                  *(int32x4_t *)uint64_t v119 = *v124;
                  if (!v123) {
                    break;
                  }
                  unint64_t v123 = (v123 - 1) >> 1;
                  int v124 = &v10[v123];
                  uint64_t v119 = (uint64_t)v127;
                }
                while (v124->i32[2] < v126);
                int32x4_t *v127 = v125;
              }
            }
          }
          BOOL v108 = v115-- <= 2;
        }
        while (!v108);
      }
      return result;
    }
    unint64_t v13 = v12 >> 1;
    int v14 = &v10[v12 >> 1];
    int32x4_t v15 = a2[-1];
    if ((unint64_t)v11 >= 0x801)
    {
      int32x4_t v16 = *v14;
      int32x4_t v17 = *v10;
      __int8 v18 = vmovn_s32(vcgtq_s32(*v14, v15)).i8[4];
      if (vmovn_s32(vcgtq_s32(*v10, *v14)).i32[1])
      {
        if (v18)
        {
          *char v10 = v15;
          goto LABEL_22;
        }
        *char v10 = v16;
        int32x4_t *v14 = v17;
        int32x4_t v24 = a2[-1];
        if (vmovn_s32(vcgtq_s32(v17, v24)).i32[1])
        {
          int32x4_t *v14 = v24;
LABEL_22:
          a2[-1] = v17;
        }
      }
      else if (v18)
      {
        int32x4_t *v14 = v15;
        a2[-1] = v16;
        int32x4_t v22 = *v10;
        if (vmovn_s32(vcgtq_s32(*v10, *v14)).i32[1])
        {
          *char v10 = *v14;
          int32x4_t *v14 = v22;
        }
      }
      unint64_t v25 = v13 - 1;
      int32x4_t v26 = v10[v13 - 1];
      int32x4_t v27 = v10[1];
      int32x4_t v28 = a2[-2];
      __int8 v29 = vmovn_s32(vcgtq_s32(v26, v28)).i8[4];
      if (vmovn_s32(vcgtq_s32(v27, v26)).i32[1])
      {
        if (v29)
        {
          v10[1] = v28;
          goto LABEL_34;
        }
        v10[1] = v26;
        v10[v25] = v27;
        int32x4_t v33 = a2[-2];
        if (vmovn_s32(vcgtq_s32(v27, v33)).i32[1])
        {
          v10[v25] = v33;
LABEL_34:
          a2[-2] = v27;
        }
      }
      else if (v29)
      {
        v10[v25] = v28;
        a2[-2] = v26;
        int32x4_t v30 = v10[v25];
        int32x4_t v31 = v10[1];
        if (vmovn_s32(vcgtq_s32(v31, v30)).i32[1])
        {
          v10[1] = v30;
          v10[v25] = v31;
        }
      }
      int32x4_t v34 = &v10[v13];
      int32x4_t v36 = v34[1];
      __int32 v35 = v34 + 1;
      int32x4_t v37 = v36;
      int32x4_t v38 = v10[2];
      int32x4_t v39 = a2[-3];
      __int8 v40 = vmovn_s32(vcgtq_s32(v36, v39)).i8[4];
      if (vmovn_s32(vcgtq_s32(v38, v36)).i32[1])
      {
        if (v40)
        {
          v10[2] = v39;
          goto LABEL_43;
        }
        v10[2] = v37;
        int32x4_t *v35 = v38;
        int32x4_t v42 = a2[-3];
        if (vmovn_s32(vcgtq_s32(v38, v42)).i32[1])
        {
          int32x4_t *v35 = v42;
LABEL_43:
          a2[-3] = v38;
        }
      }
      else if (v40)
      {
        int32x4_t *v35 = v39;
        a2[-3] = v37;
        int32x4_t v41 = v10[2];
        if (vmovn_s32(vcgtq_s32(v41, *v35)).i32[1])
        {
          v10[2] = *v35;
          int32x4_t *v35 = v41;
        }
      }
      int32x4_t v43 = *v14;
      int32x4_t v44 = v10[v25];
      int32x4_t v45 = *v35;
      __int8 v46 = vmovn_s32(vcgtq_s32(*v14, *v35)).i8[4];
      if (vmovn_s32(vcgtq_s32(v44, *v14)).i32[1])
      {
        if (v46)
        {
          v10[v25] = v45;
          goto LABEL_52;
        }
        v10[v25] = v43;
        int32x4_t *v14 = v44;
        if (vmovn_s32(vcgtq_s32(v44, v45)).i32[1])
        {
          int32x4_t *v14 = v45;
          int32x4_t v43 = v45;
LABEL_52:
          int32x4_t *v35 = v44;
        }
        else
        {
          int32x4_t v43 = v44;
        }
      }
      else if (v46)
      {
        int32x4_t *v14 = v45;
        int32x4_t *v35 = v43;
        if (vmovn_s32(vcgtq_s32(v44, v45)).i32[1])
        {
          v10[v25] = v45;
          __int32 v35 = &v10[v12 >> 1];
          int32x4_t v43 = v44;
          goto LABEL_52;
        }
        int32x4_t v43 = v45;
      }
      int32x4_t v47 = *v10;
      *char v10 = v43;
      int32x4_t *v14 = v47;
      goto LABEL_54;
    }
    int32x4_t v19 = *v10;
    int32x4_t v20 = *v14;
    __int8 v21 = vmovn_s32(vcgtq_s32(*v10, v15)).i8[4];
    if ((vmovn_s32(vcgtq_s32(*v14, *v10)).i32[1] & 1) == 0)
    {
      if (v21)
      {
        *char v10 = v15;
        a2[-1] = v19;
        int32x4_t v23 = *v14;
        if (vmovn_s32(vcgtq_s32(*v14, *v10)).i32[1])
        {
          int32x4_t *v14 = *v10;
          *char v10 = v23;
        }
      }
      goto LABEL_54;
    }
    if (v21)
    {
      int32x4_t *v14 = v15;
LABEL_31:
      a2[-1] = v20;
      goto LABEL_54;
    }
    int32x4_t *v14 = v19;
    *char v10 = v20;
    int32x4_t v32 = a2[-1];
    if (vmovn_s32(vcgtq_s32(v20, v32)).i32[1])
    {
      *char v10 = v32;
      goto LABEL_31;
    }
LABEL_54:
    --a3;
    int32x4_t v48 = *v10;
    if (a4)
    {
      __int32 v49 = v10->i64[1];
LABEL_57:
      float32x2_t v50 = v10;
      do
        float32x2_t v51 = v50++;
      while (v51[1].i32[2] < v49);
      float32x2_t v52 = a2;
      if (v51 == v10)
      {
        float32x2_t v55 = a2;
        while (v50 < v55)
        {
          uint64_t v53 = v55 - 1;
          __int32 v56 = v55[-1].i32[2];
          --v55;
          if (v56 < v49) {
            goto LABEL_66;
          }
        }
        uint64_t v53 = v55;
      }
      else
      {
        do
        {
          uint64_t v53 = v52 - 1;
          __int32 v54 = v52[-1].i32[2];
          --v52;
        }
        while (v54 >= v49);
      }
LABEL_66:
      if (v50 < v53)
      {
        int32x2_t v57 = v50;
        int32x2_t v58 = v53;
        do
        {
          int32x4_t v59 = *v57;
          int32x4_t *v57 = *v58;
          int32x4_t *v58 = v59;
          do
            float32x2_t v51 = v57++;
          while (v51[1].i32[2] < v49);
          do
          {
            __int32 v60 = v58[-1].i32[2];
            --v58;
          }
          while (v60 >= v49);
        }
        while (v57 < v58);
      }
      if (v51 != v10) {
        *char v10 = *v51;
      }
      int32x4_t *v51 = v48;
      if (v50 < v53) {
        goto LABEL_77;
      }
      BOOL v61 = sub_1DC302E28(v10, v51);
      char v10 = v51 + 1;
      float result = sub_1DC302E28(v51 + 1, a2);
      if (result)
      {
        a2 = v51;
        if (v61) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v61)
      {
LABEL_77:
        float result = sub_1DC30204C(v9, v51, a3, a4 & 1);
        a4 = 0;
        char v10 = v51 + 1;
      }
    }
    else
    {
      __int32 v49 = v10->i64[1];
      if (v10[-1].i32[2] < v48.i32[2]) {
        goto LABEL_57;
      }
      if (v48.i32[2] < a2[-1].i32[2])
      {
        v62 = v10;
        do
        {
          char v10 = v62 + 1;
          int v63 = v62[1].i32[2];
          ++v62;
        }
        while (v48.i32[2] >= v63);
      }
      else
      {
        unint64_t v64 = (unint64_t)&v10[1];
        do
        {
          char v10 = (int32x4_t *)v64;
          if (v64 >= (unint64_t)a2) {
            break;
          }
          int v65 = *(_DWORD *)(v64 + 8);
          v64 += 16;
        }
        while (v48.i32[2] >= v65);
      }
      float32x2_t v66 = a2;
      if (v10 < a2)
      {
        float32x2_t v67 = a2;
        do
        {
          float32x2_t v66 = v67 - 1;
          int v68 = v67[-1].i32[2];
          --v67;
        }
        while (v48.i32[2] < v68);
      }
      while (v10 < v66)
      {
        int32x4_t v69 = *v10;
        *char v10 = *v66;
        int32x4_t *v66 = v69;
        do
        {
          int v70 = v10[1].i32[2];
          ++v10;
        }
        while (v48.i32[2] >= v70);
        do
        {
          int v71 = v66[-1].i32[2];
          --v66;
        }
        while (v48.i32[2] < v71);
      }
      int8x8_t v72 = v10 - 1;
      BOOL v4 = (unint64_t)&v10[-1] >= v9;
      BOOL v5 = &v10[-1] == (int32x4_t *)v9;
      if (&v10[-1] != (int32x4_t *)v9) {
        *(int32x4_t *)unint64_t v9 = *v72;
      }
      a4 = 0;
      int32x4_t *v72 = v48;
    }
  }
  v93 = v10 + 1;
  BOOL v95 = v10 == a2 || v93 == a2;
  if (a4)
  {
    if (!v95)
    {
      uint64_t v96 = 0;
      float32x2_t v97 = v10;
      do
      {
        int32x4_t v98 = v97[1];
        int v99 = v97->i32[2];
        float32x2_t v97 = v93;
        if (v98.i32[2] < v99)
        {
          uint64_t v100 = v96;
          while (1)
          {
            *(int32x4_t *)((char *)&v10[1] + v100) = *(int32x4_t *)((char *)v10 + v100);
            if (!v100) {
              break;
            }
            int v101 = *(__int32 *)((char *)&v10->i32[-2] + v100);
            v100 -= 16;
            if (v98.i32[2] >= v101)
            {
              float v102 = (int32x4_t *)((char *)v10 + v100 + 16);
              goto LABEL_127;
            }
          }
          float v102 = v10;
LABEL_127:
          int32x4_t *v102 = v98;
        }
        v93 = v97 + 1;
        v96 += 16;
      }
      while (&v97[1] != a2);
    }
  }
  else if (!v95)
  {
    do
    {
      int32x4_t v130 = *(int32x4_t *)(v9 + 16);
      int v131 = *(_DWORD *)(v9 + 8);
      unint64_t v9 = (unint64_t)v93;
      if (v130.i32[2] < v131)
      {
        do
        {
          v132 = v93;
          int32x4_t v133 = v93[-1];
          --v93;
          int32x4_t *v132 = v133;
        }
        while (v130.i32[2] < v132[-2].i32[2]);
        int32x4_t *v93 = v130;
      }
      v93 = (int32x4_t *)(v9 + 16);
    }
    while ((int32x4_t *)(v9 + 16) != a2);
  }
  return result;
}

uint64_t sub_1DC302B2C(int32x2_t *a1, int a2, signed int a3, int a4, int a5)
{
  if (a2 <= 1) {
    int v8 = 1;
  }
  else {
    int v8 = a2;
  }
  if (a5 <= 1) {
    unsigned int v9 = 1;
  }
  else {
    unsigned int v9 = a5;
  }
  int32x2_t v10 = a1[1];
  uint64_t v11 = (unsigned __int8 *)*a1;
  int32x2_t v26 = v10;
  if (v10.i32[0] < 0
    || *((void *)v11 + 1) <= (unint64_t)*(void *)&a1[1]
    || v10.i32[1] < 0
    || *((void *)v11 + 2) <= (unint64_t)v10.u32[1])
  {
    int v13 = -1;
  }
  else
  {
    int v12 = sub_1DC2FF924(*((void **)v11 + 3), v10.u32[0], v10.u32[1]);
    int32x2_t v10 = v26;
    int v13 = *v11 != v12;
  }
  signed int v14 = 0;
  int v15 = 0;
  do
  {
    int v16 = v13;
    if (a3)
    {
      uint64_t result = 0xFFFFFFFFLL;
      if (v14 >= a3 || v13 == -1) {
        return result;
      }
    }
    else if (v13 == -1)
    {
      return 0xFFFFFFFFLL;
    }
    v14 += v9;
    int32x2_t v18 = a1[2];
    int32x2_t v19 = vmla_s32(v10, v18, vdup_n_s32(v14));
    if (v19.i32[0] < 0
      || *((void *)v11 + 1) <= (unint64_t)v19.u32[0]
      || v19.i32[1] < 0
      || *((void *)v11 + 2) <= (unint64_t)v19.u32[1])
    {
      int v13 = -1;
    }
    else
    {
      int v20 = sub_1DC2FF924(*((void **)v11 + 3), v19.u32[0], v19.u32[1]);
      int32x2_t v10 = v26;
      int v13 = *v11 != v20;
    }
    int v21 = v16 != v13 && (int)(v15 + v9) >= a4;
    if (v16 != v13 && (int)(v15 + v9) >= a4) {
      int v15 = 0;
    }
    else {
      v15 += v9;
    }
    v8 -= v21;
  }
  while (v8);
  if (v9 < 2)
  {
LABEL_43:
    unsigned int v25 = v14 - 1;
    uint64_t result = (v14 - 1);
  }
  else
  {
    v14 -= v9;
    int v22 = v13;
    if (!a3) {
      goto LABEL_32;
    }
LABEL_31:
    if (v14 < a3)
    {
LABEL_32:
      while (v22 != -1)
      {
        int32x2_t v23 = vmla_s32(v10, v18, vdup_n_s32(v14));
        if (v23.i32[0] < 0
          || *((void *)v11 + 1) <= (unint64_t)v23.u32[0]
          || v23.i32[1] < 0
          || *((void *)v11 + 2) <= (unint64_t)v23.u32[1])
        {
          int v22 = -1;
        }
        else
        {
          int v24 = sub_1DC2FF924(*((void **)v11 + 3), v23.u32[0], v23.u32[1]);
          int32x2_t v10 = v26;
          int v22 = *v11 != v24;
        }
        if (v22 == v13) {
          goto LABEL_43;
        }
        ++v14;
        if (a3) {
          goto LABEL_31;
        }
      }
    }
    unsigned int v25 = v14 - 1;
    uint64_t result = 0xFFFFFFFFLL;
  }
  a1[1] = vmla_s32(v10, vdup_n_s32(v25), v18);
  return result;
}

uint64_t sub_1DC302D58(unsigned __int8 *a1, int32x2_t a2, int32x2_t a3)
{
  if (a2.i32[0] < 0
    || *((void *)a1 + 1) <= (unint64_t)a2.u32[0]
    || a2.i32[1] < 0
    || *((void *)a1 + 2) <= (unint64_t)a2.u32[1])
  {
    unsigned int v6 = -1;
  }
  else
  {
    int32x2_t v10 = a2;
    int v5 = sub_1DC2FF924(*((void **)a1 + 3), a2.u32[0], a2.u32[1]);
    a2 = v10;
    unsigned int v6 = *a1 != v5;
  }
  int32x2_t v7 = vadd_s32(a2, a3);
  if (v7.i32[0] < 0
    || *((void *)a1 + 1) <= (unint64_t)v7.u32[0]
    || v7.i32[1] < 0
    || *((void *)a1 + 2) <= (unint64_t)v7.u32[1])
  {
    int v8 = -1;
  }
  else
  {
    int v8 = *a1 != sub_1DC2FF924(*((void **)a1 + 3), v7.u32[0], v7.u32[1]);
  }
  if (v8 == v6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v6;
  }
}

BOOL sub_1DC302E28(int32x4_t *a1, int32x4_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      int32x4_t v3 = a2[-1];
      int32x4_t v4 = *a1;
      if (vmovn_s32(vcgtq_s32(*a1, v3)).i32[1])
      {
        *a1 = v3;
        a2[-1] = v4;
      }
      return 1;
    case 3:
      int32x4_t v11 = *a1;
      int32x4_t v12 = a1[1];
      int32x4_t v13 = a2[-1];
      __int8 v14 = vmovn_s32(vcgtq_s32(v12, v13)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v12)).i32[1] & 1) == 0)
      {
        if ((v14 & 1) == 0) {
          return 1;
        }
        a1[1] = v13;
        a2[-1] = v12;
        int32x4_t v29 = a1[1];
        goto LABEL_70;
      }
      if (v14)
      {
        *a1 = v13;
      }
      else
      {
        *a1 = v12;
        a1[1] = v11;
        int32x4_t v39 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v11, v39)).i32[1] & 1) == 0) {
          return 1;
        }
        a1[1] = v39;
      }
      a2[-1] = v11;
      return 1;
    case 4:
      int32x2_t v23 = a1 + 1;
      int32x4_t v24 = a1[1];
      unsigned int v25 = a1 + 2;
      int32x4_t v26 = a1[2];
      int32x4_t v27 = *a1;
      __int8 v28 = vmovn_s32(vcgtq_s32(v24, v26)).i8[4];
      if (vmovn_s32(vcgtq_s32(*a1, v24)).i32[1])
      {
        if (v28)
        {
          *a1 = v26;
        }
        else
        {
          *a1 = v24;
          a1[1] = v27;
          if ((vmovn_s32(vcgtq_s32(v27, v26)).i32[1] & 1) == 0) {
            goto LABEL_54;
          }
          *int32x2_t v23 = v26;
        }
        int32x4_t v30 = a1 + 2;
        int32x4_t v24 = v27;
        goto LABEL_52;
      }
      if ((v28 & 1) == 0) {
        goto LABEL_54;
      }
      *int32x2_t v23 = v26;
      *unsigned int v25 = v24;
      if (vmovn_s32(vcgtq_s32(v27, v26)).i32[1])
      {
        *a1 = v26;
        int32x4_t v30 = a1 + 1;
LABEL_52:
        *int32x4_t v30 = v27;
      }
      int32x4_t v26 = v24;
LABEL_54:
      int32x4_t v41 = a2[-1];
      if ((vmovn_s32(vcgtq_s32(v26, v41)).i32[1] & 1) == 0) {
        return 1;
      }
      *unsigned int v25 = v41;
      a2[-1] = v26;
      int32x4_t v29 = *v25;
      int32x4_t v42 = *v23;
      goto LABEL_68;
    case 5:
      int v15 = a1 + 1;
      int32x4_t v16 = a1[1];
      int32x4_t v17 = a1 + 2;
      int32x4_t v18 = a1[2];
      int32x4_t v19 = *a1;
      __int8 v20 = vmovn_s32(vcgtq_s32(v16, v18)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v16)).i32[1] & 1) == 0)
      {
        if ((v20 & 1) == 0)
        {
          int32x4_t v40 = *a1;
          int32x4_t v19 = a1[1];
          goto LABEL_60;
        }
        *int v15 = v18;
        *int32x4_t v17 = v16;
        if ((vmovn_s32(vcgtq_s32(v19, v18)).i32[1] & 1) == 0)
        {
          int32x4_t v40 = v19;
          int32x4_t v19 = v18;
          goto LABEL_59;
        }
        *a1 = v18;
        int v21 = a1 + 1;
        int32x4_t v22 = v19;
LABEL_48:
        *int v21 = v19;
        int32x4_t v40 = v18;
        int32x4_t v19 = v22;
LABEL_59:
        int32x4_t v18 = v16;
        goto LABEL_60;
      }
      if (v20)
      {
        *a1 = v18;
        int v21 = a1 + 2;
        int32x4_t v22 = v16;
LABEL_47:
        int32x4_t v16 = v19;
        goto LABEL_48;
      }
      *a1 = v16;
      a1[1] = v19;
      if (vmovn_s32(vcgtq_s32(v19, v18)).i32[1])
      {
        int32x4_t v22 = v18;
        *int v15 = v18;
        int v21 = a1 + 2;
        int32x4_t v18 = v16;
        goto LABEL_47;
      }
      int32x4_t v40 = v16;
LABEL_60:
      int32x4_t v43 = a1[3];
      if (vmovn_s32(vcgtq_s32(v18, v43)).i32[1])
      {
        a1[2] = v43;
        a1[3] = v18;
        if (vmovn_s32(vcgtq_s32(v19, v43)).i32[1])
        {
          *int v15 = v43;
          *int32x4_t v17 = v19;
          if (vmovn_s32(vcgtq_s32(v40, v43)).i32[1])
          {
            *a1 = v43;
            a1[1] = v40;
          }
        }
      }
      else
      {
        int32x4_t v18 = a1[3];
      }
      int32x4_t v44 = a2[-1];
      if (vmovn_s32(vcgtq_s32(v18, v44)).i32[1])
      {
        a1[3] = v44;
        a2[-1] = v18;
        int32x4_t v45 = a1[2];
        int32x4_t v29 = a1[3];
        if (vmovn_s32(vcgtq_s32(v45, v29)).i32[1])
        {
          a1[2] = v29;
          a1[3] = v45;
          int32x4_t v42 = a1[1];
LABEL_68:
          if (vmovn_s32(vcgtq_s32(v42, v29)).i32[1])
          {
            a1[1] = v29;
            a1[2] = v42;
LABEL_70:
            int32x4_t v46 = *a1;
            if (vmovn_s32(vcgtq_s32(*a1, v29)).i32[1])
            {
              *a1 = v29;
              a1[1] = v46;
            }
          }
        }
      }
      return 1;
    default:
      int v5 = a1 + 2;
      int32x4_t v6 = a1[2];
      int32x2_t v7 = a1 + 1;
      int32x4_t v8 = a1[1];
      int32x4_t v9 = *a1;
      __int8 v10 = vmovn_s32(vcgtq_s32(v8, v6)).i8[4];
      if (vmovn_s32(vcgtq_s32(*a1, v8)).i32[1])
      {
        if (v10)
        {
          *a1 = v6;
        }
        else
        {
          *a1 = v8;
          a1[1] = v9;
          if ((vmovn_s32(vcgtq_s32(v9, v6)).i32[1] & 1) == 0) {
            goto LABEL_31;
          }
          int32x4_t *v7 = v6;
        }
        int32x2_t v7 = a1 + 2;
        goto LABEL_30;
      }
      if (v10)
      {
        int32x4_t *v7 = v6;
        *int v5 = v8;
        if (vmovn_s32(vcgtq_s32(v9, v6)).i32[1])
        {
          *a1 = v6;
LABEL_30:
          int32x4_t *v7 = v9;
        }
      }
LABEL_31:
      int32x4_t v31 = a1 + 3;
      if (&a1[3] == a2) {
        return 1;
      }
      uint64_t v32 = 0;
      int v33 = 0;
      while (1)
      {
        int32x4_t v34 = *v31;
        __int32 v35 = v31->i64[1];
        if (v35 < v5->i32[2])
        {
          uint64_t v36 = v32;
          while (1)
          {
            *(int32x4_t *)((char *)&a1[3] + v36) = *(int32x4_t *)((char *)&a1[2] + v36);
            if (v36 == -32) {
              break;
            }
            __int32 v37 = *(__int32 *)((char *)&a1[1].i32[2] + v36);
            v36 -= 16;
            if (v35 >= v37)
            {
              int32x4_t v38 = (int32x4_t *)((char *)a1 + v36 + 48);
              goto LABEL_39;
            }
          }
          int32x4_t v38 = a1;
LABEL_39:
          *int32x4_t v38 = v34;
          if (++v33 == 8) {
            return &v31[1] == a2;
          }
        }
        int v5 = v31;
        v32 += 16;
        if (++v31 == a2) {
          return 1;
        }
      }
  }
}

float sub_1DC303254(float *a1, uint64_t a2, float result, uint64_t a4, int a5, uint64_t a6)
{
  if (a5 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t result = a1[2];
    float v7 = *a1;
    float v8 = -a1[1];
    int32x4_t v9 = (float *)(a2 + 8);
    do
    {
      if (v6) {
        float v10 = 1.0;
      }
      else {
        float v10 = -1.0;
      }
      float v11 = *(float *)(a6 + 4 * v6) + (float)(v7 * v10);
      float v12 = (float)(v8 * v11) + 1.0;
      float v13 = v11 / v12;
      *(v9 - 2) = (float)(result * v10) / (float)(v12 * v12);
      *(v9 - 1) = v13 * (float)(result * v13);
      *int32x4_t v9 = v13;
      v9 += 3;
      ++v6;
    }
    while (a5 != v6);
  }
  return result;
}

void sub_1DC3032C0()
{
}

uint64_t sub_1DC3032D8(unint64_t *a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t *a10, uint64_t *a11, unint64_t *a12, unint64_t *a13, uint64_t a14, uint64_t *a15, os_signpost_id_t *a16, dispatch_group_t *a17, uint64_t a18, dispatch_group_t *p_group, dispatch_group_t group,void (*a21)(void),CFErrorRef a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,void *a37,unint64_t a38,char a39,unsigned char *a40,char a41,uint64_t a42,uint64_t a43,char a44,long long a45,uint64_t a46,timespec a47,char a48,timespec __tp,char a50,os_signpost_id_t a51,void *a52,uint64_t a53,char a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,long long a60,int *a61,uint64_t a62,uint64_t a63)
{
  STACK[0x1498] = *MEMORY[0x1E4F143B8];
  int32x4_t v74 = (atomic_ullong **)(a3 + 16);
  int32x4_t v73 = *(atomic_ullong **)(a3 + 16);
  a53 = a3 + 16;
  if (!sub_1DC383628(v73))
  {
LABEL_12:
    a54 = 0;
    STACK[0xF20] = -2002;
    STACK[0x12E0] = (unint64_t)@"Unable to acquire CVPixelBuffer lock.";
    sub_1DC306334((atomic_ullong *)a5, (uint64_t *)&STACK[0xF20], (CFTypeRef *)&STACK[0x12E0]);
LABEL_13:
    *a1 = 0;
    return sub_1DC3072AC((uint64_t)&a53);
  }
  int32x4_t v75 = *(uint64_t **)(a3 + 72);
  if (v75)
  {
    for (uint64_t i = *v75; ; i += 216)
    {
      if (i == v75[1]) {
        goto LABEL_14;
      }
      char v77 = sub_1DC383628((atomic_ullong *)(i + 8));
      int32x4_t v75 = *(uint64_t **)(a3 + 72);
      if ((v77 & 1) == 0) {
        break;
      }
    }
    while (i != *v75)
    {
      if ((sub_1DC383690((atomic_ullong *)(i - 208)) & 1) == 0) {
        _os_assumes_log();
      }
      i -= 216;
      int32x4_t v75 = *(uint64_t **)(a3 + 72);
    }
    sub_1DC383690(*v74);
    goto LABEL_12;
  }
LABEL_14:
  a54 = 1;
  if ((CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(*v74, memory_order_acquire)) | 0x10) != 0x34323076)
  {
    STACK[0xF20] = -2001;
    STACK[0x12E0] = (unint64_t)@"Unsupported pixel format.";
    sub_1DC306334((atomic_ullong *)a5, (uint64_t *)&STACK[0xF20], (CFTypeRef *)&STACK[0x12E0]);
    goto LABEL_13;
  }
  __int8 v78 = sub_1DC30637C();
  uint64_t v79 = 0;
  a52 = v78;
  do
  {
    *(unint64_t *)((char *)&STACK[0x12E0] + v79) = 0;
    v79 += 64;
  }
  while (v79 != 320);
  for (uint64_t j = 0; j != 320; j += 64)
  {
    v81 = (unint64_t *)((char *)&STACK[0x11A0] + j);
    void *v81 = 0;
    v81[1] = 0;
    v81[2] = 0;
  }
  for (uint64_t k = 0; k != 640; k += 128)
  {
    int32x4_t v83 = (char *)&STACK[0xF20] + k;
    *int32x4_t v83 = 0;
    v83[96] = 0;
  }
  for (uint64_t m = 0; m != 320; m += 64)
    *(_WORD *)((char *)&STACK[0xDE0] + m) = 0;
  if (qword_1EBFFC3E0 != -1) {
    dispatch_once(&qword_1EBFFC3E0, &unk_1F3662428);
  }
  oslog = qword_1EBFFC3E8;
  a51 = os_signpost_id_generate((os_log_t)qword_1EBFFC3E8);
  LOBYTE(__tp.tv_sec) = 0;
  a50 = 0;
  LOBYTE(a47.tv_sec) = 0;
  a48 = 0;
  a45 = *a4;
  a46 = *((void *)a4 + 2);
  a41 = 0;
  a44 = 0;
  uint64_t v85 = *(void *)(a2 + 8);
  if ((_os_feature_enabled_impl() & 1) == 0)
  {
LABEL_49:
    int v86 = a46;
    goto LABEL_50;
  }
  int v86 = a46;
  if (*(uint64_t *)(v85 + 56) >= 196608 && a46 == 0)
  {
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
    {
      LOWORD(STACK[0xD60]) = 0;
      _os_log_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_INFO, "All prerequisites are met, will run ANMD inference.", (uint8_t *)&STACK[0xD60], 2u);
      uint64_t v85 = *(void *)(a2 + 8);
    }
    if (*(unsigned char *)(v85 + 68))
    {
      __tp.tv_sec = 0;
      __tp.tv_nsec = 0;
      a50 = 1;
      clock_gettime(_CLOCK_MONOTONIC, &__tp);
    }
    explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire);
    if (explicit)
    {
      CFTypeID v68 = CFGetTypeID(explicit);
      if (qword_1EBFFB7E0 != -1) {
        dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
      }
      if (v68 != qword_1EBFFB818) {
        _os_assumes_log();
      }
    }
    STACK[0xDD8] = 0;
    v89 = operator new(0x30uLL);
    void *v89 = &unk_1F365E4C8;
    v89[1] = a5;
    v89[2] = &a41;
    v89[3] = a3;
    v89[4] = &a51;
    v89[5] = &a45;
    STACK[0xDD8] = (unint64_t)v89;
    sub_1DC346804((uint64_t)explicit + 16, &STACK[0xDC0]);
    sub_1DC306500(&STACK[0xDC0]);
    if (*(unsigned char *)(*(void *)(a2 + 8) + 68))
    {
      a47.tv_sec = 0;
      a47.tv_nsec = 0;
      a48 = 1;
      clock_gettime(_CLOCK_MONOTONIC, &a47);
      double v90 = (double)(a47.tv_nsec - __tp.tv_nsec) / 1000000000.0 + (double)(a47.tv_sec - __tp.tv_sec);
      *(double *)&STACK[0x1420] = v90;
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(STACK[0xD60]) = 134349056;
        *(double *)&STACK[0xD64] = v90;
        _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "Elapsed time during inference: %{public}g", (uint8_t *)&STACK[0xD60], 0xCu);
      }
      STACK[0xD60] = (unint64_t)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &STACK[0x1420]);
      CFTypeRef v91 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&a52, memory_order_acquire)+ 40), memory_order_acquire);
      if (v91) {
        CFTypeRef v91 = CFRetain(v91);
      }
      STACK[0x1470] = (unint64_t)v91;
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1470], memory_order_acquire), @"MRCDecoderResultAttributeInferenceElapsedTime", (const void *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire));
      sub_1DC306584((atomic_ullong *)&STACK[0x1470]);
      sub_1DC3065B8((atomic_ullong *)&STACK[0xD60]);
    }
    if (*(unsigned char *)(a5 + 96))
    {
      if (*(void *)a5 != -6001)
      {
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
        {
          LOWORD(STACK[0xD60]) = 0;
          _os_log_error_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_ERROR, "Underlying errors occurred during inference, bail out immediately.", (uint8_t *)&STACK[0xD60], 2u);
        }
        *a1 = 0;
        goto LABEL_448;
      }
      sub_1DC390B00((atomic_ullong *)a5);
      *(unsigned char *)(a5 + 96) = 0;
    }
    goto LABEL_49;
  }
LABEL_50:
  if (v86)
  {
    unint64_t v92 = *((void *)&a45 + 1);
    if (!*((void *)&a45 + 1))
    {
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
      {
        LOWORD(STACK[0xD60]) = 0;
        _os_log_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_INFO, "\"regions\" is not NULL but empty, presumably ANMD has been run without results.", (uint8_t *)&STACK[0xD60], 2u);
      }
      if (*(unsigned char *)(*(void *)(a2 + 8) + 52))
      {
        STACK[0xD60] = (unint64_t)CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
        CFTypeRef v122 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&a52, memory_order_acquire)+ 40), memory_order_acquire);
        if (v122) {
          CFTypeRef v122 = CFRetain(v122);
        }
        STACK[0x1420] = (unint64_t)v122;
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1420], memory_order_acquire), @"MRCDecoderResultAttributeUnrecognizedRegions", (const void *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire));
        sub_1DC306584((atomic_ullong *)&STACK[0x1420]);
        sub_1DC3065EC((atomic_ullong *)&STACK[0xD60]);
      }
      *a1 = atomic_exchange((atomic_ullong *volatile)&a52, 0);
      goto LABEL_448;
    }
    a40 = 0;
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(STACK[0xD60]) = 134349056;
      STACK[0xD64] = v92;
      _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "%{public}zu region(s)", (uint8_t *)&STACK[0xD60], 0xCu);
      if (*((void *)&a45 + 1))
      {
        v93 = (atomic_ullong *)a45;
        uint64_t v94 = 8 * *((void *)&a45 + 1);
        CFTypeID v68 = (CFTypeID)"region: %{public}@";
        do
        {
          if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
          {
            unint64_t v95 = atomic_load_explicit(v93, memory_order_acquire);
            LODWORD(STACK[0xD60]) = 138543362;
            STACK[0xD64] = v95;
            _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "region: %{public}@", (uint8_t *)&STACK[0xD60], 0xCu);
          }
          ++v93;
          v94 -= 8;
        }
        while (v94);
      }
    }
  }
  else
  {
    a40 = 0;
  }
  LOBYTE(a36) = 0;
  a39 = 0;
  if ((_BYTE)a46)
  {
    if (*((void *)&a45 + 1))
    {
      unint64_t v96 = 0;
      float32x2_t v97 = (atomic_ullong *)a45;
      uint64_t v98 = 8 * *((void *)&a45 + 1);
      do
      {
        v96 += sub_1DC328FAC((atomic_ullong *)(atomic_load_explicit(v97++, memory_order_acquire) + 136), 4);
        v98 -= 8;
      }
      while (v98);
      if (v96 >= 2)
      {
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(STACK[0xD60]) = 134349056;
          STACK[0xD64] = v96;
          _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "There are %{public}zu regions matching App Clip codes to be consolidated.", (uint8_t *)&STACK[0xD60], 0xCu);
        }
        if (a39)
        {
          STACK[0xD60] = (unint64_t)&a36;
          sub_1DC306620((void ***)&STACK[0xD60]);
        }
        a36 = 0;
        a37 = 0;
        a38 = 0;
        a39 = 1;
        if (*((void *)&a45 + 1))
        {
          int v99 = (atomic_ullong *)a45;
          uint64_t v100 = 8 * *((void *)&a45 + 1);
          do
          {
            if (!sub_1DC328FAC((atomic_ullong *)(atomic_load_explicit(v99, memory_order_acquire) + 136), 4))
            {
              int v101 = a37;
              if ((unint64_t)a37 >= a38)
              {
                uint64_t v103 = ((uint64_t)a37 - a36) >> 3;
                if ((unint64_t)(v103 + 1) >> 61) {
                  sub_1DC2FF97C();
                }
                unint64_t v104 = (uint64_t)(a38 - a36) >> 2;
                if (v104 <= v103 + 1) {
                  unint64_t v104 = v103 + 1;
                }
                if (a38 - a36 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v105 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v105 = v104;
                }
                STACK[0xD80] = (unint64_t)&a38;
                if (v105) {
                  unint64_t v105 = (unint64_t)sub_1DC2FFD7C(v105);
                }
                else {
                  uint64_t v106 = 0;
                }
                v107 = (void *)(v105 + 8 * v103);
                STACK[0xD60] = v105;
                STACK[0xD68] = (unint64_t)v107;
                STACK[0xD70] = (unint64_t)v107;
                STACK[0xD78] = v105 + 8 * v106;
                CFTypeRef v108 = (CFTypeRef)atomic_load_explicit(v99, memory_order_acquire);
                if (v108) {
                  CFTypeRef v108 = CFRetain(v108);
                }
                void *v107 = v108;
                STACK[0xD70] += 8;
                sub_1DC3066A4(&a36, &STACK[0xD60]);
                CFTypeID v68 = (CFTypeID)a37;
                sub_1DC306780((uint64_t)&STACK[0xD60]);
              }
              else
              {
                CFTypeRef v102 = (CFTypeRef)atomic_load_explicit(v99, memory_order_acquire);
                if (v102) {
                  CFTypeRef v102 = CFRetain(v102);
                }
                *int v101 = v102;
                CFTypeID v68 = (CFTypeID)(v101 + 1);
              }
              a37 = (void *)v68;
            }
            ++v99;
            v100 -= 8;
          }
          while (v100);
        }
        int v109 = *v74;
        CGFloat MinX = CGRectGetMinX(*(CGRect *)(*v74 + 1));
        CGFloat MinY = CGRectGetMinY(*(CGRect *)(v109 + 1));
        *(CGFloat *)&STACK[0xD60] = MinX;
        *(CGFloat *)&STACK[0xD68] = MinY;
        CGFloat v112 = CGRectGetMinX(*(CGRect *)(v109 + 1));
        CGFloat MaxY = CGRectGetMaxY(*(CGRect *)(v109 + 1));
        *(CGFloat *)&STACK[0xD70] = v112;
        *(CGFloat *)&STACK[0xD78] = MaxY;
        CGFloat MaxX = CGRectGetMaxX(*(CGRect *)(v109 + 1));
        CGFloat v115 = CGRectGetMaxY(*(CGRect *)(v109 + 1));
        *(CGFloat *)&STACK[0xD80] = MaxX;
        *(CGFloat *)&STACK[0xD88] = v115;
        CGFloat v116 = CGRectGetMaxX(*(CGRect *)(v109 + 1));
        CGFloat v117 = CGRectGetMinY(*(CGRect *)(v109 + 1));
        *(CGFloat *)&STACK[0xD90] = v116;
        *(CGFloat *)&STACK[0xD98] = v117;
        long long v118 = (const void *)MRCRegionCreate((long long *)&STACK[0xD60], 0, @"PseudoExternal", 0.0, 1.0);
        uint64_t v119 = v118;
        if (v118)
        {
          CFTypeID v68 = CFGetTypeID(v118);
          if (qword_1EBFFB6F8[0] != -1) {
            dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
          }
          if (v68 != qword_1EBFFB6F0) {
            _os_assumes_log();
          }
        }
        uint64_t v120 = a37;
        if ((unint64_t)a37 >= a38)
        {
          uint64_t v123 = ((uint64_t)a37 - a36) >> 3;
          if ((unint64_t)(v123 + 1) >> 61) {
            sub_1DC2FF97C();
          }
          unint64_t v124 = (uint64_t)(a38 - a36) >> 2;
          if (v124 <= v123 + 1) {
            unint64_t v124 = v123 + 1;
          }
          if (a38 - a36 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v125 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v125 = v124;
          }
          STACK[0x1440] = (unint64_t)&a38;
          if (v125) {
            unint64_t v125 = (unint64_t)sub_1DC2FFD7C(v125);
          }
          else {
            uint64_t v126 = 0;
          }
          long long v127 = (void *)(v125 + 8 * v123);
          STACK[0x1420] = v125;
          STACK[0x1428] = (unint64_t)v127;
          STACK[0x1438] = v125 + 8 * v126;
          void *v127 = v119;
          STACK[0x1430] = (unint64_t)(v127 + 1);
          sub_1DC3066A4(&a36, &STACK[0x1420]);
          uint64_t v121 = a37;
          sub_1DC306780((uint64_t)&STACK[0x1420]);
        }
        else
        {
          *a37 = v119;
          uint64_t v121 = v120 + 1;
        }
        a37 = v121;
        if (!(_BYTE)a46) {
          LOBYTE(a46) = 1;
        }
        *(void *)&a45 = a36;
        *((void *)&a45 + 1) = ((uint64_t)v121 - a36) >> 3;
      }
    }
  }
  LOBYTE(a32) = 0;
  a35 = 0;
  if (!atomic_load_explicit((atomic_ullong *volatile)(a3 + 64), memory_order_acquire))
  {
    uint64_t v146 = *(void *)(a2 + 8);
    if (*(unsigned char *)(v146 + 65))
    {
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(STACK[0xD60]) = 0;
        _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "Sample has no pyramid, and pyramid generation on demand is allowed.", (uint8_t *)&STACK[0xD60], 2u);
        uint64_t v146 = *(void *)(a2 + 8);
      }
      v147 = (unint64_t *)MEMORY[0x1E4F1DB20];
      long long v148 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
      *(_OWORD *)&STACK[0x1420] = *MEMORY[0x1E4F1DB20];
      *(_OWORD *)&STACK[0x1430] = v148;
      LOBYTE(STACK[0xD60]) = 0;
      LOBYTE(STACK[0xD64]) = 0;
      if (((sub_1DC3778A8((atomic_ullong *)v146, @"QR", (uint64_t)&STACK[0xD60]) & 1) != 0
         || *(uint64_t *)(v146 + 56) < 0x40000)
        && (_BYTE)a46
        && *((void *)&a45 + 1))
      {
        char v149 = 0;
        v150 = (atomic_ullong *)a45;
        uint64_t v151 = 8 * *((void *)&a45 + 1);
        do
        {
          if (sub_1DC328FAC((atomic_ullong *)(atomic_load_explicit(v150, memory_order_acquire) + 136), 1))
          {
            CGFloat v152 = *(double *)&STACK[0x1420];
            CGFloat v153 = *(double *)&STACK[0x1428];
            CGFloat v154 = *(double *)&STACK[0x1430];
            CGFloat v155 = *(double *)&STACK[0x1438];
            double v156 = sub_1DC326F34(atomic_load_explicit(v150, memory_order_acquire) + 16, 0.1);
            CGFloat v158 = v157;
            CGFloat v160 = v159;
            CGFloat v162 = v161;
            v146 &= 0xFFFFFFFFFFFFFF00;
            v68 &= 0xFFFFFFFFFFFFFF00;
            sub_1DC326E38((CGAffineTransform *)&a26, (_OWORD *)(atomic_load_explicit(v150, memory_order_acquire) + 16), *(void *)(a3 + 16), *(uint64_t **)(a3 + 72), (uint64_t *)v146, 0, v68, 0);
            v331.origin.x = v156;
            v331.origin.y = v158;
            v331.size.width = v160;
            v331.size.height = v162;
            CGRect v335 = CGRectApplyAffineTransform(v331, (CGAffineTransform *)&a26);
            v332.origin.x = v152;
            v332.origin.y = v153;
            v332.size.width = v154;
            v332.size.height = v155;
            CGRect v333 = CGRectUnion(v332, v335);
            STACK[0x1420] = *(void *)&v333.origin.x;
            STACK[0x1428] = *(void *)&v333.origin.y;
            char v149 = 1;
            STACK[0x1430] = *(void *)&v333.size.width;
            STACK[0x1438] = *(void *)&v333.size.height;
          }
          ++v150;
          v151 -= 8;
        }
        while (v151);
        if (v149)
        {
          if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
          {
            LOWORD(STACK[0xD60]) = 0;
            _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "At least one region contains symbologies requiring pyramid.", (uint8_t *)&STACK[0xD60], 2u);
          }
          int v163 = _os_feature_enabled_impl();
          if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(STACK[0xD60]) = 67240192;
            LODWORD(STACK[0xD64]) = v163;
            _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "On-demand pyramid generation: disablesCropping=%{public, BOOL}d", (uint8_t *)&STACK[0xD60], 8u);
          }
          v164 = sub_1DC3067D0((atomic_ullong *)a2);
          v165 = &STACK[0x1420];
          if (v163) {
            v165 = v147;
          }
          long long v166 = *((_OWORD *)v165 + 1);
          *(_OWORD *)&STACK[0xD60] = *(_OWORD *)v165;
          *(_OWORD *)&STACK[0xD70] = v166;
          LOBYTE(STACK[0xD80]) = 1;
          STACK[0x1470] = a51;
          LOBYTE(STACK[0x1478]) = 1;
          sub_1DC32DFF8(&STACK[0x1450], (uint64_t)v164, (uint64_t)v74, (uint64_t)&STACK[0xD60], a5, (uint64_t)&STACK[0x1470]);
          if (atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1450], memory_order_acquire))
          {
            sub_1DC306888((uint64_t)&a32, (atomic_ullong *)&STACK[0x1450], (CGRect *)(a3 + 32), (_OWORD *)(*(void *)(a3 + 16) + 8));
          }
          else
          {
            if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
            {
              if (*(unsigned char *)(a5 + 96))
              {
                sub_1DC390B4C((uint64_t)&STACK[0xD60], a5);
              }
              else
              {
                *(_OWORD *)&STACK[0xD70] = 0u;
                *(_OWORD *)&STACK[0xD80] = 0u;
                STACK[0xD60] = -1;
                STACK[0xD68] = 0;
                *(_OWORD *)&STACK[0xD90] = 0u;
                *(_OWORD *)&STACK[0xDA0] = 0u;
                LOBYTE(STACK[0xD7C]) = 0;
                LOBYTE(STACK[0xD94]) = 0;
                *(_OWORD *)&STACK[0xDB0] = 0u;
              }
              sub_1DC390F7C(&a22, (uint64_t)&STACK[0xD60]);
              unint64_t v319 = atomic_load_explicit((atomic_ullong *volatile)&a22, memory_order_acquire);
              LODWORD(STACK[0x1470]) = 138543362;
              STACK[0x1474] = v319;
              _os_log_error_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_ERROR, "On-demand pyramid generation failed: %{public}@", (uint8_t *)&STACK[0x1470], 0xCu);
              sub_1DC306854((atomic_ullong *)&a22);
              sub_1DC390B00((atomic_ullong *)&STACK[0xD60]);
            }
            if (*(unsigned char *)(a5 + 96))
            {
              sub_1DC390B00((atomic_ullong *)a5);
              *(unsigned char *)(a5 + 96) = 0;
            }
          }
          sub_1DC3065EC((atomic_ullong *)&STACK[0x1450]);
        }
      }
    }
  }
  LOBYTE(a22) = 0;
  a25 = 0;
  if (!a35) {
    goto LABEL_130;
  }
  a22 = 0;
  a23 = 0;
  a24 = 0;
  a25 = 1;
  uint64_t v128 = a32;
  uint64_t v129 = a33;
  if (a33 != a32)
  {
    unint64_t v130 = 0x84BDA12F684BDA13 * ((a33 - a32) >> 3);
    if (v130 >> 61) {
      sub_1DC2FF97C();
    }
    STACK[0xD80] = (unint64_t)&a24;
    int v131 = sub_1DC2FFD7C(v130);
    STACK[0xD60] = (unint64_t)v131;
    STACK[0xD68] = (unint64_t)v131;
    STACK[0xD70] = (unint64_t)v131;
    STACK[0xD78] = (unint64_t)v131 + 8 * v132;
    sub_1DC3068F8(&a22, &STACK[0xD60]);
    sub_1DC306954((uint64_t)&STACK[0xD60]);
    uint64_t v128 = a32;
    uint64_t v129 = a33;
  }
  if (v128 != v129) {
    operator new();
  }
  if (a35) {
    int32x4_t v133 = &a32;
  }
  else {
LABEL_130:
  }
    int32x4_t v133 = *(uint64_t **)(a3 + 72);
  group = dispatch_group_create();
  a21 = (void (*)(void))MEMORY[0x1E4F147B0];
  a18 = a2;
  p_group = &group;
  a14 = a3;
  a15 = v133;
  a16 = &a51;
  a17 = &group;
  a10 = &STACK[0x12E0];
  a11 = &a14;
  a12 = &STACK[0xF20];
  a13 = &STACK[0xDE0];
  os_signpost_id_t v134 = a51;
  if (a51 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(oslog))
  {
    unint64_t v135 = atomic_load_explicit(*(atomic_ullong *volatile *)(a2 + 8), memory_order_acquire);
    if (!v135) {
      unint64_t v135 = *MEMORY[0x1E4F1D260];
    }
    LODWORD(STACK[0xD60]) = 138543362;
    STACK[0xD64] = v135;
    _os_signpost_emit_with_name_impl(&dword_1DC2FE000, oslog, OS_SIGNPOST_INTERVAL_BEGIN, v134, "SampleDecoding", "Begin decoding: symbologies=%{public, signpost.description:attribute}@", (uint8_t *)&STACK[0xD60], 0xCu);
  }
  uint64_t v136 = *(void *)(a2 + 8);
  v322 = (atomic_ullong *)a5;
  uint64_t v137 = a2;
  if (*(unsigned char *)(v136 + 68))
  {
    __tp.tv_sec = 0;
    __tp.tv_nsec = 0;
    a50 = 1;
    clock_gettime(_CLOCK_MONOTONIC, &__tp);
    uint64_t v136 = *(void *)(a2 + 8);
  }
  if (*(uint64_t *)(v136 + 56) < 196608)
  {
    STACK[0xD40] = (unint64_t)&unk_1F365E520;
    STACK[0xD48] = (unint64_t)&a10;
    STACK[0xD50] = (unint64_t)&a18;
    STACK[0xD58] = (unint64_t)&STACK[0xD40];
    sub_1DC306A10(a2, &STACK[0xD40]);
    int32x4_t v138 = &STACK[0xD40];
LABEL_175:
    sub_1DC306CE8(v138);
    goto LABEL_176;
  }
  if ((_BYTE)a46)
  {
    uint64_t v139 = *((void *)&a45 + 1);
    size_t v140 = *((void *)&a45 + 1) << 6;
    if (*((void *)&a45 + 1) >> 58) {
      uint64_t v141 = -1;
    }
    else {
      uint64_t v141 = *((void *)&a45 + 1) << 6;
    }
    v142 = (unsigned char *)MEMORY[0x1E019CEA0](v141, 64);
    v143 = v142;
    if (v139) {
      bzero(v142, v140);
    }
    v144 = a40;
    a40 = v143;
    if (v144)
    {
      MEMORY[0x1E019CE60](v144, 64);
      v143 = a40;
      uint64_t v139 = *((void *)&a45 + 1);
    }
    for (; v139; --v139)
    {
      unsigned char *v143 = 0;
      v143 += 64;
    }
    STACK[0xD38] = 0;
    v145 = operator new(0x38uLL);
    uint64_t v137 = a2;
    void *v145 = &unk_1F365E578;
    v145[1] = &a45;
    v145[2] = &a40;
    v145[3] = &a10;
    v145[4] = &STACK[0xDE0];
    v145[5] = &STACK[0x11A0];
    v145[6] = &a18;
    STACK[0xD38] = (unint64_t)v145;
    sub_1DC306A10(a2, &STACK[0xD20]);
    int32x4_t v138 = &STACK[0xD20];
    goto LABEL_175;
  }
  int v167 = *(unsigned __int8 *)(v136 + 64);
  BOOL v168 = os_log_type_enabled(oslog, OS_LOG_TYPE_INFO);
  if (v167)
  {
    if (v168)
    {
      LOWORD(STACK[0xD60]) = 0;
      _os_log_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_INFO, "For v3, regions should always have value. Due to either the MachineReadableCode/ANMD feature flag is not being turned on, or no applicable inference execution targets are found. Fallback to v2.", (uint8_t *)&STACK[0xD60], 2u);
    }
    STACK[0xD00] = (unint64_t)&unk_1F365E5D0;
    STACK[0xD08] = (unint64_t)&a10;
    STACK[0xD10] = (unint64_t)&a18;
    STACK[0xD18] = (unint64_t)&STACK[0xD00];
    sub_1DC306A10(a2, &STACK[0xD00]);
    int32x4_t v138 = &STACK[0xD00];
    goto LABEL_175;
  }
  if (v168)
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_INFO, "Regions are not provided, algorithmic versioning fallback has also been explicitly disabled.", (uint8_t *)&STACK[0xD60], 2u);
  }
LABEL_176:
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "Waiting for any pending decoding passes...", (uint8_t *)&STACK[0xD60], 2u);
  }
  dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "Done waiting for pending decoding passes.", (uint8_t *)&STACK[0xD60], 2u);
  }
  v325 = a1;
  if (!*(unsigned char *)(*(void *)(v137 + 8) + 67) || !(_BYTE)a46) {
    goto LABEL_326;
  }
  v169 = (const void *)STACK[0x11A0];
  int64_t v170 = STACK[0x11A8] - STACK[0x11A0];
  if (STACK[0x11A8] == STACK[0x11A0])
  {
    v173 = 0;
    v174 = 0;
    __p = 0;
    STACK[0x1478] = 0;
    STACK[0x1470] = 0;
    BOOL v175 = 1;
    STACK[0x1480] = 0;
  }
  else
  {
    if (v170 < 0) {
      sub_1DC2FF97C();
    }
    v171 = (char *)sub_1DC2FFD7C(v170 >> 3);
    v173 = &v171[8 * v172];
    memmove(v171, v169, v170);
    __p = v171;
    v174 = &v171[8 * (v170 >> 3)];
    STACK[0x1478] = 0;
    STACK[0x1470] = 0;
    STACK[0x1480] = 0;
    BOOL v175 = 8 * (v170 >> 3) == 0;
    if (8 * (v170 >> 3))
    {
      unint64_t v176 = atomic_load_explicit((atomic_ullong *volatile)&STACK[0x12E0], memory_order_acquire);
      sub_1DC306D6C((uint64_t *)&STACK[0x1470], STACK[0x1478], *(atomic_ullong **)(v176 + 16), *(atomic_ullong **)(v176 + 24), (uint64_t)(*(void *)(v176 + 24) - *(void *)(v176 + 16)) >> 3);
    }
  }
  v177 = (char *)STACK[0x1220];
  unint64_t v178 = STACK[0x1228];
  if (STACK[0x1220] != STACK[0x1228])
  {
    if ((uint64_t)(v178 - (void)v177) >= 1)
    {
      uint64_t v179 = (uint64_t)(v178 - (void)v177) >> 3;
      uint64_t v180 = v174 - __p;
      v181 = &__p[(v174 - __p) & 0xFFFFFFFFFFFFFFF8];
      if (v179 > (v173 - v174) >> 3)
      {
        uint64_t v182 = v180 >> 3;
        unint64_t v183 = (v180 >> 3) + v179;
        if (v183 >> 61) {
          sub_1DC2FF97C();
        }
        if ((v173 - __p) >> 2 > v183) {
          unint64_t v183 = (v173 - __p) >> 2;
        }
        if ((unint64_t)(v173 - __p) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v184 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v184 = v183;
        }
        if (v184) {
          unint64_t v184 = (unint64_t)sub_1DC2FFD7C(v184);
        }
        v185 = (char *)(v184 + 8 * v182);
        v186 = &v185[8 * v179];
        uint64_t v187 = 8 * v179;
        v188 = v185;
        do
        {
          uint64_t v189 = *(void *)v177;
          v177 += 8;
          *(void *)v188 = v189;
          v188 += 8;
          v187 -= 8;
        }
        while (v187);
        if (!v175)
        {
          uint64_t v190 = 8 * v182;
          do
          {
            *(void *)(v184 + v190 - 8) = *(void *)&__p[v190 - 8];
            v190 -= 8;
          }
          while (v190);
          v185 = (char *)v184;
        }
        size_t v191 = v174 - v181;
        if (v191) {
          memmove(v186, v181, v191);
        }
        v192 = &v186[v191];
        if (__p) {
          operator delete(__p);
        }
        goto LABEL_225;
      }
      uint64_t v193 = (v174 - v181) >> 3;
      if (v193 >= v179)
      {
        v194 = &v177[8 * v179];
        v196 = v174;
        v185 = __p;
      }
      else
      {
        v194 = &v177[8 * v193];
        unint64_t v195 = v178 - (void)v194;
        v185 = __p;
        if ((char *)v178 != v194) {
          memmove(v174, &v177[8 * v193], v178 - (void)v194);
        }
        v196 = &v174[v195];
        if (v174 - v181 < 1)
        {
          v192 = &v174[v195];
          goto LABEL_225;
        }
      }
      v197 = &v181[8 * v179];
      v198 = &v196[-8 * v179];
      v192 = v196;
      if (v198 < v174)
      {
        v192 = v196;
        do
        {
          uint64_t v199 = *(void *)v198;
          v198 += 8;
          *(void *)v192 = v199;
          v192 += 8;
        }
        while (v198 < v174);
      }
      if (v196 != v197) {
        memmove(&v196[-8 * ((v196 - v197) >> 3)], v181, v196 - v197);
      }
      if (v194 != v177) {
        memmove(v181, v177, v194 - v177);
      }
      goto LABEL_225;
    }
    v192 = v174;
    v185 = __p;
LABEL_225:
    uint64_t v200 = STACK[0x1478];
    v201 = *(atomic_ullong **)(atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1360], memory_order_acquire) + 16);
    v202 = *(atomic_ullong **)(atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1360], memory_order_acquire) + 24);
    sub_1DC306D6C((uint64_t *)&STACK[0x1470], v200, v201, v202, v202 - v201);
    v174 = v192;
    goto LABEL_226;
  }
  v185 = __p;
LABEL_226:
  __pa = v185;
  if (!(_BYTE)a46) {
    sub_1DC306FEC();
  }
  if (!*((void *)&a45 + 1) || v185 == v174 || STACK[0x1470] == STACK[0x1478])
  {
    STACK[0x1458] = 0;
    STACK[0x1450] = 0;
    STACK[0x1460] = 0;
    goto LABEL_320;
  }
  uint64_t v327 = a45;
  sub_1DC314F54(&STACK[0x1420], (v174 - v185) >> 3);
  unint64_t v320 = 0;
  v321 = 0;
  v203 = 0;
  unint64_t v204 = 0;
  if ((unint64_t)((v174 - v185) >> 3) <= 1) {
    uint64_t v205 = 1;
  }
  else {
    uint64_t v205 = (v174 - v185) >> 3;
  }
  do
  {
    unint64_t v206 = v204 >> 6;
    uint64_t v207 = 1 << v204;
    if ((*(void *)(STACK[0x1420] + 8 * (v204 >> 6)) & (1 << v204)) != 0) {
      goto LABEL_282;
    }
    uint64_t v208 = *(void *)&v185[8 * v204];
    unint64_t v209 = atomic_load_explicit((atomic_ullong *volatile)(STACK[0x1470] + 8 * v204), memory_order_acquire);
    if (!*(unsigned char *)(v209 + 208) || (unint64_t)(*(void *)(v209 + 176) - 2) > 3) {
      goto LABEL_282;
    }
    unint64_t v210 = atomic_load_explicit((atomic_ullong *volatile)(v327 + 8 * v208), memory_order_acquire);
    double v211 = sub_1DC326F34(v210 + 16, 0.1);
    CGFloat v213 = v212;
    CGFloat v215 = v214;
    CGFloat v217 = v216;
    STACK[0xD60] = (unint64_t)CFRetain(@"PseudoPDF417");
    v218 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire);
    v219 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(v210 + 136), memory_order_acquire);
    if (v219 == v218 || v218 && v219 && CFEqual(v219, v218))
    {
      BOOL v220 = 1;
    }
    else
    {
      if (!atomic_load_explicit((atomic_ullong *volatile)(v210 + 136), memory_order_acquire)
        || !atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire))
      {
        BOOL v326 = 0;
        goto LABEL_247;
      }
      BOOL v220 = CFEqual((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)(v210 + 136), memory_order_acquire), (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire));
    }
    BOOL v326 = v220;
LABEL_247:
    sub_1DC31FA90((atomic_ullong *)&STACK[0xD60]);
    unint64_t v221 = 0;
    while (1)
    {
      if (v204 == v221 || (*(void *)(STACK[0x1420] + 8 * (v221 >> 6)) & (1 << v221)) != 0) {
        goto LABEL_262;
      }
      unint64_t v222 = atomic_load_explicit((atomic_ullong *volatile)(v327 + 8 * *(void *)&v185[8 * v221]), memory_order_acquire);
      STACK[0xD60] = (unint64_t)CFRetain(@"PseudoPDF417");
      v223 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire);
      v224 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(v222 + 136), memory_order_acquire);
      if (v224 == v223 || v223 && v224 && CFEqual(v224, v223)) {
        break;
      }
      if (atomic_load_explicit((atomic_ullong *volatile)(v222 + 136), memory_order_acquire)
        && atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire))
      {
        BOOL v225 = CFEqual((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)(v222 + 136), memory_order_acquire), (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire));
        sub_1DC31FA90((atomic_ullong *)&STACK[0xD60]);
        char v226 = v326 ^ v225;
        v185 = __pa;
        if ((v226 & 1) == 0) {
          goto LABEL_262;
        }
        goto LABEL_261;
      }
      sub_1DC31FA90((atomic_ullong *)&STACK[0xD60]);
      if (v326) {
        goto LABEL_261;
      }
LABEL_262:
      if (v205 == ++v221) {
        goto LABEL_263;
      }
    }
    sub_1DC31FA90((atomic_ullong *)&STACK[0xD60]);
    if (v326) {
      goto LABEL_262;
    }
LABEL_261:
    v336.origin.x = sub_1DC326F34(v222 + 16, 0.1);
    v336.origin.y = v227;
    v336.size.width = v228;
    v336.size.height = v229;
    v334.origin.x = v211;
    v334.origin.y = v213;
    v334.size.width = v215;
    v334.size.height = v217;
    if (!CGRectIntersectsRect(v334, v336)) {
      goto LABEL_262;
    }
    unint64_t v234 = STACK[0x1420];
    *(void *)(STACK[0x1420] + 8 * (v221 >> 6)) |= 1 << v221;
    *(void *)(v234 + 8 * v206) |= v207;
LABEL_263:
    if ((*(void *)(STACK[0x1420] + 8 * v206) & v207) == 0)
    {
      if ((unint64_t)v203 >= v320)
      {
        uint64_t v230 = (v203 - v321) >> 3;
        unint64_t v231 = v230 + 1;
        if ((unint64_t)(v230 + 1) >> 61) {
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v320 - (void)v321) >> 2 > v231) {
          unint64_t v231 = (uint64_t)(v320 - (void)v321) >> 2;
        }
        if (v320 - (unint64_t)v321 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v232 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v232 = v231;
        }
        if (v232) {
          unint64_t v232 = (unint64_t)sub_1DC2FFD7C(v232);
        }
        else {
          uint64_t v233 = 0;
        }
        v235 = (char *)(v232 + 8 * v230);
        *(void *)v235 = v204;
        v236 = v235 + 8;
        while (v203 != v321)
        {
          uint64_t v237 = *((void *)v203 - 1);
          v203 -= 8;
          *((void *)v235 - 1) = v237;
          v235 -= 8;
        }
        unint64_t v320 = v232 + 8 * v233;
        if (v321) {
          operator delete(v321);
        }
        v203 = v236;
        v321 = v235;
        v185 = __pa;
      }
      else
      {
        *(void *)v203 = v204;
        v203 += 8;
      }
    }
LABEL_282:
    ++v204;
  }
  while (v204 != v205);
  STACK[0x1458] = 0;
  STACK[0x1450] = 0;
  STACK[0x1460] = 0;
  sub_1DC344344((uint64_t *)&STACK[0x1450], (v203 - v321) >> 3);
  if (v321 != v203)
  {
    for (n = v321; n != v203; n += 8)
    {
      unint64_t v239 = atomic_load_explicit((atomic_ullong *volatile)(v327 + 8 * *(void *)n), memory_order_acquire);
      STACK[0xD60] = (unint64_t)CFRetain(@"PseudoPDF417");
      v240 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire);
      v241 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(v239 + 136), memory_order_acquire);
      if (v241 == v240) {
        goto LABEL_294;
      }
      BOOL v242 = !v240 || v241 == 0;
      if (!v242 && CFEqual(v241, v240)) {
        goto LABEL_294;
      }
      if (!atomic_load_explicit((atomic_ullong *volatile)(v239 + 136), memory_order_acquire)
        || !atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire))
      {
        v243 = @"PseudoPDF417";
        goto LABEL_296;
      }
      v243 = @"PseudoPDF417";
      if (CFEqual((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)(v239 + 136), memory_order_acquire), (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire)))LABEL_294:v243 = @"Pseudo1D"; {
LABEL_296:
      }
      sub_1DC31FA90((atomic_ullong *)&STACK[0xD60]);
      v244 = (const void *)MRCRegionCreate((long long *)(v239 + 16), (long long *)(v239 + 80), v243, *(double *)(v239 + 128), *(float *)(v239 + 144));
      v245 = v244;
      if (v244)
      {
        CFTypeID v246 = CFGetTypeID(v244);
        if (qword_1EBFFB6F8[0] != -1) {
          dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
        }
        if (v246 != qword_1EBFFB6F0) {
          _os_assumes_log();
        }
      }
      v247 = (void *)STACK[0x1458];
      if (STACK[0x1458] >= STACK[0x1460])
      {
        uint64_t v249 = (uint64_t)((uint64_t)v247 - STACK[0x1450]) >> 3;
        if ((unint64_t)(v249 + 1) >> 61) {
          sub_1DC2FF97C();
        }
        int64_t v250 = STACK[0x1460] - STACK[0x1450];
        uint64_t v251 = v250 >> 2;
        if (v250 >> 2 <= (unint64_t)(v249 + 1)) {
          uint64_t v251 = v249 + 1;
        }
        if ((unint64_t)v250 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v252 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v252 = v251;
        }
        STACK[0xD80] = (unint64_t)&STACK[0x1460];
        if (v252) {
          unint64_t v252 = (unint64_t)sub_1DC2FFD7C(v252);
        }
        else {
          uint64_t v253 = 0;
        }
        v254 = (void *)(v252 + 8 * v249);
        STACK[0xD60] = v252;
        STACK[0xD68] = (unint64_t)v254;
        STACK[0xD78] = v252 + 8 * v253;
        void *v254 = v245;
        STACK[0xD70] = (unint64_t)(v254 + 1);
        sub_1DC3066A4((uint64_t *)&STACK[0x1450], &STACK[0xD60]);
        unint64_t v248 = STACK[0x1458];
        sub_1DC306780((uint64_t)&STACK[0xD60]);
      }
      else
      {
        void *v247 = v245;
        unint64_t v248 = (unint64_t)(v247 + 1);
      }
      STACK[0x1458] = v248;
    }
  }
  if (STACK[0x1420]) {
    operator delete((void *)STACK[0x1420]);
  }
  uint64_t v137 = a2;
  if (v321) {
    operator delete(v321);
  }
LABEL_320:
  a68 = 0;
  v255 = operator new(0x20uLL);
  void *v255 = &unk_1F365E628;
  v255[1] = &STACK[0x1450];
  v255[2] = &a10;
  v255[3] = &a18;
  a68 = v255;
  sub_1DC306A10(v137, &a65);
  sub_1DC306CE8(&a65);
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "Waiting for any pending GS1Composite region reusing decoding passes...", (uint8_t *)&STACK[0xD60], 2u);
  }
  dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(STACK[0xD60]) = 0;
    _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "Done waiting for pending GS1Composite region reusing decoding passes.", (uint8_t *)&STACK[0xD60], 2u);
  }
  STACK[0xD60] = (unint64_t)&STACK[0x1450];
  sub_1DC306620((void ***)&STACK[0xD60]);
  STACK[0xD60] = (unint64_t)&STACK[0x1470];
  sub_1DC307038((void ***)&STACK[0xD60]);
  if (v185) {
    operator delete(v185);
  }
LABEL_326:
  uint64_t v256 = 0;
  v257 = (uint64_t *)atomic_load_explicit((atomic_ullong *volatile)&a52, memory_order_acquire);
  v258 = v257 + 2;
  v259 = v257 + 4;
  do
  {
    v260 = (atomic_ullong *)(&STACK[0x12E0] + 8 * v256);
    if (atomic_load_explicit(v260, memory_order_acquire))
    {
      v261 = *(atomic_ullong **)(atomic_load_explicit(v260, memory_order_acquire) + 16);
      v262 = *(atomic_ullong **)(atomic_load_explicit(v260, memory_order_acquire) + 24);
      if (v261 != v262)
      {
        v263 = (void *)v257[3];
        do
        {
          if ((unint64_t)v263 >= *v259)
          {
            uint64_t v264 = ((uint64_t)v263 - *v258) >> 3;
            if ((unint64_t)(v264 + 1) >> 61) {
              sub_1DC2FF97C();
            }
            uint64_t v265 = *v259 - *v258;
            uint64_t v266 = v265 >> 2;
            if (v265 >> 2 <= (unint64_t)(v264 + 1)) {
              uint64_t v266 = v264 + 1;
            }
            if ((unint64_t)v265 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v267 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v267 = v266;
            }
            STACK[0xD80] = (unint64_t)v259;
            if (v267) {
              unint64_t v267 = (unint64_t)sub_1DC2FFD7C(v267);
            }
            else {
              uint64_t v268 = 0;
            }
            v269 = (void *)(v267 + 8 * v264);
            STACK[0xD60] = v267;
            STACK[0xD68] = (unint64_t)v269;
            STACK[0xD70] = (unint64_t)v269;
            STACK[0xD78] = v267 + 8 * v268;
            void *v269 = atomic_exchange(v261, 0);
            STACK[0xD70] += 8;
            sub_1DC34D7DC(v257 + 2, &STACK[0xD60]);
            v263 = (void *)v257[3];
            sub_1DC308428((uint64_t)&STACK[0xD60]);
          }
          else
          {
            *v263++ = atomic_exchange(v261, 0);
            v257[3] = (uint64_t)v263;
          }
          v257[3] = (uint64_t)v263;
          ++v261;
        }
        while (v261 != v262);
      }
      CFTypeRef v270 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(atomic_load_explicit(v260, memory_order_acquire) + 40), memory_order_acquire);
      if (v270) {
        CFTypeRef v270 = CFRetain(v270);
      }
      STACK[0xD60] = (unint64_t)v270;
      CFDictionaryRef v271 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire);
      CFTypeRef v272 = (CFTypeRef)atomic_load_explicit(v257 + 5, memory_order_acquire);
      if (v272) {
        CFTypeRef v272 = CFRetain(v272);
      }
      STACK[0x1420] = (unint64_t)v272;
      CFDictionaryApplyFunction(v271, (CFDictionaryApplierFunction)sub_1DC39E944, (void *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1420], memory_order_acquire));
      sub_1DC306584((atomic_ullong *)&STACK[0x1420]);
      sub_1DC306584((atomic_ullong *)&STACK[0xD60]);
    }
    ++v256;
  }
  while (v256 != 5);
  unint64_t v273 = atomic_load_explicit((atomic_ullong *volatile)&a52, memory_order_acquire);
  os_signpost_id_t vars8 = a51;
  STACK[0x1470] = (unint64_t)&unk_1F3661FF0;
  STACK[0x1488] = (unint64_t)&STACK[0x1470];
  STACK[0x1450] = (unint64_t)&unk_1F3662048;
  STACK[0x1468] = (unint64_t)&STACK[0x1450];
  STACK[0xD60] = (unint64_t)&vars8;
  sub_1DC31AD78((uint64_t)&STACK[0xD68], (uint64_t)&STACK[0x1450]);
  uint64_t v274 = STACK[0x1488];
  if (*(unsigned char *)(STACK[0xD60] + 8)) {
    BOOL v275 = v274 == 0;
  }
  else {
    BOOL v275 = 1;
  }
  uint64_t v276 = a2;
  if (!v275) {
    sub_1DC31AE10(v274, *(void *)STACK[0xD60]);
  }
  sub_1DC31AE60(&STACK[0x1450]);
  sub_1DC31AE60(&STACK[0x1470]);
  if (*(unsigned char *)(*(void *)(a2 + 8) + 67))
  {
    uint64_t v277 = (*(void *)(v273 + 24) - *(void *)(v273 + 16)) >> 3;
    a61 = 0;
    HIDWORD(a60) = 0;
    a62 = 0;
    unsigned int v278 = v277 - 1;
    *(void *)((char *)&a60 + 4) = (v277 - 1);
    if ((int)v277 > 0)
    {
      while (2)
      {
        unint64_t v279 = atomic_load_explicit((atomic_ullong *volatile)(*(void *)(v273 + 16) + 8 * v278), memory_order_acquire);
        STACK[0x1420] = (unint64_t)CFRetain(@"PDF417");
        v280 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1420], memory_order_acquire);
        v281 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(v279 + 16), memory_order_acquire);
        if (v281 != v280)
        {
          BOOL v282 = !v280 || v281 == 0;
          if ((v282 || !CFEqual(v281, v280))
            && (!atomic_load_explicit((atomic_ullong *volatile)(v279 + 16), memory_order_acquire)
             || !atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1420], memory_order_acquire)
             || CFStringCompare((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)(v279 + 16), memory_order_acquire), (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1420], memory_order_acquire), 0)))
          {
            a55 = (void *)CFRetain(@"MicroPDF417");
            v283 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&a55, memory_order_acquire);
            v284 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(v279 + 16), memory_order_acquire);
            if (v284 == v283 || v283 && v284 && CFEqual(v284, v283))
            {
              sub_1DC31FA90((atomic_ullong *)&a55);
              break;
            }
            if (atomic_load_explicit((atomic_ullong *volatile)(v279 + 16), memory_order_acquire)
              && atomic_load_explicit((atomic_ullong *volatile)&a55, memory_order_acquire))
            {
              CFComparisonResult v285 = CFStringCompare((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)(v279 + 16), memory_order_acquire), (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&a55, memory_order_acquire), 0);
              sub_1DC31FA90((atomic_ullong *)&a55);
              sub_1DC31FA90((atomic_ullong *)&STACK[0x1420]);
              if (v285 == kCFCompareEqualTo)
              {
LABEL_371:
                if (*(unsigned char *)(v279 + 208)
                  && *(unsigned char *)(v279 + 164)
                  && *(unsigned char *)(v279 + 156)
                  && *(unsigned char *)(v279 + 280)
                  && *(unsigned char *)(v279 + 64)
                  && *(void *)(v279 + 48) - *(void *)(v279 + 40) == 64)
                {
                  sub_1DC353DF0();
                }
              }
            }
            else
            {
              sub_1DC31FA90((atomic_ullong *)&a55);
              sub_1DC31FA90((atomic_ullong *)&STACK[0x1420]);
            }
            int v286 = DWORD1(a60);
            unsigned int v278 = --DWORD1(a60);
            if (v286 <= 0)
            {
              v287 = (int *)*((void *)&a60 + 1);
              v288 = a61;
              if (*((int **)&a60 + 1) == a61)
              {
                uint64_t v276 = a2;
              }
              else
              {
                v289 = *(atomic_ullong **)(v273 + 24);
                uint64_t v276 = a2;
                do
                {
                  uint64_t v290 = *(void *)(v273 + 16) + 8 * *v287;
                  v291 = (atomic_ullong *)(v290 + 8);
                  if ((atomic_ullong *)(v290 + 8) != v289)
                  {
                    do
                    {
                      uint64_t v290 = (uint64_t)v291;
                      v292 = (const void *)atomic_exchange(v291 - 1, atomic_exchange(v291, 0));
                      if (v292) {
                        CFRelease(v292);
                      }
                      v291 = (atomic_ullong *)(v290 + 8);
                    }
                    while ((atomic_ullong *)(v290 + 8) != v289);
                    v289 = *(atomic_ullong **)(v273 + 24);
                  }
                  while (v289 != (atomic_ullong *)v290)
                    sub_1DC3073A4(--v289);
                  *(void *)(v273 + 24) = v290;
                  ++v287;
                  v289 = (atomic_ullong *)v290;
                }
                while (v287 != v288);
                v287 = (int *)*((void *)&a60 + 1);
              }
              if (v287) {
                operator delete(v287);
              }
              goto LABEL_398;
            }
            continue;
          }
        }
        break;
      }
      sub_1DC31FA90((atomic_ullong *)&STACK[0x1420]);
      goto LABEL_371;
    }
  }
LABEL_398:
  uint64_t v293 = STACK[0xD80];
  if (*(unsigned char *)(STACK[0xD60] + 8)) {
    BOOL v294 = v293 == 0;
  }
  else {
    BOOL v294 = 1;
  }
  if (!v294) {
    sub_1DC31AE10(v293, *(void *)STACK[0xD60]);
  }
  sub_1DC31AE60(&STACK[0xD68]);
  if (*(unsigned char *)(*(void *)(v276 + 8) + 68))
  {
    a47.tv_sec = 0;
    a47.tv_nsec = 0;
    a48 = 1;
    clock_gettime(_CLOCK_MONOTONIC, &a47);
    double v295 = (double)(a47.tv_nsec - __tp.tv_nsec) / 1000000000.0 + (double)(a47.tv_sec - __tp.tv_sec);
    *(double *)&STACK[0x1420] = v295;
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(STACK[0xD60]) = 134349056;
      *(double *)&STACK[0xD64] = v295;
      _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "Elapsed time during decoding: %{public}g", (uint8_t *)&STACK[0xD60], 0xCu);
    }
    STACK[0xD60] = (unint64_t)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &STACK[0x1420]);
    CFTypeRef v296 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&a52, memory_order_acquire)+ 40), memory_order_acquire);
    if (v296) {
      CFTypeRef v296 = CFRetain(v296);
    }
    STACK[0x1470] = (unint64_t)v296;
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1470], memory_order_acquire), @"MRCDecoderResultAttributeDecodingElapsedTime", (const void *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire));
    sub_1DC306584((atomic_ullong *)&STACK[0x1470]);
    sub_1DC3065B8((atomic_ullong *)&STACK[0xD60]);
  }
  os_signpost_id_t v297 = a51;
  if (a51 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(oslog))
  {
    unint64_t v298 = atomic_load_explicit((atomic_ullong *volatile)&a52, memory_order_acquire);
    LODWORD(STACK[0xD60]) = 138739971;
    STACK[0xD64] = v298;
    _os_signpost_emit_with_name_impl(&dword_1DC2FE000, oslog, OS_SIGNPOST_INTERVAL_END, v297, "SampleDecoding", "End decoding: decoderResult=%{sensitive, signpost.description:attribute}@", (uint8_t *)&STACK[0xD60], 0xCu);
  }
  uint64_t v299 = *(void *)(a2 + 8);
  if ((_BYTE)a46 && *(unsigned char *)(v299 + 52))
  {
    CFAllocatorRef v300 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    STACK[0xD60] = (unint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    uint64_t v301 = *((void *)&a45 + 1);
    if (*((void *)&a45 + 1))
    {
      uint64_t v302 = 0;
      uint64_t v303 = 0;
      do
      {
        if ((a40[v302] & 1) == 0)
        {
          v304 = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire);
          CFArrayAppendValue(v304, (const void *)atomic_load_explicit((atomic_ullong *volatile)(a45 + 8 * v303), memory_order_acquire));
        }
        ++v303;
        v302 += 64;
      }
      while (v301 != v303);
    }
    STACK[0x1420] = (unint64_t)CFArrayCreateCopy(v300, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&STACK[0xD60], memory_order_acquire));
    CFTypeRef v305 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&a52, memory_order_acquire)+ 40), memory_order_acquire);
    if (v305) {
      CFTypeRef v305 = CFRetain(v305);
    }
    STACK[0x1470] = (unint64_t)v305;
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1470], memory_order_acquire), @"MRCDecoderResultAttributeUnrecognizedRegions", (const void *)atomic_load_explicit((atomic_ullong *volatile)&STACK[0x1420], memory_order_acquire));
    sub_1DC306584((atomic_ullong *)&STACK[0x1470]);
    sub_1DC3065EC((atomic_ullong *)&STACK[0x1420]);
    sub_1DC3070BC((atomic_ullong *)&STACK[0xD60]);
    uint64_t v299 = *(void *)(a2 + 8);
  }
  if (*(uint64_t *)(v299 + 56) >= 196608)
  {
    unint64_t v308 = atomic_load_explicit((atomic_ullong *volatile)&a52, memory_order_acquire);
    if (*(void *)(v308 + 16) != *(void *)(v308 + 24)) {
      goto LABEL_437;
    }
LABEL_432:
    uint64_t v309 = 0;
    v310 = &STACK[0xF20];
    while (!*((unsigned char *)v310 + 96))
    {
      ++v309;
      v310 += 16;
      if (v309 == 5) {
        goto LABEL_437;
      }
    }
    sub_1DC3070F0(v322, (uint64_t)v310);
    unint64_t v318 = 0;
  }
  else
  {
    uint64_t v306 = 0;
    while (!*((unsigned char *)&STACK[0xDE0] + v306 + 1) || *((unsigned char *)&STACK[0xDE0] + v306) == 0)
    {
      v306 += 64;
      if (v306 == 320) {
        goto LABEL_432;
      }
    }
LABEL_437:
    unint64_t v318 = atomic_exchange((atomic_ullong *volatile)&a52, 0);
  }
  unint64_t *v325 = v318;
  dispatch_group_t v311 = group;
  group = 0;
  if (v311) {
    a21();
  }
  if (a25)
  {
    STACK[0xD60] = (unint64_t)&a22;
    sub_1DC307168((void ***)&STACK[0xD60]);
  }
  if (a35)
  {
    STACK[0xD60] = (unint64_t)&a32;
    sub_1DC3071F0((void ***)&STACK[0xD60]);
  }
  if (a39)
  {
    STACK[0xD60] = (unint64_t)&a36;
    sub_1DC306620((void ***)&STACK[0xD60]);
  }
  v312 = a40;
  a40 = 0;
  if (v312) {
    MEMORY[0x1E019CE60](v312, 64);
  }
LABEL_448:
  if (a44)
  {
    STACK[0xD60] = (unint64_t)&a41;
    sub_1DC306620((void ***)&STACK[0xD60]);
  }
  uint64_t v313 = 640;
  do
  {
    if (*((unsigned char *)&STACK[0xF20] + v313 - 32)) {
      sub_1DC390B00((atomic_ullong *)((char *)&STACK[0xF20] + v313 - 128));
    }
    v313 -= 128;
  }
  while (v313);
  uint64_t v314 = 320;
  do
  {
    v315 = *(void **)((char *)&STACK[0x11A0] + v314 - 64);
    if (v315)
    {
      *(unint64_t *)((char *)&STACK[0x11A0] + v314 - 56) = (unint64_t)v315;
      operator delete(v315);
    }
    v314 -= 64;
  }
  while (v314);
  for (iuint64_t i = 256; ii != -64; ii -= 64)
    sub_1DC307278((atomic_ullong *)((char *)&STACK[0x12E0] + ii));
  sub_1DC307278((atomic_ullong *)&a52);
  return sub_1DC3072AC((uint64_t)&a53);
}

void sub_1DC305E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *****a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void (*a41)(void),void ****a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void ***a52,uint64_t a53,uint64_t a54,char a55,void **a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  int v65 = (void *)STACK[0x228];
  if (STACK[0x228])
  {
    STACK[0x230] = (unint64_t)v65;
    operator delete(v65);
  }
  sub_1DC30184C((atomic_uint **)&STACK[0x240]);
  sub_1DC30184C((atomic_uint **)&STACK[0x248]);
  if (STACK[0x258]) {
    operator delete((void *)STACK[0x258]);
  }
  sub_1DC31AEE4((uint64_t **)&STACK[0x300]);
  uint64_t v66 = a40;
  a40 = 0;
  if (v66) {
    a41();
  }
  if (a45)
  {
    a34 = &a42;
    sub_1DC307168((void ***)&a34);
  }
  if (a55)
  {
    a42 = &a52;
    sub_1DC3071F0((void ***)&a42);
  }
  if (a59)
  {
    a52 = &a56;
    sub_1DC306620((void ***)&a52);
  }
  uint64_t v67 = a60;
  a60 = 0;
  if (v67) {
    MEMORY[0x1E019CE60](v67, 64);
  }
  if (a64)
  {
    a56 = (void **)&a61;
    sub_1DC306620(&a56);
  }
  uint64_t v68 = 640;
  while (1)
  {
    if (*((unsigned char *)&STACK[0x4C0] + v68 - 32)) {
      sub_1DC390B00((atomic_ullong *)((char *)&STACK[0x4C0] + v68 - 128));
    }
    v68 -= 128;
    if (!v68)
    {
      uint64_t v69 = 320;
      while (1)
      {
        int v70 = *(void **)((char *)&STACK[0x740] + v69 - 64);
        if (v70)
        {
          *(unint64_t *)((char *)&STACK[0x740] + v69 - 56) = (unint64_t)v70;
          operator delete(v70);
        }
        v69 -= 64;
        if (!v69)
        {
          for (uint64_t i = 256; i != -64; i -= 64)
            sub_1DC307278((atomic_ullong *)((char *)&STACK[0x880] + i));
          sub_1DC307278((atomic_ullong *)&STACK[0x210]);
          sub_1DC3072AC((uint64_t)&STACK[0x218]);
          _Unwind_Resume(a1);
        }
      }
    }
  }
}

uint64_t sub_1DC306334(atomic_ullong *a1, uint64_t *a2, CFTypeRef *a3)
{
  if (*((unsigned char *)a1 + 96))
  {
    a1 = sub_1DC390B00(a1);
    *((unsigned char *)a1 + 96) = 0;
  }
  uint64_t result = sub_1DC390A40((uint64_t)a1, *a2, *a3);
  *(unsigned char *)(result + 96) = 1;
  return result;
}

void *sub_1DC30637C()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (qword_1EBFFB7A8[0] != -1) {
    dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
  }
  Instance = (void *)_CFRuntimeCreateInstance();
  uint64_t v2 = Instance;
  if (Instance)
  {
    CFTypeID v3 = CFGetTypeID(Instance);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v3 != qword_1EBFFB790) {
      _os_assumes_log();
    }
    v2[2] = 0;
    v2[3] = 0;
    v2[4] = 0;
    v2[5] = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFTypeID v4 = CFGetTypeID(v2);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v4 != qword_1EBFFB790) {
      _os_assumes_log();
    }
  }
  return v2;
}

void sub_1DC3064E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC307038((void ***)va);
  _Unwind_Resume(a1);
}

void *sub_1DC306500(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

atomic_ullong *sub_1DC306584(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

atomic_ullong *sub_1DC3065B8(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

atomic_ullong *sub_1DC3065EC(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1DC306620(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (atomic_ullong *)**a1;
  if (v2)
  {
    CFTypeID v4 = (atomic_ullong *)v1[1];
    int v5 = v2;
    if (v4 != v2)
    {
      do
        CFTypeID v4 = sub_1DC30ABA4(v4 - 1);
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_1DC3066A4(uint64_t *result, void *a2)
{
  CFTypeID v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t result = (uint64_t *)atomic_load_explicit((atomic_ullong *volatile)(v4 + v7 - 8), memory_order_acquire);
      if (result) {
        uint64_t result = (uint64_t *)CFRetain(result);
      }
      *(void *)(v6 + v7 - 8) = result;
      v7 -= 8;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v8 = *v3;
  uint64_t *v3 = v6;
  a2[1] = v8;
  uint64_t v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DC306780(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC30ABA4((atomic_ullong *)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_1DC3067D0(atomic_ullong *a1)
{
  explicit = (char *)atomic_load_explicit(a1, memory_order_acquire);
  if (explicit)
  {
    CFTypeID v2 = CFGetTypeID(explicit);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v2 != qword_1EBFFB818) {
      _os_assumes_log();
    }
  }
  return explicit + 16;
}

atomic_ullong *sub_1DC306854(atomic_ullong *a1)
{
  CFTypeID v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

int64x2_t *sub_1DC306888(uint64_t a1, atomic_ullong *a2, CGRect *a3, _OWORD *a4)
{
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v9 = (void **)a1;
    sub_1DC3071F0(&v9);
    *(unsigned char *)(a1 + 24) = 0;
  }
  uint64_t result = sub_1DC38251C((int64x2_t *)a1, a2, a3, a4);
  *(unsigned char *)(a1 + 24) = 1;
  return result;
}

void *sub_1DC3068F8(void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  CFTypeID v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    uint64_t v5 = *--v2;
    void *v2 = 0;
    *(void *)(v4 - 8) = v5;
    v4 -= 8;
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *uint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DC306954(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      sub_1DC3069B0(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DC3069B0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    *(unsigned char *)(a1 + 16) = sub_1DC3836F8(*(atomic_ullong **)a1, *(void *)(a1 + 8)) ^ 1;
  }
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC306A10(uint64_t a1, void *a2)
{
  v40[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a2 + 3;
  uint64_t v4 = (void *)a2[3];
  if (v4)
  {
    if (v4 == a2)
    {
      int32x4_t v39 = v38;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v38);
      goto LABEL_7;
    }
    int32x4_t v39 = (void *)a2[3];
  }
  else
  {
    uint64_t v3 = &v39;
  }
  void *v3 = 0;
LABEL_7:
  v10[0] = sub_1DC30F4C8;
  v10[1] = 0;
  v10[2] = a1;
  long long v11 = xmmword_1E6C39DA0;
  uint64_t v12 = 0;
  v13[0] = 0;
  v13[1] = sub_1DC3EA264;
  v13[2] = 0;
  uint64_t v13[3] = a1;
  long long v14 = xmmword_1E6C39DB0;
  uint64_t v15 = 0x100000000;
  uint64_t v16 = 1;
  int32x4_t v17 = sub_1DC3C7F78;
  uint64_t v18 = 0;
  uint64_t v19 = a1;
  long long v20 = xmmword_1E6C39DC0;
  uint64_t v21 = 0x200000000;
  uint64_t v22 = 2;
  int32x2_t v23 = nullsub_327;
  uint64_t v24 = 0;
  uint64_t v25 = a1;
  long long v26 = xmmword_1E6C39DD0;
  uint64_t v27 = 0x300000000;
  uint64_t v28 = 3;
  int32x4_t v29 = sub_1DC34B430;
  uint64_t v30 = 0;
  uint64_t v31 = a1;
  long long v32 = xmmword_1E6C39DE0;
  uint64_t v33 = 0x47FFFFFFFLL;
  uint64_t v34 = 4;
  sub_1DC3090E0((unint64_t)v10, (unint64_t)&v35, 4, 1, COERCE_DOUBLE(0x47FFFFFFFLL));
  for (uint64_t i = 0; i != 35; i += 7)
  {
    uint64_t v6 = (char *)operator new(0x20uLL);
    *(void *)uint64_t v6 = &unk_1F3661A70;
    *(_OWORD *)(v6 + 8) = *(_OWORD *)&v10[i];
    *((void *)v6 + 3) = v10[i + 2];
    v40[3] = v6;
    int v7 = v13[i - 1];
    uint64_t v8 = v13[i];
    int v36 = *(_DWORD *)((char *)&v12 + i * 8 + 4);
    int v37 = v7;
    uint64_t v35 = v8;
    if (!v39) {
      sub_1DC307C38();
    }
    (*(void (**)(void *, void *, void *, int *, int *, uint64_t *))(*v39 + 48))(v39, v40, &v10[i + 3], &v37, &v36, &v35);
    sub_1DC3079EC(v40);
  }
  return sub_1DC306CE8(v38);
}

void sub_1DC306CB0(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC306CE8(void *a1)
{
  CFTypeID v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1DC306D6C(uint64_t *a1, uint64_t a2, atomic_ullong *a3, atomic_ullong *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  uint64_t v6 = a3;
  uint64_t v8 = *a1;
  uint64_t v9 = a2 - *a1;
  uint64_t v10 = v9 >> 3;
  long long v11 = (atomic_ullong *)(*a1 + (v9 & 0xFFFFFFFFFFFFFFF8));
  uint64_t v12 = a1 + 2;
  uint64_t v13 = a1[2];
  unint64_t v14 = a1[1];
  if (a5 > (uint64_t)(v13 - v14) >> 3)
  {
    unint64_t v15 = a5 + ((uint64_t)(v14 - v8) >> 3);
    if (v15 >> 61) {
      sub_1DC2FF97C();
    }
    uint64_t v16 = v13 - v8;
    if (v16 >> 2 > v15) {
      unint64_t v15 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v15;
    }
    int32x4_t v42 = v12;
    if (v17) {
      unint64_t v17 = (unint64_t)sub_1DC2FFD7C(v17);
    }
    else {
      uint64_t v18 = 0;
    }
    long long v26 = (void *)(v17 + 8 * v10);
    v39[0] = v17;
    v39[1] = v26;
    int32x4_t v40 = v26;
    unint64_t v41 = v17 + 8 * v18;
    uint64_t v27 = 8 * a5;
    uint64_t v28 = &v26[a5];
    do
    {
      CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(v6, memory_order_acquire);
      if (explicit) {
        CFTypeRef explicit = CFRetain(explicit);
      }
      *v26++ = explicit;
      ++v6;
      v27 -= 8;
    }
    while (v27);
    int32x4_t v40 = v28;
    sub_1DC30831C(a1, v39, (uint64_t)v11);
    sub_1DC308428((uint64_t)v39);
    return;
  }
  uint64_t v19 = v14 - (void)v11;
  uint64_t v20 = (uint64_t)(v14 - (void)v11) >> 3;
  if (v20 >= a5)
  {
    uint64_t v22 = &a3[a5];
    uint64_t v25 = (void *)a1[1];
LABEL_27:
    uint64_t v30 = &v11[a5];
    uint64_t v31 = &v25[-a5];
    long long v32 = v25;
    if ((unint64_t)v31 < v14)
    {
      long long v32 = v25;
      do
        *v32++ = atomic_exchange(v31++, 0);
      while ((unint64_t)v31 < v14);
    }
    a1[1] = (uint64_t)v32;
    if (v25 != v30)
    {
      uint64_t v33 = v25 - 1;
      uint64_t v34 = 8 * (v25 - v30);
      do
      {
        uint64_t v35 = (const void *)atomic_exchange(v33, atomic_exchange((atomic_ullong *volatile)(v8 + 8 * v10 - 8 + v34), 0));
        if (v35) {
          CFRelease(v35);
        }
        --v33;
        v34 -= 8;
      }
      while (v34);
    }
    for (; v6 != v22; ++v11)
    {
      CFTypeRef v36 = (CFTypeRef)atomic_load_explicit(v6, memory_order_acquire);
      if (v36) {
        CFTypeRef v36 = CFRetain(v36);
      }
      int v37 = (const void *)atomic_exchange(v11, (unint64_t)v36);
      if (v37) {
        CFRelease(v37);
      }
      ++v6;
    }
    return;
  }
  uint64_t v22 = &a3[v20];
  if (v22 == a4)
  {
    uint64_t v25 = (void *)a1[1];
  }
  else
  {
    uint64_t v38 = v10;
    uint64_t v23 = 0;
    do
    {
      CFTypeRef v24 = (CFTypeRef)atomic_load_explicit(&v22[v23], memory_order_acquire);
      if (v24) {
        CFTypeRef v24 = CFRetain(v24);
      }
      *(void *)(v14 + v23 * 8) = v24;
      ++v23;
    }
    while (&v22[v23] != a4);
    uint64_t v25 = (void *)(v14 + v23 * 8);
    uint64_t v19 = v14 - (void)v11;
    uint64_t v10 = v38;
  }
  a1[1] = (uint64_t)v25;
  if (v19 >= 1) {
    goto LABEL_27;
  }
}

void sub_1DC306FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1DC308428((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DC306FEC()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA4F8] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA348], MEMORY[0x1E4FBA1F0]);
}

void sub_1DC307038(void ***a1)
{
  uint64_t v1 = *a1;
  CFTypeID v2 = (atomic_ullong *)**a1;
  if (v2)
  {
    uint64_t v4 = (atomic_ullong *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        uint64_t v4 = sub_1DC3073A4(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

atomic_ullong *sub_1DC3070BC(atomic_ullong *a1)
{
  CFTypeID v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

atomic_ullong *sub_1DC3070F0(atomic_ullong *result, uint64_t a2)
{
  if (*((unsigned __int8 *)result + 96) == *(unsigned __int8 *)(a2 + 96))
  {
    if (*((unsigned char *)result + 96))
    {
      uint64_t v3 = sub_1DC390B00(result);
      return sub_1DC390CA0(v3, (uint64_t *)a2);
    }
  }
  else if (*((unsigned char *)result + 96))
  {
    uint64_t result = sub_1DC390B00(result);
    *((unsigned char *)result + 96) = 0;
  }
  else
  {
    uint64_t result = sub_1DC390CA0(result, (uint64_t *)a2);
    *((unsigned char *)result + 96) = 1;
  }
  return result;
}

void sub_1DC307168(void ***a1)
{
  uint64_t v1 = *a1;
  CFTypeID v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7) {
          sub_1DC3069B0(v6);
        }
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DC3071F0(void ***a1)
{
  uint64_t v1 = *a1;
  CFTypeID v2 = (atomic_ullong *)**a1;
  if (v2)
  {
    uint64_t v4 = (atomic_ullong *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 27;
        sub_1DC307370(v4 - 26);
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

atomic_ullong *sub_1DC307278(atomic_ullong *a1)
{
  CFTypeID v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1DC3072AC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    CFTypeID v2 = *(atomic_ullong ***)a1;
    if (sub_1DC383690(**(atomic_ullong ***)a1))
    {
      uint64_t v3 = v2[7];
      if (v3)
      {
        for (atomic_ullong i = *v3; i != v3[1]; i += 216)
        {
          char v5 = sub_1DC383690((atomic_ullong *)(i + 8));
          uint64_t v3 = v2[7];
          if ((v5 & 1) == 0)
          {
            while (i != *v3)
            {
              if ((sub_1DC383628((atomic_ullong *)(i - 208)) & 1) == 0) {
                _os_assumes_log();
              }
              i -= 216;
              uint64_t v3 = v2[7];
            }
            if ((sub_1DC383628(*v2) & 1) == 0) {
              _os_assumes_log();
            }
            goto LABEL_14;
          }
        }
      }
    }
    else
    {
LABEL_14:
      _os_assumes_log();
    }
  }
  return a1;
}

atomic_ullong *sub_1DC307370(atomic_ullong *a1)
{
  CFTypeID v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

atomic_ullong *sub_1DC3073A4(atomic_ullong *a1)
{
  CFTypeID v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *sub_1DC3073D8()
{
  return &unk_1F365DB18;
}

uint64_t sub_1DC3073E4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_7"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

BOOL sub_1DC307420(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if ((a2 & a1) < 0 != __OFSUB__(a1, a2)) {
    return strcmp((const char *)(a1 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(a2 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void *sub_1DC30746C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, uint64_t *a6)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  sub_1DC3075A0((uint64_t)v18, a2);
  int v9 = *a5;
  uint64_t v10 = *a6;
  int v17 = v9;
  long long v11 = (dispatch_group_t **)a1[3];
  sub_1DC3075A0((uint64_t)v19, (uint64_t)v18);
  uint64_t v12 = a1[1];
  uint64_t v13 = a1[2];
  *(void *)&long long v20 = v10;
  *((void *)&v20 + 1) = v12;
  *(void *)&long long v21 = &v17;
  *((void *)&v21 + 1) = v13;
  uint64_t v23 = 0;
  unint64_t v14 = (char *)operator new(0x48uLL);
  *(void *)unint64_t v14 = &unk_1F365E7E0;
  sub_1DC3075A0((uint64_t)(v14 + 8), (uint64_t)v19);
  long long v15 = v21;
  *(_OWORD *)(v14 + 40) = v20;
  *(_OWORD *)(v14 + 56) = v15;
  uint64_t v23 = v14;
  sub_1DC307620(v11, (uint64_t)v22);
  sub_1DC307968(v22);
  sub_1DC3079EC(v19);
  return sub_1DC3079EC(v18);
}

void sub_1DC307574(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_1DC307968((void *)(v2 - 72));
  sub_1DC3079EC((uint64_t *)va1);
  sub_1DC3079EC((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3075A0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void *sub_1DC307620(dispatch_group_t **a1, uint64_t a2)
{
  v29[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (atomic_ullong *)*a1;
  if (BYTE2((*a1)[1][8].isa))
  {
    dispatch_group_enter(*a1[1]);
    CFTypeRef explicit = (const void *)atomic_load_explicit(v3, memory_order_acquire);
    if (explicit)
    {
      CFTypeID v6 = CFGetTypeID(explicit);
      if (qword_1EBFFB7E0 != -1) {
        dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
      }
      if (v6 != qword_1EBFFB818) {
        _os_assumes_log();
      }
    }
    sub_1DC307AF0((uint64_t)v22, a2);
    uint64_t v23 = a1[1];
    uint64_t v25 = 0;
    uint64_t v7 = operator new(0x30uLL);
    void *v7 = &unk_1F365E838;
    sub_1DC307A70((uint64_t)(v7 + 1), (uint64_t)v22);
    v7[5] = v23;
    uint64_t v25 = v7;
    sub_1DC3C164C((uint64_t)explicit + 16, 1, (uint64_t)v24);
  }
  uint64_t v8 = (void *)atomic_load_explicit(v3, memory_order_acquire);
  if (v8)
  {
    CFTypeID v9 = CFGetTypeID(v8);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v9 != qword_1EBFFB818) {
      _os_assumes_log();
    }
  }
  uint64_t v10 = v8[2];
  sub_1DC307A70((uint64_t)v26, a2);
  if (v27)
  {
    dispatch_qos_class_t v11 = *(_DWORD *)(v10 + 24);
    HIDWORD(v13) = v11 - 9;
    LODWORD(v13) = v11 - 9;
    unsigned int v12 = v13 >> 2;
    BOOL v14 = v12 > 6;
    int v15 = (1 << v12) & 0x5D;
    if (v14 || v15 == 0)
    {
      (*(void (**)(void))(*(void *)v27 + 48))();
    }
    else
    {
      int v17 = *(_DWORD *)(v10 + 28);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 1174405120;
      block[2] = sub_1DC3C1C84;
      block[3] = &unk_1F3664CB8;
      sub_1DC307AF0((uint64_t)v29, (uint64_t)v26);
      if ((v17 & (v17 >> 31)) <= -15) {
        int v18 = -15;
      }
      else {
        int v18 = v17 & (v17 >> 31);
      }
      dispatch_block_t v19 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v11, v18, block);
      if (v19)
      {
        long long v20 = v19;
        (*((void (**)(void))v19 + 2))();
        _Block_release(v20);
      }
      else
      {
        if (!v27) {
          sub_1DC307C38();
        }
        (*(void (**)(uint64_t))(*(void *)v27 + 48))(v27);
      }
      sub_1DC307968(v29);
    }
  }
  return sub_1DC307968(v26);
}

void sub_1DC307920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_1DC307968((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC307968(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1DC3079EC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1DC307A70(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t sub_1DC307AF0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_1DC307B88()
{
  return &unk_1F365DB78;
}

uint64_t sub_1DC307B94(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK4$_10clENS9_8functionIFvvEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC307BD0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    sub_1DC307C38();
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  uint64_t v3 = **(NSObject ***)(a1 + 40);
  dispatch_group_leave(v3);
}

void sub_1DC307C38()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = &unk_1F3662198;
  __cxa_throw(exception, (struct type_info *)&unk_1F36607F8, (void (*)(void *))std::exception::~exception);
}

void sub_1DC307C88(std::exception *a1)
{
  std::exception::~exception(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC307CC0(void *a1)
{
  sub_1DC307968(a1 + 1);
  operator delete(a1);
}

void *sub_1DC307CFC(uint64_t a1)
{
  return sub_1DC307968((void *)(a1 + 8));
}

uint64_t sub_1DC307D04(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365E838;
  uint64_t result = sub_1DC307AF0((uint64_t)(a2 + 1), a1 + 8);
  a2[5] = *(void *)(a1 + 40);
  return result;
}

void *sub_1DC307D58(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = operator new(0x30uLL);
  void *v3 = &unk_1F365E838;
  sub_1DC307AF0((uint64_t)(v3 + 1), v2);
  v3[5] = *(void *)(a1 + 40);
  return v3;
}

void sub_1DC307DC0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DC307DD4(void *a1)
{
  *a1 = &unk_1F365E838;
  sub_1DC307968(a1 + 1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC307E38(void *a1)
{
  *a1 = &unk_1F365E838;
  sub_1DC307968(a1 + 1);
  return a1;
}

void *sub_1DC307E7C()
{
  return &unk_1F365DB68;
}

uint64_t sub_1DC307E88(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK3$_7clINS9_8functionIFvRKNS0_4PassEEEENS9_17basic_string_viewIcSB_EEiNS_9symbology12ImplCategoryEmEEDaT_RKT0_T1_T2_T3_EUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC307EC4(uint64_t result)
{
  uint64_t v1 = *(atomic_ullong ***)(result + 48);
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  if (*v1 != v3)
  {
    uint64_t v4 = result;
    do
    {
      unint64_t explicit = atomic_load_explicit(v2, memory_order_acquire);
      uint64_t result = sub_1DC328FAC((atomic_ullong *)(explicit + 136), **(_DWORD **)(v4 + 56));
      if (result)
      {
        CFTypeID v6 = *(void **)(v4 + 64);
        uint64_t v7 = *(void *)(v4 + 40);
        uint64_t v8 = (atomic_ullong *)(*v6 + (v7 << 6));
        if (!atomic_load_explicit(v8, memory_order_acquire))
        {
          v19[0] = (atomic_ullong)sub_1DC30637C();
          CFTypeID v9 = (const void *)atomic_exchange(v8, atomic_exchange(v19, 0));
          if (v9) {
            CFRelease(v9);
          }
          sub_1DC307278(v19);
        }
        uint64_t v10 = v6[1];
        uint64_t v11 = v6[2];
        unint64_t v12 = atomic_load_explicit(v8, memory_order_acquire) + 16;
        uint64_t v13 = v6[3] + (v7 << 6);
        atomic_ullong v14 = *(void *)(v10 + 8);
        uint64_t v15 = *(void *)v10 + 16;
        uint64_t v16 = *(uint64_t **)(v10 + 16);
        uint64_t v17 = **(void **)(v10 + 24);
        v19[0] = v12;
        v19[1] = v15;
        v19[2] = v14;
        v19[3] = explicit + 16;
        char v20 = 1;
        uint64_t v21 = v11 + (v7 << 7);
        uint64_t v22 = *v16;
        char v23 = 1;
        uint64_t v24 = v13;
        uint64_t v25 = v17;
        uint64_t v18 = *(void *)(v4 + 32);
        if (!v18) {
          sub_1DC307C38();
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, atomic_ullong *))(*(void *)v18 + 48))(v18, v19);
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return result;
}

void sub_1DC308000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

void sub_1DC308014(void *a1)
{
  sub_1DC3079EC(a1 + 1);
  operator delete(a1);
}

void *sub_1DC308050(uint64_t a1)
{
  return sub_1DC3079EC((void *)(a1 + 8));
}

__n128 sub_1DC308058(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365E7E0;
  sub_1DC3080B4(a2 + 8, a1 + 8);
  __n128 result = *(__n128 *)(a1 + 40);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

uint64_t sub_1DC3080B4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

char *sub_1DC30814C(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = (char *)operator new(0x48uLL);
  *(void *)uint64_t v3 = &unk_1F365E7E0;
  sub_1DC3080B4((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v3 + 56) = *(_OWORD *)(a1 + 56);
  return v3;
}

void sub_1DC3081BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DC3081D0(void *a1)
{
  *a1 = &unk_1F365E7E0;
  sub_1DC3079EC(a1 + 1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC308234(void *a1)
{
  *a1 = &unk_1F365E7E0;
  sub_1DC3079EC(a1 + 1);
  return a1;
}

__n128 sub_1DC308280(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365E628;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3082B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F365E628;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1DC308304()
{
}

uint64_t sub_1DC30831C(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = sub_1DC308478(a3, a3, *a1, *a1, v6, v6);
  a2[1] = v7;
  uint64_t v8 = a1[1];
  uint64_t v9 = a2[2];
  if (v8 != a3)
  {
    uint64_t v10 = 0;
    do
    {
      CFTypeRef explicit = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(a3 + v10), memory_order_acquire);
      if (explicit) {
        CFTypeRef explicit = CFRetain(explicit);
      }
      *(void *)(v9 + v10) = explicit;
      v10 += 8;
    }
    while (a3 + v10 != v8);
    v9 += v10;
    uint64_t v7 = a2[1];
  }
  a2[2] = v9;
  uint64_t v12 = *a1;
  *a1 = v7;
  a2[1] = v12;
  uint64_t v13 = a1[1];
  a1[1] = a2[2];
  a2[2] = v13;
  uint64_t v14 = a1[2];
  a1[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_1DC308428(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC3073A4((atomic_ullong *)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1DC308478(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a2 != a4)
  {
    uint64_t v9 = 0;
    do
    {
      CFTypeRef explicit = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + v9 - 8), memory_order_acquire);
      if (explicit) {
        CFTypeRef explicit = CFRetain(explicit);
      }
      *(void *)(a6 + v9 - 8) = explicit;
      v9 -= 8;
    }
    while (a2 + v9 != a4);
    a6 += v9;
  }
  return a6;
}

void *sub_1DC308514()
{
  return &unk_1F365DB08;
}

uint64_t sub_1DC308520(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_6"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1DC30855C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  sub_1DC3075A0((uint64_t)v13, a2);
  uint64_t v8 = *a6;
  uint64_t v9 = *(dispatch_group_t ***)(a1 + 16);
  sub_1DC3075A0((uint64_t)v14, (uint64_t)v13);
  uint64_t v10 = *(void *)(a1 + 8);
  *(void *)&long long v15 = v8;
  *((void *)&v15 + 1) = v10;
  uint64_t v17 = 0;
  uint64_t v11 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v11 = &unk_1F365E788;
  sub_1DC3075A0((uint64_t)(v11 + 8), (uint64_t)v14);
  *(_OWORD *)(v11 + 40) = v15;
  uint64_t v17 = v11;
  sub_1DC307620(v9, (uint64_t)v16);
  sub_1DC307968(v16);
  sub_1DC3079EC(v14);
  return sub_1DC3079EC(v13);
}

void sub_1DC308648(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_1DC307968((void *)(v2 - 72));
  sub_1DC3079EC((uint64_t *)va1);
  sub_1DC3079EC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC308674()
{
  return &unk_1F365DB58;
}

uint64_t sub_1DC308680(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK3$_6clINS9_8functionIFvRKNS0_4PassEEEENS9_17basic_string_viewIcSB_EEiNS_9symbology12ImplCategoryEmEEDaT_RKT0_T1_T2_T3_EUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC3086BC(void *a1)
{
  uint64_t v3 = a1[5];
  uint64_t v2 = (void *)a1[6];
  uint64_t v4 = (atomic_ullong *)(*v2 + (v3 << 6));
  if (!atomic_load_explicit(v4, memory_order_acquire))
  {
    v16[0] = (atomic_ullong)sub_1DC30637C();
    char v5 = (const void *)atomic_exchange(v4, atomic_exchange(v16, 0));
    if (v5) {
      CFRelease(v5);
    }
    sub_1DC307278(v16);
  }
  uint64_t v6 = v2[1];
  uint64_t v7 = v2[2];
  unint64_t explicit = atomic_load_explicit(v4, memory_order_acquire);
  uint64_t v9 = v2[3] + (v3 << 6);
  atomic_ullong v10 = *(void *)(v6 + 8);
  uint64_t v11 = *(void *)v6 + 16;
  uint64_t v12 = *(uint64_t **)(v6 + 16);
  uint64_t v13 = **(void **)(v6 + 24);
  v16[0] = explicit + 16;
  v16[1] = v11;
  v16[2] = v10;
  char v17 = 0;
  char v18 = 0;
  uint64_t v19 = v7 + (v3 << 7);
  uint64_t v20 = *v12;
  char v21 = 1;
  uint64_t v22 = v9;
  uint64_t v23 = v13;
  uint64_t v14 = a1[4];
  if (!v14) {
    sub_1DC307C38();
  }
  return (*(uint64_t (**)(uint64_t, atomic_ullong *))(*(void *)v14 + 48))(v14, v16);
}

void sub_1DC3087A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

void sub_1DC3087BC(void *a1)
{
  sub_1DC3079EC(a1 + 1);
  operator delete(a1);
}

void *sub_1DC3087F8(uint64_t a1)
{
  return sub_1DC3079EC((void *)(a1 + 8));
}

__n128 sub_1DC308800(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365E788;
  sub_1DC3080B4(a2 + 8, a1 + 8);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

char *sub_1DC308854(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v3 = &unk_1F365E788;
  sub_1DC3080B4((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 40);
  return v3;
}

void sub_1DC3088BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DC3088D0(void *a1)
{
  *a1 = &unk_1F365E788;
  sub_1DC3079EC(a1 + 1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC308934(void *a1)
{
  *a1 = &unk_1F365E788;
  sub_1DC3079EC(a1 + 1);
  return a1;
}

__n128 sub_1DC308980(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365E5D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3089A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F365E5D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC3089F4()
{
}

void *sub_1DC308A0C()
{
  return &unk_1F365DAF8;
}

uint64_t sub_1DC308A18(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_5"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1DC308A54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  sub_1DC3075A0((uint64_t)v15, a2);
  LODWORD(a5) = *a5;
  uint64_t v9 = *a6;
  atomic_ullong v10 = *(dispatch_group_t ***)(a1 + 48);
  sub_1DC3075A0((uint64_t)v16, (uint64_t)v15);
  LODWORD(v17) = a5;
  *((void *)&v17 + 1) = v9;
  long long v11 = *(_OWORD *)(a1 + 24);
  long long v18 = *(_OWORD *)(a1 + 8);
  long long v19 = v11;
  uint64_t v20 = *(void *)(a1 + 40);
  uint64_t v22 = 0;
  uint64_t v12 = (char *)operator new(0x60uLL);
  *(void *)uint64_t v12 = &unk_1F365E730;
  sub_1DC3075A0((uint64_t)(v12 + 8), (uint64_t)v16);
  long long v13 = v18;
  *(_OWORD *)(v12 + 40) = v17;
  *(_OWORD *)(v12 + 56) = v13;
  *(_OWORD *)(v12 + 72) = v19;
  *((void *)v12 + 11) = v20;
  uint64_t v22 = v12;
  sub_1DC307620(v10, (uint64_t)v21);
  sub_1DC307968(v21);
  sub_1DC3079EC(v16);
  return sub_1DC3079EC(v15);
}

void sub_1DC308B7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  sub_1DC307968((void *)(v13 - 88));
  sub_1DC3079EC(&a13);
  sub_1DC3079EC(&a9);
  _Unwind_Resume(a1);
}

void *sub_1DC308BA8()
{
  return &unk_1F365DB48;
}

uint64_t sub_1DC308BB4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK3$_5clINS9_8functionIFvRKNS0_4PassEEEENS9_17basic_string_viewIcSB_EEiNS_9symbology12ImplCategoryEmEEDaT_RKT0_T1_T2_T3_EUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC308BF0(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 56) + 8);
  if (v1)
  {
    for (uint64_t i = 0; i != v1; ++i)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)(**(void **)(a1 + 64) + (i << 6)), memory_order_acquire) & 1) == 0)
      {
        uint64_t v4 = (atomic_ullong *)(**(void **)(a1 + 56) + 8 * i);
        if (sub_1DC328FAC((atomic_ullong *)(atomic_load_explicit(v4, memory_order_acquire) + 136), *(_DWORD *)(a1 + 40)))
        {
          char v5 = *(void **)(a1 + 72);
          unint64_t explicit = atomic_load_explicit(v4, memory_order_acquire);
          uint64_t v7 = *(void *)(a1 + 48);
          uint64_t v8 = (atomic_ullong *)(*v5 + (v7 << 6));
          if (!atomic_load_explicit(v8, memory_order_acquire))
          {
            v32[0] = (atomic_ullong)sub_1DC30637C();
            uint64_t v9 = (const void *)atomic_exchange(v8, atomic_exchange(v32, 0));
            if (v9) {
              CFRelease(v9);
            }
            sub_1DC307278(v32);
          }
          uint64_t v10 = v5[1];
          uint64_t v11 = v5[2];
          unint64_t v12 = atomic_load_explicit(v8, memory_order_acquire) + 16;
          uint64_t v13 = v5[3] + (v7 << 6);
          atomic_ullong v14 = *(void *)(v10 + 8);
          uint64_t v15 = *(void *)v10 + 16;
          uint64_t v16 = *(uint64_t **)(v10 + 16);
          uint64_t v17 = **(void **)(v10 + 24);
          v32[0] = v12;
          v32[1] = v15;
          v32[2] = v14;
          v32[3] = explicit + 16;
          char v33 = 1;
          uint64_t v34 = v11 + (v7 << 7);
          uint64_t v35 = *v16;
          char v36 = 1;
          uint64_t v37 = v13;
          uint64_t v38 = v17;
          uint64_t v18 = *(void *)(a1 + 32);
          if (!v18) {
            sub_1DC307C38();
          }
          (*(void (**)(uint64_t, atomic_ullong *))(*(void *)v18 + 48))(v18, v32);
          long long v19 = (unsigned char *)(*(void *)(a1 + 80) + (*(void *)(a1 + 48) << 6));
          if (v19[1] && *v19)
          {
            atomic_store(1u, (unsigned __int8 *)(**(void **)(a1 + 64) + (i << 6)));
            uint64_t v20 = *(void *)(a1 + 88) + (*(void *)(a1 + 48) << 6);
            uint64_t v22 = *(void **)(v20 + 8);
            unint64_t v21 = *(void *)(v20 + 16);
            if ((unint64_t)v22 >= v21)
            {
              uint64_t v24 = *(void **)v20;
              uint64_t v25 = ((uint64_t)v22 - *(void *)v20) >> 3;
              unint64_t v26 = v25 + 1;
              if ((unint64_t)(v25 + 1) >> 61) {
                sub_1DC2FF97C();
              }
              uint64_t v27 = v21 - (void)v24;
              if (v27 >> 2 > v26) {
                unint64_t v26 = v27 >> 2;
              }
              if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v28 = v26;
              }
              if (v28)
              {
                unint64_t v28 = (unint64_t)sub_1DC2FFD7C(v28);
                uint64_t v24 = *(void **)v20;
                uint64_t v22 = *(void **)(v20 + 8);
              }
              else
              {
                uint64_t v29 = 0;
              }
              uint64_t v30 = (void *)(v28 + 8 * v25);
              *uint64_t v30 = i;
              uint64_t v23 = v30 + 1;
              while (v22 != v24)
              {
                uint64_t v31 = *--v22;
                *--uint64_t v30 = v31;
              }
              *(void *)uint64_t v20 = v30;
              *(void *)(v20 + 8) = v23;
              *(void *)(v20 + 16) = v28 + 8 * v29;
              if (v24) {
                operator delete(v24);
              }
            }
            else
            {
              *uint64_t v22 = i;
              uint64_t v23 = v22 + 1;
            }
            *(void *)(v20 + 8) = v23;
          }
        }
      }
    }
  }
}

void sub_1DC308E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

void sub_1DC308E40(void *a1)
{
  sub_1DC3079EC(a1 + 1);
  operator delete(a1);
}

void *sub_1DC308E7C(uint64_t a1)
{
  return sub_1DC3079EC((void *)(a1 + 8));
}

__n128 sub_1DC308E84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365E730;
  sub_1DC3080B4(a2 + 8, a1 + 8);
  __n128 result = *(__n128 *)(a1 + 40);
  long long v5 = *(_OWORD *)(a1 + 56);
  long long v6 = *(_OWORD *)(a1 + 72);
  *(void *)(a2 + 88) = *(void *)(a1 + 88);
  *(_OWORD *)(a2 + 72) = v6;
  *(_OWORD *)(a2 + 56) = v5;
  *(__n128 *)(a2 + 40) = result;
  return result;
}

char *sub_1DC308EF0(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = (char *)operator new(0x60uLL);
  *(void *)uint64_t v3 = &unk_1F365E730;
  sub_1DC3080B4((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v3 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v3 + 72) = *(_OWORD *)(a1 + 72);
  *((void *)v3 + 11) = *(void *)(a1 + 88);
  return v3;
}

void sub_1DC308F70(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DC308F84(void *a1)
{
  *a1 = &unk_1F365E730;
  sub_1DC3079EC(a1 + 1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC308FE8(void *a1)
{
  *a1 = &unk_1F365E730;
  sub_1DC3079EC(a1 + 1);
  return a1;
}

__n128 sub_1DC309034(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365E578;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC30906C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1F365E578;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void sub_1DC3090C8()
{
}

double sub_1DC3090E0(unint64_t a1, unint64_t a2, uint64_t a3, char a4, double result)
{
  while (2)
  {
    unint64_t v11 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v11;
          uint64_t v12 = a2 - v11;
          unint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a2 - v11) >> 3);
          if (v6 || !v5)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                int v87 = *(_DWORD *)(a2 - 16);
                int v88 = *(_DWORD *)(v11 + 40);
                BOOL v6 = v87 == v88;
                BOOL v89 = v87 > v88;
                if (v6) {
                  BOOL v89 = *(_DWORD *)(a2 - 12) < *(_DWORD *)(v11 + 44);
                }
                if (v89)
                {
                  uint64_t v90 = *(void *)(v11 + 16);
                  long long v91 = *(_OWORD *)v11;
                  *(_OWORD *)unint64_t v11 = *(_OWORD *)(a2 - 56);
                  *(void *)(v11 + 16) = *(void *)(a2 - 40);
                  *(_OWORD *)(a2 - 56) = v91;
                  *(void *)(a2 - 40) = v90;
                  long long v92 = *(_OWORD *)(v11 + 24);
                  *(_OWORD *)(v11 + 24) = *(_OWORD *)(a2 - 32);
                  *(_OWORD *)(a2 - 32) = v92;
                  __n128 result = *(double *)(a2 - 16);
                  *(void *)&long long v91 = *(void *)(v11 + 40);
                  *(double *)(v11 + 40) = result;
                  *(void *)(a2 - 16) = v91;
                  uint64_t v93 = *(void *)(v11 + 48);
                  *(void *)(v11 + 48) = *(void *)(a2 - 8);
                  *(void *)(a2 - 8) = v93;
                }
                break;
              case 3uLL:
                sub_1DC309E3C((long long *)v11, (long long *)(v11 + 56), (long long *)(a2 - 56));
                break;
              case 4uLL:
                __n128 result = sub_1DC30A064(v11, v11 + 56, v11 + 112, a2 - 56);
                break;
              case 5uLL:
                __n128 result = sub_1DC30A208(v11, v11 + 56, v11 + 112, v11 + 168, a2 - 56);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 1343)
          {
            uint64_t v94 = (char *)(v11 + 56);
            BOOL v96 = v11 == a2 || v94 == (char *)a2;
            if (a4)
            {
              if (!v96)
              {
                uint64_t v97 = 0;
                uint64_t v98 = (_OWORD *)v11;
                do
                {
                  int v99 = v94;
                  int v100 = *((_DWORD *)v98 + 24);
                  int v101 = *((_DWORD *)v98 + 25);
                  int v102 = *((_DWORD *)v98 + 10);
                  BOOL v6 = v100 == v102;
                  BOOL v103 = v100 > v102;
                  if (v6) {
                    BOOL v103 = v101 < *((_DWORD *)v98 + 11);
                  }
                  if (v103)
                  {
                    long long v104 = *v99;
                    uint64_t v105 = *((void *)v98 + 9);
                    long long v189 = v98[5];
                    uint64_t v106 = *((void *)v98 + 13);
                    uint64_t v107 = v97;
                    while (1)
                    {
                      uint64_t v108 = v107;
                      uint64_t v109 = v11 + v107;
                      *(_OWORD *)(v109 + 56) = *(_OWORD *)v109;
                      *(void *)(v109 + 72) = *(void *)(v109 + 16);
                      *(_OWORD *)(v109 + 80) = *(_OWORD *)(v109 + 24);
                      *(void *)(v109 + 96) = *(void *)(v109 + 40);
                      *(void *)(v109 + 104) = *(void *)(v109 + 48);
                      if (!v108) {
                        break;
                      }
                      int v110 = *(_DWORD *)(v109 - 16);
                      BOOL v111 = v101 < *(_DWORD *)(v109 - 12);
                      BOOL v6 = v100 == v110;
                      BOOL v112 = v100 > v110;
                      if (v6) {
                        BOOL v112 = v111;
                      }
                      uint64_t v107 = v108 - 56;
                      if (!v112)
                      {
                        unint64_t v113 = v11 + v108;
                        uint64_t v114 = (_OWORD *)(v11 + v108 + 24);
                        goto LABEL_113;
                      }
                    }
                    uint64_t v114 = (_OWORD *)(v109 + 24);
                    unint64_t v113 = v11;
LABEL_113:
                    *(_OWORD *)unint64_t v113 = v104;
                    *(void *)(v113 + 16) = v105;
                    __n128 result = *(double *)&v189;
                    *uint64_t v114 = v189;
                    *(_DWORD *)(v113 + 40) = v100;
                    *(_DWORD *)(v113 + 44) = v101;
                    *(void *)(v113 + 48) = v106;
                  }
                  uint64_t v94 = (char *)v99 + 56;
                  v97 += 56;
                  uint64_t v98 = v99;
                }
                while ((_OWORD *)((char *)v99 + 56) != (_OWORD *)a2);
              }
            }
            else if (!v96)
            {
              uint64_t v172 = (void *)(v11 + 104);
              do
              {
                v173 = v94;
                int v174 = *(_DWORD *)(a1 + 96);
                int v175 = *(_DWORD *)(a1 + 100);
                int v176 = *(_DWORD *)(a1 + 40);
                BOOL v6 = v174 == v176;
                BOOL v177 = v174 > v176;
                if (v6) {
                  BOOL v177 = v175 < *(_DWORD *)(a1 + 44);
                }
                if (v177)
                {
                  long long v178 = *v173;
                  uint64_t v179 = *(void *)(a1 + 72);
                  long long v192 = *(_OWORD *)(a1 + 80);
                  uint64_t v180 = *(void *)(a1 + 104);
                  v181 = v172;
                  do
                  {
                    uint64_t v182 = v181;
                    *((_OWORD *)v181 - 3) = *(_OWORD *)(v181 - 13);
                    *(v181 - 4) = *(v181 - 11);
                    *(_OWORD *)(v181 - 3) = *((_OWORD *)v181 - 5);
                    *(v181 - 1) = *(v181 - 8);
                    uint64_t v183 = *(v181 - 7);
                    v181 -= 7;
                    *uint64_t v182 = v183;
                    int v184 = *((_DWORD *)v182 - 30);
                    BOOL v6 = v174 == v184;
                    BOOL v185 = v174 > v184;
                    if (v6) {
                      BOOL v185 = v175 < *((_DWORD *)v182 - 29);
                    }
                  }
                  while (v185);
                  *((_OWORD *)v181 - 3) = v178;
                  *(v181 - 4) = v179;
                  __n128 result = *(double *)&v192;
                  *((_OWORD *)v182 - 5) = v192;
                  *((_DWORD *)v181 - 2) = v174;
                  *((_DWORD *)v181 - 1) = v175;
                  void *v181 = v180;
                }
                uint64_t v94 = (char *)v173 + 56;
                v172 += 7;
                a1 = (unint64_t)v173;
              }
              while ((_OWORD *)((char *)v173 + 56) != (_OWORD *)a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v115 = (v13 - 2) >> 1;
              int64_t v116 = v115;
              do
              {
                int64_t v117 = v116;
                if (v115 >= v116)
                {
                  uint64_t v118 = (2 * v116) | 1;
                  unint64_t v119 = v11 + 56 * v118;
                  if (2 * v117 + 2 < (uint64_t)v13)
                  {
                    int v120 = *(_DWORD *)(v119 + 40);
                    int v121 = *(_DWORD *)(v119 + 96);
                    BOOL v6 = v120 == v121;
                    BOOL v122 = v120 > v121;
                    if (v6) {
                      BOOL v122 = *(_DWORD *)(v119 + 44) < *(_DWORD *)(v119 + 100);
                    }
                    v119 += 56 * v122;
                    if (v122) {
                      uint64_t v118 = 2 * v117 + 2;
                    }
                  }
                  unint64_t v123 = v11 + 56 * v117;
                  int v124 = *(_DWORD *)(v119 + 40);
                  int v126 = *(_DWORD *)(v123 + 40);
                  int v125 = *(_DWORD *)(v123 + 44);
                  BOOL v6 = v124 == v126;
                  BOOL v127 = v124 > v126;
                  if (v6) {
                    BOOL v127 = *(_DWORD *)(v119 + 44) < v125;
                  }
                  if (!v127)
                  {
                    long long v128 = *(_OWORD *)v123;
                    uint64_t v129 = *(void *)(v123 + 16);
                    long long v190 = *(_OWORD *)(v123 + 24);
                    uint64_t v130 = *(void *)(v123 + 48);
                    do
                    {
                      unint64_t v131 = v123;
                      unint64_t v123 = v119;
                      *(_OWORD *)unint64_t v131 = *(_OWORD *)v119;
                      *(void *)(v131 + 16) = *(void *)(v119 + 16);
                      *(_OWORD *)(v131 + 24) = *(_OWORD *)(v119 + 24);
                      *(void *)(v131 + 40) = *(void *)(v119 + 40);
                      *(void *)(v131 + 48) = *(void *)(v119 + 48);
                      if (v115 < v118) {
                        break;
                      }
                      uint64_t v132 = (2 * v118) | 1;
                      unint64_t v119 = v11 + 56 * v132;
                      uint64_t v133 = 2 * v118 + 2;
                      if (v133 < (uint64_t)v13)
                      {
                        int v134 = *(_DWORD *)(v119 + 40);
                        int v135 = *(_DWORD *)(v119 + 96);
                        BOOL v6 = v134 == v135;
                        BOOL v136 = v134 > v135;
                        if (v6) {
                          BOOL v136 = *(_DWORD *)(v119 + 44) < *(_DWORD *)(v119 + 100);
                        }
                        v119 += 56 * v136;
                        if (v136) {
                          uint64_t v132 = v133;
                        }
                      }
                      int v137 = *(_DWORD *)(v119 + 40);
                      BOOL v138 = *(_DWORD *)(v119 + 44) < v125;
                      BOOL v6 = v137 == v126;
                      BOOL v139 = v137 > v126;
                      if (!v6) {
                        BOOL v138 = v139;
                      }
                      uint64_t v118 = v132;
                    }
                    while (!v138);
                    *(_OWORD *)unint64_t v123 = v128;
                    *(void *)(v123 + 16) = v129;
                    *(_OWORD *)(v123 + 24) = v190;
                    *(_DWORD *)(v123 + 40) = v126;
                    *(_DWORD *)(v123 + 44) = v125;
                    *(void *)(v123 + 48) = v130;
                  }
                }
                int64_t v116 = v117 - 1;
              }
              while (v117);
              int64_t v140 = v12 / 0x38uLL;
              do
              {
                uint64_t v141 = 0;
                uint64_t v142 = *(void *)v11;
                uint64_t v143 = *(void *)(v11 + 8);
                uint64_t v144 = *(void *)(v11 + 16);
                long long v186 = *(_OWORD *)(v11 + 24);
                int v145 = *(_DWORD *)(v11 + 40);
                int v146 = *(_DWORD *)(v11 + 44);
                uint64_t v147 = *(void *)(v11 + 48);
                uint64_t v148 = v140 - 2;
                if (v140 < 2) {
                  uint64_t v148 = v140 - 1;
                }
                uint64_t v149 = v148 >> 1;
                unint64_t v150 = v11;
                do
                {
                  uint64_t v151 = v150 + 56 * v141 + 56;
                  uint64_t v152 = (2 * v141) | 1;
                  uint64_t v153 = 2 * v141 + 2;
                  if (v153 < v140)
                  {
                    int v154 = *(_DWORD *)(v151 + 40);
                    int v155 = *(_DWORD *)(v151 + 96);
                    BOOL v6 = v154 == v155;
                    BOOL v156 = v154 > v155;
                    if (v6) {
                      BOOL v156 = *(_DWORD *)(v151 + 44) < *(_DWORD *)(v151 + 100);
                    }
                    v151 += 56 * v156;
                    if (v156) {
                      uint64_t v152 = v153;
                    }
                  }
                  *(_OWORD *)unint64_t v150 = *(_OWORD *)v151;
                  *(void *)(v150 + 16) = *(void *)(v151 + 16);
                  *(_OWORD *)(v150 + 24) = *(_OWORD *)(v151 + 24);
                  *(void *)(v150 + 40) = *(void *)(v151 + 40);
                  *(void *)(v150 + 48) = *(void *)(v151 + 48);
                  unint64_t v150 = v151;
                  uint64_t v141 = v152;
                }
                while (v152 <= v149);
                double v157 = (long long *)(v151 + 24);
                if (v151 == a2 - 56)
                {
                  *(void *)uint64_t v151 = v142;
                  *(void *)(v151 + 8) = v143;
                  *(void *)(v151 + 16) = v144;
                  __n128 result = *(double *)&v186;
                  *double v157 = v186;
                  *(_DWORD *)(v151 + 40) = v145;
                  *(_DWORD *)(v151 + 44) = v146;
                  *(void *)(v151 + 48) = v147;
                }
                else
                {
                  *(_OWORD *)uint64_t v151 = *(_OWORD *)(a2 - 56);
                  *(void *)(v151 + 16) = *(void *)(a2 - 40);
                  *double v157 = *(_OWORD *)(a2 - 32);
                  *(void *)(v151 + 40) = *(void *)(a2 - 16);
                  *(void *)(v151 + 48) = *(void *)(a2 - 8);
                  *(void *)(a2 - 56) = v142;
                  *(void *)(a2 - 48) = v143;
                  *(void *)(a2 - 40) = v144;
                  __n128 result = *(double *)&v186;
                  *(_OWORD *)(a2 - 32) = v186;
                  *(_DWORD *)(a2 - 16) = v145;
                  *(_DWORD *)(a2 - 12) = v146;
                  *(void *)(a2 - 8) = v147;
                  uint64_t v158 = v151 - v11 + 56;
                  if (v158 >= 57)
                  {
                    unint64_t v159 = (unint64_t)(0x6DB6DB6DB6DB6DB7 * (v158 >> 3) - 2) >> 1;
                    uint64_t v160 = v11 + 56 * v159;
                    int v161 = *(_DWORD *)(v160 + 40);
                    int v163 = *(_DWORD *)(v151 + 40);
                    int v162 = *(_DWORD *)(v151 + 44);
                    BOOL v6 = v161 == v163;
                    BOOL v164 = v161 > v163;
                    if (v6) {
                      BOOL v164 = *(_DWORD *)(v160 + 44) < v162;
                    }
                    if (v164)
                    {
                      long long v165 = *(_OWORD *)v151;
                      uint64_t v166 = *(void *)(v151 + 16);
                      long long v191 = *v157;
                      uint64_t v167 = *(void *)(v151 + 48);
                      do
                      {
                        uint64_t v168 = v151;
                        uint64_t v151 = v160;
                        *(_OWORD *)uint64_t v168 = *(_OWORD *)v160;
                        *(void *)(v168 + 16) = *(void *)(v160 + 16);
                        *(_OWORD *)(v168 + 24) = *(_OWORD *)(v160 + 24);
                        *(void *)(v168 + 40) = *(void *)(v160 + 40);
                        *(void *)(v168 + 48) = *(void *)(v160 + 48);
                        if (!v159) {
                          break;
                        }
                        unint64_t v159 = (v159 - 1) >> 1;
                        uint64_t v160 = v11 + 56 * v159;
                        int v169 = *(_DWORD *)(v160 + 40);
                        BOOL v6 = v169 == v163;
                        BOOL v170 = v169 > v163;
                        if (v6) {
                          BOOL v170 = *(_DWORD *)(v160 + 44) < v162;
                        }
                      }
                      while (v170);
                      *(_OWORD *)uint64_t v151 = v165;
                      *(void *)(v151 + 16) = v166;
                      __n128 result = *(double *)&v191;
                      *(_OWORD *)(v151 + 24) = v191;
                      *(_DWORD *)(v151 + 40) = v163;
                      *(_DWORD *)(v151 + 44) = v162;
                      *(void *)(v151 + 48) = v167;
                    }
                  }
                }
                a2 -= 56;
              }
              while (v140-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          unint64_t v15 = v11 + 56 * (v13 >> 1);
          if ((unint64_t)v12 >= 0x1C01)
          {
            sub_1DC309E3C((long long *)a1, (long long *)(a1 + 56 * (v13 >> 1)), (long long *)(a2 - 56));
            uint64_t v16 = 56 * v14;
            uint64_t v17 = (long long *)(56 * v14 + a1 - 56);
            sub_1DC309E3C((long long *)(a1 + 56), v17, (long long *)(a2 - 112));
            uint64_t v18 = (long long *)(a1 + 56 + v16);
            sub_1DC309E3C((long long *)(a1 + 112), v18, (long long *)(a2 - 168));
            sub_1DC309E3C(v17, (long long *)v15, v18);
            uint64_t v19 = *(void *)(a1 + 16);
            long long v20 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *(_OWORD *)v15;
            *(void *)(a1 + 16) = *(void *)(v15 + 16);
            *(_OWORD *)unint64_t v15 = v20;
            *(void *)(v15 + 16) = v19;
            long long v21 = *(_OWORD *)(a1 + 24);
            *(_OWORD *)(a1 + 24) = *(_OWORD *)(v15 + 24);
            *(_OWORD *)(v15 + 24) = v21;
            *(void *)&long long v20 = *(void *)(a1 + 40);
            *(void *)(a1 + 40) = *(void *)(v15 + 40);
            *(void *)(v15 + 40) = v20;
            uint64_t v22 = *(void *)(a1 + 48);
            *(void *)(a1 + 48) = *(void *)(v15 + 48);
            *(void *)(v15 + 48) = v22;
          }
          else
          {
            sub_1DC309E3C((long long *)(a1 + 56 * (v13 >> 1)), (long long *)a1, (long long *)(a2 - 56));
          }
          --a3;
          if (a4)
          {
            int v23 = *(_DWORD *)(a1 + 40);
            int v24 = *(_DWORD *)(a1 + 44);
            break;
          }
          int v25 = *(_DWORD *)(a1 - 16);
          int v23 = *(_DWORD *)(a1 + 40);
          int v24 = *(_DWORD *)(a1 + 44);
          BOOL v6 = v25 == v23;
          BOOL v26 = v25 > v23;
          if (v6) {
            BOOL v26 = *(_DWORD *)(a1 - 12) < v24;
          }
          if (v26) {
            break;
          }
          long long v57 = *(_OWORD *)a1;
          uint64_t v58 = *(void *)(a1 + 16);
          long long v188 = *(_OWORD *)(a1 + 24);
          int v59 = *(_DWORD *)(a2 - 16);
          BOOL v6 = v23 == v59;
          BOOL v60 = v23 > v59;
          if (v6) {
            BOOL v60 = v24 < *(_DWORD *)(a2 - 12);
          }
          if (v60)
          {
            unint64_t v61 = a1;
            do
            {
              unint64_t v11 = v61 + 56;
              int v62 = *(_DWORD *)(v61 + 96);
              BOOL v63 = v24 < *(_DWORD *)(v61 + 100);
              BOOL v6 = v23 == v62;
              BOOL v64 = v23 > v62;
              if (v6) {
                BOOL v64 = v63;
              }
              unint64_t v61 = v11;
            }
            while (!v64);
          }
          else
          {
            unint64_t v65 = a1 + 56;
            do
            {
              unint64_t v11 = v65;
              if (v65 >= a2) {
                break;
              }
              int v66 = *(_DWORD *)(v65 + 40);
              BOOL v67 = v24 < *(_DWORD *)(v11 + 44);
              BOOL v6 = v23 == v66;
              BOOL v68 = v23 > v66;
              if (!v6) {
                BOOL v67 = v68;
              }
              unint64_t v65 = v11 + 56;
            }
            while (!v67);
          }
          unint64_t v69 = a2;
          if (v11 < a2)
          {
            unint64_t v70 = a2;
            do
            {
              unint64_t v69 = v70 - 56;
              int v71 = *(_DWORD *)(v70 - 16);
              BOOL v72 = v24 < *(_DWORD *)(v70 - 12);
              BOOL v6 = v23 == v71;
              BOOL v73 = v23 > v71;
              if (v6) {
                BOOL v73 = v72;
              }
              unint64_t v70 = v69;
            }
            while (v73);
          }
          uint64_t v74 = *(void *)(a1 + 48);
          while (v11 < v69)
          {
            uint64_t v75 = *(void *)(v11 + 16);
            long long v76 = *(_OWORD *)v11;
            *(_OWORD *)unint64_t v11 = *(_OWORD *)v69;
            *(void *)(v11 + 16) = *(void *)(v69 + 16);
            *(_OWORD *)unint64_t v69 = v76;
            *(void *)(v69 + 16) = v75;
            long long v77 = *(_OWORD *)(v11 + 24);
            *(_OWORD *)(v11 + 24) = *(_OWORD *)(v69 + 24);
            *(_OWORD *)(v69 + 24) = v77;
            *(void *)&long long v76 = *(void *)(v11 + 40);
            *(void *)(v11 + 40) = *(void *)(v69 + 40);
            *(void *)(v69 + 40) = v76;
            uint64_t v78 = *(void *)(v11 + 48);
            *(void *)(v11 + 48) = *(void *)(v69 + 48);
            *(void *)(v69 + 48) = v78;
            do
            {
              int v79 = *(_DWORD *)(v11 + 96);
              int v80 = *(_DWORD *)(v11 + 100);
              v11 += 56;
              BOOL v81 = v24 < v80;
              BOOL v6 = v23 == v79;
              BOOL v82 = v23 > v79;
              if (v6) {
                BOOL v82 = v81;
              }
            }
            while (!v82);
            do
            {
              int v83 = *(_DWORD *)(v69 - 16);
              int v84 = *(_DWORD *)(v69 - 12);
              v69 -= 56;
              BOOL v85 = v24 < v84;
              BOOL v6 = v23 == v83;
              BOOL v86 = v23 > v83;
              if (v6) {
                BOOL v86 = v85;
              }
            }
            while (v86);
          }
          BOOL v5 = v11 - 56 >= a1;
          BOOL v6 = v11 - 56 == a1;
          if (v11 - 56 != a1)
          {
            *(_OWORD *)a1 = *(_OWORD *)(v11 - 56);
            *(void *)(a1 + 16) = *(void *)(v11 - 40);
            *(_OWORD *)(a1 + 24) = *(_OWORD *)(v11 - 32);
            *(void *)(a1 + 40) = *(void *)(v11 - 16);
            *(void *)(a1 + 48) = *(void *)(v11 - 8);
          }
          a4 = 0;
          *(_OWORD *)(v11 - 56) = v57;
          *(void *)(v11 - 40) = v58;
          __n128 result = *(double *)&v188;
          *(_OWORD *)(v11 - 32) = v188;
          *(_DWORD *)(v11 - 16) = v23;
          *(_DWORD *)(v11 - 12) = v24;
          *(void *)(v11 - 8) = v74;
        }
        long long v27 = *(_OWORD *)a1;
        uint64_t v28 = *(void *)(a1 + 16);
        long long v187 = *(_OWORD *)(a1 + 24);
        uint64_t v29 = *(void *)(a1 + 48);
        unint64_t v30 = a1;
        do
        {
          unint64_t v31 = v30;
          v30 += 56;
          int v32 = *(_DWORD *)(v31 + 96);
          BOOL v6 = v32 == v23;
          BOOL v33 = v32 > v23;
          if (v6) {
            BOOL v33 = *(_DWORD *)(v31 + 100) < v24;
          }
        }
        while (v33);
        unint64_t v34 = a2;
        if (v31 == a1)
        {
          unint64_t v39 = a2;
          while (v30 < v39)
          {
            unint64_t v35 = v39 - 56;
            int v40 = *(_DWORD *)(v39 - 16);
            BOOL v41 = *(_DWORD *)(v39 - 12) < v24;
            BOOL v6 = v40 == v23;
            BOOL v42 = v40 > v23;
            if (v6) {
              BOOL v42 = v41;
            }
            unint64_t v39 = v35;
            if (v42) {
              goto LABEL_30;
            }
          }
          unint64_t v35 = v39;
        }
        else
        {
          do
          {
            unint64_t v35 = v34 - 56;
            int v36 = *(_DWORD *)(v34 - 16);
            BOOL v37 = *(_DWORD *)(v34 - 12) < v24;
            BOOL v6 = v36 == v23;
            BOOL v38 = v36 > v23;
            if (v6) {
              BOOL v38 = v37;
            }
            unint64_t v34 = v35;
          }
          while (!v38);
        }
LABEL_30:
        unint64_t v11 = v30;
        if (v30 < v35)
        {
          unint64_t v43 = v35;
          do
          {
            uint64_t v44 = *(void *)(v11 + 16);
            long long v45 = *(_OWORD *)v11;
            *(_OWORD *)unint64_t v11 = *(_OWORD *)v43;
            *(void *)(v11 + 16) = *(void *)(v43 + 16);
            *(_OWORD *)unint64_t v43 = v45;
            *(void *)(v43 + 16) = v44;
            long long v46 = *(_OWORD *)(v11 + 24);
            *(_OWORD *)(v11 + 24) = *(_OWORD *)(v43 + 24);
            *(_OWORD *)(v43 + 24) = v46;
            *(void *)&long long v45 = *(void *)(v11 + 40);
            *(void *)(v11 + 40) = *(void *)(v43 + 40);
            *(void *)(v43 + 40) = v45;
            uint64_t v47 = *(void *)(v11 + 48);
            *(void *)(v11 + 48) = *(void *)(v43 + 48);
            *(void *)(v43 + 48) = v47;
            do
            {
              int v48 = *(_DWORD *)(v11 + 96);
              int v49 = *(_DWORD *)(v11 + 100);
              v11 += 56;
              BOOL v50 = v49 < v24;
              BOOL v6 = v48 == v23;
              BOOL v51 = v48 > v23;
              if (v6) {
                BOOL v51 = v50;
              }
            }
            while (v51);
            do
            {
              int v52 = *(_DWORD *)(v43 - 16);
              int v53 = *(_DWORD *)(v43 - 12);
              v43 -= 56;
              BOOL v54 = v53 < v24;
              BOOL v6 = v52 == v23;
              BOOL v55 = v52 > v23;
              if (v6) {
                BOOL v55 = v54;
              }
            }
            while (!v55);
          }
          while (v11 < v43);
        }
        if (v11 - 56 != a1)
        {
          *(_OWORD *)a1 = *(_OWORD *)(v11 - 56);
          *(void *)(a1 + 16) = *(void *)(v11 - 40);
          *(_OWORD *)(a1 + 24) = *(_OWORD *)(v11 - 32);
          *(void *)(a1 + 40) = *(void *)(v11 - 16);
          *(void *)(a1 + 48) = *(void *)(v11 - 8);
        }
        *(_OWORD *)(v11 - 56) = v27;
        *(void *)(v11 - 40) = v28;
        *(_OWORD *)(v11 - 32) = v187;
        *(_DWORD *)(v11 - 16) = v23;
        *(_DWORD *)(v11 - 12) = v24;
        *(void *)(v11 - 8) = v29;
        if (v30 >= v35) {
          break;
        }
LABEL_45:
        sub_1DC3090E0(a1, v11 - 56, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v56 = sub_1DC30A430(a1, v11 - 56);
      if (sub_1DC30A430(v11, a2)) {
        break;
      }
      if (!v56) {
        goto LABEL_45;
      }
    }
    a2 = v11 - 56;
    if (!v56) {
      continue;
    }
    return result;
  }
}

void *sub_1DC309D28()
{
  return &unk_1F3660910;
}

uint64_t sub_1DC309D34(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"NSt3__16__bindIRKMN3mrc7DecoderEKFvRKNS2_4PassEEJNS_17reference_wrapperIKS2_EERKNS_12placeholders4__phILi1EEEEEE"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC309D70(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  long long v3 = (void *)(a1[3] + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

__n128 sub_1DC309DA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3661A70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC309DD0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F3661A70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1DC309E24()
{
}

long long *sub_1DC309E3C(long long *result, long long *a2, long long *a3)
{
  int v3 = *((_DWORD *)a2 + 10);
  int v4 = *((_DWORD *)a2 + 11);
  int v5 = *((_DWORD *)result + 10);
  BOOL v6 = v3 == v5;
  BOOL v7 = v3 > v5;
  if (v6) {
    BOOL v7 = v4 < *((_DWORD *)result + 11);
  }
  int v8 = *((_DWORD *)a3 + 10);
  BOOL v9 = *((_DWORD *)a3 + 11) < v4;
  BOOL v6 = v8 == v3;
  BOOL v10 = v8 > v3;
  if (v6) {
    BOOL v10 = v9;
  }
  if (v7)
  {
    uint64_t v11 = *((void *)result + 2);
    long long v12 = *result;
    unint64_t v13 = (long long *)((char *)result + 24);
    if (v10)
    {
      unint64_t v14 = (uint64_t *)(result + 3);
      *__n128 result = *a3;
      *((void *)result + 2) = *((void *)a3 + 2);
      *a3 = v12;
      *((void *)a3 + 2) = v11;
      long long v15 = *v13;
      long long *v13 = *(long long *)((char *)a3 + 24);
      *(long long *)((char *)a3 + 24) = v15;
      uint64_t v16 = *((void *)result + 5);
      *((void *)result + 5) = *((void *)a3 + 5);
LABEL_17:
      *((void *)a3 + 5) = v16;
      long long v21 = (uint64_t *)(a3 + 3);
      goto LABEL_18;
    }
    *__n128 result = *a2;
    *((void *)result + 2) = *((void *)a2 + 2);
    *a2 = v12;
    *((void *)a2 + 2) = v11;
    long long v27 = *v13;
    long long *v13 = *(long long *)((char *)a2 + 24);
    *(long long *)((char *)a2 + 24) = v27;
    uint64_t v28 = *((void *)result + 5);
    *((void *)result + 5) = *((void *)a2 + 5);
    *((void *)a2 + 5) = v28;
    unint64_t v14 = (uint64_t *)(a2 + 3);
    uint64_t v29 = *((void *)result + 6);
    *((void *)result + 6) = *((void *)a2 + 6);
    *((void *)a2 + 6) = v29;
    LODWORD(v29) = *((_DWORD *)a3 + 10);
    BOOL v30 = (int)v29 > (int)v28;
    if (v29 == v28) {
      BOOL v30 = *((_DWORD *)a3 + 11) < *((_DWORD *)a2 + 11);
    }
    if (v30)
    {
      uint64_t v31 = *((void *)a2 + 2);
      long long v32 = *a2;
      *a2 = *a3;
      *((void *)a2 + 2) = *((void *)a3 + 2);
      *a3 = v32;
      *((void *)a3 + 2) = v31;
      long long v33 = *(long long *)((char *)a2 + 24);
      *(long long *)((char *)a2 + 24) = *(long long *)((char *)a3 + 24);
      *(long long *)((char *)a3 + 24) = v33;
      uint64_t v16 = *((void *)a2 + 5);
      *((void *)a2 + 5) = *((void *)a3 + 5);
      goto LABEL_17;
    }
  }
  else if (v10)
  {
    uint64_t v17 = *((void *)a2 + 2);
    long long v18 = *a2;
    *a2 = *a3;
    *((void *)a2 + 2) = *((void *)a3 + 2);
    *a3 = v18;
    *((void *)a3 + 2) = v17;
    long long v19 = *(long long *)((char *)a2 + 24);
    *(long long *)((char *)a2 + 24) = *(long long *)((char *)a3 + 24);
    *(long long *)((char *)a3 + 24) = v19;
    *(void *)&long long v18 = *((void *)a2 + 5);
    *((void *)a2 + 5) = *((void *)a3 + 5);
    *((void *)a3 + 5) = v18;
    long long v21 = (uint64_t *)(a2 + 3);
    uint64_t v20 = *((void *)a2 + 6);
    *((void *)a2 + 6) = *((void *)a3 + 6);
    *((void *)a3 + 6) = v20;
    LODWORD(v20) = *((_DWORD *)a2 + 10);
    int v22 = *((_DWORD *)result + 10);
    BOOL v6 = v20 == v22;
    BOOL v23 = (int)v20 > v22;
    if (v6) {
      BOOL v23 = *((_DWORD *)a2 + 11) < *((_DWORD *)result + 11);
    }
    if (v23)
    {
      uint64_t v24 = *((void *)result + 2);
      long long v25 = *result;
      *__n128 result = *a2;
      *((void *)result + 2) = *((void *)a2 + 2);
      *a2 = v25;
      *((void *)a2 + 2) = v24;
      long long v26 = *(long long *)((char *)result + 24);
      *(long long *)((char *)result + 24) = *(long long *)((char *)a2 + 24);
      *(long long *)((char *)a2 + 24) = v26;
      *(void *)&long long v25 = *((void *)result + 5);
      *((void *)result + 5) = *((void *)a2 + 5);
      *((void *)a2 + 5) = v25;
      unint64_t v14 = (uint64_t *)(result + 3);
LABEL_18:
      uint64_t v34 = *v14;
      uint64_t *v14 = *v21;
      *long long v21 = v34;
    }
  }
  return result;
}

double sub_1DC30A064(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1DC309E3C((long long *)a1, (long long *)a2, (long long *)a3);
  int v9 = *(_DWORD *)(a4 + 40);
  int v10 = *(_DWORD *)(a3 + 40);
  BOOL v11 = v9 == v10;
  BOOL v12 = v9 > v10;
  if (v11) {
    BOOL v12 = *(_DWORD *)(a4 + 44) < *(_DWORD *)(a3 + 44);
  }
  if (v12)
  {
    uint64_t v13 = *(void *)(a3 + 16);
    long long v14 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(void *)(a3 + 16) = *(void *)(a4 + 16);
    *(_OWORD *)a4 = v14;
    *(void *)(a4 + 16) = v13;
    long long v15 = *(_OWORD *)(a3 + 24);
    *(_OWORD *)(a3 + 24) = *(_OWORD *)(a4 + 24);
    *(_OWORD *)(a4 + 24) = v15;
    double result = *(double *)(a4 + 40);
    *(void *)&long long v14 = *(void *)(a3 + 40);
    *(double *)(a3 + 40) = result;
    *(void *)(a4 + 40) = v14;
    uint64_t v16 = *(void *)(a3 + 48);
    *(void *)(a3 + 48) = *(void *)(a4 + 48);
    *(void *)(a4 + 48) = v16;
    LODWORD(v16) = *(_DWORD *)(a3 + 40);
    int v17 = *(_DWORD *)(a2 + 40);
    BOOL v11 = v16 == v17;
    BOOL v18 = (int)v16 > v17;
    if (v11) {
      BOOL v18 = *(_DWORD *)(a3 + 44) < *(_DWORD *)(a2 + 44);
    }
    if (v18)
    {
      uint64_t v19 = *(void *)(a2 + 16);
      long long v20 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(void *)(a2 + 16) = *(void *)(a3 + 16);
      *(_OWORD *)a3 = v20;
      *(void *)(a3 + 16) = v19;
      long long v21 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
      *(_OWORD *)(a3 + 24) = v21;
      double result = *(double *)(a3 + 40);
      *(void *)&long long v20 = *(void *)(a2 + 40);
      *(double *)(a2 + 40) = result;
      *(void *)(a3 + 40) = v20;
      uint64_t v22 = *(void *)(a2 + 48);
      *(void *)(a2 + 48) = *(void *)(a3 + 48);
      *(void *)(a3 + 48) = v22;
      LODWORD(v22) = *(_DWORD *)(a2 + 40);
      int v23 = *(_DWORD *)(a1 + 40);
      BOOL v11 = v22 == v23;
      BOOL v24 = (int)v22 > v23;
      if (v11) {
        BOOL v24 = *(_DWORD *)(a2 + 44) < *(_DWORD *)(a1 + 44);
      }
      if (v24)
      {
        uint64_t v25 = *(void *)(a1 + 16);
        long long v26 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = *(void *)(a2 + 16);
        *(_OWORD *)a2 = v26;
        *(void *)(a2 + 16) = v25;
        long long v27 = *(_OWORD *)(a1 + 24);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a2 + 24) = v27;
        double result = *(double *)(a2 + 40);
        *(void *)&long long v26 = *(void *)(a1 + 40);
        *(double *)(a1 + 40) = result;
        *(void *)(a2 + 40) = v26;
        uint64_t v28 = *(void *)(a1 + 48);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(void *)(a2 + 48) = v28;
      }
    }
  }
  return result;
}

double sub_1DC30A208(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result = sub_1DC30A064(a1, a2, a3, a4);
  int v11 = *(_DWORD *)(a5 + 40);
  int v12 = *(_DWORD *)(a4 + 40);
  BOOL v13 = v11 == v12;
  BOOL v14 = v11 > v12;
  if (v13) {
    BOOL v14 = *(_DWORD *)(a5 + 44) < *(_DWORD *)(a4 + 44);
  }
  if (v14)
  {
    uint64_t v15 = *(void *)(a4 + 16);
    long long v16 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(void *)(a4 + 16) = *(void *)(a5 + 16);
    *(_OWORD *)a5 = v16;
    *(void *)(a5 + 16) = v15;
    long long v17 = *(_OWORD *)(a4 + 24);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a5 + 24);
    *(_OWORD *)(a5 + 24) = v17;
    double result = *(double *)(a5 + 40);
    *(void *)&long long v16 = *(void *)(a4 + 40);
    *(double *)(a4 + 40) = result;
    *(void *)(a5 + 40) = v16;
    uint64_t v18 = *(void *)(a4 + 48);
    *(void *)(a4 + 48) = *(void *)(a5 + 48);
    *(void *)(a5 + 48) = v18;
    LODWORD(v18) = *(_DWORD *)(a4 + 40);
    int v19 = *(_DWORD *)(a3 + 40);
    BOOL v13 = v18 == v19;
    BOOL v20 = (int)v18 > v19;
    if (v13) {
      BOOL v20 = *(_DWORD *)(a4 + 44) < *(_DWORD *)(a3 + 44);
    }
    if (v20)
    {
      uint64_t v21 = *(void *)(a3 + 16);
      long long v22 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(void *)(a3 + 16) = *(void *)(a4 + 16);
      *(_OWORD *)a4 = v22;
      *(void *)(a4 + 16) = v21;
      long long v23 = *(_OWORD *)(a3 + 24);
      *(_OWORD *)(a3 + 24) = *(_OWORD *)(a4 + 24);
      *(_OWORD *)(a4 + 24) = v23;
      double result = *(double *)(a4 + 40);
      *(void *)&long long v22 = *(void *)(a3 + 40);
      *(double *)(a3 + 40) = result;
      *(void *)(a4 + 40) = v22;
      uint64_t v24 = *(void *)(a3 + 48);
      *(void *)(a3 + 48) = *(void *)(a4 + 48);
      *(void *)(a4 + 48) = v24;
      LODWORD(v24) = *(_DWORD *)(a3 + 40);
      int v25 = *(_DWORD *)(a2 + 40);
      BOOL v13 = v24 == v25;
      BOOL v26 = (int)v24 > v25;
      if (v13) {
        BOOL v26 = *(_DWORD *)(a3 + 44) < *(_DWORD *)(a2 + 44);
      }
      if (v26)
      {
        uint64_t v27 = *(void *)(a2 + 16);
        long long v28 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(void *)(a2 + 16) = *(void *)(a3 + 16);
        *(_OWORD *)a3 = v28;
        *(void *)(a3 + 16) = v27;
        long long v29 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
        *(_OWORD *)(a3 + 24) = v29;
        double result = *(double *)(a3 + 40);
        *(void *)&long long v28 = *(void *)(a2 + 40);
        *(double *)(a2 + 40) = result;
        *(void *)(a3 + 40) = v28;
        uint64_t v30 = *(void *)(a2 + 48);
        *(void *)(a2 + 48) = *(void *)(a3 + 48);
        *(void *)(a3 + 48) = v30;
        LODWORD(v30) = *(_DWORD *)(a2 + 40);
        int v31 = *(_DWORD *)(a1 + 40);
        BOOL v13 = v30 == v31;
        BOOL v32 = (int)v30 > v31;
        if (v13) {
          BOOL v32 = *(_DWORD *)(a2 + 44) < *(_DWORD *)(a1 + 44);
        }
        if (v32)
        {
          uint64_t v33 = *(void *)(a1 + 16);
          long long v34 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(void *)(a1 + 16) = *(void *)(a2 + 16);
          *(_OWORD *)a2 = v34;
          *(void *)(a2 + 16) = v33;
          long long v35 = *(_OWORD *)(a1 + 24);
          *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
          *(_OWORD *)(a2 + 24) = v35;
          double result = *(double *)(a2 + 40);
          *(void *)&long long v34 = *(void *)(a1 + 40);
          *(double *)(a1 + 40) = result;
          *(void *)(a2 + 40) = v34;
          uint64_t v36 = *(void *)(a1 + 48);
          *(void *)(a1 + 48) = *(void *)(a2 + 48);
          *(void *)(a2 + 48) = v36;
        }
      }
    }
  }
  return result;
}

BOOL sub_1DC30A430(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0x6DB6DB6DB6DB6DB7 * v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *(_DWORD *)(a2 - 16);
      int v7 = *(_DWORD *)(a1 + 40);
      BOOL v8 = v6 == v7;
      BOOL v9 = v6 > v7;
      if (v8) {
        BOOL v9 = *(_DWORD *)(a2 - 12) < *(_DWORD *)(a1 + 44);
      }
      if (v9)
      {
        uint64_t v10 = *(void *)(a1 + 16);
        long long v11 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 56);
        *(void *)(a1 + 16) = *(void *)(a2 - 40);
        *(_OWORD *)(a2 - 56) = v11;
        *(void *)(a2 - 40) = v10;
        long long v12 = *(_OWORD *)(a1 + 24);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a2 - 32) = v12;
        *(void *)&long long v11 = *(void *)(a1 + 40);
        *(void *)(a1 + 40) = *(void *)(a2 - 16);
        *(void *)(a2 - 16) = v11;
        uint64_t v13 = *(void *)(a1 + 48);
        *(void *)(a1 + 48) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v13;
      }
      return result;
    case 3:
      sub_1DC309E3C((long long *)a1, (long long *)(a1 + 56), (long long *)(a2 - 56));
      return 1;
    case 4:
      sub_1DC30A064(a1, a1 + 56, a1 + 112, a2 - 56);
      return 1;
    case 5:
      sub_1DC30A208(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56);
      return 1;
    default:
      uint64_t v14 = a1 + 112;
      sub_1DC309E3C((long long *)a1, (long long *)(a1 + 56), (long long *)(a1 + 112));
      uint64_t v15 = a1 + 168;
      if (a1 + 168 == a2) {
        return 1;
      }
      uint64_t v16 = 0;
      int v17 = 0;
      break;
  }
  while (1)
  {
    int v18 = *(_DWORD *)(v15 + 40);
    int v19 = *(_DWORD *)(v15 + 44);
    int v20 = *(_DWORD *)(v14 + 40);
    BOOL v8 = v18 == v20;
    BOOL v21 = v18 > v20;
    if (v8) {
      BOOL v21 = v19 < *(_DWORD *)(v14 + 44);
    }
    if (v21)
    {
      long long v22 = *(_OWORD *)v15;
      uint64_t v23 = *(void *)(v15 + 16);
      long long v33 = *(_OWORD *)(v15 + 24);
      uint64_t v24 = *(void *)(v15 + 48);
      uint64_t v25 = v16;
      while (1)
      {
        uint64_t v26 = v25;
        uint64_t v27 = a1 + v25;
        *(_OWORD *)(v27 + 168) = *(_OWORD *)(v27 + 112);
        *(void *)(v27 + 184) = *(void *)(v27 + 128);
        *(_OWORD *)(v27 + 192) = *(_OWORD *)(v27 + 136);
        *(void *)(v27 + 208) = *(void *)(v27 + 152);
        *(void *)(v27 + 216) = *(void *)(v27 + 160);
        if (v26 == -112) {
          break;
        }
        int v28 = *(_DWORD *)(v27 + 96);
        BOOL v29 = v19 < *(_DWORD *)(v27 + 100);
        BOOL v8 = v18 == v28;
        BOOL v30 = v18 > v28;
        if (v8) {
          BOOL v30 = v29;
        }
        uint64_t v25 = v26 - 56;
        if (!v30)
        {
          uint64_t v31 = a1 + v25 + 168;
          BOOL v32 = (_OWORD *)(a1 + v26 + 136);
          goto LABEL_18;
        }
      }
      BOOL v32 = (_OWORD *)(v27 + 136);
      uint64_t v31 = a1;
LABEL_18:
      *(_OWORD *)uint64_t v31 = v22;
      *(void *)(v31 + 16) = v23;
      *BOOL v32 = v33;
      *(_DWORD *)(v31 + 40) = v18;
      *(_DWORD *)(v31 + 44) = v19;
      *(void *)(v31 + 48) = v24;
      if (++v17 == 8) {
        return v15 + 56 == a2;
      }
    }
    uint64_t v14 = v15;
    v16 += 56;
    v15 += 56;
    if (v15 == a2) {
      return 1;
    }
  }
}

void *sub_1DC30A6AC()
{
  return &unk_1F365DAE8;
}

uint64_t sub_1DC30A6B8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *sub_1DC30A6F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  sub_1DC3075A0((uint64_t)v13, a2);
  uint64_t v8 = *a6;
  BOOL v9 = *(dispatch_group_t ***)(a1 + 16);
  sub_1DC3075A0((uint64_t)v14, (uint64_t)v13);
  uint64_t v10 = *(void *)(a1 + 8);
  *(void *)&long long v15 = v8;
  *((void *)&v15 + 1) = v10;
  int v17 = 0;
  long long v11 = (char *)operator new(0x38uLL);
  *(void *)long long v11 = &unk_1F365E6D8;
  sub_1DC3075A0((uint64_t)(v11 + 8), (uint64_t)v14);
  *(_OWORD *)(v11 + 40) = v15;
  int v17 = v11;
  sub_1DC307620(v9, (uint64_t)v16);
  sub_1DC307968(v16);
  sub_1DC3079EC(v14);
  return sub_1DC3079EC(v13);
}

void sub_1DC30A7E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_1DC307968((void *)(v2 - 72));
  sub_1DC3079EC((uint64_t *)va1);
  sub_1DC3079EC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC30A80C()
{
  return &unk_1F365DB38;
}

uint64_t sub_1DC30A818(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEENK3$_1clINS9_8functionIFvRKNS0_4PassEEEENS9_17basic_string_viewIcSB_EEiNS_9symbology12ImplCategoryEmEEDaT_RKT0_T1_T2_T3_EUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC30A854(void *a1)
{
  uint64_t v3 = a1[5];
  uint64_t v2 = (void *)a1[6];
  uint64_t v4 = (atomic_ullong *)(*v2 + (v3 << 6));
  if (!atomic_load_explicit(v4, memory_order_acquire))
  {
    v16[0] = (atomic_ullong)sub_1DC30637C();
    int v5 = (const void *)atomic_exchange(v4, atomic_exchange(v16, 0));
    if (v5) {
      CFRelease(v5);
    }
    sub_1DC307278(v16);
  }
  uint64_t v6 = v2[1];
  uint64_t v7 = v2[2];
  unint64_t explicit = atomic_load_explicit(v4, memory_order_acquire);
  uint64_t v9 = v2[3] + (v3 << 6);
  atomic_ullong v10 = *(void *)(v6 + 8);
  uint64_t v11 = *(void *)v6 + 16;
  long long v12 = *(uint64_t **)(v6 + 16);
  uint64_t v13 = **(void **)(v6 + 24);
  v16[0] = explicit + 16;
  v16[1] = v11;
  v16[2] = v10;
  char v17 = 0;
  char v18 = 0;
  uint64_t v19 = v7 + (v3 << 7);
  uint64_t v20 = *v12;
  char v21 = 1;
  uint64_t v22 = v9;
  uint64_t v23 = v13;
  uint64_t v14 = a1[4];
  if (!v14) {
    sub_1DC307C38();
  }
  return (*(uint64_t (**)(uint64_t, atomic_ullong *))(*(void *)v14 + 48))(v14, v16);
}

void sub_1DC30A940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

void sub_1DC30A954(void *a1)
{
  sub_1DC3079EC(a1 + 1);
  operator delete(a1);
}

void *sub_1DC30A990(uint64_t a1)
{
  return sub_1DC3079EC((void *)(a1 + 8));
}

__n128 sub_1DC30A998(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365E6D8;
  sub_1DC3080B4(a2 + 8, a1 + 8);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

char *sub_1DC30A9EC(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v3 = &unk_1F365E6D8;
  sub_1DC3080B4((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 40);
  return v3;
}

void sub_1DC30AA54(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DC30AA68(void *a1)
{
  *a1 = &unk_1F365E6D8;
  sub_1DC3079EC(a1 + 1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC30AACC(void *a1)
{
  *a1 = &unk_1F365E6D8;
  sub_1DC3079EC(a1 + 1);
  return a1;
}

__n128 sub_1DC30AB18(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365E520;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC30AB40(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F365E520;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC30AB8C()
{
}

atomic_ullong *sub_1DC30ABA4(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *sub_1DC30ABD8()
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFB4F8) {
    _os_assumes_log();
  }
  if (qword_1EBFFB6F0) {
    _os_assumes_log();
  }
  qword_1EBFFB4F8 = (uint64_t)"MRCRegion";
  qword_1EBFFB6F0 = _CFRuntimeRegisterClass();
  v1[3] = 0;
  sub_1DC348EB8(qword_1EBFFB6F0, v1);
  return sub_1DC30AC9C(v1);
}

void sub_1DC30AC80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC30AC9C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC30AC9C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

CFStringRef sub_1DC30AD20(char *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v2 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"<%s %p> {\n", "MRCRegion", cf);
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    cornerPoints {\n");
    for (uint64_t i = 0; i != 64; i += 16)
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"        ");
      sub_1DC3CBEE8((atomic_ullong *)&Mutable, (double *)&cf[i + 16]);
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"\n");
    }
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    transform ");
    if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
    {
      long long v5 = *((_OWORD *)cf + 6);
      *(_OWORD *)&t1.a = *((_OWORD *)cf + 5);
      *(_OWORD *)&t1.c = v5;
      *(_OWORD *)&t1.tx = *((_OWORD *)cf + 7);
      long long v6 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      *(_OWORD *)&t2.a = *MEMORY[0x1E4F1DAB8];
      *(_OWORD *)&t2.c = v6;
      *(_OWORD *)&t2.tx = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      BOOL v7 = CGAffineTransformEqualToTransform(&t1, &t2);
      unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      if (v7)
      {
        CFStringRef v9 = @"<identity>";
      }
      else
      {
        CFStringAppend(explicit, @"{a=");
        sub_1DC3CBE3C((atomic_ullong *)&Mutable, *((double *)cf + 10));
        CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @", b=");
        sub_1DC3CBE3C((atomic_ullong *)&Mutable, *((double *)cf + 11));
        CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @", c=");
        sub_1DC3CBE3C((atomic_ullong *)&Mutable, *((double *)cf + 12));
        CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @", d=");
        sub_1DC3CBE3C((atomic_ullong *)&Mutable, *((double *)cf + 13));
        CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @", tx=");
        sub_1DC3CBE3C((atomic_ullong *)&Mutable, *((double *)cf + 14));
        CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @", ty=");
        sub_1DC3CBE3C((atomic_ullong *)&Mutable, *((double *)cf + 15));
        unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        CFStringRef v9 = @"}";
      }
      CFStringAppend(explicit, v9);
    }
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"\n");
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    orientation ");
    sub_1DC3CBE3C((atomic_ullong *)&Mutable, *((double *)cf + 16));
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"\n");
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    symbology %@\n", atomic_load_explicit((atomic_ullong *volatile)cf + 17, memory_order_acquire));
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    confidence %f\n", *((float *)cf + 36));
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"}");
    CFStringRef Copy = CFStringCreateCopy(v3, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    sub_1DC326F90((atomic_ullong *)&Mutable);
    if (Copy) {
      return Copy;
    }
  }
  else
  {
    sub_1DC326F90((atomic_ullong *)&Mutable);
  }
  return CFStringCreateWithFormat(v3, 0, @"<%s %p>", "MRCRegion", cf);
}

void sub_1DC30B098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1DC326F90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

unint64_t sub_1DC30B0B0(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v2 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
  }
  double v3 = *((double *)cf + 2);
  double v4 = *((double *)cf + 3);
  double v5 = *((double *)cf + 4);
  double v6 = *((double *)cf + 5);
  double v7 = *((double *)cf + 6);
  double v8 = *((double *)cf + 7);
  double v10 = *((double *)cf + 8);
  double v9 = *((double *)cf + 9);
  double v12 = *((double *)cf + 10);
  double v11 = *((double *)cf + 11);
  double v14 = *((double *)cf + 12);
  double v13 = *((double *)cf + 13);
  double v16 = *((double *)cf + 14);
  double v15 = *((double *)cf + 15);
  double v17 = *((double *)cf + 16);
  unint64_t explicit = (const void *)atomic_load_explicit(cf + 17, memory_order_acquire);
  if (explicit)
  {
    double v58 = v5;
    double v59 = v10;
    double v56 = v3;
    double v57 = v16;
    double v54 = v7;
    double v55 = v14;
    double v53 = v12;
    CFHashCode v19 = CFHash(explicit);
    double v12 = v53;
    double v7 = v54;
    double v14 = v55;
    double v3 = v56;
    double v16 = v57;
    double v5 = v58;
    double v10 = v59;
    uint64_t v20 = v19 + 2654435769u;
  }
  else
  {
    uint64_t v20 = 3317042773;
  }
  unint64_t v21 = *(void *)&v12 + 2654435769;
  if (v12 == 0.0) {
    unint64_t v21 = 2654435769;
  }
  uint64_t v22 = *(void *)&v11 + 2654435769;
  if (v11 == 0.0) {
    uint64_t v22 = 2654435769;
  }
  unint64_t v23 = ((v21 >> 2) + (v21 << 6) + v22) ^ v21;
  uint64_t v24 = *(void *)&v14 + 2654435769;
  if (v14 == 0.0) {
    uint64_t v24 = 2654435769;
  }
  unint64_t v25 = (v24 + (v23 << 6) + (v23 >> 2)) ^ v23;
  uint64_t v26 = *(void *)&v13 + 2654435769;
  if (v13 == 0.0) {
    uint64_t v26 = 2654435769;
  }
  unint64_t v27 = (v26 + (v25 << 6) + (v25 >> 2)) ^ v25;
  uint64_t v28 = *(void *)&v16 + 2654435769;
  if (v16 == 0.0) {
    uint64_t v28 = 2654435769;
  }
  unint64_t v29 = (v28 + (v27 << 6) + (v27 >> 2)) ^ v27;
  uint64_t v30 = *(void *)&v15 + 2654435769;
  if (v15 == 0.0) {
    uint64_t v30 = 2654435769;
  }
  uint64_t v31 = (v30 + (v29 << 6) + (v29 >> 2)) ^ v29;
  unint64_t v32 = *(void *)&v10 + 2654435769;
  if (v10 == 0.0) {
    unint64_t v32 = 2654435769;
  }
  uint64_t v33 = *(void *)&v9 + 2654435769;
  if (v9 == 0.0) {
    uint64_t v33 = 2654435769;
  }
  uint64_t v34 = (((v32 >> 2) + (v32 << 6) + v33) ^ v32) + 2654435769u;
  unint64_t v35 = *(void *)&v7 + 2654435769;
  if (v7 == 0.0) {
    unint64_t v35 = 2654435769;
  }
  uint64_t v36 = *(void *)&v8 + 2654435769;
  if (v8 == 0.0) {
    uint64_t v36 = 2654435769;
  }
  uint64_t v37 = (((v35 >> 2) + (v35 << 6) + v36) ^ v35) + 2654435769u;
  unint64_t v38 = *(void *)&v3 + 2654435769;
  if (v3 == 0.0) {
    unint64_t v38 = 2654435769;
  }
  uint64_t v39 = *(void *)&v4 + 2654435769;
  if (v4 == 0.0) {
    uint64_t v39 = 2654435769;
  }
  unint64_t v40 = (((v38 >> 2) + (v38 << 6) + v39) ^ v38) + 2654435769u;
  unint64_t v41 = *(void *)&v5 + 2654435769;
  if (v5 == 0.0) {
    unint64_t v41 = 2654435769;
  }
  uint64_t v42 = *(void *)&v6 + 2654435769;
  if (v6 == 0.0) {
    uint64_t v42 = 2654435769;
  }
  unint64_t v43 = ((v40 << 6) + 2654435769u + (v40 >> 2) + (((v41 >> 2) + (v41 << 6) + v42) ^ v41)) ^ v40;
  unint64_t v44 = (v37 + (v43 << 6) + (v43 >> 2)) ^ v43;
  unint64_t v45 = ((v34 + (v44 << 6) + (v44 >> 2)) ^ v44) + 2654435769u;
  unint64_t v46 = (v31 + 2654435769 + (v45 << 6) + (v45 >> 2)) ^ v45;
  uint64_t v47 = *(void *)&v17 + 2654435769;
  if (v17 == 0.0) {
    uint64_t v47 = 2654435769;
  }
  unint64_t v48 = (v47 + (v46 << 6) + (v46 >> 2)) ^ v46;
  unint64_t v49 = ((v48 >> 2) + (v48 << 6) + v20) ^ v48;
  float v50 = *((float *)cf + 36);
  uint64_t v51 = LODWORD(v50) + 2654435769;
  if (v50 == 0.0) {
    uint64_t v51 = 2654435769;
  }
  return ((v49 >> 2) + (v49 << 6) + v51) ^ v49;
}

uint64_t sub_1DC30B3B8(atomic_ullong *cf, atomic_ullong *a2)
{
  if (!cf) {
    goto LABEL_5;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (qword_1EBFFB6F8[0] != -1) {
    dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
  }
  if (v4 != qword_1EBFFB6F0)
  {
    _os_assumes_log();
    if (a2) {
      goto LABEL_6;
    }
  }
  else
  {
LABEL_5:
    if (a2)
    {
LABEL_6:
      CFTypeID v5 = CFGetTypeID(a2);
      if (qword_1EBFFB6F8[0] != -1) {
        dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
      }
      if (v5 != qword_1EBFFB6F0) {
        _os_assumes_log();
      }
    }
  }
  for (uint64_t i = 0; i != 8; i += 2)
  {
    int32x2_t v7 = vmovn_s64(vceqq_f64(*(float64x2_t *)&cf[i + 2], *(float64x2_t *)&a2[i + 2]));
    if ((v7.i32[0] & v7.i32[1] & 1) == 0) {
      return 0;
    }
  }
  long long v8 = *((_OWORD *)cf + 6);
  *(_OWORD *)&t1.a = *((_OWORD *)cf + 5);
  *(_OWORD *)&t1.c = v8;
  *(_OWORD *)&t1.tx = *((_OWORD *)cf + 7);
  long long v9 = *((_OWORD *)a2 + 6);
  *(_OWORD *)&v13.a = *((_OWORD *)a2 + 5);
  *(_OWORD *)&v13.c = v9;
  *(_OWORD *)&v13.tx = *((_OWORD *)a2 + 7);
  uint64_t result = CGAffineTransformEqualToTransform(&t1, &v13);
  if (!result) {
    return result;
  }
  if (*((double *)cf + 16) != *((double *)a2 + 16)) {
    return 0;
  }
  unint64_t explicit = (const void *)atomic_load_explicit(a2 + 17, memory_order_acquire);
  double v12 = (const void *)atomic_load_explicit(cf + 17, memory_order_acquire);
  if (v12 == explicit) {
    return *((float *)cf + 36) == *((float *)a2 + 36);
  }
  uint64_t result = 0;
  if (explicit)
  {
    if (v12)
    {
      uint64_t result = CFEqual(v12, explicit);
      if (result) {
        return *((float *)cf + 36) == *((float *)a2 + 36);
      }
    }
  }
  return result;
}

atomic_ullong *sub_1DC30B574(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v2 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
    CFTypeID v3 = CFGetTypeID(cf);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v3 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
  }
  return sub_1DC31FA90(cf + 17);
}

void *sub_1DC30B664()
{
  return &unk_1F365DAD8;
}

uint64_t sub_1DC30B670(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder6decodeERKNS_2CFINS_6SampleENS_2cf6TraitsIS2_NS3_13PersonalitiesIS2_XtlNS_12fixed_stringILm9EEEtlNS_18basic_fixed_stringIcLm9ENSt3__111char_traitsIcEEEEtlA10_cLc77ELc82ELc67ELc83ELc97ELc109ELc112ELc108ELc101EEEEEJEEEEEEERKNS9_8optionalINS9_4spanIKNS_5CFRefIPKNS1_INS_6RegionENS4_ISM_NS5_ISM_XtlS7_tlSC_tlSD_Lc77ELc82ELc67ELc82ELc101ELc103ELc105ELc111ELc110EEEEEJEEEEEEEEELm18446744073709551615EEEEERNSJ_INS_5ErrorEEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC30B6AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v270 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 8)) {
    _ZF = *(unsigned char *)(a3 + 96) == 0;
  }
  else {
    _ZF = 0;
  }
  if (!_ZF)
  {
    sub_1DC3070F0(*(atomic_ullong **)(a1 + 8), a3);
    if (qword_1EBFFC3E0 != -1) {
      dispatch_once(&qword_1EBFFC3E0, &unk_1F3662428);
    }
    CFTypeID v5 = qword_1EBFFC3E8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3E8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (*(unsigned char *)(v6 + 96))
      {
        sub_1DC390B4C((uint64_t)&buf, v6);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        memset(v252, 0, sizeof(v252));
        long long v253 = 0u;
      }
      sub_1DC390F7C((CFErrorRef *)&t2, (uint64_t)&buf);
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&t2, memory_order_acquire);
      LODWORD(v260.a) = 138543362;
      *(void *)((char *)&v260.a + 4) = explicit;
      unint64_t v61 = "Cannot retrieve or instantiate ANMD model: %{public}@";
LABEL_125:
      _os_log_error_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_ERROR, v61, (uint8_t *)&v260, 0xCu);
      sub_1DC306854((atomic_ullong *)&t2);
      sub_1DC390B00((atomic_ullong *)&buf);
      return;
    }
    return;
  }
  uint64_t v7 = *(void *)a2;
  CGFloat v8 = *(double *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v235 = **(void **)(a1 + 32);
  char v236 = 1;
  if (*(unsigned char *)(v7 + 200))
  {
    uint64_t v10 = *(void *)(v7 + 264);
    if (v10)
    {
      if ((*(uint64_t (**)(uint64_t))(*(void *)v10 + 24))(v10))
      {
        v255[0] = &unk_1F3664660;
        uint64_t v256 = v255;
        v254[0] = &unk_1F36646E0;
        v254[3] = v254;
        v257 = &v235;
        sub_1DC31AD78((uint64_t)v258, (uint64_t)v254);
        if (*((unsigned char *)v257 + 8) && v256) {
          sub_1DC31AE10((uint64_t)v256, *v257);
        }
        double v11 = (uint64_t *)(v9 + 16);
        sub_1DC31AE60(v254);
        sub_1DC31AE60(v255);
        long long v12 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
        *(_OWORD *)&v241.a = *MEMORY[0x1E4F1DAB8];
        *(_OWORD *)&v241.CGFloat c = v12;
        *(_OWORD *)&v241.tx = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
        CGAffineTransform v13 = *(void **)(v9 + 72);
        if (v13 && (uint64_t v14 = *(void *)(*(void *)(v9 + 72) + 8) - *v13) != 0)
        {
          uint64_t v15 = v14 / 216;
          uint64_t v16 = v15 - 1;
          uint64_t v17 = 216 * v15 - 208;
          while (1)
          {
            uint64_t v18 = **(void **)(v9 + 72);
            uint64_t v19 = v18 + v17;
            if (sub_1DC346120(v7)) {
              break;
            }
            --v16;
            v17 -= 216;
            if (v16 == -1) {
              goto LABEL_21;
            }
          }
          int v20 = 0;
          uint64_t v36 = v18 + 216 * v16;
          long long v37 = *(_OWORD *)(v36 + 184);
          *(_OWORD *)&v241.a = *(_OWORD *)(v36 + 168);
          *(_OWORD *)&v241.CGFloat c = v37;
          *(_OWORD *)&v241.tx = *(_OWORD *)(v36 + 200);
        }
        else
        {
LABEL_21:
          if (!sub_1DC346120(v7))
          {
            LOBYTE(v19) = 0;
            unint64_t v33 = 0;
            int v20 = 1;
            goto LABEL_64;
          }
          int v20 = 0;
          long long v21 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
          *(_OWORD *)&v241.a = *MEMORY[0x1E4F1DAB8];
          *(_OWORD *)&v241.CGFloat c = v21;
          *(_OWORD *)&v241.tx = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
          uint64_t v19 = *v11;
        }
        unint64_t v33 = v19 & 0xFFFFFFFFFFFFFF00;
LABEL_64:
        if (qword_1EBFFC360 != -1) {
          dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
        }
        unint64_t v38 = qword_1EBFFC3B8;
        if (v20)
        {
          if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf.a) = 138543362;
            *(void *)((char *)&buf.a + 4) = v11 - 2;
            _os_log_error_impl(&dword_1DC2FE000, v38, OS_LOG_TYPE_ERROR, "Unable to find any supported pixel buffer from MRCSample: %{public}@", (uint8_t *)&buf, 0xCu);
          }
          buf.a = NAN;
          *(void *)&v260.a = @"Unable to find any supported pixel buffer from MRCSample.";
          sub_1DC306334(*(atomic_ullong **)&v8, (uint64_t *)&buf, (CFTypeRef *)&v260);
LABEL_70:
          int d_low = 0;
          LOBYTE(buf.a) = 0;
          LOBYTE(buf.d) = 0;
          goto LABEL_135;
        }
        unint64_t v39 = v33 | v19;
        if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v64 = atomic_load_explicit((atomic_ullong *volatile)v39, memory_order_acquire);
          LODWORD(buf.a) = 138543362;
          *(void *)((char *)&buf.a + 4) = v64;
          _os_log_debug_impl(&dword_1DC2FE000, v38, OS_LOG_TYPE_DEBUG, "Found best pixel buffer: %{public}@", (uint8_t *)&buf, 0xCu);
        }
        if (((*(uint64_t (**)(void, unint64_t, CGFloat, uint64_t *))(**(void **)(v7 + 264) + 40))(*(void *)(v7 + 264), v33 | v19, COERCE_CGFLOAT(*(void *)&v8), &v235) & 1) == 0)
        {
          if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
          {
            LOWORD(buf.a) = 0;
            _os_log_impl(&dword_1DC2FE000, v38, OS_LOG_TYPE_INFO, "Failed to run image preprocessor.", (uint8_t *)&buf, 2u);
          }
          goto LABEL_70;
        }
        (*(void (**)(atomic_ullong *__return_ptr))(**(void **)(v7 + 264) + 48))(&v240);
        if (atomic_load_explicit(&v240, memory_order_acquire))
        {
          uint64_t v40 = *(void *)(v7 + 208);
          IOSurface = CVPixelBufferGetIOSurface((CVPixelBufferRef)atomic_load_explicit(&v240, memory_order_acquire));
          if (IOSurface) {
            IOSurface = CFRetain(IOSurface);
          }
          *(void *)&buf.a = IOSurface;
          char v42 = sub_1DC3166FC(v40, (atomic_ullong *)&buf, *(uint64_t *)&v8);
          sub_1DC315BA8((atomic_ullong *)&buf);
          if (v42)
          {
            if (sub_1DC31A58C(v7 + 72, (qos_class_t *)(v7 + 24), *(uint64_t *)&v8, (uint64_t)&v235))
            {
              uint64_t v228 = *(void *)(v7 + 232);
              *(_OWORD *)oslog = *(_OWORD *)(v7 + 216);
              uint64_t v43 = *(void *)(v7 + 264);
              v264[0] = &unk_1F365F8C0;
              uint64_t v265 = v264;
              v263[0] = &unk_1F365F918;
              v263[3] = v263;
              uint64_t v266 = &v235;
              sub_1DC31AD78((uint64_t)v267, (uint64_t)v263);
              if (*((unsigned char *)v266 + 8) && v265) {
                sub_1DC31AE10((uint64_t)v265, *v266);
              }
              sub_1DC31AE60(v263);
              sub_1DC31AE60(v264);
              Class isa = oslog[0][1].isa;
              if (*((void *)isa + 6) == 4 && *((void *)isa + 7) == 1 && *((void *)isa + 8) == 4)
              {
                Class v45 = oslog[1][1].isa;
                if (*((void *)v45 + 6) == 4 && *((void *)v45 + 7) == 1 && *((void *)v45 + 8) == 4)
                {
                  uint64_t v46 = *((void *)v45 + 9);
                  if (v46 == *((void *)isa + 9))
                  {
                    uint64_t v47 = *((void *)v45 + 10);
                    if (v47 == *((void *)isa + 10))
                    {
                      int v48 = *((_DWORD *)v45 + 4);
                      if (v48 == *((_DWORD *)isa + 4))
                      {
                        int v49 = *((_DWORD *)v45 + 5);
                        if (v49 == *((_DWORD *)isa + 5))
                        {
                          v223 = oslog[1][1].isa;
                          uint64_t v200 = v43;
                          uint64_t v50 = *(void *)(v228 + 8);
                          if (*(void *)(v50 + 48) != 4
                            || *(void *)(v50 + 56) != 1
                            || *(void *)(v50 + 64) != 1
                            || *(void *)(v50 + 72) != v46
                            || *(void *)(v50 + 80) != v47
                            || *(_DWORD *)(v50 + 16) != v48
                            || *(_DWORD *)(v50 + 20) != v49)
                          {
                            if (qword_1EBFFC360 != -1) {
                              dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                            }
                            BOOL v68 = qword_1EBFFC3B8;
                            if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                            {
                              LOWORD(buf.a) = 0;
                              _os_log_error_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_ERROR, "Unexpected output angles.", (uint8_t *)&buf, 2u);
                            }
                            buf.a = NAN;
                            *(void *)&v260.a = @"Unexpected output angles.";
                            sub_1DC306334(*(atomic_ullong **)&v8, (uint64_t *)&buf, (CFTypeRef *)&v260);
                            LOBYTE(v237) = 0;
                            char v239 = 0;
LABEL_150:
                            if (*((unsigned char *)v266 + 8) && v268) {
                              sub_1DC31AE10(v268, *v266);
                            }
                            sub_1DC31AE60(v267);
                            if (v239)
                            {
                              if (sub_1DC31B2C0(*(void *)(v7 + 104), *(uint64_t *)&v8))
                              {
                                if (sub_1DC316B30(*(void *)(v7 + 208), *(uint64_t *)&v8))
                                {
                                  LOBYTE(buf.a) = 0;
                                  LOBYTE(buf.d) = 0;
                                  if (v239)
                                  {
                                    *(_OWORD *)&buf.a = v237;
                                    buf.CGFloat c = v238;
                                    CGFloat v238 = 0.0;
                                    long long v237 = 0uLL;
                                    int d_low = 1;
                                    LOBYTE(buf.d) = 1;
                                    goto LABEL_166;
                                  }
                                  int d_low = 0;
LABEL_134:
                                  sub_1DC307370(&v240);
LABEL_135:
                                  if (*((unsigned char *)v257 + 8) && v259) {
                                    sub_1DC31AE10(v259, *v257);
                                  }
                                  sub_1DC31AE60(v258);
                                  goto LABEL_28;
                                }
                                if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
                                {
                                  LOWORD(buf.a) = 0;
                                  BOOL v67 = "Failed to unbind input surface.";
                                  goto LABEL_164;
                                }
LABEL_165:
                                int d_low = 0;
                                LOBYTE(buf.a) = 0;
                                LOBYTE(buf.d) = 0;
LABEL_166:
                                if (v239)
                                {
                                  *(void *)&v260.a = &v237;
                                  sub_1DC306620((void ***)&v260);
                                }
                                goto LABEL_134;
                              }
                              if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
                                goto LABEL_165;
                              }
                              LOWORD(buf.a) = 0;
                              BOOL v67 = "Failed to reset network.";
                            }
                            else
                            {
                              if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
                                goto LABEL_165;
                              }
                              LOWORD(buf.a) = 0;
                              BOOL v67 = "Failed to run postprocessor.";
                            }
LABEL_164:
                            _os_log_impl(&dword_1DC2FE000, v38, OS_LOG_TYPE_INFO, v67, (uint8_t *)&buf, 2u);
                            goto LABEL_165;
                          }
                          v244 = 0;
                          CGFloat d = 0.0;
                          __p = 0;
                          if (*((_DWORD *)isa + 4) == 4)
                          {
                            int v51 = *((_DWORD *)isa + 5);
                            if (v51 == 6)
                            {
                              CFTypeRef v70 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&oslog[0][3], memory_order_acquire);
                              if (v70) {
                                CFTypeRef v70 = CFRetain(v70);
                              }
                              *(void *)&buf.a = v70;
                              LOBYTE(buf.b) = 0;
                              *(_DWORD *)((char *)&buf.b + 1) = LODWORD(v260.a);
                              HIDWORD(buf.b) = *(_DWORD *)((char *)&v260.a + 3);
                              LOBYTE(buf.c) = 0;
                              *(_DWORD *)((char *)&buf.c + 1) = LODWORD(t2.a);
                              HIDWORD(buf.c) = *(_DWORD *)((char *)&t2.a + 3);
                              buf.CGFloat d = v8;
                              LOBYTE(buf.tx) = sub_1DC36FEF8((atomic_ullong *)&buf, (uint64_t)&buf.b, 1, *(uint64_t *)&v8);
                              CFTypeRef v71 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&oslog[1][3], memory_order_acquire);
                              if (v71) {
                                CFTypeRef v71 = CFRetain(v71);
                              }
                              *(void *)&v260.a = v71;
                              LOBYTE(v260.b) = 0;
                              *(_DWORD *)((char *)&v260.b + 1) = LODWORD(t2.a);
                              HIDWORD(v260.b) = *(_DWORD *)((char *)&t2.a + 3);
                              LOBYTE(v260.c) = 0;
                              *(_DWORD *)((char *)&v260.c + 1) = LODWORD(v262.a);
                              HIDWORD(v260.c) = *(_DWORD *)((char *)&v262.a + 3);
                              v260.CGFloat d = v8;
                              LOBYTE(v260.tx) = sub_1DC36FEF8((atomic_ullong *)&v260, (uint64_t)&v260.b, 1, *(uint64_t *)&v8);
                              CFTypeRef v72 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(v228 + 24), memory_order_acquire);
                              if (v72) {
                                CFTypeRef v72 = CFRetain(v72);
                              }
                              *(void *)&t2.a = v72;
                              LOBYTE(t2.b) = 0;
                              *(_DWORD *)((char *)&t2.b + 1) = LODWORD(v262.a);
                              HIDWORD(t2.b) = *(_DWORD *)((char *)&v262.a + 3);
                              LOBYTE(t2.c) = 0;
                              *(_DWORD *)((char *)&t2.c + 1) = LODWORD(v242.a);
                              HIDWORD(t2.c) = *(_DWORD *)((char *)&v242.a + 3);
                              t2.CGFloat d = v8;
                              int v73 = sub_1DC36FEF8((atomic_ullong *)&t2, (uint64_t)&t2.b, 1, *(uint64_t *)&v8);
                              LOBYTE(t2.tx) = v73;
                              if (LOBYTE(buf.tx)) {
                                BOOL v74 = LOBYTE(v260.tx) == 0;
                              }
                              else {
                                BOOL v74 = 1;
                              }
                              int v75 = v73 ^ 1;
                              if (v74) {
                                int v75 = 1;
                              }
                              int v189 = v75;
                              if (v75 == 1)
                              {
                                if (qword_1EBFFC360 != -1) {
                                  dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                                }
                                long long v76 = qword_1EBFFC3B8;
                                if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                                {
                                  int v77 = *(_DWORD *)(*(void *)&v8 + 56);
                                  LODWORD(v262.a) = 67240192;
                                  HIDWORD(v262.a) = v77;
                                  _os_log_error_impl(&dword_1DC2FE000, v76, OS_LOG_TYPE_ERROR, "IOSurfaceLock failed: %{public}d", (uint8_t *)&v262, 8u);
                                }
                              }
                              else
                              {
                                BaseAddress = IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)&oslog[0][3], memory_order_acquire));
                                CGFloat v227 = (float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)&oslog[1][3], memory_order_acquire));
                                BOOL v220 = (float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)(v228 + 24), memory_order_acquire));
                                uint64_t v197 = v223[9];
                                if (v197)
                                {
                                  uint64_t v199 = 0;
                                  unint64_t v103 = *((void *)isa + 4);
                                  unint64_t v212 = *((void *)isa + 15) / v103;
                                  unint64_t v195 = *((void *)isa + 14) / v103;
                                  unint64_t v104 = *((void *)isa + 13) / v103;
                                  uint64_t v214 = v223[10];
                                  uint64_t v230 = v223[8];
                                  unint64_t v105 = v223[4];
                                  unint64_t v210 = v223[15] / v105;
                                  unint64_t v193 = v223[14] / v105;
                                  unint64_t v225 = v223[13] / v105;
                                  unint64_t v106 = *(void *)(v50 + 32);
                                  unint64_t v208 = *(void *)(v50 + 120) / v106;
                                  uint64_t v204 = 2 * v104;
                                  unint64_t v206 = v104;
                                  uint64_t v202 = 3 * v104;
                                  unint64_t v191 = *(void *)(v50 + 112) / v106;
                                  do
                                  {
                                    if (v214)
                                    {
                                      uint64_t v216 = 0;
                                      uint64_t v222 = v199 * v191;
                                      oslogCGFloat b = v199 * v193;
                                      uint64_t v107 = v199 * v195;
                                      do
                                      {
                                        if (v230)
                                        {
                                          for (uint64_t i = 0; i != v230; ++i)
                                          {
                                            float v109 = v227[oslogb + i * v225];
                                            if (v109 > 0.1)
                                            {
                                              float v110 = v220[v222];
                                              if (fabsf(v110) == INFINITY)
                                              {
                                                if (qword_1EBFFC360 != -1) {
                                                  dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                                                }
                                                BOOL v111 = qword_1EBFFC3B8;
                                                if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_INFO))
                                                {
                                                  LODWORD(v262.a) = 134349056;
                                                  *(double *)((char *)&v262.a + 4) = v110;
                                                  _os_log_impl(&dword_1DC2FE000, v111, OS_LOG_TYPE_INFO, "Predicted orientation is inf or nan: %{public}f", (uint8_t *)&v262, 0xCu);
                                                }
                                              }
                                              else
                                              {
                                                LODWORD(v262.a) = BaseAddress[v107];
                                                LODWORD(v242.a) = BaseAddress[v107 + v206];
                                                int v250 = BaseAddress[v107 + v204];
                                                int v249 = BaseAddress[v107 + v202];
                                                float v248 = sqrtf(v109);
                                                float v112 = -v110;
                                                if (v110 > 0.0) {
                                                  float v113 = 2.0;
                                                }
                                                else {
                                                  float v113 = -2.0;
                                                }
                                                if (v110 > 1.0 || v110 < -1.0)
                                                {
                                                  do
                                                  {
                                                    do
                                                      float v112 = v113 + v112;
                                                    while (v112 < -1.0);
                                                  }
                                                  while (v112 > 1.0);
                                                }
                                                float v247 = v112 * 90.0;
                                                int v246 = i;
                                                sub_1DC34530C((char **)&__p, &v262, (int *)&v242, &v250, &v249, (int *)&v248, (int *)&v247, &v246);
                                              }
                                            }
                                          }
                                        }
                                        v107 += v212;
                                        oslogb += v210;
                                        v222 += v208;
                                        ++v216;
                                      }
                                      while (v216 != v214);
                                    }
                                    ++v199;
                                  }
                                  while (v199 != v197);
                                }
                              }
                              if (LOBYTE(t2.tx)) {
                                LOBYTE(t2.tx) = sub_1DC370168((atomic_ullong *)&t2, (uint64_t)&t2.b, 1, *(uint64_t *)&t2.d) ^ 1;
                              }
                              sub_1DC315BA8((atomic_ullong *)&t2);
                              if (LOBYTE(v260.tx)) {
                                LOBYTE(v260.tx) = sub_1DC370168((atomic_ullong *)&v260, (uint64_t)&v260.b, 1, *(uint64_t *)&v260.d) ^ 1;
                              }
                              sub_1DC315BA8((atomic_ullong *)&v260);
                              if (LOBYTE(buf.tx)) {
                                LOBYTE(buf.tx) = sub_1DC370168((atomic_ullong *)&buf, (uint64_t)&buf.b, 1, *(uint64_t *)&buf.d) ^ 1;
                              }
                              sub_1DC315BA8((atomic_ullong *)&buf);
                              if (v189) {
                                goto LABEL_230;
                              }
                              goto LABEL_264;
                            }
                            if (v51 == 3)
                            {
                              CFTypeRef v52 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&oslog[0][3], memory_order_acquire);
                              if (v52) {
                                CFTypeRef v52 = CFRetain(v52);
                              }
                              *(void *)&buf.a = v52;
                              LOBYTE(buf.b) = 0;
                              *(_DWORD *)((char *)&buf.b + 1) = LODWORD(v260.a);
                              HIDWORD(buf.b) = *(_DWORD *)((char *)&v260.a + 3);
                              LOBYTE(buf.c) = 0;
                              *(_DWORD *)((char *)&buf.c + 1) = LODWORD(t2.a);
                              HIDWORD(buf.c) = *(_DWORD *)((char *)&t2.a + 3);
                              buf.CGFloat d = v8;
                              LOBYTE(buf.tx) = sub_1DC36FEF8((atomic_ullong *)&buf, (uint64_t)&buf.b, 1, *(uint64_t *)&v8);
                              CFTypeRef v53 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&oslog[1][3], memory_order_acquire);
                              if (v53) {
                                CFTypeRef v53 = CFRetain(v53);
                              }
                              *(void *)&v260.a = v53;
                              LOBYTE(v260.b) = 0;
                              *(_DWORD *)((char *)&v260.b + 1) = LODWORD(t2.a);
                              HIDWORD(v260.b) = *(_DWORD *)((char *)&t2.a + 3);
                              LOBYTE(v260.c) = 0;
                              *(_DWORD *)((char *)&v260.c + 1) = LODWORD(v262.a);
                              HIDWORD(v260.c) = *(_DWORD *)((char *)&v262.a + 3);
                              v260.CGFloat d = v8;
                              LOBYTE(v260.tx) = sub_1DC36FEF8((atomic_ullong *)&v260, (uint64_t)&v260.b, 1, *(uint64_t *)&v8);
                              CFTypeRef v54 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(v228 + 24), memory_order_acquire);
                              if (v54) {
                                CFTypeRef v54 = CFRetain(v54);
                              }
                              *(void *)&t2.a = v54;
                              LOBYTE(t2.b) = 0;
                              *(_DWORD *)((char *)&t2.b + 1) = LODWORD(v262.a);
                              HIDWORD(t2.b) = *(_DWORD *)((char *)&v262.a + 3);
                              LOBYTE(t2.c) = 0;
                              *(_DWORD *)((char *)&t2.c + 1) = LODWORD(v242.a);
                              HIDWORD(t2.c) = *(_DWORD *)((char *)&v242.a + 3);
                              t2.CGFloat d = v8;
                              int v55 = sub_1DC36FEF8((atomic_ullong *)&t2, (uint64_t)&t2.b, 1, *(uint64_t *)&v8);
                              LOBYTE(t2.tx) = v55;
                              if (LOBYTE(buf.tx)) {
                                BOOL v56 = LOBYTE(v260.tx) == 0;
                              }
                              else {
                                BOOL v56 = 1;
                              }
                              int v57 = v55 ^ 1;
                              if (v56) {
                                int v57 = 1;
                              }
                              char v188 = v57;
                              if (v57 == 1)
                              {
                                if (qword_1EBFFC360 != -1) {
                                  dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                                }
                                double v58 = qword_1EBFFC3B8;
                                if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                                {
                                  int v59 = *(_DWORD *)(*(void *)&v8 + 56);
                                  LODWORD(v262.a) = 67240192;
                                  HIDWORD(v262.a) = v59;
                                  _os_log_error_impl(&dword_1DC2FE000, v58, OS_LOG_TYPE_ERROR, "IOSurfaceLock failed: %{public}d", (uint8_t *)&v262, 8u);
                                }
                              }
                              else
                              {
                                CGFloat v217 = IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)&oslog[0][3], memory_order_acquire));
                                char v226 = (short float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)&oslog[1][3], memory_order_acquire));
                                v219 = IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)(v228 + 24), memory_order_acquire));
                                uint64_t v196 = v223[9];
                                if (v196)
                                {
                                  uint64_t v198 = 0;
                                  unint64_t v79 = *((void *)isa + 4);
                                  unint64_t v211 = *((void *)isa + 15) / v79;
                                  unint64_t v194 = *((void *)isa + 14) / v79;
                                  unint64_t v80 = *((void *)isa + 13) / v79;
                                  uint64_t v213 = v223[10];
                                  uint64_t v229 = v223[8];
                                  unint64_t v81 = v223[4];
                                  unint64_t v209 = v223[15] / v81;
                                  unint64_t v192 = v223[14] / v81;
                                  unint64_t v224 = v223[13] / v81;
                                  unint64_t v82 = *(void *)(v50 + 32);
                                  unint64_t v207 = *(void *)(v50 + 120) / v82;
                                  uint64_t v203 = 2 * v80;
                                  unint64_t v205 = v80;
                                  uint64_t v201 = 3 * v80;
                                  unint64_t v190 = *(void *)(v50 + 112) / v82;
                                  do
                                  {
                                    if (v213)
                                    {
                                      uint64_t v215 = 0;
                                      uint64_t v221 = v198 * v190;
                                      uint64_t osloga = v198 * v192;
                                      uint64_t v83 = v198 * v194;
                                      do
                                      {
                                        if (v229)
                                        {
                                          for (uint64_t j = 0; j != v229; ++j)
                                          {
                                            _H0 = v226[osloga + j * v224];
                                            if (_H0 > COERCE_SHORT_FLOAT(11878))
                                            {
                                              LOWORD(_S1) = v219[v221];
                                              if ((~_S1 & 0x7C00) != 0)
                                              {
                                                _H2 = v217[v83];
                                                __asm { FCVT            S2, H2 }
                                                LODWORD(v262.a) = _S2;
                                                LOWORD(_S2) = v217[v83 + v205];
                                                __asm { FCVT            S2, H2 }
                                                LODWORD(v242.a) = _S2;
                                                LOWORD(_S2) = v217[v83 + v203];
                                                __asm { FCVT            S2, H2 }
                                                int v250 = _S2;
                                                LOWORD(_S2) = v217[v83 + v201];
                                                __asm { FCVT            S2, H2 }
                                                int v249 = _S2;
                                                __asm { FCVT            S0, H0 }
                                                float v248 = sqrtf(_S0);
                                                __asm { FCVT            S2, H1 }
                                                float v99 = -_S2;
                                                __asm { FCMP            H1, #0 }
                                                if (!_ZF & _CF) {
                                                  float v101 = 2.0;
                                                }
                                                else {
                                                  float v101 = -2.0;
                                                }
                                                if (_S2 > 1.0 || _S2 < -1.0)
                                                {
                                                  do
                                                  {
                                                    do
                                                      float v99 = v101 + v99;
                                                    while (v99 < -1.0);
                                                  }
                                                  while (v99 > 1.0);
                                                }
                                                float v247 = v99 * 90.0;
                                                int v246 = j;
                                                sub_1DC34530C((char **)&__p, &v262, (int *)&v242, &v250, &v249, (int *)&v248, (int *)&v247, &v246);
                                              }
                                              else
                                              {
                                                _H13 = v219[v221];
                                                if (qword_1EBFFC360 != -1) {
                                                  dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                                                }
                                                int v87 = qword_1EBFFC3B8;
                                                if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_INFO))
                                                {
                                                  __asm { FCVT            D0, H13 }
                                                  LODWORD(v262.a) = 134349056;
                                                  *(void *)((char *)&v262.a + 4) = _D0;
                                                  _os_log_impl(&dword_1DC2FE000, v87, OS_LOG_TYPE_INFO, "Predicted orientation is inf or nan: %{public}f", (uint8_t *)&v262, 0xCu);
                                                }
                                              }
                                            }
                                          }
                                        }
                                        v83 += v211;
                                        osloga += v209;
                                        v221 += v207;
                                        ++v215;
                                      }
                                      while (v215 != v213);
                                    }
                                    ++v198;
                                  }
                                  while (v198 != v196);
                                }
                              }
                              if (LOBYTE(t2.tx)) {
                                LOBYTE(t2.tx) = sub_1DC370168((atomic_ullong *)&t2, (uint64_t)&t2.b, 1, *(uint64_t *)&t2.d) ^ 1;
                              }
                              sub_1DC315BA8((atomic_ullong *)&t2);
                              if (LOBYTE(v260.tx)) {
                                LOBYTE(v260.tx) = sub_1DC370168((atomic_ullong *)&v260, (uint64_t)&v260.b, 1, *(uint64_t *)&v260.d) ^ 1;
                              }
                              sub_1DC315BA8((atomic_ullong *)&v260);
                              if (LOBYTE(buf.tx)) {
                                LOBYTE(buf.tx) = sub_1DC370168((atomic_ullong *)&buf, (uint64_t)&buf.b, 1, *(uint64_t *)&buf.d) ^ 1;
                              }
                              sub_1DC315BA8((atomic_ullong *)&buf);
                              if (v188)
                              {
LABEL_230:
                                if (qword_1EBFFC360 != -1) {
                                  dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                                }
                                int v102 = qword_1EBFFC3B8;
                                if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_INFO))
                                {
                                  LOWORD(buf.a) = 0;
                                  _os_log_impl(&dword_1DC2FE000, v102, OS_LOG_TYPE_INFO, "Failed to collect det boxes.", (uint8_t *)&buf, 2u);
                                }
LABEL_180:
                                LOBYTE(v237) = 0;
                                char v239 = 0;
LABEL_181:
                                if (__p)
                                {
                                  v244 = (char *)__p;
                                  operator delete(__p);
                                }
                                goto LABEL_150;
                              }
LABEL_264:
                              uint64_t v114 = (char *)__p;
                              int64_t v115 = v244;
                              if (qword_1EBFFC360 != -1) {
                                dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                              }
                              oslogCGFloat c = qword_1EBFFC3B8;
                              if (v114 == v115)
                              {
                                if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_INFO))
                                {
                                  LOWORD(buf.a) = 0;
                                  _os_log_impl(&dword_1DC2FE000, oslogc, OS_LOG_TYPE_INFO, "No candidate with scores above pre-NMS-thresholds has been found.", (uint8_t *)&buf, 2u);
                                }
                                long long v237 = 0uLL;
                                CGFloat v238 = 0.0;
                                char v239 = 1;
                                goto LABEL_181;
                              }
                              if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_DEBUG))
                              {
                                LODWORD(buf.a) = 134349056;
                                *(void *)((char *)&buf.a + 4) = 0x6DB6DB6DB6DB6DB7 * ((v115 - v114) >> 2);
                                _os_log_debug_impl(&dword_1DC2FE000, oslogc, OS_LOG_TYPE_DEBUG, "%{public}zu candidate(s) with scores above pre-NMS-thresholds has/have been found.", (uint8_t *)&buf, 0xCu);
                              }
                              CGFloat v116 = *(double *)&__p;
                              if (__p != v244)
                              {
                                sub_1DC3443DC((unint64_t)__p, v244, 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * ((v244 - (unsigned char *)__p) >> 2)), 1);
                                int64_t v117 = (char *)__p;
                                CGFloat v116 = *(double *)&v244;
                                unint64_t v118 = 0x6DB6DB6DB6DB6DB7 * ((v244 - (unsigned char *)__p) >> 2);
                                if (v244 == __p)
                                {
                                  unint64_t v138 = 0;
                                  int64_t v117 = v244;
                                }
                                else
                                {
                                  unint64_t v119 = 0;
                                  int v120 = (float *)((char *)__p + 52);
                                  uint64_t v121 = -1;
                                  unint64_t v122 = 0x6DB6DB6DB6DB6DB7 * ((v244 - (unsigned char *)__p) >> 2);
                                  while (1)
                                  {
                                    unint64_t v123 = v119 + 1;
                                    if (v119 + 1 >= v122) {
                                      break;
                                    }
                                    int v124 = &v117[28 * v119];
                                    int v125 = (float *)(v124 + 4);
                                    int v126 = (float *)(v124 + 8);
                                    BOOL v127 = (float *)(v124 + 12);
                                    unint64_t v128 = v122 + v121;
                                    uint64_t v129 = v120;
                                    unint64_t v122 = v123;
                                    do
                                    {
                                      if (*((_DWORD *)v124 + 6) != *(_DWORD *)v129
                                        || (float v130 = *(v129 - 6),
                                            float v131 = *(v129 - 5),
                                            float v132 = *(v129 - 4),
                                            float v133 = *(v129 - 3),
                                            float v134 = fmax((float)(fminf(*v126, v132) - fmaxf(*(float *)v124, v130)), 0.0),
                                            float v135 = fmax((float)(fminf(*v127, v133) - fmaxf(*v125, v131)), 0.0),
                                            (float)((float)(v134 * v135)
                                                  / (float)((float)((float)((float)(v132 - v130) * (float)(v133 - v131))
                                                                  + (float)((float)(*v126 - *(float *)v124)
                                                                          * (float)(*v127 - *v125)))
                                                          - (float)(v134 * v135))) <= 0.5))
                                      {
                                        BOOL v136 = &v117[28 * v122];
                                        long long v137 = *(_OWORD *)(v129 - 6);
                                        ++v122;
                                        *(_OWORD *)(v136 + 12) = *(_OWORD *)(v129 - 3);
                                        *(_OWORD *)BOOL v136 = v137;
                                      }
                                      v129 += 7;
                                      --v128;
                                    }
                                    while (v128);
                                    v120 += 7;
                                    --v121;
                                    unint64_t v119 = v123;
                                    if (v123 >= v122)
                                    {
                                      unint64_t v138 = v118;
                                      unint64_t v118 = v122;
                                      goto LABEL_285;
                                    }
                                  }
                                  unint64_t v138 = v118;
                                  unint64_t v118 = v119 + 1;
                                }
LABEL_285:
                                unint64_t v139 = v118 - v138;
                                if (v118 > v138)
                                {
                                  if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&d - *(void *)&v116) >> 2) < v139)
                                  {
                                    if (v118 > 0x924924924924924) {
                                      sub_1DC2FF97C();
                                    }
                                    unint64_t v140 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&d - (void)v117) >> 2);
                                    if (2 * v140 > v118) {
                                      unint64_t v118 = 2 * v140;
                                    }
                                    if (v140 >= 0x492492492492492) {
                                      unint64_t v141 = 0x924924924924924;
                                    }
                                    else {
                                      unint64_t v141 = v118;
                                    }
                                    sub_1DC344D58(&buf, v141, v138, (uint64_t)&d);
                                    CGFloat c = buf.c;
                                    bzero(*(void **)&buf.c, 28 * ((28 * v139 - 28) / 0x1C) + 28);
                                    *(void *)&CGFloat v116 = *(void *)&c + 28 * ((28 * v139 - 28) / 0x1C) + 28;
                                    buf.CGFloat c = v116;
                                    uint64_t v143 = (char *)__p;
                                    uint64_t v144 = v244;
                                    CGFloat b = buf.b;
                                    if (v244 == __p)
                                    {
                                      uint64_t v143 = v244;
                                    }
                                    else
                                    {
                                      int v146 = v244;
                                      do
                                      {
                                        long long v147 = *(_OWORD *)(v146 - 28);
                                        *(_OWORD *)(*(void *)&b - 16) = *((_OWORD *)v146 - 1);
                                        *(_OWORD *)(*(void *)&b - 28) = v147;
                                        *(void *)&b -= 28;
                                        v146 -= 28;
                                      }
                                      while (v146 != v143);
                                      CGFloat v116 = buf.c;
                                    }
                                    __p = *(void **)&b;
                                    v244 = *(char **)&v116;
                                    CGFloat v148 = d;
                                    CGFloat d = buf.d;
                                    *(void *)&buf.CGFloat c = v144;
                                    buf.CGFloat d = v148;
                                    *(void *)&buf.CGFloat b = v143;
                                    *(void *)&buf.a = v143;
                                    if (v144 != v143) {
                                      *(void *)&buf.CGFloat c = &v143[(v144 - v143 - 28) % 0x1CuLL];
                                    }
                                    if (v143)
                                    {
                                      operator delete(v143);
                                      CGFloat v116 = *(double *)&v244;
                                    }
                                    goto LABEL_306;
                                  }
                                  bzero(*(void **)&v116, 28 * ((28 * v139 - 28) / 0x1C) + 28);
                                  *(void *)&v116 += 28 * ((28 * v139 - 28) / 0x1C) + 28;
                                  goto LABEL_300;
                                }
                                if (v118 < v138)
                                {
                                  *(void *)&CGFloat v116 = &v117[28 * v118];
LABEL_300:
                                  v244 = *(char **)&v116;
                                }
                              }
LABEL_306:
                              uint64_t v149 = (char *)__p;
                              if (__p != *(void **)&v116)
                              {
                                while (*((float *)v149 + 4) >= flt_1DC3FDE60[*((unsigned int *)v149 + 6)])
                                {
                                  v149 += 28;
                                  if (v149 == *(char **)&v116) {
                                    goto LABEL_316;
                                  }
                                }
                                if (v149 != *(char **)&v116)
                                {
                                  for (uint64_t k = v149 + 28; k != *(char **)&v116; k += 28)
                                  {
                                    if (*((float *)k + 4) >= flt_1DC3FDE60[*((unsigned int *)k + 6)])
                                    {
                                      long long v151 = *(_OWORD *)k;
                                      *(_OWORD *)(v149 + 12) = *(_OWORD *)(k + 12);
                                      *(_OWORD *)uint64_t v149 = v151;
                                      v149 += 28;
                                    }
                                  }
                                }
                              }
LABEL_316:
                              long long v152 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
                              long long v153 = *MEMORY[0x1E4F1DAB8];
                              *(_OWORD *)&v262.CGFloat c = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
                              *(_OWORD *)&v262.tx = v152;
                              *(_OWORD *)&v262.a = v153;
                              if (*(unsigned char *)(v200 + 28))
                              {
                                CGFloat v154 = (double)*(unint64_t *)(v200 + 32) * 0.5;
                                CGFloat v155 = (double)*(unint64_t *)(v200 + 40) * 0.5;
                                CGAffineTransformMakeTranslation(&v242, -v154, -v155);
                                long long v156 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
                                *(_OWORD *)&v260.a = *MEMORY[0x1E4F1DAB8];
                                *(_OWORD *)&v260.CGFloat c = v156;
                                *(_OWORD *)&v260.tx = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
                                CGAffineTransform t2 = v242;
                                CGAffineTransformConcat(&buf, &v260, &t2);
                                CGAffineTransform v262 = buf;
                                CGAffineTransformMakeRotation(&v242, -1.57079633);
                                CGAffineTransform v260 = v262;
                                CGAffineTransform t2 = v242;
                                CGAffineTransformConcat(&buf, &v260, &t2);
                                CGAffineTransform v262 = buf;
                                CGAffineTransformMakeTranslation(&v242, v155, v154);
                                CGAffineTransform v260 = v262;
                                CGAffineTransform t2 = v242;
                                CGAffineTransformConcat(&buf, &v260, &t2);
                                CGAffineTransform v262 = buf;
                              }
                              double Width = CGRectGetWidth(*(CGRect *)(v39 + 8));
                              double v158 = Width / CGRectGetHeight(*(CGRect *)(v39 + 8));
                              if (*(unsigned char *)(v200 + 28)) {
                                double v159 = (double)*(unint64_t *)(v200 + 16);
                              }
                              else {
                                double v159 = (double)*(unint64_t *)(v200 + 8);
                              }
                              if (*(unsigned char *)(v200 + 28)) {
                                double v160 = (double)*(unint64_t *)(v200 + 8);
                              }
                              else {
                                double v160 = (double)*(unint64_t *)(v200 + 16);
                              }
                              uint64_t v161 = *(void *)(v39 + 8);
                              uint64_t v162 = *(void *)(v39 + 16);
                              uint64_t v163 = *(void *)(v39 + 24);
                              uint64_t v164 = *(void *)(v39 + 32);
                              if (v158 >= v159 / v160) {
                                double v165 = CGRectGetWidth(*(CGRect *)&v161) / v159;
                              }
                              else {
                                double v165 = CGRectGetHeight(*(CGRect *)&v161) / v160;
                              }
                              CGAffineTransformMakeScale(&v242, v165, v165);
                              CGAffineTransform v260 = v262;
                              CGAffineTransform t2 = v242;
                              CGAffineTransformConcat(&buf, &v260, &t2);
                              CGAffineTransform v262 = buf;
                              CGAffineTransform v260 = buf;
                              CGAffineTransform t2 = v241;
                              CGAffineTransformConcat(&buf, &v260, &t2);
                              CGAffineTransform v262 = buf;
                              memset(&v242, 0, 24);
                              sub_1DC344344((uint64_t *)&v242, 0x6DB6DB6DB6DB6DB7 * ((v244 - (unsigned char *)__p) >> 2));
                              *(void *)&t2.a = @"Pseudo1D";
                              *(void *)&t2.CGFloat b = @"Pseudo2D";
                              *(void *)&t2.CGFloat c = @"PseudoPDF417";
                              *(void *)&t2.CGFloat d = @"PseudoExternal";
                              uint64_t v166 = (char *)__p;
                              uint64_t v167 = v244;
                              if (__p != v244)
                              {
                                do
                                {
                                  *(float64x2_t *)&v260.a = vcvtq_f64_f32(*(float32x2_t *)v166);
                                  CGFloat v168 = *((float *)v166 + 3);
                                  v260.CGFloat c = *(float *)v166;
                                  v260.CGFloat d = v168;
                                  *(float64x2_t *)&v260.tx = vcvtq_f64_f32(*(float32x2_t *)(v166 + 8));
                                  int8x16_t v169 = (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)(v166 + 4));
                                  int8x16_t v261 = vextq_s8(v169, v169, 8uLL);
                                  if (os_log_type_enabled(oslogc, OS_LOG_TYPE_DEBUG))
                                  {
                                    int v181 = *((_DWORD *)v166 + 6);
                                    double v182 = *((float *)v166 + 4);
                                    float v183 = *((float *)v166 + 1);
                                    double v184 = *(float *)v166;
                                    float v185 = *((float *)v166 + 3) - v183;
                                    CGFloat v186 = (float)(*((float *)v166 + 2) - *(float *)v166);
                                    double v187 = *((float *)v166 + 5);
                                    LODWORD(buf.a) = 67241728;
                                    HIDWORD(buf.a) = v181;
                                    LOWORD(buf.b) = 2050;
                                    *(double *)((char *)&buf.b + 2) = v182;
                                    WORD1(buf.c) = 2050;
                                    *(double *)((char *)&buf.c + 4) = v184;
                                    WORD2(buf.d) = 2050;
                                    *(double *)((char *)&buf.d + 6) = v183;
                                    HIWORD(buf.tx) = 2050;
                                    buf.ty = v186;
                                    LOWORD(v252[0]) = 2050;
                                    *(double *)((char *)v252 + 2) = v185;
                                    WORD5(v252[0]) = 2050;
                                    *(double *)((char *)v252 + 12) = v187;
                                    _os_log_debug_impl(&dword_1DC2FE000, oslogc, OS_LOG_TYPE_DEBUG, "class=%{public}u | score=%{public}f | x=%{public}f, y=%{public}f, width=%{public}f, height=%{public}f | angle=%{public}f", (uint8_t *)&buf, 0x44u);
                                  }
                                  uint64_t v170 = *((unsigned int *)v166 + 6);
                                  if (v170 >= 4)
                                  {
                                    if (os_log_type_enabled(oslogc, OS_LOG_TYPE_ERROR))
                                    {
                                      LODWORD(buf.a) = 67240192;
                                      HIDWORD(buf.a) = v170;
                                      _os_log_error_impl(&dword_1DC2FE000, oslogc, OS_LOG_TYPE_ERROR, "Invalid coarse class id: %{public}u, skipping...", (uint8_t *)&buf, 8u);
                                    }
                                  }
                                  else
                                  {
                                    v171 = (const void *)MRCRegionCreate((long long *)&v260, (long long *)&v262, *((const void **)&t2.a + v170), *((float *)v166 + 5), *((float *)v166 + 4));
                                    uint64_t v172 = v171;
                                    if (v171)
                                    {
                                      CFTypeID v173 = CFGetTypeID(v171);
                                      if (qword_1EBFFB6F8[0] != -1) {
                                        dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
                                      }
                                      if (v173 != qword_1EBFFB6F0) {
                                        _os_assumes_log();
                                      }
                                    }
                                    CGFloat v174 = v242.b;
                                    if (*(void *)&v242.b >= *(void *)&v242.c)
                                    {
                                      uint64_t v176 = (uint64_t)(*(void *)&v242.b - *(void *)&v242.a) >> 3;
                                      if ((unint64_t)(v176 + 1) >> 61) {
                                        sub_1DC2FF97C();
                                      }
                                      unint64_t v177 = (uint64_t)(*(void *)&v242.c - *(void *)&v242.a) >> 2;
                                      if (v177 <= v176 + 1) {
                                        unint64_t v177 = v176 + 1;
                                      }
                                      if (*(void *)&v242.c - *(void *)&v242.a >= 0x7FFFFFFFFFFFFFF8uLL) {
                                        CGFloat v178 = 1.49166815e-154;
                                      }
                                      else {
                                        CGFloat v178 = *(double *)&v177;
                                      }
                                      *(void *)&buf.tx = &v242.c;
                                      if (v178 == 0.0) {
                                        uint64_t v179 = 0;
                                      }
                                      else {
                                        CGFloat v178 = COERCE_DOUBLE(sub_1DC2FFD7C(*(unint64_t *)&v178));
                                      }
                                      uint64_t v180 = (void *)(*(void *)&v178 + 8 * v176);
                                      buf.a = v178;
                                      *(void *)&buf.CGFloat b = v180;
                                      *(void *)&buf.CGFloat d = *(void *)&v178 + 8 * v179;
                                      *uint64_t v180 = v172;
                                      *(void *)&buf.CGFloat c = v180 + 1;
                                      sub_1DC3066A4((uint64_t *)&v242, &buf);
                                      CGFloat v175 = v242.b;
                                      sub_1DC306780((uint64_t)&buf);
                                    }
                                    else
                                    {
                                      **(void **)&v242.CGFloat b = v172;
                                      *(void *)&CGFloat v175 = *(void *)&v174 + 8;
                                    }
                                    v242.CGFloat b = v175;
                                  }
                                  v166 += 28;
                                }
                                while (v166 != v167);
                              }
                              long long v237 = *(_OWORD *)&v242.a;
                              CGFloat v238 = v242.c;
                              memset(&v242, 0, 24);
                              char v239 = 1;
                              *(void *)&buf.a = &v242;
                              sub_1DC306620((void ***)&buf);
                              goto LABEL_181;
                            }
                          }
                          if (qword_1EBFFC360 != -1) {
                            dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                          }
                          unint64_t v69 = qword_1EBFFC3B8;
                          if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                          {
                            LOWORD(buf.a) = 0;
                            _os_log_error_impl(&dword_1DC2FE000, v69, OS_LOG_TYPE_ERROR, "Unsupported output tensor data type", (uint8_t *)&buf, 2u);
                          }
                          buf.a = NAN;
                          *(void *)&v260.a = @"Unsupported output tensor data type.";
                          sub_1DC306334(*(atomic_ullong **)&v8, (uint64_t *)&buf, (CFTypeRef *)&v260);
                          goto LABEL_180;
                        }
                      }
                    }
                  }
                }
                if (qword_1EBFFC360 != -1) {
                  dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                }
                int v66 = qword_1EBFFC3B8;
                if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(buf.a) = 0;
                  _os_log_error_impl(&dword_1DC2FE000, v66, OS_LOG_TYPE_ERROR, "Unexpected output scores.", (uint8_t *)&buf, 2u);
                }
                buf.a = NAN;
                *(void *)&v260.a = @"Unexpected output scores.";
                sub_1DC306334(*(atomic_ullong **)&v8, (uint64_t *)&buf, (CFTypeRef *)&v260);
              }
              else
              {
                if (qword_1EBFFC360 != -1) {
                  dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                }
                unint64_t v65 = qword_1EBFFC3B8;
                if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(buf.a) = 0;
                  _os_log_error_impl(&dword_1DC2FE000, v65, OS_LOG_TYPE_ERROR, "Unexpected output.", (uint8_t *)&buf, 2u);
                }
                buf.a = NAN;
                *(void *)&v260.a = @"Unexpected output.";
                sub_1DC306334(*(atomic_ullong **)&v8, (uint64_t *)&buf, (CFTypeRef *)&v260);
              }
              LOBYTE(v237) = 0;
              char v239 = 0;
              goto LABEL_150;
            }
            if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
            {
              LOWORD(buf.a) = 0;
              BOOL v63 = "Failed to execute.";
              goto LABEL_132;
            }
LABEL_133:
            int d_low = 0;
            LOBYTE(buf.a) = 0;
            LOBYTE(buf.d) = 0;
            goto LABEL_134;
          }
          if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
            goto LABEL_133;
          }
          LOWORD(buf.a) = 0;
          BOOL v63 = "Failed to bind input surface.";
        }
        else
        {
          if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
            goto LABEL_133;
          }
          LOWORD(buf.a) = 0;
          BOOL v63 = "Failed to create input pixel buffer.";
        }
LABEL_132:
        _os_log_impl(&dword_1DC2FE000, v38, OS_LOG_TYPE_INFO, v63, (uint8_t *)&buf, 2u);
        goto LABEL_133;
      }
    }
  }
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  uint64_t v22 = qword_1EBFFC3B8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.a) = 0;
    _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "ANMDModel is not ready.", (uint8_t *)&buf, 2u);
  }
  buf.a = NAN;
  *(void *)&v260.a = @"ANMDModel is not ready.";
  sub_1DC306334(*(atomic_ullong **)&v8, (uint64_t *)&buf, (CFTypeRef *)&v260);
  int d_low = 0;
  LOBYTE(buf.a) = 0;
  LOBYTE(buf.d) = 0;
LABEL_28:
  uint64_t v24 = *(void *)(a1 + 16);
  if (*(unsigned __int8 *)(v24 + 24) != d_low)
  {
    if (!*(unsigned char *)(v24 + 24))
    {
      *(_OWORD *)uint64_t v24 = *(_OWORD *)&buf.a;
      *(CGFloat *)(v24 + 16) = buf.c;
      memset(&buf, 0, 24);
      *(unsigned char *)(v24 + 24) = 1;
      if (!d_low) {
        goto LABEL_41;
      }
      goto LABEL_40;
    }
    v260.a = *(CGFloat *)(a1 + 16);
    sub_1DC306620((void ***)&v260);
    *(unsigned char *)(v24 + 24) = 0;
    goto LABEL_39;
  }
  if (!*(unsigned char *)(v24 + 24))
  {
LABEL_39:
    if (!d_low) {
      goto LABEL_41;
    }
LABEL_40:
    *(void *)&v260.a = &buf;
    sub_1DC306620((void ***)&v260);
    goto LABEL_41;
  }
  unint64_t v25 = *(atomic_ullong **)v24;
  if (*(void *)v24)
  {
    uint64_t v26 = *(atomic_ullong **)(v24 + 8);
    unint64_t v27 = *(atomic_ullong **)v24;
    if (v26 != v25)
    {
      do
        uint64_t v26 = sub_1DC30ABA4(v26 - 1);
      while (v26 != v25);
      unint64_t v27 = *(atomic_ullong **)v24;
      int d_low = LOBYTE(buf.d);
    }
    *(void *)(v24 + 8) = v25;
    operator delete(v27);
    *(void *)uint64_t v24 = 0;
    *(void *)(v24 + 8) = 0;
    *(void *)(v24 + 16) = 0;
  }
  *(_OWORD *)uint64_t v24 = *(_OWORD *)&buf.a;
  *(CGFloat *)(v24 + 16) = buf.c;
  memset(&buf, 0, 24);
  if (d_low) {
    goto LABEL_40;
  }
LABEL_41:
  uint64_t v28 = *(uint64_t **)(a1 + 16);
  if (*((unsigned char *)v28 + 24) && !*(unsigned char *)(*(void *)(a1 + 8) + 96))
  {
    if (qword_1EBFFC3E0 != -1) {
      dispatch_once(&qword_1EBFFC3E0, &unk_1F3662428);
    }
    unint64_t v29 = qword_1EBFFC3E8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3E8, OS_LOG_TYPE_INFO))
    {
      uint64_t v30 = (v28[1] - *v28) >> 3;
      LODWORD(buf.a) = 134349056;
      *(void *)((char *)&buf.a + 4) = v30;
      _os_log_impl(&dword_1DC2FE000, v29, OS_LOG_TYPE_INFO, "ANMD inference yields %{public}zu region(s).", (uint8_t *)&buf, 0xCu);
      uint64_t v28 = *(uint64_t **)(a1 + 16);
    }
    uint64_t v31 = *(void *)(a1 + 40);
    if (*(unsigned __int8 *)(v31 + 16) == *((unsigned __int8 *)v28 + 24))
    {
      if (*(unsigned char *)(v31 + 16))
      {
        uint64_t v32 = (v28[1] - *v28) >> 3;
        *(void *)uint64_t v31 = *v28;
        *(void *)(v31 + 8) = v32;
      }
    }
    else if (*(unsigned char *)(v31 + 16))
    {
      *(unsigned char *)(v31 + 16) = 0;
    }
    else
    {
      uint64_t v35 = *v28;
      *(void *)uint64_t v31 = *v28;
      *(void *)(v31 + 8) = (v28[1] - v35) >> 3;
      *(unsigned char *)(v31 + 16) = 1;
    }
  }
  else
  {
    if (qword_1EBFFC3E0 != -1) {
      dispatch_once(&qword_1EBFFC3E0, &unk_1F3662428);
    }
    CFTypeID v5 = qword_1EBFFC3E8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3E8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v34 = *(void *)(a1 + 8);
      if (*(unsigned char *)(v34 + 96))
      {
        sub_1DC390B4C((uint64_t)&buf, v34);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        memset(v252, 0, sizeof(v252));
        long long v253 = 0u;
      }
      sub_1DC390F7C((CFErrorRef *)&t2, (uint64_t)&buf);
      unint64_t v62 = atomic_load_explicit((atomic_ullong *volatile)&t2, memory_order_acquire);
      LODWORD(v260.a) = 138543362;
      *(void *)((char *)&v260.a + 4) = v62;
      unint64_t v61 = "Cannot run ANMD inference: %{public}@";
      goto LABEL_125;
    }
  }
}

void sub_1DC30DAF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,atomic_ullong a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (__p)
  {
    a68 = (uint64_t)__p;
    operator delete(__p);
  }
  uint64_t v70 = *(void *)(v68 - 248);
  if (*(unsigned char *)(v70 + 8))
  {
    uint64_t v71 = *(void *)(v68 - 216);
    if (v71) {
      sub_1DC31AE10(v71, *(void *)v70);
    }
  }
  sub_1DC31AE60(a23);
  sub_1DC307370(&a54);
  if (*(unsigned char *)(STACK[0x2A8] + 8))
  {
    if (STACK[0x2C8]) {
      sub_1DC31AE10(STACK[0x2C8], *(void *)STACK[0x2A8]);
    }
  }
  sub_1DC31AE60(a46);
  _Unwind_Resume(a1);
}

__n128 sub_1DC30DE38(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365E4C8;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC30DE70(uint64_t a1)
{
  CFTypeID v2 = (char *)operator new(0x30uLL);
  *(void *)CFTypeID v2 = &unk_1F365E4C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void sub_1DC30DECC()
{
}

void *sub_1DC30DEE4()
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFB630) {
    _os_assumes_log();
  }
  if (qword_1EBFFB818) {
    _os_assumes_log();
  }
  qword_1EBFFB630 = (uint64_t)"MRCContext";
  qword_1EBFFB818 = _CFRuntimeRegisterClass();
  v1[3] = 0;
  sub_1DC348EB8(qword_1EBFFB818, v1);
  return sub_1DC30AC9C(v1);
}

void sub_1DC30DF8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC30AC9C((uint64_t *)va);
  _Unwind_Resume(a1);
}

CFStringRef sub_1DC30DFA8(os_unfair_lock_s *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v2 != qword_1EBFFB818) {
      _os_assumes_log();
    }
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (!atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    sub_1DC326F90((atomic_ullong *)&Mutable);
    return CFStringCreateWithFormat(v3, 0, @"<%s %p>", "MRCContext", cf);
  }
  CFTypeID v4 = (uint64_t *)&cf[4];
  CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"<%s %p> {\n", "MRCContext", cf);
  CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    options {\n");
  unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  uint64_t v6 = **(void **)&cf[4]._os_unfair_lock_opaque;
  sub_1DC3C1B48(__dst, v6);
  CFStringAppendFormat(explicit, 0, @"        inferenceFlags 0x%lx (%@)\n", v6, atomic_load_explicit((atomic_ullong *volatile)__dst, memory_order_acquire));
  sub_1DC31FA90((atomic_ullong *)__dst);
  uint64_t v7 = **(void **)&cf[4]._os_unfair_lock_opaque;
  if (v7 != sub_1DC3B52CC(*(void **)&cf[4]._os_unfair_lock_opaque))
  {
    CGFloat v8 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    uint64_t v9 = (void *)*v4;
    unint64_t v10 = sub_1DC3B52CC((void *)*v4);
    int v11 = sub_1DC3B52CC(v9);
    sub_1DC3C1B48(__dst, v11);
    CFStringAppendFormat(v8, 0, @"        effectiveInferenceFlags 0x%lx (%@)\n", v10, atomic_load_explicit((atomic_ullong *volatile)__dst, memory_order_acquire));
    sub_1DC31FA90((atomic_ullong *)__dst);
  }
  long long v12 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  unint64_t v13 = atomic_load_explicit((atomic_ullong *volatile)(*v4 + 8), memory_order_acquire);
  unint64_t v14 = *MEMORY[0x1E4F1D260];
  if (!v13) {
    unint64_t v13 = *MEMORY[0x1E4F1D260];
  }
  CFStringAppendFormat(v12, 0, @"        preferredMetalDevice %@\n", v13);
  uint64_t v15 = (atomic_ullong *)(*v4 + 8);
  sub_1DC3B5790((uint64_t *)__dst, *v4);
  uint64_t v16 = (const void *)atomic_load_explicit((atomic_ullong *volatile)__dst, memory_order_acquire);
  uint64_t v17 = (const void *)atomic_load_explicit(v15, memory_order_acquire);
  if (v17 != v16)
  {
    if (v16 && v17)
    {
      int v18 = CFEqual(v17, v16);
      sub_1DC31EB58((atomic_ullong *)__dst);
      if (v18) {
        goto LABEL_22;
      }
    }
    else
    {
      sub_1DC31EB58((atomic_ullong *)__dst);
    }
    uint64_t v19 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    sub_1DC3B5790((uint64_t *)__dst, *v4);
    unint64_t v20 = atomic_load_explicit((atomic_ullong *volatile)__dst, memory_order_acquire);
    if (!v20) {
      unint64_t v20 = v14;
    }
    CFStringAppendFormat(v19, 0, @"        effectivePreferredMetalDevice %@\n", v20);
  }
  sub_1DC31EB58((atomic_ullong *)__dst);
LABEL_22:
  long long v21 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  unint64_t v22 = atomic_load_explicit((atomic_ullong *volatile)(*v4 + 16), memory_order_acquire);
  if (!v22) {
    unint64_t v22 = v14;
  }
  CFStringAppendFormat(v21, 0, @"        computeDevice %@\n", v22);
  unint64_t v23 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  int v24 = *(_DWORD *)(*v4 + 24);
  if (v24 > 20)
  {
    switch(v24)
    {
      case 21:
        unint64_t v25 = @"default";
        goto LABEL_38;
      case 33:
        unint64_t v25 = @"user-interactive";
        goto LABEL_38;
      case 25:
        unint64_t v25 = @"user-initiated";
        goto LABEL_38;
    }
  }
  else
  {
    switch(v24)
    {
      case 0:
        unint64_t v25 = @"unspecified";
        goto LABEL_38;
      case 9:
        unint64_t v25 = @"background";
        goto LABEL_38;
      case 17:
        unint64_t v25 = @"utility";
LABEL_38:
        uint64_t v26 = (void *)CFRetain(v25);
        goto LABEL_39;
    }
  }
  uint64_t v26 = (void *)CFStringCreateWithFormat(v3, 0, @"unspecified (0x%x)", *(unsigned int *)(*v4 + 24));
LABEL_39:
  __dst[0] = v26;
  CFStringAppendFormat(v23, 0, @"        qosClass %@\n", atomic_load_explicit((atomic_ullong *volatile)__dst, memory_order_acquire));
  sub_1DC31FA90((atomic_ullong *)__dst);
  CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        relativePriority %d\n", *(unsigned int *)(*v4 + 28));
  unint64_t v27 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  if (*(unsigned char *)(*v4 + 32)) {
    uint64_t v28 = "true";
  }
  else {
    uint64_t v28 = "false";
  }
  CFStringAppendFormat(v27, 0, @"        isGlobal %s\n", v28);
  unint64_t v29 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  if (*(unsigned char *)(*v4 + 33)) {
    uint64_t v30 = "true";
  }
  else {
    uint64_t v30 = "false";
  }
  CFStringAppendFormat(v29, 0, @"        isOneShot %s\n", v30);
  int v31 = *(unsigned __int8 *)(*v4 + 48);
  uint64_t v32 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  if (v31) {
    CFStringAppendFormat(v32, 0, @"        maximumBufferAge %g\n", *(void *)(*v4 + 40));
  }
  else {
    CFStringAppendFormat(v32, 0, @"        maximumBufferAge <unspecified>\n");
  }
  unint64_t v33 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  if (*(unsigned char *)(*v4 + 57))
  {
    if (*(unsigned char *)(*v4 + 56)) {
      uint64_t v34 = "true";
    }
    else {
      uint64_t v34 = "false";
    }
  }
  else
  {
    uint64_t v34 = "<unspecified>";
  }
  CFStringAppendFormat(v33, 0, @"        isStreaming %s\n", v34);
  CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
  os_unfair_lock_lock_with_options();
  CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    concreteContexts [%zu] {\n", *(void *)&cf[16]._os_unfair_lock_opaque);
  uint64_t v35 = cf + 14;
  while (1)
  {
    uint64_t v35 = *(os_unfair_lock_s **)&v35->_os_unfair_lock_opaque;
    uint64_t v36 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (!v35) {
      break;
    }
    CFStringAppend(v36, @"        ");
    size_t v37 = *(void *)&v35[10]._os_unfair_lock_opaque;
    if (v37)
    {
      if (v37 >= 0x7FFFFFFFFFFFFFF8) {
        sub_1DC3127EC();
      }
      unint64_t v38 = *(const void **)&v35[8]._os_unfair_lock_opaque;
      if (v37 >= 0x17)
      {
        uint64_t v40 = (v37 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v37 | 7) != 0x17) {
          uint64_t v40 = v37 | 7;
        }
        uint64_t v41 = v40 + 1;
        unint64_t v39 = (void **)operator new(v40 + 1);
        __dst[1] = (void *)v37;
        int64_t v48 = v41 | 0x8000000000000000;
        __dst[0] = v39;
      }
      else
      {
        HIBYTE(v48) = *(void *)&v35[10]._os_unfair_lock_opaque;
        unint64_t v39 = __dst;
      }
      memmove(v39, v38, v37);
      *((unsigned char *)v39 + v37) = 0;
      char v42 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      if (v48 >= 0) {
        uint64_t v43 = __dst;
      }
      else {
        uint64_t v43 = (void **)__dst[0];
      }
      CFStringAppendFormat(v42, 0, @"<%s %p>", v43, *(void *)&v35[12]._os_unfair_lock_opaque);
      if (SHIBYTE(v48) < 0) {
        operator delete(__dst[0]);
      }
    }
    else
    {
      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"<ConcreteContext(classID=%p) %p>", *(void *)&v35[6]._os_unfair_lock_opaque, *(void *)&v35[12]._os_unfair_lock_opaque);
    }
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"\n");
  }
  CFStringAppend(v36, @"    }\n");
  os_unfair_lock_unlock(cf + 6);
  CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"}");
  CFStringRef Copy = CFStringCreateCopy(v3, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  sub_1DC326F90((atomic_ullong *)&Mutable);
  if (Copy) {
    return Copy;
  }
  return CFStringCreateWithFormat(v3, 0, @"<%s %p>", "MRCContext", cf);
}

void sub_1DC30E614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, os_unfair_lock_t lock, atomic_ullong a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

unint64_t sub_1DC30E690(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v2 != qword_1EBFFB818) {
      _os_assumes_log();
    }
  }
  unint64_t v3 = 0x9DDFEA08EB382D69
     * (((((((unint64_t)cf + 16) >> 3) & 0x3FFFFFF) << 6) | 8) ^ (((unint64_t)cf + 16) >> 32));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * ((((unint64_t)cf + 16) >> 32) ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69
                                                                                             * ((((unint64_t)cf
                                                                                                + 16) >> 32) ^ (v3 >> 47) ^ v3)) >> 47));
}

BOOL sub_1DC30E754(CFTypeRef cf, CFTypeRef a2)
{
  if (!cf) {
    goto LABEL_5;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (qword_1EBFFB7E0 != -1) {
    dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
  }
  if (v4 != qword_1EBFFB818)
  {
    _os_assumes_log();
    if (!a2) {
      return cf == a2;
    }
  }
  else
  {
LABEL_5:
    if (!a2) {
      return cf == a2;
    }
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (qword_1EBFFB7E0 != -1) {
    dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
  }
  if (v5 != qword_1EBFFB818) {
    _os_assumes_log();
  }
  return cf == a2;
}

uint64_t *sub_1DC30E84C(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v2 != qword_1EBFFB818) {
      _os_assumes_log();
    }
    CFTypeID v3 = CFGetTypeID(cf);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v3 != qword_1EBFFB818) {
      _os_assumes_log();
    }
  }
  dispatch_release(*((dispatch_object_t *)cf + 4));
  sub_1DC3C04F0((uint64_t)cf + 40);
  return sub_1DC3C052C((uint64_t *)cf + 2);
}

void *sub_1DC30E950()
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFB570) {
    _os_assumes_log();
  }
  if (qword_1EBFFB790) {
    _os_assumes_log();
  }
  qword_1EBFFB570 = (uint64_t)"MRCDecoderResult";
  qword_1EBFFB790 = _CFRuntimeRegisterClass();
  v1[0] = &unk_1F3664C28;
  v1[3] = v1;
  sub_1DC348EB8(qword_1EBFFB790, v1);
  return sub_1DC30AC9C(v1);
}

void sub_1DC30EA18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC30AC9C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC30EA34()
{
  return &unk_1F3664C88;
}

uint64_t sub_1DC30EA40(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc2CFINS_13DecoderResultENS_2cf6TraitsIS1_NS2_13PersonalitiesIS1_XtlNS_12fixed_stringILm16EEEtlNS_18basic_fixed_stringIcLm16ENSt3__111char_traitsIcEEEEtlA17_cLc77ELc82ELc67ELc68ELc101ELc99ELc111ELc100ELc101ELc114ELc82ELc101ELc115ELc117ELc108ELc116EEEEEJEEEEEE18registerClassOnce_EPvEUlPKvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

CFStringRef sub_1DC30EA7C@<X0>(CFTypeRef *a1@<X1>, CFStringRef *a2@<X8>)
{
  CFTypeID v3 = *a1;
  if (*a1)
  {
    CFTypeID v4 = CFGetTypeID(*a1);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v4 != qword_1EBFFB790) {
      _os_assumes_log();
    }
  }
  CFStringRef result = sub_1DC39E690(v3 + 2, 1);
  *a2 = result;
  return result;
}

void sub_1DC30EB20(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664C28;
}

void *sub_1DC30EB40()
{
  CFStringRef result = operator new(0x10uLL);
  *CFStringRef result = &unk_1F3664C28;
  return result;
}

void sub_1DC30EB78()
{
}

CFStringRef sub_1DC30EB90(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v2 != qword_1EBFFB790) {
      _os_assumes_log();
    }
  }
  CFStringRef result = sub_1DC39E690((void *)cf + 2, 0);
  if (!result) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s %p>", "MRCDecoderResult", cf);
  }
  return result;
}

CFHashCode sub_1DC30EC50(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v2 != qword_1EBFFB790) {
      _os_assumes_log();
    }
  }
  CFHashCode v3 = 3317042773;
  CFTypeID v4 = (atomic_ullong *)cf[2];
  CFTypeID v5 = (atomic_ullong *)cf[3];
  unint64_t v6 = 3317042773;
  if (v4 != v5)
  {
    unint64_t v7 = 0;
    do
    {
      unint64_t explicit = (const void *)atomic_load_explicit(v4, memory_order_acquire);
      CFHashCode v9 = 3317042773;
      if (explicit) {
        CFHashCode v9 = CFHash(explicit) + 2654435769u;
      }
      v7 ^= (v7 >> 2) + (v7 << 6) + v9;
      ++v4;
    }
    while (v4 != v5);
    unint64_t v6 = v7 + 2654435769u;
  }
  unint64_t v10 = (const void *)atomic_load_explicit(cf + 5, memory_order_acquire);
  if (v10) {
    CFHashCode v3 = CFHash(v10) + 2654435769u;
  }
  return (v3 + (v6 << 6) + (v6 >> 2)) ^ v6;
}

uint64_t sub_1DC30ED60(atomic_ullong *cf, atomic_ullong *a2)
{
  if (!cf) {
    goto LABEL_5;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (qword_1EBFFB7A8[0] != -1) {
    dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
  }
  if (v4 != qword_1EBFFB790)
  {
    _os_assumes_log();
    if (a2) {
      goto LABEL_6;
    }
  }
  else
  {
LABEL_5:
    if (a2)
    {
LABEL_6:
      CFTypeID v5 = CFGetTypeID(a2);
      if (qword_1EBFFB7A8[0] != -1) {
        dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
      }
      if (v5 != qword_1EBFFB790) {
        _os_assumes_log();
      }
    }
  }
  unint64_t v7 = (atomic_ullong *)cf[2];
  unint64_t v6 = (atomic_ullong *)cf[3];
  CGFloat v8 = (atomic_ullong *)a2[2];
  if ((char *)v6 - (char *)v7 != a2[3] - (void)v8) {
    return 0;
  }
  while (v7 != v6)
  {
    unint64_t explicit = (const void *)atomic_load_explicit(v8, memory_order_acquire);
    unint64_t v10 = (const void *)atomic_load_explicit(v7, memory_order_acquire);
    if (v10 != explicit)
    {
      if (explicit) {
        BOOL v11 = v10 == 0;
      }
      else {
        BOOL v11 = 1;
      }
      if (v11) {
        return 0;
      }
      uint64_t result = CFEqual(v10, explicit);
      if (!result) {
        return result;
      }
    }
    ++v7;
    ++v8;
  }
  unint64_t v13 = (const void *)atomic_load_explicit(a2 + 5, memory_order_acquire);
  unint64_t v14 = (const void *)atomic_load_explicit(cf + 5, memory_order_acquire);
  if (v14 == v13) {
    return 1;
  }
  BOOL v15 = !v13 || v14 == 0;
  return !v15 && CFEqual(v14, v13);
}

void sub_1DC30EED8(char *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v2 != qword_1EBFFB790) {
      _os_assumes_log();
    }
    CFTypeID v3 = CFGetTypeID(cf);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v3 != qword_1EBFFB790) {
      _os_assumes_log();
    }
  }
  sub_1DC306584((atomic_ullong *)cf + 5);
  CFTypeID v4 = (void **)(cf + 16);
  sub_1DC307038(&v4);
}

float sub_1DC30EFD4(float32x4_t *a1, int32x4_t *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  malloc_type_malloc(0x10uLL, 0x100004052888210uLL);
  uint64_t v4 = 0;
  v5.n128_u64[0] = 0;
  do
    v5.n128_f32[0] = v5.n128_f32[0] + a1->f32[v4++];
  while (v4 != 4);
  a2->i64[0] = -1;
  a2->i64[1] = -1;
  unint64_t v6 = (float *)MEMORY[0x1F4188790](v5);
  for (int i = 0; i != 4; ++i)
  {
    for (uint64_t j = 0; j != 4; ++j)
    {
      float v10 = a1->f32[j] / v7;
      int v11 = llroundf(v10);
      if (v11 >= 4) {
        int v11 = 4;
      }
      if (v11 <= 1) {
        int v11 = 1;
      }
      v30.i32[j] = v11;
      v6[j] = v10 - (float)v11;
    }
    int v12 = vaddvq_s32(v30);
    if (v12 >= 8)
    {
      while (1)
      {
        uint64_t v13 = 0;
        int v14 = 0;
        float v15 = *v6;
        do
        {
          if (v6[v13] < v15)
          {
            float v15 = v6[v13];
            int v14 = v13;
          }
          ++v13;
        }
        while (v13 != 4);
        uint64_t v16 = v14;
        __int32 v17 = v30.i32[v14];
        BOOL v18 = __OFSUB__(v17, 1);
        int v19 = v17 - 1;
        if (!((v19 < 0) ^ v18 | (v19 == 0))) {
          break;
        }
        if (!v19) {
          goto LABEL_18;
        }
LABEL_19:
        if (v12 <= 7) {
          goto LABEL_31;
        }
      }
      --v12;
      v30.i32[v16] = v19;
LABEL_18:
      v6[v16] = v6[v16] + 1.0;
      goto LABEL_19;
    }
    if (v12 != 7)
    {
      while (1)
      {
        uint64_t v20 = 0;
        int v21 = 0;
        float v22 = *v6;
        do
        {
          if (v6[v20] > v22)
          {
            float v22 = v6[v20];
            int v21 = v20;
          }
          ++v20;
        }
        while (v20 != 4);
        uint64_t v23 = v21;
        int v24 = v30.i32[v21];
        if (v24 < 4) {
          break;
        }
        if (v24 == 4) {
          goto LABEL_29;
        }
LABEL_30:
        if (v12 >= 7) {
          goto LABEL_31;
        }
      }
      ++v12;
      v30.i32[v23] = v24 + 1;
LABEL_29:
      v6[v23] = v6[v23] + -1.0;
      goto LABEL_30;
    }
LABEL_31:
    uint64_t v25 = 0;
    float32x4_t v26 = vmulq_f32(*a1, vcvtq_f32_s32(v30));
    float32x4_t v27 = vcvtq_f32_s32(vmulq_s32(v30, v30));
    float v7 = (float)((float)((float)((float)(v26.f32[0] + 0.0) + v26.f32[1]) + v26.f32[2]) + v26.f32[3])
       / (float)((float)((float)((float)(v27.f32[0] + 0.0) + v27.f32[1]) + v27.f32[2]) + v27.f32[3]);
    while (v30.i32[v25] == a2->i32[v25])
    {
      if (++v25 == 4) {
        goto LABEL_36;
      }
    }
    *a2 = v30;
  }
LABEL_36:
  float32x4_t v31 = *(float32x4_t *)v6;
  free(v6);
  float32x4_t v28 = vabsq_f32(v31);
  return (float)((float)((float)(v28.f32[0] + 0.0) + v28.f32[1]) + v28.f32[2]) + v28.f32[3];
}

uint64_t sub_1DC30F278(int32x4_t *a1, int a2, char a3)
{
  unint64_t v4 = 0;
  LODWORD(v5) = 0;
  uint64_t v6 = 0;
  int v7 = vaddvq_s32(*a1);
  char v31 = a3 ^ 1;
  uint64_t v30 = a2;
  int v24 = 1;
  float v22 = a1;
  do
  {
    int v8 = 1 << v4;
    uint64_t v9 = a1->u32[v4];
    if ((int)v9 < 2)
    {
      LODWORD(v5) = v8 | v5;
      LODWORD(v9) = 1;
    }
    else
    {
      uint64_t v10 = 1;
      int v11 = 1 - v4;
      int v23 = v7;
      uint64_t v32 = v7;
      int v25 = v4 - 3;
      int v26 = v4 - 4;
      uint64_t v5 = v5 & ~v8;
      uint64_t v28 = 3 - (int)v4;
      int64_t v29 = 3 - v4;
      uint64_t v33 = 2 - (int)v4;
      int v12 = 1;
      unint64_t v27 = v4;
      do
      {
        uint64_t v13 = v32 - v10;
        int v14 = sub_1DC30F458((int)v32 - (int)v10 - 1, v33);
        char v15 = v31;
        if (v12) {
          char v15 = 1;
        }
        if ((v15 & 1) == 0 && v29 <= v13 - v28) {
          v14 -= sub_1DC30F458(v26 + (int)v13, v33);
        }
        if (v4 > 1)
        {
          int v20 = v14 - (v13 > v30);
        }
        else
        {
          uint64_t v16 = v5;
          int v17 = v13 - v33;
          if (v13 - v33 <= v30)
          {
            int v18 = 0;
          }
          else
          {
            int v18 = 0;
            int v19 = v24;
            do
            {
              v18 += sub_1DC30F458(v19, v11);
              --v17;
              ++v19;
            }
            while (v17 > a2);
          }
          int v20 = v14 + v18 * v25;
          uint64_t v5 = v16;
          unint64_t v4 = v27;
        }
        uint64_t v6 = (v20 + v6);
        ++v10;
        int v12 = v5;
      }
      while (v10 != v9);
      a1 = v22;
      int v7 = v23;
    }
    v7 -= v9;
    ++v4;
    --v24;
  }
  while (v4 != 3);
  return v6;
}

uint64_t sub_1DC30F458(int a1, int a2)
{
  if (a1 - a2 <= a2) {
    int v2 = a2;
  }
  else {
    int v2 = a1 - a2;
  }
  if (a1 - a2 >= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a1 - a2;
  }
  if (v2 >= a1)
  {
    uint64_t result = 1;
    int v5 = 1;
  }
  else
  {
    int v4 = a1;
    int v5 = 1;
    LODWORD(result) = 1;
    do
    {
      uint64_t result = (v4 * result);
      if (v5 <= v3) {
        uint64_t result = ((int)result / v5++);
      }
      --v4;
    }
    while (v4 > v2);
  }
  if (v5 <= v3)
  {
    do
      uint64_t result = ((int)result / v5++);
    while (v3 + 1 != v5);
  }
  return result;
}

uint64_t sub_1DC30F4C8(uint64_t a1, uint64_t a2)
{
  sub_1DC3D566C();
  LODWORD(v56.x) = 0;
  BYTE4(v56.x) = 1;
  uint64_t result = sub_1DC3777A8(*(atomic_ullong **)(a1 + 8), (uint64_t)&v56);
  if (dword_1EBFFC218 < 1)
  {
    __int32 v14 = 0;
  }
  else
  {
    unsigned int v6 = (dword_1EBFFC218 + 3) & 0xFFFFFFFC;
    int32x4_t v7 = (int32x4_t)xmmword_1DC3FDC00;
    int8x16_t v8 = 0uLL;
    v9.i64[0] = 0x100000001;
    v9.i64[1] = 0x100000001;
    v10.i64[0] = 0x400000004;
    v10.i64[1] = 0x400000004;
    do
    {
      int8x16_t v11 = v8;
      uint32x4_t v12 = (uint32x4_t)v7;
      int8x16_t v8 = vorrq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)v7), v8);
      int32x4_t v7 = vaddq_s32(v7, v10);
      v6 -= 4;
    }
    while (v6);
    v5.i32[0] = dword_1EBFFC218 - 1;
    int8x16_t v13 = vbslq_s8((int8x16_t)vcgtq_u32(v12, (uint32x4_t)vdupq_lane_s32(v5, 0)), v11, v8);
    *(int8x8_t *)v13.i8 = vorr_s8(*(int8x8_t *)v13.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
    __int32 v14 = v13.i32[0] | v13.i32[1];
  }
  if ((v14 & result) == 0) {
    goto LABEL_33;
  }
  uint64_t v15 = *(void *)(a2 + 8);
  CGSize v16 = *(CGSize *)(v15 + 32);
  CGPoint v56 = *(CGPoint *)(v15 + 16);
  CGSize v57 = v16;
  v61.origin = v56;
  v61.size = v16;
  int v17 = CGRectIsInfinite(v61) ? (CGPoint *)(**(void **)(a2 + 8) + 8) : &v56;
  CGSize v18 = (CGSize)v17[1];
  CGPoint v56 = *v17;
  CGSize v57 = v18;
  int v54 = 0;
  char v55 = 1;
  int v19 = *(atomic_ullong **)(a1 + 8);
  int v20 = sub_1DC3777A8(v19, (uint64_t)&v54);
  BOOL v21 = v19[7] < 196608 || *(unsigned char *)(a2 + 32) == 0;
  BOOL v22 = !v21;
  if (v21)
  {
    double y = v56.y;
    double x = v56.x;
    float v47 = 0.0;
    double height = v57.height;
    double width = v57.width;
  }
  else
  {
    unint64_t v23 = sub_1DC328648((atomic_ullong *)(*(void *)(a2 + 24) + 120));
    uint64_t v24 = *(void *)(a2 + 24);
    double v25 = sub_1DC326F34(v24, 0.0);
    uint64_t v27 = v26;
    uint64_t v29 = v28;
    uint64_t v31 = v30;
    double v32 = *(double *)(v24 + 112);
    float v33 = *(double *)(v24 + 72);
    *(float *)&uint64_t v26 = *(double *)(v24 + 64);
    double v34 = (float)(atan2f(v33, *(float *)&v26) * -180.0) / 3.14159265;
    float v35 = v32;
    int v36 = (int)(v34 + fmodf(v35, 180.0));
    if (v36 > 90) {
      v36 -= 180;
    }
    int v37 = v36 >= -90 ? v36 : v36 + 180;
    BOOL v38 = v23 != 2 || HIDWORD(v23) == 0;
    int v20 = v38 ? v20 & 0xFFFF9FFF : 24576;
    long long v39 = *(_OWORD *)(v24 + 80);
    *(_OWORD *)&v53.a = *(_OWORD *)(v24 + 64);
    *(_OWORD *)&v53.CGFloat c = v39;
    *(_OWORD *)&v53.tdouble x = *(_OWORD *)(v24 + 96);
    double v40 = v25;
    *(void *)&long long v39 = v27;
    uint64_t v41 = v29;
    uint64_t v42 = v31;
    CGRect v58 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v39 - 8), &v53);
    double x = v58.origin.x;
    double y = v58.origin.y;
    double width = v58.size.width;
    double height = v58.size.height;
    float v47 = (float)v37;
  }
  v59.origin.double x = x;
  v59.origin.double y = y;
  v59.size.double width = width;
  v59.size.double height = height;
  uint64_t result = CGRectIsNull(v59);
  if (result) {
    goto LABEL_33;
  }
  v60.origin.double x = x;
  v60.origin.double y = y;
  v60.size.double width = width;
  v60.size.double height = height;
  uint64_t result = CGRectIsEmpty(v60);
  if ((result & 1) != 0
    || (int64_t v48 = (const UInt8 *)sub_1DC383CD0(**(atomic_ullong ***)(a2 + 8)),
        double v49 = CGRectGetWidth(*(CGRect *)(**(void **)(a2 + 8) + 8)),
        CGFloat v50 = CGRectGetHeight(*(CGRect *)(**(void **)(a2 + 8) + 8)),
        uint64_t result = sub_1DC3CDD84(a1, v48, (unint64_t)v49, (unint64_t)v50, *(void *)(**(void **)(a2 + 8) + 40), v20, v22, *(uint64_t **)a2, x, y, width, height, v47), result))
  {
LABEL_33:
    int v51 = *(__int16 **)(a2 + 64);
    __int16 v52 = 256;
  }
  else
  {
    int v51 = *(__int16 **)(a2 + 64);
    __int16 v52 = 257;
  }
  __int16 *v51 = v52;
  return result;
}

void sub_1DC30F7E8(void *a1)
{
}

atomic_uint **sub_1DC30F7FC@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  uint64_t v154 = *MEMORY[0x1E4F143B8];
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  (*(void (**)(atomic_uint **__return_ptr))(**(void **)(*(void *)a1 + 16) + 16))(&v129);
  sub_1DC321B30((uint64_t)&v130, (uint64_t *)&v129);
  sub_1DC2FF548(&v129);
  int v4 = *(void **)a2;
  uint64_t v107 = *(void **)(a2 + 8);
  if (*(void **)a2 != v107)
  {
    do
    {
      uint64_t v5 = *v4;
      if (*v4)
      {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
        atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
      }
      unint64_t v128 = (atomic_uint *)v5;
      int v126 = (atomic_uint *)v5;
      char v132 = *(unsigned char *)(v5 + 180);
      int v124 = v4;
      float v6 = (*(float (**)(uint64_t))(*(void *)v5 + 16))(v5);
      float v7 = (*(float (**)(atomic_uint *))(*(void *)v126 + 24))(v126);
      int8x16_t v8 = v131;
      if (v131) {
        atomic_fetch_add_explicit(v131 + 2, 1u, memory_order_relaxed);
      }
      float v133 = v8;
      BOOL v136 = 0;
      float v134 = 0;
      float v135 = 0;
      double v147 = COERCE_DOUBLE(&v134);
      LOBYTE(v148) = 0;
      uint32x4_t v9 = operator new(0x180uLL);
      uint64_t v10 = 0;
      uint64_t v11 = (int)v6;
      uint64_t v12 = (int)v7;
      uint64_t v13 = v11 | (v12 << 32);
      BOOL v136 = v9 + 24;
      *uint32x4_t v9 = 0u;
      v9[1] = 0u;
      v9[2] = 0u;
      v9[3] = 0u;
      v9[4] = 0u;
      v9[5] = 0u;
      v9[6] = 0u;
      v9[7] = 0u;
      v9[8] = 0u;
      v9[9] = 0u;
      v9[10] = 0u;
      v9[11] = 0u;
      v9[12] = 0u;
      v9[13] = 0u;
      v9[14] = 0u;
      v9[15] = 0u;
      v9[16] = 0u;
      v9[17] = 0u;
      v9[18] = 0u;
      v9[19] = 0u;
      v9[20] = 0u;
      v9[21] = 0u;
      v9[22] = 0u;
      v9[23] = 0u;
      uint64_t v14 = (int)v11;
      uint64_t v15 = (int)v12;
      float v134 = v9;
      float v135 = v9 + 24;
      do
      {
        CGSize v16 = (char *)&unk_1DC3FDEC8;
        int v17 = &unk_1DC3FDED0;
        switch((int)v10)
        {
          case 0:
            break;
          case 1:
            CGSize v16 = (char *)&unk_1DC3FDF08;
            goto LABEL_20;
          case 2:
            CGSize v16 = (char *)&unk_1DC3FDED0;
            goto LABEL_24;
          case 3:
            CGSize v16 = (char *)&unk_1DC3FDF30;
            goto LABEL_20;
          case 4:
            CGSize v16 = (char *)&unk_1DC3FDED8;
            goto LABEL_24;
          case 5:
            CGSize v16 = (char *)&unk_1DC3FDF58;
            goto LABEL_20;
          case 6:
            CGSize v16 = (char *)&unk_1DC3FDEE0;
            goto LABEL_24;
          case 7:
            CGSize v16 = (char *)&unk_1DC3FDF80;
            goto LABEL_20;
          case 8:
            CGSize v16 = (char *)&unk_1DC3FDEE8;
            goto LABEL_24;
          case 9:
            CGSize v16 = (char *)&unk_1DC3FDFA8;
            goto LABEL_20;
          case 10:
            CGSize v16 = (char *)&unk_1DC3FDEF0;
            goto LABEL_24;
          case 11:
            CGSize v16 = (char *)&unk_1DC3FDFD0;
            goto LABEL_20;
          case 12:
            CGSize v16 = (char *)&unk_1DC3FDEF8;
            goto LABEL_24;
          case 13:
            CGSize v16 = (char *)&unk_1DC3FDFF8;
            goto LABEL_20;
          case 14:
            CGSize v16 = (char *)&unk_1DC3FDF00;
LABEL_24:
            int v17 = v16 + 8;
            break;
          case 15:
            CGSize v16 = (char *)&unk_1DC3FE020;
LABEL_20:
            int v17 = v16 + 40;
            break;
          default:
            CGSize v16 = 0;
            int v17 = 0;
            break;
        }
        CGSize v18 = v133;
        int v19 = v133 + 2;
        atomic_fetch_add_explicit(v133 + 2, 1u, memory_order_relaxed);
        uint64_t v144 = v18;
        uint64_t v20 = *((void *)v18 + 7);
        uint64_t v21 = -v20;
        uint64_t v22 = *((void *)v18 + 4);
        uint64_t v23 = v22 & -v20--;
        uint64_t v24 = *((void *)v18 + 2);
        unint64_t v25 = v24 & v20 | v23;
        unint64_t v26 = v22 & v20 | v24 & v21;
        atomic_fetch_add_explicit(v19, 1u, memory_order_relaxed);
        int v146 = v18;
        if (v25 > v26) {
          LODWORD(v26) = v25;
        }
        LOBYTE(v147) = 0;
        CGFloat v148 = 0;
        atomic_fetch_add_explicit(v19, 1u, memory_order_relaxed);
        CGFloat v148 = v18;
        *(void *)&long long v149 = v13;
        *((void *)&v149 + 1) = v16;
        *(void *)&long long v150 = v17;
        *((void *)&v150 + 1) = v16;
        *(void *)&long long v151 = v17;
        *((void *)&v151 + 1) = v13;
        *(void *)&long long v152 = 0;
        *((void *)&v152 + 1) = 0x300000000;
        *(void *)&long long v153 = 0;
        *((void *)&v153 + 1) = v26;
        if (sub_1DC2FF8BC((uint64_t)&v147))
        {
          LOBYTE(v147) = sub_1DC2FF924(v18, v14, v15);
          sub_1DC2FF700((uint64_t)&v147);
        }
        sub_1DC2FF548(&v146);
        sub_1DC2FF548(&v144);
        LOBYTE(v137) = LOBYTE(v147);
        unint64_t v138 = 0;
        uint64_t v27 = v148;
        if (v148)
        {
          atomic_fetch_add_explicit(v148 + 2, 1u, memory_order_relaxed);
          if (v138) {
            sub_1DC2FF57C(v138);
          }
        }
        unint64_t v138 = v27;
        long long v142 = v152;
        long long v143 = v153;
        long long v140 = v150;
        long long v141 = v151;
        long long v139 = v149;
        int v145 = (char **)&v134[3 * v10];
        sub_1DC2FF604(&v145, *((uint64_t *)&v151 + 1));
        int v28 = -3;
        do
        {
          sub_1DC2FF700((uint64_t)&v137);
          sub_1DC2FF604(&v145, *((uint64_t *)&v141 + 1));
        }
        while (!__CFADD__(v28++, 1));
        sub_1DC2FF548(&v138);
        sub_1DC2FF548(&v148);
        ++v10;
      }
      while (v10 != 16);
      sub_1DC2FF548(&v133);
      uint64_t v119 = *(void *)(v134[3] + 24);
      uint64_t v116 = *(void *)(*v134 + 24);
      uint64_t v114 = *(void *)(v134[6] + 24);
      uint64_t v30 = *(void *)(v134[12] + 24);
      uint64_t v122 = *(void *)(v134[15] + 24);
      uint64_t v123 = *(void *)(v134[45] + 24);
      uint64_t v31 = *(void *)(v134[18] + 24);
      uint64_t v120 = *(void *)(v134[9] + 24);
      uint64_t v121 = *(void *)(v134[21] + 24);
      uint64_t v32 = *(void *)(v134[24] + 24);
      uint64_t v33 = *(void *)(v134[27] + 24);
      uint64_t v34 = *(void *)(v134[30] + 24);
      uint64_t v35 = *(void *)(v134[33] + 24);
      unint64_t v36 = *(void *)(v134[36] + 24);
      uint64_t v118 = *(void *)(v134[39] + 24);
      uint64_t v37 = *(void *)(v134[42] + 24);
      BOOL v38 = (char *)operator new(0xC0uLL);
      int v39 = v36;
      v36 >>= 32;
      *(void *)BOOL v38 = (HIDWORD(v123) - HIDWORD(v119)) | ((unint64_t)(v119 - v123) << 32);
      *((_DWORD *)v38 + 2) = HIDWORD(v119) * v123 - v119 * HIDWORD(v123);
      *(void *)(v38 + 12) = (HIDWORD(v116) - HIDWORD(v114)) | ((unint64_t)(v114 - v116) << 32);
      *((_DWORD *)v38 + 5) = HIDWORD(v114) * v116 - v114 * HIDWORD(v116);
      *((void *)v38 + 3) = (HIDWORD(v119) - HIDWORD(v120)) | ((unint64_t)(v120 - v119) << 32);
      *((_DWORD *)v38 + 8) = HIDWORD(v120) * v119 - v120 * HIDWORD(v119);
      *(void *)(v38 + 36) = (HIDWORD(v114) - HIDWORD(v30)) | ((unint64_t)(v30 - v114) << 32);
      *((_DWORD *)v38 + 11) = HIDWORD(v30) * v114 - v30 * HIDWORD(v114);
      *((void *)v38 + 6) = (HIDWORD(v120) - HIDWORD(v122)) | ((unint64_t)(v122 - v120) << 32);
      *((_DWORD *)v38 + 14) = HIDWORD(v122) * v120 - v122 * HIDWORD(v120);
      *(void *)(v38 + 60) = (HIDWORD(v30) - HIDWORD(v31)) | ((unint64_t)(v31 - v30) << 32);
      *((_DWORD *)v38 + 17) = HIDWORD(v31) * v30 - v31 * HIDWORD(v30);
      *((void *)v38 + 9) = (HIDWORD(v122) - HIDWORD(v121)) | ((unint64_t)(v121 - v122) << 32);
      *(void *)(v38 + 84) = (HIDWORD(v31) - HIDWORD(v32)) | ((unint64_t)(v32 - v31) << 32);
      *((_DWORD *)v38 + 20) = HIDWORD(v121) * v122 - v121 * HIDWORD(v122);
      *((_DWORD *)v38 + 23) = HIDWORD(v32) * v31 - v32 * HIDWORD(v31);
      *((void *)v38 + 12) = (HIDWORD(v121) - HIDWORD(v33)) | ((unint64_t)(v33 - v121) << 32);
      *((_DWORD *)v38 + 26) = HIDWORD(v33) * v121 - v33 * HIDWORD(v121);
      *(void *)(v38 + 108) = (HIDWORD(v32) - HIDWORD(v34)) | ((unint64_t)(v34 - v32) << 32);
      *((void *)v38 + 15) = (HIDWORD(v33) - HIDWORD(v35)) | ((unint64_t)(v35 - v33) << 32);
      *((_DWORD *)v38 + 29) = HIDWORD(v34) * v32 - v34 * HIDWORD(v32);
      *((_DWORD *)v38 + 32) = HIDWORD(v35) * v33 - v35 * HIDWORD(v33);
      *(void *)(v38 + 132) = (HIDWORD(v34) - v36) | ((unint64_t)(v39 - v34) << 32);
      *((_DWORD *)v38 + 35) = v36 * v34 - v39 * HIDWORD(v34);
      *((_DWORD *)v38 + 38) = HIDWORD(v118) * v35 - v118 * HIDWORD(v35);
      *((_DWORD *)v38 + 41) = HIDWORD(v37) * v39 - v37 * v36;
      *((_DWORD *)v38 + 44) = HIDWORD(v123) * v118 - v123 * HIDWORD(v118);
      *((_DWORD *)v38 + 47) = HIDWORD(v116) * v37 - v116 * HIDWORD(v37);
      *((void *)v38 + 18) = (HIDWORD(v35) - HIDWORD(v118)) | ((unint64_t)(v118 - v35) << 32);
      *(void *)(v38 + 156) = (v36 - HIDWORD(v37)) | ((unint64_t)(v37 - v39) << 32);
      double v40 = v134;
      *((void *)v38 + 21) = (HIDWORD(v118) - HIDWORD(v123)) | ((unint64_t)(v123 - v118) << 32);
      *(void *)(v38 + 180) = (HIDWORD(v37) - HIDWORD(v116)) | ((unint64_t)(v116 - v37) << 32);
      sub_1DC2FFA6C(*(_DWORD *)(*v40 + 24), *(_DWORD *)(*v40 + 28), (uint64_t)v38);
      uint64_t v113 = v41;
      sub_1DC2FFA6C(*(_DWORD *)(v40[3] + 24), *(_DWORD *)(v40[3] + 28), (uint64_t)(v38 + 12));
      uint64_t v112 = v42;
      sub_1DC2FFA6C(*(_DWORD *)(v40[6] + 24), *(_DWORD *)(v40[6] + 28), (uint64_t)(v38 + 24));
      uint64_t v111 = v43;
      sub_1DC2FFA6C(*(_DWORD *)(v40[9] + 24), *(_DWORD *)(v40[9] + 28), (uint64_t)(v38 + 36));
      uint64_t v110 = v44;
      sub_1DC2FFA6C(*(_DWORD *)(v40[12] + 24), *(_DWORD *)(v40[12] + 28), (uint64_t)(v38 + 48));
      uint64_t v109 = v45;
      sub_1DC2FFA6C(*(_DWORD *)(v40[15] + 24), *(_DWORD *)(v40[15] + 28), (uint64_t)(v38 + 60));
      uint64_t v115 = v46;
      sub_1DC2FFA6C(*(_DWORD *)(v40[18] + 24), *(_DWORD *)(v40[18] + 28), (uint64_t)(v38 + 72));
      uint64_t v108 = v47;
      sub_1DC2FFA6C(*(_DWORD *)(v40[21] + 24), *(_DWORD *)(v40[21] + 28), (uint64_t)(v38 + 84));
      uint64_t v117 = v48;
      sub_1DC2FFA6C(*(_DWORD *)(v40[24] + 24), *(_DWORD *)(v40[24] + 28), (uint64_t)(v38 + 96));
      uint64_t v50 = v49;
      sub_1DC2FFA6C(*(_DWORD *)(v40[27] + 24), *(_DWORD *)(v40[27] + 28), (uint64_t)(v38 + 108));
      uint64_t v52 = v51;
      sub_1DC2FFA6C(*(_DWORD *)(v40[30] + 24), *(_DWORD *)(v40[30] + 28), (uint64_t)(v38 + 120));
      uint64_t v54 = v53;
      sub_1DC2FFA6C(*(_DWORD *)(v40[33] + 24), *(_DWORD *)(v40[33] + 28), (uint64_t)(v38 + 132));
      uint64_t v56 = v55;
      sub_1DC2FFA6C(*(_DWORD *)(v40[36] + 24), *(_DWORD *)(v40[36] + 28), (uint64_t)(v38 + 144));
      uint64_t v58 = v57;
      sub_1DC2FFA6C(*(_DWORD *)(v40[39] + 24), *(_DWORD *)(v40[39] + 28), (uint64_t)(v38 + 156));
      uint64_t v60 = v59;
      sub_1DC2FFA6C(*(_DWORD *)(v40[42] + 24), *(_DWORD *)(v40[42] + 28), (uint64_t)(v38 + 168));
      uint64_t v62 = v61;
      sub_1DC2FFA6C(*(_DWORD *)(v40[45] + 24), *(_DWORD *)(v40[45] + 28), (uint64_t)(v38 + 180));
      uint64_t v64 = v63;
      unint64_t v65 = operator new(0x80uLL);
      int v66 = v65;
      uint64_t v67 = 0;
      *unint64_t v65 = v113;
      v65[1] = v112;
      v65[2] = v111;
      v65[3] = v110;
      v65[4] = v109;
      v65[5] = v115;
      v65[6] = v108;
      v65[7] = v117;
      v65[8] = v50;
      v65[9] = v52;
      v65[10] = v54;
      v65[11] = v56;
      v65[12] = v58;
      v65[13] = v60;
      uint64_t v68 = (char *)&unk_1DC3FE048;
      v65[14] = v62;
      v65[15] = v64;
      do
      {
        uint64_t v69 = 0;
        double v70 = 0.0;
        do
        {
          double v70 = *(double *)&v65[*(int *)&v68[v69]] + v70;
          v69 += 4;
        }
        while (v69 != 16);
        *(&v147 + v67++) = v70;
        v68 += 16;
      }
      while (v67 != 4);
      uint64_t v71 = (void ***)&v147;
      *(double *)&CFTypeRef v72 = v147;
      for (uint64_t i = 8; i != 32; i += 8)
      {
        if (*(double *)((char *)&v147 + i) < *(double *)&v72)
        {
          CFTypeRef v72 = *(void ***)((char *)&v147 + i);
          uint64_t v71 = (void ***)((char *)&v147 + i);
        }
      }
      uint64_t v74 = (char *)v71 - (char *)&v147;
      int v75 = (int *)((char *)&unk_1DC3FE048 + 2 * ((char *)v71 - (char *)&v147));
      uint64_t v76 = (uint64_t)&v38[12 * *v75];
      uint64_t v77 = (uint64_t)&v38[12 * v75[1]];
      double v78 = sub_1DC2FFAE0(v76, v77);
      uint64_t v80 = v79;
      uint64_t v81 = (uint64_t)&v38[12 * v75[2]];
      double v82 = sub_1DC2FFAE0(v77, v81);
      uint64_t v84 = v83;
      uint64_t v85 = (uint64_t)&v38[12 * v75[3]];
      double v86 = sub_1DC2FFAE0(v81, v85);
      uint64_t v88 = v87;
      double v89 = sub_1DC2FFAE0(v85, v76);
      uint64_t v91 = v90;
      long long v92 = (double *)operator new(0x40uLL);
      *long long v92 = v78;
      *((void *)v92 + 1) = v80;
      v92[2] = v82;
      *((void *)v92 + 3) = v84;
      v92[4] = v86;
      *((void *)v92 + 5) = v88;
      v92[6] = v89;
      *((void *)v92 + 7) = v91;
      uint64_t v93 = operator new(0x40uLL);
      long long v94 = *((_OWORD *)v92 + 1);
      _OWORD *v93 = *(_OWORD *)v92;
      v93[1] = v94;
      long long v95 = *((_OWORD *)v92 + 3);
      v93[2] = *((_OWORD *)v92 + 2);
      v93[3] = v95;
      BOOL v96 = *((void ***)&v147 + (v74 >> 3));
      operator delete(v92);
      operator delete(v66);
      operator delete(v38);
      unint64_t v97 = 0;
      BOOL v98 = 0;
      double v99 = 1.79769313e308;
      uint64_t v100 = 16;
LABEL_46:
      unint64_t v101 = v97++;
      uint64_t v102 = v100;
      while (1)
      {
        float64x2_t v103 = vsubq_f64((float64x2_t)v93[v101], *(float64x2_t *)((char *)v93 + v102));
        double v104 = sqrt(vaddvq_f64(vmulq_f64(v103, v103)));
        if (v104 < 15.0) {
          break;
        }
        if (v104 < v99) {
          double v99 = v104;
        }
        v102 += 16;
        if (v102 == 64)
        {
          BOOL v98 = v101 > 1;
          v100 += 16;
          if (v97 != 3) {
            goto LABEL_46;
          }
          BOOL v98 = 1;
          break;
        }
      }
      if (v98 && v99 > *(double *)&v96) {
        sub_1DC353CE0();
      }
      BOOL v127 = 0;
      operator delete(v93);
      double v147 = COERCE_DOUBLE(&v134);
      sub_1DC2FF82C((void ***)&v147);
      sub_1DC311694(&v126);
      if (v127)
      {
        double v147 = 0.0;
        CGFloat v148 = 0;
        *(void *)&long long v149 = 0;
        sub_1DC2FFB5C((atomic_uint *)&v147, *((void *)v127 + 2), *((void *)v127 + 3), (uint64_t)(*((void *)v127 + 3) - *((void *)v127 + 2)) >> 3);
        unint64_t v105 = v127;
        if (v127) {
          atomic_fetch_add_explicit(v127 + 2, 1u, memory_order_relaxed);
        }
        int v125 = v105;
        sub_1DC312834((uint64_t)&v134, (uint64_t)&v125);
      }
      sub_1DC3116C8(&v127);
      sub_1DC311694(&v128);
      int v4 = v124 + 1;
    }
    while (v124 + 1 != v107);
  }
  float v130 = &unk_1F3661570;
  return sub_1DC2FF548(&v131);
}

void sub_1DC3115F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, atomic_uint **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,atomic_uint *a56,uint64_t a57,void *a58)
{
  sub_1DC311694(&a56);
  a58 = &unk_1F3661570;
  sub_1DC2FF548(a13);
  *(void *)(v58 - 256) = a18;
  sub_1DC311C68((void ***)(v58 - 256));
  JUMPOUT(0x1DC31164CLL);
}

atomic_uint **sub_1DC311694(atomic_uint **a1)
{
  int v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

atomic_uint **sub_1DC3116C8(atomic_uint **a1)
{
  int v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t *sub_1DC3116FC(uint64_t **a1, int a2, unsigned int *a3)
{
  float v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        float v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        float v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        float v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    float v7 = a1 + 1;
LABEL_9:
    uint32x4_t v9 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v9 + 28) = *a3;
    sub_1DC311D78(a1, (uint64_t)v7, v6, v9);
    return v9;
  }
  return (uint64_t *)v7;
}

uint64_t sub_1DC3117A4(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  int v3 = (uint64_t **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  int v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      float v6 = *(uint64_t **)(a1 + 8);
      float v7 = v3;
      if (*(uint64_t ***)a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v8 = *(void *)(a1 + 8);
      uint32x4_t v9 = v3;
      if (v6)
      {
        do
        {
          float v7 = (uint64_t **)v8;
          uint64_t v8 = *(void *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          float v7 = (uint64_t **)v9[2];
          BOOL v10 = *v7 == (uint64_t *)v9;
          uint32x4_t v9 = v7;
        }
        while (v10);
      }
      int v11 = *((_DWORD *)v5 + 7);
      if (*((_DWORD *)v7 + 7) < v11)
      {
LABEL_8:
        if (v6) {
          uint64_t v12 = v7;
        }
        else {
          uint64_t v12 = v3;
        }
        if (v6) {
          uint64_t v13 = v7 + 1;
        }
        else {
          uint64_t v13 = v3;
        }
      }
      else
      {
        uint64_t v12 = v3;
        uint64_t v13 = v3;
        if (v6)
        {
          uint64_t v13 = v3;
          while (1)
          {
            while (1)
            {
              uint64_t v12 = (uint64_t **)v6;
              int v17 = *((_DWORD *)v6 + 7);
              if (v11 >= v17) {
                break;
              }
              float v6 = *v12;
              uint64_t v13 = v12;
              if (!*v12) {
                goto LABEL_15;
              }
            }
            if (v17 >= v11) {
              break;
            }
            uint64_t v13 = v12 + 1;
            float v6 = v12[1];
            if (!v6) {
              goto LABEL_15;
            }
          }
        }
      }
      if (!*v13)
      {
LABEL_15:
        uint64_t v14 = (uint64_t *)operator new(0x28uLL);
        *(uint64_t *)((char *)v14 + 28) = *(void *)((char *)v5 + 28);
        sub_1DC311D78((uint64_t **)a1, (uint64_t)v12, v13, v14);
      }
      uint64_t v15 = (void *)v5[1];
      if (v15)
      {
        do
        {
          CGSize v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          CGSize v16 = (void *)v5[2];
          BOOL v10 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v10);
      }
      uint64_t v5 = v16;
    }
    while (v16 != v4);
  }
  return a1;
}

void sub_1DC311908(_Unwind_Exception *a1)
{
  sub_1DC31191C(*v1);
  _Unwind_Resume(a1);
}

void sub_1DC31191C(void *a1)
{
  if (a1)
  {
    sub_1DC31191C(*a1);
    sub_1DC31191C(a1[1]);
    operator delete(a1);
  }
}

void *sub_1DC311968(void *a1)
{
  *a1 = &unk_1F3661908;
  int v2 = (atomic_uint *)a1[2];
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  a1[2] = 0;
  return a1;
}

atomic_uint **sub_1DC3119BC(atomic_uint **a1)
{
  int v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

atomic_uint *sub_1DC3119F0(atomic_uint *result, atomic_uint **a2)
{
  int v2 = result;
  int v3 = (atomic_uint **)*((void *)result + 1);
  void *v3 = 0;
  int v4 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    uint64_t result = *v3;
    if (*v3) {
      uint64_t result = sub_1DC2FF57C(result);
    }
  }
  void *v3 = v4;
  *((void *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1DC311A48(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC311A50(atomic_uint ***a1, atomic_uint **a2)
{
  uint64_t v2 = a1[1] - *a1;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  float v6 = a1 + 2;
  uint64_t v7 = (char *)a1[2] - (char *)*a1;
  if (v7 >> 2 > v3) {
    unint64_t v3 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v3;
  }
  uint64_t v27 = v6;
  if (v8) {
    unint64_t v8 = (unint64_t)sub_1DC2FFD7C(v8);
  }
  else {
    uint64_t v9 = 0;
  }
  BOOL v10 = (atomic_uint **)(v8 + 8 * v2);
  unint64_t v24 = v8;
  v25.i64[0] = (uint64_t)v10;
  v25.i64[1] = (uint64_t)v10;
  unint64_t v26 = v8 + 8 * v9;
  *BOOL v10 = 0;
  int v11 = *a2;
  uint64_t v12 = v10;
  uint64_t v13 = v10;
  if (v11)
  {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    uint64_t v12 = v10;
    uint64_t v13 = v10;
    if (*v10)
    {
      sub_1DC2FF57C(*v10);
      uint64_t v13 = (atomic_uint **)v25.i64[1];
      uint64_t v12 = (atomic_uint **)v25.i64[0];
    }
  }
  *BOOL v10 = v11;
  uint64_t v14 = v13 + 1;
  v25.i64[1] = (uint64_t)(v13 + 1);
  CGSize v16 = *a1;
  unint64_t v15 = (unint64_t)a1[1];
  if ((atomic_uint **)v15 == *a1)
  {
    int64x2_t v21 = vdupq_n_s64(v15);
  }
  else
  {
    uint64_t v17 = 0;
    do
    {
      CGSize v18 = &v12[v17];
      v12[v17 - 1] = 0;
      int v19 = *(atomic_uint **)(v15 + v17 * 8 - 8);
      if (v19)
      {
        atomic_fetch_add_explicit(v19 + 2, 1u, memory_order_relaxed);
        uint64_t v20 = *(v18 - 1);
        if (v20) {
          sub_1DC2FF57C(v20);
        }
      }
      *(v18 - 1) = v19;
      --v17;
    }
    while ((atomic_uint **)(v15 + v17 * 8) != v16);
    uint64_t v12 = (atomic_uint **)((char *)v12 + v17 * 8);
    int64x2_t v21 = *(int64x2_t *)a1;
    uint64_t v14 = (atomic_uint **)v25.i64[1];
  }
  *a1 = v12;
  a1[1] = v14;
  int64x2_t v25 = v21;
  unint64_t v22 = (unint64_t)a1[2];
  a1[2] = (atomic_uint **)v26;
  unint64_t v26 = v22;
  unint64_t v24 = v21.i64[0];
  sub_1DC311CEC((uint64_t)&v24);
  return v14;
}

void sub_1DC311BCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC311CEC((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC311C00(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

atomic_uint **sub_1DC311C34(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC311C68(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (atomic_uint **)**a1;
  if (v2)
  {
    int v4 = (atomic_uint **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        int v4 = sub_1DC311C00(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1DC311CEC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC311C00((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DC311D3C(void *a1)
{
  sub_1DC311968(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t *sub_1DC311D78(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  uint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = sub_1DC311DD0(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_1DC311DD0(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      int v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            BOOL v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *uint64_t v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), uint64_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *uint64_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void sub_1DC311F68(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661570;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC311FCC(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661570;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1DC312010(uint64_t a1@<X0>, atomic_uint **a2@<X1>, uint64_t *a3@<X2>, long long *a4@<X3>, atomic_uint **a5@<X8>)
{
  v28[1] = *(void ***)MEMORY[0x1E4F143B8];
  uint64_t v9 = *a3;
  if (*a3) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 1u, memory_order_relaxed);
  }
  v28[0] = (void **)v9;
  unint64_t v26 = 0;
  uint64_t v27 = 0;
  int64x2_t v25 = 0;
  uint64_t v23 = (void **)&v25;
  LOBYTE(v24) = 0;
  BOOL v10 = operator new(8uLL);
  uint64_t v11 = (void ***)v10;
  int64x2_t v25 = v10;
  unint64_t v26 = v10;
  *BOOL v10 = 0;
  uint64_t v12 = v10 + 1;
  uint64_t v27 = v10 + 1;
  uint64_t v13 = v28[0];
  if (v28[0])
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)v28[0] + 2, 1u, memory_order_relaxed);
    uint64_t v14 = (atomic_uint *)*v10;
    if (*v11) {
      sub_1DC2FF57C(v14);
    }
  }
  *uint64_t v11 = v13;
  unint64_t v26 = v12;
  sub_1DC311694((atomic_uint **)v28);
  unint64_t v15 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v15 + 2, 1u, memory_order_relaxed);
  }
  unint64_t v22 = v15;
  long long v19 = *a4;
  char v20 = *((unsigned char *)a4 + 16);
  CGSize v16 = (atomic_uint *)*((void *)a4 + 3);
  if (v16) {
    atomic_fetch_add_explicit(v16 + 2, 1u, memory_order_relaxed);
  }
  int64x2_t v21 = v16;
  (*(void (**)(void ***__return_ptr, uint64_t, atomic_uint **, void **, long long *))(*(void *)a1 + 40))(&v23, a1, &v22, &v25, &v19);
  sub_1DC3122B8(&v21);
  sub_1DC3122EC(&v22);
  uint64_t v17 = v23;
  if (v24 - (void)v23 == 8)
  {
    *a5 = 0;
    CGSize v18 = (atomic_uint *)*v17;
    if (v18) {
      atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
    }
  }
  else
  {
    CGSize v18 = 0;
  }
  *a5 = v18;
  v28[0] = (void **)&v23;
  sub_1DC311C68(v28);
  uint64_t v23 = (void **)&v25;
  sub_1DC312234(&v23);
}

void sub_1DC3121E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DC312234((void ***)va);
  sub_1DC311694((atomic_uint **)(v7 - 80));
  _Unwind_Resume(a1);
}

void sub_1DC312234(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (atomic_uint **)**a1;
  if (v2)
  {
    int v4 = (atomic_uint **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        int v4 = sub_1DC311694(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

atomic_uint **sub_1DC3122B8(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

atomic_uint **sub_1DC3122EC(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

atomic_uint **sub_1DC312320(uint64_t a1, atomic_uint **a2)
{
  uint64_t v2 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v2 + 2, 1u, memory_order_relaxed);
  }
  int v4 = v2;
  (*(void (**)(uint64_t, atomic_uint **))(*(void *)a1 + 16))(a1, &v4);
  return sub_1DC3122EC(&v4);
}

void sub_1DC31238C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3122EC((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1DC3123A0(uint64_t a1@<X1>, void *a2@<X8>)
{
  *a2 = 0;
  (*(void (**)(atomic_uint **__return_ptr))(**(void **)(*(void *)a1 + 16) + 16))(&v3);
  sub_1DC321B30((uint64_t)v4, (uint64_t *)&v3);
  sub_1DC2FF548(&v3);
  sub_1DC321BAC((uint64_t)&v2, (uint64_t)v4);
}

void sub_1DC312568(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, atomic_uint *a18, uint64_t a19, atomic_uint *a20,char a21)
{
  sub_1DC31191C(a10);
  *(void *)(v22 - 40) = &a12;
  sub_1DC2FFC48((void ***)(v22 - 40));
  sub_1DC311968(&a15);
  sub_1DC3119BC(&a18);
  MEMORY[0x1E019CE90](v21, 0x10A1C4006AAC113);
  sub_1DC311C34(&a20);
  *(void *)(v22 - 40) = &a21;
  sub_1DC2FFC48((void ***)(v22 - 40));
  sub_1DC3116C8((atomic_uint **)(v22 - 104));
  *(void *)(v22 - 88) = &unk_1F3661570;
  sub_1DC2FF548((atomic_uint **)(v22 - 72));
  if (a2 == 2)
  {
    exception_ptr = __cxa_get_exception_ptr(a1);
    sub_1DC3126D0((void *)(v22 - 88), (uint64_t)exception_ptr);
    __cxa_begin_catch(a1);
    sub_1DC379B0C((std::exception *)(v22 - 88));
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1DC312554);
}

void sub_1DC31266C(_Unwind_Exception *a1)
{
  sub_1DC311C00(v1);
  _Unwind_Resume(a1);
}

void sub_1DC312688(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_1DC3116C8((atomic_uint **)va);
  JUMPOUT(0x1DC3125E8);
}

void sub_1DC31269C()
{
}

void sub_1DC3126A8()
{
}

void sub_1DC3126B4()
{
}

void sub_1DC3126C4()
{
}

void *sub_1DC3126D0(void *a1, uint64_t a2)
{
  *a1 = &unk_1F36619D8;
  uint64_t v3 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1DC312750(v3, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v3 = v4;
  }
  return a1;
}

void sub_1DC31273C(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DC312750(unsigned char *__dst, void *__src, unint64_t a3)
{
  uint64_t v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      sub_1DC3127EC();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    int v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    *uint64_t v5 = v8;
    uint64_t v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, a3 + 1);
}

void sub_1DC3127EC()
{
}

void sub_1DC312804()
{
}

void sub_1DC31281C()
{
}

void sub_1DC312834(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(*(void *)a2 + 88);
  int v3 = *(_DWORD *)(*(void *)a2 + 96);
  uint64_t v4 = *(void *)(*(void *)a2 + 64);
  if (v4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
  }
  if (!v2)
  {
    uint64_t v5 = *(void *)(*(void *)a2 + 64);
    if (v5) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
    }
    operator new();
  }
  if (v4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v57 = (void *)v4;
  if (v3 < 6)
  {
    sub_1DC314F54(&v58, dword_1DC400E20[v3]);
    uint64_t v6 = v58;
    if (v3)
    {
      int v7 = 0;
      unsigned int v8 = 0;
      int v9 = v57[4] & (v57[7] - 1) | v57[2] & -(int)v57[7];
      int v53 = (2 * v9) | 1;
      uint64_t v10 = v9;
      int v11 = 2 * v9 - 4;
      int v12 = 8 * v9 - 24;
      int v13 = 8 * v9 - 16;
      int v52 = 6 * v9 - 12;
      int v14 = 8 * v9 - 40;
      int v51 = 4 * v9 - 8;
      int v15 = 8 * v9 - 32;
      int v16 = v11;
      int v17 = v3;
      do
      {
        int v44 = v17;
        int v45 = v16;
        int v46 = v12;
        int v47 = v13;
        int v48 = v14;
        int v49 = v15;
        uint64_t v55 = v11;
        uint64_t v56 = v7;
        if (v16 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v16;
        }
        if (v10 >= 3)
        {
          uint64_t v19 = 0;
          int v20 = 0;
          do
          {
            int v21 = sub_1DC2FF924(v57, v20 | v8, v8 + (v19 >> 1));
            unint64_t v22 = (unint64_t)(v56 + v19) >> 6;
            uint64_t v23 = 1 << (v56 + v19);
            if (v21) {
              uint64_t v24 = *(void *)(v6 + 8 * v22) | v23;
            }
            else {
              uint64_t v24 = *(void *)(v6 + 8 * v22) & ~v23;
            }
            *(void *)(v6 + 8 * v22) = v24;
            int v25 = sub_1DC2FF924(v57, v8 + (v19 >> 1), (int)(v8 + v10 + ~v20));
            unint64_t v26 = (unint64_t)(v55 + v19) >> 6;
            uint64_t v27 = 1 << (v55 + v19);
            if (v25) {
              uint64_t v28 = *(void *)(v6 + 8 * v26) | v27;
            }
            else {
              uint64_t v28 = *(void *)(v6 + 8 * v26) & ~v27;
            }
            *(void *)(v6 + 8 * v26) = v28;
            int v20 = (v20 & 1) == 0;
            ++v19;
          }
          while (v18 != v19);
        }
        uint64_t v50 = v10;
        if ((int)((2 * v10) | 1) >= 6)
        {
          int v29 = 0;
          uint64_t v30 = v53 + 1;
          int v54 = v8 + v10;
          unsigned int v31 = v53;
          int v33 = v51;
          int v32 = v52;
          do
          {
            uint64_t v34 = (int)(v8 - 1 + (v31 >> 1));
            int v35 = sub_1DC2FF924(v57, v54 + ~v29, v34);
            unint64_t v36 = (unint64_t)v33 >> 6;
            uint64_t v37 = 1 << v33;
            if (v35) {
              uint64_t v38 = *(void *)(v6 + 8 * v36) | v37;
            }
            else {
              uint64_t v38 = *(void *)(v6 + 8 * v36) & ~v37;
            }
            *(void *)(v6 + 8 * v36) = v38;
            int v39 = sub_1DC2FF924(v57, v34, v29 | v8);
            unint64_t v40 = (unint64_t)v32 >> 6;
            uint64_t v41 = 1 << v32;
            if (v39) {
              uint64_t v42 = *(void *)(v6 + 8 * v40) | v41;
            }
            else {
              uint64_t v42 = *(void *)(v6 + 8 * v40) & ~v41;
            }
            *(void *)(v6 + 8 * v40) = v42;
            int v29 = (v29 & 1) == 0;
            --v30;
            ++v32;
            ++v33;
            --v31;
          }
          while (v30 > 6);
        }
        v8 += 2;
        uint64_t v10 = v50 - 4;
        v53 -= 8;
        int v16 = v45 - 8;
        int v11 = v55 + v46;
        int v12 = v46 - 32;
        int v7 = v56 + v47;
        v52 += v48;
        int v14 = v48 - 32;
        v51 += v49;
        int v15 = v49 - 32;
        int v13 = v47 - 32;
        int v17 = v44 - 1;
      }
      while (v44 != 1);
    }
    operator new();
  }
  exception = __cxa_allocate_exception(0x20uLL);
  sub_1DC379B70(exception, "data is too long");
  void *exception = &unk_1F3661188;
  __cxa_throw(exception, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
}

void sub_1DC313494()
{
  sub_1DC314A14((atomic_uint **)(v0 - 184));
  JUMPOUT(0x1DC313754);
}

void sub_1DC3134E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  if (*(char *)(v36 - 97) < 0) {
    operator delete(*(void **)(v36 - 120));
  }
  MEMORY[0x1E019CE90](v35, 0x1093C40E92185C3);
  sub_1DC311968(&a30);
  MEMORY[0x1E019CE90](v34, 0x10B3C40E71DBE67);
  sub_1DC31191C(*(void **)(v36 - 176));
  sub_1DC311968(&a34);
  JUMPOUT(0x1DC3137CCLL);
}

void sub_1DC3134F8()
{
  MEMORY[0x1E019CE90](v0, 0x1091C409401DBA8);
  sub_1DC2FF548((atomic_uint **)(v1 - 200));
  JUMPOUT(0x1DC3137D4);
}

void sub_1DC313528()
{
  __cxa_free_exception(v0);
  JUMPOUT(0x1DC313754);
}

void sub_1DC31353C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,atomic_uint *a29,uint64_t a30)
{
  sub_1DC31191C(a27);
  sub_1DC3119BC(&a29);
  if (*(char *)(v31 - 97) < 0) {
    operator delete(*(void **)(v31 - 120));
  }
  sub_1DC311968(&a30);
  MEMORY[0x1E019CE90](v30, 0x10B3C40E71DBE67);
  JUMPOUT(0x1DC3137BCLL);
}

void sub_1DC3135B4()
{
}

void sub_1DC3135BC()
{
  sub_1DC311968((void *)(v0 - 184));
  sub_1DC314BD0((void *)(v0 - 120));
  JUMPOUT(0x1DC313754);
}

void sub_1DC3135CC()
{
  sub_1DC314BD0(v0 - 120);
  JUMPOUT(0x1DC313754);
}

void sub_1DC3135D4(void *a1, int a2)
{
  sub_1DC314BD0((void *)(v2 - 152));
  sub_1DC314B30((atomic_uint **)(v2 - 184));
  if (a2 == 2)
  {
    exception_ptr = __cxa_get_exception_ptr(a1);
    sub_1DC314C24((void *)(v2 - 184), (uint64_t)exception_ptr);
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC379B70(exception, "rs decoding failed");
    void *exception = &unk_1F3661188;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
  }
  if (a2 == 1)
  {
    int v7 = __cxa_get_exception_ptr(a1);
    sub_1DC314CC0((void *)(v2 - 184), (uint64_t)v7);
    __cxa_begin_catch(a1);
    unsigned int v8 = __cxa_allocate_exception(0x20uLL);
    int v9 = v8;
    if (*(char *)(v2 - 153) >= 0) {
      uint64_t v10 = (char *)(v2 - 176);
    }
    else {
      uint64_t v10 = *(char **)(v2 - 176);
    }
    sub_1DC379B70(v8, v10);
    *int v9 = &unk_1F3661188;
    __cxa_throw(v9, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
  }
  sub_1DC314BD0((void *)(v2 - 120));
  JUMPOUT(0x1DC313754);
}

void sub_1DC313700()
{
  sub_1DC379B0C((std::exception *)(v0 - 184));
  __cxa_end_catch();
  sub_1DC314BD0((void *)(v0 - 120));
  JUMPOUT(0x1DC313754);
}

void sub_1DC313724()
{
  sub_1DC379B0C((std::exception *)(v0 - 184));
  __cxa_end_catch();
  JUMPOUT(0x1DC313744);
}

void sub_1DC313750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,atomic_uint *a33)
{
  sub_1DC314A14((atomic_uint **)(v33 - 96));
  sub_1DC314744(&a33);
  sub_1DC314744((atomic_uint **)(v33 - 208));
  sub_1DC2FF548((atomic_uint **)(v33 - 192));
  _Unwind_Resume(a1);
}

void sub_1DC313768()
{
}

void sub_1DC313770()
{
  MEMORY[0x1E019CE90](v1, 0x1091C40C7871EBFLL);
  if (v0) {
    operator delete(v0);
  }
  JUMPOUT(0x1DC3137B0);
}

void sub_1DC3137E4(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)sub_1DC3116FC(a3, 17, &dword_1DC4162AC) + 8);
  uint64_t v5 = *((unsigned int *)sub_1DC3116FC(a3, 16, &dword_1DC4162A8) + 8);
  uint64_t v6 = sub_1DC3116FC(a3, 18, &dword_1DC4162B0);
  if ((v5 & 0x80000000) != 0
    || (int v7 = *((_DWORD *)v6 + 8)) == 0 && v5 > 0x20
    || (v7 ? (BOOL v8 = v5 >= 5) : (BOOL v8 = 0), v8))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC379C04(exception, "invalid layer count");
  }
  else
  {
    if (v7) {
      int v9 = &unk_1DC400D88;
    }
    else {
      int v9 = &unk_1DC400D9C;
    }
    if (v4 > v9[v5])
    {
      exception = __cxa_allocate_exception(0x20uLL);
      sub_1DC379C04(exception, "invalid data codeword count for layer count");
    }
    else
    {
      if (v5 >= 0x17) {
        int v10 = 12;
      }
      else {
        int v10 = 10;
      }
      if (v5 >= 9) {
        int v11 = v10;
      }
      else {
        int v11 = 8;
      }
      if (v5 >= 3) {
        int v12 = v11;
      }
      else {
        int v12 = 6;
      }
      if (v12 * v4 <= (unint64_t)(8
                                        * (*(void *)(*(void *)(a2 + 16) + 24)
                                         - *(void *)(*(void *)(a2 + 16) + 16))))
        sub_1DC31465C((uint64_t)v15);
      exception = __cxa_allocate_exception(0x20uLL);
      sub_1DC379C04(exception, "invalid input data");
    }
  }
  __cxa_throw(exception, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
}

void sub_1DC314528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,atomic_uint *a33,__int16 a34,char a35,char a36,int a37,atomic_uint *a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (*(char *)(v47 - 113) < 0) {
    operator delete(*(void **)(v47 - 136));
  }
  if (*(char *)(v47 - 89) < 0) {
    operator delete(*(void **)(v47 - 112));
  }
  sub_1DC314744(&a33);
  sub_1DC314744(&a38);
  sub_1DC311968(&a39);
  _Unwind_Resume(a1);
}

void sub_1DC31465C(uint64_t a1)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661908;
  *(void *)(a1 + 16) = 0;
  operator new();
}

void sub_1DC314720(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x1091C403A844E10);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC314744(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t sub_1DC314778(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661908;
  *(void *)(a1 + 16) = 0;
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
    int v4 = *(atomic_uint **)(a1 + 16);
    if (v4) {
      sub_1DC2FF57C(v4);
    }
  }
  *(void *)(a1 + 16) = v3;
  return a1;
}

void *sub_1DC3147E4(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_1DC3127EC();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void *sub_1DC314894(void *a1, size_t a2, unsigned char *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    size_t v5 = a2;
    sub_1DC314914(a1, a2);
    uint64_t v6 = (unsigned char *)a1[1];
    uint64_t v7 = &v6[v5];
    do
    {
      *v6++ = *a3;
      --v5;
    }
    while (v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_1DC3148F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1DC314914(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    sub_1DC2FF97C();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void sub_1DC314954(void *a1)
{
  *a1 = &unk_1F3661460;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3149C4(void *a1)
{
  *a1 = &unk_1F3661460;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

atomic_uint **sub_1DC314A14(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC314A48(uint64_t a1)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661928;
  *(void *)(a1 + 16) = 0;
  operator new();
}

void sub_1DC314B0C(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x1091C403A844E10);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC314B30(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t sub_1DC314B64(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661928;
  *(void *)(a1 + 16) = 0;
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
    size_t v4 = *(atomic_uint **)(a1 + 16);
    if (v4) {
      sub_1DC2FF57C(v4);
    }
  }
  *(void *)(a1 + 16) = v3;
  return a1;
}

void *sub_1DC314BD0(void *a1)
{
  *a1 = &unk_1F3661928;
  uint64_t v2 = (atomic_uint *)a1[2];
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  a1[2] = 0;
  return a1;
}

void *sub_1DC314C24(void *a1, uint64_t a2)
{
  *a1 = &unk_1F36619D8;
  uint64_t v3 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1DC312750(v3, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v3 = v4;
  }
  *a1 = &unk_1F36612D0;
  return a1;
}

void sub_1DC314CAC(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DC314CC0(void *a1, uint64_t a2)
{
  *a1 = &unk_1F36619D8;
  uint64_t v3 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1DC312750(v3, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v3 = v4;
  }
  *a1 = &unk_1F36613B0;
  return a1;
}

void sub_1DC314D48(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC314D5C(void *a1)
{
  sub_1DC314BD0(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC314D98(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DC314E1C(a1, a2);
    uint64_t v6 = (_DWORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1DC314E00(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1DC314E1C(void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_1DC2FF97C();
  }
  uint64_t result = (char *)sub_1DC314E5C(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *sub_1DC314E5C(unint64_t a1)
{
  if (a1 >> 62) {
    sub_1DC2FF994();
  }
  return operator new(4 * a1);
}

void sub_1DC314E94(void *a1)
{
  *a1 = &unk_1F3661480;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC314F04(void *a1)
{
  *a1 = &unk_1F3661480;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void *sub_1DC314F54(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      sub_1DC2FF97C();
    }
    uint64_t v4 = sub_1DC2FFD7C(((a2 - 1) >> 6) + 1);
    size_t v5 = v4;
    a1[1] = a2;
    a1[2] = v6;
    *a1 = v4;
    if (a2 >= 0x41) {
      unint64_t v7 = (a2 - 1) >> 6;
    }
    else {
      unint64_t v7 = 0;
    }
    v4[v7] = 0;
    unint64_t v8 = a2 >> 6;
    if (a2 >= 0x40) {
      bzero(v4, 8 * v8);
    }
    if ((a2 & 0x3F) != 0) {
      v5[v8] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(a2 & 0x3F));
    }
  }
  return a1;
}

uint64_t sub_1DC314FF8(void *a1, uint64_t a2, atomic_ullong *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1[1];
  uint64_t v6 = *(void *)(v5 + 48);
  uint64_t v7 = 5;
  if (v6 == -1) {
    uint64_t v6 = 5;
  }
  if (*(void *)(a2 + 32) != -1) {
    uint64_t v7 = *(void *)(a2 + 32);
  }
  if (v6 == v7 && !memcmp((const void *)(v5 + 56), (const void *)(a2 + 40), 8 * v6)) {
    return 1;
  }
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  unint64_t v8 = qword_1EBFFC3D8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
  {
    int v10 = (void *)*a1;
    if (*(char *)(*a1 + 23) < 0) {
      int v10 = (void *)*v10;
    }
    *(_DWORD *)CGAffineTransform buf = 136446210;
    *(void *)&buf[4] = v10;
    _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "E5RTNetwork: failed to validate tensor shape for I/O port: %{public}s", buf, 0xCu);
  }
  int v11 = @"Failed to validate tensor shape for I/O port.";
  *(void *)CGAffineTransform buf = -6004;
  sub_1DC306334(a3, (uint64_t *)buf, (CFTypeRef *)&v11);
  return 0;
}

uint64_t sub_1DC31514C(void *a1, uint64_t a2, atomic_ullong *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1[1];
  uint64_t v6 = *(void *)(v5 + 48);
  uint64_t v7 = 5;
  if (v6 == -1) {
    uint64_t v6 = 5;
  }
  if (*(void *)(a2 + 32) != -1) {
    uint64_t v7 = *(void *)(a2 + 32);
  }
  if (v6 == v7 && !memcmp((const void *)(v5 + 56), (const void *)(a2 + 40), 8 * v6)) {
    return 1;
  }
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  unint64_t v8 = qword_1EBFFC3D8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
  {
    int v10 = (void *)*a1;
    if (*(char *)(*a1 + 23) < 0) {
      int v10 = (void *)*v10;
    }
    *(_DWORD *)CGAffineTransform buf = 136446210;
    *(void *)&buf[4] = v10;
    _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "E5RTNetwork: failed to validate tensor shape for I/O port: %{public}s", buf, 0xCu);
  }
  int v11 = @"Failed to validate tensor shape for I/O port.";
  *(void *)CGAffineTransform buf = -6004;
  sub_1DC306334(a3, (uint64_t *)buf, (CFTypeRef *)&v11);
  return 0;
}

void sub_1DC3152A0(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned __int8 *)(a1 + 16) == *((unsigned __int8 *)a2 + 16))
  {
    if (*(unsigned char *)(a1 + 16))
    {
      sub_1DC315BDC((void *)a1);
      uint64_t v4 = *a2;
      *a2 = 0;
      *(void *)a1 = v4;
      uint64_t v5 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 8), atomic_exchange(a2 + 1, 0));
      if (v5)
      {
        CFRelease(v5);
      }
    }
  }
  else if (*(unsigned char *)(a1 + 16))
  {
    sub_1DC315F5C((void *)a1);
  }
  else
  {
    uint64_t v6 = *a2;
    *a2 = 0;
    *(void *)a1 = v6;
    *(void *)(a1 + 8) = atomic_exchange(a2 + 1, 0);
    *(unsigned char *)(a1 + 16) = 1;
  }
}

uint64_t sub_1DC315358(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16))
  {
    sub_1DC315BA8((atomic_ullong *)(a1 + 8));
    sub_1DC315BDC((void *)a1);
  }
  return a1;
}

BOOL sub_1DC315398(uint64_t a1, uint64_t *a2, unsigned __int8 a3, _DWORD *a4)
{
  int v7 = a3;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = sub_1DC3154F4();
  if (v7) {
    uint64_t v9 = *a2;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 160))(a1, v9);
  *a4 = v10;
  if (v10)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    int v11 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t))v8)(v10);
      int v14 = "";
      if (v13) {
        int v14 = (const char *)v13;
      }
      v15[0] = 67240450;
      v15[1] = v10;
      __int16 v16 = 2082;
      int v17 = v14;
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "e5rt_io_port_bind_buffer_object failed: (%{public}d): %{public}s", (uint8_t *)v15, 0x12u);
    }
  }
  return v10 == 0;
}

uint64_t sub_1DC3154F4()
{
  if (qword_1EBFFB9E0 != -1) {
    dispatch_once_f(&qword_1EBFFB9E0, 0, (dispatch_function_t)sub_1DC31557C);
  }
  if (qword_1EBFFB9E8) {
    return qword_1EBFFB9E8;
  }
  else {
    return 0;
  }
}

void sub_1DC31557C()
{
  qword_1EBFFB820 = MEMORY[0x1E4F61300];
  qword_1EBFFB828 = MEMORY[0x1E4F614B8];
  qword_1EBFFB830 = MEMORY[0x1E4F614B0];
  qword_1EBFFB838 = MEMORY[0x1E4F614A8];
  qword_1EBFFB840 = MEMORY[0x1E4F614A0];
  qword_1EBFFB848 = MEMORY[0x1E4F61498];
  qword_1EBFFB850 = MEMORY[0x1E4F61490];
  qword_1EBFFB858 = MEMORY[0x1E4F614D8];
  qword_1EBFFB860 = MEMORY[0x1E4F61488];
  qword_1EBFFB868 = MEMORY[0x1E4F614E0];
  qword_1EBFFB870 = MEMORY[0x1E4F614C0];
  qword_1EBFFB878 = MEMORY[0x1E4F614C8];
  qword_1EBFFB880 = MEMORY[0x1E4F614D0];
  qword_1EBFFB888 = MEMORY[0x1E4F61270];
  qword_1EBFFB890 = MEMORY[0x1E4F61290];
  qword_1EBFFB898 = MEMORY[0x1E4F61278];
  qword_1EBFFB8A0 = MEMORY[0x1E4F61288];
  qword_1EBFFB8A8 = MEMORY[0x1E4F613D8];
  qword_1EBFFB8B0 = MEMORY[0x1E4F613D0];
  qword_1EBFFB8B8 = MEMORY[0x1E4F613E8];
  qword_1EBFFB8C0 = MEMORY[0x1E4F613C0];
  qword_1EBFFB8C8 = MEMORY[0x1E4F61298];
  qword_1EBFFB8D0 = MEMORY[0x1E4F61420];
  qword_1EBFFB8D8 = MEMORY[0x1E4F61460];
  qword_1EBFFB8E0 = MEMORY[0x1E4F61470];
  qword_1EBFFB8E8 = MEMORY[0x1E4F61468];
  qword_1EBFFB8F0 = MEMORY[0x1E4F61478];
  qword_1EBFFB8F8 = MEMORY[0x1E4F612B8];
  qword_1EBFFB900 = MEMORY[0x1E4F612C0];
  qword_1EBFFB908 = MEMORY[0x1E4F612C8];
  qword_1EBFFB910 = MEMORY[0x1E4F612E0];
  qword_1EBFFB918 = MEMORY[0x1E4F612E8];
  qword_1EBFFB920 = MEMORY[0x1E4F612D8];
  qword_1EBFFB928 = MEMORY[0x1E4F612D0];
  qword_1EBFFB930 = MEMORY[0x1E4F612A8];
  qword_1EBFFB938 = MEMORY[0x1E4F612F8];
  qword_1EBFFB940 = MEMORY[0x1E4F612A0];
  qword_1EBFFB948 = MEMORY[0x1E4F612B0];
  qword_1EBFFB950 = MEMORY[0x1E4F612F0];
  qword_1EBFFB958 = MEMORY[0x1E4F613F8];
  qword_1EBFFB960 = MEMORY[0x1E4F61400];
  qword_1EBFFB968 = MEMORY[0x1E4F61410];
  qword_1EBFFB970 = MEMORY[0x1E4F61408];
  qword_1EBFFB978 = MEMORY[0x1E4F61418];
  qword_1EBFFB980 = MEMORY[0x1E4F61388];
  qword_1EBFFB988 = MEMORY[0x1E4F61390];
  qword_1EBFFB990 = MEMORY[0x1E4F61330];
  qword_1EBFFB998 = MEMORY[0x1E4F61378];
  qword_1EBFFB9A0 = MEMORY[0x1E4F61308];
  qword_1EBFFB9A8 = MEMORY[0x1E4F613A0];
  qword_1EBFFB9B0 = MEMORY[0x1E4F61310];
  qword_1EBFFB9B8 = MEMORY[0x1E4F61318];
  qword_1EBFFB9C0 = MEMORY[0x1E4F613B8];
  qword_1EBFFB9C8 = MEMORY[0x1E4F613A8];
  qword_1EBFFB9D0 = MEMORY[0x1E4F613B0];
  qword_1EBFFB9E8 = (uint64_t)&qword_1EBFFB820;
}

atomic_ullong *sub_1DC315BA8(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *sub_1DC315BDC(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365E050;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A940);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC315C70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1DC315C84(uint64_t a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = sub_1DC3154F4();
  if (!a1) {
    sub_1DC307C38();
  }
  uint64_t v5 = (uint64_t (**)(uint64_t))v4;
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 48))(a1, v4);
  if (v6)
  {
    uint64_t v7 = v6;
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v8 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      int v11 = a2;
      uint64_t v9 = *a2;
      uint64_t v10 = v11[1];
      uint64_t v12 = (*v5)(v7);
      uint64_t v13 = "";
      v14[0] = 68158466;
      v14[1] = v10;
      if (v12) {
        uint64_t v13 = (const char *)v12;
      }
      __int16 v15 = 2082;
      uint64_t v16 = v9;
      __int16 v17 = 1026;
      int v18 = v7;
      __int16 v19 = 2082;
      int v20 = v13;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "e5rt_%{public}.*s_release failed: (%{public}d): %{public}s", (uint8_t *)v14, 0x22u);
    }
  }
}

void *sub_1DC315DF0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1DC315E74()
{
  return &unk_1F365DA08;
}

uint64_t sub_1DC315E80(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP18e5rt_buffer_objectEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC315EBC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))(*(void *)(a1 + 8));
}

uint64_t sub_1DC315ED8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365E050;
  a2[1] = v2;
  return result;
}

void *sub_1DC315EFC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365E050;
  result[1] = v3;
  return result;
}

void sub_1DC315F44()
{
}

void *sub_1DC315F5C(void *result)
{
  if (*((unsigned char *)result + 16))
  {
    uint64_t v1 = result;
    sub_1DC315BA8(result + 1);
    uint64_t result = sub_1DC315BDC(v1);
    *((unsigned char *)v1 + 16) = 0;
  }
  return result;
}

void sub_1DC315F9C(uint64_t a1, void *a2, _DWORD *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v22 = 0;
  uint64_t v6 = sub_1DC3154F4();
  uint64_t v7 = (*(uint64_t (**)(void, int *))(v6 + 128))(*a2, &v22);
  *a3 = v7;
  if (v7)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v8 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    uint64_t v9 = (*(uint64_t (**)(uint64_t))v6)(v7);
    uint64_t v10 = "";
    if (v9) {
      uint64_t v10 = (const char *)v9;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v7;
    *(_WORD *)uint64_t v24 = 2082;
    *(void *)&v24[2] = v10;
    int v11 = "e5rt_buffer_object_get_type failed: (%{public}d): %{public}s";
    goto LABEL_8;
  }
  int v14 = v22;
  if (v22)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v15 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    *(_DWORD *)CGAffineTransform buf = 67240192;
    *(_DWORD *)&buf[4] = v14;
    int v11 = "E5RTBufferObject: unexpected buffer object type: %{public}d";
    uint64_t v12 = v15;
    uint32_t v13 = 8;
    goto LABEL_14;
  }
  CFTypeRef cf = 0;
  uint64_t v16 = (*(uint64_t (**)(void, CFTypeRef *))(v6 + 120))(*a2, &cf);
  *a3 = v16;
  if (v16)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v8 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    uint64_t v19 = (*(uint64_t (**)(uint64_t))v6)(v16);
    int v20 = "";
    if (v19) {
      int v20 = (const char *)v19;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v16;
    *(_WORD *)uint64_t v24 = 2082;
    *(void *)&v24[2] = v20;
    int v11 = "e5rt_buffer_object_get_iosurface failed: (%{public}d): %{public}s";
LABEL_8:
    uint64_t v12 = v8;
    uint32_t v13 = 18;
LABEL_14:
    _os_log_error_impl(&dword_1DC2FE000, v12, OS_LOG_TYPE_ERROR, v11, buf, v13);
LABEL_19:
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 16) = 0;
    return;
  }
  uint64_t v17 = *a2;
  *a2 = 0;
  *(void *)CGAffineTransform buf = v17;
  CFTypeRef v18 = cf;
  if (cf)
  {
    CFTypeRef v18 = CFRetain(cf);
    uint64_t v17 = *(void *)buf;
  }
  *(void *)CGAffineTransform buf = 0;
  *(void *)uint64_t v24 = v18;
  *(void *)a1 = v17;
  *(void *)(a1 + 8) = atomic_exchange((atomic_ullong *volatile)v24, 0);
  *(unsigned char *)(a1 + 16) = 1;
  sub_1DC315BA8((atomic_ullong *)v24);
  sub_1DC315BDC(buf);
}

void sub_1DC316278(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3162A8(uint64_t a1, uint64_t a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v24 = 0;
  uint64_t v5 = sub_1DC3154F4();
  uint64_t v6 = (*(uint64_t (**)(void, void, uint64_t, uint64_t *))(v5 + 64))(*(void *)(v4 + 8), 0, 1, &v24);
  int v23 = v6;
  if (v6)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v7 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = (*(uint64_t (**)(uint64_t))v5)(v6);
      uint32_t v13 = "";
      if (v12) {
        uint32_t v13 = (const char *)v12;
      }
      *(_DWORD *)CGAffineTransform buf = 67240450;
      *(_DWORD *)&buf[4] = v6;
      __int16 v31 = 2082;
      int v32 = v13;
      _os_log_error_impl(&dword_1DC2FE000, v7, OS_LOG_TYPE_ERROR, "e5rt_tensor_desc_alloc_buffer_object failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    v25[0] = 0;
    v27[2] = 0;
  }
  else
  {
    *(void *)CGAffineTransform buf = v24;
    sub_1DC315F9C((uint64_t)v25, buf, &v23);
    sub_1DC315BDC(buf);
  }
  sub_1DC3152A0(a1 + 16, (uint64_t *)v25);
  sub_1DC315358((uint64_t)v25);
  int v8 = *(unsigned __int8 *)(a1 + 32);
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  uint64_t v9 = qword_1EBFFC3D8;
  if (v8)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      IOSurfaceID ID = IOSurfaceGetID((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire));
      size_t AllocSize = IOSurfaceGetAllocSize((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire));
      uint64_t v17 = *(void **)a1;
      if (*(char *)(*(void *)a1 + 23) < 0) {
        uint64_t v17 = (void *)*v17;
      }
      *(_DWORD *)uint64_t v25 = 134284291;
      *(void *)&v25[4] = v14;
      __int16 v26 = 1025;
      *(_DWORD *)uint64_t v27 = ID;
      *(_WORD *)&v27[4] = 2050;
      *(void *)&v27[6] = AllocSize;
      __int16 v28 = 2082;
      int v29 = v17;
      _os_log_debug_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_DEBUG, "E5RTNetwork: allocated buffer object %{private}p surface id #%{private}x of %{public, iec-bytes}zu with tensor descriptor of port: %{public}s", v25, 0x26u);
    }
    if (sub_1DC315398(**(void **)(a1 + 8), (uint64_t *)(a1 + 16), 1u, &v23))
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v19 = *(void *)(a1 + 16);
        int v20 = *(void **)a1;
        if (*(char *)(*(void *)a1 + 23) < 0) {
          int v20 = (void *)*v20;
        }
        *(_DWORD *)uint64_t v25 = 134283779;
        *(void *)&v25[4] = v19;
        __int16 v26 = 2082;
        *(void *)uint64_t v27 = v20;
        _os_log_debug_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_DEBUG, "E5RTNetwork: bound buffer object %{private}p to port: %{public}s", v25, 0x16u);
      }
      return 1;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = *(void *)(a1 + 16);
      int v22 = *(void **)a1;
      if (*(char *)(*(void *)a1 + 23) < 0) {
        int v22 = (void *)*v22;
      }
      *(_DWORD *)uint64_t v25 = 134283779;
      *(void *)&v25[4] = v21;
      __int16 v26 = 2082;
      *(void *)uint64_t v27 = v22;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to bind buffer object %{private}p to port: %{public}s", v25, 0x16u);
    }
    *(void *)uint64_t v25 = -6004;
    *(void *)CGAffineTransform buf = @"Unable to bind buffer object to port.";
    sub_1DC306334((atomic_ullong *)a2, (uint64_t *)v25, (CFTypeRef *)buf);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      CFTypeRef v18 = *(void **)a1;
      if (*(char *)(*(void *)a1 + 23) < 0) {
        CFTypeRef v18 = (void *)*v18;
      }
      *(_DWORD *)uint64_t v25 = 136446210;
      *(void *)&v25[4] = v18;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable allocate buffer object with tensor descriptor of port: %{public}s", v25, 0xCu);
    }
    *(void *)uint64_t v25 = -2003;
    *(void *)CGAffineTransform buf = @"Unable allocate buffer object with tensor descriptor of port.";
    sub_1DC306334((atomic_ullong *)a2, (uint64_t *)v25, (CFTypeRef *)buf);
  }
  int v11 = v23;
  if (!*(unsigned char *)(a2 + 52)) {
    *(unsigned char *)(a2 + 52) = 1;
  }
  uint64_t result = 0;
  *(_DWORD *)(a2 + 48) = v11;
  return result;
}

void sub_1DC3166BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3166FC(uint64_t a1, atomic_ullong *a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  int v24 = 0;
  uint64_t v25 = 0;
  uint64_t v6 = sub_1DC3154F4();
  uint64_t v7 = (*(uint64_t (**)(uint64_t *, unint64_t))(v6 + 104))(&v25, atomic_load_explicit(a2, memory_order_acquire));
  int v24 = v7;
  if (v7)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    int v8 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t))v6)(v7);
      uint64_t v14 = "";
      if (v13) {
        uint64_t v14 = (const char *)v13;
      }
      *(_DWORD *)CGAffineTransform buf = 67240450;
      *(_DWORD *)&buf[4] = v7;
      __int16 v32 = 2082;
      uint64_t v33 = v14;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "e5rt_buffer_object_create_from_iosurface failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    v26[0] = 0;
    v28[2] = 0;
  }
  else
  {
    *(void *)CGAffineTransform buf = v25;
    sub_1DC315F9C((uint64_t)v26, buf, &v24);
    sub_1DC315BDC(buf);
  }
  sub_1DC3152A0(a1 + 16, (uint64_t *)v26);
  sub_1DC315358((uint64_t)v26);
  int v9 = *(unsigned __int8 *)(a1 + 32);
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  uint64_t v10 = qword_1EBFFC3D8;
  if (v9)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v15 = *(void *)(a1 + 16);
      IOSurfaceID ID = IOSurfaceGetID((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire));
      size_t AllocSize = IOSurfaceGetAllocSize((IOSurfaceRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire));
      unint64_t explicit = atomic_load_explicit(a2, memory_order_acquire);
      *(_DWORD *)__int16 v26 = 134284289;
      *(void *)&v26[4] = v15;
      __int16 v27 = 1025;
      *(_DWORD *)__int16 v28 = ID;
      *(_WORD *)&v28[4] = 2050;
      *(void *)&v28[6] = AllocSize;
      __int16 v29 = 2050;
      unint64_t v30 = explicit;
      _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "E5RTNetwork: created buffer object %{private}p surface id #%{private}x of %{public, iec-bytes}zu from surface: %{public}p", v26, 0x26u);
    }
    if (sub_1DC315398(**(void **)(a1 + 8), (uint64_t *)(a1 + 16), 1u, &v24))
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v20 = *(void *)(a1 + 16);
        uint64_t v21 = *(void **)a1;
        if (*(char *)(*(void *)a1 + 23) < 0) {
          uint64_t v21 = (void *)*v21;
        }
        *(_DWORD *)__int16 v26 = 134283779;
        *(void *)&v26[4] = v20;
        __int16 v27 = 2082;
        *(void *)__int16 v28 = v21;
        _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "E5RTNetwork: bound buffer object %{private}p to port: %{public}s", v26, 0x16u);
      }
      return 1;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = *(void *)(a1 + 16);
      int v23 = *(void **)a1;
      if (*(char *)(*(void *)a1 + 23) < 0) {
        int v23 = (void *)*v23;
      }
      *(_DWORD *)__int16 v26 = 134283779;
      *(void *)&v26[4] = v22;
      __int16 v27 = 2082;
      *(void *)__int16 v28 = v23;
      _os_log_error_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to bind buffer object %{private}p to port: %{public}s", v26, 0x16u);
    }
    *(void *)__int16 v26 = -6004;
    *(void *)CGAffineTransform buf = @"Unable to bind buffer object to port.";
    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v26, (CFTypeRef *)buf);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      unint64_t v19 = atomic_load_explicit(a2, memory_order_acquire);
      *(_DWORD *)__int16 v26 = 134283521;
      *(void *)&v26[4] = v19;
      _os_log_error_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable create buffer object from surface: %{private}p", v26, 0xCu);
    }
    *(void *)__int16 v26 = -2003;
    *(void *)CGAffineTransform buf = @"Unable create buffer object from surface.";
    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v26, (CFTypeRef *)buf);
  }
  int v12 = v24;
  if (!*(unsigned char *)(a3 + 52)) {
    *(unsigned char *)(a3 + 52) = 1;
  }
  uint64_t result = 0;
  *(_DWORD *)(a3 + 48) = v12;
  return result;
}

void sub_1DC316AF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1DC316B30(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v13 = 0;
  BOOL v4 = sub_1DC315398(**(void **)(a1 + 8), 0, 0, &v13);
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  uint64_t v5 = qword_1EBFFC3D8;
  if (v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a1 + 16);
      int v9 = *(void **)a1;
      if (*(char *)(*(void *)a1 + 23) < 0) {
        int v9 = (void *)*v9;
      }
      *(_DWORD *)CGAffineTransform buf = 134283779;
      *(void *)&buf[4] = v8;
      __int16 v15 = 2082;
      uint64_t v16 = v9;
      _os_log_debug_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_DEBUG, "E5RTNetwork: unbound buffer object %{private}p from port: %{public}s", buf, 0x16u);
    }
    sub_1DC315F5C((void *)(a1 + 16));
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 16);
      int v11 = *(void **)a1;
      if (*(char *)(*(void *)a1 + 23) < 0) {
        int v11 = (void *)*v11;
      }
      *(_DWORD *)CGAffineTransform buf = 134283779;
      *(void *)&buf[4] = v10;
      __int16 v15 = 2082;
      uint64_t v16 = v11;
      _os_log_error_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to unbind buffer object %{private}p from port: %{public}s", buf, 0x16u);
    }
    *(void *)CGAffineTransform buf = -6004;
    int v12 = @"Unable to unbind buffer object from port.";
    sub_1DC306334((atomic_ullong *)a2, (uint64_t *)buf, (CFTypeRef *)&v12);
    int v6 = v13;
    if (!*(unsigned char *)(a2 + 52)) {
      *(unsigned char *)(a2 + 52) = 1;
    }
    *(_DWORD *)(a2 + 48) = v6;
  }
  return v4;
}

void *sub_1DC316CFC(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365E1B0;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A2E0);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC316D90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC316DA4()
{
  return &unk_1F365DA48;
}

uint64_t sub_1DC316DB0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP22e5rt_tensor_desc_dtypeEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC316DEC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))(*(void *)(a1 + 8));
}

uint64_t sub_1DC316E08(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365E1B0;
  a2[1] = v2;
  return result;
}

void *sub_1DC316E2C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365E1B0;
  result[1] = v3;
  return result;
}

void sub_1DC316E74()
{
}

void sub_1DC316E8C(uint64_t a1, void *a2, _DWORD *a3)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  char v78 = 0;
  uint64_t v6 = sub_1DC3154F4();
  uint64_t v7 = (*(uint64_t (**)(void, char *))(v6 + 144))(*a2, &v78);
  *a3 = v7;
  if (v7)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v8 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_5;
    }
    uint64_t v23 = (*(uint64_t (**)(uint64_t))v6)(v7);
    int v24 = "";
    if (v23) {
      int v24 = (const char *)v23;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v7;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v24;
    int v12 = "e5rt_io_port_is_tensor failed: (%{public}d): %{public}s";
    goto LABEL_30;
  }
  if (!v78)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v13 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_5;
    }
    *(_WORD *)CGAffineTransform buf = 0;
    int v12 = "E5RTTensorIOPort: port is not a tensor";
    uint64_t v14 = v13;
    uint32_t v15 = 2;
    goto LABEL_31;
  }
  uint64_t v77 = 0;
  uint64_t v9 = (*(uint64_t (**)(void, uint64_t *))(v6 + 152))(*a2, &v77);
  *a3 = v9;
  if (v9)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v8 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_5;
    }
    uint64_t v10 = (*(uint64_t (**)(uint64_t))v6)(v9);
    int v11 = "";
    if (v10) {
      int v11 = (const char *)v10;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v9;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v11;
    int v12 = "e5rt_io_port_retain_tensor_desc failed: (%{public}d): %{public}s";
LABEL_30:
    uint64_t v14 = v8;
    uint32_t v15 = 18;
LABEL_31:
    _os_log_error_impl(&dword_1DC2FE000, v14, OS_LOG_TYPE_ERROR, v12, buf, v15);
LABEL_5:
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 144) = 0;
    return;
  }
  uint64_t v76 = v77;
  uint64_t v83 = 0;
  uint64_t v16 = (*(uint64_t (**)(void))(v6 + 72))();
  *a3 = v16;
  if (v16)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v17 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    uint64_t v18 = (*(uint64_t (**)(uint64_t))v6)(v16);
    unint64_t v19 = "";
    if (v18) {
      unint64_t v19 = (const char *)v18;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v16;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v19;
    uint64_t v20 = "e5rt_tensor_desc_retain_dtype failed: (%{public}d): %{public}s";
    goto LABEL_25;
  }
  __srCGFloat c = v83;
  LOBYTE(v81) = 0;
  uint64_t v25 = (*(uint64_t (**)(void))(v6 + 16))();
  *a3 = v25;
  if (v25)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    __int16 v26 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_68;
    }
    uint64_t v27 = (*(uint64_t (**)(uint64_t))v6)(v25);
    __int16 v28 = "";
    if (v27) {
      __int16 v28 = (const char *)v27;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v25;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v28;
    __int16 v29 = "e5rt_tensor_desc_dtype_get_num_components failed: (%{public}d): %{public}s";
LABEL_67:
    _os_log_error_impl(&dword_1DC2FE000, v26, OS_LOG_TYPE_ERROR, v29, buf, 0x12u);
LABEL_68:
    char v42 = 0;
    goto LABEL_69;
  }
  *((void *)&v69 + 1) = v81;
  uint64_t v30 = (*(uint64_t (**)(void *, long long *))(v6 + 24))(__src, &v70);
  *a3 = v30;
  if (v30)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    __int16 v26 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_68;
    }
    uint64_t v31 = (*(uint64_t (**)(uint64_t))v6)(v30);
    __int16 v32 = "";
    if (v31) {
      __int16 v32 = (const char *)v31;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v30;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v32;
    __int16 v29 = "e5rt_tensor_desc_dtype_get_element_size failed: (%{public}d): %{public}s";
    goto LABEL_67;
  }
  uint64_t v33 = (*(uint64_t (**)(void *, char *))(v6 + 32))(__src, (char *)&v70 + 8);
  *a3 = v33;
  if (v33)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    __int16 v26 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_68;
    }
    uint64_t v34 = (*(uint64_t (**)(uint64_t))v6)(v33);
    uint64_t v35 = "";
    if (v34) {
      uint64_t v35 = (const char *)v34;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v33;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v35;
    __int16 v29 = "e5rt_tensor_desc_dtype_get_component_size failed: (%{public}d): %{public}s";
    goto LABEL_67;
  }
  uint64_t v36 = (*(uint64_t (**)(void *, char *))(v6 + 40))(__src, (char *)&v69 + 4);
  *a3 = v36;
  if (v36)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    __int16 v26 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_68;
    }
    uint64_t v37 = (*(uint64_t (**)(uint64_t))v6)(v36);
    uint64_t v38 = "";
    if (v37) {
      uint64_t v38 = (const char *)v37;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v36;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v38;
    __int16 v29 = "e5rt_tensor_desc_dtype_get_component_pack failed: (%{public}d): %{public}s";
    goto LABEL_67;
  }
  uint64_t v39 = (*(uint64_t (**)(void *, long long *))(v6 + 48))(__src, &v69);
  *a3 = v39;
  if (v39)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    __int16 v26 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_68;
    }
    uint64_t v40 = (*(uint64_t (**)(uint64_t))v6)(v39);
    uint64_t v41 = "";
    if (v40) {
      uint64_t v41 = (const char *)v40;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v39;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v41;
    __int16 v29 = "e5rt_tensor_desc_dtype_get_component_dtype failed: (%{public}d): %{public}s";
    goto LABEL_67;
  }
  char v42 = 1;
LABEL_69:
  sub_1DC316CFC(&__src);
  if ((v42 & 1) == 0) {
    goto LABEL_104;
  }
  uint64_t v43 = (*(uint64_t (**)(uint64_t, size_t *))(v6 + 80))(v76, __len);
  *a3 = v43;
  if (v43)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v17 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    uint64_t v44 = (*(uint64_t (**)(uint64_t))v6)(v43);
    int v45 = "";
    if (v44) {
      int v45 = (const char *)v44;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v43;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v45;
    uint64_t v20 = "e5rt_tensor_desc_get_rank failed: (%{public}d): %{public}s";
    goto LABEL_25;
  }
  size_t v46 = __len[0];
  if (__len[0] >= 6)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v47 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    *(_DWORD *)CGAffineTransform buf = 134349312;
    *(void *)&buf[4] = v46;
    *(_WORD *)&unsigned char buf[12] = 2050;
    *(void *)&buf[14] = 5;
    uint64_t v20 = "E5RTTensorDescriptor: rank %{public}zu exceeds max rank %{public}zu";
    goto LABEL_82;
  }
  uint64_t v81 = 0;
  __srCGFloat c = 0;
  uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t *, void **))(v6 + 88))(v76, &v81, &__src);
  *a3 = v48;
  if (v48)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v17 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    uint64_t v49 = (*(uint64_t (**)(uint64_t))v6)(v48);
    uint64_t v50 = "";
    if (v49) {
      uint64_t v50 = (const char *)v49;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v48;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v50;
    uint64_t v20 = "e5rt_tensor_desc_get_shape failed: (%{public}d): %{public}s";
    goto LABEL_25;
  }
  uint64_t v51 = v81;
  size_t v52 = __len[0];
  if (v81 != __len[0])
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v47 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    *(_DWORD *)CGAffineTransform buf = 134349312;
    *(void *)&buf[4] = v51;
    *(_WORD *)&unsigned char buf[12] = 2050;
    *(void *)&buf[14] = v52;
    uint64_t v20 = "E5RTTensorDescriptor: shape rank %{public}zu differs from rank %{public}zu";
LABEL_82:
    uint64_t v21 = v47;
    uint32_t v22 = 22;
    goto LABEL_26;
  }
  uint64_t v53 = 8 * v81;
  if (!v81 || (memmove(&__len[1], __src, 8 * v81), v51 != 5)) {
    bzero((char *)&v69 + v53 + 40, 40 - v53);
  }
  uint64_t v79 = 0;
  uint64_t v80 = 0;
  uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(v6 + 96))(v76, &v79, &v80);
  *a3 = v54;
  if (v54)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v17 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    uint64_t v55 = (*(uint64_t (**)(uint64_t))v6)(v54);
    uint64_t v56 = "";
    if (v55) {
      uint64_t v56 = (const char *)v55;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v54;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v56;
    uint64_t v20 = "e5rt_tensor_desc_get_strides failed: (%{public}d): %{public}s";
LABEL_25:
    uint64_t v21 = v17;
    uint32_t v22 = 18;
LABEL_26:
    _os_log_error_impl(&dword_1DC2FE000, v21, OS_LOG_TYPE_ERROR, v20, buf, v22);
    goto LABEL_104;
  }
  uint64_t v57 = v79;
  size_t v58 = __len[0];
  if (v79 != __len[0])
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v47 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    *(_DWORD *)CGAffineTransform buf = 134349312;
    *(void *)&buf[4] = v57;
    *(_WORD *)&unsigned char buf[12] = 2050;
    *(void *)&buf[14] = v58;
    uint64_t v20 = "E5RTTensorDescriptor: strides rank %{public}zu differs from rank %{public}zu";
    goto LABEL_82;
  }
  if (!v79)
  {
LABEL_113:
    bzero((char *)v74 + 8 * v57, 40 - 8 * v57);
LABEL_114:
    uint64_t v62 = *a2;
    *a2 = 0;
    uint64_t v63 = v76;
    uint64_t v76 = 0;
    long long v88 = v73;
    long long v89 = v74[0];
    long long v90 = v74[1];
    *(void *)&long long v91 = v75;
    *(_OWORD *)&buf[16] = v69;
    long long v85 = v70;
    long long v86 = *(_OWORD *)__len;
    long long v87 = v72;
    BYTE8(v91) = 1;
    *(void *)CGAffineTransform buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    *(void *)a1 = v62;
    *(void *)(a1 + 8) = v63;
    long long v64 = v85;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)&buf[16];
    *(_OWORD *)(a1 + 32) = v64;
    long long v65 = v89;
    *(_OWORD *)(a1 + 80) = v88;
    *(_OWORD *)(a1 + 96) = v65;
    long long v66 = v87;
    *(_OWORD *)(a1 + 48) = v86;
    *(_OWORD *)(a1 + 64) = v66;
    long long v67 = v91;
    *(_OWORD *)(a1 + 112) = v90;
    *(_OWORD *)(a1 + 128) = v67;
    *(unsigned char *)(a1 + 144) = 1;
    sub_1DC317BA4(&buf[8]);
    sub_1DC317C4C(buf);
    goto LABEL_105;
  }
  uint64_t v59 = 0;
  uint64_t v60 = v80;
  while (1)
  {
    uint64_t v61 = *(void *)(v60 + 8 * v59);
    if (v61 < 0) {
      break;
    }
    *((void *)v74 + v59++) = v61;
    if (v57 == v59)
    {
      if (v57 == 5) {
        goto LABEL_114;
      }
      goto LABEL_113;
    }
  }
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  uint64_t v68 = qword_1EBFFC3D8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)CGAffineTransform buf = 134349056;
    *(void *)&buf[4] = v61;
    uint64_t v20 = "E5RTTensorDescriptor: unexpected negative stride %{public}zd";
    uint64_t v21 = v68;
    uint32_t v22 = 12;
    goto LABEL_26;
  }
LABEL_104:
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 144) = 0;
LABEL_105:
  sub_1DC317BA4(&v76);
}

void sub_1DC317B54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC317BA4(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365DFF8;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A300);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC317C38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC317C4C(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365DF48;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A2F0);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC317CE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC317CF4()
{
  return &unk_1F365D9D8;
}

uint64_t sub_1DC317D00(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP12e5rt_io_portEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC317D3C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))(*(void *)(a1 + 8));
}

uint64_t sub_1DC317D58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365DF48;
  a2[1] = v2;
  return result;
}

void *sub_1DC317D7C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365DF48;
  result[1] = v3;
  return result;
}

void sub_1DC317DC4()
{
}

void *sub_1DC317DDC()
{
  return &unk_1F365D9F8;
}

uint64_t sub_1DC317DE8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP16e5rt_tensor_descEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC317E24(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))(*(void *)(a1 + 8));
}

uint64_t sub_1DC317E40(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365DFF8;
  a2[1] = v2;
  return result;
}

void *sub_1DC317E64(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365DFF8;
  result[1] = v3;
  return result;
}

void sub_1DC317EAC()
{
}

void *sub_1DC317EC4(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365E158;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A270);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC317F58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC317F6C()
{
  return &unk_1F365DA38;
}

uint64_t sub_1DC317F78(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP21e5rt_program_functionEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC317FB4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 176))(*(void *)(a1 + 8));
}

uint64_t sub_1DC317FD0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365E158;
  a2[1] = v2;
  return result;
}

void *sub_1DC317FF4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365E158;
  result[1] = v3;
  return result;
}

void sub_1DC31803C()
{
}

void *sub_1DC318054(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365E0A8;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A280);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC3180E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC3180FC()
{
  return &unk_1F365DA18;
}

uint64_t sub_1DC318108(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP20e5rt_program_libraryEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC318144(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 192))(*(void *)(a1 + 8));
}

uint64_t sub_1DC318160(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365E0A8;
  a2[1] = v2;
  return result;
}

void *sub_1DC318184(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365E0A8;
  result[1] = v3;
  return result;
}

void sub_1DC3181CC()
{
}

BOOL sub_1DC3181E4(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = sub_1DC3154F4();
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 248))(a1, a2, a3);
  *a4 = v9;
  if (v9)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v10 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = (*(uint64_t (**)(uint64_t))v8)(v9);
      uint64_t v13 = "";
      if (v12) {
        uint64_t v13 = (const char *)v12;
      }
      v14[0] = 67240450;
      v14[1] = v9;
      __int16 v15 = 2082;
      uint64_t v16 = v13;
      _os_log_error_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_set_preferred_cpu_backends failed: (%{public}d): %{public}s", (uint8_t *)v14, 0x12u);
    }
  }
  return v9 == 0;
}

void *sub_1DC318338(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365E260;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A290);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC3183CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC3183E0()
{
  return &unk_1F365DA68;
}

uint64_t sub_1DC3183EC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP24e5rt_e5_compiler_optionsEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC318428(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 224))(*(void *)(a1 + 8));
}

uint64_t sub_1DC318444(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365E260;
  a2[1] = v2;
  return result;
}

void *sub_1DC318468(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365E260;
  result[1] = v3;
  return result;
}

void sub_1DC3184B0()
{
}

void *sub_1DC3184C8(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365DFA0;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A2A0);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC31855C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC318570()
{
  return &unk_1F365D9E8;
}

uint64_t sub_1DC31857C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP16e5rt_e5_compilerEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC3185B8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 280))(*(void *)(a1 + 8));
}

uint64_t sub_1DC3185D8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365DFA0;
  a2[1] = v2;
  return result;
}

void *sub_1DC3185FC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365DFA0;
  result[1] = v3;
  return result;
}

void sub_1DC318644()
{
}

BOOL sub_1DC31865C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = sub_1DC3154F4();
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 328))(a1, a2);
  *a3 = v7;
  if (v7)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v8 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))v6)(v7);
      int v11 = "";
      if (v10) {
        int v11 = (const char *)v10;
      }
      v12[0] = 67240450;
      v12[1] = v7;
      __int16 v13 = 2082;
      uint64_t v14 = v11;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "e5rt_precompiled_compute_op_create_options_set_operation_name failed: (%{public}d): %{public}s", (uint8_t *)v12, 0x12u);
    }
  }
  return v7 == 0;
}

BOOL sub_1DC3187A0(uint64_t a1, _DWORD *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = sub_1DC3154F4();
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 336))(a1, 1);
  *a2 = v5;
  if (v5)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v6 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))v4)(v5);
      uint64_t v9 = "";
      if (v8) {
        uint64_t v9 = (const char *)v8;
      }
      v10[0] = 67240450;
      v10[1] = v5;
      __int16 v11 = 2082;
      uint64_t v12 = v9;
      _os_log_error_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_ERROR, "e5rt_precompiled_compute_op_create_options_set_allocate_intermediate_buffers failed: (%{public}d): %{public}s", (uint8_t *)v10, 0x12u);
    }
  }
  return v5 == 0;
}

BOOL sub_1DC3188E0(uint64_t a1, uint64_t *a2, unsigned __int8 a3, _DWORD *a4)
{
  int v7 = a3;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = sub_1DC3154F4();
  if (v7) {
    uint64_t v9 = *a2;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 344))(a1, v9);
  *a4 = v10;
  if (v10)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    __int16 v11 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t))v8)(v10);
      uint64_t v14 = "";
      if (v13) {
        uint64_t v14 = (const char *)v13;
      }
      v15[0] = 67240450;
      v15[1] = v10;
      __int16 v16 = 2082;
      uint64_t v17 = v14;
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "e5rt_precompiled_compute_op_create_options_set_override_compute_gpu_device failed: (%{public}d): %{public}s", (uint8_t *)v15, 0x12u);
    }
  }
  return v10 == 0;
}

void sub_1DC318A3C(unsigned char *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  uint64_t v6 = sub_1DC3154F4();
  uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(v6 + 312))(&v11, a2);
  *a3 = v7;
  if (v7)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v8 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = (*(uint64_t (**)(uint64_t))v6)(v7);
      uint64_t v10 = "";
      if (v9) {
        uint64_t v10 = (const char *)v9;
      }
      *(_DWORD *)CGAffineTransform buf = 67240450;
      *(_DWORD *)&buf[4] = v7;
      __int16 v13 = 2082;
      uint64_t v14 = v10;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "e5rt_precompiled_compute_op_create_options_create_with_program_function failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    *a1 = 0;
    a1[8] = 0;
  }
  else
  {
    *(void *)CGAffineTransform buf = 0;
    *(void *)a1 = v11;
    a1[8] = 1;
    sub_1DC318BB0(buf);
  }
}

void sub_1DC318BA4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1DC2FFA58(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_1DC318BB0(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365E310;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A2B0);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC318C44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC318C58()
{
  return &unk_1F365DA88;
}

uint64_t sub_1DC318C64(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP42e5rt_precompiled_compute_op_create_optionsEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC318CA0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 320))(*(void *)(a1 + 8));
}

uint64_t sub_1DC318CC0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365E310;
  a2[1] = v2;
  return result;
}

void *sub_1DC318CE4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365E310;
  result[1] = v3;
  return result;
}

void sub_1DC318D2C()
{
}

void sub_1DC318D44(unsigned char *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  uint64_t v6 = sub_1DC3154F4();
  uint64_t v7 = (*(uint64_t (**)(uint64_t *, uint64_t))(v6 + 368))(&v11, a2);
  *a3 = v7;
  if (v7)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v8 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = (*(uint64_t (**)(uint64_t))v6)(v7);
      uint64_t v10 = "";
      if (v9) {
        uint64_t v10 = (const char *)v9;
      }
      *(_DWORD *)CGAffineTransform buf = 67240450;
      *(_DWORD *)&buf[4] = v7;
      __int16 v13 = 2082;
      uint64_t v14 = v10;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_operation_create_precompiled_compute_operation_with_options failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    *a1 = 0;
    a1[8] = 0;
  }
  else
  {
    *(void *)CGAffineTransform buf = 0;
    *(void *)a1 = v11;
    a1[8] = 1;
    sub_1DC318EB8(buf);
  }
}

void sub_1DC318EAC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1DC2FFA58(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_1DC318EB8(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365E2B8;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A2C0);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC318F4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC318F60()
{
  return &unk_1F365DA78;
}

uint64_t sub_1DC318F6C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP31e5rt_execution_stream_operationEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC318FA8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 376))(*(void *)(a1 + 8));
}

uint64_t sub_1DC318FC8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365E2B8;
  a2[1] = v2;
  return result;
}

void *sub_1DC318FEC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365E2B8;
  result[1] = v3;
  return result;
}

void sub_1DC319034()
{
}

void *sub_1DC31904C(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365E100;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A2D0);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC3190E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC3190F4()
{
  return &unk_1F365DA28;
}

uint64_t sub_1DC319100(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP21e5rt_execution_streamEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC31913C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 392))(*(void *)(a1 + 8));
}

uint64_t sub_1DC31915C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365E100;
  a2[1] = v2;
  return result;
}

void *sub_1DC319180(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365E100;
  result[1] = v3;
  return result;
}

void sub_1DC3191C8()
{
}

uint64_t sub_1DC3191E0(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1DC31923C(uint64_t a1)
{
  sub_1DC319278(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1DC319278(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      uint64_t v2 = (void *)*v1;
      sub_1DC3192BC((uint64_t)(v1 + 2));
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void sub_1DC3192BC(uint64_t a1)
{
  sub_1DC317BA4((void *)(a1 + 32));
  sub_1DC317C4C((void *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t sub_1DC31931C(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  uint64_t v5 = *((void *)a2 + 3);
  uint64_t v6 = *((void *)a2 + 4);
  *((void *)a2 + 4) = 0;
  *(void *)(a1 + 24) = v5;
  *(void *)(a1 + 32) = v6;
  uint64_t v7 = *((void *)a2 + 5);
  *((void *)a2 + 5) = 0;
  *(void *)(a1 + 40) = v7;
  sub_1DC31938C(a1 + 48, (uint64_t *)a2 + 6);
  sub_1DC31938C(a1 + 88, (uint64_t *)a2 + 11);
  return a1;
}

uint64_t sub_1DC31938C(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *(void *)uint64_t result = v2;
  *(void *)(result + 8) = a2[1];
  a2[1] = 0;
  uint64_t v5 = a2[2];
  uint64_t v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 16;
    void *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void sub_1DC3193FC(uint64_t a1, uint64_t *a2)
{
  if (*(void *)(a1 + 24))
  {
    sub_1DC319278(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4)
    {
      for (uint64_t i = 0; i != v4; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v6 = *a2;
  *a2 = 0;
  unint64_t v7 = *(void **)a1;
  *(void *)a1 = v6;
  if (v7) {
    operator delete(v7);
  }
  uint64_t v10 = a2[2];
  uint64_t v9 = a2 + 2;
  uint64_t v8 = v10;
  uint64_t v11 = *(v9 - 1);
  *(void *)(a1 + 16) = v10;
  *(void *)(a1 + 8) = v11;
  *(v9 - 1) = 0;
  uint64_t v12 = v9[1];
  *(void *)(a1 + 24) = v12;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v9 + 4);
  if (v12)
  {
    unint64_t v13 = *(void *)(v8 + 8);
    unint64_t v14 = *(void *)(a1 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v13 >= v14) {
        v13 %= v14;
      }
    }
    else
    {
      v13 &= v14 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v13) = a1 + 16;
    *uint64_t v9 = 0;
    v9[1] = 0;
  }
}

uint64_t sub_1DC3194D4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*(char *)(a3 + 23) >= 0) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = *(void *)a3;
  }
  uint64_t v23 = 0;
  uint64_t v9 = sub_1DC3154F4();
  uint64_t v10 = (*(uint64_t (**)(void, uint64_t, __CFString **))(v9 + 352))(*(void *)(a2 + 40), v8, &v23);
  int v22 = v10;
  if (v10)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v11 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = (*(uint64_t (**)(uint64_t))v9)(v10);
      uint64_t v17 = "";
      if (v16) {
        uint64_t v17 = (const char *)v16;
      }
      *(_DWORD *)CGAffineTransform buf = 67240450;
      *(_DWORD *)&buf[4] = v10;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v17;
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_operation_retain_input_port failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    LOBYTE(v20[0]) = 0;
    char v21 = 0;
    BOOL v12 = 1;
  }
  else
  {
    *(void *)CGAffineTransform buf = v23;
    sub_1DC316E8C((uint64_t)v20, buf, &v22);
    sub_1DC317C4C(buf);
    BOOL v12 = v21 == 0;
  }
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  unint64_t v13 = qword_1EBFFC3D8;
  if (!v12)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a3 + 23) >= 0) {
        uint64_t v19 = a3;
      }
      else {
        uint64_t v19 = *(void *)a3;
      }
      *(_DWORD *)CGAffineTransform buf = 134283779;
      *(void *)&buf[4] = v20[0];
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v19;
      _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "E5RTNetwork: retrieved input port %{private}p: %{public}s", buf, 0x16u);
    }
    sub_1DC319844(a2 + 48, a3, a3, (uint64_t)v20);
    operator new();
  }
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v18 = a3;
    }
    else {
      uint64_t v18 = *(void *)a3;
    }
    *(_DWORD *)CGAffineTransform buf = 136446210;
    *(void *)&buf[4] = v18;
    _os_log_error_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to get input port: %{public}s", buf, 0xCu);
  }
  uint64_t v23 = @"Unable to get an input port.";
  *(void *)CGAffineTransform buf = -6004;
  sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)&v23);
  int v14 = v22;
  if (!*(unsigned char *)(a4 + 52)) {
    *(unsigned char *)(a4 + 52) = 1;
  }
  *(_DWORD *)(a4 + 48) = v14;
  *a1 = 0;
  return sub_1DC31A180((uint64_t)v20);
}

void sub_1DC3197FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1DC319844(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(char *)(a2 + 23);
  if (v8 >= 0) {
    uint64_t v9 = (void *)a2;
  }
  else {
    uint64_t v9 = *(void **)a2;
  }
  if (v8 >= 0) {
    unint64_t v10 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v10 = *(void *)(a2 + 8);
  }
  if (v10 > 0x20)
  {
    if (v10 > 0x40)
    {
      uint64_t v37 = *(void *)((char *)v9 + v10 - 48);
      uint64_t v38 = *(void *)((char *)v9 + v10 - 40);
      uint64_t v39 = *(void *)((char *)v9 + v10 - 24);
      uint64_t v40 = *(void *)((char *)v9 + v10 - 56);
      uint64_t v41 = *(void *)((char *)v9 + v10 - 16);
      uint64_t v42 = *(void *)((char *)v9 + v10 - 8);
      unint64_t v43 = v40 + v41;
      unint64_t v44 = 0x9DDFEA08EB382D69
          * (v39 ^ ((0x9DDFEA08EB382D69 * (v39 ^ (v37 + v10))) >> 47) ^ (0x9DDFEA08EB382D69 * (v39 ^ (v37 + v10))));
      unint64_t v45 = 0x9DDFEA08EB382D69 * (v44 ^ (v44 >> 47));
      unint64_t v46 = *(void *)((char *)v9 + v10 - 64) + v10;
      unint64_t v47 = v46 + v40 + v37;
      uint64_t v48 = v47 + v38;
      uint64_t v49 = __ROR8__(v47, 44) + v46 + __ROR8__(v38 + v46 + v45, 21);
      uint64_t v50 = v40 + v41 + *(void *)((char *)v9 + v10 - 32) - 0x4B6D499041670D8DLL;
      uint64_t v51 = v50 + v39 + v41;
      uint64_t v52 = v51 + v42;
      uint64_t v53 = __ROR8__(v51, 44) + v50 + __ROR8__(v50 + v38 + v42, 21);
      uint64_t v54 = v9 + 4;
      uint64_t v55 = *v9 - 0x4B6D499041670D8DLL * v38;
      uint64_t v56 = -(uint64_t)((v10 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        uint64_t v57 = *(v54 - 3);
        uint64_t v58 = v55 + v48 + v43 + v57;
        uint64_t v59 = v54[2];
        uint64_t v60 = v54[3];
        uint64_t v61 = v54[1];
        unint64_t v43 = v61 + v48 - 0x4B6D499041670D8DLL * __ROR8__(v43 + v49 + v59, 42);
        uint64_t v62 = v45 + v52;
        uint64_t v63 = *(v54 - 2);
        uint64_t v64 = *(v54 - 1);
        uint64_t v65 = *(v54 - 4) - 0x4B6D499041670D8DLL * v49;
        uint64_t v66 = v65 + v52 + v64;
        uint64_t v67 = v65 + v57 + v63;
        uint64_t v48 = v67 + v64;
        uint64_t v68 = __ROR8__(v67, 44) + v65;
        unint64_t v69 = (0xB492B66FBE98F273 * __ROR8__(v58, 37)) ^ v53;
        uint64_t v55 = 0xB492B66FBE98F273 * __ROR8__(v62, 33);
        uint64_t v49 = v68 + __ROR8__(v66 + v69, 21);
        uint64_t v70 = v55 + v53 + *v54;
        uint64_t v52 = v70 + v61 + v59 + v60;
        uint64_t v53 = __ROR8__(v70 + v61 + v59, 44) + v70 + __ROR8__(v43 + v63 + v70 + v60, 21);
        v54 += 8;
        unint64_t v45 = v69;
        v56 += 64;
      }
      while (v56);
      unint64_t v71 = v55
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v53 ^ ((0x9DDFEA08EB382D69 * (v53 ^ v49)) >> 47) ^ (0x9DDFEA08EB382D69 * (v53 ^ v49)))) ^ ((0x9DDFEA08EB382D69 * (v53 ^ ((0x9DDFEA08EB382D69 * (v53 ^ v49)) >> 47) ^ (0x9DDFEA08EB382D69 * (v53 ^ v49)))) >> 47));
      unint64_t v72 = 0x9DDFEA08EB382D69
          * (v71 ^ (v69
                  - 0x4B6D499041670D8DLL * (v43 ^ (v43 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v52 ^ ((0x9DDFEA08EB382D69 * (v52 ^ v48)) >> 47) ^ (0x9DDFEA08EB382D69 * (v52 ^ v48)))) ^ ((0x9DDFEA08EB382D69 * (v52 ^ ((0x9DDFEA08EB382D69 * (v52 ^ v48)) >> 47) ^ (0x9DDFEA08EB382D69 * (v52 ^ v48)))) >> 47))));
      unint64_t v13 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69 * (v71 ^ (v72 >> 47) ^ v72)) ^ ((0x9DDFEA08EB382D69 * (v71 ^ (v72 >> 47) ^ v72)) >> 47));
      goto LABEL_19;
    }
    uint64_t v14 = *(void *)((char *)v9 + v10 - 16);
    uint64_t v15 = *v9 - 0x3C5A37A36834CED9 * (v14 + v10);
    uint64_t v17 = v9[2];
    uint64_t v16 = v9[3];
    uint64_t v18 = __ROR8__(v15 + v16, 52);
    uint64_t v19 = v15 + v9[1];
    uint64_t v20 = __ROR8__(v19, 7);
    uint64_t v21 = v19 + v17;
    uint64_t v22 = *(void *)((char *)v9 + v10 - 32) + v17;
    uint64_t v23 = *(void *)((char *)v9 + v10 - 8) + v16;
    uint64_t v24 = __ROR8__(v23 + v22, 52);
    uint64_t v25 = v20 + __ROR8__(*v9 - 0x3C5A37A36834CED9 * (v14 + v10), 37) + v18 + __ROR8__(v21, 31);
    uint64_t v26 = *(void *)((char *)v9 + v10 - 24) + v22 + v14;
    uint64_t v27 = v26 + v23;
    unint64_t v28 = 0x9AE16A3B2F90404FLL;
    unint64_t v29 = 0xC3A5C85C97CB3127 * (v27 + v25)
        - 0x651E95C4D06FBFB1
        * (v21
         + v16
         + __ROR8__(v22, 37)
         + __ROR8__(*(void *)((char *)v9 + v10 - 24) + v22, 7)
         + v24
         + __ROR8__(v26, 31));
    unint64_t v30 = v25 - 0x3C5A37A36834CED9 * (v29 ^ (v29 >> 47));
    goto LABEL_15;
  }
  if (v10 > 0x10)
  {
    uint64_t v31 = v9[1];
    unint64_t v32 = 0xB492B66FBE98F273 * *v9;
    uint64_t v33 = __ROR8__(0x9AE16A3B2F90404FLL * *(void *)((char *)v9 + v10 - 8), 30) + __ROR8__(v32 - v31, 43);
    unint64_t v34 = v32
        + v10
        + __ROR8__(v31 ^ 0xC949D7C7509E6557, 20)
        - 0x9AE16A3B2F90404FLL * *(void *)((char *)v9 + v10 - 8);
    unint64_t v28 = 0x9DDFEA08EB382D69;
    unint64_t v35 = 0x9DDFEA08EB382D69 * (v34 ^ (v33 - 0x3C5A37A36834CED9 * *(void *)((char *)v9 + v10 - 16)));
    unint64_t v36 = v34 ^ (v35 >> 47) ^ v35;
LABEL_14:
    unint64_t v30 = 0x9DDFEA08EB382D69 * v36;
LABEL_15:
    unint64_t v13 = (v30 ^ (v30 >> 47)) * v28;
    goto LABEL_19;
  }
  if (v10 >= 9)
  {
    uint64_t v11 = *(void *)((char *)v9 + v10 - 8);
    uint64_t v12 = __ROR8__(v11 + v10, v10);
    unint64_t v13 = (0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v12 ^ ((0x9DDFEA08EB382D69 * (v12 ^ *v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v12 ^ *v9)))) ^ ((0x9DDFEA08EB382D69 * (v12 ^ ((0x9DDFEA08EB382D69 * (v12 ^ *v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v12 ^ *v9)))) >> 47))) ^ v11;
    goto LABEL_19;
  }
  if (v10 >= 4)
  {
    uint64_t v112 = *(unsigned int *)((char *)v9 + v10 - 4);
    unint64_t v28 = 0x9DDFEA08EB382D69;
    unint64_t v113 = 0x9DDFEA08EB382D69 * ((v10 + (8 * *(_DWORD *)v9)) ^ v112);
    unint64_t v36 = v112 ^ (v113 >> 47) ^ v113;
    goto LABEL_14;
  }
  unint64_t v13 = 0x9AE16A3B2F90404FLL;
  if (v10)
  {
    unint64_t v119 = (0xC949D7C7509E6557 * (v10 + 4 * *((unsigned __int8 *)v9 + v10 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)v9 | ((unint64_t)*((unsigned __int8 *)v9 + (v10 >> 1)) << 8)));
    unint64_t v13 = 0x9AE16A3B2F90404FLL * (v119 ^ (v119 >> 47));
  }
LABEL_19:
  unint64_t v73 = *(void *)(a1 + 8);
  if (v73)
  {
    uint8x8_t v74 = (uint8x8_t)vcnt_s8((int8x8_t)v73);
    v74.i16[0] = vaddlv_u8(v74);
    unint64_t v75 = v74.u32[0];
    if (v74.u32[0] > 1uLL)
    {
      unint64_t v4 = v13;
      if (v13 >= v73) {
        unint64_t v4 = v13 % v73;
      }
    }
    else
    {
      unint64_t v4 = (v73 - 1) & v13;
    }
    uint64_t v76 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v76)
    {
      for (uint64_t i = *v76; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v78 = i[1];
        if (v78 == v13)
        {
          uint64_t v79 = *((unsigned __int8 *)i + 39);
          if ((v79 & 0x80u) == 0) {
            uint64_t v80 = *((unsigned __int8 *)i + 39);
          }
          else {
            uint64_t v80 = i[3];
          }
          if (v80 == v10)
          {
            uint64_t v81 = (const void **)(i + 2);
            if ((v79 & 0x80) != 0)
            {
              if (!memcmp(*v81, v9, i[3])) {
                return i;
              }
            }
            else
            {
              if (!*((unsigned char *)i + 39)) {
                return i;
              }
              uint64_t v82 = v79 - 1;
              uint64_t v83 = (unsigned __int8 *)v9;
              do
              {
                int v85 = *(unsigned __int8 *)v81;
                uint64_t v81 = (const void **)((char *)v81 + 1);
                int v84 = v85;
                int v87 = *v83++;
                int v86 = v87;
                BOOL v89 = v82-- != 0;
              }
              while (v84 == v86 && v89);
              if (v84 == v86) {
                return i;
              }
            }
          }
        }
        else
        {
          if (v75 > 1)
          {
            if (v78 >= v73) {
              v78 %= v73;
            }
          }
          else
          {
            v78 &= v73 - 1;
          }
          if (v78 != v4) {
            break;
          }
        }
      }
    }
  }
  long long v90 = (void *)(a1 + 16);
  long long v91 = (char *)operator new(0xB8uLL);
  v121[0] = v91;
  v121[1] = a1 + 16;
  char v122 = 0;
  *(void *)long long v91 = 0;
  *((void *)v91 + 1) = v13;
  uint64_t v92 = v91 + 16;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1DC312750(v92, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v92 = *(_OWORD *)a3;
    *((void *)v91 + 4) = *(void *)(a3 + 16);
  }
  long long v93 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)(v91 + 40) = *(_OWORD *)a4;
  long long v94 = *(_OWORD *)(a4 + 64);
  *(_OWORD *)(v91 + 120) = *(_OWORD *)(a4 + 80);
  long long v95 = *(_OWORD *)(a4 + 112);
  *(_OWORD *)(v91 + 136) = *(_OWORD *)(a4 + 96);
  *(_OWORD *)(v91 + 152) = v95;
  *(_OWORD *)(v91 + 168) = *(_OWORD *)(a4 + 128);
  *(_OWORD *)(v91 + 56) = v93;
  long long v96 = *(_OWORD *)(a4 + 48);
  *(_OWORD *)(v91 + 72) = *(_OWORD *)(a4 + 32);
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(_OWORD *)(v91 + 88) = v96;
  *(_OWORD *)(v91 + 104) = v94;
  char v122 = 1;
  float v97 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v98 = *(float *)(a1 + 32);
  if (!v73 || (float)(v98 * (float)v73) < v97)
  {
    BOOL v99 = v73 < 3 || (v73 & (v73 - 1)) != 0;
    unint64_t v100 = v99 | (2 * v73);
    unint64_t v101 = vcvtps_u32_f32(v97 / v98);
    if (v100 <= v101) {
      int8x8_t prime = (int8x8_t)v101;
    }
    else {
      int8x8_t prime = (int8x8_t)v100;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v73 = *(void *)(a1 + 8);
    if (*(void *)&prime > v73) {
      goto LABEL_67;
    }
    if (*(void *)&prime < v73)
    {
      unint64_t v109 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v73 < 3 || (uint8x8_t v110 = (uint8x8_t)vcnt_s8((int8x8_t)v73), v110.i16[0] = vaddlv_u8(v110), v110.u32[0] > 1uLL))
      {
        unint64_t v109 = std::__next_prime(v109);
      }
      else
      {
        uint64_t v111 = 1 << -(char)__clz(v109 - 1);
        if (v109 >= 2) {
          unint64_t v109 = v111;
        }
      }
      if (*(void *)&prime <= v109) {
        int8x8_t prime = (int8x8_t)v109;
      }
      if (*(void *)&prime >= v73)
      {
        unint64_t v73 = *(void *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_67:
          if (*(void *)&prime >> 61) {
            sub_1DC2FF994();
          }
          float64x2_t v103 = operator new(8 * *(void *)&prime);
          double v104 = *(void **)a1;
          *(void *)a1 = v103;
          if (v104) {
            operator delete(v104);
          }
          uint64_t v105 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v105++) = 0;
          while (*(void *)&prime != v105);
          unint64_t v106 = (void *)*v90;
          if (*v90)
          {
            unint64_t v107 = v106[1];
            uint8x8_t v108 = (uint8x8_t)vcnt_s8(prime);
            v108.i16[0] = vaddlv_u8(v108);
            if (v108.u32[0] > 1uLL)
            {
              if (v107 >= *(void *)&prime) {
                v107 %= *(void *)&prime;
              }
            }
            else
            {
              v107 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v107) = v90;
            uint64_t v114 = (void *)*v106;
            if (*v106)
            {
              do
              {
                unint64_t v115 = v114[1];
                if (v108.u32[0] > 1uLL)
                {
                  if (v115 >= *(void *)&prime) {
                    v115 %= *(void *)&prime;
                  }
                }
                else
                {
                  v115 &= *(void *)&prime - 1;
                }
                if (v115 != v107)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v115))
                  {
                    *(void *)(*(void *)a1 + 8 * v115) = v106;
                    goto LABEL_94;
                  }
                  *unint64_t v106 = *v114;
                  *uint64_t v114 = **(void **)(*(void *)a1 + 8 * v115);
                  **(void **)(*(void *)a1 + 8 * v115) = v114;
                  uint64_t v114 = v106;
                }
                unint64_t v115 = v107;
LABEL_94:
                unint64_t v106 = v114;
                uint64_t v114 = (void *)*v114;
                unint64_t v107 = v115;
              }
              while (v114);
            }
          }
          unint64_t v73 = (unint64_t)prime;
          goto LABEL_98;
        }
        uint64_t v120 = *(void **)a1;
        *(void *)a1 = 0;
        if (v120) {
          operator delete(v120);
        }
        unint64_t v73 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_98:
    if ((v73 & (v73 - 1)) != 0)
    {
      if (v13 >= v73) {
        unint64_t v4 = v13 % v73;
      }
      else {
        unint64_t v4 = v13;
      }
    }
    else
    {
      unint64_t v4 = (v73 - 1) & v13;
    }
  }
  uint64_t v116 = *(void **)(*(void *)a1 + 8 * v4);
  uint64_t i = (uint64_t *)v121[0];
  if (v116)
  {
    *(void *)v121[0] = *v116;
LABEL_111:
    *uint64_t v116 = i;
    goto LABEL_112;
  }
  *(void *)v121[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(*(void *)a1 + 8 * v4) = v90;
  if (*i)
  {
    unint64_t v117 = *(void *)(*i + 8);
    if ((v73 & (v73 - 1)) != 0)
    {
      if (v117 >= v73) {
        v117 %= v73;
      }
    }
    else
    {
      v117 &= v73 - 1;
    }
    uint64_t v116 = (void *)(*(void *)a1 + 8 * v117);
    goto LABEL_111;
  }
LABEL_112:
  v121[0] = 0;
  ++*(void *)(a1 + 24);
  sub_1DC31A1C4((uint64_t)v121);
  return i;
}

void sub_1DC31A168(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC31A1C4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC31A180(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 144))
  {
    sub_1DC317BA4((void *)(a1 + 8));
    sub_1DC317C4C((void *)a1);
  }
  return a1;
}

void sub_1DC31A1C4(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1DC3192BC((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

uint64_t sub_1DC31A21C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*(char *)(a3 + 23) >= 0) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = *(void *)a3;
  }
  uint64_t v23 = 0;
  uint64_t v9 = sub_1DC3154F4();
  uint64_t v10 = (*(uint64_t (**)(void, uint64_t, __CFString **))(v9 + 360))(*(void *)(a2 + 40), v8, &v23);
  int v22 = v10;
  if (v10)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v11 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = (*(uint64_t (**)(uint64_t))v9)(v10);
      uint64_t v17 = "";
      if (v16) {
        uint64_t v17 = (const char *)v16;
      }
      *(_DWORD *)CGAffineTransform buf = 67240450;
      *(_DWORD *)&buf[4] = v10;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v17;
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_operation_retain_output_port failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    LOBYTE(v20[0]) = 0;
    char v21 = 0;
    BOOL v12 = 1;
  }
  else
  {
    *(void *)CGAffineTransform buf = v23;
    sub_1DC316E8C((uint64_t)v20, buf, &v22);
    sub_1DC317C4C(buf);
    BOOL v12 = v21 == 0;
  }
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  unint64_t v13 = qword_1EBFFC3D8;
  if (!v12)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a3 + 23) >= 0) {
        uint64_t v19 = a3;
      }
      else {
        uint64_t v19 = *(void *)a3;
      }
      *(_DWORD *)CGAffineTransform buf = 134283779;
      *(void *)&buf[4] = v20[0];
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v19;
      _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "E5RTNetwork: retrieved output port %{private}p: %{public}s", buf, 0x16u);
    }
    sub_1DC319844(a2 + 88, a3, a3, (uint64_t)v20);
    operator new();
  }
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v18 = a3;
    }
    else {
      uint64_t v18 = *(void *)a3;
    }
    *(_DWORD *)CGAffineTransform buf = 136446210;
    *(void *)&buf[4] = v18;
    _os_log_error_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to get output port: %{public}s", buf, 0xCu);
  }
  uint64_t v23 = @"Unable to get an output port.";
  *(void *)CGAffineTransform buf = -6004;
  sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)&v23);
  int v14 = v22;
  if (!*(unsigned char *)(a4 + 52)) {
    *(unsigned char *)(a4 + 52) = 1;
  }
  *(_DWORD *)(a4 + 48) = v14;
  *a1 = 0;
  return sub_1DC31A180((uint64_t)v20);
}

void sub_1DC31A544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC31A58C(uint64_t a1, qos_class_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  v37[0] = &unk_1F365DE98;
  v37[1] = a1;
  uint64_t v38 = v37;
  uint64_t v39 = a4;
  v36[0] = &unk_1F365DEF0;
  v36[1] = a1;
  v36[3] = v36;
  sub_1DC31AD78((uint64_t)v40, (uint64_t)v36);
  if (*(unsigned char *)(v39 + 8)) {
    BOOL v7 = v38 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    sub_1DC31AE10((uint64_t)v38, *(void *)v39);
  }
  sub_1DC31AE60(v36);
  sub_1DC31AE60(v37);
  if ((*(unsigned char *)(a1 + 27) & 1) == 0)
  {
    if (qword_1EBFFC3F8[0] != -1) {
      dispatch_once_f(qword_1EBFFC3F8, 0, (dispatch_function_t)sub_1DC3ABAE8);
    }
    if (byte_1EBFFC390)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      uint64_t v8 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)CGAffineTransform buf = 0;
        _os_log_debug_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_DEBUG, "E5RTNetwork: may execute on ANE, setting ANE execution priority from QoS", buf, 2u);
      }
      HIDWORD(v10) = *a2 - 9;
      LODWORD(v10) = HIDWORD(v10);
      unsigned int v9 = v10 >> 2;
      uint64_t v11 = 5;
      if (v9 <= 6 && ((0x22u >> v9) & 1) == 0)
      {
        if ((0x5Du >> v9))
        {
          int v12 = dword_1DC421FC4[v9];
        }
        else
        {
          HIDWORD(v13) = qos_class_self() - 9;
          LODWORD(v13) = HIDWORD(v13);
          int v12 = v13 >> 2;
        }
        uint64_t v11 = *(unsigned int *)&asc_1DC4026A4[4 * v12];
      }
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      int v14 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
      {
        qos_class_t v28 = *a2;
        HIDWORD(v30) = *a2 - 9;
        LODWORD(v30) = HIDWORD(v30);
        unsigned int v29 = v30 >> 2;
        if (v29 > 6 || ((1 << v29) & 0x5D) == 0) {
          qos_class_t v28 = qos_class_self();
        }
        *(_DWORD *)CGAffineTransform buf = 67240448;
        *(_DWORD *)&buf[4] = v28;
        __int16 v43 = 1026;
        LODWORD(v44) = v11;
        _os_log_debug_impl(&dword_1DC2FE000, v14, OS_LOG_TYPE_DEBUG, "E5RTExecutionStream: QoS %{public}x mapped to E5RT ANE execution priority %{public}d", buf, 0xEu);
      }
      uint64_t v15 = sub_1DC3154F4();
      uint64_t v16 = (*(uint64_t (**)(void, uint64_t))(v15 + 432))(*(void *)(a1 + 32), v11);
      if (v16)
      {
        if (qword_1EBFFC3D0 != -1) {
          dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
        }
        uint64_t v17 = qword_1EBFFC3D8;
        if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v31 = (*(uint64_t (**)(uint64_t))v15)(v16);
          unint64_t v32 = "";
          if (v31) {
            unint64_t v32 = (const char *)v31;
          }
          *(_DWORD *)CGAffineTransform buf = 67240450;
          *(_DWORD *)&buf[4] = v16;
          __int16 v43 = 2082;
          unint64_t v44 = v32;
          _os_log_error_impl(&dword_1DC2FE000, v17, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_set_ane_execution_priority failed: (%{public}d): %{public}s", buf, 0x12u);
        }
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)CGAffineTransform buf = 67240192;
          *(_DWORD *)&buf[4] = v11;
          _os_log_error_impl(&dword_1DC2FE000, v17, OS_LOG_TYPE_ERROR, "E5RTExecutionStream: failed to set ANE execution priority %{public}d", buf, 8u);
        }
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)CGAffineTransform buf = 0;
          _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set ANE execution priority from QoS", buf, 2u);
        }
        *(void *)CGAffineTransform buf = -6005;
        unint64_t v35 = @"Unable to set ANE execution priority from QoS.";
        sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v35);
        if (!*(unsigned char *)(a3 + 52)) {
          *(unsigned char *)(a3 + 52) = 1;
        }
        uint64_t v18 = 0;
        *(_DWORD *)(a3 + 48) = v16;
        goto LABEL_63;
      }
    }
  }
  uint64_t v19 = sub_1DC3154F4();
  uint64_t v20 = (*(uint64_t (**)(void, void))(v19 + 400))(*(void *)(a1 + 32), *(void *)(a1 + 40));
  if (v20)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    char v21 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_43;
    }
    uint64_t v22 = (*(uint64_t (**)(uint64_t))v19)(v20);
    uint64_t v23 = "";
    if (v22) {
      uint64_t v23 = (const char *)v22;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v20;
    __int16 v43 = 2082;
    unint64_t v44 = v23;
    _os_log_error_impl(&dword_1DC2FE000, v21, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_encode_operation failed: (%{public}d): %{public}s", buf, 0x12u);
  }
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
LABEL_43:
  uint64_t v24 = qword_1EBFFC3D8;
  if (v20)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CGAffineTransform buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v24, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to encode execution stream operation", buf, 2u);
    }
    *(void *)CGAffineTransform buf = -6005;
    unint64_t v35 = @"Unable to encode execution stream operation.";
    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v35);
    if (!*(unsigned char *)(a3 + 52)) {
      *(unsigned char *)(a3 + 52) = 1;
    }
    uint64_t v18 = 0;
    *(_DWORD *)(a3 + 48) = v20;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)CGAffineTransform buf = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v24, OS_LOG_TYPE_DEBUG, "E5RTNetwork: done encoding execution stream operation", buf, 2u);
    }
    uint64_t v25 = (*(uint64_t (**)(void))(v19 + 408))(*(void *)(a1 + 32));
    if (v25)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      uint64_t v26 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v33 = (*(uint64_t (**)(uint64_t))v19)(v25);
        unint64_t v34 = "";
        if (v33) {
          unint64_t v34 = (const char *)v33;
        }
        *(_DWORD *)CGAffineTransform buf = 67240450;
        *(_DWORD *)&buf[4] = v25;
        __int16 v43 = 2082;
        unint64_t v44 = v34;
        _os_log_error_impl(&dword_1DC2FE000, v26, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_execute_sync failed: (%{public}d): %{public}s", buf, 0x12u);
      }
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CGAffineTransform buf = 0;
        _os_log_error_impl(&dword_1DC2FE000, v24, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to execute excution stream", buf, 2u);
      }
      *(void *)CGAffineTransform buf = -6005;
      unint64_t v35 = @"Unable to execute excution stream.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v35);
      if (!*(unsigned char *)(a3 + 52)) {
        *(unsigned char *)(a3 + 52) = 1;
      }
      uint64_t v18 = 0;
      *(_DWORD *)(a3 + 48) = v25;
    }
    else
    {
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)CGAffineTransform buf = 0;
        _os_log_debug_impl(&dword_1DC2FE000, v24, OS_LOG_TYPE_DEBUG, "E5RTNetwork: done executing execution stream", buf, 2u);
      }
      uint64_t v18 = 1;
    }
  }
LABEL_63:
  if (*(unsigned char *)(v39 + 8) && v41) {
    sub_1DC31AE10(v41, *(void *)v39);
  }
  sub_1DC31AE60(v40);
  return v18;
}

void sub_1DC31AD20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_1DC31AEE4((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC31AD78(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_1DC31AE10(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (!a1) {
    sub_1DC307C38();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v3);
}

void *sub_1DC31AE60(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t **sub_1DC31AEE4(uint64_t **a1)
{
  uint64_t v2 = *a1;
  if (*((unsigned char *)*a1 + 8))
  {
    uint64_t v3 = (uint64_t)a1[4];
    if (v3) {
      sub_1DC31AE10(v3, *v2);
    }
  }
  sub_1DC31AE60(a1 + 1);
  return a1;
}

void *sub_1DC31AF30()
{
  return &unk_1F365D9C8;
}

uint64_t sub_1DC31AF3C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork7executeERKNS_7Context3QoSERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC31AF78(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = *a2;
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    unint64_t v4 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      if (*((char *)v3 + 23) < 0) {
        uint64_t v3 = (uint64_t *)*v3;
      }
      int v5 = 136446210;
      uint64_t v6 = v3;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_END, v2, "E5RTNetwork::execute", "name=%{public, signpost.description:attribute}s", (uint8_t *)&v5, 0xCu);
    }
  }
}

uint64_t sub_1DC31B074(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365DEF0;
  a2[1] = v2;
  return result;
}

void *sub_1DC31B098(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365DEF0;
  result[1] = v3;
  return result;
}

void sub_1DC31B0E0()
{
}

void *sub_1DC31B0F8()
{
  return &unk_1F365D9B8;
}

uint64_t sub_1DC31B104(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork7executeERKNS_7Context3QoSERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC31B140(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = *a2;
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    unint64_t v4 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      if (*((char *)v3 + 23) < 0) {
        uint64_t v3 = (uint64_t *)*v3;
      }
      int v5 = 136446210;
      uint64_t v6 = v3;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v2, "E5RTNetwork::execute", "name=%{public, signpost.description:attribute}s", (uint8_t *)&v5, 0xCu);
    }
  }
}

uint64_t sub_1DC31B23C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365DE98;
  a2[1] = v2;
  return result;
}

void *sub_1DC31B260(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365DE98;
  result[1] = v3;
  return result;
}

void sub_1DC31B2A8()
{
}

BOOL sub_1DC31B2C0(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (uint64_t (**)(uint64_t))sub_1DC3154F4();
  uint64_t v5 = v4[53](a1);
  if (!v5)
  {
LABEL_8:
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    goto LABEL_10;
  }
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  uint64_t v6 = qword_1EBFFC3D8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v7 = (*v4)(v5);
    uint64_t v8 = "";
    if (v7) {
      uint64_t v8 = (const char *)v7;
    }
    *(_DWORD *)CGAffineTransform buf = 67240450;
    *(_DWORD *)&buf[4] = v5;
    __int16 v13 = 2082;
    int v14 = v8;
    _os_log_error_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_ERROR, "e5rt_execution_stream_reset failed: (%{public}d): %{public}s", buf, 0x12u);
    goto LABEL_8;
  }
LABEL_10:
  unsigned int v9 = qword_1EBFFC3D8;
  if (v5)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CGAffineTransform buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to reset excution stream", buf, 2u);
    }
    uint64_t v11 = @"Unable to reset excution stream.";
    *(void *)CGAffineTransform buf = -6005;
    sub_1DC306334((atomic_ullong *)a2, (uint64_t *)buf, (CFTypeRef *)&v11);
    if (!*(unsigned char *)(a2 + 52)) {
      *(unsigned char *)(a2 + 52) = 1;
    }
    *(_DWORD *)(a2 + 48) = v5;
  }
  else if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)CGAffineTransform buf = 0;
    _os_log_debug_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_DEBUG, "E5RTNetwork: done resetting execution stream", buf, 2u);
  }
  return v5 == 0;
}

void sub_1DC31B4D4(unsigned char *a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, atomic_ullong *a8)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  memset(&__dst, 0, sizeof(__dst));
  sub_1DC31FAC4(&__dst, *(std::string **)a2, (std::string *)(*(void *)a2 + *(void *)(a2 + 8)));
  if (a4)
  {
    if (a4 != 1)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      int v12 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 67240192;
        HIDWORD(buf.__pn_.__r_.__value_.__r.__words[0]) = a4;
        _os_log_error_impl(&dword_1DC2FE000, v12, OS_LOG_TYPE_ERROR, "E5RTNetwork: unrecognized compilation flavor: %{public}d", (uint8_t *)&buf, 8u);
      }
      buf.__pn_.__r_.__value_.__r.__words[0] = -6003;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)@"Unrecognized compilation flavor.";
      sub_1DC306334(a8, (uint64_t *)&buf, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
      goto LABEL_40;
    }
    if (a3)
    {
      if (a3 == 1)
      {
        unint64_t v10 = ".mil";
        std::string::size_type v11 = 4;
        goto LABEL_13;
      }
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      char v21 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 67240192;
        HIDWORD(buf.__pn_.__r_.__value_.__r.__words[0]) = a3;
        _os_log_error_impl(&dword_1DC2FE000, v21, OS_LOG_TYPE_ERROR, "E5RTNetwork: unrecognized network kind: %{public}d", (uint8_t *)&buf, 8u);
      }
      buf.__pn_.__r_.__value_.__r.__words[0] = -6003;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)@"Unrecognized network kind.";
      sub_1DC306334(a8, (uint64_t *)&buf, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
LABEL_40:
      v42[1] = 0;
      uint64_t v43 = 0;
      v42[0] = 0;
      goto LABEL_65;
    }
    unint64_t v10 = ".espresso.net";
    std::string::size_type v11 = 13;
  }
  else
  {
    unint64_t v10 = ".bundle";
    std::string::size_type v11 = 7;
  }
LABEL_13:
  std::string::append(&__dst, v10, v11);
  memset(&__p, 0, sizeof(__p));
  sub_1DC31FAC4(&__p, (std::string *)"Networks", (std::string *)"");
  sub_1DC31F9D0(&buf, (uint64_t)&__p, (std::__fs::filesystem::path *)&__dst);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  std::string __dst = buf.__pn_;
  *((unsigned char *)&buf.__pn_.__r_.__value_.__s + 23) = 0;
  buf.__pn_.__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)p_dst, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (!atomic_load_explicit((atomic_ullong *volatile)&__p, memory_order_acquire))
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v20 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      unint64_t v36 = &__dst;
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unint64_t v36 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
      _os_log_error_impl(&dword_1DC2FE000, v20, OS_LOG_TYPE_ERROR, "E5RTNetwork: CFStringCreateWithCStringNoCopy failed with: %{public}s", (uint8_t *)&buf, 0xCu);
    }
    buf.__pn_.__r_.__value_.__r.__words[0] = -6003;
    unint64_t v46 = @"CFStringCreateWithCStringNoCopy failed.";
    sub_1DC306334(a8, (uint64_t *)&buf, (CFTypeRef *)&v46);
    v42[1] = 0;
    uint64_t v43 = 0;
    v42[0] = 0;
    goto LABEL_64;
  }
  if (qword_1EBFFC3A0 != -1) {
    dispatch_once(&qword_1EBFFC3A0, &unk_1F3664C98);
  }
  int v14 = (__CFBundle *)qword_1EBFFC358;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  uint64_t v15 = qword_1EBFFC3D8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
  {
    std::string::size_type explicit = atomic_load_explicit((atomic_ullong *volatile)&__p, memory_order_acquire);
    LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 138543618;
    *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = explicit;
    WORD2(buf.__pn_.__r_.__value_.__r.__words[1]) = 2114;
    *(std::string::size_type *)((char *)&buf.__pn_.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v14;
    _os_log_debug_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_DEBUG, "E5RTNetwork: attempt to locate %{public}@ from within: %{public}@", (uint8_t *)&buf, 0x16u);
  }
  oslog = v15;
  uint64_t v16 = (void *)atomic_load_explicit((atomic_ullong *volatile)&__p, memory_order_acquire);
  context = (void *)MEMORY[0x1E019D500]();
  if (v14)
  {
    CFURLRef v18 = CFBundleCopyBundleURL(v14);
    if (v18)
    {
      uint64_t v19 = objc_msgSend_bundleWithURL_(MEMORY[0x1E4F28B50], v17, (uint64_t)v18);
    }
    else
    {
      uint64_t v19 = 0;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  id v22 = v16;
  id v23 = v19;
  if (qword_1EBFFB810 != -1) {
    dispatch_once(&qword_1EBFFB810, &unk_1F365E8C0);
  }
  id v25 = (id)qword_1EBFFBA08;
  if (v25)
  {
    if (qword_1EBFFC270 != -1) {
      dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
    }
    uint64_t v26 = (id)qword_1EBFFC278;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 138543362;
      *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
      _os_log_impl(&dword_1DC2FE000, v26, OS_LOG_TYPE_INFO, "_MRCResourcePath: overriddenBasePath=\"%{public}@\"", (uint8_t *)&buf, 0xCu);
    }

    objc_msgSend_stringByAppendingPathComponent_(v25, v27, (uint64_t)v22);
    qos_class_t v28 = (__CFString *)objc_claimAutoreleasedReturnValue();
    uint64_t v31 = objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v29, v30);
    char v33 = objc_msgSend_fileExistsAtPath_(v31, v32, (uint64_t)v28);

    if (v33) {
      goto LABEL_57;
    }
  }
  if (!v23
    || (objc_msgSend_pathForResource_ofType_(v23, v24, (uint64_t)v22, 0),
        (qos_class_t v28 = (__CFString *)objc_claimAutoreleasedReturnValue()) == 0))
  {
    if (qword_1EAA94E08 != -1) {
      dispatch_once(&qword_1EAA94E08, &unk_1F365E880);
    }
    qos_class_t v28 = 0;
  }
LABEL_57:

  unint64_t v46 = v28;
  if (atomic_load_explicit((atomic_ullong *volatile)&v46, memory_order_acquire))
  {
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
    {
      std::string::size_type v35 = atomic_load_explicit((atomic_ullong *volatile)&v46, memory_order_acquire);
      LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 138543618;
      *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = v35;
      WORD2(buf.__pn_.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__pn_.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v14;
      _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "E5RTNetwork: located %{public}@ from within: %{public}@", (uint8_t *)&buf, 0x16u);
    }
    CFStringGetMaximumSizeOfFileSystemRepresentation((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v46, memory_order_acquire));
    operator new[]();
  }
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
  {
    std::string::size_type v37 = atomic_load_explicit((atomic_ullong *volatile)&__p, memory_order_acquire);
    LODWORD(buf.__pn_.__r_.__value_.__l.__data_) = 138543618;
    *(std::string::size_type *)((char *)buf.__pn_.__r_.__value_.__r.__words + 4) = v37;
    WORD2(buf.__pn_.__r_.__value_.__r.__words[1]) = 2114;
    *(std::string::size_type *)((char *)&buf.__pn_.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v14;
    _os_log_error_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_ERROR, "E5RTNetwork: Unable to locate %{public}@ from within: %{public}@", (uint8_t *)&buf, 0x16u);
  }
  buf.__pn_.__r_.__value_.__r.__words[0] = -6003;
  unint64_t v44 = @"Unable to locate network file.";
  sub_1DC306334(a8, (uint64_t *)&buf, (CFTypeRef *)&v44);
  v42[1] = 0;
  uint64_t v43 = 0;
  v42[0] = 0;
  sub_1DC31FA90((atomic_ullong *)&v46);
LABEL_64:
  sub_1DC31FA90((atomic_ullong *)&__p);
LABEL_65:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  *a1 = 0;
  a1[128] = 0;
}

void sub_1DC31C040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,atomic_ullong a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  MEMORY[0x1E019CE70](v36, 0x1000C8077774924);
  sub_1DC31FA90(&a30);
  sub_1DC31FA90((atomic_ullong *)&a24);
  if (a36 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_1DC31C12C(unsigned char *a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  int v136 = a4;
  uint64_t v135 = a6;
  unint64_t v134 = sub_1DC3B52CC(a7);
  __int16 v13 = operator new(0x28uLL);
  void *v13 = &unk_1F365D530;
  v13[1] = a2;
  v13[2] = &v136;
  uint64_t v13[3] = &v135;
  void v13[4] = &v134;
  long long v149 = v13;
  double v147 = 0;
  int v14 = operator new(0x28uLL);
  void *v14 = &unk_1F365D588;
  v14[1] = a2;
  _DWORD v14[2] = &v136;
  v14[3] = &v135;
  void v14[4] = &v134;
  double v147 = v14;
  uint64_t v150 = a9;
  sub_1DC31AD78((uint64_t)v151, (uint64_t)v146);
  if (*(unsigned char *)(v150 + 8) && v149) {
    sub_1DC31AE10((uint64_t)v149, *(void *)v150);
  }
  sub_1DC31AE60(v146);
  sub_1DC31AE60(v148);
  int v15 = v134;
  if ((v134 & 0x1000000) != 0)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v17 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_18;
    }
    *(_WORD *)std::__fs::filesystem::path buf = 0;
    char v21 = "_ProhibitsANE is explicitly specified, skipping...";
    goto LABEL_188;
  }
  if (qword_1EBFFC3F8[0] != -1) {
    dispatch_once_f(qword_1EBFFC3F8, 0, (dispatch_function_t)sub_1DC3ABAE8);
  }
  int v16 = byte_1EBFFC390;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  uint64_t v17 = qword_1EBFFC3D8;
  BOOL v18 = os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG);
  if (!v16)
  {
    if (!v18)
    {
LABEL_18:
      uint64_t v20 = 0;
      BOOL v19 = 1;
      goto LABEL_19;
    }
    *(_WORD *)std::__fs::filesystem::path buf = 0;
    char v21 = "Device does not have ANE, skipping...";
LABEL_188:
    _os_log_debug_impl(&dword_1DC2FE000, v17, OS_LOG_TYPE_DEBUG, v21, buf, 2u);
    goto LABEL_18;
  }
  if (v18)
  {
    *(_WORD *)std::__fs::filesystem::path buf = 0;
    _os_log_debug_impl(&dword_1DC2FE000, v17, OS_LOG_TYPE_DEBUG, "Device has ANE.", buf, 2u);
  }
  BOOL v19 = 0;
  uint64_t v20 = 4;
LABEL_19:
  if (v15)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v23 = qword_1EBFFC3D8;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_INFO)) {
      goto LABEL_42;
    }
    *(_WORD *)std::__fs::filesystem::path buf = 0;
    uint64_t v24 = "UsesANEOnly is explicitly specified, skipping all other engines.";
    id v25 = v23;
    goto LABEL_40;
  }
  if ((v15 & 0x2000000) != 0)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    id v22 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::__fs::filesystem::path buf = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "_ProhibitsGPU is explicitly specified, skipping...", buf, 2u);
    }
  }
  else
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    id v22 = qword_1EBFFC3D8;
    if ((v15 & 2) != 0 && os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::__fs::filesystem::path buf = 0;
      _os_log_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_INFO, "MRCContextInferenceProhibitsIntegratedGPU is obsolete, please use MRCContextOptionPreferredMetalDevice instead.", buf, 2u);
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::__fs::filesystem::path buf = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "_ProhibitsGPU is not explicitly specified.", buf, 2u);
    }
    v20 |= 2uLL;
  }
  if ((v15 & 4) != 0)
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::__fs::filesystem::path buf = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "AllowsCPU is explicitly specified.", buf, 2u);
    }
    v20 |= 1uLL;
    goto LABEL_49;
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::__fs::filesystem::path buf = 0;
    uint64_t v24 = "AllowsCPU is not explicitly specified, skipping...";
    id v25 = v22;
LABEL_40:
    _os_log_impl(&dword_1DC2FE000, v25, OS_LOG_TYPE_INFO, v24, buf, 2u);
  }
  BOOL v19 = v20 == 0;
  if (qword_1EBFFC3D0 != -1)
  {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    id v22 = qword_1EBFFC3D8;
    if (!v20) {
      goto LABEL_43;
    }
    goto LABEL_49;
  }
LABEL_42:
  id v22 = qword_1EBFFC3D8;
  if (v19)
  {
LABEL_43:
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::__fs::filesystem::path buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: none allowed compute device types", buf, 2u);
    }
    *(void *)std::__fs::filesystem::path buf = -6001;
    double v157 = @"None allowed compute device types.";
    sub_1DC306334((atomic_ullong *)a8, (uint64_t *)buf, (CFTypeRef *)&v157);
    *a1 = 0;
    a1[8] = 0;
    goto LABEL_167;
  }
LABEL_49:
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::__fs::filesystem::path buf = 134349312;
    *(void *)&buf[4] = v134;
    *(_WORD *)&unsigned char buf[12] = 2050;
    *(void *)&buf[14] = v20;
    _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "E5RTNetwork: inference flags %{public}lx mapped to E5RT compute device types %{public}llx", buf, 0x16u);
  }
  LOBYTE(v132) = 0;
  char v133 = 0;
  int v26 = v136;
  if (v136 != 1)
  {
    if (v136)
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::__fs::filesystem::path buf = 67240192;
        *(_DWORD *)&buf[4] = v26;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unrecognized compilation flavor: %{public}d", buf, 8u);
      }
      *(void *)std::__fs::filesystem::path buf = -6003;
      double v157 = @"Unrecognized compilation flavor.";
      sub_1DC306334((atomic_ullong *)a8, (uint64_t *)buf, (CFTypeRef *)&v157);
      goto LABEL_128;
    }
    double v157 = (__CFString *)&unk_1F365DDE8;
    uint64_t v158 = a2;
    double v160 = &v157;
    *(void *)std::__fs::filesystem::path buf = a9;
    *(void *)&long long v154 = &unk_1F365DE40;
    *((void *)&v154 + 1) = a2;
    long long v156 = &v154;
    sub_1DC31AD78((uint64_t)&buf[8], (uint64_t)&v154);
    if (*(unsigned char *)(*(void *)buf + 8) && v160) {
      sub_1DC31AE10((uint64_t)v160, **(void **)buf);
    }
    sub_1DC31AE60(&v154);
    sub_1DC31AE60(&v157);
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v27 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v60 = a2;
      }
      else {
        uint64_t v60 = *(void *)a2;
      }
      *(_DWORD *)long long v153 = 136446210;
      *(void *)&v153[4] = v60;
      _os_log_debug_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_DEBUG, "E5RTNetwork: attempt to load precompiled library: %{public}s", v153, 0xCu);
    }
    if (*(char *)(a2 + 23) >= 0) {
      qos_class_t v28 = (const char *)a2;
    }
    else {
      qos_class_t v28 = *(const char **)a2;
    }
    if (access(v28, 4))
    {
      int v29 = *__error();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v66 = a2;
        }
        else {
          uint64_t v66 = *(void *)a2;
        }
        *(_DWORD *)long long v153 = 136446466;
        *(void *)&v153[4] = v66;
        *(_WORD *)&v153[12] = 1026;
        *(_DWORD *)&v153[14] = v29;
        _os_log_error_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_ERROR, "E5RTNetwork: %{public}s is not readable, reason: %{public, errno}d", v153, 0x12u);
      }
      *(void *)long long v153 = -6003;
      long long v141 = @"Unable to load precompiled library.";
      sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v141);
      sub_1DC390D54(a8, v29);
      sub_1DC390EC4(a8, (uint64_t *)a2);
      LOBYTE(v139) = 0;
      char v140 = 0;
LABEL_118:
      if (*(unsigned char *)(*(void *)buf + 8) && v162) {
        sub_1DC31AE10(v162, **(void **)buf);
      }
      sub_1DC31AE60(&buf[8]);
      sub_1DC31EA68(&v132, (uint64_t *)&v139);
      sub_1DC31EAE8((uint64_t)&v139);
      if (v133)
      {
        uint64_t v127 = sub_1DC3154F4();
        goto LABEL_123;
      }
LABEL_128:
      *a1 = 0;
      a1[8] = 0;
      goto LABEL_166;
    }
    uint64_t v137 = 0;
    uint64_t v33 = sub_1DC3154F4();
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v34 = a2;
    }
    else {
      uint64_t v34 = *(void *)a2;
    }
    uint64_t v35 = (*(uint64_t (**)(__CFString **, uint64_t))(v33 + 184))(&v137, v34);
    if (v35)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      uint64_t v36 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v73 = (*(uint64_t (**)(uint64_t))v33)(v35);
        uint8x8_t v74 = "";
        if (v73) {
          uint8x8_t v74 = (const char *)v73;
        }
        *(_DWORD *)long long v153 = 67240450;
        *(_DWORD *)&v153[4] = v35;
        *(_WORD *)&v153[8] = 2082;
        *(void *)&v153[10] = v74;
        _os_log_error_impl(&dword_1DC2FE000, v36, OS_LOG_TYPE_ERROR, "e5rt_program_library_create failed: (%{public}d): %{public}s", v153, 0x12u);
      }
      LOBYTE(v141) = 0;
      char v142 = 0;
      goto LABEL_99;
    }
    *(void *)long long v153 = 0;
    long long v141 = v137;
    char v142 = 1;
    sub_1DC318054(v153);
    if (!v142)
    {
LABEL_99:
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v70 = a2;
        }
        else {
          uint64_t v70 = *(void *)a2;
        }
        *(_DWORD *)long long v153 = 136446210;
        *(void *)&v153[4] = v70;
        _os_log_error_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to load precompiled library: %{public}s", v153, 0xCu);
      }
      *(void *)long long v153 = -6003;
      uint64_t v137 = @"Unable to load precompiled library.";
      sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v137);
      if (!*(unsigned char *)(a8 + 52)) {
        *(unsigned char *)(a8 + 52) = 1;
      }
      *(_DWORD *)(a8 + 48) = v35;
      if (v35 == 8) {
        *(void *)a8 = -6001;
      }
      LOBYTE(v139) = 0;
      char v140 = 0;
      goto LABEL_117;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v83 = a2;
      }
      else {
        uint64_t v83 = *(void *)a2;
      }
      *(_DWORD *)long long v153 = 134349314;
      *(void *)&v153[4] = v141;
      *(_WORD *)&v153[12] = 2082;
      *(void *)&v153[14] = v83;
      _os_log_debug_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_DEBUG, "E5RTNetwork: loaded precompiled library %{public}p: %{public}s", v153, 0x16u);
      LOBYTE(v139) = 0;
      char v140 = 0;
      if (!v142) {
        goto LABEL_117;
      }
    }
    else
    {
      char v140 = 0;
    }
    uint64_t v38 = v141;
    long long v141 = 0;
    long long v139 = v38;
    char v140 = 1;
LABEL_117:
    sub_1DC31EAE8((uint64_t)&v141);
    goto LABEL_118;
  }
  unint64_t v144 = v134;
  double v157 = (__CFString *)&unk_1F365D480;
  uint64_t v158 = a2;
  double v159 = &v144;
  double v160 = &v157;
  *(void *)&long long v154 = &unk_1F365D4D8;
  *((void *)&v154 + 1) = a2;
  CGFloat v155 = &v144;
  long long v156 = &v154;
  *(void *)std::__fs::filesystem::path buf = a9;
  sub_1DC31AD78((uint64_t)&buf[8], (uint64_t)&v154);
  if (*(unsigned char *)(*(void *)buf + 8) && v160) {
    sub_1DC31AE10((uint64_t)v160, **(void **)buf);
  }
  sub_1DC31AE60(&v154);
  sub_1DC31AE60(&v157);
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  uint64_t v30 = qword_1EBFFC3D8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v61 = a2;
    }
    else {
      uint64_t v61 = *(void *)a2;
    }
    *(_DWORD *)long long v153 = 136446210;
    *(void *)&v153[4] = v61;
    _os_log_debug_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_DEBUG, "E5RTNetwork: attempt to perform on-demand compilation for: %{public}s", v153, 0xCu);
  }
  long long v139 = 0;
  uint64_t v127 = sub_1DC3154F4();
  uint64_t v31 = (*(uint64_t (**)(__CFString **))(v127 + 216))(&v139);
  int v143 = v31;
  if (v31)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    unint64_t v32 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v67 = (*(uint64_t (**)(uint64_t))v127)(v31);
      uint64_t v68 = "";
      if (v67) {
        uint64_t v68 = (const char *)v67;
      }
      *(_DWORD *)long long v153 = 67240450;
      *(_DWORD *)&v153[4] = v31;
      *(_WORD *)&v153[8] = 2082;
      *(void *)&v153[10] = v68;
      _os_log_error_impl(&dword_1DC2FE000, v32, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_create failed: (%{public}d): %{public}s", v153, 0x12u);
    }
    LOBYTE(v141) = 0;
    char v142 = 0;
    goto LABEL_76;
  }
  *(void *)long long v153 = 0;
  long long v141 = v139;
  char v142 = 1;
  sub_1DC318338(v153);
  if (v142)
  {
    uint64_t v31 = (*(uint64_t (**)(__CFString *, uint64_t))(v127 + 232))(v141, v20);
    int v143 = v31;
    if (v31)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      std::string::size_type v37 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v80 = (*(uint64_t (**)(uint64_t))v127)(v31);
        uint64_t v81 = "";
        if (v80) {
          uint64_t v81 = (const char *)v80;
        }
        *(_DWORD *)long long v153 = 67240450;
        *(_DWORD *)&v153[4] = v31;
        *(_WORD *)&v153[8] = 2082;
        *(void *)&v153[10] = v81;
        _os_log_error_impl(&dword_1DC2FE000, v37, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_set_compute_device_types_mask failed: (%{public}d): %{public}s", v153, 0x12u);
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v153 = 134349056;
        *(void *)&v153[4] = v20;
        _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set compute device types %{public}llx", v153, 0xCu);
      }
      *(void *)long long v153 = -6003;
      long long v139 = @"Unable to set compute device types.";
      sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v139);
      goto LABEL_79;
    }
    if (a3 == 1)
    {
      long long v139 = (__CFString *)"*";
      uint64_t v31 = (*(uint64_t (**)(__CFString *, __CFString **, uint64_t))(v127 + 240))(v141, &v139, 1);
      int v143 = v31;
      if (v31)
      {
        if (qword_1EBFFC3D0 != -1) {
          dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
        }
        uint64_t v59 = qword_1EBFFC3D8;
        if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v87 = (*(uint64_t (**)(uint64_t))v127)(v31);
          long long v88 = "";
          if (v87) {
            long long v88 = (const char *)v87;
          }
          *(_DWORD *)long long v153 = 67240450;
          *(_DWORD *)&v153[4] = v31;
          *(_WORD *)&v153[8] = 2082;
          *(void *)&v153[10] = v88;
          _os_log_error_impl(&dword_1DC2FE000, v59, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_set_mil_entry_points failed: (%{public}d): %{public}s", v153, 0x12u);
        }
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long v153 = 0;
          _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set MIL entry points", v153, 2u);
        }
        *(void *)long long v153 = -6003;
        long long v139 = @"Unable to set MIL entry points.";
        sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v139);
        goto LABEL_79;
      }
      *(void *)long long v153 = "bnns";
      *(void *)&v153[8] = "classic_cpu";
      if (sub_1DC3181E4((uint64_t)v141, (uint64_t)v153, 2, &v143))
      {
        uint64_t v31 = (*(uint64_t (**)(__CFString *, uint64_t))(v127 + 256))(v141, 1);
        if (v31)
        {
          if (qword_1EBFFC3D0 != -1) {
            dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
          }
          unint64_t v71 = qword_1EBFFC3D8;
          if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
          {
            uint64_t v114 = (*(uint64_t (**)(uint64_t))v127)(v31);
            unint64_t v115 = "";
            if (v114) {
              unint64_t v115 = (const char *)v114;
            }
            *(_DWORD *)long long v153 = 67240450;
            *(_DWORD *)&v153[4] = v31;
            *(_WORD *)&v153[8] = 2082;
            *(void *)&v153[10] = v115;
            _os_log_error_impl(&dword_1DC2FE000, v71, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_options_set_force_classic_aot_old_hw failed: (%{public}d): %{public}s", v153, 0x12u);
          }
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long v153 = 0;
            _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set the forceClassicAotOldHw flag.", v153, 2u);
          }
          *(void *)long long v153 = -6003;
          long long v139 = @"Unable to set the forceClassicAotOldHw flag.";
          sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v139);
          goto LABEL_79;
        }
LABEL_193:
        uint64_t v137 = 0;
        uint64_t v64 = (*(uint64_t (**)(__CFString **))(v127 + 272))(&v137);
        int v143 = v64;
        if (v64)
        {
          if (qword_1EBFFC3D0 != -1) {
            dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
          }
          uint64_t v65 = qword_1EBFFC3D8;
          if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
          {
            uint64_t v102 = (*(uint64_t (**)(uint64_t))v127)(v64);
            float64x2_t v103 = "";
            if (v102) {
              float64x2_t v103 = (const char *)v102;
            }
            *(_DWORD *)long long v153 = 67240450;
            *(_DWORD *)&v153[4] = v64;
            *(_WORD *)&v153[8] = 2082;
            *(void *)&v153[10] = v103;
            _os_log_error_impl(&dword_1DC2FE000, v65, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_create failed: (%{public}d): %{public}s", v153, 0x12u);
          }
          LOBYTE(v139) = 0;
          char v140 = 0;
          goto LABEL_198;
        }
        *(void *)long long v153 = 0;
        long long v139 = v137;
        char v140 = 1;
        sub_1DC3184C8(v153);
        if (!v140)
        {
LABEL_198:
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long v153 = 0;
            _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT compiler", v153, 2u);
          }
          *(void *)long long v153 = -6003;
          uint64_t v137 = @"Unable to create E5RT compiler.";
          sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v137);
          if (!*(unsigned char *)(a8 + 52)) {
            *(unsigned char *)(a8 + 52) = 1;
          }
          *(_DWORD *)(a8 + 48) = v64;
LABEL_203:
          LOBYTE(v130) = 0;
          char v131 = 0;
LABEL_204:
          sub_1DC31EDC0((uint64_t)&v139);
          goto LABEL_83;
        }
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          LOBYTE(v137) = 0;
          if (*(char *)(a2 + 23) >= 0) {
            uint64_t v75 = a2;
          }
          else {
            uint64_t v75 = *(void *)a2;
          }
          uint64_t v76 = (*(uint64_t (**)(__CFString *, uint64_t, __CFString *, __CFString **))(v127 + 296))(v139, v75, v141, &v137);
          if (!v76)
          {
            int v98 = v137;
            BOOL v99 = os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG);
            if (v98)
            {
              if (!v99) {
                goto LABEL_346;
              }
              if (*(char *)(a2 + 23) >= 0) {
                uint64_t v100 = a2;
              }
              else {
                uint64_t v100 = *(void *)a2;
              }
              *(_DWORD *)long long v153 = 136446210;
              *(void *)&v153[4] = v100;
              uint64_t v79 = "E5RTNetwork: a new compilation is required for network: %{public}s";
            }
            else
            {
              if (!v99) {
                goto LABEL_346;
              }
              if (*(char *)(a2 + 23) >= 0) {
                uint64_t v105 = a2;
              }
              else {
                uint64_t v105 = *(void *)a2;
              }
              *(_DWORD *)long long v153 = 136446210;
              *(void *)&v153[4] = v105;
              uint64_t v79 = "E5RTNetwork: a new compilation is not required for network: %{public}s";
            }
            goto LABEL_345;
          }
          if (qword_1EBFFC3D0 != -1) {
            dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
          }
          uint64_t v77 = qword_1EBFFC3D8;
          if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
          {
            uint64_t v117 = (*(uint64_t (**)(uint64_t))v127)(v76);
            uint64_t v118 = "";
            if (v117) {
              uint64_t v118 = (const char *)v117;
            }
            *(_DWORD *)long long v153 = 67240450;
            *(_DWORD *)&v153[4] = v76;
            *(_WORD *)&v153[8] = 2082;
            *(void *)&v153[10] = v118;
            _os_log_error_impl(&dword_1DC2FE000, v77, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_is_new_compile_required failed: (%{public}d): %{public}s", v153, 0x12u);
          }
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            if (*(char *)(a2 + 23) >= 0) {
              uint64_t v78 = a2;
            }
            else {
              uint64_t v78 = *(void *)a2;
            }
            *(_DWORD *)long long v153 = 136446210;
            *(void *)&v153[4] = v78;
            uint64_t v79 = "E5RTNetwork: unable to determine whether a new compilation is required for network: %{public}s";
LABEL_345:
            _os_log_debug_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_DEBUG, v79, v153, 0xCu);
          }
        }
LABEL_346:
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          if (*(char *)(a2 + 23) >= 0) {
            uint64_t v112 = a2;
          }
          else {
            uint64_t v112 = *(void *)a2;
          }
          *(_DWORD *)long long v153 = 136446210;
          *(void *)&v153[4] = v112;
          _os_log_debug_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_DEBUG, "E5RTNetwork: attempt to compile network: %{public}s", v153, 0xCu);
        }
        if (*(char *)(a2 + 23) >= 0) {
          unint64_t v106 = (const char *)a2;
        }
        else {
          unint64_t v106 = *(const char **)a2;
        }
        if (access(v106, 4))
        {
          int v107 = *__error();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            if (*(char *)(a2 + 23) >= 0) {
              uint64_t v116 = a2;
            }
            else {
              uint64_t v116 = *(void *)a2;
            }
            *(_DWORD *)long long v153 = 136446466;
            *(void *)&v153[4] = v116;
            *(_WORD *)&v153[12] = 1026;
            *(_DWORD *)&v153[14] = v107;
            _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "E5RTNetwork: %{public}s is not readable, reason: %{public, errno}d", v153, 0x12u);
          }
          *(void *)long long v153 = -6003;
          uint64_t v137 = @"Unable to compile network.";
          sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v137);
          sub_1DC390D54(a8, v107);
          sub_1DC390EC4(a8, (uint64_t *)a2);
          goto LABEL_203;
        }
        int v145 = 0;
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v108 = a2;
        }
        else {
          uint64_t v108 = *(void *)a2;
        }
        uint64_t v109 = (*(uint64_t (**)(__CFString *, uint64_t, __CFString *, __CFString **))(v127 + 288))(v139, v108, v141, &v145);
        int v143 = v109;
        if (v109)
        {
          if (qword_1EBFFC3D0 != -1) {
            dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
          }
          uint8x8_t v110 = qword_1EBFFC3D8;
          if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
          {
            uint64_t v120 = (*(uint64_t (**)(uint64_t))v127)(v109);
            uint64_t v121 = "";
            if (v120) {
              uint64_t v121 = (const char *)v120;
            }
            *(_DWORD *)long long v153 = 67240450;
            *(_DWORD *)&v153[4] = v109;
            *(_WORD *)&v153[8] = 2082;
            *(void *)&v153[10] = v121;
            _os_log_error_impl(&dword_1DC2FE000, v110, OS_LOG_TYPE_ERROR, "e5rt_e5_compiler_compile failed: (%{public}d): %{public}s", v153, 0x12u);
          }
          LOBYTE(v137) = 0;
          char v138 = 0;
          goto LABEL_361;
        }
        *(void *)long long v153 = 0;
        uint64_t v137 = v145;
        char v138 = 1;
        sub_1DC318054(v153);
        if (!v138)
        {
LABEL_361:
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            if (*(char *)(a2 + 23) >= 0) {
              uint64_t v119 = a2;
            }
            else {
              uint64_t v119 = *(void *)a2;
            }
            *(_DWORD *)long long v153 = 136446210;
            *(void *)&v153[4] = v119;
            _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to compile network: %{public}s", v153, 0xCu);
          }
          *(void *)long long v153 = -6003;
          int v145 = @"Unable to compile network.";
          sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v145);
          if (!*(unsigned char *)(a8 + 52)) {
            *(unsigned char *)(a8 + 52) = 1;
          }
          *(_DWORD *)(a8 + 48) = v109;
          if (v109 == 11) {
            *(void *)a8 = -6001;
          }
          LOBYTE(v130) = 0;
          char v131 = 0;
          goto LABEL_371;
        }
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          if (*(char *)(a2 + 23) >= 0) {
            uint64_t v123 = a2;
          }
          else {
            uint64_t v123 = *(void *)a2;
          }
          *(_DWORD *)long long v153 = 134349314;
          *(void *)&v153[4] = v137;
          *(_WORD *)&v153[12] = 2082;
          *(void *)&v153[14] = v123;
          _os_log_debug_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_DEBUG, "E5RTNetwork: compiled as library %{public}p: %{public}s", v153, 0x16u);
          LOBYTE(v130) = 0;
          char v131 = 0;
          if (!v138) {
            goto LABEL_371;
          }
        }
        else
        {
          char v131 = 0;
        }
        uint64_t v111 = v137;
        uint64_t v137 = 0;
        float v130 = v111;
        char v131 = 1;
LABEL_371:
        sub_1DC31EAE8((uint64_t)&v137);
        goto LABEL_204;
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v153 = 0;
        _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set preferred CPU backends", v153, 2u);
      }
    }
    else
    {
      *(void *)long long v153 = "classic_cpu";
      if (sub_1DC3181E4((uint64_t)v141, (uint64_t)v153, 1, &v143)) {
        goto LABEL_193;
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v153 = 0;
        _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set preferred CPU backends", v153, 2u);
      }
    }
    *(void *)long long v153 = -6003;
    long long v139 = @"Unable to set preferred CPU backends.";
    sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v139);
    int v82 = v143;
    if (!*(unsigned char *)(a8 + 52)) {
      *(unsigned char *)(a8 + 52) = 1;
    }
    *(_DWORD *)(a8 + 48) = v82;
    goto LABEL_82;
  }
LABEL_76:
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long v153 = 0;
    _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT compiler options", v153, 2u);
  }
  *(void *)long long v153 = -6003;
  long long v139 = @"Unable to create E5RT compiler options.";
  sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v139);
LABEL_79:
  if (!*(unsigned char *)(a8 + 52)) {
    *(unsigned char *)(a8 + 52) = 1;
  }
  *(_DWORD *)(a8 + 48) = v31;
LABEL_82:
  LOBYTE(v130) = 0;
  char v131 = 0;
LABEL_83:
  sub_1DC31EDF8((uint64_t)&v141);
  if (*(unsigned char *)(*(void *)buf + 8) && v162) {
    sub_1DC31AE10(v162, **(void **)buf);
  }
  sub_1DC31AE60(&buf[8]);
  sub_1DC31EA68(&v132, (uint64_t *)&v130);
  sub_1DC31EAE8((uint64_t)&v130);
  if (!v133) {
    goto LABEL_128;
  }
LABEL_123:
  double v157 = 0;
  uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t, __CFString **))(v127 + 200))(v132, v135, &v157);
  LODWORD(v130) = v39;
  if (v39)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v40 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v62 = (*(uint64_t (**)(uint64_t))v127)(v39);
      uint64_t v63 = "";
      if (v62) {
        uint64_t v63 = (const char *)v62;
      }
      *(_DWORD *)std::__fs::filesystem::path buf = 67240450;
      *(_DWORD *)&buf[4] = v39;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v63;
      _os_log_error_impl(&dword_1DC2FE000, v40, OS_LOG_TYPE_ERROR, "e5rt_program_library_get_function_metadata failed: (%{public}d): %{public}s", buf, 0x12u);
    }
    uint64_t v41 = 0;
  }
  else
  {
    uint64_t v41 = v157;
  }
  long long v141 = v41;
  if (!atomic_load_explicit((atomic_ullong *volatile)&v141, memory_order_acquire))
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 136446210;
      *(void *)&buf[4] = v135;
      _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to get metadata for function: %{public}s", buf, 0xCu);
    }
    *(void *)std::__fs::filesystem::path buf = -6003;
    double v157 = @"Unable to get function metadata.";
    sub_1DC306334((atomic_ullong *)a8, (uint64_t *)buf, (CFTypeRef *)&v157);
    int v57 = (int)v130;
    if (!*(unsigned char *)(a8 + 52)) {
      *(unsigned char *)(a8 + 52) = 1;
    }
    *(_DWORD *)(a8 + 48) = v57;
    goto LABEL_164;
  }
  uint64_t v126 = v135;
  CFTypeID v42 = CFGetTypeID((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v141, memory_order_acquire));
  if (v42 != CFDictionaryGetTypeID())
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v141, memory_order_acquire);
      *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
      *(void *)&buf[4] = v126;
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = explicit;
      _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
    }
    goto LABEL_163;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v141, memory_order_acquire), @"Ops");
  CFArrayRef v44 = Value;
  if (!Value || (CFTypeID v45 = CFGetTypeID(Value), v45 != CFArrayGetTypeID()))
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      unint64_t v72 = atomic_load_explicit((atomic_ullong *volatile)&v141, memory_order_acquire);
      *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
      *(void *)&buf[4] = v126;
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v72;
      _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
    }
LABEL_163:
    *(void *)std::__fs::filesystem::path buf = -6003;
    double v157 = @"Invalid E5RT function metadata.";
    sub_1DC306334((atomic_ullong *)a8, (uint64_t *)buf, (CFTypeRef *)&v157);
LABEL_164:
    *a1 = 0;
    a1[8] = 0;
    goto LABEL_165;
  }
  CFIndex Count = CFArrayGetCount(v44);
  if (Count < 1) {
    goto LABEL_282;
  }
  BOOL v125 = 0;
  CFIndex v47 = 0;
  while (1)
  {
    ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(v44, v47);
    CFDictionaryRef v49 = ValueAtIndex;
    if (!ValueAtIndex || (CFTypeID v50 = CFGetTypeID(ValueAtIndex), v50 != CFDictionaryGetTypeID()))
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        unint64_t v96 = atomic_load_explicit((atomic_ullong *volatile)&v141, memory_order_acquire);
        *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
        *(void *)&buf[4] = v126;
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v96;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
      }
      goto LABEL_238;
    }
    CFStringRef v51 = (const __CFString *)CFDictionaryGetValue(v49, @"OpCode");
    CFStringRef v52 = v51;
    if (!v51 || (CFTypeID v53 = CFGetTypeID(v51), v53 != CFStringGetTypeID()))
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        unint64_t v97 = atomic_load_explicit((atomic_ullong *volatile)&v141, memory_order_acquire);
        *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
        *(void *)&buf[4] = v126;
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v97;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
      }
      goto LABEL_238;
    }
    if (CFEqual(v52, @"Cast")) {
      goto LABEL_151;
    }
    CFStringRef v54 = (const __CFString *)CFDictionaryGetValue(v49, @"ComputeBackend");
    CFStringRef v55 = v54;
    if (!v54 || (CFTypeID v56 = CFGetTypeID(v54), v56 != CFStringGetTypeID()))
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        unint64_t v104 = atomic_load_explicit((atomic_ullong *volatile)&v141, memory_order_acquire);
        *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
        *(void *)&buf[4] = v126;
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v104;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "Invalid E5RT metadatafor function: %{public}s: %{public}@", buf, 0x16u);
      }
LABEL_238:
      *(void *)std::__fs::filesystem::path buf = -6003;
      double v157 = @"Invalid E5RT function metadata.";
      sub_1DC306334((atomic_ullong *)a8, (uint64_t *)buf, (CFTypeRef *)&v157);
      goto LABEL_281;
    }
    if (CFEqual(v55, @"ANE"))
    {
      if ((v20 & 4) != 0) {
        goto LABEL_151;
      }
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        goto LABEL_278;
      }
      *(_WORD *)std::__fs::filesystem::path buf = 0;
      int v85 = "E5RT compute device type ANE is not allowed.";
LABEL_277:
      _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, v85, buf, 2u);
      goto LABEL_278;
    }
    if (CFEqual(v55, @"GPU"))
    {
      if ((v20 & 2) != 0) {
        goto LABEL_151;
      }
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        goto LABEL_278;
      }
      *(_WORD *)std::__fs::filesystem::path buf = 0;
      int v85 = "E5RT compute device type GPU is not allowed.";
      goto LABEL_277;
    }
    if (CFStringCompare(v55, @"CPU", 0)) {
      goto LABEL_278;
    }
    if ((v20 & 1) == 0) {
      break;
    }
LABEL_151:
    BOOL v125 = ++v47 >= Count;
    if (Count == v47) {
      goto LABEL_282;
    }
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::__fs::filesystem::path buf = 0;
    int v85 = "E5RT compute device type CPU is not allowed.";
    goto LABEL_277;
  }
LABEL_278:
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::__fs::filesystem::path buf = 138543362;
    *(void *)&buf[4] = v55;
    _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "Unexpected, unsupported, or disallowed E5RT compute backend: %{public}@", buf, 0xCu);
  }
  *(void *)std::__fs::filesystem::path buf = -6001;
  double v157 = @"Unexpected, unsupported, or disallowed E5RT compute backend.";
  sub_1DC306334((atomic_ullong *)a8, (uint64_t *)buf, (CFTypeRef *)&v157);
LABEL_281:
  if (!v125) {
    goto LABEL_164;
  }
LABEL_282:
  *(void *)&long long v154 = 0;
  uint64_t v89 = (*(uint64_t (**)(uint64_t, uint64_t, long long *))(v127 + 208))(v132, v135, &v154);
  LODWORD(v130) = v89;
  if (!v89)
  {
    *(void *)std::__fs::filesystem::path buf = 0;
    double v157 = (__CFString *)v154;
    LOBYTE(v158) = 1;
    sub_1DC317EC4(buf);
    if (!(_BYTE)v158) {
      goto LABEL_287;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 134349314;
      *(void *)&buf[4] = v157;
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v135;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "E5RTNetwork: found function %{public}p: %{public}s", buf, 0x16u);
    }
    sub_1DC318A3C(buf, (uint64_t)v157, &v130);
    if (buf[8])
    {
      if (sub_1DC31865C(*(uint64_t *)buf, a5, &v130))
      {
        if (sub_1DC3187A0(*(uint64_t *)buf, &v130))
        {
          if ((v134 & 0x2000000) != 0)
          {
LABEL_306:
            sub_1DC318D44(&v154, *(uint64_t *)buf, &v130);
            if (BYTE8(v154))
            {
              uint64_t v92 = v154;
              *(void *)&long long v154 = 0;
              *(void *)a1 = v92;
              a1[8] = 1;
            }
            else
            {
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long v153 = 0;
                _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT execution stream operation", v153, 2u);
              }
              *(void *)long long v153 = -6003;
              long long v139 = @"Unable to create E5RT execution stream operation.";
              sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v139);
              int v101 = (int)v130;
              if (!*(unsigned char *)(a8 + 52)) {
                *(unsigned char *)(a8 + 52) = 1;
              }
              *(_DWORD *)(a8 + 48) = v101;
              *a1 = 0;
              a1[8] = 0;
            }
            sub_1DC31EA30((uint64_t)&v154);
LABEL_323:
            sub_1DC31EB8C((uint64_t)buf);
            goto LABEL_324;
          }
          sub_1DC3B5790((uint64_t *)&v139, (uint64_t)a7);
          if (atomic_load_explicit((atomic_ullong *volatile)&v139, memory_order_acquire))
          {
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
            {
              unint64_t v122 = atomic_load_explicit((atomic_ullong *volatile)&v139, memory_order_acquire);
              LODWORD(v154) = 138543362;
              *(void *)((char *)&v154 + 4) = v122;
              _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "E5RTNetwork: effectively preferred Metal device: %{public}@", (uint8_t *)&v154, 0xCu);
            }
            sub_1DC3B4D6C(&v154, (atomic_ullong *)&v139, (int *)&v130);
            if (BYTE8(v154))
            {
              if (sub_1DC3188E0(*(uint64_t *)buf, (uint64_t *)&v154, 1u, &v130))
              {
                sub_1DC31EB20((uint64_t)&v154);
                goto LABEL_305;
              }
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long v153 = 0;
                _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set overridden-compute-GPU-device", v153, 2u);
              }
              *(void *)long long v153 = -6003;
              uint64_t v137 = @"Unable to set overridden-compute-GPU-device.";
              sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v137);
            }
            else
            {
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                unint64_t v124 = atomic_load_explicit((atomic_ullong *volatile)&v139, memory_order_acquire);
                *(_DWORD *)long long v153 = 138543362;
                *(void *)&v153[4] = v124;
                _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT compute GPU device: %{public}@", v153, 0xCu);
              }
              *(void *)long long v153 = -6003;
              uint64_t v137 = @"Unable to create E5RT compute GPU device.";
              sub_1DC306334((atomic_ullong *)a8, (uint64_t *)v153, (CFTypeRef *)&v137);
            }
            int v113 = (int)v130;
            if (!*(unsigned char *)(a8 + 52)) {
              *(unsigned char *)(a8 + 52) = 1;
            }
            *(_DWORD *)(a8 + 48) = v113;
            *a1 = 0;
            a1[8] = 0;
            sub_1DC31EB20((uint64_t)&v154);
            sub_1DC31EB58((atomic_ullong *)&v139);
            goto LABEL_323;
          }
LABEL_305:
          sub_1DC31EB58((atomic_ullong *)&v139);
          goto LABEL_306;
        }
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v154) = 0;
          _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set allocates-intermediate-buffers", (uint8_t *)&v154, 2u);
        }
        *(void *)&long long v154 = -6003;
        *(void *)long long v153 = @"Unable to set allocates-intermediate-buffers.";
        sub_1DC306334((atomic_ullong *)a8, (uint64_t *)&v154, (CFTypeRef *)v153);
      }
      else
      {
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v154) = 0;
          _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to set operation name", (uint8_t *)&v154, 2u);
        }
        *(void *)&long long v154 = -6003;
        *(void *)long long v153 = @"Unable to set operation name.";
        sub_1DC306334((atomic_ullong *)a8, (uint64_t *)&v154, (CFTypeRef *)v153);
      }
    }
    else
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v154) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to create E5RT precompiled-compute-op-create options", (uint8_t *)&v154, 2u);
      }
      *(void *)&long long v154 = -6003;
      *(void *)long long v153 = @"Unable to create E5RT precompiled-compute-op-create options.";
      sub_1DC306334((atomic_ullong *)a8, (uint64_t *)&v154, (CFTypeRef *)v153);
    }
    int v95 = (int)v130;
    if (!*(unsigned char *)(a8 + 52)) {
      *(unsigned char *)(a8 + 52) = 1;
    }
    *(_DWORD *)(a8 + 48) = v95;
    *a1 = 0;
    a1[8] = 0;
    goto LABEL_323;
  }
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  long long v90 = qword_1EBFFC3D8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v93 = (*(uint64_t (**)(uint64_t))v127)(v89);
    long long v94 = "";
    if (v93) {
      long long v94 = (const char *)v93;
    }
    *(_DWORD *)std::__fs::filesystem::path buf = 67240450;
    *(_DWORD *)&buf[4] = v89;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v94;
    _os_log_error_impl(&dword_1DC2FE000, v90, OS_LOG_TYPE_ERROR, "e5rt_program_library_retain_program_function failed: (%{public}d): %{public}s", buf, 0x12u);
  }
  LOBYTE(v157) = 0;
  LOBYTE(v158) = 0;
LABEL_287:
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::__fs::filesystem::path buf = 136446210;
    *(void *)&buf[4] = v135;
    _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "E5RTNetwork: unable to find function: %{public}s", buf, 0xCu);
  }
  *(void *)std::__fs::filesystem::path buf = -6003;
  *(void *)&long long v154 = @"Unable to find function.";
  sub_1DC306334((atomic_ullong *)a8, (uint64_t *)buf, (CFTypeRef *)&v154);
  int v91 = (int)v130;
  if (!*(unsigned char *)(a8 + 52)) {
    *(unsigned char *)(a8 + 52) = 1;
  }
  *(_DWORD *)(a8 + 48) = v91;
  *a1 = 0;
  a1[8] = 0;
LABEL_324:
  sub_1DC31EBC4((uint64_t)&v157);
LABEL_165:
  sub_1DC31EBFC((atomic_ullong *)&v141);
LABEL_166:
  sub_1DC31EAE8((uint64_t)&v132);
LABEL_167:
  if (*(unsigned char *)(v150 + 8) && v152) {
    sub_1DC31AE10(v152, *(void *)v150);
  }
  return sub_1DC31AE60(v151);
}

void sub_1DC31E820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,atomic_ullong a25,uint64_t a26,atomic_ullong a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t *a40)
{
  sub_1DC31EB20(v40 - 208);
  sub_1DC31EB58(&a25);
  sub_1DC31EB8C(v40 - 144);
  sub_1DC31EBC4(v40 - 176);
  sub_1DC31EBFC(&a27);
  sub_1DC31EAE8((uint64_t)&a18);
  sub_1DC31AEE4(&a40);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC31E9F8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC31904C((void *)a1);
  }
  return a1;
}

uint64_t sub_1DC31EA30(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC318EB8((void *)a1);
  }
  return a1;
}

void *sub_1DC31EA68(void *result, uint64_t *a2)
{
  uint64_t v3 = result;
  if (*((unsigned __int8 *)result + 8) == *((unsigned __int8 *)a2 + 8))
  {
    if (*((unsigned char *)result + 8))
    {
      uint64_t result = sub_1DC318054(result);
      uint64_t v4 = *a2;
      *a2 = 0;
      void *v3 = v4;
    }
  }
  else if (*((unsigned char *)result + 8))
  {
    uint64_t result = sub_1DC318054(result);
    *((unsigned char *)v3 + 8) = 0;
  }
  else
  {
    uint64_t v5 = *a2;
    *a2 = 0;
    *uint64_t result = v5;
    *((unsigned char *)result + 8) = 1;
  }
  return result;
}

uint64_t sub_1DC31EAE8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC318054((void *)a1);
  }
  return a1;
}

uint64_t sub_1DC31EB20(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC31EC30((void *)a1);
  }
  return a1;
}

atomic_ullong *sub_1DC31EB58(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1DC31EB8C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC318BB0((void *)a1);
  }
  return a1;
}

uint64_t sub_1DC31EBC4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC317EC4((void *)a1);
  }
  return a1;
}

atomic_ullong *sub_1DC31EBFC(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *sub_1DC31EC30(void *result)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (*result)
  {
    v1[0] = &unk_1F365E208;
    v1[1] = result;
    v1[3] = v1;
    sub_1DC315C84((uint64_t)v1, &off_1E6C3A9E0);
    return sub_1DC315DF0(v1);
  }
  return result;
}

void sub_1DC31ECC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC315DF0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC31ECD8()
{
  return &unk_1F365DA58;
}

uint64_t sub_1DC31ECE4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt18__e5rt_ref_details10deallocateIP23e5rt_compute_gpu_deviceEEvRNS1_13E5RTRefTraitsIT_E4typeEEUlOS7_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC31ED20(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 168))(*(void *)(a1 + 8));
}

uint64_t sub_1DC31ED3C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365E208;
  a2[1] = v2;
  return result;
}

void *sub_1DC31ED60(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365E208;
  result[1] = v3;
  return result;
}

void sub_1DC31EDA8()
{
}

uint64_t sub_1DC31EDC0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC3184C8((void *)a1);
  }
  return a1;
}

uint64_t sub_1DC31EDF8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC318338((void *)a1);
  }
  return a1;
}

void *sub_1DC31EE30()
{
  return &unk_1F365D440;
}

uint64_t sub_1DC31EE3C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork27performOnDemandCompilation_ERKNSt3__14__fs10filesystem4pathENS0_11NetworkKindEmyRNS3_8optionalINS_5ErrorEEERKNSA_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC31EE78(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      uint64_t v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0) {
        uint64_t v5 = (uint64_t *)*v5;
      }
      uint64_t v6 = **(void **)(a1 + 16);
      int v7 = 136446466;
      uint64_t v8 = v5;
      __int16 v9 = 2050;
      uint64_t v10 = v6;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_END, v3, "E5RTNetwork::performOnDemandCompilation_", "path=%{public, signpost.description:attribute}s, inferenceFlags=%{public, signpost.description:attribute}lx", (uint8_t *)&v7, 0x16u);
    }
  }
}

__n128 sub_1DC31EF8C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365D4D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC31EFB4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F365D4D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC31F000()
{
}

void *sub_1DC31F018()
{
  return &unk_1F365D430;
}

uint64_t sub_1DC31F024(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork27performOnDemandCompilation_ERKNSt3__14__fs10filesystem4pathENS0_11NetworkKindEmyRNS3_8optionalINS_5ErrorEEERKNSA_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC31F060(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      uint64_t v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0) {
        uint64_t v5 = (uint64_t *)*v5;
      }
      uint64_t v6 = **(void **)(a1 + 16);
      int v7 = 136446466;
      uint64_t v8 = v5;
      __int16 v9 = 2050;
      uint64_t v10 = v6;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "E5RTNetwork::performOnDemandCompilation_", "path=%{public, signpost.description:attribute}s, inferenceFlags=%{public, signpost.description:attribute}lx", (uint8_t *)&v7, 0x16u);
    }
  }
}

__n128 sub_1DC31F174(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365D480;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC31F19C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F365D480;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC31F1E8()
{
}

void *sub_1DC31F200()
{
  return &unk_1F365D9A8;
}

uint64_t sub_1DC31F20C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork23loadPrecompiledLibrary_ERKNSt3__14__fs10filesystem4pathERNS3_8optionalINS_5ErrorEEERKNS9_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC31F248(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      uint64_t v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0) {
        uint64_t v5 = (uint64_t *)*v5;
      }
      int v6 = 136446210;
      int v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_END, v3, "E5RTNetwork::loadPrecompiledLibrary_", "path=%{public, signpost.description:attribute}s", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t sub_1DC31F348(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365DE40;
  a2[1] = v2;
  return result;
}

void *sub_1DC31F36C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F365DE40;
  result[1] = v3;
  return result;
}

void sub_1DC31F3B4()
{
}

void *sub_1DC31F3CC()
{
  return &unk_1F365D998;
}

uint64_t sub_1DC31F3D8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork23loadPrecompiledLibrary_ERKNSt3__14__fs10filesystem4pathERNS3_8optionalINS_5ErrorEEERKNS9_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC31F414(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      uint64_t v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0) {
        uint64_t v5 = (uint64_t *)*v5;
      }
      int v6 = 136446210;
      int v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "E5RTNetwork::loadPrecompiledLibrary_", "path=%{public, signpost.description:attribute}s", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t sub_1DC31F514(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365DDE8;
  a2[1] = v2;
  return result;
}

void *sub_1DC31F538(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F365DDE8;
  result[1] = v3;
  return result;
}

void sub_1DC31F580()
{
}

void *sub_1DC31F598()
{
  return &unk_1F365D460;
}

uint64_t sub_1DC31F5A4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork5load_ERKNSt3__14__fs10filesystem4pathENS0_11NetworkKindENS2_17CompilationFlavorEPKcSC_RKNS_7Context7OptionsERNS3_8optionalINS_5ErrorEEERKNSH_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC31F5E0(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      uint64_t v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0) {
        uint64_t v5 = (uint64_t *)*v5;
      }
      int v6 = **(_DWORD **)(a1 + 16);
      uint64_t v7 = **(void **)(a1 + 24);
      uint64_t v8 = **(void **)(a1 + 32);
      int v9 = 136446978;
      uint64_t v10 = v5;
      __int16 v11 = 1026;
      int v12 = v6;
      __int16 v13 = 2082;
      uint64_t v14 = v7;
      __int16 v15 = 2050;
      uint64_t v16 = v8;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_END, v3, "E5RTNetwork::load_", "path=%{public, signpost.description:attribute}s, compilationFlavor=%{public, signpost.description:attribute}d, function=%{public, signpost.description:attribute}s, inferenceFlags=%{public, signpost.description:attribute}lx", (uint8_t *)&v9, 0x26u);
    }
  }
}

__n128 sub_1DC31F718(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365D588;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC31F748(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F365D588;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_1DC31F79C()
{
}

void *sub_1DC31F7B4()
{
  return &unk_1F365D450;
}

uint64_t sub_1DC31F7C0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4e5rt11E5RTNetwork5load_ERKNSt3__14__fs10filesystem4pathENS0_11NetworkKindENS2_17CompilationFlavorEPKcSC_RKNS_7Context7OptionsERNS3_8optionalINS_5ErrorEEERKNSH_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC31F7FC(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      uint64_t v5 = *(uint64_t **)(a1 + 8);
      if (*((char *)v5 + 23) < 0) {
        uint64_t v5 = (uint64_t *)*v5;
      }
      int v6 = **(_DWORD **)(a1 + 16);
      uint64_t v7 = **(void **)(a1 + 24);
      uint64_t v8 = **(void **)(a1 + 32);
      int v9 = 136446978;
      uint64_t v10 = v5;
      __int16 v11 = 1026;
      int v12 = v6;
      __int16 v13 = 2082;
      uint64_t v14 = v7;
      __int16 v15 = 2050;
      uint64_t v16 = v8;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "E5RTNetwork::load_", "path=%{public, signpost.description:attribute}s, compilationFlavor=%{public, signpost.description:attribute}d, function=%{public, signpost.description:attribute}s, inferenceFlags=%{public, signpost.description:attribute}lx", (uint8_t *)&v9, 0x26u);
    }
  }
}

__n128 sub_1DC31F934(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365D530;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC31F964(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F365D530;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_1DC31F9B8()
{
}

std::string *sub_1DC31F9D0(std::__fs::filesystem::path *__dst, uint64_t a2, std::__fs::filesystem::path *this)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1DC312750(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&__dst->__pn_.__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    __dst->__pn_.__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
  if (std::__fs::filesystem::path::__root_directory(this).__size_) {
    return std::string::operator=(&__dst->__pn_, &this->__pn_);
  }
  if (std::__fs::filesystem::path::__filename(__dst).__size_) {
    std::string::push_back(&__dst->__pn_, 47);
  }
  int v6 = SHIBYTE(this->__pn_.__r_.__value_.__r.__words[2]);
  if (v6 >= 0) {
    uint64_t v7 = this;
  }
  else {
    uint64_t v7 = (std::__fs::filesystem::path *)this->__pn_.__r_.__value_.__r.__words[0];
  }
  if (v6 >= 0) {
    std::string::size_type size = HIBYTE(this->__pn_.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = this->__pn_.__r_.__value_.__l.__size_;
  }
  return std::string::append(&__dst->__pn_, (const std::string::value_type *)v7, size);
}

void sub_1DC31FA74(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

atomic_ullong *sub_1DC31FA90(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

std::string *sub_1DC31FAC4(std::string *this, std::string *a2, std::string *a3)
{
  uint64_t v4 = a2;
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  unint64_t v7 = (char *)a3 - (char *)a2;
  if ((v6 & 0x80000000) != 0)
  {
    if (a3 == a2) {
      return this;
    }
    std::string::size_type size = this->__r_.__value_.__l.__size_;
    unint64_t v11 = this->__r_.__value_.__r.__words[2];
    std::string::size_type v9 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    uint64_t v10 = (std::string *)this->__r_.__value_.__r.__words[0];
    unint64_t v6 = HIBYTE(v11);
  }
  else
  {
    if (a3 == a2) {
      return this;
    }
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v9 = 22;
    uint64_t v10 = this;
  }
  if (v10 > v4 || (std::string *)((char *)&v10->__r_.__value_.__l.__data_ + size + 1) <= v4)
  {
    if (v9 - size < v7)
    {
      std::string::__grow_by(this, v9, size - v9 + v7, size, size, 0, 0);
      this->__r_.__value_.__l.__size_ = size;
      LOBYTE(v6) = *((unsigned char *)&this->__r_.__value_.__s + 23);
    }
    __int16 v13 = this;
    if ((v6 & 0x80) != 0) {
      __int16 v13 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    uint64_t v14 = (char *)v13 + size;
    do
    {
      std::string::value_type v15 = v4->__r_.__value_.__s.__data_[0];
      uint64_t v4 = (std::string *)((char *)v4 + 1);
      *v14++ = v15;
    }
    while (v4 != a3);
    std::string::value_type *v14 = 0;
    std::string::size_type v16 = v7 + size;
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
      this->__r_.__value_.__l.__size_ = v16;
    }
    else {
      *((unsigned char *)&this->__r_.__value_.__s + 23) = v16 & 0x7F;
    }
  }
  else
  {
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      sub_1DC3127EC();
    }
    if (v7 > 0x16)
    {
      uint64_t v17 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v17 = v7 | 7;
      }
      uint64_t v18 = v17 + 1;
      p_p = (std::string::value_type *)operator new(v17 + 1);
      std::string::size_type v24 = v7;
      int64_t v25 = v18 | 0x8000000000000000;
      std::string __p = p_p;
    }
    else
    {
      HIBYTE(v25) = v7;
      p_p = (std::string::value_type *)&__p;
    }
    do
    {
      std::string::value_type v19 = v4->__r_.__value_.__s.__data_[0];
      uint64_t v4 = (std::string *)((char *)v4 + 1);
      *p_p++ = v19;
    }
    while (v4 != a3);
    std::string::value_type *p_p = 0;
    if (v25 >= 0) {
      uint64_t v20 = (const std::string::value_type *)&__p;
    }
    else {
      uint64_t v20 = (const std::string::value_type *)__p;
    }
    if (v25 >= 0) {
      std::string::size_type v21 = HIBYTE(v25);
    }
    else {
      std::string::size_type v21 = v24;
    }
    std::string::append(this, v20, v21);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p);
    }
  }
  return this;
}

void sub_1DC31FC68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC31FC84(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1E019CC60](v23, a1);
  if (v23[0])
  {
    unint64_t v6 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *((void *)v6 + 5);
    int v8 = *((_DWORD *)v6 + 2);
    int v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    uint64_t v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v12 = a2 + a3;
    }
    else {
      uint64_t v12 = a2;
    }
    if (!v7) {
      goto LABEL_29;
    }
    uint64_t v13 = *((void *)v6 + 3);
    BOOL v14 = v13 <= a3;
    uint64_t v15 = v13 - a3;
    size_t v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_29;
    }
    if ((uint64_t)v16 >= 1)
    {
      if (v16 >= 0x7FFFFFFFFFFFFFF8) {
        sub_1DC3127EC();
      }
      if (v16 >= 0x17)
      {
        uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v16 | 7) != 0x17) {
          uint64_t v18 = v16 | 7;
        }
        uint64_t v19 = v18 + 1;
        p_CGFloat b = (std::locale::__imp *)operator new(v18 + 1);
        size_t v25 = v16;
        int64_t v26 = v19 | 0x8000000000000000;
        __b.__locale_ = p_b;
      }
      else
      {
        HIBYTE(v26) = v16;
        p_CGFloat b = (std::locale::__imp *)&__b;
      }
      memset(p_b, v9, v16);
      *((unsigned char *)p_b + v16) = 0;
      uint64_t v20 = v26 >= 0 ? &__b : (std::locale *)__b.__locale_;
      uint64_t v21 = (*(uint64_t (**)(uint64_t, std::locale *, size_t))(*(void *)v7 + 96))(v7, v20, v16);
      if (SHIBYTE(v26) < 0) {
        operator delete(__b.__locale_);
      }
      if (v21 != v16) {
        goto LABEL_29;
      }
    }
    if (v11 - v12 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v12, v11 - v12) == v11 - v12)
    {
      *((void *)v6 + 3) = 0;
    }
    else
    {
LABEL_29:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1E019CC70](v23);
  return a1;
}

void sub_1DC31FF20(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1E019CC70](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1DC31FEF4);
}

void sub_1DC31FF8C(_Unwind_Exception *a1)
{
}

uint64_t sub_1DC31FFA0(int a1, int a2)
{
  if (!a1)
  {
    if ((a2 - 33) > 0xFFFFFFDF)
    {
      uint64_t v2 = (unsigned int *)&unk_1DC4026D4;
      return v2[a2];
    }
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "number of data layers is out of bounds for full Aztec symbol");
LABEL_9:
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  if ((a2 - 5) <= 0xFFFFFFFB)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "number of data layers is out of bounds for compact Aztec symbol");
    goto LABEL_9;
  }
  uint64_t v2 = (unsigned int *)&unk_1DC4026C0;
  return v2[a2];
}

void sub_1DC320048(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1DC320060(uint64_t a1, signed int a2, int a3)
{
  if (!sub_1DC325C44(a1, a2, a3))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC3B430C(exception, "Sample point is out of image bounds");
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
  int v6 = *(unsigned __int8 *)(a1 + 45);
  return v6 != sub_1DC2FF924(*(void **)(a1 + 16), a2, a3);
}

void sub_1DC3200EC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC320100(uint64_t a1, void *a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  int v19 = 0;
  sub_1DC32021C(__p, 2uLL, &v19);
  LODWORD(v12) = 0;
  *(void *)&long long v13 = __PAIR64__(a4, a3);
  int32x2_t v17 = (int32x2_t)__PAIR64__(a6, a5);
  int v14 = 10;
  do
  {
    long long v18 = v13;
    *(float32x2_t *)__p[0] = vcvt_f32_s32(*(int32x2_t *)&v13);
    (*(void (**)(void, void **))(*(void *)*a2 + 16))(*a2, __p);
    BOOL v15 = sub_1DC320060(a1, (int)*(float *)__p[0], (int)*((float *)__p[0] + 1));
    *((void *)&v13 + 1) = *((void *)&v18 + 1);
    *(int32x2_t *)&long long v13 = vadd_s32(v17, *(int32x2_t *)&v18);
    uint64_t v12 = (v12 + v15);
    --v14;
  }
  while (v14);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v12;
}

void sub_1DC320200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC32021C(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DC314E1C(a1, a2);
    int v6 = (_DWORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1DC320284(_Unwind_Exception *exception_object)
{
  os_signpost_id_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC3202A0()
{
}

void sub_1DC320404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  sub_1DC314744(v15);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC320450(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t sub_1DC320484(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = (atomic_uint **)(a3 + v6);
      *(void *)(a3 + v6) = 0;
      uint64_t v8 = *(atomic_uint **)(a1 + v6);
      if (v8)
      {
        atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
        if (*v7) {
          sub_1DC2FF57C(*v7);
        }
      }
      _DWORD *v7 = v8;
      v6 += 8;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

uint64_t sub_1DC32053C(uint64_t a1, atomic_uint **a2)
{
  uint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  uint64_t v6 = a1 + 16;
  uint64_t v7 = *(void *)(a1 + 16) - *(void *)a1;
  if (v7 >> 2 > v3) {
    unint64_t v3 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v3;
  }
  uint64_t v18 = v6;
  if (v8) {
    unint64_t v8 = (unint64_t)sub_1DC2FFD7C(v8);
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = (atomic_uint **)(v8 + 8 * v2);
  v15[0] = v8;
  v15[1] = v10;
  size_t v16 = v10;
  unint64_t v17 = v8 + 8 * v9;
  *uint64_t v10 = 0;
  uint64_t v11 = *a2;
  uint64_t v12 = v10;
  if (v11)
  {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    uint64_t v12 = v10;
    if (*v10)
    {
      sub_1DC2FF57C(*v10);
      uint64_t v12 = v16;
    }
  }
  *uint64_t v10 = v11;
  size_t v16 = v12 + 1;
  sub_1DC3206A4((atomic_uint *)a1, v15);
  uint64_t v13 = *(void *)(a1 + 8);
  sub_1DC32079C((uint64_t)v15);
  return v13;
}

void sub_1DC320630(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC32079C((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint *sub_1DC320644(atomic_uint *result, atomic_uint **a2)
{
  uint64_t v2 = result;
  unint64_t v3 = (atomic_uint **)*((void *)result + 1);
  void *v3 = 0;
  uint64_t v4 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    __n128 result = *v3;
    if (*v3) {
      __n128 result = sub_1DC2FF57C(result);
    }
  }
  void *v3 = v4;
  *((void *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1DC32069C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

atomic_uint *sub_1DC3206A4(atomic_uint *result, void *a2)
{
  unint64_t v3 = result;
  uint64_t v5 = *(void *)result;
  uint64_t v4 = *((void *)result + 1);
  uint64_t v6 = a2[1];
  if (v4 != *(void *)result)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = v6 + v7;
      *(void *)(v6 + v7 - 8) = 0;
      uint64_t v9 = *(void *)(v4 + v7 - 8);
      if (v9)
      {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 1u, memory_order_relaxed);
        __n128 result = *(atomic_uint **)(v8 - 8);
        if (result) {
          __n128 result = sub_1DC2FF57C(result);
        }
      }
      *(void *)(v8 - 8) = v9;
      v7 -= 8;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v10 = *(void *)v3;
  *(void *)unint64_t v3 = v6;
  a2[1] = v10;
  uint64_t v11 = *((void *)v3 + 1);
  *((void *)v3 + 1) = a2[2];
  a2[2] = v11;
  uint64_t v12 = *((void *)v3 + 2);
  *((void *)v3 + 2) = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DC32079C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC2FFD08((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DC3207EC(float **a1, int a2, int a3, _DWORD *a4)
{
  if (a2 <= 0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "dimension <= 0");
    goto LABEL_38;
  }
  if (a3 > a2 || !a3 || (int v4 = -a2, -a2 > a3))
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "invalid init_center");
LABEL_38:
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  int v6 = a3 + 8;
  if (a3 + 8 >= a2) {
    int v6 = a2;
  }
  float v7 = (float)v6;
  if (a3 - 8 > v4) {
    int v4 = a3 - 8;
  }
  float v8 = (float)v4;
  *a4 = (int)(float)((float)((float)a3 - (float)v4) + (float)((float)a3 - (float)v4));
  unint64_t v9 = (unint64_t)(float)((float)((float)(v7 - (float)v4) * 2.0) + 1.0);
  if (v9 == 2)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    uint64_t v11 = (float *)operator new(8uLL);
    a1[1] = v11 + 2;
    a1[2] = v11 + 2;
    *uint64_t v11 = v8;
    v11[1] = v7;
    *a1 = v11;
  }
  else if (v9 == 1)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    uint64_t v10 = (float *)operator new(4uLL);
    *a1 = v10;
    *v10++ = v8;
    a1[1] = v10;
    a1[2] = v10;
  }
  else if (v9)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    int v14 = 0;
    uint64_t v15 = 0;
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    float v16 = (float)(v7 - (float)v4) / (float)(v9 - 1);
    do
    {
      if ((unint64_t)v14 >= v13)
      {
        uint64_t v18 = v14 - v12;
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 62) {
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v13 - (void)v12) >> 1 > v19) {
          unint64_t v19 = (uint64_t)(v13 - (void)v12) >> 1;
        }
        if (v13 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v19;
        }
        if (v20) {
          unint64_t v20 = (unint64_t)sub_1DC314E5C(v20);
        }
        else {
          uint64_t v21 = 0;
        }
        id v22 = (float *)(v20 + 4 * v18);
        *id v22 = v8;
        unint64_t v17 = v22 + 1;
        while (v14 != v12)
        {
          int v23 = *((_DWORD *)v14-- - 1);
          *((_DWORD *)v22-- - 1) = v23;
        }
        unint64_t v13 = v20 + 4 * v21;
        *a1 = v22;
        a1[1] = v17;
        a1[2] = (float *)v13;
        if (v12) {
          operator delete(v12);
        }
        uint64_t v12 = v22;
      }
      else
      {
        float *v14 = v8;
        unint64_t v17 = v14 + 1;
      }
      a1[1] = v17;
      float v8 = v16 + v8;
      ++v15;
      int v14 = v17;
    }
    while (v15 != v9);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1DC320A28(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DC320A5C(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DC314E1C(a1, a2);
    int v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_1DC320AB8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC320AD4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (a6 < 2) {
    return 0;
  }
  unsigned __int8 v13 = sub_1DC2FF924(a1, a2, a3);
  LODWORD(v6) = 0;
  unint64_t v14 = a6 - 1;
  uint64_t v15 = a4 + a2;
  uint64_t v16 = a5 + a3;
  do
  {
    unsigned __int8 v17 = sub_1DC2FF924(a1, v15, v16);
    uint64_t v6 = v6 + ((v13 ^ v17) & 1);
    if ((v13 ^ v17)) {
      unsigned __int8 v13 = v17;
    }
    v15 += a4;
    v16 += a5;
    --v14;
  }
  while (v14);
  return v6;
}

void *sub_1DC320B84(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DC314E1C(a1, a2);
    int v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_1DC320BE0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC320BFC(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = sub_1DC314E1C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1DC320C5C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1DC320C78(atomic_uint **a1, int32x2_t *a2, int32x2_t *a3, int32x2_t *a4)
{
  uint64_t v7 = *a1;
  uint64_t v8 = *((void *)*a1 + 7);
  uint64_t v9 = -v8;
  uint64_t v10 = *((void *)*a1 + 4);
  uint64_t v11 = v10 & -v8--;
  uint64_t v12 = *((void *)*a1 + 2);
  unint64_t v13 = v12 & v8 | v11;
  unint64_t v14 = v10 & v8 | v12 & v9;
  if (v13 <= v14) {
    unsigned int v15 = v14;
  }
  else {
    unsigned int v15 = v13;
  }
  atomic_fetch_add_explicit(v7 + 2, 1u, memory_order_relaxed);
  CFStringRef v52 = v7;
  int32x2_t v16 = *a3;
  int32x2_t v17 = vadd_s32(*a3, *a2);
  v45[0] = *a2;
  v45[1] = v17;
  uint64_t v51 = 0;
  int8x8_t v18 = vorr_s8((int8x8_t)vcltz_s32(v16), vbic_s8((int8x8_t)0x100000001, (int8x8_t)vceqz_s32(v16)));
  __int32 v19 = v18.i32[1];
  __int32 v20 = v18.i32[0];
  unint64_t v46 = (unint64_t)vabs_s32(v16);
  if (v46 >= HIDWORD(v46))
  {
    __int32 v22 = 0;
    __int32 v21 = v18.i32[0];
    __int32 v20 = 0;
  }
  else
  {
    __int32 v21 = 0;
    unint64_t v46 = __PAIR64__(v46, HIDWORD(v46));
    __int32 v22 = v18.i32[1];
    __int32 v19 = 0;
  }
  __int32 v47 = v21;
  __int32 v48 = v22;
  __int32 v49 = v20;
  __int32 v50 = v19;
  sub_1DC320E98((uint64_t)v53, v7, (uint64_t)v45, v15);
  sub_1DC2FF548(&v52);
  int v23 = v54[7];
  std::string::size_type v24 = *a1;
  if (*a1) {
    atomic_fetch_add_explicit(v24 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v41 = 0;
  CFTypeID v42 = v24;
  int32x2_t v25 = *a4;
  int32x2_t v26 = vadd_s32(*a4, *a2);
  v35[0] = *a2;
  v35[1] = v26;
  int8x8_t v27 = vorr_s8((int8x8_t)vcltz_s32(v25), vbic_s8((int8x8_t)0x100000001, (int8x8_t)vceqz_s32(v25)));
  __int32 v28 = v27.i32[1];
  __int32 v29 = v27.i32[0];
  unint64_t v36 = (unint64_t)vabs_s32(v25);
  if (v36 >= HIDWORD(v36))
  {
    __int32 v31 = 0;
    __int32 v30 = v27.i32[0];
    __int32 v29 = 0;
  }
  else
  {
    __int32 v30 = 0;
    unint64_t v36 = __PAIR64__(v36, HIDWORD(v36));
    __int32 v31 = v27.i32[1];
    __int32 v28 = 0;
  }
  __int32 v37 = v30;
  __int32 v38 = v31;
  __int32 v39 = v29;
  __int32 v40 = v28;
  sub_1DC320E98((uint64_t)v43, v24, (uint64_t)v35, v15);
  sub_1DC2FF548(&v42);
  *(float32x2_t *)&long long v32 = vmul_f32(vcvt_f32_s32(vadd_s32((int32x2_t)v44[7], (int32x2_t)v23)), (float32x2_t)0x3F0000003F000000);
  long long v34 = v32;
  sub_1DC2FF548(v44);
  sub_1DC2FF548(v54);
  return (__n128)v34;
}

void sub_1DC320E6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_1DC2FF548((atomic_uint **)va);
  sub_1DC2FF548((atomic_uint **)(v9 - 160));
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC320E98(uint64_t a1, atomic_uint *a2, uint64_t a3, unsigned int a4)
{
  if (a2)
  {
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
    int64_t v7 = *(void *)a3;
    long long v25 = *(_OWORD *)(a3 + 8);
    long long v26 = *(_OWORD *)(a3 + 24);
    uint64_t v27 = *(void *)(a3 + 40);
    __int32 v28 = a2;
    *(unsigned char *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  }
  else
  {
    int64_t v7 = *(void *)a3;
    long long v25 = *(_OWORD *)(a3 + 8);
    long long v26 = *(_OWORD *)(a3 + 24);
    uint64_t v27 = *(void *)(a3 + 40);
    __int32 v28 = 0;
    *(unsigned char *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
  *(_OWORD *)(a1 + 24) = v25;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = v7;
  *(_OWORD *)(a1 + 40) = v26;
  *(void *)(a1 + 56) = v27;
  *(void *)(a1 + 64) = v7;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0x100000000;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = a4;
  uint64_t v23 = a4;
  if (sub_1DC3210FC(a2, v7))
  {
    int v8 = sub_1DC2FF924(a2, (int)v7, v7 >> 32);
    int v9 = 0;
    uint64_t v10 = 0;
    *(unsigned char *)a1 = v8;
    int32x2_t v11 = *(int32x2_t *)(a1 + 40);
    int v12 = *(_DWORD *)(a1 + 32);
    int v22 = *(_DWORD *)(a1 + 36);
    int v13 = *(_DWORD *)(a1 + 56);
    int v19 = *(_DWORD *)(a1 + 60);
    int v20 = v19 + 1 + a4;
    int v21 = v8;
    while (1)
    {
      unint64_t v14 = (unint64_t)vadd_s32(v11, (int32x2_t)v7);
      v13 += v22;
      if (v12 < 2 * v13)
      {
        unint64_t v14 = (unint64_t)vadd_s32(*(int32x2_t *)(a1 + 48), (int32x2_t)v14);
        v13 -= v12;
      }
      int v15 = HIDWORD(v14);
      if (v23 == v10) {
        break;
      }
      if (v12 - v19 == v10)
      {
        int v17 = v12 + 1;
        goto LABEL_23;
      }
      unint64_t v24 = v14;
      unint64_t v16 = v14;
      if (!sub_1DC3210FC(a2, v14))
      {
        int v17 = v19 + v10 + 1;
        unint64_t v14 = v24;
        goto LABEL_23;
      }
      *(void *)(a1 + 88) = v10 + 1;
      if (v21 == sub_1DC2FF924(a2, (int)v16, v15))
      {
        int v9 = 0;
      }
      else
      {
        if (v9)
        {
          *(void *)(a1 + 72) = v7;
          *(void *)(a1 + 16) = v24;
          *(_DWORD *)(a1 + 56) = v13;
          *(_DWORD *)(a1 + 60) = v19 + 1 + v10;
          *(unsigned char *)a1 = v21 ^ 1;
          *(_DWORD *)(a1 + 80) = 0;
          return sub_1DC2FF548(&v28);
        }
        *(void *)(a1 + 64) = v24;
        if ((int)v7 > (int)v16) {
          *(_DWORD *)(a1 + 64) = v7;
        }
        if (SHIDWORD(v24) < SHIDWORD(v7)) {
          *(_DWORD *)(a1 + 68) = HIDWORD(v7);
        }
        int v9 = 1;
      }
      *(_DWORD *)(a1 + 80) = v9;
      int64_t v7 = v16;
      ++v10;
    }
    int v17 = v20;
LABEL_23:
    *(void *)(a1 + 72) = v7;
    *(void *)(a1 + 16) = v14;
    *(_DWORD *)(a1 + 56) = v13;
    *(_DWORD *)(a1 + 60) = v17;
  }
  return sub_1DC2FF548(&v28);
}

BOOL sub_1DC3210FC(void *a1, unint64_t a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  BOOL result = 0;
  if ((a2 & 0x8000000000000000) == 0)
  {
    uint64_t v4 = a1[7];
    uint64_t v5 = -v4;
    uint64_t v6 = a1[4];
    uint64_t v7 = v6 & -v4;
    uint64_t v8 = v4 - 1;
    uint64_t v9 = a1[2];
    if ((v9 & v8 | (unint64_t)v7) > a2) {
      return (v6 & v8 | v9 & (unint64_t)v5) > HIDWORD(a2);
    }
  }
  return result;
}

void sub_1DC32115C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int v3 = a3;
  unint64_t v5 = HIDWORD(a3);
  int v6 = sub_1DC31FFA0(*(unsigned __int8 *)(a1 + 24), *(_DWORD *)(a1 + 28));
  if (v6 >= 0) {
    int v7 = v6;
  }
  else {
    int v7 = v6 + 1;
  }
  int v8 = v7 >> 1;
  uint64_t v11 = 0;
  sub_1DC3207EC(&v10, v7 >> 1, v3, (_DWORD *)&v11 + 1);
  sub_1DC3207EC(&v9, v8, v5, &v11);
  if (*(void *)a2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)a2 + 8), 1u, memory_order_relaxed);
  }
  operator new();
}

void sub_1DC3218B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,int a33,atomic_uint *a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38)
{
  if (__p)
  {
    a36 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a38) {
    operator delete(a38);
  }
  _Unwind_Resume(a1);
}

void *sub_1DC3219D0(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    BOOL result = sub_1DC314E1C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1DC321A30(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC321A4C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  int v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

BOOL sub_1DC321A90(int a1, int a2)
{
  return ((a2 + a1 + a2 * a1 - a2 * a1 / 3) & 1) == 0;
}

BOOL sub_1DC321AC4(int a1, int a2)
{
  return a2 * a1 % 6 < 3;
}

BOOL sub_1DC321AF4(int a1, int a2)
{
  if (a1 >= 0) {
    unsigned int v2 = a1;
  }
  else {
    unsigned int v2 = a1 + 1;
  }
  return ((a2 / 3 + (v2 >> 1)) & 1) == 0;
}

BOOL sub_1DC321B24(char a1)
{
  return (a1 & 1) == 0;
}

uint64_t sub_1DC321B30(uint64_t a1, uint64_t *a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661570;
  *(void *)(a1 + 16) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
    uint64_t v4 = *(atomic_uint **)(a1 + 16);
    if (v4) {
      sub_1DC2FF57C(v4);
    }
  }
  *(void *)(a1 + 16) = v3;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 36) = 0;
  *(void *)(a1 + 28) = 0;
  *(_WORD *)(a1 + 44) = 0;
  return a1;
}

void sub_1DC321BAC(uint64_t a1, uint64_t a2)
{
  v24[3] = 0;
  uint64_t v23 = 0;
  unsigned int v2 = *(atomic_uint **)(a2 + 16);
  if (v2) {
    atomic_fetch_add_explicit(v2 + 2, 1u, memory_order_relaxed);
  }
  int v22 = v2;
  LODWORD(v15) = 0;
  unint64_t v14 = &unk_1F36612F8;
  unint64_t v16 = 0;
  if (v2) {
    atomic_fetch_add_explicit(v2 + 2, 1u, memory_order_relaxed);
  }
  unint64_t v16 = v2;
  atomic_uint v3 = v2[14];
  int v4 = -v3;
  atomic_uint v5 = v2[8];
  int v6 = v5 & -v3--;
  atomic_uint v7 = v2[4];
  int v8 = v7 & v3 | v6;
  signed int v9 = v5 & v3 | v7 & v4;
  int v17 = v8;
  signed int v18 = v9;
  int v19 = (v8 - 30) >> 1;
  int v20 = (v8 + 30) >> 1;
  int32x2_t v21 = vshr_n_s32(vadd_s32(vdup_n_s32(v9), (int32x2_t)0xFFFFFFE20000001ELL), 1uLL);
  if (v9 < 30 || v8 < 30 || v21.i32[0] >= v9 || (v8 + 30) >> 1 >= v8)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC379B70(exception, "Invalid dimensions WhiteRectangleDetector");
    void *exception = &unk_1F3661208;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FFB0, (void (*)(void *))sub_1DC3914A4);
  }
  sub_1DC349B6C(v24, &v14);
}

void sub_1DC323D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,__int16 a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,atomic_uint *a43,std::exception a44)
{
  sub_1DC2FFD08((atomic_uint **)(v44 - 160));
  *(void *)(v44 - 160) = &a33;
  sub_1DC2FFC48((void ***)(v44 - 160));
  unint64_t v46 = *(void **)(v44 - 184);
  if (v46)
  {
    *(void *)(v44 - 176) = v46;
    operator delete(v46);
  }
  sub_1DC30184C((atomic_uint **)(v44 - 192));
  *(void *)(v44 - 184) = &a30;
  sub_1DC324B20((void ***)(v44 - 184));
  for (uint64_t i = 24; i != -8; i -= 8)
    sub_1DC314744((atomic_uint **)((char *)&a44 + i));
  a44.__vftable = (std::exception_vtbl *)&a40;
  sub_1DC324B20((void ***)&a44);
  sub_1DC320450(&a43);
  _Unwind_Resume(a1);
}

atomic_uint *sub_1DC324A18(atomic_uint *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 61) {
      sub_1DC2FF97C();
    }
    int v6 = result;
    BOOL result = (atomic_uint *)sub_1DC2FFD7C(a4);
    atomic_uint v7 = result;
    void *v6 = result;
    v6[1] = result;
    v6[2] = &result[2 * v8];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v10 = (atomic_uint **)&v7[v9];
        *(void *)&v7[v9] = 0;
        uint64_t v11 = *(void *)(a2 + v9 * 4);
        if (v11)
        {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v11 + 8), 1u, memory_order_relaxed);
          BOOL result = *v10;
          if (*v10) {
            BOOL result = sub_1DC2FF57C(result);
          }
        }
        *(void *)&v7[v9] = v11;
        v9 += 2;
      }
      while (a2 + v9 * 4 != a3);
      atomic_uint v7 = (atomic_uint *)((char *)v7 + v9 * 4);
    }
    v6[1] = v7;
  }
  return result;
}

void sub_1DC324AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_1DC324B20(void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = (atomic_uint **)**a1;
  if (v2)
  {
    int v4 = (atomic_uint **)v1[1];
    atomic_uint v5 = v2;
    if (v4 != v2)
    {
      do
        int v4 = sub_1DC320450(v4 - 1);
      while (v4 != v2);
      atomic_uint v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DC324BA4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  *(unsigned char *)(a1 + 44) = 0;
  while (1)
  {
    atomic_uint v3 = *(_DWORD **)(*(void *)(a2 + 8 * v2) + 48);
    if (*v3)
    {
      unint64_t v4 = *(int *)(a1 + 36);
      if ((*(_DWORD *)((char *)v3 + ((v4 >> 2) & 0x1FFFFFFFFFFFFFFCLL)) >> ((2 * v4) & 0x1E))) {
        break;
      }
    }
    if (++v2 == 4)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      sub_1DC3B430C(exception, "could not determine orientation");
      __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
    }
  }
  if ((*v3 & 2) == 0
    && ((*(_DWORD *)((char *)v3 + (((unint64_t)(2 * (int)v4 - 1) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> (2 * v4 - 1)) & 1) != 0)
  {
    *(unsigned char *)(a1 + 44) = 1;
  }
  *(_DWORD *)(a1 + 40) = v2;
  operator new();
}

void sub_1DC3253C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, atomic_uint *a11, atomic_uint *a12, atomic_uint *a13, std::exception a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  sub_1DC314BD0(&a18);
  sub_1DC314B30((atomic_uint **)&a14);
  if (a2 == 1)
  {
    exception_ptr = __cxa_get_exception_ptr(a1);
    sub_1DC314C24(&a14, (uint64_t)exception_ptr);
    __cxa_begin_catch(a1);
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC379B70(exception, "failed to decode parameter data");
    void *exception = &unk_1F36611E0;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
  sub_1DC314BD0((void *)(v18 - 72));
  sub_1DC314744(&a11);
  sub_1DC314744(&a12);
  sub_1DC314744(&a13);
  _Unwind_Resume(a1);
}

void sub_1DC325538(uint64_t a1, char a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1DC31FFA0(a2 != 0, a3);
  sub_1DC350558();
  if (*(void *)a4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)a4 + 8), 1u, memory_order_relaxed);
  }
  (*(void (**)(void))(**(void **)a5 + 16))();
  (*(void (**)(void))(**(void **)a5 + 24))();
  (*(void (**)(void))(**(void **)a8 + 16))();
  (*(void (**)(void))(**(void **)a8 + 24))();
  (*(void (**)(void))(**(void **)a7 + 16))();
  (*(void (**)(void))(**(void **)a7 + 24))();
  (*(void (**)(void))(**(void **)a6 + 16))();
  (*(void (**)(void))(**(void **)a6 + 24))();
  sub_1DC353CE0();
}

void sub_1DC3257D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  int v6 = va_arg(va1, atomic_uint *);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, atomic_uint *);
  va_copy(va3, va2);
  uint64_t v10 = va_arg(va3, atomic_uint *);
  sub_1DC34E8D0((atomic_uint **)va1);
  sub_1DC2FF548((atomic_uint **)va2);
  sub_1DC30184C((atomic_uint **)va3);
  sub_1DC2FF548((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1DC325808(float a1, uint64_t a2, uint64_t a3, signed int a4, int a5)
{
  float v7 = a1 * 5.0;
  unsigned int v8 = llroundf(v7);
  float v9 = (float)a5;
  float v10 = (float)a4;
  if ((v8 & 0x80000000) == 0)
  {
    int v13 = llroundf(v7 / a1);
    int v14 = -v8;
    int v15 = (2 * v8) | 1;
    float v16 = 0.0;
    int v17 = -v8;
    do
    {
      float v18 = sub_1DC325DAC(a3, a4, llroundf(v9 + (float)v17), v13, a1, 0.0);
      if (v18 > v16) {
        float v16 = v18;
      }
      ++v17;
      --v15;
    }
    while (v15);
    int v19 = 2 * v13;
    int v20 = (2 * v8) | 1;
    float v21 = 0.0;
    do
    {
      float v22 = sub_1DC325DAC(a3, llroundf(v10 + (float)v14), a5, v19, 0.0, a1);
      if (v22 > v21) {
        float v21 = v22;
      }
      ++v14;
      --v20;
    }
    while (v20);
  }
  operator new();
}

void sub_1DC325C30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC320450((atomic_uint **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1DC325C44(uint64_t a1, signed int a2, int a3)
{
  if (a2 < 0) {
    return 0;
  }
  BOOL result = 0;
  if ((a3 & 0x80000000) == 0)
  {
    atomic_uint v5 = *(void **)(a1 + 16);
    uint64_t v6 = v5[7];
    uint64_t v7 = -v6;
    uint64_t v8 = v5[4];
    unsigned int v9 = v8 & -(int)v6;
    unsigned int v10 = v6 - 1;
    uint64_t v11 = v5[2];
    if ((v11 & v10 | v9) > a2) {
      return (v8 & v10 | v11 & v7) > a3;
    }
  }
  return result;
}

uint64_t sub_1DC325CA4(uint64_t a1, atomic_uint **a2)
{
  uint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  uint64_t v6 = a1 + 16;
  uint64_t v7 = *(void *)(a1 + 16) - *(void *)a1;
  if (v7 >> 2 > v3) {
    unint64_t v3 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v3;
  }
  uint64_t v18 = v6;
  if (v8) {
    unint64_t v8 = (unint64_t)sub_1DC2FFD7C(v8);
  }
  else {
    uint64_t v9 = 0;
  }
  unsigned int v10 = (atomic_uint **)(v8 + 8 * v2);
  v15[0] = v8;
  v15[1] = v10;
  float v16 = v10;
  unint64_t v17 = v8 + 8 * v9;
  *unsigned int v10 = 0;
  uint64_t v11 = *a2;
  int v12 = v10;
  if (v11)
  {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    int v12 = v10;
    if (*v10)
    {
      sub_1DC2FF57C(*v10);
      int v12 = v16;
    }
  }
  *unsigned int v10 = v11;
  float v16 = v12 + 1;
  sub_1DC3206A4((atomic_uint *)a1, v15);
  uint64_t v13 = *(void *)(a1 + 8);
  sub_1DC32079C((uint64_t)v15);
  return v13;
}

void sub_1DC325D98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC32079C((uint64_t)va);
  _Unwind_Resume(a1);
}

float sub_1DC325DAC(uint64_t a1, signed int a2, int a3, int a4, float a5, float a6)
{
  float v12 = 0.0;
  if (sub_1DC325C44(a1, a2, a3))
  {
    uint64_t v13 = *(void **)(a1 + 16);
    int v14 = sub_1DC2FF924(v13, a2, a3);
    if (a4 >= 2)
    {
      int v15 = v14;
      float v16 = (float)a2;
      float v17 = (float)a3;
      int v18 = a4 - 1;
      int v19 = 1;
      int v20 = v14;
      while (1)
      {
        signed int v21 = llroundf(v16 + (float)((float)v19 * a5));
        int v22 = llroundf(v17 + (float)((float)v19 * a6));
        if (!sub_1DC325C44(a1, v21, v22)) {
          break;
        }
        int v23 = sub_1DC2FF924(v13, v21, v22);
        int v24 = v23 - v20;
        if (v23 - v20 < 0) {
          int v24 = v20 - v23;
        }
        float v12 = v12 + (float)v24;
        ++v19;
        int v20 = v23;
        if (a4 == v19)
        {
          int v25 = a4 - 1;
          goto LABEL_10;
        }
      }
      int v25 = v19 - 1;
LABEL_10:
      int v26 = 1;
      while (1)
      {
        signed int v27 = llroundf(v16 - (float)((float)v26 * a5));
        int v28 = llroundf(v17 - (float)((float)v26 * a6));
        if (!sub_1DC325C44(a1, v27, v28)) {
          break;
        }
        int v29 = sub_1DC2FF924(v13, v27, v28);
        int v30 = v29 - v15;
        if (v29 - v15 < 0) {
          int v30 = v15 - v29;
        }
        float v12 = v12 + (float)v30;
        ++v26;
        int v15 = v29;
        if (a4 == v26) {
          goto LABEL_17;
        }
      }
      int v18 = v26 - 1;
LABEL_17:
      if (v18 + v25) {
        return v12 / (float)(v18 + v25);
      }
      else {
        return 0.0;
      }
    }
  }
  return v12;
}

void sub_1DC325F3C()
{
}

void sub_1DC325F54(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7)
{
  uint64_t v9 = a4;
  uint64_t v10 = a7;
  uint64_t v11 = a3;
  uint64_t v12 = a6;
  signed int v13 = a6 + a3;
  int v14 = a7 + a4;
  do
  {
    uint64_t v15 = v9;
    uint64_t v16 = v11;
    if (!sub_1DC325C44(a2, v13, v14)) {
      break;
    }
    v11 += v12;
    v9 += v10;
    v13 += a6;
    v14 += a7;
  }
  while (sub_1DC2FF924(*(void **)(a2 + 16), v16 + v12, v15 + v10) == a5);
  do
  {
    int v17 = v16;
    if (!sub_1DC325C44(a2, v16, v15)) {
      break;
    }
    int v18 = sub_1DC2FF924(*(void **)(a2 + 16), v16, (int)v15);
    v16 += v12;
  }
  while (v18 == a5);
  signed int v19 = v17 - a6;
  do
  {
    if (!sub_1DC325C44(a2, v19, v15)) {
      break;
    }
    int v20 = sub_1DC2FF924(*(void **)(a2 + 16), v19, v15);
    v15 += v10;
  }
  while (v20 == a5);
  operator new();
}

atomic_uint **sub_1DC3260DC(atomic_uint ***a1, atomic_uint **a2)
{
  uint64_t v2 = a1[1] - *a1;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  uint64_t v6 = a1 + 2;
  uint64_t v7 = (char *)a1[2] - (char *)*a1;
  if (v7 >> 2 > v3) {
    unint64_t v3 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v3;
  }
  signed int v27 = v6;
  if (v8) {
    unint64_t v8 = (unint64_t)sub_1DC2FFD7C(v8);
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = (atomic_uint **)(v8 + 8 * v2);
  unint64_t v24 = v8;
  v25.i64[0] = (uint64_t)v10;
  v25.i64[1] = (uint64_t)v10;
  unint64_t v26 = v8 + 8 * v9;
  *uint64_t v10 = 0;
  uint64_t v11 = *a2;
  uint64_t v12 = v10;
  signed int v13 = v10;
  if (v11)
  {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    uint64_t v12 = v10;
    signed int v13 = v10;
    if (*v10)
    {
      sub_1DC2FF57C(*v10);
      signed int v13 = (atomic_uint **)v25.i64[1];
      uint64_t v12 = (atomic_uint **)v25.i64[0];
    }
  }
  *uint64_t v10 = v11;
  int v14 = v13 + 1;
  v25.i64[1] = (uint64_t)(v13 + 1);
  uint64_t v16 = *a1;
  unint64_t v15 = (unint64_t)a1[1];
  if ((atomic_uint **)v15 == *a1)
  {
    int64x2_t v21 = vdupq_n_s64(v15);
  }
  else
  {
    uint64_t v17 = 0;
    do
    {
      int v18 = &v12[v17];
      v12[v17 - 1] = 0;
      signed int v19 = *(atomic_uint **)(v15 + v17 * 8 - 8);
      if (v19)
      {
        atomic_fetch_add_explicit(v19 + 2, 1u, memory_order_relaxed);
        int v20 = *(v18 - 1);
        if (v20) {
          sub_1DC2FF57C(v20);
        }
      }
      *(v18 - 1) = v19;
      --v17;
    }
    while ((atomic_uint **)(v15 + v17 * 8) != v16);
    uint64_t v12 = (atomic_uint **)((char *)v12 + v17 * 8);
    int64x2_t v21 = *(int64x2_t *)a1;
    int v14 = (atomic_uint **)v25.i64[1];
  }
  *a1 = v12;
  a1[1] = v14;
  int64x2_t v25 = v21;
  unint64_t v22 = (unint64_t)a1[2];
  a1[2] = (atomic_uint **)v26;
  unint64_t v26 = v22;
  unint64_t v24 = v21.i64[0];
  sub_1DC32628C((uint64_t)&v24);
  return v14;
}

void sub_1DC326258(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC32628C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC32628C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC320450((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1DC3262DC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v6 + 8), 1u, memory_order_relaxed);
  }
  __int32 v31 = (atomic_uint *)v6;
  uint64_t v7 = *a3;
  if (*a3) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 8), 1u, memory_order_relaxed);
  }
  int32x2_t v8 = vsub_s32(*(int32x2_t *)(v6 + 12), *(int32x2_t *)(v7 + 12));
  int32x2_t v9 = vmul_s32(v8, v8);
  int v30 = (atomic_uint *)v7;
  int32x2_t v10 = vadd_s32(vdup_lane_s32(v9, 1), v9);
  *(float *)v10.i32 = sqrtf((float)v10.i32[0]);
  int32x2_t v27 = v10;
  sub_1DC320450(&v30);
  sub_1DC320450(&v31);
  int32x2_t v11 = *(int32x2_t *)(*a3 + 12);
  int32x2_t v12 = *(int32x2_t *)(*a2 + 12);
  signed int v13 = *(void **)(a1 + 16);
  int32x2_t v28 = v12;
  int v14 = sub_1DC2FF924(v13, v12.i32[0], v12.i32[1]);
  float v16 = *(float *)v27.i32;
  int v17 = v14;
  float v18 = 0.0;
  if (*(float *)v27.i32 > 0.0)
  {
    int v19 = 0;
    float32x2_t v20 = vdiv_f32(vcvt_f32_s32(vsub_s32(v11, v28)), (float32x2_t)vdup_lane_s32(v27, 0));
    *(float32x2_t *)&long long v15 = vcvt_f32_s32(v28);
    int v21 = 1;
    do
    {
      *(float32x2_t *)&long long v15 = vadd_f32(v20, *(float32x2_t *)&v15);
      long long v29 = v15;
      int v22 = sub_1DC2FF924(v13, (int)(float)(*(float *)&v15 + 0.5), (int)(float)(*((float *)&v15 + 1) + 0.5));
      float v16 = *(float *)v27.i32;
      long long v15 = v29;
      v19 += v17 ^ v22;
      float v23 = (float)v21++;
    }
    while (*(float *)v27.i32 > v23);
    float v18 = (float)v19;
  }
  double v24 = (float)(v18 / v16);
  if (v24 > 0.1 && v24 < 0.9) {
    return 0;
  }
  if (v24 <= 0.1) {
    unsigned int v26 = 1;
  }
  else {
    unsigned int v26 = -1;
  }
  if (v17) {
    return v26;
  }
  else {
    return -v26;
  }
}

void *sub_1DC326480(void *a1, uint64_t a2)
{
  *a1 = &unk_1F36619D8;
  uint64_t v3 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1DC312750(v3, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v3 = v4;
  }
  *a1 = &unk_1F3661208;
  return a1;
}

void sub_1DC326508(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC32651C()
{
}

void sub_1DC326594(uint64_t a1)
{
  *(void *)a1 = &unk_1F36612F8;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC3265F8(uint64_t a1)
{
  *(void *)a1 = &unk_1F36612F8;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1DC32663C()
{
}

void sub_1DC3267B0(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x1091C40C7871EBFLL);
  _Unwind_Resume(a1);
}

uint64_t MRCSegmentationMaskCreateForSampleUsingNeuralNetwork(uint64_t a1, uint64_t a2, void *a3)
{
  if (qword_1EAA94C80 != -1) {
    dispatch_once(&qword_1EAA94C80, &unk_1F3662468);
  }
  long long v4 = qword_1EAA94C78;
  if (os_log_type_enabled((os_log_t)qword_1EAA94C78, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v6[0]) = 0;
    _os_log_error_impl(&dword_1DC2FE000, v4, OS_LOG_TYPE_ERROR, "MRCSegmentationMaskCreateForSampleUsingNeuralNetwork is obsolete", (uint8_t *)v6, 2u);
    if (!a3) {
      return 0;
    }
    goto LABEL_5;
  }
  if (a3)
  {
LABEL_5:
    sub_1DC390A40((uint64_t)v6, -4001, @"MRCSegmentationMaskCreateForSampleUsingNeuralNetwork is obsolete");
    sub_1DC390F7C(&v7, (uint64_t)v6);
    *a3 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
    sub_1DC306854((atomic_ullong *)&v7);
    sub_1DC390B00(v6);
  }
  return 0;
}

void sub_1DC3268C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

uint64_t MRCRegionGetTypeID()
{
  if (qword_1EBFFB6F8[0] != -1) {
    dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
  }
  return qword_1EBFFB6F0;
}

unint64_t MRCRegionCreate(long long *a1, long long *a2, const void *a3, double a4, float a5)
{
  if (!a1) {
    _os_assumes_log();
  }
  if (a2) {
    int32x2_t v10 = a2;
  }
  else {
    int32x2_t v10 = (long long *)MEMORY[0x1E4F1DAB8];
  }
  if (qword_1EBFFB6F8[0] != -1) {
    dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
  }
  Instance = (const void *)_CFRuntimeCreateInstance();
  atomic_ullong v12 = (atomic_ullong)Instance;
  if (Instance)
  {
    CFTypeID v13 = CFGetTypeID(Instance);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v13 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
    long long v14 = *v10;
    long long v15 = v10[2];
    *(_OWORD *)(v12 + 96) = v10[1];
    *(_OWORD *)(v12 + 112) = v15;
    *(_OWORD *)(v12 + 80) = v14;
    *(double *)(v12 + 128) = a4;
    if (a3)
    {
      CFTypeRef v16 = CFRetain(a3);
    }
    else
    {
      _os_assumes_log();
      CFTypeRef v16 = 0;
    }
    *(void *)(v12 + 136) = v16;
    *(float *)(v12 + 144) = a5;
    if (a5 < 0.0 || a5 > 1.0) {
      _os_assumes_log();
    }
    long long v17 = *a1;
    long long v18 = a1[1];
    long long v19 = a1[3];
    *(_OWORD *)(v12 + 48) = a1[2];
    *(_OWORD *)(v12 + 64) = v19;
    *(_OWORD *)(v12 + 16) = v17;
    *(_OWORD *)(v12 + 32) = v18;
    CFTypeID v20 = CFGetTypeID((CFTypeRef)v12);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v20 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
  }
  atomic_ullong v24 = v12;
  unint64_t v21 = atomic_exchange(&v24, 0);
  int v22 = (const void *)atomic_exchange(&v24, 0);
  if (v22) {
    CFRelease(v22);
  }
  return v21;
}

void sub_1DC326B40(_Unwind_Exception *a1)
{
  sub_1DC31FA90((atomic_ullong *)(v1 + 136));
  _Unwind_Resume(a1);
}

__n128 MRCRegionGetCornerPoints(__n128 *cf, __n128 *a2)
{
  if (a2)
  {
    if (!cf) {
      goto LABEL_7;
    }
  }
  else
  {
    _os_assumes_log();
    if (!cf) {
      goto LABEL_7;
    }
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (qword_1EBFFB6F8[0] != -1) {
    dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
  }
  if (v4 != qword_1EBFFB6F0) {
    _os_assumes_log();
  }
LABEL_7:
  __n128 result = cf[1];
  __n128 v6 = cf[2];
  __n128 v7 = cf[4];
  a2[2] = cf[3];
  a2[3] = v7;
  *a2 = result;
  a2[1] = v6;
  return result;
}

__n128 MRCRegionGetTransform@<Q0>(__n128 *cf@<X0>, __n128 *a2@<X8>)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v4 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
  }
  __n128 v5 = cf[6];
  *a2 = cf[5];
  a2[1] = v5;
  __n128 result = cf[7];
  a2[2] = result;
  return result;
}

double MRCRegionGetOrientation(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v2 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
  }
  return *((double *)cf + 16);
}

unint64_t MRCRegionGetSymbology(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v2 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
  }
  return atomic_load_explicit(cf + 17, memory_order_acquire);
}

float MRCRegionGetConfidence(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB6F8[0] != -1) {
      dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
    }
    if (v2 != qword_1EBFFB6F0) {
      _os_assumes_log();
    }
  }
  return *((float *)cf + 36);
}

CGAffineTransform *sub_1DC326E38(CGAffineTransform *result, _OWORD *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, char a6, uint64_t a7, char a8)
{
  int32x2_t v9 = result;
  if (a8)
  {
    if (a6) {
      a4 = a5;
    }
    uint64_t v12 = *a4;
    memset(&v22, 0, sizeof(v22));
    uint64_t v13 = v12 + 216 * a7;
    double Width = CGRectGetWidth(*(CGRect *)(v13 + 16));
    CGFloat v15 = Width / CGRectGetWidth(*(CGRect *)(a3 + 8));
    double Height = CGRectGetHeight(*(CGRect *)(v13 + 16));
    CGFloat v17 = CGRectGetHeight(*(CGRect *)(a3 + 8));
    CGAffineTransformMakeScale(&v22, v15, Height / v17);
    long long v18 = a2[5];
    *(_OWORD *)&t1.a = a2[4];
    *(_OWORD *)&t1.CGFloat c = v18;
    *(_OWORD *)&t1.tdouble x = a2[6];
    CGAffineTransform v20 = v22;
    return CGAffineTransformConcat(v9, &t1, &v20);
  }
  else
  {
    long long v19 = a2[5];
    *(_OWORD *)&result->a = a2[4];
    *(_OWORD *)&result->CGFloat c = v19;
    *(_OWORD *)&result->tdouble x = a2[6];
  }
  return result;
}

double sub_1DC326F34(uint64_t a1, float a2)
{
  uint64_t v2 = 0;
  float64x2_t v3 = (float64x2_t)vdupq_n_s64(0x41DFFFFFFFC00000uLL);
  float64x2_t v4 = (float64x2_t)vdupq_n_s64(0xC1E0000000000000);
  do
  {
    float64x2_t v5 = *(float64x2_t *)(a1 + v2);
    float64x2_t v3 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v3, v5), (int8x16_t)v5, (int8x16_t)v3);
    float64x2_t v4 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v5, v4), (int8x16_t)v5, (int8x16_t)v4);
    v2 += 16;
  }
  while (v2 != 64);
  *(void *)&double result = *(_OWORD *)&vsubq_f64(v3, vmulq_n_f64(vsubq_f64(v4, v3), a2));
  __asm { FMOV            V1.2D, #2.0 }
  return result;
}

atomic_ullong *sub_1DC326F90(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

CFArrayRef MRCSymbologyCopySupportedSymbologies()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (qword_1EBFFC430 != -1) {
    dispatch_once_f(&qword_1EBFFC430, 0, (dispatch_function_t)sub_1DC327040);
  }
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)qword_1EBFFC428, memory_order_acquire);
  return CFArrayCreateCopy(v0, explicit);
}

void sub_1DC327040()
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Aztec");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code39");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code39_checksum");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code39_fullAscii");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code39_fullAscii_checksum");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code93");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code93i");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code128");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"DataMatrix");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"EAN8");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"EAN13");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"I2of5");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"I2of5_checksum");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ITF14");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"PDF417");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"QR");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"UPCE");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MSIPlessey");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Codabar");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"GS1DataBar");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"GS1DataBarExpanded");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"GS1DataBarLimited");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MicroQR");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MicroPDF417");
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"AppClipCode");
  while (1)
  {
    CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    v3.length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    v3.location = 0;
    FirstIndexOfCFArrayRef Value = CFArrayGetFirstIndexOfValue(explicit, v3, @"AppClipCode");
    if (FirstIndexOfValue == -1) {
      break;
    }
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), FirstIndexOfValue);
  }
  operator new();
}

void sub_1DC3272D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x1E019CE90](v2, 0x60C4044C4A2DFLL);
  sub_1DC3070BC((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

CFArrayRef MRCSymbologyCopySupported1DSymbologies()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)sub_1DC327358(0), memory_order_acquire);
  return CFArrayCreateCopy(v0, explicit);
}

char *sub_1DC327358(int a1)
{
  os_unfair_lock_lock_with_options();
  if (!qword_1EAA94BB8) {
    operator new();
  }
  unint64_t v2 = *(void *)(qword_1EAA94BB8 + 8);
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a1;
      if (v2 <= a1) {
        unint64_t v4 = a1 % v2;
      }
    }
    else
    {
      unint64_t v4 = (v2 - 1) & a1;
    }
    float64x2_t v5 = *(void ***)(*(void *)qword_1EAA94BB8 + 8 * v4);
    if (v5)
    {
      __n128 v6 = *v5;
      if (*v5)
      {
        do
        {
          unint64_t v7 = v6[1];
          if (v7 == a1)
          {
            if (*((_DWORD *)v6 + 4) == a1) {
              goto LABEL_100;
            }
          }
          else
          {
            if (v3.u32[0] > 1uLL)
            {
              if (v7 >= v2) {
                v7 %= v2;
              }
            }
            else
            {
              v7 &= v2 - 1;
            }
            if (v7 != v4) {
              break;
            }
          }
          __n128 v6 = (void *)*v6;
        }
        while (v6);
      }
    }
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  switch(a1)
  {
    case 1:
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Aztec");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"DataMatrix");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"QR");
      CFArrayRef explicit = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      int32x2_t v10 = @"MicroQR";
LABEL_27:
      CFArrayAppendValue(explicit, v10);
      goto LABEL_28;
    case 0:
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code39");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code39_checksum");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code39_fullAscii");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code39_fullAscii_checksum");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code93");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code93i");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Code128");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"EAN8");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"EAN13");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"I2of5");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"I2of5_checksum");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ITF14");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"UPCE");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MSIPlessey");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Codabar");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"GS1DataBar");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"GS1DataBarExpanded");
      CFArrayRef explicit = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      int32x2_t v10 = @"GS1DataBarLimited";
      goto LABEL_27;
    case 2:
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"PDF417");
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MicroPDF417");
      break;
  }
  if (a1 == 3)
  {
    CFArrayRef explicit = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    int32x2_t v10 = @"AppClipCode";
    goto LABEL_27;
  }
LABEL_28:
  uint64_t v11 = qword_1EAA94BB8;
  CFArrayRef Copy = CFArrayCreateCopy(v8, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  __n128 v6 = operator new(0x20uLL);
  uint64_t v13 = (void *)(v11 + 16);
  v44[0] = v6;
  v44[1] = v11 + 16;
  *((_DWORD *)v6 + 4) = a1;
  v6[3] = Copy;
  char v45 = 1;
  void *v6 = 0;
  v6[1] = a1;
  unint64_t v14 = *(void *)(v11 + 8);
  if (v14)
  {
    uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v15.i16[0] = vaddlv_u8(v15);
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v16 = a1;
      if (v14 <= a1) {
        unint64_t v16 = a1 % v14;
      }
    }
    else
    {
      unint64_t v16 = (v14 - 1) & a1;
    }
    CGFloat v17 = *(void **)(*(void *)v11 + 8 * v16);
    if (v17)
    {
      for (uint64_t i = (_DWORD *)*v17; i; uint64_t i = *(_DWORD **)i)
      {
        unint64_t v19 = *((void *)i + 1);
        if (v19 == a1)
        {
          if (i[4] == a1)
          {
            __n128 v6 = i;
            goto LABEL_99;
          }
        }
        else
        {
          if (v15.u32[0] > 1uLL)
          {
            if (v19 >= v14) {
              v19 %= v14;
            }
          }
          else
          {
            v19 &= v14 - 1;
          }
          if (v19 != v16) {
            break;
          }
        }
      }
    }
  }
  float v20 = (float)(unint64_t)(*(void *)(v11 + 24) + 1);
  float v21 = *(float *)(v11 + 32);
  if (!v14 || (float)(v21 * (float)v14) < v20)
  {
    BOOL v22 = 1;
    if (v14 >= 3) {
      BOOL v22 = (v14 & (v14 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v14);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    else {
      int8x8_t prime = (int8x8_t)v23;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v14 = *(void *)(v11 + 8);
    }
    if (*(void *)&prime > v14) {
      goto LABEL_113;
    }
    if (*(void *)&prime >= v14) {
      goto LABEL_85;
    }
    unint64_t v32 = vcvtps_u32_f32((float)*(unint64_t *)(v11 + 24) / *(float *)(v11 + 32));
    if (v14 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
    {
      unint64_t v32 = std::__next_prime(v32);
    }
    else
    {
      uint64_t v34 = 1 << -(char)__clz(v32 - 1);
      if (v32 >= 2) {
        unint64_t v32 = v34;
      }
    }
    if (*(void *)&prime <= v32) {
      int8x8_t prime = (int8x8_t)v32;
    }
    if (*(void *)&prime >= v14)
    {
      unint64_t v14 = *(void *)(v11 + 8);
      goto LABEL_85;
    }
    if (prime)
    {
LABEL_113:
      if (*(void *)&prime >> 61) {
        sub_1DC2FF994();
      }
      unsigned int v26 = operator new(8 * *(void *)&prime);
      int32x2_t v27 = *(void **)v11;
      *(void *)uint64_t v11 = v26;
      if (v27) {
        operator delete(v27);
      }
      uint64_t v28 = 0;
      *(int8x8_t *)(v11 + 8) = prime;
      do
        *(void *)(*(void *)v11 + 8 * v28++) = 0;
      while (*(void *)&prime != v28);
      long long v29 = (void *)*v13;
      if (*v13)
      {
        unint64_t v30 = v29[1];
        uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
        v31.i16[0] = vaddlv_u8(v31);
        if (v31.u32[0] > 1uLL)
        {
          if (v30 >= *(void *)&prime) {
            v30 %= *(void *)&prime;
          }
        }
        else
        {
          v30 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)v11 + 8 * v30) = v13;
        uint64_t v35 = (void *)*v29;
        if (*v29)
        {
          do
          {
            unint64_t v36 = v35[1];
            if (v31.u32[0] > 1uLL)
            {
              if (v36 >= *(void *)&prime) {
                v36 %= *(void *)&prime;
              }
            }
            else
            {
              v36 &= *(void *)&prime - 1;
            }
            if (v36 != v30)
            {
              if (!*(void *)(*(void *)v11 + 8 * v36))
              {
                *(void *)(*(void *)v11 + 8 * v36) = v29;
                goto LABEL_81;
              }
              *long long v29 = *v35;
              void *v35 = **(void **)(*(void *)v11 + 8 * v36);
              **(void **)(*(void *)v11 + 8 * v36) = v35;
              uint64_t v35 = v29;
            }
            unint64_t v36 = v30;
LABEL_81:
            long long v29 = v35;
            uint64_t v35 = (void *)*v35;
            unint64_t v30 = v36;
          }
          while (v35);
        }
      }
      unint64_t v14 = (unint64_t)prime;
    }
    else
    {
      CFTypeID v42 = *(void **)v11;
      *(void *)uint64_t v11 = 0;
      if (v42) {
        operator delete(v42);
      }
      unint64_t v14 = 0;
      *(void *)(v11 + 8) = 0;
    }
  }
LABEL_85:
  unint64_t v37 = v6[1];
  uint8x8_t v38 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
  v38.i16[0] = vaddlv_u8(v38);
  if (v38.u32[0] > 1uLL)
  {
    if (v37 >= v14) {
      v37 %= v14;
    }
  }
  else
  {
    v37 &= v14 - 1;
  }
  __int32 v39 = *(void **)(*(void *)v11 + 8 * v37);
  if (v39)
  {
    void *v6 = *v39;
  }
  else
  {
    void *v6 = *(void *)(v11 + 16);
    *(void *)(v11 + 16) = v6;
    *(void *)(*(void *)v11 + 8 * v37) = v13;
    if (!*v6) {
      goto LABEL_98;
    }
    unint64_t v40 = *(void *)(*v6 + 8);
    if (v38.u32[0] > 1uLL)
    {
      if (v40 >= v14) {
        v40 %= v14;
      }
    }
    else
    {
      v40 &= v14 - 1;
    }
    __int32 v39 = (void *)(*(void *)v11 + 8 * v40);
  }
  *__int32 v39 = v6;
LABEL_98:
  ++*(void *)(v11 + 24);
  v44[0] = 0;
LABEL_99:
  sub_1DC327AE0((uint64_t)v44);
  sub_1DC3070BC((atomic_ullong *)&Mutable);
LABEL_100:
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EAA94BC0);
  return (char *)(v6 + 3);
}

void sub_1DC327AA0(_Unwind_Exception *a1)
{
}

void sub_1DC327AE0(uint64_t a1)
{
  uint64_t v1 = *(atomic_ullong **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1DC3065EC(v1 + 3);
    }
    operator delete(v1);
  }
}

CFArrayRef MRCSymbologyCopySupported2DSymbologies()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)sub_1DC327358(1), memory_order_acquire);
  return CFArrayCreateCopy(v0, explicit);
}

CFStringRef MRCSymbologyCopyDisplayName(CFTypeRef cf)
{
  if (qword_1EAA94BB0 != -1) {
    dispatch_once_f(&qword_1EAA94BB0, 0, (dispatch_function_t)sub_1DC327D40);
  }
  unint64_t v2 = (void *)qword_1EAA94BA8;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  CFTypeRef v17 = v3;
  CFArrayRef explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
  if (explicit) {
    CFHashCode v5 = CFHash(explicit);
  }
  else {
    CFHashCode v5 = 662607004;
  }
  int8x8_t v6 = (int8x8_t)v2[1];
  if (!*(void *)&v6) {
    goto LABEL_28;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    CFHashCode v9 = v5;
    if (v5 >= *(void *)&v6) {
      CFHashCode v9 = v5 % *(void *)&v6;
    }
  }
  else
  {
    CFHashCode v9 = (*(void *)&v6 - 1) & v5;
  }
  int32x2_t v10 = *(void **)(*v2 + 8 * v9);
  if (!v10 || (uint64_t v11 = (void *)*v10) == 0)
  {
LABEL_28:
    sub_1DC31FA90((atomic_ullong *)&v17);
    return 0;
  }
  while (1)
  {
    unint64_t v12 = v11[1];
    if (v12 == v5) {
      break;
    }
    if (v8 > 1)
    {
      if (v12 >= *(void *)&v6) {
        v12 %= *(void *)&v6;
      }
    }
    else
    {
      v12 &= *(void *)&v6 - 1;
    }
    if (v12 != v9) {
      goto LABEL_28;
    }
LABEL_27:
    uint64_t v11 = (void *)*v11;
    if (!v11) {
      goto LABEL_28;
    }
  }
  uint64_t v13 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
  unint64_t v14 = (const void *)atomic_load_explicit(v11 + 2, memory_order_acquire);
  if (v14 != v13)
  {
    BOOL v15 = !v13 || v14 == 0;
    if (v15 || !CFEqual(v14, v13)) {
      goto LABEL_27;
    }
  }
  sub_1DC31FA90((atomic_ullong *)&v17);
  return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)atomic_load_explicit(v11 + 3, memory_order_acquire));
}

void sub_1DC327D28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC31FA90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void sub_1DC327D40()
{
}

void sub_1DC3280B0(uint64_t *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  int8x8_t v6 = (atomic_ullong *)operator new(0x20uLL);
  atomic_ullong *v6 = 0;
  v6[1] = 0;
  CFTypeRef v7 = *a2;
  if (*a2) {
    CFTypeRef v7 = CFRetain(v7);
  }
  v6[2] = (atomic_ullong)v7;
  CFTypeRef v8 = *a3;
  if (*a3) {
    CFTypeRef v8 = CFRetain(v8);
  }
  CFHashCode v9 = 662607004;
  v6[3] = (atomic_ullong)v8;
  CFArrayRef explicit = (const void *)atomic_load_explicit(v6 + 2, memory_order_acquire);
  CFHashCode v11 = 662607004;
  if (explicit) {
    CFHashCode v11 = CFHash(explicit);
  }
  v6[1] = v11;
  unint64_t v12 = (const void *)atomic_load_explicit(v6 + 2, memory_order_acquire);
  if (v12) {
    CFHashCode v9 = CFHash(v12);
  }
  v6[1] = v9;
  unint64_t v13 = a1[1];
  if (!v13) {
    goto LABEL_30;
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
  v14.i16[0] = vaddlv_u8(v14);
  unint64_t v15 = v14.u32[0];
  if (v14.u32[0] > 1uLL)
  {
    CFHashCode v16 = v9;
    if (v13 <= v9) {
      CFHashCode v16 = v9 % v13;
    }
  }
  else
  {
    CFHashCode v16 = (v13 - 1) & v9;
  }
  CFTypeRef v17 = *(void **)(*a1 + 8 * v16);
  if (!v17 || (long long v18 = (void *)*v17) == 0)
  {
LABEL_30:
    unint64_t v23 = a1 + 2;
    float v24 = (float)(unint64_t)(a1[3] + 1);
    float v25 = *((float *)a1 + 8);
    if (v13 && (float)(v25 * (float)v13) >= v24) {
      goto LABEL_32;
    }
    BOOL v29 = 1;
    if (v13 >= 3) {
      BOOL v29 = (v13 & (v13 - 1)) != 0;
    }
    unint64_t v30 = v29 | (2 * v13);
    unint64_t v31 = vcvtps_u32_f32(v24 / v25);
    if (v30 <= v31) {
      int8x8_t prime = (int8x8_t)v31;
    }
    else {
      int8x8_t prime = (int8x8_t)v30;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    int8x8_t v36 = (int8x8_t)a1[1];
    if (*(void *)&prime <= *(void *)&v36)
    {
      if (*(void *)&prime >= *(void *)&v36) {
        goto LABEL_32;
      }
      unint64_t v43 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (*(void *)&v36 < 3uLL || (uint8x8_t v44 = (uint8x8_t)vcnt_s8(v36), v44.i16[0] = vaddlv_u8(v44), v44.u32[0] > 1uLL))
      {
        unint64_t v43 = std::__next_prime(v43);
      }
      else
      {
        uint64_t v45 = 1 << -(char)__clz(v43 - 1);
        if (v43 >= 2) {
          unint64_t v43 = v45;
        }
      }
      if (*(void *)&prime <= v43) {
        int8x8_t prime = (int8x8_t)v43;
      }
      if (*(void *)&prime >= *(void *)&v36) {
        goto LABEL_32;
      }
      if (!*(void *)&prime)
      {
        __int32 v48 = (void *)*a1;
        *a1 = 0;
        if (v48) {
          operator delete(v48);
        }
        a1[1] = 0;
        goto LABEL_32;
      }
    }
    if (*(void *)&prime >> 61) {
      sub_1DC2FF994();
    }
    unint64_t v37 = operator new(8 * *(void *)&prime);
    uint8x8_t v38 = (void *)*a1;
    *a1 = (uint64_t)v37;
    if (v38) {
      operator delete(v38);
    }
    uint64_t v39 = 0;
    a1[1] = (uint64_t)prime;
    do
      *(void *)(*a1 + 8 * v39++) = 0;
    while (*(void *)&prime != v39);
    unint64_t v40 = (void *)*v23;
    if (*v23)
    {
      unint64_t v41 = v40[1];
      uint8x8_t v42 = (uint8x8_t)vcnt_s8(prime);
      v42.i16[0] = vaddlv_u8(v42);
      if (v42.u32[0] > 1uLL)
      {
        if (v41 >= *(void *)&prime) {
          v41 %= *(void *)&prime;
        }
      }
      else
      {
        v41 &= *(void *)&prime - 1;
      }
      *(void *)(*a1 + 8 * v41) = v23;
      unint64_t v46 = (void *)*v40;
      if (*v40)
      {
        do
        {
          unint64_t v47 = v46[1];
          if (v42.u32[0] > 1uLL)
          {
            if (v47 >= *(void *)&prime) {
              v47 %= *(void *)&prime;
            }
          }
          else
          {
            v47 &= *(void *)&prime - 1;
          }
          if (v47 != v41)
          {
            if (!*(void *)(*a1 + 8 * v47))
            {
              *(void *)(*a1 + 8 * v47) = v40;
              goto LABEL_81;
            }
            *unint64_t v40 = *v46;
            *unint64_t v46 = **(void **)(*a1 + 8 * v47);
            **(void **)(*a1 + 8 * v47) = v46;
            unint64_t v46 = v40;
          }
          unint64_t v47 = v41;
LABEL_81:
          unint64_t v40 = v46;
          unint64_t v46 = (void *)*v46;
          unint64_t v41 = v47;
        }
        while (v46);
      }
    }
LABEL_32:
    int8x8_t v26 = (int8x8_t)a1[1];
    unint64_t v27 = v6[1];
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(v26);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      if (v27 >= *(void *)&v26) {
        v27 %= *(void *)&v26;
      }
    }
    else
    {
      v27 &= *(void *)&v26 - 1;
    }
    uint64_t v33 = *a1;
    uint64_t v34 = *(atomic_ullong ***)(*a1 + 8 * v27);
    if (v34)
    {
      atomic_ullong *v6 = (atomic_ullong)*v34;
    }
    else
    {
      atomic_ullong *v6 = *v23;
      *unint64_t v23 = (atomic_ullong)v6;
      *(void *)(v33 + 8 * v27) = v23;
      if (!*v6)
      {
LABEL_69:
        ++a1[3];
        return;
      }
      unint64_t v35 = *(void *)(*v6 + 8);
      if (v28.u32[0] > 1uLL)
      {
        if (v35 >= *(void *)&v26) {
          v35 %= *(void *)&v26;
        }
      }
      else
      {
        v35 &= *(void *)&v26 - 1;
      }
      uint64_t v34 = (atomic_ullong **)(*a1 + 8 * v35);
    }
    const char *v34 = v6;
    goto LABEL_69;
  }
  while (1)
  {
    unint64_t v19 = v18[1];
    if (v19 == v9) {
      break;
    }
    if (v15 > 1)
    {
      if (v19 >= v13) {
        v19 %= v13;
      }
    }
    else
    {
      v19 &= v13 - 1;
    }
    if (v19 != v16) {
      goto LABEL_30;
    }
LABEL_29:
    long long v18 = (void *)*v18;
    if (!v18) {
      goto LABEL_30;
    }
  }
  float v20 = (const void *)atomic_load_explicit(v6 + 2, memory_order_acquire);
  float v21 = (const void *)atomic_load_explicit(v18 + 2, memory_order_acquire);
  if (v21 != v20)
  {
    BOOL v22 = !v20 || v21 == 0;
    if (v22 || !CFEqual(v21, v20)) {
      goto LABEL_29;
    }
  }
  sub_1DC328578(1, v6);
}

void sub_1DC32853C(_Unwind_Exception *a1)
{
  sub_1DC328578(1, v1);
  _Unwind_Resume(a1);
}

void sub_1DC328578(char a1, atomic_ullong *__p)
{
  if (a1)
  {
    sub_1DC31FA90(__p + 3);
    sub_1DC31FA90(__p + 2);
  }
  operator delete(__p);
}

CFSetRef sub_1DC3285C8()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v1[0] = xmmword_1E6C3A318;
  v1[1] = *(_OWORD *)&off_1E6C3A328;
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)v1, 4, MEMORY[0x1E4F1D548]);
  qword_1EBFFC438 = (uint64_t)result;
  return result;
}

unint64_t sub_1DC328648(atomic_ullong *a1)
{
  if (qword_1EBFFC410 != -1) {
    dispatch_once_f(&qword_1EBFFC410, 0, (dispatch_function_t)sub_1DC3286E4);
  }
  unint64_t explicit = atomic_load_explicit(a1, memory_order_acquire);
  if (!explicit) {
    goto LABEL_7;
  }
  unint64_t Value = (unint64_t)CFDictionaryGetValue((CFDictionaryRef)qword_1EBFFC408, (const void *)atomic_load_explicit(a1, memory_order_acquire));
  if (!Value)
  {
    unint64_t explicit = 0;
LABEL_7:
    unsigned int v5 = 0;
    int v4 = 0;
    return explicit | v4 | v5;
  }
  int v4 = ((Value >> 4) - 1) & 0xFFFFFF00;
  unsigned int v5 = ((Value >> 4) - 1);
  unint64_t explicit = 0x100000000;
  return explicit | v4 | v5;
}

CFDictionaryRef sub_1DC3286E4()
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  long long v29 = xmmword_1E6C3A3F8;
  long long v30 = *(_OWORD *)&off_1E6C3A408;
  unint64_t v31 = @"PseudoExternal";
  long long v25 = xmmword_1E6C3A3B8;
  long long v26 = *(_OWORD *)&off_1E6C3A3C8;
  long long v27 = xmmword_1E6C3A3D8;
  long long v28 = *(_OWORD *)&off_1E6C3A3E8;
  long long v21 = xmmword_1E6C3A378;
  long long v22 = *(_OWORD *)&off_1E6C3A388;
  long long v23 = xmmword_1E6C3A398;
  long long v24 = *(_OWORD *)&off_1E6C3A3A8;
  *(_OWORD *)keys = xmmword_1E6C3A338;
  long long v18 = *(_OWORD *)&off_1E6C3A348;
  long long v19 = xmmword_1E6C3A358;
  long long v20 = *(_OWORD *)&off_1E6C3A368;
  long long v12 = xmmword_1DC402810;
  long long v13 = unk_1DC402820;
  long long v14 = xmmword_1DC402830;
  long long v15 = unk_1DC402840;
  long long v8 = xmmword_1DC4027D0;
  long long v9 = unk_1DC4027E0;
  long long v10 = xmmword_1DC4027F0;
  long long v11 = unk_1DC402800;
  long long v4 = xmmword_1DC402790;
  long long v5 = unk_1DC4027A0;
  long long v6 = xmmword_1DC4027B0;
  long long v7 = unk_1DC4027C0;
  *(_OWORD *)values = xmmword_1DC402770;
  long long v3 = unk_1DC402780;
  uint64_t v16 = 64;
  memset(&v1, 0, sizeof(v1));
  CFDictionaryRef result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 29, MEMORY[0x1E4F1D530], &v1);
  qword_1EBFFC408 = (uint64_t)result;
  return result;
}

unint64_t sub_1DC328800(atomic_ullong *a1)
{
  if (qword_1EBFFB7D0 != -1) {
    dispatch_once_f(&qword_1EBFFB7D0, 0, (dispatch_function_t)sub_1DC32889C);
  }
  unint64_t explicit = atomic_load_explicit(a1, memory_order_acquire);
  if (!explicit) {
    goto LABEL_7;
  }
  unint64_t Value = (unint64_t)CFDictionaryGetValue((CFDictionaryRef)qword_1EBFFB7C8, (const void *)atomic_load_explicit(a1, memory_order_acquire));
  if (!Value)
  {
    unint64_t explicit = 0;
LABEL_7:
    unsigned int v5 = 0;
    int v4 = 0;
    return explicit | v4 | v5;
  }
  int v4 = ((Value >> 4) - 1) & 0xFFFFFF00;
  unsigned int v5 = ((Value >> 4) - 1);
  unint64_t explicit = 0x100000000;
  return explicit | v4 | v5;
}

CFDictionaryRef sub_1DC32889C()
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  long long v25 = xmmword_1E6C3A4C0;
  long long v26 = off_1E6C3A4D0;
  long long v27 = @"AppClipCode";
  long long v21 = xmmword_1E6C3A480;
  long long v22 = *(_OWORD *)&off_1E6C3A490;
  long long v23 = xmmword_1E6C3A4A0;
  long long v24 = *(_OWORD *)&off_1E6C3A4B0;
  long long v17 = xmmword_1E6C3A440;
  long long v18 = *(_OWORD *)&off_1E6C3A450;
  long long v19 = xmmword_1E6C3A460;
  long long v20 = *(_OWORD *)&off_1E6C3A470;
  *(_OWORD *)keys = xmmword_1E6C3A420;
  long long v16 = *(_OWORD *)&off_1E6C3A430;
  long long v10 = xmmword_1DC4028D8;
  long long v11 = unk_1DC4028E8;
  long long v12 = xmmword_1DC4028F8;
  long long v13 = unk_1DC402908;
  long long v6 = xmmword_1DC402898;
  long long v7 = unk_1DC4028A8;
  long long v8 = xmmword_1DC4028B8;
  long long v9 = unk_1DC4028C8;
  *(_OWORD *)values = xmmword_1DC402858;
  long long v3 = unk_1DC402868;
  long long v4 = xmmword_1DC402878;
  long long v5 = unk_1DC402888;
  uint64_t v14 = 80;
  memset(&v1, 0, sizeof(v1));
  CFDictionaryRef result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 25, MEMORY[0x1E4F1D530], &v1);
  qword_1EBFFB7C8 = (uint64_t)result;
  return result;
}

void sub_1DC3289A8()
{
}

void sub_1DC328B8C(float *a1, int a2, int a3)
{
  long long v6 = operator new(0x18uLL);
  long long v7 = v6;
  *((_DWORD *)v6 + 4) = a2;
  *((_DWORD *)v6 + 5) = a3;
  unint64_t v8 = a3 ^ a2;
  void *v6 = 0;
  v6[1] = v8;
  unint64_t v9 = *((void *)a1 + 1);
  if (!v9) {
    goto LABEL_21;
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    uint64_t v11 = a3 ^ a2;
    if (v9 <= v8) {
      uint64_t v11 = v8 % v9;
    }
  }
  else
  {
    uint64_t v11 = (v9 - 1) & v8;
  }
  long long v12 = *(uint64_t ***)(*(void *)a1 + 8 * v11);
  if (!v12 || (long long v13 = *v12) == 0)
  {
LABEL_21:
    float v16 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
    float v17 = a1[8];
    if (!v9 || (float)(v17 * (float)v9) < v16)
    {
      BOOL v18 = 1;
      if (v9 >= 3) {
        BOOL v18 = (v9 & (v9 - 1)) != 0;
      }
      unint64_t v19 = v18 | (2 * v9);
      unint64_t v20 = vcvtps_u32_f32(v16 / v17);
      if (v19 <= v20) {
        int8x8_t prime = (int8x8_t)v20;
      }
      else {
        int8x8_t prime = (int8x8_t)v19;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v9 = *((void *)a1 + 1);
      }
      if (*(void *)&prime > v9) {
        goto LABEL_91;
      }
      if (*(void *)&prime >= v9) {
        goto LABEL_62;
      }
      unint64_t v28 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (*(void *)&prime <= v28) {
        int8x8_t prime = (int8x8_t)v28;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *((void *)a1 + 1);
        goto LABEL_62;
      }
      if (prime)
      {
LABEL_91:
        if (*(void *)&prime >> 61) {
          sub_1DC2FF994();
        }
        long long v22 = operator new(8 * *(void *)&prime);
        long long v23 = *(void **)a1;
        *(void *)a1 = v22;
        if (v23) {
          operator delete(v23);
        }
        uint64_t v24 = 0;
        *((int8x8_t *)a1 + 1) = prime;
        do
          *(void *)(*(void *)a1 + 8 * v24++) = 0;
        while (*(void *)&prime != v24);
        long long v25 = (void *)*((void *)a1 + 2);
        if (v25)
        {
          unint64_t v26 = v25[1];
          uint8x8_t v27 = (uint8x8_t)vcnt_s8(prime);
          v27.i16[0] = vaddlv_u8(v27);
          if (v27.u32[0] > 1uLL)
          {
            if (v26 >= *(void *)&prime) {
              v26 %= *(void *)&prime;
            }
          }
          else
          {
            v26 &= *(void *)&prime - 1;
          }
          *(void *)(*(void *)a1 + 8 * v26) = a1 + 4;
          unint64_t v31 = (void *)*v25;
          if (*v25)
          {
            do
            {
              unint64_t v32 = v31[1];
              if (v27.u32[0] > 1uLL)
              {
                if (v32 >= *(void *)&prime) {
                  v32 %= *(void *)&prime;
                }
              }
              else
              {
                v32 &= *(void *)&prime - 1;
              }
              if (v32 != v26)
              {
                if (!*(void *)(*(void *)a1 + 8 * v32))
                {
                  *(void *)(*(void *)a1 + 8 * v32) = v25;
                  goto LABEL_58;
                }
                *long long v25 = *v31;
                *unint64_t v31 = **(void **)(*(void *)a1 + 8 * v32);
                **(void **)(*(void *)a1 + 8 * v32) = v31;
                unint64_t v31 = v25;
              }
              unint64_t v32 = v26;
LABEL_58:
              long long v25 = v31;
              unint64_t v31 = (void *)*v31;
              unint64_t v26 = v32;
            }
            while (v31);
          }
        }
        unint64_t v9 = (unint64_t)prime;
      }
      else
      {
        uint8x8_t v38 = *(void **)a1;
        *(void *)a1 = 0;
        if (v38) {
          operator delete(v38);
        }
        unint64_t v9 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_62:
    unint64_t v33 = v7[1];
    uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v34.i16[0] = vaddlv_u8(v34);
    if (v34.u32[0] > 1uLL)
    {
      if (v33 >= v9) {
        v33 %= v9;
      }
    }
    else
    {
      v33 &= v9 - 1;
    }
    unint64_t v35 = *(void **)a1;
    int8x8_t v36 = *(void **)(*(void *)a1 + 8 * v33);
    if (v36)
    {
      void *v7 = *v36;
    }
    else
    {
      void *v7 = *((void *)a1 + 2);
      *((void *)a1 + 2) = v7;
      v35[v33] = a1 + 4;
      if (!*v7)
      {
LABEL_75:
        ++*((void *)a1 + 3);
        return;
      }
      unint64_t v37 = *(void *)(*v7 + 8);
      if (v34.u32[0] > 1uLL)
      {
        if (v37 >= v9) {
          v37 %= v9;
        }
      }
      else
      {
        v37 &= v9 - 1;
      }
      int8x8_t v36 = (void *)(*(void *)a1 + 8 * v37);
    }
    *int8x8_t v36 = v7;
    goto LABEL_75;
  }
  while (1)
  {
    unint64_t v14 = v13[1];
    if (v14 == v8) {
      break;
    }
    if (v10.u32[0] > 1uLL)
    {
      if (v14 >= v9) {
        v14 %= v9;
      }
    }
    else
    {
      v14 &= v9 - 1;
    }
    if (v14 != v11) {
      goto LABEL_21;
    }
LABEL_20:
    long long v13 = (uint64_t *)*v13;
    if (!v13) {
      goto LABEL_21;
    }
  }
  if (*((_DWORD *)v13 + 4) != a2 || *((_DWORD *)v13 + 5) != a3) {
    goto LABEL_20;
  }
  operator delete(v6);
}

void sub_1DC328F98(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1DC328FAC(atomic_ullong *a1, int a2)
{
  if (qword_1EBFFC440 != -1) {
    dispatch_once_f(&qword_1EBFFC440, 0, (dispatch_function_t)sub_1DC3285C8);
  }
  if (atomic_load_explicit(a1, memory_order_acquire)
    && CFSetContainsValue((CFSetRef)qword_1EBFFC438, (const void *)atomic_load_explicit(a1, memory_order_acquire)))
  {
    int v4 = sub_1DC328648(a1);
    if (qword_1EBFFC420 != -1) {
      dispatch_once_f(&qword_1EBFFC420, 0, (dispatch_function_t)sub_1DC3289A8);
    }
    int8x8_t v5 = *(int8x8_t *)(qword_1EBFFC418 + 8);
    if (v5)
    {
      unint64_t v6 = v4 ^ a2;
      uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
      v7.i16[0] = vaddlv_u8(v7);
      if (v7.u32[0] > 1uLL)
      {
        uint64_t v8 = v4 ^ a2;
        if (*(void *)&v5 <= v6) {
          uint64_t v8 = v6 % *(void *)&v5;
        }
      }
      else
      {
        uint64_t v8 = (*(void *)&v5 - 1) & v6;
      }
      uint64_t i = *(uint64_t **)(*(void *)qword_1EBFFC418 + 8 * v8);
      if (i)
      {
        for (uint64_t i = (uint64_t *)*i; i; uint64_t i = (uint64_t *)*i)
        {
          unint64_t v13 = i[1];
          if (v13 == v6)
          {
            if (*((_DWORD *)i + 4) == v4 && *((_DWORD *)i + 5) == a2) {
              return i != 0;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v13 >= *(void *)&v5) {
                v13 %= *(void *)&v5;
              }
            }
            else
            {
              v13 &= *(void *)&v5 - 1;
            }
            if (v13 != v8) {
              goto LABEL_34;
            }
          }
        }
      }
    }
    else
    {
LABEL_34:
      uint64_t i = 0;
    }
    return i != 0;
  }
  else
  {
    unint64_t v9 = sub_1DC328800(a1);
    return HIDWORD(v9) && v9 == a2;
  }
}

uint64_t sub_1DC32914C(uint64_t a1, uint64_t *a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661968;
  *(void *)(a1 + 16) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
    int v4 = *(atomic_uint **)(a1 + 16);
    if (v4) {
      sub_1DC2FF57C(v4);
    }
  }
  *(void *)(a1 + 16) = v3;
  return a1;
}

atomic_uint **sub_1DC3291B8(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

double sub_1DC3291EC@<D0>(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(void *)(a1 + 84) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  *(unsigned char *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  return result;
}

void sub_1DC32922C(uint64_t a1)
{
  *(void *)a1 = &unk_1F36610D8;
  sub_1DC329290((atomic_uint **)(a1 + 16));
  JUMPOUT(0x1E019CE90);
}

atomic_uint **sub_1DC329290(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t sub_1DC3292C4(uint64_t a1)
{
  *(void *)a1 = &unk_1F36610D8;
  sub_1DC329290((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1DC329308(uint64_t a1@<X1>, unsigned __int8 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  std::string __p = 0;
  unint64_t v122 = 0;
  unint64_t v123 = 0;
  sub_1DC329ED4(&__p, 0x2FuLL);
  uint8x8_t v7 = *a2;
  unint64_t v6 = a2[1];
  if (v6 == *a2) {
    goto LABEL_34;
  }
  uint64_t v8 = *a2;
  while (*v8)
  {
    if (++v8 == v6)
    {
      uint64_t v8 = a2[1];
      break;
    }
  }
  if (v8 == v6)
  {
LABEL_34:
    *(_DWORD *)a3 = 1;
    *(void *)(a3 + 112) = 0;
    *(void *)(a3 + 104) = 0;
    *(_OWORD *)(a3 + 4) = 0u;
    *(_OWORD *)(a3 + 20) = 0u;
    *(_OWORD *)(a3 + 36) = 0u;
    *(_OWORD *)(a3 + 52) = 0u;
    *(_OWORD *)(a3 + 68) = 0u;
    *(void *)(a3 + 84) = 0;
    *(void *)(a3 + 96) = a3 + 104;
    *(unsigned char *)(a3 + 120) = 0;
    *(_DWORD *)(a3 + 124) = 0;
    *(_DWORD *)(a3 + 128) = 0;
    long long v25 = (int *)__p;
    if (!__p) {
      return;
    }
    goto LABEL_35;
  }
  uint64_t v119 = a1;
  uint64_t v120 = a3;
  for (unsigned int i = 0; v7 != v8; i += v10)
    int v10 = *v7++;
  unint64_t v11 = v123;
  long long v12 = __p;
  unint64_t v13 = v8;
  while (1)
  {
    int v14 = *v8 == 0;
    long long v15 = &v8[v6 - v13];
    while (*v8 != v14)
    {
      if (++v8 == v6)
      {
        uint64_t v8 = v15;
        break;
      }
    }
    float v16 = v122;
    if (v8 == v6) {
      break;
    }
    int v17 = v8 - v13;
    if ((unint64_t)v122 >= v11)
    {
      uint64_t v19 = (v122 - v12) >> 2;
      unint64_t v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 62) {
        goto LABEL_128;
      }
      if ((uint64_t)(v11 - (void)v12) >> 1 > v20) {
        unint64_t v20 = (uint64_t)(v11 - (void)v12) >> 1;
      }
      if (v11 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v20;
      }
      if (v21) {
        unint64_t v21 = (unint64_t)sub_1DC314E5C(v21);
      }
      else {
        uint64_t v22 = 0;
      }
      long long v23 = (char *)(v21 + 4 * v19);
      *(_DWORD *)long long v23 = v17;
      BOOL v18 = v23 + 4;
      while (v16 != v12)
      {
        int v24 = *((_DWORD *)v16 - 1);
        v16 -= 4;
        *((_DWORD *)v23 - 1) = v24;
        v23 -= 4;
      }
      unint64_t v11 = v21 + 4 * v22;
      std::string __p = v23;
      unint64_t v123 = v11;
      if (v12) {
        operator delete(v12);
      }
      long long v12 = v23;
    }
    else
    {
      *(_DWORD *)unint64_t v122 = v17;
      BOOL v18 = v16 + 4;
    }
    unint64_t v122 = v18;
    unint64_t v6 = a2[1];
    unint64_t v13 = v8;
    if (v6 == v8) {
      goto LABEL_38;
    }
  }
  BOOL v18 = v122;
LABEL_38:
  int v26 = v8 - v13;
  if ((unint64_t)v18 >= v11)
  {
    uint64_t v28 = (v18 - v12) >> 2;
    unint64_t v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 62) {
LABEL_128:
    }
      sub_1DC2FF97C();
    if ((uint64_t)(v11 - (void)v12) >> 1 > v29) {
      unint64_t v29 = (uint64_t)(v11 - (void)v12) >> 1;
    }
    if (v11 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v29;
    }
    if (v30) {
      unint64_t v30 = (unint64_t)sub_1DC314E5C(v30);
    }
    else {
      uint64_t v31 = 0;
    }
    long long v25 = (int *)(v30 + 4 * v28);
    *long long v25 = v26;
    uint8x8_t v27 = (char *)(v25 + 1);
    while (v18 != v12)
    {
      int v32 = *((_DWORD *)v18 - 1);
      v18 -= 4;
      *--long long v25 = v32;
    }
    std::string __p = v25;
    unint64_t v123 = v30 + 4 * v31;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    *(_DWORD *)BOOL v18 = v26;
    long long v25 = (int *)__p;
    uint8x8_t v27 = v18 + 4;
  }
  unint64_t v122 = v27;
  if ((unint64_t)(v27 - (char *)v25) < 0xBC)
  {
LABEL_115:
    *(_DWORD *)uint64_t v120 = 1;
    *(void *)(v120 + 104) = 0;
    *(void *)(v120 + 112) = 0;
    *(_OWORD *)(v120 + 4) = 0u;
    *(_OWORD *)(v120 + 20) = 0u;
    *(_OWORD *)(v120 + 36) = 0u;
    *(_OWORD *)(v120 + 52) = 0u;
    *(_OWORD *)(v120 + 68) = 0u;
    *(void *)(v120 + 84) = 0;
    *(void *)(v120 + 96) = v120 + 104;
    *(unsigned char *)(v120 + 120) = 0;
    *(_DWORD *)(v120 + 124) = 0;
    *(_DWORD *)(v120 + 128) = 0;
    if (!v25) {
      return;
    }
    goto LABEL_35;
  }
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  unint64_t v35 = &v128;
  int8x8_t v36 = v130;
  unint64_t v37 = &v129;
  uint8x8_t v38 = v125;
  uint64_t v39 = &v127[1];
  while (1)
  {
    unint64_t v40 = &v25[v34];
    int v41 = v40[1];
    int v43 = v40[44];
    int v42 = v40[45];
    float v44 = (float)v41;
    if (*v40 < v41 && (float)(vabds_f32((float)*v40, v44) / (float)(v41 + *v40)) >= 0.3) {
      goto LABEL_114;
    }
    int v45 = v40[46];
    if ((float)(vabds_f32((float)v45, (float)v42) / (float)(v45 + v42)) >= 0.3 && v45 < v42) {
      goto LABEL_114;
    }
    float v47 = (float)v43;
    if ((float)(vabds_f32((float)v42, (float)v43) / (float)(v43 + v42)) >= 0.3) {
      goto LABEL_114;
    }
    int v48 = 0;
    for (uint64_t j = 2; j != 16; ++j)
      v48 += v25[v33 + j];
    int v50 = 0;
    for (uint64_t k = 16; k != 30; ++k)
      v50 += v25[v33 + k];
    int v52 = 0;
    for (uint64_t m = 30; m != 44; ++m)
      v52 += v25[v33 + m];
    float v54 = (float)v48 / 26.0;
    if ((float)(vabds_f32(v44, v54) / (float)(v54 + v44)) >= 0.3) {
      goto LABEL_114;
    }
    float v55 = (float)v50 / 18.0;
    if ((float)(vabds_f32(v54, v55) / (float)(v54 + v55)) >= 0.3) {
      goto LABEL_114;
    }
    float v56 = (float)v52 / 26.0;
    if ((float)(vabds_f32(v55, v56) / (float)(v55 + v56)) >= 0.3
      || (float)(vabds_f32(v56, v47) / (float)(v56 + v47)) >= 0.3)
    {
      goto LABEL_114;
    }
    uint64_t v117 = v39;
    int v113 = v36;
    uint64_t v114 = v38;
    uint64_t v115 = (uint64_t)v37;
    memmove(__dst, v40 + 2, 0xA8uLL);
    uint64_t v57 = 0;
    int v58 = 0;
    do
    {
      v58 += *(_DWORD *)&__dst[v57];
      v57 += 4;
    }
    while (v57 != 56);
    uint64_t v116 = v35;
    int v59 = 0;
    for (uint64_t n = 56; n != 112; n += 4)
      v59 += *(_DWORD *)&__dst[n];
    int v61 = 0;
    do
    {
      v61 += *(_DWORD *)&__dst[n];
      n += 4;
    }
    while (n != 168);
    float v62 = (float)v59 / 18.0;
    int v63 = v141;
    float v64 = (float)(v141 + v140);
    BOOL v65 = (float)(v62 * 2.5) >= v64 && (float)(v62 * 1.5) <= v64;
    if (v65 && (float)(v62 * 2.5) <= (float)(v139 + v138))
    {
      uint64_t v67 = 0;
      int v68 = 1;
      int v131 = 1;
      while (v67 != -13)
      {
        int v68 = (int)(float)(roundf((float)(*(int *)((char *)&v140 + v67 * 4) + v142[v67 - 1]) / v62) - (float)v68);
        *(_DWORD *)&v130[v67 * 4 + 8] = v68;
        --v67;
        if (v68 < 1) {
          goto LABEL_113;
        }
      }
      uint64_t v69 = 0;
      int v70 = 0;
      unint64_t v71 = v127;
      do
      {
        std::wstring::value_type v72 = *v71;
        v71 += 2;
        v143.__r_.__value_.__s.__data_[v69] = v72;
        v70 += v72;
        ++v69;
      }
      while (v69 != 6);
      if (v70 == 8)
      {
        int v112 = v63;
        int v73 = sub_1DC399FD4((int *)&v143, 6u, 3, 1);
        uint64_t v74 = 0;
        int v75 = 0;
        uint64_t v76 = v117;
        do
        {
          std::wstring::value_type v77 = *v76;
          v76 += 2;
          v143.__r_.__value_.__s.__data_[v74] = v77;
          v75 += v77;
          ++v74;
        }
        while (v74 != 6);
        if (v75 == 8)
        {
          int v78 = dword_1DC4029B4[(int)(sub_1DC399FD4((int *)&v143, 6u, 3, 0) + 21 * v73)];
          if ((v78 & 0x80000000) == 0)
          {
            int v111 = v78;
            int v79 = v136;
            int v80 = (int)(float)(roundf((float)(v137 + v136) / v62) - (float)v127[0]);
            int v131 = v80;
            uint64_t v81 = 12;
            while (v81 != -1)
            {
              int v82 = *(_DWORD *)&__dst[v81 * 4];
              int v80 = (int)(float)(roundf((float)(v82 + v79) / (float)((float)v58 / 26.0)) - (float)v80);
              v127[v81--] = v80;
              int v79 = v82;
              if (v80 < 1) {
                goto LABEL_113;
              }
            }
            unint64_t v83 = sub_1DC329F70(v127);
            if (HIDWORD(v83))
            {
              uint64_t v84 = 0;
              int v85 = 0;
              do
              {
                int v85 = (v85 + v127[v84] * byte_1DC402996[v84]) % 89;
                ++v84;
              }
              while (v84 != 14);
              uint64_t v86 = 0;
              int v87 = (int)(float)(roundf((float)(v142[0] + v112) / v62) + -1.0);
              v127[0] = v87;
              while (v86 != 13)
              {
                int v87 = (int)(float)(roundf((float)(v142[v86 + 1] + v142[v86]) / (float)((float)v61 / 26.0)) - (float)v87);
                v127[++v86] = v87;
                if (v87 <= 0) {
                  goto LABEL_113;
                }
              }
              int v88 = v83;
              unint64_t v89 = sub_1DC329F70(v127);
              if (HIDWORD(v89))
              {
                for (iunsigned int i = 0; ii != 14; ++ii)
                  int v85 = (v85 + v127[ii] * byte_1DC4029A4[ii]) % 89;
                if (v111 == v85) {
                  break;
                }
              }
            }
          }
        }
      }
    }
LABEL_113:
    unint64_t v37 = (void **)v115;
    unint64_t v35 = v116;
    int8x8_t v36 = v113;
    uint8x8_t v38 = v114;
    uint64_t v39 = v117;
LABEL_114:
    unint64_t v91 = v34 + 49;
    v34 += 2;
    v33 += 2;
    if (v91 > (v27 - (char *)v25) >> 2) {
      goto LABEL_115;
    }
  }
  BOOL v118 = (int)v89 + 2013571 * v88 > 0x1D52F517BD7;
  sub_1DC32A0F4((uint64_t)v127);
  *(void *)((char *)*(v128 - 3) + (void)v113) = 13;
  sub_1DC32A258(v116, 48);
  std::wostream::operator<<();
  sub_1DC32A320(&v143, v115);
  std::wstring::size_type size = v143.__r_.__value_.__l.__size_;
  if ((v143.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::wstring::size_type size = HIBYTE(v143.__r_.__value_.__r.__words[2]);
  }
  if (size)
  {
    uint64_t v93 = 0;
    int v94 = 0;
    int v95 = &v143;
    if ((v143.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v95 = (std::wstring *)v143.__r_.__value_.__r.__words[0];
    }
    do
    {
      int v96 = v95->__r_.__value_.__s.__data_[v93] - 48;
      if ((v93 & 1) == 0) {
        v96 *= 3;
      }
      v94 += v96;
      ++v93;
    }
    while (size != v93);
    int v97 = v94 % 10;
    if (v97 > 0) {
      int v97 = 10 - v97;
    }
    std::wstring::value_type v98 = v97 + 48;
  }
  else
  {
    std::wstring::value_type v98 = 48;
  }
  std::wstring::append(&v143, 1uLL, v98);
  sub_1DC32A3FC(&v124, (const void **)&v143.__r_.__value_.__l.__data_);
  uint64_t v99 = v124;
  v126[0] = *v114;
  *(void *)((char *)v126 + 7) = *(void *)((char *)v114 + 7);
  char v100 = v125[15];
  if (SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v143.__r_.__value_.__l.__data_);
  }
  *(void *)uint64_t v127 = off_1F36621C8;
  unint64_t v134 = off_1F3662218;
  unint64_t v128 = off_1F36621F0;
  uint64_t v129 = &unk_1F3662118;
  if (v133 < 0) {
    operator delete(v132);
  }
  int v101 = v40 + 46;
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1E019CE20](&v134);
  unsigned int v102 = i;
  if (v40 + 1 != v25)
  {
    float64x2_t v103 = v25 - 1;
    unsigned int v102 = i;
    do
    {
      int v104 = v103[1];
      ++v103;
      v102 += v104;
    }
    while (v103 != v40);
  }
  if (v101 != v25)
  {
    uint64_t v105 = v25;
    do
    {
      int v106 = *v105++;
      i += v106;
    }
    while (v105 != v101);
  }
  unint64_t v107 = v102 | ((unint64_t)v119 << 32);
  unint64_t v108 = i | (unint64_t)(v119 << 32);
  *(void *)uint64_t v120 = 0x2000000000000;
  uint64_t v109 = v126[0];
  *(void *)(v120 + 8) = v99;
  *(void *)(v120 + 16) = v109;
  *(void *)(v120 + 23) = *(void *)((char *)v126 + 7);
  *(unsigned char *)(v120 + 31) = v100;
  v126[0] = 0;
  *(void *)((char *)v126 + 7) = 0;
  *(void *)(v120 + 32) = v107;
  *(void *)(v120 + 40) = v108;
  *(void *)(v120 + 48) = v108;
  *(void *)(v120 + 56) = v107;
  *(void *)(v120 + 104) = 0;
  *(void *)(v120 + 112) = 0;
  *(void *)(v120 + 64) = 0;
  *(void *)(v120 + 72) = 0;
  *(void *)(v120 + 80) = 0;
  *(void *)(v120 + 96) = v120 + 104;
  *(unsigned char *)(v120 + 120) = 0;
  *(_DWORD *)(v120 + 124) = 0;
  *(_DWORD *)(v120 + 128) = 0;
  *(_DWORD *)(v120 + 88) = 0;
  float v110 = (float)(int)(i - v102) / 73.0;
  *(float *)(v120 + 124) = v110;
  *(float *)(v120 + 128) = v110;
  *(unsigned char *)(v120 + 120) = v118;
  if (v25)
  {
LABEL_35:
    unint64_t v122 = (char *)v25;
    operator delete(v25);
  }
}

void sub_1DC329E6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (*(char *)(v27 - 161) < 0) {
    operator delete(*(void **)(v27 - 184));
  }
  sub_1DC32A4FC((uint64_t)&a26);
  if (v26) {
    operator delete(v26);
  }
  _Unwind_Resume(a1);
}

void sub_1DC329ED4(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 2)
  {
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    int v4 = (char *)sub_1DC314E5C(a2);
    int8x8_t v5 = &v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    uint8x8_t v7 = &v4[4 * v6];
    uint64_t v8 = (char *)*a1;
    unint64_t v9 = (char *)a1[1];
    int v10 = v5;
    if (v9 != *a1)
    {
      int v10 = v5;
      do
      {
        int v11 = *((_DWORD *)v9 - 1);
        v9 -= 4;
        *((_DWORD *)v10 - 1) = v11;
        v10 -= 4;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t sub_1DC329F70(int *a1)
{
  uint64_t v2 = 0;
  int v3 = 0;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v4 = a1;
  do
  {
    int v5 = *v4;
    v4 += 2;
    v23[v2] = v5;
    v3 += v5;
    ++v2;
  }
  while (v2 != 7);
  if ((v3 - 20) < 0xFFFFFFF3 || (v3 & 1) == 0) {
    goto LABEL_18;
  }
  uint64_t v7 = 0;
  while (1)
  {
    uint64_t v8 = (char *)&unk_1DC403098 + v7;
    if (*(_DWORD *)((char *)&unk_1DC403098 + v7 + 4) == v3) {
      break;
    }
    v7 += 28;
    if (v7 == 196) {
      goto LABEL_18;
    }
  }
  if (v8 == "N5zxing8BitArrayE") {
    goto LABEL_18;
  }
  int v9 = sub_1DC399FD4(v23, 7u, *((_DWORD *)v8 + 3), 1);
  uint64_t v10 = 0;
  int v11 = 0;
  int v12 = *((_DWORD *)v8 + 6);
  int v13 = *(_DWORD *)v8;
  int v14 = a1 + 1;
  do
  {
    int v15 = *v14;
    v14 += 2;
    v23[v10] = v15;
    v11 += v15;
    ++v10;
  }
  while (v10 != 7);
  if (v11 != *((_DWORD *)v8 + 2))
  {
LABEL_18:
    int v18 = 0;
    unsigned int v19 = 0;
    uint64_t v20 = 0;
  }
  else
  {
    uint64_t v16 = 0;
    int v17 = v13 + v12 * v9;
    while (v23[v16] != 1)
    {
      if (++v16 == 7) {
        goto LABEL_18;
      }
    }
    int v22 = sub_1DC399FD4(v23, 7u, *((_DWORD *)v8 + 4), 0);
    unsigned int v19 = (v17 + v22) & 0xFFFFFF00;
    int v18 = (v17 + v22);
    uint64_t v20 = 0x100000000;
  }
  return v20 | v19 | v18;
}

uint64_t sub_1DC32A0F4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = off_1F36621F0;
  *(void *)a1 = &unk_1F365FA78;
  *(void *)(a1 + 128) = &unk_1F365FAA0;
  std::ios_base::init((std::ios_base *)(a1 + 128), (void *)(a1 + 24));
  *(void *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 272) = -1;
  *(void *)a1 = off_1F36621C8;
  *(void *)(a1 + 128) = off_1F3662218;
  *(void *)(a1 + 16) = off_1F36621F0;
  std::wstreambuf::basic_streambuf();
  *(void *)(a1 + 24) = &unk_1F3662118;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1DC32A21C(_Unwind_Exception *a1)
{
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1E019CE20](v1);
  _Unwind_Resume(a1);
}

void *sub_1DC32A258(void *a1, int a2)
{
  int v4 = (char *)a1 + *(void *)(*a1 - 24);
  if (*((_DWORD *)v4 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    int v5 = std::locale::use_facet(&v8, MEMORY[0x1E4FBA260]);
    int v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[3].__on_zero_shared)(v5, 32);
    std::locale::~locale(&v8);
    *((_DWORD *)v4 + 36) = v6;
  }
  *((_DWORD *)v4 + 36) = a2;
  return a1;
}

void sub_1DC32A30C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void *sub_1DC32A320(void *__dst, uint64_t a2)
{
  uint64_t v2 = __dst;
  int v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0x10) != 0)
  {
    int v5 = *(unsigned char **)(a2 + 88);
    int v6 = *(unsigned char **)(a2 + 48);
    if (v5 < v6)
    {
      *(void *)(a2 + 88) = v6;
      int v5 = v6;
    }
    uint64_t v7 = (const void **)(a2 + 40);
LABEL_8:
    std::locale v8 = *v7;
    int64_t v9 = v5 - (unsigned char *)*v7;
    if (v9 < 0) {
      sub_1DC3127EC();
    }
    uint64_t v4 = v9 >> 2;
    if ((unint64_t)v9 >= 0x14)
    {
      uint64_t v10 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 2;
      if ((v4 | 1) != 5) {
        uint64_t v10 = v4 | 1;
      }
      int v11 = sub_1DC314E5C(v10 + 1);
      v2[1] = v4;
      v2[2] = v12 | 0x8000000000000000;
      void *v2 = v11;
      uint64_t v2 = v11;
    }
    else
    {
      *((unsigned char *)__dst + 23) = (unint64_t)v9 >> 2;
      if (v5 == v8)
      {
        uint64_t v4 = 0;
        goto LABEL_16;
      }
    }
    std::string __dst = memmove(v2, v8, v9);
    goto LABEL_16;
  }
  if ((v3 & 8) != 0)
  {
    uint64_t v7 = (const void **)(a2 + 16);
    int v5 = *(unsigned char **)(a2 + 32);
    goto LABEL_8;
  }
  uint64_t v4 = 0;
  *((unsigned char *)__dst + 23) = 0;
LABEL_16:
  *((_DWORD *)v2 + v4) = 0;
  return __dst;
}

void *sub_1DC32A3FC(void *result, const void **a2)
{
  int v2 = *((char *)a2 + 23);
  if (v2 >= 0) {
    unint64_t v3 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    unint64_t v3 = (unint64_t)a2[1];
  }
  unint64_t v4 = v3 + 2;
  if (v3 + 2 >= 0x3FFFFFFFFFFFFFF8) {
    sub_1DC3127EC();
  }
  int v6 = result;
  if (v4 >= 5)
  {
    unint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 2;
    if ((v4 | 1) != 5) {
      unint64_t v9 = v4 | 1;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      sub_1DC2FF994();
    }
    unint64_t v10 = v9 + 1;
    int v11 = operator new(4 * (v9 + 1));
    v6[1] = v4;
    v6[2] = v10 | 0x8000000000000000;
    void *v6 = v11;
    *int v11 = 0x3100000030;
    std::locale v8 = v11 + 1;
    goto LABEL_15;
  }
  result[1] = 0;
  result[2] = 0;
  *double result = 0;
  *((unsigned char *)result + 23) = v4;
  if ((v4 & 0x80u) == 0) {
    uint64_t v7 = result;
  }
  else {
    uint64_t v7 = 0;
  }
  void *v7 = 0x3100000030;
  std::locale v8 = v7 + 1;
  if (v3)
  {
LABEL_15:
    if (v2 >= 0) {
      uint64_t v12 = a2;
    }
    else {
      uint64_t v12 = *a2;
    }
    double result = memmove(v8, v12, 4 * v3);
  }
  *((_DWORD *)v8 + v3) = 0;
  return result;
}

uint64_t sub_1DC32A4FC(uint64_t a1)
{
  *(void *)a1 = off_1F36621C8;
  uint64_t v2 = a1 + 128;
  *(void *)(a1 + 128) = off_1F3662218;
  *(void *)(a1 + 16) = off_1F36621F0;
  *(void *)(a1 + 24) = &unk_1F3662118;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1E019CE20](v2);
  return a1;
}

uint64_t sub_1DC32A5E4(uint64_t a1, uint64_t a2)
{
  if (a2 == -1) {
    return 0;
  }
  uint64_t v2 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v7 = *(_DWORD **)(a1 + 48);
  int v6 = *(_DWORD **)(a1 + 56);
  if (v7 != v6)
  {
    unint64_t v8 = *(void *)(a1 + 88);
    goto LABEL_14;
  }
  if ((*(unsigned char *)(a1 + 96) & 0x10) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 88);
  uint64_t v11 = a1 + 64;
  std::wstring::push_back((std::wstring *)(a1 + 64), 0);
  if (*(char *)(a1 + 87) < 0) {
    std::wstring::size_type v12 = (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1;
  }
  else {
    std::wstring::size_type v12 = 4;
  }
  std::wstring::resize((std::wstring *)(a1 + 64), v12, 0);
  if (*(char *)(a1 + 87) < 0)
  {
    uint64_t v11 = *(void *)(a1 + 64);
    uint64_t v13 = *(void *)(a1 + 72);
  }
  else
  {
    uint64_t v13 = *(unsigned __int8 *)(a1 + 87);
  }
  int v6 = (_DWORD *)(v11 + 4 * v13);
  uint64_t v7 = (_DWORD *)(v11 + 4 * (((uint64_t)v7 - v9) >> 2));
  *(void *)(a1 + 40) = v11;
  *(void *)(a1 + 48) = v7;
  *(void *)(a1 + 56) = v6;
  unint64_t v8 = v11 + 4 * ((v10 - v9) >> 2);
LABEL_14:
  if ((unint64_t)(v7 + 1) >= v8) {
    unint64_t v8 = (unint64_t)(v7 + 1);
  }
  *(void *)(a1 + 88) = v8;
  if ((*(unsigned char *)(a1 + 96) & 8) != 0)
  {
    int v14 = (void *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0) {
      int v14 = (void *)*v14;
    }
    *(void *)(a1 + 16) = v14;
    *(void *)(a1 + 24) = (char *)v14 + 4 * ((v4 - v5) >> 2);
    *(void *)(a1 + 32) = v8;
  }
  if (v7 != v6)
  {
    *(void *)(a1 + 48) = v7 + 1;
    _DWORD *v7 = v2;
    return v2;
  }
  uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 104);
  return v16(a1, v2);
}

void sub_1DC32A770(void *a1)
{
}

uint64_t sub_1DC32A77C(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 88);
  unint64_t v3 = *(void *)(a1 + 48);
  if (v2 < v3)
  {
    *(void *)(a1 + 88) = v3;
    unint64_t v2 = v3;
  }
  unint64_t v4 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 16) < v4)
  {
    if (a2 == -1)
    {
      a2 = 0;
      unint64_t v5 = v4 - 4;
      goto LABEL_10;
    }
    if ((*(unsigned char *)(a1 + 96) & 0x10) != 0 || *(_DWORD *)(v4 - 4) == a2)
    {
      *(_DWORD *)(v4 - 4) = a2;
      unint64_t v5 = v4 - 4;
LABEL_10:
      *(void *)(a1 + 24) = v5;
      *(void *)(a1 + 32) = v2;
      return a2;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1DC32A7E0(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 88);
  unint64_t v2 = *(void *)(a1 + 48);
  if (v1 < v2)
  {
    *(void *)(a1 + 88) = v2;
    unint64_t v1 = v2;
  }
  if ((*(unsigned char *)(a1 + 96) & 8) == 0) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v3 = *(void *)(a1 + 32);
  if (v3 < v1)
  {
    *(void *)(a1 + 32) = v1;
    unint64_t v3 = v1;
  }
  unint64_t v4 = *(unsigned int **)(a1 + 24);
  if ((unint64_t)v4 < v3) {
    return *v4;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_1DC32A830(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a1 + 32))(a1, *(void *)(a2 + 128), 0, a3);
}

double sub_1DC32A860@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  unint64_t v5 = *(void *)(a1 + 88);
  unint64_t v6 = *(void *)(a1 + 48);
  if (v5 < v6)
  {
    *(void *)(a1 + 88) = v6;
    unint64_t v5 = v6;
  }
  if ((a4 & 0x18) == 0 || a3 == 1 && (a4 & 0x18) == 0x18) {
    goto LABEL_14;
  }
  if (!v5)
  {
    uint64_t v8 = 0;
    if (a3) {
      goto LABEL_10;
    }
LABEL_17:
    uint64_t v12 = a3;
    goto LABEL_21;
  }
  uint64_t v7 = (void *)(a1 + 64);
  if (*(char *)(a1 + 87) < 0) {
    uint64_t v7 = (void *)*v7;
  }
  uint64_t v8 = (uint64_t)(v5 - (void)v7) >> 2;
  if (!a3) {
    goto LABEL_17;
  }
LABEL_10:
  if (a3 == 2)
  {
    uint64_t v12 = v8;
    goto LABEL_21;
  }
  if (a3 != 1)
  {
LABEL_14:
    uint64_t v10 = -1;
    goto LABEL_15;
  }
  if ((a4 & 8) != 0) {
    uint64_t v9 = *(void *)(a1 + 24) - *(void *)(a1 + 16);
  }
  else {
    uint64_t v9 = v6 - *(void *)(a1 + 40);
  }
  uint64_t v12 = v9 >> 2;
LABEL_21:
  uint64_t v10 = -1;
  uint64_t v13 = v12 + a2;
  if (v13 >= 0 && v8 >= v13 && (!v13 || ((a4 & 8) == 0 || *(void *)(a1 + 24)) && ((a4 & 0x10) == 0 || v6)))
  {
    if ((a4 & 8) != 0)
    {
      *(void *)(a1 + 24) = *(void *)(a1 + 16) + 4 * v13;
      *(void *)(a1 + 32) = v5;
    }
    if ((a4 & 0x10) != 0) {
      *(void *)(a1 + 48) = *(void *)(a1 + 40) + 4 * v13;
    }
    uint64_t v10 = v13;
  }
LABEL_15:
  double result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(void *)(a5 + 128) = v10;
  return result;
}

void sub_1DC32A968(uint64_t a1)
{
  *(void *)a1 = &unk_1F3662118;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  std::wstreambuf::~wstreambuf();
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC32A9DC(uint64_t a1)
{
  *(void *)a1 = &unk_1F3662118;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  return std::wstreambuf::~wstreambuf();
}

void sub_1DC32AA3C(void *a1)
{
  unint64_t v1 = (char *)a1 + *(void *)(*a1 - 24);
  *(void *)unint64_t v1 = off_1F36621C8;
  *((void *)v1 + 16) = off_1F3662218;
  *((void *)v1 + 2) = off_1F36621F0;
  *((void *)v1 + 3) = &unk_1F3662118;
  if (v1[111] < 0) {
    operator delete(*((void **)v1 + 11));
  }
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1E019CE20](v1 + 128);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC32AB58(void *a1)
{
  unint64_t v1 = (char *)a1 + *(void *)(*a1 - 24);
  *(void *)unint64_t v1 = off_1F36621C8;
  *((void *)v1 + 16) = off_1F3662218;
  *((void *)v1 + 2) = off_1F36621F0;
  *((void *)v1 + 3) = &unk_1F3662118;
  if (v1[111] < 0) {
    operator delete(*((void **)v1 + 11));
  }
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  JUMPOUT(0x1E019CE20);
}

void sub_1DC32AC5C(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1F36621C8;
  uint64_t v1 = a1 + 112;
  *(void *)(a1 + 112) = off_1F3662218;
  *(void *)a1 = off_1F36621F0;
  *(void *)(a1 + 8) = &unk_1F3662118;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1E019CE20](v1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC32AD64(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1F36621C8;
  *(void *)(a1 + 112) = off_1F3662218;
  *(void *)a1 = off_1F36621F0;
  *(void *)(a1 + 8) = &unk_1F3662118;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  JUMPOUT(0x1E019CE20);
}

void sub_1DC32AE54(uint64_t a1)
{
  *(void *)a1 = off_1F36621C8;
  uint64_t v1 = a1 + 128;
  *(void *)(a1 + 128) = off_1F3662218;
  *(void *)(a1 + 16) = off_1F36621F0;
  *(void *)(a1 + 24) = &unk_1F3662118;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::wstreambuf::~wstreambuf();
  std::wostream::~wostream();
  std::wistream::~wistream();
  MEMORY[0x1E019CE20](v1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC32AF5C(void *a1)
{
  sub_1DC32AFAC((uint64_t)a1 + *(void *)(*a1 - 24));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC32AFAC(uint64_t a1)
{
  return a1;
}

uint64_t sub_1DC32AFF8(void *a1)
{
  return sub_1DC32AFAC((uint64_t)a1 + *(void *)(*a1 - 24));
}

void sub_1DC32B014(uint64_t a1)
{
  sub_1DC32AFAC(a1 - 16);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC32B050(uint64_t a1)
{
  return sub_1DC32AFAC(a1 - 16);
}

void sub_1DC32B058(uint64_t a1)
{
  sub_1DC32AFAC(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC32B090()
{
}

void sub_1DC32B0A8(void *a1)
{
  *a1 = &unk_1F3661948;
  unint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC32B118(void *a1)
{
  *a1 = &unk_1F3661948;
  unint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_1DC32B168(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661948;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = 0;
  unint64_t v4 = a2 + 31;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  if ((unint64_t)(a2 + 31) >= 0x20)
  {
    unint64_t v5 = v4 >> 5;
    sub_1DC314E1C((void *)(a1 + 24), v4 >> 5);
    unint64_t v6 = *(_DWORD **)(a1 + 32);
    uint64_t v7 = &v6[v5];
    uint64_t v8 = 4 * v5;
    do
    {
      *v6++ = 0;
      v8 -= 4;
    }
    while (v8);
    *(void *)(a1 + 32) = v7;
    uint64_t v3 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 48) = v3;
  return a1;
}

void sub_1DC32B208(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC32B224(char **a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v6 = *a1;
  unint64_t v5 = a1[1];
  unint64_t v7 = (v5 - *a1) >> 2;
  if (a2 <= v7)
  {
    if (a2 < v7) {
      a1[1] = &v6[4 * a2];
    }
  }
  else
  {
    uint64_t v9 = a1[2];
    if (a2 - v7 <= (v9 - v5) >> 2)
    {
      long long v23 = &v5[4 * (a2 - v7)];
      uint64_t v24 = 4 * a2 - 4 * v7;
      do
      {
        *(_DWORD *)unint64_t v5 = *a3;
        v5 += 4;
        v24 -= 4;
      }
      while (v24);
      a1[1] = v23;
    }
    else
    {
      if (a2 >> 62) {
        sub_1DC2FF97C();
      }
      unint64_t v10 = v9 - v6;
      unint64_t v11 = (v9 - v6) >> 1;
      if (v11 <= a2) {
        unint64_t v11 = a2;
      }
      if (v10 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      uint64_t v13 = (char *)sub_1DC314E5C(v12);
      int v15 = &v13[4 * v7];
      uint64_t v16 = &v13[4 * a2];
      uint64_t v17 = 4 * a2 - 4 * v7;
      int v18 = v15;
      do
      {
        *(_DWORD *)int v18 = *a3;
        v18 += 4;
        v17 -= 4;
      }
      while (v17);
      unsigned int v19 = &v13[4 * v14];
      uint64_t v20 = *a1;
      for (unsigned int i = a1[1]; i != v20; i -= 4)
      {
        int v22 = *((_DWORD *)i - 1);
        *((_DWORD *)v15 - 1) = v22;
        v15 -= 4;
      }
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (v20)
      {
        operator delete(v20);
      }
    }
  }
}

void sub_1DC32B350(void *a1)
{
  *a1 = &unk_1F3661998;
  uint64_t v1 = a1[6];
  if (v1) {
    MEMORY[0x1E019CE70](v1, 0x1000C8052888210);
  }
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC32B3CC(void *a1)
{
  *a1 = &unk_1F3661998;
  uint64_t v2 = a1[6];
  if (v2) {
    MEMORY[0x1E019CE70](v2, 0x1000C8052888210);
  }
  return a1;
}

void sub_1DC32B428(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661998;
  unint64_t v2 = (a2 + 31) & 0xFFFFFFFFFFFFFFE0;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = v2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = (v2 * a2) >> 5;
  operator new[]();
}

void sub_1DC32B4C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661998;
  unint64_t v3 = (a2 + 31) & 0xFFFFFFFFFFFFFFE0;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = v3;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = (v3 * a3) >> 5;
  operator new[]();
}

void *sub_1DC32B568(void *result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (((a3 | a2) & 0x8000000000000000) != 0)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "topI and leftJ must be nonnegative");
    goto LABEL_16;
  }
  if (!a4 || !a5)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "height and width must be at least 1");
LABEL_16:
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  if (a4 + a2 > result[2] || (unint64_t v5 = a5 + a3, a5 + a3 > result[4]))
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "top + height and left + width must be <= matrix dimension");
    goto LABEL_16;
  }
  if (v5 > a3)
  {
    uint64_t v6 = result[3];
    unint64_t v7 = a2 + v6 * a3;
    do
    {
      if (a4 + a2 > a2)
      {
        uint64_t v8 = result[6];
        unint64_t v9 = v7;
        uint64_t v10 = a4;
        do
        {
          *(_DWORD *)(v8 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v9;
          ++v9;
          --v10;
        }
        while (v10);
      }
      ++a3;
      v7 += v6;
    }
    while (a3 != v5);
  }
  return result;
}

void sub_1DC32B680(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC32B69C(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  unint64_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1DC32B80C(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1E019CE10](v1);
  _Unwind_Resume(a1);
}

void *sub_1DC32B834(void *__dst, uint64_t a2)
{
  uint64_t v2 = __dst;
  int v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0x10) != 0)
  {
    unint64_t v5 = *(void *)(a2 + 88);
    unint64_t v6 = *(void *)(a2 + 48);
    if (v5 < v6)
    {
      *(void *)(a2 + 88) = v6;
      unint64_t v5 = v6;
    }
    unint64_t v7 = (const void **)(a2 + 40);
  }
  else
  {
    if ((v3 & 8) == 0)
    {
      size_t v4 = 0;
      *((unsigned char *)__dst + 23) = 0;
      goto LABEL_16;
    }
    unint64_t v7 = (const void **)(a2 + 16);
    unint64_t v5 = *(void *)(a2 + 32);
  }
  uint64_t v8 = *v7;
  size_t v4 = v5 - (void)*v7;
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_1DC3127EC();
  }
  if (v4 >= 0x17)
  {
    uint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v9 = v4 | 7;
    }
    uint64_t v10 = v9 + 1;
    unint64_t v11 = operator new(v9 + 1);
    v2[1] = v4;
    v2[2] = v10 | 0x8000000000000000;
    void *v2 = v11;
    uint64_t v2 = v11;
  }
  else
  {
    *((unsigned char *)__dst + 23) = v4;
    if (!v4) {
      goto LABEL_16;
    }
  }
  std::string __dst = memmove(v2, v8, v4);
LABEL_16:
  *((unsigned char *)v2 + v4) = 0;
  return __dst;
}

uint64_t sub_1DC32B90C(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1E019CE10](a1 + 112);
  return a1;
}

void sub_1DC32BA10(const char *a1)
{
  exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1DC32BA6C(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6C39918, MEMORY[0x1E4FBA1D0]);
}

void sub_1DC32BA58(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1DC32BA6C(std::logic_error *a1, const char *a2)
{
  double result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

uint64_t MRCSegmentationMaskGetTypeID()
{
  if (qword_1EAA94C38 != -1) {
    dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
  }
  return qword_1EAA94C40;
}

void *sub_1DC32BAF0()
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFB498) {
    _os_assumes_log();
  }
  if (qword_1EAA94C40) {
    _os_assumes_log();
  }
  qword_1EBFFB498 = (uint64_t)"MRCSegmentationMask";
  qword_1EAA94C40 = _CFRuntimeRegisterClass();
  v1[3] = 0;
  sub_1DC348EB8(qword_1EAA94C40, v1);
  return sub_1DC30AC9C(v1);
}

void sub_1DC32BB98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC30AC9C((uint64_t *)va);
  _Unwind_Resume(a1);
}

CFStringRef sub_1DC32BBB4(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"<%s %p> {\n", "MRCSegmentationMask", cf);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    data %p\n", cf[2]);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    dataDeallocatorContext %p\n", cf[3]);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    dataDeallocator %p\n", cf[4]);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    dataType %ld\n", cf[5]);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    width %zu\n", cf[6]);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    height %zu\n", cf[7]);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    bytesPerRow %zu\n", cf[8]);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    scalingMode %ld\n", cf[9]);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    symbologies %@\n", atomic_load_explicit(cf + 10, memory_order_acquire));
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"}");
    CFStringRef Copy = CFStringCreateCopy(v3, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    sub_1DC326F90((atomic_ullong *)&Mutable);
    if (Copy) {
      return Copy;
    }
  }
  else
  {
    sub_1DC326F90((atomic_ullong *)&Mutable);
  }
  return CFStringCreateWithFormat(v3, 0, @"<%s %p>", "MRCSegmentationMask", cf);
}

void sub_1DC32BE08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1DC326F90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

unint64_t sub_1DC32BE1C(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  unint64_t v3 = 0x9DDFEA08EB382D69
     * (((((((unint64_t)cf + 16) >> 3) & 0x3FFFFFF) << 6) | 8) ^ (((unint64_t)cf + 16) >> 32));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * ((((unint64_t)cf + 16) >> 32) ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69
                                                                                             * ((((unint64_t)cf
                                                                                                + 16) >> 32) ^ (v3 >> 47) ^ v3)) >> 47));
}

BOOL sub_1DC32BEE0(CFTypeRef cf, CFTypeRef a2)
{
  if (!cf) {
    goto LABEL_5;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (qword_1EAA94C38 != -1) {
    dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
  }
  if (v4 != qword_1EAA94C40)
  {
    _os_assumes_log();
    if (!a2) {
      return cf == a2;
    }
  }
  else
  {
LABEL_5:
    if (!a2) {
      return cf == a2;
    }
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (qword_1EAA94C38 != -1) {
    dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
  }
  if (v5 != qword_1EAA94C40) {
    _os_assumes_log();
  }
  return cf == a2;
}

atomic_ullong *sub_1DC32BFD8(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
    CFTypeID v3 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v3 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  CFTypeID v4 = (void (*)(atomic_ullong, atomic_ullong))cf[4];
  if (v4) {
    v4(cf[2], cf[3]);
  }
  return sub_1DC3065EC(cf + 10);
}

unint64_t MRCSegmentationMaskCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CFTypeRef cf)
{
  if (qword_1EAA94C38 != -1) {
    dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
  }
  Instance = (void *)_CFRuntimeCreateInstance();
  int v18 = Instance;
  if (Instance)
  {
    uint64_t v26 = a8;
    CFTypeID v19 = CFGetTypeID(Instance);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v19 != qword_1EAA94C40) {
      _os_assumes_log();
    }
    v18[2] = a1;
    v18[3] = a2;
    void v18[4] = a3;
    v18[5] = a4;
    v18[6] = a5;
    v18[7] = a6;
    v18[8] = a7;
    v18[9] = v26;
    if (cf)
    {
      CFTypeRef v20 = CFRetain(cf);
    }
    else
    {
      _os_assumes_log();
      CFTypeRef v20 = 0;
    }
    v18[10] = v20;
    if (!v18[2]) {
      _os_assumes_log();
    }
    unint64_t v21 = v18[6];
    if (!v21 || !v18[7])
    {
      _os_assumes_log();
      unint64_t v21 = v18[6];
    }
    if (v18[8] < v21) {
      _os_assumes_log();
    }
    CFTypeID v22 = CFGetTypeID(v18);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v22 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  uint64_t v27 = v18;
  unint64_t v23 = atomic_exchange((atomic_ullong *volatile)&v27, 0);
  uint64_t v24 = (const void *)atomic_exchange((atomic_ullong *volatile)&v27, 0);
  if (v24) {
    CFRelease(v24);
  }
  return v23;
}

void sub_1DC32C2EC(_Unwind_Exception *a1)
{
  sub_1DC3065EC((atomic_ullong *)(v1 + 80));
  _Unwind_Resume(a1);
}

uint64_t MRCSegmentationMaskGetData(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  return *((void *)cf + 2);
}

uint64_t MRCSegmentationMaskGetDataType(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  return *((void *)cf + 5);
}

uint64_t MRCSegmentationMaskGetWidth(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  return *((void *)cf + 6);
}

uint64_t MRCSegmentationMaskGetHeight(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  return *((void *)cf + 7);
}

uint64_t MRCSegmentationMaskGetBytesPerRow(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  return *((void *)cf + 8);
}

uint64_t MRCSegmentationMaskGetScalingMode(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  return *((void *)cf + 9);
}

unint64_t MRCSegmentationMaskGetSymbologies(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  return atomic_load_explicit(cf + 10, memory_order_acquire);
}

void sub_1DC32C6AC(uint64_t *a1)
{
  if (a1[3] == 1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      uint64_t v3 = a1[4];
      if (v3)
      {
        uint64_t v4 = a1[5];
        if (v4)
        {
          unint64_t v5 = 0;
          unint64_t v6 = 0;
          unint64_t v7 = 0;
          unint64_t v8 = v3 - 1;
          unint64_t v9 = v4 - 1;
          do
          {
            for (unint64_t i = 0; i != v3; ++i)
            {
              if (i >= v8) {
                unint64_t v11 = v8;
              }
              else {
                unint64_t v11 = i;
              }
              if (i <= v5) {
                unint64_t v12 = v5;
              }
              else {
                unint64_t v12 = i;
              }
              if (v7 >= v9) {
                unint64_t v13 = v9;
              }
              else {
                unint64_t v13 = v7;
              }
              if (v7 <= v6) {
                unint64_t v14 = v6;
              }
              else {
                unint64_t v14 = v7;
              }
              if (*(float *)(v2 + 4 * i) >= 0.1)
              {
                unint64_t v6 = v14;
                unint64_t v9 = v13;
                unint64_t v5 = v12;
                unint64_t v8 = v11;
              }
            }
            ++v7;
            v2 += a1[6];
          }
          while (v7 != v4);
          if (v8 <= v5 && v9 <= v6)
          {
            CGFloat v15 = (double)(v6 - v9 + 1);
            CGFloat v16 = (double)(v5 - v8 + 1);
            CGFloat v17 = (double)v9;
            CGFloat v18 = (double)v8;
            v21.origin.double x = (double)v8;
            v21.origin.double y = (double)v9;
            v21.size.double width = v16;
            v21.size.double height = v15;
            CGFloat v19 = CGRectGetWidth(v21) * -0.25;
            v22.origin.double x = v18;
            v22.origin.double y = v17;
            v22.size.double width = v16;
            v22.size.double height = v15;
            CGFloat v20 = CGRectGetHeight(v22) * -0.25;
            v23.origin.double x = v18;
            v23.origin.double y = v17;
            v23.size.double width = v16;
            v23.size.double height = v15;
            CGRect v24 = CGRectInset(v23, v19, v20);
            v25.size.double width = (double)(unint64_t)a1[4];
            v25.size.double height = (double)(unint64_t)a1[5];
            v25.origin.double x = 0.0;
            v25.origin.double y = 0.0;
            CGRectIntersection(v24, v25);
          }
        }
      }
    }
  }
}

void sub_1DC32C828(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC32C8AC((atomic_ullong *)a1);
  }
  JUMPOUT(0x1E019CE90);
}

atomic_ullong *sub_1DC32C8AC(atomic_ullong *a1)
{
  if (atomic_load_explicit(a1, memory_order_acquire)) {
    VTPixelTransferSessionInvalidate((VTPixelTransferSessionRef)atomic_load_explicit(a1, memory_order_acquire));
  }
  return sub_1DC32C8F4(a1);
}

atomic_ullong *sub_1DC32C8F4(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

unint64_t sub_1DC32C928(unint64_t *a1, atomic_ullong *a2, uint64_t a3, uint64_t a4)
{
  v55[2] = *MEMORY[0x1E4F143B8];
  if (atomic_load_explicit(a2, memory_order_acquire)) {
    BOOL v6 = *(unsigned char *)(a3 + 16) == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    unint64_t v7 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::__fs::filesystem::path buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v7, OS_LOG_TYPE_ERROR, "Invalid pixel buffer state.", buf, 2u);
    }
    *(void *)std::__fs::filesystem::path buf = -2004;
    *(void *)uint8x8_t v38 = @"Invalid pixel buffer state.";
    unint64_t result = sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)v38);
    goto LABEL_79;
  }
  unint64_t v34 = 0;
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
  if (PixelFormatType != 875704422)
  {
    if (PixelFormatType == 1278226488)
    {
      unint64_t result = atomic_load_explicit(a2, memory_order_acquire);
      if (result) {
        unint64_t result = (unint64_t)CFRetain((CFTypeRef)result);
      }
      *a1 = result;
      return result;
    }
    if (PixelFormatType != 875704438)
    {
      if (qword_1EBFFC380 != -1) {
        dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
      }
      CGFloat v17 = qword_1EBFFC388;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::__fs::filesystem::path buf = 67240960;
        *(_DWORD *)&buf[4] = (int)CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire)) >> 24;
        LOWORD(v40) = 1026;
        *(_DWORD *)((char *)&v40 + 2) = (int)(CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire)) << 8) >> 24;
        HIWORD(v40) = 1026;
        *(_DWORD *)int v41 = (__int16)CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire)) >> 8;
        *(_WORD *)&v41[4] = 1026;
        *(_DWORD *)&v41[6] = (char)CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
        _os_log_error_impl(&dword_1DC2FE000, v17, OS_LOG_TYPE_ERROR, "Unsupported pixel format type: %{public}c%{public}c%{public}c%{public}c", buf, 0x1Au);
      }
      *(void *)std::__fs::filesystem::path buf = -2004;
      *(void *)uint8x8_t v38 = @"Unsupported pixel format type.";
      unint64_t result = sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)v38);
      goto LABEL_79;
    }
  }
  IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
  unint64_t v12 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (IOSurface)
  {
    unint64_t v13 = CVPixelBufferGetIOSurface((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
    if (v13) {
      unint64_t v13 = CFRetain(v13);
    }
    atomic_ullong v33 = (atomic_ullong)v13;
    if (atomic_load_explicit(&v33, memory_order_acquire))
    {
      if (IOSurfaceGetPlaneCount((IOSurfaceRef)atomic_load_explicit(&v33, memory_order_acquire)))
      {
        buf[0] = 0;
        LOBYTE(v40) = 0;
        v41[0] = 0;
        v41[8] = 0;
        LOBYTE(HeightOfPlane) = 0;
        char v44 = 0;
        LOBYTE(BytesPerRowOfPlane) = 0;
        char v46 = 0;
        LOBYTE(v48) = 0;
        BYTE8(v48) = 0;
        LOBYTE(v49) = 0;
        BYTE8(v49) = 0;
        char v50 = 0;
        char v51 = 0;
        __int16 v52 = 0;
        LOBYTE(v53) = 0;
        char v54 = 0;
        v55[0] = 0;
        *(void *)int v41 = IOSurfaceGetWidthOfPlane((IOSurfaceRef)atomic_load_explicit(&v33, memory_order_acquire), 0);
        v41[8] = 1;
        size_t HeightOfPlane = IOSurfaceGetHeightOfPlane((IOSurfaceRef)atomic_load_explicit(&v33, memory_order_acquire), 0);
        char v44 = 1;
        size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane((IOSurfaceRef)atomic_load_explicit(&v33, memory_order_acquire), 0);
        char v46 = 1;
        *(void *)std::__fs::filesystem::path buf = HeightOfPlane * BytesPerRowOfPlane;
        LOBYTE(v40) = 1;
        *(void *)&long long v48 = IOSurfaceGetBytesPerElementOfPlane((IOSurfaceRef)atomic_load_explicit(&v33, memory_order_acquire), 0);
        BYTE8(v48) = 1;
        BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane((IOSurfaceRef)atomic_load_explicit(&v33, memory_order_acquire), 0);
        *(void *)&long long v49 = BaseAddressOfPlane
                        - (unsigned char *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(&v33, memory_order_acquire));
        BYTE8(v49) = 1;
        int v53 = 1278226488;
        char v54 = 1;
        atomic_ullong v35 = 0;
        sub_1DC3703D8(&v36, (uint64_t *)buf, &v35);
        if (atomic_load_explicit(&v33, memory_order_acquire))
        {
          if (atomic_load_explicit((atomic_ullong *volatile)&v36, memory_order_acquire))
          {
            atomic_load_explicit(&v33, memory_order_acquire);
            atomic_load_explicit((atomic_ullong *volatile)&v36, memory_order_acquire);
            uint64_t ChildSurface = IOSurfaceCreateChildSurface();
            if (ChildSurface)
            {
LABEL_57:
              atomic_ullong v32 = ChildSurface;
              sub_1DC31EBFC((atomic_ullong *)&v36);
              sub_1DC31EBFC(&v35);
              sub_1DC31FA90(v55);
              goto LABEL_58;
            }
            if (qword_1EAA94CA0 != -1) {
              dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
            }
            CGFloat v16 = qword_1EAA94C98;
            if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint8x8_t v38 = 0;
              _os_log_error_impl(&dword_1DC2FE000, v16, OS_LOG_TYPE_ERROR, "IOSurfaceCreateChildSurface failed", v38, 2u);
            }
            unint64_t v37 = @"IOSurfaceCreateChildSurface failed.";
            *(void *)uint8x8_t v38 = -2003;
            sub_1DC306334((atomic_ullong *)a4, (uint64_t *)v38, (CFTypeRef *)&v37);
          }
          else
          {
            if (qword_1EAA94CA0 != -1) {
              dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
            }
            CGRect v21 = qword_1EAA94C98;
            if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint8x8_t v38 = 0;
              _os_log_error_impl(&dword_1DC2FE000, v21, OS_LOG_TYPE_ERROR, "Invalid surface properties", v38, 2u);
            }
            unint64_t v37 = @"Invalid surface properties.";
            *(void *)uint8x8_t v38 = -2006;
            sub_1DC306334((atomic_ullong *)a4, (uint64_t *)v38, (CFTypeRef *)&v37);
          }
        }
        else
        {
          if (qword_1EAA94CA0 != -1) {
            dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
          }
          CGFloat v20 = qword_1EAA94C98;
          if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint8x8_t v38 = 0;
            _os_log_error_impl(&dword_1DC2FE000, v20, OS_LOG_TYPE_ERROR, "Invalid parent surface", v38, 2u);
          }
          unint64_t v37 = @"Invalid parent surface.";
          *(void *)uint8x8_t v38 = -2006;
          sub_1DC306334((atomic_ullong *)a4, (uint64_t *)v38, (CFTypeRef *)&v37);
        }
        uint64_t ChildSurface = 0;
        goto LABEL_57;
      }
      if (qword_1EAA94CA0 != -1) {
        dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
      }
      CGFloat v19 = qword_1EAA94C98;
      if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::__fs::filesystem::path buf = 0;
        _os_log_error_impl(&dword_1DC2FE000, v19, OS_LOG_TYPE_ERROR, "Invalid non-planar parent surface", buf, 2u);
      }
      *(void *)std::__fs::filesystem::path buf = -2006;
      *(void *)uint8x8_t v38 = @"Invalid non-planar parent surface.";
      sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)v38);
    }
    else
    {
      if (qword_1EAA94CA0 != -1) {
        dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
      }
      CGFloat v18 = qword_1EAA94C98;
      if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::__fs::filesystem::path buf = 0;
        _os_log_error_impl(&dword_1DC2FE000, v18, OS_LOG_TYPE_ERROR, "Invalid parent surface", buf, 2u);
      }
      *(void *)std::__fs::filesystem::path buf = -2006;
      *(void *)uint8x8_t v38 = @"Invalid parent surface.";
      sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)v38);
    }
    atomic_ullong v32 = 0;
LABEL_58:
    if (atomic_load_explicit(&v32, memory_order_acquire))
    {
      *(void *)std::__fs::filesystem::path buf = 0;
      CVReturn v22 = CVPixelBufferCreateWithIOSurface(*v12, (IOSurfaceRef)atomic_load_explicit(&v32, memory_order_acquire), 0, (CVPixelBufferRef *)buf);
      if (!v22)
      {
        *a1 = *(void *)buf;
        sub_1DC315BA8(&v32);
        return (unint64_t)sub_1DC315BA8(&v33);
      }
      if (qword_1EBFFC380 != -1) {
        dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
      }
      CGRect v23 = qword_1EBFFC388;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint8x8_t v38 = 67240192;
        *(_DWORD *)&v38[4] = v22;
        _os_log_error_impl(&dword_1DC2FE000, v23, OS_LOG_TYPE_ERROR, "CVPixelBufferCreateWithIOSurface failed when creating child Yp8: %{public}d", v38, 8u);
      }
    }
    else
    {
      *(void *)std::__fs::filesystem::path buf = -1;
      uint64_t v40 = 0;
      v41[0] = 0;
      v41[4] = 0;
      v41[8] = 0;
      char v42 = 0;
      LOBYTE(HeightOfPlane) = 0;
      char v44 = 0;
      LOBYTE(BytesPerRowOfPlane) = 0;
      BYTE4(BytesPerRowOfPlane) = 0;
      char v46 = 0;
      char v47 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      if (*(unsigned char *)(a4 + 96))
      {
        sub_1DC390B00((atomic_ullong *)buf);
        sub_1DC390CA0(buf, (uint64_t *)a4);
        if (*(unsigned char *)(a4 + 96))
        {
          sub_1DC390B00((atomic_ullong *)a4);
          *(unsigned char *)(a4 + 96) = 0;
        }
      }
      if (qword_1EBFFC380 != -1) {
        dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
      }
      CGRect v24 = qword_1EBFFC388;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
      {
        sub_1DC390F7C((CFErrorRef *)&v37, (uint64_t)buf);
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v37, memory_order_acquire);
        *(_DWORD *)uint8x8_t v38 = 138543362;
        *(void *)&v38[4] = explicit;
        _os_log_error_impl(&dword_1DC2FE000, v24, OS_LOG_TYPE_ERROR, "Failed to create child Yp8 surface: %{public}@", v38, 0xCu);
        sub_1DC306854((atomic_ullong *)&v37);
      }
      sub_1DC390B00((atomic_ullong *)buf);
    }
    sub_1DC315BA8(&v32);
    sub_1DC315BA8(&v33);
  }
  size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
  size_t v26 = CVPixelBufferGetHeightOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
  uint64_t v27 = CVPixelBufferGetBaseAddressOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
  size_t v28 = CVPixelBufferGetBytesPerRowOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
  unint64_t result = CVPixelBufferCreateWithBytes(*v12, WidthOfPlane, v26, 0x4C303038u, v27, v28, 0, 0, 0, (CVPixelBufferRef *)&v34);
  int v29 = result;
  if (result)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    unint64_t v30 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 67240192;
      *(_DWORD *)&buf[4] = v29;
      _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "CVPixelBufferCreate failed when creating shallow Yp8: %{public}d", buf, 8u);
    }
    *(void *)std::__fs::filesystem::path buf = -2003;
    *(void *)uint8x8_t v38 = @"CVPixelBufferCreate failed when creating shallow Yp8.";
    unint64_t result = sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)v38);
    *(_DWORD *)(a4 + 24) = v29;
    *(unsigned char *)(a4 + 28) = 1;
LABEL_79:
    *a1 = 0;
    return result;
  }
  *a1 = v34;
  return result;
}

void sub_1DC32D2F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  atomic_ullong v4 = va_arg(va1, void);
  va_copy(va2, va1);
  atomic_ullong v6 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  sub_1DC390B00((atomic_ullong *)va2);
  sub_1DC315BA8((atomic_ullong *)va);
  sub_1DC315BA8((atomic_ullong *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC32D374(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    *(unsigned char *)(a1 + 16) = sub_1DC3836F8(*(atomic_ullong **)a1, *(void *)(a1 + 8)) ^ 1;
  }
  return a1;
}

size_t sub_1DC32D3B4(atomic_ullong *a1)
{
  if (!atomic_load_explicit(a1, memory_order_acquire)) {
    return -1;
  }
  int IsPlanar = CVPixelBufferIsPlanar((CVPixelBufferRef)atomic_load_explicit(a1, memory_order_acquire));
  unint64_t explicit = (__CVBuffer *)atomic_load_explicit(a1, memory_order_acquire);
  if (IsPlanar)
  {
    PlaneCFIndex Count = CVPixelBufferGetPlaneCount(explicit);
    if (PlaneCount)
    {
      size_t v5 = PlaneCount;
      size_t result = CVPixelBufferGetBytesPerRowOfPlane((CVPixelBufferRef)atomic_load_explicit(a1, memory_order_acquire), 0);
      size_t v7 = result;
      if (v5 != 1)
      {
        for (size_t i = 1; i != v5; ++i)
        {
          size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane((CVPixelBufferRef)atomic_load_explicit(a1, memory_order_acquire), i);
          if (BytesPerRowOfPlane)
          {
            size_t v10 = BytesPerRowOfPlane;
            do
            {
              size_t result = v10;
              size_t v10 = v7 % v10;
              size_t v7 = result;
            }
            while (v10);
          }
          else
          {
            size_t result = v7;
          }
          size_t v7 = result;
        }
      }
      return result;
    }
    return -1;
  }
  return CVPixelBufferGetBytesPerRow(explicit);
}

double sub_1DC32D490(CGRect *a1, unint64_t a2, char a3, OSType a4)
{
  double v8 = floor(CGRectGetMinX(*a1) * 0.5);
  double v9 = floor(CGRectGetMinY(*a1) * 0.5);
  double v10 = ceil(CGRectGetMaxX(*a1) * 0.5) - v8;
  double v11 = ceil(CGRectGetMaxY(*a1) * 0.5) - v9;
  if ((a3 & 0xF) != 0) {
    return v8;
  }
  CFDictionaryRef v59 = CVPixelFormatDescriptionCreateWithPixelFormatType((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a4);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire)) {
    goto LABEL_50;
  }
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire);
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(explicit, (const void *)*MEMORY[0x1E4F24EE0]);
  CFArrayRef v14 = Value;
  if (Value)
  {
    unint64_t Count = CFArrayGetCount(Value);
    unint64_t v16 = Count;
    if (Count)
    {
      if (Count >> 61) {
        sub_1DC2FF97C();
      }
      CGFloat v17 = (char *)sub_1DC2FFD7C(Count);
      CFIndex v18 = 0;
      CGFloat v20 = &v17[8 * v19];
      CGRect v21 = (const void *)*MEMORY[0x1E4F24E18];
      CVReturn v22 = v17;
      unint64_t v57 = a2;
      do
      {
        ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(v14, v18);
        CFDictionaryRef v24 = ValueAtIndex;
        if (!ValueAtIndex) {
          goto LABEL_51;
        }
        CFTypeID v25 = CFGetTypeID(ValueAtIndex);
        if (v25 != CFDictionaryGetTypeID()) {
          goto LABEL_51;
        }
        CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(v24, v21);
        CFNumberRef v27 = v26;
        if (!v26) {
          goto LABEL_51;
        }
        CFTypeID v28 = CFGetTypeID(v26);
        if (v28 != CFNumberGetTypeID()) {
          goto LABEL_51;
        }
        int valuePtr = 0;
        if (!CFNumberGetValue(v27, kCFNumberIntType, &valuePtr)) {
          goto LABEL_51;
        }
        uint64_t v29 = valuePtr;
        if (v22 >= v20)
        {
          uint64_t v30 = (v22 - v17) >> 3;
          unint64_t v31 = v30 + 1;
          if ((unint64_t)(v30 + 1) >> 61) {
            sub_1DC2FF97C();
          }
          if ((v20 - v17) >> 2 > v31) {
            unint64_t v31 = (v20 - v17) >> 2;
          }
          if ((unint64_t)(v20 - v17) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v32 = v31;
          }
          if (v32) {
            unint64_t v32 = (unint64_t)sub_1DC2FFD7C(v32);
          }
          else {
            uint64_t v33 = 0;
          }
          unint64_t v34 = (char *)(v32 + 8 * v30);
          *(void *)unint64_t v34 = v29;
          atomic_ullong v35 = v34 + 8;
          while (v22 != v17)
          {
            uint64_t v36 = *((void *)v22 - 1);
            v22 -= 8;
            *((void *)v34 - 1) = v36;
            v34 -= 8;
          }
          CGFloat v20 = (char *)(v32 + 8 * v33);
          if (v17) {
            operator delete(v17);
          }
          CGFloat v17 = v34;
          CVReturn v22 = v35;
          a2 = v57;
        }
        else
        {
          *(void *)CVReturn v22 = valuePtr;
          v22 += 8;
        }
        ++v18;
      }
      while (v18 != v16);
      if (v17 == v22)
      {
LABEL_51:
        LOBYTE(v40) = 0;
        BOOL v50 = 0;
        unint64_t v51 = 0;
        if (!v17) {
          goto LABEL_53;
        }
      }
      else
      {
        unint64_t v37 = *(void *)v17;
        if ((unint64_t)(v22 - v17) < 9)
        {
          unint64_t v40 = *(void *)v17;
        }
        else
        {
          unint64_t v38 = (v22 - v17) >> 3;
          if (v38 <= 2) {
            unint64_t v38 = 2;
          }
          for (uint64_t i = 1; i != v38; ++i)
          {
            unint64_t v40 = 0;
            if (v37)
            {
              uint64_t v41 = *(void *)&v17[8 * i];
              if (v41)
              {
                unint64_t v42 = *(void *)&v17[8 * i];
                unint64_t v43 = v37;
                do
                {
                  unint64_t v44 = v43;
                  unint64_t v43 = v42;
                  unint64_t v42 = v44 % v42;
                }
                while (v42);
                unint64_t v40 = v37 / v43 * v41;
              }
            }
            unint64_t v37 = v40;
          }
        }
        unint64_t v51 = v40 & 0xFFFFFFFFFFFFFF00;
        BOOL v50 = 1;
        if (!v17) {
          goto LABEL_53;
        }
      }
      operator delete(v17);
      goto LABEL_53;
    }
LABEL_50:
    sub_1DC31EBFC((atomic_ullong *)&v59);
    return v8;
  }
  CFDictionaryRef v45 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire);
  CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(v45, (const void *)*MEMORY[0x1E4F24E18]);
  CFNumberRef v47 = v46;
  if (!v46) {
    goto LABEL_50;
  }
  CFTypeID v48 = CFGetTypeID(v46);
  if (v48 != CFNumberGetTypeID()) {
    goto LABEL_50;
  }
  int valuePtr = 0;
  int v49 = CFNumberGetValue(v47, kCFNumberIntType, &valuePtr);
  BOOL v50 = v49 != 0;
  if (v49) {
    LOBYTE(v40) = valuePtr;
  }
  else {
    LOBYTE(v40) = 0;
  }
  if (v49) {
    unint64_t v51 = valuePtr & 0xFFFFFFFFFFFFFF00;
  }
  else {
    unint64_t v51 = 0;
  }
LABEL_53:
  sub_1DC31EBFC((atomic_ullong *)&v59);
  if (v50)
  {
    unint64_t v52 = a2;
    unint64_t v53 = ((v51 & 0xFFFFFFFFFFFFFF00 | v40) + 7) >> 3;
    v60.origin.double x = v8;
    v60.origin.double y = v9;
    v60.size.double width = v10;
    v60.size.double height = v11;
    unint64_t MinX = (unint64_t)CGRectGetMinX(v60);
    v61.origin.double x = v8;
    v61.origin.double y = v9;
    v61.size.double width = v10;
    v61.size.double height = v11;
    CGRectGetMaxX(v61);
    unint64_t v55 = ((v53 * MinX) & 0xFFFFFFFFFFFFFFF0) / v53;
    if (v55 >= v52) {
      return (double)v52;
    }
    return (double)v55;
  }
  return v8;
}

void sub_1DC32D8A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1DC31EBFC((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void sub_1DC32D8E8(atomic_ullong *a1, CFTypeRef cf)
{
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  atomic_ullong v4 = (const void *)atomic_exchange(a1, (unint64_t)v3);
  if (v4)
  {
    CFRelease(v4);
  }
}

void *sub_1DC32D940()
{
  return &unk_1F36626F0;
}

uint64_t sub_1DC32D94C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE0EE13transferImageERKNS_5CFRefIP10__CVBufferEES9_RKNSt3__18optionalI6CGRectEESF_RNSB_INS_5ErrorEEERKNSB_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC32D988(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    CFTypeRef v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)atomic_ullong v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::transferImage", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC32DA34(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3662690;
}

void *sub_1DC32DA54()
{
  size_t result = operator new(0x10uLL);
  *size_t result = &unk_1F3662690;
  return result;
}

void sub_1DC32DA8C()
{
}

void *sub_1DC32DAA4()
{
  return &unk_1F3662670;
}

uint64_t sub_1DC32DAB0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE0EE13transferImageERKNS_5CFRefIP10__CVBufferEES9_RKNSt3__18optionalI6CGRectEESF_RNSB_INS_5ErrorEEERKNSB_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC32DAEC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    CFTypeRef v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)atomic_ullong v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::transferImage", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC32DB98(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3662610;
}

void *sub_1DC32DBB8()
{
  size_t result = operator new(0x10uLL);
  *size_t result = &unk_1F3662610;
  return result;
}

void sub_1DC32DBF0()
{
}

void *sub_1DC32DC08()
{
  return &unk_1F36628F0;
}

uint64_t sub_1DC32DC14(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE15generatePyramidERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS7_INS_5ErrorEEERKNS7_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC32DC50(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v4 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      unint64_t v5 = vcvtpd_u64_f64(CGRectGetWidth(*(CGRect *)(**(void **)(a1 + 8) + 8)));
      CGRect v11 = *(CGRect *)(**(void **)(a1 + 8) + 8);
      int v6 = 134349312;
      unint64_t v7 = v5;
      __int16 v8 = 2050;
      unint64_t v9 = vcvtpd_u64_f64(CGRectGetHeight(v11));
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_END, v3, "PyramidGenerationSession::generatePyramid", "masterPixelBufferWidth=%{public, signpost.description:attribute}zu, masterPixelBufferHeight=%{public, signpost.description:attribute}zu", (uint8_t *)&v6, 0x16u);
    }
  }
}

uint64_t sub_1DC32DD7C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3662890;
  a2[1] = v2;
  return result;
}

void *sub_1DC32DDA0(uint64_t a1)
{
  size_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *size_t result = &unk_1F3662890;
  result[1] = v3;
  return result;
}

void sub_1DC32DDE8()
{
}

void *sub_1DC32DE00()
{
  return &unk_1F3662870;
}

uint64_t sub_1DC32DE0C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE15generatePyramidERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS7_INS_5ErrorEEERKNS7_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC32DE48(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v4 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      unint64_t v5 = vcvtpd_u64_f64(CGRectGetWidth(*(CGRect *)(**(void **)(a1 + 8) + 8)));
      CGRect v11 = *(CGRect *)(**(void **)(a1 + 8) + 8);
      int v6 = 134349312;
      unint64_t v7 = v5;
      __int16 v8 = 2050;
      unint64_t v9 = vcvtpd_u64_f64(CGRectGetHeight(v11));
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "PyramidGenerationSession::generatePyramid", "masterPixelBufferWidth=%{public, signpost.description:attribute}zu, masterPixelBufferHeight=%{public, signpost.description:attribute}zu", (uint8_t *)&v6, 0x16u);
    }
  }
}

uint64_t sub_1DC32DF74(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3662810;
  a2[1] = v2;
  return result;
}

void *sub_1DC32DF98(uint64_t a1)
{
  size_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *size_t result = &unk_1F3662810;
  result[1] = v3;
  return result;
}

void sub_1DC32DFE0()
{
}

void *sub_1DC32DFF8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void v14[4] = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  uint64_t v12 = operator new(0x30uLL);
  *uint64_t v12 = &unk_1F3662910;
  v12[1] = a5;
  _DWORD v12[2] = a1;
  v12[3] = a3;
  v12[4] = a4;
  v12[5] = a6;
  v14[3] = v12;
  sub_1DC32E0E0(a2, v14);
  return sub_1DC32E6A4(v14);
}

void sub_1DC32E0BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC32E6A4((uint64_t *)va);
  sub_1DC3065EC(v2);
  _Unwind_Resume(a1);
}

void sub_1DC32E0E0(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2 + 3;
  if (!a2[3]) {
    return;
  }
  atomic_ullong v4 = (std::__shared_weak_count *)a1;
  unint64_t v5 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock_with_options();
  int v6 = sub_1DC32E728(&v4[1].__vftable, (unint64_t)&unk_1DC404F38);
  if (!v6) {
    operator new();
  }
  if ((_UNKNOWN *)v6[3] != &unk_1DC404F38)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_29;
  }
  unint64_t v7 = (atomic_ullong *)v6[6];
  if (!v7)
  {
LABEL_29:
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_30:
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
LABEL_13:
    unint64_t v9 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      LOWORD(context[0]) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "Unable to retrieve or instantiate concrete PyramidGenerationSession context.", (uint8_t *)context, 2u);
    }
    LOBYTE(v15) = 0;
    char v16 = 0;
    sub_1DC390A40((uint64_t)v12, -1, 0);
    sub_1DC390CA0(context, v12);
    char v14 = 1;
    if (!*v2) {
      sub_1DC307C38();
    }
    (*(void (**)(void, uint64_t *, atomic_ullong *))(*(void *)*v2 + 48))(*v2, &v15, context);
    if (v14) {
      sub_1DC390B00(context);
    }
    sub_1DC390B00(v12);
    if (v4) {
      goto LABEL_26;
    }
    return;
  }
  atomic_ullong v8 = *v7;
  atomic_ullong v4 = (std::__shared_weak_count *)v7[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  if (!v8)
  {
    if (qword_1EBFFC380 == -1) {
      goto LABEL_13;
    }
    goto LABEL_30;
  }
  if (!*v2)
  {
    uint64_t v2 = &v11;
    goto LABEL_21;
  }
  if ((void *)*v2 != a2)
  {
    CGRect v11 = (void *)*v2;
LABEL_21:
    void *v2 = 0;
    goto LABEL_23;
  }
  CGRect v11 = v10;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v10);
LABEL_23:
  if (v11)
  {
    context[0] = (atomic_ullong)&unk_1F3663230;
    context[1] = v8;
    context[2] = (atomic_ullong)v10;
    context[3] = (atomic_ullong)context;
    dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v8 + 8), context, (dispatch_function_t)sub_1DC32EF68);
    sub_1DC307968(context);
  }
  sub_1DC32E6A4(v10);
  if (v4) {
LABEL_26:
  }
    sub_1DC32EEF4(v4);
}

void sub_1DC32E5A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC32E6A4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1DC32E728(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  atomic_ullong v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  size_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      size_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t sub_1DC32E810(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 200)) {
      sub_1DC390B00((atomic_ullong *)(result + 104));
    }
    if (*(unsigned char *)(v1 + 96))
    {
      uint64_t v2 = *(void *)(v1 + 88);
      *(void *)(v1 + 88) = 0;
      if (v2) {
        sub_1DC32C828(v2);
      }
    }
    sub_1DC31EB58((atomic_ullong *)(v1 + 40));
    sub_1DC31EB58((atomic_ullong *)(v1 + 32));
    uint64_t v3 = *(void *)(v1 + 8);
    *(void *)uint64_t v1 = &unk_1F3663140;
    *(void *)(v1 + 8) = 0;
    if (v3) {
      (*(void (**)(void))(v1 + 16))();
    }
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

uint64_t sub_1DC32E8C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_1DC32E940(uint64_t *result)
{
  uint64_t v1 = *result;
  *size_t result = 0;
  if (v1)
  {
    uint64_t v3 = v1;
    uint64_t v2 = result[4];
    if (!v2) {
      sub_1DC307C38();
    }
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v3);
  }
  return result;
}

void *sub_1DC32E9A8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1DC32EA2C(uint64_t *a1, void *a2, uint64_t *a3)
{
  uint8x8_t v6 = a1 + 2;
  unint64_t v7 = operator new(0x58uLL);
  v44[0] = v7;
  v44[1] = v6;
  char v45 = 0;
  void *v7 = 0;
  v7[1] = 0;
  uint64_t v8 = *a3;
  v7[2] = *a2;
  v7[3] = v8;
  long long v9 = *(_OWORD *)(a3 + 1);
  v7[6] = a3[3];
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  *((_OWORD *)v7 + 2) = v9;
  sub_1DC32E8C0((uint64_t)(v7 + 7), (uint64_t)(a3 + 4));
  if (!v7[3]) {
    _os_assumes_log();
  }
  if (!v7[6]) {
    _os_assumes_log();
  }
  char v45 = 1;
  unint64_t v10 = v7[2];
  unint64_t v11 = 0x9DDFEA08EB382D69 * (((8 * v10) + 8) ^ HIDWORD(v10));
  unint64_t v12 = 0x9DDFEA08EB382D69 * (HIDWORD(v10) ^ (v11 >> 47) ^ v11);
  unint64_t v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
  v7[1] = v13;
  unint64_t v14 = a1[1];
  if (!v14) {
    goto LABEL_21;
  }
  uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
  v15.i16[0] = vaddlv_u8(v15);
  if (v15.u32[0] > 1uLL)
  {
    unint64_t v16 = v13;
    if (v14 <= v13) {
      unint64_t v16 = v13 % v14;
    }
  }
  else
  {
    unint64_t v16 = (v14 - 1) & v13;
  }
  uint64_t v17 = *(void **)(*a1 + 8 * v16);
  if (!v17 || (CFIndex v18 = (void *)*v17) == 0)
  {
LABEL_21:
    float v20 = (float)(unint64_t)(a1[3] + 1);
    float v21 = *((float *)a1 + 8);
    if (!v14 || (float)(v21 * (float)v14) < v20)
    {
      BOOL v22 = 1;
      if (v14 >= 3) {
        BOOL v22 = (v14 & (v14 - 1)) != 0;
      }
      unint64_t v23 = v22 | (2 * v14);
      unint64_t v24 = vcvtps_u32_f32(v20 / v21);
      if (v23 <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      else {
        int8x8_t prime = (int8x8_t)v23;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v14 = a1[1];
      }
      if (*(void *)&prime > v14) {
        goto LABEL_89;
      }
      if (*(void *)&prime >= v14) {
        goto LABEL_62;
      }
      unint64_t v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v14 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (*(void *)&prime <= v32) {
        int8x8_t prime = (int8x8_t)v32;
      }
      if (*(void *)&prime >= v14)
      {
        unint64_t v14 = a1[1];
        goto LABEL_62;
      }
      if (prime)
      {
LABEL_89:
        if (*(void *)&prime >> 61) {
          sub_1DC2FF994();
        }
        CFNumberRef v26 = operator new(8 * *(void *)&prime);
        CFNumberRef v27 = (void *)*a1;
        *a1 = (uint64_t)v26;
        if (v27) {
          operator delete(v27);
        }
        uint64_t v28 = 0;
        a1[1] = (uint64_t)prime;
        do
          *(void *)(*a1 + 8 * v28++) = 0;
        while (*(void *)&prime != v28);
        uint64_t v29 = (void *)*v6;
        if (*v6)
        {
          unint64_t v30 = v29[1];
          uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
          v31.i16[0] = vaddlv_u8(v31);
          if (v31.u32[0] > 1uLL)
          {
            if (v30 >= *(void *)&prime) {
              v30 %= *(void *)&prime;
            }
          }
          else
          {
            v30 &= *(void *)&prime - 1;
          }
          *(void *)(*a1 + 8 * v30) = v6;
          atomic_ullong v35 = (void *)*v29;
          if (*v29)
          {
            do
            {
              unint64_t v36 = v35[1];
              if (v31.u32[0] > 1uLL)
              {
                if (v36 >= *(void *)&prime) {
                  v36 %= *(void *)&prime;
                }
              }
              else
              {
                v36 &= *(void *)&prime - 1;
              }
              if (v36 != v30)
              {
                if (!*(void *)(*a1 + 8 * v36))
                {
                  *(void *)(*a1 + 8 * v36) = v29;
                  goto LABEL_58;
                }
                *uint64_t v29 = *v35;
                void *v35 = **(void **)(*a1 + 8 * v36);
                **(void **)(*a1 + 8 * v36) = v35;
                atomic_ullong v35 = v29;
              }
              unint64_t v36 = v30;
LABEL_58:
              uint64_t v29 = v35;
              atomic_ullong v35 = (void *)*v35;
              unint64_t v30 = v36;
            }
            while (v35);
          }
        }
        unint64_t v14 = (unint64_t)prime;
      }
      else
      {
        unint64_t v43 = (void *)*a1;
        *a1 = 0;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v14 = 0;
        a1[1] = 0;
      }
    }
LABEL_62:
    unint64_t v37 = v7[1];
    uint8x8_t v38 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v38.i16[0] = vaddlv_u8(v38);
    if (v38.u32[0] > 1uLL)
    {
      if (v37 >= v14) {
        v37 %= v14;
      }
    }
    else
    {
      v37 &= v14 - 1;
    }
    uint64_t v39 = *a1;
    unint64_t v40 = *(void **)(*a1 + 8 * v37);
    if (v40)
    {
      void *v7 = *v40;
    }
    else
    {
      void *v7 = *v6;
      void *v6 = v7;
      *(void *)(v39 + 8 * v37) = v6;
      if (!*v7)
      {
LABEL_75:
        ++a1[3];
        v44[0] = 0;
        goto LABEL_76;
      }
      unint64_t v41 = *(void *)(*v7 + 8);
      if (v38.u32[0] > 1uLL)
      {
        if (v41 >= v14) {
          v41 %= v14;
        }
      }
      else
      {
        v41 &= v14 - 1;
      }
      unint64_t v40 = (void *)(*a1 + 8 * v41);
    }
    *unint64_t v40 = v7;
    goto LABEL_75;
  }
  while (1)
  {
    unint64_t v19 = v18[1];
    if (v19 == v13) {
      break;
    }
    if (v15.u32[0] > 1uLL)
    {
      if (v19 >= v14) {
        v19 %= v14;
      }
    }
    else
    {
      v19 &= v14 - 1;
    }
    if (v19 != v16) {
      goto LABEL_21;
    }
LABEL_20:
    CFIndex v18 = (void *)*v18;
    if (!v18) {
      goto LABEL_21;
    }
  }
  if (v18[2] != v10) {
    goto LABEL_20;
  }
  unint64_t v7 = v18;
LABEL_76:
  sub_1DC333814((uint64_t)v44);
  return v7;
}

void sub_1DC32EEC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC32E940(v2);
  sub_1DC32E9A8(v3);
  sub_1DC333814((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DC32EEF4(std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t sub_1DC32EF68(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    sub_1DC307C38();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

void *sub_1DC32EFB8()
{
  return &unk_1F3663290;
}

uint64_t sub_1DC32EFC4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_131PyramidGenerationSessionContextILNS_25PyramidGenerationBehaviorE0EE7performENSt3__18functionIFvONS4_8optionalINS4_17reference_wrapperINS_24PyramidGenerationSessionILS2_0EEEEEEEONS6_INS_5ErrorEEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC32F000(uint64_t a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v2 + 200))
  {
    uint64_t v3 = *(void *)(a1 + 16);
    LOBYTE(v38) = 0;
    LOBYTE(v39[0]) = 0;
    sub_1DC390B4C((uint64_t)v41, v2 + 104);
    char v44 = 1;
    uint64_t v4 = *(void *)(v3 + 24);
    if (!v4) {
      sub_1DC307C38();
    }
    size_t result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, os_signpost_id_t **, uint8_t *))(*(void *)v4 + 48))(v4, &v38, v41);
LABEL_50:
    if (!v44) {
      return result;
    }
    unint64_t v30 = (atomic_ullong *)v41;
    return sub_1DC390B00(v30);
  }
  uint8x8_t v6 = (uint64_t *)(v2 + 88);
  if (*(unsigned char *)(v2 + 96)) {
    goto LABEL_48;
  }
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  os_signpost_id_t v32 = os_signpost_id_make_with_pointer((os_log_t)qword_1EBFFC388, (const void *)v2);
  char v33 = 1;
  v46[0] = &unk_1F36629A0;
  CFNumberRef v47 = v46;
  v45[0] = &unk_1F3662A20;
  v45[3] = v45;
  uint8x8_t v38 = &v32;
  sub_1DC31AD78((uint64_t)v39, (uint64_t)v45);
  if (*((unsigned char *)v38 + 8) && v47) {
    sub_1DC31AE10((uint64_t)v47, *v38);
  }
  sub_1DC31AE60(v45);
  sub_1DC31AE60(v46);
  BOOL v50 = &unk_1F3662AA0;
  unint64_t v52 = &v50;
  v49[0] = &unk_1F3662B20;
  v49[3] = v49;
  *(void *)unint64_t v41 = &v32;
  sub_1DC31AD78((uint64_t)v42, (uint64_t)v49);
  if (*(unsigned char *)(*(void *)v41 + 8) && v52) {
    sub_1DC31AE10((uint64_t)v52, **(void **)v41);
  }
  sub_1DC31AE60(v49);
  sub_1DC31AE60(&v50);
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  OSStatus v8 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
  if (v8)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    long long v9 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 67240192;
      *(_DWORD *)&buf[4] = v8;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate failed: %{public}d", buf, 8u);
    }
    *(void *)std::__fs::filesystem::path buf = -2003;
    VTPixelTransferSessionRef v36 = (VTPixelTransferSessionRef)@"VTPixelTransferSessionCreate failed.";
    sub_1DC306334((atomic_ullong *)(v2 + 104), (uint64_t *)buf, (CFTypeRef *)&v36);
    *(void *)std::__fs::filesystem::path buf = CFErrorCreate(v7, (CFErrorDomain)*MEMORY[0x1E4F1D158], v8, 0);
    unint64_t v10 = (const void *)atomic_exchange((atomic_ullong *volatile)(v2 + 168), atomic_exchange((atomic_ullong *volatile)buf, 0));
    if (v10) {
      CFRelease(v10);
    }
    sub_1DC306854((atomic_ullong *)buf);
    LOBYTE(v34) = 0;
    char v35 = 0;
  }
  else
  {
    VTPixelTransferSessionRef v36 = pixelTransferSessionOut;
    *(void *)std::__fs::filesystem::path buf = atomic_exchange((atomic_ullong *volatile)&v36, 0);
    if (atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire))
    {
      CFDictionaryRef explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      VTSessionSetProperty(explicit, (CFStringRef)*MEMORY[0x1E4F45168], (CFTypeRef)*MEMORY[0x1E4F45460]);
      unint64_t v12 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      VTSessionSetProperty(v12, (CFStringRef)*MEMORY[0x1E4F45110], (CFTypeRef)*MEMORY[0x1E4F44DB0]);
      qos_class_t v13 = *(_DWORD *)(v2 + 48);
      HIDWORD(v15) = v13 - 9;
      LODWORD(v15) = v13 - 9;
      unsigned int v14 = v15 >> 2;
      unint64_t v16 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      if (v14 <= 6 && ((0x22u >> v14) & 1) == 0)
      {
        if (((1 << v14) & 0x5D) == 0) {
          qos_class_t v13 = qos_class_self();
        }
        if (v13 == QOS_CLASS_USER_INTERACTIVE)
        {
          uint64_t v17 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
          VTSessionSetProperty(v17, (CFStringRef)*MEMORY[0x1E4F45158], *v16);
        }
      }
      CFIndex v18 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      CFTypeRef v19 = *v16;
      VTSessionSetProperty(v18, (CFStringRef)*MEMORY[0x1E4F45128], v19);
      float v20 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      float v21 = (const void *)*MEMORY[0x1E4F1CFC8];
      VTSessionSetProperty(v20, (CFStringRef)*MEMORY[0x1E4F45188], (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
      int v22 = _os_feature_enabled_impl();
      unint64_t v23 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      CFStringRef v24 = (const __CFString *)*MEMORY[0x1E4F45120];
      if (v22)
      {
        VTSessionSetProperty(v23, v24, v19);
        unint64_t v23 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
        CFStringRef v24 = (const __CFString *)*MEMORY[0x1E4F45178];
      }
      else
      {
        CFTypeRef v19 = v21;
      }
      VTSessionSetProperty(v23, v24, v19);
    }
    unint64_t v34 = atomic_exchange((atomic_ullong *volatile)buf, 0);
    char v35 = 1;
    sub_1DC32C8AC((atomic_ullong *)buf);
    sub_1DC32C8F4((atomic_ullong *)&v36);
  }
  if (*(unsigned char *)(*(void *)v41 + 8) && v43) {
    sub_1DC31AE10(v43, **(void **)v41);
  }
  sub_1DC31AE60(v42);
  if (!v8) {
    operator new();
  }
  if (*((unsigned char *)v38 + 8) && v40) {
    sub_1DC31AE10(v40, *v38);
  }
  sub_1DC31AE60(v39);
  if (*(unsigned char *)(v2 + 96))
  {
    uint64_t v25 = *v6;
    uint64_t *v6 = 0;
    if (v25) {
      sub_1DC32C828(v25);
    }
    *(unsigned char *)(v2 + 96) = 0;
  }
  if (*(unsigned char *)(v2 + 96))
  {
LABEL_48:
    uint64_t v28 = *(void *)(a1 + 16);
    uint8x8_t v38 = (os_signpost_id_t *)(v2 + 88);
    LOBYTE(v39[0]) = 1;
    v41[0] = 0;
    char v44 = 0;
    uint64_t v29 = *(void *)(v28 + 24);
    if (!v29) {
      sub_1DC307C38();
    }
    size_t result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, os_signpost_id_t **, uint8_t *))(*(void *)v29 + 48))(v29, &v38, v41);
    goto LABEL_50;
  }
  uint64_t v26 = *(void *)(a1 + 16);
  LOBYTE(v50) = 0;
  char v51 = 0;
  int v27 = *(unsigned __int8 *)(v2 + 200);
  if (*(unsigned char *)(v2 + 200))
  {
    sub_1DC390B4C((uint64_t)v41, v2 + 104);
  }
  else
  {
    sub_1DC390A40((uint64_t)&v38, -1, 0);
    sub_1DC390CA0(v41, (uint64_t *)&v38);
  }
  char v44 = 1;
  uint64_t v31 = *(void *)(v26 + 24);
  if (!v31) {
    sub_1DC307C38();
  }
  size_t result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, void **, uint8_t *))(*(void *)v31 + 48))(v31, &v50, v41);
  if (v44) {
    size_t result = sub_1DC390B00((atomic_ullong *)v41);
  }
  if (!v27)
  {
    unint64_t v30 = (atomic_ullong *)&v38;
    return sub_1DC390B00(v30);
  }
  return result;
}

void sub_1DC32F838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  atomic_ullong v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  sub_1DC31EB58(v4);
  MEMORY[0x1E019CE90](v3, 0x10C1C40764D44F6);
  if ((_BYTE)v8) {
    sub_1DC32C8AC((atomic_ullong *)va);
  }
  sub_1DC31AEE4((uint64_t **)va1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1DC32F9A8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_1DC31EB58((atomic_ullong *)(v2 + 48));
    sub_1DC31EB58((atomic_ullong *)(v2 + 40));
    MEMORY[0x1E019CE90](v2, 0x10C1C40764D44F6);
  }
  return a1;
}

uint64_t sub_1DC32FA00()
{
  return 1;
}

uint64_t sub_1DC32FA08()
{
  return 1;
}

const char *sub_1DC32FA10()
{
  return "PlaceholderPyramidAllocator";
}

uint64_t sub_1DC32FA1C@<X0>(atomic_ullong *a1@<X1>, void *a2@<X8>)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  uint64_t v4 = qword_1EBFFC388;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::__fs::filesystem::path buf = 136446210;
    *(void *)&buf[4] = "virtual CFRef<CFArrayRef> mrc::(anonymous namespace)::PlaceholderPyramidAllocator<mrc::PyramidG"
                         "enerationBehavior::Default>::allocate(std::optional<Error> &, const std::optional<os_signpost_i"
                         "d_t> &) const [_Behavior = mrc::PyramidGenerationBehavior::Default]";
    _os_log_fault_impl(&dword_1DC2FE000, v4, OS_LOG_TYPE_FAULT, "Unexpected invocation: %{public}s", buf, 0xCu);
  }
  atomic_ullong v6 = @"PlaceholderPyramidAllocator::allocate should never be invoked.";
  *(void *)std::__fs::filesystem::path buf = -2011;
  uint64_t result = sub_1DC306334(a1, (uint64_t *)buf, (CFTypeRef *)&v6);
  *a2 = 0;
  return result;
}

void sub_1DC32FB20(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 89)) {
    BOOL v1 = *(unsigned char *)(a1 + 88) == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (!v1)
  {
    _os_feature_enabled_impl();
    operator new();
  }
  operator new();
}

void sub_1DC32FCAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1DC32FCE4(void *a1, uint64_t *a2, atomic_ullong *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  CFAllocatorRef v7 = qword_1EBFFC388;
  if (v6)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
      *(void *)&buf[4] = "EphemeralPyramidAllocator";
      __int16 v10 = 2050;
      uint64_t v11 = v6;
      _os_log_debug_impl(&dword_1DC2FE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", buf, 0x16u);
      uint64_t v6 = *a2;
    }
    *a2 = 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 136446210;
      *(void *)&buf[4] = "EphemeralPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v7, OS_LOG_TYPE_ERROR, "Failed to allocate pyramid allocator: %{public}s", buf, 0xCu);
    }
    uint64_t v8 = @"Failed to allocate pyramid allocator.";
    *(void *)std::__fs::filesystem::path buf = -2003;
    sub_1DC306334(a3, (uint64_t *)buf, (CFTypeRef *)&v8);
    uint64_t v6 = 0;
  }
  *a1 = v6;
}

void sub_1DC32FE68(uint64_t *a1, uint64_t *a2, atomic_ullong *a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  if (!*a2)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    uint64_t v11 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 136446210;
      *(void *)&buf[4] = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "Failed to allocate pyramid allocator: %{public}s", buf, 0xCu);
    }
    uint64_t v12 = @"Failed to allocate pyramid allocator.";
    *(void *)std::__fs::filesystem::path buf = -2003;
    sub_1DC306334(a3, (uint64_t *)buf, (CFTypeRef *)&v12);
    goto LABEL_17;
  }
  int v9 = *(unsigned __int8 *)(v6 + 96);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  __int16 v10 = qword_1EBFFC388;
  if (v9) {
    goto LABEL_9;
  }
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
    *(void *)&buf[4] = "CachedPyramidAllocator";
    __int16 v14 = 2050;
    uint64_t v15 = v6;
    _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is being prepared", buf, 0x16u);
    uint64_t v6 = *a2;
  }
  if (!sub_1DC330148(v6, (uint64_t)a3, a4))
  {
LABEL_17:
    uint64_t v6 = 0;
    goto LABEL_18;
  }
  uint64_t v6 = *a2;
LABEL_9:
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
    *(void *)&buf[4] = "CachedPyramidAllocator";
    __int16 v14 = 2050;
    uint64_t v15 = v6;
    _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", buf, 0x16u);
    uint64_t v6 = *a2;
  }
  *a2 = 0;
LABEL_18:
  *a1 = v6;
}

uint64_t *sub_1DC3300AC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    for (uint64_t i = 72; i != 40; i -= 8)
      sub_1DC330114((atomic_ullong *)(v2 + i));
    MEMORY[0x1E019CE90](v2, 0x10E3C4081D78B51);
  }
  return a1;
}

atomic_ullong *sub_1DC330114(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1DC330148(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 96)) {
    return 1;
  }
  v49[0] = &unk_1F3662E10;
  v49[1] = a1;
  BOOL v50 = v49;
  uint64_t v51 = a3;
  v48[0] = &unk_1F3662E90;
  v48[1] = a1;
  v48[3] = v48;
  sub_1DC31AD78((uint64_t)v52, (uint64_t)v48);
  if (*(unsigned char *)(v51 + 8)) {
    BOOL v6 = v50 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    sub_1DC31AE10((uint64_t)v50, *(void *)v51);
  }
  sub_1DC31AE60(v48);
  sub_1DC31AE60(v49);
  LOBYTE(v35) = 0;
  char v43 = 0;
  int v7 = *(unsigned __int8 *)(a1 + 28);
  if (*(unsigned char *)(a1 + 28))
  {
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    char v43 = 1;
    BYTE4(v41) = 1;
    LODWORD(v41) = 1024;
    WORD4(v41) = 257;
    BOOL v8 = *(unsigned char *)(a1 + 29) == 0;
    long long v35 = 0u;
    long long v36 = 0u;
  }
  else
  {
    BOOL v8 = 1;
    if (*(unsigned char *)(a1 + 29))
    {
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      char v43 = 1;
      BOOL v8 = 0;
    }
  }
  v22[0] = 0;
  v22[8] = 0;
  v22[16] = 0;
  v22[24] = 0;
  LOBYTE(v25) = 0;
  char v26 = 0;
  LOBYTE(v27) = 0;
  char v28 = 0;
  v31[0] = 0;
  char v33 = 0;
  __int16 v34 = 0;
  int v29 = 0;
  __int16 v30 = 0;
  int v23 = *(_DWORD *)(a1 + 24);
  char v24 = 1;
  if (v7)
  {
    char v26 = 1;
    uint64_t v25 = 64;
    char v28 = 1;
    uint64_t v27 = 64;
  }
  if (!v8) {
    __int16 v30 = 257;
  }
  sub_1DC330554((uint64_t)v31, &v35);
  v19[0] = 0;
  v19[8] = 0;
  uint64_t v20 = *(void *)(a1 + 32);
  char v21 = *(unsigned char *)(a1 + 40);
  unint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 16);
  CFNumberRef v47 = 0;
  uint64_t v11 = operator new(0x28uLL);
  *uint64_t v11 = &unk_1F3662F10;
  v11[1] = v22;
  v11[2] = v19;
  v11[3] = a1;
  v11[4] = a2;
  CFNumberRef v47 = v11;
  uint64_t v3 = sub_1DC330630(v9, v10, (uint64_t)v46);
  sub_1DC330744(v46);
  if (v3)
  {
    uint64_t v12 = 0;
    uint64_t v13 = a1 + 48;
    uint64_t v14 = a1 + 80;
    while (atomic_load_explicit((atomic_ullong *volatile)(v13 + v12), memory_order_acquire))
    {
      v12 += 8;
      if (v12 == 32) {
        goto LABEL_26;
      }
    }
    uint64_t v14 = v13 + v12;
LABEL_26:
    int v16 = *(unsigned __int8 *)(a1 + 96);
    *(void *)(a1 + 80) = v13;
    *(void *)(a1 + 88) = (v14 - v13) >> 3;
    if (!v16) {
      *(unsigned char *)(a1 + 96) = 1;
    }
  }
  else
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    uint64_t v15 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 136446210;
      char v45 = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_ERROR, "%{public}s: failed to prepare", buf, 0xCu);
    }
  }
  if (v33) {
    sub_1DC31FA90(&v32);
  }
  if (v43) {
    sub_1DC31FA90((atomic_ullong *)&v42 + 1);
  }
  if (*(unsigned char *)(v51 + 8)) {
    BOOL v17 = v53 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  if (!v17) {
    sub_1DC31AE10(v53, *(void *)v51);
  }
  sub_1DC31AE60(v52);
  return v3;
}

void sub_1DC3304CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC330554(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 128) == *((unsigned __int8 *)a2 + 128))
  {
    if (*(unsigned char *)(a1 + 128))
    {
      long long v3 = *a2;
      long long v4 = a2[1];
      long long v5 = a2[3];
      *(_OWORD *)(a1 + 32) = a2[2];
      *(_OWORD *)(a1 + 48) = v5;
      *(_OWORD *)a1 = v3;
      *(_OWORD *)(a1 + 16) = v4;
      long long v6 = a2[4];
      long long v7 = a2[5];
      long long v8 = a2[6];
      *(unsigned char *)(a1 + 112) = *((unsigned char *)a2 + 112);
      *(_OWORD *)(a1 + 80) = v7;
      *(_OWORD *)(a1 + 96) = v8;
      *(_OWORD *)(a1 + 64) = v6;
      unint64_t v9 = (atomic_ullong *)(a1 + 120);
      CFDictionaryRef explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)a2 + 15, memory_order_acquire);
      sub_1DC32D8E8(v9, explicit);
    }
  }
  else if (*(unsigned char *)(a1 + 128))
  {
    sub_1DC31FA90((atomic_ullong *)(a1 + 120));
    *(unsigned char *)(a1 + 128) = 0;
  }
  else
  {
    long long v11 = *a2;
    long long v12 = a2[1];
    long long v13 = a2[3];
    *(_OWORD *)(a1 + 32) = a2[2];
    *(_OWORD *)(a1 + 48) = v13;
    *(_OWORD *)a1 = v11;
    *(_OWORD *)(a1 + 16) = v12;
    long long v14 = a2[4];
    long long v15 = a2[5];
    long long v16 = a2[6];
    *(unsigned char *)(a1 + 112) = *((unsigned char *)a2 + 112);
    *(_OWORD *)(a1 + 80) = v15;
    *(_OWORD *)(a1 + 96) = v16;
    *(_OWORD *)(a1 + 64) = v14;
    CFTypeRef v17 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 15, memory_order_acquire);
    if (v17) {
      CFTypeRef v17 = CFRetain(v17);
    }
    *(void *)(a1 + 120) = v17;
    *(unsigned char *)(a1 + 128) = 1;
  }
}

uint64_t sub_1DC330630(unint64_t a1, unint64_t a2, uint64_t a3)
{
  double v3 = (double)a1;
  unint64_t v4 = vcvtpd_u64_f64((double)a1 * 0.5);
  if (v4)
  {
    unint64_t v6 = 0;
    double v7 = (double)a2;
    double v8 = ceil((double)a2 * 0.5);
    double v9 = 0.5;
    double v10 = (double)a2;
    double v11 = (double)a1;
    do
    {
      double v12 = v11;
      unint64_t v13 = (unint64_t)v8;
      double v11 = (double)v4;
      double v14 = v10;
      double v10 = (double)(unint64_t)v8;
      BOOL v15 = v12 <= (double)v4 || v13 == 0;
      if (v15 || v14 <= v10) {
        break;
      }
      unint64_t v17 = v13 >= v4 ? v4 : (unint64_t)v8;
      if (v17 < 0x40 || v6 > 3) {
        break;
      }
      unint64_t v22 = v4;
      unint64_t v23 = v6;
      unint64_t v21 = (unint64_t)v8;
      uint64_t v19 = *(void *)(a3 + 24);
      if (!v19) {
        sub_1DC307C38();
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t *, unint64_t *, unint64_t *))(*(void *)v19 + 48))(v19, &v23, &v22, &v21);
      if (!result) {
        return result;
      }
      ++v6;
      double v9 = v9 * 0.5;
      double v8 = ceil(v9 * v7);
      unint64_t v4 = vcvtpd_u64_f64(v9 * v3);
    }
    while (v4);
  }
  return 1;
}

void *sub_1DC330744(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1DC3307C8()
{
  return &unk_1F3662F70;
}

uint64_t sub_1DC3307D4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlmmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

BOOL sub_1DC330810(uint64_t a1, uint64_t *a2, void *a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v6 = *a4;
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 8);
  *(void *)uint64_t v8 = *a3;
  *(unsigned char *)(v8 + 8) = 1;
  uint64_t v9 = *(void *)(a1 + 8);
  *(void *)(v9 + 16) = v6;
  *(unsigned char *)(v9 + 24) = 1;
  if (*(unsigned char *)(*(void *)(a1 + 8) + 208))
  {
    *(void *)std::__fs::filesystem::path buf = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"MRC: Cached Pyramid Level #%zu", v5);
    double v10 = (const void *)atomic_exchange((atomic_ullong *volatile)(*(void *)(a1 + 8) + 200), atomic_exchange((atomic_ullong *volatile)buf, 0));
    if (v10) {
      CFRelease(v10);
    }
    sub_1DC31FA90((atomic_ullong *)buf);
  }
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  double v11 = qword_1EBFFC388;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v25 = 2050;
    uint64_t v26 = v5;
    _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s: attempting to create a CVPixelBufferPool at level #%{public}zu", buf, 0x16u);
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    unint64_t v17 = *(uint64_t **)(a1 + 8);
    atomic_ullong v21 = 0;
    atomic_ullong v22 = 0;
    sub_1DC3708C4(&v23, v17, &v22, &v21);
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire);
    *(_DWORD *)std::__fs::filesystem::path buf = 136446722;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v25 = 2050;
    uint64_t v26 = v5;
    __int16 v27 = 2114;
    unint64_t v28 = explicit;
    _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, pixelBufferAttributes: %{public}@", buf, 0x20u);
    sub_1DC31EBFC((atomic_ullong *)&v23);
    sub_1DC31EBFC(&v21);
    sub_1DC31EBFC(&v22);
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v19 = *(uint64_t **)(a1 + 16);
    atomic_ullong v22 = 0;
    sub_1DC370DDC(&v23, v19, &v22);
    unint64_t v20 = atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire);
    *(_DWORD *)std::__fs::filesystem::path buf = 136446722;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v25 = 2050;
    uint64_t v26 = v5;
    __int16 v27 = 2114;
    unint64_t v28 = v20;
    _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, pixelBufferPoolAttributes: %{public}@", buf, 0x20u);
    sub_1DC31EBFC((atomic_ullong *)&v23);
    sub_1DC31EBFC(&v22);
  }
  sub_1DC37112C((CVPixelBufferPoolRef *)buf, *(uint64_t **)(a1 + 16), *(uint64_t **)(a1 + 8), *(void *)(a1 + 32));
  double v12 = (atomic_ullong *)(v7 + 8 * v5 + 48);
  unint64_t v13 = (const void *)atomic_exchange(v12, atomic_exchange((atomic_ullong *volatile)buf, 0));
  if (v13) {
    CFRelease(v13);
  }
  sub_1DC330114((atomic_ullong *)buf);
  unint64_t v14 = atomic_load_explicit(v12, memory_order_acquire);
  if (v14)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v15 = atomic_load_explicit(v12, memory_order_acquire);
      *(_DWORD *)std::__fs::filesystem::path buf = 136446722;
      *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
      __int16 v25 = 2050;
      uint64_t v26 = v5;
      __int16 v27 = 2114;
      unint64_t v28 = v15;
      _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, allocated pixel buffer pool: %{public}@", buf, 0x20u);
    }
  }
  else if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v25 = 2050;
    uint64_t v26 = v5;
    _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "%{public}s: failed to create pixel buffer pool at level #%{public}zu", buf, 0x16u);
  }
  return v14 != 0;
}

void sub_1DC330BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1DC31FA90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

__n128 sub_1DC330C14(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3662F10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC330C44(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F3662F10;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_1DC330C98()
{
}

void *sub_1DC330CB0()
{
  return &unk_1F3662EF0;
}

uint64_t sub_1DC330CBC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC330CF8(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)std::__fs::filesystem::path buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      __int16 v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_END, v3, "CachedPyramidAllocator::prepare_", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC330EA8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3662E90;
  a2[1] = v2;
  return result;
}

void *sub_1DC330ECC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3662E90;
  result[1] = v3;
  return result;
}

void sub_1DC330F14()
{
}

void *sub_1DC330F2C()
{
  return &unk_1F3662E70;
}

uint64_t sub_1DC330F38(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC330F74(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)std::__fs::filesystem::path buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      __int16 v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "CachedPyramidAllocator::prepare_", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC331124(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3662E10;
  a2[1] = v2;
  return result;
}

void *sub_1DC331148(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3662E10;
  result[1] = v3;
  return result;
}

void sub_1DC331190()
{
}

uint64_t sub_1DC3311A8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 96);
}

const char *sub_1DC3311B0()
{
  return "CachedPyramidAllocator";
}

void *sub_1DC3311BC@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, CFArrayRef *a4@<X8>)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  v37[0] = &unk_1F3662FF8;
  v37[1] = a1;
  long long v38 = v37;
  v36[0] = &unk_1F3663078;
  v36[1] = a1;
  v36[3] = v36;
  uint64_t v39 = a3;
  sub_1DC31AD78((uint64_t)v40, (uint64_t)v36);
  if (*(unsigned char *)(v39 + 8)) {
    BOOL v7 = v38 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    sub_1DC31AE10((uint64_t)v38, *(void *)v39);
  }
  sub_1DC31AE60(v36);
  sub_1DC31AE60(v37);
  if (*(unsigned char *)(a1 + 96))
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(void *)(a1 + 88), MEMORY[0x1E4F1D510]);
    if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
    {
      uint64_t v9 = *(void *)(a1 + 88);
      __int16 v26 = a4;
      if (qword_1EBFFC380 != -1) {
        dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
      }
      uint32x2_t v10 = qword_1EBFFC388;
      if (v9)
      {
        uint64_t v11 = 0;
        unint64_t v12 = 0;
        while (1)
        {
          int8x8_t v13 = (atomic_ullong *)(*(void *)(a1 + 80) + v11);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          {
            unint64_t explicit = atomic_load_explicit(v13, memory_order_acquire);
            *(_DWORD *)std::__fs::filesystem::path buf = 136446722;
            *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
            __int16 v30 = 2050;
            unint64_t v31 = v12;
            __int16 v32 = 2050;
            unint64_t v33 = explicit;
            _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s: attempting to create a CVPixelBuffer at level #%{public}zu from pool %{public}p", buf, 0x20u);
          }
          sub_1DC3712B8((CVPixelBufferRef *)&v27, v13, (uint64_t)a2);
          if (!atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire)) {
            break;
          }
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire));
          sub_1DC307370((atomic_ullong *)&v27);
          ++v12;
          v11 += 8;
          if (v12 >= *(void *)(a1 + 88)) {
            goto LABEL_22;
          }
        }
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          unint64_t v25 = atomic_load_explicit(v13, memory_order_acquire);
          *(_DWORD *)std::__fs::filesystem::path buf = 136446722;
          *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
          __int16 v30 = 2050;
          unint64_t v31 = v12;
          __int16 v32 = 2050;
          unint64_t v33 = v25;
          _os_log_error_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_ERROR, "%{public}s: failed to create pixel buffer at level #%{public}zu from pool %{public}p", buf, 0x20u);
        }
        *__int16 v26 = 0;
        sub_1DC307370((atomic_ullong *)&v27);
      }
      else
      {
LABEL_22:
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v18 = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
          CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
          *(_DWORD *)std::__fs::filesystem::path buf = 136446722;
          *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
          __int16 v30 = 2050;
          unint64_t v31 = v18;
          __int16 v32 = 2050;
          unint64_t v33 = Count;
          _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s: allocated pyramid %{public}p with %{public}ld level(s)", buf, 0x20u);
          CFMutableStringRef v27 = CFStringCreateMutable(v8, 0);
          CFIndex v20 = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
          if (v20 >= 1)
          {
            for (CFIndex i = 0; i != v20; ++i)
            {
              ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), i);
              if (ValueAtIndex) {
                ValueAtIndedouble x = CFRetain(ValueAtIndex);
              }
              *(void *)std::__fs::filesystem::path buf = ValueAtIndex;
              sub_1DC3CBAD8((atomic_ullong *)&v27, (atomic_ullong *)buf);
              sub_1DC307370((atomic_ullong *)buf);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
              {
                unint64_t v23 = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
                unint64_t v24 = atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
                *(_DWORD *)std::__fs::filesystem::path buf = 136446978;
                *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
                __int16 v30 = 2050;
                unint64_t v31 = i;
                __int16 v32 = 2050;
                unint64_t v33 = v23;
                __int16 v34 = 2114;
                unint64_t v35 = v24;
                _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s: level #%{public}ld of pyramid %{public}p: %{public}@", buf, 0x2Au);
              }
              CFStringReplaceAll((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire), &stru_1F3665D38);
            }
          }
          sub_1DC326F90((atomic_ullong *)&v27);
        }
        *__int16 v26 = CFArrayCreateCopy(v8, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
      }
    }
    else
    {
      if (qword_1EBFFC380 != -1) {
        dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
      }
      uint64x2_t v16 = qword_1EBFFC388;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::__fs::filesystem::path buf = 0;
        _os_log_error_impl(&dword_1DC2FE000, v16, OS_LOG_TYPE_ERROR, "CFArrayCreateMutable failed", buf, 2u);
      }
      *(void *)std::__fs::filesystem::path buf = -2003;
      CFMutableStringRef v27 = @"CFArrayCreateMutable failed.";
      sub_1DC306334(a2, (uint64_t *)buf, (CFTypeRef *)&v27);
      *a4 = 0;
    }
    sub_1DC3070BC((atomic_ullong *)&Mutable);
  }
  else
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    int8x16_t v15 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 136446210;
      *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_ERROR, "%{public}s: effective pixel buffer pools are not yet ready", buf, 0xCu);
    }
    CFMutableArrayRef Mutable = (CFMutableArrayRef)@"Effective pixel buffer pools are not yet ready.";
    *(void *)std::__fs::filesystem::path buf = -2011;
    sub_1DC306334(a2, (uint64_t *)buf, (CFTypeRef *)&Mutable);
    *a4 = 0;
  }
  if (*(unsigned char *)(v39 + 8) && v41) {
    sub_1DC31AE10(v41, *(void *)v39);
  }
  return sub_1DC31AE60(v40);
}

void sub_1DC33177C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  atomic_ullong v7 = va_arg(va1, void);
  sub_1DC326F90((atomic_ullong *)va);
  sub_1DC3070BC((atomic_ullong *)va1);
  sub_1DC31AEE4((uint64_t **)(v5 - 136));
  _Unwind_Resume(a1);
}

void *sub_1DC331824()
{
  return &unk_1F36630D8;
}

uint64_t sub_1DC331830(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC33186C(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)std::__fs::filesystem::path buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      CFMutableStringRef v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_END, v3, "CachedPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC331A1C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3663078;
  a2[1] = v2;
  return result;
}

void *sub_1DC331A40(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3663078;
  result[1] = v3;
  return result;
}

void sub_1DC331A88()
{
}

void *sub_1DC331AA0()
{
  return &unk_1F3663058;
}

uint64_t sub_1DC331AAC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC331AE8(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)std::__fs::filesystem::path buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      CFMutableStringRef v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "CachedPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC331C98(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3662FF8;
  a2[1] = v2;
  return result;
}

void *sub_1DC331CBC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3662FF8;
  result[1] = v3;
  return result;
}

void sub_1DC331D04()
{
}

void sub_1DC331D1C()
{
}

void sub_1DC331E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_1DC331E18(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return *(void *)(a1 + 8) != a2 || *(void *)(a1 + 16) != a3 || *(_DWORD *)(a1 + 24) != a4;
}

void sub_1DC331E48(uint64_t a1)
{
  for (uint64_t i = 72; i != 40; i -= 8)
    sub_1DC330114((atomic_ullong *)(a1 + i));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC331EA4(uint64_t a1)
{
  for (uint64_t i = 72; i != 40; i -= 8)
    sub_1DC330114((atomic_ullong *)(a1 + i));
  return a1;
}

const char *sub_1DC331EE0()
{
  return "EphemeralPyramidAllocator";
}

void *sub_1DC331EEC@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, CFArrayRef *a4@<X8>)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  v36[0] = &unk_1F3662C80;
  v36[1] = a1;
  long long v37 = v36;
  v35[0] = &unk_1F3662D00;
  v35[1] = a1;
  v35[3] = v35;
  uint64_t v38 = a3;
  sub_1DC31AD78((uint64_t)v39, (uint64_t)v35);
  if (*(unsigned char *)(v38 + 8)) {
    BOOL v7 = v37 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    sub_1DC31AE10((uint64_t)v37, *(void *)v38);
  }
  sub_1DC31AE60(v35);
  sub_1DC31AE60(v36);
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D510]);
  if (!atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    int8x16_t v15 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::__fs::filesystem::path buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_ERROR, "CFArrayCreateMutable failed", buf, 2u);
    }
    *(void *)std::__fs::filesystem::path buf = -2003;
    CFMutableStringRef v24 = @"CFArrayCreateMutable failed.";
    sub_1DC306334(a2, (uint64_t *)buf, (CFTypeRef *)&v24);
    goto LABEL_19;
  }
  unint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 16);
  __int16 v34 = 0;
  uint64_t v11 = operator new(0x20uLL);
  *uint64_t v11 = &unk_1F3662D80;
  v11[1] = a1;
  v11[2] = a2;
  v11[3] = &Mutable;
  __int16 v34 = v11;
  char v12 = sub_1DC330630(v9, v10, (uint64_t)v33);
  sub_1DC330744(v33);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  int8x8_t v13 = qword_1EBFFC388;
  if ((v12 & 1) == 0)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 136446210;
      *(void *)&uint8_t buf[4] = "EphemeralPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_ERROR, "%{public}s: failed to allocate pyramid", buf, 0xCu);
    }
LABEL_19:
    CFArrayRef Copy = 0;
    goto LABEL_20;
  }
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
  {
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    *(_DWORD *)std::__fs::filesystem::path buf = 136446722;
    *(void *)&uint8_t buf[4] = "EphemeralPyramidAllocator";
    __int16 v27 = 2050;
    unint64_t v28 = explicit;
    __int16 v29 = 2050;
    unint64_t v30 = Count;
    _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: allocated pyramid %{public}p with %{public}ld level(s)", buf, 0x20u);
    CFMutableStringRef v24 = CFStringCreateMutable(v8, 0);
    CFIndex v19 = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    if (v19 >= 1)
    {
      for (CFIndex i = 0; i != v19; ++i)
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), i);
        if (ValueAtIndex) {
          ValueAtIndedouble x = CFRetain(ValueAtIndex);
        }
        *(void *)std::__fs::filesystem::path buf = ValueAtIndex;
        sub_1DC3CBAD8((atomic_ullong *)&v24, (atomic_ullong *)buf);
        sub_1DC307370((atomic_ullong *)buf);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v22 = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
          unint64_t v23 = atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire);
          *(_DWORD *)std::__fs::filesystem::path buf = 136446978;
          *(void *)&uint8_t buf[4] = "EphemeralPyramidAllocator";
          __int16 v27 = 2050;
          unint64_t v28 = i;
          __int16 v29 = 2050;
          unint64_t v30 = v22;
          __int16 v31 = 2114;
          unint64_t v32 = v23;
          _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: level #%{public}ld of pyramid %{public}p: %{public}@", buf, 0x2Au);
        }
        CFStringReplaceAll((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire), &stru_1F3665D38);
      }
    }
    sub_1DC326F90((atomic_ullong *)&v24);
  }
  CFArrayRef Copy = CFArrayCreateCopy(v8, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
LABEL_20:
  *a4 = Copy;
  sub_1DC3070BC((atomic_ullong *)&Mutable);
  if (*(unsigned char *)(v38 + 8) && v40) {
    sub_1DC31AE10(v40, *(void *)v38);
  }
  return sub_1DC31AE60(v39);
}

void sub_1DC332358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  atomic_ullong v5 = va_arg(va1, void);
  sub_1DC326F90((atomic_ullong *)va);
  sub_1DC3070BC((atomic_ullong *)va1);
  sub_1DC31AEE4((uint64_t **)(v3 - 136));
  _Unwind_Resume(a1);
}

void *sub_1DC3323F8()
{
  return &unk_1F3662DF0;
}

uint64_t sub_1DC332404(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlmmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

BOOL sub_1DC332440(uint64_t a1, void *a2, size_t *a3, size_t *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  size_t v6 = *a3;
  size_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"MRC: Ephemeral Pyramid Level #%zu", *a2);
  sub_1DC3325E4(&v12, v6, v7, *(_DWORD *)(v8 + 24), (atomic_ullong *)&v13, *(void *)(a1 + 16));
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
  if (explicit)
  {
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 24), memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire));
  }
  else
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    unint64_t v10 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::__fs::filesystem::path buf = 136446466;
      int8x16_t v15 = "EphemeralPyramidAllocator";
      __int16 v16 = 2050;
      uint64_t v17 = v5;
      _os_log_error_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_ERROR, "%{public}s: failed to create IOSurface-backed pixel buffer at level #%{public}zu", buf, 0x16u);
    }
  }
  sub_1DC307370((atomic_ullong *)&v12);
  sub_1DC31FA90((atomic_ullong *)&v13);
  return explicit != 0;
}

void sub_1DC3325C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  atomic_ullong v4 = va_arg(va1, void);
  sub_1DC307370((atomic_ullong *)va);
  sub_1DC31FA90((atomic_ullong *)va1);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3325E4(CVPixelBufferRef *a1, size_t a2, size_t a3, unsigned int a4, atomic_ullong *a5, uint64_t a6)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  CVPixelBufferRef v12 = qword_1EBFFC388;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
  {
    int v18 = HIBYTE(a4);
    int32x2_t v19 = (int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(a4), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
    if (HIBYTE(a4) - 32 >= 0x5Fu) {
      int v18 = 46;
    }
    int8x8_t v20 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v19, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v19, (int8x8_t)0x2E0000002ELL);
    v21.i64[0] = v20.u32[0];
    v21.i64[1] = v20.u32[1];
    v22.i64[0] = 255;
    v22.i64[1] = 255;
    uint64x2_t v23 = vshlq_u64((uint64x2_t)vandq_s8(v21, v22), (uint64x2_t)xmmword_1DC3FDC10);
    if (a4 - 32 >= 0x5F) {
      uint64_t v24 = 46;
    }
    else {
      uint64_t v24 = a4;
    }
    uint64_t v25 = v23.i64[0] | (v24 << 24) | v23.i64[1];
    BYTE4(v28) = BYTE4(v25);
    LODWORD(v28) = v25 | v18;
    *(_DWORD *)std::__fs::filesystem::path buf = 134349826;
    *(void *)&uint8_t buf[4] = a2;
    __int16 v49 = 2050;
    size_t v50 = a3;
    __int16 v51 = 1042;
    int v52 = 4;
    __int16 v53 = 2082;
    uint64_t v54 = &v28;
    _os_log_debug_impl(&dword_1DC2FE000, v12, OS_LOG_TYPE_DEBUG, "Attempting to create an IOSurface-backed CVPixelBuffer: width=%{public}zu, height=%{public}zu, pixelFormatType=%{public}.4s", buf, 0x26u);
  }
  atomic_ullong v45 = 0;
  *(void *)std::__fs::filesystem::path buf = FigCreateIOSurfacePropertiesDictionary();
  CFStringRef v13 = (const void *)atomic_exchange(&v45, atomic_exchange((atomic_ullong *volatile)buf, 0));
  if (v13) {
    CFRelease(v13);
  }
  sub_1DC31EBFC((atomic_ullong *)buf);
  LOBYTE(v28) = 0;
  BYTE8(v28) = 0;
  char v29 = 0;
  char v30 = 0;
  char v31 = 0;
  char v32 = 0;
  char v33 = 0;
  char v34 = 0;
  char v35 = 0;
  char v36 = 0;
  char v37 = 0;
  char v38 = 0;
  __int16 v41 = 0;
  char v42 = 0;
  char v43 = 0;
  atomic_ullong v44 = 0;
  char v40 = 1;
  int v39 = 1280;
  sub_1DC32D8E8(&v44, (CFTypeRef)atomic_load_explicit(a5, memory_order_acquire));
  buf[0] = 0;
  uint8_t buf[8] = 0;
  BYTE2(v50) = 0;
  LOBYTE(v52) = 0;
  BYTE2(v54) = 0;
  BYTE6(v54) = 0;
  char v55 = 0;
  char v56 = 0;
  char v57 = 0;
  char v58 = 0;
  v61[0] = 0;
  char v63 = 0;
  __int16 v64 = 0;
  int v59 = 0;
  __int16 v60 = 0;
  sub_1DC332A24((uint64_t)v61, &v28);
  atomic_ullong v26 = 0;
  sub_1DC3708C4(&v27, (uint64_t *)buf, &v26, &v45);
  CVPixelBufferRef pixelBufferOut = 0;
  CVReturn v14 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, a4, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire), &pixelBufferOut);
  if (v14)
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    int8x16_t v15 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)BOOL v65 = 67240192;
      *(_DWORD *)&v65[4] = v14;
      _os_log_error_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_ERROR, "CVPixelBufferCreate failed: %{public}d", v65, 8u);
    }
    *(void *)BOOL v65 = -2003;
    CFNumberRef v46 = @"CVPixelBufferCreate failed.";
    sub_1DC306334((atomic_ullong *)a6, (uint64_t *)v65, (CFTypeRef *)&v46);
    CVPixelBufferRef v16 = 0;
    *(_DWORD *)(a6 + 24) = v14;
    *(unsigned char *)(a6 + 28) = 1;
  }
  else
  {
    CVPixelBufferRef v16 = pixelBufferOut;
  }
  *a1 = v16;
  sub_1DC31EBFC((atomic_ullong *)&v27);
  sub_1DC31EBFC(&v26);
  if (v63) {
    sub_1DC31FA90(&v62);
  }
  sub_1DC31FA90(&v44);
  return sub_1DC31EBFC(&v45);
}

void sub_1DC3329B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, atomic_ullong a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,atomic_ullong a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,atomic_ullong a56,char a57)
{
  sub_1DC31EBFC(&a10);
  if (a57) {
    sub_1DC31FA90(&a56);
  }
  sub_1DC31FA90(v57);
  sub_1DC31EBFC(&a28);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC332A24(uint64_t a1, long long *a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 128);
  long long v4 = a2[3];
  long long v6 = *a2;
  long long v5 = a2[1];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v6;
  *(_OWORD *)(a1 + 16) = v5;
  long long v8 = a2[5];
  long long v7 = a2[6];
  long long v9 = a2[4];
  *(unsigned char *)(a1 + 112) = *((unsigned char *)a2 + 112);
  *(_OWORD *)(a1 + 80) = v8;
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 64) = v9;
  if (v3)
  {
    sub_1DC32D8E8((atomic_ullong *)(a1 + 120), (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 15, memory_order_acquire));
  }
  else
  {
    CFTypeRef explicit = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 15, memory_order_acquire);
    if (explicit) {
      CFTypeRef explicit = CFRetain(explicit);
    }
    *(void *)(a1 + 120) = explicit;
    *(unsigned char *)(a1 + 128) = 1;
  }
  return a1;
}

__n128 sub_1DC332AB0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3662D80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC332AE0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F3662D80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1DC332B34()
{
}

void *sub_1DC332B4C()
{
  return &unk_1F3662D60;
}

uint64_t sub_1DC332B58(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC332B94(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    long long v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)std::__fs::filesystem::path buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      CFDictionaryRef v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_END, v3, "EphemeralPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC332D44(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3662D00;
  a2[1] = v2;
  return result;
}

void *sub_1DC332D68(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3662D00;
  result[1] = v3;
  return result;
}

void sub_1DC332DB0()
{
}

void *sub_1DC332DC8()
{
  return &unk_1F3662CE0;
}

uint64_t sub_1DC332DD4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE0EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC332E10(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    long long v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)std::__fs::filesystem::path buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      CFDictionaryRef v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "EphemeralPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC332FC0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3662C80;
  a2[1] = v2;
  return result;
}

void *sub_1DC332FE4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3662C80;
  result[1] = v3;
  return result;
}

void sub_1DC33302C()
{
}

void sub_1DC333044()
{
}

void sub_1DC333120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1E019CE90](a9, 0x1081C40DCAC275BLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC333148()
{
}

uint64_t sub_1DC333160()
{
  return 1;
}

void sub_1DC333168(uint64_t a1)
{
  sub_1DC31EB58((atomic_ullong *)(a1 + 48));
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC3331BC(uint64_t a1)
{
  return a1;
}

void *sub_1DC3331F0()
{
  return &unk_1F3662B80;
}

uint64_t sub_1DC3331FC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE0EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS9_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC333238(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3332E4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3662B20;
}

void *sub_1DC333304()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3662B20;
  return result;
}

void sub_1DC33333C()
{
}

void *sub_1DC333354()
{
  return &unk_1F3662B00;
}

uint64_t sub_1DC333360(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE0EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS9_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC33339C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC333448(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3662AA0;
}

void *sub_1DC333468()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3662AA0;
  return result;
}

void sub_1DC3334A0()
{
}

void *sub_1DC3334B8()
{
  return &unk_1F3662A80;
}

uint64_t sub_1DC3334C4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC333500(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PyramidGenerationSession::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3335AC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3662A20;
}

void *sub_1DC3335CC()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3662A20;
  return result;
}

void sub_1DC333604()
{
}

void *sub_1DC33361C()
{
  return &unk_1F3662A00;
}

uint64_t sub_1DC333628(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC333664(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PyramidGenerationSession::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC333710(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36629A0;
}

void *sub_1DC333730()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36629A0;
  return result;
}

void sub_1DC333768()
{
}

__n128 sub_1DC333788(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3663230;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3337B0(uint64_t a1)
{
  os_signpost_id_t v2 = (char *)operator new(0x18uLL);
  *(void *)os_signpost_id_t v2 = &unk_1F3663230;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC3337FC()
{
}

void sub_1DC333814(uint64_t a1)
{
  BOOL v1 = *(uint64_t **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      sub_1DC32E940(v1 + 6);
      sub_1DC32E9A8(v1 + 7);
    }
    operator delete(v1);
  }
}

void *sub_1DC333874()
{
  return &unk_1F3663210;
}

uint64_t sub_1DC333880(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeINS_12_GLOBAL__N_131PyramidGenerationSessionContextILNS_25PyramidGenerationBehaviorE0EEEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3338BC(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    os_signpost_id_t v2 = *(std::__shared_weak_count **)(*(void *)a2 + 8);
    if (v2) {
      sub_1DC32EEF4(v2);
    }
    JUMPOUT(0x1E019CE90);
  }
}

void sub_1DC333924(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36631B0;
}

void *sub_1DC333944()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36631B0;
  return result;
}

void sub_1DC33397C()
{
}

uint64_t sub_1DC333998(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN3mrc12_GLOBAL__N_131PyramidGenerationSessionContextILNS1_25PyramidGenerationBehaviorE0EEEE27__shared_ptr_default_deleteIS5_S5_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC3339D4(uint64_t a1)
{
  return sub_1DC32E810(*(void *)(a1 + 24));
}

void sub_1DC3339DC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC333A18(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 200)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 104));
  }
  if (*(unsigned char *)(a1 + 96))
  {
    uint64_t v2 = *(void *)(a1 + 88);
    *(void *)(a1 + 88) = 0;
    if (v2) {
      sub_1DC32C828(v2);
    }
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3663140;
  *(void *)(a1 + 8) = 0;
  if (v3) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC333AC0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 200)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 104));
  }
  if (*(unsigned char *)(a1 + 96))
  {
    uint64_t v2 = *(void *)(a1 + 88);
    *(void *)(a1 + 88) = 0;
    if (v2) {
      sub_1DC32C828(v2);
    }
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3663140;
  *(void *)(a1 + 8) = 0;
  if (v3) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void sub_1DC333B48(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3663140;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC333BB8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3663140;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void *sub_1DC333C08()
{
  return &unk_1F3662980;
}

uint64_t sub_1DC333C14(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE26generatePyramidWithContextERNS_7ContextERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS9_INS_5ErrorEEERKNS9_IyEEEUlOT_OT0_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC333C50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 8)) {
    BOOL v4 = *(unsigned char *)(a3 + 96) == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    sub_1DC3070F0(*(atomic_ullong **)(a1 + 8), a3);
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    long long v5 = qword_1EBFFC388;
    __n128 result = (atomic_ullong *)os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR);
    if (result)
    {
      uint64_t v7 = *(void *)(a1 + 8);
      if (*(unsigned char *)(v7 + 96))
      {
        sub_1DC390B4C((uint64_t)&buf, v7);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        BYTE4(buf.d) = 0;
        long long v102 = 0u;
        long long v103 = 0u;
        BYTE4(v102) = 0;
        long long v104 = 0u;
      }
      sub_1DC390F7C((CFErrorRef *)v111, (uint64_t)&buf);
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v111, memory_order_acquire);
      LODWORD(v108[0]) = 138543362;
      *(void *)((char *)v108 + 4) = explicit;
      char v35 = "Cannot retrieve or instantiate pyramid generation session: %{public}@";
LABEL_153:
      _os_log_error_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_ERROR, v35, (uint8_t *)v108, 0xCu);
      sub_1DC306854((atomic_ullong *)v111);
      return sub_1DC390B00((atomic_ullong *)&buf);
    }
    return result;
  }
  unsigned int v8 = *(atomic_ullong ***)a2;
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 8);
  double v12 = *(double *)(a1 + 40);
  if (atomic_load_explicit((atomic_ullong *volatile)(v9 + 48), memory_order_acquire))
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    int8x8_t v13 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.a) = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "Sample has existing pyramid, skipping...", (uint8_t *)&buf, 2u);
    }
    CFTypeRef v14 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(v9 + 48), memory_order_acquire);
    if (v14) {
      CFTypeRef v14 = CFRetain(v14);
    }
    CFTypeRef v88 = v14;
    goto LABEL_141;
  }
  v106[0] = &unk_1F3662810;
  v106[1] = v9;
  unint64_t v107 = v106;
  v108[0] = v12;
  v105[0] = &unk_1F3662890;
  v105[1] = v9;
  v105[3] = v105;
  CGFloat v87 = v12;
  sub_1DC31AD78((uint64_t)&v108[1], (uint64_t)v105);
  if (*(unsigned char *)(*(void *)&v108[0] + 8) && v107) {
    sub_1DC31AE10((uint64_t)v107, **(void **)&v108[0]);
  }
  sub_1DC31AE60(v105);
  sub_1DC31AE60(v106);
  unint64_t v91 = *(atomic_ullong **)v9;
  uint64_t v92 = v11;
  char v93 = sub_1DC38379C(v91, v11);
  if ((v93 & 1) == 0)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    char v29 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      int v44 = *(_DWORD *)(v11 + 24);
      LODWORD(buf.a) = 67240192;
      HIDWORD(buf.a) = v44;
      _os_log_error_impl(&dword_1DC2FE000, v29, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&buf, 8u);
    }
    CFTypeRef v88 = 0;
    goto LABEL_137;
  }
  sub_1DC32C928(&v90, *(atomic_ullong **)v9, (uint64_t)&v91, v11);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire))
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    char v30 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "Failed to get or create shallow Yp8 pixel buffer.", (uint8_t *)&buf, 2u);
    }
    goto LABEL_48;
  }
  size_t Width = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire));
  size_t Height = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire));
  uint64_t PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire));
  atomic_ullong v18 = (*v8)[2];
  if (!v18)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    char v31 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v31, OS_LOG_TYPE_ERROR, "Invalid pyramid allocator", (uint8_t *)&buf, 2u);
    }
    buf.a = NAN;
    v111[0] = @"Invalid pyramid allocator.";
    sub_1DC306334((atomic_ullong *)v11, (uint64_t *)&buf, v111);
LABEL_48:
    CFTypeRef v88 = 0;
    goto LABEL_135;
  }
  double v19 = (double)Width;
  double v20 = (double)Height;
  int v21 = (*(uint64_t (**)(atomic_ullong, unint64_t, unint64_t, uint64_t))(*(void *)v18 + 16))(v18, (unint64_t)(double)Width, (unint64_t)(double)Height, PixelFormatType);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  __int16 v22 = qword_1EBFFC388;
  BOOL v23 = os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG);
  if (v21)
  {
    if (v23)
    {
      uint64_t v75 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
      atomic_ullong v76 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(void *)((char *)&buf.a + 4) = v75;
      WORD2(buf.b) = 2050;
      *(void *)((char *)&buf.b + 6) = v76;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Resetting pyramid allocator <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
    }
    (*(void (**)(CFTypeRef *__return_ptr))(*(void *)(*v8)[2] + 24))(v111);
    CFTypeRef v24 = v111[0];
    if (v111[0])
    {
      int v25 = *v8;
      v111[0] = 0;
      atomic_ullong v26 = v25[2];
      v25[2] = (atomic_ullong)v24;
      if (v26) {
        (*(void (**)(atomic_ullong))(*(void *)v26 + 8))(v26);
      }
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v27 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
        atomic_ullong v28 = (*v8)[2];
        LODWORD(buf.a) = 136446466;
        *(void *)((char *)&buf.a + 4) = v27;
        WORD2(buf.b) = 2050;
        *(void *)((char *)&buf.b + 6) = v28;
        _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "New pyramid allocator: <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
      }
    }
    else
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v79 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
        atomic_ullong v80 = (*v8)[2];
        LODWORD(buf.a) = 136446466;
        *(void *)((char *)&buf.a + 4) = v79;
        WORD2(buf.b) = 2050;
        *(void *)((char *)&buf.b + 6) = v80;
        _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Unable to reset pyramid allocator <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
      }
      CFTypeRef v88 = 0;
    }
    CFTypeRef v36 = v111[0];
    v111[0] = 0;
    if (v36) {
      (*(void (**)(CFTypeRef))(*(void *)v36 + 8))(v36);
    }
    if (!v24) {
      goto LABEL_135;
    }
  }
  else if (v23)
  {
    uint64_t v32 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
    atomic_ullong v33 = (*v8)[2];
    LODWORD(buf.a) = 136446466;
    *(void *)((char *)&buf.a + 4) = v32;
    WORD2(buf.b) = 2050;
    *(void *)((char *)&buf.b + 6) = v33;
    _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Pyramid allocator <%{public}s %{public}p> can be reused", (uint8_t *)&buf, 0x16u);
  }
  (*(void (**)(atomic_ullong *__return_ptr))(*(void *)(*v8)[2] + 32))(&v89);
  if (!atomic_load_explicit(&v89, memory_order_acquire))
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v77 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
      atomic_ullong v78 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(void *)((char *)&buf.a + 4) = v77;
      WORD2(buf.b) = 2050;
      *(void *)((char *)&buf.b + 6) = v78;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Pyramid allocator <%{public}s %{public}p>: unable to allocate pyramid", (uint8_t *)&buf, 0x16u);
    }
    char v43 = 0;
    goto LABEL_134;
  }
  CGFloat v37 = *(double *)(v9 + 16);
  CGFloat v38 = *(double *)(v9 + 24);
  CGFloat v39 = *(double *)(v9 + 32);
  CGFloat v40 = *(double *)(v9 + 40);
  v115.origin.CGFloat x = v37;
  v115.origin.CGFloat y = v38;
  v115.size.double width = v39;
  v115.size.double height = v40;
  if (!CGRectIsNull(v115))
  {
    v116.origin.CGFloat x = v37;
    v116.origin.CGFloat y = v38;
    v116.size.double width = v39;
    v116.size.double height = v40;
    if (CGRectIsInfinite(v116))
    {
      CGFloat x = *MEMORY[0x1E4F1DAD8];
      CGFloat y = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
      goto LABEL_68;
    }
    v126.origin.CGFloat x = 0.0;
    v126.origin.CGFloat y = 0.0;
    v117.origin.CGFloat x = v37;
    v117.origin.CGFloat y = v38;
    v117.size.double width = v39;
    v117.size.double height = v40;
    v126.size.double width = v19;
    v126.size.double height = (double)Height;
    CGRect v118 = CGRectIntersection(v117, v126);
    CGFloat x = v118.origin.x;
    CGFloat y = v118.origin.y;
    double v19 = v118.size.width;
    double v20 = v118.size.height;
    if (!CGRectIsNull(v118)) {
      goto LABEL_68;
    }
  }
  CGFloat x = *MEMORY[0x1E4F1DB28];
  CGFloat y = *(double *)(MEMORY[0x1E4F1DB28] + 8);
  double v19 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
  double v20 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
LABEL_68:
  if (*(unsigned char *)(v10 + 32))
  {
    if (!CGRectIsNull(*(CGRect *)v10) && !CGRectIsInfinite(*(CGRect *)v10))
    {
      v119.origin.CGFloat x = x;
      v119.origin.CGFloat y = y;
      v119.size.double width = v19;
      v119.size.double height = v20;
      CGRect v120 = CGRectIntersection(v119, *(CGRect *)v10);
      CGFloat x = v120.origin.x;
      CGFloat y = v120.origin.y;
      double v19 = v120.size.width;
      double v20 = v120.size.height;
      if (CGRectIsNull(v120))
      {
        CGFloat x = *MEMORY[0x1E4F1DB28];
        CGFloat y = *(double *)(MEMORY[0x1E4F1DB28] + 8);
        double v19 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
        double v20 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
      }
    }
  }
  v121.origin.CGFloat x = x;
  v121.origin.CGFloat y = y;
  v121.size.double width = v19;
  v121.size.double height = v20;
  if (CGRectIsEmpty(v121))
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.a) = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Empty effective region-of-interest.", (uint8_t *)&buf, 2u);
    }
    char v43 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
    goto LABEL_134;
  }
  atomic_ullong v45 = *v8;
  CFTypeRef v46 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire);
  if (v46) {
    CFTypeRef v46 = CFRetain(v46);
  }
  CFTypeRef v96 = v46;
  v95.origin.CGFloat x = x;
  v95.origin.CGFloat y = y;
  v95.size.double width = v19;
  v95.size.double height = v20;
  CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(&v89, memory_order_acquire));
  if (Count <= 0)
  {
LABEL_117:
    sub_1DC307370((atomic_ullong *)&v96);
LABEL_131:
    char v43 = (const void *)atomic_load_explicit(&v89, memory_order_acquire);
    if (v43) {
      char v43 = CFRetain(v43);
    }
    goto LABEL_134;
  }
  BOOL v48 = 0;
  CFIndex v49 = 0;
  propertyKeCGFloat y = (const __CFString *)*MEMORY[0x1E4F45170];
  CFStringRef v85 = (const __CFString *)*MEMORY[0x1E4F450F0];
  CFStringRef v83 = (const __CFString *)*MEMORY[0x1E4F1D158];
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v81 = (const __CFString *)*MEMORY[0x1E4F45148];
  CFStringRef v82 = (const __CFString *)*MEMORY[0x1E4F45150];
  while (1)
  {
    ValueAtIndeCGFloat x = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(&v89, memory_order_acquire), v49);
    if (ValueAtIndex) {
      ValueAtIndeCGFloat x = CFRetain(ValueAtIndex);
    }
    atomic_ullong v94 = (atomic_ullong)ValueAtIndex;
    size_t v51 = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit(&v94, memory_order_acquire));
    char v52 = sub_1DC32D3B4(&v94);
    OSType v53 = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(&v94, memory_order_acquire));
    double v54 = sub_1DC32D490(&v95, v51, v52, v53);
    CGFloat v56 = v55;
    CGFloat v58 = v57;
    CGFloat v60 = v59;
    CGAffineTransformMakeScale(&buf, 2.0, 2.0);
    v122.origin.CGFloat x = v54;
    v122.origin.CGFloat y = v56;
    v122.size.double width = v58;
    v122.size.double height = v60;
    CGRect v123 = CGRectApplyAffineTransform(v122, &buf);
    CGRect v95 = v123;
    if (!atomic_load_explicit(v45, memory_order_acquire)) {
      break;
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire)
      || !atomic_load_explicit(&v94, memory_order_acquire))
    {
      if (qword_1EBFFC380 != -1) {
        dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
      }
      int v68 = qword_1EBFFC388;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.a) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_ERROR, "Invalid source and/or destination buffer.", (uint8_t *)&buf, 2u);
      }
      buf.a = NAN;
      *(void *)int v113 = @"Invalid source and/or destination buffer.";
      sub_1DC306334((atomic_ullong *)v11, (uint64_t *)&buf, (CFTypeRef *)v113);
      goto LABEL_128;
    }
    CGFloat v61 = v123.origin.x;
    CGFloat v62 = v123.origin.y;
    CGFloat v63 = v123.size.width;
    CGFloat v64 = v123.size.height;
    v111[0] = &unk_1F3662610;
    int v112 = v111;
    v110[0] = &unk_1F3662690;
    v110[3] = v110;
    buf.a = v87;
    sub_1DC31AD78((uint64_t)&buf.b, (uint64_t)v110);
    if (*(unsigned char *)(*(void *)&buf.a + 8) && v112) {
      sub_1DC31AE10((uint64_t)v112, **(void **)&buf.a);
    }
    sub_1DC31AE60(v110);
    sub_1DC31AE60(v111);
    atomic_ullong v98 = 0;
    v124.origin.CGFloat x = v61;
    v124.origin.CGFloat y = v62;
    v124.size.double width = v63;
    v124.size.double height = v64;
    *(void *)int v113 = CGRectCreateDictionaryRepresentation(v124);
    BOOL v65 = (const void *)atomic_exchange(&v98, atomic_exchange((atomic_ullong *volatile)v113, 0));
    if (v65) {
      CFRelease(v65);
    }
    sub_1DC31EBFC((atomic_ullong *)v113);
    atomic_ullong v97 = 0;
    v125.origin.CGFloat x = v54;
    v125.origin.CGFloat y = v56;
    v125.size.double width = v58;
    v125.size.double height = v60;
    *(void *)int v113 = CGRectCreateDictionaryRepresentation(v125);
    uint64_t v66 = (const void *)atomic_exchange(&v97, atomic_exchange((atomic_ullong *volatile)v113, 0));
    if (v66) {
      CFRelease(v66);
    }
    sub_1DC31EBFC((atomic_ullong *)v113);
    VTSessionSetProperty((VTSessionRef)atomic_load_explicit(v45, memory_order_acquire), propertyKey, (CFTypeRef)atomic_load_explicit(&v98, memory_order_acquire));
    VTSessionSetProperty((VTSessionRef)atomic_load_explicit(v45, memory_order_acquire), v85, (CFTypeRef)atomic_load_explicit(&v97, memory_order_acquire));
    OSStatus v67 = VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)atomic_load_explicit(v45, memory_order_acquire), (CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire), (CVPixelBufferRef)atomic_load_explicit(&v94, memory_order_acquire));
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    int v68 = qword_1EBFFC388;
    if (v67)
    {
      if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v113 = 67240192;
        *(_DWORD *)&v113[4] = v67;
        _os_log_error_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionTransferImage failed: %{public}d", v113, 8u);
      }
      *(void *)int v113 = -2004;
      propertyValueOut = @"VTPixelTransferSessionTransferImage failed.";
      sub_1DC306334((atomic_ullong *)v11, (uint64_t *)v113, (CFTypeRef *)&propertyValueOut);
      *(void *)int v113 = CFErrorCreate(allocator, v83, v67, 0);
      uint64_t v69 = (const void *)atomic_exchange((atomic_ullong *volatile)(v11 + 64), atomic_exchange((atomic_ullong *volatile)v113, 0));
      if (v69) {
        CFRelease(v69);
      }
      sub_1DC306854((atomic_ullong *)v113);
    }
    else if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
    {
      propertyValueOut = 0;
      if (!VTSessionCopyProperty((VTSessionRef)atomic_load_explicit(v45, memory_order_acquire), v82, allocator, &propertyValueOut))
      {
        int v70 = propertyValueOut;
        if (propertyValueOut)
        {
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int v113 = 138543362;
            *(void *)&v113[4] = v70;
            _os_log_debug_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_DEBUG, "PixelTransferSession: mostRecentConversionType: %{public}@", v113, 0xCu);
            int v70 = propertyValueOut;
          }
          CFRelease(v70);
        }
      }
      uint64_t v99 = 0;
      if (!VTSessionCopyProperty((VTSessionRef)atomic_load_explicit(v45, memory_order_acquire), v81, allocator, &v99))
      {
        unint64_t v71 = v99;
        if (v99)
        {
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int v113 = 138543362;
            *(void *)&v113[4] = v71;
            _os_log_debug_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_DEBUG, "PixelTransferSession: mostRecentChainDescription: %{public}@", v113, 0xCu);
            unint64_t v71 = v99;
          }
          CFRelease(v71);
        }
      }
    }
    sub_1DC31EBFC(&v97);
    sub_1DC31EBFC(&v98);
    if (*(unsigned char *)(*(void *)&buf.a + 8) && *(void *)&buf.tx) {
      sub_1DC31AE10(*(uint64_t *)&buf.tx, **(void **)&buf.a);
    }
    sub_1DC31AE60(&buf.b);
    if (v67) {
      goto LABEL_128;
    }
    sub_1DC32D8E8((atomic_ullong *)&v96, (CFTypeRef)atomic_load_explicit(&v94, memory_order_acquire));
    v95.origin.CGFloat x = v54;
    v95.origin.CGFloat y = v56;
    v95.size.double width = v58;
    v95.size.double height = v60;
    sub_1DC307370(&v94);
    BOOL v48 = ++v49 >= Count;
    if (Count == v49) {
      goto LABEL_117;
    }
  }
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  int v68 = qword_1EBFFC388;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.a) = 0;
    _os_log_error_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_ERROR, "Invalid pixel transfer session.", (uint8_t *)&buf, 2u);
  }
  buf.a = NAN;
  *(void *)int v113 = @"Invalid pixel transfer session.";
  sub_1DC306334((atomic_ullong *)v11, (uint64_t *)&buf, (CFTypeRef *)v113);
LABEL_128:
  if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf.a) = 134349056;
    *(void *)((char *)&buf.a + 4) = v49;
    _os_log_error_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_ERROR, "Failed to transfer image at level #%{public}ld.", (uint8_t *)&buf, 0xCu);
  }
  sub_1DC307370(&v94);
  sub_1DC307370((atomic_ullong *)&v96);
  if (v48) {
    goto LABEL_131;
  }
  char v43 = 0;
LABEL_134:
  CFTypeRef v88 = v43;
  sub_1DC3065EC(&v89);
LABEL_135:
  sub_1DC307370((atomic_ullong *)&v90);
  if (v93) {
    sub_1DC3836F8(v91, v92);
  }
LABEL_137:
  if (*(unsigned char *)(*(void *)&v108[0] + 8) && v109) {
    sub_1DC31AE10(v109, **(void **)&v108[0]);
  }
  sub_1DC31AE60(&v108[1]);
LABEL_141:
  std::wstring::value_type v72 = (const void *)atomic_exchange(*(atomic_ullong *volatile *)(a1 + 16), atomic_exchange((atomic_ullong *volatile)&v88, 0));
  if (v72) {
    CFRelease(v72);
  }
  __n128 result = sub_1DC3065EC((atomic_ullong *)&v88);
  if (!atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 16), memory_order_acquire)
    || *(unsigned char *)(*(void *)(a1 + 8) + 96))
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    long long v5 = qword_1EBFFC388;
    __n128 result = (atomic_ullong *)os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR);
    if (result)
    {
      uint64_t v73 = *(void *)(a1 + 8);
      if (*(unsigned char *)(v73 + 96))
      {
        sub_1DC390B4C((uint64_t)&buf, v73);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        BYTE4(buf.d) = 0;
        long long v102 = 0u;
        long long v103 = 0u;
        BYTE4(v102) = 0;
        long long v104 = 0u;
      }
      sub_1DC390F7C((CFErrorRef *)v111, (uint64_t)&buf);
      unint64_t v74 = atomic_load_explicit((atomic_ullong *volatile)v111, memory_order_acquire);
      LODWORD(v108[0]) = 138543362;
      *(void *)((char *)v108 + 4) = v74;
      char v35 = "Cannot generate pyramid: %{public}@";
      goto LABEL_153;
    }
  }
  return result;
}

void sub_1DC334E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,atomic_ullong a24,atomic_ullong a25,atomic_ullong *a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a28) {
    sub_1DC3836F8(a26, a27);
  }
  if (*(unsigned char *)(a59 + 8))
  {
    if (a63) {
      sub_1DC31AE10(a63, *(void *)a59);
    }
  }
  sub_1DC31AE60(a21);
  _Unwind_Resume(a1);
}

__n128 sub_1DC3350C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3662910;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3350FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1F3662910;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void sub_1DC335158()
{
}

atomic_ullong *sub_1DC335170@<X0>(uint64_t a1@<X0>, CFErrorRef *a2@<X8>)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  LOBYTE(v4[0]) = 0;
  char v5 = 0;
  v6[0] = &unk_1F36632B0;
  v6[1] = v4;
  v6[3] = v6;
  sub_1DC32E0E0(a1, v6);
  __n128 result = sub_1DC32E6A4(v6);
  if (v5)
  {
    __n128 result = sub_1DC390F7C(a2, (uint64_t)v4);
    if (v5) {
      return sub_1DC390B00(v4);
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_1DC335230(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a21) {
    sub_1DC390B00(&a9);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC33525C()
{
  return &unk_1F3663310;
}

uint64_t sub_1DC335268(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE0EE19preflightForContextERNS_7ContextEEUlOT_OT0_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC3352A4(atomic_ullong *result, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a2 + 8)) {
    return sub_1DC3070F0((atomic_ullong *)result[1], a3);
  }
  return result;
}

uint64_t sub_1DC3352C4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F36632B0;
  a2[1] = v2;
  return result;
}

void *sub_1DC3352E8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F36632B0;
  result[1] = v3;
  return result;
}

void sub_1DC335330()
{
}

void sub_1DC335348(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DC3353CC((atomic_ullong *)a1);
  }
  JUMPOUT(0x1E019CE90);
}

atomic_ullong *sub_1DC3353CC(atomic_ullong *a1)
{
  if (atomic_load_explicit(a1, memory_order_acquire)) {
    VTPixelTransferSessionInvalidate((VTPixelTransferSessionRef)atomic_load_explicit(a1, memory_order_acquire));
  }
  return sub_1DC32C8F4(a1);
}

void *sub_1DC335414()
{
  return &unk_1F36627F0;
}

uint64_t sub_1DC335420(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE1EE13transferImageERKNS_5CFRefIP10__CVBufferEES9_RKNSt3__18optionalI6CGRectEESF_RNSB_INS_5ErrorEEERKNSB_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC33545C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)BOOL v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::transferImage", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC335508(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3662790;
}

void *sub_1DC335528()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3662790;
  return result;
}

void sub_1DC335560()
{
}

void *sub_1DC335578()
{
  return &unk_1F3662770;
}

uint64_t sub_1DC335584(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE1EE13transferImageERKNS_5CFRefIP10__CVBufferEES9_RKNSt3__18optionalI6CGRectEESF_RNSB_INS_5ErrorEEERKNSB_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3355C0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)BOOL v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::transferImage", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC33566C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3662710;
}

void *sub_1DC33568C()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3662710;
  return result;
}

void sub_1DC3356C4()
{
}

void *sub_1DC3356DC()
{
  return &unk_1F3663410;
}

uint64_t sub_1DC3356E8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE15generatePyramidERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS7_INS_5ErrorEEERKNS7_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC335724(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    BOOL v4 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      unint64_t v5 = vcvtpd_u64_f64(CGRectGetWidth(*(CGRect *)(**(void **)(a1 + 8) + 8)));
      CGRect v11 = *(CGRect *)(**(void **)(a1 + 8) + 8);
      int v6 = 134349312;
      unint64_t v7 = v5;
      __int16 v8 = 2050;
      unint64_t v9 = vcvtpd_u64_f64(CGRectGetHeight(v11));
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_END, v3, "PyramidGenerationSession::generatePyramid", "masterPixelBufferWidth=%{public, signpost.description:attribute}zu, masterPixelBufferHeight=%{public, signpost.description:attribute}zu", (uint8_t *)&v6, 0x16u);
    }
  }
}

uint64_t sub_1DC335850(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F36633B0;
  a2[1] = v2;
  return result;
}

void *sub_1DC335874(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F36633B0;
  result[1] = v3;
  return result;
}

void sub_1DC3358BC()
{
}

void *sub_1DC3358D4()
{
  return &unk_1F3663390;
}

uint64_t sub_1DC3358E0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE15generatePyramidERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS7_INS_5ErrorEEERKNS7_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC33591C(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    BOOL v4 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      unint64_t v5 = vcvtpd_u64_f64(CGRectGetWidth(*(CGRect *)(**(void **)(a1 + 8) + 8)));
      CGRect v11 = *(CGRect *)(**(void **)(a1 + 8) + 8);
      int v6 = 134349312;
      unint64_t v7 = v5;
      __int16 v8 = 2050;
      unint64_t v9 = vcvtpd_u64_f64(CGRectGetHeight(v11));
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "PyramidGenerationSession::generatePyramid", "masterPixelBufferWidth=%{public, signpost.description:attribute}zu, masterPixelBufferHeight=%{public, signpost.description:attribute}zu", (uint8_t *)&v6, 0x16u);
    }
  }
}

uint64_t sub_1DC335A48(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3663330;
  a2[1] = v2;
  return result;
}

void *sub_1DC335A6C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3663330;
  result[1] = v3;
  return result;
}

void sub_1DC335AB4()
{
}

void sub_1DC335ACC(uint64_t a1, void *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2 + 3;
  if (!a2[3]) {
    return;
  }
  BOOL v4 = (std::__shared_weak_count *)a1;
  unint64_t v5 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock_with_options();
  int v6 = sub_1DC32E728(&v4[1].__vftable, (unint64_t)&unk_1DC406D28);
  if (!v6) {
    operator new();
  }
  if ((_UNKNOWN *)v6[3] != &unk_1DC406D28)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_29;
  }
  unint64_t v7 = (atomic_ullong *)v6[6];
  if (!v7)
  {
LABEL_29:
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_30:
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
LABEL_13:
    unint64_t v9 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      LOWORD(context[0]) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "Unable to retrieve or instantiate concrete PyramidGenerationSession context.", (uint8_t *)context, 2u);
    }
    LOBYTE(v15) = 0;
    char v16 = 0;
    sub_1DC390A40((uint64_t)v12, -1, 0);
    sub_1DC390CA0(context, v12);
    char v14 = 1;
    if (!*v2) {
      sub_1DC307C38();
    }
    (*(void (**)(void, uint64_t *, atomic_ullong *))(*(void *)*v2 + 48))(*v2, &v15, context);
    if (v14) {
      sub_1DC390B00(context);
    }
    sub_1DC390B00(v12);
    if (v4) {
      goto LABEL_26;
    }
    return;
  }
  atomic_ullong v8 = *v7;
  BOOL v4 = (std::__shared_weak_count *)v7[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  if (!v8)
  {
    if (qword_1EBFFC380 == -1) {
      goto LABEL_13;
    }
    goto LABEL_30;
  }
  if (!*v2)
  {
    uint64_t v2 = &v11;
    goto LABEL_21;
  }
  if ((void *)*v2 != a2)
  {
    CGRect v11 = (void *)*v2;
LABEL_21:
    void *v2 = 0;
    goto LABEL_23;
  }
  CGRect v11 = v10;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v10);
LABEL_23:
  if (v11)
  {
    context[0] = (atomic_ullong)&unk_1F3663D40;
    context[1] = v8;
    context[2] = (atomic_ullong)v10;
    context[3] = (atomic_ullong)context;
    dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v8 + 8), context, (dispatch_function_t)sub_1DC3361C4);
    sub_1DC307968(context);
  }
  sub_1DC336090(v10);
  if (v4) {
LABEL_26:
  }
    sub_1DC32EEF4(v4);
}

void sub_1DC335F8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC336090(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1DC336114(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 200)) {
      sub_1DC390B00((atomic_ullong *)(result + 104));
    }
    if (*(unsigned char *)(v1 + 96))
    {
      uint64_t v2 = *(void *)(v1 + 88);
      *(void *)(v1 + 88) = 0;
      if (v2) {
        sub_1DC335348(v2);
      }
    }
    sub_1DC31EB58((atomic_ullong *)(v1 + 40));
    sub_1DC31EB58((atomic_ullong *)(v1 + 32));
    uint64_t v3 = *(void *)(v1 + 8);
    *(void *)uint64_t v1 = &unk_1F3663C50;
    *(void *)(v1 + 8) = 0;
    if (v3) {
      (*(void (**)(void))(v1 + 16))();
    }
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

uint64_t sub_1DC3361C4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    sub_1DC307C38();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

void *sub_1DC336214()
{
  return &unk_1F3663DA0;
}

uint64_t sub_1DC336220(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_131PyramidGenerationSessionContextILNS_25PyramidGenerationBehaviorE1EE7performENSt3__18functionIFvONS4_8optionalINS4_17reference_wrapperINS_24PyramidGenerationSessionILS2_1EEEEEEEONS6_INS_5ErrorEEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC33625C(uint64_t a1)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v2 + 200))
  {
    uint64_t v3 = *(void *)(a1 + 16);
    LOBYTE(v36) = 0;
    LOBYTE(v37[0]) = 0;
    sub_1DC390B4C((uint64_t)v39, v2 + 104);
    char v42 = 1;
    uint64_t v4 = *(void *)(v3 + 24);
    if (!v4) {
      sub_1DC307C38();
    }
    __n128 result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, os_signpost_id_t **, uint8_t *))(*(void *)v4 + 48))(v4, &v36, v39);
LABEL_47:
    if (!v42) {
      return result;
    }
    atomic_ullong v28 = (atomic_ullong *)v39;
    return sub_1DC390B00(v28);
  }
  int v6 = (uint64_t *)(v2 + 88);
  if (*(unsigned char *)(v2 + 96)) {
    goto LABEL_45;
  }
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  os_signpost_id_t v30 = os_signpost_id_make_with_pointer((os_log_t)qword_1EBFFC388, (const void *)v2);
  char v31 = 1;
  v44[0] = &unk_1F36634C0;
  atomic_ullong v45 = v44;
  v43[0] = &unk_1F3663540;
  v43[3] = v43;
  CFTypeRef v36 = &v30;
  sub_1DC31AD78((uint64_t)v37, (uint64_t)v43);
  if (*((unsigned char *)v36 + 8) && v45) {
    sub_1DC31AE10((uint64_t)v45, *v36);
  }
  sub_1DC31AE60(v43);
  sub_1DC31AE60(v44);
  BOOL v48 = &unk_1F36635C0;
  size_t v50 = &v48;
  v47[0] = &unk_1F3663640;
  v47[3] = v47;
  *(void *)CGFloat v39 = &v30;
  sub_1DC31AD78((uint64_t)v40, (uint64_t)v47);
  if (*(unsigned char *)(*(void *)v39 + 8) && v50) {
    sub_1DC31AE10((uint64_t)v50, **(void **)v39);
  }
  sub_1DC31AE60(v47);
  sub_1DC31AE60(&v48);
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  OSStatus v8 = VTPixelTransferSessionCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &pixelTransferSessionOut);
  if (v8)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    unint64_t v9 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CGAffineTransform buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v8;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate failed: %{public}d", buf, 8u);
    }
    *(void *)CGAffineTransform buf = -2003;
    VTPixelTransferSessionRef v34 = (VTPixelTransferSessionRef)@"VTPixelTransferSessionCreate failed.";
    sub_1DC306334((atomic_ullong *)(v2 + 104), (uint64_t *)buf, (CFTypeRef *)&v34);
    *(void *)CGAffineTransform buf = CFErrorCreate(v7, (CFErrorDomain)*MEMORY[0x1E4F1D158], v8, 0);
    uint64_t v10 = (const void *)atomic_exchange((atomic_ullong *volatile)(v2 + 168), atomic_exchange((atomic_ullong *volatile)buf, 0));
    if (v10) {
      CFRelease(v10);
    }
    sub_1DC306854((atomic_ullong *)buf);
    LOBYTE(v32) = 0;
    char v33 = 0;
  }
  else
  {
    VTPixelTransferSessionRef v34 = pixelTransferSessionOut;
    *(void *)CGAffineTransform buf = atomic_exchange((atomic_ullong *volatile)&v34, 0);
    if (atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire))
    {
      unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      VTSessionSetProperty(explicit, (CFStringRef)*MEMORY[0x1E4F45168], (CFTypeRef)*MEMORY[0x1E4F45460]);
      double v12 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      VTSessionSetProperty(v12, (CFStringRef)*MEMORY[0x1E4F45110], (CFTypeRef)*MEMORY[0x1E4F44DB0]);
      qos_class_t v13 = *(_DWORD *)(v2 + 48);
      HIDWORD(v15) = v13 - 9;
      LODWORD(v15) = v13 - 9;
      unsigned int v14 = v15 >> 2;
      char v16 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      if (v14 <= 6 && ((0x22u >> v14) & 1) == 0)
      {
        if (((1 << v14) & 0x5D) == 0) {
          qos_class_t v13 = qos_class_self();
        }
        if (v13 == QOS_CLASS_USER_INTERACTIVE)
        {
          uint64_t v17 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
          VTSessionSetProperty(v17, (CFStringRef)*MEMORY[0x1E4F45158], *v16);
        }
      }
      atomic_ullong v18 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      VTSessionSetProperty(v18, (CFStringRef)*MEMORY[0x1E4F45128], *v16);
      double v19 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      double v20 = (const void *)*MEMORY[0x1E4F1CFC8];
      VTSessionSetProperty(v19, (CFStringRef)*MEMORY[0x1E4F45188], (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
      int v21 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      VTSessionSetProperty(v21, (CFStringRef)*MEMORY[0x1E4F45120], v20);
      __int16 v22 = (const void *)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire);
      VTSessionSetProperty(v22, (CFStringRef)*MEMORY[0x1E4F45118], v20);
    }
    unint64_t v32 = atomic_exchange((atomic_ullong *volatile)buf, 0);
    char v33 = 1;
    sub_1DC3353CC((atomic_ullong *)buf);
    sub_1DC32C8F4((atomic_ullong *)&v34);
  }
  if (*(unsigned char *)(*(void *)v39 + 8) && v41) {
    sub_1DC31AE10(v41, **(void **)v39);
  }
  sub_1DC31AE60(v40);
  if (!v8) {
    operator new();
  }
  if (*((unsigned char *)v36 + 8) && v38) {
    sub_1DC31AE10(v38, *v36);
  }
  sub_1DC31AE60(v37);
  if (*(unsigned char *)(v2 + 96))
  {
    uint64_t v23 = *v6;
    uint64_t *v6 = 0;
    if (v23) {
      sub_1DC335348(v23);
    }
    *(unsigned char *)(v2 + 96) = 0;
  }
  if (*(unsigned char *)(v2 + 96))
  {
LABEL_45:
    uint64_t v26 = *(void *)(a1 + 16);
    CFTypeRef v36 = (os_signpost_id_t *)(v2 + 88);
    LOBYTE(v37[0]) = 1;
    v39[0] = 0;
    char v42 = 0;
    uint64_t v27 = *(void *)(v26 + 24);
    if (!v27) {
      sub_1DC307C38();
    }
    __n128 result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, os_signpost_id_t **, uint8_t *))(*(void *)v27 + 48))(v27, &v36, v39);
    goto LABEL_47;
  }
  uint64_t v24 = *(void *)(a1 + 16);
  LOBYTE(v48) = 0;
  char v49 = 0;
  int v25 = *(unsigned __int8 *)(v2 + 200);
  if (*(unsigned char *)(v2 + 200))
  {
    sub_1DC390B4C((uint64_t)v39, v2 + 104);
  }
  else
  {
    sub_1DC390A40((uint64_t)&v36, -1, 0);
    sub_1DC390CA0(v39, (uint64_t *)&v36);
  }
  char v42 = 1;
  uint64_t v29 = *(void *)(v24 + 24);
  if (!v29) {
    sub_1DC307C38();
  }
  __n128 result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, void **, uint8_t *))(*(void *)v29 + 48))(v29, &v48, v39);
  if (v42) {
    __n128 result = sub_1DC390B00((atomic_ullong *)v39);
  }
  if (!v25)
  {
    atomic_ullong v28 = (atomic_ullong *)&v36;
    return sub_1DC390B00(v28);
  }
  return result;
}

void sub_1DC336A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  atomic_ullong v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  sub_1DC31EB58(v4);
  MEMORY[0x1E019CE90](v3, 0x10C1C40764D44F6);
  if ((_BYTE)v8) {
    sub_1DC3353CC((atomic_ullong *)va);
  }
  sub_1DC31AEE4((uint64_t **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC336BE0()
{
  return 1;
}

uint64_t sub_1DC336BE8()
{
  return 1;
}

const char *sub_1DC336BF0()
{
  return "PlaceholderPyramidAllocator";
}

uint64_t sub_1DC336BFC@<X0>(atomic_ullong *a1@<X1>, void *a2@<X8>)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  uint64_t v4 = qword_1EBFFC388;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)CGAffineTransform buf = 136446210;
    *(void *)&uint8_t buf[4] = "virtual CFRef<CFArrayRef> mrc::(anonymous namespace)::PlaceholderPyramidAllocator<mrc::PyramidG"
                         "enerationBehavior::Legacy>::allocate(std::optional<Error> &, const std::optional<os_signpost_id"
                         "_t> &) const [_Behavior = mrc::PyramidGenerationBehavior::Legacy]";
    _os_log_fault_impl(&dword_1DC2FE000, v4, OS_LOG_TYPE_FAULT, "Unexpected invocation: %{public}s", buf, 0xCu);
  }
  atomic_ullong v6 = @"PlaceholderPyramidAllocator::allocate should never be invoked.";
  *(void *)CGAffineTransform buf = -2011;
  uint64_t result = sub_1DC306334(a1, (uint64_t *)buf, (CFTypeRef *)&v6);
  *a2 = 0;
  return result;
}

void sub_1DC336D00(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 89)) {
    BOOL v1 = *(unsigned char *)(a1 + 88) == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (!v1) {
    operator new();
  }
  operator new();
}

void sub_1DC336E6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1DC336EA4(void *a1, uint64_t *a2, atomic_ullong *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  CFAllocatorRef v7 = qword_1EBFFC388;
  if (v6)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)CGAffineTransform buf = 136446466;
      *(void *)&uint8_t buf[4] = "EphemeralPyramidAllocator";
      __int16 v10 = 2050;
      uint64_t v11 = v6;
      _os_log_debug_impl(&dword_1DC2FE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", buf, 0x16u);
      uint64_t v6 = *a2;
    }
    *a2 = 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CGAffineTransform buf = 136446210;
      *(void *)&uint8_t buf[4] = "EphemeralPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v7, OS_LOG_TYPE_ERROR, "Failed to allocate pyramid allocator: %{public}s", buf, 0xCu);
    }
    uint64_t v8 = @"Failed to allocate pyramid allocator.";
    *(void *)CGAffineTransform buf = -2003;
    sub_1DC306334(a3, (uint64_t *)buf, (CFTypeRef *)&v8);
    uint64_t v6 = 0;
  }
  *a1 = v6;
}

void sub_1DC337028(uint64_t *a1, uint64_t *a2, atomic_ullong *a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  if (!*a2)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    uint64_t v11 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CGAffineTransform buf = 136446210;
      *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "Failed to allocate pyramid allocator: %{public}s", buf, 0xCu);
    }
    uint64_t v12 = @"Failed to allocate pyramid allocator.";
    *(void *)CGAffineTransform buf = -2003;
    sub_1DC306334(a3, (uint64_t *)buf, (CFTypeRef *)&v12);
    goto LABEL_17;
  }
  int v9 = *(unsigned __int8 *)(v6 + 96);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  __int16 v10 = qword_1EBFFC388;
  if (v9) {
    goto LABEL_9;
  }
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)CGAffineTransform buf = 136446466;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v14 = 2050;
    uint64_t v15 = v6;
    _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is being prepared", buf, 0x16u);
    uint64_t v6 = *a2;
  }
  if (!sub_1DC33726C(v6, (uint64_t)a3, a4))
  {
LABEL_17:
    uint64_t v6 = 0;
    goto LABEL_18;
  }
  uint64_t v6 = *a2;
LABEL_9:
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)CGAffineTransform buf = 136446466;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v14 = 2050;
    uint64_t v15 = v6;
    _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}p is ready", buf, 0x16u);
    uint64_t v6 = *a2;
  }
  *a2 = 0;
LABEL_18:
  *a1 = v6;
}

uint64_t sub_1DC33726C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 96)) {
    return 1;
  }
  v49[0] = &unk_1F3663920;
  v49[1] = a1;
  size_t v50 = v49;
  uint64_t v51 = a3;
  v48[0] = &unk_1F36639A0;
  v48[1] = a1;
  v48[3] = v48;
  sub_1DC31AD78((uint64_t)v52, (uint64_t)v48);
  if (*(unsigned char *)(v51 + 8)) {
    BOOL v6 = v50 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    sub_1DC31AE10((uint64_t)v50, *(void *)v51);
  }
  sub_1DC31AE60(v48);
  sub_1DC31AE60(v49);
  LOBYTE(v35) = 0;
  char v43 = 0;
  int v7 = *(unsigned __int8 *)(a1 + 28);
  if (*(unsigned char *)(a1 + 28))
  {
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    char v43 = 1;
    BYTE4(v41) = 1;
    LODWORD(v41) = 1024;
    WORD4(v41) = 257;
    BOOL v8 = *(unsigned char *)(a1 + 29) == 0;
    long long v35 = 0u;
    long long v36 = 0u;
  }
  else
  {
    BOOL v8 = 1;
    if (*(unsigned char *)(a1 + 29))
    {
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      char v43 = 1;
      BOOL v8 = 0;
    }
  }
  v22[0] = 0;
  v22[8] = 0;
  v22[16] = 0;
  v22[24] = 0;
  LOBYTE(v25) = 0;
  char v26 = 0;
  LOBYTE(v27) = 0;
  char v28 = 0;
  v31[0] = 0;
  char v33 = 0;
  __int16 v34 = 0;
  int v29 = 0;
  __int16 v30 = 0;
  int v23 = *(_DWORD *)(a1 + 24);
  char v24 = 1;
  if (v7)
  {
    char v26 = 1;
    uint64_t v25 = 64;
    char v28 = 1;
    uint64_t v27 = 64;
  }
  if (!v8) {
    __int16 v30 = 257;
  }
  sub_1DC330554((uint64_t)v31, &v35);
  v19[0] = 0;
  v19[8] = 0;
  uint64_t v20 = *(void *)(a1 + 32);
  char v21 = *(unsigned char *)(a1 + 40);
  unint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 16);
  CFNumberRef v47 = 0;
  uint64_t v11 = operator new(0x28uLL);
  *uint64_t v11 = &unk_1F3663A20;
  v11[1] = v22;
  v11[2] = v19;
  v11[3] = a1;
  v11[4] = a2;
  CFNumberRef v47 = v11;
  uint64_t v3 = sub_1DC330630(v9, v10, (uint64_t)v46);
  sub_1DC330744(v46);
  if (v3)
  {
    uint64_t v12 = 0;
    uint64_t v13 = a1 + 48;
    uint64_t v14 = a1 + 80;
    while (atomic_load_explicit((atomic_ullong *volatile)(v13 + v12), memory_order_acquire))
    {
      v12 += 8;
      if (v12 == 32) {
        goto LABEL_26;
      }
    }
    uint64_t v14 = v13 + v12;
LABEL_26:
    int v16 = *(unsigned __int8 *)(a1 + 96);
    *(void *)(a1 + 80) = v13;
    *(void *)(a1 + 88) = (v14 - v13) >> 3;
    if (!v16) {
      *(unsigned char *)(a1 + 96) = 1;
    }
  }
  else
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    uint64_t v15 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CGAffineTransform buf = 136446210;
      atomic_ullong v45 = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_ERROR, "%{public}s: failed to prepare", buf, 0xCu);
    }
  }
  if (v33) {
    sub_1DC31FA90(&v32);
  }
  if (v43) {
    sub_1DC31FA90((atomic_ullong *)&v42 + 1);
  }
  if (*(unsigned char *)(v51 + 8)) {
    BOOL v17 = v53 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  if (!v17) {
    sub_1DC31AE10(v53, *(void *)v51);
  }
  sub_1DC31AE60(v52);
  return v3;
}

void sub_1DC3375F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC337678()
{
  return &unk_1F3663A80;
}

uint64_t sub_1DC337684(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlmmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

BOOL sub_1DC3376C0(uint64_t a1, uint64_t *a2, void *a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v6 = *a4;
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 8);
  *(void *)uint64_t v8 = *a3;
  *(unsigned char *)(v8 + 8) = 1;
  uint64_t v9 = *(void *)(a1 + 8);
  *(void *)(v9 + 16) = v6;
  *(unsigned char *)(v9 + 24) = 1;
  if (*(unsigned char *)(*(void *)(a1 + 8) + 208))
  {
    *(void *)CGAffineTransform buf = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"MRC: Cached Pyramid Level #%zu", v5);
    unint64_t v10 = (const void *)atomic_exchange((atomic_ullong *volatile)(*(void *)(a1 + 8) + 200), atomic_exchange((atomic_ullong *volatile)buf, 0));
    if (v10) {
      CFRelease(v10);
    }
    sub_1DC31FA90((atomic_ullong *)buf);
  }
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  uint64_t v11 = qword_1EBFFC388;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)CGAffineTransform buf = 136446466;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v25 = 2050;
    uint64_t v26 = v5;
    _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s: attempting to create a CVPixelBufferPool at level #%{public}zu", buf, 0x16u);
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    BOOL v17 = *(uint64_t **)(a1 + 8);
    atomic_ullong v21 = 0;
    atomic_ullong v22 = 0;
    sub_1DC3708C4(&v23, v17, &v22, &v21);
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire);
    *(_DWORD *)CGAffineTransform buf = 136446722;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v25 = 2050;
    uint64_t v26 = v5;
    __int16 v27 = 2114;
    unint64_t v28 = explicit;
    _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, pixelBufferAttributes: %{public}@", buf, 0x20u);
    sub_1DC31EBFC((atomic_ullong *)&v23);
    sub_1DC31EBFC(&v21);
    sub_1DC31EBFC(&v22);
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    double v19 = *(uint64_t **)(a1 + 16);
    atomic_ullong v22 = 0;
    sub_1DC370DDC(&v23, v19, &v22);
    unint64_t v20 = atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire);
    *(_DWORD *)CGAffineTransform buf = 136446722;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v25 = 2050;
    uint64_t v26 = v5;
    __int16 v27 = 2114;
    unint64_t v28 = v20;
    _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, pixelBufferPoolAttributes: %{public}@", buf, 0x20u);
    sub_1DC31EBFC((atomic_ullong *)&v23);
    sub_1DC31EBFC(&v22);
  }
  sub_1DC37112C((CVPixelBufferPoolRef *)buf, *(uint64_t **)(a1 + 16), *(uint64_t **)(a1 + 8), *(void *)(a1 + 32));
  uint64_t v12 = (atomic_ullong *)(v7 + 8 * v5 + 48);
  uint64_t v13 = (const void *)atomic_exchange(v12, atomic_exchange((atomic_ullong *volatile)buf, 0));
  if (v13) {
    CFRelease(v13);
  }
  sub_1DC330114((atomic_ullong *)buf);
  unint64_t v14 = atomic_load_explicit(v12, memory_order_acquire);
  if (v14)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v15 = atomic_load_explicit(v12, memory_order_acquire);
      *(_DWORD *)CGAffineTransform buf = 136446722;
      *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
      __int16 v25 = 2050;
      uint64_t v26 = v5;
      __int16 v27 = 2114;
      unint64_t v28 = v15;
      _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s: at level #%{public}zu, allocated pixel buffer pool: %{public}@", buf, 0x20u);
    }
  }
  else if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)CGAffineTransform buf = 136446466;
    *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
    __int16 v25 = 2050;
    uint64_t v26 = v5;
    _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "%{public}s: failed to create pixel buffer pool at level #%{public}zu", buf, 0x16u);
  }
  return v14 != 0;
}

void sub_1DC337A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1DC31FA90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

__n128 sub_1DC337AC4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3663A20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC337AF4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F3663A20;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_1DC337B48()
{
}

void *sub_1DC337B60()
{
  return &unk_1F3663A00;
}

uint64_t sub_1DC337B6C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC337BA8(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)CGAffineTransform buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      __int16 v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_END, v3, "CachedPyramidAllocator::prepare_", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC337D58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F36639A0;
  a2[1] = v2;
  return result;
}

void *sub_1DC337D7C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F36639A0;
  result[1] = v3;
  return result;
}

void sub_1DC337DC4()
{
}

void *sub_1DC337DDC()
{
  return &unk_1F3663980;
}

uint64_t sub_1DC337DE8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8prepare_ERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC337E24(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)CGAffineTransform buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      __int16 v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "CachedPyramidAllocator::prepare_", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC337FD4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3663920;
  a2[1] = v2;
  return result;
}

void *sub_1DC337FF8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3663920;
  result[1] = v3;
  return result;
}

void sub_1DC338040()
{
}

uint64_t sub_1DC338058(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 96);
}

const char *sub_1DC338060()
{
  return "CachedPyramidAllocator";
}

void *sub_1DC33806C@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, CFArrayRef *a4@<X8>)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  v37[0] = &unk_1F3663B08;
  v37[1] = a1;
  long long v38 = v37;
  v36[0] = &unk_1F3663B88;
  v36[1] = a1;
  void v36[3] = v36;
  uint64_t v39 = a3;
  sub_1DC31AD78((uint64_t)v40, (uint64_t)v36);
  if (*(unsigned char *)(v39 + 8)) {
    BOOL v7 = v38 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    sub_1DC31AE10((uint64_t)v38, *(void *)v39);
  }
  sub_1DC31AE60(v36);
  sub_1DC31AE60(v37);
  if (*(unsigned char *)(a1 + 96))
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(void *)(a1 + 88), MEMORY[0x1E4F1D510]);
    if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
    {
      uint64_t v9 = *(void *)(a1 + 88);
      __int16 v26 = a4;
      if (qword_1EBFFC380 != -1) {
        dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
      }
      uint32x2_t v10 = qword_1EBFFC388;
      if (v9)
      {
        uint64_t v11 = 0;
        unint64_t v12 = 0;
        while (1)
        {
          int8x8_t v13 = (atomic_ullong *)(*(void *)(a1 + 80) + v11);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          {
            unint64_t explicit = atomic_load_explicit(v13, memory_order_acquire);
            *(_DWORD *)CGAffineTransform buf = 136446722;
            *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
            __int16 v30 = 2050;
            unint64_t v31 = v12;
            __int16 v32 = 2050;
            unint64_t v33 = explicit;
            _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s: attempting to create a CVPixelBuffer at level #%{public}zu from pool %{public}p", buf, 0x20u);
          }
          sub_1DC3712B8((CVPixelBufferRef *)&v27, v13, (uint64_t)a2);
          if (!atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire)) {
            break;
          }
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire));
          sub_1DC307370((atomic_ullong *)&v27);
          ++v12;
          v11 += 8;
          if (v12 >= *(void *)(a1 + 88)) {
            goto LABEL_22;
          }
        }
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          unint64_t v25 = atomic_load_explicit(v13, memory_order_acquire);
          *(_DWORD *)CGAffineTransform buf = 136446722;
          *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
          __int16 v30 = 2050;
          unint64_t v31 = v12;
          __int16 v32 = 2050;
          unint64_t v33 = v25;
          _os_log_error_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_ERROR, "%{public}s: failed to create pixel buffer at level #%{public}zu from pool %{public}p", buf, 0x20u);
        }
        *__int16 v26 = 0;
        sub_1DC307370((atomic_ullong *)&v27);
      }
      else
      {
LABEL_22:
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v18 = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
          CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
          *(_DWORD *)CGAffineTransform buf = 136446722;
          *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
          __int16 v30 = 2050;
          unint64_t v31 = v18;
          __int16 v32 = 2050;
          unint64_t v33 = Count;
          _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s: allocated pyramid %{public}p with %{public}ld level(s)", buf, 0x20u);
          CFMutableStringRef v27 = CFStringCreateMutable(v8, 0);
          CFIndex v20 = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
          if (v20 >= 1)
          {
            for (CFIndex i = 0; i != v20; ++i)
            {
              ValueAtIndeCGFloat x = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), i);
              if (ValueAtIndex) {
                ValueAtIndeCGFloat x = CFRetain(ValueAtIndex);
              }
              *(void *)CGAffineTransform buf = ValueAtIndex;
              sub_1DC3CBAD8((atomic_ullong *)&v27, (atomic_ullong *)buf);
              sub_1DC307370((atomic_ullong *)buf);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
              {
                unint64_t v23 = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
                unint64_t v24 = atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
                *(_DWORD *)CGAffineTransform buf = 136446978;
                *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
                __int16 v30 = 2050;
                unint64_t v31 = i;
                __int16 v32 = 2050;
                unint64_t v33 = v23;
                __int16 v34 = 2114;
                unint64_t v35 = v24;
                _os_log_debug_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s: level #%{public}ld of pyramid %{public}p: %{public}@", buf, 0x2Au);
              }
              CFStringReplaceAll((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire), &stru_1F3665D38);
            }
          }
          sub_1DC326F90((atomic_ullong *)&v27);
        }
        *__int16 v26 = CFArrayCreateCopy(v8, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
      }
    }
    else
    {
      if (qword_1EBFFC380 != -1) {
        dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
      }
      uint64x2_t v16 = qword_1EBFFC388;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CGAffineTransform buf = 0;
        _os_log_error_impl(&dword_1DC2FE000, v16, OS_LOG_TYPE_ERROR, "CFArrayCreateMutable failed", buf, 2u);
      }
      *(void *)CGAffineTransform buf = -2003;
      CFMutableStringRef v27 = @"CFArrayCreateMutable failed.";
      sub_1DC306334(a2, (uint64_t *)buf, (CFTypeRef *)&v27);
      *a4 = 0;
    }
    sub_1DC3070BC((atomic_ullong *)&Mutable);
  }
  else
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    int8x16_t v15 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CGAffineTransform buf = 136446210;
      *(void *)&uint8_t buf[4] = "CachedPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_ERROR, "%{public}s: effective pixel buffer pools are not yet ready", buf, 0xCu);
    }
    CFMutableArrayRef Mutable = (CFMutableArrayRef)@"Effective pixel buffer pools are not yet ready.";
    *(void *)CGAffineTransform buf = -2011;
    sub_1DC306334(a2, (uint64_t *)buf, (CFTypeRef *)&Mutable);
    *a4 = 0;
  }
  if (*(unsigned char *)(v39 + 8) && v41) {
    sub_1DC31AE10(v41, *(void *)v39);
  }
  return sub_1DC31AE60(v40);
}

void sub_1DC33862C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  atomic_ullong v7 = va_arg(va1, void);
  sub_1DC326F90((atomic_ullong *)va);
  sub_1DC3070BC((atomic_ullong *)va1);
  sub_1DC31AEE4((uint64_t **)(v5 - 136));
  _Unwind_Resume(a1);
}

void *sub_1DC3386D4()
{
  return &unk_1F3663BE8;
}

uint64_t sub_1DC3386E0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC33871C(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)CGAffineTransform buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      CFMutableStringRef v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_END, v3, "CachedPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC3388CC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3663B88;
  a2[1] = v2;
  return result;
}

void *sub_1DC3388F0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3663B88;
  result[1] = v3;
  return result;
}

void sub_1DC338938()
{
}

void *sub_1DC338950()
{
  return &unk_1F3663B68;
}

uint64_t sub_1DC33895C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_122CachedPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC338998(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)CGAffineTransform buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      CFMutableStringRef v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "CachedPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC338B48(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3663B08;
  a2[1] = v2;
  return result;
}

void *sub_1DC338B6C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3663B08;
  result[1] = v3;
  return result;
}

void sub_1DC338BB4()
{
}

void sub_1DC338BCC()
{
}

void sub_1DC338CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_1DC338CC8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return *(void *)(a1 + 8) != a2 || *(void *)(a1 + 16) != a3 || *(_DWORD *)(a1 + 24) != a4;
}

void sub_1DC338CF8(uint64_t a1)
{
  for (uint64_t i = 72; i != 40; i -= 8)
    sub_1DC330114((atomic_ullong *)(a1 + i));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC338D54(uint64_t a1)
{
  for (uint64_t i = 72; i != 40; i -= 8)
    sub_1DC330114((atomic_ullong *)(a1 + i));
  return a1;
}

const char *sub_1DC338D90()
{
  return "EphemeralPyramidAllocator";
}

void *sub_1DC338D9C@<X0>(uint64_t a1@<X0>, atomic_ullong *a2@<X1>, uint64_t a3@<X2>, CFArrayRef *a4@<X8>)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  v36[0] = &unk_1F36637A0;
  v36[1] = a1;
  long long v37 = v36;
  v35[0] = &unk_1F3663820;
  v35[1] = a1;
  v35[3] = v35;
  uint64_t v38 = a3;
  sub_1DC31AD78((uint64_t)v39, (uint64_t)v35);
  if (*(unsigned char *)(v38 + 8)) {
    BOOL v7 = v37 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    sub_1DC31AE10((uint64_t)v37, *(void *)v38);
  }
  sub_1DC31AE60(v35);
  sub_1DC31AE60(v36);
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D510]);
  if (!atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    int8x16_t v15 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CGAffineTransform buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_ERROR, "CFArrayCreateMutable failed", buf, 2u);
    }
    *(void *)CGAffineTransform buf = -2003;
    CFMutableStringRef v24 = @"CFArrayCreateMutable failed.";
    sub_1DC306334(a2, (uint64_t *)buf, (CFTypeRef *)&v24);
    goto LABEL_19;
  }
  unint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = *(void *)(a1 + 16);
  __int16 v34 = 0;
  uint64_t v11 = operator new(0x20uLL);
  *uint64_t v11 = &unk_1F36638A0;
  v11[1] = a1;
  v11[2] = a2;
  v11[3] = &Mutable;
  __int16 v34 = v11;
  char v12 = sub_1DC330630(v9, v10, (uint64_t)v33);
  sub_1DC330744(v33);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  int8x8_t v13 = qword_1EBFFC388;
  if ((v12 & 1) == 0)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CGAffineTransform buf = 136446210;
      *(void *)&uint8_t buf[4] = "EphemeralPyramidAllocator";
      _os_log_error_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_ERROR, "%{public}s: failed to allocate pyramid", buf, 0xCu);
    }
LABEL_19:
    CFArrayRef Copy = 0;
    goto LABEL_20;
  }
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
  {
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    *(_DWORD *)CGAffineTransform buf = 136446722;
    *(void *)&uint8_t buf[4] = "EphemeralPyramidAllocator";
    __int16 v27 = 2050;
    unint64_t v28 = explicit;
    __int16 v29 = 2050;
    unint64_t v30 = Count;
    _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: allocated pyramid %{public}p with %{public}ld level(s)", buf, 0x20u);
    CFMutableStringRef v24 = CFStringCreateMutable(v8, 0);
    CFIndex v19 = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    if (v19 >= 1)
    {
      for (CFIndex i = 0; i != v19; ++i)
      {
        ValueAtIndeCGFloat x = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), i);
        if (ValueAtIndex) {
          ValueAtIndeCGFloat x = CFRetain(ValueAtIndex);
        }
        *(void *)CGAffineTransform buf = ValueAtIndex;
        sub_1DC3CBAD8((atomic_ullong *)&v24, (atomic_ullong *)buf);
        sub_1DC307370((atomic_ullong *)buf);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v22 = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
          unint64_t v23 = atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire);
          *(_DWORD *)CGAffineTransform buf = 136446978;
          *(void *)&uint8_t buf[4] = "EphemeralPyramidAllocator";
          __int16 v27 = 2050;
          unint64_t v28 = i;
          __int16 v29 = 2050;
          unint64_t v30 = v22;
          __int16 v31 = 2114;
          unint64_t v32 = v23;
          _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s: level #%{public}ld of pyramid %{public}p: %{public}@", buf, 0x2Au);
        }
        CFStringReplaceAll((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire), &stru_1F3665D38);
      }
    }
    sub_1DC326F90((atomic_ullong *)&v24);
  }
  CFArrayRef Copy = CFArrayCreateCopy(v8, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
LABEL_20:
  *a4 = Copy;
  sub_1DC3070BC((atomic_ullong *)&Mutable);
  if (*(unsigned char *)(v38 + 8) && v40) {
    sub_1DC31AE10(v40, *(void *)v38);
  }
  return sub_1DC31AE60(v39);
}

void sub_1DC339208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  atomic_ullong v5 = va_arg(va1, void);
  sub_1DC326F90((atomic_ullong *)va);
  sub_1DC3070BC((atomic_ullong *)va1);
  sub_1DC31AEE4((uint64_t **)(v3 - 136));
  _Unwind_Resume(a1);
}

void *sub_1DC3392A8()
{
  return &unk_1F3663900;
}

uint64_t sub_1DC3392B4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlmmmE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

BOOL sub_1DC3392F0(uint64_t a1, void *a2, size_t *a3, size_t *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  size_t v6 = *a3;
  size_t v7 = *a4;
  uint64_t v8 = *(void *)(a1 + 8);
  CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"MRC: Ephemeral Pyramid Level #%zu", *a2);
  sub_1DC3325E4(&v12, v6, v7, *(_DWORD *)(v8 + 24), (atomic_ullong *)&v13, *(void *)(a1 + 16));
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
  if (explicit)
  {
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 24), memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire));
  }
  else
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    unint64_t v10 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CGAffineTransform buf = 136446466;
      int8x16_t v15 = "EphemeralPyramidAllocator";
      __int16 v16 = 2050;
      uint64_t v17 = v5;
      _os_log_error_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_ERROR, "%{public}s: failed to create IOSurface-backed pixel buffer at level #%{public}zu", buf, 0x16u);
    }
  }
  sub_1DC307370((atomic_ullong *)&v12);
  sub_1DC31FA90((atomic_ullong *)&v13);
  return explicit != 0;
}

void sub_1DC339470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  atomic_ullong v4 = va_arg(va1, void);
  sub_1DC307370((atomic_ullong *)va);
  sub_1DC31FA90((atomic_ullong *)va1);
  _Unwind_Resume(a1);
}

__n128 sub_1DC33949C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F36638A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3394CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F36638A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1DC339520()
{
}

void *sub_1DC339538()
{
  return &unk_1F3663880;
}

uint64_t sub_1DC339544(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC339580(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)CGAffineTransform buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      __int16 v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_END, v3, "EphemeralPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC339730(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3663820;
  a2[1] = v2;
  return result;
}

void *sub_1DC339754(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3663820;
  result[1] = v3;
  return result;
}

void sub_1DC33979C()
{
}

void *sub_1DC3397B4()
{
  return &unk_1F3663800;
}

uint64_t sub_1DC3397C0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc12_GLOBAL__N_125EphemeralPyramidAllocatorILNS_25PyramidGenerationBehaviorE1EE8allocateERNSt3__18optionalINS_5ErrorEEERKNS5_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

__n128 sub_1DC3397FC(uint64_t a1, os_signpost_id_t *a2, __n128 result)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v7 = *(void *)(v4 + 16);
      unsigned int v8 = *(_DWORD *)(v4 + 24);
      int v9 = HIBYTE(v8);
      if (HIBYTE(v8) - 32 >= 0x5Fu) {
        int v9 = 46;
      }
      uint32x2_t v10 = (uint32x2_t)vdup_n_s32(v8);
      if (*(_DWORD *)(v4 + 24) - 32 >= 0x5F) {
        uint64_t v11 = 46;
      }
      else {
        uint64_t v11 = *(_DWORD *)(v4 + 24);
      }
      int32x2_t v12 = (int32x2_t)vshl_u32(v10, (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v12, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v12, (int8x8_t)0x2E0000002ELL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15.i64[0] = 255;
      v15.i64[1] = 255;
      uint64x2_t v16 = vshlq_u64((uint64x2_t)vandq_s8(v14, v15), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v17 = v16.i64[0] | (v11 << 24) | v16.i64[1];
      char v19 = BYTE4(v17);
      int v18 = v17 | v9;
      *(_DWORD *)CGAffineTransform buf = 134349826;
      uint64_t v21 = v6;
      __int16 v22 = 2050;
      uint64_t v23 = v7;
      __int16 v24 = 1042;
      int v25 = 4;
      __int16 v26 = 2082;
      __int16 v27 = &v18;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "EphemeralPyramidAllocator::allocate", "masterWidth=%{public, signpost.description:attribute}zu, masterHeight=%{public, signpost.description:attribute}zu, pixelFormatType=%{public, signpost.description:attribute}.4s", buf, 0x26u);
    }
  }
  return result;
}

uint64_t sub_1DC3399AC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F36637A0;
  a2[1] = v2;
  return result;
}

void *sub_1DC3399D0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F36637A0;
  result[1] = v3;
  return result;
}

void sub_1DC339A18()
{
}

void sub_1DC339A30()
{
}

void sub_1DC339B0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    MEMORY[0x1E019CE90](a9, 0x1081C40DCAC275BLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC339B34()
{
}

uint64_t sub_1DC339B4C()
{
  return 1;
}

void sub_1DC339B54(uint64_t a1)
{
  sub_1DC31EB58((atomic_ullong *)(a1 + 48));
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC339BA8(uint64_t a1)
{
  return a1;
}

void *sub_1DC339BDC()
{
  return &unk_1F36636A0;
}

uint64_t sub_1DC339BE8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE1EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS9_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC339C24(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC339CD0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3663640;
}

void *sub_1DC339CF0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3663640;
  return result;
}

void sub_1DC339D28()
{
}

void *sub_1DC339D40()
{
  return &unk_1F3663620;
}

uint64_t sub_1DC339D4C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120PixelTransferSessionILNS_25PyramidGenerationBehaviorE1EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS9_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC339D88(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC339E34(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36635C0;
}

void *sub_1DC339E54()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36635C0;
  return result;
}

void sub_1DC339E8C()
{
}

void *sub_1DC339EA4()
{
  return &unk_1F36635A0;
}

uint64_t sub_1DC339EB0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC339EEC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "PyramidGenerationSession::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC339F98(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3663540;
}

void *sub_1DC339FB8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3663540;
  return result;
}

void sub_1DC339FF0()
{
}

void *sub_1DC33A008()
{
  return &unk_1F3663520;
}

uint64_t sub_1DC33A014(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE6createERKNS_7Context7OptionsERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC33A050(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC388;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC388))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PyramidGenerationSession::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC33A0FC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36634C0;
}

void *sub_1DC33A11C()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36634C0;
  return result;
}

void sub_1DC33A154()
{
}

__n128 sub_1DC33A174(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3663D40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC33A19C(uint64_t a1)
{
  os_signpost_id_t v2 = (char *)operator new(0x18uLL);
  *(void *)os_signpost_id_t v2 = &unk_1F3663D40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC33A1E8()
{
}

void *sub_1DC33A200()
{
  return &unk_1F3663D20;
}

uint64_t sub_1DC33A20C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeINS_12_GLOBAL__N_131PyramidGenerationSessionContextILNS_25PyramidGenerationBehaviorE1EEEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC33A248(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    os_signpost_id_t v2 = *(std::__shared_weak_count **)(*(void *)a2 + 8);
    if (v2) {
      sub_1DC32EEF4(v2);
    }
    JUMPOUT(0x1E019CE90);
  }
}

void sub_1DC33A2B0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3663CC0;
}

void *sub_1DC33A2D0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3663CC0;
  return result;
}

void sub_1DC33A308()
{
}

uint64_t sub_1DC33A324(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN3mrc12_GLOBAL__N_131PyramidGenerationSessionContextILNS1_25PyramidGenerationBehaviorE1EEEE27__shared_ptr_default_deleteIS5_S5_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC33A360(uint64_t a1)
{
  return sub_1DC336114(*(void *)(a1 + 24));
}

void sub_1DC33A368(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC33A3A4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 200)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 104));
  }
  if (*(unsigned char *)(a1 + 96))
  {
    uint64_t v2 = *(void *)(a1 + 88);
    *(void *)(a1 + 88) = 0;
    if (v2) {
      sub_1DC335348(v2);
    }
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3663C50;
  *(void *)(a1 + 8) = 0;
  if (v3) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC33A44C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 200)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 104));
  }
  if (*(unsigned char *)(a1 + 96))
  {
    uint64_t v2 = *(void *)(a1 + 88);
    *(void *)(a1 + 88) = 0;
    if (v2) {
      sub_1DC335348(v2);
    }
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3663C50;
  *(void *)(a1 + 8) = 0;
  if (v3) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void sub_1DC33A4D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3663C50;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC33A544(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3663C50;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void *sub_1DC33A594()
{
  return &unk_1F36634A0;
}

uint64_t sub_1DC33A5A0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE26generatePyramidWithContextERNS_7ContextERKNS_6SampleERKNSt3__18optionalI6CGRectEERNS9_INS_5ErrorEEERKNS9_IyEEEUlOT_OT0_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC33A5DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 8)) {
    BOOL v4 = *(unsigned char *)(a3 + 96) == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    sub_1DC3070F0(*(atomic_ullong **)(a1 + 8), a3);
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    uint64_t v5 = qword_1EBFFC388;
    __n128 result = (atomic_ullong *)os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR);
    if (result)
    {
      uint64_t v7 = *(void *)(a1 + 8);
      if (*(unsigned char *)(v7 + 96))
      {
        sub_1DC390B4C((uint64_t)&buf, v7);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        BYTE4(buf.d) = 0;
        long long v102 = 0u;
        long long v103 = 0u;
        BYTE4(v102) = 0;
        long long v104 = 0u;
      }
      sub_1DC390F7C((CFErrorRef *)v111, (uint64_t)&buf);
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v111, memory_order_acquire);
      LODWORD(v108[0]) = 138543362;
      *(void *)((char *)v108 + 4) = explicit;
      unint64_t v35 = "Cannot retrieve or instantiate pyramid generation session: %{public}@";
LABEL_153:
      _os_log_error_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_ERROR, v35, (uint8_t *)v108, 0xCu);
      sub_1DC306854((atomic_ullong *)v111);
      return sub_1DC390B00((atomic_ullong *)&buf);
    }
    return result;
  }
  unsigned int v8 = *(atomic_ullong ***)a2;
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 8);
  double v12 = *(double *)(a1 + 40);
  if (atomic_load_explicit((atomic_ullong *volatile)(v9 + 48), memory_order_acquire))
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    int8x8_t v13 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.a) = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "Sample has existing pyramid, skipping...", (uint8_t *)&buf, 2u);
    }
    CFTypeRef v14 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(v9 + 48), memory_order_acquire);
    if (v14) {
      CFTypeRef v14 = CFRetain(v14);
    }
    CFTypeRef v88 = v14;
    goto LABEL_141;
  }
  v106[0] = &unk_1F3663330;
  v106[1] = v9;
  unint64_t v107 = v106;
  v108[0] = v12;
  v105[0] = &unk_1F36633B0;
  v105[1] = v9;
  v105[3] = v105;
  CGFloat v87 = v12;
  sub_1DC31AD78((uint64_t)&v108[1], (uint64_t)v105);
  if (*(unsigned char *)(*(void *)&v108[0] + 8) && v107) {
    sub_1DC31AE10((uint64_t)v107, **(void **)&v108[0]);
  }
  sub_1DC31AE60(v105);
  sub_1DC31AE60(v106);
  unint64_t v91 = *(atomic_ullong **)v9;
  uint64_t v92 = v11;
  char v93 = sub_1DC38379C(v91, v11);
  if ((v93 & 1) == 0)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    __int16 v29 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      int v44 = *(_DWORD *)(v11 + 24);
      LODWORD(buf.a) = 67240192;
      HIDWORD(buf.a) = v44;
      _os_log_error_impl(&dword_1DC2FE000, v29, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&buf, 8u);
    }
    CFTypeRef v88 = 0;
    goto LABEL_137;
  }
  sub_1DC32C928(&v90, *(atomic_ullong **)v9, (uint64_t)&v91, v11);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire))
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    unint64_t v30 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v30, OS_LOG_TYPE_ERROR, "Failed to get or create shallow Yp8 pixel buffer.", (uint8_t *)&buf, 2u);
    }
    goto LABEL_48;
  }
  size_t Width = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire));
  size_t Height = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire));
  uint64_t PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire));
  atomic_ullong v18 = (*v8)[2];
  if (!v18)
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    __int16 v31 = qword_1EBFFC388;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.a) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v31, OS_LOG_TYPE_ERROR, "Invalid pyramid allocator", (uint8_t *)&buf, 2u);
    }
    buf.a = NAN;
    v111[0] = @"Invalid pyramid allocator.";
    sub_1DC306334((atomic_ullong *)v11, (uint64_t *)&buf, v111);
LABEL_48:
    CFTypeRef v88 = 0;
    goto LABEL_135;
  }
  double v19 = (double)Width;
  double v20 = (double)Height;
  int v21 = (*(uint64_t (**)(atomic_ullong, unint64_t, unint64_t, uint64_t))(*(void *)v18 + 16))(v18, (unint64_t)(double)Width, (unint64_t)(double)Height, PixelFormatType);
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  __int16 v22 = qword_1EBFFC388;
  BOOL v23 = os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG);
  if (v21)
  {
    if (v23)
    {
      uint64_t v75 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
      atomic_ullong v76 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(void *)((char *)&buf.a + 4) = v75;
      WORD2(buf.b) = 2050;
      *(void *)((char *)&buf.b + 6) = v76;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Resetting pyramid allocator <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
    }
    (*(void (**)(CFTypeRef *__return_ptr))(*(void *)(*v8)[2] + 24))(v111);
    CFTypeRef v24 = v111[0];
    if (v111[0])
    {
      int v25 = *v8;
      v111[0] = 0;
      atomic_ullong v26 = v25[2];
      v25[2] = (atomic_ullong)v24;
      if (v26) {
        (*(void (**)(atomic_ullong))(*(void *)v26 + 8))(v26);
      }
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v27 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
        atomic_ullong v28 = (*v8)[2];
        LODWORD(buf.a) = 136446466;
        *(void *)((char *)&buf.a + 4) = v27;
        WORD2(buf.b) = 2050;
        *(void *)((char *)&buf.b + 6) = v28;
        _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "New pyramid allocator: <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
      }
    }
    else
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v79 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
        atomic_ullong v80 = (*v8)[2];
        LODWORD(buf.a) = 136446466;
        *(void *)((char *)&buf.a + 4) = v79;
        WORD2(buf.b) = 2050;
        *(void *)((char *)&buf.b + 6) = v80;
        _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Unable to reset pyramid allocator <%{public}s %{public}p>", (uint8_t *)&buf, 0x16u);
      }
      CFTypeRef v88 = 0;
    }
    CFTypeRef v36 = v111[0];
    v111[0] = 0;
    if (v36) {
      (*(void (**)(CFTypeRef))(*(void *)v36 + 8))(v36);
    }
    if (!v24) {
      goto LABEL_135;
    }
  }
  else if (v23)
  {
    uint64_t v32 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
    atomic_ullong v33 = (*v8)[2];
    LODWORD(buf.a) = 136446466;
    *(void *)((char *)&buf.a + 4) = v32;
    WORD2(buf.b) = 2050;
    *(void *)((char *)&buf.b + 6) = v33;
    _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Pyramid allocator <%{public}s %{public}p> can be reused", (uint8_t *)&buf, 0x16u);
  }
  (*(void (**)(atomic_ullong *__return_ptr))(*(void *)(*v8)[2] + 32))(&v89);
  if (!atomic_load_explicit(&v89, memory_order_acquire))
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v77 = (*(uint64_t (**)(atomic_ullong))(*(void *)(*v8)[2] + 40))((*v8)[2]);
      atomic_ullong v78 = (*v8)[2];
      LODWORD(buf.a) = 136446466;
      *(void *)((char *)&buf.a + 4) = v77;
      WORD2(buf.b) = 2050;
      *(void *)((char *)&buf.b + 6) = v78;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Pyramid allocator <%{public}s %{public}p>: unable to allocate pyramid", (uint8_t *)&buf, 0x16u);
    }
    char v43 = 0;
    goto LABEL_134;
  }
  CGFloat v37 = *(double *)(v9 + 16);
  CGFloat v38 = *(double *)(v9 + 24);
  CGFloat v39 = *(double *)(v9 + 32);
  CGFloat v40 = *(double *)(v9 + 40);
  v115.origin.CGFloat x = v37;
  v115.origin.CGFloat y = v38;
  v115.size.double width = v39;
  v115.size.double height = v40;
  if (!CGRectIsNull(v115))
  {
    v116.origin.CGFloat x = v37;
    v116.origin.CGFloat y = v38;
    v116.size.double width = v39;
    v116.size.double height = v40;
    if (CGRectIsInfinite(v116))
    {
      CGFloat x = *MEMORY[0x1E4F1DAD8];
      CGFloat y = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
      goto LABEL_68;
    }
    v126.origin.CGFloat x = 0.0;
    v126.origin.CGFloat y = 0.0;
    v117.origin.CGFloat x = v37;
    v117.origin.CGFloat y = v38;
    v117.size.double width = v39;
    v117.size.double height = v40;
    v126.size.double width = v19;
    v126.size.double height = (double)Height;
    CGRect v118 = CGRectIntersection(v117, v126);
    CGFloat x = v118.origin.x;
    CGFloat y = v118.origin.y;
    double v19 = v118.size.width;
    double v20 = v118.size.height;
    if (!CGRectIsNull(v118)) {
      goto LABEL_68;
    }
  }
  CGFloat x = *MEMORY[0x1E4F1DB28];
  CGFloat y = *(double *)(MEMORY[0x1E4F1DB28] + 8);
  double v19 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
  double v20 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
LABEL_68:
  if (*(unsigned char *)(v10 + 32))
  {
    if (!CGRectIsNull(*(CGRect *)v10) && !CGRectIsInfinite(*(CGRect *)v10))
    {
      v119.origin.CGFloat x = x;
      v119.origin.CGFloat y = y;
      v119.size.double width = v19;
      v119.size.double height = v20;
      CGRect v120 = CGRectIntersection(v119, *(CGRect *)v10);
      CGFloat x = v120.origin.x;
      CGFloat y = v120.origin.y;
      double v19 = v120.size.width;
      double v20 = v120.size.height;
      if (CGRectIsNull(v120))
      {
        CGFloat x = *MEMORY[0x1E4F1DB28];
        CGFloat y = *(double *)(MEMORY[0x1E4F1DB28] + 8);
        double v19 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
        double v20 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
      }
    }
  }
  v121.origin.CGFloat x = x;
  v121.origin.CGFloat y = y;
  v121.size.double width = v19;
  v121.size.double height = v20;
  if (CGRectIsEmpty(v121))
  {
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf.a) = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "Empty effective region-of-interest.", (uint8_t *)&buf, 2u);
    }
    char v43 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
    goto LABEL_134;
  }
  atomic_ullong v45 = *v8;
  CFTypeRef v46 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v90, memory_order_acquire);
  if (v46) {
    CFTypeRef v46 = CFRetain(v46);
  }
  CFTypeRef v96 = v46;
  v95.origin.CGFloat x = x;
  v95.origin.CGFloat y = y;
  v95.size.double width = v19;
  v95.size.double height = v20;
  CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(&v89, memory_order_acquire));
  if (Count <= 0)
  {
LABEL_117:
    sub_1DC307370((atomic_ullong *)&v96);
LABEL_131:
    char v43 = (const void *)atomic_load_explicit(&v89, memory_order_acquire);
    if (v43) {
      char v43 = CFRetain(v43);
    }
    goto LABEL_134;
  }
  BOOL v48 = 0;
  CFIndex v49 = 0;
  propertyKeCGFloat y = (const __CFString *)*MEMORY[0x1E4F45170];
  CFStringRef v85 = (const __CFString *)*MEMORY[0x1E4F450F0];
  CFStringRef v83 = (const __CFString *)*MEMORY[0x1E4F1D158];
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v81 = (const __CFString *)*MEMORY[0x1E4F45148];
  CFStringRef v82 = (const __CFString *)*MEMORY[0x1E4F45150];
  while (1)
  {
    ValueAtIndeCGFloat x = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(&v89, memory_order_acquire), v49);
    if (ValueAtIndex) {
      ValueAtIndeCGFloat x = CFRetain(ValueAtIndex);
    }
    atomic_ullong v94 = (atomic_ullong)ValueAtIndex;
    size_t v51 = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit(&v94, memory_order_acquire));
    char v52 = sub_1DC32D3B4(&v94);
    OSType v53 = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(&v94, memory_order_acquire));
    double v54 = sub_1DC32D490(&v95, v51, v52, v53);
    CGFloat v56 = v55;
    CGFloat v58 = v57;
    CGFloat v60 = v59;
    CGAffineTransformMakeScale(&buf, 2.0, 2.0);
    v122.origin.CGFloat x = v54;
    v122.origin.CGFloat y = v56;
    v122.size.double width = v58;
    v122.size.double height = v60;
    CGRect v123 = CGRectApplyAffineTransform(v122, &buf);
    CGRect v95 = v123;
    if (!atomic_load_explicit(v45, memory_order_acquire)) {
      break;
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire)
      || !atomic_load_explicit(&v94, memory_order_acquire))
    {
      if (qword_1EBFFC380 != -1) {
        dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
      }
      int v68 = qword_1EBFFC388;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.a) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_ERROR, "Invalid source and/or destination buffer.", (uint8_t *)&buf, 2u);
      }
      buf.a = NAN;
      *(void *)int v113 = @"Invalid source and/or destination buffer.";
      sub_1DC306334((atomic_ullong *)v11, (uint64_t *)&buf, (CFTypeRef *)v113);
      goto LABEL_128;
    }
    CGFloat v61 = v123.origin.x;
    CGFloat v62 = v123.origin.y;
    CGFloat v63 = v123.size.width;
    CGFloat v64 = v123.size.height;
    v111[0] = &unk_1F3662710;
    int v112 = v111;
    v110[0] = &unk_1F3662790;
    v110[3] = v110;
    buf.a = v87;
    sub_1DC31AD78((uint64_t)&buf.b, (uint64_t)v110);
    if (*(unsigned char *)(*(void *)&buf.a + 8) && v112) {
      sub_1DC31AE10((uint64_t)v112, **(void **)&buf.a);
    }
    sub_1DC31AE60(v110);
    sub_1DC31AE60(v111);
    atomic_ullong v98 = 0;
    v124.origin.CGFloat x = v61;
    v124.origin.CGFloat y = v62;
    v124.size.double width = v63;
    v124.size.double height = v64;
    *(void *)int v113 = CGRectCreateDictionaryRepresentation(v124);
    BOOL v65 = (const void *)atomic_exchange(&v98, atomic_exchange((atomic_ullong *volatile)v113, 0));
    if (v65) {
      CFRelease(v65);
    }
    sub_1DC31EBFC((atomic_ullong *)v113);
    atomic_ullong v97 = 0;
    v125.origin.CGFloat x = v54;
    v125.origin.CGFloat y = v56;
    v125.size.double width = v58;
    v125.size.double height = v60;
    *(void *)int v113 = CGRectCreateDictionaryRepresentation(v125);
    uint64_t v66 = (const void *)atomic_exchange(&v97, atomic_exchange((atomic_ullong *volatile)v113, 0));
    if (v66) {
      CFRelease(v66);
    }
    sub_1DC31EBFC((atomic_ullong *)v113);
    VTSessionSetProperty((VTSessionRef)atomic_load_explicit(v45, memory_order_acquire), propertyKey, (CFTypeRef)atomic_load_explicit(&v98, memory_order_acquire));
    VTSessionSetProperty((VTSessionRef)atomic_load_explicit(v45, memory_order_acquire), v85, (CFTypeRef)atomic_load_explicit(&v97, memory_order_acquire));
    OSStatus v67 = VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)atomic_load_explicit(v45, memory_order_acquire), (CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire), (CVPixelBufferRef)atomic_load_explicit(&v94, memory_order_acquire));
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    int v68 = qword_1EBFFC388;
    if (v67)
    {
      if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v113 = 67240192;
        *(_DWORD *)&v113[4] = v67;
        _os_log_error_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionTransferImage failed: %{public}d", v113, 8u);
      }
      *(void *)int v113 = -2004;
      propertyValueOut = @"VTPixelTransferSessionTransferImage failed.";
      sub_1DC306334((atomic_ullong *)v11, (uint64_t *)v113, (CFTypeRef *)&propertyValueOut);
      *(void *)int v113 = CFErrorCreate(allocator, v83, v67, 0);
      uint64_t v69 = (const void *)atomic_exchange((atomic_ullong *volatile)(v11 + 64), atomic_exchange((atomic_ullong *volatile)v113, 0));
      if (v69) {
        CFRelease(v69);
      }
      sub_1DC306854((atomic_ullong *)v113);
    }
    else if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_DEBUG))
    {
      propertyValueOut = 0;
      if (!VTSessionCopyProperty((VTSessionRef)atomic_load_explicit(v45, memory_order_acquire), v82, allocator, &propertyValueOut))
      {
        int v70 = propertyValueOut;
        if (propertyValueOut)
        {
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int v113 = 138543362;
            *(void *)&v113[4] = v70;
            _os_log_debug_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_DEBUG, "PixelTransferSession: mostRecentConversionType: %{public}@", v113, 0xCu);
            int v70 = propertyValueOut;
          }
          CFRelease(v70);
        }
      }
      uint64_t v99 = 0;
      if (!VTSessionCopyProperty((VTSessionRef)atomic_load_explicit(v45, memory_order_acquire), v81, allocator, &v99))
      {
        unint64_t v71 = v99;
        if (v99)
        {
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int v113 = 138543362;
            *(void *)&v113[4] = v71;
            _os_log_debug_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_DEBUG, "PixelTransferSession: mostRecentChainDescription: %{public}@", v113, 0xCu);
            unint64_t v71 = v99;
          }
          CFRelease(v71);
        }
      }
    }
    sub_1DC31EBFC(&v97);
    sub_1DC31EBFC(&v98);
    if (*(unsigned char *)(*(void *)&buf.a + 8) && *(void *)&buf.tx) {
      sub_1DC31AE10(*(uint64_t *)&buf.tx, **(void **)&buf.a);
    }
    sub_1DC31AE60(&buf.b);
    if (v67) {
      goto LABEL_128;
    }
    sub_1DC32D8E8((atomic_ullong *)&v96, (CFTypeRef)atomic_load_explicit(&v94, memory_order_acquire));
    v95.origin.CGFloat x = v54;
    v95.origin.CGFloat y = v56;
    v95.size.double width = v58;
    v95.size.double height = v60;
    sub_1DC307370(&v94);
    BOOL v48 = ++v49 >= Count;
    if (Count == v49) {
      goto LABEL_117;
    }
  }
  if (qword_1EBFFC380 != -1) {
    dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
  }
  int v68 = qword_1EBFFC388;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.a) = 0;
    _os_log_error_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_ERROR, "Invalid pixel transfer session.", (uint8_t *)&buf, 2u);
  }
  buf.a = NAN;
  *(void *)int v113 = @"Invalid pixel transfer session.";
  sub_1DC306334((atomic_ullong *)v11, (uint64_t *)&buf, (CFTypeRef *)v113);
LABEL_128:
  if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf.a) = 134349056;
    *(void *)((char *)&buf.a + 4) = v49;
    _os_log_error_impl(&dword_1DC2FE000, v68, OS_LOG_TYPE_ERROR, "Failed to transfer image at level #%{public}ld.", (uint8_t *)&buf, 0xCu);
  }
  sub_1DC307370(&v94);
  sub_1DC307370((atomic_ullong *)&v96);
  if (v48) {
    goto LABEL_131;
  }
  char v43 = 0;
LABEL_134:
  CFTypeRef v88 = v43;
  sub_1DC3065EC(&v89);
LABEL_135:
  sub_1DC307370((atomic_ullong *)&v90);
  if (v93) {
    sub_1DC3836F8(v91, v92);
  }
LABEL_137:
  if (*(unsigned char *)(*(void *)&v108[0] + 8) && v109) {
    sub_1DC31AE10(v109, **(void **)&v108[0]);
  }
  sub_1DC31AE60(&v108[1]);
LABEL_141:
  std::wstring::value_type v72 = (const void *)atomic_exchange(*(atomic_ullong *volatile *)(a1 + 16), atomic_exchange((atomic_ullong *volatile)&v88, 0));
  if (v72) {
    CFRelease(v72);
  }
  __n128 result = sub_1DC3065EC((atomic_ullong *)&v88);
  if (!atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 16), memory_order_acquire)
    || *(unsigned char *)(*(void *)(a1 + 8) + 96))
  {
    if (qword_1EBFFC380 != -1) {
      dispatch_once(&qword_1EBFFC380, &unk_1F36624C8);
    }
    uint64_t v5 = qword_1EBFFC388;
    __n128 result = (atomic_ullong *)os_log_type_enabled((os_log_t)qword_1EBFFC388, OS_LOG_TYPE_ERROR);
    if (result)
    {
      uint64_t v73 = *(void *)(a1 + 8);
      if (*(unsigned char *)(v73 + 96))
      {
        sub_1DC390B4C((uint64_t)&buf, v73);
      }
      else
      {
        buf.a = NAN;
        memset(&buf.b, 0, 40);
        BYTE4(buf.d) = 0;
        long long v102 = 0u;
        long long v103 = 0u;
        BYTE4(v102) = 0;
        long long v104 = 0u;
      }
      sub_1DC390F7C((CFErrorRef *)v111, (uint64_t)&buf);
      unint64_t v74 = atomic_load_explicit((atomic_ullong *volatile)v111, memory_order_acquire);
      LODWORD(v108[0]) = 138543362;
      *(void *)((char *)v108 + 4) = v74;
      unint64_t v35 = "Cannot generate pyramid: %{public}@";
      goto LABEL_153;
    }
  }
  return result;
}

void sub_1DC33B820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,atomic_ullong a24,atomic_ullong a25,atomic_ullong *a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a28) {
    sub_1DC3836F8(a26, a27);
  }
  if (*(unsigned char *)(a59 + 8))
  {
    if (a63) {
      sub_1DC31AE10(a63, *(void *)a59);
    }
  }
  sub_1DC31AE60(a21);
  _Unwind_Resume(a1);
}

__n128 sub_1DC33BA50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3663430;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC33BA88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1F3663430;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void sub_1DC33BAE4()
{
}

atomic_ullong *sub_1DC33BAFC@<X0>(uint64_t a1@<X0>, CFErrorRef *a2@<X8>)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  LOBYTE(v4[0]) = 0;
  char v5 = 0;
  v6[0] = &unk_1F3663DC0;
  v6[1] = v4;
  v6[3] = v6;
  sub_1DC335ACC(a1, v6);
  __n128 result = sub_1DC336090(v6);
  if (v5)
  {
    __n128 result = sub_1DC390F7C(a2, (uint64_t)v4);
    if (v5) {
      return sub_1DC390B00(v4);
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_1DC33BBBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a21) {
    sub_1DC390B00(&a9);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC33BBE8()
{
  return &unk_1F3663E20;
}

uint64_t sub_1DC33BBF4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc24PyramidGenerationSessionILNS_25PyramidGenerationBehaviorE1EE19preflightForContextERNS_7ContextEEUlOT_OT0_E_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC33BC30(atomic_ullong *result, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a2 + 8)) {
    return sub_1DC3070F0((atomic_ullong *)result[1], a3);
  }
  return result;
}

uint64_t sub_1DC33BC50(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3663DC0;
  a2[1] = v2;
  return result;
}

void *sub_1DC33BC74(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3663DC0;
  result[1] = v3;
  return result;
}

void sub_1DC33BCBC()
{
}

uint64_t sub_1DC33BCD4(uint64_t a1, int a2)
{
  if (a2 >= 0x21)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "cannot read <1 or >32 bits");
    goto LABEL_19;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 16);
  int v5 = *(_DWORD *)(a1 + 40);
  int v4 = *(_DWORD *)(a1 + 44);
  if (8 * (*(_DWORD *)(v2 + 24) - (int)v3 - v5) - v4 < a2)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "reading more bits than are available");
LABEL_19:
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  if (v4 < 1)
  {
    uint64_t v7 = 0;
  }
  else
  {
    if (8 - v4 >= a2) {
      int v6 = a2;
    }
    else {
      int v6 = 8 - v4;
    }
    uint64_t v7 = ((0xFFu >> (8 - v6) << (8 - v4 - v6)) & *(unsigned __int8 *)(v3 + v5)) >> (8 - v4 - v6);
    a2 -= v6;
    v4 += v6;
    *(_DWORD *)(a1 + 44) = v4;
    if (v4 == 8)
    {
      int v4 = 0;
      *(void *)(a1 + 40) = ++v5;
    }
  }
  if (a2 >= 1)
  {
    if (a2 < 8) {
      goto LABEL_15;
    }
    unsigned int v8 = (unsigned __int8 *)(v3 + v5);
    do
    {
      unsigned int v9 = *v8++;
      uint64_t v7 = v9 | (v7 << 8);
      *(_DWORD *)(a1 + 40) = ++v5;
      a2 -= 8;
    }
    while (a2 > 7);
    if (a2)
    {
LABEL_15:
      uint64_t v7 = (((-1 << (8 - a2)) & *(unsigned __int8 *)(v3 + v5)) >> (8 - a2)) | (v7 << a2);
      *(_DWORD *)(a1 + 44) = v4 + a2;
    }
  }
  return v7;
}

void sub_1DC33BE3C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC33BE54(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a3;
  unint64_t v8 = a3[3];
  unsigned int v9 = (unsigned __int16 *)a3[2];
  if ((unsigned __int16 *)*a3 != v9 + 1
    || ((*(_OWORD *)&__s.__r_.__value_.__l.__data_ = xmmword_1DC3FDC20,
         __int32 v10 = sub_1DC33C304(v7, 7),
         (uint64_t v11 = wmemchr((__int32 *)&__s, v10, 4uLL)) != 0)
      ? (double v12 = v11)
      : (double v12 = (__int32 *)&__s.__r_.__value_.__r.__words[2]),
        (char *)v12 - (char *)&__s == 16))
  {
    unint64_t v13 = v7 + 4;
    if (v7 + 4 >= v8) {
      goto LABEL_17;
    }
    while (1)
    {
      uint64_t v14 = 0;
      int v15 = 0;
      unsigned int v16 = *(unsigned __int16 *)(v7 + 2);
      uint64_t v7 = v13;
      do
      {
        v15 += *(unsigned __int16 *)(v13 + v14);
        v14 += 2;
      }
      while (v14 != 14);
      if ((float)((float)v15 * 0.5) <= (float)v16)
      {
        *(_OWORD *)&__s.__r_.__value_.__l.__data_ = xmmword_1DC3FDC20;
        __int32 v17 = sub_1DC33C304(v13, 7);
        atomic_ullong v18 = wmemchr((__int32 *)&__s, v17, 4uLL);
        double v19 = v18 ? (std::string::size_type *)v18 : &__s.__r_.__value_.__r.__words[2];
        if ((char *)v19 - (char *)&__s != 16) {
          break;
        }
      }
      v13 += 4;
      if (v7 + 4 >= v8) {
        goto LABEL_17;
      }
    }
  }
  unint64_t v13 = v7;
LABEL_17:
  if (v13 >= v8)
  {
    *(_DWORD *)a4 = 1;
    *(void *)(a4 + 104) = 0;
    *(void *)(a4 + 112) = 0;
    *(_OWORD *)(a4 + 4) = 0u;
    *(_OWORD *)(a4 + 20) = 0u;
    *(_OWORD *)(a4 + 36) = 0u;
    *(_OWORD *)(a4 + 52) = 0u;
    *(_OWORD *)(a4 + 68) = 0u;
    *(void *)(a4 + 84) = 0;
    *(void *)(a4 + 96) = a4 + 104;
    *(unsigned char *)(a4 + 120) = 0;
    *(_DWORD *)(a4 + 124) = 0;
    *(_DWORD *)(a4 + 128) = 0;
  }
  else
  {
    if (v9 == (unsigned __int16 *)v13)
    {
      unsigned int v20 = 0;
    }
    else
    {
      unsigned int v20 = 0;
      int v21 = v9;
      do
      {
        int v22 = *v21++;
        v20 += v22;
      }
      while (v21 != (unsigned __int16 *)v13);
    }
    uint64_t v23 = 0;
    unsigned int v24 = 0;
    do
    {
      v24 += *(unsigned __int16 *)(v13 + v23);
      v23 += 2;
    }
    while (v23 != 14);
    memset(&__s, 0, sizeof(__s));
    std::string::reserve(&__s, 0x14uLL);
    __int32 v25 = sub_1DC33C304(v13, 7);
    std::string::value_type v26 = sub_1DC33C458(v25);
    std::string::push_back(&__s, v26);
    std::string::size_type size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
    char v28 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __s.__r_.__value_.__l.__size_;
    }
    else {
      p_s = &__s;
    }
    if (p_s->__r_.__value_.__s.__data_[size - 1] - 65 <= 3 && v13 + 14 < v8)
    {
      unint64_t v30 = (unsigned __int16 *)(v13 + 16);
      while ((unint64_t)v30 <= v8 && v24 >> 1 > *(v30 - 1))
      {
        __int32 v31 = sub_1DC33C304((uint64_t)v30, 7);
        std::string::value_type v32 = sub_1DC33C458(v31);
        std::string::push_back(&__s, v32);
        char v28 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
        std::string::size_type v34 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
        {
          int v35 = *(char *)(__s.__r_.__value_.__r.__words[0] + __s.__r_.__value_.__l.__size_ - 1);
          if (v35 < 0) {
            break;
          }
        }
        else
        {
          int v35 = *(&v48 + HIBYTE(__s.__r_.__value_.__r.__words[2]));
          if (v35 < 0) {
            break;
          }
        }
        if (v35 - 65 <= 3)
        {
          if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v34 = __s.__r_.__value_.__l.__size_;
          }
          if ((int)v34 < 4) {
            break;
          }
          if (v30 + 7 != (unsigned __int16 *)(v8 - 2))
          {
            uint64_t v37 = 0;
            int v38 = 0;
            LOWORD(v33) = v30[7];
            float v39 = (float)v33;
            do
              v38 += v30[v37++];
            while (v37 != 7);
            if ((float)((float)v38 * 0.5) > v39) {
              break;
            }
          }
          if (!*(unsigned char *)(a1 + 8))
          {
            std::string::basic_string(&v47, &__s, 1uLL, v34 - 2, (std::allocator<char> *)&v48);
            if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__s.__r_.__value_.__l.__data_);
            }
            std::string __s = v47;
          }
          if (v9 == v30)
          {
            int v43 = -1;
          }
          else
          {
            int v40 = 0;
            uint64_t v41 = v9 - 1;
            do
            {
              int v42 = v41[1];
              ++v41;
              v40 += v42;
            }
            while (v41 != v30 - 1);
            int v43 = v40 - 1;
          }
          int v44 = 0;
          uint64_t v45 = 7;
          do
          {
            int v46 = *v30++;
            v44 += v46;
            --v45;
          }
          while (v45);
          memset(&v47, 0, sizeof(v47));
          sub_1DC3CA23C(a4, (unsigned __int8 *)&__s, a2, v20, v43 + v44, (uint64_t)&v47);
          if (v47.__r_.__value_.__r.__words[0]) {
            operator delete(v47.__r_.__value_.__l.__data_);
          }
          if ((*((unsigned char *)&__s.__r_.__value_.__s + 23) & 0x80) == 0) {
            return;
          }
          goto LABEL_49;
        }
        CFTypeRef v36 = v30 + 7;
        v30 += 8;
        if ((unint64_t)v36 >= v8) {
          break;
        }
      }
    }
    *(_DWORD *)a4 = 1;
    *(void *)(a4 + 104) = 0;
    *(void *)(a4 + 112) = 0;
    *(_OWORD *)(a4 + 4) = 0u;
    *(_OWORD *)(a4 + 20) = 0u;
    *(_OWORD *)(a4 + 36) = 0u;
    *(_OWORD *)(a4 + 52) = 0u;
    *(_OWORD *)(a4 + 68) = 0u;
    *(void *)(a4 + 84) = 0;
    *(void *)(a4 + 96) = a4 + 104;
    *(unsigned char *)(a4 + 120) = 0;
    *(_DWORD *)(a4 + 124) = 0;
    *(_DWORD *)(a4 + 128) = 0;
    if (v28 < 0) {
LABEL_49:
    }
      operator delete(__s.__r_.__value_.__l.__data_);
  }
}

void sub_1DC33C2CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC33C304(uint64_t a1, int a2)
{
  int v20 = 0;
  int v21 = -1;
  if (a2 >= 1)
  {
    for (uint64_t i = 0; i != a2; *((_WORD *)&v20 + (i++ & 1)) = v3)
    {
      unsigned int v3 = *(unsigned __int16 *)(a1 + 2 * i);
      unsigned int v4 = *((unsigned __int16 *)&v21 + (i & 1));
      if (v3 < v4) {
        LOWORD(v4) = *(_WORD *)(a1 + 2 * i);
      }
      *((_WORD *)&v21 + (i & 1)) = v4;
      if (*((unsigned __int16 *)&v20 + (i & 1)) > v3) {
        LOWORD(v3) = *((_WORD *)&v20 + (i & 1));
      }
    }
  }
  uint64_t v5 = 0;
  unsigned int v19 = 0;
  char v6 = 1;
  do
  {
    unsigned int v7 = *((unsigned __int16 *)&v20 + v5);
    char v8 = v6;
    unsigned int v9 = *((unsigned __int16 *)&v21 + v5);
    if (4 * v9 + 4 < v7
      || 3 * *((unsigned __int16 *)&v20 + (v5 ^ 1)) < v7
      || 2 * *((unsigned __int16 *)&v21 + (v5 ^ 1)) + 2 < v9)
    {
      return 0xFFFFFFFFLL;
    }
    char v6 = 0;
    unsigned int v10 = (v9 + v7) >> 1;
    if (v10 <= (3 * v9) >> 1) {
      __int16 v11 = (3 * v9) >> 1;
    }
    else {
      __int16 v11 = v10;
    }
    *((_WORD *)&v19 + v5) = v11;
    uint64_t v5 = 1;
  }
  while ((v8 & 1) != 0);
  int v21 = v19;
  if ((_WORD)v19) {
    BOOL v12 = v19 >= 0x10000;
  }
  else {
    BOOL v12 = 0;
  }
  int v13 = !v12;
  uint64_t v14 = (v13 << 31 >> 31);
  if (v12 && a2 >= 1)
  {
    uint64_t v15 = 0;
    LODWORD(v14) = 0;
    while (1)
    {
      unsigned int v16 = *(unsigned __int16 *)(a1 + 2 * v15);
      unsigned int v17 = *(unsigned __int16 *)((unint64_t)&v21 & 0xFFFFFFFFFFFFFFFDLL | (2 * (v15 & 1)));
      if (v16 > 2 * v17) {
        break;
      }
      uint64_t v14 = (v16 > v17) | (2 * v14);
      if (a2 == ++v15) {
        return v14;
      }
    }
    return 0xFFFFFFFFLL;
  }
  return v14;
}

uint64_t sub_1DC33C458(__int32 __c)
{
  BOOL v1 = wmemchr(dword_1DC40744C, __c, 0x14uLL);
  uint64_t v2 = &dword_1DC40744C[20];
  if (v1) {
    uint64_t v2 = v1;
  }
  unint64_t v3 = (char *)v2 - (char *)dword_1DC40744C;
  if (v3 == 80 || (v3 & 0x3FFFFFFFCLL) == 0x3FFFFFFFCLL) {
    return -1;
  }
  else {
    return a0123456789Abcd[(int)(v3 >> 2)];
  }
}

void sub_1DC33C4CC(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, uint64_t *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v129 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *a4;
  if (!*a4) {
    operator new();
  }
  std::string __p = 0;
  CGRect v125 = 0;
  unint64_t v126 = 0;
  sub_1DC329ED4(&__p, 0x50uLL);
  __int16 v11 = *(unsigned char **)a3;
  unsigned int v10 = *(unsigned char **)(a3 + 8);
  if (v10 == *(unsigned char **)a3) {
    goto LABEL_60;
  }
  while (*v11)
  {
    if (++v11 == v10)
    {
      __int16 v11 = *(unsigned char **)(a3 + 8);
      break;
    }
  }
  if (v11 == v10) {
    goto LABEL_60;
  }
  uint64_t v114 = a1;
  uint64_t v112 = v9;
  unsigned int v113 = a2;
  unint64_t v12 = v126;
  int v13 = __p;
  uint64_t v14 = v11;
  while (1)
  {
    int v15 = *v11 == 0;
    unsigned int v16 = &v11[v10 - v14];
    while (*v11 != v15)
    {
      if (++v11 == v10)
      {
        __int16 v11 = v16;
        break;
      }
    }
    unsigned int v17 = v125;
    if (v11 == v10) {
      break;
    }
    int v18 = v11 - v14;
    if ((unint64_t)v125 >= v12)
    {
      uint64_t v20 = (v125 - v13) >> 2;
      unint64_t v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 62) {
        goto LABEL_165;
      }
      if ((uint64_t)(v12 - (void)v13) >> 1 > v21) {
        unint64_t v21 = (uint64_t)(v12 - (void)v13) >> 1;
      }
      if (v12 - (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v21;
      }
      if (v22) {
        unint64_t v22 = (unint64_t)sub_1DC314E5C(v22);
      }
      else {
        uint64_t v23 = 0;
      }
      unsigned int v24 = (char *)(v22 + 4 * v20);
      *(_DWORD *)unsigned int v24 = v18;
      unsigned int v19 = v24 + 4;
      while (v17 != v13)
      {
        int v25 = *((_DWORD *)v17 - 1);
        v17 -= 4;
        *((_DWORD *)v24 - 1) = v25;
        v24 -= 4;
      }
      unint64_t v12 = v22 + 4 * v23;
      std::string __p = v24;
      unint64_t v126 = v12;
      if (v13) {
        operator delete(v13);
      }
      int v13 = v24;
    }
    else
    {
      *(_DWORD *)CGRect v125 = v18;
      unsigned int v19 = v17 + 4;
    }
    CGRect v125 = v19;
    unsigned int v10 = *(unsigned char **)(a3 + 8);
    uint64_t v14 = v11;
    if (v10 == v11) {
      goto LABEL_34;
    }
  }
  unsigned int v19 = v125;
LABEL_34:
  int v26 = v11 - v14;
  if ((unint64_t)v19 >= v12)
  {
    uint64_t v29 = (v19 - v13) >> 2;
    unint64_t v30 = v29 + 1;
    if ((unint64_t)(v29 + 1) >> 62) {
LABEL_165:
    }
      sub_1DC2FF97C();
    if ((uint64_t)(v12 - (void)v13) >> 1 > v30) {
      unint64_t v30 = (uint64_t)(v12 - (void)v13) >> 1;
    }
    if (v12 - (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v31 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v31 = v30;
    }
    if (v31) {
      unint64_t v31 = (unint64_t)sub_1DC314E5C(v31);
    }
    else {
      uint64_t v32 = 0;
    }
    uint64_t v27 = (_DWORD *)(v31 + 4 * v29);
    *uint64_t v27 = v26;
    uint64_t v28 = (uint64_t)(v27 + 1);
    while (v19 != v13)
    {
      int v33 = *((_DWORD *)v19 - 1);
      v19 -= 4;
      *--uint64_t v27 = v33;
    }
    std::string __p = v27;
    unint64_t v126 = v31 + 4 * v32;
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *(_DWORD *)unsigned int v19 = v26;
    uint64_t v27 = __p;
    uint64_t v28 = (uint64_t)(v19 + 4);
  }
  CGRect v125 = (char *)v28;
  uint64_t v123 = 0;
  if ((int)((unint64_t)(v28 - (void)v27) >> 2) < 2) {
    goto LABEL_60;
  }
  uint64_t v34 = 1;
  int v35 = v27;
  uint64_t v36 = 1;
  while (1)
  {
    int v37 = sub_1DC33CF14((uint64_t)v27, v28, v36, (float *)&v123 + 1);
    if ((v37 & 0x80000000) == 0)
    {
      int v38 = memchr("ABCD", a0123456789Abcd[v37], 5uLL);
      if (v38)
      {
        if (((v38 - "ABCD") & 0x80000000) == 0)
        {
          int v39 = 0;
          for (uint64_t i = 1; i != 8; ++i)
            v39 += v35[i];
          if (v36 == 1) {
            goto LABEL_65;
          }
          if (v27[v36 - 1] >= v39 / 2) {
            break;
          }
        }
      }
    }
    v36 += 2;
    v35 += 2;
    if (v36 >= (int)((v28 - (uint64_t)v27) >> 2)) {
      goto LABEL_60;
    }
  }
  uint64_t v34 = v36;
  if ((v36 & 0x80000000) != 0)
  {
LABEL_60:
    *(_DWORD *)a5 = 1;
    *(void *)(a5 + 104) = 0;
    *(void *)(a5 + 112) = 0;
    *(_OWORD *)(a5 + 4) = 0u;
    *(_OWORD *)(a5 + 20) = 0u;
    *(_OWORD *)(a5 + 36) = 0u;
    *(_OWORD *)(a5 + 52) = 0u;
    *(_OWORD *)(a5 + 68) = 0u;
    *(void *)(a5 + 84) = 0;
    *(void *)(a5 + 96) = a5 + 104;
    *(unsigned char *)(a5 + 120) = 0;
    *(_DWORD *)(a5 + 124) = 0;
    *(_DWORD *)(a5 + 128) = 0;
    goto LABEL_61;
  }
LABEL_65:
  uint64_t v111 = v34;
  CGRect v120 = 0;
  CGRect v121 = 0;
  unint64_t v122 = 0;
  sub_1DC329ED4(&v120, 0x14uLL);
  unsigned int v41 = v36 + 7;
  int v42 = __p;
  uint64_t v116 = (uint64_t)v125;
  unint64_t v115 = (unint64_t)(v125 - (unsigned char *)__p) >> 2;
  unint64_t v43 = v122;
  int v44 = v36;
  while (1)
  {
    int v45 = v44;
    unsigned int v117 = v41;
    int v46 = v42;
    int v47 = sub_1DC33CF14((uint64_t)v42, v116, v44, (float *)&v123);
    if (v47 < 0) {
      goto LABEL_93;
    }
    int v48 = v47;
    CFIndex v49 = v121;
    if ((unint64_t)v121 >= v43)
    {
      char v52 = (char *)v120;
      uint64_t v53 = (v121 - (unsigned char *)v120) >> 2;
      unint64_t v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 62) {
        sub_1DC2FF97C();
      }
      if ((uint64_t)(v43 - (void)v120) >> 1 > v54) {
        unint64_t v54 = (uint64_t)(v43 - (void)v120) >> 1;
      }
      if (v43 - (unint64_t)v120 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v55 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v55 = v54;
      }
      if (v55) {
        unint64_t v55 = (unint64_t)sub_1DC314E5C(v55);
      }
      else {
        uint64_t v56 = 0;
      }
      uint64_t v50 = (int *)(v55 + 4 * v53);
      int *v50 = v48;
      size_t v51 = v50 + 1;
      while (v49 != v52)
      {
        int v57 = *((_DWORD *)v49 - 1);
        v49 -= 4;
        *--uint64_t v50 = v57;
      }
      unint64_t v43 = v55 + 4 * v56;
      CGRect v120 = v50;
      if (v52) {
        operator delete(v52);
      }
    }
    else
    {
      *(_DWORD *)CGRect v121 = v47;
      uint64_t v50 = (int *)v120;
      size_t v51 = (int *)(v49 + 4);
    }
    CGRect v121 = (char *)v51;
    int v44 = v45 + 8;
    if ((unint64_t)((char *)v51 - (char *)v50) >= 5)
    {
      CGFloat v58 = memchr("ABCD", a0123456789Abcd[v48], 5uLL);
      if (v58)
      {
        if (((v58 - "ABCD") & 0x80000000) == 0) {
          break;
        }
      }
    }
    unsigned int v41 = v117 + 8;
    int v42 = v46;
    if (v44 >= (int)v115)
    {
      unint64_t v122 = v43;
      goto LABEL_89;
    }
  }
  unint64_t v122 = v43;
  int v42 = __p;
LABEL_89:
  int v59 = 0;
  int v60 = v45 + 7;
  for (uint64_t j = 0x3FFFFFFFFFFFFFF8; j != -1; ++j)
    v59 += v42[v44 + j];
  int v62 = v59 + (v59 < 0);
  if (v44 < (int)((unint64_t)(v116 - (void)v42) >> 2) && v42[v60] < v62 >> 1)
  {
LABEL_93:
    *(_DWORD *)a5 = 1;
    *(void *)(a5 + 104) = 0;
    *(void *)(a5 + 112) = 0;
    *(_OWORD *)(a5 + 4) = 0u;
    *(_OWORD *)(a5 + 20) = 0u;
    *(_OWORD *)(a5 + 36) = 0u;
    *(_OWORD *)(a5 + 52) = 0u;
    *(_OWORD *)(a5 + 68) = 0u;
    *(void *)(a5 + 84) = 0;
    *(void *)(a5 + 96) = a5 + 104;
    *(unsigned char *)(a5 + 120) = 0;
    *(_DWORD *)(a5 + 124) = 0;
    *(_DWORD *)(a5 + 128) = 0;
    goto LABEL_94;
  }
  *(_OWORD *)&__str.__r_.__value_.__l.__data_ = 0uLL;
  *(_OWORD *)&v118.__r_.__value_.__l.__data_ = 0uLL;
  if (v50 != v51)
  {
    CGFloat v63 = v50;
    CGFloat v64 = (char *)&v42[v111];
    do
    {
      int v65 = dword_1DC40744C[*v63];
      for (uint64_t k = 6; k != -1; --k)
      {
        unsigned int v67 = k & 1 | (2 * (v65 & 1));
        *((_DWORD *)&__str.__r_.__value_.__l.__data_ + v67) += *(_DWORD *)&v64[4 * k];
        ++*((_DWORD *)&v118.__r_.__value_.__l.__data_ + v67);
        v65 >>= 1;
      }
      ++v63;
      v64 += 32;
    }
    while (v63 != v51);
  }
  uint64_t v68 = 0;
  v127[0] = 0;
  char v69 = 1;
  do
  {
    char v70 = v69;
    uint64_t v71 = (4 * v68) | 8;
    float v72 = (float)*(int *)((char *)&__str.__r_.__value_.__l.__data_ + v71);
    float v73 = (float)*(int *)((char *)&v118.__r_.__value_.__l.__data_ + v71);
    float v74 = (float)((float)((float)*((int *)&__str.__r_.__value_.__l.__data_ + v68)
                        / (float)*((int *)&v118.__r_.__value_.__l.__data_ + v68))
                + (float)(v72 / v73))
        * 0.5;
    *(float *)((char *)v127 + v71) = v74;
    v128[v68] = v74;
    *(float *)((char *)v128 + v71) = (float)((float)(v72 * 2.0) + 1.5) / v73;
    uint64_t v68 = 1;
    char v69 = 0;
  }
  while ((v70 & 1) != 0);
  if (v50 != v51)
  {
    uint64_t v75 = v50;
    atomic_ullong v76 = (char *)&v42[v111];
LABEL_105:
    int v77 = dword_1DC40744C[*v75];
    uint64_t v78 = 6;
    while (1)
    {
      uint64_t v79 = v78 & 1 | (2 * (v77 & 1u));
      float v80 = (float)*(int *)&v76[4 * v78];
      if (*((float *)v127 + v79) > v80 || v128[v79] < v80) {
        goto LABEL_93;
      }
      v77 >>= 1;
      if (--v78 == -1)
      {
        ++v75;
        v76 += 32;
        if (v75 != v51) {
          goto LABEL_105;
        }
        break;
      }
    }
  }
  memset(&__str, 0, sizeof(__str));
  std::string::reserve(&__str, v51 - v50);
  while (v50 != v51)
    std::string::push_back(&__str, a0123456789Abcd[*v50++]);
  std::string::size_type v81 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  int v82 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  uint64_t v84 = memchr("ABCD", p_str->__r_.__value_.__s.__data_[0], 5uLL);
  if (!v84 || ((v84 - "ABCD") & 0x80000000) != 0) {
    goto LABEL_155;
  }
  std::string::size_type size = __str.__r_.__value_.__l.__size_;
  std::string::size_type v86 = v82 >= 0 ? v81 : __str.__r_.__value_.__l.__size_;
  CGFloat v87 = memchr("ABCD", p_str->__r_.__value_.__s.__data_[v86 - 1], 5uLL);
  if (!v87 || ((v87 - "ABCD") & 0x80000000) != 0 || (int)v86 <= 3) {
    goto LABEL_155;
  }
  if (!*(unsigned char *)(v114 + 8))
  {
    std::string::basic_string(&v118, &__str, 1uLL, v86 - 2, (std::allocator<char> *)v128);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    std::string __str = v118;
    std::string::size_type v81 = HIBYTE(v118.__r_.__value_.__r.__words[2]);
    std::string::size_type size = v118.__r_.__value_.__l.__size_;
    LOBYTE(v82) = *((unsigned char *)&v118.__r_.__value_.__s + 23);
  }
  int v88 = (char)v82;
  if ((v82 & 0x80u) == 0) {
    unint64_t v89 = v81;
  }
  else {
    unint64_t v89 = size;
  }
  if (v89 <= 7)
  {
    uint64_t v97 = *(void *)(v112 + 8);
    uint64_t v98 = *(void *)(v112 + 16);
    if (v97 != v98)
    {
      if (v88 >= 0) {
        uint64_t v99 = &__str;
      }
      else {
        uint64_t v99 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      do
      {
        int v100 = *(char *)(v97 + 23);
        unint64_t v101 = v100 >= 0 ? *(unsigned __int8 *)(v97 + 23) : *(void *)(v97 + 8);
        long long v102 = v100 >= 0 ? (const void *)v97 : *(const void **)v97;
        size_t v103 = v101 >= v89 ? v89 : v101;
        if (!memcmp(v99, v102, v103) && v101 == v89) {
          goto LABEL_132;
        }
        v97 += 24;
      }
      while (v97 != v98);
    }
    sub_1DC33D0A4((unint64_t *)(v112 + 8), (long long *)&__str);
LABEL_155:
    *(_DWORD *)a5 = 1;
    *(void *)(a5 + 104) = 0;
    *(void *)(a5 + 112) = 0;
    *(_OWORD *)(a5 + 4) = 0u;
    *(_OWORD *)(a5 + 20) = 0u;
    *(_OWORD *)(a5 + 36) = 0u;
    *(_OWORD *)(a5 + 52) = 0u;
    *(_OWORD *)(a5 + 68) = 0u;
    *(void *)(a5 + 84) = 0;
    *(void *)(a5 + 96) = a5 + 104;
    int v105 = 0;
    int v106 = 0;
    *(unsigned char *)(a5 + 120) = 0;
    goto LABEL_156;
  }
LABEL_132:
  if ((int)v36 < 1)
  {
    unsigned int v90 = 0;
    uint64_t v94 = v113;
    uint64_t v92 = v111;
    unsigned int v95 = v117;
  }
  else
  {
    unsigned int v90 = 0;
    unint64_t v91 = (int *)__p;
    uint64_t v92 = v111;
    uint64_t v93 = v111;
    uint64_t v94 = v113;
    unsigned int v95 = v117;
    do
    {
      int v96 = *v91++;
      v90 += v96;
      --v93;
    }
    while (v93);
  }
  unsigned int v107 = v90;
  if (v60 > (int)v36)
  {
    uint64_t v108 = v95 - v92;
    uint64_t v109 = (int *)((char *)__p + 4 * v92);
    unsigned int v107 = v90;
    do
    {
      int v110 = *v109++;
      v107 += v110;
      --v108;
    }
    while (v108);
  }
  memset(&v118, 0, sizeof(v118));
  sub_1DC3CA23C(a5, (unsigned __int8 *)&__str, v94, v90, v107, (uint64_t)&v118);
  if (v118.__r_.__value_.__r.__words[0]) {
    operator delete(v118.__r_.__value_.__l.__data_);
  }
  int v105 = HIDWORD(v123);
  int v106 = v123;
LABEL_156:
  *(_DWORD *)(a5 + 124) = v105;
  *(_DWORD *)(a5 + 128) = v106;
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
LABEL_94:
  if (v120) {
    operator delete(v120);
  }
LABEL_61:
  if (__p) {
    operator delete(__p);
  }
}

void sub_1DC33CEA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a25) {
    operator delete(a25);
  }
  if (a29) {
    operator delete(a29);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC33CF14(uint64_t a1, uint64_t a2, int a3, float *a4)
{
  if (a3 + 7 >= (int)((unint64_t)(a2 - a1) >> 2)) {
    return 0xFFFFFFFFLL;
  }
  int v4 = 0;
  uint64_t v5 = (__int32 *)(a1 + 4 * a3);
  v6.i32[0] = *v5;
  v6.i32[1] = v5[2];
  v6.i32[2] = v5[4];
  v6.i32[3] = v5[6];
  int32x4_t v7 = vmaxq_s32(v6, (int32x4_t)0);
  int v8 = vminvq_s32(v6);
  uint64_t v9 = a3 + 1;
  int v10 = 0x7FFFFFFF;
  do
  {
    int v11 = *(_DWORD *)(a1 + 4 * v9);
    if (v11 < v10) {
      int v10 = *(_DWORD *)(a1 + 4 * v9);
    }
    if (v11 > v4) {
      int v4 = *(_DWORD *)(a1 + 4 * v9);
    }
    v9 += 2;
  }
  while (v9 < a3 + 7);
  uint64_t v12 = 0;
  int v13 = 0;
  int v14 = 0;
  __int32 v15 = 0;
  int v16 = vmaxvq_s32(v7);
  int v17 = v8 + v16;
  char v32 = (v8 + v16 < 0) ^ __OFADD__(v8, v16);
  float v18 = (float)v8;
  if (v32) {
    int v19 = v17 + 1;
  }
  else {
    int v19 = v17;
  }
  float v20 = (float)v10;
  BOOL v21 = __OFADD__(v10, v4);
  int v22 = v10 + v4;
  if (v22 < 0 != v21) {
    ++v22;
  }
  int v23 = v22 >> 1;
  float v24 = v18 / 3.0;
  float v25 = v20 + 1.5;
  float v26 = v20 * 1.5;
  if (v25 >= v26) {
    float v26 = v25;
  }
  if (v24 < v26) {
    float v24 = v26;
  }
  if (v24 < (float)v4) {
    int v4 = v23;
  }
  int v27 = v19 >> 1;
  unsigned int v29 = 128;
  do
  {
    if (v12) {
      int v30 = v4;
    }
    else {
      int v30 = v27;
    }
    v29 >>= 1;
    uint64_t v28 = a1 + 4 * a3;
    int v31 = *(_DWORD *)(v28 + 4 * v12);
    char v32 = v31 <= v30;
    if (v31 > v30) {
      unsigned int v33 = v29;
    }
    else {
      unsigned int v33 = 0;
    }
    v15 |= v33;
    if (v32) {
      int v34 = *(_DWORD *)(v28 + 4 * v12);
    }
    else {
      int v34 = 0;
    }
    v14 += v34;
    if (v32) {
      ++v13;
    }
    ++v12;
  }
  while (v12 != 7);
  if (v13) {
    float v35 = (float)v14 / (float)v13;
  }
  else {
    float v35 = 0.0;
  }
  *a4 = v35;
  int v37 = wmemchr(dword_1DC40744C, v15, 0x14uLL);
  int v38 = &dword_1DC40744C[20];
  if (v37) {
    int v38 = v37;
  }
  unint64_t v39 = (char *)v38 - (char *)dword_1DC40744C;
  if (v39 == 80) {
    return 0xFFFFFFFFLL;
  }
  else {
    return (v39 >> 2);
  }
}

unint64_t *sub_1DC33D0A4(unint64_t *result, long long *a2)
{
  unint64_t v3 = result;
  unint64_t v4 = result[2];
  unint64_t v5 = result[1];
  if (v5 >= v4)
  {
    unint64_t v7 = *result;
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *result) >> 3);
    unint64_t v9 = v8 + 1;
    if (v8 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1DC2FF97C();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v7) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    int v22 = result + 2;
    if (v11)
    {
      if (v11 > 0xAAAAAAAAAAAAAAALL) {
        sub_1DC2FF994();
      }
      uint64_t v12 = (char *)operator new(24 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    int v14 = &v12[24 * v8];
    int v19 = v12;
    v20.i64[0] = (uint64_t)v14;
    v20.i64[1] = (uint64_t)v14;
    BOOL v21 = &v12[24 * v11];
    if (*((char *)a2 + 23) < 0)
    {
      sub_1DC312750(v14, *(void **)a2, *((void *)a2 + 1));
      unint64_t v7 = *v3;
      unint64_t v5 = v3[1];
      __int32 v15 = (char *)v20.i64[1];
      int v14 = (char *)v20.i64[0];
    }
    else
    {
      *(_OWORD *)int v14 = *a2;
      *((void *)v14 + 2) = *((void *)a2 + 2);
      __int32 v15 = &v12[24 * v8];
    }
    unint64_t v13 = (unint64_t)(v15 + 24);
    if (v5 == v7)
    {
      int64x2_t v17 = vdupq_n_s64(v7);
    }
    else
    {
      do
      {
        long long v16 = *(_OWORD *)(v5 - 24);
        *((void *)v14 - 1) = *(void *)(v5 - 8);
        *(_OWORD *)(v14 - 24) = v16;
        v14 -= 24;
        *(void *)(v5 - 16) = 0;
        *(void *)(v5 - 8) = 0;
        *(void *)(v5 - 24) = 0;
        v5 -= 24;
      }
      while (v5 != v7);
      int64x2_t v17 = *(int64x2_t *)v3;
    }
    unint64_t *v3 = (unint64_t)v14;
    v3[1] = v13;
    int64x2_t v20 = v17;
    unint64_t v18 = v3[2];
    v3[2] = (unint64_t)v21;
    BOOL v21 = (char *)v18;
    int v19 = (char *)v17.i64[0];
    __n128 result = (unint64_t *)sub_1DC33D27C((uint64_t)&v19);
  }
  else
  {
    if (*((char *)a2 + 23) < 0)
    {
      __n128 result = (unint64_t *)sub_1DC312750((unsigned char *)result[1], *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v6 = *a2;
      *(void *)(v5 + 16) = *((void *)a2 + 2);
      *(_OWORD *)unint64_t v5 = v6;
    }
    unint64_t v13 = v5 + 24;
    v3[1] = v5 + 24;
  }
  v3[1] = v13;
  return result;
}

void sub_1DC33D25C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC33D27C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC33D27C(uint64_t a1)
{
  unint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      unint64_t v4 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v4);
        unint64_t v4 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DC33D2E0(uint64_t a1)
{
  *(void *)a1 = &unk_1F3660FC8;
  BOOL v1 = (void **)(a1 + 8);
  sub_1DC33D358(&v1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC33D358(void ***a1)
{
  BOOL v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0) {
          operator delete(*(v4 - 3));
        }
        v4 -= 3;
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1DC33D3E4(uint64_t a1)
{
  *(void *)a1 = &unk_1F3660FC8;
  unint64_t v3 = (void **)(a1 + 8);
  sub_1DC33D358(&v3);
  return a1;
}

void sub_1DC33D43C()
{
}

void sub_1DC33D454()
{
}

void sub_1DC33D568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1E019CE90](v14, 0xD0C40BFC0A3C0);
  _Unwind_Resume(a1);
}

uint64_t **sub_1DC33D5A8(uint64_t **a1, int a2, _DWORD *a3)
{
  long long v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = *v7;
        long long v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        long long v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = a1 + 1;
LABEL_9:
    unint64_t v9 = (uint64_t *)v7;
    unint64_t v7 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[5] = 0;
    NSObject *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    __CFString *v6 = (uint64_t *)v7;
    unint64_t v10 = (uint64_t *)**a1;
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v6;
    }
    sub_1DC311DD0(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_1DC33D678(uint64_t a1, void *a2, void *a3)
{
  unint64_t v5 = (void *)(a1 + 8);
  unint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unint64_t v7 = v4;
        int v8 = v4 + 4;
        if ((sub_1DC33D70C(a3, v4 + 4) & 0x80) == 0) {
          break;
        }
        unint64_t v4 = (void *)*v7;
        unint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if ((sub_1DC33D70C(v8, a3) & 0x80) == 0) {
        break;
      }
      unint64_t v5 = v7 + 1;
      unint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    unint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t sub_1DC33D70C(void *a1, void *a2)
{
  size_t v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }
  else
  {
    a1 = (void *)*a1;
    size_t v3 = v2;
  }
  size_t v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (void *)*a2;
    size_t v5 = v4;
  }
  if (v5 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v5;
  }
  int v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0) {
      return 1;
    }
  }
  else
  {
    if (v3 == v5) {
      return 0;
    }
    if (v3 >= v5) {
      return 1;
    }
  }
  return 255;
}

void sub_1DC33D78C()
{
}

void sub_1DC33DA28()
{
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EAA94BD8, memory_order_acquire) != -1)
  {
    CFAllocatorRef v0 = &v1;
    BOOL v1 = sub_1DC33D78C;
    std::__call_once(&qword_1EAA94BD8, &v0, (void (__cdecl *)(void *))sub_1DC33DA8C);
  }
}

uint64_t sub_1DC33DA8C(uint64_t (***a1)(void))
{
  return (**a1)();
}

uint64_t *sub_1DC33DA98(int a1)
{
  int v9 = a1;
  sub_1DC33DA28();
  if (a1 > 0x383) {
    goto LABEL_13;
  }
  uint64_t v2 = *(void *)(qword_1EAA94BC8 + 8);
  if (!v2) {
    goto LABEL_13;
  }
  uint64_t v3 = qword_1EAA94BC8 + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      size_t v6 = (uint64_t *)v2;
    }
    else {
      size_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == qword_1EAA94BC8 + 8 || *(_DWORD *)(v3 + 32) > a1)
  {
LABEL_13:
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    exception[2] = 0;
    exception[3] = 0;
    void *exception = &unk_1F3661188;
    exception[1] = 0;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
  }
  return sub_1DC33D5A8((uint64_t **)qword_1EAA94BC8, a1, &v9)[5];
}

uint64_t sub_1DC33DB6C(uint64_t a1)
{
  sub_1DC33DA28();
  uint64_t v2 = (uint64_t **)qword_1EAA94BD0;
  uint64_t v3 = qword_1EAA94BD0 + 8;
  int v4 = *(void **)(qword_1EAA94BD0 + 8);
  if (!v4) {
    goto LABEL_17;
  }
  uint64_t v5 = qword_1EAA94BD0 + 8;
  do
  {
    char v6 = sub_1DC33D70C(v4 + 4, (void *)a1);
    if (v6 >= 0) {
      int v7 = v4;
    }
    else {
      int v7 = v4 + 1;
    }
    if (v6 >= 0) {
      uint64_t v5 = (uint64_t)v4;
    }
    int v4 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v3 || (sub_1DC33D70C((void *)a1, (void *)(v5 + 32)) & 0x80) != 0)
  {
LABEL_17:
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    exception[2] = 0;
    exception[3] = 0;
    void *exception = &unk_1F3661188;
    exception[1] = 0;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
  }
  int v8 = (uint64_t **)sub_1DC33D678((uint64_t)v2, &v14, (void *)a1);
  int v9 = *v8;
  if (!*v8)
  {
    unint64_t v10 = v8;
    int v9 = (uint64_t *)operator new(0x40uLL);
    unint64_t v11 = v9 + 4;
    if (*(char *)(a1 + 23) < 0)
    {
      sub_1DC312750(v11, *(void **)a1, *(void *)(a1 + 8));
    }
    else
    {
      *(_OWORD *)unint64_t v11 = *(_OWORD *)a1;
      v9[6] = *(void *)(a1 + 16);
    }
    v9[7] = 0;
    sub_1DC311D78(v2, v14, v10, v9);
  }
  return v9[7];
}

void sub_1DC33DCB0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DC33DCC4()
{
}

BOOL sub_1DC33DCD4(uint64_t a1, atomic_ullong *a2)
{
  return atomic_load_explicit(a2, memory_order_acquire)
      && ((CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire)) - 875704422) & 0xFFFFFFEF) == 0;
}

BOOL sub_1DC33DD14(uint64_t a1, atomic_ullong *a2, uint64_t a3, __CFString *a4)
{
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1))
  {
    v108[0] = &unk_1F3664060;
    uint64_t v109 = v108;
    int v110 = a4;
    v107[0] = &unk_1F36640E0;
    v107[3] = v107;
    sub_1DC31AD78((uint64_t)v111, (uint64_t)v107);
    if (LOBYTE(v110->info)) {
      BOOL v8 = v109 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8) {
      sub_1DC31AE10((uint64_t)v109, (uint64_t)v110->isa);
    }
    sub_1DC31AE60(v107);
    sub_1DC31AE60(v108);
    if (atomic_load_explicit(a2, memory_order_acquire))
    {
      if ((CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire)) | 0x10) == 0x34323076)
      {
        char v101 = sub_1DC38379C(a2, a3);
        if (v101)
        {
          v125[0] = &unk_1F3664160;
          unint64_t v126 = v125;
          *(void *)CGRect v119 = &unk_1F36641E0;
          CGRect v120 = v119;
          CGRect v121 = a4;
          sub_1DC31AD78((uint64_t)v122, (uint64_t)v119);
          if (LOBYTE(v121->info) && v126) {
            sub_1DC31AE10((uint64_t)v126, (uint64_t)v121->isa);
          }
          sub_1DC31AE60(v119);
          sub_1DC31AE60(v125);
          OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
          if (PixelFormatType == 875704438)
          {
            unint64_t v10 = (unint64_t)&unk_1DC40FBF0;
          }
          else
          {
            if (PixelFormatType != 875704422)
            {
              uint64_t v18 = 0;
              unint64_t v17 = 0;
LABEL_44:
              src.data = CVPixelBufferGetBaseAddressOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
              src.double height = CVPixelBufferGetHeightOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
              src.double width = CVPixelBufferGetWidthOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
              src.rowBytes = CVPixelBufferGetBytesPerRowOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
              v105.data = CVPixelBufferGetBaseAddressOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 1uLL);
              v105.double height = CVPixelBufferGetHeightOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 1uLL);
              v105.double width = CVPixelBufferGetWidthOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 1uLL);
              v105.rowBytes = CVPixelBufferGetBytesPerRowOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 1uLL);
              long long v19 = *(_OWORD *)(a1 + 368);
              *(_OWORD *)&dest.data = *(_OWORD *)(a1 + 352);
              *(_OWORD *)&dest.double width = v19;
              long long v20 = *(_OWORD *)(a1 + 408);
              *(_OWORD *)&v103.data = *(_OWORD *)(a1 + 392);
              *(_OWORD *)&v103.double width = v20;
              *(unsigned char *)(a1 + 28) = 0;
              double width = (double)dest.width;
              double height = (double)dest.height;
              double v23 = (double)dest.width / (double)dest.height;
              if (vabdd_f64(1.0, v23) >= 2.22044605e-16)
              {
                double v24 = (double)src.width / (double)src.height;
                double v25 = 1.0 / v24;
                if (v24 <= v23)
                {
                  double v27 = ceil(v24 * height);
                  if (v24 >= v23) {
                    double v27 = (double)dest.width;
                  }
                  double v26 = (double)dest.height;
                }
                else
                {
                  double v26 = ceil(width / v24);
                  double v27 = (double)dest.width;
                }
                if (v25 <= v23)
                {
                  if (v25 < v23) {
                    double width = ceil(v25 * height);
                  }
                }
                else
                {
                  double height = ceil(width / v25);
                }
                if (v27 * v26 < width * height)
                {
                  uint64_t v99 = (_OWORD *)(a1 + 472);
                  unint64_t v100 = v17;
                  if (!*(unsigned char *)(a1 + 504))
                  {
                    *uint64_t v99 = 0u;
                    *(_OWORD *)(a1 + 488) = 0u;
                    *(unsigned char *)(a1 + 504) = 1;
                    unint64_t v55 = (void *)MEMORY[0x1E019D900]();
                    if (v55)
                    {
                      if (*(unsigned char *)(a1 + 504)) {
                        *(unsigned char *)(a1 + 504) = 0;
                      }
                      if (qword_1EBFFC360 != -1) {
                        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                      }
                      uint64_t v56 = qword_1EBFFC3B8;
                      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_INFO))
                      {
                        LODWORD(buf.data) = 134349056;
                        *(void **)((char *)&buf.data + 4) = v55;
                        _os_log_impl(&dword_1DC2FE000, v56, OS_LOG_TYPE_INFO, "vImageBuffer_Init failed for 90CW_420Yp8: %{public}zd", (uint8_t *)&buf, 0xCu);
                      }
                    }
                    else
                    {
                      if (qword_1EBFFC360 != -1) {
                        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                      }
                      uint64_t v66 = qword_1EBFFC3B8;
                      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_DEBUG))
                      {
                        vImagePixelCount v67 = *(void *)(a1 + 472);
                        size_t v68 = *(void *)(a1 + 480);
                        uint64_t v69 = *(void *)(a1 + 488);
                        uint64_t v70 = *(void *)(a1 + 496);
                        LODWORD(buf.data) = 136447234;
                        *(void **)((char *)&buf.data + 4) = "90CW_420Yp8";
                        WORD2(buf.height) = 2050;
                        *(vImagePixelCount *)((char *)&buf.height + 6) = v67;
                        HIWORD(buf.width) = 2050;
                        buf.rowBytes = v68;
                        *(_WORD *)uint64_t v116 = 2050;
                        *(void *)&v116[2] = v69;
                        __int16 v117 = 2050;
                        uint64_t v118 = v70;
                        _os_log_debug_impl(&dword_1DC2FE000, v66, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", (uint8_t *)&buf, 0x34u);
                      }
                    }
                  }
                  uint64_t v28 = (_OWORD *)(a1 + 512);
                  if (!*(unsigned char *)(a1 + 544))
                  {
                    *uint64_t v28 = 0u;
                    *(_OWORD *)(a1 + 528) = 0u;
                    *(unsigned char *)(a1 + 544) = 1;
                    int v57 = (void *)MEMORY[0x1E019D900](a1 + 512, *(void *)(a1 + 8) >> 1, *(void *)(a1 + 16) >> 1, 16, 0);
                    if (v57)
                    {
                      if (*(unsigned char *)(a1 + 544)) {
                        *(unsigned char *)(a1 + 544) = 0;
                      }
                      if (qword_1EBFFC360 != -1) {
                        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                      }
                      CGFloat v58 = qword_1EBFFC3B8;
                      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_INFO))
                      {
                        LODWORD(buf.data) = 134349056;
                        *(void **)((char *)&buf.data + 4) = v57;
                        _os_log_impl(&dword_1DC2FE000, v58, OS_LOG_TYPE_INFO, "vImageBuffer_Init failed for 90CW_420CbCr8: %{public}zd", (uint8_t *)&buf, 0xCu);
                      }
                    }
                    else
                    {
                      if (qword_1EBFFC360 != -1) {
                        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                      }
                      uint64_t v71 = qword_1EBFFC3B8;
                      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_DEBUG))
                      {
                        vImagePixelCount v72 = *(void *)(a1 + 512);
                        size_t v73 = *(void *)(a1 + 520);
                        uint64_t v74 = *(void *)(a1 + 528);
                        uint64_t v75 = *(void *)(a1 + 536);
                        LODWORD(buf.data) = 136447234;
                        *(void **)((char *)&buf.data + 4) = "90CW_420CbCr8";
                        WORD2(buf.height) = 2050;
                        *(vImagePixelCount *)((char *)&buf.height + 6) = v72;
                        HIWORD(buf.width) = 2050;
                        buf.rowBytes = v73;
                        *(_WORD *)uint64_t v116 = 2050;
                        *(void *)&v116[2] = v74;
                        __int16 v117 = 2050;
                        uint64_t v118 = v75;
                        _os_log_debug_impl(&dword_1DC2FE000, v71, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", (uint8_t *)&buf, 0x34u);
                      }
                    }
                  }
                  unint64_t v17 = v100;
                  if (*(unsigned char *)(a1 + 504) && *(unsigned char *)(a1 + 544))
                  {
                    *(unsigned char *)(a1 + 28) = 1;
                    long long v29 = *(_OWORD *)(a1 + 488);
                    *(_OWORD *)&dest.data = *v99;
                    *(_OWORD *)&dest.double width = v29;
                    long long v30 = *(_OWORD *)(a1 + 528);
                    *(_OWORD *)&v103.data = *v28;
                    *(_OWORD *)&v103.double width = v30;
                  }
                }
              }
              double v31 = (double)src.width / (double)src.height;
              double v32 = (double)dest.width / (double)dest.height;
              if (v31 <= v32)
              {
                if (v31 >= v32) {
                  goto LABEL_65;
                }
                p_double width = &dest.width;
                double v34 = v31 * (double)dest.height;
              }
              else
              {
                p_double width = &dest.height;
                double v34 = (double)dest.width / v31;
              }
              *p_double width = vcvtpd_u64_f64(v34);
LABEL_65:
              double v35 = (double)v105.width / (double)v105.height;
              double v36 = (double)v103.width / (double)v103.height;
              if (v35 <= v36)
              {
                if (v35 >= v36)
                {
LABEL_70:
                  unint64_t v39 = (void *)vImageScale_Planar8(&src, &dest, 0, 0);
                  if (v39 || (unint64_t v39 = (void *)vImageScale_CbCr8(&v105, &v103, 0, 0)) != 0)
                  {
                    if (qword_1EBFFC360 != -1) {
                      dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                    }
                    int v40 = qword_1EBFFC3B8;
                    if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                    {
                      LODWORD(buf.data) = 134349056;
                      *(void **)((char *)&buf.data + 4) = v39;
                      _os_log_error_impl(&dword_1DC2FE000, v40, OS_LOG_TYPE_ERROR, "vImageScale_{Planar8,CbCr8} failed: %{public}zd", (uint8_t *)&buf, 0xCu);
                    }
                    buf.data = (void *)-2004;
                    v114.data = @"vImageScale_{Planar8,CbCr8} failed.";
                    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, (CFTypeRef *)&v114.data);
                    goto LABEL_77;
                  }
                  int v47 = (Pixel_8 *)(v17 | v18);
                  int v48 = *(unsigned __int8 *)(a1 + 28);
                  if (*(unsigned char *)(a1 + 28))
                  {
                    Pixel_8 v49 = *v47;
                    int v50 = *(_DWORD *)((v17 | v18) + 4);
                    size_t v51 = *(void **)(a1 + 352);
                    *(int8x16_t *)&buf.double height = vextq_s8(*(int8x16_t *)&dest.height, *(int8x16_t *)&dest.height, 8uLL);
                    buf.rowBytes = *(void *)(a1 + 376);
                    char v52 = *(void **)(a1 + 392);
                    *(int8x16_t *)&v114.double height = vextq_s8(*(int8x16_t *)&v103.height, *(int8x16_t *)&v103.height, 8uLL);
                    size_t v53 = *(void *)(a1 + 416);
                    v114.data = v52;
                    v114.rowBytes = v53;
                    buf.data = v51;
                    unint64_t v39 = (void *)vImageRotate90_Planar8(&dest, &buf, 3u, v49, 0);
                    if (v39
                      || (unint64_t v39 = (void *)vImageRotate90_Planar16U(&v103, &v114, 3u, (unsigned __int16)v50 | (unsigned __int16)((_WORD)v50 << 8), 0)) != 0)
                    {
                      if (qword_1EBFFC360 != -1) {
                        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                      }
                      unint64_t v54 = qword_1EBFFC3B8;
                      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)unsigned int v113 = 134349056;
                        *(void *)&v113[4] = v39;
                        _os_log_error_impl(&dword_1DC2FE000, v54, OS_LOG_TYPE_ERROR, "vImageRotate90_{Planar8,Planar16U} failed: %{public}zd", v113, 0xCu);
                      }
                      *(void *)unsigned int v113 = -2004;
                      *(void *)color = @"vImageRotate90_{Planar8,Planar16U} failed.";
                      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v113, (CFTypeRef *)color);
                      goto LABEL_77;
                    }
                    int v48 = *(unsigned __int8 *)(a1 + 28);
                  }
                  BOOL v77 = v48 == 0;
                  if (v48) {
                    vImagePixelCount v78 = dest.height;
                  }
                  else {
                    vImagePixelCount v78 = dest.width;
                  }
                  if (v48) {
                    vImagePixelCount v79 = dest.width;
                  }
                  else {
                    vImagePixelCount v79 = dest.height;
                  }
                  *(void *)(a1 + 32) = v78;
                  *(void *)(a1 + 40) = v79;
                  vImagePixelCount v80 = v103.height;
                  if (v77) {
                    vImagePixelCount v81 = v103.width;
                  }
                  else {
                    vImagePixelCount v81 = v103.height;
                  }
                  if (!v77) {
                    vImagePixelCount v80 = v103.width;
                  }
                  *(void *)(a1 + 48) = v81;
                  *(void *)(a1 + 56) = v80;
                  vImagePixelCount v82 = *(void *)(a1 + 360);
                  if (v79 >= v82)
                  {
                    vImagePixelCount v88 = *(void *)(a1 + 368);
                    if (v78 < v88)
                    {
                      if (v82)
                      {
                        for (vImagePixelCount i = 0; i < v82; ++i)
                        {
                          vImagePixelCount v90 = *(void *)(a1 + 32);
                          if (v90 < v88)
                          {
                            do
                            {
                              *(unsigned char *)(*(void *)(a1 + 352) + i * *(void *)(a1 + 376) + v90++) = *(_DWORD *)v47;
                              vImagePixelCount v88 = *(void *)(a1 + 368);
                            }
                            while (v90 < v88);
                            vImagePixelCount v82 = *(void *)(a1 + 360);
                          }
                        }
                        vImagePixelCount v81 = *(void *)(a1 + 48);
                      }
                      vImagePixelCount v91 = *(void *)(a1 + 400);
                      buf.data = (void *)(*(void *)(a1 + 392) + 2 * v81);
                      buf.double height = v91;
                      size_t v92 = *(void *)(a1 + 416);
                      buf.double width = *(void *)(a1 + 408) - v81;
                      buf.rowBytes = v92;
                      color[0] = v47[4];
                      color[1] = color[0];
                      unint64_t v39 = (void *)vImageBufferFill_CbCr8(&buf, color, 0);
                      if (v39)
                      {
                        if (qword_1EBFFC360 != -1) {
                          dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                        }
                        uint64_t v93 = qword_1EBFFC3B8;
                        if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                        {
                          LODWORD(v114.data) = 134349056;
                          *(void **)((char *)&v114.data + 4) = v39;
                          _os_log_error_impl(&dword_1DC2FE000, v93, OS_LOG_TYPE_ERROR, "vImageBufferFill_CbCr8 failed: %{public}zd", (uint8_t *)&v114, 0xCu);
                        }
                        goto LABEL_179;
                      }
                    }
                  }
                  else
                  {
                    do
                      memset((void *)(*(void *)(a1 + 352) + *(void *)(a1 + 376) * v79++), *(_DWORD *)v47, *(void *)(a1 + 376));
                    while (v79 < *(void *)(a1 + 360));
                    uint64_t v83 = *(void *)(a1 + 56);
                    uint64_t v84 = *(void *)(a1 + 400);
                    vImagePixelCount v86 = *(void *)(a1 + 408);
                    size_t v85 = *(void *)(a1 + 416);
                    buf.data = (void *)(*(void *)(a1 + 392) + v85 * v83);
                    buf.double height = v84 - v83;
                    buf.double width = v86;
                    buf.rowBytes = v85;
                    color[0] = v47[4];
                    color[1] = color[0];
                    unint64_t v39 = (void *)vImageBufferFill_CbCr8(&buf, color, 0);
                    if (v39)
                    {
                      if (qword_1EBFFC360 != -1) {
                        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
                      }
                      CGFloat v87 = qword_1EBFFC3B8;
                      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
                      {
                        LODWORD(v114.data) = 134349056;
                        *(void **)((char *)&v114.data + 4) = v39;
                        _os_log_error_impl(&dword_1DC2FE000, v87, OS_LOG_TYPE_ERROR, "vImageBufferFill_CbCr8 failed: %{public}zd", (uint8_t *)&v114, 0xCu);
                      }
LABEL_179:
                      v114.data = (void *)-2004;
                      *(void *)unsigned int v113 = @"vImageBufferFill_CbCr8 failed.";
                      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&v114, (CFTypeRef *)v113);
LABEL_77:
                      int v41 = 0;
                      *(void *)(a3 + 32) = v39;
                      *(unsigned char *)(a3 + 40) = 1;
                      goto LABEL_78;
                    }
                  }
                  int v41 = 1;
LABEL_78:
                  if (LOBYTE(v121->info)) {
                    BOOL v42 = v124 == 0;
                  }
                  else {
                    BOOL v42 = 1;
                  }
                  if (!v42) {
                    sub_1DC31AE10(v124, (uint64_t)v121->isa);
                  }
                  sub_1DC31AE60(v122);
                  if (!v41)
                  {
                    BOOL v12 = 0;
LABEL_159:
                    sub_1DC3836F8(a2, a3);
LABEL_36:
                    if (LOBYTE(v110->info) && v112) {
                      sub_1DC31AE10(v112, (uint64_t)v110->isa);
                    }
                    sub_1DC31AE60(v111);
                    return v12;
                  }
                  OSType v43 = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
                  int v44 = *(_DWORD *)(a1 + 24);
                  CGRect v121 = (__CFString *)&unk_1F365F7B8;
                  uint64_t v123 = &v121;
                  v125[0] = &unk_1F365F810;
                  unint64_t v126 = v125;
                  buf.data = a4;
                  sub_1DC31AD78((uint64_t)&buf.height, (uint64_t)v125);
                  if (*((unsigned char *)buf.data + 8) && v123) {
                    sub_1DC31AE10((uint64_t)v123, *(void *)buf.data);
                  }
                  sub_1DC31AE60(v125);
                  sub_1DC31AE60(&v121);
                  if (!*(unsigned char *)(a1 + 192) || !*(unsigned char *)(a1 + 336))
                  {
                    if (qword_1EBFFC3D0 != -1) {
                      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                    }
                    int v46 = qword_1EBFFC3D8;
                    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)CGRect v119 = 0;
                      _os_log_error_impl(&dword_1DC2FE000, v46, OS_LOG_TYPE_ERROR, "YpCbCrToRGBImageConverter is not ready.", v119, 2u);
                    }
                    *(void *)CGRect v119 = -2005;
                    src.data = @"YpCbCrToRGBImageConverter is not ready.";
                    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v119, (CFTypeRef *)&src.data);
                    goto LABEL_154;
                  }
                  if ((v43 | 0x10) != 0x34323076)
                  {
                    if (qword_1EBFFC3D0 != -1) {
                      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                    }
                    int v59 = qword_1EBFFC3D8;
                    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)CGRect v119 = 67240192;
                      *(_DWORD *)&v119[4] = v43;
                      _os_log_error_impl(&dword_1DC2FE000, v59, OS_LOG_TYPE_ERROR, "Unsupported input pixel format type: %{public}u", v119, 8u);
                    }
                    *(void *)CGRect v119 = -2001;
                    src.data = @"Unsupported input pixel format type.";
                    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v119, (CFTypeRef *)&src.data);
                    goto LABEL_154;
                  }
                  if (v44 > 1111970368)
                  {
                    if (v44 == 1111970369) {
                      goto LABEL_129;
                    }
                    int v45 = 1380401729;
                  }
                  else
                  {
                    if (v44 == 32) {
                      goto LABEL_129;
                    }
                    int v45 = 1094862674;
                  }
                  if (v44 != v45)
                  {
                    if (qword_1EBFFC3D0 != -1) {
                      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                    }
                    atomic_ullong v76 = qword_1EBFFC3D8;
                    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)CGRect v119 = 67240192;
                      *(_DWORD *)&v119[4] = v44;
                      _os_log_error_impl(&dword_1DC2FE000, v76, OS_LOG_TYPE_ERROR, "Unsupported output pixel format type: %{public}u", v119, 8u);
                    }
                    *(void *)CGRect v119 = -2001;
                    src.data = @"Unsupported output pixel format type.";
                    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v119, (CFTypeRef *)&src.data);
                    goto LABEL_154;
                  }
LABEL_129:
                  if (*(void *)(a1 + 352)
                    && (unint64_t v60 = *(void *)(a1 + 360)) != 0
                    && (unint64_t v61 = *(void *)(a1 + 368), v61 - 1 < *(void *)(a1 + 376))
                    && *(void *)(a1 + 392)
                    && *(void *)(a1 + 400) == v60 >> 1
                    && (uint64_t v62 = *(void *)(a1 + 408), v62 == v61 >> 1)
                    && *(void *)(a1 + 416) >= (unint64_t)(2 * v62))
                  {
                    if (*(void *)(a1 + 432)
                      && *(void *)(a1 + 440) == v60
                      && *(void *)(a1 + 448) == v61
                      && *(void *)(a1 + 456) >= 4 * v61)
                    {
                      if (v43 == 875704438) {
                        unsigned int v95 = (const vImage_YpCbCrToARGB *)(a1 + 64);
                      }
                      else {
                        unsigned int v95 = (const vImage_YpCbCrToARGB *)(a1 + 208);
                      }
                      LODWORD(v105.data) = 50462976;
                      LODWORD(dest.data) = 66051;
                      LODWORD(v103.data) = 16909056;
                      LODWORD(v114.data) = 197121;
                      if (v44 > 1111970368)
                      {
                        if (v44 == 1380401729) {
                          p_vImage_Buffer dest = &v114;
                        }
                        else {
                          p_vImage_Buffer dest = &dest;
                        }
                      }
                      else if (v44 == 32)
                      {
                        p_vImage_Buffer dest = &v105;
                      }
                      else
                      {
                        p_vImage_Buffer dest = &v103;
                      }
                      vImage_Error v97 = vImageConvert_420Yp8_CbCr8ToARGB8888((const vImage_Buffer *)(a1 + 352), (const vImage_Buffer *)(a1 + 392), (const vImage_Buffer *)(a1 + 432), v95, (const uint8_t *)p_dest, 0xFFu, 0);
                      BOOL v12 = v97 == 0;
                      if (v97)
                      {
                        if (qword_1EBFFC3D0 != -1) {
                          dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                        }
                        uint64_t v98 = qword_1EBFFC3D8;
                        if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)CGRect v119 = 134349056;
                          *(void *)&v119[4] = v97;
                          _os_log_error_impl(&dword_1DC2FE000, v98, OS_LOG_TYPE_ERROR, "vImageConvert_420Yp8_CbCr8ToARGB8888 failed: %{public}zd", v119, 0xCu);
                        }
                        *(void *)CGRect v119 = -2005;
                        src.data = @"vImageConvert_420Yp8_CbCr8ToARGB8888 failed.";
                        sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v119, (CFTypeRef *)&src.data);
                        *(void *)(a3 + 32) = v97;
                        *(unsigned char *)(a3 + 40) = 1;
                      }
LABEL_155:
                      if (*((unsigned char *)buf.data + 8) && *(void *)v116) {
                        sub_1DC31AE10(*(uint64_t *)v116, *(void *)buf.data);
                      }
                      sub_1DC31AE60(&buf.height);
                      if (!v101) {
                        goto LABEL_36;
                      }
                      goto LABEL_159;
                    }
                    if (qword_1EBFFC3D0 != -1) {
                      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                    }
                    uint64_t v94 = qword_1EBFFC3D8;
                    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)CGRect v119 = 0;
                      _os_log_error_impl(&dword_1DC2FE000, v94, OS_LOG_TYPE_ERROR, "Invalid output image buffer.", v119, 2u);
                    }
                    *(void *)CGRect v119 = -2005;
                    src.data = @"Invalid output image buffer.";
                    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v119, (CFTypeRef *)&src.data);
                  }
                  else
                  {
                    if (qword_1EBFFC3D0 != -1) {
                      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                    }
                    CGFloat v63 = qword_1EBFFC3D8;
                    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)CGRect v119 = 0;
                      _os_log_error_impl(&dword_1DC2FE000, v63, OS_LOG_TYPE_ERROR, "Invalid input image buffer.", v119, 2u);
                    }
                    *(void *)CGRect v119 = -2005;
                    src.data = @"Invalid input image buffer.";
                    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v119, (CFTypeRef *)&src.data);
                  }
LABEL_154:
                  BOOL v12 = 0;
                  goto LABEL_155;
                }
                p_double height = &v103.width;
                double v38 = v35 * (double)v103.height;
              }
              else
              {
                p_double height = &v103.height;
                double v38 = (double)v103.width / v35;
              }
              *p_double height = vcvtpd_u64_f64(v38);
              goto LABEL_70;
            }
            unint64_t v10 = (unint64_t)&xmmword_1DC416308;
          }
          unint64_t v17 = v10 & 0xFFFFFFFFFFFFFF00;
          uint64_t v18 = v10;
          goto LABEL_44;
        }
        if (qword_1EBFFC360 != -1) {
          dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
        }
        __int32 v15 = qword_1EBFFC3B8;
        if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
        {
          int v65 = *(_DWORD *)(a3 + 24);
          LODWORD(buf.data) = 67240192;
          HIDWORD(buf.data) = v65;
          _os_log_error_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&buf, 8u);
        }
      }
      else
      {
        if (qword_1EBFFC360 != -1) {
          dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
        }
        uint64_t v14 = qword_1EBFFC3B8;
        if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
        {
          OSType v64 = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
          LODWORD(buf.data) = 67240192;
          HIDWORD(buf.data) = v64;
          _os_log_error_impl(&dword_1DC2FE000, v14, OS_LOG_TYPE_ERROR, "Unsupported pixel format: %{public}u", (uint8_t *)&buf, 8u);
        }
        buf.data = (void *)-2001;
        CGRect v121 = @"Unsupported pixel format.";
        sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, (CFTypeRef *)&v121);
      }
    }
    else
    {
      if (qword_1EBFFC360 != -1) {
        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
      }
      unint64_t v13 = qword_1EBFFC3B8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.data) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_ERROR, "Missing pixel buffer.", (uint8_t *)&buf, 2u);
      }
      buf.data = (void *)-6008;
      CGRect v121 = @"Missing pixel buffer.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, (CFTypeRef *)&v121);
    }
    BOOL v12 = 0;
    goto LABEL_36;
  }
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  unint64_t v11 = qword_1EBFFC3B8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.data) = 0;
    _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "ANMDImagePreprocessor_Accelerate_32BGRA is not ready.", (uint8_t *)&buf, 2u);
  }
  buf.data = (void *)-6008;
  CGRect v121 = @"ANMDImagePreprocessor_Accelerate_32BGRA is not ready.";
  sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, (CFTypeRef *)&v121);
  return 0;
}

void sub_1DC33F1B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t *a53)
{
}

void *sub_1DC33F2DC()
{
  return &unk_1F3664240;
}

uint64_t sub_1DC33F2E8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA26resampleAndRotateIfNeeded_ERKNS_6Sample11PixelBufferERKNS3_21ScopedPixelBufferLockILb1EEERNSt3__18optionalINS_5ErrorEEERKNSC_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC33F324(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::resampleAndRotateIfNeeded_", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC33F3D0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36641E0;
}

void *sub_1DC33F3F0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36641E0;
  return result;
}

void sub_1DC33F428()
{
}

void *sub_1DC33F440()
{
  return &unk_1F36641C0;
}

uint64_t sub_1DC33F44C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA26resampleAndRotateIfNeeded_ERKNS_6Sample11PixelBufferERKNS3_21ScopedPixelBufferLockILb1EEERNSt3__18optionalINS_5ErrorEEERKNSC_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC33F488(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::resampleAndRotateIfNeeded_", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC33F534(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664160;
}

void *sub_1DC33F554()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3664160;
  return result;
}

void sub_1DC33F58C()
{
}

void *sub_1DC33F5A4()
{
  return &unk_1F3664140;
}

uint64_t sub_1DC33F5B0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC33F5EC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC33F698(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36640E0;
}

void *sub_1DC33F6B8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36640E0;
  return result;
}

void sub_1DC33F6F0()
{
}

void *sub_1DC33F708()
{
  return &unk_1F36640C0;
}

uint64_t sub_1DC33F714(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC33F750(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC33F7FC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664060;
}

void *sub_1DC33F81C()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3664060;
  return result;
}

void sub_1DC33F854()
{
}

uint64_t sub_1DC33F86C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1)) {
    return 1;
  }
  v49[0] = &unk_1F3663F60;
  int v50 = v49;
  uint64_t v51 = a3;
  v48[0] = &unk_1F3663FE0;
  v48[3] = v48;
  sub_1DC31AD78((uint64_t)v52, (uint64_t)v48);
  if (*(unsigned char *)(v51 + 8)) {
    BOOL v7 = v50 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    sub_1DC31AE10((uint64_t)v50, *(void *)v51);
  }
  sub_1DC31AE60(v48);
  sub_1DC31AE60(v49);
  if (*(unsigned char *)(a1 + 192) && *(unsigned char *)(a1 + 336)) {
    goto LABEL_35;
  }
  v56[0] = &unk_1F365F080;
  int v57 = v56;
  v55[0] = &unk_1F365F0D8;
  atomic_ullong v55[3] = v55;
  *(void *)vImage_Buffer buf = a3;
  sub_1DC31AD78((uint64_t)&buf[8], (uint64_t)v55);
  if (*(unsigned char *)(a3 + 8) && v57) {
    sub_1DC31AE10((uint64_t)v57, **(void **)buf);
  }
  sub_1DC31AE60(v55);
  sub_1DC31AE60(v56);
  BOOL v8 = (const vImage_YpCbCrToARGBMatrix *)*MEMORY[0x1E4F167D8];
  if (!*(unsigned char *)(a1 + 192))
  {
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(unsigned char *)(a1 + 192) = 1;
    Conversiouint64_t n = vImageConvert_YpCbCrToARGB_GenerateConversion(v8, (const vImage_YpCbCrPixelRange *)&unk_1DC40FBF0, (vImage_YpCbCrToARGB *)(a1 + 64), kvImage420Yp8_CbCr8, kvImageARGB8888, 0);
    if (Conversion)
    {
      if (*(unsigned char *)(a1 + 192)) {
        *(unsigned char *)(a1 + 192) = 0;
      }
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      BOOL v12 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unint64_t v54 = 134349056;
        *(void *)&v54[4] = Conversion;
        _os_log_error_impl(&dword_1DC2FE000, v12, OS_LOG_TYPE_ERROR, "vImageConvert_YpCbCrToARGB_GenerateConversion failed with vImage_Error: %{public}zd", v54, 0xCu);
      }
LABEL_30:
      *(void *)unint64_t v54 = -2003;
      unint64_t v39 = @"vImageConvert_YpCbCrToARGB_GenerateConversion failed.";
      sub_1DC306334((atomic_ullong *)a2, (uint64_t *)v54, (CFTypeRef *)&v39);
      char v9 = 0;
      *(void *)(a2 + 32) = Conversion;
      *(unsigned char *)(a2 + 40) = 1;
      goto LABEL_31;
    }
  }
  char v9 = 1;
  if (!*(unsigned char *)(a1 + 336))
  {
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 304) = 0u;
    *(_OWORD *)(a1 + 320) = 0u;
    *(_OWORD *)(a1 + 272) = 0u;
    *(_OWORD *)(a1 + 288) = 0u;
    *(_OWORD *)(a1 + 240) = 0u;
    *(_OWORD *)(a1 + 256) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    *(unsigned char *)(a1 + 336) = 1;
    Conversiouint64_t n = vImageConvert_YpCbCrToARGB_GenerateConversion(v8, (const vImage_YpCbCrPixelRange *)&xmmword_1DC416308, (vImage_YpCbCrToARGB *)(a1 + 208), kvImage420Yp8_CbCr8, kvImageARGB8888, 0);
    if (Conversion)
    {
      if (*(unsigned char *)(a1 + 336)) {
        *(unsigned char *)(a1 + 336) = 0;
      }
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      unint64_t v11 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unint64_t v54 = 134349056;
        *(void *)&v54[4] = Conversion;
        _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "vImageConvert_YpCbCrToARGB_GenerateConversion failed with vImage_Error: %{public}zd", v54, 0xCu);
      }
      goto LABEL_30;
    }
  }
LABEL_31:
  if (*(unsigned char *)(*(void *)buf + 8) && *(void *)v45) {
    sub_1DC31AE10(*(uint64_t *)v45, **(void **)buf);
  }
  sub_1DC31AE60(&buf[8]);
  if ((v9 & 1) == 0) {
    goto LABEL_56;
  }
LABEL_35:
  uint64_t v13 = *(void *)(a1 + 8);
  uint64_t v14 = *(void *)(a1 + 16);
  if (!v13 || (v13 & 0xF) != 0 || !v14 || (v14 & 0xF) != 0)
  {
    if (qword_1EBFFC360 != -1) {
      dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
    }
    uint64_t v18 = qword_1EBFFC3B8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 134349312;
      *(void *)&uint8_t buf[4] = v13;
      __int16 v41 = 2050;
      uint64_t v42 = v14;
      _os_log_error_impl(&dword_1DC2FE000, v18, OS_LOG_TYPE_ERROR, "Invalid image size: width=%{public}zu, height=%{public}zu", buf, 0x16u);
    }
    *(void *)vImage_Buffer buf = -6008;
    v56[0] = @"Invalid image size.";
    sub_1DC306334((atomic_ullong *)a2, (uint64_t *)buf, v56);
    goto LABEL_56;
  }
  int v15 = *(_DWORD *)(a1 + 24);
  if (v15 != 1111970369)
  {
    if (qword_1EBFFC360 != -1) {
      dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
    }
    long long v20 = qword_1EBFFC3B8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v15;
      _os_log_error_impl(&dword_1DC2FE000, v20, OS_LOG_TYPE_ERROR, "Unsupported pixel format type: %{public}u", buf, 8u);
    }
    *(void *)vImage_Buffer buf = -6008;
    v56[0] = @"Unsupported pixel format type.";
    sub_1DC306334((atomic_ullong *)a2, (uint64_t *)buf, v56);
LABEL_56:
    uint64_t v6 = 0;
    goto LABEL_57;
  }
  if (!*(unsigned char *)(a1 + 384))
  {
    *(_OWORD *)(a1 + 352) = 0u;
    *(_OWORD *)(a1 + 368) = 0u;
    *(unsigned char *)(a1 + 384) = 1;
    uint64_t v21 = MEMORY[0x1E019D900]();
    if (v21)
    {
      if (*(unsigned char *)(a1 + 384)) {
        *(unsigned char *)(a1 + 384) = 0;
      }
      if (qword_1EBFFC360 != -1) {
        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
      }
      int v22 = qword_1EBFFC3B8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)vImage_Buffer buf = 134349056;
        *(void *)&uint8_t buf[4] = v21;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
      }
      goto LABEL_82;
    }
    if (qword_1EBFFC360 != -1) {
      dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
    }
    double v24 = qword_1EBFFC3B8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v25 = *(void *)(a1 + 352);
      uint64_t v26 = *(void *)(a1 + 360);
      uint64_t v27 = *(void *)(a1 + 368);
      uint64_t v28 = *(void *)(a1 + 376);
      *(_DWORD *)vImage_Buffer buf = 136447234;
      *(void *)&uint8_t buf[4] = "420Yp8";
      __int16 v41 = 2050;
      uint64_t v42 = v25;
      __int16 v43 = 2050;
      uint64_t v44 = v26;
      *(_WORD *)int v45 = 2050;
      *(void *)&void v45[2] = v27;
      __int16 v46 = 2050;
      uint64_t v47 = v28;
      _os_log_debug_impl(&dword_1DC2FE000, v24, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
    }
  }
  if (*(unsigned char *)(a1 + 424))
  {
LABEL_42:
    uint64_t v6 = 1;
    if (*(unsigned char *)(a1 + 464)) {
      goto LABEL_57;
    }
    *(_OWORD *)(a1 + 432) = 0u;
    *(_OWORD *)(a1 + 448) = 0u;
    *(unsigned char *)(a1 + 464) = 1;
    uint64_t v16 = MEMORY[0x1E019D900]();
    if (!v16)
    {
      if (qword_1EBFFC360 != -1) {
        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
      }
      double v34 = qword_1EBFFC3B8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v35 = *(void *)(a1 + 432);
        uint64_t v36 = *(void *)(a1 + 440);
        uint64_t v37 = *(void *)(a1 + 448);
        uint64_t v38 = *(void *)(a1 + 456);
        *(_DWORD *)vImage_Buffer buf = 136447234;
        *(void *)&uint8_t buf[4] = "32BGRA";
        __int16 v41 = 2050;
        uint64_t v42 = v35;
        __int16 v43 = 2050;
        uint64_t v44 = v36;
        *(_WORD *)int v45 = 2050;
        *(void *)&void v45[2] = v37;
        __int16 v46 = 2050;
        uint64_t v47 = v38;
        _os_log_debug_impl(&dword_1DC2FE000, v34, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
      }
      goto LABEL_57;
    }
    if (*(unsigned char *)(a1 + 464)) {
      *(unsigned char *)(a1 + 464) = 0;
    }
    if (qword_1EBFFC360 != -1) {
      dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
    }
    unint64_t v17 = qword_1EBFFC3B8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 134349056;
      *(void *)&uint8_t buf[4] = v16;
      _os_log_error_impl(&dword_1DC2FE000, v17, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
    }
    *(void *)vImage_Buffer buf = -2003;
    v56[0] = @"vImageBuffer_Init failed.";
    sub_1DC306334((atomic_ullong *)a2, (uint64_t *)buf, v56);
    uint64_t v6 = 0;
    *(void *)(a2 + 32) = v16;
    goto LABEL_83;
  }
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(unsigned char *)(a1 + 424) = 1;
  uint64_t v21 = MEMORY[0x1E019D900]();
  if (!v21)
  {
    if (qword_1EBFFC360 != -1) {
      dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
    }
    long long v29 = qword_1EBFFC3B8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v30 = *(void *)(a1 + 392);
      uint64_t v31 = *(void *)(a1 + 400);
      uint64_t v32 = *(void *)(a1 + 408);
      uint64_t v33 = *(void *)(a1 + 416);
      *(_DWORD *)vImage_Buffer buf = 136447234;
      *(void *)&uint8_t buf[4] = "420CbCr8";
      __int16 v41 = 2050;
      uint64_t v42 = v30;
      __int16 v43 = 2050;
      uint64_t v44 = v31;
      *(_WORD *)int v45 = 2050;
      *(void *)&void v45[2] = v32;
      __int16 v46 = 2050;
      uint64_t v47 = v33;
      _os_log_debug_impl(&dword_1DC2FE000, v29, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
    }
    goto LABEL_42;
  }
  if (*(unsigned char *)(a1 + 424)) {
    *(unsigned char *)(a1 + 424) = 0;
  }
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  double v23 = qword_1EBFFC3B8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)vImage_Buffer buf = 134349056;
    *(void *)&uint8_t buf[4] = v21;
    _os_log_error_impl(&dword_1DC2FE000, v23, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
  }
LABEL_82:
  *(void *)vImage_Buffer buf = -2003;
  v56[0] = @"vImageBuffer_Init failed.";
  sub_1DC306334((atomic_ullong *)a2, (uint64_t *)buf, v56);
  uint64_t v6 = 0;
  *(void *)(a2 + 32) = v21;
LABEL_83:
  *(unsigned char *)(a2 + 40) = 1;
LABEL_57:
  if (*(unsigned char *)(v51 + 8) && v53) {
    sub_1DC31AE10(v53, *(void *)v51);
  }
  sub_1DC31AE60(v52);
  return v6;
}

void sub_1DC3402E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t *a26)
{
}

void *sub_1DC340388()
{
  return &unk_1F3664040;
}

uint64_t sub_1DC340394(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3403D0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC34047C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3663FE0;
}

void *sub_1DC34049C()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3663FE0;
  return result;
}

void sub_1DC3404D4()
{
}

void *sub_1DC3404EC()
{
  return &unk_1F3663FC0;
}

uint64_t sub_1DC3404F8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd39ANMDImagePreprocessor_Accelerate_32BGRA7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC340534(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate_32BGRA::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3405E0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3663F60;
}

void *sub_1DC340600()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3663F60;
  return result;
}

void sub_1DC340638()
{
}

BOOL sub_1DC340650(unsigned char *a1)
{
  return a1[192] && a1[336] && a1[384] && a1[424] && a1[464] != 0;
}

void sub_1DC340688(uint64_t a1)
{
  sub_1DC3406C0(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC3406C0(uint64_t a1)
{
  *(void *)a1 = &unk_1F3663E40;
  if (*(unsigned char *)(a1 + 384)) {
    free(*(void **)(a1 + 352));
  }
  if (*(unsigned char *)(a1 + 424)) {
    free(*(void **)(a1 + 392));
  }
  if (*(unsigned char *)(a1 + 464)) {
    free(*(void **)(a1 + 432));
  }
  if (*(unsigned char *)(a1 + 504)) {
    free(*(void **)(a1 + 472));
  }
  if (*(unsigned char *)(a1 + 544)) {
    free(*(void **)(a1 + 512));
  }
  return a1;
}

uint64_t sub_1DC340754@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = atomic_exchange((atomic_ullong *volatile)(result + 680), 0);
  return result;
}

BOOL sub_1DC340764(uint64_t a1, atomic_ullong *a2, uint64_t a3, __CFString *a4)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 192)
    && *(unsigned char *)(a1 + 336)
    && *(unsigned char *)(a1 + 384)
    && *(unsigned char *)(a1 + 424)
    && *(unsigned char *)(a1 + 464)
    && atomic_load_explicit((atomic_ullong *volatile)(a1 + 672), memory_order_acquire))
  {
    v49[0] = &unk_1F3664360;
    int v50 = v49;
    uint64_t v51 = a4;
    v48[0] = &unk_1F36643E0;
    v48[3] = v48;
    sub_1DC31AD78((uint64_t)v52, (uint64_t)v48);
    if (LOBYTE(v51->info) && v50) {
      sub_1DC31AE10((uint64_t)v50, (uint64_t)v51->isa);
    }
    sub_1DC31AE60(v48);
    sub_1DC31AE60(v49);
    if (!sub_1DC33DD14(a1, a2, a3, a4))
    {
      BOOL v11 = 0;
LABEL_60:
      if (LOBYTE(v51->info) && v53) {
        sub_1DC31AE10(v53, (uint64_t)v51->isa);
      }
      sub_1DC31AE60(v52);
      return v11;
    }
    if (*(unsigned char *)(a1 + 464)) {
      BOOL v8 = (const vImage_Buffer *)(a1 + 432);
    }
    else {
      BOOL v8 = 0;
    }
    v64[0] = &unk_1F365E368;
    int v65 = v64;
    uint64_t v66 = (uint64_t *)a4;
    v63[0] = &unk_1F365E3C0;
    v63[3] = v63;
    sub_1DC31AD78((uint64_t)v67, (uint64_t)v63);
    if (*((unsigned char *)v66 + 8) && v65) {
      sub_1DC31AE10((uint64_t)v65, *v66);
    }
    sub_1DC31AE60(v63);
    sub_1DC31AE60(v64);
    sub_1DC3712B8(&v47, (atomic_ullong *)(a1 + 672), a3);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire))
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      uint64_t v13 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)vImage_Buffer buf = 0;
        _os_log_error_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_ERROR, "Failed to create input pixel buffer from pixel buffer pool", buf, 2u);
      }
      goto LABEL_53;
    }
    if (CVPixelBufferIsPlanar((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire)))
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      char v9 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)vImage_Buffer buf = 0;
        _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", buf, 2u);
      }
LABEL_52:
      *(void *)vImage_Buffer buf = -2001;
      dest.data = @"Invalid input pixel buffer.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&dest.data);
LABEL_53:
      unint64_t v36 = 0;
LABEL_54:
      sub_1DC307370((atomic_ullong *)&v47);
      if (*((unsigned char *)v66 + 8) && v68) {
        sub_1DC31AE10(v68, *v66);
      }
      sub_1DC31AE60(v67);
      double v23 = (atomic_ullong *)(a1 + 680);
      double v24 = (const void *)atomic_exchange(v23, atomic_exchange((atomic_ullong *volatile)&v36, 0));
      if (v24) {
        CFRelease(v24);
      }
      sub_1DC307370((atomic_ullong *)&v36);
      BOOL v11 = atomic_load_explicit(v23, memory_order_acquire) != 0;
      goto LABEL_60;
    }
    vImagePixelCount Width = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire));
    size_t Height = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire));
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire));
    if (Width != *(void *)(a1 + 616)
      || Height != 3 * *(void *)(a1 + 608)
      || (OSType v17 = PixelFormatType, PixelFormatType != 1278226534) && PixelFormatType != 1278226536)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      int v22 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)vImage_Buffer buf = 0;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", buf, 2u);
      }
      goto LABEL_52;
    }
    CFTypeRef explicit = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire);
    if (explicit) {
      CFTypeRef explicit = CFRetain(explicit);
    }
    CFTypeRef v44 = explicit;
    uint64_t v45 = a3;
    char v46 = sub_1DC36FB80((atomic_ullong *)&v44, 0, a3);
    if ((v46 & 1) == 0)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      uint64_t v25 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        int v31 = *(_DWORD *)(a3 + 24);
        *(_DWORD *)vImage_Buffer buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = v31;
        _os_log_error_impl(&dword_1DC2FE000, v25, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", buf, 8u);
      }
      goto LABEL_68;
    }
    dest.data = CVPixelBufferGetBaseAddress((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire));
    dest.double height = Height / 3;
    dest.double width = Width;
    dest.size_t rowBytes = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire));
    size_t v19 = dest.rowBytes * (Height / 3);
    v42.data = (char *)dest.data + v19;
    v42.double height = Height / 3;
    v42.double width = Width;
    v42.size_t rowBytes = dest.rowBytes;
    v41.data = (char *)dest.data + 2 * v19;
    v41.double height = Height / 3;
    v41.double width = Width;
    v41.size_t rowBytes = dest.rowBytes;
    uint64_t v20 = MEMORY[0x1E019D900](&blue);
    if (v20)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      uint64_t v21 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)vImage_Buffer buf = 134349056;
        *(void *)&uint8_t buf[4] = v20;
        _os_log_error_impl(&dword_1DC2FE000, v21, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
      }
      *(void *)vImage_Buffer buf = -2003;
      green.data = @"vImageBuffer_Init failed.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&green.data);
      *(void *)(a3 + 32) = v20;
      *(unsigned char *)(a3 + 40) = 1;
LABEL_68:
      unint64_t v36 = 0;
LABEL_69:
      if (v46) {
        char v46 = sub_1DC36FD3C((atomic_ullong *)&v44, 0, v45) ^ 1;
      }
      sub_1DC307370((atomic_ullong *)&v44);
      goto LABEL_54;
    }
    uint64_t v26 = v8;
    data = blue.data;
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v28 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)vImage_Buffer buf = 136447234;
      *(void *)&uint8_t buf[4] = "blueU8";
      __int16 v55 = 2050;
      uint64_t v56 = data;
      __int16 v57 = 2050;
      vImagePixelCount v58 = blue.height;
      __int16 v59 = 2050;
      vImagePixelCount v60 = blue.width;
      __int16 v61 = 2050;
      size_t rowBytes = blue.rowBytes;
      _os_log_debug_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
    }
    uint64_t v29 = MEMORY[0x1E019D900](&green, v42.height, v42.width, 8, 0);
    if (v29)
    {
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)vImage_Buffer buf = 134349056;
        *(void *)&uint8_t buf[4] = v29;
        _os_log_error_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
      }
      *(void *)vImage_Buffer buf = -2003;
      red.data = @"vImageBuffer_Init failed.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&red.data);
      *(void *)(a3 + 32) = v29;
      *(unsigned char *)(a3 + 40) = 1;
      unint64_t v36 = 0;
LABEL_110:
      if (data) {
        free(data);
      }
      goto LABEL_69;
    }
    uint64_t v35 = green.data;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)vImage_Buffer buf = 136447234;
      *(void *)&uint8_t buf[4] = "greenU8";
      __int16 v55 = 2050;
      uint64_t v56 = v35;
      __int16 v57 = 2050;
      vImagePixelCount v58 = green.height;
      __int16 v59 = 2050;
      vImagePixelCount v60 = green.width;
      __int16 v61 = 2050;
      size_t rowBytes = green.rowBytes;
      _os_log_debug_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
    }
    uint64_t v30 = MEMORY[0x1E019D900](&red, v41.height, v41.width, 8, 0);
    if (v30)
    {
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)vImage_Buffer buf = 134349056;
        *(void *)&uint8_t buf[4] = v30;
        _os_log_error_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
      }
      *(void *)vImage_Buffer buf = -2003;
      uint64_t v37 = @"vImageBuffer_Init failed.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v37);
      *(void *)(a3 + 32) = v30;
      *(unsigned char *)(a3 + 40) = 1;
      unint64_t v36 = 0;
LABEL_108:
      if (v35) {
        free(v35);
      }
      goto LABEL_110;
    }
    uint64_t v32 = red.data;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)vImage_Buffer buf = 136447234;
      *(void *)&uint8_t buf[4] = "redU8";
      __int16 v55 = 2050;
      uint64_t v56 = v32;
      __int16 v57 = 2050;
      vImagePixelCount v58 = red.height;
      __int16 v59 = 2050;
      vImagePixelCount v60 = red.width;
      __int16 v61 = 2050;
      size_t rowBytes = red.rowBytes;
      _os_log_debug_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
    }
    vImage_Error v33 = vImageConvert_BGRX8888ToPlanar8(v26, &blue, &green, &red, 0);
    if (v33)
    {
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)vImage_Buffer buf = 134349056;
        *(void *)&uint8_t buf[4] = v33;
        _os_log_error_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_ERROR, "vImageConvert_BGRX8888ToPlanar8 failed: %{public}zd", buf, 0xCu);
      }
      *(void *)vImage_Buffer buf = -2005;
      uint64_t v37 = @"vImageConvert_BGRX8888ToPlanar8 failed.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v37);
LABEL_105:
      unint64_t v34 = 0;
      *(void *)(a3 + 32) = v33;
      *(unsigned char *)(a3 + 40) = 1;
      goto LABEL_106;
    }
    if (v17 == 1278226536)
    {
      vImage_Error v33 = vImageConvert_Planar8toPlanar16F(&blue, &dest, 0);
      if (v33
        || (vImage_Error v33 = vImageConvert_Planar8toPlanar16F(&green, &v42, 0)) != 0
        || (vImage_Error v33 = vImageConvert_Planar8toPlanar16F(&red, &v41, 0)) != 0)
      {
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)vImage_Buffer buf = 134349056;
          *(void *)&uint8_t buf[4] = v33;
          _os_log_error_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_ERROR, "vImageConvert_Planar8toPlanar16F failed: %{public}zd", buf, 0xCu);
        }
        *(void *)vImage_Buffer buf = -2005;
        uint64_t v37 = @"vImageConvert_Planar8toPlanar16F failed.";
        sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v37);
        goto LABEL_105;
      }
      sub_1DC38F220((uint64_t *)&dest);
      sub_1DC38F220((uint64_t *)&v42);
      sub_1DC38F220((uint64_t *)&v41);
    }
    else
    {
      vImage_Error v33 = vImageConvert_Planar8toPlanarF(&blue, &dest, 255.0, 0.0, 0);
      if (v33
        || (vImage_Error v33 = vImageConvert_Planar8toPlanarF(&green, &v42, 255.0, 0.0, 0)) != 0
        || (vImage_Error v33 = vImageConvert_Planar8toPlanarF(&red, &v41, 255.0, 0.0, 0)) != 0)
      {
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)vImage_Buffer buf = 134349056;
          *(void *)&uint8_t buf[4] = v33;
          _os_log_error_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_ERROR, "vImageConvert_Planar8toPlanarF failed: %{public}zd", buf, 0xCu);
        }
        *(void *)vImage_Buffer buf = -2005;
        uint64_t v37 = @"vImageConvert_Planar8toPlanarF failed.";
        sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v37);
        goto LABEL_105;
      }
    }
    unint64_t v34 = atomic_exchange((atomic_ullong *volatile)&v47, 0);
LABEL_106:
    unint64_t v36 = v34;
    if (v32) {
      free(v32);
    }
    goto LABEL_108;
  }
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  unint64_t v10 = qword_1EBFFC3B8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)vImage_Buffer buf = 0;
    _os_log_error_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_ERROR, "ANMDImagePreprocessor_Accelerate is not ready.", buf, 2u);
  }
  *(void *)vImage_Buffer buf = -6008;
  uint64_t v66 = (uint64_t *)@"ANMDImagePreprocessor_Accelerate is not ready.";
  sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v66);
  return 0;
}

void sub_1DC341430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,atomic_ullong a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t *a50)
{
  if (v51) {
    free(v51);
  }
  if (a9) {
    free(a9);
  }
  if (v50) {
    free(v50);
  }
  sub_1DC38F37C((uint64_t)&a36);
  sub_1DC307370(&a39);
  sub_1DC31AEE4((uint64_t **)(v52 - 144));
  sub_1DC31AEE4(&a50);
  _Unwind_Resume(a1);
}

void *sub_1DC341578()
{
  return &unk_1F3664440;
}

uint64_t sub_1DC341584(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd32ANMDImagePreprocessor_Accelerate3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3415C0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC34166C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36643E0;
}

void *sub_1DC34168C()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36643E0;
  return result;
}

void sub_1DC3416C4()
{
}

void *sub_1DC3416DC()
{
  return &unk_1F36643C0;
}

uint64_t sub_1DC3416E8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd32ANMDImagePreprocessor_Accelerate3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC341724(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3417D0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664360;
}

void *sub_1DC3417F0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3664360;
  return result;
}

void sub_1DC341828()
{
}

uint64_t sub_1DC341840(uint64_t a1, atomic_ullong *a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 192)
    && *(unsigned char *)(a1 + 336)
    && *(unsigned char *)(a1 + 384)
    && *(unsigned char *)(a1 + 424)
    && *(unsigned char *)(a1 + 464)
    && atomic_load_explicit((atomic_ullong *volatile)(a1 + 672), memory_order_acquire))
  {
    return 1;
  }
  v14[0] = &unk_1F3664260;
  int v15 = v14;
  uint64_t v16 = a3;
  v13[0] = &unk_1F36642E0;
  uint64_t v13[3] = v13;
  sub_1DC31AD78((uint64_t)v17, (uint64_t)v13);
  if (*(unsigned char *)(v16 + 8)) {
    BOOL v7 = v15 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    sub_1DC31AE10((uint64_t)v15, *(void *)v16);
  }
  sub_1DC31AE60(v13);
  sub_1DC31AE60(v14);
  if ((sub_1DC33F86C(a1, (uint64_t)a2, a3) & 1) == 0) {
    goto LABEL_19;
  }
  if (atomic_load_explicit((atomic_ullong *volatile)(a1 + 672), memory_order_acquire)) {
    goto LABEL_18;
  }
  sub_1DC38F084(&v12, a1 + 552, a2);
  BOOL v8 = (atomic_ullong *)(a1 + 672);
  char v9 = (const void *)atomic_exchange(v8, atomic_exchange((atomic_ullong *volatile)&v12, 0));
  if (v9) {
    CFRelease(v9);
  }
  sub_1DC330114((atomic_ullong *)&v12);
  if (atomic_load_explicit(v8, memory_order_acquire)) {
LABEL_18:
  }
    uint64_t v6 = 1;
  else {
LABEL_19:
  }
    uint64_t v6 = 0;
  if (*(unsigned char *)(v16 + 8)) {
    BOOL v10 = v18 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10) {
    sub_1DC31AE10(v18, *(void *)v16);
  }
  sub_1DC31AE60(v17);
  return v6;
}

void sub_1DC3419F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  atomic_ullong v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  sub_1DC330114((atomic_ullong *)va);
  sub_1DC31AEE4((uint64_t **)va1);
  _Unwind_Resume(a1);
}

void *sub_1DC341A58()
{
  return &unk_1F3664340;
}

uint64_t sub_1DC341A64(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd32ANMDImagePreprocessor_Accelerate7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC341AA0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_Accelerate::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC341B4C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36642E0;
}

void *sub_1DC341B6C()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36642E0;
  return result;
}

void sub_1DC341BA4()
{
}

void *sub_1DC341BBC()
{
  return &unk_1F36642C0;
}

uint64_t sub_1DC341BC8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd32ANMDImagePreprocessor_Accelerate7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC341C04(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_Accelerate::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC341CB0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664260;
}

void *sub_1DC341CD0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3664260;
  return result;
}

void sub_1DC341D08()
{
}

BOOL sub_1DC341D20(uint64_t a1)
{
  return *(unsigned char *)(a1 + 192)
      && *(unsigned char *)(a1 + 336)
      && *(unsigned char *)(a1 + 384)
      && *(unsigned char *)(a1 + 424)
      && *(unsigned char *)(a1 + 464)
      && atomic_load_explicit((atomic_ullong *volatile)(a1 + 672), memory_order_acquire) != 0;
}

void sub_1DC341D64(uint64_t a1)
{
  sub_1DC307370((atomic_ullong *)(a1 + 680));
  sub_1DC330114((atomic_ullong *)(a1 + 672));
  sub_1DC3406C0(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC341DBC(uint64_t a1)
{
  sub_1DC307370((atomic_ullong *)(a1 + 680));
  sub_1DC330114((atomic_ullong *)(a1 + 672));
  return sub_1DC3406C0(a1);
}

uint64_t sub_1DC341E00@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = atomic_exchange((atomic_ullong *volatile)(result + 240), 0);
  return result;
}

BOOL sub_1DC341E10(uint64_t a1, atomic_ullong *a2, uint64_t a3, __CFString *a4)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 200)
    && *(void *)(a1 + 208)
    && atomic_load_explicit((atomic_ullong *volatile)(a1 + 216), memory_order_acquire)
    && atomic_load_explicit((atomic_ullong *volatile)(a1 + 224), memory_order_acquire)
    && atomic_load_explicit((atomic_ullong *volatile)(a1 + 232), memory_order_acquire))
  {
    v85[0] = &unk_1F3664560;
    vImagePixelCount v86 = v85;
    CGFloat v87 = a4;
    v84[0] = &unk_1F36645E0;
    v84[3] = v84;
    sub_1DC31AD78((uint64_t)v88, (uint64_t)v84);
    if (LOBYTE(v87->info)) {
      BOOL v8 = v86 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8) {
      sub_1DC31AE10((uint64_t)v86, (uint64_t)v87->isa);
    }
    sub_1DC31AE60(v84);
    sub_1DC31AE60(v85);
    if (atomic_load_explicit(a2, memory_order_acquire))
    {
      OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
      if ((PixelFormatType | 0x10) == 0x34323076)
      {
        size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
        size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
        unint64_t v12 = HeightOfPlane;
        double v13 = (double)*(unint64_t *)(a1 + 8);
        double v14 = (double)*(unint64_t *)(a1 + 16);
        double v15 = v13 / v14;
        unint64_t v68 = WidthOfPlane;
        if (vabdd_f64(1.0, v13 / v14) >= 2.22044605e-16)
        {
          double v22 = (double)WidthOfPlane / (double)HeightOfPlane;
          double v23 = 1.0 / v22;
          double v24 = ceil(v22 * v14);
          if (v22 >= v15) {
            double v24 = (double)*(unint64_t *)(a1 + 8);
          }
          double v25 = ceil(v13 / v22);
          if (v22 <= v15)
          {
            double v26 = (double)*(unint64_t *)(a1 + 16);
          }
          else
          {
            double v24 = (double)*(unint64_t *)(a1 + 8);
            double v26 = v25;
          }
          if (v23 <= v15)
          {
            if (v23 < v15) {
              double v13 = ceil(v23 * v14);
            }
          }
          else
          {
            double v14 = ceil(v13 / v23);
          }
          BOOL v16 = v24 * v26 < v13 * v14;
        }
        else
        {
          BOOL v16 = 0;
        }
        *(unsigned char *)(a1 + 28) = v16;
        atomic_ullong v70 = 0;
        atomic_ullong v71 = 0;
        sub_1DC3712B8((CVPixelBufferRef *)&buf, (atomic_ullong *)(a1 + 216), a3);
        uint64_t v27 = (const void *)atomic_exchange(&v71, atomic_exchange((atomic_ullong *volatile)&buf, 0));
        if (v27) {
          CFRelease(v27);
        }
        sub_1DC307370((atomic_ullong *)&buf);
        if (!atomic_load_explicit(&v71, memory_order_acquire)) {
          goto LABEL_54;
        }
        if (qword_1EBFFC360 != -1) {
          dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
        }
        uint64_t v28 = qword_1EBFFC3B8;
        if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_DEBUG))
        {
          unint64_t v33 = atomic_load_explicit(&v71, memory_order_acquire);
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v33;
          _os_log_debug_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_DEBUG, "Allocated interleaved pixel buffer: %{public}@", (uint8_t *)&buf, 0xCu);
          if (v16)
          {
LABEL_49:
            sub_1DC3712B8((CVPixelBufferRef *)&buf, (atomic_ullong *)(a1 + 224), a3);
            uint64_t v29 = (const void *)atomic_exchange(&v70, atomic_exchange((atomic_ullong *volatile)&buf, 0));
            if (v29) {
              CFRelease(v29);
            }
            sub_1DC307370((atomic_ullong *)&buf);
            if (atomic_load_explicit(&v70, memory_order_acquire))
            {
              log = v28;
              BOOL v30 = os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG);
              int v31 = &v70;
              if (v30)
              {
                unint64_t v32 = atomic_load_explicit(&v70, memory_order_acquire);
                LODWORD(buf) = 138543362;
                *(void *)((char *)&buf + 4) = v32;
                _os_log_debug_impl(&dword_1DC2FE000, log, OS_LOG_TYPE_DEBUG, "Allocated interleaved90CW pixel buffer: %{public}@", (uint8_t *)&buf, 0xCu);
              }
LABEL_57:
              size_t Width = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit(v31, memory_order_acquire));
              size_t Height = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit(v31, memory_order_acquire));
              double v36 = (double)v68 / (double)v12;
              double v37 = (double)Width;
              double v38 = (double)Height;
              double v39 = (double)Width / (double)Height;
              if (v36 <= v39)
              {
                if (v36 < v39)
                {
                  size_t Width = vcvtpd_u64_f64(v36 * v38);
                  double v37 = (double)(unint64_t)ceil(v36 * v38);
                }
              }
              else
              {
                size_t Height = vcvtpd_u64_f64(v37 / v36);
                double v38 = (double)(unint64_t)ceil(v37 / v36);
              }
              uint64_t v40 = *(void *)(a1 + 200);
              long long buf = 0uLL;
              double v96 = (double)v68;
              double v97 = (double)v12;
              LOBYTE(v98) = 1;
              v81[0] = 0;
              v81[1] = 0;
              v81[2] = *(CFTypeRef *)&v37;
              vImagePixelCount v82 = *(CFTypeRef **)&v38;
              char v83 = 1;
              LOBYTE(v92) = 0;
              char v93 = 0;
              if ((sub_1DC35DC24(v40, a2, v31, (uint64_t)&buf, (uint64_t)v81, (atomic_ullong *)a3, (uint64_t)&v92) & 1) == 0) {
                goto LABEL_64;
              }
              if (v16)
              {
                uint64_t v41 = *(void *)(a1 + 208);
                LOBYTE(buf) = 0;
                LOBYTE(v98) = 0;
                LOBYTE(v81[0]) = 0;
                char v83 = 0;
                LOBYTE(v92) = 0;
                char v93 = 0;
                char v42 = sub_1DC35E8D8(v41, &v70, &v71, (uint64_t)&buf, (uint64_t)v81, (atomic_ullong *)a3, (uint64_t)&v92);
                size_t v43 = Width;
                if ((v42 & 1) == 0)
                {
LABEL_64:
                  BOOL v18 = 0;
                  goto LABEL_104;
                }
              }
              else
              {
                if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
                {
                  LOWORD(buf) = 0;
                  _os_log_debug_impl(&dword_1DC2FE000, log, OS_LOG_TYPE_DEBUG, "ANMDImagePreprocessor: rotation is not needed", (uint8_t *)&buf, 2u);
                }
                size_t v43 = Height;
                size_t Height = Width;
              }
              *(void *)(a1 + 32) = Height;
              *(void *)(a1 + 40) = v43;
              *(void *)(a1 + 48) = Height >> 1;
              *(void *)(a1 + 56) = v43 >> 1;
              v81[0] = &unk_1F3664B28;
              vImagePixelCount v82 = v81;
              size_t v92 = &unk_1F3664BA8;
              uint64_t v94 = &v92;
              *(void *)&long long buf = a4;
              sub_1DC31AD78((uint64_t)&buf + 8, (uint64_t)&v92);
              if (*(unsigned char *)(buf + 8) && v82) {
                sub_1DC31AE10((uint64_t)v82, *(void *)buf);
              }
              sub_1DC31AE60(&v92);
              sub_1DC31AE60(v81);
              if (!atomic_load_explicit(&v71, memory_order_acquire)
                || CVPixelBufferIsPlanar((CVPixelBufferRef)atomic_load_explicit(&v71, memory_order_acquire)))
              {
                if (qword_1EBFFC3D0 != -1) {
                  dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                }
                CFTypeRef v44 = qword_1EBFFC3D8;
                if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v77.data) = 0;
                  _os_log_error_impl(&dword_1DC2FE000, v44, OS_LOG_TYPE_ERROR, "Invalid interleaved pixel buffer", (uint8_t *)&v77, 2u);
                }
                v77.data = (void *)-2006;
                v91.data = @"Invalid interleaved pixel buffer.";
                sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&v77, (CFTypeRef *)&v91.data);
LABEL_97:
                unint64_t v69 = 0;
LABEL_98:
                if (*(unsigned char *)(buf + 8) && v98) {
                  sub_1DC31AE10(v98, *(void *)buf);
                }
                sub_1DC31AE60((void *)&buf + 1);
                uint64_t v52 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 240), atomic_exchange((atomic_ullong *volatile)&v69, 0));
                if (v52) {
                  CFRelease(v52);
                }
                sub_1DC307370((atomic_ullong *)&v69);
                BOOL v18 = atomic_load_explicit((atomic_ullong *volatile)(a1 + 240), memory_order_acquire) != 0;
                goto LABEL_104;
              }
              vImagePixelCount v45 = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit(&v71, memory_order_acquire));
              vImagePixelCount v46 = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit(&v71, memory_order_acquire));
              OSType v47 = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(&v71, memory_order_acquire));
              if (v45 != *(void *)(a1 + 128)
                || v46 != *(void *)(a1 + 120)
                || (OSType v48 = v47, v47 != 1380410945) && v47 != 1380411457)
              {
                if (qword_1EBFFC3D0 != -1) {
                  dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                }
                uint64_t v51 = qword_1EBFFC3D8;
                if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v77.data) = 0;
                  _os_log_error_impl(&dword_1DC2FE000, v51, OS_LOG_TYPE_ERROR, "Invalid interleaved pixel buffer", (uint8_t *)&v77, 2u);
                }
                v77.data = (void *)-2001;
                v91.data = @"Invalid interleaved pixel buffer.";
                sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&v77, (CFTypeRef *)&v91.data);
                goto LABEL_97;
              }
              CFTypeRef v49 = (CFTypeRef)atomic_load_explicit(&v71, memory_order_acquire);
              if (v49) {
                CFTypeRef v49 = CFRetain(v49);
              }
              CFTypeRef v78 = v49;
              uint64_t v79 = a3;
              char v80 = sub_1DC36FB80((atomic_ullong *)&v78, 1, a3);
              if ((v80 & 1) == 0)
              {
                if (qword_1EBFFC3D0 != -1) {
                  dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                }
                uint64_t v53 = qword_1EBFFC3D8;
                if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v77.data) = 0;
                  _os_log_error_impl(&dword_1DC2FE000, v53, OS_LOG_TYPE_ERROR, "Failed to lock interleaved pixel buffer for reading", (uint8_t *)&v77, 2u);
                }
                unint64_t v69 = 0;
                goto LABEL_132;
              }
              memset(&v77, 0, sizeof(v77));
              v77.data = CVPixelBufferGetBaseAddress((CVPixelBufferRef)atomic_load_explicit(&v71, memory_order_acquire));
              v77.double height = v46;
              v77.double width = v45;
              v77.size_t rowBytes = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)atomic_load_explicit(&v71, memory_order_acquire));
              sub_1DC3712B8(&v76, (atomic_ullong *)(a1 + 232), a3);
              if (!atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire))
              {
                if (qword_1EBFFC3D0 != -1) {
                  dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                }
                unint64_t v54 = qword_1EBFFC3D8;
                if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v91.data) = 0;
                  _os_log_error_impl(&dword_1DC2FE000, v54, OS_LOG_TYPE_ERROR, "Failed to create input pixel buffer from pixel buffer pool", (uint8_t *)&v91, 2u);
                }
                goto LABEL_130;
              }
              if (CVPixelBufferIsPlanar((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire)))
              {
                if (qword_1EBFFC3D0 != -1) {
                  dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                }
                int v50 = qword_1EBFFC3D8;
                if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v91.data) = 0;
                  _os_log_error_impl(&dword_1DC2FE000, v50, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", (uint8_t *)&v91, 2u);
                }
LABEL_129:
                v91.data = (void *)-2001;
                green.data = @"Invalid input pixel buffer.";
                sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&v91, (CFTypeRef *)&green.data);
LABEL_130:
                unint64_t v69 = 0;
LABEL_131:
                sub_1DC307370((atomic_ullong *)&v76);
LABEL_132:
                if (v80) {
                  char v80 = sub_1DC36FD3C((atomic_ullong *)&v78, 1, v79) ^ 1;
                }
                sub_1DC307370((atomic_ullong *)&v78);
                goto LABEL_98;
              }
              vImagePixelCount v55 = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire));
              size_t v56 = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire));
              OSType v57 = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire));
              if (v55 != *(void *)(a1 + 128)
                || v56 != 3 * *(void *)(a1 + 120)
                || v57 != 1278226534 && v57 != 1278226536)
              {
                if (qword_1EBFFC3D0 != -1) {
                  dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                }
                __int16 v61 = qword_1EBFFC3D8;
                if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v91.data) = 0;
                  _os_log_error_impl(&dword_1DC2FE000, v61, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", (uint8_t *)&v91, 2u);
                }
                goto LABEL_129;
              }
              sub_1DC38F6D0((uint64_t)v75, (atomic_ullong *)&v76, a3);
              if (!v75[16])
              {
                if (qword_1EBFFC3D0 != -1) {
                  dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                }
                uint64_t v62 = qword_1EBFFC3D8;
                if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                {
                  int v66 = *(_DWORD *)(a3 + 24);
                  LODWORD(v91.data) = 67240192;
                  HIDWORD(v91.data) = v66;
                  _os_log_error_impl(&dword_1DC2FE000, v62, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&v91, 8u);
                }
                unint64_t v69 = 0;
                goto LABEL_149;
              }
              BaseAddress = (char *)CVPixelBufferGetBaseAddress((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire));
              size_t BytesPerRow = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire));
              v91.data = BaseAddress;
              v91.double height = v56 / 3;
              v91.double width = v55;
              v91.size_t rowBytes = BytesPerRow;
              unint64_t v60 = BytesPerRow * (v56 / 3);
              green.data = &BaseAddress[v60];
              green.double height = v56 / 3;
              green.double width = v55;
              green.size_t rowBytes = BytesPerRow;
              blue.data = &BaseAddress[2 * v60];
              blue.double height = v56 / 3;
              blue.double width = v55;
              blue.size_t rowBytes = BytesPerRow;
              if (v48 == 1380411457)
              {
                sub_1DC38F730(&v77, &blue, &green, &v91);
              }
              else
              {
                vImage_Error v63 = vImageConvert_BGRXFFFFToPlanarF(&v77, &blue, &green, &v91, 0);
                if (v63)
                {
                  if (qword_1EBFFC3D0 != -1) {
                    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
                  }
                  OSType v64 = qword_1EBFFC3D8;
                  if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)vImagePixelCount v90 = 134349056;
                    *(void *)&v90[4] = v63;
                    _os_log_error_impl(&dword_1DC2FE000, v64, OS_LOG_TYPE_ERROR, "vImageConvert_RGBXFFFFToPlanarF failed: %{public}zd", v90, 0xCu);
                  }
                  *(void *)vImagePixelCount v90 = -2005;
                  vImagePixelCount v72 = @"vImageConvert_RGBXFFFFToPlanarF failed.";
                  sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v90, (CFTypeRef *)&v72);
                  unint64_t v65 = 0;
                  *(void *)(a3 + 32) = v63;
                  *(unsigned char *)(a3 + 40) = 1;
                  goto LABEL_148;
                }
                sub_1DC38FB24((uint64_t)&v91);
                sub_1DC38FB24((uint64_t)&green);
                sub_1DC38FB24((uint64_t)&blue);
              }
              unint64_t v65 = atomic_exchange((atomic_ullong *volatile)&v76, 0);
LABEL_148:
              unint64_t v69 = v65;
LABEL_149:
              sub_1DC38F37C((uint64_t)v75);
              goto LABEL_131;
            }
LABEL_54:
            BOOL v18 = 0;
LABEL_104:
            sub_1DC307370(&v70);
            sub_1DC307370(&v71);
LABEL_105:
            if (LOBYTE(v87->info) && v89) {
              sub_1DC31AE10(v89, (uint64_t)v87->isa);
            }
            sub_1DC31AE60(v88);
            return v18;
          }
        }
        else if (v16)
        {
          goto LABEL_49;
        }
        log = v28;
        int v31 = &v71;
        goto LABEL_57;
      }
      if (qword_1EBFFC360 != -1) {
        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
      }
      uint64_t v21 = qword_1EBFFC3B8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 67240192;
        DWORD1(buf) = PixelFormatType;
        _os_log_error_impl(&dword_1DC2FE000, v21, OS_LOG_TYPE_ERROR, "Unsupported pixel format: %{public}#x", (uint8_t *)&buf, 8u);
      }
      *(void *)&long long buf = -2001;
      v81[0] = @"Unsupported pixel format.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, v81);
    }
    else
    {
      if (qword_1EBFFC360 != -1) {
        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
      }
      uint64_t v20 = qword_1EBFFC3B8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v20, OS_LOG_TYPE_ERROR, "Missing pixel buffer.", (uint8_t *)&buf, 2u);
      }
      *(void *)&long long buf = -6008;
      v81[0] = @"Missing pixel buffer.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, v81);
    }
    BOOL v18 = 0;
    goto LABEL_105;
  }
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  OSType v17 = qword_1EBFFC3B8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl(&dword_1DC2FE000, v17, OS_LOG_TYPE_ERROR, "ANMDImagePreprocessor_VideoToolbox is not ready.", (uint8_t *)&buf, 2u);
  }
  *(void *)&long long buf = -6008;
  CGFloat v87 = @"ANMDImagePreprocessor_VideoToolbox is not ready.";
  sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, (CFTypeRef *)&v87);
  return 0;
}

void sub_1DC342CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, atomic_ullong a14, atomic_ullong a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,atomic_ullong a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t *a50)
{
  sub_1DC38F37C((uint64_t)&a25);
  sub_1DC307370(&a28);
  sub_1DC38FBEC((uint64_t)&a34);
  sub_1DC31AEE4((uint64_t **)(v50 - 144));
  sub_1DC307370(&a14);
  sub_1DC307370(&a15);
  sub_1DC31AEE4(&a50);
  _Unwind_Resume(a1);
}

BOOL sub_1DC342E28(atomic_ullong *a1)
{
  return a1[25]
      && a1[26]
      && atomic_load_explicit(a1 + 27, memory_order_acquire)
      && atomic_load_explicit(a1 + 28, memory_order_acquire)
      && atomic_load_explicit(a1 + 29, memory_order_acquire) != 0;
}

void *sub_1DC342E6C()
{
  return &unk_1F3664640;
}

uint64_t sub_1DC342E78(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd34ANMDImagePreprocessor_VideoToolbox3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC342EB4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_VideoToolbox::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC342F60(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36645E0;
}

void *sub_1DC342F80()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36645E0;
  return result;
}

void sub_1DC342FB8()
{
}

void *sub_1DC342FD0()
{
  return &unk_1F36645C0;
}

uint64_t sub_1DC342FDC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd34ANMDImagePreprocessor_VideoToolbox3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC343018(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_VideoToolbox::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3430C4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664560;
}

void *sub_1DC3430E4()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3664560;
  return result;
}

void sub_1DC34311C()
{
}

uint64_t sub_1DC343134(uint64_t a1, atomic_ullong *a2, uint64_t a3)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void **)(a1 + 200);
  if (*(void *)(a1 + 200)
    && *(void *)(a1 + 208)
    && atomic_load_explicit((atomic_ullong *volatile)(a1 + 216), memory_order_acquire)
    && atomic_load_explicit((atomic_ullong *volatile)(a1 + 224), memory_order_acquire)
    && atomic_load_explicit((atomic_ullong *volatile)(a1 + 232), memory_order_acquire))
  {
    return 1;
  }
  v86[0] = &unk_1F3664460;
  CGFloat v87 = v86;
  uint64_t v88 = a3;
  v85[0] = &unk_1F36644E0;
  void v85[3] = v85;
  sub_1DC31AD78((uint64_t)v89, (uint64_t)v85);
  if (*(unsigned char *)(v88 + 8)) {
    BOOL v7 = v87 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    sub_1DC31AE10((uint64_t)v87, *(void *)v88);
  }
  sub_1DC31AE60(v85);
  sub_1DC31AE60(v86);
  if (!*v5)
  {
    if (*(unsigned char *)(a1 + 192))
    {
      int v8 = *(_DWORD *)(a1 + 184);
      HIDWORD(v10) = v8 - 9;
      LODWORD(v10) = v8 - 9;
      unsigned int v9 = v10 >> 2;
      if (v9 <= 6 && ((0x22u >> v9) & 1) == 0 && ((1 << v9) & 0x5D) == 0) {
        qos_class_self();
      }
    }
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = *(void *)(a1 + 16);
    unsigned int v14 = *(_DWORD *)(a1 + 24);
    int v15 = HIBYTE(v14);
    if (HIBYTE(v14) - 32 >= 0x5Fu) {
      int v15 = 46;
    }
    if (*(_DWORD *)(a1 + 24) - 32 >= 0x5F) {
      uint64_t v16 = 46;
    }
    else {
      uint64_t v16 = *(_DWORD *)(a1 + 24);
    }
    int32x2_t v17 = (int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(v14), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
    int8x8_t v18 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v17, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v17, (int8x8_t)0x2E0000002ELL);
    v19.i64[0] = v18.u32[0];
    v19.i64[1] = v18.u32[1];
    v20.i64[0] = 255;
    v20.i64[1] = 255;
    uint64x2_t v21 = vshlq_u64((uint64x2_t)vandq_s8(v19, v20), (uint64x2_t)xmmword_1DC3FDC10);
    uint64_t v22 = v21.i64[0] | (v16 << 24);
    uint8_t buf[4] = ((unint64_t)v22 | v21.i64[1]) >> 32;
    *(_DWORD *)long long buf = v22 | v21.i32[2] | v15;
    CFStringRef v67 = CFStringCreateWithFormat(v11, 0, @"ANMDImagePreprocessor[Transfer, %zu, %zu, %.4s]", v12, v13, buf);
    *(void *)&long long pixelTransferSessionOut = 0;
    OSStatus v23 = VTPixelTransferSessionCreate(v11, (VTPixelTransferSessionRef *)&pixelTransferSessionOut);
    if (!v23) {
      operator new();
    }
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    double v24 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v23;
      _os_log_error_impl(&dword_1DC2FE000, v24, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionCreate failed: %{public}d", buf, 8u);
    }
    CFStringRef v68 = @"VTPixelTransferSessionCreate failed.";
    *(void *)long long buf = -2003;
    sub_1DC306334(a2, (uint64_t *)buf, (CFTypeRef *)&v68);
    sub_1DC390E0C((uint64_t)a2, v23);
    sub_1DC343F44(v5, 0);
    double v25 = *v5;
    sub_1DC31FA90((atomic_ullong *)&v67);
    if (!v25) {
      goto LABEL_77;
    }
  }
  if (!*(void *)(a1 + 208))
  {
    CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v27 = *(void *)(a1 + 8);
    uint64_t v28 = *(void *)(a1 + 16);
    unsigned int v29 = *(_DWORD *)(a1 + 24);
    int v30 = HIBYTE(v29);
    if (HIBYTE(v29) - 32 >= 0x5Fu) {
      int v30 = 46;
    }
    if (*(_DWORD *)(a1 + 24) - 32 >= 0x5F) {
      uint64_t v31 = 46;
    }
    else {
      uint64_t v31 = *(_DWORD *)(a1 + 24);
    }
    int32x2_t v32 = (int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(v29), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
    int8x8_t v33 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v32, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v32, (int8x8_t)0x2E0000002ELL);
    v34.i64[0] = v33.u32[0];
    v34.i64[1] = v33.u32[1];
    v35.i64[0] = 255;
    v35.i64[1] = 255;
    uint64x2_t v36 = vshlq_u64((uint64x2_t)vandq_s8(v34, v35), (uint64x2_t)xmmword_1DC3FDC10);
    uint64_t v37 = v36.i64[0] | (v31 << 24);
    uint8_t buf[4] = ((unint64_t)v37 | v36.i64[1]) >> 32;
    *(_DWORD *)long long buf = v37 | v36.i32[2] | v30;
    CFStringRef v67 = CFStringCreateWithFormat(v26, 0, @"ANMDImagePreprocessor[Rotation, %zu, %zu, %.4s]", v27, v28, buf, (void)pixelTransferSessionOut);
    *(void *)&long long pixelTransferSessionOut = 0;
    OSStatus v38 = VTPixelRotationSessionCreate(v26, (VTPixelRotationSessionRef *)&pixelTransferSessionOut);
    if (!v38) {
      operator new();
    }
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    double v39 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v38;
      _os_log_error_impl(&dword_1DC2FE000, v39, OS_LOG_TYPE_ERROR, "VTPixelRotationSessionCreate failed: %{public}d", buf, 8u);
    }
    CFStringRef v68 = @"VTPixelRotationSessionCreate failed.";
    *(void *)long long buf = -2003;
    sub_1DC306334(a2, (uint64_t *)buf, (CFTypeRef *)&v68);
    sub_1DC390E0C((uint64_t)a2, v38);
    sub_1DC343F94((void **)(a1 + 208), 0);
    uint64_t v40 = *(void *)(a1 + 208);
    sub_1DC31FA90((atomic_ullong *)&v67);
    if (!v40) {
      goto LABEL_77;
    }
  }
  if (!atomic_load_explicit((atomic_ullong *volatile)(a1 + 216), memory_order_acquire)
    || !atomic_load_explicit((atomic_ullong *volatile)(a1 + 224), memory_order_acquire))
  {
    LOBYTE(pixelTransferSessionOut) = 0;
    BYTE8(pixelTransferSessionOut) = 0;
    char v51 = 0;
    char v52 = 0;
    char v53 = 0;
    char v54 = 0;
    char v55 = 0;
    char v56 = 0;
    char v57 = 0;
    char v58 = 0;
    char v59 = 0;
    char v60 = 0;
    char v64 = 0;
    char v65 = 0;
    atomic_ullong v66 = 0;
    char v62 = 1;
    int v61 = 1024;
    __int16 v63 = 257;
    *(void *)long long buf = CFRetain(@"MRC: ANMD Preprocessor Interleaved");
    uint64_t v41 = (const void *)atomic_exchange(&v66, atomic_exchange((atomic_ullong *volatile)buf, 0));
    if (v41) {
      CFRelease(v41);
    }
    sub_1DC31FA90((atomic_ullong *)buf);
    v81[0] = 0;
    char v83 = 0;
    __int16 v84 = 0;
    int v79 = 0;
    __int16 v80 = 0;
    uint64_t v42 = *(void *)(a1 + 16);
    *(void *)long long buf = *(void *)(a1 + 8);
    char v70 = 1;
    uint64_t v71 = v42;
    LOBYTE(v72) = 1;
    int v73 = *(_DWORD *)(a1 + 24);
    char v74 = 1;
    char v76 = 1;
    uint64_t v75 = 64;
    char v78 = 1;
    uint64_t v77 = 64;
    sub_1DC332A24((uint64_t)v81, &pixelTransferSessionOut);
    if (!atomic_load_explicit((atomic_ullong *volatile)(a1 + 216), memory_order_acquire))
    {
      sub_1DC37120C((CVPixelBufferPoolRef *)&v68, (uint64_t *)buf, (uint64_t)a2);
      size_t v43 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 216), atomic_exchange((atomic_ullong *volatile)&v68, 0));
      if (v43) {
        CFRelease(v43);
      }
      sub_1DC330114((atomic_ullong *)&v68);
      if (!atomic_load_explicit((atomic_ullong *volatile)(a1 + 216), memory_order_acquire)) {
        goto LABEL_74;
      }
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)(a1 + 224), memory_order_acquire))
    {
      if ((v70 != 0) != ((_BYTE)v72 != 0))
      {
        if (v70)
        {
          uint64_t v71 = *(void *)buf;
          LOBYTE(v72) = 1;
          char v70 = 0;
        }
        else
        {
          *(void *)long long buf = v71;
          char v70 = 1;
          if ((_BYTE)v72) {
            LOBYTE(v72) = 0;
          }
        }
      }
      else if (v70)
      {
        uint64_t v44 = *(void *)buf;
        *(void *)long long buf = v71;
        uint64_t v71 = v44;
      }
      CFStringRef v68 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ 90CW", atomic_load_explicit(&v82, memory_order_acquire));
      vImagePixelCount v45 = (const void *)atomic_exchange(&v82, atomic_exchange((atomic_ullong *volatile)&v68, 0));
      if (v45) {
        CFRelease(v45);
      }
      sub_1DC31FA90((atomic_ullong *)&v68);
      sub_1DC37120C((CVPixelBufferPoolRef *)&v68, (uint64_t *)buf, (uint64_t)a2);
      vImagePixelCount v46 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 224), atomic_exchange((atomic_ullong *volatile)&v68, 0));
      if (v46) {
        CFRelease(v46);
      }
      sub_1DC330114((atomic_ullong *)&v68);
      if (!atomic_load_explicit((atomic_ullong *volatile)(a1 + 224), memory_order_acquire))
      {
LABEL_74:
        if (v83) {
          sub_1DC31FA90(&v82);
        }
        sub_1DC31FA90(&v66);
        goto LABEL_77;
      }
    }
    if (v83) {
      sub_1DC31FA90(&v82);
    }
    sub_1DC31FA90(&v66);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)(a1 + 232), memory_order_acquire)) {
    goto LABEL_73;
  }
  sub_1DC38F084((CVPixelBufferPoolRef *)buf, a1 + 64, a2);
  OSType v47 = (atomic_ullong *)(a1 + 232);
  OSType v48 = (const void *)atomic_exchange(v47, atomic_exchange((atomic_ullong *volatile)buf, 0));
  if (v48) {
    CFRelease(v48);
  }
  sub_1DC330114((atomic_ullong *)buf);
  if (atomic_load_explicit(v47, memory_order_acquire))
  {
LABEL_73:
    uint64_t v6 = 1;
    goto LABEL_78;
  }
LABEL_77:
  uint64_t v6 = 0;
LABEL_78:
  if (*(unsigned char *)(v88 + 8) && v90) {
    sub_1DC31AE10(v90, *(void *)v88);
  }
  sub_1DC31AE60(v89);
  return v6;
}

void sub_1DC343DF8(_Unwind_Exception *a1)
{
  sub_1DC31AEE4((uint64_t **)(v1 - 144));
  _Unwind_Resume(a1);
}

void *sub_1DC343F44(void **a1, void *a2)
{
  __n128 result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1DC35E5F4(result);
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

void *sub_1DC343F94(void **a1, void *a2)
{
  __n128 result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1DC35F1D8(result);
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

void *sub_1DC343FE4()
{
  return &unk_1F3664540;
}

uint64_t sub_1DC343FF0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd34ANMDImagePreprocessor_VideoToolbox7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC34402C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDImagePreprocessor_VideoToolbox::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3440D8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36644E0;
}

void *sub_1DC3440F8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F36644E0;
  return result;
}

void sub_1DC344130()
{
}

void *sub_1DC344148()
{
  return &unk_1F36644C0;
}

uint64_t sub_1DC344154(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd34ANMDImagePreprocessor_VideoToolbox7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC344190(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)int v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDImagePreprocessor_VideoToolbox::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC34423C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664460;
}

void *sub_1DC34425C()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3664460;
  return result;
}

void sub_1DC344294()
{
}

void sub_1DC3442AC(uint64_t a1)
{
  sub_1DC3442E4(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC3442E4(uint64_t a1)
{
  return a1;
}

uint64_t *sub_1DC344344(uint64_t *result, unint64_t a2)
{
  if (a2 > (result[2] - *result) >> 3)
  {
    if (a2 >> 61) {
      sub_1DC2FF97C();
    }
    os_signpost_id_t v2 = result;
    uint64_t v3 = result[1] - *result;
    v5[4] = result + 2;
    v5[0] = sub_1DC2FFD7C(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 8 * v4;
    sub_1DC3066A4(v2, v5);
    return (uint64_t *)sub_1DC306780((uint64_t)v5);
  }
  return result;
}

void sub_1DC3443C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC306780((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DC3443DC(unint64_t a1, _OWORD *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = (_OWORD *)((char *)a2 - 28);
    unint64_t v11 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v11;
          uint64_t v12 = (uint64_t)a2 - v11;
          unint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)((uint64_t)a2 - v11) >> 2);
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*((float *)a2 - 3) > *(float *)(v11 + 16))
                {
                  *(_OWORD *)&v103[12] = *(_OWORD *)(v11 + 12);
                  *(_OWORD *)vImage_Buffer v103 = *(_OWORD *)v11;
                  long long v49 = *v10;
                  *(_OWORD *)(v11 + 12) = *(a2 - 1);
                  *(_OWORD *)unint64_t v11 = v49;
                  *(a2 - 1) = *(_OWORD *)&v103[12];
                  *unint64_t v10 = *(_OWORD *)v103;
                }
                break;
              case 3uLL:
                sub_1DC344DD8(v11, v11 + 28, (uint64_t)a2 - 28);
                break;
              case 4uLL:
                sub_1DC344F10(v11, v11 + 28, v11 + 56, (uint64_t)a2 - 28);
                break;
              case 5uLL:
                uint64_t v50 = (_OWORD *)(v11 + 28);
                char v51 = (_OWORD *)(v11 + 56);
                char v52 = (_OWORD *)(v11 + 84);
                sub_1DC344F10(v11, v11 + 28, v11 + 56, v11 + 84);
                if (*((float *)a2 - 3) > *(float *)(v11 + 100))
                {
                  *(_OWORD *)long long v104 = *v52;
                  *(_OWORD *)&v104[12] = *(_OWORD *)(v11 + 96);
                  long long v53 = *v10;
                  *(_OWORD *)(v11 + 96) = *(a2 - 1);
                  _OWORD *v52 = v53;
                  *(a2 - 1) = *(_OWORD *)&v104[12];
                  *unint64_t v10 = *(_OWORD *)v104;
                  if (*(float *)(v11 + 100) > *(float *)(v11 + 72))
                  {
                    *(_OWORD *)vImage_Buffer v105 = *v51;
                    *(_OWORD *)&v105[12] = *(_OWORD *)(v11 + 68);
                    _OWORD *v51 = *v52;
                    *(_OWORD *)(v11 + 68) = *(_OWORD *)(v11 + 96);
                    _OWORD *v52 = *(_OWORD *)v105;
                    *(_OWORD *)(v11 + 96) = *(_OWORD *)&v105[12];
                    if (*(float *)(v11 + 72) > *(float *)(v11 + 44))
                    {
                      *(_OWORD *)int v106 = *v50;
                      *(_OWORD *)&v106[12] = *(_OWORD *)(v11 + 40);
                      _OWORD *v50 = *v51;
                      *(_OWORD *)(v11 + 40) = *(_OWORD *)(v11 + 68);
                      _OWORD *v51 = *(_OWORD *)v106;
                      *(_OWORD *)(v11 + 68) = *(_OWORD *)&v106[12];
                      if (*(float *)(v11 + 44) > *(float *)(v11 + 16))
                      {
                        *(_OWORD *)&v107[12] = *(_OWORD *)(v11 + 12);
                        *(_OWORD *)unsigned int v107 = *(_OWORD *)v11;
                        *(_OWORD *)unint64_t v11 = *v50;
                        *(_OWORD *)(v11 + 12) = *(_OWORD *)(v11 + 40);
                        _OWORD *v50 = *(_OWORD *)v107;
                        *(_OWORD *)(v11 + 40) = *(_OWORD *)&v107[12];
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v12 <= 671)
          {
            char v54 = (_OWORD *)(v11 + 28);
            BOOL v56 = (_OWORD *)v11 == a2 || v54 == a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v11;
                do
                {
                  char v59 = v54;
                  float v60 = *(float *)(v58 + 44);
                  if (v60 > *(float *)(v58 + 16))
                  {
                    long long v108 = *v54;
                    uint64_t v61 = *(void *)(v58 + 48);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      uint64_t v63 = v11 + v62;
                      *(_OWORD *)(v63 + 28) = *(_OWORD *)(v11 + v62);
                      *(_OWORD *)(v63 + 40) = *(_OWORD *)(v11 + v62 + 12);
                      if (!v62) {
                        break;
                      }
                      v62 -= 28;
                      if (v60 <= *(float *)(v63 - 12))
                      {
                        uint64_t v64 = v11 + v62 + 28;
                        goto LABEL_84;
                      }
                    }
                    uint64_t v64 = v11;
LABEL_84:
                    *(_OWORD *)uint64_t v64 = v108;
                    *(float *)(v64 + 16) = v60;
                    *(void *)(v64 + 20) = v61;
                  }
                  char v54 = (_OWORD *)((char *)v59 + 28);
                  v57 += 28;
                  unint64_t v58 = (unint64_t)v59;
                }
                while ((_OWORD *)((char *)v59 + 28) != a2);
              }
            }
            else if (!v56)
            {
              do
              {
                unint64_t v93 = (unint64_t)v54;
                float v94 = *(float *)(a1 + 44);
                if (v94 > *(float *)(a1 + 16))
                {
                  long long v111 = *v54;
                  uint64_t v95 = *(void *)(a1 + 48);
                  do
                  {
                    *char v54 = *(_OWORD *)((char *)v54 - 28);
                    *(_OWORD *)((char *)v54 + 12) = *(v54 - 1);
                    float v96 = *((float *)v54 - 10);
                    char v54 = (_OWORD *)((char *)v54 - 28);
                  }
                  while (v94 > v96);
                  *char v54 = v111;
                  *((float *)v54 + 4) = v94;
                  *(void *)((char *)v54 + 20) = v95;
                }
                char v54 = (_OWORD *)(v93 + 28);
                a1 = v93;
              }
              while ((_OWORD *)(v93 + 28) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((_OWORD *)v11 != a2)
            {
              int64_t v65 = (v13 - 2) >> 1;
              int64_t v66 = v65;
              do
              {
                int64_t v67 = v66;
                if (v65 >= v66)
                {
                  uint64_t v68 = (2 * v66) | 1;
                  unint64_t v69 = v11 + 28 * v68;
                  if (2 * v67 + 2 < (uint64_t)v13 && *(float *)(v11 + 28 * v68 + 16) > *(float *)(v69 + 44))
                  {
                    v69 += 28;
                    uint64_t v68 = 2 * v67 + 2;
                  }
                  float v70 = *(float *)(v11 + 28 * v67 + 16);
                  if (*(float *)(v69 + 16) <= v70)
                  {
                    unint64_t v71 = v11 + 28 * v67;
                    long long v109 = *(_OWORD *)v71;
                    uint64_t v72 = *(void *)(v71 + 20);
                    do
                    {
                      int v73 = (_OWORD *)v71;
                      unint64_t v71 = v69;
                      long long v74 = *(_OWORD *)v69;
                      *(_OWORD *)((char *)v73 + 12) = *(_OWORD *)(v69 + 12);
                      *int v73 = v74;
                      if (v65 < v68) {
                        break;
                      }
                      uint64_t v75 = (2 * v68) | 1;
                      unint64_t v69 = v11 + 28 * v75;
                      uint64_t v76 = 2 * v68 + 2;
                      if (v76 < (uint64_t)v13 && *(float *)(v11 + 28 * v75 + 16) > *(float *)(v69 + 44))
                      {
                        v69 += 28;
                        uint64_t v75 = v76;
                      }
                      uint64_t v68 = v75;
                    }
                    while (*(float *)(v69 + 16) <= v70);
                    *(_OWORD *)unint64_t v71 = v109;
                    *(float *)(v71 + 16) = v70;
                    *(void *)(v71 + 20) = v72;
                  }
                }
                int64_t v66 = v67 - 1;
              }
              while (v67);
              int64_t v77 = v12 / 0x1CuLL;
              do
              {
                uint64_t v78 = 0;
                *(_OWORD *)&v110[12] = *(_OWORD *)(v11 + 12);
                *(_OWORD *)int v110 = *(_OWORD *)v11;
                unint64_t v79 = v11;
                do
                {
                  __int16 v80 = (_OWORD *)v79;
                  uint64_t v81 = v78 + 1;
                  v79 += 28 * (v78 + 1);
                  uint64_t v82 = 2 * v78;
                  uint64_t v78 = (2 * v78) | 1;
                  int64_t v83 = v82 + 2;
                  if (v83 < v77 && *((float *)v80 + 7 * v81 + 4) > *(float *)(v79 + 44))
                  {
                    v79 += 28;
                    uint64_t v78 = v83;
                  }
                  long long v84 = *(_OWORD *)v79;
                  *(_OWORD *)((char *)v80 + 12) = *(_OWORD *)(v79 + 12);
                  *__int16 v80 = v84;
                }
                while (v78 <= (uint64_t)((unint64_t)(v77 - 2) >> 1));
                a2 = (_OWORD *)((char *)a2 - 28);
                if ((_OWORD *)v79 == a2)
                {
                  *(_OWORD *)(v79 + 12) = *(_OWORD *)&v110[12];
                  *(_OWORD *)unint64_t v79 = *(_OWORD *)v110;
                }
                else
                {
                  long long v85 = *a2;
                  *(_OWORD *)(v79 + 12) = *(_OWORD *)((char *)a2 + 12);
                  *(_OWORD *)unint64_t v79 = v85;
                  *(_OWORD *)((char *)a2 + 12) = *(_OWORD *)&v110[12];
                  *a2 = *(_OWORD *)v110;
                  uint64_t v86 = v79 - v11 + 28;
                  if (v86 >= 29)
                  {
                    unint64_t v87 = (v86 / 0x1CuLL - 2) >> 1;
                    float v88 = *(float *)(v79 + 16);
                    if (*(float *)(v11 + 28 * v87 + 16) > v88)
                    {
                      long long v99 = *(_OWORD *)v79;
                      uint64_t v89 = *(void *)(v79 + 20);
                      do
                      {
                        uint64_t v90 = (_OWORD *)v79;
                        unint64_t v79 = v11 + 28 * v87;
                        long long v91 = *(_OWORD *)v79;
                        *(_OWORD *)((char *)v90 + 12) = *(_OWORD *)(v79 + 12);
                        *uint64_t v90 = v91;
                        if (!v87) {
                          break;
                        }
                        unint64_t v87 = (v87 - 1) >> 1;
                      }
                      while (*(float *)(v11 + 28 * v87 + 16) > v88);
                      *(_OWORD *)unint64_t v79 = v99;
                      *(float *)(v79 + 16) = v88;
                      *(void *)(v79 + 20) = v89;
                    }
                  }
                }
              }
              while (v77-- > 2);
            }
            return;
          }
          unint64_t v14 = v13 >> 1;
          int v15 = (long long *)(v11 + 28 * (v13 >> 1));
          if ((unint64_t)v12 >= 0xE01)
          {
            sub_1DC344DD8(a1, a1 + 28 * (v13 >> 1), (uint64_t)a2 - 28);
            uint64_t v16 = 28 * v14;
            uint64_t v17 = 28 * v14 + a1 - 28;
            sub_1DC344DD8(a1 + 28, v17, (uint64_t)a2 - 56);
            uint64_t v18 = a1 + 28 + v16;
            sub_1DC344DD8(a1 + 56, v18, (uint64_t)a2 - 84);
            sub_1DC344DD8(v17, (uint64_t)v15, v18);
            *(_OWORD *)&v100[12] = *(_OWORD *)(a1 + 12);
            *(_OWORD *)unint64_t v100 = *(_OWORD *)a1;
            long long v19 = *v15;
            *(_OWORD *)(a1 + 12) = *(long long *)((char *)v15 + 12);
            *(_OWORD *)a1 = v19;
            *(long long *)((char *)v15 + 12) = *(_OWORD *)&v100[12];
            *int v15 = *(_OWORD *)v100;
          }
          else
          {
            sub_1DC344DD8(a1 + 28 * (v13 >> 1), a1, (uint64_t)a2 - 28);
          }
          --a3;
          if (a4) {
            break;
          }
          float v20 = *(float *)(a1 + 16);
          if (*(float *)(a1 - 12) > v20) {
            goto LABEL_12;
          }
          long long v98 = *(_OWORD *)a1;
          if (v20 <= *((float *)a2 - 3))
          {
            unint64_t v38 = a1 + 28;
            do
            {
              unint64_t v11 = v38;
              if (v38 >= (unint64_t)a2) {
                break;
              }
              float v39 = *(float *)(v38 + 16);
              v38 += 28;
            }
            while (v20 <= v39);
          }
          else
          {
            unint64_t v36 = a1;
            do
            {
              unint64_t v11 = v36 + 28;
              float v37 = *(float *)(v36 + 44);
              v36 += 28;
            }
            while (v20 <= v37);
          }
          uint64_t v40 = (float *)a2;
          if (v11 < (unint64_t)a2)
          {
            uint64_t v41 = (float *)a2;
            do
            {
              uint64_t v40 = v41 - 7;
              float v42 = *(v41 - 3);
              v41 -= 7;
            }
            while (v20 > v42);
          }
          uint64_t v43 = *(void *)(a1 + 20);
          while (v11 < (unint64_t)v40)
          {
            *(_OWORD *)&v102[12] = *(_OWORD *)(v11 + 12);
            *(_OWORD *)long long v102 = *(_OWORD *)v11;
            long long v44 = *(_OWORD *)v40;
            *(_OWORD *)(v11 + 12) = *(_OWORD *)(v40 + 3);
            *(_OWORD *)unint64_t v11 = v44;
            *(_OWORD *)(v40 + 3) = *(_OWORD *)&v102[12];
            *(_OWORD *)uint64_t v40 = *(_OWORD *)v102;
            do
            {
              float v45 = *(float *)(v11 + 44);
              v11 += 28;
            }
            while (v20 <= v45);
            do
            {
              float v46 = *(v40 - 3);
              v40 -= 7;
            }
            while (v20 > v46);
          }
          OSType v47 = (long long *)(v11 - 28);
          BOOL v4 = v11 - 28 >= a1;
          BOOL v5 = v11 - 28 == a1;
          if (v11 - 28 != a1)
          {
            long long v48 = *v47;
            *(_OWORD *)(a1 + 12) = *(_OWORD *)(v11 - 16);
            *(_OWORD *)a1 = v48;
          }
          a4 = 0;
          *OSType v47 = v98;
          *(float *)(v11 - 12) = v20;
          *(void *)(v11 - 8) = v43;
        }
        float v20 = *(float *)(a1 + 16);
LABEL_12:
        long long v97 = *(_OWORD *)a1;
        uint64_t v21 = *(void *)(a1 + 20);
        unint64_t v22 = a1;
        do
        {
          unint64_t v23 = v22;
          v22 += 28;
        }
        while (*(float *)(v23 + 44) > v20);
        double v24 = (float *)a2;
        if (v23 == a1)
        {
          uint64_t v27 = (float *)a2;
          while (v22 < (unint64_t)v27)
          {
            double v25 = v27 - 7;
            float v28 = *(v27 - 3);
            v27 -= 7;
            if (v28 > v20) {
              goto LABEL_22;
            }
          }
          double v25 = v27;
        }
        else
        {
          do
          {
            double v25 = v24 - 7;
            float v26 = *(v24 - 3);
            v24 -= 7;
          }
          while (v26 <= v20);
        }
LABEL_22:
        unint64_t v11 = v22;
        if (v22 < (unint64_t)v25)
        {
          unsigned int v29 = v25;
          do
          {
            *(_OWORD *)char v101 = *(_OWORD *)v11;
            *(_OWORD *)&v101[12] = *(_OWORD *)(v11 + 12);
            long long v30 = *(_OWORD *)v29;
            *(_OWORD *)(v11 + 12) = *(_OWORD *)(v29 + 3);
            *(_OWORD *)unint64_t v11 = v30;
            *(_OWORD *)(v29 + 3) = *(_OWORD *)&v101[12];
            *(_OWORD *)unsigned int v29 = *(_OWORD *)v101;
            do
            {
              float v31 = *(float *)(v11 + 44);
              v11 += 28;
            }
            while (v31 > v20);
            do
            {
              float v32 = *(v29 - 3);
              v29 -= 7;
            }
            while (v32 <= v20);
          }
          while (v11 < (unint64_t)v29);
        }
        int8x8_t v33 = (long long *)(v11 - 28);
        if (v11 - 28 != a1)
        {
          long long v34 = *v33;
          *(_OWORD *)(a1 + 12) = *(_OWORD *)(v11 - 16);
          *(_OWORD *)a1 = v34;
        }
        *int8x8_t v33 = v97;
        *(float *)(v11 - 12) = v20;
        *(void *)(v11 - 8) = v21;
        if (v22 >= (unint64_t)v25) {
          break;
        }
LABEL_33:
        sub_1DC3443DC(a1, v11 - 28, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v35 = sub_1DC345010(a1, v11 - 28);
      if (sub_1DC345010(v11, (uint64_t)a2)) {
        break;
      }
      if (!v35) {
        goto LABEL_33;
      }
    }
    a2 = (_OWORD *)(v11 - 28);
    if (!v35) {
      continue;
    }
    break;
  }
}

void *sub_1DC344D58(void *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  a1[3] = 0;
  a1[4] = a4;
  if (a2)
  {
    if (a2 >= 0x924924924924925) {
      sub_1DC2FF994();
    }
    BOOL v7 = (char *)operator new(28 * a2);
  }
  else
  {
    BOOL v7 = 0;
  }
  int v8 = &v7[28 * a3];
  *a1 = v7;
  a1[1] = v8;
  a1[2] = v8;
  a1[3] = &v7[28 * a2];
  return a1;
}

__n128 sub_1DC344DD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  result.n128_u32[0] = *(_DWORD *)(a2 + 16);
  float v4 = *(float *)(a3 + 16);
  if (result.n128_f32[0] <= *(float *)(a1 + 16))
  {
    if (v4 > result.n128_f32[0])
    {
      *(_OWORD *)unint64_t v11 = *(_OWORD *)a2;
      *(_OWORD *)&v11[12] = *(_OWORD *)(a2 + 12);
      long long v6 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v6;
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v11[12];
      __n128 result = *(__n128 *)v11;
      *(_OWORD *)a3 = *(_OWORD *)v11;
      result.n128_u32[0] = *(_DWORD *)(a2 + 16);
      if (result.n128_f32[0] > *(float *)(a1 + 16))
      {
        *(_OWORD *)uint64_t v12 = *(_OWORD *)a1;
        *(_OWORD *)&uint64_t v12[12] = *(_OWORD *)(a1 + 12);
        long long v7 = *(_OWORD *)(a2 + 12);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 12) = v7;
        *(_OWORD *)(a2 + 12) = *(_OWORD *)&v12[12];
        __n128 result = *(__n128 *)v12;
        *(_OWORD *)a2 = *(_OWORD *)v12;
      }
    }
  }
  else
  {
    if (v4 <= result.n128_f32[0])
    {
      *(_OWORD *)unint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)&v13[12] = *(_OWORD *)(a1 + 12);
      long long v8 = *(_OWORD *)(a2 + 12);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 12) = v8;
      *(_OWORD *)(a2 + 12) = *(_OWORD *)&v13[12];
      __n128 result = *(__n128 *)v13;
      *(_OWORD *)a2 = *(_OWORD *)v13;
      result.n128_u32[0] = *(_DWORD *)(a3 + 16);
      if (result.n128_f32[0] <= *(float *)(a2 + 16)) {
        return result;
      }
      *(_OWORD *)unint64_t v10 = *(_OWORD *)a2;
      *(_OWORD *)&v10[12] = *(_OWORD *)(a2 + 12);
      long long v9 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v9;
    }
    else
    {
      *(_OWORD *)unint64_t v10 = *(_OWORD *)a1;
      *(_OWORD *)&v10[12] = *(_OWORD *)(a1 + 12);
      long long v5 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)(a1 + 12) = v5;
    }
    *(_OWORD *)(a3 + 12) = *(_OWORD *)&v10[12];
    __n128 result = *(__n128 *)v10;
    *(_OWORD *)a3 = *(_OWORD *)v10;
  }
  return result;
}

__n128 sub_1DC344F10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result = sub_1DC344DD8(a1, a2, a3);
  result.n128_u32[0] = *(_DWORD *)(a4 + 16);
  if (result.n128_f32[0] > *(float *)(a3 + 16))
  {
    *(_OWORD *)uint64_t v12 = *(_OWORD *)a3;
    *(_OWORD *)&uint64_t v12[12] = *(_OWORD *)(a3 + 12);
    long long v9 = *(_OWORD *)(a4 + 12);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 12) = v9;
    *(_OWORD *)(a4 + 12) = *(_OWORD *)&v12[12];
    __n128 result = *(__n128 *)v12;
    *(_OWORD *)a4 = *(_OWORD *)v12;
    result.n128_u32[0] = *(_DWORD *)(a3 + 16);
    if (result.n128_f32[0] > *(float *)(a2 + 16))
    {
      *(_OWORD *)unint64_t v13 = *(_OWORD *)a2;
      *(_OWORD *)&v13[12] = *(_OWORD *)(a2 + 12);
      long long v10 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v10;
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v13[12];
      __n128 result = *(__n128 *)v13;
      *(_OWORD *)a3 = *(_OWORD *)v13;
      result.n128_u32[0] = *(_DWORD *)(a2 + 16);
      if (result.n128_f32[0] > *(float *)(a1 + 16))
      {
        *(_OWORD *)unint64_t v14 = *(_OWORD *)a1;
        *(_OWORD *)&v14[12] = *(_OWORD *)(a1 + 12);
        long long v11 = *(_OWORD *)(a2 + 12);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 12) = v11;
        *(_OWORD *)(a2 + 12) = *(_OWORD *)&v14[12];
        __n128 result = *(__n128 *)v14;
        *(_OWORD *)a2 = *(_OWORD *)v14;
      }
    }
  }
  return result;
}

BOOL sub_1DC345010(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 2;
  BOOL result = 1;
  switch(0x6DB6DB6DB6DB6DB7 * v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 12) > *(float *)(a1 + 16))
      {
        *(_OWORD *)float v20 = *(_OWORD *)a1;
        *(_OWORD *)&v20[12] = *(_OWORD *)(a1 + 12);
        long long v6 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 28);
        *(_OWORD *)(a1 + 12) = v6;
        *(_OWORD *)(a2 - 16) = *(_OWORD *)&v20[12];
        *(_OWORD *)(a2 - 28) = *(_OWORD *)v20;
      }
      return result;
    case 3:
      sub_1DC344DD8(a1, a1 + 28, a2 - 28);
      return 1;
    case 4:
      sub_1DC344F10(a1, a1 + 28, a1 + 56, a2 - 28);
      return 1;
    case 5:
      uint64_t v16 = (_OWORD *)(a1 + 28);
      uint64_t v17 = (_OWORD *)(a1 + 56);
      uint64_t v18 = (_OWORD *)(a1 + 84);
      sub_1DC344F10(a1, a1 + 28, a1 + 56, a1 + 84);
      if (*(float *)(a2 - 12) > *(float *)(a1 + 100))
      {
        *(_OWORD *)unint64_t v22 = *v18;
        *(_OWORD *)&v22[12] = *(_OWORD *)(a1 + 96);
        long long v19 = *(_OWORD *)(a2 - 16);
        *uint64_t v18 = *(_OWORD *)(a2 - 28);
        *(_OWORD *)(a1 + 96) = v19;
        *(_OWORD *)(a2 - 16) = *(_OWORD *)&v22[12];
        *(_OWORD *)(a2 - 28) = *(_OWORD *)v22;
        if (*(float *)(a1 + 100) > *(float *)(a1 + 72))
        {
          *(_OWORD *)unint64_t v23 = *v17;
          *(_OWORD *)&v23[12] = *(_OWORD *)(a1 + 68);
          *uint64_t v17 = *v18;
          *(_OWORD *)(a1 + 68) = *(_OWORD *)(a1 + 96);
          *uint64_t v18 = *(_OWORD *)v23;
          *(_OWORD *)(a1 + 96) = *(_OWORD *)&v23[12];
          if (*(float *)(a1 + 72) > *(float *)(a1 + 44))
          {
            *(_OWORD *)double v24 = *v16;
            *(_OWORD *)&v24[12] = *(_OWORD *)(a1 + 40);
            *uint64_t v16 = *v17;
            *(_OWORD *)(a1 + 40) = *(_OWORD *)(a1 + 68);
            *uint64_t v17 = *(_OWORD *)v24;
            *(_OWORD *)(a1 + 68) = *(_OWORD *)&v24[12];
            if (*(float *)(a1 + 44) > *(float *)(a1 + 16))
            {
              *(_OWORD *)double v25 = *(_OWORD *)a1;
              *(_OWORD *)&unsigned char v25[12] = *(_OWORD *)(a1 + 12);
              *(_OWORD *)a1 = *v16;
              *(_OWORD *)(a1 + 12) = *(_OWORD *)(a1 + 40);
              *uint64_t v16 = *(_OWORD *)v25;
              *(_OWORD *)(a1 + 40) = *(_OWORD *)&v25[12];
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v7 = a1 + 56;
      sub_1DC344DD8(a1, a1 + 28, a1 + 56);
      uint64_t v8 = a1 + 84;
      if (a1 + 84 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    float v11 = *(float *)(v8 + 16);
    if (v11 > *(float *)(v7 + 16))
    {
      long long v21 = *(_OWORD *)v8;
      uint64_t v12 = *(void *)(v8 + 20);
      uint64_t v13 = v9;
      while (1)
      {
        uint64_t v14 = a1 + v13;
        *(_OWORD *)(v14 + 84) = *(_OWORD *)(a1 + v13 + 56);
        *(_OWORD *)(v14 + 96) = *(_OWORD *)(a1 + v13 + 68);
        if (v13 == -56) {
          break;
        }
        v13 -= 28;
        if (v11 <= *(float *)(v14 + 44))
        {
          uint64_t v15 = a1 + v13 + 84;
          goto LABEL_13;
        }
      }
      uint64_t v15 = a1;
LABEL_13:
      *(_OWORD *)uint64_t v15 = v21;
      *(float *)(v15 + 16) = v11;
      *(void *)(v15 + 20) = v12;
      if (++v10 == 8) {
        return v8 + 28 == a2;
      }
    }
    uint64_t v7 = v8;
    v9 += 28;
    v8 += 28;
    if (v8 == a2) {
      return 1;
    }
  }
}

void sub_1DC34530C(char **a1, _DWORD *a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8)
{
  unint64_t v16 = (unint64_t)a1[2];
  uint64_t v17 = a1[1];
  if ((unint64_t)v17 >= v16)
  {
    uint64_t v25 = 0x6DB6DB6DB6DB6DB7 * ((v17 - *a1) >> 2);
    unint64_t v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) > 0x924924924924924) {
      sub_1DC2FF97C();
    }
    unint64_t v27 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v16 - (void)*a1) >> 2);
    if (2 * v27 > v26) {
      unint64_t v26 = 2 * v27;
    }
    if (v27 >= 0x492492492492492) {
      unint64_t v28 = 0x924924924924924;
    }
    else {
      unint64_t v28 = v26;
    }
    sub_1DC344D58(&v42, v28, v25, (uint64_t)(a1 + 2));
    unsigned int v29 = v44;
    int v30 = *a3;
    int v31 = *a4;
    int v32 = *a5;
    int v33 = *a6;
    int v34 = *a7;
    int v35 = *a8;
    *(_DWORD *)long long v44 = *a2;
    *((_DWORD *)v29 + 1) = v30;
    *((_DWORD *)v29 + 2) = v31;
    *((_DWORD *)v29 + 3) = v32;
    *((_DWORD *)v29 + 4) = v33;
    *((_DWORD *)v29 + 5) = v34;
    *((_DWORD *)v29 + 6) = v35;
    double v24 = v29 + 28;
    long long v44 = v29 + 28;
    float v37 = *a1;
    unint64_t v36 = a1[1];
    unint64_t v38 = v43;
    if (v36 == *a1)
    {
      uint64_t v40 = a1[1];
    }
    else
    {
      do
      {
        long long v39 = *(_OWORD *)(v36 - 28);
        *((_OWORD *)v38 - 1) = *((_OWORD *)v36 - 1);
        *(_OWORD *)(v38 - 28) = v39;
        v38 -= 28;
        v36 -= 28;
      }
      while (v36 != v37);
      uint64_t v40 = *a1;
      unint64_t v36 = a1[1];
      double v24 = v44;
    }
    *a1 = v38;
    a1[1] = v24;
    uint64_t v41 = a1[2];
    a1[2] = v45;
    long long v44 = v36;
    float v45 = v41;
    float v42 = v40;
    uint64_t v43 = v40;
    if (v36 != v40) {
      long long v44 = &v40[(v36 - v40 - 28) % 0x1CuLL];
    }
    if (v40) {
      operator delete(v40);
    }
  }
  else
  {
    int v18 = *a3;
    int v19 = *a4;
    int v20 = *a5;
    int v21 = *a6;
    int v22 = *a7;
    int v23 = *a8;
    *(_DWORD *)uint64_t v17 = *a2;
    *((_DWORD *)v17 + 1) = v18;
    *((_DWORD *)v17 + 2) = v19;
    *((_DWORD *)v17 + 3) = v20;
    *((_DWORD *)v17 + 4) = v21;
    *((_DWORD *)v17 + 5) = v22;
    double v24 = v17 + 28;
    *((_DWORD *)v17 + 6) = v23;
  }
  a1[1] = v24;
}

atomic_ullong *sub_1DC345504(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 32)) {
    *(unsigned char *)(a1 + 32) = sub_1DC370168((atomic_ullong *)a1, a1 + 8, 1, *(void *)(a1 + 24)) ^ 1;
  }
  return sub_1DC315BA8((atomic_ullong *)a1);
}

void *sub_1DC345560()
{
  return &unk_1F365EDF8;
}

uint64_t sub_1DC34556C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc9inference4anmd17ANMDPostprocessor3runERKNS1_21ANMDImagePreprocessorERKNS_6Sample11PixelBufferERK17CGAffineTransformRNSt3__18optionalINS_5ErrorEEERKNSE_IyEEE3$_4"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3455A8(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDPostprocessor::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC345654(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F918;
}

void *sub_1DC345674()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365F918;
  return result;
}

void sub_1DC3456AC()
{
}

void *sub_1DC3456C4()
{
  return &unk_1F365EDE8;
}

uint64_t sub_1DC3456D0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc9inference4anmd17ANMDPostprocessor3runERKNS1_21ANMDImagePreprocessorERKNS_6Sample11PixelBufferERK17CGAffineTransformRNSt3__18optionalINS_5ErrorEEERKNSE_IyEEE3$_3"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC34570C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDPostprocessor::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3457B8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F8C0;
}

void *sub_1DC3457D8()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365F8C0;
  return result;
}

void sub_1DC345810()
{
}

uint64_t sub_1DC345828(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = atomic_exchange((atomic_ullong *volatile)(a2 + 8), 0);
  *(void *)(a1 + 16) = atomic_exchange((atomic_ullong *volatile)(a2 + 16), 0);
  long long v4 = *(_OWORD *)(a2 + 24);
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(_OWORD *)(a1 + 24) = v4;
  uint64_t v6 = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  uint64_t v7 = a1 + 72;
  *(void *)(v7 - 8) = v6;
  *(unsigned char *)(v7 + 128) = 0;
  if (*(unsigned char *)(a2 + 200))
  {
    sub_1DC31931C(v7, (long long *)(a2 + 72));
    *(unsigned char *)(a1 + 200) = 1;
    if (*(unsigned char *)(a2 + 200))
    {
      sub_1DC3191E0(a2 + 72);
      *(unsigned char *)(a2 + 200) = 0;
    }
  }
  uint64_t v8 = *(void *)(a2 + 208);
  *(void *)(a2 + 208) = 0;
  *(void *)(a1 + 208) = v8;
  uint64_t v9 = *(void *)(a2 + 216);
  *(void *)(a2 + 216) = 0;
  *(void *)(a1 + 216) = v9;
  uint64_t v10 = *(void *)(a2 + 224);
  *(void *)(a2 + 224) = 0;
  *(void *)(a1 + 224) = v10;
  uint64_t v11 = *(void *)(a2 + 232);
  *(void *)(a2 + 232) = 0;
  *(void *)(a1 + 232) = v11;
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
  *(void *)(a1 + 256) = *(void *)(a2 + 256);
  uint64_t v12 = *(void *)(a2 + 264);
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(void *)(a1 + 264) = v12;
  return a1;
}

uint64_t sub_1DC345928(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 264);
  *(void *)(a1 + 264) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  long long v5 = (void **)(a1 + 240);
  sub_1DC345A14(&v5);
  sub_1DC345A9C((uint64_t *)(a1 + 232), 0);
  sub_1DC345A9C((uint64_t *)(a1 + 224), 0);
  sub_1DC345A9C((uint64_t *)(a1 + 216), 0);
  sub_1DC345A9C((uint64_t *)(a1 + 208), 0);
  if (*(unsigned char *)(a1 + 200)) {
    sub_1DC3191E0(a1 + 72);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 16));
  sub_1DC31EB58((atomic_ullong *)(a1 + 8));
  return a1;
}

void sub_1DC345A14(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t *)**a1;
  if (v2)
  {
    long long v4 = (uint64_t *)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      do
        sub_1DC345A9C(--v4, 0);
      while (v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_1DC345A9C(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *BOOL result = a2;
  if (v2)
  {
    sub_1DC315358(v2 + 16);
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

void sub_1DC345AFC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a2 + 128))
  {
    if (*(unsigned char *)(a1 + 128))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(_OWORD *)a1 = v4;
      *(unsigned char *)(a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      sub_1DC31904C((void *)(a1 + 32));
      uint64_t v5 = *(void *)(a2 + 32);
      *(void *)(a2 + 32) = 0;
      *(void *)(a1 + 32) = v5;
      sub_1DC318EB8((void *)(a1 + 40));
      uint64_t v6 = *(void *)(a2 + 40);
      *(void *)(a2 + 40) = 0;
      *(void *)(a1 + 40) = v6;
      sub_1DC3193FC(a1 + 48, (uint64_t *)(a2 + 48));
      sub_1DC3193FC(a1 + 88, (uint64_t *)(a2 + 88));
    }
  }
  else if (*(unsigned char *)(a1 + 128))
  {
    sub_1DC3191E0(a1);
    *(unsigned char *)(a1 + 128) = 0;
  }
  else
  {
    sub_1DC31931C(a1, (long long *)a2);
    *(unsigned char *)(a1 + 128) = 1;
  }
}

uint64_t sub_1DC345BE8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC345A9C((uint64_t *)(i - 8), 0);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DC345C3C()
{
}

uint64_t sub_1DC345D1C(uint64_t *a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1DC3442E4(result);
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

void sub_1DC345D6C()
{
}

void *sub_1DC345E58()
{
  return &unk_1F365ED58;
}

uint64_t sub_1DC345E64(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC345EA0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDModel::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC345F4C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F5A8;
}

void *sub_1DC345F6C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F5A8;
  return result;
}

void sub_1DC345FA4()
{
}

void *sub_1DC345FBC()
{
  return &unk_1F365ED48;
}

uint64_t sub_1DC345FC8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC346004(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDModel::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3460B0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F550;
}

void *sub_1DC3460D0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F550;
  return result;
}

void sub_1DC346108()
{
}

uint64_t sub_1DC346120(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 200)) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 264);
  if (!v2 || !(*(unsigned int (**)(uint64_t))(*(void *)v2 + 24))(v2)) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 264) + 16);
  return v3();
}

void *sub_1DC3461C4()
{
  return &unk_1F3664740;
}

uint64_t sub_1DC3461D0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel3runERKNS_6SampleERKNSt3__18optionalINS6_17reference_wrapperINS2_16InferenceMetricsEEEEERNS7_INS_5ErrorEEERKNS7_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC34620C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDModel::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3462B8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F36646E0;
}

void *sub_1DC3462D8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F36646E0;
  return result;
}

void sub_1DC346310()
{
}

void *sub_1DC346328()
{
  return &unk_1F36646C0;
}

uint64_t sub_1DC346334(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel3runERKNS_6SampleERKNSt3__18optionalINS6_17reference_wrapperINS2_16InferenceMetricsEEEEERNS7_INS_5ErrorEEERKNS7_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC346370(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDModel::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC34641C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664660;
}

void *sub_1DC34643C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F3664660;
  return result;
}

void sub_1DC346474()
{
}

char **sub_1DC34648C()
{
  return off_1E6C3A4F8;
}

const char *sub_1DC34649C()
{
  return "rotation";
}

const char *sub_1DC3464B0()
{
  return "box_cls";
}

const char *sub_1DC3464C4()
{
  return "detections";
}

const char *sub_1DC3464D8()
{
  return "input_image";
}

const char *sub_1DC3464EC()
{
  return "main";
}

const char *sub_1DC3464F8()
{
  return "MRCANMD";
}

uint64_t sub_1DC346504()
{
  return 0;
}

uint64_t sub_1DC34650C()
{
  return 0;
}

const char *sub_1DC346514()
{
  return "anmd-model";
}

void sub_1DC346524()
{
}

void *sub_1DC34653C()
{
  return &unk_1F365D988;
}

uint64_t sub_1DC346548(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel6createERKNS_7Context7OptionsEbRNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC346584(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "ANMDModel::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC346630(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365DD90;
}

void *sub_1DC346650()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365DD90;
  return result;
}

void sub_1DC346688()
{
}

void *sub_1DC3466A0()
{
  return &unk_1F365D978;
}

uint64_t sub_1DC3466AC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel6createERKNS_7Context7OptionsEbRNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3466E8(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC360 != -1) {
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3B8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3B8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "ANMDModel::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC346794(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365DD38;
}

void *sub_1DC3467B4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365DD38;
  return result;
}

void sub_1DC3467EC()
{
}

void sub_1DC346804(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = a2 + 3;
  if (!a2[3]) {
    return;
  }
  long long v4 = (std::__shared_weak_count *)a1;
  uint64_t v5 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock_with_options();
  uint64_t v6 = sub_1DC32E728(&v4[1].__vftable, (unint64_t)&unk_1DC409518);
  if (!v6) {
    operator new();
  }
  if ((_UNKNOWN *)v6[3] != &unk_1DC409518)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_38;
  }
  uint64_t v7 = (atomic_ullong *)v6[6];
  if (!v7)
  {
LABEL_38:
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_39:
    dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
LABEL_13:
    uint64_t v9 = qword_1EBFFC3B8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(context[0]) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "Unable to retrieve or instantiate concrete ANMD context.", (uint8_t *)context, 2u);
    }
    LOBYTE(v15) = 0;
    char v16 = 0;
    sub_1DC390A40((uint64_t)v17, -1, 0);
    sub_1DC390CA0(context, v17);
    char v19 = 1;
    if (!*v2) {
      sub_1DC307C38();
    }
    (*(void (**)(void, uint64_t *, atomic_ullong *))(*(void *)*v2 + 48))(*v2, &v15, context);
    if (v19) {
      sub_1DC390B00(context);
    }
    sub_1DC390B00(v17);
    if (v4) {
      goto LABEL_35;
    }
    return;
  }
  atomic_ullong v8 = *v7;
  long long v4 = (std::__shared_weak_count *)v7[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  if (!v8)
  {
    if (qword_1EBFFC360 == -1) {
      goto LABEL_13;
    }
    goto LABEL_39;
  }
  if (!*v2)
  {
    os_signpost_id_t v2 = &v14;
    goto LABEL_21;
  }
  if ((void *)*v2 != a2)
  {
    uint64_t v14 = (void *)*v2;
LABEL_21:
    void *v2 = 0;
    goto LABEL_23;
  }
  uint64_t v14 = v13;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v13);
LABEL_23:
  if (v14)
  {
    uint64_t v10 = *(NSObject **)(v8 + 472);
    dispatch_time_t v11 = dispatch_time(0, 3000000000);
    if (dispatch_group_wait(v10, v11))
    {
      if (qword_1EBFFC360 != -1) {
        dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
      }
      uint64_t v12 = qword_1EBFFC3B8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3B8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(context[0]) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v12, OS_LOG_TYPE_ERROR, "Timed out waiting for model to be loaded.", (uint8_t *)context, 2u);
      }
      LOBYTE(v15) = 0;
      char v16 = 0;
      sub_1DC390A40((uint64_t)v17, -6010, @"Timed out waiting for model to be loaded.");
      sub_1DC390CA0(context, v17);
      char v19 = 1;
      if (!v14) {
        sub_1DC307C38();
      }
      (*(void (**)(void *, uint64_t *, atomic_ullong *))(*v14 + 48))(v14, &v15, context);
      if (v19) {
        sub_1DC390B00(context);
      }
      sub_1DC390B00(v17);
    }
    else
    {
      context[0] = (atomic_ullong)&unk_1F3661D30;
      context[1] = v8;
      context[2] = (atomic_ullong)v13;
      context[3] = (atomic_ullong)context;
      dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v8 + 8), context, (dispatch_function_t)sub_1DC346FDC);
      sub_1DC307968(context);
    }
  }
  sub_1DC306500(v13);
  if (v4) {
LABEL_35:
  }
    sub_1DC32EEF4(v4);
}

void sub_1DC346DEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC346F20(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 472);
    *(void *)(v1 + 472) = 0;
    if (v2) {
      (*(void (**)(void))(v1 + 480))();
    }
    if (*(unsigned char *)(v1 + 464)) {
      sub_1DC390B00((atomic_ullong *)(v1 + 368));
    }
    if (*(unsigned char *)(v1 + 360)) {
      sub_1DC345928(v1 + 88);
    }
    sub_1DC31EB58((atomic_ullong *)(v1 + 40));
    sub_1DC31EB58((atomic_ullong *)(v1 + 32));
    uint64_t v3 = *(void *)(v1 + 8);
    *(void *)uint64_t v1 = &unk_1F3660CF8;
    *(void *)(v1 + 8) = 0;
    if (v3) {
      (*(void (**)(void))(v1 + 16))();
    }
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

uint64_t sub_1DC346FDC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    sub_1DC307C38();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

void *sub_1DC34702C()
{
  return &unk_1F36609A8;
}

uint64_t sub_1DC347038(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd12_GLOBAL__N_111ANMDContext7performENSt3__18functionIFvONS4_8optionalINS4_17reference_wrapperINS1_9ANMDModelEEEEEONS6_INS_5ErrorEEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC347074(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v2 + 464))
  {
    uint64_t v3 = *(void *)(a1 + 16);
    LOBYTE(__p) = 0;
    char v17 = 0;
    sub_1DC390B4C((uint64_t)&v14, v2 + 368);
    char v15 = 1;
    uint64_t v4 = *(void *)(v3 + 24);
    if (!v4) {
      sub_1DC307C38();
    }
LABEL_3:
    uint64_t result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, void **, atomic_ullong *))(*(void *)v4 + 48))(v4, &__p, &v14);
    if (!v15) {
      return result;
    }
    p_p = &v14;
    return sub_1DC390B00(p_p);
  }
  if (!*(unsigned char *)(v2 + 360))
  {
    dispatch_group_enter(*(dispatch_group_t *)(v2 + 472));
    if (qword_1EBFFC360 != -1) {
      dispatch_once(&qword_1EBFFC360, &unk_1F3662508);
    }
    os_signpost_id_t v12 = os_signpost_id_make_with_pointer((os_log_t)qword_1EBFFC3B8, (const void *)v2);
    char v13 = 1;
    v19[0] = &unk_1F365DD38;
    uint64_t v20 = v19;
    v18[0] = &unk_1F365DD90;
    v18[3] = v18;
    int v21 = &v12;
    sub_1DC31AD78((uint64_t)&v22, (uint64_t)v18);
    if (*((unsigned char *)v21 + 8) && v20) {
      sub_1DC31AE10((uint64_t)v20, *v21);
    }
    sub_1DC31AE60(v18);
    sub_1DC31AE60(v19);
    operator new();
  }
  if (*(unsigned char *)(v2 + 288))
  {
    uint64_t v7 = *(void *)(v2 + 352);
    if (v7)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 24))(v7))
      {
        uint64_t v8 = *(void *)(a1 + 16);
        std::string __p = (void *)(v2 + 88);
        char v17 = 1;
        LOBYTE(v14) = 0;
        char v15 = 0;
        uint64_t v4 = *(void *)(v8 + 24);
        if (!v4) {
          sub_1DC307C38();
        }
        goto LABEL_3;
      }
    }
  }
  uint64_t v9 = *(void *)(a1 + 16);
  LOBYTE(v23) = 0;
  char v24 = 0;
  int v10 = *(unsigned __int8 *)(v2 + 464);
  if (*(unsigned char *)(v2 + 464))
  {
    sub_1DC390B4C((uint64_t)&v14, v2 + 368);
  }
  else
  {
    sub_1DC390A40((uint64_t)&__p, -1, 0);
    sub_1DC390CA0(&v14, (uint64_t *)&__p);
  }
  char v15 = 1;
  uint64_t v11 = *(void *)(v9 + 24);
  if (!v11) {
    sub_1DC307C38();
  }
  uint64_t result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, uint64_t *, atomic_ullong *))(*(void *)v11 + 48))(v11, &v23, &v14);
  if (v15) {
    uint64_t result = sub_1DC390B00(&v14);
  }
  if (!v10)
  {
    p_p = (atomic_ullong *)&__p;
    return sub_1DC390B00(p_p);
  }
  return result;
}

void sub_1DC347FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  sub_1DC31AEE4((uint64_t **)(v50 - 144));
  if (a50) {
    sub_1DC345928((uint64_t)&a16);
  }
  sub_1DC31AEE4((uint64_t **)(v50 - 248));
  _Unwind_Resume(a1);
}

__n128 sub_1DC348190(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3661D30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3481B8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3661D30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC348204()
{
}

void *sub_1DC34821C()
{
  return &unk_1F3660988;
}

uint64_t sub_1DC348228(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeINS_9inference4anmd12_GLOBAL__N_111ANMDContextEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC348264(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(*(void *)a2 + 8);
    if (v2) {
      sub_1DC32EEF4(v2);
    }
    JUMPOUT(0x1E019CE90);
  }
}

void sub_1DC3482CC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3661C80;
}

void *sub_1DC3482EC()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3661C80;
  return result;
}

void sub_1DC348324()
{
}

uint64_t sub_1DC348340(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN3mrc9inference4anmd12_GLOBAL__N_111ANMDContextEE27__shared_ptr_default_deleteIS5_S5_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC34837C(uint64_t a1)
{
  return sub_1DC346F20(*(void *)(a1 + 24));
}

void sub_1DC348384(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC3483C0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 472);
  *(void *)(a1 + 472) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 480))();
  }
  if (*(unsigned char *)(a1 + 464)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 368));
  }
  if (*(unsigned char *)(a1 + 360)) {
    sub_1DC345928(a1 + 88);
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CF8;
  *(void *)(a1 + 8) = 0;
  if (v3) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC348474(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 472);
  *(void *)(a1 + 472) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 480))();
  }
  if (*(unsigned char *)(a1 + 464)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 368));
  }
  if (*(unsigned char *)(a1 + 360)) {
    sub_1DC345928(a1 + 88);
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CF8;
  *(void *)(a1 + 8) = 0;
  if (v3) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void sub_1DC348508(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CF8;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC348578(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CF8;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

atomic_ullong *sub_1DC3485C8@<X0>(uint64_t a1@<X0>, CFErrorRef *a2@<X8>)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  LOBYTE(v4[0]) = 0;
  char v5 = 0;
  v6[0] = &unk_1F365F4F8;
  v6[1] = v4;
  v6[3] = v6;
  sub_1DC346804(a1, v6);
  __n128 result = sub_1DC306500(v6);
  if (v5)
  {
    __n128 result = sub_1DC390F7C(a2, (uint64_t)v4);
    if (v5) {
      return sub_1DC390B00(v4);
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_1DC348688(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a21) {
    sub_1DC390B00(&a9);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC3486B4()
{
  return &unk_1F365ED38;
}

uint64_t sub_1DC3486C0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference4anmd9ANMDModel19preflightForContextERNS_7ContextEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC3486FC(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  if (!a2[8]
    || !*(unsigned char *)(*(void *)a2 + 200)
    || (uint64_t v5 = *(void *)(*(void *)a2 + 264)) == 0
    || (__n128 result = (atomic_ullong *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5),
        (result & 1) == 0))
  {
    uint64_t v7 = *(atomic_ullong **)(a1 + 8);
    return sub_1DC3070F0(v7, a3);
  }
  return result;
}

uint64_t sub_1DC348790(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365F4F8;
  a2[1] = v2;
  return result;
}

void *sub_1DC3487B4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F365F4F8;
  result[1] = v3;
  return result;
}

void sub_1DC3487FC()
{
}

void *sub_1DC348814(void *a1)
{
  *a1 = &unk_1F36618E8;
  uint64_t v2 = (atomic_uint *)a1[2];
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  a1[2] = 0;
  return a1;
}

void sub_1DC348868(void *a1)
{
  sub_1DC348814(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC3488A4(uint64_t a1)
{
  *(void *)a1 = &unk_1F36610F8;
  sub_1DC31191C(*(void **)(a1 + 104));
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  sub_1DC348814((void *)(a1 + 48));
  sub_1DC3119BC((atomic_uint **)(a1 + 40));
  sub_1DC311968((void *)(a1 + 16));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC348934(uint64_t a1)
{
  *(void *)a1 = &unk_1F36610F8;
  sub_1DC31191C(*(void **)(a1 + 104));
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  sub_1DC348814((void *)(a1 + 48));
  sub_1DC3119BC((atomic_uint **)(a1 + 40));
  sub_1DC311968((void *)(a1 + 16));
  return a1;
}

uint64_t sub_1DC3489A4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, long long *a5)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F36610F8;
  sub_1DC314778(a1 + 16, a2);
  *(void *)(a1 + 40) = 0;
  uint64_t v9 = (atomic_uint **)(a1 + 40);
  uint64_t v10 = *a3;
  if (v10)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v10 + 8), 1u, memory_order_relaxed);
    if (*v9) {
      sub_1DC2FF57C(*v9);
    }
  }
  *(void *)(a1 + 40) = v10;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = &unk_1F36618E8;
  *(void *)(a1 + 64) = 0;
  uint64_t v11 = *(void *)(a4 + 16);
  if (v11)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v11 + 8), 1u, memory_order_relaxed);
    os_signpost_id_t v12 = *(atomic_uint **)(a1 + 64);
    if (v12) {
      sub_1DC2FF57C(v12);
    }
  }
  *(void *)(a1 + 64) = v11;
  char v13 = (unsigned char *)(a1 + 72);
  if (*((char *)a5 + 23) < 0)
  {
    sub_1DC312750(v13, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v14 = *a5;
    *(void *)(a1 + 88) = *((void *)a5 + 2);
    *(_OWORD *)char v13 = v14;
  }
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  return a1;
}

void sub_1DC348AC0(_Unwind_Exception *a1)
{
  sub_1DC348814(v3);
  sub_1DC3119BC(v2);
  sub_1DC311968(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC348AF4(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F36610F8;
  sub_1DC314778(a1 + 16, a2);
  *(void *)(a1 + 40) = 0;
  uint64_t v7 = (atomic_uint **)(a1 + 40);
  uint64_t v8 = *a3;
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v8 + 8), 1u, memory_order_relaxed);
    if (*v7) {
      sub_1DC2FF57C(*v7);
    }
  }
  *(void *)(a1 + 40) = v8;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = &unk_1F36618E8;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  sub_1DC3117A4(a1 + 96, a4);
  return a1;
}

void sub_1DC348BC0(_Unwind_Exception *a1)
{
  sub_1DC311968(v1);
  _Unwind_Resume(a1);
}

void sub_1DC348E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

double sub_1DC348E94()
{
  double result = 0.0;
  xmmword_1EBFFB758 = 0u;
  *(_OWORD *)&qword_1EBFFB768 = 0u;
  dword_1EBFFB778 = 1065353216;
  qword_1EBFFB750 = (uint64_t)&xmmword_1EBFFB758;
  return result;
}

uint64_t sub_1DC348EB8(unint64_t a1, void *a2)
{
  uint64_t v3 = a2 + 3;
  if (!a2[3]) {
    goto LABEL_83;
  }
  os_unfair_lock_lock_with_options();
  if (qword_1EBFFB788 != -1) {
    dispatch_once(&qword_1EBFFB788, &unk_1F36623E8);
  }
  uint64_t v5 = qword_1EBFFB750 + 16;
  uint64_t v6 = operator new(0x38uLL);
  uint64_t v7 = v6;
  v41[0] = v6;
  v41[1] = v5;
  void *v6 = 0;
  v6[1] = 0;
  v6[2] = a1;
  uint64_t v8 = (void *)*v3;
  if (*v3)
  {
    if (v8 == a2)
    {
      v6[6] = v6 + 3;
      (*(void (**)(void *))(*a2 + 24))(a2);
      unint64_t v9 = v7[2];
      goto LABEL_11;
    }
    v6[6] = v8;
  }
  else
  {
    uint64_t v3 = v6 + 6;
  }
  void *v3 = 0;
  unint64_t v9 = a1;
LABEL_11:
  char v42 = 1;
  v7[1] = v9;
  int8x8_t v10 = *(int8x8_t *)((char *)&xmmword_1EBFFB758 + 8);
  if (*((void *)&xmmword_1EBFFB758 + 1))
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EBFFB758 + 8));
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v12 = v9;
      if (*((void *)&xmmword_1EBFFB758 + 1) <= v9) {
        unint64_t v12 = v9 % *((void *)&xmmword_1EBFFB758 + 1);
      }
    }
    else
    {
      unint64_t v12 = (*((void *)&xmmword_1EBFFB758 + 1) - 1) & v9;
    }
    char v13 = *(void **)(xmmword_1EBFFB758 + 8 * v12);
    if (v13)
    {
      for (uint64_t i = (void *)*v13; i; uint64_t i = (void *)*i)
      {
        unint64_t v15 = i[1];
        if (v15 == v9)
        {
          if (i[2] == v7[2]) {
            goto LABEL_82;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v15 >= *((void *)&xmmword_1EBFFB758 + 1)) {
              v15 %= *((void *)&xmmword_1EBFFB758 + 1);
            }
          }
          else
          {
            v15 &= *((void *)&xmmword_1EBFFB758 + 1) - 1;
          }
          if (v15 != v12) {
            break;
          }
        }
      }
    }
  }
  float v16 = (float)(unint64_t)(qword_1EBFFB770 + 1);
  if (!*((void *)&xmmword_1EBFFB758 + 1)
    || (float)(*(float *)&dword_1EBFFB778 * (float)*((unint64_t *)&xmmword_1EBFFB758 + 1)) < v16)
  {
    BOOL v17 = 1;
    if (*((void *)&xmmword_1EBFFB758 + 1) >= 3uLL) {
      BOOL v17 = (*((void *)&xmmword_1EBFFB758 + 1) & (*((void *)&xmmword_1EBFFB758 + 1) - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * *((void *)&xmmword_1EBFFB758 + 1));
    unint64_t v19 = vcvtps_u32_f32(v16 / *(float *)&dword_1EBFFB778);
    if (v18 <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    else {
      int8x8_t prime = (int8x8_t)v18;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      int8x8_t v10 = *(int8x8_t *)((char *)&xmmword_1EBFFB758 + 8);
    }
    if (*(void *)&prime > *(void *)&v10) {
      goto LABEL_98;
    }
    if (*(void *)&prime >= *(void *)&v10) {
      goto LABEL_68;
    }
    unint64_t v27 = vcvtps_u32_f32((float)(unint64_t)qword_1EBFFB770 / *(float *)&dword_1EBFFB778);
    if (*(void *)&v10 < 3uLL || (uint8x8_t v28 = (uint8x8_t)vcnt_s8(v10), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
    {
      unint64_t v27 = std::__next_prime(v27);
    }
    else
    {
      uint64_t v29 = 1 << -(char)__clz(v27 - 1);
      if (v27 >= 2) {
        unint64_t v27 = v29;
      }
    }
    if (*(void *)&prime <= v27) {
      int8x8_t prime = (int8x8_t)v27;
    }
    if (*(void *)&prime >= *(void *)&v10)
    {
      int8x8_t v10 = *(int8x8_t *)((char *)&xmmword_1EBFFB758 + 8);
      goto LABEL_68;
    }
    if (prime)
    {
LABEL_98:
      if (*(void *)&prime >> 61) {
        sub_1DC2FF994();
      }
      int v21 = operator new(8 * *(void *)&prime);
      uint64_t v22 = (void *)xmmword_1EBFFB758;
      *(void *)&xmmword_1EBFFB758 = v21;
      if (v22) {
        operator delete(v22);
      }
      uint64_t v23 = 0;
      *((int8x8_t *)&xmmword_1EBFFB758 + 1) = prime;
      do
        *(void *)(xmmword_1EBFFB758 + 8 * v23++) = 0;
      while (*(void *)&prime != v23);
      char v24 = (void **)qword_1EBFFB768;
      if (qword_1EBFFB768)
      {
        unint64_t v25 = *(void *)(qword_1EBFFB768 + 8);
        uint8x8_t v26 = (uint8x8_t)vcnt_s8(prime);
        v26.i16[0] = vaddlv_u8(v26);
        if (v26.u32[0] > 1uLL)
        {
          if (v25 >= *(void *)&prime) {
            v25 %= *(void *)&prime;
          }
        }
        else
        {
          v25 &= *(void *)&prime - 1;
        }
        *(void *)(xmmword_1EBFFB758 + 8 * v25) = v5;
        for (j = *v24; j; unint64_t v25 = v31)
        {
          unint64_t v31 = j[1];
          if (v26.u32[0] > 1uLL)
          {
            if (v31 >= *(void *)&prime) {
              v31 %= *(void *)&prime;
            }
          }
          else
          {
            v31 &= *(void *)&prime - 1;
          }
          if (v31 != v25)
          {
            if (!*(void *)(xmmword_1EBFFB758 + 8 * v31))
            {
              *(void *)(xmmword_1EBFFB758 + 8 * v31) = v24;
              goto LABEL_64;
            }
            *char v24 = (void *)*j;
            *uint64_t j = **(void **)(xmmword_1EBFFB758 + 8 * v31);
            **(void **)(xmmword_1EBFFB758 + 8 * v31) = j;
            uint64_t j = v24;
          }
          unint64_t v31 = v25;
LABEL_64:
          char v24 = (void **)j;
          uint64_t j = (void *)*j;
        }
      }
      int8x8_t v10 = prime;
    }
    else
    {
      long long v39 = (void *)xmmword_1EBFFB758;
      *(void *)&xmmword_1EBFFB758 = 0;
      if (v39) {
        operator delete(v39);
      }
      int8x8_t v10 = 0;
      *((void *)&xmmword_1EBFFB758 + 1) = 0;
    }
  }
LABEL_68:
  unint64_t v32 = v7[1];
  uint8x8_t v33 = (uint8x8_t)vcnt_s8(v10);
  v33.i16[0] = vaddlv_u8(v33);
  if (v33.u32[0] > 1uLL)
  {
    if (v32 >= *(void *)&v10) {
      v32 %= *(void *)&v10;
    }
  }
  else
  {
    v32 &= *(void *)&v10 - 1;
  }
  uint64_t v34 = xmmword_1EBFFB758;
  int v35 = *(void **)(xmmword_1EBFFB758 + 8 * v32);
  if (v35)
  {
    void *v7 = *v35;
  }
  else
  {
    void *v7 = qword_1EBFFB768;
    qword_1EBFFB768 = (uint64_t)v7;
    *(void *)(v34 + 8 * v32) = v5;
    if (!*v7) {
      goto LABEL_81;
    }
    unint64_t v36 = *(void *)(*v7 + 8);
    if (v33.u32[0] > 1uLL)
    {
      if (v36 >= *(void *)&v10) {
        v36 %= *(void *)&v10;
      }
    }
    else
    {
      v36 &= *(void *)&v10 - 1;
    }
    int v35 = (void *)(xmmword_1EBFFB758 + 8 * v36);
  }
  void *v35 = v7;
LABEL_81:
  ++qword_1EBFFB770;
  v41[0] = 0;
LABEL_82:
  sub_1DC3493D8((uint64_t)v41);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EBFFB7F0);
LABEL_83:
  float v37 = (objc_class *)objc_opt_class();
  Name = class_getName(v37);
  return MEMORY[0x1F40D90C8](a1, Name);
}

void sub_1DC3493C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3493D8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DC3493D8(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1DC30AC9C(v1 + 3);
    }
    operator delete(v1);
  }
}

void sub_1DC349430(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661230;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC349494(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661230;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  return a1;
}

BOOL sub_1DC3494D8(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v6 = *(void **)(a1 + 16);
  if (a3 <= a2) {
    int v7 = a2;
  }
  else {
    int v7 = a3;
  }
  uint64_t v8 = v7;
  if (a5)
  {
    uint64_t v9 = a2;
    uint64_t v10 = a4;
    int v11 = sub_1DC2FF924(*(void **)(a1 + 16), a2, a4) ^ 1;
    while (1)
    {
      BOOL result = v8 != v9;
      if (v8 == v9) {
        break;
      }
      int v13 = sub_1DC2FF924(v6, ++v9, v10);
      int v14 = *(unsigned __int8 *)(a1 + 32);
      if (v14 == 2) {
        int v15 = 0;
      }
      else {
        int v15 = v11;
      }
      if (v14 == 1) {
        int v16 = 1;
      }
      else {
        int v16 = v15;
      }
      if (v13 == v16) {
        return 1;
      }
    }
  }
  else
  {
    uint64_t v17 = a4;
    uint64_t v18 = a2;
    int v19 = sub_1DC2FF924(*(void **)(a1 + 16), a4, a2) ^ 1;
    while (1)
    {
      BOOL result = v8 != v18;
      if (v8 == v18) {
        break;
      }
      int v20 = sub_1DC2FF924(v6, v17, ++v18);
      int v21 = *(unsigned __int8 *)(a1 + 32);
      if (v21 == 2) {
        int v22 = 0;
      }
      else {
        int v22 = v19;
      }
      if (v21 == 1) {
        int v23 = 1;
      }
      else {
        int v23 = v22;
      }
      if (v20 == v23) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_1DC3495D4(void *a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
  float v9 = sqrtf((float)((float)(a4 - a6) * (float)(a4 - a6)) + (float)((float)(a3 - a5) * (float)(a3 - a5))) + 0.5;
  int v10 = (int)v9;
  if ((int)v9 >= 2)
  {
    float v12 = (float)(int)v9;
    float v13 = (float)(a5 - a3) / v12;
    int v14 = *(void **)(a2 + 16);
    float v15 = (float)(a6 - a4) / v12;
    int v16 = sub_1DC2FF924(v14, (int)(float)(a3 + 0.5), (int)(float)(a4 + 0.5)) ^ 1;
    int v17 = *(unsigned __int8 *)(a2 + 32);
    if (v17 == 2) {
      int v16 = 0;
    }
    if (v17 == 1) {
      int v18 = 1;
    }
    else {
      int v18 = v16;
    }
    int v19 = 1;
    do
    {
      if (sub_1DC2FF924(v14, (int)(float)((float)(a3 + (float)((float)v19 * v13)) + 0.5), (int)(float)((float)(a4 + (float)((float)v19 * v15)) + 0.5)) == v18)operator new(); {
      ++v19;
      }
    }
    while (v10 != v19);
  }
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

void sub_1DC34974C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

void sub_1DC349AE0(_Unwind_Exception *a1)
{
  do
    sub_1DC2FFD08(--v2);
  while (v2 != v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC349B00(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = 0; i != 32; i += 8)
  {
    uint64_t v5 = *(void *)(a2 + i);
    if (v5) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
    }
    uint64_t v6 = *(atomic_uint **)(a1 + i);
    if (v6) {
      sub_1DC2FF57C(v6);
    }
    *(void *)(a1 + i) = v5;
  }
  return a1;
}

void sub_1DC349B6C(void *a1, _DWORD *a2)
{
  uint64_t v2 = (uint64_t)a2;
  char v3 = 0;
  int v72 = a2[8];
  LODWORD(v4) = a2[10];
  uint64_t v70 = a2[9];
  uint64_t v5 = a2[11];
  uint64_t v67 = (int)a2[6];
LABEL_2:
  char v66 = v3;
  uint64_t v68 = (int)v5;
  uint64_t v6 = v70;
  uint64_t v71 = v5;
  uint64_t v7 = 0;
  if ((int)v70 >= (int)v67) {
    goto LABEL_11;
  }
  uint64_t v6 = (int)v70;
  int v8 = v4 - v5 + 1;
  uint64_t v9 = (int)v70;
  while ((int)v5 <= (int)v4)
  {
    int v10 = *(void **)(v2 + 16);
    int v11 = v8;
    uint64_t v12 = v68;
    while (!sub_1DC2FF924(v10, v9, v12))
    {
      ++v12;
      if (!--v11)
      {
        uint64_t v6 = v9;
        goto LABEL_11;
      }
    }
    ++v9;
    uint64_t v7 = 1;
    LODWORD(v5) = v71;
    if (v9 >= v67)
    {
      uint64_t v6 = v9;
      goto LABEL_11;
    }
  }
  uint64_t v7 = 0;
LABEL_11:
  uint64_t v70 = v6;
  if ((int)v6 >= (int)v67) {
    goto LABEL_91;
  }
  int v13 = *(_DWORD *)(v2 + 28);
  if ((int)v4 >= v13)
  {
    char v16 = v7;
  }
  else
  {
    uint64_t v14 = v72;
    uint64_t v4 = (int)v4;
    uint64_t v15 = (v6 - v72 + 1);
    int v65 = v4;
    char v16 = v7;
    while (v72 <= (int)v70)
    {
      uint64_t v17 = v7;
      int v18 = *(void **)(v2 + 16);
      uint64_t v19 = v15;
      uint64_t v20 = v14;
      while (!sub_1DC2FF924(v18, v14, v4))
      {
        ++v14;
        LODWORD(v15) = v15 - 1;
        if (!v15) {
          goto LABEL_24;
        }
      }
      ++v4;
      char v16 = 1;
      uint64_t v14 = v20;
      uint64_t v15 = v19;
      uint64_t v7 = v17;
      if (v13 == v4) {
        goto LABEL_24;
      }
    }
    char v16 = v7;
    LODWORD(v4) = v65;
  }
LABEL_24:
  if ((int)v4 >= v13 || v72 < 0) {
    goto LABEL_91;
  }
  uint64_t v21 = v72;
  char v22 = v16;
  while (1)
  {
    if ((int)v71 > (int)v4)
    {
      char v22 = v16;
      goto LABEL_36;
    }
    int v23 = *(void **)(v2 + 16);
    int v24 = v4 + 1 - v71;
    uint64_t v25 = v68;
    while (!sub_1DC2FF924(v23, v21, v25))
    {
      ++v25;
      if (!--v24)
      {
        int v72 = v21;
        if ((v21 & 0x80000000) != 0) {
          goto LABEL_91;
        }
LABEL_36:
        if ((v71 & 0x80000000) != 0) {
          goto LABEL_91;
        }
        uint64_t v27 = v72;
        uint64_t v28 = v71;
        uint64_t v29 = (v70 - v72 + 1);
        char v30 = v22;
        char v69 = v22;
        while (1)
        {
          int v31 = v70 - v72;
          if ((int)v70 < v72) {
            break;
          }
          uint64_t v32 = v2;
          uint8x8_t v33 = *(void **)(v2 + 16);
          uint64_t v34 = v29;
          int v35 = v29;
          uint64_t v36 = v27;
          while (!sub_1DC2FF924(v33, v27, v28))
          {
            ++v27;
            if (!--v35)
            {
              uint64_t v71 = v28;
              uint64_t v2 = v32;
              if ((v28 & 0x80000000) == 0) {
                goto LABEL_47;
              }
LABEL_91:
              exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
              sub_1DC3914A8(exception, "No black point found on border");
              __cxa_throw(exception, (struct type_info *)&unk_1F365FFB0, (void (*)(void *))sub_1DC3914A4);
            }
          }
          char v30 = 1;
          BOOL v26 = v28-- <= 0;
          uint64_t v2 = v32;
          char v22 = v69;
          uint64_t v27 = v36;
          uint64_t v29 = v34;
          if (v26) {
            goto LABEL_91;
          }
        }
        char v30 = v22;
LABEL_47:
        char v3 = 1;
        uint64_t v5 = v71;
        if ((v30 & 1) == 0)
        {
          if (v66)
          {
            int v37 = v4 + 1;
            if ((int)v4 + 1 >= v31) {
              int v37 = v70 - v72;
            }
            if (v37 >= 2)
            {
              float v38 = (float)v72;
              float v39 = (float)(int)v4;
              int v40 = v72 + 1;
              int v41 = v4 - 1;
              int v42 = v37 - 1;
              int v43 = v37 - 1;
              int v44 = v41;
              do
              {
                sub_1DC34AA04(v77, v2, v38, (float)v44, (float)v40, v39);
                float v45 = v77[0];
                if (v77[0]) {
                  atomic_fetch_add_explicit(v77[0] + 2, 1u, memory_order_relaxed);
                }
                uint64_t v76 = v45;
                sub_1DC2FFD08(v77);
                if (v45)
                {
                  int v47 = *(_DWORD *)(v2 + 28) - v71;
                  if (v47 >= v31) {
                    int v47 = v70 - v72;
                  }
                  if (v47 >= 2)
                  {
                    for (int i = 1; i < v50; ++i)
                    {
                      sub_1DC34AA04(v77, v2, v38, (float)(v71 + i), (float)(v72 + i), (float)(int)v71);
                      long long v49 = v77[0];
                      if (v77[0]) {
                        atomic_fetch_add_explicit(v77[0] + 2, 1u, memory_order_relaxed);
                      }
                      uint64_t v75 = v49;
                      sub_1DC2FFD08(v77);
                      if (v49)
                      {
                        int v52 = *(_DWORD *)(v2 + 28) - v71;
                        if (v52 >= v31) {
                          int v52 = v70 - v72;
                        }
                        if (v52 >= 2)
                        {
                          float v53 = (float)(int)v70;
                          int v54 = v70 - 1;
                          int v55 = v70 - 1;
                          int v56 = 1;
                          do
                          {
                            sub_1DC34AA04(v77, v2, v53, (float)(v71 + v56), (float)v55, (float)(int)v71);
                            uint64_t v57 = v77[0];
                            if (v77[0]) {
                              atomic_fetch_add_explicit(v77[0] + 2, 1u, memory_order_relaxed);
                            }
                            long long v74 = v57;
                            sub_1DC2FFD08(v77);
                            if (v57)
                            {
                              while (1)
                              {
                                sub_1DC34AA04(v77, v2, v53, (float)v41, (float)v54, v39);
                                float v60 = v77[0];
                                if (v77[0]) {
                                  atomic_fetch_add_explicit(v77[0] + 2, 1u, memory_order_relaxed);
                                }
                                sub_1DC2FFD08(v77);
                                if (v60)
                                {
                                  atomic_fetch_add_explicit(v60 + 2, 1u, memory_order_relaxed);
                                  atomic_fetch_add_explicit(v76 + 2, 1u, memory_order_relaxed);
                                  atomic_fetch_add_explicit(v74 + 2, 1u, memory_order_relaxed);
                                  atomic_fetch_add_explicit(v75 + 2, 1u, memory_order_relaxed);
                                  int v73 = v75;
                                  float v62 = (*(float (**)(atomic_uint *))(*(void *)v60 + 16))(v60);
                                  (*(void (**)(atomic_uint *))(*(void *)v60 + 24))(v60);
                                  (*(void (**)(atomic_uint *))(*(void *)v76 + 16))(v76);
                                  (*(void (**)(atomic_uint *))(*(void *)v76 + 24))(v76);
                                  (*(void (**)(atomic_uint *))(*(void *)v74 + 16))(v74);
                                  (*(void (**)(atomic_uint *))(*(void *)v74 + 24))(v74);
                                  (*(void (**)(atomic_uint *))(*(void *)v73 + 16))(v73);
                                  (*(void (**)(atomic_uint *))(*(void *)v73 + 24))(v73);
                                  sub_1DC34AB34(a1, 4uLL);
                                  if (v62 < (float)((float)*(int *)(v2 + 24) * 0.5)) {
                                    operator new();
                                  }
                                  operator new();
                                }
                                --v54;
                                --v41;
                                if (!--v42)
                                {
                                  uint64_t v61 = __cxa_allocate_exception(0x20uLL);
                                  sub_1DC379B70(v61, "y == NULL");
                                  *uint64_t v61 = &unk_1F3661208;
                                  __cxa_throw(v61, (struct type_info *)&unk_1F365FFB0, (void (*)(void *))sub_1DC3914A4);
                                }
                              }
                            }
                            ++v56;
                            int v58 = *(_DWORD *)(v2 + 28) - v71;
                            if (v58 >= v31) {
                              int v58 = v70 - v72;
                            }
                            --v55;
                          }
                          while (v56 < v58);
                        }
                        char v59 = __cxa_allocate_exception(0x20uLL);
                        sub_1DC379B70(v59, "x == NULL");
                        *char v59 = &unk_1F3661208;
                        __cxa_throw(v59, (struct type_info *)&unk_1F365FFB0, (void (*)(void *))sub_1DC3914A4);
                      }
                      int v50 = *(_DWORD *)(v2 + 28) - v71;
                      if (v50 >= v31) {
                        int v50 = v70 - v72;
                      }
                    }
                  }
                  char v51 = __cxa_allocate_exception(0x20uLL);
                  sub_1DC379B70(v51, "t == NULL");
                  void *v51 = &unk_1F3661208;
                  __cxa_throw(v51, (struct type_info *)&unk_1F365FFB0, (void (*)(void *))sub_1DC3914A4);
                }
                ++v40;
                --v44;
                --v43;
              }
              while (v43);
            }
            float v46 = __cxa_allocate_exception(0x20uLL);
            sub_1DC379B70(v46, "z == NULL");
            *float v46 = &unk_1F3661208;
            __cxa_throw(v46, (struct type_info *)&unk_1F365FFB0, (void (*)(void *))sub_1DC3914A4);
          }
          goto LABEL_91;
        }
        goto LABEL_2;
      }
    }
    char v22 = 1;
    BOOL v26 = v21-- <= 0;
    if (v26) {
      goto LABEL_91;
    }
  }
}

void sub_1DC34A89C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, atomic_uint *a18, atomic_uint *a19, atomic_uint *a20,atomic_uint *a21,atomic_uint *a22,atomic_uint *a23,atomic_uint *a24,atomic_uint *a25,uint64_t a26,atomic_uint *a27,atomic_uint *a28,void **a29)
{
  a29 = a10;
  sub_1DC2FFC48(&a29);
  sub_1DC2FFD08(&a18);
  sub_1DC2FFD08(&a19);
  sub_1DC2FFD08(&a20);
  sub_1DC2FFD08(&a21);
  sub_1DC2FFD08(&a22);
  sub_1DC2FFD08(&a23);
  sub_1DC2FFD08(&a24);
  sub_1DC2FFD08(&a25);
  _Unwind_Resume(a1);
}

void sub_1DC34A9F4()
{
  __cxa_free_exception(v0);
  JUMPOUT(0x1DC34A9DCLL);
}

uint64_t sub_1DC34AA04(void *a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
  float v9 = sqrtf((float)((float)(a4 - a6) * (float)(a4 - a6)) + (float)((float)(a3 - a5) * (float)(a3 - a5))) + 0.5;
  int v10 = (int)v9;
  if ((int)v9 >= 1)
  {
    int v11 = 0;
    float v12 = (float)(int)v9;
    float v13 = (float)(a5 - a3) / v12;
    uint64_t v14 = *(void **)(a2 + 16);
    float v15 = (float)(a6 - a4) / v12;
    do
    {
      if (sub_1DC2FF924(v14, (int)(float)((float)(a3 + (float)((float)v11 * v13)) + 0.5), (int)(float)((float)(a4 + (float)((float)v11 * v15)) + 0.5)))operator new(); {
      ++v11;
      }
    }
    while (v10 != v11);
  }
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

void *sub_1DC34AB34(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DC2FFD3C(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1DC34ABA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_1DC34ABB4(uint64_t a1@<X0>, void *a2@<X8>)
{
  sub_1DC34ABF8(&v3, a1);
  if (v4) {
    sub_1DC32EEF4(v4);
  }
  *a2 = 0;
}

void sub_1DC34ABF8(void *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 8);
  os_unfair_lock_lock_with_options();
  uint64_t v5 = sub_1DC32E728((void *)(a2 + 24), (unint64_t)&unk_1DC4099A0);
  if (!v5)
  {
    float v9 = &unk_1DC4099A0;
    int v10 = "DecoderAppC3DContext";
    uint64_t v11 = 20;
    operator new();
  }
  if ((_UNKNOWN *)v5[3] != &unk_1DC4099A0)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_9:
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  uint64_t v6 = (uint64_t *)v5[6];
  if (!v6) {
    goto LABEL_9;
  }
  uint64_t v8 = *v6;
  uint64_t v7 = v6[1];
  *a1 = v8;
  a1[1] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
}

void sub_1DC34AE8C(_Unwind_Exception *a1)
{
  sub_1DC32E940((uint64_t *)(v2 + 24));
  sub_1DC32E9A8((void *)(v2 + 32));
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC34AF08(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    sub_1DC34B130((uint64_t **)(result + 24), 0);
    uint64_t v2 = *(void *)(v1 + 8);
    *(void *)uint64_t v1 = &unk_1F3660CB8;
    *(void *)(v1 + 8) = 0;
    if (v2) {
      (*(void (**)(void))(v1 + 16))();
    }
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

void *sub_1DC34AF8C()
{
  return &unk_1F3660968;
}

uint64_t sub_1DC34AF98(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeINS_12_GLOBAL__N_120DecoderAppC3DContextEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC34AFD4(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(*(void *)a2 + 8);
    if (v2) {
      sub_1DC32EEF4(v2);
    }
    JUMPOUT(0x1E019CE90);
  }
}

void sub_1DC34B03C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3661BD0;
}

void *sub_1DC34B05C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F3661BD0;
  return result;
}

void sub_1DC34B094()
{
}

uint64_t sub_1DC34B0B0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN3mrc12_GLOBAL__N_120DecoderAppC3DContextEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC34B0EC(uint64_t a1)
{
  return sub_1DC34AF08(*(void *)(a1 + 24));
}

void sub_1DC34B0F4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t *sub_1DC34B130(uint64_t **a1, uint64_t *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1DC34B180(result);
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

uint64_t *sub_1DC34B180(uint64_t *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  if (*a1)
  {
    if (qword_1EBFFB710 != -1) {
      dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
    }
    uint64_t v3 = qword_1EBFFB748;
    if (os_log_type_enabled((os_log_t)qword_1EBFFB748, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t v5 = 134349056;
      *(void *)&v5[4] = v2;
      _os_log_debug_impl(&dword_1DC2FE000, v3, OS_LOG_TYPE_DEBUG, "AppC3D session will be released: %{public}p", v5, 0xCu);
    }
    AppC3DRelease();
  }
  if (*((unsigned char *)a1 + 128)) {
    sub_1DC390B00(a1 + 4);
  }
  *(void *)uint64_t v5 = a1 + 1;
  sub_1DC307038((void ***)v5);
  return a1;
}

void sub_1DC34B28C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1DC2FFA58(a1);
}

void sub_1DC34B298(uint64_t a1)
{
  sub_1DC34B130((uint64_t **)(a1 + 24), 0);
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CB8;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC34B314(uint64_t a1)
{
  sub_1DC34B130((uint64_t **)(a1 + 24), 0);
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CB8;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void sub_1DC34B370(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CB8;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC34B3E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CB8;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void sub_1DC34B430(uint64_t a1, dispatch_group_t *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)long long buf = 4;
  char v13 = 1;
  if (sub_1DC3778A8(*(atomic_ullong **)(a1 + 8), @"AppClipCode", (uint64_t)buf))
  {
    if ((os_variant_has_factory_content() & 1) == 0 && MEMORY[0x1E4F4AC28] && MEMORY[0x1E4F4AC20] != 0)
    {
      dispatch_group_enter(a2[9]);
      CFTypeRef explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
      if (explicit)
      {
        CFTypeID v6 = CFGetTypeID(explicit);
        if (qword_1EBFFB7E0 != -1)
        {
          CFTypeID v11 = v6;
          dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
          CFTypeID v6 = v11;
        }
        if (v6 != qword_1EBFFB818) {
          _os_assumes_log();
        }
      }
      uint64_t v7 = (char *)operator new(0x60uLL);
      long long v8 = *(_OWORD *)a2;
      *(_OWORD *)(v7 + 24) = *((_OWORD *)a2 + 1);
      long long v9 = *((_OWORD *)a2 + 3);
      *(_OWORD *)(v7 + 40) = *((_OWORD *)a2 + 2);
      *(_OWORD *)(v7 + 56) = v9;
      *(_OWORD *)(v7 + 72) = *((_OWORD *)a2 + 4);
      *(void *)uint64_t v7 = &unk_1F3661F98;
      *(_OWORD *)(v7 + 8) = v8;
      *((void *)v7 + 11) = a1;
      float v15 = v7;
      sub_1DC3C164C((uint64_t)explicit + 16, 1, (uint64_t)v14);
    }
    if (qword_1EBFFB710 != -1) {
      dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
    }
    int v10 = qword_1EBFFB748;
    if (os_log_type_enabled((os_log_t)qword_1EBFFB748, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_INFO, "AppC3D is not available.", buf, 2u);
    }
  }
  LOWORD(a2[8]->isa) = 256;
}

void sub_1DC34B638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1DC307968((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC34B64C()
{
  return &unk_1F3660A18;
}

uint64_t sub_1DC34B658(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder18decodeUsingAppC3D_ERKNS0_4PassEE3$_0")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_1DC34B694(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFTypeRef explicit = (const void *)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 88), memory_order_acquire);
  if (explicit)
  {
    CFTypeID v3 = CFGetTypeID(explicit);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v3 != qword_1EBFFB818) {
      _os_assumes_log();
    }
  }
  sub_1DC34ABF8(&v9, (uint64_t)explicit + 16);
  uint64_t v4 = v9;
  uint64_t v5 = *(void *)(a1 + 48);
  long long v8 = *(_OWORD *)(a1 + 8);
  CFTypeID v6 = operator new(0x38uLL);
  void *v6 = &unk_1F365EE70;
  v6[1] = v4;
  v6[2] = v5;
  v6[3] = a1 + 56;
  *((_OWORD *)v6 + 2) = v8;
  v6[6] = a1 + 32;
  uint64_t v14 = v6;
  context[0] = v13;
  context[1] = &v12;
  dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v4 + 8), context, (dispatch_function_t)sub_1DC34B880);
  __int16 v7 = v12;
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  **(_WORD **)(a1 + 72) = v7 | 0x100;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 80));
  if (v10) {
    sub_1DC32EEF4(v10);
  }
}

void sub_1DC34B860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1DC32EEF4(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC34B880(void *a1)
{
  uint64_t v2 = *(void *)(*a1 + 24);
  if (!v2) {
    sub_1DC307C38();
  }
  CFTypeID v3 = (unsigned char *)a1[1];
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
  unsigned char *v3 = result;
  return result;
}

void *sub_1DC34B8DC()
{
  return &unk_1F365EC08;
}

uint64_t sub_1DC34B8E8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_120DecoderAppC3DContext6decodeERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS5_IyEERKNS_6SampleERKNS5_INS4_17reference_wrapperIKNS_6RegionEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC34B924(double *a1)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)a1 + 1);
  uint64_t v5 = *(uint64_t **)(v2 + 24);
  CFTypeID v3 = (uint64_t **)(v2 + 24);
  uint64_t v4 = v5;
  if (v5) {
    goto LABEL_31;
  }
  __int16 v7 = (atomic_ullong *)*((void *)a1 + 2);
  CGFloat v6 = a1[3];
  double Width = COERCE_DOUBLE(&unk_1F365EF20);
  *(void *)&v90.f64[1] = &Width;
  v94.i64[0] = (uint64_t)&unk_1F365EEC8;
  v95.i64[1] = (uint64_t)&v94;
  v86[0].a = v6;
  sub_1DC31AD78((uint64_t)&v86[0].b, (uint64_t)&v94);
  if (*(unsigned char *)(*(void *)&v86[0].a + 8)) {
    BOOL v8 = *(void *)&v90.f64[1] == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8) {
    sub_1DC31AE10(*(uint64_t *)&v90.f64[1], **(void **)&v86[0].a);
  }
  sub_1DC31AE60(&v94);
  sub_1DC31AE60(&Width);
  v100[0] = 0;
  v99[0] = 0;
  v83.value = 0;
  AppC3DConfigCreate();
  unint64_t v9 = v100[0];
  if (v100[0] || !v99[0])
  {
    if (qword_1EBFFB710 != -1) {
      dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
    }
    char v13 = qword_1EBFFB748;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFB748, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    LODWORD(buf[0]) = 138543362;
    *(uint64_t *)((char *)buf + 4) = v9;
    __int16 v80 = "AppC3DConfigCreate failed, and returned %{public}@";
LABEL_156:
    _os_log_error_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_ERROR, v80, (uint8_t *)buf, 0xCu);
    goto LABEL_22;
  }
  AppC3DConfigSetTrackingConfig();
  unint64_t v10 = v100[0];
  if (v100[0])
  {
    if (qword_1EBFFB710 != -1) {
      dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
    }
    char v13 = qword_1EBFFB748;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFB748, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    LODWORD(buf[0]) = 138543362;
    *(uint64_t *)((char *)buf + 4) = v10;
    __int16 v80 = "AppC3DConfigSetTrackingConfig returned %{public}@";
    goto LABEL_156;
  }
  AppC3DConfigSetTrackingMode();
  unint64_t v11 = v100[0];
  if (v100[0])
  {
    if (qword_1EBFFB710 != -1) {
      dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
    }
    char v13 = qword_1EBFFB748;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFB748, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    LODWORD(buf[0]) = 138543362;
    *(uint64_t *)((char *)buf + 4) = v11;
    __int16 v80 = "AppC3DConfigSetTrackingMode returned %{public}@";
    goto LABEL_156;
  }
  if (qword_1EBFFC3F8[0] != -1) {
    dispatch_once_f(qword_1EBFFC3F8, 0, (dispatch_function_t)sub_1DC3ABAE8);
  }
  int v12 = byte_1EBFFC390;
  if (qword_1EBFFB710 != -1) {
    dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
  }
  char v13 = qword_1EBFFB748;
  BOOL v14 = os_log_type_enabled((os_log_t)qword_1EBFFB748, OS_LOG_TYPE_DEBUG);
  if (v12)
  {
    if (v14)
    {
      LOWORD(buf[0]) = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "Device has ANE, will not tempt with fallback device.", (uint8_t *)buf, 2u);
    }
  }
  else
  {
    if (v14)
    {
      LOWORD(buf[0]) = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v13, OS_LOG_TYPE_DEBUG, "Device does not have ANE, will set fallback device to GPU.", (uint8_t *)buf, 2u);
    }
    AppC3DConfigSetANEFallbackDevice();
    unint64_t v15 = v100[0];
    if (v100[0])
    {
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
      LODWORD(buf[0]) = 138543362;
      *(uint64_t *)((char *)buf + 4) = v15;
      __int16 v80 = "AppC3DConfigSetANEFallbackDevice returned %{public}@";
      goto LABEL_156;
    }
  }
  AppC3DCreate();
  unint64_t v16 = v100[0];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf[0]) = 138543362;
    *(uint64_t *)((char *)buf + 4) = v16;
    __int16 v80 = "AppC3DCreate failed, and returned %{public}@";
    goto LABEL_156;
  }
LABEL_22:
  if (v99[0]) {
    AppC3DConfigRelease();
  }
  if (v100[0])
  {
    buf[0] = -3001;
    time.value = (CMTimeValue)@"AppC3D error.";
    sub_1DC306334(v7, buf, (CFTypeRef *)&time);
    uint64_t v17 = (const void *)atomic_exchange(v7 + 8, v100[0]);
    if (v17) {
      CFRelease(v17);
    }
  }
  if (*(unsigned char *)(*(void *)&v86[0].a + 8) && *(void *)&v86[0].tx) {
    sub_1DC31AE10(*(uint64_t *)&v86[0].tx, **(void **)&v86[0].a);
  }
  sub_1DC31AE60(&v86[0].b);
  sub_1DC34B130(v3, 0);
  uint64_t v4 = *v3;
  if (!*v3) {
    return 0;
  }
LABEL_31:
  uint64_t v19 = (atomic_ullong *)*((void *)a1 + 2);
  uint64_t v18 = *((void *)a1 + 3);
  uint64_t v20 = (uint64_t *)*((void *)a1 + 4);
  uint64_t v21 = (atomic_ullong *volatile *)*((void *)a1 + 5);
  v100[0] = (unint64_t)&unk_1F365EFD0;
  v100[1] = (unint64_t)v21;
  char v101 = v100;
  buf[0] = v18;
  v99[0] = &unk_1F365EF78;
  v99[1] = v21;
  v99[3] = v99;
  sub_1DC31AD78((uint64_t)&buf[1], (uint64_t)v99);
  if (*(unsigned char *)(buf[0] + 8) && v101) {
    sub_1DC31AE10((uint64_t)v101, *(void *)buf[0]);
  }
  sub_1DC31AE60(v99);
  sub_1DC31AE60(v100);
  unint64_t v85 = 0;
  sub_1DC3834D8((const __CFDictionary *)&v83, (uint64_t)v21);
  sub_1DC38358C((const __CFData *)&v94, (uint64_t)v21);
  if (qword_1EBFFB710 != -1) {
    dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
  }
  char v22 = qword_1EBFFB748;
  if (!os_log_type_enabled((os_log_t)qword_1EBFFB748, OS_LOG_TYPE_DEBUG))
  {
    int v23 = v84;
    goto LABEL_38;
  }
  double Width = COERCE_DOUBLE(sub_1DC383840((uint64_t)v21));
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&Width, memory_order_acquire);
  LODWORD(v86[0].a) = 138543362;
  *(void *)((char *)&v86[0].a + 4) = explicit;
  _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, "start decoding sample: %{public}@", (uint8_t *)v86, 0xCu);
  sub_1DC31FA90((atomic_ullong *)&Width);
  int v23 = v84;
  BOOL v57 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
  if (v23)
  {
    if (!v57) {
      goto LABEL_96;
    }
    LOWORD(v86[0].a) = 0;
    int v58 = "has PTS";
  }
  else
  {
    if (!v57) {
      goto LABEL_96;
    }
    LOWORD(v86[0].a) = 0;
    int v58 = "no PTS, will use current time";
  }
  _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, v58, (uint8_t *)v86, 2u);
LABEL_96:
  int v63 = v98;
  BOOL v64 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
  if (v63)
  {
    if (!v64) {
      goto LABEL_38;
    }
    LOWORD(v86[0].a) = 0;
    int v65 = "has camera intrinsic matrix";
  }
  else
  {
    if (!v64) {
      goto LABEL_38;
    }
    LOWORD(v86[0].a) = 0;
    int v65 = "no camera intrinsic matrix, will derive from pixel buffer";
  }
  _os_log_debug_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_DEBUG, v65, (uint8_t *)v86, 2u);
LABEL_38:
  if (v23)
  {
    CMTime time = v83;
    CMTimeGetSeconds(&time);
  }
  else
  {
    CFAbsoluteTimeGetCurrent();
  }
  if (v98)
  {
    double Width = *(float *)v94.i32;
    double v89 = *(float *)v95.i32;
    float64x2_t v90 = vcvtq_f64_f32((float32x2_t)__PAIR64__(v94.u32[1], v96.u32[0]));
    float64x2_t v91 = vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v95.i8, v96));
    float64x2_t v92 = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v94, v94, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v95, v95, 8uLL)));
    double v93 = v97;
  }
  else
  {
    double Width = CGRectGetWidth(*(CGRect *)(*v21 + 1));
    double v89 = 0.0;
    v90.f64[0] = (CGRectGetWidth(*(CGRect *)(*v21 + 1)) + -1.0) * 0.5;
    v90.f64[1] = 0.0;
    v91.f64[0] = CGRectGetWidth(*(CGRect *)(*v21 + 1));
    v91.f64[1] = (CGRectGetHeight(*(CGRect *)(*v21 + 1)) + -1.0) * 0.5;
    float64x2_t v92 = 0uLL;
    double v93 = 1.0;
  }
  if (!*v4 || v4[1] != v4[2] || *((unsigned char *)v4 + 128))
  {
LABEL_137:
    if (!v85) {
      goto LABEL_50;
    }
    goto LABEL_138;
  }
  atomic_load_explicit(*v21, memory_order_acquire);
  AppC3DProcessCameraFrameData();
  unint64_t v24 = v85;
  if (v85)
  {
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_138;
    }
    LODWORD(v86[0].a) = 138543362;
    *(void *)((char *)&v86[0].a + 4) = v24;
    uint64_t v78 = "AppC3DProcessCameraFrameData returned %{public}@";
    goto LABEL_136;
  }
  AppC3DWait();
  unint64_t v25 = v85;
  if (v85)
  {
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_138;
    }
    LODWORD(v86[0].a) = 138543362;
    *(void *)((char *)&v86[0].a + 4) = v25;
    uint64_t v78 = "AppC3DWait returned %{public}@";
LABEL_136:
    _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, v78, (uint8_t *)v86, 0xCu);
    goto LABEL_137;
  }
  AppC3DFlush();
  unint64_t v26 = v85;
  if (!v85) {
    goto LABEL_50;
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    LODWORD(v86[0].a) = 138543362;
    *(void *)((char *)&v86[0].a + 4) = v26;
    uint64_t v78 = "AppC3DFlush returned %{public}@";
    goto LABEL_136;
  }
LABEL_138:
  v86[0].a = NAN;
  uint64_t v81 = @"AppC3D error.";
  sub_1DC306334(v4 + 4, (uint64_t *)v86, (CFTypeRef *)&v81);
  unint64_t v79 = (const void *)atomic_exchange(v4 + 12, v85);
  if (v79) {
    CFRelease(v79);
  }
LABEL_50:
  if (*((unsigned char *)v4 + 128))
  {
    uint64_t v28 = (atomic_ullong *)v4[1];
    uint64_t v27 = (atomic_ullong *)v4[2];
    if (v27 == v28)
    {
      v4[2] = (uint64_t)v28;
      LOBYTE(v86[0].a) = 0;
      char v87 = 0;
    }
    else
    {
      do
        uint64_t v27 = sub_1DC3073A4(v27 - 1);
      while (v27 != v28);
      int v29 = *((unsigned __int8 *)v4 + 128);
      v4[2] = (uint64_t)v28;
      LOBYTE(v86[0].a) = 0;
      char v87 = 0;
      if (!v29)
      {
LABEL_76:
        sub_1DC3070F0(v19, (uint64_t)v86);
        if (v87) {
          sub_1DC390B00((atomic_ullong *)v86);
        }
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          sub_1DC390F7C((CFErrorRef *)&v81, (uint64_t)v19);
          unint64_t v59 = atomic_load_explicit((atomic_ullong *volatile)&v81, memory_order_acquire);
          LODWORD(v86[0].a) = 138543362;
          *(void *)((char *)&v86[0].a + 4) = v59;
          _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "failed to decode, error: %{public}@", (uint8_t *)v86, 0xCu);
          sub_1DC306854((atomic_ullong *)&v81);
        }
LABEL_80:
        uint64_t v51 = 0;
        goto LABEL_121;
      }
    }
    sub_1DC390CA0(v86, v4 + 4);
    char v87 = 1;
    if (*((unsigned char *)v4 + 128))
    {
      sub_1DC390B00(v4 + 4);
      *((unsigned char *)v4 + 128) = 0;
    }
    goto LABEL_76;
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
  {
    uint64_t v30 = (v4[2] - v4[1]) >> 3;
    LODWORD(v86[0].a) = 134349056;
    *(void *)((char *)&v86[0].a + 4) = v30;
    _os_log_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_INFO, "finished decoding, number of descriptors: %{public}zu", (uint8_t *)v86, 0xCu);
  }
  int v31 = (atomic_ullong *)v4[1];
  uint64_t v32 = (atomic_ullong *)v4[2];
  if (v31 == v32) {
    goto LABEL_80;
  }
  do
  {
    if (*(unsigned char *)(atomic_load_explicit(v31, memory_order_acquire) + 64))
    {
      unint64_t v33 = atomic_load_explicit(v31, memory_order_acquire);
      uint64_t v34 = *(double **)(v33 + 40);
      int v35 = *(double **)(v33 + 48);
      while (v34 != v35)
      {
        memset(v86, 0, 48);
        CGFloat v36 = CGRectGetWidth(*(CGRect *)(*v21 + 1));
        CGFloat Height = CGRectGetHeight(*(CGRect *)(*v21 + 1));
        CGAffineTransformMakeScale(v86, v36, Height);
        *(float64x2_t *)uint64_t v34 = vaddq_f64(*(float64x2_t *)&v86[0].tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v86[0].c, v34[1]), *(float64x2_t *)&v86[0].a, *v34));
        v34 += 2;
      }
    }
    ++v31;
  }
  while (v31 != v32);
  float v39 = (atomic_ullong *)v4[1];
  float v38 = (atomic_ullong *)v4[2];
  if ((char *)v38 - (char *)v39 >= 1)
  {
    uint64_t v40 = v38 - v39;
    uint64_t v41 = *v20;
    unint64_t v42 = v20[1];
    uint64_t v43 = v42 - *v20;
    uint64_t v44 = v43 >> 3;
    float v45 = (atomic_ullong *)(*v20 + (v43 & 0xFFFFFFFFFFFFFFF8));
    uint64_t v46 = v20[2];
    if (v40 > (uint64_t)(v46 - v42) >> 3)
    {
      unint64_t v47 = v44 + v40;
      if ((unint64_t)(v44 + v40) >> 61) {
        sub_1DC2FF97C();
      }
      uint64_t v48 = v46 - v41;
      if (v48 >> 2 > v47) {
        unint64_t v47 = v48 >> 2;
      }
      if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
        CGFloat v49 = 1.49166815e-154;
      }
      else {
        CGFloat v49 = *(double *)&v47;
      }
      *(void *)&v86[0].tCGFloat x = v20 + 2;
      if (v49 == 0.0) {
        uint64_t v50 = 0;
      }
      else {
        CGFloat v49 = COERCE_DOUBLE(sub_1DC2FFD7C(*(unint64_t *)&v49));
      }
      float v60 = (void *)(*(void *)&v49 + 8 * v44);
      v86[0].a = v49;
      *(void *)&v86[0].CGFloat b = v60;
      *(void *)&v86[0].CGFloat c = v60;
      *(void *)&v86[0].CGFloat d = *(void *)&v49 + 8 * v50;
      uint64_t v61 = 8 * v40;
      *(void *)&CGFloat v62 = &v60[v40];
      do
      {
        *v60++ = atomic_exchange(v39++, 0);
        v61 -= 8;
      }
      while (v61);
      v86[0].CGFloat c = v62;
      sub_1DC30831C(v20, v86, (uint64_t)v45);
      sub_1DC308428((uint64_t)v86);
      goto LABEL_117;
    }
    uint64_t v52 = (uint64_t)(v42 - (void)v45) >> 3;
    if (v52 >= v40)
    {
      float v53 = &v39[v40];
      int v55 = (void *)v20[1];
LABEL_104:
      char v66 = &v45[v40];
      uint64_t v67 = &v55[-v40];
      uint64_t v68 = v55;
      if ((unint64_t)v67 < v42)
      {
        uint64_t v68 = v55;
        do
          *v68++ = atomic_exchange(v67++, 0);
        while ((unint64_t)v67 < v42);
      }
      v20[1] = (uint64_t)v68;
      if (v55 != v66)
      {
        char v69 = v55 - 1;
        uint64_t v70 = 8 * (v55 - v66);
        uint64_t v71 = v41 + 8 * v44 - 8;
        do
        {
          int v72 = (const void *)atomic_exchange(v69, atomic_exchange((atomic_ullong *volatile)(v71 + v70), 0));
          if (v72) {
            CFRelease(v72);
          }
          --v69;
          v70 -= 8;
        }
        while (v70);
      }
      while (v39 != v53)
      {
        int v73 = (const void *)atomic_exchange(v45, atomic_exchange(v39, 0));
        if (v73) {
          CFRelease(v73);
        }
        ++v39;
        ++v45;
      }
      goto LABEL_117;
    }
    float v53 = &v39[v52];
    if (v53 == v38)
    {
      int v55 = (void *)v20[1];
    }
    else
    {
      int v54 = &v39[v52];
      int v55 = (void *)v20[1];
      do
        *v55++ = atomic_exchange(v54++, 0);
      while (v54 != v38);
    }
    v20[1] = (uint64_t)v55;
    if ((uint64_t)(v42 - (void)v45) >= 1) {
      goto LABEL_104;
    }
  }
LABEL_117:
  uint64_t v75 = (atomic_ullong *)v4[1];
  for (int i = (atomic_ullong *)v4[2]; i != v75; int i = sub_1DC3073A4(i - 1))
    ;
  v4[2] = (uint64_t)v75;
  uint64_t v51 = 1;
LABEL_121:
  if (*(unsigned char *)(buf[0] + 8)) {
    BOOL v76 = v103 == 0;
  }
  else {
    BOOL v76 = 1;
  }
  if (!v76) {
    sub_1DC31AE10(v103, *(void *)buf[0]);
  }
  sub_1DC31AE60(&buf[1]);
  return v51;
}

void sub_1DC34C72C(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v2 - 160);
  uint64_t v5 = *(void *)(v2 - 128);
  if (*(unsigned char *)(v4 + 8)) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    sub_1DC31AE10(v5, *(void *)v4);
  }
  sub_1DC31AE60(v1);
  _Unwind_Resume(a1);
}

void *sub_1DC34C824()
{
  return &unk_1F365EC38;
}

uint64_t sub_1DC34C830(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_126AppClipCodeDecoderInternal6decodeERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS5_IyEERKNS_6SampleERKNS5_INS4_17reference_wrapperIKNS_6RegionEEEEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC34C86C(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFB710 != -1) {
    dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = qword_1EBFFB748;
    if (os_signpost_enabled((os_log_t)qword_1EBFFB748))
    {
      CGFloat Width = CGRectGetWidth(*(CGRect *)(**(void **)(a1 + 8) + 8));
      CGFloat Height = CGRectGetHeight(*(CGRect *)(**(void **)(a1 + 8) + 8));
      OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(**(atomic_ullong *volatile **)(a1 + 8), memory_order_acquire));
      v8[0] = 67110144;
      v8[1] = 17;
      __int16 v9 = 2050;
      CGFloat v10 = Width;
      __int16 v11 = 1024;
      int v12 = 17;
      __int16 v13 = 2050;
      CGFloat v14 = Height;
      __int16 v15 = 1026;
      OSType v16 = PixelFormatType;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_END, v3, "AppClipCodeDecoderInternal::decode", "samplePixelBufferWidth=%{public, signpost.description:attribute}.*g, samplePixelBufferHeight=%{public, signpost.description:attribute}.*g, samplePixelBufferPixelFormatType=0x%{public, signpost.description:attribute}x", (uint8_t *)v8, 0x28u);
    }
  }
}

uint64_t sub_1DC34C9D4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365EF78;
  a2[1] = v2;
  return result;
}

void *sub_1DC34C9F8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365EF78;
  result[1] = v3;
  return result;
}

void sub_1DC34CA40()
{
}

void *sub_1DC34CA58()
{
  return &unk_1F365EC48;
}

uint64_t sub_1DC34CA64(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_126AppClipCodeDecoderInternal6decodeERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS5_IyEERKNS_6SampleERKNS5_INS4_17reference_wrapperIKNS_6RegionEEEEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC34CAA0(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v3 = *a2;
  if (qword_1EBFFB710 != -1) {
    dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
  }
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = qword_1EBFFB748;
    if (os_signpost_enabled((os_log_t)qword_1EBFFB748))
    {
      CGFloat Width = CGRectGetWidth(*(CGRect *)(**(void **)(a1 + 8) + 8));
      CGFloat Height = CGRectGetHeight(*(CGRect *)(**(void **)(a1 + 8) + 8));
      OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(**(atomic_ullong *volatile **)(a1 + 8), memory_order_acquire));
      v8[0] = 67110144;
      v8[1] = 17;
      __int16 v9 = 2050;
      CGFloat v10 = Width;
      __int16 v11 = 1024;
      int v12 = 17;
      __int16 v13 = 2050;
      CGFloat v14 = Height;
      __int16 v15 = 1026;
      OSType v16 = PixelFormatType;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "AppClipCodeDecoderInternal::decode", "samplePixelBufferWidth=%{public, signpost.description:attribute}.*g, samplePixelBufferHeight=%{public, signpost.description:attribute}.*g, samplePixelBufferPixelFormatType=0x%{public, signpost.description:attribute}x", (uint8_t *)v8, 0x28u);
    }
  }
}

uint64_t sub_1DC34CC08(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365EFD0;
  a2[1] = v2;
  return result;
}

void *sub_1DC34CC2C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365EFD0;
  result[1] = v3;
  return result;
}

void sub_1DC34CC74()
{
}

void sub_1DC34CC8C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  if (a2) {
    BOOL v9 = a7 == 0;
  }
  else {
    BOOL v9 = 0;
  }
  int v10 = !v9;
  if (qword_1EBFFB710 != -1) {
    dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
  }
  __int16 v11 = qword_1EBFFB748;
  if (v10)
  {
    if (os_log_type_enabled((os_log_t)qword_1EBFFB748, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint64_t buf[4] = a7;
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "AppC3D update callback called with error %{public}@", buf, 0xCu);
    }
    return;
  }
  char v101 = a1;
  oslog = qword_1EBFFB748;
  if (os_log_type_enabled((os_log_t)qword_1EBFFB748, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134349056;
    *(void *)&uint64_t buf[4] = a2;
    _os_log_debug_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEBUG, "AppC3D update callback called with tracking result: %{public}p", buf, 0xCu);
  }
  unint64_t v106 = 0;
  uint64_t NumberOfTrackingData = AppC3DTrackingResultGetNumberOfTrackingData();
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 134349312;
    *(void *)&uint64_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 2050;
    *(void *)&buf[14] = NumberOfTrackingData;
    _os_log_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_INFO, "Tracking result %{public}p has %{public}zu tracking data.", buf, 0x16u);
  }
  if (!NumberOfTrackingData) {
    goto LABEL_129;
  }
  uint64_t v12 = 0;
  unsigned __int8 v98 = a1 + 3;
  long long v99 = a1 + 1;
  do
  {
    atomic_ullong Data = AppC3DTrackingResultCreateData();
    unint64_t v13 = atomic_load_explicit(&Data, memory_order_acquire);
    unint64_t v14 = v106;
    if (v13) {
      BOOL v15 = v106 == 0;
    }
    else {
      BOOL v15 = 0;
    }
    if (!v15)
    {
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint64_t buf[4] = v14;
        _os_log_error_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_ERROR, "AppC3DTrackingResultCreateData failed, and returned %{public}@", buf, 0xCu);
      }
      sub_1DC34D854(&Data);
      break;
    }
    atomic_ullong Corners = AppC3DTrackingResultCreateCorners();
    unint64_t v16 = atomic_load_explicit(&Corners, memory_order_acquire);
    unint64_t v17 = v106;
    if (v16) {
      BOOL v18 = v106 == 0;
    }
    else {
      BOOL v18 = 0;
    }
    if (!v18)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_112;
      }
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint64_t buf[4] = v17;
      float64x2_t v90 = buf;
      float64x2_t v91 = oslog;
      float64x2_t v92 = "AppC3DTrackingResultCreateCorners failed, and returned %{public}@";
      goto LABEL_114;
    }
    if (CFArrayGetCount((CFArrayRef)atomic_load_explicit(&Corners, memory_order_acquire)) != 4)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_112;
      }
      CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(&Corners, memory_order_acquire));
      *(_DWORD *)long long buf = 134349056;
      *(void *)&uint64_t buf[4] = Count;
      float64x2_t v90 = buf;
      float64x2_t v91 = oslog;
      float64x2_t v92 = "AppC3DTrackingResultCreateCorners returns unexpected number of corners: %{public}ld";
LABEL_114:
      _os_log_error_impl(&dword_1DC2FE000, v91, OS_LOG_TYPE_ERROR, v92, v90, 0xCu);
LABEL_112:
      int v89 = 4;
      goto LABEL_106;
    }
    CFIndex v19 = 0;
    uint64_t v20 = (CGPoint *)buf;
    do
    {
      ValueAtIndeCGFloat x = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(&Corners, memory_order_acquire), v19);
      CFDictionaryRef v22 = ValueAtIndex;
      if (!ValueAtIndex || (CFTypeID v23 = CFGetTypeID(ValueAtIndex), v23 != CFDictionaryGetTypeID()))
      {
        if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR)) {
          goto LABEL_112;
        }
LABEL_113:
        *(_DWORD *)int v110 = 134349056;
        *(void *)&void v110[4] = v19;
        float64x2_t v90 = v110;
        float64x2_t v91 = oslog;
        float64x2_t v92 = "AppC3DTrackingResultCreateCorners returns unexpected object at: %{public}ld";
        goto LABEL_114;
      }
      if (!CGPointMakeWithDictionaryRepresentation(v22, v20))
      {
        if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR)) {
          goto LABEL_112;
        }
        goto LABEL_113;
      }
      ++v19;
      ++v20;
    }
    while (v19 != 4);
    uint64_t v24 = 0;
    long long v25 = *(_OWORD *)&buf[16];
    *(_OWORD *)&buf[16] = v109;
    long long v109 = v25;
    unint64_t v26 = buf;
    uint64_t v27 = (double *)&buf[8];
    double v28 = *(double *)buf;
    int v29 = (double *)&buf[8];
    uint64_t v30 = (double *)&buf[8];
    int v31 = (double *)&buf[8];
    uint64_t v32 = (double *)&buf[8];
    do
    {
      unint64_t v33 = v26;
      unint64_t v26 = &buf[v24 + 16];
      double v34 = *(double *)v26;
      double v35 = *(double *)v26 + *(double *)&buf[v24 + 24];
      double v36 = v28 + *v27;
      if (v35 < v36)
      {
        uint64_t v27 = (double *)&buf[v24 + 24];
      }
      else
      {
        unint64_t v26 = v33;
        uint64_t v27 = v29;
      }
      if (v35 >= v36) {
        int v29 = v30;
      }
      else {
        int v29 = (double *)&buf[v24 + 24];
      }
      if (v35 >= v36) {
        uint64_t v30 = v31;
      }
      else {
        uint64_t v30 = (double *)&buf[v24 + 24];
      }
      if (v35 >= v36) {
        int v31 = v32;
      }
      else {
        int v31 = (double *)&buf[v24 + 24];
      }
      if (v35 >= v36) {
        uint64_t v32 = (double *)(v33 + 8);
      }
      else {
        uint64_t v32 = (double *)&buf[v24 + 24];
      }
      v24 += 16;
      if (v35 < v36) {
        double v28 = v34;
      }
    }
    while (v24 != 48);
    if (v26 != buf && v26 != v110)
    {
      if (&buf[16] == v26)
      {
        long long v43 = *(_OWORD *)buf;
        long long v44 = *(_OWORD *)&buf[16];
        *(_OWORD *)&buf[16] = v108;
        long long v108 = v109;
        *(_OWORD *)long long buf = v44;
        long long v109 = v43;
      }
      else
      {
        float v38 = v33 + 16;
        if (v35 < v36 || v38 == v110)
        {
          long long v40 = v109;
          long long v42 = *(_OWORD *)&buf[16];
          long long v41 = v108;
          *(_OWORD *)&buf[16] = *(_OWORD *)buf;
          long long v108 = v42;
          long long v109 = v41;
          *(_OWORD *)long long buf = v40;
        }
        else
        {
          uint64_t v45 = (v26 - buf) >> 4;
          if (v45 == (v110 - v26) >> 4)
          {
            uint64_t v46 = v26 + 16;
            unint64_t v47 = &buf[16];
            do
            {
              *(_OWORD *)int v110 = *((_OWORD *)v47 - 1);
              long long v48 = *(_OWORD *)v110;
              *((_OWORD *)v47 - 1) = *((_OWORD *)v46 - 1);
              *((_OWORD *)v46 - 1) = v48;
              if (v47 == v26) {
                break;
              }
              v47 += 16;
              BOOL v9 = v46 == v110;
              v46 += 16;
            }
            while (!v9);
          }
          else
          {
            uint64_t v49 = (v110 - v26) >> 4;
            uint64_t v50 = (v26 - buf) >> 4;
            do
            {
              uint64_t v51 = v50;
              uint64_t v50 = v49;
              uint64_t v49 = v51 % v49;
            }
            while (v49);
            if (v50)
            {
              uint64_t v52 = &buf[16 * v50];
              do
              {
                long long v53 = *((_OWORD *)v52 - 1);
                v52 -= 16;
                *(_OWORD *)int v110 = v53;
                int v54 = &v52[16 * v45];
                int v55 = v52;
                do
                {
                  int v56 = v55;
                  int v55 = v54;
                  *int v56 = *v54;
                  BOOL v57 = __OFSUB__(v45, (v110 - (uint8_t *)v54) >> 4);
                  uint64_t v59 = v45 - ((v110 - (uint8_t *)v54) >> 4);
                  char v58 = (v59 < 0) ^ v57;
                  int v54 = &buf[16 * v59];
                  if (v58) {
                    int v54 = &v55[v45];
                  }
                }
                while (v54 != (_OWORD *)v52);
                _OWORD *v55 = *(_OWORD *)v110;
              }
              while (v52 != buf);
            }
          }
        }
      }
    }
    AppC3DTrackingResultGetConfidence();
    unint64_t v61 = v106;
    if (v106)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_112;
      }
      *(_DWORD *)int v110 = 138543362;
      *(void *)&void v110[4] = v61;
      float64x2_t v90 = v110;
      float64x2_t v91 = oslog;
      float64x2_t v92 = "AppC3DTrackingResultGetConfidence returned %{public}@";
      goto LABEL_114;
    }
    int v62 = v60;
    __int16 Metadata = AppC3DTrackingResultGetMetadata();
    unint64_t v64 = v106;
    if (v106)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_112;
      }
      *(_DWORD *)int v110 = 138543362;
      *(void *)&void v110[4] = v64;
      float64x2_t v90 = v110;
      float64x2_t v91 = oslog;
      float64x2_t v92 = "AppC3DTrackingResultGetMetadata returned %{public}@";
      goto LABEL_114;
    }
    __int16 v65 = Metadata;
    DataVersiouint64_t n = AppC3DTrackingResultGetDataVersion();
    unint64_t v67 = v106;
    if (v106)
    {
      if (!os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR)) {
        goto LABEL_112;
      }
      *(_DWORD *)int v110 = 138543362;
      *(void *)&void v110[4] = v67;
      float64x2_t v90 = v110;
      float64x2_t v91 = oslog;
      float64x2_t v92 = "AppC3DTrackingResultGetDataVersion returned %{public}@";
      goto LABEL_114;
    }
    __int16 v68 = DataVersion;
    uint64_t v103 = sub_1DC34D67C();
    if (atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire))
    {
      char v69 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire)+ 16), (unint64_t)CFRetain(@"AppClipCode"));
      if (v69) {
        CFRelease(v69);
      }
      uint64_t v70 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire)+ 24), atomic_exchange(&Data, 0));
      if (v70) {
        CFRelease(v70);
      }
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire);
      int v72 = (void **)(explicit + 40);
      if (*(unsigned char *)(explicit + 64))
      {
        int v73 = *v72;
        if (*v72)
        {
          *(void *)(explicit + 48) = v73;
          operator delete(v73);
        }
        *(unsigned char *)(explicit + 64) = 0;
      }
      const void *v72 = 0;
      *(void *)(explicit + 48) = 0;
      *(void *)(explicit + 56) = 0;
      sub_1DC34D888((void *)(explicit + 40), 4uLL);
      long long v74 = *(_OWORD **)(explicit + 48);
      long long v75 = *(_OWORD *)buf;
      long long v76 = *(_OWORD *)&buf[16];
      long long v77 = v109;
      _OWORD v74[2] = v108;
      v74[3] = v77;
      *long long v74 = v75;
      v74[1] = v76;
      *(void *)(explicit + 48) = v74 + 4;
      *(unsigned char *)(explicit + 64) = 1;
      unint64_t v78 = atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire);
      *(_DWORD *)(v78 + 32) = v62;
      *(unsigned char *)(v78 + 36) = 1;
      unint64_t v79 = atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire);
      *(_DWORD *)(v79 + 216) = 0;
      *(unsigned char *)(v79 + 220) = 1;
      *(_WORD *)(atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire) + 216) = v65 | 0x100;
      *(_WORD *)(atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire) + 218) = v68 | 0x100;
      uint64_t v81 = (void *)v101[2];
      unint64_t v80 = v101[3];
      if ((unint64_t)v81 >= v80)
      {
        uint64_t v84 = ((uint64_t)v81 - *v99) >> 3;
        if ((unint64_t)(v84 + 1) >> 61) {
          sub_1DC2FF97C();
        }
        uint64_t v85 = v80 - *v99;
        uint64_t v86 = v85 >> 2;
        if (v85 >> 2 <= (unint64_t)(v84 + 1)) {
          uint64_t v86 = v84 + 1;
        }
        if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v87 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v87 = v86;
        }
        unsigned int v113 = v98;
        if (v87) {
          unint64_t v87 = (unint64_t)sub_1DC2FFD7C(v87);
        }
        else {
          uint64_t v88 = 0;
        }
        *(void *)int v110 = v87;
        *(void *)&v110[8] = v87 + 8 * v84;
        uint64_t v111 = *(void *)&v110[8];
        unint64_t v112 = v87 + 8 * v88;
        **(void **)&v110[8] = atomic_exchange((atomic_ullong *volatile)&v103, 0);
        v111 += 8;
        sub_1DC34D7DC(v99, v110);
        CMTime v83 = v101;
        uint64_t v82 = (void *)v101[2];
        sub_1DC308428((uint64_t)v110);
      }
      else
      {
        void *v81 = atomic_exchange((atomic_ullong *volatile)&v103, 0);
        uint64_t v82 = v81 + 1;
        v101[2] = v82;
        CMTime v83 = v101;
      }
      int v89 = 0;
      v83[2] = v82;
    }
    else
    {
      int v89 = 4;
    }
    sub_1DC3073A4((atomic_ullong *)&v103);
LABEL_106:
    sub_1DC3065EC(&Corners);
    sub_1DC34D854(&Data);
    if (v89) {
      break;
    }
    ++v12;
  }
  while (v12 != NumberOfTrackingData);
LABEL_129:
  if (v106)
  {
    *(void *)long long buf = -3001;
    *(void *)int v110 = @"AppC3D error.";
    sub_1DC306334(v101 + 4, (uint64_t *)buf, (CFTypeRef *)v110);
    int32x2_t v96 = (const void *)atomic_exchange(v101 + 12, v106);
    if (v96) {
      CFRelease(v96);
    }
  }
}

void sub_1DC34D5FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va1, a14);
  va_start(va, a14);
  atomic_ullong v15 = va_arg(va1, void);
  sub_1DC3065EC((atomic_ullong *)va);
  sub_1DC34D854((atomic_ullong *)va1);
  _Unwind_Resume(a1);
}

_OWORD *sub_1DC34D67C()
{
  if (qword_1EAA94E90 != -1) {
    dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
  }
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v1 = Instance;
  if (Instance)
  {
    CFTypeID v2 = CFGetTypeID(Instance);
    if (qword_1EAA94E90 != -1) {
      dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
    }
    if (v2 != qword_1EAA94E98) {
      _os_assumes_log();
    }
    v1[20] = 0u;
    v1[21] = 0u;
    v1[18] = 0u;
    v1[19] = 0u;
    v1[16] = 0u;
    v1[17] = 0u;
    v1[14] = 0u;
    v1[15] = 0u;
    v1[12] = 0u;
    v1[13] = 0u;
    v1[10] = 0u;
    v1[11] = 0u;
    v1[8] = 0u;
    v1[9] = 0u;
    v1[6] = 0u;
    v1[7] = 0u;
    v1[4] = 0u;
    void v1[5] = 0u;
    _OWORD v1[2] = 0u;
    v1[3] = 0u;
    v1[1] = 0u;
    CFTypeID v3 = CFGetTypeID(v1);
    if (qword_1EAA94E90 != -1) {
      dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
    }
    if (v3 != qword_1EAA94E98) {
      _os_assumes_log();
    }
  }
  return v1;
}

uint64_t sub_1DC34D7DC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1DC308478(a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = result;
  uint64_t v5 = *a1;
  *a1 = result;
  a2[1] = v5;
  uint64_t v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  uint64_t v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
  return result;
}

atomic_ullong *sub_1DC34D854(atomic_ullong *a1)
{
  CFTypeID v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

char *sub_1DC34D888(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_1DC2FF97C();
  }
  uint64_t result = (char *)sub_1DC300068(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *sub_1DC34D8C8()
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFB438) {
    _os_assumes_log();
  }
  if (qword_1EAA94E98) {
    _os_assumes_log();
  }
  qword_1EBFFB438 = (uint64_t)"MRCDescriptor";
  qword_1EAA94E98 = _CFRuntimeRegisterClass();
  v1[0] = &unk_1F3664E78;
  v1[3] = v1;
  sub_1DC348EB8(qword_1EAA94E98, v1);
  return sub_1DC30AC9C(v1);
}

void sub_1DC34D990(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC30AC9C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC34D9AC()
{
  return &unk_1F3664EE8;
}

uint64_t sub_1DC34D9B8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc2CFINS_10DescriptorENS_2cf6TraitsIS1_NS2_13PersonalitiesIS1_XtlNS_12fixed_stringILm13EEEtlNS_18basic_fixed_stringIcLm13ENSt3__111char_traitsIcEEEEtlA14_cLc77ELc82ELc67ELc68ELc101ELc115ELc99ELc114ELc105ELc112ELc116ELc111ELc114EEEEEJEEEEEE18registerClassOnce_EPvEUlPKvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

CFStringRef sub_1DC34D9F4@<X0>(CFTypeRef *a1@<X1>, CFStringRef *a2@<X8>)
{
  CFTypeRef v3 = *a1;
  if (*a1)
  {
    CFTypeID v4 = CFGetTypeID(*a1);
    if (qword_1EAA94E90 != -1) {
      dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
    }
    if (v4 != qword_1EAA94E98) {
      _os_assumes_log();
    }
  }
  CFStringRef result = sub_1DC3C5500((uint64_t)v3 + 16, 1);
  *a2 = result;
  return result;
}

void sub_1DC34DA98(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664E78;
}

void *sub_1DC34DAB8()
{
  CFStringRef result = operator new(0x10uLL);
  *CFStringRef result = &unk_1F3664E78;
  return result;
}

void sub_1DC34DAF0()
{
}

CFStringRef sub_1DC34DB08(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94E90 != -1) {
      dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
    }
    if (v2 != qword_1EAA94E98) {
      _os_assumes_log();
    }
  }
  CFStringRef result = sub_1DC3C5500((uint64_t)cf + 16, 0);
  if (!result) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s %p>", "MRCDescriptor", cf);
  }
  return result;
}

unint64_t sub_1DC34DBC8(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94E90 != -1) {
      dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
    }
    if (v2 != qword_1EAA94E98) {
      _os_assumes_log();
    }
  }
  uint64_t v3 = 3317042773;
  unint64_t v41 = 0;
  unint64_t explicit = (const void *)atomic_load_explicit(cf + 2, memory_order_acquire);
  CFHashCode v5 = 3317042773;
  if (explicit) {
    CFHashCode v5 = CFHash(explicit) + 2654435769u;
  }
  v41 ^= v5 + (v41 << 6) + (v41 >> 2);
  uint64_t v6 = (const void *)atomic_load_explicit(cf + 3, memory_order_acquire);
  CFHashCode v7 = 3317042773;
  if (v6) {
    CFHashCode v7 = CFHash(v6) + 2654435769u;
  }
  CFHashCode v8 = (v7 + (v41 << 6) + (v41 >> 2)) ^ v41;
  float v9 = *((float *)cf + 8);
  uint64_t v10 = LODWORD(v9) + 2654435769;
  if (v9 == 0.0) {
    uint64_t v10 = 2654435769;
  }
  if (*((unsigned char *)cf + 36)) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 3317042773;
  }
  unint64_t v41 = ((v8 >> 2) + (v8 << 6) + v11) ^ v8;
  sub_1DC3C6564(&v41, (uint64_t)(cf + 5));
  sub_1DC3C6564(&v41, (uint64_t)(cf + 9));
  if (*((unsigned char *)cf + 105)) {
    uint64_t v12 = *((unsigned __int8 *)cf + 104) + 2654435769;
  }
  else {
    uint64_t v12 = 3317042773;
  }
  unint64_t v13 = ((v41 >> 2) + (v41 << 6) + v12) ^ v41;
  uint64_t v14 = 3317042773;
  if (*((unsigned char *)cf + 136))
  {
    uint64_t v14 = 3317042773;
    if (cf[16])
    {
      atomic_ullong v15 = (atomic_ullong *)cf[14];
      uint64_t v14 = 2654435769;
      if (v15 != cf + 15)
      {
        unint64_t v16 = 0;
        do
        {
          unint64_t v17 = (atomic_ullong *)v15[1];
          BOOL v18 = v15;
          if (v17)
          {
            do
            {
              CFIndex v19 = v17;
              unint64_t v17 = (atomic_ullong *)*v17;
            }
            while (v17);
          }
          else
          {
            do
            {
              CFIndex v19 = (atomic_ullong *)v18[2];
              BOOL v20 = *v19 == (void)v18;
              BOOL v18 = v19;
            }
            while (!v20);
          }
          v16 ^= (v16 << 6)
               + 2654435769u
               + (v16 >> 2)
               + ((*((int *)v15 + 8)
                 + 2654435769
                 + ((*((int *)v15 + 7) + 2654435769) << 6)
                 + ((unint64_t)(*((int *)v15 + 7) + 2654435769) >> 2)) ^ (*((int *)v15 + 7) + 2654435769));
          atomic_ullong v15 = v19;
        }
        while (v19 != cf + 15);
        uint64_t v14 = v16 + 2654435769u;
      }
    }
  }
  unint64_t v21 = (v14 + (v13 << 6) + (v13 >> 2)) ^ v13;
  uint64_t v22 = 3317042773;
  if (*((unsigned char *)cf + 164))
  {
    if (*((unsigned char *)cf + 148)) {
      unint64_t v23 = *((int *)cf + 36) + 2654435769;
    }
    else {
      unint64_t v23 = 3317042773;
    }
    if (*((unsigned char *)cf + 156)) {
      uint64_t v24 = *((int *)cf + 38) + 2654435769;
    }
    else {
      uint64_t v24 = 3317042773;
    }
    unint64_t v25 = ((v23 >> 2) + (v23 << 6) + v24) ^ v23;
    if (*((unsigned char *)cf + 161)) {
      uint64_t v26 = *((unsigned __int8 *)cf + 160) + 2654435769;
    }
    else {
      uint64_t v26 = 3317042773;
    }
    uint64_t v22 = ((v26 + (v25 << 6) + (v25 >> 2)) ^ v25) + 2654435769u;
  }
  unint64_t v27 = (v22 + (v21 << 6) + (v21 >> 2)) ^ v21;
  unint64_t v41 = v27;
  if (*((unsigned char *)cf + 208))
  {
    uint64_t v28 = *((unsigned __int8 *)cf + 168);
    int v29 = *((unsigned __int8 *)cf + 192);
    atomic_ullong v30 = cf[22];
    atomic_ullong v31 = cf[23];
    uint64_t v32 = (const void *)atomic_load_explicit(cf + 25, memory_order_acquire);
    CFHashCode v33 = 3317042773;
    if (v32) {
      CFHashCode v33 = CFHash(v32) + 2654435769u;
    }
    uint64_t v34 = v31 + 2654435769;
    if (!v29) {
      uint64_t v34 = 3317042773;
    }
    unint64_t v35 = (v34
         + (((v30 + ((v28 + 2654435769) << 6) + 3318044711) ^ (v28 + 2654435769)) << 6)
         + (((v30 + ((v28 + 2654435769) << 6) + 3318044711) ^ (unint64_t)(v28 + 2654435769)) >> 2)) ^ (v30 + ((v28 + 2654435769) << 6) + 3318044711) ^ (v28 + 2654435769);
    uint64_t v36 = (((v35 >> 2) + (v35 << 6) + v33) ^ v35) + 2654435769u;
    unint64_t v27 = v41;
  }
  else
  {
    uint64_t v36 = 3317042773;
  }
  if (*((unsigned char *)cf + 220))
  {
    if (*((unsigned char *)cf + 217)) {
      unint64_t v37 = *((unsigned __int8 *)cf + 216) + 2654435769;
    }
    else {
      unint64_t v37 = 3317042773;
    }
    if (*((unsigned char *)cf + 219)) {
      uint64_t v38 = *((unsigned __int8 *)cf + 218) + 2654435769;
    }
    else {
      uint64_t v38 = 3317042773;
    }
    uint64_t v3 = (((v37 >> 2) + (v37 << 6) + v38) ^ v37) + 2654435769u;
  }
  unint64_t v39 = (v36 + (v27 << 6) + (v27 >> 2)) ^ v27;
  return (v3 + (v39 << 6) + (v39 >> 2)) ^ v39;
}

uint64_t sub_1DC34DF60(unsigned __int8 *cf, unsigned __int8 *a2)
{
  if (!cf) {
    goto LABEL_5;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (qword_1EAA94E90 != -1) {
    dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
  }
  if (v4 != qword_1EAA94E98)
  {
    _os_assumes_log();
    if (!a2) {
      goto LABEL_10;
    }
  }
  else
  {
LABEL_5:
    if (!a2) {
      goto LABEL_10;
    }
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (qword_1EAA94E90 != -1) {
    dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
  }
  if (v5 != qword_1EAA94E98) {
    _os_assumes_log();
  }
LABEL_10:
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)a2 + 2, memory_order_acquire);
  CFHashCode v7 = (const void *)atomic_load_explicit((atomic_ullong *volatile)cf + 2, memory_order_acquire);
  if (v7 != explicit)
  {
    BOOL v8 = !explicit || v7 == 0;
    if ((v8 || !CFEqual(v7, explicit))
      && (!atomic_load_explicit((atomic_ullong *volatile)cf + 2, memory_order_acquire)
       || !atomic_load_explicit((atomic_ullong *volatile)a2 + 2, memory_order_acquire)
       || CFStringCompare((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)cf + 2, memory_order_acquire), (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 2, memory_order_acquire), 0)))
    {
      return 0;
    }
  }
  float v9 = (const void *)atomic_load_explicit((atomic_ullong *volatile)a2 + 3, memory_order_acquire);
  uint64_t v10 = (const void *)atomic_load_explicit((atomic_ullong *volatile)cf + 3, memory_order_acquire);
  if (v10 != v9)
  {
    uint64_t result = 0;
    if (!v9) {
      return result;
    }
    if (!v10) {
      return result;
    }
    uint64_t result = CFEqual(v10, v9);
    if (!result) {
      return result;
    }
  }
  if (cf[36] && a2[36])
  {
    if (*((float *)cf + 8) != *((float *)a2 + 8)) {
      return 0;
    }
  }
  else if ((cf[36] != 0) != (a2[36] != 0))
  {
    return 0;
  }
  uint64_t result = sub_1DC3C5178((uint64_t)(cf + 40), (uint64_t)(a2 + 40));
  if (!result) {
    return result;
  }
  uint64_t result = sub_1DC3C5178((uint64_t)(cf + 72), (uint64_t)(a2 + 72));
  if (!result) {
    return result;
  }
  if (cf[105] && a2[105])
  {
    if (cf[104] != a2[104]) {
      return 0;
    }
  }
  else if ((cf[105] != 0) != (a2[105] != 0))
  {
    return 0;
  }
  if (sub_1DC3C522C((uint64_t)(cf + 112), (uint64_t)(a2 + 112))) {
    return 0;
  }
  if (cf[164] && a2[164])
  {
    if (!sub_1DC3C530C((uint64_t)(cf + 144), (uint64_t)(a2 + 144))) {
      return 0;
    }
  }
  else if ((cf[164] != 0) != (a2[164] != 0))
  {
    return 0;
  }
  if (cf[208] && a2[208])
  {
    if (sub_1DC3C53D0(cf + 168, a2 + 168)) {
      goto LABEL_50;
    }
    return 0;
  }
  if ((cf[208] != 0) != (a2[208] != 0)) {
    return 0;
  }
LABEL_50:
  int v12 = (cf[220] != 0) ^ (a2[220] != 0);
  if (cf[220])
  {
    if (a2[220]) {
      int v12 = !sub_1DC3C5478(cf + 216, a2 + 216);
    }
  }
  return v12 ^ 1u;
}

atomic_ullong *sub_1DC34E23C(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94E90 != -1) {
      dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
    }
    if (v2 != qword_1EAA94E98) {
      _os_assumes_log();
    }
    CFTypeID v3 = CFGetTypeID(cf);
    if (qword_1EAA94E90 != -1) {
      dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
    }
    if (v3 != qword_1EAA94E98) {
      _os_assumes_log();
    }
  }
  if (*((unsigned char *)cf + 344))
  {
    CFTypeID v4 = (void *)cf[40];
    if (v4)
    {
      cf[41] = (atomic_ullong)v4;
      operator delete(v4);
    }
  }
  if (*((unsigned char *)cf + 312))
  {
    CFTypeID v5 = (void *)cf[36];
    if (v5)
    {
      cf[37] = (atomic_ullong)v5;
      operator delete(v5);
    }
  }
  if (*((unsigned char *)cf + 208)) {
    sub_1DC34D854(cf + 25);
  }
  if (*((unsigned char *)cf + 136)) {
    sub_1DC31191C((void *)cf[15]);
  }
  if (*((unsigned char *)cf + 96))
  {
    uint64_t v6 = (void *)cf[9];
    if (v6)
    {
      cf[10] = (atomic_ullong)v6;
      operator delete(v6);
    }
  }
  if (*((unsigned char *)cf + 64))
  {
    CFHashCode v7 = (void *)cf[5];
    if (v7)
    {
      cf[6] = (atomic_ullong)v7;
      operator delete(v7);
    }
  }
  sub_1DC34D854(cf + 3);
  return sub_1DC31FA90(cf + 2);
}

void *sub_1DC34E3B8()
{
  return &unk_1F365EC18;
}

uint64_t sub_1DC34E3C4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_126AppClipCodeDecoderInternal6createERNSt3__18optionalINS_5ErrorEEERKNS3_IyEEEUlyE0_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC34E400(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFB710 != -1) {
    dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    CFTypeID v3 = qword_1EBFFB748;
    if (os_signpost_enabled((os_log_t)qword_1EBFFB748))
    {
      *(_WORD *)CFTypeID v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "AppClipCodeDecoderInternal::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC34E4AC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365EEC8;
}

void *sub_1DC34E4CC()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365EEC8;
  return result;
}

void sub_1DC34E504()
{
}

void *sub_1DC34E51C()
{
  return &unk_1F365EC28;
}

uint64_t sub_1DC34E528(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc12_GLOBAL__N_126AppClipCodeDecoderInternal6createERNSt3__18optionalINS_5ErrorEEERKNS3_IyEEEUlyE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC34E564(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFB710 != -1) {
    dispatch_once(&qword_1EBFFB710, &unk_1F365F960);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    CFTypeID v3 = qword_1EBFFB748;
    if (os_signpost_enabled((os_log_t)qword_1EBFFB748))
    {
      *(_WORD *)CFTypeID v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "AppClipCodeDecoderInternal::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC34E610(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365EF20;
}

void *sub_1DC34E630()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365EF20;
  return result;
}

void sub_1DC34E668()
{
}

__n128 sub_1DC34E688(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365EE70;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC34E6C0(uint64_t a1)
{
  os_signpost_id_t v2 = (char *)operator new(0x38uLL);
  *(void *)os_signpost_id_t v2 = &unk_1F365EE70;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void sub_1DC34E71C()
{
}

__n128 sub_1DC34E73C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3661F98;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  __n128 result = *(__n128 *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 56);
  long long v5 = *(_OWORD *)(a1 + 72);
  *(void *)(a2 + 88) = *(void *)(a1 + 88);
  *(_OWORD *)(a2 + 72) = v5;
  *(_OWORD *)(a2 + 56) = v4;
  *(__n128 *)(a2 + 40) = result;
  return result;
}

__n128 sub_1DC34E78C(uint64_t a1)
{
  long long v2 = (char *)operator new(0x60uLL);
  *(void *)long long v2 = &unk_1F3661F98;
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  *((void *)v2 + 11) = *(void *)(a1 + 88);
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void sub_1DC34E800()
{
}

void sub_1DC34E818(uint64_t a1)
{
  sub_1DC34E850(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC34E850(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661168;
  long long v2 = (void **)(a1 + 16);
  sub_1DC311C34((atomic_uint **)(a1 + 80));
  sub_1DC34E8D0((atomic_uint **)(a1 + 72));
  sub_1DC2FF548((atomic_uint **)(a1 + 64));
  long long v4 = (void **)(a1 + 40);
  sub_1DC2FF82C(&v4);
  long long v4 = v2;
  sub_1DC2FFC48(&v4);
  return a1;
}

atomic_uint **sub_1DC34E8D0(atomic_uint **a1)
{
  long long v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t sub_1DC34E908(uint64_t a1, uint64_t *a2, uint64_t *a3, char a4)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661168;
  *(unsigned char *)(a1 + 12) = a4;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  sub_1DC2FFB5C((atomic_uint *)(a1 + 16), *a3, a3[1], (a3[1] - *a3) >> 3);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  uint64_t v6 = *a2;
  if (v6)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v6 + 8), 1u, memory_order_relaxed);
    CFHashCode v7 = *(atomic_uint **)(a1 + 64);
    if (v7) {
      sub_1DC2FF57C(v7);
    }
  }
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = v6;
  return a1;
}

void sub_1DC34E9BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC2FF82C((void ***)va);
  sub_1DC2FFC48((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC34E9E0(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      sub_1DC2FF97C();
    }
    uint64_t v6 = (void *)result;
    CFHashCode v7 = sub_1DC34EB60(a4);
    BOOL v8 = v7;
    void *v6 = v7;
    v6[1] = v7;
    v6[2] = &v7[3 * v9];
    unint64_t v13 = v7;
    int v12 = v7;
    v10[0] = v6 + 2;
    v10[1] = &v12;
    _DWORD v10[2] = &v13;
    char v11 = 0;
    if (a2 != a3)
    {
      do
      {
        void *v7 = 0;
        v7[1] = 0;
        v7[2] = 0;
        sub_1DC3219D0(v7, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
        CFHashCode v7 = v13 + 3;
        v13 += 3;
        a2 += 24;
      }
      while (a2 != a3);
      BOOL v8 = v7;
    }
    char v11 = 1;
    __n128 result = sub_1DC34EAF8((uint64_t)v10);
    v6[1] = v8;
  }
  return result;
}

void sub_1DC34EAD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_1DC34EAF8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v2 = **(void **)(a1 + 16);
    uint64_t v3 = **(void **)(a1 + 8);
    if (v2 != v3)
    {
      uint64_t v4 = **(void **)(a1 + 16);
      do
      {
        uint64_t v6 = *(void **)(v4 - 24);
        v4 -= 24;
        long long v5 = v6;
        if (v6)
        {
          *(void *)(v2 - 16) = v5;
          operator delete(v5);
        }
        uint64_t v2 = v4;
      }
      while (v4 != v3);
    }
  }
  return a1;
}

void *sub_1DC34EB60(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    sub_1DC2FF994();
  }
  return operator new(24 * a1);
}

void sub_1DC34EBA8(uint64_t a1)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F36618E8;
  *(void *)(a1 + 16) = 0;
  operator new();
}

atomic_uint **sub_1DC34EC90(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC34ECC4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 24;
      CFHashCode v7 = v4 - 24;
      BOOL v8 = v4 - 24;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 24;
        (*v9)(v7);
        v6 -= 24;
        BOOL v10 = v7 == v2;
        CFHashCode v7 = v8;
      }
      while (!v10);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DC34ED84(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661440;
  uint64_t v1 = (void **)(a1 + 16);
  sub_1DC34ECC4(&v1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC34EDFC(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661440;
  uint64_t v3 = (void **)(a1 + 16);
  sub_1DC34ECC4(&v3);
  return a1;
}

void sub_1DC34EE54(void *a1)
{
  *a1 = &unk_1F36619B8;
  sub_1DC311968(a1 + 2);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC34EEB8(void *a1)
{
  *a1 = &unk_1F36619B8;
  sub_1DC311968(a1 + 2);
  return a1;
}

void sub_1DC34EEFC()
{
}

void sub_1DC34EF84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3291B8((atomic_uint **)va);
  MEMORY[0x1E019CE90](v2, 0x10A1C409D1393C9);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC34EFB0(uint64_t a1, atomic_uint *a2)
{
  if (a2) {
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v4 = a2;
  sub_1DC32914C(a1, (uint64_t *)&v4);
  sub_1DC3291B8(&v4);
  *(void *)a1 = &unk_1F3661318;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = -1;
  return a1;
}

void sub_1DC34F02C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3291B8((atomic_uint **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC34F040@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 24);
  if (!v2)
  {
    uint64_t v3 = *(atomic_uint **)(result + 16);
    if (v3) {
      atomic_fetch_add_explicit(v3 + 2, 1u, memory_order_relaxed);
    }
    std::string __p = v3;
    sub_1DC3291B8((atomic_uint **)&__p);
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
    (*(void (**)(atomic_uint *))(*(void *)v3 + 24))(v3);
    v4[0] = 0;
    sub_1DC314D98(&__p, 0x20uLL, v4);
    sub_1DC31465C((uint64_t)v4);
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  *a2 = v2;
  return result;
}

void sub_1DC34F478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  __cxa_free_exception(v15);
  sub_1DC311968(&a11);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1DC34F4EC(uint64_t a1)
{
  sub_1DC34F524(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC34F524(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661318;
  uint64_t v2 = (atomic_uint **)(a1 + 24);
  sub_1DC314744((atomic_uint **)(a1 + 32));
  sub_1DC2FF548(v2);
  *(void *)a1 = &unk_1F3661968;
  sub_1DC3291B8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1DC34F5A0()
{
}

void sub_1DC34F6AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_1DC34F6E0()
{
  return 1;
}

uint64_t sub_1DC34F6E8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 44) || *(_DWORD *)(a1 + 48) || (uint64_t v1 = *(void *)(a1 + 24)) == 0)
  {
    uint64_t v1 = *(void *)(a1 + 16);
    if (!v1) {
      operator new[]();
    }
  }
  return v1;
}

void *sub_1DC34F7D8(uint64_t a1, int a2, void *a3)
{
  if (a2 < 0 || (*(int (**)(uint64_t))(*(void *)a1 + 24))(a1) <= a2)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "Requested row is outside the image");
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (!a3) {
    operator new[]();
  }
  CFHashCode v7 = (const void *)(*(void *)(a1 + 24) + *(int *)(a1 + 44) + (*(int *)(a1 + 48) + (uint64_t)a2) * *(int *)(a1 + 32));
  return memcpy(a3, v7, v6);
}

void sub_1DC34F8EC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC34F900(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_1DC34F908(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sub_1DC34F910(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

void sub_1DC34F918(void *a1)
{
  *a1 = &unk_1F3661348;
  uint64_t v1 = a1[2];
  if (v1) {
    MEMORY[0x1E019CE70](v1, 0x1000C8077774924);
  }
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC34F994(void *a1)
{
  *a1 = &unk_1F3661348;
  uint64_t v2 = a1[2];
  if (v2) {
    MEMORY[0x1E019CE70](v2, 0x1000C8077774924);
  }
  return a1;
}

uint64_t sub_1DC34F9F0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  uint64_t v2 = v3;
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v1;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < 0;
    if (v5 >= 0) {
      CFHashCode v7 = (uint64_t *)v2;
    }
    else {
      CFHashCode v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 != v1 && *(int *)(v4 + 32) <= 0) {
    return (*(uint64_t (**)(void, void))(**(void **)(v4 + 40) + 16))(*(void *)(v4 + 40), 0);
  }
  else {
    return 0;
  }
}

void sub_1DC34FA60(uint64_t **a1, int a2)
{
  uint64_t v4 = operator new(0x28uLL);
  v4[1] = 0;
  v4[2] = 0;
  *uint64_t v4 = &unk_1F3662238;
  v4[3] = &unk_1F3660DD8;
  *((_DWORD *)v4 + 8) = a2;
  BOOL v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        CFHashCode v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 < 1) {
          break;
        }
        int v5 = *v7;
        BOOL v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if ((v8 & 0x80000000) == 0) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        BOOL v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    CFHashCode v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x38uLL);
    v9[8] = 0;
    *((void *)v9 + 5) = 0;
    *((void *)v9 + 6) = 0;
    sub_1DC311D78(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    CFHashCode v7 = (uint64_t **)v9;
  }
  BOOL v10 = (std::__shared_weak_count *)v7[6];
  v7[5] = v4 + 3;
  v7[6] = v4;
  if (v10)
  {
    sub_1DC32EEF4(v10);
  }
}

void sub_1DC34FB84(_Unwind_Exception *a1)
{
  sub_1DC32EEF4(v1);
  _Unwind_Resume(a1);
}

std::wstring *sub_1DC34FB98@<X0>(uint64_t a1@<X0>, std::wstring *a2@<X8>)
{
  return std::to_wstring(a2, *(_DWORD *)(a1 + 8));
}

uint64_t sub_1DC34FBA0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

void sub_1DC34FBA8()
{
}

uint64_t sub_1DC34FBC4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1DC34FBE8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3662238;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC34FC3C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3662238;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *sub_1DC34FC5C(unsigned char *__dst, void *__src, unint64_t a3)
{
  int v5 = __dst;
  if (a3 > 4)
  {
    if (a3 >= 0x3FFFFFFFFFFFFFF8) {
      sub_1DC3127EC();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFFELL) + 2;
    if ((a3 | 1) != 5) {
      uint64_t v6 = a3 | 1;
    }
    CFHashCode v7 = sub_1DC314E5C(v6 + 1);
    v5[1] = a3;
    v5[2] = v8 | 0x8000000000000000;
    *int v5 = v7;
    int v5 = v7;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, 4 * a3 + 4);
}

uint64_t sub_1DC34FCF8()
{
  return 0;
}

uint64_t sub_1DC34FD00(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    operator new[]();
  }
  if (*(int *)(a1 + 52) >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v3, v2 + *(int *)(a1 + 48) * (uint64_t)(int)v3);
      uint64_t v3 = (v3 + 1);
    }
    while ((int)v3 < *(_DWORD *)(a1 + 52));
  }
  return v2;
}

unsigned char *sub_1DC34FDAC(uint64_t a1, int a2, unsigned char *a3)
{
  if (a2 < 0 || (*(int (**)(uint64_t))(*(void *)a1 + 24))(a1) <= a2)
  {
    sub_1DC32B69C((uint64_t)&v15);
    sub_1DC31FC84(&v15, (uint64_t)"Requested row is outside the image: ", 36);
    std::ostream::operator<<();
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC32B834(v13, (uint64_t)&v16);
    if (v14 >= 0) {
      int v12 = (char *)v13;
    }
    else {
      int v12 = (char *)v13[0];
    }
    sub_1DC379B70(exception, v12);
    void *exception = &unk_1F36613B0;
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (!a3) {
    operator new[]();
  }
  if (v6 >= 1)
  {
    int v7 = *(_DWORD *)(a1 + 32) - (*(_DWORD *)(a1 + 44) + a2) + *(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 40);
    uint64_t v8 = v6;
    uint64_t v9 = a3;
    do
    {
      *v9++ = *(unsigned char *)(*(void *)(a1 + 16) + v7);
      v7 += *(_DWORD *)(a1 + 32);
      --v8;
    }
    while (v8);
  }
  return a3;
}

void sub_1DC34FF54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (v14 < 0)
  {
    operator delete(v13);
    if ((v15 & 1) == 0)
    {
LABEL_6:
      sub_1DC32B90C((uint64_t)&a12);
      _Unwind_Resume(a1);
    }
  }
  else if (!v15)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v12);
  goto LABEL_6;
}

uint64_t sub_1DC34FF98(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t sub_1DC34FFA0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t sub_1DC34FFA8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

void sub_1DC34FFB0(void *a1)
{
  *a1 = &unk_1F36613D8;
  uint64_t v1 = a1[3];
  if (v1) {
    MEMORY[0x1E019CE70](v1, 0x1000C8077774924);
  }
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC35002C(void *a1)
{
  *a1 = &unk_1F36613D8;
  uint64_t v2 = a1[3];
  if (v2) {
    MEMORY[0x1E019CE70](v2, 0x1000C8077774924);
  }
  return a1;
}

void sub_1DC350088(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (a2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v6 = a2;
  uint64_t v4 = *a4;
  if (*a4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v5 = v4;
  sub_1DC350118();
}

void sub_1DC3500FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, atomic_uint *a10)
{
}

void sub_1DC350118()
{
}

void sub_1DC350484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, atomic_uint **a10)
{
}

void sub_1DC350528()
{
}

void sub_1DC350558()
{
  if (atomic_load_explicit((atomic_ullong *volatile)qword_1EBFFC228, memory_order_acquire) != -1)
  {
    CFAllocatorRef v0 = &v1;
    uint64_t v1 = sub_1DC350528;
    std::__call_once(qword_1EBFFC228, &v0, (void (__cdecl *)(void *))sub_1DC33DA8C);
  }
}

void sub_1DC3505BC()
{
}

void sub_1DC350644(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3291B8((atomic_uint **)va);
  MEMORY[0x1E019CE90](v2, 0x10A1C406BBA158DLL);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC350670(uint64_t a1, atomic_uint *a2)
{
  if (a2) {
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v4 = a2;
  sub_1DC34EFB0(a1, a2);
  sub_1DC3291B8(&v4);
  *(void *)a1 = &unk_1F36611B0;
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 56) = xmmword_1DC3FDC30;
  *(void *)(a1 + 72) = 0x1800000007;
  return a1;
}

void sub_1DC3506F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3291B8((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC35070C@<X0>(atomic_uint **result@<X0>, atomic_uint **a2@<X8>)
{
  uint64_t v3 = result[6];
  if (v3)
  {
    *a2 = 0;
LABEL_14:
    atomic_fetch_add_explicit(v3 + 2, 1u, memory_order_relaxed);
    goto LABEL_15;
  }
  uint64_t v4 = (uint64_t)result;
  uint64_t v5 = result[2];
  if (v5) {
    atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v8 = v5;
  sub_1DC3291B8(&v8);
  if ((*(int (**)(atomic_uint *))(*(void *)v5 + 16))(v5) >= *(_DWORD *)(v4 + 76)
    && (*(int (**)(atomic_uint *))(*(void *)v5 + 24))(v5) >= *(_DWORD *)(v4 + 76))
  {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 48))(v5);
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
    (*(void (**)(atomic_uint *))(*(void *)v5 + 24))(v5);
    (*(void (**)(atomic_uint *))(*(void *)v5 + 32))(v5);
    operator new[]();
  }
  sub_1DC34F040(v4, &v8);
  uint64_t v6 = v8;
  if (v8) {
    atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
  }
  int v7 = *(atomic_uint **)(v4 + 48);
  if (v7) {
    sub_1DC2FF57C(v7);
  }
  *(void *)(v4 + 48) = v6;
  __n128 result = sub_1DC2FF548(&v8);
  *a2 = 0;
  uint64_t v3 = *(atomic_uint **)(v4 + 48);
  if (v3) {
    goto LABEL_14;
  }
LABEL_15:
  *a2 = v3;
  return result;
}

void sub_1DC350CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1DC2FF548((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1DC350D14(uint64_t a1)
{
  *(void *)a1 = &unk_1F36611B0;
  sub_1DC2FF548((atomic_uint **)(a1 + 48));
  sub_1DC34F524(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC350D7C(uint64_t a1)
{
  *(void *)a1 = &unk_1F36611B0;
  sub_1DC2FF548((atomic_uint **)(a1 + 48));
  return sub_1DC34F524(a1);
}

void sub_1DC350DD0(std::string *a1, uint64_t *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  unint64_t v3 = a2[1] - *a2;
  if (v3 <= 1) {
    goto LABEL_76;
  }
  uint64_t v6 = (unsigned __int8 *)(v2 + 1);
  if (*(unsigned char *)(v2 + 1))
  {
    if ((int)v3 > 47)
    {
      memset(&v29, 0, sizeof(v29));
      std::string::append(&v29, "01", 2uLL);
      if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v7 = HIBYTE(v29.__r_.__value_.__r.__words[2]);
      }
      else {
        int v7 = v29.__r_.__value_.__r.__words[1];
      }
      int v8 = *((_DWORD *)a2 + 2) - *a2;
      if (v8 >= 8) {
        int v8 = 8;
      }
      if (v8 < 5)
      {
        int v9 = 0;
      }
      else
      {
        int v9 = 0;
        BOOL v10 = (unsigned __int8 *)(*a2 + 4);
        int v11 = v8 - 4;
        do
        {
          int v12 = *v10++;
          int v9 = (v12 != 0) | (2 * v9);
          --v11;
        }
        while (v11);
      }
      std::to_string(&v27, v9);
      if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v13 = &v27;
      }
      else {
        unint64_t v13 = (std::string *)v27.__r_.__value_.__r.__words[0];
      }
      if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v27.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v27.__r_.__value_.__l.__size_;
      }
      std::string::append(&v29, (const std::string::value_type *)v13, size);
      if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v27.__r_.__value_.__l.__data_);
      }
      sub_1DC351438(&v29, a2, 8u, v7);
      int v15 = sub_1DC35D3E4(a2, 48, &v29);
      goto LABEL_28;
    }
    goto LABEL_16;
  }
  if (v3 <= 2) {
LABEL_76:
  }
    sub_1DC351420();
  if (!*(unsigned char *)(v2 + 2))
  {
    memset(&v29, 0, sizeof(v29));
    int v15 = sub_1DC35D3E4(a2, 5, &v29);
LABEL_28:
    if (v15)
    {
      a1->__r_.__value_.__r.__words[0] = 0;
      a1->__r_.__value_.__l.__size_ = 0;
      a1->__r_.__value_.__r.__words[2] = 0;
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      *a1 = v29;
    }
    return;
  }
  if ((int)v3 < 5)
  {
LABEL_16:
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    return;
  }
  uint64_t v16 = 0;
  int v17 = 0;
  do
    int v17 = (v6[v16++] != 0) | (2 * v17);
  while (v16 != 4);
  if (v17 == 5)
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    if (v3 != 60) {
      return;
    }
    sub_1DC351630((uint64_t)a1, a2, 5u);
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F365F600;
    atomic_ullong v30 = &v29;
    v27.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F365F658;
    uint64_t v28 = &v27;
    sub_1DC3516B0(a1, *a2, a2[1], 0x2Du, 15, (uint64_t)&v29, (uint64_t)&v27);
LABEL_41:
    sub_1DC35183C(&v27);
    sub_1DC3518C0(&v29);
    return;
  }
  if (v17 == 4)
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    if (v3 != 60) {
      return;
    }
    sub_1DC351630((uint64_t)a1, a2, 5u);
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F3661D88;
    atomic_ullong v30 = &v29;
    v27.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F3661DE0;
    uint64_t v28 = &v27;
    sub_1DC3516B0(a1, *a2, a2[1], 0x2Du, 15, (uint64_t)&v29, (uint64_t)&v27);
    goto LABEL_41;
  }
  if ((int)v3 <= 5) {
    goto LABEL_16;
  }
  int v18 = 0;
  int v19 = v3 - 1;
  if ((int)v3 - 1 >= 5) {
    int v20 = 5;
  }
  else {
    int v20 = v3 - 1;
  }
  unint64_t v21 = v6;
  do
  {
    int v22 = *v21++;
    int v18 = (v22 != 0) | (2 * v18);
    --v20;
  }
  while (v20);
  if (v18 == 13)
  {
    sub_1DC351AC8(a1, (uint64_t)a2);
  }
  else if (v18 == 12)
  {
    sub_1DC351944(a1, (uint64_t)a2);
  }
  else
  {
    if ((int)v3 <= 7) {
      goto LABEL_16;
    }
    int v23 = 0;
    if (v19 >= 7) {
      int v19 = 7;
    }
    do
    {
      int v24 = *v6++;
      int v23 = (v24 != 0) | (2 * v23);
      --v19;
    }
    while (v19);
    switch(v23)
    {
      case '8':
        unint64_t v25 = "310";
        goto LABEL_63;
      case '9':
        unint64_t v25 = "320";
LABEL_63:
        uint64_t v26 = "11";
        goto LABEL_73;
      case ':':
        unint64_t v25 = "310";
        goto LABEL_66;
      case ';':
        unint64_t v25 = "320";
LABEL_66:
        uint64_t v26 = "13";
        goto LABEL_73;
      case '<':
        unint64_t v25 = "310";
        goto LABEL_69;
      case '=':
        unint64_t v25 = "320";
LABEL_69:
        uint64_t v26 = "15";
        goto LABEL_73;
      case '>':
        unint64_t v25 = "310";
        goto LABEL_72;
      case '?':
        unint64_t v25 = "320";
LABEL_72:
        uint64_t v26 = "17";
LABEL_73:
        sub_1DC351D14(a1, (uint64_t)a2, (std::string::size_type)v25, v26);
        break;
      default:
        goto LABEL_16;
    }
  }
}

void sub_1DC35138C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_1DC35183C(&__p);
  sub_1DC3518C0(&a17);
  if (*(char *)(v22 + 23) < 0) {
    operator delete(*(void **)v22);
  }
  _Unwind_Resume(a1);
}

void sub_1DC351420()
{
}

void sub_1DC351438(std::string *this, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v7 = 0;
  int v8 = -a3;
  uint64_t v9 = a3;
  do
  {
    uint64_t v10 = v9 + 10 * v7;
    uint64_t v11 = *a2;
    uint64_t v12 = a2[1];
    if ((int)(v12 - *a2 - v10) < 1)
    {
      int v13 = 0;
LABEL_9:
      std::string::push_back(this, 48);
      goto LABEL_10;
    }
    int v13 = 0;
    int v14 = (unsigned __int8 *)(v11 + v10);
    int v15 = v8 + v12 - v11;
    if (v15 >= 10) {
      int v15 = 10;
    }
    do
    {
      int v16 = *v14++;
      int v13 = (v16 != 0) | (2 * v13);
      --v15;
    }
    while (v15);
    if ((v13 + 99) <= 0xC6) {
      goto LABEL_9;
    }
LABEL_10:
    if ((v13 + 9) <= 0x12) {
      std::string::push_back(this, 48);
    }
    std::to_string(&v28, v13);
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v17 = &v28;
    }
    else {
      int v17 = (std::string *)v28.__r_.__value_.__r.__words[0];
    }
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v28.__r_.__value_.__l.__size_;
    }
    std::string::append(this, (const std::string::value_type *)v17, size);
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
    ++v7;
    v8 -= 10;
  }
  while (v7 != 4);
  uint64_t v19 = 0;
  int v20 = 0;
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v21 = this;
  }
  else {
    unint64_t v21 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  uint64_t v22 = (char *)v21 + a4;
  do
  {
    int v23 = v22[v19] - 48;
    if ((v19 & 1) == 0) {
      v23 *= 3;
    }
    v20 += v23;
    ++v19;
  }
  while (v19 != 13);
  int v24 = v20 % 10;
  if (v24) {
    int v25 = 10 - v24;
  }
  else {
    int v25 = 0;
  }
  std::to_string(&v28, v25);
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v26 = &v28;
  }
  else {
    uint64_t v26 = (std::string *)v28.__r_.__value_.__r.__words[0];
  }
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v27 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v27 = v28.__r_.__value_.__l.__size_;
  }
  std::string::append(this, (const std::string::value_type *)v26, v27);
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
}

void sub_1DC351610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC351630(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  std::string::append((std::string *)a1, "01", 2uLL);
  if (*(char *)(a1 + 23) >= 0) {
    int v6 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  std::string::push_back((std::string *)a1, 57);
  sub_1DC351438((std::string *)a1, a2, a3, v6);
}

void sub_1DC3516B0(std::string *a1, uint64_t a2, int a3, unsigned int a4, int a5, uint64_t a6, uint64_t a7)
{
  int v9 = a3 - a2 - a4;
  if (v9 >= a5) {
    int v9 = a5;
  }
  if (v9 < 1)
  {
    int v10 = 0;
  }
  else
  {
    int v10 = 0;
    uint64_t v11 = (unsigned __int8 *)(a2 + a4);
    do
    {
      int v12 = *v11++;
      int v10 = (v12 != 0) | (2 * v10);
      --v9;
    }
    while (v9);
  }
  LODWORD(v19.__r_.__value_.__l.__data_) = v10;
  if (!a6
    || ((*(void (**)(uint64_t, std::string *, std::string *))(*(void *)a6 + 48))(a6, a1, &v19),
        LODWORD(v19.__r_.__value_.__l.__data_) = v10,
        (uint64_t v13 = *(void *)(a7 + 24)) == 0))
  {
    sub_1DC307C38();
  }
  int v14 = (*(uint64_t (**)(uint64_t, std::string *))(*(void *)v13 + 48))(v13, &v19);
  int v15 = 100000;
  int v16 = 5;
  do
  {
    if (!(v14 / v15)) {
      std::string::push_back(a1, 48);
    }
    v15 /= 10;
    --v16;
  }
  while (v16);
  std::to_string(&v19, v14);
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v17 = &v19;
  }
  else {
    int v17 = (std::string *)v19.__r_.__value_.__r.__words[0];
  }
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v19.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v19.__r_.__value_.__l.__size_;
  }
  std::string::append(a1, (const std::string::value_type *)v17, size);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
}

void sub_1DC351820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC35183C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1DC3518C0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

double sub_1DC351944(std::string *a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2 > 49)
  {
    memset(&v13, 0, sizeof(v13));
    sub_1DC351630((uint64_t)&v13, (uint64_t *)a2, 8u);
    int v4 = *(_DWORD *)(a2 + 8) - *(void *)a2;
    if (v4 >= 50) {
      int v4 = 50;
    }
    if (v4 < 49)
    {
      int v5 = 0;
    }
    else
    {
      int v5 = 0;
      int v6 = (unsigned __int8 *)(*(void *)a2 + 48);
      int v7 = v4 - 48;
      do
      {
        int v8 = *v6++;
        int v5 = (v8 != 0) | (2 * v5);
        --v7;
      }
      while (v7);
    }
    std::string::append(&v13, "392", 3uLL);
    std::to_string(&__p, v5);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    std::string::append(&v13, (const std::string::value_type *)p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (sub_1DC35C820((uint64_t *)a2, 50, &v13))
    {
      a1->__r_.__value_.__r.__words[0] = 0;
      a1->__r_.__value_.__l.__size_ = 0;
      a1->__r_.__value_.__r.__words[2] = 0;
      if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v13.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      double result = *(double *)&v13.__r_.__value_.__l.__data_;
      *a1 = v13;
    }
  }
  else
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
  }
  return result;
}

void sub_1DC351A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

double sub_1DC351AC8(std::string *a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2 <= 59)
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    return result;
  }
  memset(&v20, 0, sizeof(v20));
  sub_1DC351630((uint64_t)&v20, (uint64_t *)a2, 8u);
  int v4 = *(_DWORD *)(a2 + 8) - *(void *)a2;
  if (v4 >= 50) {
    int v4 = 50;
  }
  if (v4 < 49)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    int v6 = (unsigned __int8 *)(*(void *)a2 + 48);
    int v7 = v4 - 48;
    do
    {
      int v8 = *v6++;
      int v5 = (v8 != 0) | (2 * v5);
      --v7;
    }
    while (v7);
  }
  std::string::append(&v20, "393", 3uLL);
  std::to_string(&__p, v5);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  std::string::append(&v20, (const std::string::value_type *)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  int v11 = *(_DWORD *)(a2 + 8) - *(void *)a2;
  if (v11 >= 60) {
    int v11 = 60;
  }
  if (v11 < 51)
  {
    int v12 = 0;
  }
  else
  {
    int v12 = 0;
    std::string v13 = (unsigned __int8 *)(*(void *)a2 + 50);
    int v14 = v11 - 50;
    do
    {
      int v15 = *v13++;
      int v12 = (v15 != 0) | (2 * v12);
      --v14;
    }
    while (v14);
    if ((v12 + 99) > 0xC6) {
      goto LABEL_27;
    }
  }
  std::string::push_back(&v20, 48);
LABEL_27:
  if ((v12 + 9) <= 0x12) {
    std::string::push_back(&v20, 48);
  }
  std::to_string(&__p, v12);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v16 = &__p;
  }
  else {
    int v16 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v17 = __p.__r_.__value_.__l.__size_;
  }
  std::string::append(&v20, (const std::string::value_type *)v16, v17);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (sub_1DC35C820((uint64_t *)a2, 60, &v20))
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v20.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    double result = *(double *)&v20.__r_.__value_.__l.__data_;
    *a1 = v20;
  }
  return result;
}

void sub_1DC351CCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC351D14(std::string *a1, uint64_t a2, std::string::size_type a3, const char *a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  if (v4 == 84)
  {
    sub_1DC351630((uint64_t)a1, (uint64_t *)a2, 8u);
    v26.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F365F6B0;
    v26.__r_.__value_.__l.__size_ = a3;
    std::string::size_type v27 = &v26;
    v25[0] = &unk_1F365F708;
    v25[3] = v25;
    sub_1DC3516B0(a1, *(void *)a2, *(void *)(a2 + 8), 0x30u, 20, (uint64_t)&v26, (uint64_t)v25);
    sub_1DC35183C(v25);
    sub_1DC3518C0(&v26);
    uint64_t v9 = *(void *)a2;
    int v10 = *(_DWORD *)(a2 + 8) - *(void *)a2;
    if (v10 >= 84) {
      int v10 = 84;
    }
    if (v10 < 69)
    {
      int v11 = 0;
    }
    else
    {
      int v11 = 0;
      int v12 = (unsigned __int8 *)(v9 + 68);
      int v13 = v10 - 68;
      do
      {
        int v14 = *v12++;
        int v11 = (v14 != 0) | (2 * v11);
        --v13;
      }
      while (v13);
      if (v11 == 38400) {
        return;
      }
    }
    std::string::size_type v15 = strlen(a4);
    std::string::append(a1, a4, v15);
    if (v11 >= 0) {
      int v16 = v11;
    }
    else {
      int v16 = v11 + 31;
    }
    if ((v11 + 3839) <= 0x1DFE) {
      std::string::push_back(a1, 48);
    }
    std::to_string(&v26, v11 / 384);
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v17 = &v26;
    }
    else {
      std::string::size_type v17 = (std::string *)v26.__r_.__value_.__r.__words[0];
    }
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v26.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v26.__r_.__value_.__l.__size_;
    }
    std::string::append(a1, (const std::string::value_type *)v17, size);
    int v19 = (v16 >> 5) % 12;
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
    if ((v19 + 10) <= 0x12) {
      std::string::push_back(a1, 48);
    }
    std::to_string(&v26, v19 + 1);
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string v20 = &v26;
    }
    else {
      std::string v20 = (std::string *)v26.__r_.__value_.__r.__words[0];
    }
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v21 = HIBYTE(v26.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v21 = v26.__r_.__value_.__l.__size_;
    }
    std::string::append(a1, (const std::string::value_type *)v20, v21);
    int v22 = v11 - (v16 & 0xFFFFFFE0);
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
    if ((v22 + 9) <= 0x12) {
      std::string::push_back(a1, 48);
    }
    std::to_string(&v26, v22);
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v23 = &v26;
    }
    else {
      int v23 = (std::string *)v26.__r_.__value_.__r.__words[0];
    }
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v24 = HIBYTE(v26.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v24 = v26.__r_.__value_.__l.__size_;
    }
    std::string::append(a1, (const std::string::value_type *)v23, v24);
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1DC351FDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v19 + 23) < 0) {
    operator delete(*(void **)v19);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC352044()
{
  return &unk_1F365ED98;
}

uint64_t sub_1DC352050(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL16DecodeAI013x0x1xERKNS0_8BitArrayEPKcS7_E3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC35208C(uint64_t a1, _DWORD *a2)
{
  return (*a2 % 100000);
}

void sub_1DC3520C0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F708;
}

void *sub_1DC3520E0()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1F365F708;
  return result;
}

void sub_1DC352118()
{
}

void *sub_1DC352130()
{
  return &unk_1F365ED88;
}

uint64_t sub_1DC35213C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL16DecodeAI013x0x1xERKNS0_8BitArrayEPKcS7_E3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC352178(uint64_t a1, std::string *a2, int *a3)
{
  int v4 = *a3;
  int v5 = *(const char **)(a1 + 8);
  std::string::size_type v6 = strlen(v5);
  std::string::append(a2, v5, v6);
  std::to_string(&v9, v4 / 100000);
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v7 = &v9;
  }
  else {
    int v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
  }
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v9.__r_.__value_.__l.__size_;
  }
  std::string::append(a2, (const std::string::value_type *)v7, size);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_1DC35221C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC352240(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365F6B0;
  a2[1] = v2;
  return result;
}

void *sub_1DC352264(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1F365F6B0;
  result[1] = v3;
  return result;
}

void sub_1DC3522AC()
{
}

void *sub_1DC3522C4()
{
  return &unk_1F365ED78;
}

uint64_t sub_1DC3522D0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL14DecodeAI01320xERKNS0_8BitArrayEE3$_1")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t sub_1DC35230C(uint64_t a1, unsigned int *a2)
{
  if ((int)*a2 >= 10000) {
    return *a2 - 10000;
  }
  else {
    return *a2;
  }
}

void sub_1DC352330(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F658;
}

void *sub_1DC352350()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1F365F658;
  return result;
}

void sub_1DC352388()
{
}

void *sub_1DC3523A0()
{
  return &unk_1F365ED68;
}

uint64_t sub_1DC3523AC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL14DecodeAI01320xERKNS0_8BitArrayEE3$_0")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

std::string *sub_1DC3523E8(int a1, std::string *this, int *a3)
{
  if (*a3 >= 10000) {
    int v4 = "3203";
  }
  else {
    int v4 = "3202";
  }
  return std::string::append(this, v4, 4uLL);
}

void sub_1DC35241C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F600;
}

void *sub_1DC35243C()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1F365F600;
  return result;
}

void sub_1DC352474()
{
}

void *sub_1DC35248C()
{
  return &unk_1F36609C8;
}

uint64_t sub_1DC352498(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL14DecodeAI013103ERKNS0_8BitArrayEE3$_1")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t sub_1DC3524D4(uint64_t a1, unsigned int *a2)
{
  return *a2;
}

void sub_1DC3524E4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3661DE0;
}

void *sub_1DC352504()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1F3661DE0;
  return result;
}

void sub_1DC35253C()
{
}

void *sub_1DC352554()
{
  return &unk_1F36609B8;
}

uint64_t sub_1DC352560(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN5ZXing9__Nu_book4OneD3RSSL14DecodeAI013103ERKNS0_8BitArrayEE3$_0")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

std::string *sub_1DC35259C(int a1, std::string *this)
{
  return std::string::append(this, "3103", 4uLL);
}

void sub_1DC3525B8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3661D88;
}

void *sub_1DC3525D8()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1F3661D88;
  return result;
}

void sub_1DC352610()
{
}

void sub_1DC352628(int a1@<W1>, uint64_t a2@<X2>, uint64_t a3@<X3>, int a4@<W4>, uint64_t **a5@<X5>, uint64_t a6@<X8>)
{
  v64[2] = *MEMORY[0x1E4F143B8];
  int v10 = *a5;
  if (!*a5) {
    operator new();
  }
  int v55 = 0;
  int v56 = 0;
  uint64_t v57 = 0;
  sub_1DC352C78(&v55, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  uint64_t v52 = 0;
  long long v53 = 0;
  uint64_t v54 = 0;
  sub_1DC352C78(&v52, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  int v11 = v10 + 1;
  sub_1DC352CF4((unint64_t)v59, (uint64_t *)&v55, (uint64_t)v52, 0, a1);
  sub_1DC3532F0(v10 + 1, (uint64_t)v59);
  if (v55 != v56)
  {
    int v12 = v56 - 1;
    if (v56 - 1 > v55)
    {
      int v13 = (char *)v55 + 1;
      do
      {
        char v14 = *(v13 - 1);
        *(v13 - 1) = *v12;
        *v12-- = v14;
        BOOL v15 = v13++ >= v12;
      }
      while (!v15);
    }
  }
  int v16 = v52;
  std::string::size_type v17 = v53 - 1;
  if (v52 != v53 && v17 > v52)
  {
    uint64_t v19 = (char *)v52 + 1;
    do
    {
      char v20 = *(v19 - 1);
      *(v19 - 1) = *v17;
      *v17-- = v20;
      BOOL v15 = v19++ >= v17;
    }
    while (!v15);
  }
  sub_1DC352CF4((unint64_t)v59, (uint64_t *)&v55, (uint64_t)v16, 1, a1);
  sub_1DC3532F0(v10 + 4, (uint64_t)v59);
  if (a4) {
    int v21 = 1;
  }
  else {
    int v21 = 2;
  }
  for (uint64_t i = v10[2]; (uint64_t *)i != v11; uint64_t i = *(void *)(i + 8))
  {
    if (*(_DWORD *)(i + 72) >= v21)
    {
      for (uint64_t j = v10[5]; (uint64_t *)j != v10 + 4; uint64_t j = *(void *)(j + 8))
      {
        if (*(_DWORD *)(j + 72) >= v21)
        {
          int v24 = 9 * *(_DWORD *)(i + 24) + *(_DWORD *)(j + 24);
          if ((*(_DWORD *)(i + 20) + 16 * *(_DWORD *)(j + 20)) % 79 == v24 - (v24 > 72) - (v24 - (v24 > 72) > 8))
          {
            int v25 = *(_DWORD *)(i + 16);
            uint64_t v26 = *(int *)(j + 16);
            sub_1DC32A0F4((uint64_t)v59);
            *(void *)((char *)&v61[2] + (void)*(v60 - 3)) = 13;
            sub_1DC32A258(&v60, 48);
            unint64_t v27 = v26 + 4537077 * v25 - 10000000000000;
            std::wostream::operator<<();
            int v28 = 0;
            for (int k = 0; k != 13; ++k)
            {
              int v30 = std::wistream::get() - 48;
              if ((k & 1) == 0) {
                v30 *= 3;
              }
              v28 += v30;
            }
            std::wostream::put();
            double v32 = *(double *)(i + 48);
            double v31 = *(double *)(i + 56);
            double v34 = *(double *)(j + 48);
            double v33 = *(double *)(j + 56);
            double v35 = *(double *)(i + 40);
            double v36 = *(double *)(j + 40);
            sub_1DC32A320(&__dst, (uint64_t)v61);
            unint64_t v37 = std::wstring::insert(&__dst, 0, dword_1DC40AC30, 2uLL);
            float v38 = v31;
            float v39 = v35;
            float v40 = (float)(v38 - v39) / 46.0;
            float v41 = v36;
            float v42 = v33;
            float v43 = (float)(v41 - v42) / 46.0;
            float v44 = v32;
            std::wstring::size_type v45 = v37->__r_.__value_.__r.__words[0];
            v64[0] = v37->__r_.__value_.__l.__size_;
            *(void *)((char *)v64 + 7) = *(std::wstring::size_type *)((char *)&v37->__r_.__value_.__r.__words[1] + 7);
            char v46 = HIBYTE(v37->__r_.__value_.__r.__words[2]);
            v37->__r_.__value_.__l.__size_ = 0;
            v37->__r_.__value_.__r.__words[2] = 0;
            uint64_t v47 = (int)(float)(v39 - v40);
            v37->__r_.__value_.__r.__words[0] = 0;
            float v48 = v34;
            *(void *)a6 = 0x100000000000;
            *(void *)(a6 + 23) = *(void *)((char *)v64 + 7);
            uint64_t v49 = v64[0];
            *(void *)(a6 + 8) = v45;
            *(void *)(a6 + 16) = v49;
            *(unsigned char *)(a6 + 31) = v46;
            unint64_t v50 = v47 | ((unint64_t)(int)v44 << 32);
            unint64_t v51 = (int)(float)(v41 + (float)(v43 * 2.0)) | ((unint64_t)(int)v48 << 32);
            *(void *)(a6 + 32) = v50;
            *(void *)(a6 + 40) = v51;
            *(void *)(a6 + 48) = v51;
            *(void *)(a6 + 56) = v50;
            *(void *)(a6 + 112) = 0;
            *(void *)(a6 + 104) = 0;
            *(void *)(a6 + 72) = 0;
            *(void *)(a6 + 80) = 0;
            *(void *)(a6 + 64) = 0;
            *(void *)(a6 + 96) = a6 + 104;
            *(unsigned char *)(a6 + 120) = 0;
            *(_DWORD *)(a6 + 124) = 0;
            *(_DWORD *)(a6 + 128) = 0;
            *(_DWORD *)(a6 + 88) = 0;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            *(unsigned char *)(a6 + 120) = v27 < 0x9184E72A000;
            *(float *)(a6 + 124) = v40;
            *(float *)(a6 + 128) = v43;
            v59[0] = off_1F36621C8;
            int v63 = off_1F3662218;
            int v60 = off_1F36621F0;
            v61[0] = &unk_1F3662118;
            if (v62 < 0) {
              operator delete((void *)v61[8]);
            }
            std::wstreambuf::~wstreambuf();
            std::wostream::~wostream();
            std::wistream::~wistream();
            MEMORY[0x1E019CE20](&v63);
            goto LABEL_38;
          }
        }
      }
    }
  }
  *(_DWORD *)a6 = 1;
  *(void *)(a6 + 104) = 0;
  *(void *)(a6 + 112) = 0;
  *(_OWORD *)(a6 + 4) = 0u;
  *(_OWORD *)(a6 + 20) = 0u;
  *(_OWORD *)(a6 + 36) = 0u;
  *(_OWORD *)(a6 + 52) = 0u;
  *(_OWORD *)(a6 + 68) = 0u;
  *(void *)(a6 + 84) = 0;
  *(void *)(a6 + 96) = a6 + 104;
  *(unsigned char *)(a6 + 120) = 0;
  *(_DWORD *)(a6 + 124) = 0;
  *(_DWORD *)(a6 + 128) = 0;
LABEL_38:
  if (v52) {
    operator delete(v52);
  }
  if (v55) {
    operator delete(v55);
  }
}

void sub_1DC352C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_1DC32A4FC((uint64_t)&a22);
  if (a10) {
    operator delete(a10);
  }
  if (a13) {
    operator delete(a13);
  }
  _Unwind_Resume(a1);
}

void *sub_1DC352C78(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    std::string::size_type v6 = result;
    double result = sub_1DC314914(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      double result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1DC352CD8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1DC352CF4(unint64_t result, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  unint64_t v6 = result;
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  int32x4_t v89 = 0uLL;
  uint64_t v8 = *a2;
  uint64_t v7 = (unsigned __int8 *)a2[1];
  unint64_t v9 = v7 - *a2;
  int v10 = v7;
  int v11 = v7;
  if ((int)v9 >= 50)
  {
    int v12 = (unsigned __int8 *)(v8 + 18);
    if (v7 != (unsigned __int8 *)(v8 + 18))
    {
      while (*v12 != (a4 ^ 1))
      {
        if (++v12 == v7)
        {
          int v12 = (unsigned __int8 *)a2[1];
          break;
        }
      }
      if (v12 != v7)
      {
        uint64_t v13 = 0;
        int v10 = v12;
        int v11 = v12;
        while (1)
        {
          if (*v11 == (*v12 == 0)) {
            goto LABEL_11;
          }
          if (++v11 == v7)
          {
            int v11 = v7;
LABEL_11:
            v89.i32[v13] = v11 - v12;
            if (v11 == v7) {
              break;
            }
            if (++v13 == 4)
            {
              float v14 = (float)vaddvq_s32(v89);
              float v15 = v14 / 14.0;
              float v16 = v14 / 12.0;
              if (v15 >= 4.0) {
                float v17 = 0.0;
              }
              else {
                float v17 = 0.5;
              }
              float v18 = v17 + (float)(v16 * 0.5);
              float v19 = (float)(v89.i32[3] + v89.i32[2]);
              float v20 = -(float)(v18 - (float)(v15 * 2.0));
              BOOL v21 = v20 > v19 || (float)(v18 + (float)(v16 * 2.0)) < v19;
              float v22 = (float)v89.i32[0];
              float v23 = v15 - v18;
              BOOL v25 = v21 || v23 > v22 || (float)(v18 + (float)(v16 * 8.0)) < v22;
              float v26 = (float)v89.i32[1];
              BOOL v28 = v25 || v20 > v26 || (float)(v18 + (float)(v16 * 9.0)) < v26;
              float v29 = v16 + v18;
              float v30 = (float)v89.i32[2];
              BOOL v32 = v28 || v23 > v30 || v29 < v30;
              float v33 = (float)v89.i32[3];
              BOOL v35 = v32 || v23 > v33 || v29 < v33;
              if (!v35 && (uint64_t)&v10[-v8] > v11 - v10 && v7 - v11 > v11 - v10) {
                goto LABEL_51;
              }
              v10 += v89.i32[1] + v89.i32[0];
              v89.i64[0] = v89.i64[1];
              uint64_t v13 = 2;
            }
            int v12 = v11;
          }
        }
      }
    }
    int v10 = v7;
    int v11 = v7;
  }
LABEL_51:
  if (v10 >= v11 || v8 == (void)v10) {
    goto LABEL_102;
  }
  unint64_t v37 = v10;
  while (v37 != (unsigned __int8 *)v8)
  {
    int v38 = *--v37;
    if (v38 == *v10)
    {
      uint64_t v39 = a3;
      int v40 = v37 + 1;
      goto LABEL_60;
    }
  }
  uint64_t v39 = a3;
  int v40 = v8;
LABEL_60:
  int v86 = v40;
  int v41 = vaddvq_s32(v89) + v10 - v40;
  int v42 = v11 - v8;
  bzero(&v91, 0x400uLL);
  if (v41 < 1)
  {
    float v45 = 0.0;
    float v44 = 0.0;
    double result = v9;
  }
  else
  {
    uint64_t v43 = -(uint64_t)v41;
    float v44 = 0.0;
    float v45 = 0.0;
    double result = v9;
    do
    {
      uint64_t v46 = *(unsigned __int8 *)(v39 + v42 + v43);
      float v44 = v44 + (float)v46;
      float v45 = v45 + (float)(v46 * v46);
      ++*((_DWORD *)&v91 + v46);
      BOOL v47 = __CFADD__(v43++, 1);
    }
    while (!v47);
  }
  uint64_t v48 = 0;
  int v49 = 0;
  int v50 = 0;
  float v52 = (float)(v45 / (float)(v41 + 1)) - (float)((float)(v44 / (float)(v41 + 1)) * (float)(v44 / (float)(v41 + 1)));
  int v53 = (int)((double)v41 * 0.3);
  while (1)
  {
    int v54 = *((_DWORD *)&v91 + v48);
    if (v54 + v49 >= v53) {
      break;
    }
    v50 += v54 * v48++;
    v49 += v54;
    if (v48 == 255) {
      goto LABEL_71;
    }
  }
  v50 += (v53 - v49) * v48;
LABEL_71:
  int v55 = 0;
  int v56 = 0;
  float v57 = (float)(v50 / v53);
  unsigned int v58 = 255;
  while (1)
  {
    int v59 = *((_DWORD *)&v91 + v58);
    if (v59 + v55 >= v53) {
      break;
    }
    v56 += v59 * v58;
    v55 += v59;
    BOOL v47 = v58-- != 0;
    if (v58 == 0 || !v47) {
      goto LABEL_76;
    }
  }
  v56 += (v53 - v55) * v58;
LABEL_76:
  uint64_t v60 = 0;
  float v61 = (float)(v56 / v53);
  float v62 = 1.0 / (float)(v52 + v52);
  int v63 = (char *)&unk_1DC40AB10;
  int v64 = -1;
  float v65 = -0.15;
  do
  {
    uint64_t v66 = 0;
    int v67 = 0;
    do
    {
      v67 += *(_DWORD *)&v63[v66 * 4];
      float v51 = (double)v41 / 15.0;
      v90[v66++] = (int)((float)(v51 * (float)v67) + 0.5);
    }
    while (v66 != 5);
    uint64_t v68 = 0;
    float v69 = 0.0;
    do
    {
      if (v68) {
        int v70 = v90[(v68 - 1)];
      }
      else {
        int v70 = 0;
      }
      uint64_t v71 = v90[v68];
      if (v70 < (int)v71)
      {
        uint64_t v72 = v71 - v70;
        int v73 = (unsigned __int8 *)(v39 + v42 - v41 + v70);
        do
        {
          unsigned int v74 = *v73++;
          float v75 = (float)v74;
          if (((v68 & 1) == 0) != a4) {
            double v76 = fmin((float)(v75 - v61), 0.0);
          }
          else {
            double v76 = fmax((float)(v75 - v57), 0.0);
          }
          float v77 = v76;
          float v69 = v69 + (float)(v62 * (float)(v77 * v77));
          --v72;
        }
        while (v72);
      }
      ++v68;
    }
    while (v68 != 5);
    float v78 = (float)-v69 / (float)v41;
    if (v78 > v65)
    {
      int v64 = v60;
      float v65 = v78;
    }
    ++v60;
    v63 += 20;
  }
  while (v60 != 9);
  int v79 = a4 ? result + ~(v86 - v8) : v86 - (int)v8;
  int v80 = a4 ? result + ~v42 : v42;
  LODWORD(v91) = v64;
  DWORD1(v91) = v86 - v8;
  DWORD2(v91) = v42;
  *(double *)&long long v92 = (double)v79;
  *((double *)&v92 + 1) = (double)a5;
  *(double *)&long long v93 = (double)v80;
  *((double *)&v93 + 1) = (double)a5;
  if (v64 < 0
    || (v90[0] = 0, double result = sub_1DC3533A8(v8, v7, (uint64_t)&v91, 1, v90), v81 = result, result == 0x7FFFFFFF)
    || (v88 = 0, double result = sub_1DC3533A8(*a2, (unsigned char *)a2[1], (uint64_t)&v91, 0, &v88), result == 0x7FFFFFFF))
  {
LABEL_102:
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 48) = 0u;
    *(_OWORD *)unint64_t v6 = xmmword_1DC3FDC40;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_DWORD *)(v6 + 16) = -1;
    *(_OWORD *)(v6 + 24) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    *(_DWORD *)(v6 + 56) = 0;
  }
  else
  {
    int v82 = v90[0];
    int v83 = v88;
    if (a4)
    {
      int v83 = -v88;
      int v82 = -v90[0];
    }
    *(double *)&long long v92 = (float)((float)v79 - (float)v82);
    *((double *)&v92 + 1) = (float)a5;
    *(double *)&long long v93 = (float)((float)v80 + (float)v83);
    *((double *)&v93 + 1) = *((double *)&v92 + 1);
    *(_DWORD *)unint64_t v6 = result + 1597 * v81;
    *(_DWORD *)(v6 + 4) = ((result >> 30) & 0xFFFFFFFC) + HIDWORD(v81);
    long long v84 = v92;
    *(_OWORD *)(v6 + 8) = v91;
    *(_OWORD *)(v6 + 24) = v84;
    *(_OWORD *)(v6 + 40) = v93;
    *(_DWORD *)(v6 + 56) = 1;
  }
  return result;
}

uint64_t *sub_1DC3532F0(uint64_t *result, uint64_t a2)
{
  if (*(_DWORD *)a2 != 0x7FFFFFFF)
  {
    uint64_t v3 = result;
    uint64_t v4 = result[1];
    if ((uint64_t *)v4 == result)
    {
LABEL_7:
      double result = (uint64_t *)operator new(0x50uLL);
      long long v5 = *(_OWORD *)(a2 + 16);
      *((_OWORD *)result + 1) = *(_OWORD *)a2;
      *((_OWORD *)result + 2) = v5;
      long long v6 = *(_OWORD *)(a2 + 48);
      *((_OWORD *)result + 3) = *(_OWORD *)(a2 + 32);
      *((_OWORD *)result + 4) = v6;
      uint64_t v7 = *v3;
      *double result = *v3;
      result[1] = (uint64_t)v3;
      *(void *)(v7 + 8) = result;
      uint64_t *v3 = (uint64_t)result;
      ++v3[2];
    }
    else
    {
      while (*(_DWORD *)(v4 + 16) != *(_DWORD *)a2
           || *(_DWORD *)(v4 + 20) != *(_DWORD *)(a2 + 4)
           || *(_DWORD *)(a2 + 8) != *(_DWORD *)(v4 + 24))
      {
        uint64_t v4 = *(void *)(v4 + 8);
        if ((uint64_t *)v4 == result) {
          goto LABEL_7;
        }
      }
      ++*(_DWORD *)(v4 + 72);
    }
  }
  return result;
}

unint64_t sub_1DC3533A8(uint64_t a1, unsigned char *a2, uint64_t a3, int a4, int *a5)
{
  int32x4_t v90 = 0u;
  int32x4_t v91 = 0u;
  if (a4)
  {
    unint64_t v8 = sub_1DC353964(a1, a1 + *(int *)(a3 + 4), (uint64_t)&v90);
    if (v8 >= v9) {
      goto LABEL_22;
    }
    int v10 = 16;
  }
  else
  {
    int v12 = (unsigned char *)(a1 + *(int *)(a3 + 8));
    uint64_t v13 = sub_1DC353A28(v12, a2, (uint64_t)&v90);
    BOOL v15 = v14 != a2 || v91.i32[3] == 0;
    if (v15) {
      float v16 = v13;
    }
    else {
      float v16 = v12;
    }
    if (v15) {
      float v17 = v14;
    }
    else {
      float v17 = a2;
    }
    if (v16 >= v17) {
      goto LABEL_22;
    }
    float v18 = &v91.i8[12];
    float v19 = &v90.i8[4];
    do
    {
      int v20 = *((_DWORD *)v19 - 1);
      *((_DWORD *)v19 - 1) = *(_DWORD *)v18;
      *(_DWORD *)float v18 = v20;
      v18 -= 4;
      BOOL v21 = v19 >= v18;
      v19 += 4;
    }
    while (!v21);
    int v10 = 15;
  }
  int v22 = vaddvq_s32(vaddq_s32(v91, v90));
  *a5 = v22;
  float v23 = (float)v22 / (float)v10;
  float v24 = (float)(*(_DWORD *)(a3 + 8) - *(_DWORD *)(a3 + 4)) / 15.0;
  if ((float)(v23 * 1.5) < v24 || v23 > (float)(v24 * 1.5)) {
    goto LABEL_22;
  }
  for (uint64_t i = 0; i != 8; ++i)
  {
    float v30 = (float)v90.i32[i] / v23;
    int v31 = (int)(float)(v30 + 0.5);
    if (v31 >= 8) {
      int v31 = 8;
    }
    if (v31 <= 1) {
      int v31 = 1;
    }
    uint64_t v32 = i >> 1;
    float v33 = v30 - (float)v31;
    if (i) {
      double v34 = &v88;
    }
    else {
      double v34 = &v89;
    }
    if (i) {
      BOOL v35 = v86;
    }
    else {
      BOOL v35 = v87;
    }
    v34->i32[v32] = v31;
    *(float *)&v35[v32] = v33;
  }
  int v36 = vaddvq_s32(v89);
  int v37 = vaddvq_s32(v88);
  int v38 = vaddvq_s32(vaddq_s32(v88, v89));
  int v39 = v38 - v10;
  int v40 = ((v36 & 1) == 0) ^ a4;
  if (a4) {
    int v41 = 12;
  }
  else {
    int v41 = 11;
  }
  if (a4) {
    int v42 = 4;
  }
  else {
    int v42 = 5;
  }
  if (a4) {
    int v43 = 12;
  }
  else {
    int v43 = 10;
  }
  BOOL v44 = v36 > v41;
  BOOL v45 = v37 > v43;
  BOOL v46 = v37 < 4;
  if (v39 == -1)
  {
    if (v40)
    {
      uint64_t v26 = 0;
      unsigned int v27 = 0x7FFFFFFF;
      if ((v37 & 1) != 0 || v36 > v41) {
        return v27 | (unint64_t)(v26 << 32);
      }
LABEL_81:
      float v52 = *(float *)v87;
      uint64_t v53 = 1;
      int v54 = (char *)v87;
      do
      {
        if (v52 < *(float *)&v87[v53])
        {
          float v52 = *(float *)&v87[v53];
          int v54 = (char *)&v87[v53];
        }
        ++v53;
      }
      while (v53 != 4);
      int64_t v50 = v54 - (char *)v87;
      __int32 v51 = *(__int32 *)((char *)v89.i32 + v54 - (char *)v87) + 1;
      goto LABEL_86;
    }
    if ((v37 & 1) == 0) {
      goto LABEL_22;
    }
    BOOL v46 = 1;
  }
  else if (v39 == 1)
  {
    if (v40)
    {
      if (v37) {
        goto LABEL_22;
      }
      BOOL v44 = 1;
    }
    else
    {
      if ((v37 & 1) == 0) {
        goto LABEL_22;
      }
      BOOL v45 = 1;
    }
  }
  else
  {
    if (v38 != v10) {
      goto LABEL_22;
    }
    if (v40)
    {
      if ((v37 & 1) == 0) {
        goto LABEL_22;
      }
      BOOL v44 = v36 >= v37 || v36 > v41;
      BOOL v46 = v36 >= v37 || v37 < 4;
      BOOL v45 = v37 > v43 || v36 < v37;
      if (v36 < v42 || v36 < v37) {
        goto LABEL_80;
      }
      goto LABEL_68;
    }
    if (v37) {
      goto LABEL_22;
    }
  }
  if (v36 < v42)
  {
LABEL_80:
    if (v44) {
      goto LABEL_22;
    }
    goto LABEL_81;
  }
LABEL_68:
  if (v44)
  {
    float v47 = *(float *)v87;
    uint64_t v48 = 1;
    int v49 = (char *)v87;
    do
    {
      if (*(float *)&v87[v48] < v47)
      {
        float v47 = *(float *)&v87[v48];
        int v49 = (char *)&v87[v48];
      }
      ++v48;
    }
    while (v48 != 4);
    int64_t v50 = v49 - (char *)v87;
    __int32 v51 = *(__int32 *)((char *)v89.i32 + v49 - (char *)v87) - 1;
LABEL_86:
    *(__int32 *)((char *)v89.i32 + v50) = v51;
    if (v46) {
      goto LABEL_87;
    }
    goto LABEL_94;
  }
  if (v46)
  {
LABEL_87:
    if (!v45)
    {
      float v55 = *(float *)v86;
      uint64_t v56 = 1;
      float v57 = (char *)v86;
      do
      {
        if (v55 < *(float *)&v86[v56])
        {
          float v55 = *(float *)&v86[v56];
          float v57 = (char *)&v86[v56];
        }
        ++v56;
      }
      while (v56 != 4);
      int v58 = 1;
LABEL_100:
      *(__int32 *)((char *)v88.i32 + v57 - (char *)v86) += v58;
      goto LABEL_101;
    }
LABEL_22:
    uint64_t v26 = 0;
    unsigned int v27 = 0x7FFFFFFF;
    return v27 | (unint64_t)(v26 << 32);
  }
LABEL_94:
  if (v45)
  {
    float v59 = *(float *)v86;
    uint64_t v60 = 1;
    float v57 = (char *)v86;
    do
    {
      if (*(float *)&v86[v60] < v59)
      {
        float v59 = *(float *)&v86[v60];
        float v57 = (char *)&v86[v60];
      }
      ++v60;
    }
    while (v60 != 4);
    int v58 = -1;
    goto LABEL_100;
  }
LABEL_101:
  __int32 v61 = v89.i32[0];
  uint64_t v62 = 1;
  int v63 = &v89;
  do
  {
    if (v89.i32[v62] < v61)
    {
      __int32 v61 = v89.i32[v62];
      int v63 = (int32x4_t *)((char *)&v89 + v62 * 4);
    }
    ++v62;
  }
  while (v62 != 4);
  if (!v63->i32[0]) {
    goto LABEL_22;
  }
  __int32 v64 = v88.i32[0];
  uint64_t v65 = 1;
  uint64_t v66 = &v88;
  do
  {
    if (v88.i32[v65] < v64)
    {
      __int32 v64 = v88.i32[v65];
      uint64_t v66 = (int32x4_t *)((char *)&v88 + v65 * 4);
    }
    ++v65;
  }
  while (v65 != 4);
  if (!v66->i32[0]) {
    goto LABEL_22;
  }
  __int32 v67 = 0;
  for (uint64_t j = 3; j != -1; --j)
    __int32 v67 = v89.i32[j] + 9 * v67;
  __int32 v69 = 0;
  for (uint64_t k = 3; k != -1; --k)
    __int32 v69 = v88.i32[k] + 9 * v69;
  uint64_t v71 = (3 * v69 + v67);
  uint64_t v26 = 0;
  if (a4)
  {
    int v72 = vaddvq_s32(v89);
    unsigned int v27 = 0x7FFFFFFF;
    if ((v72 & 1) == 0 && (v72 - 13) >= 0xFFFFFFF7)
    {
      unsigned int v73 = (12 - v72) >> 1;
      int v74 = dword_1DC40ABC4[v73];
      int v75 = 9 - v74;
      int v76 = sub_1DC399FD4(v89.i32, 4u, v74, 1);
      int v77 = sub_1DC399FD4(v88.i32, 4u, v75, 0);
      int v78 = dword_1DC40ABEC[v73];
      int v79 = v77 + dword_1DC40ABD8[v73] * v76;
LABEL_122:
      unsigned int v27 = v79 + v78;
      uint64_t v26 = v71;
    }
  }
  else
  {
    int v80 = vaddvq_s32(v88);
    unsigned int v27 = 0x7FFFFFFF;
    if ((v80 & 1) == 0 && (v80 - 11) >= 0xFFFFFFF9)
    {
      unsigned int v81 = (10 - v80) >> 1;
      int v82 = dword_1DC40AC00[v81];
      int v83 = 9 - v82;
      int v84 = sub_1DC399FD4(v89.i32, 4u, v82, 0);
      int v85 = sub_1DC399FD4(v88.i32, 4u, v83, 1);
      int v78 = dword_1DC40AC20[v81];
      int v79 = v84 + dword_1DC40AC10[v81] * v85;
      goto LABEL_122;
    }
  }
  return v27 | (unint64_t)(v26 << 32);
}

uint64_t sub_1DC353964(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 28) = 0;
  uint64_t v3 = (int *)(a3 + 28);
  if (a2 == result)
  {
    int v9 = 0;
    uint64_t v8 = a2;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = a2;
    while (1)
    {
      uint64_t v6 = v5;
      while (v6 != result)
      {
        int v7 = *(unsigned __int8 *)--v6;
        if (v7 == (*(unsigned char *)(v5 - 1) == 0))
        {
          uint64_t v8 = v6 + 1;
          goto LABEL_8;
        }
      }
      uint64_t v8 = result;
LABEL_8:
      *(_DWORD *)(a3 + 4 * v4) = v5 - v8;
      if (v8 == result) {
        break;
      }
      ++v4;
      uint64_t v5 = v8;
      if (v4 == 8) {
        goto LABEL_13;
      }
    }
    uint64_t v8 = result;
LABEL_13:
    int v9 = *v3;
  }
  unint64_t v10 = a3 + 4;
  do
  {
    int v11 = *(_DWORD *)(v10 - 4);
    *(_DWORD *)(v10 - 4) = *v3;
    *v3-- = v11;
    BOOL v12 = v10 >= (unint64_t)v3;
    v10 += 4;
  }
  while (!v12);
  if (v8 != result || v9 == 0) {
    return v8;
  }
  return result;
}

unsigned char *sub_1DC353A28(unsigned char *result, unsigned char *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = result;
    uint64_t v5 = result;
    while (1)
    {
      while (*v5 == (*v4 == 0))
      {
LABEL_6:
        *(_DWORD *)(a3 + 4 * v3) = v5 - v4;
        if (v5 == a2) {
          return a2;
        }
        ++v3;
        uint64_t v4 = v5;
        if (v3 == 8) {
          return result;
        }
      }
      if (++v5 == a2)
      {
        uint64_t v5 = a2;
        goto LABEL_6;
      }
    }
  }
  return a2;
}

void sub_1DC353A94(void *a1)
{
  *a1 = &unk_1F3660FA8;
  uint64_t v1 = a1 + 1;
  sub_1DC353B08(a1 + 4);
  sub_1DC353B08(v1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC353B08(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    double result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    _OWORD v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        double result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void *sub_1DC353B6C(void *a1)
{
  *a1 = &unk_1F3660FA8;
  uint64_t v2 = a1 + 1;
  sub_1DC353B08(a1 + 4);
  sub_1DC353B08(v2);
  return a1;
}

void sub_1DC353BC0()
{
}

void sub_1DC353BD8(std::exception *a1)
{
  sub_1DC379B0C(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC353C14(void *a1, char *a2)
{
  double result = sub_1DC379B70(a1, a2);
  *double result = &unk_1F36613B0;
  return result;
}

float sub_1DC353C48(float *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1] - *a2;
  if ((int)((unint64_t)v3 >> 2) >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (int)(v3 >> 2);
    do
    {
      uint64_t v6 = (float *)(v2 + 4 * v4);
      float v7 = *v6;
      float v8 = v6[1];
      float v9 = a1[11] + (float)((float)(v8 * a1[10]) + (float)(a1[9] * *v6));
      float *v6 = (float)(a1[5] + (float)((float)(v8 * a1[4]) + (float)(a1[3] * *v6))) / v9;
      float result = (float)(a1[8] + (float)((float)(v8 * a1[7]) + (float)(a1[6] * v7))) / v9;
      v6[1] = result;
      v4 += 2;
    }
    while (v4 < v5);
  }
  return result;
}

void sub_1DC353CC8()
{
}

void sub_1DC353CE0()
{
}

void sub_1DC353DB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, atomic_uint *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, atomic_uint *);
  sub_1DC30184C((atomic_uint **)va);
  sub_1DC30184C((atomic_uint **)va2);
  sub_1DC30184C((atomic_uint **)va1);
  _Unwind_Resume(a1);
}

void sub_1DC353DF0()
{
}

void sub_1DC353F50()
{
}

void sub_1DC354074()
{
}

double sub_1DC354150(void *a1, float *a2)
{
  float v2 = (float)((float)(a2[3] * (float)((float)(a2[7] * a2[11]) - (float)(a2[10] * a2[8])))
             - (float)(a2[6] * (float)((float)(a2[4] * a2[11]) - (float)(a2[10] * a2[5]))))
     + (float)(a2[9] * (float)((float)(a2[4] * a2[8]) - (float)(a2[7] * a2[5])));
  *a1 = 0;
  double result = fabsf(v2);
  if (result > 0.00001) {
    sub_1DC354074();
  }
  return result;
}

void sub_1DC354224(_Unwind_Exception *a1)
{
  sub_1DC30184C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC354238(uint64_t a1, const void **a2, uint64_t a3)
{
  v12[48] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v6 = (uint64_t)a2[1];
  if ((unint64_t)(v6 - (void)v5) >= 0x10)
  {
    memset(v12, 0, 24);
    sub_1DC3219D0(v12, v5, v6, (v6 - (uint64_t)v5) >> 2);
    memset(v11, 0, sizeof(v11));
    sub_1DC3219D0(v11, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
    sub_1DC35477C((uint64_t)v10, a2, v12);
    sub_1DC35477C((uint64_t)v9, (void *)a3, v11);
    if (v10[36] && v9[36]) {
      operator new[]();
    }
    if (v11[0]) {
      operator delete(v11[0]);
    }
    if (v12[0]) {
      operator delete(v12[0]);
    }
  }
  return 0;
}

void sub_1DC354770(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1DC2FFA58(a1);
}

void sub_1DC35477C(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = a2[1] - *a2;
  unint64_t v7 = (unint64_t)(v6 >> 2) >> 1;
  sub_1DC320A5C(&__p, v7);
  sub_1DC320A5C(&v42, v7);
  float v8 = (float *)__p;
  if ((unint64_t)v6 >= 8)
  {
    float v9 = v42;
    if (v7 <= 1) {
      unint64_t v10 = 1;
    }
    else {
      unint64_t v10 = (unint64_t)(v6 >> 2) >> 1;
    }
    int v11 = (int *)(*a2 + 4);
    BOOL v12 = __p;
    do
    {
      *v12++ = *(v11 - 1);
      int v13 = *v11;
      v11 += 2;
      *(_DWORD *)v9++ = v13;
      --v10;
    }
    while (v10);
  }
  float v14 = 0.0;
  float v15 = 0.0;
  if (v8 != v45)
  {
    float v16 = v8;
    do
    {
      float v17 = *v16++;
      float v15 = v15 + v17;
    }
    while (v16 != v45);
  }
  float v18 = (float)v7;
  float v19 = v42;
  if (v42 != v43)
  {
    float v14 = 0.0;
    int v20 = v42;
    do
    {
      float v21 = *v20++;
      float v14 = v14 + v21;
    }
    while (v20 != v43);
  }
  float v22 = v15 / v18;
  float v23 = 0.0;
  float v24 = v14 / v18;
  if ((unint64_t)v6 >= 8)
  {
    if (v7 <= 1) {
      unint64_t v25 = 1;
    }
    else {
      unint64_t v25 = (unint64_t)(v6 >> 2) >> 1;
    }
    uint64_t v26 = v8;
    unsigned int v27 = v42;
    do
    {
      float v28 = *v26++;
      float v29 = v23 + (float)((float)(v28 - v22) * (float)(v28 - v22));
      float v30 = *v27++;
      float v23 = v29 + (float)((float)(v30 - v24) * (float)(v30 - v24));
      --v25;
    }
    while (v25);
  }
  float v31 = 1.41421356 / sqrtf(v23 / v18);
  float v32 = -(float)(v31 * v24);
  if ((unint64_t)v6 < 8)
  {
LABEL_26:
    *(float *)a1 = v31;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(float *)(a1 + 16) = v31;
    *(_DWORD *)(a1 + 20) = 0;
    *(float *)(a1 + 24) = -(float)(v31 * v22);
    *(float *)(a1 + 28) = v32;
    *(_DWORD *)(a1 + 32) = 1065353216;
    *(unsigned char *)(a1 + 36) = 1;
    if (!v19)
    {
      if (!v8) {
        return;
      }
      goto LABEL_28;
    }
  }
  else
  {
    if (v7 <= 1) {
      unint64_t v33 = 1;
    }
    else {
      unint64_t v33 = (unint64_t)(v6 >> 2) >> 1;
    }
    double v34 = (float *)(*a3 + 4);
    BOOL v35 = v8;
    int v36 = v42;
    while (1)
    {
      float v37 = *v35;
      float v38 = *v36 * 0.0;
      float v39 = (float)(v38 + (float)(*v35 * 0.0)) + 1.0;
      if (v39 == 0.0) {
        break;
      }
      float v40 = (float)((float)(v38 + (float)(v31 * v37)) - (float)(v31 * v22)) / v39;
      float v41 = (float)(v32 + (float)((float)(*v36 * v31) + (float)(v37 * 0.0))) / v39;
      *(v34 - 1) = v40;
      float *v34 = v41;
      v34 += 2;
      ++v36;
      ++v35;
      if (!--v33) {
        goto LABEL_26;
      }
    }
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 36) = 0;
  }
  int v43 = v19;
  operator delete(v19);
  float v8 = (float *)__p;
  if (!__p) {
    return;
  }
LABEL_28:
  BOOL v45 = v8;
  operator delete(v8);
}

void sub_1DC3549A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3549C4(int a1, float *a2, int a3, float *a4, uint64_t a5)
{
  uint64_t result = 2;
  if (a3 >= 15 && (a3 & 3) == 3 && (a1 == a3 || a3 + 1 == a1) && *a2 <= *a4)
  {
    size_t v11 = (a3 - 1);
    BOOL v12 = (float *)malloc_type_calloc(v11, 4uLL, 0x100004052888210uLL);
    uint64_t v13 = 0;
    do
    {
      v12[v13] = a2[v13 + 1] - a2[v13];
      ++v13;
    }
    while (v11 != v13);
    uint64_t v14 = 0;
    float v15 = 0.0;
    float v16 = 0.0;
    float v17 = 0.0;
    float v18 = 0.0;
    do
    {
      float v15 = v15 + (float)(int)v14;
      float v16 = v16 + (float)((float)(int)v14 * (float)(int)v14);
      float v19 = v12[v14];
      float v17 = v17 + (float)((float)(int)v14 * v19);
      float v18 = v18 + v19;
      ++v14;
    }
    while (v11 != v14);
    uint64_t v20 = 0;
    float v21 = (float)((float)((float)(int)v11 * v17) - (float)(v15 * v18))
        / (float)((float)((float)(int)v11 * v16) - (float)(v15 * v15));
    float v22 = (float)(v18 - (float)(v21 * v15)) / (float)(int)v11;
    float v23 = 0.0;
    do
    {
      float v23 = v23
          + (float)((float)((float)(v22 + (float)(v21 * (float)(int)v20)) - v12[v20])
                  * (float)((float)(v22 + (float)(v21 * (float)(int)v20)) - v12[v20]));
      ++v20;
    }
    while (v11 != v20);
    float v24 = v23 * (float)(int)v11;
    float v25 = (float)(v18 * v18) * 0.01;
    free(v12);
    if (v24 > v25) {
      return 2;
    }
    float v26 = (float)(a2[1] - *a2) / 3.0;
    if (fabsf((float)(*a4 - *a2) + (float)(v26 * -2.0)) > (float)(v26 * 0.5)) {
      return 2;
    }
    *(float *)(a5 + 72) = v26;
    unsigned int v27 = *(_DWORD **)(a5 + 64);
    v27[12] = *(_DWORD *)a2;
    float v28 = a2[v11];
    v27[10] = 0;
    uint64_t v29 = (a3 - 2);
    float v30 = a2[v29];
    float v31 = (float)(v28 - v30) / 3.0;
    if (vabds_f32(a4[v11] - v28, v31) > (float)(v31 * 0.5) || vabds_f32(a4[v29] - v30, v31) > (float)(v31 * 0.5))
    {
      return 2;
    }
    else
    {
      *(float *)(a5 + 76) = v31;
      v27[11] = 0;
      v27[13] = LODWORD(a4[v11]);
      float v32 = *(void **)(a5 + 16);
      if (v32) {
        free(v32);
      }
      size_t v33 = (a3 - 3) >> 2;
      *(void *)(a5 + 8) = v33;
      *(void *)(a5 + 16) = 0;
      double v34 = malloc_type_calloc(v33, 1uLL, 0x100004077774924uLL);
      uint64_t v35 = 0;
      LOBYTE(v36) = 0;
      *(void *)(a5 + 16) = v34;
      do
      {
        int v36 = ((float)(a4[v35 + 1] - a2[v35 + 1]) > (float)(a2[v35 + 2] - a4[v35 + 1])) | (char)(2 * v36);
        if ((++v35 & 3) == 0)
        {
          if (v36 > 9) {
            goto LABEL_35;
          }
          *(unsigned char *)((v35 >> 2) + *(void *)(a5 + 16) - 1) = v36;
          LOBYTE(v36) = 0;
        }
      }
      while (v29 - 1 != v35);
      uint64_t v37 = *(void *)(a5 + 8);
      if ((int)v37 >= 1)
      {
        int v38 = 0;
        uint64_t v39 = *(void *)(a5 + 16);
        unint64_t v40 = *(void *)(a5 + 8) + 1;
        int v41 = 1;
        do
        {
          int v42 = *(char *)(v39 + (v40 - 2));
          if (!v41) {
            int v42 = dword_1DC40AD54[*(char *)(v39 + (v40 - 2))];
          }
          v38 += v42;
          v41 ^= 1u;
          --v40;
        }
        while (v40 > 1);
        HIDWORD(v43) = -858993459 * v38 + 429496728;
        LODWORD(v43) = HIDWORD(v43);
        if ((v43 >> 1) >= 0x19999999)
        {
          int v44 = *(char *)(v39 + (v37 - 1));
          if ((int)v37 >= 2)
          {
            uint64_t v45 = (v37 - 2);
            int v46 = 2;
            do
            {
              if (v46 > 7) {
                int v46 = 2;
              }
              v44 += v46 * *(char *)(v39 + v45--);
              ++v46;
            }
            while (v45 != -1);
          }
          if ((-1171354717 * v44 + 195225786) >= 0x1745D175)
          {
LABEL_35:
            *(void *)(a5 + 8) = 0;
            *(_DWORD *)(a5 + 24) = 0;
            return 2;
          }
        }
      }
      uint64_t result = 0;
      *(_DWORD *)(a5 + 24) = 1065353216;
      *(_DWORD *)(a5 + 80) = 1;
      *(_DWORD *)(a5 + 84) = v37;
      *(_DWORD *)(*(void *)(a5 + 64) + 20) = a3;
    }
  }
  return result;
}

uint64_t sub_1DC354D6C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - 1;
  if ((unint64_t)(a3 - 1) >= *(void *)(result + 8)) {
    uint64_t v3 = *(void *)(result + 8);
  }
  if (v3)
  {
    for (uint64_t i = 0; i != v3; ++i)
      *(unsigned char *)(a2 + i) = *(unsigned char *)(*(void *)(result + 16) + i) + 48;
  }
  *(unsigned char *)(a2 + v3) = 0;
  return result;
}

BOOL sub_1DC354DA8(int a1)
{
  return (a1 & 3) != 0 && a1 > 14;
}

void sub_1DC354DB8()
{
}

void sub_1DC35510C(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

void sub_1DC355144(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661A00;
  sub_1DC3551D0((atomic_uint **)(a1 + 72));
  sub_1DC3551D0((atomic_uint **)(a1 + 64));
  float v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3)
  {
    *(void *)(a1 + 24) = v3;
    operator delete(v3);
  }
  JUMPOUT(0x1E019CE90);
}

atomic_uint **sub_1DC3551D0(atomic_uint **a1)
{
  float v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t sub_1DC355204(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661A00;
  sub_1DC3551D0((atomic_uint **)(a1 + 72));
  sub_1DC3551D0((atomic_uint **)(a1 + 64));
  float v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3)
  {
    *(void *)(a1 + 24) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1DC355270(uint64_t a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = (std::once_flag::_State_type *)(a1 + 88);
  if (atomic_load_explicit((atomic_ullong *volatile)v1, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v2;
    uint64_t v3 = &v4;
    std::__call_once(v1, &v3, (void (__cdecl *)(void *))sub_1DC3552C8);
  }
}

void sub_1DC3552C8(uint64_t ***a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *v1;
  sub_1DC3556D4((char **)(*v1 + 16), *(int *)(*v1 + 80));
  sub_1DC3556D4((char **)(v2 + 40), *(int *)(v2 + 80));
  if (*(int *)(v2 + 80) >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(v2 + 16);
    int v5 = 1;
    do
    {
      *(_DWORD *)(v4 + 4 * v3) = v5;
      v5 *= 2;
      uint64_t v6 = *(int *)(v2 + 80);
      if (v5 >= (int)v6) {
        int v5 = (*(_DWORD *)(v2 + 84) ^ v5) & (v6 - 1);
      }
      ++v3;
    }
    while (v3 < v6);
    if ((int)v6 >= 2)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(v2 + 40);
      do
      {
        *(_DWORD *)(v8 + 4 * *(int *)(v4 + 4 * v7)) = v7;
        ++v7;
      }
      while (v7 < *(int *)(v2 + 80) - 1);
    }
  }
  operator new();
}

void sub_1DC3555E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, uint64_t a10, uint64_t a11, atomic_uint *a12, atomic_uint *a13, uint64_t a14)
{
}

void sub_1DC3556D4(char **a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 2;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    float v19 = &v3[4 * a2];
    goto LABEL_15;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 2)
  {
    bzero(a1[1], 4 * v6);
    float v19 = &v4[4 * v6];
LABEL_15:
    a1[1] = v19;
    return;
  }
  if (a2 >> 62) {
    sub_1DC2FF97C();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 1;
  if (v8 >> 1 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v10 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  size_t v11 = (char *)sub_1DC314E5C(v10);
  BOOL v12 = *a1;
  uint64_t v13 = a1[1];
  uint64_t v14 = &v11[4 * v5];
  float v16 = &v11[4 * v15];
  bzero(v14, 4 * v6);
  float v17 = &v14[4 * v6];
  while (v13 != v12)
  {
    int v18 = *((_DWORD *)v13 - 1);
    v13 -= 4;
    *((_DWORD *)v14 - 1) = v18;
    v14 -= 4;
  }
  *a1 = v14;
  a1[1] = v17;
  a1[2] = v16;
  if (v12)
  {
    operator delete(v12);
  }
}

void sub_1DC3557E8()
{
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBFFC2D8, memory_order_acquire) != -1)
  {
    CFAllocatorRef v0 = &v1;
    uint64_t v1 = sub_1DC354DB8;
    std::__call_once(&qword_1EBFFC2D8, &v0, (void (__cdecl *)(void *))sub_1DC33DA8C);
  }
}

void sub_1DC35584C(void *a1, uint64_t a2, int a3, int a4)
{
  sub_1DC355270(a2);
  if (a3 < 0)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "Degree must be non-negative");
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  if (a4) {
    operator new();
  }
  *a1 = 0;
  uint64_t v8 = *(void *)(a2 + 64);
  if (v8) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v8 + 8), 1u, memory_order_relaxed);
  }
  *a1 = v8;
}

void sub_1DC3559F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16)
{
  __cxa_free_exception(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC355A70(uint64_t a1, int a2)
{
  sub_1DC355270(a1);
  if (!a2)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "Cannot calculate the inverse of 0");
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  return *(unsigned int *)(*(void *)(a1 + 16)
                         + 4 * (*(_DWORD *)(a1 + 80) + ~*(_DWORD *)(*(void *)(a1 + 40) + 4 * a2)));
}

void sub_1DC355AF0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC355B04(uint64_t a1, int a2, int a3)
{
  sub_1DC355270(a1);
  uint64_t result = 0;
  if (a2)
  {
    if (a3) {
      return *(unsigned int *)(*(void *)(a1 + 16)
    }
                             + 4
                             * ((*(_DWORD *)(*(void *)(a1 + 40) + 4 * a3)
                               + *(_DWORD *)(*(void *)(a1 + 40) + 4 * a2))
                              % (*(_DWORD *)(a1 + 80) - 1)));
  }
  return result;
}

uint64_t sub_1DC355B6C(uint64_t a1, void *a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661148;
  *(void *)(a1 + 16) = 0;
  unint64_t v6 = (atomic_uint **)(a1 + 16);
  uint64_t v7 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 8), 1u, memory_order_relaxed);
    if (*v6) {
      sub_1DC2FF57C(*v6);
    }
  }
  *(void *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = &unk_1F3661928;
  *(void *)(a1 + 40) = 0;
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t v9 = *(_DWORD **)(v8 + 16);
  unint64_t v10 = *(void *)(v8 + 24) - (void)v9;
  if (!v10)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC379B70(exception, "need coefficients");
    void *exception = &unk_1F36613B0;
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  unint64_t v11 = v10 >> 2;
  if ((int)(v10 >> 2) < 2 || *v9)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v8 + 8), 1u, memory_order_relaxed);
    BOOL v12 = *(atomic_uint **)(a1 + 40);
    if (v12) {
      sub_1DC2FF57C(v12);
    }
    *(void *)(a1 + 40) = v8;
  }
  else
  {
    uint64_t v14 = (v10 >> 2);
    uint64_t v15 = 1;
    while (!v9[v15])
    {
      if (v14 == ++v15) {
        goto LABEL_16;
      }
    }
    if (v15 != v11) {
      operator new();
    }
LABEL_16:
    uint64_t v16 = *a2;
    sub_1DC355270(*a2);
    float v17 = *(atomic_uint **)(v16 + 64);
    if (v17) {
      atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
    }
    float v21 = v17;
    sub_1DC314B64((uint64_t)&v22, (uint64_t)(v17 + 6));
    uint64_t v18 = v23;
    if (v23) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v23 + 8), 1u, memory_order_relaxed);
    }
    float v19 = *(atomic_uint **)(a1 + 40);
    if (v19) {
      sub_1DC2FF57C(v19);
    }
    *(void *)(a1 + 40) = v18;
    sub_1DC314BD0(&v22);
    sub_1DC3551D0(&v21);
  }
  return a1;
}

void sub_1DC355E30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC314BD0((uint64_t *)va);
  sub_1DC314BD0(v3);
  sub_1DC314B30(v2);
  _Unwind_Resume(a1);
}

void sub_1DC355EB8(void *a1)
{
  *a1 = &unk_1F3661148;
  uint64_t v1 = (atomic_uint **)(a1 + 2);
  sub_1DC314BD0(a1 + 3);
  sub_1DC314B30(v1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC355F2C(void *a1)
{
  *a1 = &unk_1F3661148;
  uint64_t v2 = (atomic_uint **)(a1 + 2);
  sub_1DC314BD0(a1 + 3);
  sub_1DC314B30(v2);
  return a1;
}

uint64_t sub_1DC355F80(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int **)(*(void *)(a1 + 40) + 16);
  unint64_t v3 = *(void *)(*(void *)(a1 + 40) + 24) - (void)v2;
  if (!a2) {
    return *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 24) - 4);
  }
  unint64_t v5 = v3 >> 2;
  if (a2 == 1)
  {
    if ((int)v5 < 1)
    {
      return 0;
    }
    else
    {
      LODWORD(v6) = 0;
      uint64_t v7 = (v3 >> 2);
      do
      {
        int v8 = *v2++;
        uint64_t v6 = v8 ^ v6;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    uint64_t v6 = *v2;
    if ((int)v5 >= 2)
    {
      uint64_t v10 = (v3 >> 2);
      uint64_t v11 = 1;
      do
        uint64_t v6 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 16) + 4 * v11++) ^ sub_1DC355B04(*(void *)(a1 + 16), a2, v6);
      while (v10 != v11);
    }
  }
  return v6;
}

void *sub_1DC356040(void *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  if (*(void *)(a2 + 16) != *(void *)(*a3 + 16))
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "GenericGFPolys do not have same GenericGF field");
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  if (**(_DWORD **)(*(void *)(a2 + 40) + 16))
  {
    if (**(_DWORD **)(*(void *)(v3 + 40) + 16))
    {
      sub_1DC314B64((uint64_t)v12, a2 + 24);
      sub_1DC314B64((uint64_t)v10, *a3 + 24);
      if (*((void *)v13 + 3) - *((void *)v13 + 2) > *((void *)v11 + 3) - *((void *)v11 + 2))
      {
        sub_1DC314B64((uint64_t)&v8, (uint64_t)v12);
        unint64_t v5 = v11;
        if (v11) {
          atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
        }
        if (v13) {
          sub_1DC2FF57C(v13);
        }
        uint64_t v13 = v5;
        uint64_t v6 = v9;
        if (v9) {
          atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
        }
        if (v11) {
          sub_1DC2FF57C(v11);
        }
        uint64_t v11 = v6;
        sub_1DC314BD0(&v8);
      }
      operator new();
    }
    atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 8), 1u, memory_order_relaxed);
    *uint64_t result = a2;
  }
  else
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
    *uint64_t result = v3;
  }
  return result;
}

void sub_1DC35632C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1DC314BD0((uint64_t *)va);
  sub_1DC314BD0((void *)(v8 - 64));
  _Unwind_Resume(a1);
}

void sub_1DC3563B8()
{
}

void sub_1DC3563C0()
{
  __cxa_free_exception(v0);
  JUMPOUT(0x1DC3563B0);
}

void sub_1DC3563D0(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3 != *(void *)(*(void *)a3 + 16))
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC353C14(exception, "GenericGFPolys do not have same GenericGF field");
    __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
  }
  if (**(_DWORD **)(*(void *)(a2 + 40) + 16) && **(_DWORD **)(*(void *)(*(void *)a3 + 40) + 16))
  {
    sub_1DC314B64((uint64_t)v9, a2 + 24);
    sub_1DC314B64((uint64_t)v8, *(void *)a3 + 24);
    operator new();
  }
  sub_1DC355270(*(void *)(a2 + 16));
  uint64_t v6 = *(void *)(v3 + 64);
  if (v6) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v6 + 8), 1u, memory_order_relaxed);
  }
  *a1 = v6;
}

void sub_1DC356680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_uint *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  sub_1DC314BD0(&a9);
  sub_1DC314B30(&a12);
  MEMORY[0x1E019CE90](v19, 0x10E1C405E447FC4);
  sub_1DC314BD0(&a13);
  sub_1DC314BD0(&a16);
  sub_1DC314BD0(&a19);
  _Unwind_Resume(a1);
}

void sub_1DC356720(void *a1, uint64_t a2, int a3)
{
  if (a3 == 1)
  {
    *a1 = 0;
    if (a2) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 8), 1u, memory_order_relaxed);
    }
    *a1 = a2;
  }
  else
  {
    if (a3) {
      operator new();
    }
    uint64_t v4 = *(void *)(a2 + 16);
    sub_1DC355270(v4);
    uint64_t v5 = *(void *)(v4 + 64);
    if (v5) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
    }
    *a1 = v5;
  }
}

void sub_1DC3568F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_uint *a12, uint64_t a13)
{
  sub_1DC314BD0(&a9);
  sub_1DC314B30(&a12);
  MEMORY[0x1E019CE90](v13, 0x10E1C405E447FC4);
  sub_1DC314BD0(&a13);
  _Unwind_Resume(a1);
}

void sub_1DC356968()
{
}

void sub_1DC35794C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, atomic_uint *a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,atomic_uint *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,atomic_uint *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,atomic_uint *a37)
{
  sub_1DC314BD0((void *)(v37 - 112));
  sub_1DC3551D0(&a18);
  *(void *)(v37 - 112) = &a21;
  sub_1DC357D24((void ***)(v37 - 112));
  sub_1DC3551D0(&a24);
  sub_1DC3551D0(&a29);
  sub_1DC314BD0(&a30);
  sub_1DC3551D0(&a37);
  _Unwind_Resume(a1);
}

void sub_1DC357D24(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (atomic_uint **)**a1;
  if (v2)
  {
    uint64_t v4 = (atomic_uint **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        uint64_t v4 = sub_1DC3551D0(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DC357DA8(std::exception *a1)
{
  sub_1DC379B0C(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC357DE4(void *a1, char *a2)
{
  uint64_t result = sub_1DC379B70(a1, a2);
  *uint64_t result = &unk_1F36612D0;
  return result;
}

void MRCSegmentationMaskGetEstimatedRegionOfInterest(uint64_t *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94C38 != -1) {
      dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
    }
    if (v2 != qword_1EAA94C40) {
      _os_assumes_log();
    }
  }
  sub_1DC32C6AC(cf + 2);
}

BOOL MRCSegmentationMaskWritePGMToFile(const void *a1, const __CFURL *a2)
{
  BOOL v2 = 0;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    uint64_t Data = MRCSegmentationMaskGetData(a1);
    uint64_t DataType = MRCSegmentationMaskGetDataType(a1);
    uint64_t Width = MRCSegmentationMaskGetWidth(a1);
    uint64_t Height = MRCSegmentationMaskGetHeight(a1);
    uint64_t BytesPerRow = MRCSegmentationMaskGetBytesPerRow(a1);
    if (DataType == 1 && (uint64_t v9 = BytesPerRow, CFURLGetFileSystemRepresentation(a2, 1u, buffer, 1024)))
    {
      sub_1DC358390(&v25);
      if ((v26[*(void *)(v25 - 24) + 24] & 5) != 0)
      {
        BOOL v2 = 0;
      }
      else
      {
        sub_1DC31FC84(&v25, (uint64_t)"P2", 2);
        std::ios_base::getloc((const std::ios_base *)&v26[*(void *)(v25 - 24) - 8]);
        uint64_t v10 = std::locale::use_facet(&v24, MEMORY[0x1E4FBA258]);
        ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
        std::locale::~locale(&v24);
        std::ostream::put();
        std::ostream::flush();
        uint64_t v11 = (void *)std::ostream::operator<<();
        sub_1DC31FC84(v11, (uint64_t)" ", 1);
        BOOL v12 = (void *)std::ostream::operator<<();
        std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
        uint64_t v13 = std::locale::use_facet(&v24, MEMORY[0x1E4FBA258]);
        ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
        std::locale::~locale(&v24);
        std::ostream::put();
        std::ostream::flush();
        uint64_t v14 = (void *)std::ostream::operator<<();
        std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
        uint64_t v15 = std::locale::use_facet(&v24, MEMORY[0x1E4FBA258]);
        ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
        std::locale::~locale(&v24);
        std::ostream::put();
        std::ostream::flush();
        if (Height)
        {
          uint64_t v16 = 0;
          float v17 = (std::locale::id *)MEMORY[0x1E4FBA258];
          do
          {
            uint64_t v18 = Data;
            for (uint64_t i = Width; i; --i)
            {
              uint64_t v20 = (void *)std::ostream::operator<<();
              sub_1DC31FC84(v20, (uint64_t)" ", 1);
              v18 += 4;
            }
            std::ios_base::getloc((const std::ios_base *)&v26[*(void *)(v25 - 24) - 8]);
            float v21 = std::locale::use_facet(&v24, v17);
            ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
            std::locale::~locale(&v24);
            std::ostream::put();
            std::ostream::flush();
            ++v16;
            Data += v9;
          }
          while (v16 != Height);
        }
        BOOL v2 = (v26[*(void *)(v25 - 24) + 24] & 5) == 0;
      }
      uint64_t v25 = *MEMORY[0x1E4FBA400];
      *(void *)&v26[*(void *)(v25 - 24) - 8] = *(void *)(MEMORY[0x1E4FBA400] + 24);
      MEMORY[0x1E019CC10](v26);
      std::ostream::~ostream();
      MEMORY[0x1E019CE10](&v27);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void sub_1DC358350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::locale a11, uint64_t a12)
{
}

uint64_t *sub_1DC358390(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA468] + 64;
  a1[52] = MEMORY[0x1E4FBA468] + 64;
  uint64_t v3 = a1 + 1;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA400] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA400] + 8);
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = v4;
  uint64_t v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 1);
  uint64_t v7 = MEMORY[0x1E4FBA468] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  a1[52] = v2;
  MEMORY[0x1E019CC00](v3);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_1DC358514(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1E019CE10](v1);
  _Unwind_Resume(a1);
}

void *sub_1DC35854C(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA400];
  uint64_t v3 = *MEMORY[0x1E4FBA400];
  *a1 = *MEMORY[0x1E4FBA400];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x1E019CC10](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x1E019CE10](a1 + 52);
  return a1;
}

CGImageRef MRCSegmentationMaskCreateJetColorMapImage(const void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t Data = MRCSegmentationMaskGetData(a1);
  uint64_t DataType = MRCSegmentationMaskGetDataType(a1);
  size_t Width = MRCSegmentationMaskGetWidth(a1);
  size_t Height = MRCSegmentationMaskGetHeight(a1);
  uint64_t BytesPerRow = MRCSegmentationMaskGetBytesPerRow(a1);
  if (DataType != 1) {
    return 0;
  }
  uint64_t v7 = BytesPerRow;
  size_t v8 = (4 * (Width & 0x7FFFFFFFFFFFFFFLL) + 15) & 0x3FFFFFFFFFFFFFF0;
  uint64_t v9 = (const UInt8 *)malloc_type_malloc(v8 * Height, 0x40AAB4DCuLL);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = sub_1DC3587B0;
  block[3] = &unk_1E6C3A530;
  void block[4] = Data;
  block[5] = v7;
  block[6] = v9;
  block[7] = v8;
  block[8] = Width;
  dispatch_apply(Height, 0, block);
  CFDataRef v10 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9, v8 * Height, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
  uint64_t v11 = CGDataProviderCreateWithCFData(v10);
  CFRelease(v10);
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CGImageRef v13 = CGImageCreate(Width, Height, 8uLL, 0x20uLL, v8, DeviceRGB, 0x2002u, v11, 0, 0, kCGRenderingIntentDefault);
  CGColorSpaceRelease(DeviceRGB);
  CGDataProviderRelease(v11);
  return v13;
}

void *sub_1DC3587B0(void *result, uint64_t a2)
{
  if (result[8])
  {
    unint64_t v2 = 0;
    uint64_t v3 = result[4] + result[5] * a2;
    uint64_t v4 = result[6] + result[7] * a2;
    do
    {
      float v5 = *(float *)(v3 + 4 * v2);
      *(unsigned char *)(v4 + 4 * v2 + 3) = -1;
      double v6 = v5;
      unint64_t v7 = 5;
      size_t v8 = (double *)&unk_1DC40ADC8;
      do
      {
        unint64_t v9 = v7 >> 1;
        CFDataRef v10 = &v8[3 * (v7 >> 1)];
        double v12 = *v10;
        uint64_t v11 = v10 + 3;
        v7 += ~(v7 >> 1);
        if (v12 > v6) {
          unint64_t v7 = v9;
        }
        else {
          size_t v8 = v11;
        }
      }
      while (v7);
      if (v8 == (double *)&unk_1DC40ADC8)
      {
        LOBYTE(v13) = 0;
      }
      else if (v8 == (double *)&unk_1DC40AE40)
      {
        LOBYTE(v13) = 127;
      }
      else
      {
        int v13 = (int)((*(v8 - 1) + (v8[1] - *(v8 - 1)) * ((v6 - *(v8 - 3)) / (*v8 - *(v8 - 3)))) * 255.0);
      }
      unint64_t v14 = 6;
      uint64_t v15 = (double *)&unk_1DC40AE40;
      do
      {
        unint64_t v16 = v14 >> 1;
        float v17 = &v15[3 * (v14 >> 1)];
        double v19 = *v17;
        uint64_t v18 = v17 + 3;
        v14 += ~(v14 >> 1);
        if (v19 > v6) {
          unint64_t v14 = v16;
        }
        else {
          uint64_t v15 = v18;
        }
      }
      while (v14);
      if (v15 == (double *)&unk_1DC40AE40 || v15 == (double *)&unk_1DC40AED0) {
        LOBYTE(v21) = 0;
      }
      else {
        int v21 = (int)((*(v15 - 1) + (v15[1] - *(v15 - 1)) * ((v6 - *(v15 - 3)) / (*v15 - *(v15 - 3)))) * 255.0);
      }
      unint64_t v22 = 5;
      uint64_t v23 = (double *)&unk_1DC40AED0;
      do
      {
        unint64_t v24 = v22 >> 1;
        uint64_t v25 = &v23[3 * (v22 >> 1)];
        double v27 = *v25;
        float v26 = v25 + 3;
        v22 += ~(v22 >> 1);
        if (v27 > v6) {
          unint64_t v22 = v24;
        }
        else {
          uint64_t v23 = v26;
        }
      }
      while (v22);
      if (v23 == (double *)&unk_1DC40AED0)
      {
        LOBYTE(v28) = 127;
      }
      else if (v23 == (double *)"N5zxing6StringE")
      {
        LOBYTE(v28) = 0;
      }
      else
      {
        int v28 = (int)((*(v23 - 1) + (v23[1] - *(v23 - 1)) * ((v6 - *(v23 - 3)) / (*v23 - *(v23 - 3)))) * 255.0);
      }
      *(unsigned char *)(v4 + ((4 * v2) | 2)) = v13;
      *(unsigned char *)(v4 + ((4 * v2) | 1)) = v21;
      *(unsigned char *)(v4 + 4 * v2++) = v28;
    }
    while (v2 < result[8]);
  }
  return result;
}

void sub_1DC3589B8(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661638;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC358A28(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661638;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

float sub_1DC358A78(float *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v4 = v3 - *a2;
  if (v3 != *a2)
  {
    unint64_t v5 = 0;
    unint64_t v6 = v4 >> 2;
    do
    {
      unint64_t v7 = (float *)(v2 + 4 * v5);
      float v8 = *v7;
      float v9 = v7[1];
      float *v7 = (float)((float)((float)((float)(a1[3] + (float)(a1[4] * *v7)) + (float)(a1[5] * v9))
                          + (float)((float)(*v7 * a1[6]) * *v7))
                  + (float)((float)(*v7 * a1[7]) * v9))
          + (float)((float)(v9 * a1[8]) * v9);
      float result = (float)((float)((float)((float)(a1[9] + (float)(a1[10] * v8)) + (float)(a1[11] * v9))
                             + (float)((float)(v8 * a1[12]) * v8))
                     + (float)((float)(v8 * a1[13]) * v9))
             + (float)((float)(v9 * a1[14]) * v9);
      v7[1] = result;
      v5 += 2;
    }
    while (v6 > v5);
  }
  return result;
}

void sub_1DC358B04()
{
}

uint64_t sub_1DC358B1C(uint64_t a1, void *a2, void *a3)
{
  if (*a2 != a2[1] || *a3 != a3[1])
  {
    if (a1) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), 1u, memory_order_relaxed);
    }
    uint64_t v4 = a1;
    sub_1DC358B8C();
  }
  return 1;
}

void sub_1DC358B8C()
{
}

void sub_1DC358ED8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1DC2FFA58(a1);
}

atomic_uint **sub_1DC358EE4(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC358F18(uint64_t a1@<X0>, void *a2@<X8>)
{
  v20[4] = *(atomic_uint **)MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 144);
  if (v3) {
    goto LABEL_11;
  }
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  _DWORD v14[2] = sub_1DC359200;
  void v14[3] = &unk_1E6C3A550;
  void v14[4] = a1;
  uint64_t v15 = v14;
  v17[0] = &unk_1F3661E38;
  v17[1] = &v15;
  void v17[3] = v17;
  if (*(unsigned char *)(a1 + 136))
  {
    uint64_t v5 = *(void *)(a1 + 128);
    sub_1DC35937C((uint64_t)v20, (uint64_t)v17);
    sub_1DC359414(v5, v20);
    sub_1DC359974(v20);
  }
  else
  {
    unint64_t v6 = (void *)MEMORY[0x1E019D500]();
    uint64_t v18 = @"_MRCContextOptionIsOneShot";
    uint64_t v19 = MEMORY[0x1E4F1CC38];
    float v8 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E4F1C9E8], v7, (uint64_t)&v19, &v18, 1);
    unint64_t v16 = MRCContextCreateWithOptions(v8);
    unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire);
    if (explicit)
    {
      CFTypeID v10 = CFGetTypeID(explicit);
      if (qword_1EBFFB7E0 != -1)
      {
        CFTypeID v13 = v10;
        dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
        CFTypeID v10 = v13;
      }
      if (v10 != qword_1EBFFB818) {
        _os_assumes_log();
      }
    }
    sub_1DC35937C((uint64_t)v20, (uint64_t)v17);
    sub_1DC359414((uint64_t)explicit + 16, v20);
    sub_1DC359974(v20);
    sub_1DC3599F8((atomic_ullong *)&v16);
  }
  sub_1DC359974(v17);

  uint64_t v3 = *(void *)(a1 + 144);
  if (v3)
  {
LABEL_11:
    *a2 = 0;
LABEL_12:
    atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
    goto LABEL_13;
  }
  sub_1DC35B494((atomic_uint **)a1, v20);
  uint64_t v11 = v20[0];
  if (v20[0]) {
    atomic_fetch_add_explicit(v20[0] + 2, 1u, memory_order_relaxed);
  }
  double v12 = *(atomic_uint **)(a1 + 144);
  if (v12) {
    sub_1DC2FF57C(v12);
  }
  *(void *)(a1 + 144) = v11;
  sub_1DC2FF548(v20);
  uint64_t v3 = *(void *)(a1 + 144);
  *a2 = 0;
  if (v3) {
    goto LABEL_12;
  }
LABEL_13:
  *a2 = v3;
}

void sub_1DC359190(_Unwind_Exception *a1)
{
  sub_1DC2FF548((atomic_uint **)(v1 - 88));
  _Unwind_Resume(a1);
}

void sub_1DC359200(uint64_t a1, void *a2)
{
  if (objc_msgSend_newTextureByBinarizingPixelBuffer_error_(a2, (const char *)a2, *(void *)(*(void *)(a1 + 32) + 88), 0))
  {
    operator new();
  }
}

void sub_1DC35934C(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v2, 0x1091C409401DBA8);

  _Unwind_Resume(a1);
}

uint64_t sub_1DC35937C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1DC359414(uint64_t a1, void *a2)
{
  void v15[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2 + 3;
  if (!a2[3]) {
    return;
  }
  uint64_t v5 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock_with_options();
  unint64_t v6 = sub_1DC32E728((void *)(a1 + 24), (unint64_t)&unk_1DC40AF98);
  if (!v6) {
    operator new();
  }
  if ((_UNKNOWN *)v6[3] != &unk_1DC40AF98)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_26:
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  unint64_t v7 = (atomic_ullong *)v6[6];
  if (!v7) {
    goto LABEL_26;
  }
  atomic_ullong v9 = *v7;
  float v8 = (std::__shared_weak_count *)v7[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  if (!v9)
  {
    v15[0] = 0;
    sub_1DC390A40((uint64_t)v12, -1, 0);
    sub_1DC390CA0(context, v12);
    char v14 = 1;
    if (!*v2) {
      sub_1DC307C38();
    }
    (*(void (**)(void, atomic_ullong *, atomic_ullong *))(*(void *)*v2 + 48))(*v2, v15, context);
    if (v14) {
      sub_1DC390B00(context);
    }
    sub_1DC390B00(v12);
    sub_1DC31EB58(v15);
    if (v8) {
      goto LABEL_23;
    }
    return;
  }
  if (!*v2)
  {
    uint64_t v2 = &v11;
    goto LABEL_18;
  }
  if ((void *)*v2 != a2)
  {
    uint64_t v11 = (void *)*v2;
LABEL_18:
    void *v2 = 0;
    goto LABEL_20;
  }
  uint64_t v11 = v10;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v10);
LABEL_20:
  if (v11)
  {
    context[0] = (atomic_ullong)&unk_1F3661E90;
    context[1] = v9;
    void context[2] = (atomic_ullong)v10;
    context[3] = (atomic_ullong)context;
    dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v9 + 8), context, (dispatch_function_t)sub_1DC359ACC);
    sub_1DC307968(context);
  }
  sub_1DC359974(v10);
  if (v8) {
LABEL_23:
  }
    sub_1DC32EEF4(v8);
}

void sub_1DC359868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC359974(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

atomic_ullong *sub_1DC3599F8(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1DC359A2C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 192)) {
      sub_1DC390B00((atomic_ullong *)(result + 96));
    }
    sub_1DC31EB58((atomic_ullong *)(v1 + 88));
    sub_1DC31EB58((atomic_ullong *)(v1 + 40));
    sub_1DC31EB58((atomic_ullong *)(v1 + 32));
    uint64_t v2 = *(void *)(v1 + 8);
    *(void *)uint64_t v1 = &unk_1F3660C98;
    *(void *)(v1 + 8) = 0;
    if (v2) {
      (*(void (**)(void))(v1 + 16))();
    }
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

uint64_t sub_1DC359ACC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    sub_1DC307C38();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

void *sub_1DC359B1C()
{
  return &unk_1F36609E8;
}

uint64_t sub_1DC359B28(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN6quagga12_GLOBAL__N_127MetalHybridBinarizerContext7performENSt3__18functionIFvRKN3mrc5CFRefIPKvEEONS2_8optionalINS4_5ErrorEEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC359B64(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v2 + 192))
  {
    uint64_t v3 = *(void *)(a1 + 16);
    v43[0] = 0;
    sub_1DC390B4C((uint64_t)v44, v2 + 96);
    char v45 = 1;
    uint64_t v4 = *(void *)(v3 + 24);
    if (!v4) {
      sub_1DC307C38();
    }
    (*(void (**)(uint64_t, uint64_t *, id *))(*(void *)v4 + 48))(v4, v43, v44);
    if (v45) {
      sub_1DC390B00((atomic_ullong *)v44);
    }
    uint64_t v5 = v43;
    return (uint64_t)sub_1DC31EB58(v5);
  }
  unint64_t v7 = (atomic_ullong *)(v2 + 88);
  if (!atomic_load_explicit((atomic_ullong *volatile)(v2 + 88), memory_order_acquire))
  {
    float v8 = (void *)MEMORY[0x1E019D500]();
    sub_1DC3B5790((uint64_t *)v44, v2 + 24);
    id v9 = (id)atomic_load_explicit((atomic_ullong *volatile)v44, memory_order_acquire);
    sub_1DC31EB58((atomic_ullong *)v44);
    CFTypeID v10 = [_MRCMetalContext alloc];
    v44[0] = 0;
    double v12 = objc_msgSend_initWithDevice_libraryURL_error_(v10, v11, (uint64_t)v9, 0, v44);
    id v13 = v44[0];
    unint64_t v16 = v13;
    if (v12)
    {
      HIDWORD(v17) = *(_DWORD *)(v2 + 48) - 9;
      LODWORD(v17) = HIDWORD(v17);
      unsigned int v18 = (0x22u >> (v17 >> 2)) & 1;
      if ((v17 >> 2) <= 6 && v18 == 0)
      {
        uint64_t result = objc_msgSend_commandQueue(v12, v14, v15);
        int v21 = (void *)result;
        int v22 = *(_DWORD *)(v2 + 48) - 9;
        HIDWORD(v24) = v22;
        LODWORD(v24) = v22;
        unsigned int v23 = v24 >> 2;
        BOOL v25 = v23 > 6;
        int v26 = (1 << v23) & 0x5D;
        if (v25 || v26 == 0)
        {
          uint64_t result = qos_class_self();
          int v22 = result - 9;
        }
        HIDWORD(v28) = v22;
        LODWORD(v28) = v22;
        switch((v28 >> 2))
        {
          case 1u:
          case 5u:
            __break(1u);
            return result;
          case 3u:
            uint64_t v29 = 1;
            objc_msgSend_setGPUPriority_(v21, v20, 1);
            goto LABEL_25;
          case 4u:
          case 6u:
            uint64_t v29 = 4;
            objc_msgSend_setGPUPriority_(v21, v20, 4);
            goto LABEL_25;
          default:
            uint64_t v29 = 2;
            objc_msgSend_setGPUPriority_(v21, v20, 2);
LABEL_25:
            objc_msgSend_setBackgroundGPUPriority_(v21, v30, v29);

            break;
        }
      }
      float v32 = [_MRCMetalHybridBinarizer alloc];
      v46[0] = v16;
      double v34 = objc_msgSend_initWithMetalContext_error_(v32, v33, (uint64_t)v12, v46);
      id v31 = v46[0];

      id v35 = v34;
      v43[0] = (uint64_t)v35;
      int v36 = (const void *)atomic_exchange(v7, atomic_exchange(v43, 0));
      if (v36) {
        CFRelease(v36);
      }
      sub_1DC31EB58(v43);
    }
    else
    {
      id v31 = v13;
    }

    if (v31)
    {
      v44[0] = (id)CFRetain(v31);
      if (*(unsigned char *)(v2 + 192)) {
        sub_1DC390B00((atomic_ullong *)(v2 + 96));
      }
      *(_OWORD *)(v2 + 160) = 0u;
      *(_OWORD *)(v2 + 128) = 0u;
      *(_OWORD *)(v2 + 144) = 0u;
      *(_OWORD *)(v2 + 112) = 0u;
      *(void *)(v2 + 96) = -1;
      *(void *)(v2 + 104) = 0;
      *(_OWORD *)(v2 + 176) = 0u;
      *(unsigned char *)(v2 + 192) = 1;
      uint64_t v37 = (const void *)atomic_exchange((atomic_ullong *volatile)(v2 + 160), atomic_exchange((atomic_ullong *volatile)v44, 0));
      if (v37) {
        CFRelease(v37);
      }
      sub_1DC306854((atomic_ullong *)v44);
    }
  }
  unint64_t explicit = atomic_load_explicit(v7, memory_order_acquire);
  uint64_t v39 = *(void *)(a1 + 16);
  if (!explicit)
  {
    v46[0] = 0;
    int v41 = *(unsigned __int8 *)(v2 + 192);
    if (*(unsigned char *)(v2 + 192))
    {
      sub_1DC390B4C((uint64_t)v44, v2 + 96);
    }
    else
    {
      sub_1DC390A40((uint64_t)v43, -1, 0);
      sub_1DC390CA0(v44, v43);
    }
    char v45 = 1;
    uint64_t v42 = *(void *)(v39 + 24);
    if (!v42) {
      sub_1DC307C38();
    }
    (*(void (**)(uint64_t, id *, id *))(*(void *)v42 + 48))(v42, v46, v44);
    if (v45) {
      sub_1DC390B00((atomic_ullong *)v44);
    }
    if (!v41) {
      sub_1DC390B00(v43);
    }
    uint64_t v5 = (atomic_ullong *)v46;
    return (uint64_t)sub_1DC31EB58(v5);
  }
  LOBYTE(v44[0]) = 0;
  char v45 = 0;
  uint64_t v40 = *(void *)(v39 + 24);
  if (!v40) {
    sub_1DC307C38();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, id *))(*(void *)v40 + 48))(v40, v2 + 88, v44);
  if (v45) {
    return (uint64_t)sub_1DC390B00((atomic_ullong *)v44);
  }
  return result;
}

void sub_1DC359F4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 sub_1DC35A04C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3661E90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC35A074(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3661E90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC35A0C0()
{
}

void *sub_1DC35A0D8()
{
  return &unk_1F3660958;
}

uint64_t sub_1DC35A0E4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeIN6quagga12_GLOBAL__N_127MetalHybridBinarizerContextEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC35A120(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(*(void *)a2 + 8);
    if (v2) {
      sub_1DC32EEF4(v2);
    }
    JUMPOUT(0x1E019CE90);
  }
}

void sub_1DC35A188(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3661B78;
}

void *sub_1DC35A1A8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3661B78;
  return result;
}

void sub_1DC35A1E0()
{
}

uint64_t sub_1DC35A1FC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN6quagga12_GLOBAL__N_127MetalHybridBinarizerContextEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC35A238(uint64_t a1)
{
  return sub_1DC359A2C(*(void *)(a1 + 24));
}

void sub_1DC35A240(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC35A27C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 192)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 96));
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 88));
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660C98;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC35A314(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 192)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 96));
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 88));
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660C98;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void sub_1DC35A38C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660C98;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC35A3FC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660C98;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void *sub_1DC35A44C()
{
  return &unk_1F36609D8;
}

uint64_t sub_1DC35A458(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN6quagga12_GLOBAL__N_118performWithContextERKNSt3__18optionalINS1_17reference_wrapperIN3mrc7ContextEEEEEU13block_pointerFvP24_MRCMetalHybridBinarizerEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC35A494(uint64_t a1, atomic_ullong *a2)
{
  uint64_t v4 = (void *)MEMORY[0x1E019D500]();
  unint64_t explicit = atomic_load_explicit(a2, memory_order_acquire);
  uint64_t v6 = **(void **)(a1 + 8);
  if (explicit) {
    unint64_t v7 = atomic_load_explicit(a2, memory_order_acquire);
  }
  else {
    unint64_t v7 = 0;
  }
  (*(void (**)(uint64_t, unint64_t))(v6 + 16))(v6, v7);
}

uint64_t sub_1DC35A50C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3661E38;
  a2[1] = v2;
  return result;
}

void *sub_1DC35A530(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3661E38;
  result[1] = v3;
  return result;
}

void sub_1DC35A578()
{
}

void sub_1DC35A590(uint64_t a1)
{
  sub_1DC35A5C8(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC35A5C8(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661A40;
  CVPixelBufferRelease(*(CVPixelBufferRef *)(a1 + 88));
  sub_1DC2FF548((atomic_uint **)(a1 + 144));
  return sub_1DC35C7A8(a1);
}

atomic_ullong *sub_1DC35A630@<X0>(uint64_t a1@<X0>, CFErrorRef *a2@<X8>)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  LOBYTE(v4[0]) = 0;
  char v5 = 0;
  v6[0] = &unk_1F365F760;
  v6[1] = v4;
  v6[3] = v6;
  sub_1DC359414(a1, v6);
  __n128 result = sub_1DC359974(v6);
  if (v5)
  {
    __n128 result = sub_1DC390F7C(a2, (uint64_t)v4);
    if (v5) {
      return sub_1DC390B00(v4);
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_1DC35A6F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a21) {
    sub_1DC390B00(&a9);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC35A71C()
{
  return &unk_1F365EDA8;
}

uint64_t sub_1DC35A728(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN6quagga20MetalHybridBinarizer19preflightForContextERN3mrc7ContextEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC35A764(atomic_ullong *result, atomic_ullong *a2, uint64_t a3)
{
  if (!atomic_load_explicit(a2, memory_order_acquire)) {
    return sub_1DC3070F0((atomic_ullong *)result[1], a3);
  }
  return result;
}

uint64_t sub_1DC35A784(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365F760;
  a2[1] = v2;
  return result;
}

void *sub_1DC35A7A8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F365F760;
  result[1] = v3;
  return result;
}

void sub_1DC35A7F0()
{
}

std::string *sub_1DC35A808(std::string *a1, const std::string::value_type *a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = MEMORY[0x1E019D3A0]("UTF-8", a3);
  if (v6 == -1)
  {
    if (qword_1EAA94CD0 != -1) {
      dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
    }
    id v9 = qword_1EAA94CC8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR))
    {
      int v24 = *__error();
      *(_DWORD *)__leuint64_t n = 136446722;
      *(void *)&__len[4] = "UTF-8";
      __int16 v29 = 2082;
      uint64_t v30 = a3;
      __int16 v31 = 1026;
      int v32 = v24;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "[ZXing] iconv_open(\"%{public}s\", \"%{public}s\") failed: %{public, errno}d", __len, 0x1Cu);
    }
    int v10 = a2[23];
    if (v10 >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = *(const std::string::value_type **)a2;
    }
    if (v10 >= 0) {
      std::string::size_type v12 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      std::string::size_type v12 = *((void *)a2 + 1);
    }
    return std::string::append(a1, v11, v12);
  }
  else
  {
    uint64_t v7 = v6;
    if (a2[23] < 0) {
      uint64_t v8 = *((void *)a2 + 1);
    }
    else {
      uint64_t v8 = *((unsigned __int8 *)a2 + 23);
    }
    uint64_t v27 = v8;
    *(void *)__leuint64_t n = 4 * v8;
    char v14 = (std::string::value_type *)malloc_type_malloc((4 * v8) | 1, 0x5EBAF320uLL);
    uint64_t v15 = v14;
    if (a2[23] >= 0) {
      unint64_t v16 = a2;
    }
    else {
      unint64_t v16 = *(const std::string::value_type **)a2;
    }
    BOOL v25 = v16;
    __srCGFloat c = v14;
    if (v14) {
      BOOL v17 = v16 == 0;
    }
    else {
      BOOL v17 = 1;
    }
    if (!v17 && v8 != 0)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v19 = __src;
          uint64_t v20 = MEMORY[0x1E019D380](v7, &v25, &v27, &__src, __len);
          if ((unsigned char *)__src - v19 >= 1) {
            std::string::append(a1, v15, (unsigned char *)__src - v19);
          }
          if (v20 == -1) {
            break;
          }
          uint64_t v8 = v27;
          if (!v27) {
            goto LABEL_27;
          }
        }
        if (*__error() != 7)
        {
          if (qword_1EAA94CD0 != -1) {
            dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
          }
          int v22 = qword_1EAA94CC8;
          if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR)) {
            goto LABEL_44;
          }
          goto LABEL_27;
        }
        uint64_t v21 = v27;
        if (v8 == v27) {
          break;
        }
        memmove(v15, __src, *(size_t *)__len);
        __srCGFloat c = v15;
        uint64_t v8 = v21;
        if (!v21) {
          goto LABEL_27;
        }
      }
      if (qword_1EAA94CD0 != -1) {
        dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
      }
      int v22 = qword_1EAA94CC8;
      if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR))
      {
LABEL_44:
        int v23 = *__error();
        *(_DWORD *)long long buf = 67240192;
        int v34 = v23;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "[ZXing] iconv failed: %{public, errno}d", buf, 8u);
      }
    }
LABEL_27:
    free(v15);
    return (std::string *)MEMORY[0x1E019D390](v7);
  }
}

void sub_1DC35AB30()
{
}

void sub_1DC35ABBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3291B8((atomic_uint **)va);
  MEMORY[0x1E019CE90](v2, 0x10B1C4009E930FDLL);
  _Unwind_Resume(a1);
}

void sub_1DC35ABE8(void *a1, atomic_uint **a2)
{
  uint64_t v4 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  char v5 = v4;
  sub_1DC32914C((uint64_t)a1, (uint64_t *)&v5);
  sub_1DC3291B8(&v5);
  a1[3] = 0;
  *a1 = &unk_1F3661250;
  (*(void (**)(void))(*(void *)*a2 + 16))();
  (*(void (**)(void))(*(void *)*a2 + 24))();
  operator new[]();
}

void sub_1DC35ACF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3291B8((atomic_uint **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC35AD34@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(result + 24);
  if (!v3)
  {
    uint64_t v4 = *(atomic_uint **)(result + 16);
    if (v4) {
      atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    }
    char v5 = v4;
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
    (*(void (**)(atomic_uint *))(*(void *)v5 + 24))(v5);
    operator new();
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
  *a2 = v3;
  return result;
}

void sub_1DC35B24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_1DC2FF548((atomic_uint **)(v13 - 88));
  sub_1DC3291B8((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1DC35B298(uint64_t a1)
{
  sub_1DC35B2D0(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC35B2D0(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661250;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    MEMORY[0x1E019CE70](v2, 0x1000C8052888210);
  }
  sub_1DC2FF548((atomic_uint **)(a1 + 24));
  *(void *)a1 = &unk_1F3661968;
  sub_1DC3291B8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1DC35B35C()
{
}

void sub_1DC35B3E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3291B8((atomic_uint **)va);
  MEMORY[0x1E019CE90](v2, 0x10A1C40D086140DLL);
  _Unwind_Resume(a1);
}

void *sub_1DC35B410(void *a1, atomic_uint *a2)
{
  if (a2) {
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v4 = a2;
  sub_1DC350670((uint64_t)a1, a2);
  sub_1DC3291B8(&v4);
  *a1 = &unk_1F3660BF0;
  a1[10] = 0;
  return a1;
}

void sub_1DC35B480(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3291B8((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC35B494@<X0>(atomic_uint **result@<X0>, atomic_uint **a2@<X8>)
{
  uint64_t v3 = result[10];
  if (v3)
  {
    atomic_fetch_add_explicit(v3 + 2, 1u, memory_order_relaxed);
    *a2 = v3;
  }
  else
  {
    uint64_t v4 = result;
    char v5 = result[2];
    if (v5) {
      atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
    }
    unint64_t v16 = v5;
    char v6 = (*(uint64_t (**)(atomic_uint *))(*(void *)v5 + 48))(v5);
    unsigned int v7 = (*(uint64_t (**)(atomic_uint *))(*(void *)v16 + 16))(v16);
    unsigned int v8 = (*(uint64_t (**)(atomic_uint *))(*(void *)v16 + 24))(v16);
    char v9 = (*(uint64_t (**)(atomic_uint *))(*(void *)v16 + 32))(v16);
    *a2 = 0;
    if ((v9 & 7) == 0 && (v6 & 7) == 0 && v7 >= 0x18 && v8 > 0x17) {
      operator new();
    }
    sub_1DC35070C(v4, &v15);
    uint64_t v13 = v15;
    if (v15)
    {
      atomic_fetch_add_explicit(v15 + 2, 1u, memory_order_relaxed);
      *a2 = v13;
      sub_1DC2FF548(&v15);
      atomic_fetch_add_explicit(v13 + 2, 1u, memory_order_relaxed);
    }
    else
    {
      *a2 = 0;
      sub_1DC2FF548(&v15);
    }
    char v14 = v4[10];
    if (v14) {
      sub_1DC2FF57C(v14);
    }
    v4[10] = v13;
    return sub_1DC3291B8(&v16);
  }
  return result;
}

void sub_1DC35C5BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, atomic_uint **a14)
{
  sub_1DC2FF548(a14);
  sub_1DC3291B8((atomic_uint **)(v14 - 96));
  _Unwind_Resume(a1);
}

void sub_1DC35C6A4(uint64_t a1)
{
  *(void *)a1 = &unk_1F3660BF0;
  sub_1DC2FF548((atomic_uint **)(a1 + 80));
  *(void *)a1 = &unk_1F36611B0;
  sub_1DC2FF548((atomic_uint **)(a1 + 48));
  sub_1DC34F524(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC35C730(uint64_t a1)
{
  *(void *)a1 = &unk_1F3660BF0;
  sub_1DC2FF548((atomic_uint **)(a1 + 80));
  *(void *)a1 = &unk_1F36611B0;
  sub_1DC2FF548((atomic_uint **)(a1 + 48));
  return sub_1DC34F524(a1);
}

uint64_t sub_1DC35C7A8(uint64_t a1)
{
  *(void *)a1 = &unk_1F3660BF0;
  sub_1DC2FF548((atomic_uint **)(a1 + 80));
  *(void *)a1 = &unk_1F36611B0;
  sub_1DC2FF548((atomic_uint **)(a1 + 48));
  return sub_1DC34F524(a1);
}

uint64_t sub_1DC35C820(uint64_t *a1, int a2, std::string *a3)
{
  v11[0] = a2;
  v11[1] = 0;
  memset(&v7, 0, sizeof(v7));
  sub_1DC35C908((uint64_t)v8, v11, a1, &v7);
  if ((v10 & 0x80u) == 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if ((v10 & 0x80u) == 0) {
    std::string::size_type v5 = v10;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a3, (const std::string::value_type *)v4, v5);
  if ((char)v10 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_1DC35C8B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1DC35C8A4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC35C908(uint64_t a1, int *a2, uint64_t *a3, std::string *this)
{
  while (1)
  {
    int v8 = *a2;
    int v7 = a2[1];
    switch(v7)
    {
      case 3:
        int v9 = v8 + 5;
        uint64_t v16 = *a3;
        int v17 = *((_DWORD *)a3 + 2) - *a3;
        if (v8 + 5 > v17) {
          goto LABEL_39;
        }
        int v18 = *a2;
        while (1)
        {
          int v19 = v17 - v18;
          int v20 = v17 - v18 >= 5 ? 5 : v17 - v18;
          if (v19 < 1) {
            break;
          }
          unsigned int v21 = 0;
          int v22 = (unsigned __int8 *)(v16 + v18);
          int v23 = v22;
          do
          {
            int v24 = *v23++;
            unsigned int v21 = (v24 != 0) | (2 * v21);
            --v20;
          }
          while (v20);
          if (v21 <= 0x19) {
            goto LABEL_29;
          }
          if (v21 == 31)
          {
LABEL_182:
            *a2 = v9;
            goto LABEL_184;
          }
          int v25 = v18 + 6;
          if (v18 + 6 > v17) {
            goto LABEL_39;
          }
          int v26 = 0;
          int v27 = v19 >= 6 ? 6 : v19;
          do
          {
            int v28 = v26;
            int v29 = *v22++;
            int v26 = (v29 != 0) | (2 * v26);
            --v27;
          }
          while (v27);
          if ((2 * v28 - 52) > 9) {
            goto LABEL_39;
          }
          std::string::value_type v30 = v26 - 4;
          *a2 = v25;
          if (v30 == 36) {
            goto LABEL_184;
          }
LABEL_30:
          std::string::push_back(this, v30);
          int v18 = *a2;
          int v9 = *a2 + 5;
          uint64_t v16 = *a3;
          int v17 = *((_DWORD *)a3 + 2) - *a3;
          if (v9 > v17) {
            goto LABEL_39;
          }
        }
        LOBYTE(v21) = 0;
LABEL_29:
        std::string::value_type v30 = v21 + 65;
        *a2 = v9;
        goto LABEL_30;
      case 2:
        int v31 = v8 + 5;
        uint64_t v32 = *a3;
        uint64_t v33 = a3[1];
        int v34 = v33 - *a3;
        int v35 = *a2;
        if (v8 + 5 <= v34)
        {
          while (1)
          {
            int v81 = v34 - v35;
            if (v34 - v35 >= 5) {
              int v82 = 5;
            }
            else {
              int v82 = v34 - v35;
            }
            if (v81 < 1) {
              goto LABEL_33;
            }
            int v83 = 0;
            uint64_t v84 = v35;
            int v85 = (unsigned __int8 *)(v32 + v35);
            uint64_t v86 = v35;
            int v87 = v82;
            do
            {
              int v83 = (*(unsigned char *)(v32 + v86++) != 0) | (2 * v83);
              --v87;
            }
            while (v87);
            if ((v83 - 5) >= 0xB)
            {
              if (v35 + 7 > v34) {
                goto LABEL_33;
              }
              int v88 = 0;
              int v89 = v81 >= 7 ? 7 : v34 - v35;
              uint64_t v90 = v35;
              do
              {
                int v91 = v88;
                int v88 = (*(unsigned char *)(v32 + v90++) != 0) | (2 * v88);
                --v89;
              }
              while (v89);
              if ((2 * v91 - 64) >= 0x34)
              {
                if (v35 + 8 > v34) {
                  goto LABEL_33;
                }
                int v92 = 0;
                int v93 = v81 >= 8 ? 8 : v34 - v35;
                do
                {
                  int v92 = (*(unsigned char *)(v32 + v84++) != 0) | (2 * v92);
                  --v93;
                }
                while (v93);
                if ((v92 - 232) > 0x14) {
                  goto LABEL_33;
                }
              }
            }
            int v94 = 0;
            int8x16_t v95 = (unsigned __int8 *)(v32 + v35);
            do
            {
              int v96 = *v95++;
              int v94 = (v96 != 0) | (2 * v94);
              --v82;
            }
            while (v82);
            if (v94 == 15) {
              break;
            }
            if ((v94 - 5) > 9)
            {
              int v98 = 0;
              if (v81 >= 7) {
                int v99 = 7;
              }
              else {
                int v99 = v81;
              }
              unint64_t v100 = (unsigned __int8 *)(v32 + v35);
              do
              {
                int v101 = v98;
                int v102 = *v100++;
                int v98 = (v102 != 0) | (2 * v98);
                --v99;
              }
              while (v99);
              if ((2 * v101 - 64) > 0x19)
              {
                if ((2 * v101 - 90) > 0x19)
                {
                  int v104 = 0;
                  if (v81 >= 8) {
                    int v81 = 8;
                  }
                  do
                  {
                    int v105 = *v85++;
                    int v104 = (v105 != 0) | (2 * v104);
                    --v81;
                  }
                  while (v81);
                  if ((v104 - 253) <= 0xFFFFFFEA)
                  {
                    exceptiouint64_t n = __cxa_allocate_exception(0x10uLL);
                    MEMORY[0x1E019CAC0](exception, "Decoding invalid ISO-IEC-646 value");
LABEL_214:
                    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
                  }
                  std::string::value_type v97 = asc_1DC423F95[v104 - 232];
                  int v103 = v35 + 8;
                }
                else
                {
                  int v103 = v35 + 7;
                  std::string::value_type v97 = v98 + 7;
                }
              }
              else
              {
                int v103 = v35 + 7;
                std::string::value_type v97 = v98 + 1;
              }
              *a2 = v103;
              if (v97 == 36) {
                goto LABEL_184;
              }
            }
            else
            {
              std::string::value_type v97 = v94 + 43;
              *a2 = v31;
            }
            std::string::push_back(this, v97);
            int v35 = *a2;
            int v31 = *a2 + 5;
            uint64_t v32 = *a3;
            uint64_t v33 = a3[1];
            int v34 = v33 - *a3;
            if (v31 > v34) {
              goto LABEL_33;
            }
          }
          *a2 = v31;
LABEL_184:
          std::string::push_back(this, 29);
          a2[1] = 0;
          int v63 = *a2;
          if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
            sub_1DC312750(&__dst, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = *this;
          }
          int v36 = (void *)__dst.__r_.__value_.__r.__words[0];
          char v37 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
LABEL_177:
          unsigned int v47 = -1;
          goto LABEL_178;
        }
LABEL_33:
        if (v35 + 3 <= v34)
        {
          uint64_t v107 = 0;
          uint64_t v15 = (v35 + 3);
          while (!*(unsigned char *)(v32 + v35 + v107))
          {
            if (++v107 == 3) {
              goto LABEL_175;
            }
          }
        }
        if (sub_1DC35D360(v32, v33, v35))
        {
          int v14 = *a2 + 5;
          if (v14 >= *((_DWORD *)a3 + 2) - *(_DWORD *)a3) {
            int v14 = *((_DWORD *)a3 + 2) - *(_DWORD *)a3;
          }
          HIDWORD(v15) = 1;
LABEL_38:
          LODWORD(v15) = v14;
LABEL_175:
          int v36 = 0;
          char v37 = 0;
          *(void *)a2 = v15;
          goto LABEL_176;
        }
LABEL_39:
        int v36 = 0;
        char v37 = 0;
LABEL_176:
        int v63 = 0x7FFFFFFF;
        goto LABEL_177;
      case 1:
        int v9 = v8 + 5;
        uint64_t v10 = *a3;
        uint64_t v11 = a3[1];
        int v12 = v11 - *a3;
        int v13 = *a2;
        if (v8 + 5 <= v12)
        {
          do
          {
            int v64 = v12 - v13;
            if (v12 - v13 >= 5) {
              int v65 = 5;
            }
            else {
              int v65 = v12 - v13;
            }
            if (v64 < 1) {
              break;
            }
            int v66 = 0;
            uint64_t v67 = v13;
            uint64_t v68 = (unsigned __int8 *)(v10 + v13);
            uint64_t v69 = v13;
            int v70 = v65;
            do
            {
              int v66 = (*(unsigned char *)(v10 + v69++) != 0) | (2 * v66);
              --v70;
            }
            while (v70);
            if ((v66 - 5) >= 0xB)
            {
              if (v13 + 6 > v12) {
                break;
              }
              int v71 = 0;
              int v72 = v64 >= 6 ? 6 : v12 - v13;
              do
              {
                int v71 = (*(unsigned char *)(v10 + v67++) != 0) | (2 * v71);
                --v72;
              }
              while (v72);
              if ((v71 - 16) > 0x2E) {
                break;
              }
            }
            int v73 = 0;
            int v74 = (unsigned __int8 *)(v10 + v13);
            do
            {
              int v75 = *v74++;
              int v73 = (v75 != 0) | (2 * v73);
              --v65;
            }
            while (v65);
            if (v73 == 15) {
              goto LABEL_182;
            }
            if ((v73 - 5) > 9)
            {
              int v77 = 0;
              if (v64 >= 6) {
                int v78 = 6;
              }
              else {
                int v78 = v64;
              }
              do
              {
                int v79 = v77;
                int v80 = *v68++;
                int v77 = (v80 != 0) | (2 * v77);
                --v78;
              }
              while (v78);
              if ((2 * v79 - 32) > 0x19)
              {
                if ((v77 - 63) <= 0xFFFFFFFA)
                {
                  exceptiouint64_t n = __cxa_allocate_exception(0x10uLL);
                  MEMORY[0x1E019CAC0](exception, "Decoding invalid alphanumeric value");
                  goto LABEL_214;
                }
                std::string::value_type v76 = asc_1DC423F6C[v77 - 58];
              }
              else
              {
                std::string::value_type v76 = v77 + 33;
              }
              *a2 = v13 + 6;
              if (v76 == 36) {
                goto LABEL_184;
              }
            }
            else
            {
              std::string::value_type v76 = v73 + 43;
              *a2 = v9;
            }
            std::string::push_back(this, v76);
            int v13 = *a2;
            int v9 = *a2 + 5;
            uint64_t v10 = *a3;
            uint64_t v11 = a3[1];
            int v12 = v11 - *a3;
          }
          while (v9 <= v12);
        }
        if (v13 + 3 <= v12)
        {
          uint64_t v106 = 0;
          uint64_t v15 = (v13 + 3);
          while (!*(unsigned char *)(v10 + v13 + v106))
          {
            if (++v106 == 3) {
              goto LABEL_175;
            }
          }
        }
        if (sub_1DC35D360(v10, v11, v13))
        {
          int v14 = *a2 + 5;
          if (v14 >= *((_DWORD *)a3 + 2) - *(_DWORD *)a3) {
            int v14 = *((_DWORD *)a3 + 2) - *(_DWORD *)a3;
          }
          HIDWORD(v15) = 2;
          goto LABEL_38;
        }
        goto LABEL_39;
    }
    for (int i = *a2; ; int i = *a2)
    {
      int v39 = i + 7;
      uint64_t v40 = *a3;
      int v41 = *((_DWORD *)a3 + 2) - *a3;
      if (i + 7 > v41) {
        break;
      }
      uint64_t v48 = 0;
      int v49 = (unsigned __int8 *)(v40 + i);
      while (!v49[v48])
      {
        if (++v48 == 4) {
          goto LABEL_88;
        }
      }
      if (v41 - i >= 7) {
        int v50 = 7;
      }
      else {
        int v50 = v41 - i;
      }
      if (v41 - i < 1)
      {
        int v53 = -8;
      }
      else
      {
        int v51 = 0;
        do
        {
          int v52 = *v49++;
          int v51 = (v52 != 0) | (2 * v51);
          --v50;
        }
        while (v50);
        int v53 = v51 - 8;
      }
      int v46 = v53 / 11;
      unsigned int v47 = v53 % 11;
      if ((v53 / 11) > 0xA || v47 > 0xA)
      {
LABEL_88:
        int v55 = *((_DWORD *)a3 + 2) - *a3;
        goto LABEL_89;
      }
LABEL_68:
      int v55 = *((_DWORD *)a3 + 2) - *a3;
      if (v39 == 0x7FFFFFFF) {
        goto LABEL_89;
      }
      *a2 = v39;
      if (v46 == 10)
      {
        std::string::push_back(this, 29);
        if (v47 == 10) {
          goto LABEL_193;
        }
        int v63 = *a2;
        if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
          sub_1DC312750(&__dst, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = *this;
        }
        int v36 = (void *)__dst.__r_.__value_.__r.__words[0];
        goto LABEL_197;
      }
      std::to_string(&__dst, v46);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_dst = &__dst;
      }
      else {
        p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      }
      std::string::append(this, (const std::string::value_type *)p_dst, size);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (v47 == 10) {
        goto LABEL_193;
      }
      std::to_string(&__dst, v47);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v58 = &__dst;
      }
      else {
        int v58 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v59 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v59 = __dst.__r_.__value_.__l.__size_;
      }
      std::string::append(this, (const std::string::value_type *)v58, v59);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    if (i + 4 > v41) {
      goto LABEL_88;
    }
    if (v41 - i >= 4) {
      int v42 = 4;
    }
    else {
      int v42 = v41 - i;
    }
    if (v41 - i <= 0) {
      goto LABEL_192;
    }
    int v43 = 0;
    int v44 = (unsigned __int8 *)(v40 + i);
    do
    {
      int v45 = *v44++;
      int v43 = (v45 != 0) | (2 * v43);
      --v42;
    }
    while (v42);
    if (v43)
    {
      int v46 = v43 - 1;
      if ((v43 - 1) > 0xA) {
        goto LABEL_88;
      }
      unsigned int v47 = 10;
      int v39 = *((_DWORD *)a3 + 2) - *a3;
      goto LABEL_68;
    }
    int v55 = 0x7FFFFFFF;
    if (v41 != 0x7FFFFFFF)
    {
LABEL_192:
      *a2 = v41;
      std::string::push_back(this, 29);
LABEL_193:
      std::string::push_back(this, 29);
      int v63 = *a2;
      if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
        sub_1DC312750(&__dst, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = *this;
      }
      int v36 = (void *)__dst.__r_.__value_.__r.__words[0];
      unsigned int v47 = -1;
LABEL_197:
      char v37 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      goto LABEL_178;
    }
LABEL_89:
    if (i < v55)
    {
      uint64_t v60 = 0;
      uint64_t v61 = v40 + i;
      while (!*(unsigned char *)(v61 + v60))
      {
        if (v60 <= 2)
        {
          int v62 = i + 1 + v60++;
          if (v62 < v55) {
            continue;
          }
        }
        int v36 = 0;
        char v37 = 0;
        *a2 = i + 4;
        a2[1] = 1;
        goto LABEL_96;
      }
    }
    int v36 = 0;
    char v37 = 0;
LABEL_96:
    unsigned int v47 = -1;
    int v63 = 0x7FFFFFFF;
LABEL_178:
    int v108 = *a2;
    if (v63 != 0x7FFFFFFF || v8 == v108) {
      break;
    }
    if (v37 < 0) {
      operator delete(v36);
    }
  }
  int v109 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if (v63 == 0x7FFFFFFF || (v47 & 0x80000000) != 0)
  {
    if (v109 < 0)
    {
      int v110 = v114;
      sub_1DC312750(v114, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
      unsigned int v47 = -1;
    }
    else
    {
      unsigned int v47 = -1;
      int v110 = v114;
LABEL_206:
      *(_OWORD *)int v110 = *(_OWORD *)&this->__r_.__value_.__l.__data_;
      *((void *)v110 + 2) = *((void *)&this->__r_.__value_.__l + 2);
    }
  }
  else
  {
    if ((v109 & 0x80000000) == 0)
    {
      int v110 = v115;
      goto LABEL_206;
    }
    int v110 = v115;
    sub_1DC312750(v115, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
  }
  *(_DWORD *)a1 = v108;
  long long v111 = *(_OWORD *)v110;
  *(void *)(a1 + 24) = *((void *)v110 + 2);
  *(_OWORD *)(a1 + 8) = v111;
  *((void *)v110 + 1) = 0;
  *((void *)v110 + 2) = 0;
  *(void *)int v110 = 0;
  *(_DWORD *)(a1 + 32) = v47;
  if (v37 < 0) {
    operator delete(v36);
  }
}

void sub_1DC35D31C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (v22 < 0) {
    operator delete(v23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC35D360(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3 = a2 - a1;
  if ((int)a2 - (int)a1 <= a3) {
    return 0;
  }
  uint64_t v4 = 0;
  unint64_t v5 = a3 + 2;
  do
  {
    if (a2 - a1 - a3 == v4) {
      break;
    }
    if (v4 == 2)
    {
      if (v3 <= v5) {
        goto LABEL_13;
      }
      if (!*(unsigned char *)(a1 + v5)) {
        return 0;
      }
    }
    else
    {
      if (v3 <= a3 + v4) {
LABEL_13:
      }
        sub_1DC351420();
      if (*(unsigned char *)(a1 + a3 + v4)) {
        return 0;
      }
    }
    ++v4;
  }
  while (v4 != 5);
  return 1;
}

uint64_t sub_1DC35D3E4(uint64_t *a1, int a2, std::string *a3)
{
  std::string::size_type v6 = 0;
  std::string::size_type size = 0;
  char v8 = 0;
  v25[1] = 0;
  memset(v24, 0, 7);
  do
  {
    v25[0] = a2;
    if (v8 < 0)
    {
      sub_1DC312750(&__p, (void *)v6, size);
    }
    else
    {
      __p.__r_.__value_.__r.__words[0] = v6;
      __p.__r_.__value_.__l.__size_ = size;
      LODWORD(__p.__r_.__value_.__r.__words[2]) = v24[0];
      *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v24 + 3);
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = v8;
    }
    sub_1DC35C908((uint64_t)&v20, v25, a1, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if ((v22 & 0x80u) == 0) {
      int v9 = v21;
    }
    else {
      int v9 = (void **)v21[0];
    }
    if ((v22 & 0x80u) == 0) {
      std::string::size_type v10 = v22;
    }
    else {
      std::string::size_type v10 = (std::string::size_type)v21[1];
    }
    std::string::append(a3, (const std::string::value_type *)v9, v10);
    if (__val < 0)
    {
      if (v8 < 0)
      {
        std::string::size_type size = 0;
        *(unsigned char *)std::string::size_type v6 = 0;
      }
      else
      {
        char v8 = 0;
        v6 &= 0xFFFFFFFFFFFFFF00;
      }
    }
    else
    {
      std::to_string(&v18, __val);
      if (v8 < 0) {
        operator delete((void *)v6);
      }
      std::string::size_type size = v18.__r_.__value_.__l.__size_;
      std::string::size_type v6 = v18.__r_.__value_.__r.__words[0];
      v24[0] = v18.__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v24 + 3) = *(_DWORD *)((char *)&v18.__r_.__value_.__r.__words[2] + 3);
      char v8 = HIBYTE(v18.__r_.__value_.__r.__words[2]);
    }
    int v11 = v20;
    if ((char)v22 < 0) {
      operator delete(v21[0]);
    }
    BOOL v12 = a2 == v11;
    a2 = v11;
  }
  while (!v12);
  while ((SHIBYTE(a3->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    uint64_t v13 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
    if (!*((unsigned char *)&a3->__r_.__value_.__s + 23) || *((unsigned char *)&a3[-1].__r_.__value_.__r.__words[2] + v13 + 7) != 29) {
      goto LABEL_32;
    }
    std::string::size_type v14 = v13 - 1;
    *((unsigned char *)&a3->__r_.__value_.__s + 23) = v13 - 1;
    uint64_t v15 = a3;
LABEL_31:
    v15->__r_.__value_.__s.__data_[v14] = 0;
  }
  std::string::size_type v16 = a3->__r_.__value_.__l.__size_;
  if (v16)
  {
    uint64_t v15 = (std::string *)a3->__r_.__value_.__r.__words[0];
    if (*(unsigned char *)(a3->__r_.__value_.__r.__words[0] + v16 - 1) == 29)
    {
      std::string::size_type v14 = v16 - 1;
      a3->__r_.__value_.__l.__size_ = v14;
      goto LABEL_31;
    }
  }
LABEL_32:
  if (v8 < 0) {
    operator delete((void *)v6);
  }
  return 0;
}

void sub_1DC35D5B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  operator delete(v25);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1DC35D598);
  }
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC35D624@<X0>(uint64_t a1@<X1>, atomic_uint ***a2@<X2>, atomic_uint **a3@<X8>)
{
  *a3 = 0;
  (*(void (**)(atomic_uint **__return_ptr))(**(void **)(*(void *)a1 + 16) + 16))(&v23);
  unint64_t v5 = *a2;
  std::string::size_type v6 = a2[1];
  if (*a2 != v6)
  {
    while (1)
    {
      int v7 = *v5;
      if (*v5) {
        atomic_fetch_add_explicit(v7 + 2, 1u, memory_order_relaxed);
      }
      unsigned __int8 v22 = v7;
      char v8 = v23;
      if (v23) {
        atomic_fetch_add_explicit(v23 + 2, 1u, memory_order_relaxed);
      }
      int v20 = v8;
      if (v7) {
        atomic_fetch_add_explicit(v7 + 2, 1u, memory_order_relaxed);
      }
      int v19 = v7;
      sub_1DC368FCC(&v21, (uint64_t *)&v20, (uint64_t)&v19, 0);
      int v9 = v21;
      if (v21) {
        break;
      }
      *a3 = 0;
      sub_1DC311C00(&v21);
      sub_1DC35D870(&v19);
      sub_1DC2FF548(&v20);
      sub_1DC35D870(&v22);
      if (++v5 == v6) {
        goto LABEL_10;
      }
    }
    atomic_fetch_add_explicit(v21 + 2, 1u, memory_order_relaxed);
    *a3 = v9;
    sub_1DC311C00(&v21);
    sub_1DC35D870(&v19);
    uint64_t v15 = &v20;
    goto LABEL_22;
  }
LABEL_10:
  int v11 = a2[3];
  std::string::size_type v10 = a2[4];
  if (v11 != v10)
  {
    while (1)
    {
      BOOL v12 = *v11;
      if (*v11) {
        atomic_fetch_add_explicit(v12 + 2, 1u, memory_order_relaxed);
      }
      unsigned __int8 v22 = v12;
      uint64_t v13 = v23;
      if (v23) {
        atomic_fetch_add_explicit(v23 + 2, 1u, memory_order_relaxed);
      }
      std::string v18 = v13;
      if (v12) {
        atomic_fetch_add_explicit(v12 + 2, 1u, memory_order_relaxed);
      }
      int v17 = v12;
      sub_1DC368FCC(&v21, (uint64_t *)&v18, (uint64_t)&v17, 1);
      std::string::size_type v14 = v21;
      if (v21) {
        break;
      }
      *a3 = 0;
      sub_1DC311C00(&v21);
      sub_1DC35D870(&v17);
      sub_1DC2FF548(&v18);
      sub_1DC35D870(&v22);
      if (++v11 == v10) {
        return sub_1DC2FF548(&v23);
      }
    }
    atomic_fetch_add_explicit(v21 + 2, 1u, memory_order_relaxed);
    *a3 = v14;
    sub_1DC311C00(&v21);
    sub_1DC35D870(&v17);
    uint64_t v15 = &v18;
LABEL_22:
    sub_1DC2FF548(v15);
    sub_1DC35D870(&v22);
  }
  return sub_1DC2FF548(&v23);
}

void sub_1DC35D820(_Unwind_Exception *a1)
{
  sub_1DC311C00(v1);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC35D870(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC35D8A4(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_1DC35D8AC()
{
}

void sub_1DC35D8C4(void *a1@<X8>)
{
  *a1 = 0;
}

const char *sub_1DC35D8D4()
{
  return "PixelTransferSession";
}

atomic_ullong *sub_1DC35D8E0@<X0>(uint64_t a1@<X0>, CFDictionaryRef *a2@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  LOBYTE(v14[0]) = 0;
  char v15 = 0;
  sub_1DC35DABC(&v13, a1, (CFStringRef)*MEMORY[0x1E4F45150], v14);
  if (v15
    || atomic_load_explicit(&v13, memory_order_acquire)
    && (CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(&v13, memory_order_acquire)), v4 != CFStringGetTypeID()))
  {
    *a2 = 0;
  }
  else
  {
    sub_1DC35DABC(&v12, a1, (CFStringRef)*MEMORY[0x1E4F45148], v14);
    if (v15
      || atomic_load_explicit(&v12, memory_order_acquire)
      && (CFTypeID v5 = CFGetTypeID((CFTypeRef)atomic_load_explicit(&v12, memory_order_acquire)), v5 != CFArrayGetTypeID()))
    {
      *a2 = 0;
    }
    else
    {
      *(_OWORD *)keys = xmmword_1E6C3A570;
      values = 0;
      unint64_t v17 = 0;
      std::string::size_type v6 = (void **)MEMORY[0x1E4F1D260];
      unint64_t v7 = atomic_load_explicit(&v13, memory_order_acquire);
      char v8 = *v6;
      if (v7) {
        int v9 = (void *)v7;
      }
      else {
        int v9 = v8;
      }
      unint64_t v10 = atomic_load_explicit(&v12, memory_order_acquire);
      if (!v10) {
        unint64_t v10 = (unint64_t)v8;
      }
      values = v9;
      unint64_t v17 = v10;
      *a2 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    sub_1DC31EB58(&v12);
  }
  __n128 result = sub_1DC31EB58(&v13);
  if (v15) {
    return sub_1DC390B00(v14);
  }
  return result;
}

void sub_1DC35DA78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, atomic_ullong a10, atomic_ullong a11, atomic_ullong a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a24) {
    sub_1DC390B00(&a12);
  }
  _Unwind_Resume(a1);
}

void sub_1DC35DABC(void *a1, uint64_t a2, CFStringRef propertyKey, atomic_ullong *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t propertyValueOut = 0;
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 24), memory_order_acquire);
  OSStatus v8 = VTSessionCopyProperty(explicit, propertyKey, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], &propertyValueOut);
  if (v8 == -12900)
  {
LABEL_9:
    uint64_t v10 = 0;
    goto LABEL_10;
  }
  int v9 = v8;
  if (v8)
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    int v11 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67240450;
      *(_DWORD *)&uint8_t buf[4] = v9;
      __int16 v16 = 2114;
      CFStringRef v17 = propertyKey;
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "VTSessionCopyProperty failed with status %{public}d, key=%{public}@", buf, 0x12u);
    }
    *(void *)long long buf = -2011;
    atomic_ullong v13 = @"VTSessionCopyProperty failed.";
    uint64_t v12 = sub_1DC306334(a4, (uint64_t *)buf, (CFTypeRef *)&v13);
    sub_1DC390E0C(v12, v9);
    goto LABEL_9;
  }
  uint64_t v10 = propertyValueOut;
LABEL_10:
  *a1 = v10;
}

uint64_t sub_1DC35DC24(uint64_t a1, atomic_ullong *a2, atomic_ullong *a3, uint64_t a4, uint64_t a5, atomic_ullong *a6, uint64_t a7)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire))
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    int v20 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v20, OS_LOG_TYPE_ERROR, "Invalid pixel transfer session.", buf, 2u);
    }
    *(void *)long long buf = -2004;
    int v24 = @"Invalid pixel transfer session.";
    sub_1DC306334(a6, (uint64_t *)buf, (CFTypeRef *)&v24);
    return 0;
  }
  if (!atomic_load_explicit(a2, memory_order_acquire) || !atomic_load_explicit(a3, memory_order_acquire))
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    uint64_t v19 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v19, OS_LOG_TYPE_ERROR, "Invalid source and/or destination buffer.", buf, 2u);
    }
    *(void *)long long buf = -2004;
    int v24 = @"Invalid source and/or destination buffer.";
    sub_1DC306334(a6, (uint64_t *)buf, (CFTypeRef *)&v24);
    return 0;
  }
  v27[0] = &unk_1F36648E8;
  v27[1] = a1;
  int v28 = v27;
  *(void *)long long buf = a7;
  v26[0] = &unk_1F3664968;
  v26[1] = a1;
  void v26[3] = v26;
  sub_1DC31AD78((uint64_t)v30, (uint64_t)v26);
  if (*(unsigned char *)(*(void *)buf + 8)) {
    BOOL v13 = v28 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13) {
    sub_1DC31AE10((uint64_t)v28, **(void **)buf);
  }
  sub_1DC31AE60(v26);
  sub_1DC31AE60(v27);
  int v24 = 0;
  if (*(unsigned char *)(a4 + 32))
  {
    DictionaryRepresentatiouint64_t n = CGRectCreateDictionaryRepresentation(*(CGRect *)a4);
    std::string::size_type v14 = (const void *)atomic_exchange((atomic_ullong *volatile)&v24, atomic_exchange((atomic_ullong *volatile)&DictionaryRepresentation, 0));
    if (v14) {
      CFRelease(v14);
    }
    sub_1DC31EBFC((atomic_ullong *)&DictionaryRepresentation);
  }
  DictionaryRepresentatiouint64_t n = 0;
  if (*(unsigned char *)(a5 + 32))
  {
    *(void *)int v25 = CGRectCreateDictionaryRepresentation(*(CGRect *)a5);
    char v15 = (const void *)atomic_exchange((atomic_ullong *volatile)&DictionaryRepresentation, atomic_exchange((atomic_ullong *volatile)v25, 0));
    if (v15) {
      CFRelease(v15);
    }
    sub_1DC31EBFC((atomic_ullong *)v25);
  }
  if (!sub_1DC35E0C8(a1, (const __CFString *)*MEMORY[0x1E4F45170], (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire), a6)|| !sub_1DC35E0C8(a1, (const __CFString *)*MEMORY[0x1E4F450F0], (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&DictionaryRepresentation, memory_order_acquire), a6))
  {
    goto LABEL_25;
  }
  OSStatus v16 = VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire), (CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), (CVPixelBufferRef)atomic_load_explicit(a3, memory_order_acquire));
  if (v16)
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    CFStringRef v17 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v25 = 67240192;
      *(_DWORD *)&void v25[4] = v16;
      _os_log_error_impl(&dword_1DC2FE000, v17, OS_LOG_TYPE_ERROR, "VTPixelTransferSessionTransferImage failed: %{public}d", v25, 8u);
    }
    *(void *)int v25 = -2004;
    unsigned __int8 v22 = @"VTPixelTransferSessionTransferImage failed.";
    sub_1DC306334(a6, (uint64_t *)v25, (CFTypeRef *)&v22);
    sub_1DC390E0C((uint64_t)a6, v16);
LABEL_25:
    uint64_t v18 = 0;
    goto LABEL_26;
  }
  uint64_t v18 = 1;
LABEL_26:
  sub_1DC31EBFC((atomic_ullong *)&DictionaryRepresentation);
  sub_1DC31EBFC((atomic_ullong *)&v24);
  if (*(unsigned char *)(*(void *)buf + 8) && v31) {
    sub_1DC31AE10(v31, **(void **)buf);
  }
  sub_1DC31AE60(v30);
  return v18;
}

void sub_1DC35E03C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  atomic_ullong v4 = va_arg(va1, void);
  va_copy(va2, va1);
  atomic_ullong v6 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  sub_1DC31EBFC((atomic_ullong *)va);
  sub_1DC31EBFC((atomic_ullong *)va1);
  sub_1DC31AEE4((uint64_t **)va2);
  _Unwind_Resume(a1);
}

BOOL sub_1DC35E0C8(uint64_t a1, const __CFString *a2, __CFString *a3, atomic_ullong *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  OSStatus v7 = VTSessionSetProperty((VTSessionRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire), a2, a3);
  if (v7)
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    uint64_t v8 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = @"<null>";
      *(_DWORD *)long long buf = 67240706;
      if (a3) {
        uint64_t v11 = a3;
      }
      *(_DWORD *)&uint8_t buf[4] = v7;
      __int16 v14 = 2114;
      CFStringRef v15 = a2;
      __int16 v16 = 2114;
      uint64_t v17 = v11;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "VTSessionSetProperty failed with status %{public}d, key=%{public}@, value=%{public}@", buf, 0x1Cu);
    }
    uint64_t v12 = @"VTSessionSetProperty failed.";
    *(void *)long long buf = -2011;
    uint64_t v9 = sub_1DC306334(a4, (uint64_t *)buf, (CFTypeRef *)&v12);
    sub_1DC390E0C(v9, v7);
  }
  return v7 == 0;
}

void *sub_1DC35E214()
{
  return &unk_1F36649C8;
}

uint64_t sub_1DC35E220(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7imaging20PixelTransferSession13transferImageERKNS_5CFRefIP10__CVBufferEES7_RKNSt3__18optionalI6CGRectEESD_RNS9_INS_5ErrorEEERKNS9_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC35E25C(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (qword_1EAA94CA0 != -1) {
    dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v4 = qword_1EAA94C98;
    if (os_signpost_enabled((os_log_t)qword_1EAA94C98))
    {
      unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)(v3 + 16), memory_order_acquire);
      if (!explicit) {
        unint64_t explicit = @"<anonymous>";
      }
      int v6 = 138543362;
      OSStatus v7 = explicit;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_END, v2, "PixelTransferSession::transferImage", "name=%{public, signpost.description:attribute}@", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t sub_1DC35E364(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3664968;
  a2[1] = v2;
  return result;
}

void *sub_1DC35E388(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3664968;
  result[1] = v3;
  return result;
}

void sub_1DC35E3D0()
{
}

void *sub_1DC35E3E8()
{
  return &unk_1F3664948;
}

uint64_t sub_1DC35E3F4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7imaging20PixelTransferSession13transferImageERKNS_5CFRefIP10__CVBufferEES7_RKNSt3__18optionalI6CGRectEESD_RNS9_INS_5ErrorEEERKNS9_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC35E430(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (qword_1EAA94CA0 != -1) {
    dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v4 = qword_1EAA94C98;
    if (os_signpost_enabled((os_log_t)qword_1EAA94C98))
    {
      unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)(v3 + 16), memory_order_acquire);
      if (!explicit) {
        unint64_t explicit = @"<anonymous>";
      }
      int v6 = 138543362;
      OSStatus v7 = explicit;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelTransferSession::transferImage", "name=%{public, signpost.description:attribute}@", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t sub_1DC35E538(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F36648E8;
  a2[1] = v2;
  return result;
}

void *sub_1DC35E55C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F36648E8;
  result[1] = v3;
  return result;
}

void sub_1DC35E5A4()
{
}

void sub_1DC35E5BC(void *a1)
{
  sub_1DC35E5F4(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC35E5F4(void *a1)
{
  uint64_t v2 = a1 + 3;
  if (atomic_load_explicit(a1 + 3, memory_order_acquire)) {
    VTPixelTransferSessionInvalidate((VTPixelTransferSessionRef)atomic_load_explicit(v2, memory_order_acquire));
  }
  *a1 = &unk_1F3664878;
  sub_1DC32C8F4(v2);
  *a1 = &unk_1F3664760;
  sub_1DC31FA90(a1 + 2);
  return a1;
}

const char *sub_1DC35E684()
{
  return "PixelRotationSession";
}

atomic_ullong *sub_1DC35E690@<X0>(uint64_t a1@<X0>, CFDictionaryRef *a2@<X8>)
{
  propertyValueOut[1] = *(const void **)MEMORY[0x1E4F143B8];
  LOBYTE(v14[0]) = 0;
  char v15 = 0;
  CFStringRef v3 = (const __CFString *)*MEMORY[0x1E4F450B8];
  propertyValueOut[0] = 0;
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire);
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  OSStatus v6 = VTSessionCopyProperty(explicit, v3, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], propertyValueOut);
  int v7 = v6;
  if (v6 == -12900)
  {
LABEL_9:
    uint64_t v8 = 0;
    goto LABEL_10;
  }
  if (v6)
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    uint64_t v9 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      LODWORD(keys) = 67240450;
      HIDWORD(keys) = v7;
      __int16 v18 = 2114;
      CFStringRef v19 = v3;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "VTSessionCopyProperty failed with status %{public}d, key=%{public}@", (uint8_t *)&keys, 0x12u);
    }
    __int16 v16 = @"VTSessionCopyProperty failed.";
    keys = (void *)-2011;
    sub_1DC306334(v14, (uint64_t *)&keys, (CFTypeRef *)&v16);
    sub_1DC390E0C((uint64_t)v14, v7);
    goto LABEL_9;
  }
  uint64_t v8 = propertyValueOut[0];
LABEL_10:
  atomic_ullong v13 = (atomic_ullong)v8;
  if (v15
    || atomic_load_explicit(&v13, memory_order_acquire)
    && (CFTypeID v10 = CFGetTypeID((CFTypeRef)atomic_load_explicit(&v13, memory_order_acquire)), v10 != CFArrayGetTypeID()))
  {
    *a2 = 0;
  }
  else
  {
    keys = @"MostRecentChainDescription";
    propertyValueOut[0] = 0;
    uint64_t v11 = (const void *)atomic_load_explicit(&v13, memory_order_acquire);
    if (!v11) {
      uint64_t v11 = (const void *)*MEMORY[0x1E4F1D260];
    }
    propertyValueOut[0] = v11;
    *a2 = CFDictionaryCreate(v5, (const void **)&keys, propertyValueOut, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  __n128 result = sub_1DC31EB58(&v13);
  if (v15) {
    return sub_1DC390B00(v14);
  }
  return result;
}

void sub_1DC35E8A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, atomic_ullong a10, atomic_ullong a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a23) {
    sub_1DC390B00(&a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DC35E8D8(uint64_t a1, atomic_ullong *a2, atomic_ullong *a3, uint64_t a4, uint64_t a5, atomic_ullong *a6, uint64_t a7)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (!atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire))
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    CFStringRef v19 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v19, OS_LOG_TYPE_ERROR, "Invalid pixel rotation session.", buf, 2u);
    }
    *(void *)long long buf = -2004;
    *(void *)uint64_t v33 = @"Invalid pixel rotation session.";
    sub_1DC306334(a6, (uint64_t *)buf, (CFTypeRef *)v33);
    return 0;
  }
  if (!atomic_load_explicit(a2, memory_order_acquire) || !atomic_load_explicit(a3, memory_order_acquire))
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    __int16 v18 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v18, OS_LOG_TYPE_ERROR, "Invalid source and/or destination buffer.", buf, 2u);
    }
    *(void *)long long buf = -2004;
    *(void *)uint64_t v33 = @"Invalid source and/or destination buffer.";
    sub_1DC306334(a6, (uint64_t *)buf, (CFTypeRef *)v33);
    return 0;
  }
  v28[0] = &unk_1F36649E8;
  v28[1] = a1;
  int v29 = v28;
  *(void *)long long buf = a7;
  v27[0] = &unk_1F3664A68;
  v27[1] = a1;
  void v27[3] = v27;
  sub_1DC31AD78((uint64_t)v31, (uint64_t)v27);
  if (*(unsigned char *)(*(void *)buf + 8)) {
    BOOL v13 = v29 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13) {
    sub_1DC31AE10((uint64_t)v29, **(void **)buf);
  }
  sub_1DC31AE60(v27);
  sub_1DC31AE60(v28);
  int v14 = *(unsigned __int8 *)(a4 + 32);
  int v15 = *(unsigned __int8 *)(a5 + 32);
  unint64_t explicit = (OpaqueVTPixelRotationSession *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire);
  uint64_t v17 = (__CVBuffer *)atomic_load_explicit(a2, memory_order_acquire);
  if (v14 | v15)
  {
    if (!*(unsigned char *)(a4 + 32))
    {
      CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
      CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
    }
    atomic_load_explicit(a3, memory_order_acquire);
    if (!*(unsigned char *)(a5 + 32))
    {
      CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit(a3, memory_order_acquire));
      CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit(a3, memory_order_acquire));
    }
    int v23 = VTPixelRotationSessionRotateSubImage();
    if (v23)
    {
      if (qword_1EAA94CA0 != -1) {
        dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
      }
      int v24 = qword_1EAA94C98;
      if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v33 = 67240192;
        *(_DWORD *)&v33[4] = v23;
        _os_log_error_impl(&dword_1DC2FE000, v24, OS_LOG_TYPE_ERROR, "VTPixelRotationSessionRotateSubImage failed: %{public}d", v33, 8u);
      }
      *(void *)uint64_t v33 = -2004;
      int v26 = @"VTPixelRotationSessionRotateSubImage failed.";
      sub_1DC306334(a6, (uint64_t *)v33, (CFTypeRef *)&v26);
      sub_1DC390E0C((uint64_t)a6, v23);
LABEL_38:
      uint64_t v20 = 0;
      goto LABEL_40;
    }
  }
  else
  {
    OSStatus v21 = VTPixelRotationSessionRotateImage(explicit, v17, (CVPixelBufferRef)atomic_load_explicit(a3, memory_order_acquire));
    if (v21)
    {
      if (qword_1EAA94CA0 != -1) {
        dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
      }
      unsigned __int8 v22 = qword_1EAA94C98;
      if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v33 = 67240192;
        *(_DWORD *)&v33[4] = v21;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "VTPixelRotationSessionRotateImage failed: %{public}d", v33, 8u);
      }
      *(void *)uint64_t v33 = -2004;
      int v26 = @"VTPixelRotationSessionRotateImage failed.";
      sub_1DC306334(a6, (uint64_t *)v33, (CFTypeRef *)&v26);
      sub_1DC390E0C((uint64_t)a6, v21);
      goto LABEL_38;
    }
  }
  uint64_t v20 = 1;
LABEL_40:
  if (*(unsigned char *)(*(void *)buf + 8) && v32) {
    sub_1DC31AE10(v32, **(void **)buf);
  }
  sub_1DC31AE60(v31);
  return v20;
}

void sub_1DC35ED98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_1DC31AEE4((uint64_t **)va);
  _Unwind_Resume(a1);
}

void *sub_1DC35EDF8()
{
  return &unk_1F3664AC8;
}

uint64_t sub_1DC35EE04(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7imaging20PixelRotationSession11rotateImageERKNS_5CFRefIP10__CVBufferEES7_RKNSt3__18optionalI6CGRectEESD_RNS9_INS_5ErrorEEERKNS9_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC35EE40(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (qword_1EAA94CA0 != -1) {
    dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v4 = qword_1EAA94C98;
    if (os_signpost_enabled((os_log_t)qword_1EAA94C98))
    {
      unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)(v3 + 16), memory_order_acquire);
      if (!explicit) {
        unint64_t explicit = @"<anonymous>";
      }
      int v6 = 138543362;
      int v7 = explicit;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_END, v2, "PixelRotationSession::rotateImage", "name=%{public, signpost.description:attribute}@", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t sub_1DC35EF48(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3664A68;
  a2[1] = v2;
  return result;
}

void *sub_1DC35EF6C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3664A68;
  result[1] = v3;
  return result;
}

void sub_1DC35EFB4()
{
}

void *sub_1DC35EFCC()
{
  return &unk_1F3664A48;
}

uint64_t sub_1DC35EFD8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7imaging20PixelRotationSession11rotateImageERKNS_5CFRefIP10__CVBufferEES7_RKNSt3__18optionalI6CGRectEESD_RNS9_INS_5ErrorEEERKNS9_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC35F014(uint64_t a1, os_signpost_id_t *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (qword_1EAA94CA0 != -1) {
    dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    atomic_ullong v4 = qword_1EAA94C98;
    if (os_signpost_enabled((os_log_t)qword_1EAA94C98))
    {
      unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)(v3 + 16), memory_order_acquire);
      if (!explicit) {
        unint64_t explicit = @"<anonymous>";
      }
      int v6 = 138543362;
      int v7 = explicit;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v2, "PixelRotationSession::rotateImage", "name=%{public, signpost.description:attribute}@", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t sub_1DC35F11C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F36649E8;
  a2[1] = v2;
  return result;
}

void *sub_1DC35F140(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F36649E8;
  result[1] = v3;
  return result;
}

void sub_1DC35F188()
{
}

void sub_1DC35F1A0(void *a1)
{
  sub_1DC35F1D8(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC35F1D8(void *a1)
{
  uint64_t v2 = a1 + 3;
  if (atomic_load_explicit(a1 + 3, memory_order_acquire)) {
    VTPixelRotationSessionInvalidate((VTPixelRotationSessionRef)atomic_load_explicit(v2, memory_order_acquire));
  }
  *a1 = &unk_1F36648B0;
  sub_1DC35F25C(v2);
  *a1 = &unk_1F3664760;
  sub_1DC31FA90(a1 + 2);
  return a1;
}

atomic_ullong *sub_1DC35F25C(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1DC35F29C(uint64_t a1, int a2, atomic_ullong *a3)
{
  *(void *)a1 = &unk_1F3664760;
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DC32D8E8((atomic_ullong *)(a1 + 16), (CFTypeRef)atomic_load_explicit(a3, memory_order_acquire));
  return a1;
}

void sub_1DC35F300(_Unwind_Exception *a1)
{
  *uint64_t v1 = v2;
  sub_1DC31FA90(v3);
  _Unwind_Resume(a1);
}

void sub_1DC35F318(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v201 = *MEMORY[0x1E4F143B8];
  int v138 = 0;
  uint64_t v139 = 0;
  v136[1] = (atomic_uint *)&v137;
  v136[2] = (atomic_uint *)&v138;
  v136[3] = (atomic_uint *)&v139;
  uint64_t v137 = 0;
  (*(void (**)(atomic_uint **__return_ptr))(**(void **)(*(void *)a2 + 16) + 16))(v136);
  LODWORD(v162) = 0;
  uint64_t v161 = &unk_1F3661068;
  uint64_t v163 = 0;
  atomic_ullong v4 = v136[0];
  if (v136[0])
  {
    atomic_fetch_add_explicit(v136[0] + 2, 1u, memory_order_relaxed);
    if (v163) {
      sub_1DC2FF57C(v163);
    }
  }
  uint64_t v163 = v4;
  sub_1DC2FF548(v136);
  int v127 = *a3;
  CFAllocatorRef v5 = v163;
  uint64_t v6 = *((void *)v163 + 7);
  uint64_t v7 = -v6;
  uint64_t v8 = *((void *)v163 + 4);
  uint64_t v9 = v8 & -v6--;
  uint64_t v10 = *((void *)v163 + 2);
  char v145 = 0;
  uint64_t v146 = v10 & v6 | v9;
  uint64_t v147 = v8 & v6 | v10 & v7;
  CGFloat v148 = 0;
  atomic_fetch_add_explicit(v163 + 2, 1u, memory_order_relaxed);
  if (v148) {
    sub_1DC2FF57C(v148);
  }
  CGFloat v148 = v5;
  double v165 = 0;
  if (v127 < 0) {
    operator new();
  }
  uint64_t v11 = 0;
  for (uint64_t i = 0; i != 4; ++i)
  {
    sub_1DC3B9E54((uint64_t)&v175 + v11);
    v11 += 56;
  }
  uint64_t v14 = 0;
  long long v169 = xmmword_1DC3FDC50;
  uint64_t v172 = 0;
  uint64_t v170 = 0x3FF0000000000000;
  uint64_t v171 = 0;
  long long v173 = xmmword_1DC3FDC50;
  uint64_t v174 = 0x3FF0000000000000;
  __asm
  {
    FMOV            V1.2D, #8.0
    FMOV            V0.2D, #0.5
  }
  float64x2_t v124 = _Q0;
  float64x2_t v125 = _Q1;
  int32x2_t v20 = vdup_n_s32(0x7FC00000u);
  while (1)
  {
    float64x2_t v21 = (float64x2_t)*(&v169 + v14);
    unsigned __int8 v22 = (const double *)(v163 + 8);
    int v23 = (const double *)(v163 + 4);
    v13.i64[0] = *((void *)v163 + 7);
    v24.i64[0] = vnegq_s64(v13).u64[0];
    v25.i64[0] = -1;
    v25.i64[1] = -1;
    v24.i64[1] = vaddq_s64(vdupq_n_s64(*(void *)(v163 + 56)), v25).i64[1];
    int8x16_t v26 = (int8x16_t)vld1q_dup_f64(v23);
    int8x16_t v27 = (int8x16_t)vld1q_dup_f64(v22);
    int v140 = (unint64_t *)&v145;
    float64x2_t v28 = vcvtq_f64_u64(vshrq_n_u64((uint64x2_t)vorrq_s8(vandq_s8(v27, v24), vandq_s8(v26, vextq_s8(v24, v24, 8uLL))), 1uLL));
    float64x2_t v128 = vaddq_f64(vrndmq_f64(vaddq_f64(vmulq_f64(v21, v125), vsubq_f64(v28, vmulq_f64(v21, v28)))), v124);
    float64x2_t v141 = v128;
    uint64_t v143 = 1;
    float64x2_t v29 = vabsq_f64(v21);
    if (v29.f64[0] < v29.f64[1]) {
      v29.f64[0] = v29.f64[1];
    }
    float64x2_t v142 = vdivq_f64(v21, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v29.f64[0], 0));
    uint64_t v144 = 0;
    if (v127 < 0)
    {
      std::string::value_type v30 = v165;
      if (v165)
      {
        atomic_fetch_add_explicit(v165 + 2, 1u, memory_order_relaxed);
        uint64_t v31 = v30;
        if (v144)
        {
          sub_1DC2FF57C(v144);
          uint64_t v31 = v165;
        }
      }
      else
      {
        uint64_t v31 = 0;
      }
      uint64_t v144 = v30;
      uint64_t v32 = *((void *)v31 + 5);
      if (v32 >= 1) {
        bzero(*((void **)v31 + 6), 4 * (v32 - ((v32 & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
      }
    }
    uint64_t v126 = v14;
    int v33 = 1;
    do
    {
      int v34 = (8 * v33) & 0x7FFFFFF0;
      if (v33) {
        int v34 = -v34;
      }
      int8x16_t v35 = (int8x16_t)vmulq_n_f64(v142, (double)v34);
      float64x2_t v36 = (float64x2_t)vextq_s8(v35, v35, 8uLL);
      double v37 = vsubq_f64(v128, v36).f64[0];
      float64x2_t v38 = vaddq_f64(v128, v36);
      v39.f64[0] = v37;
      v39.f64[1] = v38.f64[1];
      float64x2_t v141 = v39;
      if (v37 < 0.0 || v37 >= (double)v140[1] || v38.f64[1] < 0.0 || v38.f64[1] >= (double)v140[2]) {
        break;
      }
      while (1)
      {
        float64x2_t v40 = v142;
        double v41 = v142.f64[0] + v141.f64[0];
        double v42 = v142.f64[1] + v141.f64[1];
        v141.f64[0] = v41;
        v141.f64[1] = v142.f64[1] + v141.f64[1];
        if (v41 < 0.0) {
          break;
        }
        int v43 = v140;
        double v44 = (double)v140[1];
        if (v41 >= v44) {
          break;
        }
        if (v42 < 0.0) {
          break;
        }
        double v45 = (double)v140[2];
        if (v42 >= v45) {
          break;
        }
        int v46 = (void *)v140[3];
        int v47 = sub_1DC2FF924(v46, (int)v41, (int)v42);
        int v48 = *(unsigned __int8 *)v43;
        double v49 = v41 - v40.f64[0];
        if (v41 - v40.f64[0] >= 0.0 && v49 < v44)
        {
          double v51 = v42 - v40.f64[1];
          BOOL v52 = v42 - v40.f64[1] >= 0.0 && v51 < v45;
          if (v52 && (v48 != sub_1DC2FF924(v46, (int)v49, (int)v51)) == (v48 != v47)) {
            continue;
          }
        }
        uint64_t v53 = 0;
        LODWORD(v143) = v48 == v47;
        HIDWORD(v143) = v48 != v47;
        double v160 = 0.0;
        double v159 = 0.0;
        double v132 = 0.0;
        double v133 = 0.0;
        double v129 = 0.0;
        double v130 = 0.0;
        double v167 = 0.0;
        double v166 = 0.0;
        do
        {
          int v54 = (int32x2_t *)((char *)&v175 + v53);
          v54[1] = *(int32x2_t *)((char *)&v175 + v53);
          v54[3] = 0;
          v54[4] = 0;
          v54[6].i32[0] = 2143289344;
          v54[5] = v20;
          v53 += 56;
        }
        while (v53 != 224);
        std::string __p = v43;
        float64x2_t v155 = v141;
        float64x2_t v156 = v142;
        LODWORD(v157) = v48 == v47;
        HIDWORD(v157) = v48 != v47;
        uint64_t v158 = 0;
        int v55 = v144;
        if (v144)
        {
          atomic_fetch_add_explicit(v144 + 2, 1u, memory_order_relaxed);
          if (v158) {
            sub_1DC2FF57C(v158);
          }
        }
        uint64_t v158 = v55;
        double v56 = v156.f64[0];
        double v57 = -v156.f64[1];
        v156.f64[0] = -v156.f64[1];
        v156.f64[1] = v56;
        if (sub_1DC3B9EA8((double *)&__p, (uint64_t)&v175, -v56, v57)
          && sub_1DC3B9FE0((uint64_t)&__p, (uint64_t)&v159, -v156.f64[1], v156.f64[0]))
        {
          if (v175 != v176)
          {
            int v58 = (_OWORD *)(v176 - 16);
            if (v176 - 16 > v175)
            {
              unint64_t v59 = v175 + 16;
              do
              {
                long long v60 = *(_OWORD *)(v59 - 16);
                *(_OWORD *)(v59 - 16) = *v58;
                *v58-- = v60;
                _CF = v59 >= (unint64_t)v58;
                v59 += 16;
              }
              while (!_CF);
            }
          }
          long long v149 = __p;
          float64x2_t v150 = v155;
          float64x2_t v151 = v156;
          uint64_t v152 = v157;
          long long v153 = 0;
          uint64_t v61 = v158;
          if (v158)
          {
            atomic_fetch_add_explicit(v158 + 2, 1u, memory_order_relaxed);
            if (v153) {
              sub_1DC2FF57C(v153);
            }
          }
          long long v153 = v61;
          std::string __p = v140;
          float64x2_t v155 = v141;
          float64x2_t v156 = v142;
          uint64_t v157 = v143;
          int v62 = v144;
          if (v144) {
            atomic_fetch_add_explicit(v144 + 2, 1u, memory_order_relaxed);
          }
          if (v158) {
            sub_1DC2FF57C(v158);
          }
          uint64_t v158 = v62;
          double v63 = fabs(v151.f64[1]);
          double v64 = fabs(v151.f64[0]);
          if (v63 < v64) {
            double v63 = v64;
          }
          v156.f64[0] = -v151.f64[1] / v63;
          v156.f64[1] = v151.f64[0] / v63;
          if (sub_1DC3B9EA8((double *)&__p, (uint64_t)&v175, v151.f64[0] / v63, -v156.f64[0]))
          {
            double v65 = v156.f64[1];
            double v66 = -v156.f64[0];
            if (sub_1DC3B9FE0((uint64_t)&__p, (uint64_t)&v132, v156.f64[1], -v156.f64[0])
              && sub_1DC3B9EA8((double *)&__p, (uint64_t)v180, v156.f64[1], -v156.f64[0]))
            {
              float64x2_t v67 = v156;
              if (sub_1DC3B9FE0((uint64_t)&__p, (uint64_t)&v129, v156.f64[1], -v156.f64[0]))
              {
                double v68 = v160;
                double v69 = sqrt((v160 - v133) * (v160 - v133) + (v159 - v132) * (v159 - v132)) + -1.0;
                double v70 = sqrt((v133 - v130) * (v133 - v130) + (v132 - v129) * (v132 - v129)) + -1.0;
                BOOL v71 = v69 < 8.0 || v70 < 10.0;
                BOOL v72 = v71 || v70 < v69 * 0.25;
                if (!v72 && v70 <= v69 * 8.0)
                {
                  double v120 = v129;
                  double v122 = v159;
                  double v118 = v130;
                  double v74 = fabs(v67.f64[0]);
                  double v75 = fabs(v67.f64[1]);
                  if (v74 < v75) {
                    double v74 = v75;
                  }
                  double v76 = v67.f64[0] / v74;
                  float64_t v77 = v67.f64[1] / v74;
                  v151.f64[0] = v67.f64[0] / v74;
                  v151.f64[1] = v67.f64[1] / v74;
                  sub_1DC3B9E54((uint64_t)&v193);
                  BOOL v78 = sub_1DC3BA17C((double *)&v149, (uint64_t)&v188, (int)(v70 / 5.0 + 1.0), (float *)&v193, -v77, v76);
                  if (v193 != 0.0)
                  {
                    double v194 = v193;
                    operator delete(*(void **)&v193);
                  }
                  if (v78)
                  {
                    if (v189[0] - (void)v188 < 0x11uLL) {
                      int v79 = 0;
                    }
                    else {
                      int v79 = (int)sqrt((v188[1] - *(double *)(v189[0] - 8)) * (v188[1] - *(double *)(v189[0] - 8))+ (*v188 - *(double *)(v189[0] - 16)) * (*v188 - *(double *)(v189[0] - 16)));
                    }
                    double v80 = -v65;
                    int v81 = v79 / 3;
                    if (v81 >= (int)(v69 / 5.0)) {
                      int v81 = (int)(v69 / 5.0);
                    }
                    int v82 = 2 * v81;
                    double v83 = fabs(v66);
                    double v84 = fabs(v80);
                    if (v83 < v84) {
                      double v83 = v84;
                    }
                    v156.f64[0] = v66 / v83;
                    v156.f64[1] = v80 / v83;
                    if (sub_1DC3BA17C((double *)&__p, (uint64_t)v184, 2 * v81, (float *)&v188, v80 / v83, -(v66 / v83))
                      && sub_1DC3B9FE0((uint64_t)&__p, (uint64_t)&v166, v156.f64[1], -v156.f64[0])
                      && vabdd_f64(sqrt((v68 - v167) * (v68 - v167) + (v122 - v166) * (v122 - v166)) + -1.0, v70) / v70 < 0.5
                      && vabdd_f64(sqrt((v167 - v118) * (v167 - v118) + (v166 - v120) * (v166 - v120)) + -1.0, v69)
                       / v69 < 0.5
                      && v189[0] - (void)v188 >= 0x41uLL
                      && v184[1] - v184[0] > 0x40uLL
                      && sub_1DC3BA17C((double *)&v149, (uint64_t)&v188, v82, (float *)v184, -v151.f64[1], v151.f64[0]))
                    {
                      uint64_t v85 = 0;
                      double v193 = COERCE_DOUBLE(&v175);
                      double v194 = COERCE_DOUBLE(v180);
                      double v195 = COERCE_DOUBLE(&v188);
                      uint64_t v196 = v184;
                      do
                      {
                        sub_1DC3BA544(*(void *)((char *)&v193 + v85), 0, 1.0);
                        v85 += 8;
                      }
                      while (v85 != 32);
                      float v86 = (float)(v181 * v178) - (float)(v182 * v177);
                      double v123 = (float)((float)((float)(v183 * v178) - (float)(v182 * v179)) / v86);
                      double v132 = v123;
                      double v133 = (float)((float)((float)(v181 * v179) - (float)(v183 * v177)) / v86);
                      double v119 = v133;
                      float v87 = (float)(v190 * v178) - (float)(v191 * v177);
                      double v88 = (float)((float)((float)(v190 * v179) - (float)(v192 * v177)) / v87);
                      double v159 = (float)((float)((float)(v192 * v178) - (float)(v191 * v179)) / v87);
                      double v160 = v88;
                      float v89 = (float)(v190 * v186) - (float)(v191 * v185);
                      double v90 = (float)((float)((float)(v192 * v186) - (float)(v191 * v187)) / v89);
                      double v91 = (float)((float)((float)(v190 * v187) - (float)(v192 * v185)) / v89);
                      double v166 = v90;
                      double v167 = v91;
                      float v92 = (float)(v181 * v186) - (float)(v182 * v185);
                      double v93 = (float)((float)((float)(v183 * v186) - (float)(v182 * v187)) / v92);
                      double v129 = v93;
                      double v130 = (float)((float)((float)(v181 * v187) - (float)(v183 * v185)) / v92);
                      double v94 = v130;
                      double v121 = v159;
                      double v95 = sub_1DC3BA748((uint64_t)&v188, v159, v88, v90, v91);
                      if (((*(void *)&v95 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF)
                      {
                        double v96 = sub_1DC3BA748((uint64_t)v184, v93, v94, v90, v91);
                        if (((*(void *)&v96 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 < 0x3FF)
                        {
                          unint64_t v97 = 0;
                          int v98 = (int)(v95 + 0.5);
                          double v99 = vabdd_f64(v95, (double)v98);
                          int v100 = (int)(v96 + 0.5);
                          double v101 = vabdd_f64(v96, (double)v100);
                          BOOL v102 = 1;
                          while (1)
                          {
                            int v103 = dword_1DC410400[v97];
                            unsigned int v104 = v98 - v103;
                            if (v98 - v103 < 0) {
                              unsigned int v104 = v103 - v98;
                            }
                            if (v104 <= 1)
                            {
                              int v105 = dword_1DC4103E8[v97];
                              unsigned int v106 = v100 - v105;
                              if (v100 - v105 < 0) {
                                unsigned int v106 = v105 - v100;
                              }
                              if (v106 < 2) {
                                break;
                              }
                            }
                            BOOL v102 = v97++ < 5;
                            if (v97 == 6) {
                              goto LABEL_113;
                            }
                          }
                          int v98 = dword_1DC410400[v97];
                          int v100 = dword_1DC4103E8[v97];
                          if (!v102)
                          {
LABEL_113:
                            unsigned int v107 = v98 - v100;
                            if (v98 - v100 < 0) {
                              unsigned int v107 = v100 - v98;
                            }
                            if (v101 >= v99) {
                              int v103 = v98;
                            }
                            else {
                              int v103 = v100;
                            }
                            if (v107 <= 5) {
                              int v105 = v103;
                            }
                            else {
                              int v105 = v100;
                            }
                            if (v107 > 5) {
                              int v103 = v98;
                            }
                          }
                          if ((v103 - 5) <= 0x43 && v105 >= 4 && v105 <= 72)
                          {
                            double v193 = sub_1DC3BAAC8(v121, v88, v90, v91, v123, v119, 0.5);
                            double v194 = *(double *)&v108;
                            double v195 = sub_1DC3BAAC8(v90, v91, v93, v94, v121, v88, 0.3);
                            uint64_t v196 = v109;
                            double v197 = sub_1DC3BAAC8(v93, v94, v123, v119, v90, v91, 0.5);
                            uint64_t v198 = v110;
                            double v199 = sub_1DC3BAAC8(v123, v119, v121, v88, v93, v94, 0.5);
                            uint64_t v200 = v111;
                            uint64_t v168 = 0;
                            sub_1DC3BAB34();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          sub_1DC2FF548(&v153);
        }
        sub_1DC2FF548(&v158);
      }
      uint64_t v164 = 0;
      sub_1DC36176C(&v164);
      ++v33;
    }
    while (v127 < 0);
    sub_1DC2FF548(&v144);
    uint64_t v14 = v126 + 1;
    if (v126 == 3)
    {
      uint64_t v164 = 0;
      uint64_t v112 = 0;
      while (1)
      {
        unsigned int v113 = (void *)v189[v112 - 1];
        if (v113)
        {
          v189[v112] = v113;
          operator delete(v113);
        }
        v112 -= 7;
        if (v112 == -28)
        {
          sub_1DC2FF548(&v165);
          sub_1DC2FF548(&v148);
          uint64_t v114 = v164;
          if (v164) {
            atomic_fetch_add_explicit(v164 + 2, 1u, memory_order_relaxed);
          }
          if (v138) {
            sub_1DC2FF57C(v138);
          }
          int v138 = v114;
          sub_1DC36176C(&v164);
          if (v138)
          {
            uint64_t v115 = *((void *)v138 + 8);
            if (v115) {
              atomic_fetch_add_explicit((atomic_uint *volatile)(v115 + 8), 1u, memory_order_relaxed);
            }
            uint64_t v135 = v115;
            sub_1DC362E10(&v175, &v135);
          }
          uint64_t v161 = &unk_1F3661068;
          sub_1DC2FF548(&v163);
          (*(void (**)(atomic_uint **__return_ptr))(**(void **)(*(void *)a2 + 16) + 16))(&v131);
          LODWORD(v133) = 0;
          double v132 = COERCE_DOUBLE(&unk_1F3661008);
          unint64_t v134 = 0;
          uint64_t v116 = v131;
          if (v131)
          {
            atomic_fetch_add_explicit(v131 + 2, 1u, memory_order_relaxed);
            if (v134) {
              sub_1DC2FF57C(v134);
            }
          }
          unint64_t v134 = v116;
          sub_1DC2FF548(&v131);
          sub_1DC366F34();
        }
      }
    }
  }
}

void sub_1DC361230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,atomic_uint **a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,atomic_uint *a46,atomic_uint *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,atomic_uint *a57,atomic_uint *a58,atomic_uint *a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1DC311C34((atomic_uint **)&STACK[0x2D0]);
  sub_1DC2FF548((atomic_uint **)&STACK[0x300]);
  sub_1DC30184C((atomic_uint **)(v71 - 240));
  *(void *)(v71 - 240) = &STACK[0x380];
  sub_1DC2FFC48((void ***)(v71 - 240));
  sub_1DC311C34((atomic_uint **)&a71);
  sub_1DC2FF548((atomic_uint **)&STACK[0x2C8]);
  STACK[0x380] = (unint64_t)&a67;
  sub_1DC2FFC48((void ***)&STACK[0x380]);
  sub_1DC311C00(&a47);
  STACK[0x380] = (unint64_t)&a43;
  sub_1DC2FFC48((void ***)&STACK[0x380]);
  sub_1DC2FF548(&a46);
  a49 = a42;
  sub_1DC2FF548(a41);
  sub_1DC311C34(&a57);
  sub_1DC36176C(&a58);
  sub_1DC311C00(&a59);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC36176C(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC3617A0(uint64_t a1, void **a2)
{
  int v2 = *(unsigned __int8 *)(*a2[1] + 12);
  *((_DWORD *)sub_1DC3116FC((uint64_t **)(**a2 + 96), 9, (unsigned int *)&unk_1DC421940) + 8) = v2;
  operator new();
}

void sub_1DC3618F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  *(void *)(v6 - 56) = va;
  sub_1DC2FFC48((void ***)(v6 - 56));
  sub_1DC311968((uint64_t *)va1);
  sub_1DC3119BC((atomic_uint **)(v6 - 64));
  MEMORY[0x1E019CE90](v5, 0x10A1C4006AAC113);
  _Unwind_Resume(a1);
}

void sub_1DC361970(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661008;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC3619D4(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661008;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1DC361A18(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661068;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC361A7C(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661068;
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_ullong *sub_1DC361AC0(atomic_ullong *a1, atomic_ullong *a2, atomic_ullong *a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    while (1)
    {
      unint64_t explicit = (const void *)atomic_load_explicit(a3, memory_order_acquire);
      uint64_t v7 = (const void *)atomic_load_explicit(v3, memory_order_acquire);
      if (v7 == explicit) {
        break;
      }
      BOOL v8 = !explicit || v7 == 0;
      if (!v8 && CFEqual(v7, explicit)) {
        break;
      }
      if (++v3 == a2) {
        return a2;
      }
    }
  }
  return v3;
}

void *sub_1DC361B30(void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    sub_1DC314E1C(a1, a3);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, a2, 4 * a3);
    a1[1] = &v6[4 * a3];
  }
  return a1;
}

void sub_1DC361B98(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1DC361BB4(char *result, char *__src, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *((void *)result + 2);
  uint64_t v7 = *(char **)result;
  if ((unint64_t)(v6 - *(void *)result) < 0x20)
  {
    if (v7)
    {
      *((void *)result + 1) = v7;
      operator delete(v7);
      uint64_t v6 = 0;
      *uint64_t v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
    }
    uint64_t v8 = v6 >> 1;
    if ((unint64_t)(v6 >> 1) <= 8) {
      uint64_t v8 = 8;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v9 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    __n128 result = sub_1DC314E1C(v5, v9);
    uint64_t v11 = (char *)v5[1];
    uint64_t v10 = (void **)(v5 + 1);
    uint64_t v7 = v11;
LABEL_15:
    size_t v15 = a3 - (void)__src;
    if (v15)
    {
      __int16 v16 = v7;
      uint64_t v17 = __src;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  uint64_t v10 = (void **)(result + 8);
  uint64_t v12 = (unsigned char *)*((void *)result + 1);
  size_t v13 = v12 - v7;
  if ((unint64_t)(v12 - v7) > 0x1F) {
    goto LABEL_15;
  }
  uint64_t v14 = &__src[v13];
  if (v12 != v7)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v13);
    uint64_t v7 = (char *)*v10;
  }
  size_t v15 = a3 - (void)v14;
  if (v15)
  {
    __int16 v16 = v7;
    uint64_t v17 = v14;
LABEL_17:
    __n128 result = (char *)memmove(v16, v17, v15);
  }
LABEL_18:
  *uint64_t v10 = &v7[v15];
  return result;
}

void sub_1DC361CAC(uint64_t a1, _DWORD *a2)
{
  uint64_t v5 = *(_DWORD **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = *(_DWORD **)a1;
    uint64_t v8 = ((uint64_t)v5 - *(void *)a1) >> 2;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 62) {
      sub_1DC2FF97C();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 1 > v9) {
      unint64_t v9 = v10 >> 1;
    }
    BOOL v11 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFFCLL;
    unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v9;
    }
    if (v12)
    {
      unint64_t v12 = (unint64_t)sub_1DC314E5C(v12);
      uint64_t v7 = *(_DWORD **)a1;
      uint64_t v5 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = (_DWORD *)(v12 + 4 * v8);
    unint64_t v15 = v12 + 4 * v13;
    _DWORD *v14 = *a2;
    uint64_t v6 = v14 + 1;
    while (v5 != v7)
    {
      int v16 = *--v5;
      *--uint64_t v14 = v16;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v6;
    *(void *)(a1 + 16) = v15;
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    *uint64_t v5 = *a2;
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a1 + 8) = v6;
}

void sub_1DC361D88()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1DC362060(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void **);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  *(void *)(v2 + 8) = v3;
  sub_1DC362228((void ***)va);
  sub_1DC31FA90((atomic_ullong *)va1);
  MEMORY[0x1E019CE90](v2, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC36218C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      CFTypeRef explicit = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + v6), memory_order_acquire);
      if (explicit) {
        CFTypeRef explicit = CFRetain(explicit);
      }
      *(void *)(a3 + v6) = explicit;
      v6 += 8;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_1DC362228(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (atomic_ullong *)**a1;
  if (v2)
  {
    unint64_t v4 = (atomic_ullong *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        unint64_t v4 = sub_1DC31FA90(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1DC3622AC()
{
  return &unk_1F3660A38;
}

uint64_t sub_1DC3622B8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder24postProcessForComposite_ERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3622F4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC270 != -1) {
    dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC278;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC278))
    {
      *(_WORD *)unint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "Decoder::postProcessForComposite_", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3623A0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3662048;
}

void *sub_1DC3623C0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3662048;
  return result;
}

void sub_1DC3623F8()
{
}

void *sub_1DC362410()
{
  return &unk_1F3660A28;
}

uint64_t sub_1DC36241C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder24postProcessForComposite_ERNS_13DecoderResultERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC362458(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC270 != -1) {
    dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC278;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC278))
    {
      *(_WORD *)unint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "Decoder::postProcessForComposite_", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC362504(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3661FF0;
}

void *sub_1DC362524()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3661FF0;
  return result;
}

void sub_1DC36255C()
{
}

void sub_1DC362574(atomic_uint **a1, atomic_uint *a2, _DWORD *a3)
{
  if (a2)
  {
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
    *a1 = a2;
    return;
  }
  int v4 = a3[14];
  int v5 = -v4;
  int v6 = a3[4];
  int v7 = v6 & -v4--;
  int v8 = a3[8];
  int v9 = v8 & v4 | v7;
  int v10 = v6 & v4 | v8 & v5;
  if ((v10 | v9))
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC3B430C(exception, "Number of rows and columns must be even");
LABEL_15:
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EAA94C30, memory_order_acquire) != -1)
  {
    int v16 = &v17;
    uint64_t v17 = sub_1DC371FF4;
    std::__call_once(&qword_1EAA94C30, &v16, (void (__cdecl *)(void *))sub_1DC371FE8);
  }
  uint64_t v11 = *(void *)qword_1EAA94C28;
  if (*(void *)(qword_1EAA94C28 + 8) == *(void *)qword_1EAA94C28)
  {
LABEL_14:
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC3B430C(exception, "Error version not found");
    goto LABEL_15;
  }
  unint64_t v12 = 0;
  while (1)
  {
    *a1 = 0;
    uint64_t v13 = *(atomic_uint **)(v11 + 8 * v12);
    if (v13)
    {
      atomic_fetch_add_explicit(v13 + 2, 1u, memory_order_relaxed);
      if (*a1) {
        sub_1DC2FF57C(*a1);
      }
    }
    *a1 = v13;
    if (v13[4] == v9 && v13[5] == v10) {
      break;
    }
    sub_1DC3627A8(a1);
    ++v12;
    uint64_t v11 = *(void *)qword_1EAA94C28;
    if (v12 >= (uint64_t)(*(void *)(qword_1EAA94C28 + 8) - *(void *)qword_1EAA94C28) >> 3) {
      goto LABEL_14;
    }
  }
  if (!v13)
  {
    unint64_t v15 = __cxa_allocate_exception(0x20uLL);
    sub_1DC379B70(v15, "Couldn't decode version");
    *unint64_t v15 = &unk_1F36611E0;
    __cxa_throw(v15, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
}

void sub_1DC362770(_Unwind_Exception *a1)
{
  sub_1DC3627A8(v1);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC3627A8(atomic_uint **a1)
{
  os_signpost_id_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC3627DC(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661028;
  os_signpost_id_t v2 = (atomic_uint **)(a1 + 16);
  sub_1DC2FF548((atomic_uint **)(a1 + 32));
  sub_1DC3627A8((atomic_uint **)(a1 + 24));
  sub_1DC2FF548(v2);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC362858(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661028;
  os_signpost_id_t v2 = (atomic_uint **)(a1 + 16);
  sub_1DC2FF548((atomic_uint **)(a1 + 32));
  sub_1DC3627A8((atomic_uint **)(a1 + 24));
  sub_1DC2FF548(v2);
  return a1;
}

uint64_t sub_1DC3628B4(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v10 = a2 - 2;
  int v11 = a3 - 2;
  if (sub_1DC362A08(a1, a2 - 2, a3 - 2, a4, a5)) {
    int v12 = 2;
  }
  else {
    int v12 = 0;
  }
  int v13 = v12 | sub_1DC362A08(a1, v10, a3 - 1, a4, a5);
  if (sub_1DC362A08(a1, a2 - 1, v11, a4, a5)) {
    int v14 = 2;
  }
  else {
    int v14 = 0;
  }
  int v15 = v14 | (4 * v13) | sub_1DC362A08(a1, a2 - 1, a3 - 1, a4, a5);
  if (sub_1DC362A08(a1, a2 - 1, a3, a4, a5)) {
    int v16 = 2;
  }
  else {
    int v16 = 0;
  }
  int v17 = v16 | (4 * v15) | sub_1DC362A08(a1, a2, v11, a4, a5);
  if (sub_1DC362A08(a1, a2, a3 - 1, a4, a5)) {
    int v18 = 2;
  }
  else {
    int v18 = 0;
  }
  return v18 | (4 * v17) | sub_1DC362A08(a1, a2, a3, a4, a5);
}

uint64_t sub_1DC362A08(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v5 = a4 + a2;
  int v6 = a3 - (((_BYTE)a4 + 4) & 7) + 4;
  if (a2 >= 0)
  {
    int v6 = a3;
    int v5 = a2;
  }
  if (v6 < 0)
  {
    v6 += a5;
    int v5 = v5 - (((_BYTE)a5 + 4) & 7) + 4;
  }
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = v5;
  unint64_t v9 = *(void *)(v7 + 24) * v5 + v6;
  *(_DWORD *)(*(void *)(v7 + 48) + ((v9 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v9;
  return sub_1DC2FF924(*(void **)(a1 + 16), v6, v8);
}

void sub_1DC362A88(void *a1)
{
  *a1 = &unk_1F3661088;
  sub_1DC311968(a1 + 2);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC362AEC(void *a1)
{
  *a1 = &unk_1F3661088;
  sub_1DC311968(a1 + 2);
  return a1;
}

atomic_uint **sub_1DC362B30(atomic_uint **a1)
{
  os_signpost_id_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC362B64(void ***a1)
{
  uint64_t v1 = *a1;
  os_signpost_id_t v2 = (atomic_uint **)**a1;
  if (v2)
  {
    int v4 = (atomic_uint **)v1[1];
    int v5 = v2;
    if (v4 != v2)
    {
      do
        int v4 = sub_1DC362B30(v4 - 1);
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DC362BEC(uint64_t a1, long long *a2)
{
  int v4 = (std::string *)(a1 + 64);
  if (*(char *)(a1 + 87) < 0) {
    operator delete(v4->__r_.__value_.__l.__data_);
  }
  long long v5 = *a2;
  v4->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
  *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  *(void *)(a1 + 88) = 0;
  char v6 = *(unsigned char *)(a1 + 87);
  if (v6 < 0)
  {
    uint64_t v7 = *(std::string **)(a1 + 64);
    unint64_t v8 = *(void *)(a1 + 72);
  }
  else
  {
    uint64_t v7 = v4;
    unint64_t v8 = *(unsigned __int8 *)(a1 + 87);
  }
  int v9 = *(_DWORD *)(a1 + 96);
  if ((v9 & 8) != 0)
  {
    *(void *)(a1 + 88) = (char *)v7 + v8;
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v7;
    *(void *)(a1 + 32) = (char *)v7 + v8;
  }
  if ((v9 & 0x10) != 0)
  {
    *(void *)(a1 + 88) = (char *)v7 + v8;
    std::string::size_type v10 = v6 < 0 ? (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize(v4, v10, 0);
    uint64_t v11 = *(char *)(a1 + 87) < 0 ? *(void *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(void *)(a1 + 40) = v7;
    *(void *)(a1 + 48) = v7;
    *(void *)(a1 + 56) = (char *)v7 + v11;
    if ((*(unsigned char *)(a1 + 96) & 3) != 0)
    {
      if (v8 >> 31)
      {
        uint64_t v12 = ((v8 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        unint64_t v13 = 0x7FFFFFFF * ((v12 + ((v8 - 0x80000000 - v12) >> 1)) >> 30);
        uint64_t v7 = (std::string *)((char *)v7 + v13 + 0x7FFFFFFF);
        unint64_t v8 = v8 - v13 - 0x7FFFFFFF;
        *(void *)(a1 + 48) = v7;
      }
      if (v8) {
        *(void *)(a1 + 48) = (char *)v7 + v8;
      }
    }
  }
}

void sub_1DC362D30()
{
}

void sub_1DC362DD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, atomic_uint *a10)
{
  sub_1DC314B30(&a10);
  sub_1DC314A14(&a9);
  MEMORY[0x1E019CE90](v10, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

void sub_1DC362E10(void *a1, uint64_t *a2)
{
  *a1 = 0;
  uint64_t v2 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v3 = v2;
  sub_1DC364B54((uint64_t)&v4, &v3);
}

void sub_1DC362F08(void *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, atomic_uint *);
  uint64_t v6 = va_arg(va1, void);
  sub_1DC311C34((atomic_uint **)va1);
  sub_1DC2FF548((atomic_uint **)va);
  *(void *)(v2 + 56) = 0;
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DC362EF4);
}

void sub_1DC362F38(void *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1DC2FF548((atomic_uint **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DC362E98);
}

void sub_1DC362F54(_Unwind_Exception *a1)
{
  sub_1DC311C34(v1);
  _Unwind_Resume(a1);
}

void sub_1DC362F68(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  sub_1DC314778((uint64_t)v2, a2);
  operator new();
}

void sub_1DC364688(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_1DC32B69C((uint64_t)&STACK[0x2C8]);
    sub_1DC3147E4(&STACK[0x2B0], "Unsupported ECI: ");
    sub_1DC362BEC((uint64_t)&STACK[0x2D0], (long long *)&STACK[0x2B0]);
    if (SLOBYTE(STACK[0x2C7]) < 0) {
      operator delete((void *)STACK[0x2B0]);
    }
    std::ostream::operator<<();
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC32B834(&STACK[0x2B0], (uint64_t)&STACK[0x2D0]);
    if (SLOBYTE(STACK[0x2C7]) >= 0) {
      uint64_t v3 = (char *)&STACK[0x2B0];
    }
    else {
      uint64_t v3 = (char *)STACK[0x2B0];
    }
    sub_1DC379B70(exception, v3);
    void *exception = &unk_1F3661188;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
  }
  JUMPOUT(0x1DC364AB4);
}

void sub_1DC36475C()
{
  if (v2 < 0)
  {
    operator delete(v1);
    if ((v3 & 1) == 0) {
      goto LABEL_6;
    }
  }
  else if (!v3)
  {
LABEL_6:
    sub_1DC32B90C((uint64_t)&STACK[0x2C8]);
    __cxa_end_catch();
    JUMPOUT(0x1DC3649F0);
  }
  __cxa_free_exception(v0);
  goto LABEL_6;
}

void sub_1DC3647C4(void *a1, int a2)
{
  if (a2) {
    sub_1DC2FFA58(a1);
  }
  JUMPOUT(0x1DC364AB4);
}

void sub_1DC3647D4()
{
  if (SLOBYTE(STACK[0x2DF]) < 0) {
    operator delete((void *)STACK[0x2C8]);
  }
  JUMPOUT(0x1DC3649F0);
}

void sub_1DC3647F0()
{
  MEMORY[0x1E019CE90](v0, 0x1093C40E92185C3);
  sub_1DC311968(&STACK[0x2C8]);
  JUMPOUT(0x1DC364A84);
}

void sub_1DC3648BC(void *a1, int a2)
{
  if (a2)
  {
    if (SLOBYTE(STACK[0x2DF]) < 0) {
      operator delete((void *)STACK[0x2C8]);
    }
    __cxa_begin_catch(a1);
    sub_1DC3147E4(&STACK[0x2C8], "ISO-8859-1");
    sub_1DC33DB6C((uint64_t)&STACK[0x2C8]);
    if (SLOBYTE(STACK[0x2DF]) < 0) {
      operator delete((void *)STACK[0x2C8]);
    }
    __cxa_end_catch();
    JUMPOUT(0x1DC363058);
  }
  JUMPOUT(0x1DC364AB4);
}

void sub_1DC364920()
{
  if (SLOBYTE(STACK[0x2DF]) < 0) {
    operator delete((void *)STACK[0x2C8]);
  }
  __cxa_end_catch();
  JUMPOUT(0x1DC364A84);
}

void sub_1DC364948()
{
}

void sub_1DC364950()
{
}

void sub_1DC364958()
{
  MEMORY[0x1E019CE90](v0, 0x10A1C4099511FF1);
  JUMPOUT(0x1DC364AACLL);
}

void sub_1DC364978()
{
}

void sub_1DC364980()
{
}

void sub_1DC364988()
{
}

void sub_1DC364990()
{
  __cxa_free_exception(v0);
  JUMPOUT(0x1DC364A84);
}

void sub_1DC3649A4()
{
}

void sub_1DC3649AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,atomic_uint *a24,__int16 a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  __cxa_free_exception(v64);
  sub_1DC34EC90(&a24);
  sub_1DC32B90C((uint64_t)&a25);
  if (a63 < 0) {
    operator delete(__p);
  }
  sub_1DC32B90C((uint64_t)&a64);
  sub_1DC34EC90((atomic_uint **)&STACK[0x2A8]);
  sub_1DC311968(&a14);
  _Unwind_Resume(a1);
}

void sub_1DC364B54(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v7 = (atomic_uint *)v2;
  if (unint64_t)(*(void *)(v2 + 16) - 8) > 0x88 || (*(void *)(v2 + 16))
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC379B70(exception, "Dimension must be even, > 8 < 144");
    void *exception = &unk_1F36611E0;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  *(void *)&long long v8 = v2;
  sub_1DC362574(&v9, 0, (_DWORD *)v2);
  uint64_t v4 = v9;
  if (v9) {
    atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
  }
  sub_1DC3627A8(&v9);
  sub_1DC2FF548((atomic_uint **)&v8);
  if (v7) {
    atomic_fetch_add_explicit(v7 + 2, 1u, memory_order_relaxed);
  }
  if (v4[4] == (v7[8] & (v7[14] - 1) | v7[4] & -v7[14])) {
    operator new();
  }
  uint64_t v6 = __cxa_allocate_exception(0x20uLL);
  sub_1DC379B70(v6, "Dimension of bitMatrix must match the version size");
  void *v6 = &unk_1F36613B0;
  __cxa_throw(v6, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
}

void sub_1DC365F58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,atomic_uint *a45,void **a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  sub_1DC314BD0((void *)(v52 - 136));
  sub_1DC311968(&a39);
  sub_1DC311968(&a42);
  sub_1DC362B30(&a45);
  sub_1DC311968(&a46);
  a46 = (void **)&a52;
  sub_1DC362B64(&a46);
  sub_1DC311968((void *)(v52 - 240));
  sub_1DC362858(v52 - 200);
  _Unwind_Resume(a1);
}

BOOL sub_1DC366224(uint64_t a1, uint64_t a2)
{
  return (*(float (**)(void))(**(void **)a2 + 16))() >= 0.0
      && (*(float (**)(void))(**(void **)a2 + 16))() < (float)(*(void *)(*(void *)(a1 + 16) + 16) & (unint64_t)(*(void *)(*(void *)(a1 + 16) + 56) - 1) | *(void *)(*(void *)(a1 + 16) + 32) & -*(void *)(*(void *)(a1 + 16) + 56))
      && (*(float (**)(void))(**(void **)a2 + 24))() >= 0.0
      && (*(float (**)(void))(**(void **)a2 + 24))() < (float)(*(void *)(*(void *)(a1 + 16) + 32) & (unint64_t)(*(void *)(*(void *)(a1 + 16) + 56) - 1) | *(void *)(*(void *)(a1 + 16) + 16) & -*(void *)(*(void *)(a1 + 16) + 56));
}

uint64_t sub_1DC366360(uint64_t a1, atomic_uint **a2, atomic_uint **a3, float a4)
{
  uint64_t v7 = a1;
  long long v8 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
  }
  float64x2_t v40 = v8;
  if (!sub_1DC366224(a1, (uint64_t)&v40))
  {
    sub_1DC2FFD08(&v40);
    return 0xFFFFFFFFLL;
  }
  int v9 = *a3;
  if (*a3) {
    atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
  }
  float64x2_t v39 = v9;
  BOOL v10 = sub_1DC366224(v7, (uint64_t)&v39);
  sub_1DC2FFD08(&v39);
  sub_1DC2FFD08(&v40);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  int v11 = (int)(*(float (**)(void))(*(void *)*a2 + 16))();
  int v12 = (int)(*(float (**)(void))(*(void *)*a2 + 24))();
  int v13 = (int)(*(float (**)(void))(*(void *)*a3 + 16))();
  int v14 = (int)(*(float (**)(void))(*(void *)*a3 + 24))();
  if (v14 - v12 >= 0) {
    unsigned int v15 = v14 - v12;
  }
  else {
    unsigned int v15 = v12 - v14;
  }
  if (v13 - v11 >= 0) {
    unsigned int v16 = v13 - v11;
  }
  else {
    unsigned int v16 = v11 - v13;
  }
  if (v15 > v16) {
    unsigned int v17 = v16;
  }
  else {
    unsigned int v17 = v15;
  }
  if (v15 > v16) {
    unsigned int v18 = v15;
  }
  else {
    unsigned int v18 = v16;
  }
  if (v15 > v16) {
    int v19 = v12;
  }
  else {
    int v19 = v11;
  }
  if (v15 > v16) {
    int v20 = v11;
  }
  else {
    int v20 = v12;
  }
  if (v15 > v16) {
    int v21 = v14;
  }
  else {
    int v21 = v13;
  }
  if (v15 > v16) {
    int v14 = v13;
  }
  int v36 = v14;
  if (v20 < v14) {
    int v22 = 1;
  }
  else {
    int v22 = -1;
  }
  int v35 = v22;
  if (v19 < v21) {
    int v23 = 1;
  }
  else {
    int v23 = -1;
  }
  int v37 = v23;
  unsigned int v38 = v17;
  if (v19 == v21) {
    return 0;
  }
  unsigned int v34 = v18;
  int64x2_t v25 = *(void **)(v7 + 16);
  int v26 = sub_1DC2FF924(v25, v11, v12);
  int v27 = 0;
  LODWORD(v7) = 0;
  int v28 = (signed int)-v34 >> 1;
  do
  {
    if (v15 <= v16) {
      int v29 = v19;
    }
    else {
      int v29 = v20;
    }
    uint64_t v30 = v29;
    if (v15 <= v16) {
      int v31 = v20;
    }
    else {
      int v31 = v19;
    }
    int v32 = sub_1DC2FF924(v25, v30, v31);
    int v33 = (v26 ^ v32) & (v27 >= (int)(float)(a4 * 0.5));
    uint64_t v7 = (v7 + v33);
    if (v33) {
      int v27 = 1;
    }
    else {
      ++v27;
    }
    if (v33) {
      int v26 = v32;
    }
    v28 += v38;
    if (v28 >= 1)
    {
      if (v20 == v36) {
        return v7;
      }
      v20 += v35;
      v28 -= v34;
    }
    v19 += v37;
  }
  while (v21 != v19);
  return v7;
}

void sub_1DC3665F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, atomic_uint *);
  sub_1DC2FFD08((atomic_uint **)va);
  sub_1DC2FFD08((atomic_uint **)va1);
  _Unwind_Resume(a1);
}

void sub_1DC36661C(uint64_t a1, atomic_uint **a2, atomic_uint **a3)
{
  long long v5 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
  }
  long long v8 = v5;
  uint64_t v6 = *a3;
  if (*a3) {
    atomic_fetch_add_explicit(v6 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v7 = v6;
  sub_1DC3B4C78(&v8, (uint64_t)&v7);
  sub_1DC2FFD08(&v7);
  sub_1DC2FFD08(&v8);
  (*(void (**)(void))(*(void *)*a3 + 16))();
  (*(void (**)(void))(*(void *)*a2 + 16))();
  (*(void (**)(void))(*(void *)*a3 + 24))();
  (*(void (**)(void))(*(void *)*a2 + 24))();
  operator new();
}

void sub_1DC36684C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, atomic_uint *a10)
{
}

void sub_1DC366888(uint64_t a1, atomic_uint **a2, atomic_uint **a3, atomic_uint **a4)
{
  uint64_t v7 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v7 + 2, 1u, memory_order_relaxed);
  }
  unsigned int v15 = v7;
  long long v8 = *a3;
  if (*a3) {
    atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
  }
  int v14 = v8;
  sub_1DC3B4C78(&v15, (uint64_t)&v14);
  sub_1DC2FFD08(&v14);
  sub_1DC2FFD08(&v15);
  int v9 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
  }
  int v13 = v9;
  BOOL v10 = *a4;
  if (*a4) {
    atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
  }
  int v12 = v10;
  sub_1DC3B4C78(&v13, (uint64_t)&v12);
  sub_1DC2FFD08(&v12);
  sub_1DC2FFD08(&v13);
  (*(void (**)(void))(*(void *)*a3 + 16))();
  (*(void (**)(void))(*(void *)*a2 + 16))();
  (*(void (**)(atomic_uint *, uint64_t))(*(void *)*a4 + 16))(*a4, v11);
  (*(void (**)(void))(*(void *)*a2 + 16))();
  (*(void (**)(void))(*(void *)*a3 + 24))();
  (*(void (**)(void))(*(void *)*a2 + 24))();
  (*(void (**)(void))(*(void *)*a4 + 24))();
  (*(void (**)(void))(*(void *)*a2 + 24))();
  operator new();
}

void sub_1DC366C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, atomic_uint *);
  sub_1DC2FFD08((atomic_uint **)va);
  sub_1DC2FFD08((atomic_uint **)va1);
  _Unwind_Resume(a1);
}

void sub_1DC366C58(_OWORD *a1, atomic_uint **a2)
{
  *a1 = 0u;
  a1[1] = 0u;
  uint64_t v2 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v2 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v7 = v2;
  int v3 = a2[3];
  if (v3) {
    atomic_fetch_add_explicit(v3 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v6 = v3;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  long long v5 = v4;
  sub_1DC366888((uint64_t)&v8, &v7, &v6, &v5);
}

void sub_1DC366D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, atomic_uint *a10, atomic_uint *a11, atomic_uint *a12)
{
  sub_1DC2FFD08(&a12);
  sub_1DC2FFD08(&a9);
  sub_1DC2FFD08(&a10);
  sub_1DC2FFD08(&a11);
  for (uint64_t i = 24; i != -8; i -= 8)
    sub_1DC2FFD08((atomic_uint **)(v12 + i));
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC366DE4(atomic_uint **a1, atomic_uint **a2, atomic_uint **a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = a2;
  while (1)
  {
    __n128 result = sub_1DC366E84(a1++, v4);
    if (++v4 == a3) {
      break;
    }
    if (a1 == v6) {
      uint64_t v6 = v4;
    }
  }
  if (a1 != v6)
  {
    uint64_t v8 = v6;
    do
    {
      while (1)
      {
        __n128 result = sub_1DC366E84(a1++, v6);
        if (++v6 == a3) {
          break;
        }
        if (a1 == v8) {
          uint64_t v8 = v6;
        }
      }
      uint64_t v6 = v8;
    }
    while (a1 != v8);
  }
  return result;
}

atomic_uint **sub_1DC366E84(atomic_uint **a1, atomic_uint **a2)
{
  uint64_t v4 = *a1;
  if (*a1) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v8 = v4;
  long long v5 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v6 = *a1;
  if (*a1)
  {
    sub_1DC2FF57C(v6);
    uint64_t v4 = v8;
  }
  *a1 = v5;
  if (v4) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  if (*a2) {
    sub_1DC2FF57C(*a2);
  }
  *a2 = v4;
  return sub_1DC2FFD08(&v8);
}

void sub_1DC366F20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC2FFD08((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1DC366F34()
{
}

void sub_1DC368B08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,atomic_uint *a31,atomic_uint *a32,atomic_uint *a33,char a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,atomic_uint *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52)
{
  sub_1DC2FFD08((atomic_uint **)(v52 - 256));
  sub_1DC2FFD08((atomic_uint **)(v52 - 232));
  sub_1DC2FFD08((atomic_uint **)(v52 - 224));
  sub_1DC2FFD08((atomic_uint **)(v52 - 216));
  for (uint64_t i = 24; i != -8; i -= 8)
    sub_1DC2FFD08((atomic_uint **)((char *)&a52 + i));
  sub_1DC311C34(&a31);
  sub_1DC2FF548(&a32);
  sub_1DC30184C(&a33);
  *(void *)(v52 - 224) = &a34;
  sub_1DC2FFC48((void ***)(v52 - 224));
  for (uint64_t j = 24; j != -8; j -= 8)
    sub_1DC2FFD08((atomic_uint **)(&a37 + j));
  sub_1DC368F98(&a43);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC368F98(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

atomic_uint **sub_1DC368FCC(void *a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  sub_1DC36B188((uint64_t)v84, a2, a4);
  unsigned int v80 = COERCE_UNSIGNED_INT64((*(double (**)(void))(**(void **)a3 + 16))());
  *(float *)&unsigned int v5 = (*(float (**)(void))(**(void **)a3 + 24))();
  float v6 = *(float *)(*(void *)a3 + 20);
  int32x2_t v7 = vcvt_s32_f32((float32x2_t)__PAIR64__(v5, v80));
  float v92 = v84;
  int32x2_t v93 = v7;
  uint64_t v95 = 1;
  int32x2_t v94 = 0;
  if (sub_1DC301E70(v84, 1, *(double *)&v7))
  {
    if (!sub_1DC301EE0((int32x2_t *)&v92, v6)) {
      goto LABEL_114;
    }
    goto LABEL_61;
  }
  unint64_t v9 = 0;
  BOOL v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  int v13 = (int)v6;
  do
  {
    if (v13 >= 1)
    {
      __int32 v14 = 0;
      int32x2_t v15 = qword_1DC40C2E0[v12];
      unsigned int v16 = v85;
      *(int32x2_t *)v8.i8 = v7;
      int32x4_t v81 = v8;
      int v17 = v84[0];
      while (1)
      {
        v18.i64[1] = v81.i64[1];
        *(int32x2_t *)v18.i8 = vadd_s32(*(int32x2_t *)v81.i8, v15);
        int32x4_t v81 = v18;
        if (v17 != sub_1DC2FF924(v16, v18.i32[0], v18.i32[1])) {
          break;
        }
        if (v13 == ++v14) {
          goto LABEL_27;
        }
      }
      int32x4_t v8 = v81;
      v8.i32[2] = v14;
      if ((unint64_t)v10 >= v9)
      {
        int32x4_t v82 = v8;
        uint64_t v19 = ((uint64_t)v10->i64 - v11) >> 4;
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 60) {
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v9 - v11) >> 3 > v20) {
          unint64_t v20 = (uint64_t)(v9 - v11) >> 3;
        }
        if (v9 - v11 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v21 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v21 = v20;
        }
        if (v21) {
          unint64_t v21 = (unint64_t)sub_1DC300068(v21);
        }
        else {
          uint64_t v22 = 0;
        }
        int v23 = (int32x4_t *)(v21 + 16 * v19);
        v8.i64[1] = v82.i64[1];
        *int v23 = v82;
        int8x16_t v24 = v23 + 1;
        if (v10 != (int32x4_t *)v11)
        {
          do
          {
            int32x4_t v25 = v10[-1];
            --v10;
            v8.i64[1] = v25.i64[1];
            v23[-1] = v25;
            --v23;
          }
          while (v10 != (int32x4_t *)v11);
          BOOL v10 = (int32x4_t *)v11;
        }
        uint64_t v11 = (uint64_t)v23;
        unint64_t v9 = v21 + 16 * v22;
        if (v10) {
          operator delete(v10);
        }
        BOOL v10 = v24;
      }
      else
      {
        *v10++ = v8;
      }
    }
LABEL_27:
    ++v12;
  }
  while (v12 != 8);
  unint64_t v26 = 126 - 2 * __clz(((uint64_t)v10->i64 - v11) >> 4);
  if (v10 == (int32x4_t *)v11) {
    uint64_t v27 = 0;
  }
  else {
    uint64_t v27 = v26;
  }
  sub_1DC30204C(v11, v10, v27, 1);
  if (v10 == (int32x4_t *)v11)
  {
    int v28 = 0;
    int v29 = 0;
    if (v10) {
LABEL_52:
    }
      operator delete(v10);
  }
  else
  {
    int v28 = 0;
    int v29 = 0;
    unint64_t v30 = 0;
    int v31 = (int32x4_t *)v11;
    do
    {
      uint64_t v32 = v31->i64[0];
      if ((unint64_t)v29 >= v30)
      {
        uint64_t v33 = (v29 - v28) >> 3;
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 61) {
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v30 - (void)v28) >> 2 > v34) {
          unint64_t v34 = (uint64_t)(v30 - (void)v28) >> 2;
        }
        if (v30 - (unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v35 = v34;
        }
        if (v35) {
          unint64_t v35 = (unint64_t)sub_1DC2FFD7C(v35);
        }
        else {
          uint64_t v36 = 0;
        }
        int v37 = (char *)(v35 + 8 * v33);
        *(void *)int v37 = v32;
        unsigned int v38 = v37 + 8;
        while (v29 != v28)
        {
          uint64_t v39 = *((void *)v29 - 1);
          v29 -= 8;
          *((void *)v37 - 1) = v39;
          v37 -= 8;
        }
        unint64_t v30 = v35 + 8 * v36;
        if (v28) {
          operator delete(v28);
        }
        int v28 = v37;
        int v29 = v38;
      }
      else
      {
        *(void *)int v29 = v32;
        v29 += 8;
      }
      ++v31;
    }
    while (v31 != v10);
    BOOL v10 = (int32x4_t *)v11;
    if (v11) {
      goto LABEL_52;
    }
  }
  if (v28 == v29)
  {
    BOOL v41 = 0;
    if (v28) {
LABEL_59:
    }
      operator delete(v28);
  }
  else
  {
    float64x2_t v40 = v28 + 8;
    do
    {
      int32x2_t v93 = *(int32x2_t *)(v40 - 8);
      BOOL v41 = sub_1DC301EE0((int32x2_t *)&v92, v6);
      if (v41) {
        break;
      }
      BOOL v42 = v40 == v29;
      v40 += 8;
    }
    while (!v42);
    if (v28) {
      goto LABEL_59;
    }
  }
  if (!v41)
  {
LABEL_114:
    float v86 = 0;
    float v87 = 0;
    unint64_t v88 = 0;
    return sub_1DC2FF548(&v85);
  }
LABEL_61:
  float v43 = v6 * 7.0;
  int32x2_t v44 = v93;
  int32x2_t v94 = (int32x2_t)0x100000000;
  signed int v45 = (int)(float)(v6 * 7.0);
  if (sub_1DC302B2C((int32x2_t *)&v92, 3, v45, (int)(float)(v6 / 5.0), (int)(float)(v6 * 0.5)) == -1) {
    goto LABEL_114;
  }
  int32x2_t v47 = v93;
  v46.i32[0] = -v94.i32[1];
  int32x2_t v94 = vzip1_s32(v46, v94);
  float v89 = 0;
  double v90 = 0;
  unint64_t v91 = 0;
  sub_1DC300D68((void **)&v89, vcvts_n_u32_f32(v43, 2uLL));
  int v48 = 0;
  float v49 = v43 * 8.0;
  double v51 = v90;
  unint64_t v50 = v91;
  int32x2_t v52 = v47;
  do
  {
    float32x2_t v53 = vadd_f32(vcvt_f32_s32(v52), (float32x2_t)0x3F0000003F000000);
    if ((unint64_t)v51 >= v50)
    {
      int v54 = v89;
      uint64_t v55 = ((char *)v51 - v89) >> 3;
      unint64_t v56 = v55 + 1;
      if ((unint64_t)(v55 + 1) >> 61) {
        sub_1DC2FF97C();
      }
      if ((uint64_t)(v50 - (void)v89) >> 2 > v56) {
        unint64_t v56 = (uint64_t)(v50 - (void)v89) >> 2;
      }
      if (v50 - (unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v57 = v56;
      }
      if (v57) {
        unint64_t v57 = (unint64_t)sub_1DC2FFD7C(v57);
      }
      else {
        uint64_t v58 = 0;
      }
      unint64_t v59 = (float32x2_t *)(v57 + 8 * v55);
      *unint64_t v59 = v53;
      long long v60 = v59 + 1;
      if (v51 != (float32x2_t *)v54)
      {
        do
        {
          float32x2_t v61 = v51[-1];
          --v51;
          v59[-1] = v61;
          --v59;
        }
        while (v51 != (float32x2_t *)v54);
        double v51 = (float32x2_t *)v89;
      }
      unint64_t v50 = v57 + 8 * v58;
      float v89 = (char *)v59;
      double v90 = v60;
      unint64_t v91 = v50;
      if (v51) {
        operator delete(v51);
      }
      double v51 = v60;
    }
    else
    {
      *v51++ = v53;
    }
    int32x2_t v62 = v93;
    int32x2_t v63 = vsub_s32(v93, v44);
    __int32 v64 = v63.i32[1];
    __int32 v65 = v63.i32[0];
    if (v63.i32[0] >= 0) {
      unsigned int v66 = v63.i32[0];
    }
    else {
      unsigned int v66 = -v63.i32[0];
    }
    if (v63.i32[1] >= 0) {
      unsigned int v67 = v63.u32[1];
    }
    else {
      unsigned int v67 = -v63.i32[1];
    }
    if (v66 <= v67) {
      signed int v68 = v67;
    }
    else {
      signed int v68 = v66;
    }
    double v90 = v51;
    v63.i32[0] = -v94.i32[1];
    int32x2_t v83 = v94;
    int32x2_t v69 = vzip1_s32(v63, v94);
    int32x2_t v70 = vneg_s32(v69);
    int32x2_t v71 = (int32x2_t)v92;
    if (sub_1DC302D58(v92, v93, v70) == -1)
    {
      int32x2_t v94 = v70;
    }
    else if (sub_1DC302D58(*(unsigned __int8 **)&v71, v62, v83) == -1)
    {
      int32x2_t v70 = v83;
    }
    else
    {
      int32x2_t v94 = v69;
      if (sub_1DC302D58(*(unsigned __int8 **)&v71, v62, v69) == -1)
      {
        int32x2_t v70 = v69;
      }
      else
      {
        v72.i32[1] = v83.i32[1];
        v72.i32[0] = -v83.i32[0];
        int32x2_t v70 = vzip1_s32(v72, v69);
        int32x2_t v94 = v70;
        if (sub_1DC302D58(*(unsigned __int8 **)&v71, v62, v70) != -1) {
          goto LABEL_115;
        }
      }
    }
    int32x2_t v52 = vadd_s32(v70, v62);
    int32x2_t v93 = v52;
    if (v52.i32[0] < 0
      || *(void *)(*(void *)&v71 + 8) <= (unint64_t)v52.u32[0]
      || v52.i32[1] < 0
      || *(void *)(*(void *)&v71 + 16) <= (unint64_t)v52.u32[1])
    {
      goto LABEL_115;
    }
    int32x2_t v73 = vsub_s32(v52, v44);
    int v74 = v73.i32[1];
    unsigned int v75 = v73.i32[0];
    if (v73.i32[0] < 0) {
      unsigned int v75 = -v73.i32[0];
    }
    if (v73.i32[1] < 0) {
      int v74 = -v73.i32[1];
    }
    if (v75 > v74) {
      int v74 = v75;
    }
    if (v74 > v45
      || (uint32x2_t v76 = (uint32x2_t)vceq_s32(v52, v44), (vpmin_u32(v76, v76).u32[0] & 0x80000000) != 0)
      || (float64_t v77 = v89, v49 < (float)(unint64_t)(((char *)v51 - v89) >> 3)))
    {
LABEL_115:
      float64_t v77 = v89;
LABEL_116:
      float v86 = 0;
      float v87 = 0;
      unint64_t v88 = 0;
      if (v77) {
        operator delete(v77);
      }
      return sub_1DC2FF548(&v85);
    }
    v48 |= 1 << (v65 / v68 + 3 * (v64 / v68) + 4);
    uint32x2_t v78 = (uint32x2_t)vceq_s32(v52, v47);
  }
  while ((vpmin_u32(v78, v78).u32[0] & 0x80000000) == 0);
  if (v48 != 495) {
    goto LABEL_116;
  }
  float v86 = v89;
  float v87 = v51;
  unint64_t v88 = v91;
  if (v89 != (char *)v51) {
    sub_1DC300E10(&v92, &v86, vadd_f32(vcvt_f32_s32(v44), (float32x2_t)0x3F0000003F000000));
  }
  float v87 = v51;
  operator delete(v51);
  return sub_1DC2FF548(&v85);
}

void sub_1DC36AEC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, atomic_uint **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, atomic_uint *a19, atomic_uint *a20,atomic_uint *a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,atomic_uint *a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,atomic_uint *a47)
{
  sub_1DC311C00((atomic_uint **)(v47 - 168));
  sub_1DC35D870(&a19);
  sub_1DC30184C(&a20);
  sub_1DC2FF548(&a21);
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }
  float v49 = *(void **)(v47 - 248);
  if (v49) {
    operator delete(v49);
  }
  unint64_t v50 = *(void **)(v47 - 224);
  if (v50) {
    operator delete(v50);
  }
  double v51 = *(void **)(v47 - 200);
  if (v51)
  {
    *(void *)(v47 - 192) = v51;
    operator delete(v51);
  }
  sub_1DC30184C(&a39);
  if (a41)
  {
    a42 = (uint64_t)a41;
    operator delete(a41);
  }
  if (a12) {
    operator delete(a12);
  }
  sub_1DC2FF548(&a47);
  sub_1DC311C00(a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC36B188(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t v4 = *(void *)(*a2 + 56);
  uint64_t v5 = -v4;
  uint64_t v6 = *(void *)(*a2 + 32);
  uint64_t v7 = v6 & -v4--;
  uint64_t v8 = *(void *)(*a2 + 16);
  *(unsigned char *)a1 = a3;
  *(void *)(a1 + 8) = v8 & v4 | v7;
  *(void *)(a1 + 16) = v6 & v4 | v8 & v5;
  *(void *)(a1 + 24) = 0;
  uint64_t v9 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 1u, memory_order_relaxed);
    BOOL v10 = *(atomic_uint **)(a1 + 24);
    if (v10) {
      sub_1DC2FF57C(v10);
    }
  }
  *(void *)(a1 + 24) = v9;
  return a1;
}

char *sub_1DC36B20C(char *__src, char *a2, char *a3)
{
  if (__src != a2 && a2 != a3)
  {
    int v3 = __src;
    if (__src + 4 == a2)
    {
      int v9 = *(_DWORD *)__src;
      int64_t v10 = a3 - a2;
      __srCGFloat c = (char *)memmove(__src, a2, a3 - a2);
      *(_DWORD *)((char *)v3 + v10) = v9;
    }
    else if (a2 + 4 == a3)
    {
      int v11 = *((_DWORD *)a3 - 1);
      if (a3 - 4 != __src) {
        __srCGFloat c = (char *)memmove(__src + 4, __src, a3 - 4 - __src);
      }
      _DWORD *v3 = v11;
    }
    else
    {
      uint64_t v4 = (a2 - __src) >> 2;
      if (v4 == (a3 - a2) >> 2)
      {
        uint64_t v5 = __src + 4;
        uint64_t v6 = a2 + 4;
        do
        {
          int v7 = *((_DWORD *)v5 - 1);
          *((_DWORD *)v5 - 1) = *((_DWORD *)v6 - 1);
          *((_DWORD *)v6 - 1) = v7;
          if (v5 == a2) {
            break;
          }
          v5 += 4;
          BOOL v8 = v6 == a3;
          v6 += 4;
        }
        while (!v8);
      }
      else
      {
        uint64_t v12 = (a3 - a2) >> 2;
        uint64_t v13 = (a2 - __src) >> 2;
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = v12;
          uint64_t v12 = v14 % v12;
        }
        while (v12);
        if (v13)
        {
          int32x2_t v15 = &__src[4 * v13];
          do
          {
            int v16 = *((_DWORD *)v15 - 1);
            v15 -= 4;
            int v17 = v16;
            int32x4_t v18 = &v15[4 * v4];
            uint64_t v19 = v15;
            do
            {
              unint64_t v20 = v18;
              *(_DWORD *)uint64_t v19 = *(_DWORD *)v18;
              unint64_t v21 = &v18[4 * v4];
              BOOL v22 = __OFSUB__(v4, (a3 - v18) >> 2);
              uint64_t v24 = v4 - ((a3 - v18) >> 2);
              char v23 = (v24 < 0) ^ v22;
              int32x4_t v18 = &__src[4 * v24];
              if (v23) {
                int32x4_t v18 = v21;
              }
              uint64_t v19 = v20;
            }
            while (v18 != v15);
            *(_DWORD *)unint64_t v20 = v17;
          }
          while (v15 != __src);
        }
      }
    }
  }
  return __src;
}

uint64_t sub_1DC36B358(uint64_t a1, int a2, float a3, float a4, float a5, float a6, float a7)
{
  float v7 = a5;
  float v8 = a4;
  float v9 = a6 - a4;
  float v10 = a7 - a5;
  float v11 = sqrtf((float)(v10 * v10) + (float)(v9 * v9));
  if (v11 < 0.00001) {
    return 0xFFFFFFFFLL;
  }
  int v12 = (int)(float)(a3 * 0.5);
  if (v12 <= 1) {
    int v12 = 1;
  }
  int v43 = v12;
  int v13 = (int)v8;
  if ((int)v8 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = (int)v7;
  uint64_t result = 0xFFFFFFFFLL;
  if ((v15 & 0x80000000) == 0)
  {
    int v17 = *(_DWORD *)(a1 + 56);
    int v18 = -v17;
    int v19 = *(_DWORD *)(a1 + 32);
    int v20 = v17 - 1;
    int v21 = *(_DWORD *)(a1 + 16);
    int v22 = v21 & v20 | v19 & v18;
    if (v13 < v22)
    {
      int v23 = v19 & v20 | v21 & v18;
      if ((int)v15 < v23)
      {
        uint64_t result = 0;
        int v24 = (int)v11;
        if ((int)v11 >= 1)
        {
          int v42 = (int)(float)((float)(a3 * 2.0) + 0.5);
          if ((v42 & 0x80000000) == 0)
          {
            float v26 = v9 / v11;
            float v27 = v10 / v11;
            LOBYTE(v28) = sub_1DC2FF924((void *)a1, (int)v8, v15);
            unsigned __int8 v29 = v28;
            int v30 = 0;
            int v31 = 0;
            int v32 = 1;
            do
            {
              uint64_t v33 = (int)v7;
              BOOL v34 = (int)v33 < v23 && v13 < v22;
              if (!v34 || (v33 & 0x80000000) != 0) {
                break;
              }
              int v28 = sub_1DC2FF924((void *)a1, v13, v33);
              char v35 = v29 ^ v28;
              int v36 = v28 ^ a2;
              if (v30 < v43) {
                int v36 = 0;
              }
              int v37 = v31 + v36;
              if ((v29 ^ v28))
              {
                unsigned __int8 v29 = v28;
                int v30 = 1;
              }
              else
              {
                ++v30;
              }
              if (v35) {
                int v31 = v37;
              }
              if (v32 >= v24) {
                break;
              }
              if (v30 > v42) {
                break;
              }
              float v8 = v26 + v8;
              float v7 = v27 + v7;
              int v13 = (int)v8;
              ++v32;
            }
            while (((int)v8 & 0x80000000) == 0);
            BOOL v39 = v30 < v43 || v30 > v42;
            int v40 = v31 - v39;
            if ((v28 ^ a2)) {
              unsigned int v41 = v40;
            }
            else {
              unsigned int v41 = v31;
            }
            if (v31 >= 1) {
              return v41;
            }
            else {
              return v31;
            }
          }
        }
      }
    }
  }
  return result;
}

char *sub_1DC36B53C(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  float v7 = result;
  uint64_t v8 = *((void *)result + 2);
  float v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62) {
      sub_1DC2FF97C();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = sub_1DC314E1C(v7, v11);
    int v13 = (char *)v7[1];
    int v12 = (void **)(v7 + 1);
    float v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      int v18 = v9;
      int v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  int v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  int v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    float v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    int v18 = v9;
    int v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *int v12 = &v9[v17];
  return result;
}

atomic_uint **sub_1DC36B644(atomic_uint **a1, uint64_t *a2, atomic_uint **a3, uint64_t a4, void *a5, uint64_t a6, _DWORD *a7)
{
  int v21 = 0;
  if (*a7 - 18) >= 0xFFFFFFF9 && (*a7)
  {
    if (*(void *)a4 == *(void *)(a4 + 8) && *a5 == a5[1])
    {
      int v12 = *a3;
      if (*a3)
      {
LABEL_10:
        v19[2] = 0;
        uint64_t v14 = *a2;
        if (*a2) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v14 + 8), 1u, memory_order_relaxed);
        }
        v19[1] = v14;
        uint64_t v15 = *a7;
        uint64_t v16 = (uint64_t)*a3;
        if (*a3) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v16 + 8), 1u, memory_order_relaxed);
        }
        v19[0] = v16;
        sub_1DC350088((uint64_t)&v22, v14, v15, v19);
      }
    }
    else
    {
      int v12 = *a3;
      if (*a3) {
        atomic_fetch_add_explicit(v12 + 2, 1u, memory_order_relaxed);
      }
    }
    int v20 = v12;
    int v13 = sub_1DC354238((uint64_t)&v20, (const void **)a4, (uint64_t)a5);
    sub_1DC30184C(&v20);
    if (v13) {
      goto LABEL_10;
    }
  }
  *a1 = 0;
  size_t v17 = v21;
  if (v21) {
    atomic_fetch_add_explicit(v21 + 2, 1u, memory_order_relaxed);
  }
  *a1 = v17;
  return sub_1DC311C00(&v21);
}

void sub_1DC36BC44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,char a28,int a29,atomic_uint *a30,__int16 a31,char a32,char a33,int a34,__int16 a35,char a36,char a37,int a38,atomic_uint *a39)
{
  *(void *)(v39 - 152) = &a20;
  sub_1DC2FFC48((void ***)(v39 - 152));
  if (__p)
  {
    a26 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1DC311C34(&a30);
  sub_1DC2FF548(&a39);
  sub_1DC311C00((atomic_uint **)(v39 - 160));
  _Unwind_Resume(a1);
}

unint64_t sub_1DC36BE10(uint64_t a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  if (a3 < 1)
  {
    unsigned int v21 = -1;
    uint64_t v22 = 0xFFFFFFFFLL;
  }
  else
  {
    int v7 = a3;
    int v14 = *(_DWORD *)(a1 + 56);
    int v15 = -v14;
    int v16 = *(_DWORD *)(a1 + 32);
    int v17 = v16 & -v14--;
    int v18 = *(_DWORD *)(a1 + 16);
    int v19 = v18 & v14 | v17;
    int v20 = v16 & v14 | v18 & v15;
    while (1)
    {
      a4 = a4 + a6;
      a5 = a5 + a7;
      unsigned int v21 = (int)a4;
      if (((int)a4 & 0x80000000) == 0)
      {
        uint64_t v22 = (int)a5;
        if ((int)v22 < v20
          && (v22 & 0x80000000) == 0
          && (int)v21 < v19
          && sub_1DC2FF924((void *)a1, (int)a4, (int)a5) != a2)
        {
          break;
        }
      }
      if (!--v7)
      {
        unsigned int v21 = -1;
        uint64_t v22 = 0xFFFFFFFFLL;
        return v21 | (unint64_t)(v22 << 32);
      }
    }
  }
  return v21 | (unint64_t)(v22 << 32);
}

uint64_t sub_1DC36BF08(uint64_t a1, int a2, unsigned int a3, int a4, float a5, float a6, float a7)
{
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  int v12 = 0;
  int v13 = 0;
  for (int i = -1; i != 2; ++i)
  {
    for (int j = -1; j != 2; ++j)
    {
      float v16 = (float)((float)j * a6) + (float)((float)i * a5);
      if (v16 >= 0.00001)
      {
        if (v13 >= v12)
        {
          unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (v13 - v10);
          unint64_t v18 = v17 + 1;
          if (v17 + 1 > 0x1555555555555555) {
            sub_1DC2FF97C();
          }
          if (0x5555555555555556 * (v12 - v10) > v18) {
            unint64_t v18 = 0x5555555555555556 * (v12 - v10);
          }
          if (0xAAAAAAAAAAAAAAABLL * (v12 - v10) >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v19 = 0x1555555555555555;
          }
          else {
            unint64_t v19 = v18;
          }
          if (v19)
          {
            if (v19 > 0x1555555555555555) {
              sub_1DC2FF994();
            }
            int v20 = (char *)operator new(12 * v19);
            int v13 = v11;
          }
          else
          {
            int v20 = 0;
          }
          unsigned int v21 = &v20[12 * v17];
          *(_DWORD *)unsigned int v21 = i;
          *((_DWORD *)v21 + 1) = j;
          *((float *)v21 + 2) = v16;
          uint64_t v22 = (int *)v21;
          while (v13 != v10)
          {
            uint64_t v23 = *(void *)(v13 - 3);
            v13 -= 3;
            int v24 = v13[2];
            *(void *)(v22 - 3) = v23;
            v22 -= 3;
            v22[2] = v24;
          }
          int v12 = (int *)&v20[12 * v19];
          unint64_t v11 = (int *)(v21 + 12);
          if (v10) {
            operator delete(v10);
          }
          uint64_t v10 = v22;
        }
        else
        {
          int *v13 = i;
          v13[1] = j;
          *((float *)v13 + 2) = v16;
          unint64_t v11 = v13 + 3;
        }
        int v13 = v11;
      }
    }
  }
  unint64_t v25 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (v13 - v10));
  if (v13 == v10) {
    uint64_t v26 = 0;
  }
  else {
    uint64_t v26 = v25;
  }
  sub_1DC36C2DC((uint64_t)v10, (unint64_t)v13, v26, 1);
  if (a7 <= 0.0) {
    goto LABEL_44;
  }
  int v27 = 0;
  int v28 = *(void **)a1;
  int v29 = *(_DWORD *)(*(void *)a1 + 56);
  int v30 = -v29;
  int v31 = *(_DWORD *)(*(void *)a1 + 32);
  int v32 = v31 & -v29--;
  int v33 = *(_DWORD *)(*(void *)a1 + 16);
  int v34 = v33 & v29 | v32;
  int v35 = v31 & v29 | v33 & v30;
  int v37 = a2;
  unsigned int v36 = a3;
LABEL_30:
  if (v10 == v11)
  {
LABEL_44:
    LODWORD(v39) = a2;
    unsigned int v41 = a3;
LABEL_45:
    if (v10) {
LABEL_46:
    }
      operator delete(v10);
  }
  else
  {
    int v47 = v27;
    unsigned int v38 = v10;
    do
    {
      uint64_t v39 = (*v38 + v37);
      if (*v38 + v37 >= 0)
      {
        int v40 = v38[1];
        unsigned int v41 = v40 + v36;
        BOOL v42 = (int)(v40 + v36) < v35 && (int)v39 < v34;
        if (v42 && (v41 & 0x80000000) == 0 && sub_1DC2FF924(v28, v39, v40 + v36) != a4)
        {
          int v27 = v47 + 1;
          int v37 = v39;
          unsigned int v36 = v41;
          if ((float)(v47 + 1) < a7) {
            goto LABEL_30;
          }
          goto LABEL_45;
        }
      }
      v38 += 3;
    }
    while (v38 != v11);
    unsigned int v41 = v36;
    LODWORD(v39) = v37;
    if (v10) {
      goto LABEL_46;
    }
  }
  if (a6 <= 0.0) {
    uint64_t v43 = v41;
  }
  else {
    uint64_t v43 = v41 + 1;
  }
  if (a5 <= 0.0) {
    uint64_t v44 = v39;
  }
  else {
    uint64_t v44 = (v39 + 1);
  }
  return v44 | (v43 << 32);
}

void sub_1DC36C1E0(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC36C200(uint64_t a1, _DWORD *a2)
{
  uint64_t v5 = *(_DWORD **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = ((uint64_t)v5 - *(void *)a1) >> 2;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 62) {
      sub_1DC2FF97C();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 1 > v9) {
      unint64_t v9 = v10 >> 1;
    }
    BOOL v11 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFFCLL;
    unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v9;
    }
    if (v12)
    {
      unint64_t v12 = (unint64_t)sub_1DC314E5C(v12);
      int v7 = *(_DWORD **)a1;
      uint64_t v5 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    int v14 = (_DWORD *)(v12 + 4 * v8);
    unint64_t v15 = v12 + 4 * v13;
    _DWORD *v14 = *a2;
    uint64_t v6 = v14 + 1;
    while (v5 != v7)
    {
      int v16 = *--v5;
      *--int v14 = v16;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v6;
    *(void *)(a1 + 16) = v15;
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    *uint64_t v5 = *a2;
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a1 + 8) = v6;
}

uint64_t sub_1DC36C2DC(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  unint64_t v10 = v9;
  while (1)
  {
    unint64_t v9 = v10;
    uint64_t v11 = a2 - v10;
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v10) >> 2);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          float v48 = *(float *)(a2 - 4);
          float v49 = *(float *)(v10 + 8);
          if (v48 > v49)
          {
            float v50 = *(float *)v10;
            *(_DWORD *)unint64_t v10 = *(_DWORD *)(a2 - 12);
            *(float *)(a2 - 12) = v50;
            int v51 = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v10 + 4) = *(_DWORD *)(a2 - 8);
            *(_DWORD *)(a2 - 8) = v51;
            *(float *)(v10 + 8) = v48;
            *(float *)(a2 - 4) = v49;
          }
          break;
        case 3uLL:
          uint64_t result = (uint64_t)sub_1DC36CB4C((float *)v10, (float *)(v10 + 12), (float *)(a2 - 12));
          break;
        case 4uLL:
          uint64_t result = (uint64_t)sub_1DC36CC58(v10, v10 + 12, v10 + 24, a2 - 12);
          break;
        case 5uLL:
          uint64_t result = (uint64_t)sub_1DC36CC58(v10, v10 + 12, v10 + 24, v10 + 36);
          float v52 = *(float *)(a2 - 4);
          float v53 = *(float *)(v10 + 44);
          if (v52 > v53)
          {
            int v54 = *(_DWORD *)(v10 + 36);
            *(_DWORD *)(v10 + 36) = *(_DWORD *)(a2 - 12);
            *(_DWORD *)(a2 - 12) = v54;
            int v55 = *(_DWORD *)(v10 + 40);
            *(_DWORD *)(v10 + 40) = *(_DWORD *)(a2 - 8);
            *(_DWORD *)(a2 - 8) = v55;
            *(float *)(v10 + 44) = v52;
            *(float *)(a2 - 4) = v53;
            float v56 = *(float *)(v10 + 44);
            float v57 = *(float *)(v10 + 32);
            if (v56 > v57)
            {
              int v58 = *(_DWORD *)(v10 + 36);
              int v59 = *(_DWORD *)(v10 + 40);
              uint64_t v60 = *(void *)(v10 + 24);
              *(_DWORD *)(v10 + 24) = v58;
              *(_DWORD *)(v10 + 28) = v59;
              *(void *)(v10 + 36) = v60;
              *(float *)(v10 + 32) = v56;
              *(float *)(v10 + 44) = v57;
              float v61 = *(float *)(v10 + 20);
              if (v56 > v61)
              {
                uint64_t v62 = *(void *)(v10 + 12);
                *(_DWORD *)(v10 + 12) = v58;
                *(_DWORD *)(v10 + 16) = v59;
                *(void *)(v10 + 24) = v62;
                *(float *)(v10 + 20) = v56;
                *(float *)(v10 + 32) = v61;
                float v63 = *(float *)(v10 + 8);
                if (v56 > v63)
                {
                  uint64_t v64 = *(void *)v10;
                  *(_DWORD *)unint64_t v10 = v58;
                  *(_DWORD *)(v10 + 4) = v59;
                  *(void *)(v10 + 12) = v64;
                  *(float *)(v10 + 8) = v56;
                  *(float *)(v10 + 20) = v63;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v11 <= 287) {
      break;
    }
    if (!a3)
    {
      if (v10 == a2) {
        return result;
      }
      int64_t v77 = (v12 - 2) >> 1;
      int64_t v78 = v77;
      do
      {
        int64_t v79 = v78;
        if (v77 >= v78)
        {
          uint64_t v80 = (2 * v78) | 1;
          unint64_t v81 = v10 + 12 * v80;
          if (2 * v79 + 2 < (uint64_t)v12 && *(float *)(v81 + 8) > *(float *)(v81 + 20))
          {
            v81 += 12;
            uint64_t v80 = 2 * v79 + 2;
          }
          unint64_t v82 = v10 + 12 * v79;
          float v83 = *(float *)(v81 + 8);
          float v84 = *(float *)(v82 + 8);
          if (v83 <= v84)
          {
            uint64_t v85 = *(void *)v82;
            do
            {
              unint64_t v86 = v82;
              unint64_t v82 = v81;
              *(_DWORD *)unint64_t v86 = *(_DWORD *)v81;
              *(_DWORD *)(v86 + 4) = *(_DWORD *)(v81 + 4);
              *(float *)(v86 + 8) = v83;
              if (v77 < v80) {
                break;
              }
              uint64_t v87 = 2 * v80;
              uint64_t v80 = (2 * v80) | 1;
              unint64_t v81 = v10 + 12 * v80;
              uint64_t v88 = v87 + 2;
              if (v88 < (uint64_t)v12 && *(float *)(v81 + 8) > *(float *)(v81 + 20))
              {
                v81 += 12;
                uint64_t v80 = v88;
              }
              float v83 = *(float *)(v81 + 8);
            }
            while (v83 <= v84);
            *(void *)unint64_t v82 = v85;
            *(float *)(v82 + 8) = v84;
          }
        }
        int64_t v78 = v79 - 1;
      }
      while (v79);
      int64_t v89 = v11 / 0xCuLL;
      while (2)
      {
        int64_t v90 = 0;
        float v91 = *(float *)v10;
        int v92 = *(_DWORD *)(v10 + 4);
        float v93 = *(float *)(v10 + 8);
        unint64_t v94 = v10;
        do
        {
          uint64_t v95 = (_DWORD *)v94;
          v94 += 12 * v90 + 12;
          uint64_t v96 = 2 * v90;
          uint64_t result = (2 * v90) | 1;
          int64_t v90 = result;
          uint64_t v97 = v96 + 2;
          if (v97 < v89 && *(float *)(v94 + 8) > *(float *)(v94 + 20))
          {
            v94 += 12;
            int64_t v90 = v97;
          }
          *uint64_t v95 = *(_DWORD *)v94;
          v95[1] = *(_DWORD *)(v94 + 4);
          v95[2] = *(_DWORD *)(v94 + 8);
        }
        while (v90 <= (uint64_t)((unint64_t)(v89 - 2) >> 1));
        if (v94 != a2 - 12)
        {
          *(_DWORD *)unint64_t v94 = *(_DWORD *)(a2 - 12);
          *(_DWORD *)(v94 + 4) = *(_DWORD *)(a2 - 8);
          *(_DWORD *)(v94 + 8) = *(_DWORD *)(a2 - 4);
          *(float *)(a2 - 12) = v91;
          *(_DWORD *)(a2 - 8) = v92;
          *(float *)(a2 - 4) = v93;
          uint64_t v98 = v94 - v10 + 12;
          if (v98 >= 13)
          {
            unint64_t v99 = (v98 / 0xCuLL - 2) >> 1;
            unint64_t v100 = v10 + 12 * v99;
            float v101 = *(float *)(v100 + 8);
            float v93 = *(float *)(v94 + 8);
            if (v101 > v93)
            {
              uint64_t v102 = *(void *)v94;
              do
              {
                unint64_t v103 = v94;
                unint64_t v94 = v100;
                *(_DWORD *)unint64_t v103 = *(_DWORD *)v100;
                *(_DWORD *)(v103 + 4) = *(_DWORD *)(v100 + 4);
                *(float *)(v103 + 8) = v101;
                if (!v99) {
                  break;
                }
                unint64_t v99 = (v99 - 1) >> 1;
                unint64_t v100 = v10 + 12 * v99;
                float v101 = *(float *)(v100 + 8);
              }
              while (v101 > v93);
              *(void *)unint64_t v94 = v102;
LABEL_117:
              *(float *)(v94 + 8) = v93;
            }
          }
          a2 -= 12;
          if (v89-- <= 2) {
            return result;
          }
          continue;
        }
        break;
      }
      *(float *)unint64_t v94 = v91;
      *(_DWORD *)(v94 + 4) = v92;
      goto LABEL_117;
    }
    unint64_t v13 = v12 >> 1;
    unint64_t v14 = v10 + 12 * (v12 >> 1);
    if ((unint64_t)v11 >= 0x601)
    {
      sub_1DC36CB4C((float *)v9, (float *)(v9 + 12 * (v12 >> 1)), (float *)(a2 - 12));
      uint64_t v15 = 3 * v13;
      int v16 = (float *)(v9 + 12 * v13 - 12);
      sub_1DC36CB4C((float *)(v9 + 12), v16, (float *)(a2 - 24));
      unint64_t v17 = (float *)(v9 + 12 + 4 * v15);
      sub_1DC36CB4C((float *)(v9 + 24), v17, (float *)(a2 - 36));
      uint64_t result = (uint64_t)sub_1DC36CB4C(v16, (float *)v14, v17);
      uint64_t v18 = *(void *)v9;
      *(void *)unint64_t v9 = *(void *)v14;
      *(void *)unint64_t v14 = v18;
      LODWORD(v18) = *(_DWORD *)(v9 + 8);
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(v14 + 8);
      *(_DWORD *)(v14 + 8) = v18;
    }
    else
    {
      uint64_t result = (uint64_t)sub_1DC36CB4C((float *)(v9 + 12 * (v12 >> 1)), (float *)v9, (float *)(a2 - 12));
    }
    --a3;
    if (a4)
    {
      float v19 = *(float *)(v9 + 8);
LABEL_13:
      uint64_t v20 = *(void *)v9;
      unint64_t v21 = v9;
      do
      {
        unint64_t v22 = v21;
        v21 += 12;
      }
      while (*(float *)(v22 + 20) > v19);
      unint64_t v23 = a2;
      if (v22 == v9)
      {
        unint64_t v26 = a2;
        while (v21 < v26)
        {
          int v24 = (float *)(v26 - 12);
          float v27 = *(float *)(v26 - 4);
          v26 -= 12;
          if (v27 > v19) {
            goto LABEL_23;
          }
        }
        int v24 = (float *)v26;
      }
      else
      {
        do
        {
          int v24 = (float *)(v23 - 12);
          float v25 = *(float *)(v23 - 4);
          v23 -= 12;
        }
        while (v25 <= v19);
      }
LABEL_23:
      unint64_t v10 = v21;
      if (v21 < (unint64_t)v24)
      {
        int v28 = v24;
        do
        {
          float v29 = *(float *)v10;
          *(float *)unint64_t v10 = *v28;
          *int v28 = v29;
          int v30 = *(_DWORD *)(v10 + 4);
          *(float *)(v10 + 4) = v28[1];
          *((_DWORD *)v28 + 1) = v30;
          int v31 = *(_DWORD *)(v10 + 8);
          *(float *)(v10 + 8) = v28[2];
          *((_DWORD *)v28 + 2) = v31;
          do
          {
            float v32 = *(float *)(v10 + 20);
            v10 += 12;
          }
          while (v32 > v19);
          do
          {
            float v33 = *(v28 - 1);
            v28 -= 3;
          }
          while (v33 <= v19);
        }
        while (v10 < (unint64_t)v28);
      }
      if (v10 - 12 != v9)
      {
        *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 12);
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v10 - 8);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 4);
      }
      *(void *)(v10 - 12) = v20;
      *(float *)(v10 - 4) = v19;
      if (v21 < (unint64_t)v24) {
        goto LABEL_34;
      }
      BOOL v34 = sub_1DC36CD38(v9, v10 - 12);
      uint64_t result = sub_1DC36CD38(v10, a2);
      if (result)
      {
        a2 = v10 - 12;
        if (v34) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v34)
      {
LABEL_34:
        uint64_t result = sub_1DC36C2DC(v9, v10 - 12, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      float v19 = *(float *)(v9 + 8);
      if (*(float *)(v9 - 4) > v19) {
        goto LABEL_13;
      }
      if (v19 <= *(float *)(a2 - 4))
      {
        unint64_t v37 = v9 + 12;
        do
        {
          unint64_t v10 = v37;
          if (v37 >= a2) {
            break;
          }
          float v38 = *(float *)(v37 + 8);
          v37 += 12;
        }
        while (v19 <= v38);
      }
      else
      {
        unint64_t v35 = v9;
        do
        {
          unint64_t v10 = v35 + 12;
          float v36 = *(float *)(v35 + 20);
          v35 += 12;
        }
        while (v19 <= v36);
      }
      uint64_t v39 = (float *)a2;
      if (v10 < a2)
      {
        unint64_t v40 = a2;
        do
        {
          uint64_t v39 = (float *)(v40 - 12);
          float v41 = *(float *)(v40 - 4);
          v40 -= 12;
        }
        while (v19 > v41);
      }
      uint64_t v42 = *(void *)v9;
      while (v10 < (unint64_t)v39)
      {
        float v43 = *(float *)v10;
        *(float *)unint64_t v10 = *v39;
        *uint64_t v39 = v43;
        int v44 = *(_DWORD *)(v10 + 4);
        *(float *)(v10 + 4) = v39[1];
        *((_DWORD *)v39 + 1) = v44;
        int v45 = *(_DWORD *)(v10 + 8);
        *(float *)(v10 + 8) = v39[2];
        *((_DWORD *)v39 + 2) = v45;
        do
        {
          float v46 = *(float *)(v10 + 20);
          v10 += 12;
        }
        while (v19 <= v46);
        do
        {
          float v47 = *(v39 - 1);
          v39 -= 3;
        }
        while (v19 > v47);
      }
      BOOL v4 = v10 - 12 >= v9;
      BOOL v5 = v10 - 12 == v9;
      if (v10 - 12 != v9)
      {
        *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 12);
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v10 - 8);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 4);
      }
      a4 = 0;
      *(void *)(v10 - 12) = v42;
      *(float *)(v10 - 4) = v19;
    }
  }
  __int32 v65 = (void *)(v10 + 12);
  BOOL v67 = v10 == a2 || v65 == (void *)a2;
  if (a4)
  {
    if (!v67)
    {
      uint64_t v68 = 0;
      int32x2_t v69 = (void *)v10;
      do
      {
        float v70 = *((float *)v69 + 5);
        float v71 = *((float *)v69 + 2);
        int32x2_t v69 = v65;
        if (v70 > v71)
        {
          uint64_t v72 = *v65;
          uint64_t v73 = v68;
          while (1)
          {
            int v74 = (float *)(v10 + v73);
            int v75 = *(_DWORD *)(v10 + v73 + 4);
            v74[3] = *(float *)(v10 + v73);
            *((_DWORD *)v74 + 4) = v75;
            v74[5] = *(float *)(v10 + v73 + 8);
            if (!v73) {
              break;
            }
            v73 -= 12;
            if (v70 <= *(v74 - 1))
            {
              uint64_t v76 = v10 + v73 + 12;
              goto LABEL_85;
            }
          }
          uint64_t v76 = v10;
LABEL_85:
          *(void *)uint64_t v76 = v72;
          *(float *)(v76 + 8) = v70;
        }
        __int32 v65 = (void *)((char *)v69 + 12);
        v68 += 12;
      }
      while ((void *)((char *)v69 + 12) != (void *)a2);
    }
  }
  else if (!v67)
  {
    int v105 = (_DWORD *)(v10 + 8);
    do
    {
      float v106 = *(float *)(v9 + 20);
      float v107 = *(float *)(v9 + 8);
      unint64_t v9 = (unint64_t)v65;
      if (v106 > v107)
      {
        uint64_t v108 = *v65;
        int v109 = v105;
        do
        {
          int v110 = *(v109 - 1);
          v109[1] = *(v109 - 2);
          v109[2] = v110;
          v109[3] = *v109;
          float v111 = *((float *)v109 - 3);
          v109 -= 3;
        }
        while (v106 > v111);
        *(void *)(v109 + 1) = v108;
        *((float *)v109 + 3) = v106;
      }
      __int32 v65 = (void *)(v9 + 12);
      v105 += 3;
    }
    while (v9 + 12 != a2);
  }
  return result;
}

float *sub_1DC36CB4C(float *result, float *a2, float *a3)
{
  float v3 = a2[2];
  float v4 = result[2];
  float v5 = a3[2];
  if (v3 <= v4)
  {
    if (v5 > v3)
    {
      float v8 = *a2;
      *a2 = *a3;
      *a3 = v8;
      int v9 = *((_DWORD *)a2 + 1);
      a2[1] = a3[1];
      *((_DWORD *)a3 + 1) = v9;
      a2[2] = v5;
      a3[2] = v3;
      float v10 = a2[2];
      float v11 = result[2];
      if (v10 > v11)
      {
        float v12 = *result;
        *uint64_t result = *a2;
        *a2 = v12;
        int v13 = *((_DWORD *)result + 1);
        result[1] = a2[1];
        *((_DWORD *)a2 + 1) = v13;
        result[2] = v10;
        a2[2] = v11;
      }
    }
  }
  else
  {
    float v6 = *result;
    if (v5 <= v3)
    {
      *uint64_t result = *a2;
      *a2 = v6;
      int v14 = *((_DWORD *)result + 1);
      result[1] = a2[1];
      *((_DWORD *)a2 + 1) = v14;
      result[2] = v3;
      a2[2] = v4;
      float v15 = a3[2];
      if (v15 <= v4) {
        return result;
      }
      float v16 = *a2;
      *a2 = *a3;
      *a3 = v16;
      int v17 = *((_DWORD *)a2 + 1);
      a2[1] = a3[1];
      *((_DWORD *)a3 + 1) = v17;
      a2[2] = v15;
    }
    else
    {
      *uint64_t result = *a3;
      *a3 = v6;
      int v7 = *((_DWORD *)result + 1);
      result[1] = a3[1];
      *((_DWORD *)a3 + 1) = v7;
      result[2] = v5;
    }
    a3[2] = v4;
  }
  return result;
}

float *sub_1DC36CC58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_1DC36CB4C((float *)a1, (float *)a2, (float *)a3);
  float v9 = *(float *)(a4 + 8);
  float v10 = *(float *)(a3 + 8);
  if (v9 > v10)
  {
    float v11 = *(float *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(float *)a4 = v11;
    int v12 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(a4 + 4);
    *(_DWORD *)(a4 + 4) = v12;
    *(float *)(a3 + 8) = v9;
    *(float *)(a4 + 8) = v10;
    float v13 = *(float *)(a3 + 8);
    float v14 = *(float *)(a2 + 8);
    if (v13 > v14)
    {
      float v15 = *(float *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(float *)a3 = v15;
      int v16 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a3 + 4) = v16;
      *(float *)(a2 + 8) = v13;
      *(float *)(a3 + 8) = v14;
      float v17 = *(float *)(a2 + 8);
      float v18 = *(float *)(a1 + 8);
      if (v17 > v18)
      {
        float v19 = *(float *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(float *)a2 = v19;
        int v20 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = v20;
        *(float *)(a1 + 8) = v17;
        *(float *)(a2 + 8) = v18;
      }
    }
  }
  return result;
}

BOOL sub_1DC36CD38(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 2;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      float v6 = *(float *)(a2 - 4);
      float v7 = *(float *)(a1 + 8);
      if (v6 > v7)
      {
        float v8 = *(float *)a1;
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 12);
        *(float *)(a2 - 12) = v8;
        int v9 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v9;
        *(float *)(a1 + 8) = v6;
        *(float *)(a2 - 4) = v7;
      }
      return result;
    case 3uLL:
      sub_1DC36CB4C((float *)a1, (float *)(a1 + 12), (float *)(a2 - 12));
      return 1;
    case 4uLL:
      sub_1DC36CC58(a1, a1 + 12, a1 + 24, a2 - 12);
      return 1;
    case 5uLL:
      sub_1DC36CC58(a1, a1 + 12, a1 + 24, a1 + 36);
      float v20 = *(float *)(a2 - 4);
      float v21 = *(float *)(a1 + 44);
      if (v20 > v21)
      {
        int v22 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 - 12);
        *(_DWORD *)(a2 - 12) = v22;
        int v23 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v23;
        *(float *)(a1 + 44) = v20;
        *(float *)(a2 - 4) = v21;
        float v24 = *(float *)(a1 + 44);
        float v25 = *(float *)(a1 + 32);
        if (v24 > v25)
        {
          int v26 = *(_DWORD *)(a1 + 36);
          int v27 = *(_DWORD *)(a1 + 40);
          uint64_t v28 = *(void *)(a1 + 24);
          *(_DWORD *)(a1 + 24) = v26;
          *(_DWORD *)(a1 + 28) = v27;
          *(void *)(a1 + 36) = v28;
          *(float *)(a1 + 32) = v24;
          *(float *)(a1 + 44) = v25;
          float v29 = *(float *)(a1 + 20);
          if (v24 > v29)
          {
            uint64_t v30 = *(void *)(a1 + 12);
            *(_DWORD *)(a1 + 12) = v26;
            *(_DWORD *)(a1 + 16) = v27;
            *(void *)(a1 + 24) = v30;
            *(float *)(a1 + 20) = v24;
            *(float *)(a1 + 32) = v29;
            float v31 = *(float *)(a1 + 8);
            if (v24 > v31)
            {
              uint64_t v32 = *(void *)a1;
              *(_DWORD *)a1 = v26;
              *(_DWORD *)(a1 + 4) = v27;
              *(void *)(a1 + 12) = v32;
              *(float *)(a1 + 8) = v24;
              *(float *)(a1 + 20) = v31;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v10 = a1 + 24;
      sub_1DC36CB4C((float *)a1, (float *)(a1 + 12), (float *)(a1 + 24));
      uint64_t v11 = a1 + 36;
      if (a1 + 36 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    float v14 = *(float *)(v11 + 8);
    if (v14 > *(float *)(v10 + 8))
    {
      uint64_t v15 = *(void *)v11;
      uint64_t v16 = v12;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        int v18 = *(_DWORD *)(a1 + v16 + 28);
        *(_DWORD *)(v17 + 36) = *(_DWORD *)(a1 + v16 + 24);
        *(_DWORD *)(v17 + 40) = v18;
        *(_DWORD *)(v17 + 44) = *(_DWORD *)(a1 + v16 + 32);
        if (v16 == -24) {
          break;
        }
        v16 -= 12;
        if (v14 <= *(float *)(v17 + 20))
        {
          uint64_t v19 = a1 + v16 + 36;
          goto LABEL_13;
        }
      }
      uint64_t v19 = a1;
LABEL_13:
      *(void *)uint64_t v19 = v15;
      *(float *)(v19 + 8) = v14;
      if (++v13 == 8) {
        return v11 + 12 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 12;
    v11 += 12;
    if (v11 == a2) {
      return 1;
    }
  }
}

uint64_t sub_1DC36CF98(uint64_t a1, atomic_uint **a2)
{
  uint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  uint64_t v6 = a1 + 16;
  uint64_t v7 = *(void *)(a1 + 16) - *(void *)a1;
  if (v7 >> 2 > v3) {
    unint64_t v3 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v3;
  }
  uint64_t v18 = v6;
  if (v8) {
    unint64_t v8 = (unint64_t)sub_1DC2FFD7C(v8);
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = (atomic_uint **)(v8 + 8 * v2);
  v15[0] = v8;
  v15[1] = v10;
  uint64_t v16 = v10;
  unint64_t v17 = v8 + 8 * v9;
  uint64_t v11 = *a2;
  *uint64_t v10 = 0;
  uint64_t v12 = v10;
  if (v11)
  {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    uint64_t v12 = v10;
    if (*v10)
    {
      sub_1DC2FF57C(*v10);
      uint64_t v12 = v16;
    }
  }
  *uint64_t v10 = v11;
  uint64_t v16 = v12 + 1;
  sub_1DC3206A4((atomic_uint *)a1, v15);
  uint64_t v13 = *(void *)(a1 + 8);
  sub_1DC32079C((uint64_t)v15);
  return v13;
}

void sub_1DC36D08C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC32079C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC36D0A0(uint64_t result)
{
  float v1 = *(float *)(result + 28) * *(float *)(result + 24);
  int v2 = *(_DWORD *)(result + 124);
  float v3 = (float)*(int *)(result + 120);
  int v4 = (int)fmaxf(v3 - v1, 0.0);
  unint64_t v5 = *(void *)(result + 48);
  float v6 = v1 + v3;
  if (v6 >= (float)((float)*(unint64_t *)(result + 40) + -1.0)) {
    float v6 = (float)*(unint64_t *)(result + 40) + -1.0;
  }
  *(_DWORD *)(result + 128) = v4;
  *(_DWORD *)(result + 132) = (int)v6;
  int v7 = (int)fmaxf((float)v2 - v1, 0.0);
  float v8 = v1 + (float)v2;
  if (v8 >= (float)((float)v5 + -1.0)) {
    float v8 = (float)v5 + -1.0;
  }
  *(_DWORD *)(result + 136) = v7;
  *(_DWORD *)(result + 140) = (int)v8;
  return result;
}

unint64_t sub_1DC36D114(unint64_t result, int32x4_t *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  uint64_t v10 = a2 - 1;
  uint64_t v11 = (int32x4_t *)v9;
  while (1)
  {
    unint64_t v9 = (unint64_t)v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    unint64_t v13 = a2 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          int32x4_t v71 = *v11;
          if (vmovn_s32(vcgtq_s32(*v11, *v10)).i32[1])
          {
            *uint64_t v11 = *v10;
            *uint64_t v10 = v71;
          }
          return result;
        case 3uLL:
          int32x4_t v72 = *v11;
          int32x4_t v73 = v11[1];
          int32x4_t v74 = *v10;
          __int8 v75 = vmovn_s32(vcgtq_s32(v73, *v10)).i8[4];
          if ((vmovn_s32(vcgtq_s32(*v11, v73)).i32[1] & 1) == 0)
          {
            if ((v75 & 1) == 0) {
              return result;
            }
            v11[1] = v74;
            *uint64_t v10 = v73;
            int32x4_t v117 = v11[1];
            goto LABEL_182;
          }
          if (v75)
          {
            *uint64_t v11 = v74;
          }
          else
          {
            *uint64_t v11 = v73;
            v11[1] = v72;
            if ((vmovn_s32(vcgtq_s32(v72, *v10)).i32[1] & 1) == 0) {
              return result;
            }
            v11[1] = *v10;
          }
          *uint64_t v10 = v72;
          return result;
        case 4uLL:
          uint64_t v76 = v11 + 1;
          int32x4_t v77 = v11[1];
          int64_t v78 = v11 + 2;
          int32x4_t v79 = v11[2];
          int32x4_t v80 = *v11;
          __int8 v81 = vmovn_s32(vcgtq_s32(v77, v79)).i8[4];
          if (vmovn_s32(vcgtq_s32(*v11, v77)).i32[1])
          {
            if (v81)
            {
              *uint64_t v11 = v79;
            }
            else
            {
              *uint64_t v11 = v77;
              v11[1] = v80;
              if ((vmovn_s32(vcgtq_s32(v80, v79)).i32[1] & 1) == 0) {
                goto LABEL_179;
              }
              *uint64_t v76 = v79;
            }
            double v118 = v11 + 2;
            int32x4_t v77 = v80;
          }
          else
          {
            if ((v81 & 1) == 0) {
              goto LABEL_179;
            }
            *uint64_t v76 = v79;
            *int64_t v78 = v77;
            if ((vmovn_s32(vcgtq_s32(v80, v79)).i32[1] & 1) == 0)
            {
LABEL_178:
              int32x4_t v79 = v77;
LABEL_179:
              if (vmovn_s32(vcgtq_s32(v79, *v10)).i32[1])
              {
                *int64_t v78 = *v10;
                *uint64_t v10 = v79;
                int32x4_t v117 = *v78;
                int32x4_t v123 = *v76;
                if (vmovn_s32(vcgtq_s32(*v76, *v78)).i32[1])
                {
                  v11[1] = v117;
                  int v11[2] = v123;
LABEL_182:
                  int32x4_t v124 = *v11;
                  if (vmovn_s32(vcgtq_s32(*v11, v117)).i32[1])
                  {
                    *uint64_t v11 = v117;
                    v11[1] = v124;
                  }
                }
              }
              return result;
            }
            *uint64_t v11 = v79;
            double v118 = v11 + 1;
          }
          int32x4_t *v118 = v80;
          goto LABEL_178;
        case 5uLL:
          return (unint64_t)sub_1DC36DAFC(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 383) {
      break;
    }
    if (!a3)
    {
      if (v11 != a2)
      {
        int64_t v92 = (v13 - 2) >> 1;
        int64_t v93 = v92;
        do
        {
          int64_t v94 = v93;
          if (v92 >= v93)
          {
            uint64_t v95 = (2 * v93) | 1;
            uint64_t v96 = &v11[v95];
            if (2 * v94 + 2 < (uint64_t)v13)
            {
              BOOL v97 = v96->i32[2] < v96[1].i32[2];
              v96 += v97;
              if (v97) {
                uint64_t v95 = 2 * v94 + 2;
              }
            }
            uint64_t v98 = &v11[v94];
            int32x4_t v99 = *v98;
            int v100 = v98->i64[1];
            if (v96->i32[2] >= v100)
            {
              do
              {
                float v101 = v96;
                *uint64_t v98 = *v96;
                if (v92 < v95) {
                  break;
                }
                uint64_t v102 = (2 * v95) | 1;
                uint64_t v96 = &v11[v102];
                uint64_t v103 = 2 * v95 + 2;
                if (v103 < (uint64_t)v13)
                {
                  BOOL v97 = v96->i32[2] < v96[1].i32[2];
                  v96 += v97;
                  if (v97) {
                    uint64_t v102 = v103;
                  }
                }
                BOOL result = v96->u32[2];
                uint64_t v98 = v101;
                uint64_t v95 = v102;
              }
              while ((int)result >= v100);
              *float v101 = v99;
            }
          }
          int64_t v93 = v94 - 1;
        }
        while (v94);
        uint64_t v104 = (unint64_t)v12 >> 4;
        do
        {
          uint64_t v105 = 0;
          int32x4_t v106 = *v11;
          float v107 = v11;
          do
          {
            uint64_t v108 = (uint64_t)&v107[v105 + 1];
            uint64_t v109 = (2 * v105) | 1;
            uint64_t v110 = 2 * v105 + 2;
            if (v110 < v104)
            {
              BOOL v97 = *(_DWORD *)(v108 + 8) < *(_DWORD *)(v108 + 24);
              v108 += 16 * v97;
              if (v97) {
                uint64_t v109 = v110;
              }
            }
            _OWORD *v107 = *(_OWORD *)v108;
            float v107 = (_OWORD *)v108;
            uint64_t v105 = v109;
          }
          while (v109 <= (uint64_t)((unint64_t)(v104 - 2) >> 1));
          if ((int32x4_t *)v108 == --a2)
          {
            *(int32x4_t *)uint64_t v108 = v106;
          }
          else
          {
            *(int32x4_t *)uint64_t v108 = *a2;
            *a2 = v106;
            uint64_t v111 = v108 - (void)v11 + 16;
            if (v111 >= 17)
            {
              unint64_t v112 = (((unint64_t)v111 >> 4) - 2) >> 1;
              unsigned int v113 = &v11[v112];
              int32x4_t v114 = *(int32x4_t *)v108;
              __int32 v115 = *(void *)(v108 + 8);
              if (v113->i32[2] < v115)
              {
                do
                {
                  uint64_t v116 = v113;
                  *(int32x4_t *)uint64_t v108 = *v113;
                  if (!v112) {
                    break;
                  }
                  unint64_t v112 = (v112 - 1) >> 1;
                  unsigned int v113 = &v11[v112];
                  uint64_t v108 = (uint64_t)v116;
                }
                while (v113->i32[2] < v115);
                *uint64_t v116 = v114;
              }
            }
          }
          BOOL v97 = v104-- <= 2;
        }
        while (!v97);
      }
      return result;
    }
    unint64_t v14 = v13 >> 1;
    uint64_t v15 = &v11[v13 >> 1];
    int32x4_t v16 = *v10;
    if ((unint64_t)v12 >= 0x801)
    {
      int32x4_t v17 = *v15;
      int32x4_t v18 = *v11;
      __int8 v19 = vmovn_s32(vcgtq_s32(*v15, v16)).i8[4];
      if (vmovn_s32(vcgtq_s32(*v11, *v15)).i32[1])
      {
        if (v19)
        {
          *uint64_t v11 = v16;
          goto LABEL_22;
        }
        *uint64_t v11 = v17;
        *uint64_t v15 = v18;
        if (vmovn_s32(vcgtq_s32(v18, *v10)).i32[1])
        {
          *uint64_t v15 = *v10;
LABEL_22:
          *uint64_t v10 = v18;
        }
      }
      else if (v19)
      {
        *uint64_t v15 = v16;
        *uint64_t v10 = v17;
        int32x4_t v23 = *v11;
        if (vmovn_s32(vcgtq_s32(*v11, *v15)).i32[1])
        {
          *uint64_t v11 = *v15;
          *uint64_t v15 = v23;
        }
      }
      unint64_t v25 = v14 - 1;
      int32x4_t v26 = v11[v14 - 1];
      int32x4_t v27 = v11[1];
      int32x4_t v28 = a2[-2];
      __int8 v29 = vmovn_s32(vcgtq_s32(v26, v28)).i8[4];
      if (vmovn_s32(vcgtq_s32(v27, v26)).i32[1])
      {
        if (v29)
        {
          v11[1] = v28;
          goto LABEL_34;
        }
        v11[1] = v26;
        v11[v25] = v27;
        int32x4_t v32 = a2[-2];
        if (vmovn_s32(vcgtq_s32(v27, v32)).i32[1])
        {
          v11[v25] = v32;
LABEL_34:
          a2[-2] = v27;
        }
      }
      else if (v29)
      {
        v11[v25] = v28;
        a2[-2] = v26;
        int32x4_t v30 = v11[v25];
        int32x4_t v31 = v11[1];
        if (vmovn_s32(vcgtq_s32(v31, v30)).i32[1])
        {
          v11[1] = v30;
          v11[v25] = v31;
        }
      }
      float v33 = &v11[v14];
      int32x4_t v35 = v33[1];
      BOOL v34 = v33 + 1;
      int32x4_t v36 = v35;
      int32x4_t v37 = v11[2];
      int32x4_t v38 = a2[-3];
      __int8 v39 = vmovn_s32(vcgtq_s32(v35, v38)).i8[4];
      if (vmovn_s32(vcgtq_s32(v37, v35)).i32[1])
      {
        if (v39)
        {
          int v11[2] = v38;
          goto LABEL_43;
        }
        int v11[2] = v36;
        int32x4_t *v34 = v37;
        int32x4_t v41 = a2[-3];
        if (vmovn_s32(vcgtq_s32(v37, v41)).i32[1])
        {
          int32x4_t *v34 = v41;
LABEL_43:
          a2[-3] = v37;
        }
      }
      else if (v39)
      {
        int32x4_t *v34 = v38;
        a2[-3] = v36;
        int32x4_t v40 = v11[2];
        if (vmovn_s32(vcgtq_s32(v40, *v34)).i32[1])
        {
          int v11[2] = *v34;
          int32x4_t *v34 = v40;
        }
      }
      int32x4_t v42 = *v15;
      int32x4_t v43 = v11[v25];
      int32x4_t v44 = *v34;
      __int8 v45 = vmovn_s32(vcgtq_s32(*v15, *v34)).i8[4];
      if (vmovn_s32(vcgtq_s32(v43, *v15)).i32[1])
      {
        if (v45)
        {
          v11[v25] = v44;
          goto LABEL_52;
        }
        v11[v25] = v42;
        *uint64_t v15 = v43;
        if (vmovn_s32(vcgtq_s32(v43, v44)).i32[1])
        {
          *uint64_t v15 = v44;
          int32x4_t v42 = v44;
LABEL_52:
          int32x4_t *v34 = v43;
        }
        else
        {
          int32x4_t v42 = v43;
        }
      }
      else if (v45)
      {
        *uint64_t v15 = v44;
        int32x4_t *v34 = v42;
        if (vmovn_s32(vcgtq_s32(v43, v44)).i32[1])
        {
          v11[v25] = v44;
          BOOL v34 = &v11[v13 >> 1];
          int32x4_t v42 = v43;
          goto LABEL_52;
        }
        int32x4_t v42 = v44;
      }
      int32x4_t v46 = *v11;
      *uint64_t v11 = v42;
      *uint64_t v15 = v46;
      goto LABEL_54;
    }
    int32x4_t v20 = *v11;
    int32x4_t v21 = *v15;
    __int8 v22 = vmovn_s32(vcgtq_s32(*v11, v16)).i8[4];
    if ((vmovn_s32(vcgtq_s32(*v15, *v11)).i32[1] & 1) == 0)
    {
      if (v22)
      {
        *uint64_t v11 = v16;
        *uint64_t v10 = v20;
        int32x4_t v24 = *v15;
        if (vmovn_s32(vcgtq_s32(*v15, *v11)).i32[1])
        {
          *uint64_t v15 = *v11;
          *uint64_t v11 = v24;
        }
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *uint64_t v15 = v16;
LABEL_31:
      *uint64_t v10 = v21;
      goto LABEL_54;
    }
    *uint64_t v15 = v20;
    *uint64_t v11 = v21;
    if (vmovn_s32(vcgtq_s32(v21, *v10)).i32[1])
    {
      *uint64_t v11 = *v10;
      goto LABEL_31;
    }
LABEL_54:
    --a3;
    if (a4)
    {
      int32x4_t v47 = *v11;
LABEL_57:
      float v48 = v11;
      do
        float v49 = v48++;
      while (v49[1].i32[2] < v47.i32[2]);
      float v50 = a2;
      if (v49 == v11)
      {
        float v53 = a2;
        while (v48 < v53)
        {
          int v51 = v53 - 1;
          int v54 = v53[-1].i32[2];
          --v53;
          if (v54 < v47.i32[2]) {
            goto LABEL_66;
          }
        }
        int v51 = v53;
      }
      else
      {
        do
        {
          int v51 = v50 - 1;
          int v52 = v50[-1].i32[2];
          --v50;
        }
        while (v52 >= v47.i32[2]);
      }
LABEL_66:
      if (v48 < v51)
      {
        int v55 = v48;
        float v56 = v51;
        do
        {
          int32x4_t v57 = *v55;
          int32x4_t *v55 = *v56;
          *float v56 = v57;
          do
            float v49 = v55++;
          while (v49[1].i32[2] < v47.i32[2]);
          do
          {
            int v58 = v56[-1].i32[2];
            --v56;
          }
          while (v58 >= v47.i32[2]);
        }
        while (v55 < v56);
      }
      if (v49 != v11) {
        *uint64_t v11 = *v49;
      }
      *float v49 = v47;
      if (v48 < v51) {
        goto LABEL_77;
      }
      BOOL v59 = sub_1DC36DC74(v11, v49);
      uint64_t v11 = v49 + 1;
      BOOL result = sub_1DC36DC74(v49 + 1, a2);
      if (result)
      {
        a2 = v49;
        if (v59) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v59)
      {
LABEL_77:
        BOOL result = sub_1DC36D114(v9, v49, a3, a4 & 1);
        a4 = 0;
        uint64_t v11 = v49 + 1;
      }
    }
    else
    {
      int32x4_t v47 = *v11;
      if (v11[-1].i32[2] < v11->i32[2]) {
        goto LABEL_57;
      }
      if (v47.i32[2] < a2[-1].i32[2])
      {
        uint64_t v60 = v11;
        do
        {
          uint64_t v11 = v60 + 1;
          int v61 = v60[1].i32[2];
          ++v60;
        }
        while (v47.i32[2] >= v61);
      }
      else
      {
        uint64_t v62 = v11 + 1;
        do
        {
          uint64_t v11 = v62;
          if (v62 >= a2) {
            break;
          }
          int v63 = v62->i32[2];
          ++v62;
        }
        while (v47.i32[2] >= v63);
      }
      uint64_t v64 = a2;
      if (v11 < a2)
      {
        __int32 v65 = a2;
        do
        {
          uint64_t v64 = v65 - 1;
          int v66 = v65[-1].i32[2];
          --v65;
        }
        while (v47.i32[2] < v66);
      }
      while (v11 < v64)
      {
        int32x4_t v67 = *v11;
        *uint64_t v11 = *v64;
        *uint64_t v64 = v67;
        do
        {
          int v68 = v11[1].i32[2];
          ++v11;
        }
        while (v47.i32[2] >= v68);
        do
        {
          int v69 = v64[-1].i32[2];
          --v64;
        }
        while (v47.i32[2] < v69);
      }
      float v70 = v11 - 1;
      BOOL v4 = (unint64_t)&v11[-1] >= v9;
      BOOL v5 = &v11[-1] == (int32x4_t *)v9;
      if (&v11[-1] != (int32x4_t *)v9) {
        *(int32x4_t *)unint64_t v9 = *v70;
      }
      a4 = 0;
      *float v70 = v47;
    }
  }
  unint64_t v82 = v11 + 1;
  BOOL v84 = v11 == a2 || v82 == a2;
  if (a4)
  {
    if (!v84)
    {
      uint64_t v85 = 0;
      unint64_t v86 = v11;
      do
      {
        int32x4_t v87 = v86[1];
        int v88 = v86->i32[2];
        unint64_t v86 = v82;
        if (v87.i32[2] < v88)
        {
          uint64_t v89 = v85;
          while (1)
          {
            *(int32x4_t *)((char *)&v11[1] + v89) = *(int32x4_t *)((char *)v11 + v89);
            if (!v89) {
              break;
            }
            int v90 = *(__int32 *)((char *)&v11->i32[-2] + v89);
            v89 -= 16;
            if (v87.i32[2] >= v90)
            {
              float v91 = (int32x4_t *)((char *)v11 + v89 + 16);
              goto LABEL_127;
            }
          }
          float v91 = v11;
LABEL_127:
          *float v91 = v87;
        }
        unint64_t v82 = v86 + 1;
        v85 += 16;
      }
      while (&v86[1] != a2);
    }
  }
  else if (!v84)
  {
    do
    {
      int32x4_t v119 = *(int32x4_t *)(v9 + 16);
      int v120 = *(_DWORD *)(v9 + 8);
      unint64_t v9 = (unint64_t)v82;
      if (v119.i32[2] < v120)
      {
        do
        {
          double v121 = v82;
          int32x4_t v122 = v82[-1];
          --v82;
          *double v121 = v122;
        }
        while (v119.i32[2] < v121[-2].i32[2]);
        *unint64_t v82 = v119;
      }
      unint64_t v82 = (int32x4_t *)(v9 + 16);
    }
    while ((int32x4_t *)(v9 + 16) != a2);
  }
  return result;
}

int32x4_t *sub_1DC36DAFC(int32x4_t *result, int32x4_t *a2, int32x4_t *a3, int32x4_t *a4, int32x4_t *a5)
{
  int32x4_t v5 = *a2;
  int32x4_t v6 = *result;
  int32x4_t v7 = *a3;
  __int8 v8 = vmovn_s32(vcgtq_s32(*a2, *a3)).i8[4];
  if (vmovn_s32(vcgtq_s32(*result, *a2)).i32[1])
  {
    if (v8)
    {
      *BOOL result = v7;
LABEL_9:
      *a3 = v6;
      int32x4_t v5 = v6;
      goto LABEL_11;
    }
    *BOOL result = v5;
    *a2 = v6;
    int32x4_t v5 = *a3;
    if (vmovn_s32(vcgtq_s32(v6, *a3)).i32[1])
    {
      *a2 = v5;
      goto LABEL_9;
    }
  }
  else if (v8)
  {
    *a2 = v7;
    *a3 = v5;
    int32x4_t v9 = *result;
    if (vmovn_s32(vcgtq_s32(*result, *a2)).i32[1])
    {
      *BOOL result = *a2;
      *a2 = v9;
      int32x4_t v5 = *a3;
    }
  }
  else
  {
    int32x4_t v5 = *a3;
  }
LABEL_11:
  if (vmovn_s32(vcgtq_s32(v5, *a4)).i32[1])
  {
    *a3 = *a4;
    *a4 = v5;
    int32x4_t v10 = *a2;
    if (vmovn_s32(vcgtq_s32(*a2, *a3)).i32[1])
    {
      *a2 = *a3;
      *a3 = v10;
      int32x4_t v11 = *result;
      if (vmovn_s32(vcgtq_s32(*result, *a2)).i32[1])
      {
        *BOOL result = *a2;
        *a2 = v11;
      }
    }
  }
  int32x4_t v12 = *a4;
  if (vmovn_s32(vcgtq_s32(*a4, *a5)).i32[1])
  {
    *a4 = *a5;
    *a5 = v12;
    int32x4_t v13 = *a3;
    if (vmovn_s32(vcgtq_s32(*a3, *a4)).i32[1])
    {
      *a3 = *a4;
      *a4 = v13;
      int32x4_t v14 = *a2;
      if (vmovn_s32(vcgtq_s32(*a2, *a3)).i32[1])
      {
        *a2 = *a3;
        *a3 = v14;
        int32x4_t v15 = *result;
        if (vmovn_s32(vcgtq_s32(*result, *a2)).i32[1])
        {
          *BOOL result = *a2;
          *a2 = v15;
        }
      }
    }
  }
  return result;
}

BOOL sub_1DC36DC74(int32x4_t *a1, int32x4_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      int32x4_t v3 = a2[-1];
      int32x4_t v4 = *a1;
      if (vmovn_s32(vcgtq_s32(*a1, v3)).i32[1])
      {
        *a1 = v3;
        a2[-1] = v4;
      }
      return 1;
    case 3:
      int32x4_t v11 = *a1;
      int32x4_t v12 = a1[1];
      int32x4_t v13 = a2[-1];
      __int8 v14 = vmovn_s32(vcgtq_s32(v12, v13)).i8[4];
      if ((vmovn_s32(vcgtq_s32(*a1, v12)).i32[1] & 1) == 0)
      {
        if ((v14 & 1) == 0) {
          return 1;
        }
        a1[1] = v13;
        a2[-1] = v12;
        int32x4_t v21 = a1[1];
        goto LABEL_48;
      }
      if (v14)
      {
        *a1 = v13;
      }
      else
      {
        *a1 = v12;
        a1[1] = v11;
        int32x4_t v31 = a2[-1];
        if ((vmovn_s32(vcgtq_s32(v11, v31)).i32[1] & 1) == 0) {
          return 1;
        }
        a1[1] = v31;
      }
      a2[-1] = v11;
      return 1;
    case 4:
      int32x4_t v15 = a1 + 1;
      int32x4_t v16 = a1[1];
      int32x4_t v17 = a1 + 2;
      int32x4_t v18 = a1[2];
      int32x4_t v19 = *a1;
      __int8 v20 = vmovn_s32(vcgtq_s32(v16, v18)).i8[4];
      if (vmovn_s32(vcgtq_s32(*a1, v16)).i32[1])
      {
        if (v20)
        {
          *a1 = v18;
        }
        else
        {
          *a1 = v16;
          a1[1] = v19;
          if ((vmovn_s32(vcgtq_s32(v19, v18)).i32[1] & 1) == 0) {
            goto LABEL_45;
          }
          *int32x4_t v15 = v18;
        }
        __int8 v22 = a1 + 2;
        int32x4_t v16 = v19;
        goto LABEL_43;
      }
      if ((v20 & 1) == 0) {
        goto LABEL_45;
      }
      *int32x4_t v15 = v18;
      *int32x4_t v17 = v16;
      if (vmovn_s32(vcgtq_s32(v19, v18)).i32[1])
      {
        *a1 = v18;
        __int8 v22 = a1 + 1;
LABEL_43:
        *__int8 v22 = v19;
      }
      int32x4_t v18 = v16;
LABEL_45:
      int32x4_t v32 = a2[-1];
      if (vmovn_s32(vcgtq_s32(v18, v32)).i32[1])
      {
        *int32x4_t v17 = v32;
        a2[-1] = v18;
        int32x4_t v21 = *v17;
        int32x4_t v33 = *v15;
        if (vmovn_s32(vcgtq_s32(*v15, *v17)).i32[1])
        {
          a1[1] = v21;
          a1[2] = v33;
LABEL_48:
          int32x4_t v34 = *a1;
          if (vmovn_s32(vcgtq_s32(*a1, v21)).i32[1])
          {
            *a1 = v21;
            a1[1] = v34;
          }
        }
      }
      return 1;
    case 5:
      sub_1DC36DAFC(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      int32x4_t v5 = a1 + 2;
      int32x4_t v6 = a1[2];
      int32x4_t v7 = a1 + 1;
      int32x4_t v8 = a1[1];
      int32x4_t v9 = *a1;
      __int8 v10 = vmovn_s32(vcgtq_s32(v8, v6)).i8[4];
      if (vmovn_s32(vcgtq_s32(*a1, v8)).i32[1])
      {
        if (v10)
        {
          *a1 = v6;
        }
        else
        {
          *a1 = v8;
          a1[1] = v9;
          if ((vmovn_s32(vcgtq_s32(v9, v6)).i32[1] & 1) == 0) {
            goto LABEL_26;
          }
          int32x4_t *v7 = v6;
        }
        int32x4_t v7 = a1 + 2;
        goto LABEL_25;
      }
      if (v10)
      {
        int32x4_t *v7 = v6;
        *int32x4_t v5 = v8;
        if (vmovn_s32(vcgtq_s32(v9, v6)).i32[1])
        {
          *a1 = v6;
LABEL_25:
          int32x4_t *v7 = v9;
        }
      }
LABEL_26:
      int32x4_t v23 = a1 + 3;
      if (&a1[3] == a2) {
        return 1;
      }
      uint64_t v24 = 0;
      int v25 = 0;
      while (1)
      {
        int32x4_t v26 = *v23;
        __int32 v27 = v23->i64[1];
        if (v27 < v5->i32[2])
        {
          uint64_t v28 = v24;
          while (1)
          {
            *(int32x4_t *)((char *)&a1[3] + v28) = *(int32x4_t *)((char *)&a1[2] + v28);
            if (v28 == -32) {
              break;
            }
            __int32 v29 = *(__int32 *)((char *)&a1[1].i32[2] + v28);
            v28 -= 16;
            if (v27 >= v29)
            {
              int32x4_t v30 = (int32x4_t *)((char *)a1 + v28 + 48);
              goto LABEL_34;
            }
          }
          int32x4_t v30 = a1;
LABEL_34:
          *int32x4_t v30 = v26;
          if (++v25 == 8) {
            return &v23[1] == a2;
          }
        }
        int32x4_t v5 = v23;
        v24 += 16;
        if (++v23 == a2) {
          return 1;
        }
      }
  }
}

uint64_t sub_1DC36DF7C(uint64_t a1, int a2, __n128 a3, int32x2_t a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 128;
  if (a4.i32[0] > 0) {
    uint64_t v5 = 132;
  }
  uint64_t v6 = 136;
  if (a4.i32[1] > 0) {
    uint64_t v6 = 140;
  }
  if (a2 >= 1)
  {
    int v7 = *(_DWORD *)(a1 + v5);
    int v8 = *(_DWORD *)(a1 + v6);
    BOOL v9 = a3.n128_u32[0] == v7 || a3.n128_u32[1] == v8;
    __n128 v27 = a3;
    if (!v9)
    {
      int32x4_t v11 = *(unsigned __int8 **)(a1 + 32);
      int32x4_t v12 = (void *)*((void *)v11 + 3);
      int v13 = sub_1DC2FF924(v12, a3.n128_i32[0], a3.n128_i32[1]);
      LODWORD(v4) = 0;
      int v14 = *v11;
      BOOL v15 = v14 != v13;
      int v16 = 1;
      do
      {
        v17.n128_u64[1] = v27.n128_u64[1];
        v17.n128_u64[0] = (unint64_t)vadd_s32((int32x2_t)v27.n128_u64[0], a4);
        uint64_t v4 = (v4 + 1);
        unsigned __int32 v18 = v17.n128_u32[0];
        unsigned __int32 v19 = v17.n128_u32[1];
        __n128 v27 = v17;
        BOOL v20 = v14 != sub_1DC2FF924(v12, v17.n128_i32[0], v17.n128_i32[1]);
        int v21 = (v15 ^ v20) & 1;
        if ((v15 ^ v20)) {
          BOOL v15 = v20;
        }
        v16 -= v21;
        if (v16) {
          BOOL v22 = (int)v4 < a2;
        }
        else {
          BOOL v22 = 0;
        }
      }
      while (v22 && v18 != v7 && v19 != v8);
    }
  }
  return v4;
}

uint64_t sub_1DC36E09C(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4 = 128;
  if (a3 > 0) {
    uint64_t v4 = 132;
  }
  int v5 = *(_DWORD *)(a1 + v4);
  uint64_t v6 = 136;
  if (a4 > 0) {
    uint64_t v6 = 140;
  }
  int v7 = *(_DWORD *)(a1 + v6);
  int v8 = *(_DWORD *)(a1 + 124);
  uint64_t v9 = *(int *)(a1 + 120);
  if (v9 == v5 || v8 == v7)
  {
LABEL_24:
    uint64_t result = 0;
    *(void *)a2 = -1;
    return result;
  }
  uint64_t v11 = v8;
  int32x4_t v12 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v28 = (void *)*((void *)v12 + 3);
  int v13 = sub_1DC2FF924(v28, v9, v8);
  int v14 = 0;
  int v15 = 0;
  int v26 = *v12;
  int v27 = *(unsigned __int8 *)(a1 + 13);
  BOOL v16 = v27 == (v26 != v13);
  int v17 = v5 - (v9 + a3);
  int v18 = v7 - (v11 + a4);
  while (1)
  {
    BOOL v19 = v16;
    int v20 = v18;
    BOOL v16 = v27 == (v26 != sub_1DC2FF924(v28, v9 + a3, v11 + a4));
    if ((v19 ^ v16)) {
      int v21 = 0;
    }
    else {
      int v21 = v14;
    }
    if ((v19 ^ v16)) {
      BOOL v22 = v16;
    }
    else {
      BOOL v22 = v19;
    }
    if (!v19 || ((v19 ^ v16) & 1) == 0)
    {
      BOOL v16 = v22;
      if (!v17) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
    if (v14 >= *(_DWORD *)(a1 + 20) && ++v15 == *(_DWORD *)(a1 + 16)) {
      break;
    }
    int v21 = 0;
    if (!v17) {
      goto LABEL_24;
    }
LABEL_23:
    int v14 = v21 + 1;
    v17 -= a3;
    int v18 = v20 - a4;
    v9 += a3;
    v11 += a4;
    if (!v20) {
      goto LABEL_24;
    }
  }
  *(_DWORD *)a2 = v9;
  *(_DWORD *)(a2 + 4) = v11;
  return 1;
}

uint64_t sub_1DC36E24C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 1);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = a1 + 72;
  uint64_t v5 = a1 + 80;
  int v6 = -v2;
  int v7 = sub_1DC36E09C(a1, a1 + 56, -1, -v2);
  LODWORD(v3) = sub_1DC36E09C(a1, v3, v2, -1);
  int v8 = v3 + sub_1DC36E09C(a1, v4, 1, v2) + v7;
  return v8 + sub_1DC36E09C(a1, v5, v6, 1);
}

uint64_t sub_1DC36E2F8(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v4 = *a2;
  int v5 = v4 + a3;
  if (*(_DWORD *)(a1 + 128) > (int)v4 + a3) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v9 = a4;
  uint64_t v10 = a3;
  do
  {
    if (v5 > *(_DWORD *)(a1 + 132)) {
      break;
    }
    uint64_t v11 = *(unsigned __int8 **)(a1 + 32);
    uint64_t v12 = a2[1];
    int v13 = (void *)*((void *)v11 + 3);
    int v14 = sub_1DC2FF924(v13, v5, v12);
    int v15 = *v11;
    int v16 = *(unsigned __int8 *)(a1 + 13);
    if (v16 != (v15 != v14)) {
      break;
    }
    v4 += v10;
    *a2 = v4;
    uint64_t v6 = (v6 + 1);
    if (*(_DWORD *)(a1 + 136) <= (int)v12 + a4)
    {
      uint64_t v17 = v9 + v12;
      do
      {
        if ((int)v17 > *(_DWORD *)(a1 + 140)) {
          break;
        }
        if (v16 != (v15 != sub_1DC2FF924(v13, v4, (int)v17))) {
          break;
        }
        a2[1] = v17;
        uint64_t v6 = (v6 + 1);
        v17 += v9;
      }
      while (v17 >= *(int *)(a1 + 136));
    }
    int v5 = v4 + v10;
  }
  while (v4 + v10 >= *(int *)(a1 + 128));
  return v6;
}

uint64_t sub_1DC36E430(uint64_t a1, int *a2, int a3, int a4)
{
  uint64_t v4 = a2[1];
  int v5 = v4 + a4;
  if (*(_DWORD *)(a1 + 136) > (int)v4 + a4) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v9 = a3;
  uint64_t v10 = a4;
  do
  {
    if (v5 > *(_DWORD *)(a1 + 140)) {
      break;
    }
    uint64_t v11 = *(unsigned __int8 **)(a1 + 32);
    uint64_t v12 = *a2;
    int v13 = (void *)*((void *)v11 + 3);
    int v14 = sub_1DC2FF924(v13, v12, v5);
    int v15 = *v11;
    int v16 = *(unsigned __int8 *)(a1 + 13);
    if (v16 != (v15 != v14)) {
      break;
    }
    v4 += v10;
    a2[1] = v4;
    uint64_t v6 = (v6 + 1);
    if (*(_DWORD *)(a1 + 128) <= (int)v12 + a3)
    {
      uint64_t v17 = v9 + v12;
      do
      {
        if ((int)v17 > *(_DWORD *)(a1 + 132)) {
          break;
        }
        if (v16 != (v15 != sub_1DC2FF924(v13, (int)v17, v4))) {
          break;
        }
        *a2 = v17;
        uint64_t v6 = (v6 + 1);
        v17 += v9;
      }
      while (v17 >= *(int *)(a1 + 128));
    }
    int v5 = v4 + v10;
  }
  while (v4 + v10 >= *(int *)(a1 + 136));
  return v6;
}

uint64_t sub_1DC36E568(uint64_t a1, int *a2, int a3, int a4)
{
  if (a3)
  {
    uint64_t v6 = *a2;
    if (*(_DWORD *)(a1 + 128) <= (int)v6 + a3)
    {
      uint64_t v7 = 0;
      uint64_t v8 = a2[1];
      uint64_t v9 = a3;
      uint64_t v10 = v6 + a3;
      do
      {
        if ((int)v10 > *(_DWORD *)(a1 + 132)) {
          break;
        }
        uint64_t v11 = *(unsigned __int8 **)(a1 + 32);
        if (*(unsigned char *)(a1 + 13) != (*v11 != sub_1DC2FF924(*((void **)v11 + 3), (int)v10, v8))) {
          break;
        }
        *a2 = v10;
        uint64_t v7 = (v7 + 1);
        v10 += v9;
      }
      while (v10 >= *(int *)(a1 + 128));
      return v7;
    }
    return 0;
  }
  if (!a4) {
    return 0;
  }
  uint64_t v12 = a2[1];
  if (*(_DWORD *)(a1 + 136) > (int)v12 + a4) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v14 = *a2;
  uint64_t v15 = a4;
  uint64_t v16 = v12 + a4;
  do
  {
    if ((int)v16 > *(_DWORD *)(a1 + 140)) {
      break;
    }
    uint64_t v17 = *(unsigned __int8 **)(a1 + 32);
    if (*(unsigned char *)(a1 + 13) != (*v17 != sub_1DC2FF924(*((void **)v17 + 3), v14, (int)v16))) {
      break;
    }
    a2[1] = v16;
    uint64_t v7 = (v7 + 1);
    v16 += v15;
  }
  while (v16 >= *(int *)(a1 + 136));
  return v7;
}

float sub_1DC36E6AC(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if ((a2 & 0x8000000080000000) != 0) {
    return NAN;
  }
  int v7 = a3;
  unint64_t v49 = a2;
  uint64_t v9 = sub_1DC36E430;
  if (a3 == 1) {
    uint64_t v9 = sub_1DC36E568;
  }
  if (a3 < 1) {
    uint64_t v9 = sub_1DC36E2F8;
  }
  int32x4_t v37 = v9;
  uint64_t v10 = (int)a6;
  uint64_t v11 = (int)a7;
  int v38 = a4;
  for (int i = a5; ; a5 = i)
  {
    v37(a1, (int *)&v49, a4, a5);
    if (qword_1EBFFC290 != -1) {
      dispatch_once(&qword_1EBFFC290, &unk_1F3662568);
    }
    log = qword_1EBFFC298;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC298, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 67240448;
      int v51 = v49;
      __int16 v52 = 1026;
      unsigned int v53 = HIDWORD(v49);
      _os_log_debug_impl(&dword_1DC2FE000, log, OS_LOG_TYPE_DEBUG, "(%{public}d, %{public}d)", buf, 0xEu);
    }
    if (v7 == 1)
    {
      int v12 = 0;
      *(_DWORD *)(a1 + 8) = 0;
      if (!a6) {
        goto LABEL_16;
      }
      goto LABEL_29;
    }
    int v12 = *(_DWORD *)(a1 + 8);
    if (v7 > 1)
    {
      if (v12 < 0) {
        break;
      }
LABEL_16:
      uint64_t v13 = 0;
      uint64_t v14 = *(int *)(a1 + 4);
      int v34 = v49;
      uint64_t v43 = v11 + SHIDWORD(v49);
      uint64_t v45 = (int)v49;
      while ((int)v14 < 1)
      {
LABEL_26:
        BOOL v20 = v13++ < v12;
        if (!v20)
        {
          int v26 = v34;
          int v7 = a3;
          goto LABEL_42;
        }
      }
      int v47 = v12;
      uint64_t v15 = 0;
      uint64_t v16 = v43;
      uint64_t v17 = v45 + v13 * v10;
      uint64_t v18 = *(int *)(a1 + 128);
      while (1)
      {
        if (v17 >= v18 && v17 <= *(int *)(a1 + 132) && v16 >= *(int *)(a1 + 136) && v16 <= *(int *)(a1 + 140))
        {
          BOOL v19 = *(unsigned __int8 **)(a1 + 32);
          if (*(unsigned char *)(a1 + 13) == (*v19 != sub_1DC2FF924(*((void **)v19 + 3), v17, v16))) {
            goto LABEL_41;
          }
        }
        ++v15;
        v16 += v11;
        if (v15 >= v14)
        {
          int v12 = v47;
          goto LABEL_26;
        }
      }
    }
    if (v12 < 0) {
      break;
    }
LABEL_29:
    uint64_t v21 = 0;
    uint64_t v22 = *(int *)(a1 + 4);
    int v35 = v49;
    uint64_t v44 = v10 + (int)v49;
    uint64_t v46 = SHIDWORD(v49);
    while ((int)v22 < 1)
    {
LABEL_39:
      BOOL v20 = v21++ < v12;
      if (!v20)
      {
        int v7 = a3;
        int v26 = v35;
        goto LABEL_42;
      }
    }
    int v48 = v12;
    uint64_t v23 = 0;
    uint64_t v17 = v44;
    uint64_t v16 = v46 + v21 * v11;
    uint64_t v24 = *(int *)(a1 + 128);
    while (1)
    {
      if (v17 >= v24 && v17 <= *(int *)(a1 + 132) && v16 >= *(int *)(a1 + 136) && v16 <= *(int *)(a1 + 140))
      {
        int v25 = *(unsigned __int8 **)(a1 + 32);
        if (*(unsigned char *)(a1 + 13) == (*v25 != sub_1DC2FF924(*((void **)v25 + 3), v17, v16))) {
          break;
        }
      }
      ++v23;
      v17 += v10;
      if (v23 >= v22)
      {
        int v12 = v48;
        goto LABEL_39;
      }
    }
LABEL_41:
    unint64_t v49 = __PAIR64__(v16, v17);
    int v7 = a3;
    a4 = v38;
  }
  int v26 = v49;
LABEL_42:
  if (v26 == *(_DWORD *)(a1 + 128)) {
    return NAN;
  }
  if (v26 == *(_DWORD *)(a1 + 132)) {
    return NAN;
  }
  int v27 = HIDWORD(v49);
  if (HIDWORD(v49) == *(_DWORD *)(a1 + 136) || HIDWORD(v49) == *(_DWORD *)(a1 + 140)) {
    return NAN;
  }
  if (v38 <= 0) {
    int v29 = v26;
  }
  else {
    int v29 = v26 + 1;
  }
  if (i > 0) {
    int v27 = HIDWORD(v49) + 1;
  }
  unsigned int v30 = a6 >> 31;
  if (v7 != 1) {
    unsigned int v30 = 0;
  }
  int v31 = v29 + v30;
  if (v7 == 1) {
    unsigned int v32 = a7 >> 31;
  }
  else {
    unsigned int v32 = 0;
  }
  unsigned int v33 = v27 + v32;
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 67240448;
    int v51 = v31;
    __int16 v52 = 1026;
    unsigned int v53 = v33;
    _os_log_debug_impl(&dword_1DC2FE000, log, OS_LOG_TYPE_DEBUG, "(%{public}d, %{public}d)", buf, 0xEu);
  }
  return (float)v31;
}

void sub_1DC36EAFC(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 1)) {
    int v7 = (char *)&unk_1DC40C320 + 8 * a2;
  }
  else {
    int v7 = (char *)&unk_1DC40C340 + 8 * a2;
  }
  uint64_t v9 = *(unsigned int *)v7;
  uint64_t v8 = *((unsigned int *)v7 + 1);
  if (*(unsigned char *)(a1 + 1)) {
    int v10 = 1;
  }
  else {
    int v10 = ~(2 * a2) & 2;
  }
  if (qword_1EBFFC290 != -1) {
    dispatch_once(&qword_1EBFFC290, &unk_1F3662568);
  }
  uint64_t v11 = qword_1EBFFC298;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC298, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "===== corner1 =====", buf, 2u);
  }
  *(float *)a3 = sub_1DC36E6AC(a1, *(void *)(a1 + 56 + 8 * a2), v10, v9, v8, -(int)v8, v9);
  *(_DWORD *)(a3 + 4) = v12;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v16 = 0;
    _os_log_debug_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_DEBUG, "===== corner2 =====", v16, 2u);
  }
  int v13 = (a2 + 1) & 3;
  if (a2 + 1 <= 0) {
    int v13 = -(-(a2 + 1) & 3);
  }
  *(float *)a4 = sub_1DC36E6AC(a1, *(void *)(a1 + 56 + 8 * v13), 2 - v10, v9, v8, v8, -(int)v9);
  *(_DWORD *)(a4 + 4) = v14;
}

float sub_1DC36EC9C(uint64_t a1, float *a2, float *a3, uint64_t a4)
{
  float result = *a2;
  if (*a2 < 0.0
    || (float v5 = a2[1], v5 < 0.0)
    || (float v6 = *a3, *a3 < 0.0)
    || (float v7 = a3[1], v7 < 0.0)
    || (float)((float)((float)(v5 - v7) * (float)(v5 - v7)) + (float)((float)(result - v6) * (float)(result - v6))) > (float)(*(float *)(a1 + 28) * *(float *)(a1 + 28)))
  {
    uint64_t v8 = 0x7FC000007FC00000;
LABEL_7:
    *(void *)a4 = v8;
    return result;
  }
  if (!*(unsigned char *)(a1 + 1))
  {
    float v9 = (float)*(int *)(a1 + 120);
    float v10 = (float)*(int *)(a1 + 124);
    float result = (float)((float)(v5 - v10) * (float)(v5 - v10)) + (float)((float)(result - v9) * (float)(result - v9));
    if (result <= (float)((float)((float)(v7 - v10) * (float)(v7 - v10)) + (float)((float)(v6 - v9) * (float)(v6 - v9)))) {
      uint64_t v11 = (uint64_t *)a3;
    }
    else {
      uint64_t v11 = (uint64_t *)a2;
    }
    uint64_t v8 = *v11;
    goto LABEL_7;
  }
  float result = (float)(result + v6) * 0.5;
  *(float *)a4 = result;
  *(float *)(a4 + 4) = (float)(v5 + v7) * 0.5;
  return result;
}

void sub_1DC36ED70(void *a1, uint64_t a2, int a3, int a4)
{
  float v7 = a1;
  sub_1DC320A5C(a1, 8uLL);
  uint64_t v8 = (char *)(a2 + 88);
  memset_pattern16((void *)(a2 + 88), &unk_1DC3FDE70, 0x20uLL);
  *(_DWORD *)(a2 + 120) = a3;
  *(_DWORD *)(a2 + 124) = a4;
  sub_1DC36D0A0(a2);
  float v9 = *(unsigned __int8 **)(a2 + 32);
  if (*v9 != sub_1DC2FF924(*((void **)v9 + 3), a3, a4))
  {
LABEL_73:
    if (*(unsigned char *)(a2 + 1)) {
      goto LABEL_95;
    }
    sub_1DC36E24C(a2);
    uint64_t v63 = 0;
    uint64_t v64 = (uint64_t)v8;
    do
    {
      uint64_t v99 = 0;
      uint64_t v100 = 0;
      int v65 = v63 + *(_DWORD *)(a2 + 144);
      int v66 = v65 & 3;
      int v67 = -v65;
      BOOL v76 = v67 < 0;
      int v68 = v67 & 3;
      if (v76) {
        int v69 = v66;
      }
      else {
        int v69 = -v68;
      }
      sub_1DC36EAFC(a2, v69, (uint64_t)&v100, (uint64_t)&v99);
      if (!*(unsigned char *)a2 && *(float *)&v100 >= 0.0 && *((float *)&v100 + 1) >= 0.0)
      {
        float v70 = (float)*(int *)(a2 + 120);
        float v71 = (float)*(int *)(a2 + 124);
        float v72 = vabds_f32(*(float *)&v100, v70);
        float v73 = vabds_f32(*((float *)&v100 + 1), v71);
        float v74 = v72 * 0.41421;
        float v75 = v72 * 2.4142;
        BOOL v76 = v74 < v73 && v73 < v75;
        if (!v76 && *(float *)&v99 >= 0.0 && *((float *)&v99 + 1) >= 0.0)
        {
          float v77 = vabds_f32(*(float *)&v99, v70);
          float v78 = vabds_f32(*((float *)&v99 + 1), v71);
          float v79 = v77 * 0.41421;
          float v80 = v77 * 2.4142;
          if (v79 >= v78 || v78 >= v80)
          {
            *(unsigned char *)(a2 + 1) = 1;
            memset_pattern16(v8, &unk_1DC3FDE70, 0x20uLL);
            goto LABEL_95;
          }
        }
      }
      sub_1DC36EC9C(a2, (float *)&v100, (float *)&v99, v64);
      ++v63;
      v64 += 8;
    }
    while (v63 != 4);
    if (*(unsigned char *)(a2 + 1))
    {
LABEL_95:
      if (sub_1DC36E24C(a2) == 4)
      {
        for (uint64_t i = 0; i != 4; ++i)
        {
          uint64_t v99 = 0;
          uint64_t v100 = 0;
          int v83 = i + *(_DWORD *)(a2 + 144);
          int v84 = v83 & 3;
          int v85 = -v83;
          BOOL v76 = v85 < 0;
          int v86 = v85 & 3;
          if (v76) {
            int v87 = v84;
          }
          else {
            int v87 = -v86;
          }
          sub_1DC36EAFC(a2, v87, (uint64_t)&v100, (uint64_t)&v99);
          sub_1DC36EC9C(a2, (float *)&v100, (float *)&v99, (uint64_t)v8);
          v8 += 8;
        }
      }
    }
    goto LABEL_101;
  }
  int64_t v92 = v7;
  uint64_t v11 = 0;
  int v12 = 0;
  unint64_t v13 = 0;
  uint64_t v14 = 0;
  v10.i64[0] = __PAIR64__(a4, a3);
  int32x4_t v93 = v10;
  int v15 = (int)*(float *)(a2 + 28);
  do
  {
    if (v15 >= 1)
    {
      __int32 v16 = 0;
      int32x2_t v17 = qword_1DC40C2E0[v14];
      uint64_t v18 = *(unsigned __int8 **)(a2 + 32);
      BOOL v19 = (void *)*((void *)v18 + 3);
      int v20 = *v18;
      int32x4_t v96 = v93;
      while (1)
      {
        v21.i64[1] = v96.i64[1];
        *(int32x2_t *)v21.i8 = vadd_s32(*(int32x2_t *)v96.i8, v17);
        int32x4_t v96 = v21;
        if (v20 != sub_1DC2FF924(v19, v21.i32[0], v21.i32[1])) {
          break;
        }
        if (v15 == ++v16) {
          goto LABEL_25;
        }
      }
      int32x4_t v22 = v96;
      v22.i32[2] = v16;
      if ((unint64_t)v12 >= v13)
      {
        int32x4_t v97 = v22;
        uint64_t v23 = v12 - v11;
        unint64_t v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 60) {
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v13 - (void)v11) >> 3 > v24) {
          unint64_t v24 = (uint64_t)(v13 - (void)v11) >> 3;
        }
        if (v13 - (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v24;
        }
        if (v25) {
          unint64_t v25 = (unint64_t)sub_1DC300068(v25);
        }
        else {
          uint64_t v26 = 0;
        }
        int v27 = (int32x4_t *)(v25 + 16 * v23);
        *int v27 = v97;
        uint64_t v28 = v27 + 1;
        while (v12 != v11)
        {
          int32x4_t v29 = v12[-1];
          --v12;
          v27[-1] = v29;
          --v27;
        }
        unint64_t v13 = v25 + 16 * v26;
        if (v11) {
          operator delete(v11);
        }
        uint64_t v11 = v27;
        int v12 = v28;
      }
      else
      {
        *v12++ = v22;
      }
    }
LABEL_25:
    ++v14;
  }
  while (v14 != 8);
  unint64_t v30 = 126 - 2 * __clz(v12 - v11);
  if (v12 == v11) {
    uint64_t v31 = 0;
  }
  else {
    uint64_t v31 = v30;
  }
  sub_1DC36D114((unint64_t)v11, v12, v31, 1);
  if (v12 == v11)
  {
    unsigned int v33 = 0;
    int v38 = 0;
    if (v11) {
LABEL_50:
    }
      operator delete(v11);
  }
  else
  {
    unsigned int v33 = 0;
    int v34 = 0;
    unint64_t v35 = 0;
    int32x4_t v36 = v11;
    do
    {
      uint64_t v37 = v36->i64[0];
      if ((unint64_t)v34 >= v35)
      {
        uint64_t v39 = (v34 - v33) >> 3;
        unint64_t v40 = v39 + 1;
        if ((unint64_t)(v39 + 1) >> 61) {
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v35 - (void)v33) >> 2 > v40) {
          unint64_t v40 = (uint64_t)(v35 - (void)v33) >> 2;
        }
        if (v35 - (unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v41 = v40;
        }
        if (v41) {
          unint64_t v41 = (unint64_t)sub_1DC2FFD7C(v41);
        }
        else {
          uint64_t v42 = 0;
        }
        uint64_t v43 = (char *)(v41 + 8 * v39);
        *(void *)uint64_t v43 = v37;
        int v38 = v43 + 8;
        while (v34 != v33)
        {
          uint64_t v44 = *((void *)v34 - 1);
          v34 -= 8;
          *((void *)v43 - 1) = v44;
          v43 -= 8;
        }
        unint64_t v35 = v41 + 8 * v42;
        if (v33) {
          operator delete(v33);
        }
        unsigned int v33 = v43;
      }
      else
      {
        *(void *)int v34 = v37;
        int v38 = v34 + 8;
      }
      ++v36;
      int v34 = v38;
    }
    while (v36 != v12);
    if (v11) {
      goto LABEL_50;
    }
  }
  if (v33 == v38)
  {
LABEL_69:
    int v91 = 0;
  }
  else
  {
    float v45 = *(float *)(a2 + 28);
    int v46 = (int)(float)(v45 + v45);
    int v47 = (int)(float)(v45 * 0.5);
    int v48 = (unint64_t *)v33;
    while (1)
    {
      v32.n128_u64[0] = *v48;
      __n128 v98 = v32;
      int v49 = sub_1DC36DF7C(a2, v46, v32, (int32x2_t)0xFFFFFFFFLL);
      if (v49)
      {
        int v50 = v49;
        int v51 = sub_1DC36DF7C(a2, v46, v98, (int32x2_t)1);
        if (v51)
        {
          __n128 v52 = v98;
          v52.n128_u32[0] = (int)(float)((float)(v98.n128_u32[0] - v50 + 1) + (float)((float)(v50 + v51 - 1) * 0.5));
          __n128 v94 = v52;
          int v53 = sub_1DC36DF7C(a2, v46, v52, (int32x2_t)0xFFFFFFFF00000000);
          if (v53)
          {
            int v54 = v53;
            int v55 = sub_1DC36DF7C(a2, v46, v94, (int32x2_t)0x100000000);
            if (v55)
            {
              int v56 = v55 + v54 - 1;
              if (v55 + v54 <= v46 && v56 > v47)
              {
                __n128 v58 = v94;
                v58.n128_u32[1] = (int)(float)((float)(v98.n128_u32[1] - v54 + 1) + (float)((float)v56 * 0.5));
                __n128 v95 = v58;
                int v59 = sub_1DC36DF7C(a2, v46, v58, (int32x2_t)0xFFFFFFFFLL);
                if (v59)
                {
                  int v60 = v59;
                  int v61 = sub_1DC36DF7C(a2, v46, v95, (int32x2_t)1);
                  if (v61)
                  {
                    if (v61 + v60 <= v46 && v61 + v60 - 1 > v47) {
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (++v48 == (unint64_t *)v38) {
        goto LABEL_69;
      }
    }
    *(void *)(a2 + 120) = v95.n128_u64[0];
    sub_1DC36D0A0(a2);
    int v91 = 1;
  }
  uint64_t v8 = (char *)(a2 + 88);
  float v7 = v92;
  if (v33) {
    operator delete(v33);
  }
  if (v91) {
    goto LABEL_73;
  }
LABEL_101:
  uint64_t v88 = 0;
  uint64_t v89 = *v7;
  do
  {
    int v90 = (_DWORD *)(v89 + v88);
    *int v90 = *(_DWORD *)(a2 + v88 + 88);
    v90[1] = *(_DWORD *)(a2 + v88 + 92);
    v88 += 8;
  }
  while (v88 != 32);
}

void sub_1DC36F3C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    operator delete(v10);
  }
  int v12 = *(void **)a10;
  if (*(void *)a10)
  {
    *(void *)(a10 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

size_t sub_1DC36F420(uint64_t a1, uint64_t a2, char *a3, std::string::size_type a4)
{
  size_t v4 = 0;
  if (!a1 || !a2) {
    return v4;
  }
  memset(&v63, 0, sizeof(v63));
  v65.__r_.__value_.__s.__data_[0] = 0;
  sub_1DC314894(&v61, (int)a2, &v65);
  unint64_t v9 = 0;
  do
  {
    if (((*(unsigned __int16 *)(a1 + 2 * (v9 >> 4)) << (v9 & 0xF)) & 0x8000) != 0)
    {
      if (v62 - (unsigned char *)v61 <= v9) {
        sub_1DC351420();
      }
      *((unsigned char *)v61 + v9) = 1;
    }
    ++v9;
  }
  while (a2 != v9);
  int32x4_t v10 = (char *)v61;
  unint64_t v11 = v62 - (unsigned char *)v61;
  if (v62 == v61) {
    goto LABEL_153;
  }
  if (!*(unsigned char *)v61)
  {
    LODWORD(v12) = 1;
    goto LABEL_123;
  }
  if (v11 < 2) {
    goto LABEL_153;
  }
  if (*((unsigned char *)v61 + 1))
  {
    if ((int)v11 < 13)
    {
      LODWORD(v12) = 2;
      goto LABEL_123;
    }
    std::string::append(&v63, "90", 2uLL);
    unint64_t v13 = v62 - (unsigned char *)v61;
    if ((unint64_t)(v62 - (unsigned char *)v61) >= 3)
    {
      if (*((unsigned char *)v61 + 2))
      {
        if (v13 < 4) {
          goto LABEL_153;
        }
        if (*((unsigned char *)v61 + 3)) {
          int v14 = 3;
        }
        else {
          int v14 = 0;
        }
        unsigned int v15 = 4;
      }
      else
      {
        int v14 = 1;
        unsigned int v15 = 3;
      }
      if (v13 > v15)
      {
        uint64_t v17 = v15;
        unint64_t v18 = v15 + 1;
        if (!*((unsigned char *)v61 + v17))
        {
          int v20 = 0;
          goto LABEL_38;
        }
        if (v13 > v18)
        {
          int v19 = v17 + 2;
          if (*((unsigned char *)v61 + v18)) {
            int v20 = 2;
          }
          else {
            int v20 = 1;
          }
          LODWORD(v18) = v19;
LABEL_38:
          if ((int)v13 - (int)v18 >= 5) {
            int v21 = 5;
          }
          else {
            int v21 = v13 - v18;
          }
          if ((int)v13 - (int)v18 <= 0)
          {
            int v22 = 0;
            LODWORD(v12) = v18 + 5;
          }
          else
          {
            int v22 = 0;
            uint64_t v23 = (unsigned __int8 *)v61 + v18;
            do
            {
              int v24 = *v23++;
              int v22 = (v24 != 0) | (2 * v22);
              --v21;
            }
            while (v21);
            LODWORD(v12) = v18 + 5;
            if (v22 > 30)
            {
              int v25 = v18 + 20;
              if ((int)v18 + 20 > (int)v13) {
                goto LABEL_123;
              }
              int v22 = 0;
              uint64_t v26 = 5;
              do
                int v22 = (*((unsigned char *)v61 + v18 + v26++) != 0) | (2 * v22);
              while (v26 != 15);
              char v27 = 0;
              uint64_t v28 = (v18 + 15);
              int v29 = v13 - v28;
              if (v29 >= 5) {
                int v29 = 5;
              }
              unint64_t v30 = (unsigned __int8 *)v61 + v28;
              do
              {
                int v31 = *v30++;
                char v27 = (v31 != 0) | (2 * v27);
                --v29;
              }
              while (v29);
              std::string::value_type v32 = v27 + 65;
LABEL_60:
              std::to_string(&v65, v22);
              if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                uint64_t v37 = &v65;
              }
              else {
                uint64_t v37 = (std::string *)v65.__r_.__value_.__r.__words[0];
              }
              if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type size = HIBYTE(v65.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type size = v65.__r_.__value_.__l.__size_;
              }
              std::string::append(&v63, (const std::string::value_type *)v37, size);
              if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v65.__r_.__value_.__l.__data_);
              }
              std::string::push_back(&v63, v32);
              v68[0] = v25;
              v68[1] = v14;
              LODWORD(__p.__r_.__value_.__r.__words[2]) = 0;
              *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[2] + 3) = 0;
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
              *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
              sub_1DC35C908((uint64_t)&v65, v68, (uint64_t *)&v61, &__p);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
              if (LODWORD(v65.__r_.__value_.__l.__data_) == 0x7FFFFFFF)
              {
                unsigned int v39 = -1;
                LODWORD(v12) = v25;
              }
              else
              {
                if ((v66 & 0x80u) == 0) {
                  int32x4_t v57 = &v65.__r_.__value_.__s.__data_[8];
                }
                else {
                  int32x4_t v57 = (const std::string::value_type *)v65.__r_.__value_.__l.__size_;
                }
                if ((v66 & 0x80u) == 0) {
                  std::string::size_type v58 = v66;
                }
                else {
                  std::string::size_type v58 = v65.__r_.__value_.__r.__words[2];
                }
                std::string::append(&v63, v57, v58);
                LODWORD(v12) = v65.__r_.__value_.__l.__data_;
                if (v67 < 0) {
                  unsigned int v39 = -1;
                }
                else {
                  unsigned int v39 = v67;
                }
              }
              if ((char)v66 < 0) {
                operator delete((void *)v65.__r_.__value_.__l.__size_);
              }
              if (v20)
              {
                if (v20 == 1)
                {
                  int v59 = "21";
                  std::string::size_type v60 = 2;
                }
                else
                {
                  int v59 = "8004";
                  std::string::size_type v60 = 4;
                }
                std::string::append(&v63, v59, v60);
                if (v39 <= 9) {
                  std::string::push_back(&v63, v39 + 48);
                }
              }
              goto LABEL_123;
            }
          }
          if ((int)v18 + 9 > (int)v13) {
            goto LABEL_123;
          }
          int v33 = 0;
          int v34 = v13 - v12;
          if (v34 >= 4) {
            int v34 = 4;
          }
          unint64_t v35 = (unsigned __int8 *)v61 + v12;
          do
          {
            int v36 = *v35++;
            int v33 = (v36 != 0) | (2 * v33);
            --v34;
          }
          while (v34);
          int v25 = v12 + 4;
          std::string::value_type v32 = aBdhijklnpqrstv[v33];
          goto LABEL_60;
        }
      }
    }
LABEL_153:
    sub_1DC351420();
  }
  if (v11 < 3) {
    goto LABEL_153;
  }
  if (*((unsigned char *)v61 + 2))
  {
    if (v11 < 4) {
      goto LABEL_153;
    }
    if (*((unsigned char *)v61 + 3))
    {
      LODWORD(v12) = 2;
      std::string::append(&v63, "10", 2uLL);
      goto LABEL_123;
    }
  }
  if ((int)v11 >= 19)
  {
    int v40 = 0;
    uint64_t v41 = 2;
    do
      int v40 = (*((unsigned char *)v61 + v41++) != 0) | (2 * v40);
    while (v41 != 18);
    if (v11 <= 0x12) {
      goto LABEL_153;
    }
    if (v40 <= 38399)
    {
      if (*((unsigned char *)v61 + 18)) {
        uint64_t v42 = "17";
      }
      else {
        uint64_t v42 = "11";
      }
      std::string::append(&v63, v42, 2uLL);
      if (v40 >= 0) {
        int v43 = v40;
      }
      else {
        int v43 = v40 + 31;
      }
      if ((v40 + 3839) <= 0x1DFE) {
        std::string::push_back(&v63, 48);
      }
      std::to_string(&v65, v40 / 384);
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v44 = &v65;
      }
      else {
        uint64_t v44 = (std::string *)v65.__r_.__value_.__r.__words[0];
      }
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v45 = HIBYTE(v65.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v45 = v65.__r_.__value_.__l.__size_;
      }
      std::string::append(&v63, (const std::string::value_type *)v44, v45);
      int v46 = (v43 >> 5) % 12;
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v65.__r_.__value_.__l.__data_);
      }
      if ((v46 + 10) <= 0x12) {
        std::string::push_back(&v63, 48);
      }
      std::to_string(&v65, v46 + 1);
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v47 = &v65;
      }
      else {
        int v47 = (std::string *)v65.__r_.__value_.__r.__words[0];
      }
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v48 = HIBYTE(v65.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v48 = v65.__r_.__value_.__l.__size_;
      }
      std::string::append(&v63, (const std::string::value_type *)v47, v48);
      int v49 = v40 - (v43 & 0xFFFFFFE0);
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v65.__r_.__value_.__l.__data_);
      }
      if ((v49 + 9) <= 0x12) {
        std::string::push_back(&v63, 48);
      }
      std::to_string(&v65, v49);
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v50 = &v65;
      }
      else {
        int v50 = (std::string *)v65.__r_.__value_.__r.__words[0];
      }
      if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v51 = HIBYTE(v65.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v51 = v65.__r_.__value_.__l.__size_;
      }
      std::string::append(&v63, (const std::string::value_type *)v50, v51);
      if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v65.__r_.__value_.__l.__data_);
      }
      int32x4_t v10 = (char *)v61;
      LODWORD(v11) = v62 - v61;
    }
    unsigned int v16 = 19;
  }
  else
  {
    unsigned int v16 = 2;
  }
  uint64_t v12 = v16;
  if ((int)(v16 + 7) > (int)v11) {
    goto LABEL_122;
  }
  int v52 = v11 - v16;
  int v53 = (int)v11 - (int)v12 >= 7 ? 7 : v11 - v12;
  if (v52 < 1) {
    goto LABEL_122;
  }
  int v54 = 0;
  do
  {
    int v54 = (v10[v12] != 0) | (2 * v54);
    ++v10;
    --v53;
  }
  while (v53);
  if (v54 < 108) {
LABEL_122:
  }
    std::string::append(&v63, "10", 2uLL);
LABEL_123:
  sub_1DC35D3E4((uint64_t *)&v61, v12, &v63);
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0)
  {
    if (v63.__r_.__value_.__l.__size_ < a4)
    {
      int v55 = (std::string *)v63.__r_.__value_.__r.__words[0];
      goto LABEL_128;
    }
LABEL_129:
    size_t v4 = 0;
    goto LABEL_130;
  }
  if (HIBYTE(v63.__r_.__value_.__r.__words[2]) >= a4) {
    goto LABEL_129;
  }
  int v55 = &v63;
LABEL_128:
  size_t v4 = strlcpy(a3, (const char *)v55, a4);
LABEL_130:
  if (v61)
  {
    uint64_t v62 = v61;
    operator delete(v61);
  }
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v63.__r_.__value_.__l.__data_);
  }
  return v4;
}

void sub_1DC36FAD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,void *a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a10) {
    operator delete(a10);
  }
  if (a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC36FB80(atomic_ullong *a1, char a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (atomic_load_explicit(a1, memory_order_acquire))
  {
    CVReturn v4 = CVPixelBufferLockBaseAddress((CVPixelBufferRef)atomic_load_explicit(a1, memory_order_acquire), a2 & 1);
    if (v4)
    {
      CVReturn v5 = v4;
      if (qword_1EAA94CA0 != -1) {
        dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
      }
      float v6 = qword_1EAA94C98;
      if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = v5;
        _os_log_error_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", buf, 8u);
      }
      unint64_t v9 = @"CVPixelBufferLockBaseAddress failed.";
      *(void *)long long buf = -2002;
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v9);
      uint64_t result = 0;
      *(_DWORD *)(a3 + 24) = v5;
      *(unsigned char *)(a3 + 28) = 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    uint64_t v8 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "Invalid pixel buffer", buf, 2u);
    }
    unint64_t v9 = @"Invalid pixel buffer.";
    *(void *)long long buf = -2002;
    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v9);
    return 0;
  }
  return result;
}

uint64_t sub_1DC36FD3C(atomic_ullong *a1, char a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (atomic_load_explicit(a1, memory_order_acquire))
  {
    CVReturn v4 = CVPixelBufferUnlockBaseAddress((CVPixelBufferRef)atomic_load_explicit(a1, memory_order_acquire), a2 & 1);
    if (v4)
    {
      CVReturn v5 = v4;
      if (qword_1EAA94CA0 != -1) {
        dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
      }
      float v6 = qword_1EAA94C98;
      if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = v5;
        _os_log_error_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_ERROR, "CVPixelBufferUnlockBaseAddress failed: %{public}d", buf, 8u);
      }
      unint64_t v9 = @"CVPixelBufferUnlockBaseAddress failed.";
      *(void *)long long buf = -2002;
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v9);
      uint64_t result = 0;
      *(_DWORD *)(a3 + 24) = v5;
      *(unsigned char *)(a3 + 28) = 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    uint64_t v8 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "Invalid pixel buffer", buf, 2u);
    }
    unint64_t v9 = @"Invalid pixel buffer.";
    *(void *)long long buf = -2002;
    sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v9);
    return 0;
  }
  return result;
}

uint64_t sub_1DC36FEF8(atomic_ullong *a1, uint64_t a2, char a3, uint64_t a4)
{
  kern_return_t v7;
  kern_return_t v8;
  NSObject *v9;
  __CFString *v10;
  NSObject *v11;
  uint64_t result;
  kern_return_t v13;
  NSObject *v14;
  __CFString *v15;
  uint8_t buf[8];
  uint64_t v17;

  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (atomic_load_explicit(a1, memory_order_acquire))
  {
    int v5 = *(unsigned __int8 *)(a2 + 8);
    CFTypeRef explicit = (__IOSurface *)atomic_load_explicit(a1, memory_order_acquire);
    if (v5)
    {
      float v7 = IOSurfaceLockPlane();
      if (v7)
      {
        uint64_t v8 = v7;
        if (qword_1EAA94CA0 != -1) {
          dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
        }
        unint64_t v9 = qword_1EAA94C98;
        if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = v8;
          _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "IOSurfaceLockPlane failed: %{public}d", buf, 8u);
        }
        *(void *)long long buf = -2010;
        int32x4_t v10 = @"IOSurfaceLockPlane failed.";
LABEL_20:
        unsigned int v15 = v10;
        sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)&v15);
        uint64_t result = 0;
        *(_DWORD *)(a4 + 56) = v8;
        *(unsigned char *)(a4 + 60) = 1;
        return result;
      }
    }
    else
    {
      unint64_t v13 = IOSurfaceLock(explicit, a3 & 1, 0);
      if (v13)
      {
        uint64_t v8 = v13;
        if (qword_1EAA94CA0 != -1) {
          dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
        }
        int v14 = qword_1EAA94C98;
        if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = v8;
          _os_log_error_impl(&dword_1DC2FE000, v14, OS_LOG_TYPE_ERROR, "IOSurfaceLock failed: %{public}d", buf, 8u);
        }
        *(void *)long long buf = -2010;
        int32x4_t v10 = @"IOSurfaceLock failed.";
        goto LABEL_20;
      }
    }
    return 1;
  }
  else
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    uint64_t v11 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "Invalid IOSurface", buf, 2u);
    }
    unsigned int v15 = @"Invalid IOSurface.";
    *(void *)long long buf = -2010;
    sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)&v15);
    return 0;
  }
}

uint64_t sub_1DC370168(atomic_ullong *a1, uint64_t a2, char a3, uint64_t a4)
{
  kern_return_t v7;
  kern_return_t v8;
  NSObject *v9;
  __CFString *v10;
  NSObject *v11;
  uint64_t result;
  kern_return_t v13;
  NSObject *v14;
  __CFString *v15;
  uint8_t buf[8];
  uint64_t v17;

  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (atomic_load_explicit(a1, memory_order_acquire))
  {
    int v5 = *(unsigned __int8 *)(a2 + 8);
    CFTypeRef explicit = (__IOSurface *)atomic_load_explicit(a1, memory_order_acquire);
    if (v5)
    {
      float v7 = IOSurfaceUnlockPlane();
      if (v7)
      {
        uint64_t v8 = v7;
        if (qword_1EAA94CA0 != -1) {
          dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
        }
        unint64_t v9 = qword_1EAA94C98;
        if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = v8;
          _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "IOSurfaceUnlockPlane failed: %{public}d", buf, 8u);
        }
        *(void *)long long buf = -2010;
        int32x4_t v10 = @"IOSurfaceUnlockPlane failed.";
LABEL_20:
        unsigned int v15 = v10;
        sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)&v15);
        uint64_t result = 0;
        *(_DWORD *)(a4 + 56) = v8;
        *(unsigned char *)(a4 + 60) = 1;
        return result;
      }
    }
    else
    {
      unint64_t v13 = IOSurfaceUnlock(explicit, a3 & 1, 0);
      if (v13)
      {
        uint64_t v8 = v13;
        if (qword_1EAA94CA0 != -1) {
          dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
        }
        int v14 = qword_1EAA94C98;
        if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = v8;
          _os_log_error_impl(&dword_1DC2FE000, v14, OS_LOG_TYPE_ERROR, "IOSurfaceUnlock failed: %{public}d", buf, 8u);
        }
        *(void *)long long buf = -2010;
        int32x4_t v10 = @"IOSurfaceUnlock failed.";
        goto LABEL_20;
      }
    }
    return 1;
  }
  else
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    uint64_t v11 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "Invalid IOSurface", buf, 2u);
    }
    unsigned int v15 = @"Invalid IOSurface.";
    *(void *)long long buf = -2010;
    sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)&v15);
    return 0;
  }
}

atomic_ullong *sub_1DC3703D8(CFDictionaryRef *a1, uint64_t *a2, atomic_ullong *a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    if (atomic_load_explicit(a3, memory_order_acquire)) {
      CFDictionaryApplyFunction((CFDictionaryRef)atomic_load_explicit(a3, memory_order_acquire), (CFDictionaryApplierFunction)sub_1DC3708B0, (void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    }
    if (*((unsigned char *)a2 + 8))
    {
      CFTypeRef explicit = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v8 = *a2;
      unint64_t valuePtr = 0;
      uint64_t v48 = v8;
      CFNumberRef v9 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      int32x4_t v10 = (const void *)*MEMORY[0x1E4F2EFB8];
      CFNumberRef v45 = v9;
      CFDictionarySetValue(explicit, v10, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v45);
    }
    if (*((unsigned char *)a2 + 24))
    {
      uint64_t v11 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v12 = a2[2];
      unint64_t valuePtr = 0;
      uint64_t v48 = v12;
      CFNumberRef v13 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      int v14 = (const void *)*MEMORY[0x1E4F2F2C0];
      CFNumberRef v45 = v13;
      CFDictionarySetValue(v11, v14, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v45);
    }
    if (*((unsigned char *)a2 + 40))
    {
      unsigned int v15 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v16 = a2[4];
      unint64_t valuePtr = 0;
      uint64_t v48 = v16;
      CFNumberRef v17 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      unint64_t v18 = (const void *)*MEMORY[0x1E4F2F0E8];
      CFNumberRef v45 = v17;
      CFDictionarySetValue(v15, v18, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v45);
    }
    if (*((unsigned char *)a2 + 56))
    {
      int v19 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v20 = a2[6];
      unint64_t valuePtr = 0;
      uint64_t v48 = v20;
      CFNumberRef v21 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      int v22 = (const void *)*MEMORY[0x1E4F2EFE0];
      CFNumberRef v45 = v21;
      CFDictionarySetValue(v19, v22, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v45);
    }
    if (*((unsigned char *)a2 + 72))
    {
      uint64_t v23 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v24 = a2[8];
      unint64_t valuePtr = 0;
      uint64_t v48 = v24;
      CFNumberRef v25 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      uint64_t v26 = (const void *)*MEMORY[0x1E4F2EFD8];
      CFNumberRef v45 = v25;
      CFDictionarySetValue(v23, v26, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v45);
    }
    if (*((unsigned char *)a2 + 88))
    {
      char v27 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v28 = a2[10];
      unint64_t valuePtr = 0;
      uint64_t v48 = v28;
      CFNumberRef v29 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      unint64_t v30 = (const void *)*MEMORY[0x1E4F2F138];
      CFNumberRef v45 = v29;
      CFDictionarySetValue(v27, v30, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v45);
    }
    if (*((unsigned char *)a2 + 100))
    {
      int v31 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      unint64_t valuePtr = *((unsigned int *)a2 + 24);
      CFNumberRef v32 = CFNumberCreate(v6, kCFNumberSInt64Type, &valuePtr);
      int v33 = (const void *)*MEMORY[0x1E4F2EFE8];
      CFNumberRef v45 = v32;
      CFDictionarySetValue(v31, v33, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v45);
    }
    if (*((unsigned char *)a2 + 105))
    {
      int v34 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      unint64_t v35 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      if (!*((unsigned char *)a2 + 104)) {
        unint64_t v35 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
      }
      CFTypeRef v36 = CFRetain(*v35);
      uint64_t v37 = (const void *)*MEMORY[0x1E4F2F0F8];
      unint64_t valuePtr = (unint64_t)v36;
      CFDictionarySetValue(v34, v37, (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire));
      sub_1DC37087C((atomic_ullong *)&valuePtr);
    }
    if (*((unsigned char *)a2 + 112))
    {
      int v38 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      unint64_t valuePtr = *((unsigned int *)a2 + 27);
      CFNumberRef v39 = CFNumberCreate(v6, kCFNumberSInt64Type, &valuePtr);
      int v40 = (const void *)*MEMORY[0x1E4F2F150];
      CFNumberRef v45 = v39;
      CFDictionarySetValue(v38, v40, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v45);
    }
    if (atomic_load_explicit(a2 + 15, memory_order_acquire))
    {
      uint64_t v41 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      CFDictionarySetValue(v41, (const void *)*MEMORY[0x1E4F2F128], (const void *)atomic_load_explicit(a2 + 15, memory_order_acquire));
    }
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v6, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  }
  else
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    int v43 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      LOWORD(valuePtr) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v43, OS_LOG_TYPE_ERROR, "CFDictionaryCreateMutable failed", (uint8_t *)&valuePtr, 2u);
    }
    CFDictionaryRef Copy = 0;
  }
  *a1 = Copy;
  return sub_1DC306584((atomic_ullong *)&Mutable);
}

void sub_1DC370804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9, atomic_ullong a10)
{
}

atomic_ullong *sub_1DC37087C(atomic_ullong *a1)
{
  int v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1DC3708B0(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

atomic_ullong *sub_1DC3708C4(CFDictionaryRef *a1, uint64_t *a2, atomic_ullong *a3, atomic_ullong *a4)
{
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    if (atomic_load_explicit(a3, memory_order_acquire)) {
      CFDictionaryApplyFunction((CFDictionaryRef)atomic_load_explicit(a3, memory_order_acquire), (CFDictionaryApplierFunction)sub_1DC370DC8, (void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    }
    if (*((unsigned char *)a2 + 8))
    {
      CFTypeRef explicit = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v10 = *a2;
      unint64_t valuePtr = 0;
      uint64_t v54 = v10;
      CFNumberRef v11 = CFNumberCreate(v8, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      uint64_t v12 = (const void *)*MEMORY[0x1E4F24E10];
      CFNumberRef v51 = v11;
      CFDictionarySetValue(explicit, v12, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v51);
    }
    if (*((unsigned char *)a2 + 24))
    {
      CFNumberRef v13 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v14 = a2[2];
      unint64_t valuePtr = 0;
      uint64_t v54 = v14;
      CFNumberRef v15 = CFNumberCreate(v8, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      uint64_t v16 = (const void *)*MEMORY[0x1E4F24D08];
      CFNumberRef v51 = v15;
      CFDictionarySetValue(v13, v16, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v51);
    }
    if (*((unsigned char *)a2 + 36))
    {
      CFNumberRef v17 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      unint64_t valuePtr = *((unsigned int *)a2 + 8);
      CFNumberRef v18 = CFNumberCreate(v8, kCFNumberSInt64Type, &valuePtr);
      int v19 = (const void *)*MEMORY[0x1E4F24D70];
      CFNumberRef v51 = v18;
      CFDictionarySetValue(v17, v19, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v51);
    }
    if (*((unsigned char *)a2 + 48))
    {
      uint64_t v20 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v21 = a2[5];
      unint64_t valuePtr = 0;
      uint64_t v54 = v21;
      CFNumberRef v22 = CFNumberCreate(v8, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      uint64_t v23 = (const void *)*MEMORY[0x1E4F24C98];
      CFNumberRef v51 = v22;
      CFDictionarySetValue(v20, v23, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v51);
    }
    if (*((unsigned char *)a2 + 64))
    {
      uint64_t v24 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v25 = a2[7];
      unint64_t valuePtr = 0;
      uint64_t v54 = v25;
      CFNumberRef v26 = CFNumberCreate(v8, kCFNumberMaxType|kCFNumberSInt8Type, &valuePtr);
      char v27 = (const void *)*MEMORY[0x1E4F24D78];
      CFNumberRef v51 = v26;
      CFDictionarySetValue(v24, v27, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v51);
    }
    uint64_t v28 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
    CFNumberRef v29 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
    if (*((unsigned char *)a2 + 73))
    {
      unint64_t v30 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      if (*((unsigned char *)a2 + 72)) {
        int v31 = v28;
      }
      else {
        int v31 = v29;
      }
      CFDictionaryRef v32 = (const __CFDictionary *)CFRetain(*v31);
      int v33 = (const void *)*MEMORY[0x1E4F24CA0];
      unint64_t valuePtr = (unint64_t)v32;
      CFDictionarySetValue(v30, v33, (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire));
      sub_1DC37087C((atomic_ullong *)&valuePtr);
    }
    if (*((unsigned char *)a2 + 75))
    {
      int v34 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      if (*((unsigned char *)a2 + 74)) {
        unint64_t v35 = v28;
      }
      else {
        unint64_t v35 = v29;
      }
      CFDictionaryRef v36 = (const __CFDictionary *)CFRetain(*v35);
      uint64_t v37 = (const void *)*MEMORY[0x1E4F24CA8];
      unint64_t valuePtr = (unint64_t)v36;
      CFDictionarySetValue(v34, v37, (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire));
      sub_1DC37087C((atomic_ullong *)&valuePtr);
    }
    if (*((unsigned char *)a2 + 77))
    {
      int v38 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      if (*((unsigned char *)a2 + 76)) {
        CFNumberRef v39 = v28;
      }
      else {
        CFNumberRef v39 = v29;
      }
      CFDictionaryRef v40 = (const __CFDictionary *)CFRetain(*v39);
      uint64_t v41 = (const void *)*MEMORY[0x1E4F24D40];
      unint64_t valuePtr = (unint64_t)v40;
      CFDictionarySetValue(v38, v41, (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire));
      sub_1DC37087C((atomic_ullong *)&valuePtr);
    }
    if (*((unsigned char *)a2 + 208))
    {
      uint64_t v42 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      sub_1DC3703D8((CFDictionaryRef *)&valuePtr, a2 + 10, a4);
      CFDictionarySetValue(v42, (const void *)*MEMORY[0x1E4F24D20], (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire));
      sub_1DC31EBFC((atomic_ullong *)&valuePtr);
    }
    else if (atomic_load_explicit(a4, memory_order_acquire))
    {
      CFNumberRef v45 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      CFDictionarySetValue(v45, (const void *)*MEMORY[0x1E4F24D20], (const void *)atomic_load_explicit(a4, memory_order_acquire));
    }
    if (*((unsigned char *)a2 + 217))
    {
      int v46 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      if (*((unsigned char *)a2 + 216)) {
        int v47 = v28;
      }
      else {
        int v47 = v29;
      }
      CFDictionaryRef v48 = (const __CFDictionary *)CFRetain(*v47);
      int v49 = (const void *)*MEMORY[0x1E4F24D18];
      unint64_t valuePtr = (unint64_t)v48;
      CFDictionarySetValue(v46, v49, (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire));
      sub_1DC37087C((atomic_ullong *)&valuePtr);
    }
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v8, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  }
  else
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    int v43 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      LOWORD(valuePtr) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v43, OS_LOG_TYPE_ERROR, "CFDictionaryCreateMutable failed", (uint8_t *)&valuePtr, 2u);
    }
    CFDictionaryRef Copy = 0;
  }
  *a1 = Copy;
  return sub_1DC306584((atomic_ullong *)&Mutable);
}

void sub_1DC370D3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  atomic_ullong v3 = va_arg(va1, void);
  sub_1DC37087C((atomic_ullong *)va1);
  sub_1DC306584((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void sub_1DC370DC8(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

atomic_ullong *sub_1DC370DDC(CFDictionaryRef *a1, uint64_t *a2, atomic_ullong *a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    if (atomic_load_explicit(a3, memory_order_acquire)) {
      CFDictionaryApplyFunction((CFDictionaryRef)atomic_load_explicit(a3, memory_order_acquire), (CFDictionaryApplierFunction)sub_1DC370FD8, (void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    }
    if (*((unsigned char *)a2 + 8))
    {
      CFTypeRef explicit = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v8 = *a2;
      valuePtr[0] = 0;
      valuePtr[1] = v8;
      CFNumberRef v9 = CFNumberCreate(v6, kCFNumberMaxType|kCFNumberSInt8Type, valuePtr);
      uint64_t v10 = (const void *)*MEMORY[0x1E4F24D90];
      CFNumberRef v17 = v9;
      CFDictionarySetValue(explicit, v10, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v17);
    }
    if (*((unsigned char *)a2 + 24))
    {
      CFNumberRef v11 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      valuePtr[0] = a2[2];
      CFNumberRef v12 = CFNumberCreate(v6, kCFNumberDoubleType, valuePtr);
      CFNumberRef v13 = (const void *)*MEMORY[0x1E4F24D88];
      CFNumberRef v17 = v12;
      CFDictionarySetValue(v11, v13, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire));
      sub_1DC3065B8((atomic_ullong *)&v17);
    }
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v6, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  }
  else
  {
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    CFNumberRef v15 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      LOWORD(valuePtr[0]) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_ERROR, "CFDictionaryCreateMutable failed", (uint8_t *)valuePtr, 2u);
    }
    CFDictionaryRef Copy = 0;
  }
  *a1 = Copy;
  return sub_1DC306584((atomic_ullong *)&Mutable);
}

void sub_1DC370FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9, atomic_ullong a10)
{
}

void sub_1DC370FD8(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t sub_1DC370FEC(CVPixelBufferPoolRef *a1, atomic_ullong *a2, atomic_ullong *a3, uint64_t a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CVPixelBufferPoolRef poolOut = 0;
  uint64_t result = CVPixelBufferPoolCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), (CFDictionaryRef)atomic_load_explicit(a3, memory_order_acquire), &poolOut);
  if (result)
  {
    int v7 = result;
    if (qword_1EAA94CA0 != -1) {
      dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
    }
    uint64_t v8 = qword_1EAA94C98;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v7;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "CVPixelBufferPoolCreate failed: %{public}d", buf, 8u);
    }
    *(void *)long long buf = -2003;
    uint64_t v10 = @"CVPixelBufferPoolCreate failed.";
    uint64_t result = sub_1DC306334((atomic_ullong *)a4, (uint64_t *)buf, (CFTypeRef *)&v10);
    CVPixelBufferPoolRef v9 = 0;
    *(_DWORD *)(a4 + 24) = v7;
    *(unsigned char *)(a4 + 28) = 1;
  }
  else
  {
    CVPixelBufferPoolRef v9 = poolOut;
  }
  *a1 = v9;
  return result;
}

atomic_ullong *sub_1DC37112C(CVPixelBufferPoolRef *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  atomic_ullong v11 = 0;
  sub_1DC370DDC(&v12, a2, &v11);
  atomic_ullong v8 = 0;
  atomic_ullong v9 = 0;
  sub_1DC3708C4(&v10, a3, &v9, &v8);
  sub_1DC370FEC(a1, (atomic_ullong *)&v12, (atomic_ullong *)&v10, a4);
  sub_1DC31EBFC((atomic_ullong *)&v10);
  sub_1DC31EBFC(&v8);
  sub_1DC31EBFC(&v9);
  sub_1DC31EBFC((atomic_ullong *)&v12);
  return sub_1DC31EBFC(&v11);
}

void sub_1DC3711C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  atomic_ullong v3 = va_arg(va1, void);
  va_copy(va2, va1);
  atomic_ullong v5 = va_arg(va2, void);
  va_copy(va3, va2);
  atomic_ullong v7 = va_arg(va3, void);
  va_copy(va4, va3);
  atomic_ullong v9 = va_arg(va4, void);
  sub_1DC31EBFC((atomic_ullong *)va2);
  sub_1DC31EBFC((atomic_ullong *)va);
  sub_1DC31EBFC((atomic_ullong *)va1);
  sub_1DC31EBFC((atomic_ullong *)va4);
  sub_1DC31EBFC((atomic_ullong *)va3);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC37120C(CVPixelBufferPoolRef *a1, uint64_t *a2, uint64_t a3)
{
  atomic_ullong v9 = 0;
  atomic_ullong v6 = 0;
  atomic_ullong v7 = 0;
  sub_1DC3708C4(&v8, a2, &v7, &v6);
  sub_1DC370FEC(a1, &v9, (atomic_ullong *)&v8, a3);
  sub_1DC31EBFC((atomic_ullong *)&v8);
  sub_1DC31EBFC(&v6);
  sub_1DC31EBFC(&v7);
  return sub_1DC31EBFC(&v9);
}

void sub_1DC371284(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9, atomic_ullong a10, atomic_ullong a11, atomic_ullong a12)
{
}

atomic_ullong *sub_1DC3712B8(CVPixelBufferRef *a1, atomic_ullong *a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  atomic_ullong v14 = 0;
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    pixelBufferOut[0] = 0;
    unint64_t v5 = atomic_load_explicit(&v14, memory_order_acquire);
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFTypeRef explicit = (__CVPixelBufferPool *)atomic_load_explicit(a2, memory_order_acquire);
    if (v5)
    {
      CVReturn PixelBufferWithAuxAttributes = CVPixelBufferPoolCreatePixelBufferWithAuxAttributes(v6, explicit, (CFDictionaryRef)atomic_load_explicit(&v14, memory_order_acquire), pixelBufferOut);
      if (PixelBufferWithAuxAttributes)
      {
        if (qword_1EAA94CA0 != -1) {
          dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
        }
        atomic_ullong v9 = qword_1EAA94C98;
        if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = PixelBufferWithAuxAttributes;
          _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "CVPixelBufferPoolCreatePixelBufferWithAuxAttributes failed: %{public}d", buf, 8u);
        }
        *(void *)long long buf = -2003;
        CFNumberRef v15 = @"CVPixelBufferPoolCreatePixelBufferWithAuxAttributes failed.";
        sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v15);
LABEL_20:
        CVPixelBufferRef v12 = 0;
        *(_DWORD *)(a3 + 24) = PixelBufferWithAuxAttributes;
        *(unsigned char *)(a3 + 28) = 1;
LABEL_22:
        *a1 = v12;
        return sub_1DC31EBFC(&v14);
      }
    }
    else
    {
      CVReturn PixelBufferWithAuxAttributes = CVPixelBufferPoolCreatePixelBuffer(v6, explicit, pixelBufferOut);
      if (PixelBufferWithAuxAttributes)
      {
        if (qword_1EAA94CA0 != -1) {
          dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
        }
        atomic_ullong v11 = qword_1EAA94C98;
        if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = PixelBufferWithAuxAttributes;
          _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "CVPixelBufferPoolCreatePixelBuffer failed: %{public}d", buf, 8u);
        }
        *(void *)long long buf = -2003;
        CFNumberRef v15 = @"CVPixelBufferPoolCreatePixelBuffer failed.";
        sub_1DC306334((atomic_ullong *)a3, (uint64_t *)buf, (CFTypeRef *)&v15);
        goto LABEL_20;
      }
    }
    CVPixelBufferRef v12 = pixelBufferOut[0];
    goto LABEL_22;
  }
  if (qword_1EAA94CA0 != -1) {
    dispatch_once(&qword_1EAA94CA0, &unk_1F36624A8);
  }
  CFDictionaryRef v10 = qword_1EAA94C98;
  if (os_log_type_enabled((os_log_t)qword_1EAA94C98, OS_LOG_TYPE_ERROR))
  {
    LOWORD(pixelBufferOut[0]) = 0;
    _os_log_error_impl(&dword_1DC2FE000, v10, OS_LOG_TYPE_ERROR, "Invalid pixel buffer pool", (uint8_t *)pixelBufferOut, 2u);
  }
  pixelBufferOut[0] = (CVPixelBufferRef)-2003;
  *(void *)long long buf = @"Invalid pixel buffer pool.";
  sub_1DC306334((atomic_ullong *)a3, (uint64_t *)pixelBufferOut, (CFTypeRef *)buf);
  *a1 = 0;
  return sub_1DC31EBFC(&v14);
}

void sub_1DC371560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

void sub_1DC371E24(void *a1)
{
  sub_1DC371E5C(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC371E5C(void *a1)
{
  *a1 = &unk_1F3661048;
  uint64_t v2 = a1[4];
  if (v2)
  {
    atomic_ullong v3 = *(void **)(v2 + 8);
    CVReturn v4 = *(unsigned char **)(v2 + 16);
    if (v4 == (unsigned char *)v3)
    {
      atomic_ullong v3 = *(void **)(v2 + 16);
      if (!v4) {
        goto LABEL_9;
      }
    }
    else
    {
      unint64_t v5 = 0;
      do
      {
        if (v3[v5])
        {
          MEMORY[0x1E019CE90](v3[v5], 0x1000C4000313F17);
          atomic_ullong v3 = *(void **)(v2 + 8);
          CVReturn v4 = *(unsigned char **)(v2 + 16);
        }
        ++v5;
      }
      while (v5 < (v4 - (unsigned char *)v3) >> 3);
      if (!v3) {
        goto LABEL_9;
      }
    }
    *(void *)(v2 + 16) = v3;
    operator delete(v3);
LABEL_9:
    MEMORY[0x1E019CE90](v2, 0x1080C406BDE4C18);
  }
  return a1;
}

void *sub_1DC371F24(void *a1, void *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CVReturn v4 = operator new(8uLL);
  *a1 = v4;
  a1[1] = v4;
  a1[2] = v4 + 1;
  *CVReturn v4 = *a2;
  a1[1] = v4 + 1;
  return a1;
}

uint64_t sub_1DC371F74(uint64_t result, int a2, int a3, int a4, int a5, int a6, uint64_t a7)
{
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = a2;
  *(void *)uint64_t result = &unk_1F3661048;
  *(_DWORD *)(result + 16) = a3;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  *(_DWORD *)(result + 28) = a6;
  *(void *)(result + 32) = a7;
  uint64_t v8 = *(void *)(a7 + 8);
  uint64_t v7 = *(void *)(a7 + 16);
  uint64_t v9 = v7 - v8;
  if (v7 == v8)
  {
    int v11 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 0;
    unint64_t v12 = v9 >> 3;
    do
    {
      v11 += (*(_DWORD *)(*(void *)(v8 + 8 * v10) + 4) + *(_DWORD *)a7) * **(_DWORD **)(v8 + 8 * v10);
      ++v10;
    }
    while (v12 > v10);
  }
  *(_DWORD *)(result + 40) = v11;
  return result;
}

uint64_t sub_1DC371FE8(uint64_t (***a1)(void))
{
  return (**a1)();
}

void sub_1DC371FF4()
{
}

void sub_1DC373B78(_Unwind_Exception *a1)
{
  unint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v2 + 16) = v5;
    operator delete(v5);
  }
  MEMORY[0x1E019CE90](v2, 0x1080C406BDE4C18);
  MEMORY[0x1E019CE90](v1, 0x10A1C40F1DF6643);
  _Unwind_Resume(a1);
}

atomic_uint *sub_1DC373D40(atomic_uint *result, atomic_uint **a2)
{
  uint64_t v2 = result;
  atomic_ullong v3 = (atomic_uint **)*((void *)result + 1);
  void *v3 = 0;
  CVReturn v4 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    uint64_t result = *v3;
    if (*v3) {
      uint64_t result = sub_1DC2FF57C(result);
    }
  }
  void *v3 = v4;
  *((void *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1DC373D98(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC373DA0(atomic_uint ***a1, atomic_uint **a2)
{
  uint64_t v2 = a1[1] - *a1;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  uint64_t v6 = (char *)a1[2] - (char *)*a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  CFNumberRef v26 = a1 + 2;
  if (v7)
  {
    if (v7 >> 61) {
      sub_1DC2FF994();
    }
    uint64_t v8 = (char *)operator new(8 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (atomic_uint **)&v8[8 * v2];
  uint64_t v23 = v8;
  v24.i64[0] = (uint64_t)v9;
  v24.i64[1] = (uint64_t)v9;
  uint64_t v25 = &v8[8 * v7];
  *uint64_t v9 = 0;
  uint64_t v10 = *a2;
  int v11 = v9;
  unint64_t v12 = v9;
  if (v10)
  {
    atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
    int v11 = v9;
    unint64_t v12 = v9;
    if (*v9)
    {
      sub_1DC2FF57C(*v9);
      unint64_t v12 = (atomic_uint **)v24.i64[1];
      int v11 = (atomic_uint **)v24.i64[0];
    }
  }
  *uint64_t v9 = v10;
  uint64_t v13 = v12 + 1;
  v24.i64[1] = (uint64_t)(v12 + 1);
  CFNumberRef v15 = *a1;
  unint64_t v14 = (unint64_t)a1[1];
  if ((atomic_uint **)v14 == *a1)
  {
    int64x2_t v20 = vdupq_n_s64(v14);
  }
  else
  {
    uint64_t v16 = 0;
    do
    {
      CFNumberRef v17 = &v11[v16];
      v11[v16 - 1] = 0;
      uint64_t v18 = *(atomic_uint **)(v14 + v16 * 8 - 8);
      if (v18)
      {
        atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
        int v19 = *(v17 - 1);
        if (v19) {
          sub_1DC2FF57C(v19);
        }
      }
      *(v17 - 1) = v18;
      --v16;
    }
    while ((atomic_uint **)(v14 + v16 * 8) != v15);
    int v11 = (atomic_uint **)((char *)v11 + v16 * 8);
    int64x2_t v20 = *(int64x2_t *)a1;
    uint64_t v13 = (atomic_uint **)v24.i64[1];
  }
  *a1 = v11;
  a1[1] = v13;
  int64x2_t v24 = v20;
  uint64_t v21 = (char *)a1[2];
  a1[2] = (atomic_uint **)v25;
  uint64_t v25 = v21;
  uint64_t v23 = (char *)v20.i64[0];
  sub_1DC373F60((uint64_t)&v23);
  return v13;
}

void sub_1DC373F2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC373F60((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC373F60(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC3627A8((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

long long *sub_1DC373FB0(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = 0;
  unsigned int v4 = 0;
  int v5 = 0x7FFFFFFF;
  do
  {
    int v6 = *(_DWORD *)((char *)&unk_1DC40C380 + v3);
    if (v6 == a2)
    {
      unint64_t v13 = *(unsigned int *)((char *)&unk_1DC40C380 + v3 + 4);
      unint64_t v14 = (char *)&unk_1DC40C480 + 12 * ((v13 >> 2) & 7);
      uint64_t v10 = *(void *)(v14 + 4);
      uint64_t result = sub_1DC39EDAC(*(_DWORD *)v14);
      int v5 = 0;
      char v12 = v13 & 3;
      goto LABEL_10;
    }
    unsigned int v7 = v6 ^ a2;
    int v8 = dword_1DC40F8F0[(v6 ^ a2) >> 4]
       + dword_1DC40F8F0[(v6 ^ a2) & 0xF]
       + dword_1DC40F8F0[(v7 >> 8) & 0xF]
       + dword_1DC40F8F0[(unsigned __int16)v7 >> 12]
       + dword_1DC40F8F0[((v6 ^ a2) >> 16) & 0xF]
       + dword_1DC40F8F0[((v6 ^ a2) >> 20) & 0xF]
       + dword_1DC40F8F0[((v6 ^ a2) >> 24) & 0xF]
       + dword_1DC40F8F0[v7 >> 28];
    if (v8 < v5)
    {
      unsigned int v4 = *(_DWORD *)((char *)&unk_1DC40C380 + v3 + 4);
      int v5 = v8;
    }
    v3 += 8;
  }
  while (v3 != 256);
  if (v5 > 3)
  {
    uint64_t result = 0;
    char v12 = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 17) = 0;
    uint64_t v10 = 3;
    int v5 = 0x7FFFFFFF;
  }
  else
  {
    uint64_t v9 = (char *)&unk_1DC40C480 + 12 * ((v4 >> 2) & 7);
    uint64_t v10 = *(void *)(v9 + 4);
    uint64_t result = sub_1DC39EDAC(*(_DWORD *)v9);
    char v12 = v4 & 3;
  }
LABEL_10:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v10;
  *(unsigned char *)(a1 + 16) = v12;
  *(_DWORD *)(a1 + 24) = v5;
  return result;
}

uint64_t MRCDecoderGetTypeID()
{
  if (qword_1EBFFB7B8[0] != -1) {
    dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
  }
  return qword_1EBFFB7A0;
}

void *sub_1DC374168()
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFB5D0) {
    _os_assumes_log();
  }
  if (qword_1EBFFB7A0) {
    _os_assumes_log();
  }
  qword_1EBFFB5D0 = (uint64_t)"MRCDecoder";
  qword_1EBFFB7A0 = _CFRuntimeRegisterClass();
  v1[3] = 0;
  sub_1DC348EB8(qword_1EBFFB7A0, v1);
  return sub_1DC30AC9C(v1);
}

void sub_1DC374210(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC30AC9C((uint64_t *)va);
  _Unwind_Resume(a1);
}

CFStringRef sub_1DC37422C(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7B8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
    }
    if (v2 != qword_1EBFFB7A0) {
      _os_assumes_log();
    }
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"<%s %p> {\n", "MRCDecoder", cf);
    if (atomic_load_explicit((atomic_ullong *volatile)cf + 2, memory_order_acquire))
    {
      CFStringRef v30 = CFCopyDescription((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)cf + 2, memory_order_acquire));
      if (atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire))
      {
        CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v3, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire), @"\n");
        if (atomic_load_explicit((atomic_ullong *volatile)&ArrayBySeparatingStrings, memory_order_acquire))
        {
          CFStringRef v28 = CFStringCreateByCombiningStrings(v3, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&ArrayBySeparatingStrings, memory_order_acquire), @"\n    ");
          if (atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire)) {
            CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    context %@\n", atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire));
          }
          sub_1DC31FA90((atomic_ullong *)&v28);
        }
        sub_1DC3065EC((atomic_ullong *)&ArrayBySeparatingStrings);
      }
      sub_1DC31FA90((atomic_ullong *)&v30);
    }
    if (atomic_load_explicit(*((atomic_ullong *volatile *)cf + 3), memory_order_acquire))
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    symbologies {");
      CFSetGetCount((CFSetRef)atomic_load_explicit(*((atomic_ullong *volatile *)cf + 3), memory_order_acquire));
      operator new[]();
    }
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    locatingMode %ld\n", *(void *)(*((void *)cf + 3) + 8));
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    accuracy 0x%x\n", *(unsigned int *)(*((void *)cf + 3) + 16));
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    maximumQRModuleSamplingCount %d\n", *(unsigned int *)(*((void *)cf + 3) + 20));
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    maximumQRFinderPatternTripletCount %d\n", *(unsigned int *)(*((void *)cf + 3) + 24));
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    maximum1DSymbologyDecodingTime %g\n", *(void *)(*((void *)cf + 3) + 32));
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    maximum1DSymbologyDecodingScanlineCount %d\n", *(unsigned int *)(*((void *)cf + 3) + 40));
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    minimum1DSymbologyDecodingScanlineCount %d\n", *(unsigned int *)(*((void *)cf + 3) + 44));
    CFTypeRef explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 48)) {
      int v5 = "true";
    }
    else {
      int v5 = "false";
    }
    CFStringAppendFormat(explicit, 0, @"    shouldStopAtFirstPyramidWith2DSymbologies %s\n", v5);
    int v6 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 49)) {
      unsigned int v7 = "true";
    }
    else {
      unsigned int v7 = "false";
    }
    CFStringAppendFormat(v6, 0, @"    needsDecoderResultAttributeUnmatchedFinderPatternPoints %s\n", v7);
    int v8 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 50)) {
      uint64_t v9 = "true";
    }
    else {
      uint64_t v9 = "false";
    }
    CFStringAppendFormat(v8, 0, @"    needsDecoderResultAttributeFocusSharpness %s\n", v9);
    uint64_t v10 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 51)) {
      int v11 = "true";
    }
    else {
      int v11 = "false";
    }
    CFStringAppendFormat(v10, 0, @"    needsDecoderResultAttributeUnrecognizedCornerPointQuadruplets %s\n", v11);
    char v12 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 52)) {
      unint64_t v13 = "true";
    }
    else {
      unint64_t v13 = "false";
    }
    CFStringAppendFormat(v12, 0, @"    needsDecoderResultAttributeUnrecognizedRegions %s\n", v13);
    unint64_t v14 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 53)) {
      CFNumberRef v15 = "true";
    }
    else {
      CFNumberRef v15 = "false";
    }
    CFStringAppendFormat(v14, 0, @"    needsDecoderResultAttributeDebugInfo %s\n", v15);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    algorithmVersion 0x%lx (major=%ld, minor=%ld)\n", *(void *)(*((void *)cf + 3) + 56), *(uint64_t *)(*((void *)cf + 3) + 56) >> 16, (unsigned __int16)*(void *)(*((void *)cf + 3) + 56));
    uint64_t v16 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 64)) {
      CFNumberRef v17 = "true";
    }
    else {
      CFNumberRef v17 = "false";
    }
    CFStringAppendFormat(v16, 0, @"    allowsAlgorithmicVersioningFallback %s\n", v17);
    uint64_t v18 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 65)) {
      int v19 = "true";
    }
    else {
      int v19 = "false";
    }
    CFStringAppendFormat(v18, 0, @"    allowsPyramidGenerationOnDemand %s\n", v19);
    int64x2_t v20 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 66)) {
      uint64_t v21 = "true";
    }
    else {
      uint64_t v21 = "false";
    }
    CFStringAppendFormat(v20, 0, @"    allowsConcurrentDecoding %s\n", v21);
    CFNumberRef v22 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 67)) {
      uint64_t v23 = "true";
    }
    else {
      uint64_t v23 = "false";
    }
    CFStringAppendFormat(v22, 0, @"    shouldCoalesceCompositeSymbologies %s\n", v23);
    int64x2_t v24 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (*(unsigned char *)(*((void *)cf + 3) + 68)) {
      uint64_t v25 = "true";
    }
    else {
      uint64_t v25 = "false";
    }
    CFStringAppendFormat(v24, 0, @"    shouldCollectMetrics %s\n", v25);
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"}");
    CFStringRef Copy = CFStringCreateCopy(v3, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    sub_1DC326F90((atomic_ullong *)&Mutable);
    if (Copy) {
      return Copy;
    }
  }
  else
  {
    sub_1DC326F90((atomic_ullong *)&Mutable);
  }
  return CFStringCreateWithFormat(v3, 0, @"<%s %p>", "MRCDecoder", cf);
}

void sub_1DC374800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  atomic_ullong v6 = va_arg(va1, void);
  va_copy(va2, va1);
  atomic_ullong v8 = va_arg(va2, void);
  va_copy(va3, va2);
  atomic_ullong v10 = va_arg(va3, void);
  sub_1DC31FA90((atomic_ullong *)va);
  sub_1DC3065EC((atomic_ullong *)va1);
  sub_1DC31FA90((atomic_ullong *)va2);
  sub_1DC326F90((atomic_ullong *)va3);
  _Unwind_Resume(a1);
}

unint64_t sub_1DC374854(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7B8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
    }
    if (v2 != qword_1EBFFB7A0) {
      _os_assumes_log();
    }
  }
  uint64_t v3 = *((void *)cf + 3);
  CFTypeRef explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)v3, memory_order_acquire);
  if (explicit) {
    CFHashCode v5 = CFHash(explicit) + 2654435769u;
  }
  else {
    CFHashCode v5 = 3317042773;
  }
  unint64_t v6 = (*(void *)(v3 + 8) + 2654435769 + (v5 << 6) + (v5 >> 2)) ^ v5;
  unint64_t v7 = (*(unsigned int *)(v3 + 16) + 2654435769 + (v6 << 6) + (v6 >> 2)) ^ v6;
  unint64_t v8 = (*(int *)(v3 + 20) + 2654435769 + (v7 << 6) + (v7 >> 2)) ^ v7;
  unint64_t v9 = (*(int *)(v3 + 24) + 2654435769 + (v8 << 6) + (v8 >> 2)) ^ v8;
  uint64_t v10 = *(void *)(v3 + 32) + 2654435769;
  if (*(double *)(v3 + 32) == 0.0) {
    uint64_t v10 = 2654435769;
  }
  unint64_t v11 = (v10 + (v9 << 6) + (v9 >> 2)) ^ v9;
  unint64_t v12 = (*(int *)(v3 + 40) + 2654435769 + (v11 << 6) + (v11 >> 2)) ^ v11;
  unint64_t v13 = (*(int *)(v3 + 44) + 2654435769 + (v12 << 6) + (v12 >> 2)) ^ v12;
  unint64_t v14 = (*(unsigned __int8 *)(v3 + 48) + 2654435769 + (v13 << 6) + (v13 >> 2)) ^ v13;
  unint64_t v15 = (*(unsigned __int8 *)(v3 + 49) + 2654435769 + (v14 << 6) + (v14 >> 2)) ^ v14;
  unint64_t v16 = (*(unsigned __int8 *)(v3 + 51) + 2654435769 + (v15 << 6) + (v15 >> 2)) ^ v15;
  unint64_t v17 = (*(unsigned __int8 *)(v3 + 52) + 2654435769 + (v16 << 6) + (v16 >> 2)) ^ v16;
  unint64_t v18 = (*(unsigned __int8 *)(v3 + 53) + 2654435769 + (v17 << 6) + (v17 >> 2)) ^ v17;
  unint64_t v19 = (*(void *)(v3 + 56) + 2654435769 + (v18 << 6) + (v18 >> 2)) ^ v18;
  unint64_t v20 = (*(unsigned __int8 *)(v3 + 64) + 2654435769 + (v19 << 6) + (v19 >> 2)) ^ v19;
  unint64_t v21 = (*(unsigned __int8 *)(v3 + 65) + 2654435769 + (v20 << 6) + (v20 >> 2)) ^ v20;
  unint64_t v22 = (*(unsigned __int8 *)(v3 + 66) + 2654435769 + (v21 << 6) + (v21 >> 2)) ^ v21;
  unint64_t v23 = (*(unsigned __int8 *)(v3 + 67) + 2654435769 + (v22 << 6) + (v22 >> 2)) ^ v22;
  return (*(unsigned __int8 *)(v3 + 68) + 2654435769 + (v23 << 6) + (v23 >> 2)) ^ v23;
}

uint64_t sub_1DC374A6C(CFTypeRef cf, CFTypeRef a2)
{
  if (!cf) {
    goto LABEL_5;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (qword_1EBFFB7B8[0] != -1) {
    dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
  }
  if (v4 != qword_1EBFFB7A0)
  {
    _os_assumes_log();
    if (!a2) {
      goto LABEL_10;
    }
  }
  else
  {
LABEL_5:
    if (!a2) {
      goto LABEL_10;
    }
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (qword_1EBFFB7B8[0] != -1) {
    dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
  }
  if (v5 != qword_1EBFFB7A0) {
    _os_assumes_log();
  }
LABEL_10:
  uint64_t v6 = *((void *)cf + 3);
  uint64_t v7 = *((void *)a2 + 3);
  CFTypeRef explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)v7, memory_order_acquire);
  unint64_t v9 = (const void *)atomic_load_explicit((atomic_ullong *volatile)v6, memory_order_acquire);
  if (v9 == explicit)
  {
LABEL_16:
    if (*(void *)(v6 + 8) == *(void *)(v7 + 8)
      && *(_DWORD *)(v6 + 16) == *(_DWORD *)(v7 + 16)
      && *(_DWORD *)(v6 + 20) == *(_DWORD *)(v7 + 20)
      && *(_DWORD *)(v6 + 24) == *(_DWORD *)(v7 + 24)
      && *(double *)(v6 + 32) == *(double *)(v7 + 32)
      && *(_DWORD *)(v6 + 40) == *(_DWORD *)(v7 + 40)
      && *(_DWORD *)(v6 + 44) == *(_DWORD *)(v7 + 44)
      && *(unsigned __int8 *)(v6 + 48) == *(unsigned __int8 *)(v7 + 48)
      && *(unsigned __int8 *)(v6 + 49) == *(unsigned __int8 *)(v7 + 49)
      && *(unsigned __int8 *)(v6 + 50) == *(unsigned __int8 *)(v7 + 50)
      && *(unsigned __int8 *)(v6 + 51) == *(unsigned __int8 *)(v7 + 51)
      && *(unsigned __int8 *)(v6 + 52) == *(unsigned __int8 *)(v7 + 52)
      && *(unsigned __int8 *)(v6 + 53) == *(unsigned __int8 *)(v7 + 53)
      && *(void *)(v6 + 56) == *(void *)(v7 + 56)
      && *(unsigned __int8 *)(v6 + 64) == *(unsigned __int8 *)(v7 + 64)
      && *(unsigned __int8 *)(v6 + 65) == *(unsigned __int8 *)(v7 + 65)
      && *(unsigned __int8 *)(v6 + 66) == *(unsigned __int8 *)(v7 + 66)
      && *(unsigned __int8 *)(v6 + 67) == *(unsigned __int8 *)(v7 + 67))
    {
      return *(unsigned __int8 *)(v6 + 68) == *(unsigned __int8 *)(v7 + 68);
    }
    return 0;
  }
  if (explicit) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    uint64_t result = CFEqual(v9, explicit);
    if (!result) {
      return result;
    }
    goto LABEL_16;
  }
  return 0;
}

atomic_ullong *sub_1DC374CC0(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7B8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
    }
    if (v2 != qword_1EBFFB7A0) {
      _os_assumes_log();
    }
    CFTypeID v3 = CFGetTypeID(cf);
    if (qword_1EBFFB7B8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
    }
    if (v3 != qword_1EBFFB7A0) {
      _os_assumes_log();
    }
  }
  sub_1DC374DBC((atomic_ullong **)cf + 3);
  return sub_1DC3599F8((atomic_ullong *)cf + 2);
}

atomic_ullong *sub_1DC374DBC(atomic_ullong **a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1DC374E0C(result);
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

atomic_ullong *sub_1DC374E0C(atomic_ullong *a1)
{
  CFTypeID v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

unint64_t MRCDecoderCreateWithOptions(CFTypeRef a1)
{
  if (a1) {
    a1 = CFRetain(a1);
  }
  CFTypeRef v11 = a1;
  if (qword_1EBFFB7B8[0] != -1) {
    dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
  }
  Instance = (void *)_CFRuntimeCreateInstance();
  CFTypeID v2 = Instance;
  if (Instance)
  {
    CFTypeID v3 = CFGetTypeID(Instance);
    if (qword_1EBFFB7B8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
    }
    if (v3 != qword_1EBFFB7A0) {
      _os_assumes_log();
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire)
      && (Value = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire), @"MRCDecoderOptionContext"), (CFTypeID v5 = Value) != 0))
    {
      CFTypeID v6 = CFGetTypeID(Value);
      if (qword_1EBFFB7E0 != -1) {
        dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
      }
      if (v6 != qword_1EBFFB818) {
        _os_assumes_log();
      }
      CFTypeRef v7 = CFRetain(v5);
    }
    else
    {
      CFTypeRef v7 = 0;
    }
    v2[2] = v7;
    operator new();
  }
  atomic_ullong v12 = 0;
  unint64_t v8 = atomic_exchange(&v12, 0);
  unint64_t v9 = (const void *)atomic_exchange(&v12, 0);
  if (v9) {
    CFRelease(v9);
  }
  sub_1DC31EBFC((atomic_ullong *)&v11);
  return v8;
}

void sub_1DC3750D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC374DBC(v3);
  sub_1DC3599F8(v2);
  sub_1DC31EBFC((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC375140(uint64_t a1, atomic_ullong *a2)
{
  sub_1DC37566C((atomic_ullong *)a1, a2, @"MRCDecoderOptionSymbologies");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 13;
  *(void *)(a1 + 16) = -2575995796;
  *(_DWORD *)(a1 + 24) = -1;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 46) = 0;
  *(void *)(a1 + 56) = 0x40000;
  *(unsigned char *)(a1 + 64) = 1;
  *(_DWORD *)(a1 + 65) = 0;
  sub_1DC38648C((CFDictionaryRef *)&v48, (const __CFDictionary *)atomic_load_explicit(a2, memory_order_acquire));
  CFStringRef v4 = sub_1DC386224(@"MRCDecoderOptionLocatingMode");
  if (v4 && (CFTypeRef v5 = sub_1DC38652C((CFDictionaryRef *)&v48, v4), CFRelease(v4), v5))
  {
    unint64_t v6 = sub_1DC385F4C(v5);
    char v8 = v7;
    CFRelease(v5);
    BOOL v9 = v8 != 0;
    if (v8) {
      unint64_t v10 = v6;
    }
    else {
      unint64_t v10 = 0;
    }
    unint64_t v11 = v10 & 0xFFFFFFFFFFFFFF00;
    uint64_t v12 = v10;
  }
  else
  {
    unint64_t v11 = 0;
    BOOL v9 = 0;
    uint64_t v12 = 0;
  }
  CFStringRef v13 = sub_1DC386224(@"MRCDecoderOptionAccuracy");
  BOOL v45 = v9;
  int v46 = a2;
  uint64_t v43 = v12;
  unint64_t v44 = v11;
  if (v13 && (CFTypeRef v14 = sub_1DC38652C((CFDictionaryRef *)&v48, v13), CFRelease(v13), v14))
  {
    unint64_t v15 = sub_1DC385E84(v14);
    CFRelease(v14);
    uint64_t v16 = v15 | 0x100000000;
    if (!HIDWORD(v15)) {
      uint64_t v16 = 0;
    }
    uint64_t v17 = v16 & 0x100000000;
    int v42 = v16 & 0xFFFFFF00;
    int v18 = v16;
  }
  else
  {
    int v42 = 0;
    uint64_t v17 = 0;
    int v18 = 0;
  }
  unint64_t v19 = sub_1DC3757B4((CFDictionaryRef *)&v48, @"MRCDecoderOptionMaximumQRModuleSamplingCount");
  unint64_t v20 = sub_1DC3757B4((CFDictionaryRef *)&v48, @"MRCDecoderOptionMaximumQRFinderPatternTripletCount");
  unint64_t v21 = sub_1DC3758A8((CFDictionaryRef *)&v48, @"MRCDecoderOptionMaximum1DSymbologyDecodingTime");
  char v23 = v22;
  unint64_t v24 = sub_1DC3757B4((CFDictionaryRef *)&v48, @"MRCDecoderOptionMaximum1DSymbologyDecodingScanlineCount");
  unint64_t v25 = sub_1DC3757B4((CFDictionaryRef *)&v48, @"MRCDecoderOptionMinimum1DSymbologyDecodingScanlineCount");
  unsigned __int16 v26 = sub_1DC375948((CFDictionaryRef *)&v48, @"MRCDecoderOptionShouldStopAtFirstPyramidWith2DSymbologies");
  if (v45) {
    *(void *)(a1 + 8) = v43 | v44;
  }
  if (v17) {
    *(_DWORD *)(a1 + 16) = v42 | v18;
  }
  unint64_t v27 = HIDWORD(v19);
  if (HIDWORD(v19)) {
    *(_DWORD *)(a1 + 20) = v19;
  }
  unint64_t v28 = HIDWORD(v20);
  if (HIDWORD(v20)) {
    *(_DWORD *)(a1 + 24) = v20;
  }
  if (v23) {
    *(void *)(a1 + 32) = v21;
  }
  if (HIDWORD(v24)) {
    *(_DWORD *)(a1 + 40) = v24;
  }
  if (HIDWORD(v25)) {
    *(_DWORD *)(a1 + 44) = v25;
  }
  if (v26 >= 0x100u) {
    *(unsigned char *)(a1 + 48) = v26;
  }
  int v29 = *(_DWORD *)(a1 + 16);
  if (v29 == 1751738216)
  {
    if (!v27) {
      *(_DWORD *)(a1 + 20) = 7000;
    }
    if (!v28)
    {
      int v30 = 30;
      goto LABEL_40;
    }
  }
  else if (v29 == 1819244288)
  {
    if (!v27) {
      *(_DWORD *)(a1 + 20) = 3000;
    }
    if (!v28)
    {
      int v30 = 10;
LABEL_40:
      *(_DWORD *)(a1 + 24) = v30;
    }
  }
  sub_1DC37566C(&v47, v46, @"MRCDecoderOptionNeededResultAttributes");
  if (atomic_load_explicit(&v47, memory_order_acquire))
  {
    *(unsigned char *)(a1 + 49) = CFSetContainsValue((CFSetRef)atomic_load_explicit(&v47, memory_order_acquire), @"LocatorPoints") != 0;
    *(unsigned char *)(a1 + 50) = CFSetContainsValue((CFSetRef)atomic_load_explicit(&v47, memory_order_acquire), @"FocusSharpness") != 0;
    *(unsigned char *)(a1 + 51) = CFSetContainsValue((CFSetRef)atomic_load_explicit(&v47, memory_order_acquire), @"FrameFailedLocations") != 0;
    *(unsigned char *)(a1 + 52) = CFSetContainsValue((CFSetRef)atomic_load_explicit(&v47, memory_order_acquire), @"MRCDecoderResultAttributeUnrecognizedRegions") != 0;
    *(unsigned char *)(a1 + 53) = CFSetContainsValue((CFSetRef)atomic_load_explicit(&v47, memory_order_acquire), @"FrameDebugData") != 0;
  }
  CFStringRef v31 = sub_1DC386224(@"MRCDecoderOptionAlgorithmVersion");
  if (v31)
  {
    CFTypeRef v32 = sub_1DC38652C((CFDictionaryRef *)&v48, v31);
    CFRelease(v31);
    if (v32)
    {
      unint64_t v33 = sub_1DC385F4C(v32);
      char v35 = v34;
      CFRelease(v32);
      if (v35) {
        *(void *)(a1 + 56) = v33;
      }
    }
  }
  unsigned __int16 v36 = sub_1DC375948((CFDictionaryRef *)&v48, @"MRCDecoderOptionAllowsAlgorithmicVersioningFallback");
  if (v36 >= 0x100u) {
    *(unsigned char *)(a1 + 64) = v36;
  }
  unsigned __int16 v37 = sub_1DC375948((CFDictionaryRef *)&v48, @"MRCDecoderOptionAllowsPyramidGenerationOnDemand");
  if (v37 >= 0x100u) {
    goto LABEL_53;
  }
  if (*(uint64_t *)(a1 + 56) >= 196608 && _os_feature_enabled_impl())
  {
    LOBYTE(v37) = 1;
LABEL_53:
    *(unsigned char *)(a1 + 65) = v37;
  }
  unsigned __int16 v38 = sub_1DC375948((CFDictionaryRef *)&v48, @"MRCDecoderOptionAllowsConcurrentDecoding");
  if (v38 >= 0x100u) {
    *(unsigned char *)(a1 + 66) = v38;
  }
  unsigned __int16 v39 = sub_1DC375948((CFDictionaryRef *)&v48, @"MRCDecoderOptionShouldCoalesceCompositeSymbologies");
  if (v39 < 0x100u)
  {
    if (*(uint64_t *)(a1 + 56) < 0x40000) {
      goto LABEL_60;
    }
    LOBYTE(v39) = 1;
  }
  *(unsigned char *)(a1 + 67) = v39;
LABEL_60:
  unsigned __int16 v40 = sub_1DC375948((CFDictionaryRef *)&v48, @"MRCDecoderOptionShouldCollectMetrics");
  if (v40 >= 0x100u) {
    *(unsigned char *)(a1 + 68) = v40;
  }
  sub_1DC374E0C(&v47);
  sub_1DC3864F8(&v48);
  return a1;
}

void sub_1DC375600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  atomic_ullong v9 = va_arg(va1, void);
  sub_1DC374E0C((atomic_ullong *)va);
  sub_1DC3864F8((const void **)va1);
  sub_1DC374E0C(v7);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC37566C(atomic_ullong *result, atomic_ullong *a2, void *key)
{
  CFTypeID v3 = result;
  if (atomic_load_explicit(a2, memory_order_acquire)
    && (uint64_t result = (atomic_ullong *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), key)) != 0)
  {
    CFArrayRef v4 = (const __CFArray *)result;
    CFTypeID v5 = CFGetTypeID(result);
    if (v5 == CFArrayGetTypeID())
    {
      uint64_t Count = CFArrayGetCount(v4);
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D548]);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFTypeRef explicit = (__CFSet *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
          ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(v4, i);
          CFSetSetValue(explicit, ValueAtIndex);
        }
      }
      atomic_ullong *v3 = (atomic_ullong)CFSetCreateCopy(v7, (CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
      return sub_1DC3759D0((atomic_ullong *)&Mutable);
    }
    else
    {
      CFTypeID v11 = CFGetTypeID(v4);
      if (v11 != CFSetGetTypeID()) {
        _os_assumes_log();
      }
      uint64_t result = (atomic_ullong *)CFRetain(v4);
      atomic_ullong *v3 = (atomic_ullong)result;
    }
  }
  else
  {
    atomic_ullong *v3 = 0;
  }
  return result;
}

void sub_1DC37579C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3759D0((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

unint64_t sub_1DC3757B4(CFDictionaryRef *a1, const __CFString *a2)
{
  CFStringRef v3 = sub_1DC386224(a2);
  if (!v3)
  {
    uint64_t v8 = 0;
LABEL_8:
    uint64_t v9 = 0;
    return v8 | (unint64_t)v3 | v9;
  }
  CFTypeRef v4 = sub_1DC38652C(a1, v3);
  CFRelease(v3);
  if (!v4)
  {
    uint64_t v8 = 0;
    CFStringRef v3 = 0;
    goto LABEL_8;
  }
  CFTypeID v5 = CFGetTypeID(v4);
  if (v5 == CFNumberGetTypeID() && !CFNumberIsFloatType((CFNumberRef)v4))
  {
    int Value = CFNumberGetValue((CFNumberRef)v4, kCFNumberSInt32Type, &valuePtr);
    unsigned int v7 = valuePtr & 0xFFFFFF00;
    int v6 = valuePtr;
    if (!Value)
    {
      unsigned int v7 = 0;
      int v6 = 0;
    }
    CFStringRef v3 = (const __CFString *)((unint64_t)(Value != 0) << 32);
  }
  else
  {
    int v6 = 0;
    CFStringRef v3 = 0;
    unsigned int v7 = 0;
  }
  int v11 = v7 | v6;
  CFRelease(v4);
  uint64_t v8 = v11 & 0xFFFFFF00;
  uint64_t v9 = v11;
  return v8 | (unint64_t)v3 | v9;
}

unint64_t sub_1DC3758A8(CFDictionaryRef *a1, const __CFString *a2)
{
  CFStringRef v3 = sub_1DC386224(a2);
  if (v3 && (v4 = v3, CFTypeRef v5 = sub_1DC38652C(a1, v3), CFRelease(v4), v5))
  {
    uint64_t v6 = sub_1DC386094(v5);
    unsigned __int8 v7 = v6;
    unint64_t v8 = v6 & 0xFFFFFFFFFFFFFF00;
    CFRelease(v5);
    uint64_t v9 = v7;
  }
  else
  {
    unint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  return v9 | v8;
}

uint64_t sub_1DC375948(CFDictionaryRef *a1, const __CFString *a2)
{
  CFStringRef v3 = sub_1DC386224(a2);
  if (v3)
  {
    CFTypeRef v4 = sub_1DC38652C(a1, v3);
    CFRelease(v3);
    if (v4)
    {
      __int16 v5 = sub_1DC386368(v4);
      LOBYTE(v3) = v5;
      int v6 = HIBYTE(v5);
      CFRelease(v4);
    }
    else
    {
      int v6 = 0;
      LOBYTE(v3) = 0;
    }
  }
  else
  {
    int v6 = 0;
  }
  return v3 | (v6 << 8);
}

atomic_ullong *sub_1DC3759D0(atomic_ullong *a1)
{
  CFTypeID v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void *MRCDecoderDecodeSample(__n128 a1)
{
  return MRCDecoderDecodeSampleWithRegions(a1);
}

const void *MRCDecoderDecodeSampleWithRegions(__n128 a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v139 = v2;
  CFArrayRef v4 = v3;
  int v6 = v5;
  unsigned __int8 v7 = (void *)v1;
  uint64_t v183 = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFC270 != -1) {
    dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
  }
  unint64_t v8 = qword_1EBFFC278;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC278, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDecoderDecodeSampleWithRegions: enter", (uint8_t *)&buf, 2u);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDecoderDecodeSampleWithRegions: decoder: %{public}@", (uint8_t *)&buf, 0xCu);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDecoderDecodeSampleWithRegions: sample: %{public}@", (uint8_t *)&buf, 0xCu);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v4;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDecoderDecodeSampleWithRegions: regions: %{public}@", (uint8_t *)&buf, 0xCu);
  }
  oslog = v8;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    CFMutableSetRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (v7)
    {
      CFTypeID v13 = CFGetTypeID(v7);
      if (qword_1EBFFB7B8[0] != -1) {
        dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
      }
      if (v13 != qword_1EBFFB7A0) {
        _os_assumes_log();
      }
    }
    sub_1DC3D566C();
    buf.__r_.__value_.__s.__data_[0] = 0;
    buf.__r_.__value_.__s.__data_[4] = 0;
    CFTypeRef v14 = (atomic_ullong *)v7[3];
    uint64_t v15 = sub_1DC3777A8(v14, (uint64_t)&buf);
    buf.__r_.__value_.__s.__data_[0] = 0;
    buf.__r_.__value_.__s.__data_[4] = 0;
    if (sub_1DC3778A8(v14, @"QR", (uint64_t)&buf)) {
      int v16 = 2;
    }
    else {
      int v16 = 0;
    }
    __dst[0] = 0;
    __dst[4] = 0;
    int v17 = v16 | sub_1DC3778A8(v14, @"DataMatrix", (uint64_t)__dst);
    LOBYTE(v151[0]) = 0;
    BYTE4(v151[0]) = 0;
    if (sub_1DC3778A8(v14, @"Aztec", (uint64_t)v151)) {
      int v18 = 2;
    }
    else {
      int v18 = 0;
    }
    LOBYTE(v147) = 0;
    BYTE4(v147) = 0;
    uint64_t v19 = v18 | (4 * v17) | sub_1DC3778A8(v14, @"MicroQR", (uint64_t)&v147);
    buf.__r_.__value_.__s.__data_[0] = 0;
    buf.__r_.__value_.__s.__data_[4] = 0;
    if (sub_1DC3778A8(v14, @"Codabar", (uint64_t)&buf)) {
      int v20 = 2;
    }
    else {
      int v20 = 0;
    }
    __dst[0] = 0;
    __dst[4] = 0;
    int v21 = v20 | sub_1DC3778A8(v14, @"GS1DataBar", (uint64_t)__dst);
    LOBYTE(v151[0]) = 0;
    BYTE4(v151[0]) = 0;
    if (sub_1DC3778A8(v14, @"GS1DataBarExpanded", (uint64_t)v151)) {
      int v22 = 2;
    }
    else {
      int v22 = 0;
    }
    LOBYTE(v147) = 0;
    BYTE4(v147) = 0;
    uint64_t v23 = v22 | (4 * v21) | sub_1DC3778A8(v14, @"GS1DataBarLimited", (uint64_t)&v147);
    buf.__r_.__value_.__s.__data_[0] = 0;
    buf.__r_.__value_.__s.__data_[4] = 0;
    unsigned int v24 = sub_1DC3778A8(v14, @"AppClipCode", (uint64_t)&buf);
    CFStringAppendFormat(Mutable, 0, @"V%d Symbol_%d_%d_%d_%d", (unint64_t)v14[7] >> 16, v15, v19, v23, v24);
    CVPixelBuffer = (__CVBuffer *)MRCSampleGetCVPixelBuffer(v6);
    if (CVPixelBufferIsPlanar(CVPixelBuffer))
    {
      size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(CVPixelBuffer, 0);
      size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(CVPixelBuffer, 0);
    }
    else
    {
      size_t WidthOfPlane = CVPixelBufferGetWidth(CVPixelBuffer);
      size_t HeightOfPlane = CVPixelBufferGetHeight(CVPixelBuffer);
    }
    size_t v28 = HeightOfPlane;
    double RegionOfInterest = MRCSampleGetRegionOfInterest((CFTypeRef)v6);
    double v31 = v30;
    double v33 = v32;
    double v35 = v34;
    PyramiCGFloat d = (const __CFArray *)MRCSampleGetPyramid((atomic_ullong *)v6);
    if (Pyramid) {
      PyramiCGFloat d = (const __CFArray *)CFArrayGetCount(Pyramid);
    }
    *((void *)&v135 + 1) = (int)v33;
    int v136 = (uint64_t *)(int)v35;
    *((void *)&v134 + 1) = (int)RegionOfInterest;
    *(void *)&long long v135 = (int)v31;
    *((void *)&v133 + 1) = v28;
    *(void *)&long long v134 = Pyramid;
    CFStringAppendFormat(Mutable, 0, @" Sample %zux%zu Pyramids_%d ROI_%d_%d_%d_%d", WidthOfPlane);
    CFStringAppend(Mutable, @" Regions");
    if (v4)
    {
      CFIndex Count = CFArrayGetCount(v4);
      if (Count)
      {
        ValueAtIndeCGFloat x = (__n128 *)CFArrayGetValueAtIndex(v4, 0);
        unsigned __int16 v39 = ValueAtIndex;
        if (!ValueAtIndex) {
          goto LABEL_45;
        }
        CFTypeID v40 = CFGetTypeID(ValueAtIndex);
        if (qword_1EBFFB6F8[0] != -1) {
          dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
        }
        if (v40 == qword_1EBFFB6F0)
        {
          long long v165 = 0u;
          memset(__dst, 0, sizeof(__dst));
          MRCRegionGetTransform(v39, (__n128 *)__dst);
          long long v135 = v165;
          long long v133 = *(_OWORD *)__dst;
          long long v134 = *(_OWORD *)&__dst[16];
          CFStringAppendFormat(Mutable, 0, @" Transform_%.2f_%.2f_%.2f_%.2f_%.2f_%.2f ");
          if (Count >= 1)
          {
            for (CFIndex i = 0; i != Count; ++i)
            {
              int v42 = (__n128 *)CFArrayGetValueAtIndex(v4, i);
              MRCRegionGetCornerPoints(v42, (__n128 *)&buf);
              SymbologCGFloat y = MRCRegionGetSymbology((atomic_ullong *)v42);
              long long v44 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
              double v45 = v177;
              double v46 = v178;
              *((void *)&v135 + 1) = MRCRegionGetOrientation(v42);
              *((void *)&v134 + 1) = (int)v45;
              *(void *)&long long v135 = (int)v46;
              *((void *)&v133 + 1) = (int)*(double *)&v44;
              *(void *)&long long v134 = (int)*((double *)&v44 + 1);
              *(void *)&long long v133 = Symbology;
              CFStringAppendFormat(Mutable, 0, @"%@_%d_%d_%d_%d*%.2f ");
            }
          }
        }
        else
        {
LABEL_45:
          CFStringAppend(Mutable, @" type unexpected");
        }
      }
      else
      {
        CFStringAppend(Mutable, @" empty array");
      }
    }
    else
    {
      CFStringAppend(Mutable, @" NULL");
    }
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)Mutable;
      _os_log_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&buf, 0xCu);
    }
    CFRelease(Mutable);
  }
  LOBYTE(v151[0]) = 0;
  LOBYTE(v155) = 0;
  if (!v4)
  {
LABEL_82:
    LOBYTE(v147) = 0;
    LOBYTE(v149) = 0;
    if (!v7) {
      goto LABEL_87;
    }
    goto LABEL_83;
  }
  CFTypeID v47 = CFGetTypeID(v4);
  if (v47 != CFArrayGetTypeID())
  {
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"MRCDecoderDecodeSampleWithRegions";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v4;
      _os_log_error_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_ERROR, "%{public}s: Unexpected type of \"regions\": %{public}@", (uint8_t *)&buf, 0x16u);
    }
    goto LABEL_82;
  }
  CFIndex v48 = CFArrayGetCount(v4);
  if (!v48) {
    goto LABEL_82;
  }
  memset(__dst, 0, 24);
  sub_1DC344344((uint64_t *)__dst, v48);
  if (v48 >= 1)
  {
    CFIndex v50 = 0;
    *(void *)&long long v49 = 136446722;
    *(_OWORD *)CFTypeRef cf = v49;
    do
    {
      CFNumberRef v51 = CFArrayGetValueAtIndex(v4, v50);
      int v52 = v51;
      if (!v51) {
        goto LABEL_287;
      }
      CFTypeID v53 = CFGetTypeID(v51);
      if (qword_1EBFFB6F8[0] != -1) {
        dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
      }
      if (v53 == qword_1EBFFB6F0)
      {
        CFTypeID v54 = CFGetTypeID(v52);
        if (qword_1EBFFB6F8[0] != -1) {
          dispatch_once_f(qword_1EBFFB6F8, 0, (dispatch_function_t)sub_1DC30ABD8);
        }
        if (v54 != qword_1EBFFB6F0) {
          _os_assumes_log();
        }
        int v55 = *(CFTypeRef **)&__dst[8];
        if (*(void *)&__dst[8] >= *(void *)&__dst[16])
        {
          uint64_t v57 = (uint64_t)(*(void *)&__dst[8] - *(void *)__dst) >> 3;
          if ((unint64_t)(v57 + 1) >> 61) {
            sub_1DC2FF97C();
          }
          unint64_t v58 = (uint64_t)(*(void *)&__dst[16] - *(void *)__dst) >> 2;
          if (v58 <= v57 + 1) {
            unint64_t v58 = v57 + 1;
          }
          if (*(void *)&__dst[16] - *(void *)__dst >= 0x7FFFFFFFFFFFFFF8uLL) {
            unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v59 = v58;
          }
          double v177 = COERCE_DOUBLE(&__dst[16]);
          if (v59) {
            unint64_t v59 = (unint64_t)sub_1DC2FFD7C(v59);
          }
          else {
            uint64_t v60 = 0;
          }
          int v61 = (void *)(v59 + 8 * v57);
          buf.__r_.__value_.__r.__words[0] = v59;
          buf.__r_.__value_.__l.__size_ = (std::string::size_type)v61;
          buf.__r_.__value_.__r.__words[2] = (std::string::size_type)v61;
          uint64_t v176 = v59 + 8 * v60;
          CFTypeRef v62 = CFRetain(v52);
          std::string::size_type v63 = buf.__r_.__value_.__r.__words[2];
          *int v61 = v62;
          buf.__r_.__value_.__r.__words[2] = v63 + 8;
          sub_1DC3066A4((uint64_t *)__dst, &buf);
          int v56 = *(void **)&__dst[8];
          sub_1DC306780((uint64_t)&buf);
        }
        else
        {
          CFTypeRef *v55 = CFRetain(v52);
          int v56 = v55 + 1;
        }
        *(void *)&__dst[8] = v56;
      }
      else
      {
LABEL_287:
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = cf[0];
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"MRCDecoderDecodeSampleWithRegions";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2050;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v50;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2114;
          uint64_t v176 = (uint64_t)v52;
          _os_log_error_impl(&dword_1DC2FE000, oslog, OS_LOG_TYPE_ERROR, "%{public}s: Unexpected type of \"region\" at %{public}ld: %{public}@", (uint8_t *)&buf, 0x20u);
        }
      }
      ++v50;
    }
    while (v48 != v50);
  }
  long long v147 = *(_OWORD *)__dst;
  uint64_t v148 = *(void *)&__dst[16];
  memset(__dst, 0, 24);
  LOBYTE(v149) = 1;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)__dst;
  sub_1DC306620((void ***)&buf);
  if (v7)
  {
LABEL_83:
    CFTypeID v64 = CFGetTypeID(v7);
    if (qword_1EBFFB7B8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7B8, 0, (dispatch_function_t)sub_1DC374168);
    }
    if (v64 != qword_1EBFFB7A0) {
      _os_assumes_log();
    }
  }
LABEL_87:
  if (v6)
  {
    CFTypeID v65 = CFGetTypeID((CFTypeRef)v6);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v65 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  buf.__r_.__value_.__s.__data_[0] = 0;
  buf.__r_.__value_.__s.__data_[16] = 0;
  if ((_BYTE)v149)
  {
    buf.__r_.__value_.__r.__words[0] = v147;
    buf.__r_.__value_.__l.__size_ = (uint64_t)(*((void *)&v147 + 1) - v147) >> 3;
    buf.__r_.__value_.__s.__data_[16] = 1;
  }
  sub_1DC3032D8((unint64_t *)__dst, (uint64_t)(v7 + 2), (uint64_t)v6, (long long *)&buf, (uint64_t)v151, v9, v10, v11, v133, *((unint64_t **)&v133 + 1), (uint64_t *)v134, *((unint64_t **)&v134 + 1), (unint64_t *)v135, *((uint64_t *)&v135 + 1), v136, log, v139, (uint64_t)oslog, (dispatch_group_t *)cf[0],
    (dispatch_group_t)cf[1],
    (void (*)(void))v147,
    *((CFErrorRef *)&v147 + 1),
    v148,
    v149,
    v150,
    v151[0],
    v151[1],
    v151[2],
    v151[3],
    v151[4],
    v151[5],
    v151[6],
    v151[7],
    v151[8],
    v152,
    v153,
    v154,
    v155,
    v156.__pn_.__r_.__value_.__s.__data_[0],
    (unsigned char *)v156.__pn_.__r_.__value_.__l.__size_,
    v156.__pn_.__r_.__value_.__s.__data_[16],
    v157,
    (uint64_t)__p[0],
    (char)__p[1],
    v159,
    (uint64_t)v160,
    *(timespec *)v161,
    v161[16],
    *(timespec *)&v163[2],
    __dst[0],
    *(os_signpost_id_t *)&__dst[8],
    *(void **)&__dst[16],
    *(uint64_t *)&__dst[24],
    v165,
    *((void **)&v165 + 1),
    v166,
    v167,
    v168,
    v169,
    v170,
    v171,
    v172,
    v173);
  cfa = (const void *)atomic_exchange((atomic_ullong *volatile)__dst, 0);
  sub_1DC307278((atomic_ullong *)__dst);
  if (v140 && (_BYTE)v155)
  {
    sub_1DC390F7C((CFErrorRef *)&buf, (uint64_t)v151);
    *int v140 = atomic_exchange((atomic_ullong *volatile)&buf, 0);
    sub_1DC306854((atomic_ullong *)&buf);
  }
  if (os_log_type_enabled(osloga, OS_LOG_TYPE_DEFAULT))
  {
    unsigned __int8 v66 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    CFStringAppend(v66, @"Result");
    if (cfa)
    {
      for (int64_t j = 0; j < MRCDecoderResultGetDescriptorCount(cfa); ++j)
      {
        DescriptorAtIndeCGFloat x = (char *)MRCDecoderResultGetDescriptorAtIndex(cfa, j);
        int v69 = (const void *)MRCDescriptorCopyAttribute(DescriptorAtIndex, @"BarcodeType");
        float v70 = v69;
        if (v69)
        {
          CFTypeID v71 = CFGetTypeID(v69);
          if (v71 == CFStringGetTypeID()) {
            CFStringAppendFormat(v66, 0, @" %@", v70);
          }
          CFRelease(v70);
        }
      }
    }
    else
    {
      CFStringAppend(v66, @" NULL");
    }
    if (os_log_type_enabled(osloga, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v66;
      _os_log_impl(&dword_1DC2FE000, osloga, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&buf, 0xCu);
    }
    CFRelease(v66);
  }
  if (qword_1EBFFC3B0 != -1) {
    dispatch_once(&qword_1EBFFC3B0, &unk_1F365E8A0);
  }
  if (!byte_1EAA94CD8) {
    goto LABEL_243;
  }
  if (os_log_type_enabled(osloga, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1DC2FE000, osloga, OS_LOG_TYPE_INFO, "WARNING: Live dump is enabled, this may impact the performance.", (uint8_t *)&buf, 2u);
  }
  memset(&v182, 0, sizeof(v182));
  sub_1DC31FAC4(&v182.__pn_, (std::string *)"/tmp", (std::string *)"");
  if ((v182.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float v72 = &v182;
  }
  else {
    float v72 = (std::__fs::filesystem::path *)v182.__pn_.__r_.__value_.__r.__words[0];
  }
  if (access((const char *)v72, 2))
  {
    if (qword_1EAA94C60 != -1) {
      dispatch_once(&qword_1EAA94C60, &unk_1F36625C8);
    }
    float v73 = qword_1EAA94C58;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C58, OS_LOG_TYPE_DEBUG))
    {
      int v86 = SHIBYTE(v182.__pn_.__r_.__value_.__r.__words[2]);
      std::string::size_type v87 = v182.__pn_.__r_.__value_.__r.__words[0];
      uint64_t v88 = __error();
      uint64_t v89 = &v182;
      int v90 = *v88;
      if (v86 < 0) {
        uint64_t v89 = (std::__fs::filesystem::path *)v87;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v89;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1026;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v90;
      _os_log_debug_impl(&dword_1DC2FE000, v73, OS_LOG_TYPE_DEBUG, "%{public}s is not writable, reason: %{public, errno}d", (uint8_t *)&buf, 0x12u);
    }
    std::__fs::filesystem::__temp_directory_path((std::__fs::filesystem::path *)&buf, 0);
    if (SHIBYTE(v182.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v182.__pn_.__r_.__value_.__l.__data_);
    }
    v182.__pn_ = buf;
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
    {
      int v91 = &v182;
      if ((v182.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        int v91 = (std::__fs::filesystem::path *)v182.__pn_.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v91;
      _os_log_debug_impl(&dword_1DC2FE000, v73, OS_LOG_TYPE_DEBUG, "trying %{public}s", (uint8_t *)&buf, 0xCu);
    }
    float v74 = (v182.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v182
        : (std::__fs::filesystem::path *)v182.__pn_.__r_.__value_.__r.__words[0];
    if (access((const char *)v74, 2))
    {
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
      {
        int v120 = SHIBYTE(v182.__pn_.__r_.__value_.__r.__words[2]);
        std::string::size_type v121 = v182.__pn_.__r_.__value_.__r.__words[0];
        int32x4_t v122 = __error();
        int32x4_t v123 = &v182;
        int v124 = *v122;
        if (v120 < 0) {
          int32x4_t v123 = (std::__fs::filesystem::path *)v121;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v123;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 1026;
        *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v124;
        _os_log_debug_impl(&dword_1DC2FE000, v73, OS_LOG_TYPE_DEBUG, "%{public}s is also not writable, reason: %{public, errno}d", (uint8_t *)&buf, 0x12u);
      }
      if (!os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_152;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      float v75 = "cannot find anywhere to write, skipping";
      p_std::string buf = &buf;
      float v77 = v73;
LABEL_148:
      _os_log_debug_impl(&dword_1DC2FE000, v77, OS_LOG_TYPE_DEBUG, v75, (uint8_t *)p_buf, 2u);
LABEL_152:
      memset(&v156, 0, sizeof(v156));
      goto LABEL_184;
    }
  }
  LODWORD(v160) = 0;
  *(void *)uint64_t v161 = std::system_category();
  if (std::__fs::filesystem::path::__filename(&v182).__size_) {
    std::string::push_back(&v182.__pn_, 47);
  }
  float v78 = (const std::__fs::filesystem::path *)sub_1DC31FAC4(&v182.__pn_, (std::string *)"MRCLiveDumps", (std::string *)"");
  std::__fs::filesystem::__status(v78, 0);
  if (__dst[0] != 2 && !std::__fs::filesystem::__create_directory(&v182, (std::error_code *)&v160))
  {
    if (qword_1EAA94C60 != -1) {
      dispatch_once(&qword_1EAA94C60, &unk_1F36625C8);
    }
    int v85 = qword_1EAA94C58;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C58, OS_LOG_TYPE_DEBUG))
    {
      int v125 = SHIBYTE(v182.__pn_.__r_.__value_.__r.__words[2]);
      std::string::size_type v126 = v182.__pn_.__r_.__value_.__r.__words[0];
      std::error_code::message(&buf, (const std::error_code *)&v160);
      int v127 = &v182;
      if (v125 < 0) {
        int v127 = (std::__fs::filesystem::path *)v126;
      }
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float64x2_t v128 = &buf;
      }
      else {
        float64x2_t v128 = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string __dst = 136446466;
      *(void *)&__dst[4] = v127;
      *(_WORD *)&__dst[12] = 2082;
      *(void *)&__dst[14] = v128;
      _os_log_debug_impl(&dword_1DC2FE000, v85, OS_LOG_TYPE_DEBUG, "cannot create directory at %{public}s, reason: %{public}s, skipping", __dst, 0x16u);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    goto LABEL_152;
  }
  pid_t v79 = getpid();
  if (proc_name(v79, &buf, 0x1000u) <= 0)
  {
    if (qword_1EAA94C60 != -1) {
      dispatch_once(&qword_1EAA94C60, &unk_1F36625C8);
    }
    uint64_t v84 = qword_1EAA94C58;
    if (!os_log_type_enabled((os_log_t)qword_1EAA94C58, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_152;
    }
    *(_WORD *)std::string __dst = 0;
    float v75 = "cannot retrieve process name, skipping";
    p_std::string buf = (std::string *)__dst;
    float v77 = v84;
    goto LABEL_148;
  }
  *((void *)&v159 + 1) = 0;
  if (pthread_threadid_np(0, (__uint64_t *)&v159 + 1)) {
    *((void *)&v159 + 1) = MEMORY[0x1E019D3D0]();
  }
  sub_1DC377978((uint64_t)__dst);
  size_t v80 = strlen((const char *)&buf);
  sub_1DC31FC84(&__dst[16], (uint64_t)&buf, v80);
  sub_1DC31FC84(&__dst[16], (uint64_t)"_", 1);
  __int8 v81 = (void *)std::ostream::operator<<();
  sub_1DC31FC84(v81, (uint64_t)"_", 1);
  unint64_t v82 = (void *)std::ostream::operator<<();
  sub_1DC31FC84(v82, (uint64_t)"_", 1);
  std::chrono::system_clock::now();
  std::ostream::operator<<();
  sub_1DC32B834(__p, (uint64_t)&__dst[24]);
  if (SBYTE7(v159) < 0)
  {
    if (!__p[1]) {
      goto LABEL_158;
    }
    int v83 = (void **)__p[0];
  }
  else
  {
    if (!BYTE7(v159)) {
      goto LABEL_158;
    }
    int v83 = __p;
  }
  if (*(unsigned char *)v83 != 47)
  {
LABEL_158:
    if (std::__fs::filesystem::path::__filename(&v182).__size_) {
      std::string::push_back(&v182.__pn_, 47);
    }
    goto LABEL_167;
  }
  if (SHIBYTE(v182.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    *v182.__pn_.__r_.__value_.__l.__data_ = 0;
    v182.__pn_.__r_.__value_.__l.__size_ = 0;
  }
  else
  {
    v182.__pn_.__r_.__value_.__s.__data_[0] = 0;
    *((unsigned char *)&v182.__pn_.__r_.__value_.__s + 23) = 0;
  }
LABEL_167:
  if ((SBYTE7(v159) & 0x80u) == 0) {
    int64_t v92 = (std::string *)__p;
  }
  else {
    int64_t v92 = (std::string *)__p[0];
  }
  int32x4_t v93 = (char *)BYTE7(v159);
  if (SBYTE7(v159) < 0) {
    int32x4_t v93 = (char *)__p[1];
  }
  sub_1DC31FAC4(&v182.__pn_, v92, (std::string *)&v93[(void)v92]);
  if (SBYTE7(v159) < 0) {
    operator delete(__p[0]);
  }
  std::__fs::filesystem::__status(&v182, 0);
  if (LOBYTE(__p[0]) == 2 || std::__fs::filesystem::__create_directory(&v182, (std::error_code *)&v160))
  {
    std::__fs::filesystem::path v156 = v182;
    __n128 v94 = &v182;
  }
  else
  {
    if (qword_1EAA94C60 != -1) {
      dispatch_once(&qword_1EAA94C60, &unk_1F36625C8);
    }
    __n128 v95 = qword_1EAA94C58;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C58, OS_LOG_TYPE_DEBUG))
    {
      int v129 = SHIBYTE(v182.__pn_.__r_.__value_.__r.__words[2]);
      std::string::size_type v142 = v182.__pn_.__r_.__value_.__r.__words[0];
      std::error_code::message((std::string *)__p, (const std::error_code *)&v160);
      double v130 = &v182;
      if (v129 < 0) {
        double v130 = (std::__fs::filesystem::path *)v142;
      }
      int v131 = __p;
      if (SBYTE7(v159) < 0) {
        int v131 = (void **)__p[0];
      }
      *(_DWORD *)&v161[8] = 136446466;
      *(void *)&v161[12] = v130;
      __int16 v162 = 2082;
      *(void *)uint64_t v163 = v131;
      _os_log_debug_impl(&dword_1DC2FE000, v95, OS_LOG_TYPE_DEBUG, "cannot create directory at %{public}s, reason: %{public}s, skipping", &v161[8], 0x16u);
      if (SBYTE7(v159) < 0) {
        operator delete(__p[0]);
      }
    }
    __n128 v94 = &v156;
  }
  v94->__pn_.__r_.__value_.__r.__words[0] = 0;
  v94->__pn_.__r_.__value_.__l.__size_ = 0;
  v94->__pn_.__r_.__value_.__r.__words[2] = 0;
  *(void *)std::string __dst = *MEMORY[0x1E4FBA408];
  uint64_t v96 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)&__dst[*(void *)(*(void *)__dst - 24)] = *(void *)(MEMORY[0x1E4FBA408] + 64);
  *(void *)&__dst[16] = v96;
  *(void *)&__dst[24] = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v172) < 0) {
    operator delete(*((void **)&v170 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1E019CE10](&v174);
LABEL_184:
  if (SHIBYTE(v182.__pn_.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v182.__pn_.__r_.__value_.__l.__data_);
  }
  std::string::size_type size = HIBYTE(v156.__pn_.__r_.__value_.__r.__words[2]);
  int v98 = SHIBYTE(v156.__pn_.__r_.__value_.__r.__words[2]);
  if ((v156.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v156.__pn_.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
LABEL_241:
    if ((v98 & 0x80) == 0) {
      goto LABEL_243;
    }
    goto LABEL_242;
  }
  if (qword_1EAA94C60 != -1) {
    dispatch_once(&qword_1EAA94C60, &unk_1F36625C8);
  }
  loga = qword_1EAA94C58;
  if (os_log_type_enabled((os_log_t)qword_1EAA94C58, OS_LOG_TYPE_DEBUG))
  {
    int32x4_t v114 = (std::__fs::filesystem::path *)v156.__pn_.__r_.__value_.__r.__words[0];
    if (v98 >= 0) {
      int32x4_t v114 = &v156;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v114;
    _os_log_debug_impl(&dword_1DC2FE000, loga, OS_LOG_TYPE_DEBUG, "start dumping at %{public}s", (uint8_t *)&buf, 0xCu);
  }
  sub_1DC377D88((std::string *)__dst, (std::string *)"decoder.txt");
  sub_1DC31F9D0((std::__fs::filesystem::path *)&buf, (uint64_t)&v156, (std::__fs::filesystem::path *)__dst);
  sub_1DC377DE4((int)&buf, v7);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if ((__dst[23] & 0x80000000) != 0) {
    operator delete(*(void **)__dst);
  }
  memset(__dst, 0, 24);
  sub_1DC31FAC4((std::string *)__dst, (std::string *)"sample.txt", (std::string *)"");
  sub_1DC31F9D0((std::__fs::filesystem::path *)&buf, (uint64_t)&v156, (std::__fs::filesystem::path *)__dst);
  sub_1DC377DE4((int)&buf, (CFTypeRef)v6);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if ((__dst[23] & 0x80000000) != 0) {
    operator delete(*(void **)__dst);
  }
  sub_1DC377D88((std::string *)__dst, (std::string *)"regions.txt");
  sub_1DC31F9D0((std::__fs::filesystem::path *)&buf, (uint64_t)&v156, (std::__fs::filesystem::path *)__dst);
  sub_1DC377DE4((int)&buf, v4);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if ((__dst[23] & 0x80000000) != 0) {
    operator delete(*(void **)__dst);
  }
  memset(__dst, 0, 24);
  sub_1DC31FAC4((std::string *)__dst, (std::string *)"decoder_result.txt", (std::string *)"");
  sub_1DC31F9D0((std::__fs::filesystem::path *)&buf, (uint64_t)&v156, (std::__fs::filesystem::path *)__dst);
  sub_1DC377DE4((int)&buf, cfa);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if ((__dst[23] & 0x80000000) != 0) {
    operator delete(*(void **)__dst);
  }
  memset(__dst, 0, 24);
  sub_1DC31FAC4((std::string *)__dst, (std::string *)"pixelBuffer.png", (std::string *)"");
  sub_1DC31F9D0((std::__fs::filesystem::path *)&buf, (uint64_t)&v156, (std::__fs::filesystem::path *)__dst);
  uint64_t v99 = (__CVBuffer *)MRCSampleGetCVPixelBuffer(v6);
  sub_1DC3780E0((uint64_t)&buf, v99);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if ((__dst[23] & 0x80000000) != 0) {
    operator delete(*(void **)__dst);
  }
  memset(__dst, 0, 24);
  sub_1DC31FAC4((std::string *)__dst, (std::string *)"sample.mrcsample", (std::string *)"");
  sub_1DC31F9D0((std::__fs::filesystem::path *)&buf, (uint64_t)&v156, (std::__fs::filesystem::path *)__dst);
  CFAllocatorRef v100 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float v101 = &buf;
  }
  else {
    float v101 = (std::string *)buf.__r_.__value_.__r.__words[0];
  }
  __p[0] = (void *)CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)v101);
  if (!atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire))
  {
    if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v182.__pn_.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1DC2FE000, loga, OS_LOG_TYPE_ERROR, "failed to create CFString with file system representation", (uint8_t *)&v182, 2u);
    }
    goto LABEL_225;
  }
  *(void *)&v161[8] = CFURLCreateWithFileSystemPath(v100, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire), kCFURLPOSIXPathStyle, 0);
  if (atomic_load_explicit((atomic_ullong *volatile)&v161[8], memory_order_acquire))
  {
    double v160 = 0;
    if (!MRCSampleWriteOpaqueRepresentationToFile((char *)v6, (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v161[8], memory_order_acquire), &v160))
    {
      uint64_t v102 = v160;
      BOOL v103 = os_log_type_enabled(loga, OS_LOG_TYPE_ERROR);
      if (v102)
      {
        if (v103)
        {
          double v132 = &buf;
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            double v132 = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          LODWORD(v182.__pn_.__r_.__value_.__l.__data_) = 136446466;
          *(std::string::size_type *)((char *)v182.__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)v132;
          WORD2(v182.__pn_.__r_.__value_.__r.__words[1]) = 2114;
          *(std::string::size_type *)((char *)&v182.__pn_.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v102;
          _os_log_error_impl(&dword_1DC2FE000, loga, OS_LOG_TYPE_ERROR, "failed to write sample as opaque representation to %{public}s, error: %{public}@", (uint8_t *)&v182, 0x16u);
          uint64_t v102 = v160;
        }
        CFRelease(v102);
        goto LABEL_224;
      }
      if (v103)
      {
        uint64_t v116 = &buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v116 = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        LODWORD(v182.__pn_.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v182.__pn_.__r_.__value_.__r.__words + 4) = (std::string::size_type)v116;
        int32x4_t v117 = "failed to write sample as opaque representation to %{public}s";
        double v118 = loga;
        uint32_t v119 = 12;
        goto LABEL_274;
      }
    }
  }
  else if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v182.__pn_.__r_.__value_.__l.__data_) = 0;
    int32x4_t v117 = "failed to create file URL with POSIX-style file system path";
    double v118 = loga;
    uint32_t v119 = 2;
LABEL_274:
    _os_log_error_impl(&dword_1DC2FE000, v118, OS_LOG_TYPE_ERROR, v117, (uint8_t *)&v182, v119);
  }
LABEL_224:
  sub_1DC378320((atomic_ullong *)&v161[8]);
LABEL_225:
  sub_1DC31FA90((atomic_ullong *)__p);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if ((__dst[23] & 0x80000000) != 0) {
    operator delete(*(void **)__dst);
  }
  CFArrayRef v104 = (const __CFArray *)MRCSampleCopyAttribute((char *)v6, @"MRCSampleAttributePyramid");
  CFArrayRef v105 = v104;
  if (v104)
  {
    CFIndex v106 = CFArrayGetCount(v104);
    if (v106 >= 1)
    {
      CFIndex v107 = 0;
      std::string::size_type v141 = *MEMORY[0x1E4FBA408];
      std::string::size_type v109 = *(void *)(MEMORY[0x1E4FBA408] + 64);
      std::string::size_type v108 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      do
      {
        sub_1DC377978((uint64_t)&buf);
        sub_1DC31FC84(&buf.__r_.__value_.__r.__words[2], (uint64_t)"pyramid_", 8);
        uint64_t v110 = (void *)std::ostream::operator<<();
        sub_1DC31FC84(v110, (uint64_t)".png", 4);
        sub_1DC32B834(__p, (uint64_t)&v176);
        *(_OWORD *)&v182.__pn_.__r_.__value_.__l.__data_ = *(_OWORD *)__p;
        v182.__pn_.__r_.__value_.__r.__words[2] = v159;
        __p[1] = 0;
        *(void *)&long long v159 = 0;
        __p[0] = 0;
        sub_1DC31F9D0((std::__fs::filesystem::path *)__dst, (uint64_t)&v156, &v182);
        uint64_t v111 = (__CVBuffer *)CFArrayGetValueAtIndex(v105, v107);
        sub_1DC3780E0((uint64_t)__dst, v111);
        if ((__dst[23] & 0x80000000) != 0) {
          operator delete(*(void **)__dst);
        }
        if (SHIBYTE(v182.__pn_.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v182.__pn_.__r_.__value_.__l.__data_);
        }
        buf.__r_.__value_.__r.__words[0] = v141;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + *(void *)(v141 - 24)) = v109;
        buf.__r_.__value_.__r.__words[2] = v108;
        uint64_t v176 = MEMORY[0x1E4FBA470] + 16;
        if (v180 < 0) {
          operator delete(v179);
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x1E019CE10](&v181);
        ++v107;
      }
      while (v106 != v107);
    }
    CFRelease(v105);
  }
  BOOL v112 = os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG);
  LOBYTE(v98) = *((unsigned char *)&v156.__pn_.__r_.__value_.__s + 23);
  if (!v112) {
    goto LABEL_241;
  }
  __int32 v115 = (std::__fs::filesystem::path *)v156.__pn_.__r_.__value_.__r.__words[0];
  if ((v156.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    __int32 v115 = &v156;
  }
  LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v115;
  _os_log_debug_impl(&dword_1DC2FE000, loga, OS_LOG_TYPE_DEBUG, "finish dumping at %{public}s", (uint8_t *)&buf, 0xCu);
  if ((*((unsigned char *)&v156.__pn_.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_242:
  }
    operator delete(v156.__pn_.__r_.__value_.__l.__data_);
LABEL_243:
  if (os_log_type_enabled(osloga, OS_LOG_TYPE_INFO))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 138739971;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)cfa;
    _os_log_impl(&dword_1DC2FE000, osloga, OS_LOG_TYPE_INFO, "MRCDecoderDecodeSampleWithRegions: decoderResult: %{sensitive}@", (uint8_t *)&buf, 0xCu);
  }
  if (os_log_type_enabled(osloga, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1DC2FE000, osloga, OS_LOG_TYPE_INFO, "MRCDecoderDecodeSampleWithRegions: leave", (uint8_t *)&buf, 2u);
  }
  if ((_BYTE)v149)
  {
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v147;
    sub_1DC306620((void ***)&buf);
  }
  if ((_BYTE)v155) {
    sub_1DC390B00(v151);
  }
  return cfa;
}

void sub_1DC37758C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,atomic_ullong a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53)
{
  sub_1DC377C50((uint64_t)&a53);
  if (*(char *)(v53 - 137) < 0) {
    operator delete(*(void **)(v53 - 160));
  }
  if (a24)
  {
    STACK[0x280] = (unint64_t)&a21;
    sub_1DC306620((void ***)&STACK[0x280]);
  }
  if (a38) {
    sub_1DC390B00(&a26);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3777A8(atomic_ullong *a1, uint64_t a2)
{
  if (qword_1EBFFC430 != -1) {
    dispatch_once_f(&qword_1EBFFC430, 0, (dispatch_function_t)sub_1DC327040);
  }
  CFArrayRef v4 = (atomic_ullong *)qword_1EBFFC428;
  CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)qword_1EBFFC428, memory_order_acquire));
  if (Count < 1) {
    return 0;
  }
  CFIndex v6 = Count;
  CFIndex v7 = 0;
  uint64_t v8 = 0;
  do
  {
    ValueAtIndeCGFloat x = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(v4, memory_order_acquire), v7);
    if (sub_1DC3778A8(a1, ValueAtIndex, a2))
    {
      int v13 = 0;
      BOOL v10 = sub_1DC3D60C4(ValueAtIndex, &v13);
      int v11 = 1 << v13;
      if (!v10) {
        int v11 = 0;
      }
      uint64_t v8 = v11 | v8;
    }
    ++v7;
  }
  while (v6 != v7);
  return v8;
}

uint64_t sub_1DC3778A8(atomic_ullong *a1, const void *a2, uint64_t a3)
{
  if (!atomic_load_explicit(a1, memory_order_acquire)) {
    return 1;
  }
  uint64_t result = CFSetContainsValue((CFSetRef)atomic_load_explicit(a1, memory_order_acquire), a2);
  if (!result) {
    return result;
  }
  if (!*(unsigned char *)(a3 + 4)) {
    return 1;
  }
  if (a2) {
    CFTypeRef v7 = CFRetain(a2);
  }
  else {
    CFTypeRef v7 = 0;
  }
  CFTypeRef v12 = v7;
  unint64_t v8 = sub_1DC328800((atomic_ullong *)&v12);
  int v9 = v8;
  int v10 = BYTE4(v8);
  sub_1DC31FA90((atomic_ullong *)&v12);
  if (v10 && v9 == 3)
  {
    int v9 = 2 * (a1[7] < 0x40000);
    int v10 = 1;
  }
  return v10 && v9 == *(_DWORD *)a3;
}

void sub_1DC377964(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC31FA90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC377978(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  __int16 v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  unint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x1E4FBA488] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1DC377C28(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x1E019CE10](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC377C50(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA408];
  uint64_t v3 = *MEMORY[0x1E4FBA408];
  *(void *)a1 = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1E019CE10](a1 + 128);
  return a1;
}

std::string *sub_1DC377D88(std::string *this, std::string *a2)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  uint64_t v3 = (std::string *)((char *)a2 - 1);
  do
  {
    int v4 = v3->__r_.__value_.__s.__data_[1];
    uint64_t v3 = (std::string *)((char *)v3 + 1);
  }
  while (v4);
  sub_1DC31FAC4(this, a2, v3);
  return this;
}

void sub_1DC377DC8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

atomic_ullong *sub_1DC377DE4(int a1, CFTypeRef cf)
{
  v11[19] = *MEMORY[0x1E4F143B8];
  atomic_ullong v8 = 0;
  if (cf)
  {
    uint64_t v2 = (const void *)atomic_exchange(&v8, (unint64_t)CFCopyDescription(cf));
    if (v2) {
      CFRelease(v2);
    }
  }
  if (!atomic_load_explicit(&v8, memory_order_acquire))
  {
    uint64_t v3 = (const void *)atomic_exchange(&v8, (unint64_t)CFRetain(&stru_1F3665D38));
    if (v3) {
      CFRelease(v3);
    }
  }
  CStringPtr = CFStringGetCStringPtr((CFStringRef)atomic_load_explicit(&v8, memory_order_acquire), 0x8000100u);
  if (!CStringPtr)
  {
    CFIndex Length = CFStringGetLength((CFStringRef)atomic_load_explicit(&v8, memory_order_acquire));
    CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    operator new[]();
  }
  sub_1DC358390((uint64_t *)buf);
  size_t v6 = strlen(CStringPtr);
  sub_1DC31FC84(buf, (uint64_t)CStringPtr, v6);
  *(void *)std::string buf = *MEMORY[0x1E4FBA400];
  *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x1E4FBA400] + 24);
  MEMORY[0x1E019CC10](&v10);
  std::ostream::~ostream();
  MEMORY[0x1E019CE10](v11);
  return sub_1DC31FA90(&v8);
}

void sub_1DC378088(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  atomic_ullong v4 = va_arg(va1, void);
  sub_1DC35854C((uint64_t *)va1);
  if (v2) {
    MEMORY[0x1E019CE70](v2, 0x1000C8077774924);
  }
  sub_1DC31FA90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void sub_1DC3780E0(uint64_t a1, CVPixelBufferRef pixelBuffer)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  CGImageRef imageOut = 0;
  OSStatus v3 = VTCreateCGImageFromCVPixelBuffer(pixelBuffer, 0, &imageOut);
  if (v3)
  {
    if (qword_1EAA94C60 != -1) {
      dispatch_once(&qword_1EAA94C60, &unk_1F36625C8);
    }
    atomic_ullong v4 = qword_1EAA94C58;
    if (os_log_type_enabled((os_log_t)qword_1EAA94C58, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67240192;
      LODWORD(v15) = v3;
      _os_log_error_impl(&dword_1DC2FE000, v4, OS_LOG_TYPE_ERROR, "VTCreateCGImageFromCVPixelBuffer failed with %{public}d", buf, 8u);
    }
  }
  else
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (*(char *)(a1 + 23) >= 0) {
      size_t v6 = (const char *)a1;
    }
    else {
      size_t v6 = *(const char **)a1;
    }
    CFStringRef v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, 0x8000100u);
    CFURLRef v11 = CFURLCreateWithFileSystemPath(v5, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire), kCFURLPOSIXPathStyle, 0);
    uint64_t v7 = CGImageDestinationCreateWithURL((CFURLRef)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire), @"public.png", 1uLL, 0);
    atomic_ullong v8 = v7;
    if (v7)
    {
      CGImageDestinationAddImage(v7, imageOut, 0);
      CGImageDestinationFinalize(v8);
      CFRelease(v8);
    }
    else
    {
      if (qword_1EAA94C60 != -1) {
        dispatch_once(&qword_1EAA94C60, &unk_1F36625C8);
      }
      uint64_t v9 = qword_1EAA94C58;
      if (os_log_type_enabled((os_log_t)qword_1EAA94C58, OS_LOG_TYPE_ERROR))
      {
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
        *(_DWORD *)std::string buf = 138543362;
        unint64_t v15 = explicit;
        _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "CGImageDestinationCreateWithURL failed for %{public}@", buf, 0xCu);
      }
    }
    CGImageRelease(imageOut);
    sub_1DC378320((atomic_ullong *)&v11);
    sub_1DC31FA90((atomic_ullong *)&v12);
  }
}

void sub_1DC3782F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1DC31FA90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC378320(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *sub_1DC378354()
{
  v1[4] = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFB690) {
    _os_assumes_log();
  }
  if (qword_1EBFFB9F8) {
    _os_assumes_log();
  }
  qword_1EBFFB690 = (uint64_t)"MRCSample";
  qword_1EBFFB9F8 = _CFRuntimeRegisterClass();
  v1[3] = 0;
  sub_1DC348EB8(qword_1EBFFB9F8, v1);
  return sub_1DC30AC9C(v1);
}

void sub_1DC3783FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC30AC9C((uint64_t *)va);
  _Unwind_Resume(a1);
}

CFStringRef sub_1DC378418(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v2 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  CFStringRef result = sub_1DC383840((uint64_t)cf + 16);
  if (!result) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s %p>", "MRCSample", cf);
  }
  return result;
}

unint64_t sub_1DC3784D4(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v2 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  unint64_t v3 = 0x9DDFEA08EB382D69
     * (((((((unint64_t)cf + 16) >> 3) & 0x3FFFFFF) << 6) | 8) ^ (((unint64_t)cf + 16) >> 32));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * ((((unint64_t)cf + 16) >> 32) ^ (v3 >> 47) ^ v3)) ^ ((0x9DDFEA08EB382D69
                                                                                             * ((((unint64_t)cf
                                                                                                + 16) >> 32) ^ (v3 >> 47) ^ v3)) >> 47));
}

BOOL sub_1DC378598(CFTypeRef cf, CFTypeRef a2)
{
  if (!cf) {
    goto LABEL_5;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (qword_1EBFFB800 != -1) {
    dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
  }
  if (v4 != qword_1EBFFB9F8)
  {
    _os_assumes_log();
    if (!a2) {
      return cf == a2;
    }
  }
  else
  {
LABEL_5:
    if (!a2) {
      return cf == a2;
    }
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (qword_1EBFFB800 != -1) {
    dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
  }
  if (v5 != qword_1EBFFB9F8) {
    _os_assumes_log();
  }
  return cf == a2;
}

atomic_ullong *sub_1DC378690(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v2 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
    CFTypeID v3 = CFGetTypeID(cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v3 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  sub_1DC3787A4((void ***)cf + 9, 0);
  sub_1DC3065EC((atomic_ullong *)cf + 8);
  sub_1DC31EBFC((atomic_ullong *)cf + 3);
  return sub_1DC378814((atomic_ullong **)cf + 2);
}

void ***sub_1DC3787A4(void ***result, void **a2)
{
  CFTypeID v2 = *result;
  *CFStringRef result = a2;
  if (v2)
  {
    CFTypeID v3 = v2;
    sub_1DC3071F0(&v3);
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

atomic_ullong *sub_1DC378814(atomic_ullong **a1)
{
  CFStringRef result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1DC307370(result);
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

const void *MRCDecoderDecodeSampleWithSegmentationMask(int a1, void *a2, uint64_t *cf, __n128 a4)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    goto LABEL_50;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (qword_1EAA94C38 != -1) {
    dispatch_once_f(&qword_1EAA94C38, 0, (dispatch_function_t)sub_1DC32BAF0);
  }
  if (v6 != qword_1EAA94C40) {
    _os_assumes_log();
  }
  sub_1DC32C6AC(cf + 2);
  CGFloat x = v84.origin.x;
  CGFloat y = v84.origin.y;
  CGFloat width = v84.size.width;
  CGFloat height = v84.size.height;
  if (CGRectIsNull(v84))
  {
    if (qword_1EBFFC270 != -1) {
      dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
    }
    CFURLRef v11 = qword_1EBFFC278;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC278, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
    *(_DWORD *)BOOL v76 = 136446466;
    *(void *)&v76[4] = "MRCDecoderDecodeSampleWithSegmentationMask";
    *(_WORD *)&v76[12] = 2114;
    *(void *)&v76[14] = cf;
    CFStringRef v12 = "%{public}s: Unable to estimate region-of-interest from: %{public}@";
    int v13 = (CGAffineTransform *)v76;
    goto LABEL_49;
  }
  v85.origin.CGFloat x = x;
  v85.origin.CGFloat y = y;
  v85.size.CGFloat width = width;
  v85.size.CGFloat height = height;
  CGFloat MinX = CGRectGetMinX(v85);
  v86.origin.CGFloat x = x;
  v86.origin.CGFloat y = y;
  v86.size.CGFloat width = width;
  v86.size.CGFloat height = height;
  *(CGFloat *)BOOL v76 = MinX;
  *(void *)&v76[8] = CGRectGetMinY(v86);
  v87.origin.CGFloat x = x;
  v87.origin.CGFloat y = y;
  v87.size.CGFloat width = width;
  v87.size.CGFloat height = height;
  CGFloat v15 = CGRectGetMinX(v87);
  v88.origin.CGFloat x = x;
  v88.origin.CGFloat y = y;
  v88.size.CGFloat width = width;
  v88.size.CGFloat height = height;
  *(CGFloat *)&v76[16] = v15;
  CGFloat MaxY = CGRectGetMaxY(v88);
  v89.origin.CGFloat x = x;
  v89.origin.CGFloat y = y;
  v89.size.CGFloat width = width;
  v89.size.CGFloat height = height;
  CGFloat MaxX = CGRectGetMaxX(v89);
  v90.origin.CGFloat x = x;
  v90.origin.CGFloat y = y;
  v90.size.CGFloat width = width;
  v90.size.CGFloat height = height;
  CGFloat v78 = MaxX;
  CGFloat v79 = CGRectGetMaxY(v90);
  v91.origin.CGFloat x = x;
  v91.origin.CGFloat y = y;
  v91.size.CGFloat width = width;
  v91.size.CGFloat height = height;
  CGFloat v17 = CGRectGetMaxX(v91);
  v92.origin.CGFloat x = x;
  v92.origin.CGFloat y = y;
  v92.size.CGFloat width = width;
  v92.size.CGFloat height = height;
  CGFloat v80 = v17;
  CGFloat MinY = CGRectGetMinY(v92);
  if (a2)
  {
    CFTypeID v18 = CFGetTypeID(a2);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v18 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  uint64_t v19 = (unint64_t *)(cf + 6);
  if (!cf[6] || (int v20 = (unint64_t *)(cf + 7), !cf[7]))
  {
LABEL_21:
    LOBYTE(v65.a) = 0;
    char v66 = 0;
    if (qword_1EBFFC270 != -1) {
      dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
    }
    CFURLRef v11 = qword_1EBFFC278;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC278, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
    LODWORD(v82.a) = 136446466;
    *(void *)((char *)&v82.a + 4) = "MRCDecoderDecodeSampleWithSegmentationMask";
    WORD2(v82.b) = 2114;
    *(void *)((char *)&v82.b + 6) = cf;
    CFStringRef v12 = "%{public}s: Unable to get transform from: %{public}@";
LABEL_48:
    int v13 = &v82;
LABEL_49:
    _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, v12, (uint8_t *)v13, 0x16u);
LABEL_50:
    CFArrayRef Copy = 0;
    goto LABEL_51;
  }
  uint64_t v21 = a2[2];
  switch(cf[9])
  {
    case 1:
      double v22 = CGRectGetWidth(*(CGRect *)(v21 + 8));
      double v23 = v22 / CGRectGetHeight(*(CGRect *)(v21 + 8));
      uint64_t v24 = *(void *)(v21 + 8);
      uint64_t v25 = *(void *)(v21 + 16);
      uint64_t v26 = *(void *)(v21 + 24);
      uint64_t v27 = *(void *)(v21 + 32);
      if (v23 >= (double)*v19 / (double)*v20)
      {
        double v28 = CGRectGetWidth(*(CGRect *)&v24);
      }
      else
      {
        double v28 = CGRectGetHeight(*(CGRect *)&v24);
        uint64_t v19 = (unint64_t *)(cf + 7);
      }
      double v31 = v28 / (double)*v19;
      double v30 = v31;
      goto LABEL_34;
    case 2:
      double v43 = CGRectGetWidth(*(CGRect *)(v21 + 8));
      double v44 = v43 / CGRectGetHeight(*(CGRect *)(v21 + 8));
      uint64_t v45 = *(void *)(v21 + 8);
      uint64_t v46 = *(void *)(v21 + 16);
      uint64_t v47 = *(void *)(v21 + 24);
      uint64_t v48 = *(void *)(v21 + 32);
      if (v44 >= (double)*v19 / (double)*v20)
      {
        double v49 = CGRectGetHeight(*(CGRect *)&v45) / (double)*v20;
        double v51 = (CGRectGetWidth(*(CGRect *)(v21 + 8)) / v49 - (double)*v19) * -0.5;
        double v50 = 0.0;
      }
      else
      {
        double v49 = CGRectGetWidth(*(CGRect *)&v45) / (double)*v19;
        double v50 = (CGRectGetHeight(*(CGRect *)(v21 + 8)) / v49 - (double)*v20) * -0.5;
        double v51 = 0.0;
      }
      long long v57 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      *(_OWORD *)&v82.a = *MEMORY[0x1E4F1DAB8];
      *(_OWORD *)&v82.CGFloat c = v57;
      *(_OWORD *)&v82.tCGFloat x = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      *(_OWORD *)&v75.a = *(_OWORD *)&v82.a;
      *(_OWORD *)&v75.CGFloat c = v57;
      *(_OWORD *)&v75.tCGFloat x = *(_OWORD *)&v82.tx;
      CGAffineTransformMakeScale(&v74, v49, v49);
      CGAffineTransformConcat(&v82, &v75, &v74);
      CGAffineTransform v72 = v82;
      CGAffineTransformMakeTranslation(&v71, v51, v50);
      int v55 = &v72;
      int v56 = &v71;
      goto LABEL_37;
    case 3:
      CGFloat v29 = CGRectGetWidth(*(CGRect *)(v21 + 8)) / (double)*v19;
      double v30 = CGRectGetHeight(*(CGRect *)(v21 + 8)) / (double)*v20;
      double v31 = v29;
LABEL_34:
      CGAffineTransformMakeScale(&v65, v31, v30);
      break;
    case 4:
      double v32 = CGRectGetWidth(*(CGRect *)(v21 + 8));
      double v33 = v32 / CGRectGetHeight(*(CGRect *)(v21 + 8));
      uint64_t v34 = *(void *)(v21 + 8);
      uint64_t v35 = *(void *)(v21 + 16);
      uint64_t v36 = *(void *)(v21 + 24);
      uint64_t v37 = *(void *)(v21 + 32);
      if (v33 >= (double)*v19 / (double)*v20)
      {
        CGFloat v52 = CGRectGetWidth(*(CGRect *)&v34);
        double v53 = (double)*v20;
        double v40 = v52 / (double)*v19;
        double v42 = (v53 - CGRectGetHeight(*(CGRect *)(v21 + 8)) / v40) * 0.5;
        double v41 = 0.0;
      }
      else
      {
        CGFloat v38 = CGRectGetHeight(*(CGRect *)&v34);
        double v39 = (double)*v19;
        double v40 = v38 / (double)*v20;
        double v41 = (v39 - CGRectGetWidth(*(CGRect *)(v21 + 8)) / v40) * 0.5;
        double v42 = 0.0;
      }
      long long v54 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      *(_OWORD *)&v82.a = *MEMORY[0x1E4F1DAB8];
      *(_OWORD *)&v82.CGFloat c = v54;
      *(_OWORD *)&v82.tCGFloat x = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      *(_OWORD *)&t1.a = *(_OWORD *)&v82.a;
      *(_OWORD *)&t1.CGFloat c = v54;
      *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)&v82.tx;
      CGAffineTransformMakeScale(&t2, v40, v40);
      CGAffineTransformConcat(&v82, &t1, &t2);
      CGAffineTransform v68 = v82;
      CGAffineTransformMakeTranslation(&v67, v41, v42);
      int v55 = &v68;
      int v56 = &v67;
LABEL_37:
      CGAffineTransformConcat(&v73, v55, v56);
      *(_OWORD *)&v82.tCGFloat x = *(_OWORD *)&v73.tx;
      CGAffineTransform v65 = v73;
      break;
    default:
      goto LABEL_21;
  }
  char v66 = 1;
  if (!atomic_load_explicit(cf + 10, memory_order_acquire)
    || !CFArrayGetCount((CFArrayRef)atomic_load_explicit(cf + 10, memory_order_acquire)))
  {
    if (qword_1EBFFC270 != -1) {
      dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
    }
    CFURLRef v11 = qword_1EBFFC278;
    if (!os_log_type_enabled((os_log_t)qword_1EBFFC278, OS_LOG_TYPE_ERROR)) {
      goto LABEL_50;
    }
    LODWORD(v82.a) = 136446466;
    *(void *)((char *)&v82.a + 4) = "MRCDecoderDecodeSampleWithSegmentationMask";
    WORD2(v82.b) = 2114;
    *(void *)((char *)&v82.b + 6) = cf;
    CFStringRef v12 = "%{public}s: Symbologies not specified: %{public}@";
    goto LABEL_48;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(cf + 10, memory_order_acquire));
  CFAllocatorRef v59 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex v60 = 0;
  *(void *)&v82.a = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
  while (v60 < CFArrayGetCount((CFArrayRef)atomic_load_explicit(cf + 10, memory_order_acquire)))
  {
    ValueAtIndeCGFloat x = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(cf + 10, memory_order_acquire), v60);
    if (!v66) {
      sub_1DC306FEC();
    }
    *(void *)&v75.a = MRCRegionCreate((long long *)v76, (long long *)&v65, ValueAtIndex, 0.0, 1.0);
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v82, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v75, memory_order_acquire));
    sub_1DC37910C((atomic_ullong *)&v75);
    ++v60;
  }
  CFArrayRef Copy = CFArrayCreateCopy(v59, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v82, memory_order_acquire));
  sub_1DC3070BC((atomic_ullong *)&v82);
LABEL_51:
  atomic_load_explicit((atomic_ullong *volatile)&Copy, memory_order_acquire);
  CFTypeRef v62 = MRCDecoderDecodeSampleWithRegions(a4);
  sub_1DC3065EC((atomic_ullong *)&Copy);
  return v62;
}

void sub_1DC3790B0(_Unwind_Exception *a1)
{
  sub_1DC3070BC((atomic_ullong *)(v1 - 192));
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC37910C(atomic_ullong *a1)
{
  CFTypeID v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1DC379140(atomic_ullong *a1)
{
  uint64_t result = _os_feature_enabled_impl();
  if (result)
  {
    if (a1[7] >= 0x40000)
    {
      v5[0] = 0;
      v5[4] = 0;
      if (sub_1DC3778A8(a1, @"DataMatrix", (uint64_t)v5)) {
        return 1;
      }
      v4[0] = 0;
      _DWORD v4[4] = 0;
      if (sub_1DC3778A8(a1, @"Aztec", (uint64_t)v4))
      {
        return 1;
      }
      else
      {
        v3[0] = 0;
        v3[4] = 0;
        return sub_1DC3778A8(a1, @"MicroQR", (uint64_t)v3);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

os_log_t sub_1DC3791F8()
{
  os_log_t result = os_log_create("com.apple.Quagga", "MachineReadableCode");
  qword_1EBFFC278 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379228()
{
  os_log_t result = os_log_create("com.apple.Quagga", "OpaqueRepresentation");
  qword_1EAA94C48 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379258()
{
  os_log_t result = os_log_create("com.apple.Quagga", "LiveDump");
  qword_1EAA94C58 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379288()
{
  os_log_t result = os_log_create("com.apple.Quagga", "Context");
  qword_1EBFFC3C8 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC3792B8()
{
  os_log_t result = os_log_create("com.apple.Quagga", "SampleDecoding");
  qword_1EBFFC3E8 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC3792E8()
{
  os_log_t result = os_log_create("com.apple.Quagga", "PayloadDecoding");
  qword_1EAA94C68 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379318()
{
  os_log_t result = os_log_create("com.apple.Quagga", "SegmentationNeuralNetwork");
  qword_1EAA94C78 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379348()
{
  os_log_t result = os_log_create("com.apple.Quagga", "MetalHybridBinarizer");
  qword_1EAA94C88 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379378()
{
  os_log_t result = os_log_create("com.apple.Quagga", "Imaging");
  qword_1EAA94C98 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC3793A8()
{
  os_log_t result = os_log_create("com.apple.Quagga", "PyramidGeneration");
  qword_1EBFFC388 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC3793D8()
{
  os_log_t result = os_log_create("com.apple.Quagga", "Inference");
  qword_1EBFFC3D8 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379408()
{
  os_log_t result = os_log_create("com.apple.Quagga", "ANMD");
  qword_1EBFFC3B8 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379438()
{
  os_log_t result = os_log_create("com.apple.Quagga", "IIE");
  qword_1EAA94CA8 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379468()
{
  os_log_t result = os_log_create("com.apple.Quagga", "QRFinderPattern");
  qword_1EBFFC298 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379498()
{
  os_log_t result = os_log_create("com.apple.Quagga", "QRAlignmentPattern");
  qword_1EBFFC288 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC3794C8()
{
  os_log_t result = os_log_create("com.apple.Quagga", "MicroQR");
  qword_1EAA94CB8 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC3794F8()
{
  os_log_t result = os_log_create("com.apple.Quagga", "AppClipCode");
  qword_1EBFFB748 = (uint64_t)result;
  return result;
}

os_log_t sub_1DC379528()
{
  os_log_t result = os_log_create("com.apple.Quagga", "iconv");
  qword_1EAA94CC8 = (uint64_t)result;
  return result;
}

uint64_t sub_1DC379558()
{
  uint64_t result = os_variant_has_internal_content();
  if (result)
  {
    Boolean keyExistsAndHasValidFormat = 0;
    uint64_t result = CFPreferencesGetAppBooleanValue(@"_MRCLiveDumpEnabled", (CFStringRef)*MEMORY[0x1E4F1D3D8], &keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat
      || (uint64_t result = CFPreferencesGetAppBooleanValue(@"_MRCLiveDumpEnabled", @"com.apple.Quagga", &keyExistsAndHasValidFormat), keyExistsAndHasValidFormat))
    {
      byte_1EAA94CD8 = result != 0;
    }
  }
  return result;
}

void sub_1DC3795DC()
{
}

uint64_t sub_1DC37968C()
{
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EAA94D00, memory_order_acquire) != -1)
  {
    uint64_t v1 = &v2;
    CFTypeID v2 = sub_1DC3795DC;
    std::__call_once(&qword_1EAA94D00, &v1, (void (__cdecl *)(void *))sub_1DC33DA8C);
  }
  return qword_1EAA94CF8;
}

void sub_1DC3796F8(char **a1, uint64_t a2)
{
  CFTypeID v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 < v4)
  {
    *((void *)v5 + 3) = 0;
    if (a2)
    {
      *(void *)CFTypeID v5 = &unk_1F3661AC8;
      *((void *)v5 + 1) = a2;
      *((void *)v5 + 3) = v5;
    }
    CFTypeID v6 = v5 + 32;
    goto LABEL_32;
  }
  uint64_t v7 = *a1;
  uint64_t v8 = (v5 - *a1) >> 5;
  unint64_t v9 = v8 + 1;
  if ((unint64_t)(v8 + 1) >> 59) {
    sub_1DC2FF97C();
  }
  uint64_t v10 = v4 - (void)v7;
  if (v10 >> 4 > v9) {
    unint64_t v9 = v10 >> 4;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v11 = v9;
  }
  if (v11)
  {
    if (v11 >> 59) {
      sub_1DC2FF994();
    }
    CFStringRef v12 = (char *)operator new(32 * v11);
  }
  else
  {
    CFStringRef v12 = 0;
  }
  int v13 = &v12[32 * v8];
  *((void *)v13 + 3) = 0;
  if (a2)
  {
    *(void *)int v13 = &unk_1F3661AC8;
    *((void *)v13 + 1) = a2;
    *((void *)v13 + 3) = v13;
  }
  CFTypeRef v14 = &v12[32 * v11];
  CFTypeID v6 = v13 + 32;
  if (v5 != v7)
  {
    uint64_t v15 = 0;
    uint64_t v16 = v13;
    while (1)
    {
      CGFloat v17 = &v5[v15 - 8];
      CFTypeID v18 = *(char **)v17;
      if (*(void *)v17)
      {
        uint64_t v19 = &v13[v15];
        if (&v5[v15 - 32] == v18)
        {
          *((void *)v19 - 1) = v19 - 32;
          (*(void (**)(char *))(*(void *)&v5[v15 - 32] + 24))(&v5[v15 - 32]);
          goto LABEL_25;
        }
        *((void *)v19 - 1) = v18;
      }
      else
      {
        CGFloat v17 = v16 - 8;
      }
      *(void *)CGFloat v17 = 0;
LABEL_25:
      v16 -= 32;
      v15 -= 32;
      if (&v5[v15] == v7)
      {
        CFTypeID v5 = *a1;
        int v20 = a1[1];
        *a1 = &v13[v15];
        a1[1] = v6;
        a1[2] = v14;
        while (v20 != v5)
          int v20 = (char *)sub_1DC379954((void *)v20 - 4);
        goto LABEL_30;
      }
    }
  }
  *a1 = v13;
  a1[1] = v6;
  a1[2] = v14;
LABEL_30:
  if (v5) {
    operator delete(v5);
  }
LABEL_32:
  a1[1] = v6;
}

void sub_1DC3798D0(void ***a1)
{
  uint64_t v1 = *a1;
  CFTypeID v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    CFTypeID v5 = v2;
    if (v4 != v2)
    {
      do
        unint64_t v4 = sub_1DC379954(v4 - 4);
      while (v4 != v2);
      CFTypeID v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1DC379954(void *a1)
{
  CFTypeID v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1DC3799D8()
{
  return &unk_1F3660928;
}

uint64_t sub_1DC3799E4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"PFN3mrc5CFRefIP9__CFErrorEERNS_7ContextEE")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

uint64_t sub_1DC379A20(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t sub_1DC379A34(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3661AC8;
  a2[1] = v2;
  return result;
}

void *sub_1DC379A58(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F3661AC8;
  result[1] = v3;
  return result;
}

void sub_1DC379AA0()
{
}

uint64_t sub_1DC379AB8(uint64_t a1)
{
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void sub_1DC379AD4(std::exception *a1)
{
  sub_1DC379B0C(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC379B0C(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1F36619D8;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }
  std::exception::~exception(this);
}

void *sub_1DC379B70(void *a1, char *a2)
{
  *a1 = &unk_1F36619D8;
  sub_1DC3147E4(a1 + 1, a2);
  return a1;
}

void sub_1DC379BB4(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC379BC8(std::exception *a1)
{
  sub_1DC379B0C(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC379C04(void *a1, char *a2)
{
  uint64_t result = sub_1DC379B70(a1, a2);
  *uint64_t result = &unk_1F3661188;
  return result;
}

void sub_1DC379C38()
{
}

BOOL sub_1DC379C50(float *a1, float a2, float a3, float a4)
{
  if (vabds_f32(a3, (*(float (**)(float *))(*(void *)a1 + 24))(a1)) > a2
    || vabds_f32(a4, (*(float (**)(float *))(*(void *)a1 + 16))(a1)) > a2)
  {
    return 0;
  }
  float v8 = a1[5];
  float v9 = vabds_f32(a2, v8);
  return v9 <= 1.0 || v9 <= v8;
}

float sub_1DC379D1C(uint64_t a1, float *a2, float *a3, float *a4, float *a5, int *a6, float a7, float a8, float a9, float a10)
{
  int v19 = *(_DWORD *)(a1 + 28);
  int v20 = v19 + 1;
  float v21 = (float)(a8 + (float)((float)v19 * (*(float (**)(uint64_t))(*(void *)a1 + 16))(a1)))
      / (float)(v19 + 1);
  float v22 = (float)*(int *)(a1 + 28);
  float v23 = (*(float (**)(uint64_t))(*(void *)a1 + 24))(a1);
  float v24 = (float)*(int *)(a1 + 28);
  float v25 = (float)(a9 + (float)(v24 * *(float *)(a1 + 20))) / (float)v20;
  float v26 = a10 + (float)(v24 * *(float *)(a1 + 24));
  *a2 = v21;
  *a3 = (float)(a7 + (float)(v22 * v23)) / (float)v20;
  *a4 = v25;
  float result = v26 / (float)v20;
  *a5 = result;
  *a6 = v20;
  return result;
}

void sub_1DC379E34()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
  sub_1DC353C14(exception, "This luminance source does not support rotation.");
  __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
}

void sub_1DC379E7C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC379E90()
{
  exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
  sub_1DC353C14(exception, "This luminance source does not support cropping.");
  __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
}

void sub_1DC379ED8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC379EEC()
{
  return 0;
}

void *sub_1DC379EF4(void *a1, uint64_t a2)
{
  *a1 = &unk_1F36619D8;
  uint64_t v3 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1DC312750(v3, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v3 = v4;
  }
  *a1 = &unk_1F36611E0;
  return a1;
}

void sub_1DC379F7C(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC379F90(void **a1)
{
}

void sub_1DC37A510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  *(void *)(v14 + 8) = v15;
  for (uint64_t i = 24; i != -8; i -= 8)
    sub_1DC2FFD08((atomic_uint **)(&a14 + i));
  _Unwind_Resume(a1);
}

uint64_t sub_1DC37A56C(atomic_uint **a1, atomic_uint **a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
  }
  char v150 = v10;
  unint64_t v11 = a2[1];
  if (v11) {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v149 = v11;
  if (v10) {
    atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v148 = v10;
  if (v11) {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
  }
  long long v147 = v11;
  float v12 = sub_1DC3B4C78(&v148, (uint64_t)&v147);
  sub_1DC2FFD08(&v147);
  sub_1DC2FFD08(&v148);
  int v13 = *a1;
  if (*a1) {
    atomic_fetch_add_explicit(v13 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v146 = v13;
  uint64_t v14 = v150;
  if (v150) {
    atomic_fetch_add_explicit(v150 + 2, 1u, memory_order_relaxed);
  }
  char v145 = v14;
  if (!sub_1DC37B678(v13, (uint64_t *)&v145))
  {
    sub_1DC2FFD08(&v145);
    sub_1DC2FF548(&v146);
    goto LABEL_52;
  }
  uint64_t v15 = *a1;
  if (*a1) {
    atomic_fetch_add_explicit(v15 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v144 = v15;
  uint64_t v16 = v149;
  if (v149) {
    atomic_fetch_add_explicit(v149 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v143 = v16;
  char v17 = sub_1DC37B678(v15, (uint64_t *)&v143);
  if (v12 > 1.0) {
    char v18 = v17;
  }
  else {
    char v18 = 0;
  }
  sub_1DC2FFD08(&v143);
  sub_1DC2FF548(&v144);
  sub_1DC2FFD08(&v145);
  sub_1DC2FF548(&v146);
  if (v18)
  {
    float v19 = (*(float (**)(atomic_uint *))(*(void *)v150 + 16))(v150);
    float v20 = (*(float (**)(atomic_uint *))(*(void *)v150 + 24))(v150);
    float v21 = (*(float (**)(atomic_uint *))(*(void *)v149 + 16))(v149);
    float v22 = (*(float (**)(atomic_uint *))(*(void *)v149 + 24))(v149);
    float v23 = (*(float (**)(void))(*(void *)*a2 + 16))();
    float v24 = (*(float (**)(void))(*(void *)*a2 + 24))();
    float v25 = (*(float (**)(atomic_uint *))(*(void *)a2[1] + 16))(a2[1]);
    float v26 = (*(float (**)(atomic_uint *))(*(void *)a2[1] + 24))(a2[1]);
    int v27 = (int)v19;
    int v28 = (int)v20;
    int v29 = (int)v21;
    int v30 = (int)v22;
    float v31 = v26 - v24;
    float v32 = sqrtf((float)(v31 * v31) + (float)((float)(v25 - v23) * (float)(v25 - v23)));
    float v33 = (float)(v25 - v23) / v32;
    float v34 = v31 / v32;
    float v35 = -(float)(v31 / v32);
    if (!a3) {
      float v35 = v34;
    }
    float v136 = v35;
    if (a3) {
      float v36 = v33;
    }
    else {
      float v36 = -v33;
    }
    int v37 = (int)(float)((float)(v12 * 0.125) + 0.5);
    if (v37 >= 4) {
      int v38 = 4;
    }
    else {
      int v38 = (int)(float)((float)(v12 * 0.125) + 0.5);
    }
    if (v29 >= v27) {
      int v39 = (int)v19;
    }
    else {
      int v39 = (int)v21;
    }
    atomic_uint v40 = (*a1)[14];
    int v41 = -v40;
    atomic_uint v42 = (*a1)[8];
    atomic_uint v43 = v40 - 1;
    atomic_uint v44 = (*a1)[4];
    if (v27 <= v29) {
      int v27 = (int)v21;
    }
    int v45 = v27 + v38;
    if (v45 >= (v44 & v43 | v42 & v41)) {
      int v46 = v44 & v43 | v42 & v41;
    }
    else {
      int v46 = v45;
    }
    if (v30 >= v28) {
      int v47 = (int)v20;
    }
    else {
      int v47 = (int)v22;
    }
    if (v28 <= v30) {
      int v28 = (int)v22;
    }
    int v48 = v28 + v38;
    if (v48 >= (v42 & v43 | v44 & v41)) {
      int v49 = v42 & v43 | v44 & v41;
    }
    else {
      int v49 = v48;
    }
    float v50 = (*(float (**)(atomic_uint *))(*(void *)v150 + 16))(v150);
    float v142 = v50;
    float v51 = v12 * 0.25;
    float v141 = (*(float (**)(atomic_uint *))(*(void *)v150 + 24))(v150);
    float v52 = (float)((v39 - v38) & ~((v39 - v38) >> 31));
    if (v50 < v52 || v50 >= (float)v46)
    {
      long long v54 = 0;
      int v55 = 0;
      goto LABEL_162;
    }
    int v127 = v37;
    long long v54 = 0;
    int v55 = 0;
    int v124 = 0;
    int v57 = (int)(float)(v51 + 0.5);
    float v58 = (float)((v47 - v38) & ~((v47 - v38) >> 31));
    float v59 = (float)v49;
    float v125 = fabsf(v33);
    float v126 = fabsf(v34);
    uint64_t v60 = -1;
    if (v36 > 0.0) {
      uint64_t v61 = 1;
    }
    else {
      uint64_t v61 = -1;
    }
    if (v136 > 0.0) {
      uint64_t v60 = 1;
    }
    uint64_t v128 = v60;
    float v122 = (float)v46;
    float v123 = v52;
    float v120 = v59;
    float v121 = (float)((v47 - v38) & ~((v47 - v38) >> 31));
    while (1)
    {
      float v62 = v141;
      if (v141 < v58 || v141 >= v59) {
        goto LABEL_162;
      }
      CFTypeID v64 = *a1;
      if (*a1)
      {
        atomic_fetch_add_explicit(v64 + 2, 1u, memory_order_relaxed);
        atomic_fetch_add_explicit(v64 + 2, 1u, memory_order_relaxed);
      }
      int v140 = v64;
      v151[0] = v64;
      BOOL v65 = sub_1DC37BA20(v64, v50, v62);
      sub_1DC2FF548(v151);
      if (!v65) {
        goto LABEL_158;
      }
      int v131 = v55;
      double v132 = v54;
      int v66 = (int)v50;
      int v67 = (int)v62;
      int v68 = sub_1DC2FF924(v140, (int)v50, (int)v62);
      if (v57 < 1)
      {
        long long v54 = 0;
        int v55 = 0;
LABEL_158:
        uint32_t v119 = &v140;
        goto LABEL_161;
      }
      int v69 = v68;
      uint64_t v135 = v61;
      int v133 = v38;
      uint64_t v129 = a4;
      uint64_t v130 = a5;
      int v70 = 0;
      BOOL v71 = 1;
      while (1)
      {
        CGAffineTransform v72 = v140;
        if (v140) {
          atomic_fetch_add_explicit(v140 + 2, 1u, memory_order_relaxed);
        }
        float v50 = v33 + v50;
        float v62 = v34 + v62;
        uint64_t v137 = v72;
        BOOL v73 = sub_1DC37BA20(v72, v50, v62);
        sub_1DC2FF548(&v137);
        if (!v73)
        {
LABEL_157:
          int v55 = v131;
          long long v54 = v132;
          goto LABEL_158;
        }
        int v74 = (int)v50;
        int v75 = (int)v62;
        if ((int)v50 == v66 && v67 == v75)
        {
          float v77 = v140;
          if (v140) {
            atomic_fetch_add_explicit(v140 + 2, 1u, memory_order_relaxed);
          }
          float v50 = v33 + v50;
          float v62 = v34 + v62;
          int v138 = v77;
          BOOL v78 = sub_1DC37BA20(v77, v50, v62);
          sub_1DC2FF548(&v138);
          if (!v78) {
            goto LABEL_157;
          }
          int v74 = (int)v50;
          int v75 = (int)v62;
        }
        CGFloat v79 = v140;
        if (v69 == sub_1DC2FF924(v140, v74, v75)) {
          break;
        }
        if (v70)
        {
          if (v79) {
            atomic_fetch_add_explicit(v79 + 2, 1u, memory_order_relaxed);
          }
          float v80 = v50 - v136;
          float v81 = v62 - v36;
          uint64_t v137 = v79;
          BOOL v82 = sub_1DC37BA20(v79, v50 - v136, v62 - v36);
          sub_1DC2FF548(&v137);
          if (v82)
          {
            int v74 = (int)v80;
            int v75 = (int)v81;
            if ((int)v80 == v66 && v67 == v75)
            {
              CGRect v84 = v140;
              if (v140) {
                atomic_fetch_add_explicit(v140 + 2, 1u, memory_order_relaxed);
              }
              int v138 = v84;
              BOOL v85 = sub_1DC37BA20(v84, v80 - v136, v81 - v36);
              sub_1DC2FF548(&v138);
              if (!v85) {
                goto LABEL_96;
              }
              int v74 = (int)(float)(v80 - v136);
              int v75 = (int)(float)(v81 - v36);
            }
            if (v69 == sub_1DC2FF924(v140, v74, v75)) {
              break;
            }
          }
        }
LABEL_96:
        BOOL v71 = ++v70 < v57;
        if (v57 == v70)
        {
          uint32_t v119 = &v140;
          goto LABEL_160;
        }
      }
      float v142 = (float)v74 + 0.5;
      float v141 = (float)v75 + 0.5;
      sub_1DC2FF548(&v140);
      if (!v71)
      {
        int v55 = v131;
        long long v54 = v132;
        goto LABEL_162;
      }
      CGRect v86 = *a1;
      if (*a1)
      {
        atomic_fetch_add_explicit(v86 + 2, 1u, memory_order_relaxed);
        atomic_fetch_add_explicit(v86 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v139 = v86;
      uint64_t v137 = v86;
      BOOL v87 = sub_1DC37BA20(v86, (float)v74 + 0.5, (float)v75 + 0.5);
      sub_1DC2FF548(&v137);
      if (!v87) {
        goto LABEL_159;
      }
      int v88 = (int)(float)((float)v74 + 0.5);
      int v89 = (int)(float)((float)v75 + 0.5);
      CGRect v90 = v139;
      uint64_t v91 = v88;
      uint64_t v92 = v89;
      int v134 = sub_1DC2FF924(v139, v88, v89);
      if (v126 > v125)
      {
        if (v127 >= 1)
        {
          int v93 = v133;
          while (1)
          {
            if (v90) {
              atomic_fetch_add_explicit(v90 + 2, 1u, memory_order_relaxed);
            }
            int v138 = v90;
            BOOL v94 = sub_1DC37BA20(v90, (float)(v128 + v88), (float)v89);
            sub_1DC2FF548(&v138);
            if (!v94) {
              goto LABEL_159;
            }
            CGRect v90 = v139;
            if (v134 != sub_1DC2FF924(v139, v91 + v128, v89)) {
              break;
            }
            v88 += v128;
            v91 += v128;
            if (!--v93) {
              goto LABEL_159;
            }
          }
          int v97 = v91 + (v136 > 0.0);
          int v98 = v131;
          if (v131 < (int *)v124)
          {
            *int v131 = v97;
            v131[1] = v89;
            int v55 = v131 + 2;
            uint64_t v99 = &v142;
            goto LABEL_123;
          }
          uint64_t v102 = ((char *)v131 - (char *)v132) >> 3;
          unint64_t v103 = v102 + 1;
          if (!((unint64_t)(v102 + 1) >> 61))
          {
            if ((v124 - (char *)v132) >> 2 > v103) {
              unint64_t v103 = (v124 - (char *)v132) >> 2;
            }
            if ((unint64_t)(v124 - (char *)v132) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v104 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v104 = v103;
            }
            CFArrayRef v105 = (char *)sub_1DC2FFD7C(v104);
            CFIndex v107 = &v105[8 * v102];
            *(_DWORD *)CFIndex v107 = v97;
            *((_DWORD *)v107 + 1) = v89;
            std::string::size_type v108 = v107;
            if (v131 == v132)
            {
              a4 = v129;
              a5 = v130;
              int v38 = v133;
              uint64_t v61 = v135;
            }
            else
            {
              a4 = v129;
              a5 = v130;
              int v38 = v133;
              uint64_t v61 = v135;
              do
              {
                uint64_t v109 = *((void *)v98 - 1);
                v98 -= 2;
                *((void *)v108 - 1) = v109;
                v108 -= 8;
              }
              while (v98 != v132);
            }
            int v124 = &v105[8 * v106];
            int v55 = (int *)(v107 + 8);
            if (v132) {
              operator delete(v132);
            }
            uint64_t v99 = &v142;
            long long v54 = (int *)v108;
            goto LABEL_152;
          }
LABEL_169:
          sub_1DC2FF97C();
        }
LABEL_159:
        uint32_t v119 = &v139;
LABEL_160:
        int v55 = v131;
        long long v54 = v132;
LABEL_161:
        sub_1DC2FF548(v119);
LABEL_162:
        if ((unint64_t)((char *)v55 - (char *)v54) >= 0x20) {
          operator new();
        }
        if (v54) {
          operator delete(v54);
        }
        break;
      }
      if (v127 < 1) {
        goto LABEL_159;
      }
      int v95 = v133;
      while (1)
      {
        if (v90) {
          atomic_fetch_add_explicit(v90 + 2, 1u, memory_order_relaxed);
        }
        v151[0] = v90;
        BOOL v96 = sub_1DC37BA20(v90, (float)v88, (float)(v135 + v89));
        sub_1DC2FF548(v151);
        if (!v96) {
          goto LABEL_159;
        }
        CGRect v90 = v139;
        if (v134 != sub_1DC2FF924(v139, v88, v92 + v135)) {
          break;
        }
        v89 += v135;
        v92 += v135;
        if (!--v95) {
          goto LABEL_159;
        }
      }
      int v100 = v92 + (v36 > 0.0);
      float v101 = v131;
      if (v131 >= (int *)v124)
      {
        uint64_t v110 = ((char *)v131 - (char *)v132) >> 3;
        unint64_t v111 = v110 + 1;
        if ((unint64_t)(v110 + 1) >> 61) {
          goto LABEL_169;
        }
        if ((v124 - (char *)v132) >> 2 > v111) {
          unint64_t v111 = (v124 - (char *)v132) >> 2;
        }
        if ((unint64_t)(v124 - (char *)v132) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v112 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v112 = v111;
        }
        unsigned int v113 = (char *)sub_1DC2FFD7C(v112);
        __int32 v115 = (int *)&v113[8 * v110];
        *__int32 v115 = v88;
        v115[1] = v100;
        uint64_t v116 = v115;
        if (v131 == v132)
        {
          a4 = v129;
          int v38 = v133;
          uint64_t v61 = v135;
        }
        else
        {
          a4 = v129;
          int v38 = v133;
          uint64_t v61 = v135;
          do
          {
            uint64_t v117 = *((void *)v101 - 1);
            v101 -= 2;
            *((void *)v116 - 1) = v117;
            v116 -= 2;
          }
          while (v101 != v132);
        }
        int v124 = &v113[8 * v114];
        int v55 = v115 + 2;
        if (v132) {
          operator delete(v132);
        }
        uint64_t v99 = &v141;
        long long v54 = v116;
        LODWORD(v91) = v92;
        a5 = v130;
      }
      else
      {
        *int v131 = v88;
        v131[1] = v100;
        int v55 = v131 + 2;
        uint64_t v99 = &v141;
        LODWORD(v91) = v92;
LABEL_123:
        a4 = v129;
        a5 = v130;
        long long v54 = v132;
        int v38 = v133;
        uint64_t v61 = v135;
      }
LABEL_152:
      *uint64_t v99 = (float)(int)v91 + 0.5;
      sub_1DC2FF548(&v139);
      float v50 = v142;
      BOOL v118 = v142 >= v123 && v142 < v122;
      float v59 = v120;
      float v58 = v121;
      if (!v118) {
        goto LABEL_162;
      }
    }
  }
LABEL_52:
  sub_1DC2FFD08(&v149);
  sub_1DC2FFD08(&v150);
  return 0;
}

void sub_1DC37B3CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,int a35,__int16 a36,char a37,char a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,int a47,__int16 a48,char a49,char a50,int a51,atomic_uint *a52)
{
  sub_1DC2FF548(&a52);
  if (__p) {
    operator delete(__p);
  }
  sub_1DC2FFD08((atomic_uint **)(v52 - 176));
  sub_1DC2FFD08((atomic_uint **)(v52 - 168));
  _Unwind_Resume(a1);
}

void sub_1DC37B4F8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (atomic_uint **)**a1;
  if (v2)
  {
    long long v4 = (atomic_uint **)v1[1];
    CFTypeID v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        CFTypeID v6 = v4 - 2;
        sub_1DC2FFD08(v4 - 1);
        sub_1DC2FFD08(v6);
        long long v4 = v6;
      }
      while (v6 != v2);
      CFTypeID v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

float sub_1DC37B588(void *a1)
{
  (*(void (**)(void))(*(void *)*a1 + 16))(*a1);
  float v2 = (*(float (**)(void))(*(void *)*a1 + 24))();
  (*(void (**)(void))(*(void *)a1[1] + 16))(a1[1]);
  return v2 - (*(float (**)(void))(*(void *)a1[1] + 24))(a1[1]);
}

uint64_t sub_1DC37B678(atomic_uint *a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2)
  {
    if (a1)
    {
      atomic_fetch_add_explicit(a1 + 2, 1u, memory_order_relaxed);
      uint64_t result = *a2;
    }
    float v8 = a1;
    float v5 = (*(float (**)(uint64_t))(*(void *)result + 16))(result);
    float v6 = (*(float (**)(void))(*(void *)*a2 + 24))();
    BOOL v7 = sub_1DC37BA20(v8, v5, v6);
    sub_1DC2FF548(&v8);
    return v7;
  }
  return result;
}

void sub_1DC37B73C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC2FF548((atomic_uint **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC37B750(atomic_uint **a1, atomic_uint **a2, atomic_uint **a3)
{
  float v5 = a1;
  float v6 = *a1;
  if (v6) {
    atomic_fetch_add_explicit(v6 + 2, 1u, memory_order_relaxed);
  }
  int v39 = v6;
  BOOL v7 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v7 + 2, 1u, memory_order_relaxed);
  }
  int v38 = v7;
  if (!sub_1DC37B678(v6, (uint64_t *)&v38))
  {
    sub_1DC2FFD08(&v38);
    sub_1DC2FF548(&v39);
    return 0xFFFFFFFFLL;
  }
  float v8 = *v5;
  if (*v5) {
    atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
  }
  int v37 = v8;
  float v9 = *a3;
  if (*a3) {
    atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
  }
  float v36 = v9;
  char v10 = sub_1DC37B678(v8, (uint64_t *)&v36);
  sub_1DC2FFD08(&v36);
  sub_1DC2FF548(&v37);
  sub_1DC2FFD08(&v38);
  sub_1DC2FF548(&v39);
  if ((v10 & 1) == 0) {
    return 0xFFFFFFFFLL;
  }
  int v11 = (int)(*(float (**)(void))(*(void *)*a2 + 16))();
  int v12 = (int)(*(float (**)(void))(*(void *)*a2 + 24))();
  int v13 = (int)(*(float (**)(void))(*(void *)*a3 + 16))();
  int v14 = (int)(*(float (**)(void))(*(void *)*a3 + 24))();
  if (v14 - v12 >= 0) {
    unsigned int v15 = v14 - v12;
  }
  else {
    unsigned int v15 = v12 - v14;
  }
  if (v13 - v11 >= 0) {
    unsigned int v16 = v13 - v11;
  }
  else {
    unsigned int v16 = v11 - v13;
  }
  if (v15 > v16) {
    unsigned int v17 = v16;
  }
  else {
    unsigned int v17 = v15;
  }
  if (v15 > v16) {
    unsigned int v18 = v15;
  }
  else {
    unsigned int v18 = v16;
  }
  if (v15 > v16) {
    int v19 = v12;
  }
  else {
    int v19 = v11;
  }
  if (v15 > v16) {
    int v20 = v11;
  }
  else {
    int v20 = v12;
  }
  if (v15 > v16) {
    int v21 = v14;
  }
  else {
    int v21 = v13;
  }
  if (v15 > v16) {
    int v14 = v13;
  }
  int v34 = v14;
  unsigned int v35 = v17;
  if (v20 < v14) {
    int v22 = 1;
  }
  else {
    int v22 = -1;
  }
  int v33 = v22;
  if (v19 < v21) {
    int v23 = 1;
  }
  else {
    int v23 = -1;
  }
  if (v19 == v21) {
    return 0;
  }
  unsigned int v32 = v18;
  float v25 = *v5;
  unsigned __int8 v26 = sub_1DC2FF924(*v5, v11, v12);
  LODWORD(v5) = 0;
  int v27 = (signed int)-v32 >> 1;
  do
  {
    if (v15 <= v16) {
      int v28 = v19;
    }
    else {
      int v28 = v20;
    }
    uint64_t v29 = v28;
    if (v15 <= v16) {
      int v30 = v20;
    }
    else {
      int v30 = v19;
    }
    unsigned __int8 v31 = sub_1DC2FF924(v25, v29, v30);
    float v5 = (atomic_uint **)(v5 + ((v26 ^ v31) & 1));
    if ((v26 ^ v31)) {
      unsigned __int8 v26 = v31;
    }
    v27 += v35;
    if (v27 >= 1)
    {
      if (v20 == v34) {
        return (uint64_t)v5;
      }
      v20 += v33;
      v27 -= v32;
    }
    v19 += v23;
  }
  while (v21 != v19);
  return (uint64_t)v5;
}

void sub_1DC37B9EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  long long v4 = va_arg(va1, atomic_uint *);
  va_copy(va2, va1);
  float v6 = va_arg(va2, atomic_uint *);
  va_copy(va3, va2);
  float v8 = va_arg(va3, atomic_uint *);
  sub_1DC2FFD08((atomic_uint **)va);
  sub_1DC2FF548((atomic_uint **)va1);
  sub_1DC2FFD08((atomic_uint **)va2);
  sub_1DC2FF548((atomic_uint **)va3);
  _Unwind_Resume(a1);
}

BOOL sub_1DC37BA20(void *a1, float a2, float a3)
{
  if (a2 < 0.0) {
    return 0;
  }
  BOOL result = 0;
  if (a3 >= 0.0)
  {
    uint64_t v5 = a1[7];
    uint64_t v6 = -v5;
    uint64_t v7 = a1[2];
    int v8 = v5 - 1;
    uint64_t v9 = a1[4];
    if ((float)(v7 & v8 | v9 & v6) > a2) {
      return (float)(v9 & v8 | v7 & v6) > a3;
    }
  }
  return result;
}

uint64_t sub_1DC37BA8C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    float v2 = **(atomic_uint ****)(a1 + 16);
    uint64_t v3 = **(atomic_uint ****)(a1 + 8);
    if (v2 != v3)
    {
      do
      {
        long long v4 = v2 - 2;
        sub_1DC2FFD08(v2 - 1);
        sub_1DC2FFD08(v4);
        float v2 = v4;
      }
      while (v4 != v3);
    }
  }
  return a1;
}

void sub_1DC37BAF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1DC37BBF4(uint64_t a1, int a2)
{
  if (a2) {
    int v2 = 5;
  }
  else {
    int v2 = 7;
  }
  if (a2) {
    float v3 = -5.0;
  }
  else {
    float v3 = -7.0;
  }
  sub_1DC37E748(v3, v3, 1.0, 0.0, (uint64_t)v4, a1, (2 * v2) | 1);
}

void sub_1DC37BDC0(void *a1)
{
}

void sub_1DC37BDD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, atomic_uint *a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  sub_1DC2FF548(&a13);
  for (uint64_t i = 24; i != -8; i -= 8)
    sub_1DC314744((atomic_uint **)(&a17 + i));
  _Unwind_Resume(a1);
}

uint64_t sub_1DC37BE48(uint64_t a1, double a2, double a3)
{
  if (**(unsigned char **)a1 && **(_DWORD **)(a1 + 8)) {
    sub_1DC3A82FC();
  }
  uint64_t v5 = **(float32x2_t ***)(a1 + 24);
  float32x2_t v6 = v5[1];
  float32x2_t v8 = v5[2];
  float32x2_t v7 = v5[3];
  LODWORD(a3) = **(_DWORD **)(a1 + 80);
  float32x2_t v9 = vsub_f32(*v5, v7);
  int32x2_t v10 = (int32x2_t)vmul_f32(v9, v9);
  float32x2_t v11 = vsub_f32(*v5, v6);
  float32x2_t v12 = vsub_f32(v6, v8);
  int32x2_t v13 = (int32x2_t)vmul_f32(v12, v12);
  int32x2_t v14 = (int32x2_t)vmul_f32(v11, v11);
  float32x2_t v15 = vsub_f32(v8, v7);
  int32x2_t v16 = (int32x2_t)vmul_f32(v15, v15);
  float32x2_t v17 = vmul_f32(vadd_f32(vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v14, v10), (float32x2_t)vzip2_s32(v14, v10))), vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v16, v13), (float32x2_t)vzip2_s32(v16, v13)))), (float32x2_t)0x3F0000003F000000);
  float32x2_t v18 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
  if (**(unsigned char **)(a1 + 88))
  {
    int v19 = **(float32x2_t ***)(a1 + 96);
    float32x2_t v20 = v19[1];
    float32x2_t v22 = v19[2];
    float32x2_t v21 = v19[3];
    float32x2_t v23 = vsub_f32(*v19, v21);
    int32x2_t v24 = (int32x2_t)vmul_f32(v23, v23);
    float32x2_t v25 = vsub_f32(v20, v22);
    int32x2_t v26 = (int32x2_t)vmul_f32(v25, v25);
    *(float *)v3.i32 = (float)(2 * **(_DWORD **)(a1 + 104));
    float32x2_t v27 = vsub_f32(*v19, v20);
    int32x2_t v28 = (int32x2_t)vmul_f32(v27, v27);
    float32x2_t v29 = vsub_f32(v22, v21);
    int32x2_t v30 = (int32x2_t)vmul_f32(v29, v29);
    int8x8_t v31 = (int8x8_t)vdiv_f32(vadd_f32(vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v28, v24), (float32x2_t)vzip2_s32(v28, v24))), vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v30, v26), (float32x2_t)vzip2_s32(v30, v26)))), (float32x2_t)vdup_lane_s32(v3, 0));
    float v32 = vabds_f32(*(float *)&v31.i32[1], *(float *)&a3);
    if (vabds_f32(*(float *)v31.i32, *(float *)&a3) < (float)(*(float *)&a3 * 0.5)
      && v32 < (float)(*(float *)&a3 * 0.5))
    {
      unsigned int v34 = -1;
    }
    else
    {
      unsigned int v34 = 0;
    }
    float32x2_t v18 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v34), v31, (int8x8_t)v18);
  }
  float32x2_t v35 = vdiv_f32(v17, v18);
  if (**(unsigned char **)(a1 + 40)) {
    float v36 = (int *)&unk_1DC40C73C;
  }
  else {
    float v36 = (int *)&unk_1DC40C6BC;
  }
  uint64_t v37 = 4;
  if (!**(unsigned char **)(a1 + 40)) {
    uint64_t v37 = 32;
  }
  int v38 = *v36;
  float v39 = (float)*v36;
  if (v35.f32[1] >= v35.f32[0]) {
    float v40 = v35.f32[0];
  }
  else {
    float v40 = v35.f32[1];
  }
  if (v40 <= (float)(v39 - (float)((float)v38 * 0.4))) {
    goto LABEL_35;
  }
  float v41 = (float)v36[v37 - 1];
  float v42 = v41 * 0.4;
  float v43 = v35.f32[0] >= v35.f32[1] ? v35.f32[0] : v35.f32[1];
  if (v43 >= (float)(v42 + v41)) {
    goto LABEL_35;
  }
  float v44 = (float)(v35.f32[0] + v35.f32[1]) * 0.5;
  unint64_t v45 = (unint64_t)&v36[v37];
  if (**(unsigned char **)(a1 + 40)) {
    int v46 = (int *)&unk_1DC40C740;
  }
  else {
    int v46 = (int *)&unk_1DC40C6C0;
  }
  int v47 = v36;
  if (v46 != (int *)v45)
  {
    int v48 = v46;
    do
    {
      int v50 = *v48++;
      int v49 = v50;
      if (vabds_f32((float)v50, v44) < vabds_f32((float)v38, v44))
      {
        int v38 = v49;
        int v47 = v46;
      }
      int v46 = v48;
    }
    while (v48 != (int *)v45);
    int v38 = *v47;
    float v39 = (float)*v47;
  }
  if (vabds_f32(v39, v44) <= v42)
  {
    float v51 = (char *)operator new(4uLL);
    *(_DWORD *)float v51 = v38;
    uint64_t v52 = v51 + 4;
    if (v36 < v47)
    {
      int v57 = *(v47 - 1);
      float v58 = (char *)operator new(8uLL);
      uint64_t v52 = v58 + 8;
      *(_DWORD *)float v58 = *(_DWORD *)v51;
      *((_DWORD *)v58 + 1) = v57;
      operator delete(v51);
      float v51 = v58;
    }
    if ((unint64_t)(v47 + 1) >= v45)
    {
      unint64_t v53 = (unint64_t)v52;
    }
    else
    {
      uint64_t v59 = v52 - v51;
      uint64_t v60 = (v52 - v51) >> 2;
      if ((unint64_t)(v60 + 1) >> 62) {
        sub_1DC2FF97C();
      }
      int v61 = v47[1];
      uint64_t v62 = v59 >> 1;
      if (v59 >> 1 <= (unint64_t)(v60 + 1)) {
        uint64_t v62 = v60 + 1;
      }
      if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v63 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v63 = v62;
      }
      if (v63) {
        unint64_t v63 = (unint64_t)sub_1DC314E5C(v63);
      }
      else {
        uint64_t v64 = 0;
      }
      BOOL v65 = (int *)(v63 + 4 * v60);
      unint64_t v53 = v63 + 4 * v64;
      *BOOL v65 = v61;
      int v66 = (char *)(v65 + 1);
      while (v52 != v51)
      {
        int v67 = *((_DWORD *)v52 - 1);
        v52 -= 4;
        *--BOOL v65 = v67;
      }
      operator delete(v51);
      float v51 = (char *)v65;
      uint64_t v52 = v66;
    }
    if (v52 - v51 == 12)
    {
      int v69 = *((_DWORD *)v51 + 1);
      int v68 = *((_DWORD *)v51 + 2);
      if (vabds_f32((float)v68, v44) < vabds_f32((float)v69, v44))
      {
        *((_DWORD *)v51 + 1) = v68;
        *((_DWORD *)v51 + 2) = v69;
      }
    }
  }
  else
  {
LABEL_35:
    float v51 = 0;
    uint64_t v52 = 0;
    unint64_t v53 = 0;
  }
  uint64_t v54 = *(void *)(a1 + 112);
  int v55 = *(void **)v54;
  if (*(void *)v54)
  {
    *(void *)(v54 + 8) = v55;
    operator delete(v55);
    *(void *)uint64_t v54 = 0;
    *(void *)(v54 + 8) = 0;
    *(void *)(v54 + 16) = 0;
  }
  *(void *)uint64_t v54 = v51;
  *(void *)(v54 + 8) = v52;
  *(void *)(v54 + 16) = v53;
  if (**(void **)(a1 + 112) != *(void *)(*(void *)(a1 + 112) + 8)) {
    sub_1DC3A82FC();
  }
  return 0;
}

void sub_1DC37C294(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC37C2AC(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!**(unsigned char **)a1 || (int v2 = **(_DWORD **)(a1 + 8)) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (*(void *)v3 == *(void *)(v3 + 8)) {
      return 0;
    }
    int v2 = **(_DWORD **)v3;
  }
  if (**(unsigned char **)(a1 + 24))
  {
    long long v4 = (char *)operator new(0x20uLL);
    *(float *)v5.i32 = (float)v2 * 0.5;
    float32x2_t v6 = v4 + 32;
    BOOL v82 = v4 + 32;
    uint64_t v83 = v4 + 32;
    *(float *)long long v4 = -*(float *)v5.i32;
    *((float *)v4 + 1) = -*(float *)v5.i32;
    *((float *)v4 + 2) = -*(float *)v5.i32;
    *(int32x4_t *)(v4 + 12) = vdupq_lane_s32(v5, 0);
    *((float *)v4 + 7) = -*(float *)v5.i32;
    unint64_t v80 = 0;
    float v81 = v4;
    BOOL v78 = 0;
    CGFloat v79 = 0;
    sub_1DC37E438((void **)&v78, 0x10uLL);
    uint64_t v8 = *(void *)(v1 + 32);
    float32x2_t v9 = *(void **)v8;
    int32x2_t v10 = *(void **)(v8 + 8);
    uint64_t v74 = v1;
    if (*(void **)v8 != v10)
    {
      float32x2_t v11 = v79;
      unint64_t v12 = v80;
      int32x2_t v13 = v78;
      do
      {
        *(void *)&long long v7 = *v9;
        if ((unint64_t)v11 >= v12)
        {
          long long v75 = v7;
          uint64_t v15 = (v11 - v13) >> 2;
          unint64_t v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 62)
          {
            CGFloat v79 = v11;
            unint64_t v80 = v12;
            BOOL v78 = v13;
            sub_1DC2FF97C();
          }
          if ((uint64_t)(v12 - (void)v13) >> 1 > v16) {
            unint64_t v16 = (uint64_t)(v12 - (void)v13) >> 1;
          }
          if (v12 - (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v16;
          }
          if (v17) {
            unint64_t v17 = (unint64_t)sub_1DC314E5C(v17);
          }
          else {
            uint64_t v18 = 0;
          }
          int v19 = (char *)(v17 + 4 * v15);
          *(_DWORD *)int v19 = v75;
          int32x2_t v14 = v19 + 4;
          if (v11 != v13)
          {
            float32x2_t v20 = v11;
            do
            {
              int v21 = *((_DWORD *)v20 - 1);
              v20 -= 4;
              *((_DWORD *)v19 - 1) = v21;
              v19 -= 4;
            }
            while (v20 != v13);
          }
          unint64_t v12 = v17 + 4 * v18;
          if (v13) {
            operator delete(v13);
          }
          int32x2_t v13 = v19;
          long long v7 = v75;
        }
        else
        {
          *(_DWORD *)float32x2_t v11 = v7;
          int32x2_t v14 = v11 + 4;
        }
        int v22 = DWORD1(v7);
        if ((unint64_t)v14 >= v12)
        {
          uint64_t v23 = (v14 - v13) >> 2;
          unint64_t v24 = v23 + 1;
          if ((unint64_t)(v23 + 1) >> 62)
          {
            CGFloat v79 = v11;
            unint64_t v80 = v12;
            BOOL v78 = v13;
            sub_1DC2FF97C();
          }
          if ((uint64_t)(v12 - (void)v13) >> 1 > v24) {
            unint64_t v24 = (uint64_t)(v12 - (void)v13) >> 1;
          }
          if (v12 - (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v25 = v24;
          }
          if (v25) {
            unint64_t v25 = (unint64_t)sub_1DC314E5C(v25);
          }
          else {
            uint64_t v26 = 0;
          }
          float32x2_t v27 = (char *)(v25 + 4 * v23);
          *(_DWORD *)float32x2_t v27 = v22;
          float32x2_t v11 = v27 + 4;
          while (v14 != v13)
          {
            int v28 = *((_DWORD *)v14 - 1);
            v14 -= 4;
            *((_DWORD *)v27 - 1) = v28;
            v27 -= 4;
          }
          unint64_t v12 = v25 + 4 * v26;
          if (v13) {
            operator delete(v13);
          }
          int32x2_t v13 = v27;
        }
        else
        {
          *(_DWORD *)int32x2_t v14 = DWORD1(v7);
          float32x2_t v11 = v14 + 4;
        }
        ++v9;
      }
      while (v9 != v10);
      CGFloat v79 = v11;
      unint64_t v80 = v12;
      BOOL v78 = v13;
    }
    int v29 = **(_DWORD **)(v1 + 40);
    int32x2_t v30 = (int32x2_t *)operator new(0x20uLL);
    uint64_t v31 = 0;
    *(float *)v32.i32 = (float)v29 * 0.5;
    *(float *)&long long v33 = -*(float *)v32.i32;
    int32x2_t v34 = vdup_lane_s32(v32, 0);
    *(float *)v35.i32 = -*(float *)v32.i32;
    v35.i32[1] = v32.i32[0];
    *(float *)&v32.i32[1] = -*(float *)v32.i32;
    *int32x2_t v30 = vdup_lane_s32(*(int32x2_t *)&v33, 0);
    v30[1] = v35;
    v30[2] = v34;
    void v30[3] = v32;
    unint64_t v36 = v80;
    uint64_t v37 = v78;
    int v38 = v82;
    float v39 = v4 + 32;
    do
    {
      *(void *)&long long v33 = *(void *)(**(void **)(v1 + 48) + 8 * v31);
      long long v76 = v33;
      int v40 = DWORD1(v33);
      if (v6 >= v39)
      {
        int v73 = (int)v30[v31];
        uint64_t v42 = (v6 - v4) >> 2;
        unint64_t v43 = v42 + 1;
        if ((unint64_t)(v42 + 1) >> 62)
        {
          BOOL v82 = v38;
          uint64_t v83 = v39;
          unint64_t v80 = v36;
          float v81 = v4;
          BOOL v78 = v37;
          sub_1DC2FF97C();
        }
        if ((v39 - v4) >> 1 > v43) {
          unint64_t v43 = (v39 - v4) >> 1;
        }
        if ((unint64_t)(v39 - v4) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v44 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v44 = v43;
        }
        if (v44) {
          unint64_t v44 = (unint64_t)sub_1DC314E5C(v44);
        }
        else {
          uint64_t v45 = 0;
        }
        int v46 = (char *)(v44 + 4 * v42);
        *(_DWORD *)int v46 = v73;
        float v41 = v46 + 4;
        while (v6 != v4)
        {
          int v47 = *((_DWORD *)v6 - 1);
          v6 -= 4;
          *((_DWORD *)v46 - 1) = v47;
          v46 -= 4;
        }
        float v39 = (char *)(v44 + 4 * v45);
        if (v4) {
          operator delete(v4);
        }
        long long v4 = v46;
      }
      else
      {
        *(_DWORD *)float32x2_t v6 = v30[v31];
        float v41 = v6 + 4;
      }
      __int32 v48 = v30[v31].i32[1];
      if (v41 >= v39)
      {
        uint64_t v49 = (v41 - v4) >> 2;
        unint64_t v50 = v49 + 1;
        if ((unint64_t)(v49 + 1) >> 62)
        {
          BOOL v82 = v38;
          uint64_t v83 = v39;
          unint64_t v80 = v36;
          float v81 = v4;
          BOOL v78 = v37;
          sub_1DC2FF97C();
        }
        if ((v39 - v4) >> 1 > v50) {
          unint64_t v50 = (v39 - v4) >> 1;
        }
        if ((unint64_t)(v39 - v4) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v51 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v51 = v50;
        }
        if (v51) {
          unint64_t v51 = (unint64_t)sub_1DC314E5C(v51);
        }
        else {
          uint64_t v52 = 0;
        }
        unint64_t v53 = (__int32 *)(v51 + 4 * v49);
        __int32 *v53 = v48;
        int v38 = (char *)(v53 + 1);
        while (v41 != v4)
        {
          __int32 v54 = *((_DWORD *)v41 - 1);
          v41 -= 4;
          *--unint64_t v53 = v54;
        }
        float v39 = (char *)(v51 + 4 * v52);
        if (v4) {
          operator delete(v4);
        }
        long long v4 = (char *)v53;
      }
      else
      {
        *(_DWORD *)float v41 = v48;
        int v38 = v41 + 4;
      }
      int v55 = v79;
      if ((unint64_t)v79 >= v36)
      {
        uint64_t v57 = (v79 - v37) >> 2;
        unint64_t v58 = v57 + 1;
        if ((unint64_t)(v57 + 1) >> 62)
        {
          BOOL v82 = v38;
          uint64_t v83 = v39;
          unint64_t v80 = v36;
          float v81 = v4;
          BOOL v78 = v37;
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v36 - (void)v37) >> 1 > v58) {
          unint64_t v58 = (uint64_t)(v36 - (void)v37) >> 1;
        }
        if (v36 - (unint64_t)v37 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v59 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v59 = v58;
        }
        if (v59) {
          unint64_t v59 = (unint64_t)sub_1DC314E5C(v59);
        }
        else {
          uint64_t v60 = 0;
        }
        int v61 = (char *)(v59 + 4 * v57);
        *((void *)&v33 + 1) = *((void *)&v76 + 1);
        *(_DWORD *)int v61 = v76;
        int v56 = v61 + 4;
        while (v55 != v37)
        {
          int v62 = *((_DWORD *)v55 - 1);
          v55 -= 4;
          *((_DWORD *)v61 - 1) = v62;
          v61 -= 4;
        }
        unint64_t v36 = v59 + 4 * v60;
        if (v37) {
          operator delete(v37);
        }
        uint64_t v37 = v61;
      }
      else
      {
        *((void *)&v33 + 1) = *((void *)&v76 + 1);
        *(_DWORD *)CGFloat v79 = v76;
        int v56 = v55 + 4;
      }
      if ((unint64_t)v56 >= v36)
      {
        uint64_t v64 = (v56 - v37) >> 2;
        unint64_t v65 = v64 + 1;
        if ((unint64_t)(v64 + 1) >> 62)
        {
          BOOL v82 = v38;
          uint64_t v83 = v39;
          unint64_t v80 = v36;
          float v81 = v4;
          BOOL v78 = v37;
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v36 - (void)v37) >> 1 > v65) {
          unint64_t v65 = (uint64_t)(v36 - (void)v37) >> 1;
        }
        if (v36 - (unint64_t)v37 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v66 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v66 = v65;
        }
        if (v66) {
          unint64_t v66 = (unint64_t)sub_1DC314E5C(v66);
        }
        else {
          uint64_t v67 = 0;
        }
        int v68 = (char *)(v66 + 4 * v64);
        *(_DWORD *)int v68 = v40;
        unint64_t v63 = v68 + 4;
        while (v56 != v37)
        {
          int v69 = *((_DWORD *)v56 - 1);
          v56 -= 4;
          *((_DWORD *)v68 - 1) = v69;
          v68 -= 4;
        }
        unint64_t v36 = v66 + 4 * v67;
        if (v37) {
          operator delete(v37);
        }
        uint64_t v37 = v68;
      }
      else
      {
        *(_DWORD *)int v56 = v40;
        unint64_t v63 = v56 + 4;
      }
      CGFloat v79 = v63;
      float32x2_t v6 = v38;
      ++v31;
      uint64_t v1 = v74;
    }
    while (v31 != 4);
    BOOL v82 = v38;
    uint64_t v83 = v39;
    unint64_t v80 = v36;
    float v81 = v4;
    BOOL v78 = v37;
    int v70 = *(atomic_uint **)(*(void *)(v74 + 56) + 288);
    if (v70) {
      atomic_fetch_add_explicit(v70 + 2, 1u, memory_order_relaxed);
    }
    float v77 = v70;
    int v71 = sub_1DC354238((uint64_t)&v77, (const void **)&v81, (uint64_t)&v78);
    sub_1DC30184C(&v77);
    if (v71) {
      sub_1DC37BBF4(**(void **)(v74 + 64), **(unsigned __int8 **)(v74 + 72));
    }
    operator delete(v30);
    if (v37)
    {
      CGFloat v79 = v37;
      operator delete(v37);
      long long v4 = v81;
    }
    if (v4)
    {
      BOOL v82 = v4;
      operator delete(v4);
    }
  }
  return 0;
}

void sub_1DC37C8DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  operator delete(v22);
  if (__p) {
    operator delete(__p);
  }
  if (v23) {
    operator delete(v23);
  }
  _Unwind_Resume(a1);
}

void sub_1DC37C96C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a7)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(a7 + 8), 1u, memory_order_relaxed);
    sub_1DC353F50();
  }
  sub_1DC37E254();
}

void sub_1DC37DFAC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,atomic_uint *a51)
{
  sub_1DC311C34((atomic_uint **)(v51 - 176));
  sub_1DC3116C8(&a51);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DC37DF78);
}

void sub_1DC37DFE8()
{
}

void sub_1DC37DFF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62)
{
}

void sub_1DC37E000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,atomic_uint *a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,atomic_uint *a59,atomic_uint *a60,uint64_t a61,atomic_uint *a62,uint64_t a63)
{
  if (__p) {
    operator delete(__p);
  }
  if (a67) {
    operator delete(a67);
  }
  sub_1DC311C34(&a54);
  sub_1DC3116C8(&a59);
  sub_1DC2FF548(&a60);
  sub_1DC311C00(&a62);
  _Unwind_Resume(a1);
}

void sub_1DC37E254()
{
}

void sub_1DC37E3EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  sub_1DC2FF548(v13);
  _Unwind_Resume(a1);
}

void sub_1DC37E438(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      sub_1DC2FF97C();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    long long v4 = (char *)sub_1DC314E5C(a2);
    int32x2_t v5 = &v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    long long v7 = &v4[4 * v6];
    uint64_t v8 = (char *)*a1;
    float32x2_t v9 = (char *)a1[1];
    int32x2_t v10 = v5;
    if (v9 != *a1)
    {
      int32x2_t v10 = v5;
      do
      {
        int v11 = *((_DWORD *)v9 - 1);
        v9 -= 4;
        *((_DWORD *)v10 - 1) = v11;
        v10 -= 4;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

float sub_1DC37E4E0(void *a1, int a2, int a3, _DWORD *a4)
{
  if (a3 - 4 <= -a2) {
    int v4 = -a2;
  }
  else {
    int v4 = a3 - 4;
  }
  int v5 = a3 + 4;
  if (a3 + 4 >= a2) {
    int v5 = a2;
  }
  *a4 = 2 * (a3 - v4);
  int v6 = v5 - v4;
  int v7 = (2 * (v5 - v4)) | 1;
  uint64_t v8 = (float **)sub_1DC320A5C(a1, v7);
  if ((v6 & 0x80000000) == 0)
  {
    float result = (float)v4;
    int32x2_t v10 = *v8;
    if (v7 <= 1) {
      unsigned int v11 = 1;
    }
    else {
      unsigned int v11 = v7;
    }
    uint64_t v12 = 4 * v11;
    do
    {
      *v10++ = result;
      float result = result + 0.5;
      v12 -= 4;
    }
    while (v12);
  }
  return result;
}

uint64_t sub_1DC37E56C(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6)
{
  int v6 = a6 - 1;
  if (a6 == 1 || (a3 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v9 = 0;
  if ((a2 & 0x80000000) != 0) {
    return v9;
  }
  int v11 = *(_DWORD *)(a1 + 56);
  int v12 = -v11;
  int v13 = *(_DWORD *)(a1 + 16);
  int v14 = v13 & -v11--;
  int v15 = *(_DWORD *)(a1 + 32);
  int v16 = v15 & v11 | v14;
  int v17 = v13 & v11 | v15 & v12;
  if (v16 <= (int)a3 || v17 <= (int)a2) {
    return v9;
  }
  int v20 = a3 + v6 * a5;
  if (v20 < 0) {
    return 0;
  }
  uint64_t v9 = 0;
  if (v20 < v16)
  {
    int v22 = a2 + v6 * a4;
    if ((v22 & 0x80000000) == 0 && v22 < v17 && a6 >= 2)
    {
      unsigned __int8 v23 = sub_1DC2FF924((void *)a1, a2, a3);
      LODWORD(v9) = 0;
      uint64_t v24 = a4 + (unint64_t)a2;
      uint64_t v25 = a5 + (unint64_t)a3;
      do
      {
        unsigned __int8 v26 = sub_1DC2FF924((void *)a1, v24, v25);
        uint64_t v9 = v9 + ((v23 ^ v26) & 1);
        if ((v23 ^ v26)) {
          unsigned __int8 v23 = v26;
        }
        v24 += a4;
        v25 += a5;
        --v6;
      }
      while (v6);
    }
  }
  return v9;
}

float32x2_t sub_1DC37E690(int32x4_t *a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v4 = vmul_f32(a3, a3);
  v4.i32[0] = vadd_f32(v4, (float32x2_t)vdup_lane_s32((int32x2_t)v4, 1)).u32[0];
  float32x2_t v5 = vrsqrte_f32((float32x2_t)v4.u32[0]);
  float32x2_t v6 = vmul_f32(v5, vrsqrts_f32((float32x2_t)v4.u32[0], vmul_f32(v5, v5)));
  float32x2_t v7 = vmul_n_f32(a3, vmul_f32(v6, vrsqrts_f32((float32x2_t)v4.u32[0], vmul_f32(v6, v6))).f32[0]);
  double v8 = COERCE_DOUBLE(vcvt_s32_f32(a2));
  for (unint64_t i = LODWORD(v8); (LODWORD(v8) & 0x80000000) == 0; unint64_t i = LODWORD(v8))
  {
    if (a1->i64[1] <= i) {
      break;
    }
    if ((HIDWORD(v8) & 0x80000000) != 0) {
      break;
    }
    if (a1[1].i64[0] <= (unint64_t)HIDWORD(v8)) {
      break;
    }
    if (!sub_1DC3A8728(a1, v8)) {
      break;
    }
    a2 = vadd_f32(v7, a2);
    double v8 = COERCE_DOUBLE(vcvt_s32_f32(a2));
  }
  return vcvt_f32_s32(vsub_s32(vcvt_s32_f32(vsub_f32(a2, v7)), vcgtz_f32(v7)));
}

void sub_1DC37E748(float a1, float a2, float a3, float a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  sub_1DC320A5C(&v16, 2 * a7);
  int v13 = (float *)((char *)v16 + 4);
  uint64_t v14 = a7;
  do
  {
    *(v13 - 1) = a1;
    float *v13 = a2;
    a1 = a1 + a3;
    a2 = a2 + a4;
    v13 += 2;
    --v14;
  }
  while (v14);
  sub_1DC3A83A0(&__p, a6, (uint64_t *)&v16);
  operator new();
}

void sub_1DC37E86C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  MEMORY[0x1E019CE90](v13, 0x1091C40C7871EBFLL);
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DC37F038(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int64_t v3 = *(_DWORD **)(a3 + 8);
  _DWORD *v3 = *(_DWORD *)(a1 + 12);
  int v4 = *(_DWORD *)(a1 + 16);
  uint64_t v5 = *(int *)(a1 + 12);
  if ((int)v5 + 1 >= v4)
  {
    v3[1] = v4;
    *(_DWORD *)a3 = 2;
    *(_DWORD *)a2 = 0;
    return 12;
  }
  int v6 = 0;
  uint64_t v7 = v5 + 1;
  double v8 = (float *)(*(void *)a1 + 4 * v5 + 8);
  int v9 = 1;
  do
  {
    float v11 = *(v8 - 2);
    float v10 = *(v8 - 1);
    if (v11 < v10 && v10 >= *v8)
    {
      int v13 = v9++;
      int v12 = v3;
      goto LABEL_9;
    }
    if (v11 > v10 && v10 <= *v8)
    {
      int v12 = *(_DWORD **)(a2 + 8);
      int v13 = v6++;
LABEL_9:
      v12[v13] = v7;
      int v4 = *(_DWORD *)(a1 + 16);
    }
    ++v7;
    ++v8;
  }
  while (v7 < v4);
  v3[v9] = v4;
  *(_DWORD *)a3 = v9 + 1;
  *(_DWORD *)a2 = v6;
  if (v6) {
    return 0;
  }
  return 12;
}

uint64_t sub_1DC37F104(uint64_t *a1, unsigned int *a2, int *a3, int a4, float a5, float a6)
{
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  BOOL v8 = (int)v6 < 2 || (int)v7 < 2;
  if (v8) {
    return 9;
  }
  int v13 = (int *)*((void *)a2 + 1);
  int v97 = (_DWORD *)*((void *)a3 + 1);
  uint64_t v14 = malloc_type_malloc(4 * v7, 0x100004052888210uLL);
  int v15 = malloc_type_malloc(4 * v6, 0x100004052888210uLL);
  if (a4 >= 0) {
    int v16 = a4;
  }
  else {
    int v16 = a4 + 1;
  }
  int v17 = v16 >> 1;
  if (v17 <= 1) {
    int v18 = 1;
  }
  else {
    int v18 = v17;
  }
  int v19 = (float *)malloc_type_malloc(4 * *((int *)a1 + 2), 0x100004052888210uLL);
  int v20 = (float *)malloc_type_malloc(4 * *((int *)a1 + 2), 0x100004052888210uLL);
  uint64_t v21 = *((unsigned int *)a1 + 2);
  if ((int)v21 >= 1)
  {
    uint64_t v22 = 0;
    int v23 = *((_DWORD *)a1 + 4);
    uint64_t v24 = *((int *)a1 + 3);
    uint64_t v25 = -v18;
    int v26 = -1;
    float v27 = INFINITY;
    float v28 = -INFINITY;
    int v29 = -1;
    do
    {
      if (v25 <= v24) {
        uint64_t v30 = v24;
      }
      else {
        uint64_t v30 = v25;
      }
      if ((int)v24 <= (int)v22 - v18) {
        int v31 = v22 - v18;
      }
      else {
        int v31 = v24;
      }
      int v32 = v18 + v22;
      if (v23 < v18 + (int)v22) {
        int v32 = v23;
      }
      if (v26 < v31 && v29 < v31)
      {
        if (v31 <= v32)
        {
          float v27 = INFINITY;
          float v28 = -INFINITY;
          do
          {
            uint64_t v34 = *a1;
            float v35 = *(float *)(*a1 + 4 * v30);
            if (v35 > v28)
            {
              float v28 = *(float *)(v34 + 4 * v30);
              int v26 = v30;
            }
            if (v35 < v27)
            {
              float v27 = *(float *)(v34 + 4 * v30);
              int v29 = v30;
            }
            BOOL v8 = v30++ < v32;
          }
          while (v8);
          goto LABEL_54;
        }
        float v28 = -INFINITY;
      }
      else
      {
        if (v26 >= v31)
        {
          if (*(float *)(*a1 + 4 * v32) > v28)
          {
            float v28 = *(float *)(*a1 + 4 * v32);
            int v26 = v32;
          }
        }
        else if (v31 <= v32)
        {
          float v28 = -INFINITY;
          uint64_t v36 = v30;
          do
          {
            if (*(float *)(*a1 + 4 * v36) > v28)
            {
              float v28 = *(float *)(*a1 + 4 * v36);
              int v26 = v36;
            }
            BOOL v8 = v36++ < v32;
          }
          while (v8);
        }
        else
        {
          float v28 = -INFINITY;
        }
        if (v29 >= v31)
        {
          if (*(float *)(*a1 + 4 * v32) < v27)
          {
            float v27 = *(float *)(*a1 + 4 * v32);
            int v29 = v32;
          }
          goto LABEL_54;
        }
        if (v31 <= v32)
        {
          float v27 = INFINITY;
          do
          {
            if (*(float *)(*a1 + 4 * v30) < v27)
            {
              float v27 = *(float *)(*a1 + 4 * v30);
              int v29 = v30;
            }
            BOOL v8 = v30++ < v32;
          }
          while (v8);
          goto LABEL_54;
        }
      }
      float v27 = INFINITY;
LABEL_54:
      v19[v22] = v27;
      v20[v22++] = v28;
      ++v25;
    }
    while (v22 != v21);
  }
  uint64_t v37 = (v7 - 1);
  uint64_t v38 = *a1;
  if ((int)v7 < 3)
  {
    int v39 = 0;
  }
  else
  {
    int v39 = 0;
    uint64_t v40 = v37 - 1;
    float v41 = v97 + 1;
    do
    {
      uint64_t v43 = *v41++;
      int v42 = v43;
      if (*(float *)(v38 + 4 * v43) > (float)((float)(1.0 - a5) * (float)(v19[v43] + v20[v43]))) {
        v14[v39++] = v42;
      }
      --v40;
    }
    while (v40);
  }
  int v44 = 0;
  do
  {
    uint64_t v46 = *v13++;
    int v45 = v46;
    if (*(float *)(v38 + 4 * v46) < (float)((float)(v19[v46] + v20[v46]) * a5)) {
      v15[v44++] = v45;
    }
    --v6;
  }
  while (v6);
  free(v19);
  free(v20);
  if (v39 < 2 || v44 < 2)
  {
    free(v14);
    free(v15);
    return 9;
  }
  if (*v14 <= *v15)
  {
    __int32 v48 = (int *)a2;
  }
  else
  {
    unint64_t v47 = v39;
    __int32 v48 = (int *)a2;
    do
    {
      BOOL v8 = v47 > 1;
      v14[v47] = v14[(v47 - 1)];
      --v47;
    }
    while (v8);
    _DWORD *v14 = *v97;
    ++v39;
  }
  if (v14[v39 - 1] < v15[v44 - 1]) {
    v14[v39++] = v97[v37];
  }
  int v50 = v39 + v44;
  uint64_t v51 = (unint64_t *)malloc_type_malloc(8 * (v39 + v44), 0x100004000313F17uLL);
  if (v39 + v44 >= 1)
  {
    int v52 = 0;
    int v53 = 0;
    uint64_t v54 = v50;
    int v55 = v51;
    while (1)
    {
      if (v52 >= v39 || v53 >= v44)
      {
        if (v53 == v44 && v52 < v39)
        {
          uint64_t v56 = v14[v52++];
          unint64_t v59 = 0x100000000;
          int v53 = v44;
        }
        else
        {
          if (v52 != v39 || v53 >= v44) {
            goto LABEL_95;
          }
          uint64_t v56 = v15[v53++];
          unint64_t v59 = 0xFFFFFFFF00000000;
          int v52 = v39;
        }
      }
      else
      {
        uint64_t v56 = v14[v52];
        int v57 = v15[v53];
        BOOL v58 = (int)v56 < v57;
        if ((int)v56 < v57)
        {
          unint64_t v59 = 0x100000000;
        }
        else
        {
          uint64_t v56 = v15[v53];
          unint64_t v59 = 0xFFFFFFFF00000000;
        }
        if (v58) {
          ++v52;
        }
        else {
          ++v53;
        }
      }
      unint64_t *v55 = v59 | v56;
LABEL_95:
      ++v55;
      if (!--v54)
      {
        int v60 = 0;
        int v61 = 0;
        int v62 = 0;
        uint64_t v63 = *((void *)v48 + 1);
        uint64_t v64 = *((void *)a3 + 1);
        uint64_t v65 = v50 - 1;
        int v66 = -1;
        int v67 = -1;
        while (1)
        {
          uint64_t v68 = v60 + 1;
          if (HIDWORD(v51[v60]) == 1)
          {
            if ((int)v68 < v50 && HIDWORD(v51[(int)v68]) == 1)
            {
              uint64_t v69 = v65 - (int)v68;
              int v70 = &v51[(int)v68];
              int v66 = v60;
              while (1)
              {
                if (*(float *)(*a1 + 4 * *(int *)v70) > *(float *)(*a1 + 4 * SLODWORD(v51[v66]))) {
                  int v66 = v60 + 1;
                }
                if (!v69) {
                  break;
                }
                int v71 = *((_DWORD *)v70 + 3);
                --v69;
                ++v70;
                ++v60;
                if (v71 != 1) {
                  goto LABEL_114;
                }
              }
              int v60 = v50 - 1;
              if (v67 < 0) {
                goto LABEL_127;
              }
            }
            else
            {
              int v66 = v60;
LABEL_114:
              if (v67 < 0)
              {
LABEL_127:
                LODWORD(v73) = v51[v66];
LABEL_128:
                int v74 = v62++;
                uint64_t v75 = v64;
LABEL_129:
                *(_DWORD *)(v75 + 4 * v74) = v73;
                goto LABEL_130;
              }
            }
            if (v61 <= 0) {
              goto LABEL_127;
            }
            uint64_t v73 = SLODWORD(v51[v66]);
            if (*(float *)(*a1 + 4 * v73) > (float)(*(float *)(*a1 + 4
                                                                    * *(int *)(v63 + 4 * (v61 - 1)))
                                                   + a6))
              goto LABEL_128;
            --v61;
          }
          else
          {
            if ((int)v68 < v50 && (CGAffineTransform v72 = &v51[v68], *((_DWORD *)v72 + 1) == -1))
            {
              uint64_t v76 = v65 - v68;
              int v67 = v60;
              while (1)
              {
                if (*(float *)(*a1 + 4 * *(int *)v72) < *(float *)(*a1 + 4 * SLODWORD(v51[v67]))) {
                  int v67 = v60 + 1;
                }
                if (!v76) {
                  break;
                }
                int v77 = *((_DWORD *)v72 + 3);
                --v76;
                ++v72;
                ++v60;
                if (v77 != -1) {
                  goto LABEL_109;
                }
              }
              int v60 = v50 - 1;
            }
            else
            {
              int v67 = v60;
            }
LABEL_109:
            if (v66 < 0 || v62 <= 0)
            {
              LODWORD(v73) = v51[v67];
LABEL_119:
              int v74 = v61++;
              uint64_t v75 = v63;
              goto LABEL_129;
            }
            uint64_t v73 = SLODWORD(v51[v67]);
            if (*(float *)(*a1 + 4 * v73) < (float)(*(float *)(*a1 + 4
                                                                    * *(int *)(v64 + 4 * (v62 - 1)))
                                                   - a6))
              goto LABEL_119;
            --v62;
          }
LABEL_130:
          if (++v60 >= v50)
          {
            *a3 = v62;
            *__int32 v48 = v61;
            goto LABEL_134;
          }
        }
      }
    }
  }
  int v61 = 0;
  int v62 = 0;
  int v78 = 0;
  int v79 = 0;
  *a3 = 0;
  *__int32 v48 = 0;
  if (v51)
  {
LABEL_134:
    free(v51);
    int v78 = v61;
    int v79 = v62;
  }
  free(v14);
  free(v15);
  uint64_t result = 9;
  if (v78 >= 1 && v79 == v78 + 1)
  {
    unint64_t v80 = (int *)*((void *)a3 + 1);
    if (*v48 < 2)
    {
      unsigned int v81 = 0;
    }
    else
    {
      unsigned int v81 = 0;
      uint64_t v82 = (*v48 - 1);
      uint64_t v83 = (int *)*((void *)v48 + 1);
      int v86 = *v83;
      CGRect v84 = v83 + 1;
      int v85 = v86;
      BOOL v87 = v80 + 1;
      int v88 = *v80;
      do
      {
        int v90 = *v84++;
        int v89 = v90;
        BOOL v8 = v85 < v90;
        int v92 = *v87++;
        int v91 = v92;
        if (!v8 || v88 >= v91 || v88 >= v85) {
          unsigned int v81 = 9;
        }
        int v88 = v91;
        int v85 = v89;
        --v82;
      }
      while (v82);
    }
    if (v80[*a3 - 2] >= v80[*a3 - 1]) {
      return 9;
    }
    else {
      return v81;
    }
  }
  return result;
}

uint64_t sub_1DC37F87C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(float **)(a5 + 8);
  uint64_t v7 = *(float **)(a6 + 8);
  int v8 = a2 - 1;
  if (a2 >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = a1 - 4;
    while (1)
    {
      uint64_t v11 = *(int *)(a4 + 4 * v9);
      uint64_t v12 = *(int *)(a3 + 4 * v9);
      float v13 = (float)(*(float *)(a1 + 4 * v11) + *(float *)(a1 + 4 * v12)) * 0.5;
      if ((int)v11 <= (int)v12) {
        int v14 = *(_DWORD *)(a3 + 4 * v9);
      }
      else {
        int v14 = *(_DWORD *)(a4 + 4 * v9);
      }
      uint64_t v15 = *(int *)(a4 + 4 * v9);
      do
      {
        if (v14 == v15) {
          goto LABEL_10;
        }
        uint64_t v16 = v15++;
      }
      while (*(float *)(a1 + 4 + 4 * v16) >= v13);
      int v14 = v16;
LABEL_10:
      if ((int)v12 >= (int)v11) {
        int v17 = *(_DWORD *)(a4 + 4 * v9);
      }
      else {
        int v17 = *(_DWORD *)(a3 + 4 * v9);
      }
      uint64_t v18 = *(int *)(a3 + 4 * v9);
      do
      {
        if (v18 <= v11) {
          goto LABEL_17;
        }
        uint64_t v19 = v18--;
      }
      while (*(float *)(v10 + 4 * v19) <= v13);
      int v17 = v19;
LABEL_17:
      if (v14 == v17)
      {
        float v20 = (float)v14;
      }
      else
      {
        uint64_t v21 = v14 + 1;
        if (v21 == v17)
        {
          float v22 = (float)v14;
          float v23 = *(float *)(a1 + 4 * v14);
          float v24 = v13 - v23;
          float v25 = *(float *)(a1 + 4 * v17);
        }
        else
        {
          float v26 = 0.0;
          float v27 = 0.0;
          if ((int)v21 < v17)
          {
            int v28 = ~v14 + v17;
            int v29 = (float *)(a1 + 4 * (int)v21);
            do
            {
              float v30 = *v29++;
              float v27 = v27 + v30;
              --v28;
            }
            while (v28);
          }
          if ((int)v11 <= v14)
          {
            int v31 = v14 - v11 + 1;
            int v32 = (float *)(a1 + 4 * v11);
            float v26 = 0.0;
            do
            {
              float v33 = *v32++;
              float v26 = v26 + v33;
              --v31;
            }
            while (v31);
          }
          if (v17 <= (int)v12)
          {
            int v34 = v12 + 1;
            int v36 = v34 - v17;
            uint64_t v37 = (float *)(a1 + 4 * v17);
            float v35 = 0.0;
            do
            {
              float v38 = *v37++;
              float v35 = v35 + v38;
              --v36;
            }
            while (v36);
          }
          else
          {
            int v34 = v12 + 1;
            float v35 = 0.0;
          }
          float v39 = v27 / (float)(v17 + ~v14);
          float v40 = (float)((float)(v26 / (float)(v21 - v11)) + (float)(v35 / (float)(v34 - v17))) * 0.5;
          if (v39 >= v40)
          {
            if (v39 <= v40) {
              float v20 = (float)((float)v14 + (float)v17) * 0.5;
            }
            else {
              float v20 = (float)((float)v17 + -1.0)
            }
                  + (float)((float)(v13 - *(float *)(a1 + 4 * v17 - 4))
                          / (float)(*(float *)(a1 + 4 * v17) - *(float *)(a1 + 4 * v17 - 4)));
            goto LABEL_34;
          }
          float v22 = (float)v14;
          float v23 = *(float *)(a1 + 4 * v14);
          float v24 = v13 - v23;
          float v25 = *(float *)(a1 + 4 * v21);
        }
        float v20 = (float)(v24 / (float)(v25 - v23)) + v22;
      }
LABEL_34:
      v6[v9++] = v20;
      if (v9 == a2)
      {
        uint64_t v41 = 0;
        while (1)
        {
          uint64_t v42 = v41;
          uint64_t v43 = *(int *)(a3 + 4 * v41++);
          uint64_t v44 = *(int *)(a4 + 4 * v41);
          float v45 = (float)(*(float *)(a1 + 4 * v44) + *(float *)(a1 + 4 * v43)) * 0.5;
          if ((int)v43 <= (int)v44) {
            int v46 = *(_DWORD *)(a4 + 4 * v41);
          }
          else {
            int v46 = v43;
          }
          uint64_t v47 = v43;
          while (v46 != v47)
          {
            uint64_t v48 = v47++;
            if (*(float *)(a1 + 4 + 4 * v48) > v45)
            {
              int v46 = v48;
              break;
            }
          }
          if ((int)v44 >= (int)v43) {
            int v49 = v43;
          }
          else {
            int v49 = *(_DWORD *)(a4 + 4 * v41);
          }
          uint64_t v50 = *(int *)(a4 + 4 * v41);
          while (v50 > v43)
          {
            uint64_t v51 = v50--;
            if (*(float *)(v10 + 4 * v51) < v45)
            {
              int v49 = v51;
              break;
            }
          }
          if (v46 == v49)
          {
            float v52 = (float)v46;
          }
          else
          {
            uint64_t v53 = v46 + 1;
            if (v53 == v49)
            {
              float v54 = (float)v46;
              float v55 = *(float *)(a1 + 4 * v46);
              float v56 = v45 - v55;
              float v57 = *(float *)(a1 + 4 * v49);
            }
            else
            {
              float v58 = 0.0;
              float v59 = 0.0;
              if ((int)v53 < v49)
              {
                int v60 = ~v46 + v49;
                int v61 = (float *)(a1 + 4 * (int)v53);
                do
                {
                  float v62 = *v61++;
                  float v59 = v59 + v62;
                  --v60;
                }
                while (v60);
              }
              if ((int)v43 <= v46)
              {
                int v63 = v46 - v43 + 1;
                uint64_t v64 = (float *)(a1 + 4 * v43);
                float v58 = 0.0;
                do
                {
                  float v65 = *v64++;
                  float v58 = v58 + v65;
                  --v63;
                }
                while (v63);
              }
              if (v49 <= (int)v44)
              {
                int v66 = v44 + 1;
                int v68 = v66 - v49;
                uint64_t v69 = (float *)(a1 + 4 * v49);
                float v67 = 0.0;
                do
                {
                  float v70 = *v69++;
                  float v67 = v67 + v70;
                  --v68;
                }
                while (v68);
              }
              else
              {
                int v66 = v44 + 1;
                float v67 = 0.0;
              }
              float v71 = v59 / (float)(v49 + ~v46);
              float v72 = (float)((float)(v58 / (float)(v53 - v43)) + (float)(v67 / (float)(v66 - v49))) * 0.5;
              if (v71 <= v72)
              {
                if (v71 < v72) {
                  float v52 = (float)((float)v49 + -1.0)
                }
                      + (float)((float)(v45 - *(float *)(a1 + 4 * v49 - 4))
                              / (float)(*(float *)(a1 + 4 * v49) - *(float *)(a1 + 4 * v49 - 4)));
                else {
                  float v52 = (float)((float)v46 + (float)v49) * 0.5;
                }
                goto LABEL_70;
              }
              float v54 = (float)v46;
              float v55 = *(float *)(a1 + 4 * v46);
              float v56 = v45 - v55;
              float v57 = *(float *)(a1 + 4 * v53);
            }
            float v52 = (float)(v56 / (float)(v57 - v55)) + v54;
          }
LABEL_70:
          v7[v42] = v52;
          if (v41 == a2)
          {
            *(_DWORD *)a5 = a2;
            *(_DWORD *)a6 = a2;
            if (a2 < 2)
            {
              unsigned int v73 = 0;
            }
            else
            {
              unsigned int v73 = 0;
              int v74 = v6 + 1;
              float v75 = *v6;
              uint64_t v76 = v7 + 1;
              float v77 = *v7;
              uint64_t v78 = (a2 - 1);
              do
              {
                float v79 = *v74++;
                float v80 = v79;
                BOOL v83 = v75 <= v79;
                float v81 = *v76++;
                float v82 = v81;
                BOOL v83 = v83 && v77 <= v82;
                if (!v83 || v77 < v75) {
                  unsigned int v73 = 10;
                }
                float v77 = v82;
                float v75 = v80;
                --v78;
              }
              while (v78);
            }
LABEL_91:
            if (v7[v8] >= v6[v8]) {
              return v73;
            }
            else {
              return 10;
            }
          }
        }
      }
    }
  }
  *(_DWORD *)a5 = 0;
  *(_DWORD *)a6 = 0;
  if (!a2)
  {
    unsigned int v73 = 0;
    int v8 = -1;
    goto LABEL_91;
  }
  return 10;
}

uint64_t sub_1DC37FD08(int a1, float *a2, int a3, float *a4, uint64_t a5)
{
  uint64_t v5 = a4;
  int v6 = a3;
  uint64_t v7 = a2;
  int v8 = a1;
  uint64_t v9 = **(void **)(a5 + 96);
  if (!v9) {
    operator new();
  }
  if (*(unsigned char *)(a5 + 88))
  {
    *(unsigned char *)(a5 + 88) = 0;
    int v8 = a3;
    uint64_t v7 = a4;
    int v6 = a1 - 1;
    uint64_t v5 = a2 + 1;
  }
  uint64_t v10 = (v6 + v8 - 1);
  sub_1DC320A5C(&__p, (int)v10);
  if ((int)v10 >= 1)
  {
    uint64_t v11 = 0;
    int v12 = 0;
    int v13 = 0;
    int v14 = (float *)__p;
    do
    {
      uint64_t v15 = &v5[v12];
      if (v11) {
        int v16 = v12;
      }
      else {
        int v16 = v13;
      }
      if (v11) {
        int v17 = v5;
      }
      else {
        int v17 = v7;
      }
      if (v11) {
        uint64_t v15 = &v7[v13];
      }
      else {
        ++v13;
      }
      if (v11) {
        ++v12;
      }
      v14[v11++] = *v15 - v17[v16];
    }
    while (v10 != v11);
  }
  uint64_t v19 = (float *)__p;
  unint64_t v18 = (unint64_t)v169;
  int v165 = 14;
  uint64_t v166 = __p;
  uint64_t v167 = v169;
  if (!__p) {
    goto LABEL_21;
  }
  float v20 = (char *)__p + 4;
  uint64_t v164 = (char *)__p + 4;
  if (v169 - (unsigned char *)__p < 60) {
    goto LABEL_21;
  }
  unsigned int v23 = 0;
  float v24 = (float *)((char *)__p + 56);
  uint64_t v159 = 0xFFFFFFFFLL;
  int v25 = 1;
  uint64_t v161 = 0xFFFFFFFFLL;
  uint64_t v157 = v7;
  do
  {
    if (sub_1DC380D4C(v19 + 9, 5))
    {
      float v26 = 0.0;
      for (uint64_t i = 9; i != 14; ++i)
        float v26 = v26 + v19[i];
      uint64_t v28 = 0;
      float v29 = 0.0;
      do
      {
        float v29 = v29 + *(float *)&v20[v28];
        v28 += 4;
      }
      while (v28 != 32);
      if (fabsf((float)((float)(v29 / 17.0) / (float)(v26 / 15.0)) + -1.0) < 0.1)
      {
        sub_1DC380E08((uint64_t)&v170, (uint64_t)&v164, 1);
        uint64_t v159 = (uint64_t)v170;
        uint64_t v161 = (uint64_t)v171;
        unsigned int v23 = v172;
        int v25 = HIDWORD(v172);
        uint64_t v175 = v173;
        int v176 = v174;
        if (v172)
        {
          if (v172 != 1) {
            goto LABEL_57;
          }
          float v30 = v19[12];
          if ((float)((float)(v30 * 0.75) + -2.0) < *v19 && (float)((float)(v30 * 1.25) + 2.0) > *v19) {
            goto LABEL_55;
          }
          unsigned int v23 = 1;
        }
      }
    }
    uint64_t v164 = (char *)(v19 + 2);
    if ((unint64_t)(v19 + 16) > v18) {
      goto LABEL_53;
    }
    sub_1DC320A5C(v177, 5uLL);
    uint64_t v31 = 0;
    int v32 = (float *)v177[0].__r_.__value_.__r.__words[0];
    float v33 = v24;
    do
    {
      float v34 = *v33--;
      v32[v31++] = v34;
    }
    while (v31 != 5);
    if (!sub_1DC380D4C(v32, (v177[0].__r_.__value_.__l.__size_ - (unint64_t)v32) >> 2)) {
      goto LABEL_48;
    }
    float v35 = 0.0;
    for (uint64_t j = 10; j != 15; ++j)
      float v35 = v35 + v19[j];
    float v37 = 0.0;
    for (uint64_t k = 2; k != 10; ++k)
      float v37 = v37 + v19[k];
    if (fabsf((float)((float)(v37 / 17.0) / (float)(v35 / 15.0)) + -1.0) >= 0.1)
    {
LABEL_48:
      int v39 = 0;
      if (!v32) {
        goto LABEL_50;
      }
LABEL_49:
      v177[0].__r_.__value_.__l.__size_ = (std::string::size_type)v32;
      operator delete(v32);
      goto LABEL_50;
    }
    int v39 = 1;
    if (v32) {
      goto LABEL_49;
    }
LABEL_50:
    if (v39)
    {
      sub_1DC380E08((uint64_t)&v170, (uint64_t)&v164, 0);
      uint64_t v159 = (uint64_t)v170;
      uint64_t v161 = (uint64_t)v171;
      int v25 = HIDWORD(v172);
      uint64_t v175 = v173;
      int v176 = v174;
      if (v172)
      {
        float v20 = (char *)(v19 + 2);
        unsigned int v23 = v172;
        goto LABEL_57;
      }
      unsigned int v23 = 0;
    }
LABEL_53:
    v20 += 8;
    uint64_t v164 = v20;
    float v40 = v19 + 17;
    v24 += 2;
    v19 += 2;
  }
  while ((unint64_t)v40 <= v18);
  if (!v23)
  {
LABEL_21:
    uint64_t v21 = 14;
    goto LABEL_22;
  }
LABEL_55:
  unsigned int v23 = 1;
LABEL_57:
  unint64_t v41 = 0;
  unint64_t v42 = 0;
  unint64_t v43 = 0;
  while (1)
  {
    if (v42 >= v43)
    {
      unint64_t v45 = 0x8E38E38E38E38E39 * ((uint64_t)(v42 - v41) >> 2) + 1;
      if (v45 > 0x71C71C71C71C71CLL) {
        sub_1DC2FF97C();
      }
      if (0x1C71C71C71C71C72 * ((uint64_t)(v43 - v41) >> 2) > v45) {
        unint64_t v45 = 0x1C71C71C71C71C72 * ((uint64_t)(v43 - v41) >> 2);
      }
      if (0x8E38E38E38E38E39 * ((uint64_t)(v43 - v41) >> 2) >= 0x38E38E38E38E38ELL) {
        unint64_t v46 = 0x71C71C71C71C71CLL;
      }
      else {
        unint64_t v46 = v45;
      }
      if (v46) {
        unint64_t v46 = (unint64_t)sub_1DC381124(v46);
      }
      else {
        uint64_t v47 = 0;
      }
      unint64_t v48 = v46 + 4 * ((uint64_t)(v42 - v41) >> 2);
      *(void *)&long long v49 = v159;
      *((void *)&v49 + 1) = v161;
      *(_OWORD *)unint64_t v48 = v49;
      *(_DWORD *)(v48 + 16) = v23;
      *(_DWORD *)(v48 + 20) = v25;
      *(void *)(v48 + 24) = v175;
      *(_DWORD *)(v48 + 32) = v176;
      if (v42 == v41)
      {
        unint64_t v53 = v46 + 4 * ((uint64_t)(v42 - v41) >> 2);
      }
      else
      {
        unint64_t v50 = v46 + 4 * ((uint64_t)(v42 - v41) >> 2);
        do
        {
          long long v51 = *(_OWORD *)(v42 - 36);
          long long v52 = *(_OWORD *)(v42 - 20);
          unint64_t v53 = v50 - 36;
          *(_DWORD *)(v50 - 4) = *(_DWORD *)(v42 - 4);
          *(_OWORD *)(v50 - 20) = v52;
          *(_OWORD *)(v50 - 36) = v51;
          v42 -= 36;
          v50 -= 36;
        }
        while (v42 != v41);
      }
      unint64_t v43 = v46 + 36 * v47;
      unint64_t v42 = v48 + 36;
      if (v41) {
        operator delete((void *)v41);
      }
      unint64_t v41 = v53;
      int v44 = v161;
    }
    else
    {
      int v44 = v161;
      *(void *)unint64_t v42 = v159;
      *(void *)(v42 + 8) = v161;
      *(_DWORD *)(v42 + 16) = v23;
      *(_DWORD *)(v42 + 20) = v25;
      *(void *)(v42 + 24) = v175;
      *(_DWORD *)(v42 + 32) = v176;
      v42 += 36;
    }
    if (v44 == -1) {
      break;
    }
    uint64_t v164 = v20 + 84;
    if ((unint64_t)(v20 + 140) > v18) {
      break;
    }
    sub_1DC380E08((uint64_t)&v170, (uint64_t)&v164, v23 >> 31);
    uint64_t v159 = (uint64_t)v170;
    unsigned int v23 = v172;
    int v25 = HIDWORD(v172);
    uint64_t v175 = v173;
    int v176 = v174;
    if (!v172) {
      break;
    }
    uint64_t v161 = (uint64_t)v171;
    if (v171 == -1)
    {
      uint64_t v54 = 44;
      if ((v172 & 0x80000000) != 0) {
        uint64_t v54 = 36;
      }
      float v55 = *(float *)&v20[v54 + 84];
      float v56 = *((float *)v20 + 34);
      float v57 = (float)(v56 * 0.75) + -2.0;
      float v58 = (float)(v56 * 1.25) + 2.0;
      BOOL v59 = v57 >= v55 || v58 <= v55;
      v20 += 84;
      if (v59) {
        break;
      }
    }
    else
    {
      v20 += 84;
    }
  }
  uint64_t v21 = 14;
  if (v41 == v42) {
    goto LABEL_197;
  }
  char v162 = 0;
  unint64_t v60 = 0x8E38E38E38E38E39 * ((uint64_t)(v42 - v41) >> 2);
  if (v60 > 1) {
    int v61 = 1;
  }
  else {
    int v61 = 14;
  }
  unsigned int v160 = v61;
  *(float *)(a5 + 24) = fminf((float)v60 * 0.5, 1.0);
  float v62 = (void *)(v9 + 16);
  int v63 = (_DWORD *)v41;
  while (2)
  {
    unint64_t v64 = (int)v63[4];
    unint64_t v65 = *(void *)(v9 + 8);
    if (v65)
    {
      uint8x8_t v66 = (uint8x8_t)vcnt_s8((int8x8_t)v65);
      v66.i16[0] = vaddlv_u8(v66);
      if (v66.u32[0] > 1uLL)
      {
        unint64_t v43 = (int)v63[4];
        if (v65 <= v64) {
          unint64_t v43 = v64 % v65;
        }
      }
      else
      {
        unint64_t v43 = (v65 - 1) & v64;
      }
      float v67 = *(void ***)(*(void *)v9 + 8 * v43);
      if (v67)
      {
        int v68 = *v67;
        if (*v67)
        {
          do
          {
            unint64_t v69 = v68[1];
            if (v69 == v64)
            {
              if (*((_DWORD *)v68 + 4) == v64) {
                goto LABEL_132;
              }
            }
            else
            {
              if (v66.u32[0] > 1uLL)
              {
                if (v69 >= v65) {
                  v69 %= v65;
                }
              }
              else
              {
                v69 &= v65 - 1;
              }
              if (v69 != v43) {
                break;
              }
            }
            int v68 = (void *)*v68;
          }
          while (v68);
        }
      }
    }
    int v68 = operator new(0x30uLL);
    *int v68 = 0;
    v68[1] = v64;
    *((_DWORD *)v68 + 4) = v63[4];
    v68[4] = 0;
    v68[5] = 0;
    v68[3] = 0;
    float v70 = (float)(unint64_t)(*(void *)(v9 + 24) + 1);
    float v71 = *(float *)(v9 + 32);
    if (!v65 || (float)(v71 * (float)v65) < v70)
    {
      BOOL v72 = (v65 & (v65 - 1)) != 0;
      if (v65 < 3) {
        BOOL v72 = 1;
      }
      unint64_t v73 = v72 | (2 * v65);
      unint64_t v74 = vcvtps_u32_f32(v70 / v71);
      if (v73 <= v74) {
        size_t v75 = v74;
      }
      else {
        size_t v75 = v73;
      }
      sub_1DC381634(v9, v75);
      unint64_t v65 = *(void *)(v9 + 8);
      if ((v65 & (v65 - 1)) != 0)
      {
        if (v65 <= v64) {
          unint64_t v43 = v64 % v65;
        }
        else {
          unint64_t v43 = v64;
        }
      }
      else
      {
        unint64_t v43 = (v65 - 1) & v64;
      }
    }
    uint64_t v76 = *(void *)v9;
    float v77 = *(void **)(*(void *)v9 + 8 * v43);
    if (v77)
    {
      *int v68 = *v77;
      goto LABEL_130;
    }
    *int v68 = *v62;
    void *v62 = v68;
    *(void *)(v76 + 8 * v43) = v62;
    if (*v68)
    {
      unint64_t v78 = *(void *)(*v68 + 8);
      if ((v65 & (v65 - 1)) != 0)
      {
        if (v78 >= v65) {
          v78 %= v65;
        }
      }
      else
      {
        v78 &= v65 - 1;
      }
      float v77 = (void *)(*(void *)v9 + 8 * v78);
LABEL_130:
      *float v77 = v68;
    }
    ++*(void *)(v9 + 24);
LABEL_132:
    uint64_t v79 = v68[3];
    unint64_t v43 = v68[4];
    if (v79 == v43)
    {
      unint64_t v43 = v68[3];
      unint64_t v80 = v43;
    }
    else
    {
      unint64_t v80 = v68[3];
      while (!sub_1DC381170((_DWORD *)v80, v63))
      {
        v80 += 36;
        if (v80 == v43)
        {
          unint64_t v80 = v43;
          break;
        }
      }
    }
    if (v80 == v43)
    {
      unint64_t v89 = v68[5];
      if (v43 >= v89)
      {
        unint64_t v93 = 0x8E38E38E38E38E39 * ((uint64_t)(v43 - v79) >> 2) + 1;
        if (v93 > 0x71C71C71C71C71CLL) {
          sub_1DC2FF97C();
        }
        unint64_t v94 = 0x8E38E38E38E38E39 * ((uint64_t)(v89 - v79) >> 2);
        if (2 * v94 > v93) {
          unint64_t v93 = 2 * v94;
        }
        if (v94 >= 0x38E38E38E38E38ELL) {
          unint64_t v95 = 0x71C71C71C71C71CLL;
        }
        else {
          unint64_t v95 = v93;
        }
        if (v95) {
          unint64_t v95 = (unint64_t)sub_1DC381124(v95);
        }
        else {
          uint64_t v96 = 0;
        }
        unint64_t v97 = v95 + 4 * ((uint64_t)(v43 - v79) >> 2);
        long long v98 = *(_OWORD *)v63;
        long long v99 = *((_OWORD *)v63 + 1);
        *(_DWORD *)(v97 + 32) = v63[8];
        *(_OWORD *)unint64_t v97 = v98;
        *(_OWORD *)(v97 + 16) = v99;
        float v101 = (char *)v68[3];
        int v100 = (char *)v68[4];
        unint64_t v102 = v97;
        if (v100 != v101)
        {
          do
          {
            long long v103 = *(_OWORD *)(v100 - 36);
            long long v104 = *(_OWORD *)(v100 - 20);
            *(_DWORD *)(v102 - 4) = *((_DWORD *)v100 - 1);
            *(_OWORD *)(v102 - 20) = v104;
            *(_OWORD *)(v102 - 36) = v103;
            v102 -= 36;
            v100 -= 36;
          }
          while (v100 != v101);
          int v100 = (char *)v68[3];
        }
        unint64_t v92 = v97 + 36;
        v68[3] = v102;
        v68[4] = v97 + 36;
        v68[5] = v95 + 36 * v96;
        if (v100) {
          operator delete(v100);
        }
      }
      else
      {
        long long v90 = *(_OWORD *)v63;
        long long v91 = *((_OWORD *)v63 + 1);
        *(_DWORD *)(v43 + 32) = v63[8];
        *(_OWORD *)unint64_t v43 = v90;
        *(_OWORD *)(v43 + 16) = v91;
        unint64_t v92 = v43 + 36;
      }
      v68[4] = v92;
LABEL_161:
      char v162 = 1;
    }
    else
    {
      uint64_t v81 = v79 + 4 * ((uint64_t)(v80 - v79) >> 2);
      int v82 = *(_DWORD *)(v81 + 20);
      *(_DWORD *)(v81 + 20) = v82 + 1;
      if (v80 != v79 && v82 >= *(_DWORD *)(v80 - 16))
      {
        do
        {
          int v83 = *(_DWORD *)(v80 - 4);
          long long v84 = *(_OWORD *)(v80 - 36);
          long long v85 = *(_OWORD *)(v80 + 16);
          *(_OWORD *)(v80 - 36) = *(_OWORD *)v80;
          long long v86 = *(_OWORD *)(v80 - 20);
          *(_OWORD *)(v80 - 20) = v85;
          *(_DWORD *)(v80 - 4) = *(_DWORD *)(v80 + 32);
          *(_OWORD *)unint64_t v80 = v84;
          *(_OWORD *)(v80 + 16) = v86;
          *(_DWORD *)(v80 + 32) = v83;
          if (v80 - 36 == v68[3]) {
            break;
          }
          int v87 = *(_DWORD *)(v80 - 16);
          int v88 = *(_DWORD *)(v80 - 52);
          v80 -= 36;
        }
        while (v87 > v88);
        goto LABEL_161;
      }
    }
    v63 += 9;
    if (v63 != (_DWORD *)v42) {
      continue;
    }
    break;
  }
  if ((v162 & 1) == 0) {
    goto LABEL_196;
  }
  uint64_t v21 = v160;
  if (*(_DWORD *)(v41 + 16) == 1)
  {
    uint64_t v105 = *(void *)(a5 + 64);
    if (!*(unsigned char *)(v105 + 31))
    {
      *(unsigned char *)(v105 + 31) = 1;
      float v106 = *(float *)(v41 + 32);
      *(float *)(a5 + 72) = v106;
      float v107 = *(float *)(v42 - 4);
      *(float *)(a5 + 76) = v107;
      *(float *)(v105 + 48) = (float)(*v157 + *(float *)(v41 + 24)) - v106;
      *(float *)(v105 + 52) = v107 + (float)(*v157 + *(float *)(v42 - 8));
    }
  }
  std::string::size_type v108 = sub_1DC3811CC((void *)v9, 1);
  if (!v108) {
    goto LABEL_198;
  }
  long long v170 = 0;
  uint64_t v171 = 0;
  unint64_t v172 = 0;
  uint64_t v109 = v108[3];
  uint64_t v110 = v108[4];
  if (v109 == v110)
  {
LABEL_196:
    uint64_t v21 = v160;
    goto LABEL_197;
  }
  unint64_t v111 = 0;
  while (2)
  {
    int v112 = *(_DWORD *)v109 / 211;
    int v113 = v112 + 5;
    BOOL v59 = v112 < -5;
    int v114 = v112 + 6;
    if (!v59) {
      int v114 = v113;
    }
    int v115 = v114 >> 1;
    if (*(void *)(v9 + 24) < (unint64_t)(v114 >> 1))
    {
LABEL_193:
      v109 += 36;
      if (v109 == v110)
      {
        if (v170) {
          operator delete(v170);
        }
        goto LABEL_196;
      }
      continue;
    }
    break;
  }
  if ((unint64_t)v111 >= v172)
  {
    uint32_t v119 = (char *)v170;
    unint64_t v120 = 0x8E38E38E38E38E39 * ((v111 - (unsigned char *)v170) >> 2);
    unint64_t v121 = v120 + 1;
    if (v120 + 1 > 0x71C71C71C71C71CLL) {
      sub_1DC2FF97C();
    }
    if (0x1C71C71C71C71C72 * ((uint64_t)(v172 - (void)v170) >> 2) > v121) {
      unint64_t v121 = 0x1C71C71C71C71C72 * ((uint64_t)(v172 - (void)v170) >> 2);
    }
    if (0x8E38E38E38E38E39 * ((uint64_t)(v172 - (void)v170) >> 2) >= 0x38E38E38E38E38ELL) {
      unint64_t v122 = 0x71C71C71C71C71CLL;
    }
    else {
      unint64_t v122 = v121;
    }
    if (v122) {
      unint64_t v122 = (unint64_t)sub_1DC381124(v122);
    }
    else {
      uint64_t v123 = 0;
    }
    unint64_t v124 = v122 + 36 * v120;
    long long v125 = *(_OWORD *)v109;
    long long v126 = *(_OWORD *)(v109 + 16);
    *(_DWORD *)(v124 + 32) = *(_DWORD *)(v109 + 32);
    *(_OWORD *)unint64_t v124 = v125;
    *(_OWORD *)(v124 + 16) = v126;
    if (v111 == v119)
    {
      uint64_t v130 = (void *)(v122 + 36 * v120);
    }
    else
    {
      unint64_t v127 = v122 + 36 * v120;
      do
      {
        long long v128 = *(_OWORD *)(v111 - 36);
        long long v129 = *(_OWORD *)(v111 - 20);
        uint64_t v130 = (void *)(v127 - 36);
        *(_DWORD *)(v127 - 4) = *((_DWORD *)v111 - 1);
        *(_OWORD *)(v127 - 20) = v129;
        *(_OWORD *)(v127 - 36) = v128;
        v111 -= 36;
        v127 -= 36;
      }
      while (v111 != v119);
    }
    BOOL v118 = (unsigned int *)(v124 + 36);
    long long v170 = v130;
    unint64_t v172 = v122 + 36 * v123;
    if (v119) {
      operator delete(v119);
    }
  }
  else
  {
    long long v116 = *(_OWORD *)v109;
    long long v117 = *(_OWORD *)(v109 + 16);
    *((_DWORD *)v111 + 8) = *(_DWORD *)(v109 + 32);
    *(_OWORD *)unint64_t v111 = v116;
    *((_OWORD *)v111 + 1) = v117;
    BOOL v118 = (unsigned int *)(v111 + 36);
  }
  uint64_t v171 = v118;
  if ((sub_1DC381280((void *)v9, (int *)*(&off_1E6C3A828 + 2 * v115 - 4) + 1, (int *)*(&off_1E6C3A828 + 2 * v115 - 4) + (void)*(&off_1E6C3A828 + 2 * v115 - 3), (unint64_t *)&v170) & 1) == 0)
  {
    unint64_t v111 = (char *)(v171 - 9);
    v171 -= 9;
    goto LABEL_193;
  }
  double v132 = (unsigned int *)v170;
  int v131 = v171;
  if (v170 == v171)
  {
    uint64_t v21 = v160;
    goto LABEL_255;
  }
  long long v170 = 0;
  uint64_t v171 = 0;
  unint64_t v172 = 0;
  sub_1DC381520((unint64_t *)&v170, v132[2]);
  for (uint64_t m = v132 + 9; m != v131; m += 9)
  {
    sub_1DC381520((unint64_t *)&v170, *m);
    unsigned int v134 = m[2];
    if (v134 != -1) {
      sub_1DC381520((unint64_t *)&v170, v134);
    }
  }
  sub_1DC350DD0(v177, (uint64_t *)&v170);
  std::string::size_type size = HIBYTE(v177[0].__r_.__value_.__r.__words[2]);
  char v136 = HIBYTE(v177[0].__r_.__value_.__r.__words[2]);
  if ((v177[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v177[0].__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    uint64_t v21 = v160;
    goto LABEL_251;
  }
  uint64_t v163 = v132;
  uint64_t v137 = v132;
  while (2)
  {
    int8x8_t v138 = *(int8x8_t *)(v9 + 8);
    if (!*(void *)&v138) {
      goto LABEL_225;
    }
    unint64_t v139 = (int)v137[4];
    uint8x8_t v140 = (uint8x8_t)vcnt_s8(v138);
    v140.i16[0] = vaddlv_u8(v140);
    if (v140.u32[0] > 1uLL)
    {
      unint64_t v141 = (int)v137[4];
      if (*(void *)&v138 <= v139) {
        unint64_t v141 = v139 % *(void *)&v138;
      }
    }
    else
    {
      unint64_t v141 = (*(void *)&v138 - 1) & v139;
    }
    float v142 = *(uint64_t ***)(*(void *)v9 + 8 * v141);
    if (!v142) {
      goto LABEL_225;
    }
    uint64_t v143 = *v142;
    if (!*v142) {
      goto LABEL_225;
    }
    while (2)
    {
      unint64_t v144 = v143[1];
      if (v144 != v139)
      {
        if (v140.u32[0] > 1uLL)
        {
          if (v144 >= *(void *)&v138) {
            v144 %= *(void *)&v138;
          }
        }
        else
        {
          v144 &= *(void *)&v138 - 1;
        }
        if (v144 != v141) {
          goto LABEL_225;
        }
        goto LABEL_224;
      }
      if (*((_DWORD *)v143 + 4) != v139)
      {
LABEL_224:
        uint64_t v143 = (uint64_t *)*v143;
        if (!v143) {
          goto LABEL_225;
        }
        continue;
      }
      break;
    }
    uint64_t v146 = (_DWORD *)v143[3];
    char v145 = (_DWORD *)v143[4];
    if (v146 == v145)
    {
      char v145 = (_DWORD *)v143[3];
      long long v147 = v145;
    }
    else
    {
      long long v147 = (_DWORD *)v143[3];
      while (!sub_1DC381170(v147, v137))
      {
        v147 += 9;
        if (v147 == v145)
        {
          long long v147 = v145;
          break;
        }
      }
    }
    if (v147 != v145)
    {
      uint64_t v148 = &v146[v147 - v146];
      int v149 = v148[5] - 1;
      v148[5] = v149;
      if (!v149)
      {
        if (v145 != v147 + 9) {
          memmove(v147, v147 + 9, (char *)v145 - (char *)(v147 + 9));
        }
        v143[4] = (uint64_t)(v145 - 9);
      }
    }
LABEL_225:
    v137 += 9;
    if (v137 != v131) {
      continue;
    }
    break;
  }
  if (v171 == v170) {
    sub_1DC351420();
  }
  double v132 = v163;
  if (*(unsigned char *)v170) {
    *(_DWORD *)(a5 + 4) = 4;
  }
  std::string::size_type v150 = HIBYTE(v177[0].__r_.__value_.__r.__words[2]);
  if ((v177[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v150 = v177[0].__r_.__value_.__l.__size_;
  }
  *(void *)(a5 + 8) = v150;
  float64x2_t v151 = (char *)malloc_type_malloc(v150 + 1, 0xEADD3F3FuLL);
  *(void *)(a5 + 16) = v151;
  std::string::size_type v152 = HIBYTE(v177[0].__r_.__value_.__r.__words[2]);
  if ((v177[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v153 = v177;
  }
  else {
    uint64_t v153 = (std::string *)v177[0].__r_.__value_.__r.__words[0];
  }
  if ((v177[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v152 = v177[0].__r_.__value_.__l.__size_;
  }
  strlcpy(v151, (const char *)v153, v152 + 1);
  uint64_t v21 = 0;
  *(_DWORD *)(a5 + 24) = 1065353216;
  float v154 = *(float *)(v41 + 32);
  *(float *)(a5 + 72) = v154;
  float v155 = *(float *)(v42 - 4);
  *(float *)(a5 + 76) = v155;
  uint64_t v156 = *(void *)(a5 + 64);
  *(float *)(v156 + 48) = (float)(*v157 + *(float *)(v41 + 24)) - v154;
  *(float *)(v156 + 52) = v155 + (float)(*v157 + *(float *)(v42 - 8));
  char v136 = HIBYTE(v177[0].__r_.__value_.__r.__words[2]);
LABEL_251:
  if (v136 < 0) {
    operator delete(v177[0].__r_.__value_.__l.__data_);
  }
  if (v170) {
    operator delete(v170);
  }
LABEL_255:
  if (v132) {
    operator delete(v132);
  }
LABEL_197:
  if (v41) {
LABEL_198:
  }
    operator delete((void *)v41);
LABEL_22:
  if (__p)
  {
    uint64_t v169 = __p;
    operator delete(__p);
  }
  return v21;
}

void sub_1DC380C90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (__p) {
    operator delete(__p);
  }
  if (v38) {
    operator delete(v38);
  }
  if (v37) {
    operator delete(v37);
  }
  if (a22) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1DC380D4C(float *a1, int a2)
{
  float v2 = 0.0;
  float v3 = 0.0;
  if (a2)
  {
    uint64_t v4 = 4 * a2;
    uint64_t v5 = a1;
    do
    {
      float v6 = *v5++;
      float v3 = v3 + v6;
      v4 -= 4;
    }
    while (v4);
  }
  uint64_t v7 = 0;
  float v8 = v3 / 15.0;
  if (v8 < 4.0) {
    float v2 = 0.5;
  }
  float v9 = v2 + (float)(v8 * 0.5);
  uint64_t v10 = (float *)&unk_1DC40C78C;
  do
  {
    float v11 = a1[v7];
    if ((float)((float)(v8 * *(v10 - 1)) - v9) > v11 || (float)(v9 + (float)(v8 * *v10)) < v11) {
      return 0;
    }
    v10 += 2;
    ++v7;
  }
  while (v7 != 5);
  float v13 = a1[1] + a1[2];
  return (float)((float)(v8 * 12.0) + v9) >= v13 && (float)((float)(v8 * 10.0) - v9) <= v13;
}

float *sub_1DC380E08(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = *(float **)a2;
  float v6 = 0.0;
  for (uint64_t i = 8; i != 13; ++i)
    float v6 = v6 + result[i];
  if (v6 >= 15.0)
  {
    uint64_t v9 = 0;
    float v10 = v6 / 15.0;
    float v11 = v6 * 0.2;
    int v12 = -1;
    float v13 = v11;
    do
    {
      uint64_t v14 = 0;
      float v15 = 0.0;
      int v16 = 4;
      while (1)
      {
        unsigned int v17 = a3 ? v14 : v16;
        float v18 = fabsf(result[v14 + 8] - (float)((float)dword_1DC40C7B0[5 * v9 + v17] * v10));
        if (v18 > (float)(v10 * 0.45)) {
          break;
        }
        float v15 = v15 + v18;
        ++v14;
        --v16;
        if (v14 == 5) {
          goto LABEL_14;
        }
      }
      float v15 = v11;
LABEL_14:
      if (v15 < v13)
      {
        int v12 = v9;
        float v13 = v15;
      }
      ++v9;
    }
    while (v9 != 6);
    if (a3) {
      int v8 = v12 + 1;
    }
    else {
      int v8 = ~v12;
    }
    if (!v8) {
      goto LABEL_40;
    }
  }
  else
  {
    int v8 = -1;
  }
  uint64_t result = (float *)sub_1DC381890(result, 8, v8, 0);
  uint64_t v19 = result;
  if (result == -1) {
    goto LABEL_40;
  }
  if (v8 == 1)
  {
    int v20 = (int)result / 211 + 6;
    if ((int)result / 211 >= -5) {
      int v20 = (int)result / 211 + 5;
    }
    if ((int)result < -421 || ((v20 >> 1) - 2) > 9) {
      goto LABEL_40;
    }
  }
  uint64_t v21 = 0;
  float v22 = *(float **)a2;
  float v23 = 0.0;
  do
  {
    float v23 = v23 + *(float *)(*(void *)a2 + 32 + v21);
    v21 += 4;
  }
  while (v21 != 20);
  LODWORD(v24) = 0;
  int v25 = v22 + 13;
  float v26 = v23 / 15.0;
  if (*(void *)(a2 + 16) <= (unint64_t)(v22 + 13) && (unint64_t)(v22 + 21) <= *(void *)(a2 + 24))
  {
    uint64_t v27 = 0;
    uint64_t v28 = v22 + 13;
    float v29 = 0.0;
    do
      float v29 = v29 + v28[v27++];
    while (v27 != 8);
    if (fabsf((float)((float)(v29 / 17.0) / v26) + -1.0) >= 0.1)
    {
      LODWORD(v24) = 0;
    }
    else
    {
      int v30 = 1;
      unint64_t v31 = sub_1DC381890(v25, 8, v8, 1);
      unint64_t v24 = HIDWORD(v31);
      if (v31 != -1) {
        goto LABEL_43;
      }
    }
  }
  uint64_t result = (float *)wmemchr(dword_1DC40CC2C, v8, 7uLL);
  int v32 = (float *)&dword_1DC40CC2C[7];
  if (result) {
    int v32 = result;
  }
  if ((char *)v32 - (char *)dword_1DC40CC2C == 28)
  {
LABEL_40:
    *(void *)&long long v33 = 0xFFFFFFFFLL;
    *((void *)&v33 + 1) = 0xFFFFFFFFLL;
    *(_OWORD *)a1 = v33;
    *(void *)(a1 + 16) = 0x100000000;
    *(void *)(a1 + 24) = 0;
    float v26 = 0.0;
    goto LABEL_41;
  }
  int v30 = 0;
  LODWORD(v31) = -1;
LABEL_43:
  uint64_t result = (float *)(v31 | ((unint64_t)v24 << 32));
  *(void *)a1 = v19;
  *(void *)(a1 + 8) = result;
  *(_DWORD *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 20) = 1;
  float v34 = *(float **)(a2 + 16);
  float v35 = *(float **)a2;
  float v36 = 0.0;
  float v37 = 0.0;
  if (v34 != *(float **)a2)
  {
    float v38 = *(float **)(a2 + 16);
    do
    {
      float v39 = *v38++;
      float v37 = v37 + v39;
    }
    while (v38 != v35);
  }
  *(float *)(a1 + 24) = v37;
  uint64_t v40 = 5;
  uint64_t v41 = 8;
  if (v30)
  {
    uint64_t v40 = 8;
    uint64_t v41 = 13;
  }
  unint64_t v42 = &v35[v41 + v40];
  if (v34 != v42)
  {
    float v36 = 0.0;
    do
    {
      float v43 = *v34++;
      float v36 = v36 + v43;
    }
    while (v34 != v42);
  }
  *(float *)(a1 + 28) = v36;
LABEL_41:
  *(float *)(a1 + 32) = v26;
  return result;
}

void *sub_1DC381124(unint64_t a1)
{
  if (a1 >= 0x71C71C71C71C71DLL) {
    sub_1DC2FF994();
  }
  return operator new(36 * a1);
}

BOOL sub_1DC381170(_DWORD *a1, _DWORD *a2)
{
  return a1[4] == a2[4] && *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3];
}

uint64_t *sub_1DC3811CC(void *a1, int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  uint64_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (uint64_t result = *v5; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t *sub_1DC381280(void *a1, int *a2, int *a3, unint64_t *a4)
{
  if (a2 == a3)
  {
    float v34 = (_DWORD *)a4[1];
    if ((_DWORD *)*a4 == v34)
    {
      int v37 = 0;
    }
    else
    {
      int v35 = 0;
      float v36 = (_DWORD *)*a4;
      do
      {
        v35 += v36[1] + v36[3];
        v36 += 9;
      }
      while (v36 != v34);
      int v37 = v35 % 211;
    }
    return (uint64_t *)(*(_DWORD *)*a4 == v37
                                       + 211
                                       * (1908874354 * (((unint64_t)v34 - *a4) >> 2)
                                        - (*(v34 - 7) == -1))
                                       - 844);
  }
  else
  {
    uint64_t result = sub_1DC3811CC(a1, *a2);
    if (result)
    {
      uint64_t v9 = result;
      uint64_t v11 = result[3];
      uint64_t v10 = result[4];
      if (v11 == v10) {
        return 0;
      }
      int v12 = a2 + 1;
      char v13 = 1;
      do
      {
        if (*(_DWORD *)(v11 + 8) != -1 || v12 == a3)
        {
          unint64_t v15 = a4[1];
          unint64_t v16 = a4[2];
          if (v15 >= v16)
          {
            unint64_t v20 = 0x8E38E38E38E38E39 * ((uint64_t)(v15 - *a4) >> 2);
            unint64_t v21 = v20 + 1;
            if (v20 + 1 > 0x71C71C71C71C71CLL) {
              sub_1DC2FF97C();
            }
            unint64_t v22 = 0x8E38E38E38E38E39 * ((uint64_t)(v16 - *a4) >> 2);
            if (2 * v22 > v21) {
              unint64_t v21 = 2 * v22;
            }
            if (v22 >= 0x38E38E38E38E38ELL) {
              unint64_t v23 = 0x71C71C71C71C71CLL;
            }
            else {
              unint64_t v23 = v21;
            }
            if (v23) {
              unint64_t v23 = (unint64_t)sub_1DC381124(v23);
            }
            else {
              uint64_t v24 = 0;
            }
            unint64_t v25 = v23 + 36 * v20;
            long long v26 = *(_OWORD *)v11;
            long long v27 = *(_OWORD *)(v11 + 16);
            *(_DWORD *)(v25 + 32) = *(_DWORD *)(v11 + 32);
            *(_OWORD *)unint64_t v25 = v26;
            *(_OWORD *)(v25 + 16) = v27;
            float v29 = (_DWORD *)*a4;
            uint64_t v28 = (_DWORD *)a4[1];
            unint64_t v30 = v25;
            if (v28 != (_DWORD *)*a4)
            {
              do
              {
                long long v31 = *(_OWORD *)(v28 - 9);
                long long v32 = *(_OWORD *)(v28 - 5);
                *(_DWORD *)(v30 - 4) = *(v28 - 1);
                *(_OWORD *)(v30 - 20) = v32;
                *(_OWORD *)(v30 - 36) = v31;
                v30 -= 36;
                v28 -= 9;
              }
              while (v28 != v29);
              uint64_t v28 = (_DWORD *)*a4;
            }
            unint64_t v19 = v25 + 36;
            *a4 = v30;
            a4[1] = v25 + 36;
            a4[2] = v23 + 36 * v24;
            if (v28) {
              operator delete(v28);
            }
          }
          else
          {
            long long v17 = *(_OWORD *)v11;
            long long v18 = *(_OWORD *)(v11 + 16);
            *(_DWORD *)(v15 + 32) = *(_DWORD *)(v11 + 32);
            *(_OWORD *)unint64_t v15 = v17;
            *(_OWORD *)(v15 + 16) = v18;
            unint64_t v19 = v15 + 36;
          }
          a4[1] = v19;
          if (sub_1DC381280(a1, v12, a3, a4)) {
            return (uint64_t *)1;
          }
          a4[1] -= 36;
          uint64_t v10 = v9[4];
        }
        uint64_t result = 0;
        v11 += 36;
        char v33 = (v11 != v10) & v13;
        char v13 = 0;
      }
      while ((v33 & 1) != 0);
    }
  }
  return result;
}

void sub_1DC381520(unint64_t *a1, unsigned int a2)
{
  unint64_t v4 = (unsigned char *)a1[1];
  int v5 = 12;
  do
  {
    int v6 = (a2 >> --v5) & 1;
    unint64_t v7 = a1[2];
    if ((unint64_t)v4 >= v7)
    {
      unint64_t v9 = *a1;
      uint64_t v10 = &v4[-*a1];
      unint64_t v11 = (unint64_t)(v10 + 1);
      if ((uint64_t)(v10 + 1) < 0) {
        sub_1DC2FF97C();
      }
      unint64_t v12 = v7 - v9;
      if (2 * v12 > v11) {
        unint64_t v11 = 2 * v12;
      }
      if (v12 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v13 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v13 = v11;
      }
      if (v13) {
        uint64_t v14 = (char *)operator new(v13);
      }
      else {
        uint64_t v14 = 0;
      }
      unint64_t v15 = &v10[(void)v14];
      unint64_t v16 = &v10[(void)v14];
      *unint64_t v16 = v6;
      int v8 = v16 + 1;
      if (v4 != (unsigned char *)v9)
      {
        long long v17 = &v4[~v9];
        do
        {
          char v18 = *--v4;
          (v17--)[(void)v14] = v18;
        }
        while (v4 != (unsigned char *)v9);
        unint64_t v4 = (unsigned char *)*a1;
        unint64_t v15 = v14;
      }
      *a1 = (unint64_t)v15;
      a1[1] = (unint64_t)v8;
      a1[2] = (unint64_t)&v14[v13];
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      *unint64_t v4 = v6;
      int v8 = v4 + 1;
    }
    a1[1] = (unint64_t)v8;
    unint64_t v4 = v8;
  }
  while (v5);
}

void sub_1DC381634(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      unint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    sub_1DC2FF994();
  }
  int v5 = operator new(8 * prime);
  int v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  int v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    uint64_t v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          void *v8 = *v14;
          void *v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          uint64_t v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        int v8 = v14;
        uint64_t v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

void sub_1DC381830(char a1, void *__p)
{
  if (a1)
  {
    uint8x8_t v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t sub_1DC381890(float *a1, int a2, int a3, int a4)
{
  v43[2] = *MEMORY[0x1E4F143B8];
  v43[0] = &v42;
  v43[1] = &v41;
  if (a2)
  {
    uint64_t v4 = 4 * a2;
    float v5 = 0.0;
    int v6 = a1;
    do
    {
      float v7 = *v6++;
      float v5 = v5 + v7;
      v4 -= 4;
    }
    while (v4);
  }
  else
  {
    float v5 = 0.0;
  }
  unsigned int v8 = 0;
  uint64_t v9 = 7;
  if (!a4) {
    uint64_t v9 = 0;
  }
  uint8x8_t v10 = &a1[v9];
  uint64_t v11 = -4;
  if (!a4) {
    uint64_t v11 = 4;
  }
  float v12 = v5 / 17.0;
  do
  {
    *(_DWORD *)(v43[v8 & 1] + 4 * (v8 >> 1)) = (int)(float)((float)(*v10 / v12) + 0.5);
    ++v8;
    uint8x8_t v10 = (float *)((char *)v10 + v11);
  }
  while (v8 != 8);
  int v13 = vaddvq_s32(v42);
  int v14 = vaddvq_s32(v41);
  int v15 = vaddvq_s32(vaddq_s32(v41, v42));
  int v16 = v13 - 4;
  if (v13 <= 13) {
    int v17 = 13;
  }
  else {
    int v17 = v13;
  }
  if (v14 >= 4) {
    int v18 = 4;
  }
  else {
    int v18 = v14;
  }
  int v19 = v18 - 4;
  BOOL v22 = v15 == 17 && (v16 & (v16 >> 31)) == 13 - v17 && v19 == -((v14 - 13) & ~((v14 - 13) >> 31)) && (v13 & 1) == 0;
  if (!v22 || (v14 & 1) == 0) {
    goto LABEL_39;
  }
  uint64_t v23 = 0;
  int v24 = 0;
  int v25 = a3 >= 0 ? a3 : -a3;
  uint64_t v26 = (int)(((a3 >> 30) & 2 | (4 * v25) | a4) - 4);
  long long v27 = (int *)((char *)&unk_1DC40C828 + 32 * v26);
  do
  {
    int v28 = *v27;
    v27 += 2;
    v24 += v28 * v42.i32[v23++];
  }
  while (v23 != 4);
  uint64_t v29 = 0;
  int v30 = 0;
  long long v31 = (int *)((char *)&unk_1DC40C828 + 32 * v26 + 4);
  do
  {
    int v32 = *v31;
    v31 += 2;
    v30 += v32 * v41.i32[v29++];
  }
  while (v29 != 4);
  if (v16 <= 9)
  {
    uint64_t v33 = (v30 + v24);
    unsigned int v34 = (13 - v13) >> 1;
    int v35 = dword_1DC416788[v34];
    int v36 = 9 - v35;
    int v37 = sub_1DC30F278(&v42, v35, 1);
    uint64_t v38 = sub_1DC30F278(&v41, v36, 0) + dword_1DC41679C[v34] * v37 + dword_1DC4167B0[v34];
    uint64_t v39 = v33 << 32;
  }
  else
  {
LABEL_39:
    uint64_t v39 = 0;
    uint64_t v38 = 0xFFFFFFFFLL;
  }
  return v39 | v38;
}

void sub_1DC381AE8()
{
}

void sub_1DC381DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11 = sub_1DC381E28(a10);
  MEMORY[0x1E019CE90](v11, 0x10A0C408EF24B1CLL);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC381E28(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint8x8_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  float v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

uint64_t sub_1DC381E90(uint64_t result)
{
  if (result)
  {
    sub_1DC381E28(result);
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

void *sub_1DC381ED0(uint64_t a1, void *__dst, uint64_t a3, void *a4)
{
  uint64_t result = memcpy(__dst, *(const void **)(a1 + 16), *(void *)(a1 + 8));
  *a4 = *(void *)(a1 + 8);
  return result;
}

BOOL sub_1DC381F0C(int a1, uint64_t a2, int a3)
{
  return a1 > 11 && a3 < 233;
}

uint64_t MRCSampleGetTypeID()
{
  if (qword_1EBFFB800 != -1) {
    dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
  }
  return qword_1EBFFB9F8;
}

unint64_t MRCSampleCreateWithCVPixelBuffer(const void *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  return MRCSampleCreateWithCVPixelBufferAndPyramid(a1, 0, a2, a3, a4, a5);
}

unint64_t MRCSampleCreateWithCVPixelBufferAndPyramid(const void *a1, const void *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  v18.origin.CGFloat x = a3;
  v18.origin.CGFloat y = a4;
  v18.size.CGFloat width = a5;
  v18.size.CGFloat height = a6;
  DictionaryRepresentatiouint64_t n = CGRectCreateDictionaryRepresentation(v18);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MRCSampleAttributeRegionOfInterest", DictionaryRepresentation);
  CFRelease(DictionaryRepresentation);
  if (a2) {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MRCSampleAttributePyramid", a2);
  }
  v16[1] = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  CFTypeRef v17 = a1;
  v16[0] = sub_1DC382094(&v17);
  unint64_t v13 = atomic_exchange(v16, 0);
  sub_1DC3823EC(v16);
  sub_1DC306584((atomic_ullong *)&Mutable);
  return v13;
}

void sub_1DC382080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

uint64_t sub_1DC382094(CFTypeRef *a1)
{
  if (qword_1EBFFB800 != -1) {
    dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
  }
  Instance = (const void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    CFTypeID v3 = CFGetTypeID(Instance);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v3 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
    if (*a1) {
      CFRetain(*a1);
    }
    operator new();
  }
  return 0;
}

void sub_1DC382354(_Unwind_Exception *a1)
{
  sub_1DC3787A4(v4, 0);
  sub_1DC3065EC(v3);
  sub_1DC31EBFC(v2);
  sub_1DC378814(v1);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3823EC(atomic_ullong *a1)
{
  unint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1DC382420(uint64_t a1, atomic_ullong *a2)
{
  CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(a2, memory_order_acquire);
  if (explicit) {
    CFTypeRef explicit = CFRetain(explicit);
  }
  *(void *)a1 = explicit;
  uint64_t v4 = (__CVBuffer *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (!v4) {
    _os_assumes_log();
  }
  int IsPlanar = CVPixelBufferIsPlanar(v4);
  int v6 = (__CVBuffer *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (IsPlanar)
  {
    size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(v6, 0);
    size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire), 0);
  }
  else
  {
    size_t WidthOfPlane = CVPixelBufferGetWidth(v6);
    size_t HeightOfPlane = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire));
  }
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(double *)(a1 + 24) = (double)WidthOfPlane;
  *(double *)(a1 + 32) = (double)HeightOfPlane;
  uint64_t v9 = (__CVBuffer *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (!v9) {
    _os_assumes_log();
  }
  int v10 = CVPixelBufferIsPlanar(v9);
  uint64_t v11 = (__CVBuffer *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (v10)
  {
    if (!v11) {
      _os_assumes_log();
    }
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v11, 0);
  }
  else
  {
    if (!v11) {
      _os_assumes_log();
    }
    size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRow(v11);
  }
  *(void *)(a1 + 40) = BytesPerRowOfPlane;
  return a1;
}

void sub_1DC382508(_Unwind_Exception *a1)
{
  sub_1DC307370(v1);
  _Unwind_Resume(a1);
}

int64x2_t *sub_1DC38251C(int64x2_t *a1, atomic_ullong *a2, CGRect *a3, _OWORD *a4)
{
  a1->i64[0] = 0;
  a1->i64[1] = 0;
  a1[1].i64[0] = 0;
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    float v7 = a2;
    CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(a2, memory_order_acquire));
    if (Count >= 1)
    {
      CFIndex v9 = 0;
      unint64_t v46 = v7;
      unint64_t v45 = a4;
      do
      {
        ValueAtIndeCGFloat x = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(v7, memory_order_acquire), v9);
        if (ValueAtIndex) {
          ValueAtIndeCGFloat x = CFRetain(ValueAtIndex);
        }
        atomic_ullong v48 = (atomic_ullong)ValueAtIndex;
        if (!atomic_load_explicit(&v48, memory_order_acquire)
          || (CFTypeID v11 = CFGetTypeID((CFTypeRef)atomic_load_explicit(&v48, memory_order_acquire)),
              v11 != CVPixelBufferGetTypeID()))
        {
          _os_assumes_log();
        }
        unint64_t v13 = a1->u64[1];
        unint64_t v12 = a1[1].u64[0];
        if (v13 >= v12)
        {
          unint64_t v15 = 0x84BDA12F684BDA13 * ((uint64_t)(v13 - a1->i64[0]) >> 3);
          unint64_t v16 = v15 + 1;
          if (v15 + 1 > 0x12F684BDA12F684) {
            sub_1DC2FF97C();
          }
          unint64_t v17 = 0x84BDA12F684BDA13 * ((uint64_t)(v12 - a1->i64[0]) >> 3);
          if (2 * v17 > v16) {
            unint64_t v16 = 2 * v17;
          }
          if (v17 >= 0x97B425ED097B42) {
            unint64_t v18 = 0x12F684BDA12F684;
          }
          else {
            unint64_t v18 = v16;
          }
          long long v52 = a1 + 1;
          if (v18)
          {
            if (v18 > 0x12F684BDA12F684) {
              sub_1DC2FF994();
            }
            int v19 = (char *)operator new(216 * v18);
          }
          else
          {
            int v19 = 0;
          }
          CFIndex v20 = Count;
          long long v49 = v19;
          v50.i64[0] = (uint64_t)&v19[216 * v15];
          v50.i64[1] = v50.i64[0];
          long long v51 = &v19[216 * v18];
          unint64_t v21 = a4;
          sub_1DC3828DC(v50.i64[0], v9, &v48, a4);
          uint64_t v22 = v50.i64[0];
          uint64_t v14 = v50.i64[1] + 216;
          v50.i64[1] += 216;
          uint64_t v23 = a1->i64[0];
          unint64_t v24 = a1->u64[1];
          if (v24 == a1->i64[0])
          {
            int64x2_t v38 = vdupq_n_s64(v24);
            a4 = v21;
          }
          else
          {
            uint64_t v25 = 0;
            do
            {
              uint64_t v26 = v22 + v25;
              uint64_t v27 = v24 + v25;
              *(void *)(v22 + v25 - 216) = *(void *)(v24 + v25 - 216);
              CFTypeRef explicit = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(v24 + v25 - 208), memory_order_acquire);
              if (explicit) {
                CFTypeRef explicit = CFRetain(explicit);
              }
              *(void *)(v26 - 208) = explicit;
              long long v29 = *(_OWORD *)(v27 - 200);
              long long v30 = *(_OWORD *)(v27 - 184);
              *(void *)(v26 - 168) = *(void *)(v27 - 168);
              *(_OWORD *)(v26 - 184) = v30;
              *(_OWORD *)(v26 - 200) = v29;
              long long v31 = *(_OWORD *)(v27 - 80);
              long long v33 = *(_OWORD *)(v27 - 128);
              long long v32 = *(_OWORD *)(v27 - 112);
              *(_OWORD *)(v26 - 96) = *(_OWORD *)(v27 - 96);
              *(_OWORD *)(v26 - 80) = v31;
              *(_OWORD *)(v26 - 128) = v33;
              *(_OWORD *)(v26 - 112) = v32;
              long long v34 = *(_OWORD *)(v27 - 16);
              long long v36 = *(_OWORD *)(v27 - 64);
              long long v35 = *(_OWORD *)(v27 - 48);
              *(_OWORD *)(v26 - 32) = *(_OWORD *)(v27 - 32);
              *(_OWORD *)(v26 - 16) = v34;
              *(_OWORD *)(v26 - 64) = v36;
              *(_OWORD *)(v26 - 48) = v35;
              long long v37 = *(_OWORD *)(v27 - 144);
              *(_OWORD *)(v26 - 160) = *(_OWORD *)(v27 - 160);
              *(_OWORD *)(v26 - 144) = v37;
              v25 -= 216;
            }
            while (v24 + v25 != v23);
            v22 += v25;
            int64x2_t v38 = *a1;
            uint64_t v14 = v50.i64[1];
            a4 = v45;
            float v7 = v46;
          }
          a1->i64[0] = v22;
          a1->i64[1] = v14;
          int64x2_t v50 = v38;
          uint64_t v39 = (char *)a1[1].i64[0];
          a1[1].i64[0] = (uint64_t)v51;
          long long v51 = v39;
          long long v49 = (char *)v38.i64[0];
          sub_1DC382AA8((uint64_t)&v49);
          CFIndex Count = v20;
        }
        else
        {
          sub_1DC3828DC(a1->i64[1], v9, &v48, a4);
          uint64_t v14 = v13 + 216;
          a1->i64[1] = v14;
        }
        a1->i64[1] = v14;
        if (CGRectIsNull(*a3))
        {
          uint64_t v40 = (_OWORD *)MEMORY[0x1E4F1DB20];
        }
        else
        {
          if (!CGRectIsInfinite(*a3))
          {
            CGRect v53 = *a3;
            long long v43 = *(_OWORD *)(v14 - 80);
            long long v42 = *(_OWORD *)(v14 - 64);
            *(_OWORD *)&v47.a = *(_OWORD *)(v14 - 96);
            *(_OWORD *)&v47.CGFloat c = v43;
            *(_OWORD *)&v47.tCGFloat x = v42;
            *(CGRect *)(v14 - 160) = CGRectApplyAffineTransform(v53, &v47);
            goto LABEL_35;
          }
          uint64_t v40 = (_OWORD *)MEMORY[0x1E4F1DB10];
        }
        long long v41 = v40[1];
        *(_OWORD *)(v14 - 160) = *v40;
        *(_OWORD *)(v14 - 144) = v41;
LABEL_35:
        sub_1DC307370(&v48);
        ++v9;
      }
      while (v9 != Count);
    }
  }
  return a1;
}

void sub_1DC382864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_1DC3071F0((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3828DC(uint64_t a1, uint64_t a2, atomic_ullong *a3, _OWORD *a4)
{
  *(void *)a1 = a2;
  sub_1DC382420(a1 + 8, a3);
  long long v6 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(a1 + 72) = v6;
  long long v7 = a4[1];
  *(_OWORD *)(a1 + 88) = *a4;
  *(_OWORD *)(a1 + 104) = v7;
  unsigned int v8 = (long long *)MEMORY[0x1E4F1DAB8];
  long long v9 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)(a1 + 120) = *MEMORY[0x1E4F1DAB8];
  long long v10 = *v8;
  *(_OWORD *)(a1 + 136) = v8[1];
  *(_OWORD *)(a1 + 152) = v8[2];
  *(_OWORD *)&v36.a = v10;
  *(_OWORD *)&v36.CGFloat c = v9;
  *(_OWORD *)&v36.tCGFloat x = v8[2];
  *(void *)&long long v7 = *(void *)(a1 + 88);
  *(void *)&long long v10 = *(void *)(a1 + 96);
  *(void *)&long long v9 = *(void *)(a1 + 104);
  uint64_t v11 = *(void *)(a1 + 112);
  double MinX = CGRectGetMinX(*(CGRect *)&v7);
  CGFloat MinY = CGRectGetMinY(*(CGRect *)(a1 + 88));
  CGAffineTransformTranslate((CGAffineTransform *)(a1 + 120), &v36, -MinX, -MinY);
  long long v14 = *(_OWORD *)(a1 + 136);
  *(_OWORD *)&v34.a = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v34.CGFloat c = v14;
  *(_OWORD *)&v34.tCGFloat x = *(_OWORD *)(a1 + 152);
  uint64_t v15 = *(void *)(a1 + 16);
  *(void *)&long long v14 = *(void *)(a1 + 24);
  uint64_t v16 = *(void *)(a1 + 32);
  uint64_t v17 = *(void *)(a1 + 40);
  double Width = CGRectGetWidth(*(CGRect *)((char *)&v14 - 8));
  double v19 = CGRectGetWidth(*(CGRect *)(a1 + 88));
  double Height = CGRectGetHeight(*(CGRect *)(a1 + 16));
  CGFloat v21 = CGRectGetHeight(*(CGRect *)(a1 + 88));
  CGAffineTransformScale(&v35, &v34, Width / v19, Height / v21);
  long long v22 = *(_OWORD *)&v35.c;
  *(_OWORD *)(a1 + 120) = *(_OWORD *)&v35.a;
  *(_OWORD *)(a1 + 136) = v22;
  *(_OWORD *)(a1 + 152) = *(_OWORD *)&v35.tx;
  long long v23 = *(_OWORD *)(a1 + 136);
  *(_OWORD *)&v33.a = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v33.CGFloat c = v23;
  *(_OWORD *)&v33.tCGFloat x = *(_OWORD *)(a1 + 152);
  uint64_t v24 = *(void *)(a1 + 16);
  *(void *)&long long v23 = *(void *)(a1 + 24);
  uint64_t v25 = *(void *)(a1 + 32);
  uint64_t v26 = *(void *)(a1 + 40);
  CGFloat v27 = CGRectGetMinX(*(CGRect *)((char *)&v23 - 8));
  CGFloat v28 = CGRectGetMinY(*(CGRect *)(a1 + 16));
  CGAffineTransformTranslate(&v35, &v33, v27, v28);
  long long v29 = *(_OWORD *)&v35.c;
  *(_OWORD *)(a1 + 120) = *(_OWORD *)&v35.a;
  *(_OWORD *)(a1 + 136) = v29;
  *(_OWORD *)(a1 + 152) = *(_OWORD *)&v35.tx;
  long long v30 = *(_OWORD *)(a1 + 136);
  *(_OWORD *)&v32.a = *(_OWORD *)(a1 + 120);
  *(_OWORD *)&v32.CGFloat c = v30;
  *(_OWORD *)&v32.tCGFloat x = *(_OWORD *)(a1 + 152);
  CGAffineTransformInvert((CGAffineTransform *)(a1 + 168), &v32);
  return a1;
}

void sub_1DC382A94(_Unwind_Exception *a1)
{
  sub_1DC307370(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC382AA8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 216;
    sub_1DC307370((atomic_ullong *)(i - 208));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

unint64_t MRCSampleCreateWithCVPixelBufferAndAttributes(const void *a1, atomic_ullong a2)
{
  v4[1] = a2;
  CFTypeRef v5 = a1;
  v4[0] = sub_1DC382094(&v5);
  unint64_t v2 = atomic_exchange(v4, 0);
  sub_1DC3823EC(v4);
  return v2;
}

unint64_t MRCSampleGetCVPixelBuffer(atomic_ullong *volatile *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID((CFTypeRef)cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v2 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  return atomic_load_explicit(cf[2], memory_order_acquire);
}

double MRCSampleGetRegionOfInterest(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v2 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  return *((double *)cf + 4);
}

unint64_t MRCSampleGetPyramid(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v2 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  return atomic_load_explicit(cf + 8, memory_order_acquire);
}

unint64_t MRCSampleCopyAttribute(char *cf, CFTypeRef a2)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v4 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  CFTypeRef v5 = cf + 16;
  if (a2) {
    CFTypeRef v6 = CFRetain(a2);
  }
  else {
    CFTypeRef v6 = 0;
  }
  CFTypeRef v9 = v6;
  sub_1DC382DD0(&v10, (uint64_t)v5, (atomic_ullong *)&v9);
  unint64_t v7 = atomic_exchange(&v10, 0);
  sub_1DC31EB58(&v10);
  sub_1DC31FA90((atomic_ullong *)&v9);
  return v7;
}

void sub_1DC382DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

const void *sub_1DC382DD0(void *a1, uint64_t a2, atomic_ullong *a3)
{
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire)
    && atomic_load_explicit(a3, memory_order_acquire))
  {
    uint64_t result = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire), (const void *)atomic_load_explicit(a3, memory_order_acquire));
    if (result) {
      uint64_t result = CFRetain(result);
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *a1 = result;
  return result;
}

unint64_t MRCSampleCopyAttributes(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v2 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  sub_1DC382ED0(&v5, (uint64_t)cf + 16);
  unint64_t v3 = atomic_exchange((atomic_ullong *volatile)&v5, 0);
  sub_1DC31EBFC((atomic_ullong *)&v5);
  return v3;
}

CFDictionaryRef sub_1DC382ED0(CFDictionaryRef *a1, uint64_t a2)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire);
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (explicit) {
    CFDictionaryRef result = CFDictionaryCreateCopy(v4, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire));
  }
  else {
    CFDictionaryRef result = CFDictionaryCreate(v4, 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  *a1 = result;
  return result;
}

void MRCSampleGeneratePyramidIfNotPresent(atomic_ullong *cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB800 != -1) {
      dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
    }
    if (v2 != qword_1EBFFB9F8) {
      _os_assumes_log();
    }
  }
  if (!atomic_load_explicit(cf + 8, memory_order_acquire))
  {
    if (qword_1EAA94E40 != -1) {
      dispatch_once_f(&qword_1EAA94E40, 0, (dispatch_function_t)sub_1DC3C1D80);
    }
    unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)qword_1EAA94E38, memory_order_acquire);
    if (explicit)
    {
      CFTypeID v4 = CFGetTypeID(explicit);
      if (qword_1EBFFB7E0 != -1) {
        dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
      }
      if (v4 != qword_1EBFFB818) {
        _os_assumes_log();
      }
    }
    sub_1DC383138(&v6, (uint64_t)(cf + 2), (uint64_t)explicit + 16);
    if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire))
    {
      CFDictionaryRef v5 = (const void *)atomic_exchange(cf + 8, atomic_exchange((atomic_ullong *volatile)&v6, 0));
      if (v5) {
        CFRelease(v5);
      }
      operator new();
    }
    sub_1DC3065EC((atomic_ullong *)&v6);
  }
}

void sub_1DC383100(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x1E019CE90](v2, 0x20C40960023A9);
  sub_1DC3065EC((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC383138(atomic_ullong **a1, uint64_t a2, uint64_t a3)
{
  void v13[4] = *MEMORY[0x1E4F143B8];
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 48), memory_order_acquire))
  {
    CFDictionaryRef result = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 48), memory_order_acquire);
    if (result) {
      CFDictionaryRef result = (atomic_ullong *)CFRetain(result);
    }
    *a1 = result;
  }
  else
  {
    LOBYTE(v11[0]) = 0;
    char v12 = 0;
    v10[0] = 0;
    v10[32] = 0;
    if (qword_1EBFFC270 != -1) {
      dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
    }
    os_signpost_id_t v8 = os_signpost_id_generate((os_log_t)qword_1EBFFC278);
    char v9 = 1;
    *a1 = 0;
    unint64_t v7 = operator new(0x30uLL);
    void *v7 = &unk_1F3663430;
    v7[1] = v11;
    v7[2] = a1;
    v7[3] = a2;
    v7[4] = v10;
    v7[5] = &v8;
    void v13[3] = v7;
    sub_1DC335ACC(a3, v13);
    CFDictionaryRef result = sub_1DC336090(v13);
    if (v12) {
      return sub_1DC390B00(v11);
    }
  }
  return result;
}

void sub_1DC383274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, atomic_ullong a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_1DC336090((void *)(v30 - 72));
  sub_1DC3065EC(v29);
  if (a29) {
    sub_1DC390B00(&a17);
  }
  _Unwind_Resume(a1);
}

unint64_t MRCSampleCreateByGeneratingPyramid(void *cf, CFTypeRef a2)
{
  CFTypeRef v2 = a2;
  atomic_ullong v12 = 0;
  if (a2) {
    goto LABEL_5;
  }
  CFTypeID v4 = (const void *)atomic_exchange(&v12, MRCContextCreateWithOptions(0));
  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef v2 = (CFTypeRef)atomic_load_explicit(&v12, memory_order_acquire);
  if (v2)
  {
LABEL_5:
    if (cf)
    {
      CFTypeID v5 = CFGetTypeID(cf);
      if (qword_1EBFFB800 != -1) {
        dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
      }
      if (v5 != qword_1EBFFB9F8) {
        _os_assumes_log();
      }
    }
    CFTypeID v6 = CFGetTypeID(v2);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v6 != qword_1EBFFB818) {
      _os_assumes_log();
    }
    sub_1DC383138(&v11, (uint64_t)cf + 16, (uint64_t)v2 + 16);
    if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
    {
      sub_1DC382ED0((CFDictionaryRef *)&v14, (uint64_t)cf + 16);
      MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire));
      sub_1DC31EBFC((atomic_ullong *)&v14);
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire), @"MRCSampleAttributePyramid", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire));
      CVPixelBuffer = (const void *)MRCSampleGetCVPixelBuffer((atomic_ullong *volatile *)cf);
      v13[1] = atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire);
      CFTypeRef v14 = CVPixelBuffer;
      v13[0] = sub_1DC382094(&v14);
      unint64_t v8 = atomic_exchange(v13, 0);
      sub_1DC3823EC(v13);
      sub_1DC306584((atomic_ullong *)&MutableCopy);
    }
    else
    {
      unint64_t v8 = 0;
    }
    sub_1DC3065EC((atomic_ullong *)&v11);
  }
  else
  {
    unint64_t v8 = 0;
  }
  sub_1DC3599F8(&v12);
  return v8;
}

void sub_1DC383490(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  atomic_ullong v3 = va_arg(va1, void);
  va_copy(va2, va1);
  atomic_ullong v5 = va_arg(va2, void);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  sub_1DC31EBFC((atomic_ullong *)va2);
  sub_1DC3065EC((atomic_ullong *)va);
  sub_1DC3599F8((atomic_ullong *)va1);
  _Unwind_Resume(a1);
}

CFDictionaryRef sub_1DC3834D8(const __CFDictionary *result, uint64_t a2)
{
  CFDictionaryRef v2 = result;
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire)
    && (result = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire), @"MRCSampleAttributePresentationTimeStamp")) != 0&& (v3 = result, CFTypeID v4 = CFGetTypeID(result), result = (const __CFDictionary *)CFDictionaryGetTypeID(), (const __CFDictionary *)v4 == result))
  {
    memset(&v6, 0, sizeof(v6));
    CFDictionaryRef result = (const __CFDictionary *)CMTimeMakeFromDictionary(&v6, v3);
    if (v6.flags)
    {
      *(CMTime *)CFDictionaryRef v2 = v6;
      char v5 = 1;
    }
    else
    {
      char v5 = 0;
      *(unsigned char *)CFDictionaryRef v2 = 0;
    }
    *((unsigned char *)v2 + 24) = v5;
  }
  else
  {
    *(unsigned char *)CFDictionaryRef v2 = 0;
    *((unsigned char *)v2 + 24) = 0;
  }
  return result;
}

CFDataRef sub_1DC38358C(const __CFData *result, uint64_t a2)
{
  CFDataRef v2 = result;
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire)
    && (result = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire), @"MRCSampleAttributeCameraIntrinsicMatrix")) != 0&& (v3 = result, CFTypeID v4 = CFGetTypeID(result), result = (const __CFData *)CFDataGetTypeID(), (const __CFData *)v4 == result)&& (result = (const __CFData *)CFDataGetLength(v3), result == (const __CFData *)48))
  {
    CFDictionaryRef result = (const __CFData *)CFDataGetBytePtr(v3);
    long long v5 = *((_OWORD *)result + 1);
    *(_OWORD *)CFDataRef v2 = *(_OWORD *)result;
    *((_OWORD *)v2 + 1) = v5;
    *((_OWORD *)v2 + 2) = *((_OWORD *)result + 2);
    char v6 = 1;
  }
  else
  {
    char v6 = 0;
    *(unsigned char *)CFDataRef v2 = 0;
  }
  *((unsigned char *)v2 + 48) = v6;
  return result;
}

uint64_t sub_1DC383628(atomic_ullong *a1)
{
  LOBYTE(v3[0]) = 0;
  char v4 = 0;
  uint64_t v1 = sub_1DC38379C(a1, (uint64_t)v3);
  if (v4) {
    sub_1DC390B00(v3);
  }
  return v1;
}

void sub_1DC383674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, atomic_ullong a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a22) {
    sub_1DC390B00(&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC383690(atomic_ullong *a1)
{
  LOBYTE(v3[0]) = 0;
  char v4 = 0;
  uint64_t v1 = sub_1DC3836F8(a1, (uint64_t)v3);
  if (v4) {
    sub_1DC390B00(v3);
  }
  return v1;
}

void sub_1DC3836DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, atomic_ullong a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a22) {
    sub_1DC390B00(&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3836F8(atomic_ullong *a1, uint64_t a2)
{
  if (!atomic_load_explicit(a1, memory_order_acquire))
  {
    uint64_t v7 = @"Invalid pixel buffer.";
    uint64_t v8 = -2002;
    sub_1DC306334((atomic_ullong *)a2, &v8, (CFTypeRef *)&v7);
    return 0;
  }
  uint64_t v3 = 1;
  CVReturn v4 = CVPixelBufferUnlockBaseAddress((CVPixelBufferRef)atomic_load_explicit(a1, memory_order_acquire), 1uLL);
  if (v4)
  {
    CVReturn v5 = v4;
    uint64_t v7 = @"CVPixelBufferUnlockBaseAddress failed.";
    uint64_t v8 = -2002;
    sub_1DC306334((atomic_ullong *)a2, &v8, (CFTypeRef *)&v7);
    *(_DWORD *)(a2 + 24) = v5;
    *(unsigned char *)(a2 + 28) = 1;
    return 0;
  }
  return v3;
}

uint64_t sub_1DC38379C(atomic_ullong *a1, uint64_t a2)
{
  if (!atomic_load_explicit(a1, memory_order_acquire))
  {
    uint64_t v7 = @"Invalid pixel buffer.";
    uint64_t v8 = -2002;
    sub_1DC306334((atomic_ullong *)a2, &v8, (CFTypeRef *)&v7);
    return 0;
  }
  uint64_t v3 = 1;
  CVReturn v4 = CVPixelBufferLockBaseAddress((CVPixelBufferRef)atomic_load_explicit(a1, memory_order_acquire), 1uLL);
  if (v4)
  {
    CVReturn v5 = v4;
    uint64_t v7 = @"CVPixelBufferLockBaseAddress failed.";
    uint64_t v8 = -2002;
    sub_1DC306334((atomic_ullong *)a2, &v8, (CFTypeRef *)&v7);
    *(_DWORD *)(a2 + 24) = v5;
    *(unsigned char *)(a2 + 28) = 1;
    return 0;
  }
  return v3;
}

CFStringRef sub_1DC383840(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"<%s %p> {\n", "MRCSample", a1 - 16);
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    pixelBuffer ");
    sub_1DC3CBAD8((atomic_ullong *)&Mutable, *(atomic_ullong **)a1);
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"\n");
    if (atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire)
      && CFDictionaryContainsKey((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire), @"MRCSampleAttributeRegionOfInterest"))
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    regionOfInterest ");
      if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
      {
        if (CGRectIsNull(*(CGRect *)(a1 + 16)))
        {
          unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
          CFStringRef v4 = @"<null>";
        }
        else
        {
          BOOL IsInfinite = CGRectIsInfinite(*(CGRect *)(a1 + 16));
          unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
          if (IsInfinite)
          {
            CFStringRef v4 = @"<infinite>";
          }
          else
          {
            CFStringAppend(explicit, @"{origin=");
            sub_1DC3CBEE8((atomic_ullong *)&Mutable, (double *)(a1 + 16));
            CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @", size=");
            if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
            {
              CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"{width=");
              sub_1DC3CBE3C((atomic_ullong *)&Mutable, *(double *)(a1 + 32));
              CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @", height=");
              sub_1DC3CBE3C((atomic_ullong *)&Mutable, *(double *)(a1 + 40));
              CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"}");
            }
            unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
            CFStringRef v4 = @"}";
          }
        }
        CFStringAppend(explicit, v4);
      }
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"\n");
    }
    if (*(void *)(a1 + 56))
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    pyramid {\n");
      uint64_t v7 = *(void *)(*(void *)(a1 + 56) + 8) - **(void **)(a1 + 56);
      if (v7)
      {
        uint64_t v8 = 0;
        unint64_t v9 = v7 / 216;
        if (v9 <= 1) {
          uint64_t v10 = 1;
        }
        else {
          uint64_t v10 = v9;
        }
        uint64_t v11 = 8;
        do
        {
          CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        level%zuPixelBuffer ", v8);
          sub_1DC3CBAD8((atomic_ullong *)&Mutable, (atomic_ullong *)(**(void **)(a1 + 56) + v11));
          CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"\n");
          ++v8;
          v11 += 216;
        }
        while (v10 != v8);
      }
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    }
    sub_1DC3834D8((const __CFDictionary *)&v20, a1);
    if (LOBYTE(v21))
    {
      atomic_ullong v12 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      CMTime time = v20;
      CFStringRef v18 = CMTimeCopyDescription(v2, &time);
      CFStringAppendFormat(v12, 0, @"    presentationTimeStamp %@\n", atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire));
      sub_1DC31FA90((atomic_ullong *)&v18);
    }
    sub_1DC38358C((const __CFData *)&v20, a1);
    if (v25)
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    cameraIntrinsicMatrix {\n");
      unint64_t v13 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      CFStringAppendFormat(v13, 0, @"        {%f, %f, %f}\n", *(float *)&v20.value, *(float *)&v20.epoch, v22);
      CFTypeRef v14 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      CFStringAppendFormat(v14, 0, @"        {%f, %f, %f}\n", *((float *)&v20.value + 1), *((float *)&v20.epoch + 1), v23);
      uint64_t v15 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      CFStringAppendFormat(v15, 0, @"        {%f, %f, %f}\n", *(float *)&v20.timescale, v21, v24);
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    }
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"}");
    CFStringRef Copy = CFStringCreateCopy(v2, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  }
  else
  {
    CFStringRef Copy = 0;
  }
  sub_1DC326F90((atomic_ullong *)&Mutable);
  return Copy;
}

void sub_1DC383C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  atomic_ullong v10 = va_arg(va1, void);
  sub_1DC31FA90((atomic_ullong *)va);
  sub_1DC326F90((atomic_ullong *)va1);
  _Unwind_Resume(a1);
}

void *sub_1DC383CD0(atomic_ullong *a1)
{
  unint64_t explicit = (__CVBuffer *)atomic_load_explicit(a1, memory_order_acquire);
  if (!explicit) {
    _os_assumes_log();
  }
  int IsPlanar = CVPixelBufferIsPlanar(explicit);
  CFStringRef v4 = (__CVBuffer *)atomic_load_explicit(a1, memory_order_acquire);
  if (IsPlanar)
  {
    if (!v4) {
      _os_assumes_log();
    }
    return CVPixelBufferGetBaseAddressOfPlane(v4, 0);
  }
  else
  {
    if (!v4) {
      _os_assumes_log();
    }
    return CVPixelBufferGetBaseAddress(v4);
  }
}

atomic_uint **sub_1DC383D6C@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  CVReturn v5 = (atomic_uint *)a1[2];
  if (v5) {
    atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v6 = *a2;
  uint64_t v7 = (atomic_uint **)a2[1];
  unint64_t v8 = 126 - 2 * __clz(((uint64_t)v7 - *a2) >> 3);
  BOOL v9 = v7 == (atomic_uint **)*a2;
  int v68 = v5;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  if (v9) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v8;
  }
  sub_1DC3847D4(v6, v7, v10, 1);
  v67[0] = 0;
  v67[1] = 0;
  v66[3] = v67;
  sub_1DC3851B8(v66, 3uLL);
  uint64_t v11 = (uint64_t *)*a2;
  if ((a2[1] - *a2) >> 3)
  {
    uint64_t v65 = 0;
    uint64_t v12 = *v11;
    if (*v11) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v12 + 8), 1u, memory_order_relaxed);
    }
    uint64_t v65 = v12;
    uint64_t v13 = *(void *)(v12 + 16);
    if (v13)
    {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v13 + 8), 1u, memory_order_relaxed);
      CFTypeRef v14 = (atomic_uint **)v66[0];
      atomic_fetch_add_explicit((atomic_uint *volatile)(v13 + 8), 1u, memory_order_relaxed);
      uint64_t v15 = (std::exception_vtbl *)v13;
    }
    else
    {
      uint64_t v15 = 0;
      CFTypeRef v14 = (atomic_uint **)v66[0];
    }
    v57.__vftable = v15;
    if (*v14) {
      sub_1DC2FF57C(*v14);
    }
    __CFString *v14 = (atomic_uint *)v13;
    sub_1DC35D870((atomic_uint **)&v57);
    uint64_t v16 = *(void *)(v65 + 24);
    if (v16)
    {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v16 + 8), 1u, memory_order_relaxed);
      uint64_t v17 = v66[0];
      atomic_fetch_add_explicit((atomic_uint *volatile)(v16 + 8), 1u, memory_order_relaxed);
      CFStringRef v18 = (std::exception_vtbl *)v16;
    }
    else
    {
      CFStringRef v18 = 0;
      uint64_t v17 = v66[0];
    }
    v57.__vftable = v18;
    double v19 = *(atomic_uint **)(v17 + 8);
    if (v19) {
      sub_1DC2FF57C(v19);
    }
    *(void *)(v17 + 8) = v16;
    sub_1DC35D870((atomic_uint **)&v57);
    uint64_t v20 = *(void *)(v65 + 32);
    if (v20)
    {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v20 + 8), 1u, memory_order_relaxed);
      uint64_t v21 = v66[0];
      atomic_fetch_add_explicit((atomic_uint *volatile)(v20 + 8), 1u, memory_order_relaxed);
      float v22 = (std::exception_vtbl *)v20;
    }
    else
    {
      float v22 = 0;
      uint64_t v21 = v66[0];
    }
    v57.__vftable = v22;
    float v23 = *(atomic_uint **)(v21 + 16);
    if (v23) {
      sub_1DC2FF57C(v23);
    }
    *(void *)(v21 + 16) = v20;
    sub_1DC35D870((atomic_uint **)&v57);
    char v25 = (void *)v66[0];
    uint64_t v26 = (void *)v66[1];
    while (v25 != v26)
    {
      float v27 = (*(float (**)(void, uint64_t))(*(void *)*v25 + 16))(*v25, v24);
      (*(void (**)(void, uint64_t))(*(void *)*v25 + 24))(*v25, v28);
      uint64_t v30 = v67[0];
      if (v67[0])
      {
        int v31 = (int)v27;
        CGAffineTransform v32 = v67;
        do
        {
          CGAffineTransform v33 = v30;
          CGAffineTransform v34 = v32;
          int v35 = *((_DWORD *)v30 + 8);
          CGAffineTransform v36 = v30 + 1;
          if (v35 >= v31)
          {
            CGAffineTransform v36 = v33;
            CGAffineTransform v32 = (void **)v33;
          }
          uint64_t v30 = (void *)*v36;
        }
        while (v30);
        if (v32 != v67)
        {
          long long v37 = v35 >= v31 ? v33 : v34;
          if (*((_DWORD *)v37 + 8) <= v31)
          {
            BOOL v38 = v35 < v31;
            uint64_t v39 = v35 >= v31 ? v33 : v34;
            uint64_t v40 = v38 ? (uint64_t)(v34 + 6) : (uint64_t)(v33 + 6);
            uint64_t v41 = v39[6];
            if (v41)
            {
              int v42 = (int)v29;
              uint64_t v43 = v40;
              do
              {
                int v44 = (uint64_t *)v41;
                uint64_t v45 = v43;
                int v46 = *(_DWORD *)(v41 + 28);
                CGAffineTransform v47 = (uint64_t *)(v41 + 8);
                if (v46 >= v42)
                {
                  CGAffineTransform v47 = v44;
                  uint64_t v43 = (uint64_t)v44;
                }
                uint64_t v41 = *v47;
              }
              while (v41);
              if (v43 != v40)
              {
                if (v46 >= v42) {
                  atomic_ullong v48 = v44;
                }
                else {
                  atomic_ullong v48 = (void *)v45;
                }
                if (*((_DWORD *)v48 + 7) <= v42)
                {
                  exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
                  sub_1DC379B70(exception, "Candidate fiducial already assigned to a valid symbol");
                  void *exception = &unk_1F36611E0;
                  __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
                }
              }
            }
          }
        }
      }
      ++v25;
    }
    unsigned int v63 = -1;
    float v64 = 0.0;
    long long v49 = (atomic_uint *)v65;
    if (v65) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v65 + 8), 1u, memory_order_relaxed);
    }
    int v61 = v49;
    sub_1DC3A1084(&v62, (uint64_t)a1, (uint64_t)&v61, &v64, (int *)&v63);
    sub_1DC385238(&v61);
    unsigned int v50 = v63;
    uint64_t v51 = v65;
    if (v65) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v65 + 8), 1u, memory_order_relaxed);
    }
    uint64_t v59 = v51;
    float v52 = v64;
    CGRect v53 = v62;
    if (v62) {
      atomic_fetch_add_explicit(v62 + 2, 1u, memory_order_relaxed);
    }
    float v58 = v53;
    sub_1DC3A21AC(v52, (uint64_t)&v60, a1, (uint64_t)&v59, v50, &v58);
  }
  v57.__vftable = (std::exception_vtbl *)v66;
  sub_1DC3853C0((void ***)&v57);
  sub_1DC385444(v67[0]);
  return sub_1DC2FF548(&v68);
}

void sub_1DC384780()
{
}

uint64_t sub_1DC3847D4(uint64_t result, atomic_uint **a2, uint64_t a3, char a4)
{
  unint64_t v8 = (atomic_uint **)result;
LABEL_2:
  BOOL v9 = a2;
  uint64_t v10 = a2 - 1;
  uint64_t v11 = v8;
  while (1)
  {
    unint64_t v8 = v11;
    uint64_t v12 = (char *)v9 - (char *)v11;
    uint64_t v13 = v9 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v43 = (uint64_t)*(a2 - 1);
          uint64_t v96 = a2 - 1;
          if (*(float *)(v43 + 48) > *((float *)*v8 + 12)) {
            CFDictionaryRef result = (uint64_t)sub_1DC3855A8(v8, v96);
          }
          break;
        case 3:
          CFDictionaryRef result = (uint64_t)sub_1DC385658(v8, v8 + 1, v10);
          break;
        case 4:
          CFDictionaryRef result = (uint64_t)sub_1DC385734(v8, v8 + 1, v8 + 2, v10);
          break;
        case 5:
          CFDictionaryRef result = (uint64_t)sub_1DC3857F4(v8, v8 + 1, v8 + 2, v8 + 3, v10);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191)
    {
      BOOL v5 = v8 == v9;
      int v44 = v9;
      uint64_t v45 = v8 + 1;
      char v47 = v5 || v45 == v44;
      if (a4)
      {
        if ((v47 & 1) == 0)
        {
          uint64_t v48 = 0;
          long long v49 = v8;
          do
          {
            unsigned int v50 = *v45;
            if (*((float *)*v45 + 12) > *((float *)*v49 + 12))
            {
              unint64_t v51 = 0;
              atomic_fetch_add_explicit(v50 + 2, 1u, memory_order_relaxed);
              long long v98 = v50;
              float v52 = *v49;
              while (1)
              {
                if (v52) {
                  atomic_fetch_add_explicit(v52 + 2, 1u, memory_order_relaxed);
                }
                CGRect v53 = v49[v51 / 8 + 1];
                if (v53) {
                  sub_1DC2FF57C(v53);
                }
                v49[v51 / 8 + 1] = v52;
                uint64_t v54 = v98;
                if (v48 == v51) {
                  break;
                }
                float v52 = v49[v51 / 8 - 1];
                v51 -= 8;
                if (*((float *)v98 + 12) <= *((float *)v52 + 12))
                {
                  float v55 = &v45[v51 / 8];
                  goto LABEL_107;
                }
              }
              float v55 = v8;
              if (!v98) {
                goto LABEL_108;
              }
LABEL_107:
              atomic_fetch_add_explicit(v98 + 2, 1u, memory_order_relaxed);
LABEL_108:
              if (*v55) {
                sub_1DC2FF57C(*v55);
              }
              unint64_t *v55 = v54;
              CFDictionaryRef result = (uint64_t)sub_1DC385238(&v98);
            }
            ++v45;
            ++v49;
            v48 -= 8;
          }
          while (v45 != a2);
        }
      }
      else if ((v47 & 1) == 0)
      {
        do
        {
          long long v91 = v45;
          unint64_t v92 = v8[1];
          if (*((float *)v92 + 12) > *((float *)*v8 + 12))
          {
            atomic_fetch_add_explicit(v92 + 2, 1u, memory_order_relaxed);
            long long v98 = v92;
            unint64_t v93 = *v8;
            do
            {
              if (v93) {
                atomic_fetch_add_explicit(v93 + 2, 1u, memory_order_relaxed);
              }
              if (*v45) {
                sub_1DC2FF57C(*v45);
              }
              *uint64_t v45 = v93;
              unint64_t v94 = v98;
              unint64_t v93 = *(v45 - 2);
              --v45;
            }
            while (*((float *)v98 + 12) > *((float *)v93 + 12));
            atomic_fetch_add_explicit(v98 + 2, 1u, memory_order_relaxed);
            if (*v45) {
              sub_1DC2FF57C(*v45);
            }
            *uint64_t v45 = v94;
            CFDictionaryRef result = (uint64_t)sub_1DC385238(&v98);
          }
          uint64_t v45 = v91 + 1;
          unint64_t v8 = v91;
        }
        while (v91 + 1 != a2);
      }
      return result;
    }
    if (!a3) {
      break;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    uint64_t v15 = &v8[(unint64_t)v13 >> 1];
    if ((unint64_t)v12 < 0x401)
    {
      sub_1DC385658(v15, v8, v10);
    }
    else
    {
      sub_1DC385658(v8, v15, v10);
      sub_1DC385658(v8 + 1, v15 - 1, a2 - 2);
      sub_1DC385658(v8 + 2, &v8[v14 + 1], a2 - 3);
      sub_1DC385658(v15 - 1, v15, &v8[v14 + 1]);
      uint64_t v16 = *v8;
      if (*v8) {
        atomic_fetch_add_explicit(v16 + 2, 1u, memory_order_relaxed);
      }
      long long v98 = v16;
      uint64_t v17 = *v15;
      if (*v15) {
        atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      }
      if (*v8)
      {
        sub_1DC2FF57C(*v8);
        uint64_t v16 = v98;
      }
      long long *v8 = v17;
      if (v16) {
        atomic_fetch_add_explicit(v16 + 2, 1u, memory_order_relaxed);
      }
      if (*v15) {
        sub_1DC2FF57C(*v15);
      }
      *uint64_t v15 = v16;
      sub_1DC385238(&v98);
    }
    --a3;
    CFStringRef v18 = a2;
    if (a4)
    {
      double v19 = *v8;
      if (!*v8) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
    double v19 = *v8;
    float v20 = *((float *)*v8 + 12);
    if (*((float *)*(v8 - 1) + 12) <= v20)
    {
      atomic_fetch_add_explicit(v19 + 2, 1u, memory_order_relaxed);
      long long v98 = v19;
      if (v20 <= *((float *)*v10 + 12))
      {
        int v35 = v8 + 1;
        do
        {
          uint64_t v11 = v35;
          if (v35 >= a2) {
            break;
          }
          ++v35;
        }
        while (v20 <= *((float *)*v11 + 12));
      }
      else
      {
        uint64_t v11 = v8;
        do
        {
          CGAffineTransform v34 = v11[1];
          ++v11;
        }
        while (v20 <= *((float *)v34 + 12));
      }
      CGAffineTransform v36 = a2;
      if (v11 < a2)
      {
        CGAffineTransform v36 = a2;
        do
          uint64_t v37 = (uint64_t)*--v36;
        while (v20 > *(float *)(v37 + 48));
      }
      while (v11 < v36)
      {
        sub_1DC3855A8(v11, v36);
        double v19 = v98;
        float v38 = *((float *)v98 + 12);
        do
        {
          uint64_t v39 = v11[1];
          ++v11;
        }
        while (v38 <= *((float *)v39 + 12));
        do
          uint64_t v40 = (uint64_t)*--v36;
        while (v38 > *(float *)(v40 + 48));
      }
      uint64_t v41 = v11 - 1;
      if (v11 - 1 != v8)
      {
        int v42 = *v41;
        if (*v41) {
          atomic_fetch_add_explicit(v42 + 2, 1u, memory_order_relaxed);
        }
        if (*v8) {
          sub_1DC2FF57C(*v8);
        }
        long long *v8 = v42;
        double v19 = v98;
      }
      if (v19) {
        atomic_fetch_add_explicit(v19 + 2, 1u, memory_order_relaxed);
      }
      if (*v41) {
        sub_1DC2FF57C(*v41);
      }
      *uint64_t v41 = v19;
      CFDictionaryRef result = (uint64_t)sub_1DC385238(&v98);
      a4 = 0;
      BOOL v9 = a2;
    }
    else
    {
LABEL_24:
      atomic_fetch_add_explicit(v19 + 2, 1u, memory_order_relaxed);
LABEL_25:
      long long v98 = v19;
      float v21 = *((float *)v19 + 12);
      float v22 = v8;
      do
      {
        float v23 = v22;
        uint64_t v24 = v22[1];
        ++v22;
      }
      while (*((float *)v24 + 12) > v21);
      if (v23 == v8)
      {
        CFStringRef v18 = a2;
        do
        {
          if (v22 >= v18) {
            break;
          }
          uint64_t v26 = (uint64_t)*--v18;
        }
        while (*(float *)(v26 + 48) <= v21);
      }
      else
      {
        do
          uint64_t v25 = (uint64_t)*--v18;
        while (*(float *)(v25 + 48) <= v21);
      }
      uint64_t v11 = v22;
      if (v22 < v18)
      {
        float v27 = v18;
        do
        {
          sub_1DC3855A8(v11, v27);
          double v19 = v98;
          float v28 = *((float *)v98 + 12);
          do
          {
            float v29 = v11[1];
            ++v11;
          }
          while (*((float *)v29 + 12) > v28);
          do
            uint64_t v30 = (uint64_t)*--v27;
          while (*(float *)(v30 + 48) <= v28);
        }
        while (v11 < v27);
      }
      int v31 = v11 - 1;
      if (v11 - 1 != v8)
      {
        CGAffineTransform v32 = *v31;
        if (*v31) {
          atomic_fetch_add_explicit(v32 + 2, 1u, memory_order_relaxed);
        }
        if (*v8) {
          sub_1DC2FF57C(*v8);
        }
        long long *v8 = v32;
        double v19 = v98;
      }
      if (v19) {
        atomic_fetch_add_explicit(v19 + 2, 1u, memory_order_relaxed);
      }
      if (*v31) {
        sub_1DC2FF57C(*v31);
      }
      *int v31 = v19;
      sub_1DC385238(&v98);
      BOOL v4 = v22 >= v18;
      BOOL v9 = a2;
      if (!v4) {
        goto LABEL_53;
      }
      char v33 = sub_1DC3858E8(v8, v11 - 1);
      CFDictionaryRef result = sub_1DC3858E8(v11, a2);
      if (result)
      {
        a2 = v11 - 1;
        if (v33) {
          return result;
        }
        goto LABEL_2;
      }
      if ((v33 & 1) == 0)
      {
LABEL_53:
        CFDictionaryRef result = sub_1DC3847D4(v8, v11 - 1, a3, a4 & 1);
        a4 = 0;
      }
    }
  }
  if (v8 != v9)
  {
    int64_t v56 = (unint64_t)(v13 - 2) >> 1;
    int64_t v57 = v56;
    do
    {
      int64_t v58 = v57;
      if (v56 >= v57)
      {
        uint64_t v59 = (2 * v57) | 1;
        uint64_t v60 = &v8[v59];
        if (2 * v58 + 2 < v13 && *((float *)*v60 + 12) > *((float *)v60[1] + 12))
        {
          ++v60;
          uint64_t v59 = 2 * v58 + 2;
        }
        int v61 = &v8[v58];
        float v62 = *v61;
        if (*((float *)*v60 + 12) <= *((float *)*v61 + 12))
        {
          atomic_fetch_add_explicit(v62 + 2, 1u, memory_order_relaxed);
          long long v98 = v62;
          unsigned int v63 = *v60;
          while (1)
          {
            float v64 = v60;
            if (v63) {
              atomic_fetch_add_explicit(v63 + 2, 1u, memory_order_relaxed);
            }
            if (*v61) {
              sub_1DC2FF57C(*v61);
            }
            *int v61 = v63;
            if (v56 < v59) {
              break;
            }
            uint64_t v65 = 2 * v59;
            uint64_t v59 = (2 * v59) | 1;
            uint64_t v60 = &v8[v59];
            uint64_t v66 = v65 + 2;
            if (v66 < v13 && *((float *)*v60 + 12) > *((float *)v60[1] + 12))
            {
              ++v60;
              uint64_t v59 = v66;
            }
            unsigned int v63 = *v60;
            float v67 = v98;
            int v61 = v64;
            if (*((float *)*v60 + 12) > *((float *)v98 + 12)) {
              goto LABEL_132;
            }
          }
          float v67 = v98;
          if (v98) {
LABEL_132:
          }
            atomic_fetch_add_explicit(v67 + 2, 1u, memory_order_relaxed);
          if (*v64) {
            sub_1DC2FF57C(*v64);
          }
          *float v64 = v67;
          sub_1DC385238(&v98);
        }
      }
      int64_t v57 = v58 - 1;
    }
    while (v58);
    uint64_t v68 = (unint64_t)v12 >> 3;
    while (2)
    {
      unint64_t v69 = *v8;
      if (*v8) {
        atomic_fetch_add_explicit(v69 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v70 = 0;
      unint64_t v97 = v69;
      float v71 = v8;
LABEL_141:
      BOOL v72 = &v71[v70];
      size_t v75 = v72[1];
      unint64_t v73 = v72 + 1;
      unint64_t v74 = v75;
      uint64_t v76 = 2 * v70;
      uint64_t v70 = (2 * v70) | 1;
      uint64_t v77 = v76 + 2;
      if (v77 >= v68)
      {
        if (v74) {
          goto LABEL_145;
        }
      }
      else
      {
        unint64_t v78 = v73[1];
        if (*((float *)v74 + 12) > *((float *)v78 + 12))
        {
          uint64_t v70 = v77;
          ++v73;
          unint64_t v74 = v78;
        }
LABEL_145:
        atomic_fetch_add_explicit(v74 + 2, 1u, memory_order_relaxed);
      }
      if (*v71) {
        sub_1DC2FF57C(*v71);
      }
      *float v71 = v74;
      float v71 = v73;
      if (v70 > (uint64_t)((unint64_t)(v68 - 2) >> 1))
      {
        uint64_t v79 = a2 - 1;
        BOOL v5 = v73 == --a2;
        if (v5)
        {
          unint64_t v89 = v97;
          if (v97) {
            atomic_fetch_add_explicit(v97 + 2, 1u, memory_order_relaxed);
          }
          if (*v73) {
            sub_1DC2FF57C(*v73);
          }
          *unint64_t v73 = v89;
        }
        else
        {
          unint64_t v80 = *v79;
          if (*v79) {
            atomic_fetch_add_explicit(v80 + 2, 1u, memory_order_relaxed);
          }
          if (*v73) {
            sub_1DC2FF57C(*v73);
          }
          *unint64_t v73 = v80;
          uint64_t v81 = v97;
          if (v97) {
            atomic_fetch_add_explicit(v97 + 2, 1u, memory_order_relaxed);
          }
          if (*a2) {
            sub_1DC2FF57C(*a2);
          }
          *a2 = v81;
          uint64_t v82 = (char *)v73 - (char *)v8 + 8;
          if (v82 >= 9)
          {
            unint64_t v83 = (((unint64_t)v82 >> 3) - 2) >> 1;
            long long v84 = &v8[v83];
            long long v85 = *v73;
            if (*((float *)*v84 + 12) > *((float *)*v73 + 12))
            {
              atomic_fetch_add_explicit(v85 + 2, 1u, memory_order_relaxed);
              long long v98 = v85;
              long long v86 = *v84;
              while (1)
              {
                int v87 = v84;
                if (v86) {
                  atomic_fetch_add_explicit(v86 + 2, 1u, memory_order_relaxed);
                }
                if (*v73) {
                  sub_1DC2FF57C(*v73);
                }
                *unint64_t v73 = v86;
                if (!v83) {
                  break;
                }
                unint64_t v83 = (v83 - 1) >> 1;
                long long v84 = &v8[v83];
                long long v86 = *v84;
                int v88 = v98;
                unint64_t v73 = v87;
                if (*((float *)*v84 + 12) <= *((float *)v98 + 12)) {
                  goto LABEL_174;
                }
              }
              int v88 = v98;
              if (!v98) {
                goto LABEL_175;
              }
LABEL_174:
              atomic_fetch_add_explicit(v88 + 2, 1u, memory_order_relaxed);
LABEL_175:
              if (*v87) {
                sub_1DC2FF57C(*v87);
              }
              int *v87 = v88;
              sub_1DC385238(&v98);
            }
          }
        }
        CFDictionaryRef result = (uint64_t)sub_1DC385238(&v97);
        if (v68-- <= 2) {
          return result;
        }
        continue;
      }
      goto LABEL_141;
    }
  }
  return result;
}

void sub_1DC385140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1DC385238((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void *sub_1DC3851B8(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DC2FFD3C(a1, a2);
    BOOL v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1DC385224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

atomic_uint **sub_1DC385238(atomic_uint **a1)
{
  CFAllocatorRef v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t *sub_1DC38526C(uint64_t *result, int a2, int a3)
{
  BOOL v4 = result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (void *)v5;
        int v8 = *(_DWORD *)(v5 + 28);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = result + 1;
LABEL_9:
    BOOL v9 = operator new(0x20uLL);
    v9[7] = a3;
    *(void *)BOOL v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    atomic_ullong *v6 = (uint64_t *)v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      *BOOL v4 = v10;
      uint64_t v11 = *v6;
    }
    else
    {
      uint64_t v11 = (uint64_t *)v9;
    }
    CFDictionaryRef result = sub_1DC311DD0((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

void *sub_1DC385324(void *a1, uint64_t a2)
{
  *a1 = &unk_1F36619D8;
  uint64_t v3 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1DC312750(v3, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    v3[2] = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v3 = v4;
  }
  *a1 = &unk_1F36615F0;
  return a1;
}

void sub_1DC3853AC(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC3853C0(void ***a1)
{
  uint64_t v1 = *a1;
  CFAllocatorRef v2 = (atomic_uint **)**a1;
  if (v2)
  {
    long long v4 = (atomic_uint **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        long long v4 = sub_1DC35D870(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DC385444(void *a1)
{
  if (a1)
  {
    sub_1DC385444(*a1);
    sub_1DC385444(a1[1]);
    sub_1DC31191C((void *)a1[6]);
    operator delete(a1);
  }
}

void sub_1DC385498(void ***a1)
{
  uint64_t v1 = *a1;
  CFAllocatorRef v2 = (atomic_uint **)**a1;
  if (v2)
  {
    long long v4 = (atomic_uint **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        long long v4 = sub_1DC36176C(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DC385520(std::exception *a1)
{
  sub_1DC379B0C(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC385558(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC36176C((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

atomic_uint **sub_1DC3855A8(atomic_uint **a1, atomic_uint **a2)
{
  long long v4 = *a1;
  if (*a1) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  int v8 = v4;
  uint64_t v5 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v6 = *a1;
  if (*a1)
  {
    sub_1DC2FF57C(v6);
    long long v4 = v8;
  }
  *a1 = v5;
  if (v4) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  if (*a2) {
    sub_1DC2FF57C(*a2);
  }
  *a2 = v4;
  return sub_1DC385238(&v8);
}

void sub_1DC385644(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC385238((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC385658(atomic_uint **result, atomic_uint **a2, atomic_uint **a3)
{
  uint64_t v5 = result;
  float v6 = *((float *)*a2 + 12);
  float v7 = *((float *)*a3 + 12);
  if (v6 <= *((float *)*result + 12))
  {
    if (v7 <= v6) {
      return result;
    }
    CFDictionaryRef result = sub_1DC3855A8(a2, a3);
    if (*((float *)*a2 + 12) <= *((float *)*v5 + 12)) {
      return result;
    }
    CFDictionaryRef result = v5;
    int v8 = a2;
  }
  else
  {
    if (v7 <= v6)
    {
      CFDictionaryRef result = sub_1DC3855A8(result, a2);
      if (*((float *)*a3 + 12) <= *((float *)*a2 + 12)) {
        return result;
      }
      CFDictionaryRef result = a2;
    }
    int v8 = a3;
  }
  return sub_1DC3855A8(result, v8);
}

atomic_uint **sub_1DC385734(atomic_uint **a1, atomic_uint **a2, atomic_uint **a3, atomic_uint **a4)
{
  CFDictionaryRef result = sub_1DC385658(a1, a2, a3);
  if (*((float *)*a4 + 12) > *((float *)*a3 + 12))
  {
    CFDictionaryRef result = sub_1DC3855A8(a3, a4);
    if (*((float *)*a3 + 12) > *((float *)*a2 + 12))
    {
      CFDictionaryRef result = sub_1DC3855A8(a2, a3);
      if (*((float *)*a2 + 12) > *((float *)*a1 + 12))
      {
        return sub_1DC3855A8(a1, a2);
      }
    }
  }
  return result;
}

atomic_uint **sub_1DC3857F4(atomic_uint **a1, atomic_uint **a2, atomic_uint **a3, atomic_uint **a4, atomic_uint **a5)
{
  CFDictionaryRef result = sub_1DC385734(a1, a2, a3, a4);
  if (*((float *)*a5 + 12) > *((float *)*a4 + 12))
  {
    CFDictionaryRef result = sub_1DC3855A8(a4, a5);
    if (*((float *)*a4 + 12) > *((float *)*a3 + 12))
    {
      CFDictionaryRef result = sub_1DC3855A8(a3, a4);
      if (*((float *)*a3 + 12) > *((float *)*a2 + 12))
      {
        CFDictionaryRef result = sub_1DC3855A8(a2, a3);
        if (*((float *)*a2 + 12) > *((float *)*a1 + 12))
        {
          return sub_1DC3855A8(a1, a2);
        }
      }
    }
  }
  return result;
}

uint64_t sub_1DC3858E8(atomic_uint **a1, atomic_uint **a2)
{
  BOOL v4 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      if (*((float *)*(a2 - 1) + 12) > *((float *)*a1 + 12)) {
        sub_1DC3855A8(a1, a2 - 1);
      }
      return v4;
    case 3:
      sub_1DC385658(a1, a1 + 1, a2 - 1);
      return v4;
    case 4:
      sub_1DC385734(a1, a1 + 1, a1 + 2, a2 - 1);
      return v4;
    case 5:
      sub_1DC3857F4(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return v4;
    default:
      uint64_t v5 = a1 + 2;
      sub_1DC385658(a1, a1 + 1, a1 + 2);
      float v6 = a1 + 3;
      BOOL v4 = 1;
      if (a1 + 3 == a2) {
        return v4;
      }
      int v7 = 0;
      uint64_t v8 = -16;
      break;
  }
  while (1)
  {
    BOOL v9 = *v6;
    if (*((float *)*v6 + 12) > *((float *)*v5 + 12)) {
      break;
    }
LABEL_21:
    uint64_t v5 = v6;
    v8 -= 8;
    if (++v6 == a2) {
      return 1;
    }
  }
  unint64_t v10 = 0;
  atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
  uint64_t v16 = v9;
  uint64_t v11 = *v5;
  while (1)
  {
    if (v11) {
      atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v12 = v6[v10 / 8];
    if (v12) {
      sub_1DC2FF57C(v12);
    }
    v6[v10 / 8] = v11;
    uint64_t v13 = v16;
    if (v8 == v10) {
      break;
    }
    uint64_t v11 = v6[v10 / 8 - 2];
    v10 -= 8;
    if (*((float *)v16 + 12) <= *((float *)v11 + 12))
    {
      unint64_t v14 = &v6[v10 / 8];
      goto LABEL_16;
    }
  }
  unint64_t v14 = a1;
  if (!v16) {
    goto LABEL_17;
  }
LABEL_16:
  atomic_fetch_add_explicit(v16 + 2, 1u, memory_order_relaxed);
LABEL_17:
  if (*v14) {
    sub_1DC2FF57C(*v14);
  }
  __CFString *v14 = v13;
  if (++v7 != 8)
  {
    sub_1DC385238(&v16);
    goto LABEL_21;
  }
  BOOL v4 = v6 + 1 == a2;
  sub_1DC385238(&v16);
  return v4;
}

void sub_1DC385AE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC385238((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC385B18(void *a1, long long *a2)
{
  BOOL v4 = (atomic_uint *)a1[2];
  if (v4)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = 0;
  }
  float v20 = v5;
  CFStringRef v18 = v4;
  float v6 = (atomic_uint *)*((void *)a2 + 3);
  if (v6) {
    atomic_fetch_add_explicit(v6 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v17 = v6;
  sub_1DC38EFEC((uint64_t)v19, v4, (uint64_t *)&v17);
  sub_1DC3122B8(&v17);
  sub_1DC2FF548(&v18);
  sub_1DC3865CC((uint64_t)v19, (int *)a2, (uint64_t)v13, v7);
  long long v10 = *a2;
  char v11 = *((unsigned char *)a2 + 16);
  uint64_t v8 = (atomic_uint *)*((void *)a2 + 3);
  if (v8) {
    atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v12 = v8;
  (*(void (**)(void *, unsigned char *, long long *))(*a1 + 32))(a1, v13, &v10);
  sub_1DC3122B8(&v12);
  float v21 = (void **)&v16;
  sub_1DC3853C0(&v21);
  float v21 = (void **)&v15;
  sub_1DC3853C0(&v21);
  float v21 = (void **)&v14;
  sub_1DC312234(&v21);
  float v21 = (void **)v13;
  sub_1DC385CD0(&v21);
  sub_1DC38EF24((uint64_t)v19);
  return sub_1DC2FF548(&v20);
}

void sub_1DC385C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  sub_1DC3122B8(v28);
  sub_1DC385D54(&a14);
  sub_1DC38EF24((uint64_t)&a28);
  sub_1DC2FF548((atomic_uint **)(v29 - 64));
  _Unwind_Resume(a1);
}

void sub_1DC385CD0(void ***a1)
{
  uint64_t v1 = *a1;
  CFAllocatorRef v2 = (atomic_uint **)**a1;
  if (v2)
  {
    BOOL v4 = (atomic_uint **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        BOOL v4 = sub_1DC385238(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void **sub_1DC385D54(void **a1)
{
  CFAllocatorRef v2 = a1 + 6;
  BOOL v4 = a1 + 9;
  sub_1DC3853C0(&v4);
  BOOL v4 = v2;
  sub_1DC3853C0(&v4);
  BOOL v4 = a1 + 3;
  sub_1DC312234(&v4);
  BOOL v4 = a1;
  sub_1DC385CD0(&v4);
  return a1;
}

void sub_1DC385DBC(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661868;
  uint64_t v1 = (atomic_uint **)(a1 + 16);
  sub_1DC3122B8((atomic_uint **)(a1 + 24));
  sub_1DC2FF548(v1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC385E30(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661868;
  CFAllocatorRef v2 = (atomic_uint **)(a1 + 16);
  sub_1DC3122B8((atomic_uint **)(a1 + 24));
  sub_1DC2FF548(v2);
  return a1;
}

uint64_t sub_1DC385E84(const void *a1)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFNumberGetTypeID()
    && !CFNumberIsFloatType((CFNumberRef)a1)
    && CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, v7))
  {
    unsigned __int8 v3 = v7[0];
    unsigned int v5 = v7[0] & 0xFFFFFF00;
    if (HIDWORD(v7[0]))
    {
      unsigned __int8 v3 = 0;
      uint64_t v4 = 0;
    }
    else
    {
      uint64_t v4 = 0x100000000;
    }
    if (HIDWORD(v7[0])) {
      unsigned int v5 = 0;
    }
  }
  else
  {
    unsigned __int8 v3 = 0;
    uint64_t v4 = 0;
    unsigned int v5 = 0;
  }
  return v4 & 0x100000000 | v3 | v5 & 0xFFFFFF00;
}

unint64_t sub_1DC385F4C(const void *a1)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFNumberGetTypeID() && !CFNumberIsFloatType((CFNumberRef)a1))
  {
    int Value = CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, v7);
    unint64_t v4 = v7[0] & 0xFFFFFFFFFFFFFF00;
    uint64_t v3 = LOBYTE(v7[0]);
    if (!Value)
    {
      unint64_t v4 = 0;
      uint64_t v3 = 0;
    }
  }
  else
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
  }
  return v4 | v3;
}

unint64_t sub_1DC386000(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFNumberGetTypeID() && !CFNumberIsFloatType((CFNumberRef)a1))
  {
    BOOL v5 = CFNumberGetValue((CFNumberRef)a1, kCFNumberMaxType|kCFNumberSInt8Type, &v9) != 0;
    BOOL v6 = v9 == 0;
    BOOL v7 = !v5 || !v6;
    if (v5 && v6) {
      unint64_t v4 = v10 & 0xFFFFFFFFFFFFFF00;
    }
    else {
      unint64_t v4 = 0;
    }
    if (v7) {
      uint64_t v3 = 0;
    }
    else {
      uint64_t v3 = v10;
    }
  }
  else
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
  }
  return v4 | v3;
}

uint64_t sub_1DC386094(const void *a1)
{
  v6[1] = *(double *)MEMORY[0x1E4F143B8];
  double v1 = 0.0;
  if (!a1) {
    return *(void *)&v1;
  }
  CFTypeID v3 = CFGetTypeID(a1);
  if (v3 != CFNumberGetTypeID()) {
    return *(void *)&v1;
  }
  if ((const void *)*MEMORY[0x1E4F1D3A8] == a1
    || CFNumberCompare((CFNumberRef)a1, (CFNumberRef)*MEMORY[0x1E4F1D3A8], 0) == kCFCompareEqualTo)
  {
    double v4 = INFINITY;
LABEL_17:
    double v1 = v4;
    return *(void *)&v1;
  }
  if ((const void *)*MEMORY[0x1E4F1D3A0] == a1
    || CFNumberCompare((CFNumberRef)a1, (CFNumberRef)*MEMORY[0x1E4F1D3A0], 0) == kCFCompareEqualTo)
  {
    double v4 = -INFINITY;
    goto LABEL_17;
  }
  if ((const void *)*MEMORY[0x1E4F1D398] == a1
    || CFNumberCompare((CFNumberRef)a1, (CFNumberRef)*MEMORY[0x1E4F1D398], 0) == kCFCompareEqualTo)
  {
    double v4 = NAN;
    goto LABEL_17;
  }
  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, v6))
  {
    if (v6[0] >= -1.79769313e308 && v6[0] <= 1.79769313e308) {
      double v1 = v6[0];
    }
    else {
      double v1 = 0.0;
    }
  }
  return *(void *)&v1;
}

CFStringRef sub_1DC3861F0(UInt8 *bytes, CFIndex numBytes)
{
  if (numBytes) {
    return CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, numBytes, 0x8000100u, 0);
  }
  else {
    return (CFStringRef)CFRetain(&stru_1F3665D38);
  }
}

CFStringRef sub_1DC386224(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFStringGetTypeID()) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  return CFStringCreateCopy(v3, a1);
}

CFDictionaryRef sub_1DC38628C(const void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFDictionaryGetTypeID() || !CFPropertyListIsValid(a1, kCFPropertyListBinaryFormat_v1_0)) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  return CFDictionaryCreateCopy(v3, (CFDictionaryRef)a1);
}

CFDictionaryRef sub_1DC386304(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFDictionaryGetTypeID()) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  return CFDictionaryCreateCopy(v3, (CFDictionaryRef)a1);
}

uint64_t sub_1DC386368(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFBooleanGetTypeID())
  {
    BOOL v3 = CFBooleanGetValue((CFBooleanRef)a1) != 0;
    int v4 = 1;
  }
  else
  {
    BOOL v3 = 0;
    int v4 = 0;
  }
  return v3 | (v4 << 8);
}

const void **sub_1DC3863C0(const void **a1)
{
  CFTypeID v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1DC3863F4(CFDictionaryRef *a1, const __CFString *cf, const void *a3)
{
  if (!*a1) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFStringGetTypeID()) {
    return 0;
  }
  uint64_t result = CFStringGetLength(cf);
  if (!result) {
    return result;
  }
  if (CFDictionaryContainsKey(*a1, cf)) {
    return 0;
  }
  uint64_t result = CFPropertyListIsValid(a3, kCFPropertyListBinaryFormat_v1_0);
  if (result)
  {
    CFDictionarySetValue(*a1, cf, a3);
    return 1;
  }
  return result;
}

CFDictionaryRef *sub_1DC38648C(CFDictionaryRef *a1, const __CFDictionary *cf)
{
  if (cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == CFDictionaryGetTypeID())) {
    CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cf);
  }
  else {
    CFDictionaryRef Copy = 0;
  }
  *a1 = Copy;
  return a1;
}

const void **sub_1DC3864F8(const void **a1)
{
  CFTypeID v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

CFTypeRef sub_1DC38652C(CFDictionaryRef *a1, const __CFString *cf)
{
  if (!*a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID()) {
    return 0;
  }
  if (!CFStringGetLength(cf)) {
    return 0;
  }
  int Value = CFDictionaryGetValue(*a1, cf);
  if (!Value) {
    return 0;
  }
  CFTypeID v6 = Value;
  if (!CFPropertyListIsValid(Value, kCFPropertyListBinaryFormat_v1_0)) {
    return 0;
  }
  return CFRetain(v6);
}

atomic_uint **sub_1DC3865CC@<X0>(uint64_t a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, __n128 a4@<Q0>)
{
  CFTypeID v4 = a2;
  uint64_t v78 = a3;
  v111[8] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 176) = a2[1];
  CFTypeID v6 = *(atomic_uint **)(a1 + 8);
  uint64_t v94 = a1 + 8;
  if (v6) {
    atomic_fetch_add_explicit(v6 + 2, 1u, memory_order_relaxed);
  }
  v77[1] = v77;
  memset(v105, 0, sizeof(v105));
  float v106 = v6;
  memset(v104, 0, sizeof(v104));
  MEMORY[0x1F4188790](a4);
  int v11 = v10 & v9 | v8 & v7;
  BOOL v13 = v12 < 0 || (int)(float)((float)((float)v11 / 228.0) * 3.0) < 3;
  uint64_t v96 = v74;
  uint64_t v75 = 0;
  *(void *)&v74[492] = 0;
  int v76 = 0;
  if (v13) {
    int v14 = 3;
  }
  else {
    int v14 = (int)(float)((float)((float)v11 / 228.0) * 3.0);
  }
  if (v14 > v11) {
    goto LABEL_63;
  }
  uint64_t v85 = v8 & v9 | v10 & v7;
  uint64_t v90 = (int)v85;
  uint64_t v15 = v14 - 1;
  uint64_t v79 = v11;
  uint64_t v80 = v14;
  int v88 = v111;
  uint64_t v81 = a1 + 152;
  uint64_t v82 = a1 + 128;
  long long v86 = xmmword_1DC3FDCA0;
  unint64_t v89 = v4;
  uint64_t v87 = a1;
  do
  {
    int v16 = 0;
    uint64_t v17 = *((void *)v106 + 6);
    unint64_t v18 = ((*((void *)v106 + 2) + ~v15) & -*((void *)v106 + 7))
        + ((*((void *)v106 + 4) - 1) & -*((void *)v106 + 7) | (*((void *)v106 + 7) - 1) & v15)
        * *((void *)v106 + 3);
    double v19 = v96;
    v96[2] = 0;
    int v20 = *(_DWORD *)(v17 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFFCLL));
    *double v19 = 0;
    BOOL v21 = ((1 << v18) & v20) == 0;
    uint64_t v22 = 0;
    int v23 = !v21;
    int v93 = v23;
    if (v21) {
      int v24 = 3;
    }
    else {
      int v24 = 2;
    }
    uint64_t v91 = v15;
    uint64_t v92 = (int)v15;
    while (2)
    {
      if ((int)v22 >= (int)v85)
      {
        uint64_t v84 = v22;
        goto LABEL_37;
      }
      unint64_t v25 = v24;
      uint64_t v26 = v106;
      while (2)
      {
        uint64_t v27 = 0;
        v96[v25] = 0;
        uint64_t v28 = (int)v22;
        while (1)
        {
          char v29 = sub_1DC2FF924(v26, v28 + v27, v91);
          if ((v93 & 1) == 0) {
            break;
          }
          if ((v29 & 1) == 0) {
            goto LABEL_27;
          }
LABEL_25:
          v96[v25] = ++v27;
          if (v28 + v27 >= v90)
          {
            if ((int)v28 + 1 > (int)v85) {
              uint64_t v32 = (v28 + 1);
            }
            else {
              uint64_t v32 = v85;
            }
            uint64_t v84 = v32;
            v93 ^= 1u;
            int v24 = v25 + 1;
            goto LABEL_36;
          }
        }
        if ((v29 & 1) == 0) {
          goto LABEL_25;
        }
LABEL_27:
        uint64_t v22 = v28 + v27;
        v93 ^= 1u;
        int v24 = v25 + 1;
        if (v25 <= 0x79)
        {
          ++v25;
          if ((int)v22 < (int)v85) {
            continue;
          }
        }
        break;
      }
      uint64_t v84 = v22;
      if ((int)v22 < (int)v85)
      {
        int v83 = 1;
        unsigned int v31 = 114;
        CFTypeID v4 = v89;
        goto LABEL_41;
      }
LABEL_36:
      CFTypeID v4 = v89;
LABEL_37:
      int v33 = v24 + 4;
      if (__OFSUB__(v24, v24 + 4)) {
        int v33 = v24;
      }
      bzero(&v96[v24], 4 * (v33 - v24) + 4);
      if (v24 >= 7)
      {
        int v83 = 0;
        unsigned int v31 = v24 - 4;
LABEL_41:
        CGAffineTransform v34 = v96;
        int v97 = *v96 + v16;
        uint64_t v95 = v31;
        uint64_t v35 = 2;
        do
        {
          uint64_t v36 = (uint64_t)&v96[v35];
          v97 += *(_DWORD *)(v36 - 4);
          if ((*(_WORD *)v4 & 0x802) != 0)
          {
            sub_1DC3A6B34(v36, v30);
            if (v30.n128_f32[0] > -0.75)
            {
              uint64_t v37 = 2;
              int v38 = v97;
              do
                v38 += v34[v37++];
              while (v37 != 7);
              sub_1DC3A7A48();
            }
          }
          if ((*((unsigned char *)v4 + 1) & 4) != 0)
          {
            v30.n128_f32[0] = sub_1DC3A6D54((uint64_t)&v96[v35]);
            if (v30.n128_f32[0] > -0.9)
            {
              uint64_t v39 = 0;
              int v40 = v97;
              do
              {
                int v41 = v34[v39 + 2];
                *(_DWORD *)((char *)&v111[3] + v39 * 4 + 4) = v41;
                v40 += v41;
                ++v39;
              }
              while (v39 != 9);
              operator new();
            }
          }
          ++v35;
          ++v34;
        }
        while (v35 != v95);
        if (v83)
        {
          int v42 = 0;
          if (v93) {
            uint64_t v43 = 12;
          }
          else {
            uint64_t v43 = 11;
          }
          int v24 = v43;
          uint64_t v44 = 111;
          if ((v93 & 1) == 0) {
            uint64_t v44 = 112;
          }
          uint64_t v45 = v96;
          do
          {
            int v46 = v45[v44];
            *v45++ = v46;
            v42 += v46;
            --v43;
          }
          while (v43);
          uint64_t v22 = v84;
          int v16 = v84 - v42;
          continue;
        }
      }
      break;
    }
    uint64_t v15 = v91 + v80;
  }
  while (v91 + v80 < v79);
LABEL_63:
  int v47 = *v4;
  if ((*v4 & 0x802) != 0)
  {
    if (qword_1EBFFC290 != -1) {
      dispatch_once(&qword_1EBFFC290, &unk_1F3662568);
    }
    uint64_t v48 = qword_1EBFFC298;
    BOOL v49 = os_log_type_enabled((os_log_t)qword_1EBFFC298, OS_LOG_TYPE_DEBUG);
    uint64_t v50 = v78;
    if (v49)
    {
      uint64_t v72 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
      uint64_t v73 = (uint64_t)(*(void *)(a1 + 136) - *(void *)(a1 + 128)) >> 3;
      LODWORD(v109[0]) = 134349824;
      *(void ***)((char *)v109 + 4) = (void **)v72;
      WORD2(v109[1]) = 2050;
      *(void ***)((char *)&v109[1] + 6) = (void **)v73;
      HIWORD(v109[2]) = 2050;
      v109[3] = (void **)0xBFE0000000000000;
      LOWORD(v110) = 2050;
      *(void *)((char *)&v110 + 2) = 0xBFE8000000000000;
      _os_log_debug_impl(&dword_1DC2FE000, v48, OS_LOG_TYPE_DEBUG, "FPCentersNum=(%{public}lu, %{public}lu) for threshold=(%{public}.2f, %{public}.2f)", (uint8_t *)v109, 0x2Au);
    }
    sub_1DC3876D4(a1, (uint64_t *)(a1 + 128), a1 + 16, *(void *)(a1 + 176));
    sub_1DC3876D4(a1, (uint64_t *)(a1 + 152), a1 + 64, *(void *)(a1 + 176));
    int v47 = *v4;
    uint64_t v101 = 0;
    uint64_t v102 = 0;
    uint64_t v103 = 0;
    if ((v47 & 2) != 0)
    {
      sub_1DC387854(a1, a1 + 16);
      sub_1DC387854(a1, a1 + 64);
      int v47 = *v4;
    }
  }
  else
  {
    uint64_t v101 = 0;
    uint64_t v102 = 0;
    uint64_t v103 = 0;
    uint64_t v50 = v78;
  }
  long long v110 = 0u;
  memset(v109, 0, sizeof(v109));
  if ((v47 & 0x800) != 0)
  {
    sub_1DC389370(a1, *(atomic_uint ***)(a1 + 16), *(atomic_uint ***)(a1 + 24), (uint64_t)v109, 0);
    sub_1DC389370(a1, *(atomic_uint ***)(a1 + 64), *(atomic_uint ***)(a1 + 72), (uint64_t)&v109[3], 1);
    int v47 = *v4;
  }
  long long v98 = 0;
  long long v99 = 0;
  uint64_t v100 = 0;
  if ((v47 & 0x400) != 0)
  {
    unint64_t v51 = *(atomic_uint ***)(a1 + 40);
    unint64_t v52 = (uint64_t)(*(void *)(a1 + 48) - (void)v51) >> 3;
    if (v52 >= *(void *)(a1 + 176)) {
      unint64_t v52 = *(void *)(a1 + 176);
    }
    sub_1DC3895F4(v51, &v51[v52], (uint64_t)&v98);
    CGRect v53 = *(atomic_uint ***)(a1 + 88);
    unint64_t v54 = (uint64_t)(*(void *)(a1 + 96) - (void)v53) >> 3;
    if (v54 >= *(void *)(a1 + 176)) {
      unint64_t v54 = *(void *)(a1 + 176);
    }
    sub_1DC3895F4(v53, &v53[v54], (uint64_t)&v98);
  }
  *(void *)uint64_t v50 = 0;
  *(void *)(v50 + 8) = 0;
  *(void *)(v50 + 16) = 0;
  uint64_t v55 = v101;
  uint64_t v56 = v102;
  float v107 = (void ***)v50;
  char v108 = 0;
  uint64_t v57 = v102 - v101;
  if (v102 != v101)
  {
    if (v57 < 0) {
      sub_1DC2FF97C();
    }
    int64_t v58 = (char *)sub_1DC2FFD7C(v57 >> 3);
    uint64_t v59 = 0;
    *(void *)uint64_t v50 = v58;
    *(void *)(v50 + 8) = v58;
    *(void *)(v50 + 16) = &v58[8 * v60];
    do
    {
      int v61 = (atomic_uint **)&v58[v59];
      *(void *)&v58[v59] = 0;
      uint64_t v62 = *(void *)(v55 + v59);
      if (v62)
      {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v62 + 8), 1u, memory_order_relaxed);
        if (*v61) {
          sub_1DC2FF57C(*v61);
        }
      }
      *(void *)&v58[v59] = v62;
      v59 += 8;
    }
    while (v55 + v59 != v56);
    *(void *)(v50 + 8) = &v58[v59];
  }
  *(void *)(v50 + 24) = 0;
  *(void *)(v50 + 32) = 0;
  *(void *)(v50 + 40) = 0;
  unsigned int v63 = (void **)v98;
  float v64 = v99;
  float v107 = (void ***)(v50 + 24);
  char v108 = 0;
  uint64_t v65 = (char *)v99 - (char *)v98;
  if (v99 != (void **)v98)
  {
    if (v65 < 0) {
      sub_1DC2FF97C();
    }
    uint64_t v66 = (char *)sub_1DC2FFD7C(v65 >> 3);
    unint64_t v67 = 0;
    *(void *)(v50 + 24) = v66;
    *(void *)(v50 + 32) = v66;
    *(void *)(v50 + 40) = &v66[8 * v68];
    do
    {
      unint64_t v69 = (atomic_uint **)&v66[v67];
      *(void *)&v66[v67] = 0;
      uint64_t v70 = (atomic_uint *)v63[v67 / 8];
      if (v70)
      {
        atomic_fetch_add_explicit(v70 + 2, 1u, memory_order_relaxed);
        if (*v69) {
          sub_1DC2FF57C(*v69);
        }
      }
      *(void *)&v66[v67] = v70;
      v67 += 8;
    }
    while (&v63[v67 / 8] != v64);
    *(void *)(v50 + 32) = &v66[v67];
  }
  *(void *)(v50 + 48) = 0;
  *(void *)(v50 + 56) = 0;
  *(void *)(v50 + 64) = 0;
  sub_1DC3896B4((atomic_uint *)(v50 + 48), (uint64_t)v109[0], (uint64_t)v109[1], v109[1] - v109[0]);
  *(void *)(v50 + 72) = 0;
  *(void *)(v50 + 80) = 0;
  *(void *)(v50 + 88) = 0;
  sub_1DC3896B4((atomic_uint *)(v50 + 72), (uint64_t)v109[3], v110, (uint64_t)(v110 - (unint64_t)v109[3]) >> 3);
  float v107 = (void ***)&v98;
  sub_1DC312234((void ***)&v107);
  long long v98 = &v109[3];
  sub_1DC3853C0((void ***)&v98);
  long long v98 = v109;
  sub_1DC3853C0((void ***)&v98);
  v109[0] = (void **)&v101;
  sub_1DC385CD0(v109);
  v109[0] = (void **)v104;
  sub_1DC2FF82C(v109);
  v109[0] = (void **)v105;
  sub_1DC2FF82C(v109);
  return sub_1DC2FF548(&v106);
}

void sub_1DC3875B4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 368) = v1 + 232;
  sub_1DC2FF82C((void ***)(v1 + 368));
  *(void *)(v1 + 368) = v1 + 256;
  sub_1DC2FF82C((void ***)(v1 + 368));
  sub_1DC2FF548((atomic_uint **)(v1 + 280));
  _Unwind_Resume(a1);
}

void sub_1DC3876D4(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = *(void *)a3;
  uint64_t v8 = *(atomic_uint ***)(a3 + 8);
  uint64_t v9 = (uint64_t)v8 - *(void *)a3;
  if ((unint64_t)v9 > 0x3F)
  {
    unint64_t v20 = v9 >> 3;
    if (v20 > a4)
    {
      unint64_t v21 = 126 - 2 * __clz(v20);
      if (v8 == (atomic_uint **)v7) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = v21;
      }
      sub_1DC38DF94(v7, v8, v22, 1);
      sub_1DC38DE74((atomic_uint *)a3, a4);
    }
  }
  else
  {
    uint64_t v10 = (atomic_uint **)a2[1];
    unint64_t v11 = 126 - 2 * __clz(((uint64_t)v10 - *a2) >> 3);
    if (v10 == (atomic_uint **)*a2) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = v11;
    }
    sub_1DC38D4E4(*a2, v10, v12, 1);
    unint64_t v13 = (a2[1] - *a2) >> 3;
    unint64_t v14 = *(void *)(a1 + 176);
    if (v13 > v14)
    {
      sub_1DC38DE74((atomic_uint *)a2, v14);
      unint64_t v13 = *(void *)(a1 + 176);
    }
    if (v13)
    {
      unint64_t v15 = 0;
      uint64_t v16 = a1 + 8;
      do
      {
        if (*(void *)(a3 + 8) - *(void *)a3 > 0x3FuLL) {
          break;
        }
        uint64_t v17 = *a2;
        if (v15 >= (a2[1] - *a2) >> 3) {
          sub_1DC351420();
        }
        int v23 = 0;
        unint64_t v18 = *(atomic_uint **)(v17 + 8 * v15);
        if (v18) {
          atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
        }
        int v23 = v18;
        sub_1DC3A7DC0(v16, &v23, (atomic_uint *)a3);
        sub_1DC35D870(&v23);
        ++v15;
      }
      while (v13 != v15);
    }
  }
}

void sub_1DC387840(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC35D870((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC387854(uint64_t a1, uint64_t a2)
{
  v183[2] = *MEMORY[0x1E4F143B8];
  BOOL v3 = *(atomic_uint ***)(a2 + 8);
  float v154 = (uint64_t *)a2;
  uint64_t result = *(atomic_uint ***)a2;
  uint64_t v5 = (uint64_t)v3 - *(void *)a2;
  unint64_t v6 = v5 >> 3;
  if ((int)(v5 >> 3) >= 3 && *(void *)(a1 + 176) >= (unint64_t)((unint64_t)v5 >> 3))
  {
    char v180 = (void **)sub_1DC38D4C4;
    unint64_t v7 = 126 - 2 * __clz(v6);
    if (v3 == result) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = v7;
    }
    sub_1DC38AB58((uint64_t)result, v3, (uint64_t (**)(atomic_uint **, atomic_uint **))&v180, v8, 1);
    uint64_t v9 = 0;
    uint64_t v133 = (v6 - 2);
    unint64_t v137 = (v6 - 1);
    float v10 = 0.5;
    float v11 = 3.0;
    uint64_t v136 = 1;
    uint64_t v135 = 2;
    int v153 = v6;
    do
    {
      uint64_t v12 = *v154;
      char v162 = 0;
      unint64_t v13 = *(atomic_uint **)(v12 + 8 * v9);
      if (v13) {
        atomic_fetch_add_explicit(v13 + 2, 1u, memory_order_relaxed);
      }
      char v162 = v13;
      uint64_t v134 = v9 + 1;
      if (v9 + 1 >= v137) {
        goto LABEL_146;
      }
      uint64_t v14 = v136;
      uint64_t v144 = v135;
      do
      {
        uint64_t v15 = *v154;
        uint64_t v161 = 0;
        uint64_t v16 = *(void *)(v15 + 8 * v14);
        if (v16) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v16 + 8), 1u, memory_order_relaxed);
        }
        uint64_t v161 = (atomic_uint *)v16;
        float v17 = *((float *)v162 + 5);
        float v18 = *(float *)(v16 + 20);
        if (v18 >= v17) {
          float v19 = *((float *)v162 + 5);
        }
        else {
          float v19 = *(float *)(v16 + 20);
        }
        if (vabds_f32(v17, v18) > v10 && (float)((float)(v17 - v18) / v19) >= 0.05)
        {
          sub_1DC35D870(&v161);
          break;
        }
        uint64_t v143 = v14 + 1;
        if ((int)v14 + 1 >= (int)v6) {
          goto LABEL_143;
        }
        uint64_t v20 = v144;
        while (1)
        {
          uint64_t v21 = *v154;
          unsigned int v160 = 0;
          uint64_t v22 = *(atomic_uint **)(v21 + 8 * v20);
          if (v22) {
            atomic_fetch_add_explicit(v22 + 2, 1u, memory_order_relaxed);
          }
          unsigned int v160 = v22;
          int v23 = v161;
          float v24 = *((float *)v161 + 5);
          float v25 = *((float *)v22 + 5);
          float v26 = v25 >= v24 ? *((float *)v161 + 5) : *((float *)v22 + 5);
          if (vabds_f32(v24, v25) > v10 && (float)((float)(v24 - v25) / v26) >= 0.05) {
            break;
          }
          uint64_t v156 = v20;
          uint64_t v27 = (void **)v162;
          if (v162) {
            atomic_fetch_add_explicit(v162 + 2, 1u, memory_order_relaxed);
          }
          char v180 = v27;
          uint64_t v181 = 0;
          atomic_fetch_add_explicit(v23 + 2, 1u, memory_order_relaxed);
          if (v181)
          {
            sub_1DC2FF57C(v181);
            uint64_t v22 = v160;
            uint64_t v181 = v23;
            std::__fs::filesystem::path v182 = 0;
            if (!v160) {
              goto LABEL_35;
            }
          }
          else
          {
            uint64_t v181 = v23;
            std::__fs::filesystem::path v182 = 0;
          }
          atomic_fetch_add_explicit(v22 + 2, 1u, memory_order_relaxed);
          if (v182) {
            sub_1DC2FF57C(v182);
          }
LABEL_35:
          std::__fs::filesystem::path v182 = v22;
          uint64_t v158 = 0;
          uint64_t v159 = 0;
          uint64_t v157 = 0;
          v173[0] = &v157;
          LOBYTE(v173[1]) = 0;
          uint64_t v157 = (char *)operator new(0x18uLL);
          uint64_t v158 = (atomic_uint **)v157;
          uint64_t v159 = v157 + 24;
          uint64_t v158 = (atomic_uint **)sub_1DC38BC4C((uint64_t)&v180, (uint64_t)v183, (uint64_t)v157);
          for (uint64_t i = 2; i != -1; --i)
            sub_1DC35D870((atomic_uint **)&(&v180)[i]);
          uint64_t v29 = 0;
          __n128 v30 = (float *)v177;
          unsigned int v31 = v157;
          do
          {
            *__n128 v30 = (*(float (**)(void))(**(void **)&v31[8 * v29] + 16))(*(void *)&v31[8 * v29]);
            float v32 = (*(float (**)(void))(**(void **)&v157[8 * v29] + 24))(*(void *)&v157[8 * v29]);
            unsigned int v31 = v157;
            uint64_t v33 = *(void *)&v157[8 * v29];
            int v34 = *(_DWORD *)(v33 + 24);
            v176[v29] = *(float *)(v33 + 20);
            v30[1] = v32;
            *(int *)(v176 + ++v29) = v34;
            v30 += 2;
          }
          while (v29 != 3);
          uint64_t v35 = 0;
          uint64_t v36 = *(void **)(a1 + 8);
          uint64_t v37 = v36[7];
          uint64_t v38 = -v37;
          uint64_t v39 = v36[4];
          uint64_t v40 = v39 & -v37--;
          uint64_t v41 = v36[2];
          float v42 = (float)(v176[0] + v176[1]) + v176[2];
          float v43 = (float)(v41 & v37 | (unint64_t)v40) * v10;
          float v44 = (float)(v39 & v37 | v41 & (unint64_t)v38) * v10;
          do
          {
            uint64_t v45 = (float *)&v177[v35];
            float v46 = v177[v35].f32[1] - v44;
            *uint64_t v45 = v177[v35].f32[0] - v43;
            v45[1] = v46;
            ++v35;
          }
          while (v35 != 3);
          uint64_t v47 = 0;
          int v174 = 0;
          uint64_t v48 = (float *)&v173[1];
          memset(v173, 0, sizeof(v173));
          float v49 = v42 / v11;
          do
          {
            float v50 = v49 / v176[v47];
            *((float32x2_t *)v48 - 1) = vmul_n_f32(v177[v47], v50);
            *uint64_t v48 = v50;
            v48 += 3;
            ++v47;
          }
          while (v47 != 3);
          std::string __p = (void *)0x100000000;
          int v169 = 2;
          unint64_t v51 = (atomic_uint *)*((void *)v31 + 1);
          if (v51) {
            atomic_fetch_add_explicit(v51 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v171 = v51;
          unint64_t v52 = (atomic_uint *)*((void *)v31 + 2);
          if (v52) {
            atomic_fetch_add_explicit(v52 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v167 = v52;
          LODWORD(v178) = sub_1DC3B4C78(&v171, (uint64_t)&v167);
          CGRect v53 = v157;
          unint64_t v54 = *(atomic_uint **)v157;
          if (*(void *)v157) {
            atomic_fetch_add_explicit(v54 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v166 = v54;
          uint64_t v55 = (atomic_uint *)*((void *)v53 + 2);
          if (v55) {
            atomic_fetch_add_explicit(v55 + 2, 1u, memory_order_relaxed);
          }
          int v165 = v55;
          HIDWORD(v178) = sub_1DC3B4C78(&v166, (uint64_t)&v165);
          uint64_t v56 = v157;
          uint64_t v57 = *(atomic_uint **)v157;
          if (*(void *)v157) {
            atomic_fetch_add_explicit(v57 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v164 = v57;
          int64_t v58 = (atomic_uint *)*((void *)v56 + 1);
          if (v58) {
            atomic_fetch_add_explicit(v58 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v163 = v58;
          float v179 = sub_1DC3B4C78(&v164, (uint64_t)&v163);
          sub_1DC2FFD08(&v163);
          sub_1DC2FFD08(&v164);
          sub_1DC2FFD08(&v165);
          sub_1DC2FFD08(&v166);
          sub_1DC2FFD08(&v167);
          sub_1DC2FFD08(&v171);
          char v180 = (void **)&v178;
          sub_1DC38BD54((int *)&__p, &v170, (uint64_t *)&v180, 2, 1);
          int v59 = (int)__p;
          int v60 = HIDWORD(__p);
          uint64_t v61 = v169;
          float v62 = *((float *)&v178 + SHIDWORD(__p));
          float v63 = *(float *)(*(void *)&v157[8 * (int)__p] + 20);
          float v64 = (float)((float)(v62 + v62) / (float)(*(float *)(*(void *)&v157[8 * v169] + 20) + v63)) + 7.0;
          uint64_t v65 = *(float **)&v157[8 * SHIDWORD(__p)];
          float v66 = (float)((float)(*((float *)&v178 + v169) + *((float *)&v178 + v169)) / (float)(v65[5] + v63)) + 7.0;
          if (v64 > 180.0 || v64 < 9.0 || v66 > 180.0 || v66 < 9.0) {
            goto LABEL_140;
          }
          float v70 = vabds_f32(v64, v66);
          if (v66 < v64) {
            float v64 = v66;
          }
          if (v70 > (float)(v64 * 0.8)) {
            goto LABEL_140;
          }
          uint64_t v71 = SHIDWORD(__p);
          uint64_t v72 = (int)__p;
          if (*((float *)&v178 + (int)__p) >= (float)(v62 * 1.1)) {
            goto LABEL_72;
          }
          float v150 = (*(float (**)(float *))(*(void *)v65 + 16))(v65);
          float v147 = (*(float (**)(void))(**(void **)&v157[8 * v61] + 16))(*(void *)&v157[8 * v61]);
          float v145 = (*(float (**)(void))(**(void **)&v157[8 * v59] + 16))(*(void *)&v157[8 * v59]);
          float v142 = (*(float (**)(void))(**(void **)&v157[8 * v60] + 24))(*(void *)&v157[8 * v60]);
          float v141 = (*(float (**)(void))(**(void **)&v157[8 * v61] + 24))(*(void *)&v157[8 * v61]);
          float v73 = (*(float (**)(void))(**(void **)&v157[8 * v59] + 24))(*(void *)&v157[8 * v59]);
          float v140 = (*(float (**)(void))(**(void **)&v157[8 * v59] + 16))(*(void *)&v157[8 * v59]);
          float v139 = (*(float (**)(void))(**(void **)&v157[8 * v61] + 16))(*(void *)&v157[8 * v61]);
          float v138 = (*(float (**)(void))(**(void **)&v157[8 * v60] + 16))(*(void *)&v157[8 * v60]);
          float v74 = (*(float (**)(void))(**(void **)&v157[8 * v59] + 24))(*(void *)&v157[8 * v59]);
          float v75 = (*(float (**)(void))(**(void **)&v157[8 * v61] + 24))(*(void *)&v157[8 * v61]);
          float v76 = (*(float (**)(void))(**(void **)&v157[8 * v60] + 24))(*(void *)&v157[8 * v60]);
          float v77 = (*(float (**)(void))(**(void **)&v157[8 * v61] + 16))(*(void *)&v157[8 * v61]);
          float v78 = (*(float (**)(void))(**(void **)&v157[8 * v61] + 24))(*(void *)&v157[8 * v61]);
          float v79 = sub_1DC38C4E8(a1, (int)(float)((float)(v150 + v147) - v145), (int)(float)((float)(v142 + v141) - v73), (int)v77, (int)v78);
          float v80 = (*(float (**)(void))(**(void **)&v157[8 * v61] + 16))(*(void *)&v157[8 * v61]);
          float v81 = (*(float (**)(void))(**(void **)&v157[8 * v61] + 24))(*(void *)&v157[8 * v61]);
          if (v79 >= sub_1DC38C4E8(a1, (int)(float)((float)(v140 + v139) - v138), (int)(float)((float)(v74 + v75) - v76), (int)v80, (int)v81))
          {
LABEL_72:
            uint64_t v72 = v60;
            uint64_t v71 = v59;
            int v82 = v60;
            int v60 = v59;
          }
          else
          {
            int v82 = v59;
          }
          int v83 = v157;
          float v151 = (*(float (**)(void))(**(void **)&v157[8 * v61] + 16))(*(void *)&v157[8 * v61]);
          float v148 = (*(float (**)(void))(**(void **)&v83[8 * v71] + 16))(*(void *)&v83[8 * v71]);
          float v84 = (*(float (**)(void))(**(void **)&v83[8 * v72] + 24))(*(void *)&v83[8 * v72]);
          float v85 = (*(float (**)(void))(**(void **)&v83[8 * v71] + 24))(*(void *)&v83[8 * v71]);
          float v86 = (*(float (**)(void))(**(void **)&v83[8 * v61] + 24))(*(void *)&v83[8 * v61]);
          float v87 = (*(float (**)(void))(**(void **)&v83[8 * v71] + 24))(*(void *)&v83[8 * v71]);
          float v88 = (*(float (**)(void))(**(void **)&v83[8 * v72] + 16))(*(void *)&v83[8 * v72]);
          float v89 = (float)((float)(v151 - v148) * (float)(v84 - v85))
              - (float)((float)(v86 - v87)
                      * (float)(v88
                              - (*(float (**)(void))(**(void **)&v83[8 * v71] + 16))(*(void *)&v83[8 * v71])));
          if (v89 >= 0.0) {
            int v90 = v82;
          }
          else {
            int v90 = v61;
          }
          if (v89 >= 0.0) {
            int v91 = v61;
          }
          else {
            int v91 = v82;
          }
          uint64_t v92 = (atomic_uint **)v157;
          uint64_t v93 = *(void *)&v157[8 * v90];
          if (v93) {
            atomic_fetch_add_explicit((atomic_uint *volatile)(v93 + 8), 1u, memory_order_relaxed);
          }
          char v180 = (void **)v93;
          uint64_t v94 = v92[v71];
          if (v94) {
            atomic_fetch_add_explicit(v94 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v181 = v94;
          std::__fs::filesystem::path v182 = 0;
          uint64_t v95 = v92[v91];
          float v10 = 0.5;
          float v11 = 3.0;
          if (v95)
          {
            atomic_fetch_add_explicit(v95 + 2, 1u, memory_order_relaxed);
            if (v182)
            {
              sub_1DC2FF57C(v182);
              uint64_t v92 = (atomic_uint **)v157;
            }
          }
          std::__fs::filesystem::path v182 = v95;
          int v152 = v90;
          if ((unint64_t)(v159 - (char *)v92) >= 0x18)
          {
            uint64_t v100 = (char *)v158 - (char *)v92;
            if ((unint64_t)((char *)v158 - (char *)v92) >= 0x18)
            {
              for (uint64_t j = 0; j != 3; ++j)
              {
                uint64_t v130 = (&v180)[j];
                if (v130) {
                  atomic_fetch_add_explicit((atomic_uint *volatile)v130 + 2, 1u, memory_order_relaxed);
                }
                int v131 = v92[j];
                if (v131) {
                  sub_1DC2FF57C(v131);
                }
                v92[j] = (atomic_uint *)v130;
              }
              long long v104 = v92 + 3;
              for (uint64_t k = v158; k != v104; uint64_t k = sub_1DC35D870(k - 1))
                ;
              goto LABEL_105;
            }
            if (v158 != v92)
            {
              int v149 = v91;
              uint64_t v146 = (char *)v158 - (char *)v92;
              uint64_t v101 = 8 * (v100 >> 3);
              uint64_t v102 = &v180;
              do
              {
                uint64_t v103 = (atomic_uint *)*v102;
                if (*v102) {
                  atomic_fetch_add_explicit(v103 + 2, 1u, memory_order_relaxed);
                }
                if (*v92) {
                  sub_1DC2FF57C(*v92);
                }
                *v92++ = v103;
                ++v102;
                v101 -= 8;
              }
              while (v101);
              uint64_t v92 = v158;
              int v91 = v149;
              uint64_t v100 = v146;
            }
            uint64_t v99 = sub_1DC38BC4C((uint64_t)&v180 + (v100 & 0xFFFFFFFFFFFFFFF8), (uint64_t)v183, (uint64_t)v92);
          }
          else
          {
            sub_1DC38C740((void **)&v157);
            unint64_t v96 = (v159 - v157) >> 2;
            if (v96 <= 3) {
              unint64_t v96 = 3;
            }
            if ((unint64_t)(v159 - v157) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v97 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v97 = v96;
            }
            if (v97 >> 61) {
              sub_1DC2FF97C();
            }
            uint64_t v157 = (char *)sub_1DC2FFD7C(v97);
            uint64_t v158 = (atomic_uint **)v157;
            uint64_t v159 = &v157[8 * v98];
            uint64_t v99 = sub_1DC38BC4C((uint64_t)&v180, (uint64_t)v183, (uint64_t)v157);
          }
          long long v104 = (atomic_uint **)v99;
LABEL_105:
          uint64_t v158 = v104;
          for (uint64_t m = 2; m != -1; --m)
            sub_1DC35D870((atomic_uint **)&(&v180)[m]);
          uint64_t v106 = 0;
          float v179 = 0.0;
          uint64_t v178 = 0;
          int v172 = 0;
          uint64_t v171 = 0;
          do
          {
            float v107 = *(float *)((char *)v173 + 12 * v60 + v106);
            *(float *)((char *)&v178 + v106) = *(float *)((char *)v173 + 12 * v91 + v106) - v107;
            *(float *)((char *)&v171 + v106) = *(float *)((char *)v173 + 12 * v152 + v106) - v107;
            v106 += 4;
          }
          while (v106 != 12);
          uint64_t v108 = 0;
          float v109 = fabsf(*((float *)&v171 + 1));
          float v110 = 0.0;
          do
          {
            float v110 = v110 + (float)(*(float *)((char *)&v171 + v108) * *(float *)((char *)&v171 + v108));
            v108 += 4;
          }
          while (v108 != 12);
          uint64_t v111 = 0;
          float v112 = fabsf(*(float *)&v171);
          float v113 = fabsf(*((float *)&v178 + 1));
          float v114 = 0.0;
          do
          {
            float v114 = v114 + (float)(*(float *)((char *)&v178 + v111) * *(float *)((char *)&v178 + v111));
            v111 += 4;
          }
          while (v111 != 12);
          uint64_t v115 = 0;
          float v116 = fabsf(*(float *)&v178);
          if (v112 < v109) {
            float v112 = v109;
          }
          if (v116 >= v113) {
            float v117 = v116;
          }
          else {
            float v117 = v113;
          }
          float v118 = v117 / sqrtf(v114);
          float v119 = 0.0;
          do
          {
            float v119 = v119 + (float)(*(float *)((char *)&v178 + v115) * *(float *)((char *)&v178 + v115));
            v115 += 4;
          }
          while (v115 != 12);
          uint64_t v120 = 0;
          float v121 = (float)(v112 / sqrtf(v110)) + v118;
          float v122 = 0.0;
          do
          {
            float v122 = v122 + (float)(*(float *)((char *)&v171 + v120) * *(float *)((char *)&v171 + v120));
            v120 += 4;
          }
          while (v120 != 12);
          float v123 = (float)((float)(sqrtf(v119) + sqrtf(v122)) / (float)((float)(v49 + v49) * (float)(v121 * 0.5))) + 7.0;
          if (v123 <= 180.0 && v123 >= 9.0)
          {
            uint64_t v125 = 0;
            float v126 = 0.0;
            do
            {
              float v126 = v126 + (float)(*(float *)((char *)&v178 + v125) * *(float *)((char *)&v178 + v125));
              v125 += 4;
            }
            while (v125 != 12);
            uint64_t v127 = 0;
            float v128 = 0.0;
            do
            {
              float v128 = v128 + (float)(*(float *)((char *)&v171 + v127) * *(float *)((char *)&v171 + v127));
              v127 += 4;
            }
            while (v127 != 12);
            (*(void (**)(void))(**((void **)v157 + 2) + 16))(*((void *)v157 + 2));
            (*(void (**)(void))(**(void **)v157 + 16))();
            (*(void (**)(void))(**((void **)v157 + 1) + 16))(*((void *)v157 + 1));
            (*(void (**)(void))(**((void **)v157 + 2) + 24))(*((void *)v157 + 2));
            (*(void (**)(void))(**(void **)v157 + 24))();
            (*(void (**)(void))(**((void **)v157 + 1) + 24))(*((void *)v157 + 1));
            (*(void (**)(void))(**((void **)v157 + 1) + 16))(*((void *)v157 + 1));
            (*(void (**)(void))(**((void **)v157 + 1) + 24))(*((void *)v157 + 1));
            (*(void (**)(void))(**((void **)v157 + 2) + 16))(*((void *)v157 + 2));
            (*(void (**)(void))(**((void **)v157 + 2) + 24))(*((void *)v157 + 2));
            (*(void (**)(void))(**(void **)v157 + 16))();
            (*(void (**)(void))(**(void **)v157 + 24))();
            sub_1DC353CE0();
          }
LABEL_140:
          char v180 = (void **)&v157;
          sub_1DC3853C0(&v180);
          sub_1DC35D870(&v160);
          uint64_t v20 = v156 + 1;
          LODWORD(v6) = v153;
          if ((int)v156 + 1 >= v153) {
            goto LABEL_143;
          }
        }
        sub_1DC35D870(&v160);
LABEL_143:
        sub_1DC35D870(&v161);
        uint64_t v14 = v143;
        ++v144;
      }
      while ((int)v137 > (int)v143);
LABEL_146:
      uint64_t result = sub_1DC35D870(&v162);
      uint64_t v9 = v134;
      ++v135;
      ++v136;
    }
    while (v134 != v133);
  }
  return result;
}

void sub_1DC389100(_Unwind_Exception *a1)
{
}

uint64_t sub_1DC389370(uint64_t result, atomic_uint **a2, atomic_uint **a3, uint64_t a4, int a5)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a2 != a3)
  {
    uint64_t v8 = a2;
    uint64_t v9 = result + 8;
    uint64_t v10 = a4 + 16;
    do
    {
      if (!*((unsigned char *)*v8 + 32))
      {
        float v11 = (*(float (**)(atomic_uint *))(*(void *)*v8 + 24))(*v8);
        v12.n128_f64[0] = (*(double (**)(void))(*(void *)*v8 + 16))();
        unint64_t v13 = (unint64_t)v12.n128_f32[0];
        v12.n128_u32[0] = -0.75;
        float v14 = sub_1DC3A7534(v9, (unint64_t)v11, v13, (unint64_t)(float)((float)(*((float *)*v8 + 5) * 2.0) + 0.5), (uint64_t)v34, (uint64_t)v33, 5, a5, v12, 0);
        if (v14 > -0.75)
        {
          *((float *)*v8 + 6) = v14 + *((float *)*v8 + 6);
          unint64_t v16 = *(void *)(a4 + 8);
          unint64_t v15 = *(void *)(a4 + 16);
          if (v16 >= v15)
          {
            uint64_t v18 = (uint64_t)(v16 - *(void *)a4) >> 3;
            if ((unint64_t)(v18 + 1) >> 61) {
              sub_1DC2FF97C();
            }
            uint64_t v19 = v15 - *(void *)a4;
            uint64_t v20 = v19 >> 2;
            if (v19 >> 2 <= (unint64_t)(v18 + 1)) {
              uint64_t v20 = v18 + 1;
            }
            if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v21 = v20;
            }
            uint64_t v32 = v10;
            if (v21) {
              unint64_t v21 = (unint64_t)sub_1DC2FFD7C(v21);
            }
            else {
              uint64_t v22 = 0;
            }
            int v23 = (atomic_uint **)(v21 + 8 * v18);
            v29[0] = v21;
            v29[1] = v23;
            __n128 v30 = v23;
            unint64_t v31 = v21 + 8 * v22;
            *int v23 = 0;
            float v24 = *v8;
            float v25 = v23;
            if (*v8)
            {
              atomic_fetch_add_explicit(v24 + 2, 1u, memory_order_relaxed);
              float v25 = v23;
              if (*v23)
              {
                sub_1DC2FF57C(*v23);
                float v25 = v30;
              }
            }
            *int v23 = v24;
            __n128 v30 = v25 + 1;
            sub_1DC38A3F0((atomic_uint *)a4, v29);
            unint64_t v17 = *(void *)(a4 + 8);
            sub_1DC38A4E8((uint64_t)v29);
          }
          else
          {
            sub_1DC38A390((atomic_uint *)a4, v8);
            unint64_t v17 = v16 + 8;
          }
          *(void *)(a4 + 8) = v17;
        }
      }
      ++v8;
    }
    while (v8 != a3);
    float v26 = *(atomic_uint ***)(a4 + 8);
    unint64_t v27 = 126 - 2 * __clz(((uint64_t)v26 - *(void *)a4) >> 3);
    if (v26 == *(atomic_uint ***)a4) {
      uint64_t v28 = 0;
    }
    else {
      uint64_t v28 = v27;
    }
    return sub_1DC389A00(*(void *)a4, v26, v28, 1);
  }
  return result;
}

void sub_1DC3895D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC38A4E8((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC3895F4(atomic_uint **result, atomic_uint **a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v5 = result;
    unint64_t v6 = *(atomic_uint ***)(a3 + 8);
    do
    {
      if ((unint64_t)v6 >= *(void *)(a3 + 16))
      {
        uint64_t result = sub_1DC389800((atomic_uint ***)a3, v5);
        unint64_t v6 = result;
      }
      else
      {
        uint64_t result = (atomic_uint **)sub_1DC3897A0((atomic_uint *)a3, v5);
        ++v6;
      }
      *(void *)(a3 + 8) = v6;
      ++v5;
    }
    while (v5 != a2);
  }
  return result;
}

void **sub_1DC38966C(void **a1)
{
  BOOL v3 = a1 + 3;
  sub_1DC3853C0(&v3);
  BOOL v3 = a1;
  sub_1DC3853C0(&v3);
  return a1;
}

atomic_uint *sub_1DC3896B4(atomic_uint *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = (atomic_uint *)sub_1DC2FFD3C(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    if (a2 != a3)
    {
      uint64_t v8 = 0;
      do
      {
        uint64_t v9 = (atomic_uint **)(v7 + v8);
        *(void *)(v7 + v8) = 0;
        uint64_t v10 = *(atomic_uint **)(a2 + v8);
        if (v10)
        {
          atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
          uint64_t result = *v9;
          if (*v9) {
            uint64_t result = sub_1DC2FF57C(result);
          }
        }
        *uint64_t v9 = v10;
        v8 += 8;
      }
      while (a2 + v8 != a3);
      v7 += v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1DC389764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

atomic_uint *sub_1DC3897A0(atomic_uint *result, atomic_uint **a2)
{
  CFTypeID v2 = result;
  BOOL v3 = (atomic_uint **)*((void *)result + 1);
  void *v3 = 0;
  CFTypeID v4 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    uint64_t result = *v3;
    if (*v3) {
      uint64_t result = sub_1DC2FF57C(result);
    }
  }
  void *v3 = v4;
  *((void *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1DC3897F8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC389800(atomic_uint ***a1, atomic_uint **a2)
{
  uint64_t v2 = a1[1] - *a1;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  unint64_t v6 = a1 + 2;
  uint64_t v7 = (char *)a1[2] - (char *)*a1;
  if (v7 >> 2 > v3) {
    unint64_t v3 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v3;
  }
  unint64_t v27 = v6;
  if (v8) {
    unint64_t v8 = (unint64_t)sub_1DC2FFD7C(v8);
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = (atomic_uint **)(v8 + 8 * v2);
  unint64_t v24 = v8;
  v25.i64[0] = (uint64_t)v10;
  v25.i64[1] = (uint64_t)v10;
  unint64_t v26 = v8 + 8 * v9;
  *uint64_t v10 = 0;
  float v11 = *a2;
  __n128 v12 = v10;
  unint64_t v13 = v10;
  if (v11)
  {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    __n128 v12 = v10;
    unint64_t v13 = v10;
    if (*v10)
    {
      sub_1DC2FF57C(*v10);
      unint64_t v13 = (atomic_uint **)v25.i64[1];
      __n128 v12 = (atomic_uint **)v25.i64[0];
    }
  }
  *uint64_t v10 = v11;
  float v14 = v13 + 1;
  v25.i64[1] = (uint64_t)(v13 + 1);
  unint64_t v16 = *a1;
  unint64_t v15 = (unint64_t)a1[1];
  if ((atomic_uint **)v15 == *a1)
  {
    int64x2_t v21 = vdupq_n_s64(v15);
  }
  else
  {
    uint64_t v17 = 0;
    do
    {
      uint64_t v18 = &v12[v17];
      v12[v17 - 1] = 0;
      uint64_t v19 = *(atomic_uint **)(v15 + v17 * 8 - 8);
      if (v19)
      {
        atomic_fetch_add_explicit(v19 + 2, 1u, memory_order_relaxed);
        uint64_t v20 = *(v18 - 1);
        if (v20) {
          sub_1DC2FF57C(v20);
        }
      }
      *(v18 - 1) = v19;
      --v17;
    }
    while ((atomic_uint **)(v15 + v17 * 8) != v16);
    __n128 v12 = (atomic_uint **)((char *)v12 + v17 * 8);
    int64x2_t v21 = *(int64x2_t *)a1;
    float v14 = (atomic_uint **)v25.i64[1];
  }
  *a1 = v12;
  a1[1] = v14;
  int64x2_t v25 = v21;
  unint64_t v22 = (unint64_t)a1[2];
  a1[2] = (atomic_uint **)v26;
  unint64_t v26 = v22;
  unint64_t v24 = v21.i64[0];
  sub_1DC3899B0((uint64_t)&v24);
  return v14;
}

void sub_1DC38997C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3899B0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3899B0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC311694((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1DC389A00(uint64_t result, atomic_uint **a2, uint64_t a3, char a4)
{
  unint64_t v8 = (atomic_uint **)result;
LABEL_2:
  uint64_t v9 = a2;
  uint64_t v10 = a2 - 1;
  float v11 = v8;
  while (1)
  {
    unint64_t v8 = v11;
    uint64_t v12 = (char *)v9 - (char *)v11;
    uint64_t v13 = v9 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v41 = (uint64_t)*(a2 - 1);
          uint64_t v94 = a2 - 1;
          if (*(float *)(v41 + 24) > *((float *)*v8 + 6)) {
            uint64_t result = (uint64_t)sub_1DC38A538(v8, v94);
          }
          break;
        case 3:
          uint64_t result = (uint64_t)sub_1DC38A5E8(v8, v8 + 1, v10);
          break;
        case 4:
          uint64_t result = (uint64_t)sub_1DC38A6C4(v8, v8 + 1, v8 + 2, v10);
          break;
        case 5:
          uint64_t result = (uint64_t)sub_1DC38A784(v8, v8 + 1, v8 + 2, v8 + 3, v10);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191)
    {
      BOOL v5 = v8 == v9;
      float v42 = v9;
      float v43 = v8 + 1;
      char v45 = v5 || v43 == v42;
      if (a4)
      {
        if ((v45 & 1) == 0)
        {
          uint64_t v46 = 0;
          uint64_t v47 = v8;
          do
          {
            uint64_t v48 = *v43;
            if (*((float *)*v43 + 6) > *((float *)*v47 + 6))
            {
              unint64_t v49 = 0;
              atomic_fetch_add_explicit(v48 + 2, 1u, memory_order_relaxed);
              unint64_t v96 = v48;
              float v50 = *v47;
              while (1)
              {
                if (v50) {
                  atomic_fetch_add_explicit(v50 + 2, 1u, memory_order_relaxed);
                }
                unint64_t v51 = v47[v49 / 8 + 1];
                if (v51) {
                  sub_1DC2FF57C(v51);
                }
                v47[v49 / 8 + 1] = v50;
                unint64_t v52 = v96;
                if (v46 == v49) {
                  break;
                }
                float v50 = v47[v49 / 8 - 1];
                v49 -= 8;
                if (*((float *)v96 + 6) <= *((float *)v50 + 6))
                {
                  CGRect v53 = &v43[v49 / 8];
                  goto LABEL_97;
                }
              }
              CGRect v53 = v8;
              if (!v96) {
                goto LABEL_98;
              }
LABEL_97:
              atomic_fetch_add_explicit(v96 + 2, 1u, memory_order_relaxed);
LABEL_98:
              if (*v53) {
                sub_1DC2FF57C(*v53);
              }
              char *v53 = v52;
              uint64_t result = (uint64_t)sub_1DC35D870(&v96);
            }
            ++v43;
            ++v47;
            v46 -= 8;
          }
          while (v43 != a2);
        }
      }
      else if ((v45 & 1) == 0)
      {
        do
        {
          float v89 = v43;
          int v90 = v8[1];
          if (*((float *)v90 + 6) > *((float *)*v8 + 6))
          {
            atomic_fetch_add_explicit(v90 + 2, 1u, memory_order_relaxed);
            unint64_t v96 = v90;
            int v91 = *v8;
            do
            {
              if (v91) {
                atomic_fetch_add_explicit(v91 + 2, 1u, memory_order_relaxed);
              }
              if (*v43) {
                sub_1DC2FF57C(*v43);
              }
              *float v43 = v91;
              uint64_t v92 = v96;
              int v91 = *(v43 - 2);
              --v43;
            }
            while (*((float *)v96 + 6) > *((float *)v91 + 6));
            atomic_fetch_add_explicit(v96 + 2, 1u, memory_order_relaxed);
            if (*v43) {
              sub_1DC2FF57C(*v43);
            }
            *float v43 = v92;
            uint64_t result = (uint64_t)sub_1DC35D870(&v96);
          }
          float v43 = v89 + 1;
          unint64_t v8 = v89;
        }
        while (v89 + 1 != a2);
      }
      return result;
    }
    if (!a3) {
      break;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    unint64_t v15 = &v8[(unint64_t)v13 >> 1];
    if ((unint64_t)v12 < 0x401)
    {
      sub_1DC38A5E8(v15, v8, v10);
    }
    else
    {
      sub_1DC38A5E8(v8, v15, v10);
      sub_1DC38A5E8(v8 + 1, v15 - 1, a2 - 2);
      sub_1DC38A5E8(v8 + 2, &v8[v14 + 1], a2 - 3);
      sub_1DC38A5E8(v15 - 1, v15, &v8[v14 + 1]);
      sub_1DC38A878(v8, v15);
    }
    --a3;
    unint64_t v16 = a2;
    if (a4)
    {
      uint64_t v17 = *v8;
      if (!*v8) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
    uint64_t v17 = *v8;
    float v18 = *((float *)*v8 + 6);
    if (*((float *)*(v8 - 1) + 6) <= v18)
    {
      atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      unint64_t v96 = v17;
      if (v18 <= *((float *)*v10 + 6))
      {
        uint64_t v33 = v8 + 1;
        do
        {
          float v11 = v33;
          if (v33 >= a2) {
            break;
          }
          ++v33;
        }
        while (v18 <= *((float *)*v11 + 6));
      }
      else
      {
        float v11 = v8;
        do
        {
          uint64_t v32 = v11[1];
          ++v11;
        }
        while (v18 <= *((float *)v32 + 6));
      }
      int v34 = a2;
      if (v11 < a2)
      {
        int v34 = a2;
        do
          uint64_t v35 = (uint64_t)*--v34;
        while (v18 > *(float *)(v35 + 24));
      }
      while (v11 < v34)
      {
        sub_1DC38A538(v11, v34);
        uint64_t v17 = v96;
        float v36 = *((float *)v96 + 6);
        do
        {
          uint64_t v37 = v11[1];
          ++v11;
        }
        while (v36 <= *((float *)v37 + 6));
        do
          uint64_t v38 = (uint64_t)*--v34;
        while (v36 > *(float *)(v38 + 24));
      }
      uint64_t v39 = v11 - 1;
      if (v11 - 1 != v8)
      {
        uint64_t v40 = *v39;
        if (*v39) {
          atomic_fetch_add_explicit(v40 + 2, 1u, memory_order_relaxed);
        }
        if (*v8) {
          sub_1DC2FF57C(*v8);
        }
        atomic_uint *v8 = v40;
        uint64_t v17 = v96;
      }
      if (v17) {
        atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      }
      if (*v39) {
        sub_1DC2FF57C(*v39);
      }
      *uint64_t v39 = v17;
      uint64_t result = (uint64_t)sub_1DC35D870(&v96);
      a4 = 0;
      uint64_t v9 = a2;
    }
    else
    {
LABEL_14:
      atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
LABEL_15:
      unint64_t v96 = v17;
      float v19 = *((float *)v17 + 6);
      uint64_t v20 = v8;
      do
      {
        int64x2_t v21 = v20;
        unint64_t v22 = v20[1];
        ++v20;
      }
      while (*((float *)v22 + 6) > v19);
      if (v21 == v8)
      {
        unint64_t v16 = a2;
        do
        {
          if (v20 >= v16) {
            break;
          }
          uint64_t v24 = (uint64_t)*--v16;
        }
        while (*(float *)(v24 + 24) <= v19);
      }
      else
      {
        do
          uint64_t v23 = (uint64_t)*--v16;
        while (*(float *)(v23 + 24) <= v19);
      }
      float v11 = v20;
      if (v20 < v16)
      {
        int64x2_t v25 = v16;
        do
        {
          sub_1DC38A538(v11, v25);
          uint64_t v17 = v96;
          float v26 = *((float *)v96 + 6);
          do
          {
            unint64_t v27 = v11[1];
            ++v11;
          }
          while (*((float *)v27 + 6) > v26);
          do
            uint64_t v28 = (uint64_t)*--v25;
          while (*(float *)(v28 + 24) <= v26);
        }
        while (v11 < v25);
      }
      uint64_t v29 = v11 - 1;
      if (v11 - 1 != v8)
      {
        __n128 v30 = *v29;
        if (*v29) {
          atomic_fetch_add_explicit(v30 + 2, 1u, memory_order_relaxed);
        }
        if (*v8) {
          sub_1DC2FF57C(*v8);
        }
        atomic_uint *v8 = v30;
        uint64_t v17 = v96;
      }
      if (v17) {
        atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      }
      if (*v29) {
        sub_1DC2FF57C(*v29);
      }
      *uint64_t v29 = v17;
      sub_1DC35D870(&v96);
      BOOL v4 = v20 >= v16;
      uint64_t v9 = a2;
      if (!v4) {
        goto LABEL_43;
      }
      char v31 = sub_1DC38A928(v8, v11 - 1);
      uint64_t result = sub_1DC38A928(v11, a2);
      if (result)
      {
        a2 = v11 - 1;
        if (v31) {
          return result;
        }
        goto LABEL_2;
      }
      if ((v31 & 1) == 0)
      {
LABEL_43:
        uint64_t result = sub_1DC389A00(v8, v11 - 1, a3, a4 & 1);
        a4 = 0;
      }
    }
  }
  if (v8 != v9)
  {
    int64_t v54 = (unint64_t)(v13 - 2) >> 1;
    int64_t v55 = v54;
    do
    {
      int64_t v56 = v55;
      if (v54 >= v55)
      {
        uint64_t v57 = (2 * v55) | 1;
        int64_t v58 = &v8[v57];
        if (2 * v56 + 2 < v13 && *((float *)*v58 + 6) > *((float *)v58[1] + 6))
        {
          ++v58;
          uint64_t v57 = 2 * v56 + 2;
        }
        int v59 = &v8[v56];
        int v60 = *v59;
        if (*((float *)*v58 + 6) <= *((float *)*v59 + 6))
        {
          atomic_fetch_add_explicit(v60 + 2, 1u, memory_order_relaxed);
          unint64_t v96 = v60;
          uint64_t v61 = *v58;
          while (1)
          {
            float v62 = v58;
            if (v61) {
              atomic_fetch_add_explicit(v61 + 2, 1u, memory_order_relaxed);
            }
            if (*v59) {
              sub_1DC2FF57C(*v59);
            }
            *int v59 = v61;
            if (v54 < v57) {
              break;
            }
            uint64_t v63 = 2 * v57;
            uint64_t v57 = (2 * v57) | 1;
            int64_t v58 = &v8[v57];
            uint64_t v64 = v63 + 2;
            if (v64 < v13 && *((float *)*v58 + 6) > *((float *)v58[1] + 6))
            {
              ++v58;
              uint64_t v57 = v64;
            }
            uint64_t v61 = *v58;
            uint64_t v65 = v96;
            int v59 = v62;
            if (*((float *)*v58 + 6) > *((float *)v96 + 6)) {
              goto LABEL_122;
            }
          }
          uint64_t v65 = v96;
          if (v96) {
LABEL_122:
          }
            atomic_fetch_add_explicit(v65 + 2, 1u, memory_order_relaxed);
          if (*v62) {
            sub_1DC2FF57C(*v62);
          }
          atomic_uint *v62 = v65;
          sub_1DC35D870(&v96);
        }
      }
      int64_t v55 = v56 - 1;
    }
    while (v56);
    uint64_t v66 = (unint64_t)v12 >> 3;
    while (2)
    {
      unint64_t v67 = *v8;
      if (*v8) {
        atomic_fetch_add_explicit(v67 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v68 = 0;
      uint64_t v95 = v67;
      unint64_t v69 = v8;
LABEL_131:
      float v70 = &v69[v68];
      float v73 = v70[1];
      uint64_t v71 = v70 + 1;
      uint64_t v72 = v73;
      uint64_t v74 = 2 * v68;
      uint64_t v68 = (2 * v68) | 1;
      uint64_t v75 = v74 + 2;
      if (v75 >= v66)
      {
        if (v72) {
          goto LABEL_135;
        }
      }
      else
      {
        float v76 = v71[1];
        if (*((float *)v72 + 6) > *((float *)v76 + 6))
        {
          uint64_t v68 = v75;
          ++v71;
          uint64_t v72 = v76;
        }
LABEL_135:
        atomic_fetch_add_explicit(v72 + 2, 1u, memory_order_relaxed);
      }
      if (*v69) {
        sub_1DC2FF57C(*v69);
      }
      *unint64_t v69 = v72;
      unint64_t v69 = v71;
      if (v68 > (uint64_t)((unint64_t)(v66 - 2) >> 1))
      {
        float v77 = a2 - 1;
        BOOL v5 = v71 == --a2;
        if (v5)
        {
          float v87 = v95;
          if (v95) {
            atomic_fetch_add_explicit(v95 + 2, 1u, memory_order_relaxed);
          }
          if (*v71) {
            sub_1DC2FF57C(*v71);
          }
          *uint64_t v71 = v87;
        }
        else
        {
          float v78 = *v77;
          if (*v77) {
            atomic_fetch_add_explicit(v78 + 2, 1u, memory_order_relaxed);
          }
          if (*v71) {
            sub_1DC2FF57C(*v71);
          }
          *uint64_t v71 = v78;
          float v79 = v95;
          if (v95) {
            atomic_fetch_add_explicit(v95 + 2, 1u, memory_order_relaxed);
          }
          if (*a2) {
            sub_1DC2FF57C(*a2);
          }
          *a2 = v79;
          uint64_t v80 = (char *)v71 - (char *)v8 + 8;
          if (v80 >= 9)
          {
            unint64_t v81 = (((unint64_t)v80 >> 3) - 2) >> 1;
            int v82 = &v8[v81];
            int v83 = *v71;
            if (*((float *)*v82 + 6) > *((float *)*v71 + 6))
            {
              atomic_fetch_add_explicit(v83 + 2, 1u, memory_order_relaxed);
              unint64_t v96 = v83;
              float v84 = *v82;
              while (1)
              {
                float v85 = v82;
                if (v84) {
                  atomic_fetch_add_explicit(v84 + 2, 1u, memory_order_relaxed);
                }
                if (*v71) {
                  sub_1DC2FF57C(*v71);
                }
                *uint64_t v71 = v84;
                if (!v81) {
                  break;
                }
                unint64_t v81 = (v81 - 1) >> 1;
                int v82 = &v8[v81];
                float v84 = *v82;
                float v86 = v96;
                uint64_t v71 = v85;
                if (*((float *)*v82 + 6) <= *((float *)v96 + 6)) {
                  goto LABEL_164;
                }
              }
              float v86 = v96;
              if (!v96) {
                goto LABEL_165;
              }
LABEL_164:
              atomic_fetch_add_explicit(v86 + 2, 1u, memory_order_relaxed);
LABEL_165:
              if (*v85) {
                sub_1DC2FF57C(*v85);
              }
              atomic_uint *v85 = v86;
              sub_1DC35D870(&v96);
            }
          }
        }
        uint64_t result = (uint64_t)sub_1DC35D870(&v95);
        if (v66-- <= 2) {
          return result;
        }
        continue;
      }
      goto LABEL_131;
    }
  }
  return result;
}

void sub_1DC38A31C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1DC35D870((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_uint *sub_1DC38A390(atomic_uint *result, atomic_uint **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = (atomic_uint **)*((void *)result + 1);
  void *v3 = 0;
  BOOL v4 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    uint64_t result = *v3;
    if (*v3) {
      uint64_t result = sub_1DC2FF57C(result);
    }
  }
  void *v3 = v4;
  *((void *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1DC38A3E8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

atomic_uint *sub_1DC38A3F0(atomic_uint *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *(void *)result;
  uint64_t v4 = *((void *)result + 1);
  uint64_t v6 = a2[1];
  if (v4 != *(void *)result)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = v6 + v7;
      *(void *)(v6 + v7 - 8) = 0;
      uint64_t v9 = *(void *)(v4 + v7 - 8);
      if (v9)
      {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 1u, memory_order_relaxed);
        uint64_t result = *(atomic_uint **)(v8 - 8);
        if (result) {
          uint64_t result = sub_1DC2FF57C(result);
        }
      }
      *(void *)(v8 - 8) = v9;
      v7 -= 8;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v10 = *(void *)v3;
  *(void *)uint64_t v3 = v6;
  a2[1] = v10;
  uint64_t v11 = *((void *)v3 + 1);
  *((void *)v3 + 1) = a2[2];
  a2[2] = v11;
  uint64_t v12 = *((void *)v3 + 2);
  *((void *)v3 + 2) = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DC38A4E8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC35D870((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

atomic_uint **sub_1DC38A538(atomic_uint **a1, atomic_uint **a2)
{
  uint64_t v4 = *a1;
  if (*a1) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v8 = v4;
  uint64_t v5 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v6 = *a1;
  if (*a1)
  {
    sub_1DC2FF57C(v6);
    uint64_t v4 = v8;
  }
  *a1 = v5;
  if (v4) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  if (*a2) {
    sub_1DC2FF57C(*a2);
  }
  *a2 = v4;
  return sub_1DC35D870(&v8);
}

void sub_1DC38A5D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC35D870((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC38A5E8(atomic_uint **result, atomic_uint **a2, atomic_uint **a3)
{
  uint64_t v5 = result;
  float v6 = *((float *)*a2 + 6);
  float v7 = *((float *)*a3 + 6);
  if (v6 <= *((float *)*result + 6))
  {
    if (v7 <= v6) {
      return result;
    }
    uint64_t result = sub_1DC38A538(a2, a3);
    if (*((float *)*a2 + 6) <= *((float *)*v5 + 6)) {
      return result;
    }
    uint64_t result = v5;
    uint64_t v8 = a2;
  }
  else
  {
    if (v7 <= v6)
    {
      uint64_t result = sub_1DC38A538(result, a2);
      if (*((float *)*a3 + 6) <= *((float *)*a2 + 6)) {
        return result;
      }
      uint64_t result = a2;
    }
    uint64_t v8 = a3;
  }
  return sub_1DC38A538(result, v8);
}

atomic_uint **sub_1DC38A6C4(atomic_uint **a1, atomic_uint **a2, atomic_uint **a3, atomic_uint **a4)
{
  uint64_t result = sub_1DC38A5E8(a1, a2, a3);
  if (*((float *)*a4 + 6) > *((float *)*a3 + 6))
  {
    uint64_t result = sub_1DC38A538(a3, a4);
    if (*((float *)*a3 + 6) > *((float *)*a2 + 6))
    {
      uint64_t result = sub_1DC38A538(a2, a3);
      if (*((float *)*a2 + 6) > *((float *)*a1 + 6))
      {
        return sub_1DC38A538(a1, a2);
      }
    }
  }
  return result;
}

atomic_uint **sub_1DC38A784(atomic_uint **a1, atomic_uint **a2, atomic_uint **a3, atomic_uint **a4, atomic_uint **a5)
{
  uint64_t result = sub_1DC38A6C4(a1, a2, a3, a4);
  if (*((float *)*a5 + 6) > *((float *)*a4 + 6))
  {
    uint64_t result = sub_1DC38A538(a4, a5);
    if (*((float *)*a4 + 6) > *((float *)*a3 + 6))
    {
      uint64_t result = sub_1DC38A538(a3, a4);
      if (*((float *)*a3 + 6) > *((float *)*a2 + 6))
      {
        uint64_t result = sub_1DC38A538(a2, a3);
        if (*((float *)*a2 + 6) > *((float *)*a1 + 6))
        {
          return sub_1DC38A538(a1, a2);
        }
      }
    }
  }
  return result;
}

atomic_uint **sub_1DC38A878(atomic_uint **a1, atomic_uint **a2)
{
  uint64_t v4 = *a1;
  if (*a1) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v8 = v4;
  uint64_t v5 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
  }
  float v6 = *a1;
  if (*a1)
  {
    sub_1DC2FF57C(v6);
    uint64_t v4 = v8;
  }
  *a1 = v5;
  if (v4) {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
  }
  if (*a2) {
    sub_1DC2FF57C(*a2);
  }
  *a2 = v4;
  return sub_1DC35D870(&v8);
}

void sub_1DC38A914(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC35D870((atomic_uint **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC38A928(atomic_uint **a1, atomic_uint **a2)
{
  BOOL v4 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      if (*((float *)*(a2 - 1) + 6) > *((float *)*a1 + 6)) {
        sub_1DC38A538(a1, a2 - 1);
      }
      return v4;
    case 3:
      sub_1DC38A5E8(a1, a1 + 1, a2 - 1);
      return v4;
    case 4:
      sub_1DC38A6C4(a1, a1 + 1, a1 + 2, a2 - 1);
      return v4;
    case 5:
      sub_1DC38A784(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return v4;
    default:
      uint64_t v5 = a1 + 2;
      sub_1DC38A5E8(a1, a1 + 1, a1 + 2);
      float v6 = a1 + 3;
      BOOL v4 = 1;
      if (a1 + 3 == a2) {
        return v4;
      }
      int v7 = 0;
      uint64_t v8 = -16;
      break;
  }
  while (1)
  {
    uint64_t v9 = *v6;
    if (*((float *)*v6 + 6) > *((float *)*v5 + 6)) {
      break;
    }
LABEL_21:
    uint64_t v5 = v6;
    v8 -= 8;
    if (++v6 == a2) {
      return 1;
    }
  }
  unint64_t v10 = 0;
  atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
  unint64_t v16 = v9;
  uint64_t v11 = *v5;
  while (1)
  {
    if (v11) {
      atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v12 = v6[v10 / 8];
    if (v12) {
      sub_1DC2FF57C(v12);
    }
    v6[v10 / 8] = v11;
    uint64_t v13 = v16;
    if (v8 == v10) {
      break;
    }
    uint64_t v11 = v6[v10 / 8 - 2];
    v10 -= 8;
    if (*((float *)v16 + 6) <= *((float *)v11 + 6))
    {
      unint64_t v14 = &v6[v10 / 8];
      goto LABEL_16;
    }
  }
  unint64_t v14 = a1;
  if (!v16) {
    goto LABEL_17;
  }
LABEL_16:
  atomic_fetch_add_explicit(v16 + 2, 1u, memory_order_relaxed);
LABEL_17:
  if (*v14) {
    sub_1DC2FF57C(*v14);
  }
  __CFString *v14 = v13;
  if (++v7 != 8)
  {
    sub_1DC35D870(&v16);
    goto LABEL_21;
  }
  BOOL v4 = v6 + 1 == a2;
  sub_1DC35D870(&v16);
  return v4;
}

void sub_1DC38AB28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC35D870((atomic_uint **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC38AB58(uint64_t result, atomic_uint **a2, uint64_t (**a3)(atomic_uint **, atomic_uint **), uint64_t a4, char a5)
{
  unint64_t v10 = (atomic_uint **)result;
LABEL_2:
  uint64_t v11 = v10;
  uint64_t v183 = v10 + 2;
  float v185 = v10 + 1;
  while (1)
  {
    uint64_t v12 = (char *)a2 - (char *)v11;
    uint64_t v13 = a2 - v11;
    if (v6 || !v5)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          int v83 = *a3;
          double v193 = 0;
          float v86 = *(a2 - 1);
          float v85 = a2 - 1;
          float v84 = v86;
          if (v86) {
            atomic_fetch_add_explicit(v84 + 2, 1u, memory_order_relaxed);
          }
          float v192 = 0;
          double v193 = v84;
          float v87 = *v11;
          if (*v11) {
            atomic_fetch_add_explicit(v87 + 2, 1u, memory_order_relaxed);
          }
          float v192 = v87;
          int v88 = v83(&v193, &v192);
          sub_1DC35D870(&v192);
          uint64_t result = (uint64_t)sub_1DC35D870(&v193);
          if (v88) {
            uint64_t result = (uint64_t)sub_1DC38A538(v11, v85);
          }
          break;
        case 3:
          uint64_t result = (uint64_t)sub_1DC38CB00(v11, v11 + 1, a2 - 1, a3);
          break;
        case 4:
          uint64_t result = (uint64_t)sub_1DC38CD84(v11, v11 + 1, v11 + 2, a2 - 1, a3);
          break;
        case 5:
          uint64_t result = (uint64_t)sub_1DC38CF40(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191) {
      break;
    }
    if (!a4)
    {
      if (v11 != a2)
      {
        int64_t v111 = (unint64_t)(v13 - 2) >> 1;
        float v186 = a2;
        int64_t v189 = v111;
        do
        {
          int64_t v112 = v111;
          if (v189 >= v111)
          {
            uint64_t v113 = (2 * v111) | 1;
            float v114 = &v11[v113];
            if (2 * v111 + 2 < v13)
            {
              uint64_t v115 = *a3;
              float v116 = *v114;
              if (*v114) {
                atomic_fetch_add_explicit(v116 + 2, 1u, memory_order_relaxed);
              }
              uint64_t v204 = v116;
              float v117 = v114[1];
              if (v117) {
                atomic_fetch_add_explicit(v117 + 2, 1u, memory_order_relaxed);
              }
              uint64_t v203 = v117;
              unsigned int v118 = v115(&v204, &v203);
              sub_1DC35D870(&v203);
              sub_1DC35D870(&v204);
              v114 += v118;
              if (v118) {
                uint64_t v113 = 2 * v112 + 2;
              }
            }
            float v119 = *a3;
            uint64_t v120 = *v114;
            if (*v114) {
              atomic_fetch_add_explicit(v120 + 2, 1u, memory_order_relaxed);
            }
            float v121 = &v11[v112];
            uint64_t v202 = v120;
            float v122 = *v121;
            if (*v121) {
              atomic_fetch_add_explicit(v122 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v201 = v122;
            char v123 = v119(&v202, &v201);
            sub_1DC35D870(&v201);
            uint64_t result = (uint64_t)sub_1DC35D870(&v202);
            if ((v123 & 1) == 0)
            {
              int64_t v184 = v112;
              unint64_t v124 = *v121;
              if (*v121) {
                atomic_fetch_add_explicit(v124 + 2, 1u, memory_order_relaxed);
              }
              uint64_t v200 = v124;
              do
              {
                uint64_t v125 = v114;
                float v126 = *v114;
                if (v126) {
                  atomic_fetch_add_explicit(v126 + 2, 1u, memory_order_relaxed);
                }
                if (*v121) {
                  sub_1DC2FF57C(*v121);
                }
                *float v121 = v126;
                if (v189 < v113) {
                  break;
                }
                uint64_t v127 = (2 * v113) | 1;
                float v114 = &v11[v127];
                uint64_t v113 = 2 * v113 + 2;
                if (v113 < v13)
                {
                  float v128 = *a3;
                  long long v129 = *v114;
                  if (*v114) {
                    atomic_fetch_add_explicit(v129 + 2, 1u, memory_order_relaxed);
                  }
                  double v199 = v129;
                  uint64_t v130 = v114[1];
                  if (v130) {
                    atomic_fetch_add_explicit(v130 + 2, 1u, memory_order_relaxed);
                  }
                  uint64_t v198 = v130;
                  unsigned int v131 = v128(&v199, &v198);
                  sub_1DC35D870(&v198);
                  sub_1DC35D870(&v199);
                  v114 += v131;
                  if (!v131) {
                    uint64_t v113 = v127;
                  }
                }
                else
                {
                  uint64_t v113 = v127;
                }
                double v132 = *a3;
                uint64_t v133 = *v114;
                if (*v114) {
                  atomic_fetch_add_explicit(v133 + 2, 1u, memory_order_relaxed);
                }
                double v197 = v133;
                uint64_t v134 = v200;
                if (v200) {
                  atomic_fetch_add_explicit(v200 + 2, 1u, memory_order_relaxed);
                }
                uint64_t v196 = v134;
                int v135 = v132(&v197, &v196);
                sub_1DC35D870(&v196);
                sub_1DC35D870(&v197);
                float v121 = v125;
              }
              while (!v135);
              uint64_t v136 = v200;
              if (v200) {
                atomic_fetch_add_explicit(v200 + 2, 1u, memory_order_relaxed);
              }
              if (*v125) {
                sub_1DC2FF57C(*v125);
              }
              *uint64_t v125 = v136;
              uint64_t result = (uint64_t)sub_1DC35D870(&v200);
              int64_t v112 = v184;
            }
          }
          int64_t v111 = v112 - 1;
        }
        while (v112);
        uint64_t v137 = (unint64_t)v12 >> 3;
        float v138 = v186;
        do
        {
          if (v137 >= 2)
          {
            float v187 = v138;
            float v139 = *v11;
            if (*v11) {
              atomic_fetch_add_explicit(v139 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v140 = 0;
            double v199 = v139;
            float v141 = v11;
            do
            {
              uint64_t v142 = (uint64_t)&v141[v140 + 1];
              uint64_t v143 = 2 * v140;
              uint64_t v140 = (2 * v140) | 1;
              uint64_t v144 = v143 + 2;
              if (v143 + 2 < v137)
              {
                float v145 = *a3;
                uint64_t v204 = 0;
                uint64_t v146 = *(atomic_uint **)v142;
                if (*(void *)v142) {
                  atomic_fetch_add_explicit(v146 + 2, 1u, memory_order_relaxed);
                }
                uint64_t v203 = 0;
                uint64_t v204 = v146;
                float v147 = *(atomic_uint **)(v142 + 8);
                if (v147) {
                  atomic_fetch_add_explicit(v147 + 2, 1u, memory_order_relaxed);
                }
                uint64_t v203 = v147;
                unsigned int v148 = v145(&v204, &v203);
                sub_1DC35D870(&v203);
                sub_1DC35D870(&v204);
                v142 += 8 * v148;
                if (v148) {
                  uint64_t v140 = v144;
                }
              }
              int v149 = *(atomic_uint **)v142;
              if (*(void *)v142) {
                atomic_fetch_add_explicit(v149 + 2, 1u, memory_order_relaxed);
              }
              if (*v141) {
                sub_1DC2FF57C(*v141);
              }
              *float v141 = v149;
              float v141 = (atomic_uint **)v142;
            }
            while (v140 <= (uint64_t)((unint64_t)(v137 - 2) >> 1));
            float v150 = v187 - 1;
            if ((atomic_uint **)v142 == v187 - 1)
            {
              uint64_t v168 = v199;
              if (v199) {
                atomic_fetch_add_explicit(v199 + 2, 1u, memory_order_relaxed);
              }
              if (*(void *)v142) {
                sub_1DC2FF57C(*(atomic_uint **)v142);
              }
              *(void *)uint64_t v142 = v168;
            }
            else
            {
              float v151 = *v150;
              if (*v150) {
                atomic_fetch_add_explicit(v151 + 2, 1u, memory_order_relaxed);
              }
              if (*(void *)v142) {
                sub_1DC2FF57C(*(atomic_uint **)v142);
              }
              *(void *)uint64_t v142 = v151;
              int v152 = v199;
              if (v199) {
                atomic_fetch_add_explicit(v199 + 2, 1u, memory_order_relaxed);
              }
              if (*v150) {
                sub_1DC2FF57C(*v150);
              }
              atomic_uint *v150 = v152;
              uint64_t v153 = v142 - (void)v11 + 8;
              if (v153 >= 9)
              {
                unint64_t v154 = (unint64_t)((v153 >> 3) - 2) >> 1;
                float v155 = &v11[v154];
                uint64_t v156 = *a3;
                uint64_t v157 = *v155;
                if (*v155) {
                  atomic_fetch_add_explicit(v157 + 2, 1u, memory_order_relaxed);
                }
                uint64_t v204 = v157;
                uint64_t v158 = *(atomic_uint **)v142;
                if (*(void *)v142) {
                  atomic_fetch_add_explicit(v158 + 2, 1u, memory_order_relaxed);
                }
                uint64_t v203 = v158;
                int v159 = v156(&v204, &v203);
                sub_1DC35D870(&v203);
                sub_1DC35D870(&v204);
                if (v159)
                {
                  unsigned int v160 = *(atomic_uint **)v142;
                  if (*(void *)v142) {
                    atomic_fetch_add_explicit(v160 + 2, 1u, memory_order_relaxed);
                  }
                  uint64_t v202 = v160;
                  do
                  {
                    uint64_t v161 = v155;
                    char v162 = *v155;
                    if (*v155) {
                      atomic_fetch_add_explicit(v162 + 2, 1u, memory_order_relaxed);
                    }
                    if (*(void *)v142) {
                      sub_1DC2FF57C(*(atomic_uint **)v142);
                    }
                    *(void *)uint64_t v142 = v162;
                    if (!v154) {
                      break;
                    }
                    unint64_t v154 = (v154 - 1) >> 1;
                    float v155 = &v11[v154];
                    uint64_t v163 = *a3;
                    uint64_t v164 = *v155;
                    if (*v155) {
                      atomic_fetch_add_explicit(v164 + 2, 1u, memory_order_relaxed);
                    }
                    uint64_t v201 = v164;
                    int v165 = v202;
                    if (v202) {
                      atomic_fetch_add_explicit(v202 + 2, 1u, memory_order_relaxed);
                    }
                    uint64_t v200 = v165;
                    char v166 = v163(&v201, &v200);
                    sub_1DC35D870(&v200);
                    sub_1DC35D870(&v201);
                    uint64_t v142 = (uint64_t)v161;
                  }
                  while ((v166 & 1) != 0);
                  uint64_t v167 = v202;
                  if (v202) {
                    atomic_fetch_add_explicit(v202 + 2, 1u, memory_order_relaxed);
                  }
                  if (*v161) {
                    sub_1DC2FF57C(*v161);
                  }
                  *uint64_t v161 = v167;
                  sub_1DC35D870(&v202);
                }
              }
            }
            uint64_t result = (uint64_t)sub_1DC35D870(&v199);
            float v138 = v187;
          }
          --v138;
        }
        while ((unint64_t)v137-- > 2);
      }
      return result;
    }
    unint64_t v14 = &v11[(unint64_t)v13 >> 1];
    unint64_t v15 = a2 - 1;
    if ((unint64_t)v12 < 0x401)
    {
      sub_1DC38CB00(v14, v11, a2 - 1, a3);
    }
    else
    {
      sub_1DC38CB00(v11, v14, a2 - 1, a3);
      sub_1DC38CB00(v185, v14 - 1, a2 - 2, a3);
      sub_1DC38CB00(v183, v14 + 1, a2 - 3, a3);
      sub_1DC38CB00(v14 - 1, v14, v14 + 1, a3);
      sub_1DC38A878(v11, v14);
    }
    --a4;
    if ((a5 & 1) == 0)
    {
      unint64_t v16 = *a3;
      float v191 = 0;
      uint64_t v17 = *(v11 - 1);
      if (v17) {
        atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      }
      float v190 = 0;
      float v191 = v17;
      float v18 = *v11;
      if (*v11) {
        atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
      }
      float v190 = v18;
      char v19 = v16(&v191, &v190);
      sub_1DC35D870(&v190);
      sub_1DC35D870(&v191);
      if ((v19 & 1) == 0)
      {
        CGRect v53 = *v11;
        if (*v11)
        {
          atomic_fetch_add_explicit(v53 + 2, 1u, memory_order_relaxed);
          int64_t v54 = *a3;
          atomic_fetch_add_explicit(v53 + 2, 1u, memory_order_relaxed);
        }
        else
        {
          int64_t v54 = *a3;
        }
        uint64_t v203 = v53;
        uint64_t v204 = v53;
        int64_t v55 = *v15;
        if (*v15) {
          atomic_fetch_add_explicit(v55 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v202 = v55;
        char v56 = v54(&v203, &v202);
        sub_1DC35D870(&v202);
        sub_1DC35D870(&v203);
        if (v56)
        {
          unint64_t v10 = v11;
          do
          {
            uint64_t v57 = *a3;
            int64_t v58 = v204;
            if (v204) {
              atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v201 = v58;
            int v59 = v10[1];
            if (v59) {
              atomic_fetch_add_explicit(v59 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v200 = v59;
            char v60 = v57(&v201, &v200);
            ++v10;
            sub_1DC35D870(&v200);
            sub_1DC35D870(&v201);
          }
          while ((v60 & 1) == 0);
        }
        else
        {
          uint64_t v61 = v11 + 1;
          do
          {
            unint64_t v10 = v61;
            if (v61 >= a2) {
              break;
            }
            float v62 = *a3;
            uint64_t v63 = v204;
            if (v204) {
              atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v201 = v63;
            uint64_t v64 = *v10;
            if (*v10) {
              atomic_fetch_add_explicit(v64 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v200 = v64;
            char v65 = v62(&v201, &v200);
            sub_1DC35D870(&v200);
            sub_1DC35D870(&v201);
            uint64_t v61 = v10 + 1;
          }
          while ((v65 & 1) == 0);
        }
        uint64_t v66 = a2;
        if (v10 < a2)
        {
          uint64_t v66 = a2;
          do
          {
            unint64_t v67 = *a3;
            uint64_t v68 = v204;
            if (v204) {
              atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v198 = 0;
            double v199 = v68;
            unint64_t v69 = *(v66 - 1);
            if (v69) {
              atomic_fetch_add_explicit(v69 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v198 = v69;
            char v70 = v67(&v199, &v198);
            --v66;
            sub_1DC35D870(&v198);
            sub_1DC35D870(&v199);
          }
          while ((v70 & 1) != 0);
        }
        while (v10 < v66)
        {
          sub_1DC38A538(v10, v66);
          do
          {
            uint64_t v71 = *a3;
            uint64_t v72 = v204;
            if (v204) {
              atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
            }
            double v197 = v72;
            float v73 = v10[1];
            if (v73) {
              atomic_fetch_add_explicit(v73 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v196 = v73;
            int v74 = v71(&v197, &v196);
            ++v10;
            sub_1DC35D870(&v196);
            sub_1DC35D870(&v197);
          }
          while (!v74);
          do
          {
            uint64_t v75 = *a3;
            float v76 = v204;
            if (v204) {
              atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
            }
            double v194 = 0;
            double v195 = v76;
            float v77 = *(v66 - 1);
            if (v77) {
              atomic_fetch_add_explicit(v77 + 2, 1u, memory_order_relaxed);
            }
            double v194 = v77;
            char v78 = v75(&v195, &v194);
            --v66;
            sub_1DC35D870(&v194);
            sub_1DC35D870(&v195);
          }
          while ((v78 & 1) != 0);
        }
        float v79 = a2;
        uint64_t v80 = v10 - 1;
        if (v10 - 1 != v11)
        {
          unint64_t v81 = *v80;
          if (*v80) {
            atomic_fetch_add_explicit(v81 + 2, 1u, memory_order_relaxed);
          }
          if (*v11) {
            sub_1DC2FF57C(*v11);
          }
          *uint64_t v11 = v81;
        }
        int v82 = v204;
        if (v204) {
          atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
        }
        if (*v80) {
          sub_1DC2FF57C(*v80);
        }
        *uint64_t v80 = v82;
        uint64_t result = (uint64_t)sub_1DC35D870(&v204);
        a5 = 0;
        a2 = v79;
        goto LABEL_2;
      }
    }
    uint64_t v20 = *v11;
    if (*v11) {
      atomic_fetch_add_explicit(v20 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v204 = v20;
    int64x2_t v21 = v11;
    do
    {
      uint64_t v23 = v21[1];
      ++v21;
      unint64_t v22 = v23;
      uint64_t v24 = *a3;
      if (v23) {
        atomic_fetch_add_explicit(v22 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v203 = v22;
      int64x2_t v25 = v204;
      if (v204) {
        atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v202 = v25;
      char v26 = v24(&v203, &v202);
      sub_1DC35D870(&v202);
      sub_1DC35D870(&v203);
    }
    while ((v26 & 1) != 0);
    unint64_t v27 = a2;
    if (v21 - 1 == v11)
    {
      do
      {
        if (v21 >= a2) {
          break;
        }
        uint64_t v33 = *a3;
        uint64_t v201 = 0;
        uint64_t v35 = *--a2;
        int v34 = v35;
        if (v35) {
          atomic_fetch_add_explicit(v34 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v201 = v34;
        float v36 = v204;
        if (v204) {
          atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v200 = v36;
        char v37 = v33(&v201, &v200);
        sub_1DC35D870(&v200);
        sub_1DC35D870(&v201);
      }
      while ((v37 & 1) == 0);
    }
    else
    {
      do
      {
        uint64_t v201 = 0;
        uint64_t v29 = *--a2;
        uint64_t v28 = v29;
        __n128 v30 = *a3;
        if (v29) {
          atomic_fetch_add_explicit(v28 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v201 = v28;
        char v31 = v204;
        if (v204) {
          atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v200 = v31;
        char v32 = v30(&v201, &v200);
        sub_1DC35D870(&v200);
        sub_1DC35D870(&v201);
      }
      while ((v32 & 1) == 0);
    }
    unint64_t v10 = v21;
    if (v21 < a2)
    {
      uint64_t v38 = a2;
      do
      {
        sub_1DC38A538(v10, v38);
        do
        {
          uint64_t v40 = v10[1];
          ++v10;
          uint64_t v39 = v40;
          uint64_t v41 = *a3;
          if (v40) {
            atomic_fetch_add_explicit(v39 + 2, 1u, memory_order_relaxed);
          }
          double v199 = v39;
          float v42 = v204;
          if (v204) {
            atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v198 = v42;
          char v43 = v41(&v199, &v198);
          sub_1DC35D870(&v198);
          sub_1DC35D870(&v199);
        }
        while ((v43 & 1) != 0);
        do
        {
          double v197 = 0;
          char v45 = *--v38;
          float v44 = v45;
          uint64_t v46 = *a3;
          if (v45) {
            atomic_fetch_add_explicit(v44 + 2, 1u, memory_order_relaxed);
          }
          double v197 = v44;
          uint64_t v47 = v204;
          if (v204) {
            atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v196 = v47;
          int v48 = v46(&v197, &v196);
          sub_1DC35D870(&v196);
          sub_1DC35D870(&v197);
        }
        while (!v48);
      }
      while (v10 < v38);
    }
    unint64_t v49 = v10 - 1;
    if (v10 - 1 != v11)
    {
      float v50 = *v49;
      if (*v49) {
        atomic_fetch_add_explicit(v50 + 2, 1u, memory_order_relaxed);
      }
      if (*v11) {
        sub_1DC2FF57C(*v11);
      }
      *uint64_t v11 = v50;
    }
    unint64_t v51 = v204;
    if (v204) {
      atomic_fetch_add_explicit(v204 + 2, 1u, memory_order_relaxed);
    }
    if (*v49) {
      sub_1DC2FF57C(*v49);
    }
    *unint64_t v49 = v51;
    sub_1DC35D870(&v204);
    BOOL v5 = v21 >= a2;
    a2 = v27;
    if (!v5) {
      goto LABEL_67;
    }
    char v52 = sub_1DC38D17C(v11, v10 - 1, a3);
    uint64_t result = sub_1DC38D17C(v10, v27, a3);
    if (!result)
    {
      if (v52) {
        goto LABEL_2;
      }
LABEL_67:
      uint64_t result = sub_1DC38AB58(v11, v10 - 1, a3, a4, a5 & 1);
      a5 = 0;
      goto LABEL_2;
    }
    a2 = v10 - 1;
    if (v52) {
      return result;
    }
  }
  float v89 = v11 + 1;
  int v90 = a2;
  BOOL v92 = v11 == a2 || v89 == a2;
  if (a5)
  {
    if (!v92)
    {
      uint64_t v93 = 0;
      uint64_t v94 = v11;
      do
      {
        uint64_t v95 = v89;
        unint64_t v96 = *a3;
        unint64_t v97 = v94[1];
        if (v97) {
          atomic_fetch_add_explicit(v97 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v203 = 0;
        uint64_t v204 = v97;
        uint64_t v98 = *v94;
        if (v98) {
          atomic_fetch_add_explicit(v98 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v203 = v98;
        int v99 = v96(&v204, &v203);
        sub_1DC35D870(&v203);
        uint64_t result = (uint64_t)sub_1DC35D870(&v204);
        if (v99)
        {
          uint64_t v100 = *v95;
          if (*v95) {
            atomic_fetch_add_explicit(v100 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v202 = v100;
          uint64_t v101 = v93;
          while (1)
          {
            uint64_t v102 = (char *)v11 + v101;
            uint64_t v103 = *(uint64_t *)((char *)v11 + v101);
            if (v103) {
              atomic_fetch_add_explicit((atomic_uint *volatile)(v103 + 8), 1u, memory_order_relaxed);
            }
            long long v104 = (atomic_uint *)*((void *)v102 + 1);
            if (v104) {
              sub_1DC2FF57C(v104);
            }
            *((void *)v102 + 1) = v103;
            if (!v101) {
              break;
            }
            uint64_t v105 = *a3;
            uint64_t v106 = v202;
            if (v202) {
              atomic_fetch_add_explicit(v202 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v200 = 0;
            uint64_t v201 = v106;
            float v107 = *(atomic_uint **)((char *)v11 + v101 - 8);
            if (v107) {
              atomic_fetch_add_explicit(v107 + 2, 1u, memory_order_relaxed);
            }
            uint64_t v200 = v107;
            char v108 = v105(&v201, &v200);
            sub_1DC35D870(&v200);
            sub_1DC35D870(&v201);
            v101 -= 8;
            if ((v108 & 1) == 0)
            {
              float v109 = (atomic_uint **)((char *)v11 + v101 + 8);
              goto LABEL_158;
            }
          }
          float v109 = v11;
LABEL_158:
          float v110 = v202;
          if (v202) {
            atomic_fetch_add_explicit(v202 + 2, 1u, memory_order_relaxed);
          }
          if (*v109) {
            sub_1DC2FF57C(*v109);
          }
          _DWORD *v109 = v110;
          uint64_t result = (uint64_t)sub_1DC35D870(&v202);
        }
        float v89 = v95 + 1;
        v93 += 8;
        uint64_t v94 = v95;
      }
      while (v95 + 1 != v90);
    }
  }
  else if (!v92)
  {
    do
    {
      int v170 = v89;
      uint64_t v171 = *a3;
      int v172 = v11[1];
      if (v172) {
        atomic_fetch_add_explicit(v172 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v203 = 0;
      uint64_t v204 = v172;
      uint64_t v173 = *v11;
      if (*v11) {
        atomic_fetch_add_explicit(v173 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v203 = v173;
      int v174 = v171(&v204, &v203);
      sub_1DC35D870(&v203);
      uint64_t result = (uint64_t)sub_1DC35D870(&v204);
      if (v174)
      {
        uint64_t v175 = *v170;
        if (*v170) {
          atomic_fetch_add_explicit(v175 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v202 = v175;
        int v176 = v170;
        do
        {
          double v177 = *(v176 - 1);
          if (v177) {
            atomic_fetch_add_explicit(v177 + 2, 1u, memory_order_relaxed);
          }
          if (*v176) {
            sub_1DC2FF57C(*v176);
          }
          *int v176 = v177;
          uint64_t v178 = *a3;
          float v179 = v202;
          if (v202) {
            atomic_fetch_add_explicit(v202 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v200 = 0;
          uint64_t v201 = v179;
          char v180 = *(v176 - 2);
          if (v180) {
            atomic_fetch_add_explicit(v180 + 2, 1u, memory_order_relaxed);
          }
          uint64_t v200 = v180;
          char v181 = v178(&v201, &v200);
          sub_1DC35D870(&v200);
          sub_1DC35D870(&v201);
          --v176;
        }
        while ((v181 & 1) != 0);
        std::__fs::filesystem::path v182 = v202;
        if (v202) {
          atomic_fetch_add_explicit(v202 + 2, 1u, memory_order_relaxed);
        }
        if (*v176) {
          sub_1DC2FF57C(*v176);
        }
        *int v176 = v182;
        uint64_t result = (uint64_t)sub_1DC35D870(&v202);
      }
      float v89 = v170 + 1;
      uint64_t v11 = v170;
    }
    while (v170 + 1 != a2);
  }
  return result;
}

void sub_1DC38BA90(_Unwind_Exception *a1)
{
  sub_1DC35D870((atomic_uint **)(v1 - 88));
  _Unwind_Resume(a1);
}

uint64_t sub_1DC38BC4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      int v7 = (atomic_uint **)(a3 + v6);
      *(void *)(a3 + v6) = 0;
      uint64_t v8 = *(atomic_uint **)(a1 + v6);
      if (v8)
      {
        atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
        if (*v7) {
          sub_1DC2FF57C(*v7);
        }
      }
      void *v7 = v8;
      v6 += 8;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

uint64_t sub_1DC38BD04(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC385238((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

int *sub_1DC38BD54(int *result, int *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v11 = result;
  while (2)
  {
    uint64_t v12 = a2 - 1;
    uint64_t v13 = v11;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v11 = v13;
          uint64_t v14 = (char *)a2 - (char *)v13;
          unint64_t v15 = a2 - v13;
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v46 = *v12;
                uint64_t v47 = *v13;
                if (*(float *)(*a3 + 4 * v46) > *(float *)(*a3 + 4 * v47))
                {
                  int *v13 = v46;
                  *uint64_t v12 = v47;
                }
                break;
              case 3uLL:
                uint64_t v48 = *a3;
                uint64_t result = sub_1DC38C7A0(v13, v13 + 1, a2 - 1, v48);
                break;
              case 4uLL:
                uint64_t result = sub_1DC38C828(v13, v13 + 1, v13 + 2, a2 - 1, a3);
                break;
              case 5uLL:
                unint64_t v49 = v13 + 2;
                float v50 = v13 + 3;
                uint64_t result = sub_1DC38C828(v13, v13 + 1, v13 + 2, v13 + 3, a3);
                uint64_t v51 = *v12;
                uint64_t v52 = v13[3];
                uint64_t v53 = *a3;
                if (*(float *)(*a3 + 4 * v51) > *(float *)(*a3 + 4 * v52))
                {
                  int *v50 = v51;
                  *uint64_t v12 = v52;
                  uint64_t v54 = *v50;
                  uint64_t v55 = *v49;
                  float v56 = *(float *)(v53 + 4 * v54);
                  if (v56 > *(float *)(v53 + 4 * v55))
                  {
                    *unint64_t v49 = v54;
                    int *v50 = v55;
                    uint64_t v57 = v13[1];
                    if (v56 > *(float *)(v53 + 4 * v57))
                    {
                      v13[1] = v54;
                      atomic_ullong v13[2] = v57;
                      uint64_t v58 = *v13;
                      if (v56 > *(float *)(v53 + 4 * v58))
                      {
                        int *v13 = v54;
                        v13[1] = v58;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v14 <= 95)
          {
            if (a5)
            {
              if (v13 != a2)
              {
                int v59 = v13 + 1;
                if (v13 + 1 != a2)
                {
                  uint64_t v60 = *a3;
                  uint64_t v61 = 4;
                  float v62 = v13;
                  do
                  {
                    uint64_t v64 = *v62;
                    uint64_t v63 = v62[1];
                    float v62 = v59;
                    float v65 = *(float *)(v60 + 4 * v63);
                    if (v65 > *(float *)(v60 + 4 * v64))
                    {
                      uint64_t v66 = v61;
                      do
                      {
                        *(int *)((char *)v13 + v66) = v64;
                        uint64_t v67 = v66 - 4;
                        if (v66 == 4)
                        {
                          uint64_t v68 = v13;
                          goto LABEL_78;
                        }
                        uint64_t v64 = *(int *)((char *)v13 + v66 - 8);
                        v66 -= 4;
                      }
                      while (v65 > *(float *)(v60 + 4 * v64));
                      uint64_t v68 = (int *)((char *)v13 + v67);
LABEL_78:
                      *uint64_t v68 = v63;
                    }
                    int v59 = v62 + 1;
                    v61 += 4;
                  }
                  while (v62 + 1 != a2);
                }
              }
            }
            else if (v13 != a2)
            {
              unint64_t v97 = v13 + 1;
              if (v13 + 1 != a2)
              {
                uint64_t v98 = *a3;
                do
                {
                  uint64_t v100 = *v11;
                  uint64_t v99 = v11[1];
                  uint64_t v11 = v97;
                  float v101 = *(float *)(v98 + 4 * v99);
                  if (v101 > *(float *)(v98 + 4 * v100))
                  {
                    do
                    {
                      int *v97 = v100;
                      uint64_t v100 = *(v97 - 2);
                      --v97;
                    }
                    while (v101 > *(float *)(v98 + 4 * v100));
                    int *v97 = v99;
                  }
                  unint64_t v97 = v11 + 1;
                }
                while (v11 + 1 != a2);
              }
            }
            return result;
          }
          if (!a4)
          {
            if (v13 != a2)
            {
              int64_t v69 = (v15 - 2) >> 1;
              uint64_t v70 = *a3;
              int64_t v71 = v69;
              do
              {
                int64_t v72 = v71;
                if (v69 >= v71)
                {
                  uint64_t v73 = (2 * v71) | 1;
                  int v74 = &v13[v73];
                  if (2 * v72 + 2 < (uint64_t)v15 && *(float *)(v70 + 4 * *v74) > *(float *)(v70 + 4 * v74[1]))
                  {
                    ++v74;
                    uint64_t v73 = 2 * v72 + 2;
                  }
                  uint64_t v75 = &v13[v72];
                  uint64_t result = (int *)*v74;
                  uint64_t v76 = *v75;
                  float v77 = *(float *)(v70 + 4 * v76);
                  if (*(float *)(v70 + 4 * (void)result) <= v77)
                  {
                    do
                    {
                      char v78 = v74;
                      *uint64_t v75 = (int)result;
                      if (v69 < v73) {
                        break;
                      }
                      uint64_t v79 = 2 * v73;
                      uint64_t v73 = (2 * v73) | 1;
                      int v74 = &v13[v73];
                      uint64_t v80 = v79 + 2;
                      if (v80 < (uint64_t)v15 && *(float *)(v70 + 4 * *v74) > *(float *)(v70 + 4 * v74[1]))
                      {
                        ++v74;
                        uint64_t v73 = v80;
                      }
                      uint64_t result = (int *)*v74;
                      uint64_t v75 = v78;
                    }
                    while (*(float *)(v70 + 4 * (void)result) <= v77);
                    *char v78 = v76;
                  }
                }
                int64_t v71 = v72 - 1;
              }
              while (v72);
              uint64_t v81 = (unint64_t)v14 >> 2;
              do
              {
                uint64_t v82 = 0;
                int v83 = *v13;
                uint64_t v84 = *a3;
                float v85 = v13;
                do
                {
                  float v86 = v85;
                  v85 += v82 + 1;
                  uint64_t v87 = 2 * v82;
                  uint64_t v82 = (2 * v82) | 1;
                  uint64_t v88 = v87 + 2;
                  if (v88 < v81)
                  {
                    uint64_t result = (int *)*v85;
                    if (*(float *)(v84 + 4 * (void)result) > *(float *)(v84 + 4 * v85[1]))
                    {
                      ++v85;
                      uint64_t v82 = v88;
                    }
                  }
                  *float v86 = *v85;
                }
                while (v82 <= (uint64_t)((unint64_t)(v81 - 2) >> 1));
                if (v85 == --a2)
                {
                  int *v85 = v83;
                }
                else
                {
                  int *v85 = *a2;
                  *a2 = v83;
                  uint64_t v89 = (char *)v85 - (char *)v13 + 4;
                  if (v89 >= 5)
                  {
                    unint64_t v90 = (((unint64_t)v89 >> 2) - 2) >> 1;
                    int v91 = &v13[v90];
                    uint64_t v92 = *v91;
                    uint64_t v93 = *v85;
                    float v94 = *(float *)(v84 + 4 * v93);
                    if (*(float *)(v84 + 4 * v92) > v94)
                    {
                      do
                      {
                        uint64_t v95 = v91;
                        int *v85 = v92;
                        if (!v90) {
                          break;
                        }
                        unint64_t v90 = (v90 - 1) >> 1;
                        int v91 = &v13[v90];
                        uint64_t v92 = *v91;
                        float v85 = v95;
                      }
                      while (*(float *)(v84 + 4 * v92) > v94);
                      *uint64_t v95 = v93;
                    }
                  }
                }
              }
              while (v81-- > 2);
            }
            return result;
          }
          unint64_t v16 = v15 >> 1;
          uint64_t v17 = &v13[v15 >> 1];
          uint64_t v18 = *a3;
          if ((unint64_t)v14 >= 0x201)
          {
            sub_1DC38C7A0(v11, &v11[v15 >> 1], a2 - 1, v18);
            sub_1DC38C7A0(v11 + 1, v17 - 1, a2 - 2, *a3);
            sub_1DC38C7A0(v11 + 2, &v11[v16 + 1], a2 - 3, *a3);
            uint64_t result = sub_1DC38C7A0(v17 - 1, v17, &v11[v16 + 1], *a3);
            int v19 = *v11;
            *uint64_t v11 = *v17;
            *uint64_t v17 = v19;
          }
          else
          {
            uint64_t result = sub_1DC38C7A0(&v11[v15 >> 1], v11, a2 - 1, v18);
          }
          --a4;
          int v20 = *v11;
          uint64_t v21 = *a3;
          if (a5) {
            break;
          }
          float v22 = *(float *)(v21 + 4 * v20);
          if (*(float *)(v21 + 4 * *(v11 - 1)) > v22) {
            goto LABEL_13;
          }
          if (v22 <= *(float *)(v21 + 4 * *v12))
          {
            uint64_t v38 = v11 + 1;
            do
            {
              uint64_t v13 = v38;
              if (v38 >= a2) {
                break;
              }
              ++v38;
            }
            while (v22 <= *(float *)(v21 + 4 * *v13));
          }
          else
          {
            uint64_t v13 = v11;
            do
            {
              uint64_t v37 = v13[1];
              ++v13;
            }
            while (v22 <= *(float *)(v21 + 4 * v37));
          }
          uint64_t v39 = a2;
          if (v13 < a2)
          {
            uint64_t v39 = a2;
            do
              uint64_t v40 = *--v39;
            while (v22 > *(float *)(v21 + 4 * v40));
          }
          if (v13 < v39)
          {
            int v41 = *v13;
            int v42 = *v39;
            do
            {
              int *v13 = v42;
              *uint64_t v39 = v41;
              do
              {
                uint64_t v43 = v13[1];
                ++v13;
                int v41 = v43;
              }
              while (v22 <= *(float *)(v21 + 4 * v43));
              do
              {
                uint64_t v44 = *--v39;
                int v42 = v44;
              }
              while (v22 > *(float *)(v21 + 4 * v44));
            }
            while (v13 < v39);
          }
          char v45 = v13 - 1;
          BOOL v5 = v13 - 1 >= v11;
          BOOL v6 = v13 - 1 == v11;
          if (v13 - 1 != v11) {
            *uint64_t v11 = *v45;
          }
          a5 = 0;
          *char v45 = v20;
        }
        float v22 = *(float *)(v21 + 4 * v20);
LABEL_13:
        uint64_t v23 = v11;
        do
        {
          uint64_t v24 = v23;
          uint64_t v26 = v23[1];
          ++v23;
          int v25 = v26;
        }
        while (*(float *)(v21 + 4 * v26) > v22);
        unint64_t v27 = a2;
        if (v24 == v11)
        {
          unint64_t v27 = a2;
          do
          {
            if (v23 >= v27) {
              break;
            }
            uint64_t v29 = *--v27;
          }
          while (*(float *)(v21 + 4 * v29) <= v22);
        }
        else
        {
          do
            uint64_t v28 = *--v27;
          while (*(float *)(v21 + 4 * v28) <= v22);
        }
        if (v23 < v27)
        {
          int v30 = *v27;
          int v31 = v25;
          char v32 = v23;
          uint64_t v33 = v27;
          do
          {
            *char v32 = v30;
            *uint64_t v33 = v31;
            do
            {
              uint64_t v24 = v32;
              uint64_t v34 = v32[1];
              ++v32;
              int v31 = v34;
            }
            while (*(float *)(v21 + 4 * v34) > v22);
            do
            {
              uint64_t v35 = *--v33;
              int v30 = v35;
            }
            while (*(float *)(v21 + 4 * v35) <= v22);
          }
          while (v32 < v33);
        }
        if (v24 != v11) {
          *uint64_t v11 = *v24;
        }
        *uint64_t v24 = v20;
        if (v23 >= v27) {
          break;
        }
LABEL_32:
        uint64_t result = (int *)sub_1DC38BD54(v11, v24, a3, a4, a5 & 1);
        a5 = 0;
        uint64_t v13 = v24 + 1;
      }
      BOOL v36 = sub_1DC38C8D4(v11, v24, a3);
      uint64_t v13 = v24 + 1;
      uint64_t result = (int *)sub_1DC38C8D4(v24 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v36) {
        goto LABEL_32;
      }
    }
    a2 = v24;
    if (!v36) {
      continue;
    }
    return result;
  }
}

float sub_1DC38C4E8(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  v44[1] = *MEMORY[0x1E4F143B8];
  if ((a2 & 0x80000000) != 0) {
    return -3.4028e38;
  }
  unsigned int v5 = a3;
  float result = -3.4028e38;
  if ((a3 & 0x80000000) == 0)
  {
    unsigned int v7 = a2;
    uint64_t v8 = *(void **)(a1 + 8);
    uint64_t v9 = v8[7];
    uint64_t v10 = -v9;
    uint64_t v11 = v8[4];
    uint64_t v12 = v9 - 1;
    uint64_t v13 = v8[2];
    unint64_t v14 = v13 & (v9 - 1) | v11 & -v9;
    if (v14 > a2)
    {
      float result = -3.4028e38;
      if ((a4 & 0x80000000) == 0)
      {
        unint64_t v15 = v11 & v12 | v13 & v10;
        if (v15 > a3)
        {
          float result = -3.4028e38;
          if ((a5 & 0x80000000) == 0 && v14 > a4 && v15 > a5)
          {
            int v17 = a4 > a2 ? 1 : -1;
            int v42 = v17;
            unsigned int v18 = (int)(a4 - a2) >= 0 ? a4 - a2 : a2 - a4;
            int v19 = a5 > a3 ? 1 : -1;
            int v41 = v19;
            int v20 = (int)(a5 - a3) >= 0 ? a5 - a3 : a3 - a5;
            int v21 = v18 <= v20 ? -v20 : v18;
            int v22 = v21 / 2;
            v44[0] = 0;
            unsigned __int8 v23 = sub_1DC2FF924(v8, a2, a3);
            int v24 = 0;
            int v25 = 0;
            int v26 = -v18;
            while (1)
            {
              unsigned int v27 = sub_1DC2FF924(v8, (int)v7, (int)v5);
              uint64_t v28 = (_DWORD *)((unint64_t)v44 | (4 * v27));
              int v29 = *v28 + 1;
              *uint64_t v28 = v29;
              int v30 = v25 <= v24 ? v24 : v25;
              if ((v23 ^ v27))
              {
                int v24 = v30;
                int v25 = 1;
              }
              else
              {
                ++v25;
              }
              if (v5 == a5 && v7 == a4) {
                break;
              }
              if ((v23 ^ v27)) {
                unsigned __int8 v23 = v27;
              }
              if (v22 <= v26) {
                int v31 = 0;
              }
              else {
                int v31 = v20;
              }
              int v32 = v42;
              if (v22 <= v26) {
                int v32 = 0;
              }
              int v33 = v22 - v31;
              v7 += v32;
              BOOL v34 = v22 < v20;
              if (v22 >= v20) {
                unsigned int v35 = 0;
              }
              else {
                unsigned int v35 = v18;
              }
              int v22 = v33 + v35;
              int v36 = v41;
              if (!v34) {
                int v36 = 0;
              }
              v5 += v36;
            }
            *(_DWORD *)((unint64_t)v44 | (4 * v27)) = v29 - v25;
            float v37 = fabsf((float)((float)SLODWORD(v44[0]) / (float)(HIDWORD(v44[0]) + LODWORD(v44[0]))) + -0.5);
            float v38 = (float)v24 / (float)(HIDWORD(v44[0]) + LODWORD(v44[0]));
            BOOL v39 = v37 <= 0.3 && v38 <= 0.4;
            float result = -(float)(v37 - (float)(v38 * -4.0));
            if (!v39) {
              return -3.4028e38;
            }
          }
        }
      }
    }
  }
  return result;
}

void sub_1DC38C740(void **a1)
{
  uint64_t v1 = (atomic_uint **)*a1;
  if (*a1)
  {
    uint64_t v3 = (atomic_uint **)a1[1];
    BOOL v4 = v1;
    if (v3 != v1)
    {
      do
        uint64_t v3 = sub_1DC35D870(v3 - 1);
      while (v3 != v1);
      BOOL v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

int *sub_1DC38C7A0(int *result, int *a2, int *a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *result;
  float v6 = *(float *)(a4 + 4 * v4);
  float v7 = *(float *)(a4 + 4 * v5);
  uint64_t v8 = *a3;
  float v9 = *(float *)(a4 + 4 * v8);
  if (v6 <= v7)
  {
    if (v9 > v6)
    {
      *a2 = v8;
      *a3 = v4;
      uint64_t v10 = *a2;
      uint64_t v11 = *result;
      if (*(float *)(a4 + 4 * v10) > *(float *)(a4 + 4 * v11))
      {
        *float result = v10;
        *a2 = v11;
      }
    }
  }
  else
  {
    if (v9 <= v6)
    {
      *float result = v4;
      *a2 = v5;
      uint64_t v12 = *a3;
      if (*(float *)(a4 + 4 * v12) <= v7) {
        return result;
      }
      *a2 = v12;
    }
    else
    {
      *float result = v8;
    }
    *a3 = v5;
  }
  return result;
}

int *sub_1DC38C828(int *a1, int *a2, int *a3, int *a4, uint64_t *a5)
{
  float result = sub_1DC38C7A0(a1, a2, a3, *a5);
  uint64_t v11 = *a4;
  uint64_t v12 = *a3;
  uint64_t v13 = *a5;
  if (*(float *)(*a5 + 4 * v11) > *(float *)(*a5 + 4 * v12))
  {
    *a3 = v11;
    *a4 = v12;
    uint64_t v14 = *a3;
    uint64_t v15 = *a2;
    if (*(float *)(v13 + 4 * v14) > *(float *)(v13 + 4 * v15))
    {
      *a2 = v14;
      *a3 = v15;
      uint64_t v16 = *a2;
      uint64_t v17 = *a1;
      if (*(float *)(v13 + 4 * v16) > *(float *)(v13 + 4 * v17))
      {
        *a1 = v16;
        *a2 = v17;
      }
    }
  }
  return result;
}

BOOL sub_1DC38C8D4(int *a1, int *a2, uint64_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(float *)(*a3 + 4 * v8) > *(float *)(*a3 + 4 * v9))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      sub_1DC38C7A0(a1, a1 + 1, a2 - 1, *a3);
      return 1;
    case 4:
      sub_1DC38C828(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      int v21 = a1 + 2;
      int v22 = a1 + 3;
      sub_1DC38C828(a1, a1 + 1, a1 + 2, a1 + 3, a3);
      uint64_t v23 = *(a2 - 1);
      uint64_t v24 = a1[3];
      uint64_t v25 = *a3;
      if (*(float *)(*a3 + 4 * v23) > *(float *)(*a3 + 4 * v24))
      {
        *int v22 = v23;
        *(a2 - 1) = v24;
        uint64_t v26 = *v22;
        uint64_t v27 = *v21;
        float v28 = *(float *)(v25 + 4 * v26);
        if (v28 > *(float *)(v25 + 4 * v27))
        {
          *int v21 = v26;
          *int v22 = v27;
          uint64_t v29 = a1[1];
          if (v28 > *(float *)(v25 + 4 * v29))
          {
            a1[1] = v26;
            a1[2] = v29;
            uint64_t v30 = *a1;
            if (v28 > *(float *)(v25 + 4 * v30))
            {
              *a1 = v26;
              a1[1] = v30;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      sub_1DC38C7A0(a1, a1 + 1, a1 + 2, *a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = *a3;
      uint64_t v14 = 12;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v11;
    uint64_t v16 = *v10;
    float v17 = *(float *)(v13 + 4 * v15);
    if (v17 > *(float *)(v13 + 4 * v16))
    {
      uint64_t v18 = v14;
      while (1)
      {
        *(int *)((char *)a1 + v18) = v16;
        uint64_t v19 = v18 - 4;
        if (v18 == 4) {
          break;
        }
        uint64_t v16 = *(int *)((char *)a1 + v18 - 8);
        v18 -= 4;
        if (v17 <= *(float *)(v13 + 4 * v16))
        {
          int v20 = (int *)((char *)a1 + v19);
          goto LABEL_13;
        }
      }
      int v20 = a1;
LABEL_13:
      *int v20 = v15;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v14 += 4;
    if (++v11 == a2) {
      return 1;
    }
  }
}

atomic_uint **sub_1DC38CB00(atomic_uint **a1, atomic_uint **a2, atomic_uint **a3, uint64_t (**a4)(atomic_uint **, atomic_uint **))
{
  uint64_t v8 = *a4;
  uint64_t v9 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
  }
  float v38 = v9;
  uint64_t v10 = *a1;
  if (*a1) {
    atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
  }
  float v37 = v10;
  char v11 = v8(&v38, &v37);
  sub_1DC35D870(&v37);
  sub_1DC35D870(&v38);
  int v12 = *a4;
  uint64_t v13 = *a3;
  if (v11)
  {
    if (v13) {
      atomic_fetch_add_explicit(v13 + 2, 1u, memory_order_relaxed);
    }
    int v32 = v13;
    uint64_t v14 = *a2;
    if (*a2) {
      atomic_fetch_add_explicit(v14 + 2, 1u, memory_order_relaxed);
    }
    int v31 = v14;
    int v15 = v12(&v32, &v31);
    sub_1DC35D870(&v31);
    sub_1DC35D870(&v32);
    uint64_t v16 = a1;
    if (v15) {
      goto LABEL_17;
    }
    sub_1DC38A538(a1, a2);
    float v17 = *a4;
    uint64_t v18 = *a3;
    if (*a3) {
      atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v30 = v18;
    uint64_t v19 = *a2;
    if (*a2) {
      atomic_fetch_add_explicit(v19 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v29 = v19;
    int v20 = v17(&v30, &v29);
    sub_1DC35D870(&v29);
    BOOL result = sub_1DC35D870(&v30);
    if (v20)
    {
      uint64_t v16 = a2;
LABEL_17:
      int v22 = a3;
      return sub_1DC38A538(v16, v22);
    }
  }
  else
  {
    if (v13) {
      atomic_fetch_add_explicit(v13 + 2, 1u, memory_order_relaxed);
    }
    int v36 = v13;
    uint64_t v23 = *a2;
    if (*a2) {
      atomic_fetch_add_explicit(v23 + 2, 1u, memory_order_relaxed);
    }
    unsigned int v35 = v23;
    char v24 = v12(&v36, &v35);
    sub_1DC35D870(&v35);
    BOOL result = sub_1DC35D870(&v36);
    if (v24)
    {
      sub_1DC38A538(a2, a3);
      uint64_t v25 = *a4;
      uint64_t v26 = *a2;
      if (*a2) {
        atomic_fetch_add_explicit(v26 + 2, 1u, memory_order_relaxed);
      }
      BOOL v34 = v26;
      uint64_t v27 = *a1;
      if (*a1) {
        atomic_fetch_add_explicit(v27 + 2, 1u, memory_order_relaxed);
      }
      int v33 = v27;
      int v28 = v25(&v34, &v33);
      sub_1DC35D870(&v33);
      BOOL result = sub_1DC35D870(&v34);
      if (v28)
      {
        uint64_t v16 = a1;
        int v22 = a2;
        return sub_1DC38A538(v16, v22);
      }
    }
  }
  return result;
}

void sub_1DC38CD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, atomic_uint *);
  sub_1DC35D870((atomic_uint **)va);
  sub_1DC35D870((atomic_uint **)va1);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC38CD84(atomic_uint **a1, atomic_uint **a2, atomic_uint **a3, atomic_uint **a4, uint64_t (**a5)(atomic_uint **, atomic_uint **))
{
  sub_1DC38CB00(a1, a2, a3, a5);
  uint64_t v10 = *a5;
  char v11 = *a4;
  if (*a4) {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
  }
  int v28 = v11;
  int v12 = *a3;
  if (*a3) {
    atomic_fetch_add_explicit(v12 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v27 = v12;
  int v13 = v10(&v28, &v27);
  sub_1DC35D870(&v27);
  BOOL result = sub_1DC35D870(&v28);
  if (v13)
  {
    sub_1DC38A538(a3, a4);
    int v15 = *a5;
    uint64_t v16 = *a3;
    if (*a3) {
      atomic_fetch_add_explicit(v16 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v26 = v16;
    float v17 = *a2;
    if (*a2) {
      atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v25 = v17;
    int v18 = v15(&v26, &v25);
    sub_1DC35D870(&v25);
    BOOL result = sub_1DC35D870(&v26);
    if (v18)
    {
      sub_1DC38A538(a2, a3);
      uint64_t v19 = *a5;
      int v20 = *a2;
      if (*a2) {
        atomic_fetch_add_explicit(v20 + 2, 1u, memory_order_relaxed);
      }
      char v24 = v20;
      int v21 = *a1;
      if (*a1) {
        atomic_fetch_add_explicit(v21 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v23 = v21;
      int v22 = v19(&v24, &v23);
      sub_1DC35D870(&v23);
      BOOL result = sub_1DC35D870(&v24);
      if (v22) {
        return sub_1DC38A538(a1, a2);
      }
    }
  }
  return result;
}

void sub_1DC38CF00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, atomic_uint *a10)
{
}

atomic_uint **sub_1DC38CF40(atomic_uint **a1, atomic_uint **a2, atomic_uint **a3, atomic_uint **a4, atomic_uint **a5, uint64_t (**a6)(atomic_uint **, atomic_uint **))
{
  sub_1DC38CD84(a1, a2, a3, a4, a6);
  int v12 = *a6;
  int v13 = *a5;
  if (*a5) {
    atomic_fetch_add_explicit(v13 + 2, 1u, memory_order_relaxed);
  }
  int v36 = v13;
  uint64_t v14 = *a4;
  if (*a4) {
    atomic_fetch_add_explicit(v14 + 2, 1u, memory_order_relaxed);
  }
  unsigned int v35 = v14;
  int v15 = v12(&v36, &v35);
  sub_1DC35D870(&v35);
  BOOL result = sub_1DC35D870(&v36);
  if (v15)
  {
    sub_1DC38A538(a4, a5);
    float v17 = *a6;
    int v18 = *a4;
    if (*a4) {
      atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
    }
    BOOL v34 = v18;
    uint64_t v19 = *a3;
    if (*a3) {
      atomic_fetch_add_explicit(v19 + 2, 1u, memory_order_relaxed);
    }
    int v33 = v19;
    int v20 = v17(&v34, &v33);
    sub_1DC35D870(&v33);
    BOOL result = sub_1DC35D870(&v34);
    if (v20)
    {
      sub_1DC38A538(a3, a4);
      int v21 = *a6;
      int v22 = *a3;
      if (*a3) {
        atomic_fetch_add_explicit(v22 + 2, 1u, memory_order_relaxed);
      }
      int v32 = v22;
      uint64_t v23 = *a2;
      if (*a2) {
        atomic_fetch_add_explicit(v23 + 2, 1u, memory_order_relaxed);
      }
      int v31 = v23;
      int v24 = v21(&v32, &v31);
      sub_1DC35D870(&v31);
      BOOL result = sub_1DC35D870(&v32);
      if (v24)
      {
        sub_1DC38A538(a2, a3);
        uint64_t v25 = *a6;
        uint64_t v26 = *a2;
        if (*a2) {
          atomic_fetch_add_explicit(v26 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v30 = v26;
        uint64_t v27 = *a1;
        if (*a1) {
          atomic_fetch_add_explicit(v27 + 2, 1u, memory_order_relaxed);
        }
        uint64_t v29 = v27;
        int v28 = v25(&v30, &v29);
        sub_1DC35D870(&v29);
        BOOL result = sub_1DC35D870(&v30);
        if (v28) {
          return sub_1DC38A538(a1, a2);
        }
      }
    }
  }
  return result;
}

void sub_1DC38D12C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, atomic_uint *a10)
{
}

uint64_t sub_1DC38D17C(atomic_uint **a1, atomic_uint **a2, uint64_t (**a3)(atomic_uint **, atomic_uint **))
{
  BOOL v6 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v6;
    case 2:
      float v7 = *a3;
      uint64_t v9 = a2 - 1;
      uint64_t v8 = *(a2 - 1);
      if (v8) {
        atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
      }
      float v38 = v8;
      uint64_t v10 = *a1;
      if (*a1) {
        atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
      }
      float v37 = v10;
      int v11 = v7(&v38, &v37);
      sub_1DC35D870(&v37);
      sub_1DC35D870(&v38);
      if (v11) {
        sub_1DC38A538(a1, v9);
      }
      return v6;
    case 3:
      sub_1DC38CB00(a1, a1 + 1, a2 - 1, a3);
      return v6;
    case 4:
      sub_1DC38CD84(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return v6;
    case 5:
      sub_1DC38CF40(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return v6;
    default:
      int v12 = a1 + 2;
      sub_1DC38CB00(a1, a1 + 1, a1 + 2, a3);
      int v13 = a1 + 3;
      BOOL v6 = 1;
      if (a1 + 3 == a2) {
        return v6;
      }
      uint64_t v14 = 0;
      int v15 = 0;
      break;
  }
  while (1)
  {
    uint64_t v16 = *a3;
    float v17 = *v13;
    if (*v13) {
      atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
    }
    unsigned int v35 = 0;
    int v36 = v17;
    int v18 = *v12;
    if (*v12) {
      atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
    }
    unsigned int v35 = v18;
    int v19 = v16(&v36, &v35);
    sub_1DC35D870(&v35);
    sub_1DC35D870(&v36);
    if (!v19) {
      goto LABEL_37;
    }
    int v20 = *v13;
    if (*v13) {
      atomic_fetch_add_explicit(v20 + 2, 1u, memory_order_relaxed);
    }
    BOOL v34 = v20;
    uint64_t v21 = v14;
    while (1)
    {
      int v22 = (char *)a1 + v21;
      uint64_t v23 = *(uint64_t *)((char *)a1 + v21 + 16);
      if (v23) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v23 + 8), 1u, memory_order_relaxed);
      }
      int v24 = (atomic_uint *)*((void *)v22 + 3);
      if (v24) {
        sub_1DC2FF57C(v24);
      }
      *((void *)v22 + 3) = v23;
      if (v21 == -16) {
        break;
      }
      uint64_t v25 = *a3;
      uint64_t v26 = v34;
      if (v34) {
        atomic_fetch_add_explicit(v34 + 2, 1u, memory_order_relaxed);
      }
      int v32 = 0;
      int v33 = v26;
      uint64_t v27 = *(atomic_uint **)((char *)a1 + v21 + 8);
      if (v27) {
        atomic_fetch_add_explicit(v27 + 2, 1u, memory_order_relaxed);
      }
      int v32 = v27;
      char v28 = v25(&v33, &v32);
      sub_1DC35D870(&v32);
      sub_1DC35D870(&v33);
      v21 -= 8;
      if ((v28 & 1) == 0)
      {
        uint64_t v29 = (atomic_uint **)((char *)a1 + v21 + 24);
        goto LABEL_31;
      }
    }
    uint64_t v29 = a1;
LABEL_31:
    uint64_t v30 = v34;
    if (v34) {
      atomic_fetch_add_explicit(v34 + 2, 1u, memory_order_relaxed);
    }
    if (*v29) {
      sub_1DC2FF57C(*v29);
    }
    *uint64_t v29 = v30;
    if (++v15 == 8) {
      break;
    }
    sub_1DC35D870(&v34);
LABEL_37:
    int v12 = v13;
    v14 += 8;
    if (++v13 == a2) {
      return 1;
    }
  }
  BOOL v6 = v13 + 1 == a2;
  sub_1DC35D870(&v34);
  return v6;
}

void sub_1DC38D454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, atomic_uint *);
  sub_1DC35D870((atomic_uint **)va);
  sub_1DC35D870((atomic_uint **)va1);
  _Unwind_Resume(a1);
}

BOOL sub_1DC38D4C4(uint64_t a1, uint64_t a2)
{
  return (float)(*(float *)(*(void *)a1 + 20) - *(float *)(*(void *)a2 + 20)) < 0.0;
}

uint64_t sub_1DC38D4E4(uint64_t result, atomic_uint **a2, uint64_t a3, char a4)
{
  uint64_t v8 = (atomic_uint **)result;
LABEL_2:
  uint64_t v9 = a2;
  uint64_t v10 = a2 - 1;
  int v11 = v8;
  while (1)
  {
    uint64_t v8 = v11;
    uint64_t v12 = (char *)v9 - (char *)v11;
    uint64_t v13 = v9 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v41 = (uint64_t)*(a2 - 1);
          float v94 = a2 - 1;
          if (*(float *)(v41 + 24) > *((float *)*v8 + 6)) {
            BOOL result = (uint64_t)sub_1DC38A538(v8, v94);
          }
          break;
        case 3:
          BOOL result = (uint64_t)sub_1DC38A5E8(v8, v8 + 1, v10);
          break;
        case 4:
          BOOL result = (uint64_t)sub_1DC38A6C4(v8, v8 + 1, v8 + 2, v10);
          break;
        case 5:
          BOOL result = (uint64_t)sub_1DC38A784(v8, v8 + 1, v8 + 2, v8 + 3, v10);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191)
    {
      BOOL v5 = v8 == v9;
      int v42 = v9;
      uint64_t v43 = v8 + 1;
      char v45 = v5 || v43 == v42;
      if (a4)
      {
        if ((v45 & 1) == 0)
        {
          uint64_t v46 = 0;
          uint64_t v47 = v8;
          do
          {
            uint64_t v48 = *v43;
            if (*((float *)*v43 + 6) > *((float *)*v47 + 6))
            {
              unint64_t v49 = 0;
              atomic_fetch_add_explicit(v48 + 2, 1u, memory_order_relaxed);
              unint64_t v96 = v48;
              float v50 = *v47;
              while (1)
              {
                if (v50) {
                  atomic_fetch_add_explicit(v50 + 2, 1u, memory_order_relaxed);
                }
                uint64_t v51 = v47[v49 / 8 + 1];
                if (v51) {
                  sub_1DC2FF57C(v51);
                }
                v47[v49 / 8 + 1] = v50;
                uint64_t v52 = v96;
                if (v46 == v49) {
                  break;
                }
                float v50 = v47[v49 / 8 - 1];
                v49 -= 8;
                if (*((float *)v96 + 6) <= *((float *)v50 + 6))
                {
                  uint64_t v53 = &v43[v49 / 8];
                  goto LABEL_97;
                }
              }
              uint64_t v53 = v8;
              if (!v96) {
                goto LABEL_98;
              }
LABEL_97:
              atomic_fetch_add_explicit(v96 + 2, 1u, memory_order_relaxed);
LABEL_98:
              if (*v53) {
                sub_1DC2FF57C(*v53);
              }
              atomic_uint *v53 = v52;
              BOOL result = (uint64_t)sub_1DC35D870(&v96);
            }
            ++v43;
            ++v47;
            v46 -= 8;
          }
          while (v43 != a2);
        }
      }
      else if ((v45 & 1) == 0)
      {
        do
        {
          uint64_t v89 = v43;
          unint64_t v90 = v8[1];
          if (*((float *)v90 + 6) > *((float *)*v8 + 6))
          {
            atomic_fetch_add_explicit(v90 + 2, 1u, memory_order_relaxed);
            unint64_t v96 = v90;
            int v91 = *v8;
            do
            {
              if (v91) {
                atomic_fetch_add_explicit(v91 + 2, 1u, memory_order_relaxed);
              }
              if (*v43) {
                sub_1DC2FF57C(*v43);
              }
              *uint64_t v43 = v91;
              uint64_t v92 = v96;
              int v91 = *(v43 - 2);
              --v43;
            }
            while (*((float *)v96 + 6) > *((float *)v91 + 6));
            atomic_fetch_add_explicit(v96 + 2, 1u, memory_order_relaxed);
            if (*v43) {
              sub_1DC2FF57C(*v43);
            }
            *uint64_t v43 = v92;
            BOOL result = (uint64_t)sub_1DC35D870(&v96);
          }
          uint64_t v43 = v89 + 1;
          uint64_t v8 = v89;
        }
        while (v89 + 1 != a2);
      }
      return result;
    }
    if (!a3) {
      break;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    int v15 = &v8[(unint64_t)v13 >> 1];
    if ((unint64_t)v12 < 0x401)
    {
      sub_1DC38A5E8(v15, v8, v10);
    }
    else
    {
      sub_1DC38A5E8(v8, v15, v10);
      sub_1DC38A5E8(v8 + 1, v15 - 1, a2 - 2);
      sub_1DC38A5E8(v8 + 2, &v8[v14 + 1], a2 - 3);
      sub_1DC38A5E8(v15 - 1, v15, &v8[v14 + 1]);
      sub_1DC38A878(v8, v15);
    }
    --a3;
    uint64_t v16 = a2;
    if (a4)
    {
      float v17 = *v8;
      if (!*v8) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
    float v17 = *v8;
    float v18 = *((float *)*v8 + 6);
    if (*((float *)*(v8 - 1) + 6) <= v18)
    {
      atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      unint64_t v96 = v17;
      if (v18 <= *((float *)*v10 + 6))
      {
        int v33 = v8 + 1;
        do
        {
          int v11 = v33;
          if (v33 >= a2) {
            break;
          }
          ++v33;
        }
        while (v18 <= *((float *)*v11 + 6));
      }
      else
      {
        int v11 = v8;
        do
        {
          int v32 = v11[1];
          ++v11;
        }
        while (v18 <= *((float *)v32 + 6));
      }
      BOOL v34 = a2;
      if (v11 < a2)
      {
        BOOL v34 = a2;
        do
          uint64_t v35 = (uint64_t)*--v34;
        while (v18 > *(float *)(v35 + 24));
      }
      while (v11 < v34)
      {
        sub_1DC38A538(v11, v34);
        float v17 = v96;
        float v36 = *((float *)v96 + 6);
        do
        {
          float v37 = v11[1];
          ++v11;
        }
        while (v36 <= *((float *)v37 + 6));
        do
          uint64_t v38 = (uint64_t)*--v34;
        while (v36 > *(float *)(v38 + 24));
      }
      BOOL v39 = v11 - 1;
      if (v11 - 1 != v8)
      {
        uint64_t v40 = *v39;
        if (*v39) {
          atomic_fetch_add_explicit(v40 + 2, 1u, memory_order_relaxed);
        }
        if (*v8) {
          sub_1DC2FF57C(*v8);
        }
        atomic_uint *v8 = v40;
        float v17 = v96;
      }
      if (v17) {
        atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      }
      if (*v39) {
        sub_1DC2FF57C(*v39);
      }
      *BOOL v39 = v17;
      BOOL result = (uint64_t)sub_1DC35D870(&v96);
      a4 = 0;
      uint64_t v9 = a2;
    }
    else
    {
LABEL_14:
      atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
LABEL_15:
      unint64_t v96 = v17;
      float v19 = *((float *)v17 + 6);
      int v20 = v8;
      do
      {
        uint64_t v21 = v20;
        int v22 = v20[1];
        ++v20;
      }
      while (*((float *)v22 + 6) > v19);
      if (v21 == v8)
      {
        uint64_t v16 = a2;
        do
        {
          if (v20 >= v16) {
            break;
          }
          uint64_t v24 = (uint64_t)*--v16;
        }
        while (*(float *)(v24 + 24) <= v19);
      }
      else
      {
        do
          uint64_t v23 = (uint64_t)*--v16;
        while (*(float *)(v23 + 24) <= v19);
      }
      int v11 = v20;
      if (v20 < v16)
      {
        uint64_t v25 = v16;
        do
        {
          sub_1DC38A538(v11, v25);
          float v17 = v96;
          float v26 = *((float *)v96 + 6);
          do
          {
            uint64_t v27 = v11[1];
            ++v11;
          }
          while (*((float *)v27 + 6) > v26);
          do
            uint64_t v28 = (uint64_t)*--v25;
          while (*(float *)(v28 + 24) <= v26);
        }
        while (v11 < v25);
      }
      uint64_t v29 = v11 - 1;
      if (v11 - 1 != v8)
      {
        uint64_t v30 = *v29;
        if (*v29) {
          atomic_fetch_add_explicit(v30 + 2, 1u, memory_order_relaxed);
        }
        if (*v8) {
          sub_1DC2FF57C(*v8);
        }
        atomic_uint *v8 = v30;
        float v17 = v96;
      }
      if (v17) {
        atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      }
      if (*v29) {
        sub_1DC2FF57C(*v29);
      }
      *uint64_t v29 = v17;
      sub_1DC35D870(&v96);
      BOOL v4 = v20 >= v16;
      uint64_t v9 = a2;
      if (!v4) {
        goto LABEL_43;
      }
      char v31 = sub_1DC38EB54(v8, v11 - 1);
      BOOL result = sub_1DC38EB54(v11, a2);
      if (result)
      {
        a2 = v11 - 1;
        if (v31) {
          return result;
        }
        goto LABEL_2;
      }
      if ((v31 & 1) == 0)
      {
LABEL_43:
        BOOL result = sub_1DC38D4E4(v8, v11 - 1, a3, a4 & 1);
        a4 = 0;
      }
    }
  }
  if (v8 != v9)
  {
    int64_t v54 = (unint64_t)(v13 - 2) >> 1;
    int64_t v55 = v54;
    do
    {
      int64_t v56 = v55;
      if (v54 >= v55)
      {
        uint64_t v57 = (2 * v55) | 1;
        uint64_t v58 = &v8[v57];
        if (2 * v56 + 2 < v13 && *((float *)*v58 + 6) > *((float *)v58[1] + 6))
        {
          ++v58;
          uint64_t v57 = 2 * v56 + 2;
        }
        int v59 = &v8[v56];
        uint64_t v60 = *v59;
        if (*((float *)*v58 + 6) <= *((float *)*v59 + 6))
        {
          atomic_fetch_add_explicit(v60 + 2, 1u, memory_order_relaxed);
          unint64_t v96 = v60;
          uint64_t v61 = *v58;
          while (1)
          {
            float v62 = v58;
            if (v61) {
              atomic_fetch_add_explicit(v61 + 2, 1u, memory_order_relaxed);
            }
            if (*v59) {
              sub_1DC2FF57C(*v59);
            }
            *int v59 = v61;
            if (v54 < v57) {
              break;
            }
            uint64_t v63 = 2 * v57;
            uint64_t v57 = (2 * v57) | 1;
            uint64_t v58 = &v8[v57];
            uint64_t v64 = v63 + 2;
            if (v64 < v13 && *((float *)*v58 + 6) > *((float *)v58[1] + 6))
            {
              ++v58;
              uint64_t v57 = v64;
            }
            uint64_t v61 = *v58;
            float v65 = v96;
            int v59 = v62;
            if (*((float *)*v58 + 6) > *((float *)v96 + 6)) {
              goto LABEL_122;
            }
          }
          float v65 = v96;
          if (v96) {
LABEL_122:
          }
            atomic_fetch_add_explicit(v65 + 2, 1u, memory_order_relaxed);
          if (*v62) {
            sub_1DC2FF57C(*v62);
          }
          int *v62 = v65;
          sub_1DC35D870(&v96);
        }
      }
      int64_t v55 = v56 - 1;
    }
    while (v56);
    uint64_t v66 = (unint64_t)v12 >> 3;
    while (2)
    {
      uint64_t v67 = *v8;
      if (*v8) {
        atomic_fetch_add_explicit(v67 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v68 = 0;
      uint64_t v95 = v67;
      int64_t v69 = v8;
LABEL_131:
      uint64_t v70 = &v69[v68];
      uint64_t v73 = v70[1];
      int64_t v71 = v70 + 1;
      int64_t v72 = v73;
      uint64_t v74 = 2 * v68;
      uint64_t v68 = (2 * v68) | 1;
      uint64_t v75 = v74 + 2;
      if (v75 >= v66)
      {
        if (v72) {
          goto LABEL_135;
        }
      }
      else
      {
        uint64_t v76 = v71[1];
        if (*((float *)v72 + 6) > *((float *)v76 + 6))
        {
          uint64_t v68 = v75;
          ++v71;
          int64_t v72 = v76;
        }
LABEL_135:
        atomic_fetch_add_explicit(v72 + 2, 1u, memory_order_relaxed);
      }
      if (*v69) {
        sub_1DC2FF57C(*v69);
      }
      *int64_t v69 = v72;
      int64_t v69 = v71;
      if (v68 > (uint64_t)((unint64_t)(v66 - 2) >> 1))
      {
        float v77 = a2 - 1;
        BOOL v5 = v71 == --a2;
        if (v5)
        {
          uint64_t v87 = v95;
          if (v95) {
            atomic_fetch_add_explicit(v95 + 2, 1u, memory_order_relaxed);
          }
          if (*v71) {
            sub_1DC2FF57C(*v71);
          }
          *int64_t v71 = v87;
        }
        else
        {
          char v78 = *v77;
          if (*v77) {
            atomic_fetch_add_explicit(v78 + 2, 1u, memory_order_relaxed);
          }
          if (*v71) {
            sub_1DC2FF57C(*v71);
          }
          *int64_t v71 = v78;
          uint64_t v79 = v95;
          if (v95) {
            atomic_fetch_add_explicit(v95 + 2, 1u, memory_order_relaxed);
          }
          if (*a2) {
            sub_1DC2FF57C(*a2);
          }
          *a2 = v79;
          uint64_t v80 = (char *)v71 - (char *)v8 + 8;
          if (v80 >= 9)
          {
            unint64_t v81 = (((unint64_t)v80 >> 3) - 2) >> 1;
            uint64_t v82 = &v8[v81];
            int v83 = *v71;
            if (*((float *)*v82 + 6) > *((float *)*v71 + 6))
            {
              atomic_fetch_add_explicit(v83 + 2, 1u, memory_order_relaxed);
              unint64_t v96 = v83;
              uint64_t v84 = *v82;
              while (1)
              {
                float v85 = v82;
                if (v84) {
                  atomic_fetch_add_explicit(v84 + 2, 1u, memory_order_relaxed);
                }
                if (*v71) {
                  sub_1DC2FF57C(*v71);
                }
                *int64_t v71 = v84;
                if (!v81) {
                  break;
                }
                unint64_t v81 = (v81 - 1) >> 1;
                uint64_t v82 = &v8[v81];
                uint64_t v84 = *v82;
                float v86 = v96;
                int64_t v71 = v85;
                if (*((float *)*v82 + 6) <= *((float *)v96 + 6)) {
                  goto LABEL_164;
                }
              }
              float v86 = v96;
              if (!v96) {
                goto LABEL_165;
              }
LABEL_164:
              atomic_fetch_add_explicit(v86 + 2, 1u, memory_order_relaxed);
LABEL_165:
              if (*v85) {
                sub_1DC2FF57C(*v85);
              }
              int *v85 = v86;
              sub_1DC35D870(&v96);
            }
          }
        }
        BOOL result = (uint64_t)sub_1DC35D870(&v95);
        if (v66-- <= 2) {
          return result;
        }
        continue;
      }
      goto LABEL_131;
    }
  }
  return result;
}

void sub_1DC38DE00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1DC35D870((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1DC38DE74(atomic_uint *a1, unint64_t a2)
{
  uint64_t v3 = *(void *)a1;
  BOOL v4 = (atomic_uint **)*((void *)a1 + 1);
  unint64_t v5 = ((uint64_t)v4 - *(void *)a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      unint64_t v14 = (atomic_uint **)(v3 + 8 * a2);
      while (v4 != v14)
        sub_1DC35D870(--v4);
      *((void *)a1 + 1) = v14;
    }
  }
  else
  {
    unint64_t v6 = a2 - v5;
    uint64_t v7 = *((void *)a1 + 2);
    if (a2 - v5 <= (v7 - (uint64_t)v4) >> 3)
    {
      bzero(*((void **)a1 + 1), 8 * v6);
      *((void *)a1 + 1) = &v4[v6];
    }
    else
    {
      if (a2 >> 61) {
        sub_1DC2FF97C();
      }
      void v15[4] = a1 + 4;
      uint64_t v8 = v7 - v3;
      uint64_t v9 = v8 >> 2;
      if (v8 >> 2 <= a2) {
        uint64_t v9 = a2;
      }
      if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v10 = v9;
      }
      int v11 = (char *)sub_1DC2FFD7C(v10);
      uint64_t v12 = &v11[8 * v5];
      v15[0] = v11;
      v15[1] = v12;
      v15[3] = &v11[8 * v13];
      bzero(v12, 8 * v6);
      void v15[2] = &v12[8 * v6];
      sub_1DC38A3F0(a1, v15);
      sub_1DC38A4E8((uint64_t)v15);
    }
  }
}

void sub_1DC38DF80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC38A4E8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC38DF94(uint64_t result, atomic_uint **a2, uint64_t a3, char a4)
{
  uint64_t v8 = (atomic_uint **)result;
LABEL_2:
  uint64_t v9 = a2;
  unint64_t v10 = a2 - 1;
  int v11 = v8;
  while (1)
  {
    uint64_t v8 = v11;
    uint64_t v12 = (char *)v9 - (char *)v11;
    uint64_t v13 = v9 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v41 = (uint64_t)*(a2 - 1);
          float v94 = a2 - 1;
          if (*(float *)(v41 + 24) > *((float *)*v8 + 6)) {
            BOOL result = (uint64_t)sub_1DC38A538(v8, v94);
          }
          break;
        case 3:
          BOOL result = (uint64_t)sub_1DC38A5E8(v8, v8 + 1, v10);
          break;
        case 4:
          BOOL result = (uint64_t)sub_1DC38A6C4(v8, v8 + 1, v8 + 2, v10);
          break;
        case 5:
          BOOL result = (uint64_t)sub_1DC38A784(v8, v8 + 1, v8 + 2, v8 + 3, v10);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 191)
    {
      BOOL v5 = v8 == v9;
      int v42 = v9;
      uint64_t v43 = v8 + 1;
      char v45 = v5 || v43 == v42;
      if (a4)
      {
        if ((v45 & 1) == 0)
        {
          uint64_t v46 = 0;
          uint64_t v47 = v8;
          do
          {
            uint64_t v48 = *v43;
            if (*((float *)*v43 + 6) > *((float *)*v47 + 6))
            {
              unint64_t v49 = 0;
              atomic_fetch_add_explicit(v48 + 2, 1u, memory_order_relaxed);
              unint64_t v96 = v48;
              float v50 = *v47;
              while (1)
              {
                if (v50) {
                  atomic_fetch_add_explicit(v50 + 2, 1u, memory_order_relaxed);
                }
                uint64_t v51 = v47[v49 / 8 + 1];
                if (v51) {
                  sub_1DC2FF57C(v51);
                }
                v47[v49 / 8 + 1] = v50;
                uint64_t v52 = v96;
                if (v46 == v49) {
                  break;
                }
                float v50 = v47[v49 / 8 - 1];
                v49 -= 8;
                if (*((float *)v96 + 6) <= *((float *)v50 + 6))
                {
                  uint64_t v53 = &v43[v49 / 8];
                  goto LABEL_97;
                }
              }
              uint64_t v53 = v8;
              if (!v96) {
                goto LABEL_98;
              }
LABEL_97:
              atomic_fetch_add_explicit(v96 + 2, 1u, memory_order_relaxed);
LABEL_98:
              if (*v53) {
                sub_1DC2FF57C(*v53);
              }
              atomic_uint *v53 = v52;
              BOOL result = (uint64_t)sub_1DC35D870(&v96);
            }
            ++v43;
            ++v47;
            v46 -= 8;
          }
          while (v43 != a2);
        }
      }
      else if ((v45 & 1) == 0)
      {
        do
        {
          uint64_t v89 = v43;
          unint64_t v90 = v8[1];
          if (*((float *)v90 + 6) > *((float *)*v8 + 6))
          {
            atomic_fetch_add_explicit(v90 + 2, 1u, memory_order_relaxed);
            unint64_t v96 = v90;
            int v91 = *v8;
            do
            {
              if (v91) {
                atomic_fetch_add_explicit(v91 + 2, 1u, memory_order_relaxed);
              }
              if (*v43) {
                sub_1DC2FF57C(*v43);
              }
              *uint64_t v43 = v91;
              uint64_t v92 = v96;
              int v91 = *(v43 - 2);
              --v43;
            }
            while (*((float *)v96 + 6) > *((float *)v91 + 6));
            atomic_fetch_add_explicit(v96 + 2, 1u, memory_order_relaxed);
            if (*v43) {
              sub_1DC2FF57C(*v43);
            }
            *uint64_t v43 = v92;
            BOOL result = (uint64_t)sub_1DC35D870(&v96);
          }
          uint64_t v43 = v89 + 1;
          uint64_t v8 = v89;
        }
        while (v89 + 1 != a2);
      }
      return result;
    }
    if (!a3) {
      break;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    int v15 = &v8[(unint64_t)v13 >> 1];
    if ((unint64_t)v12 < 0x401)
    {
      sub_1DC38A5E8(v15, v8, v10);
    }
    else
    {
      sub_1DC38A5E8(v8, v15, v10);
      sub_1DC38A5E8(v8 + 1, v15 - 1, a2 - 2);
      sub_1DC38A5E8(v8 + 2, &v8[v14 + 1], a2 - 3);
      sub_1DC38A5E8(v15 - 1, v15, &v8[v14 + 1]);
      sub_1DC38A878(v8, v15);
    }
    --a3;
    uint64_t v16 = a2;
    if (a4)
    {
      float v17 = *v8;
      if (!*v8) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
    float v17 = *v8;
    float v18 = *((float *)*v8 + 6);
    if (*((float *)*(v8 - 1) + 6) <= v18)
    {
      atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      unint64_t v96 = v17;
      if (v18 <= *((float *)*v10 + 6))
      {
        int v33 = v8 + 1;
        do
        {
          int v11 = v33;
          if (v33 >= a2) {
            break;
          }
          ++v33;
        }
        while (v18 <= *((float *)*v11 + 6));
      }
      else
      {
        int v11 = v8;
        do
        {
          int v32 = v11[1];
          ++v11;
        }
        while (v18 <= *((float *)v32 + 6));
      }
      BOOL v34 = a2;
      if (v11 < a2)
      {
        BOOL v34 = a2;
        do
          uint64_t v35 = (uint64_t)*--v34;
        while (v18 > *(float *)(v35 + 24));
      }
      while (v11 < v34)
      {
        sub_1DC38A538(v11, v34);
        float v17 = v96;
        float v36 = *((float *)v96 + 6);
        do
        {
          float v37 = v11[1];
          ++v11;
        }
        while (v36 <= *((float *)v37 + 6));
        do
          uint64_t v38 = (uint64_t)*--v34;
        while (v36 > *(float *)(v38 + 24));
      }
      BOOL v39 = v11 - 1;
      if (v11 - 1 != v8)
      {
        uint64_t v40 = *v39;
        if (*v39) {
          atomic_fetch_add_explicit(v40 + 2, 1u, memory_order_relaxed);
        }
        if (*v8) {
          sub_1DC2FF57C(*v8);
        }
        atomic_uint *v8 = v40;
        float v17 = v96;
      }
      if (v17) {
        atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      }
      if (*v39) {
        sub_1DC2FF57C(*v39);
      }
      *BOOL v39 = v17;
      BOOL result = (uint64_t)sub_1DC35D870(&v96);
      a4 = 0;
      uint64_t v9 = a2;
    }
    else
    {
LABEL_14:
      atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
LABEL_15:
      unint64_t v96 = v17;
      float v19 = *((float *)v17 + 6);
      int v20 = v8;
      do
      {
        uint64_t v21 = v20;
        int v22 = v20[1];
        ++v20;
      }
      while (*((float *)v22 + 6) > v19);
      if (v21 == v8)
      {
        uint64_t v16 = a2;
        do
        {
          if (v20 >= v16) {
            break;
          }
          uint64_t v24 = (uint64_t)*--v16;
        }
        while (*(float *)(v24 + 24) <= v19);
      }
      else
      {
        do
          uint64_t v23 = (uint64_t)*--v16;
        while (*(float *)(v23 + 24) <= v19);
      }
      int v11 = v20;
      if (v20 < v16)
      {
        uint64_t v25 = v16;
        do
        {
          sub_1DC38A538(v11, v25);
          float v17 = v96;
          float v26 = *((float *)v96 + 6);
          do
          {
            uint64_t v27 = v11[1];
            ++v11;
          }
          while (*((float *)v27 + 6) > v26);
          do
            uint64_t v28 = (uint64_t)*--v25;
          while (*(float *)(v28 + 24) <= v26);
        }
        while (v11 < v25);
      }
      uint64_t v29 = v11 - 1;
      if (v11 - 1 != v8)
      {
        uint64_t v30 = *v29;
        if (*v29) {
          atomic_fetch_add_explicit(v30 + 2, 1u, memory_order_relaxed);
        }
        if (*v8) {
          sub_1DC2FF57C(*v8);
        }
        atomic_uint *v8 = v30;
        float v17 = v96;
      }
      if (v17) {
        atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
      }
      if (*v29) {
        sub_1DC2FF57C(*v29);
      }
      *uint64_t v29 = v17;
      sub_1DC35D870(&v96);
      BOOL v4 = v20 >= v16;
      uint64_t v9 = a2;
      if (!v4) {
        goto LABEL_43;
      }
      char v31 = sub_1DC38E924(v8, v11 - 1);
      BOOL result = sub_1DC38E924(v11, a2);
      if (result)
      {
        a2 = v11 - 1;
        if (v31) {
          return result;
        }
        goto LABEL_2;
      }
      if ((v31 & 1) == 0)
      {
LABEL_43:
        BOOL result = sub_1DC38DF94(v8, v11 - 1, a3, a4 & 1);
        a4 = 0;
      }
    }
  }
  if (v8 != v9)
  {
    int64_t v54 = (unint64_t)(v13 - 2) >> 1;
    int64_t v55 = v54;
    do
    {
      int64_t v56 = v55;
      if (v54 >= v55)
      {
        uint64_t v57 = (2 * v55) | 1;
        uint64_t v58 = &v8[v57];
        if (2 * v56 + 2 < v13 && *((float *)*v58 + 6) > *((float *)v58[1] + 6))
        {
          ++v58;
          uint64_t v57 = 2 * v56 + 2;
        }
        int v59 = &v8[v56];
        uint64_t v60 = *v59;
        if (*((float *)*v58 + 6) <= *((float *)*v59 + 6))
        {
          atomic_fetch_add_explicit(v60 + 2, 1u, memory_order_relaxed);
          unint64_t v96 = v60;
          uint64_t v61 = *v58;
          while (1)
          {
            float v62 = v58;
            if (v61) {
              atomic_fetch_add_explicit(v61 + 2, 1u, memory_order_relaxed);
            }
            if (*v59) {
              sub_1DC2FF57C(*v59);
            }
            *int v59 = v61;
            if (v54 < v57) {
              break;
            }
            uint64_t v63 = 2 * v57;
            uint64_t v57 = (2 * v57) | 1;
            uint64_t v58 = &v8[v57];
            uint64_t v64 = v63 + 2;
            if (v64 < v13 && *((float *)*v58 + 6) > *((float *)v58[1] + 6))
            {
              ++v58;
              uint64_t v57 = v64;
            }
            uint64_t v61 = *v58;
            float v65 = v96;
            int v59 = v62;
            if (*((float *)*v58 + 6) > *((float *)v96 + 6)) {
              goto LABEL_122;
            }
          }
          float v65 = v96;
          if (v96) {
LABEL_122:
          }
            atomic_fetch_add_explicit(v65 + 2, 1u, memory_order_relaxed);
          if (*v62) {
            sub_1DC2FF57C(*v62);
          }
          int *v62 = v65;
          sub_1DC35D870(&v96);
        }
      }
      int64_t v55 = v56 - 1;
    }
    while (v56);
    uint64_t v66 = (unint64_t)v12 >> 3;
    while (2)
    {
      uint64_t v67 = *v8;
      if (*v8) {
        atomic_fetch_add_explicit(v67 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v68 = 0;
      uint64_t v95 = v67;
      int64_t v69 = v8;
LABEL_131:
      uint64_t v70 = &v69[v68];
      uint64_t v73 = v70[1];
      int64_t v71 = v70 + 1;
      int64_t v72 = v73;
      uint64_t v74 = 2 * v68;
      uint64_t v68 = (2 * v68) | 1;
      uint64_t v75 = v74 + 2;
      if (v75 >= v66)
      {
        if (v72) {
          goto LABEL_135;
        }
      }
      else
      {
        uint64_t v76 = v71[1];
        if (*((float *)v72 + 6) > *((float *)v76 + 6))
        {
          uint64_t v68 = v75;
          ++v71;
          int64_t v72 = v76;
        }
LABEL_135:
        atomic_fetch_add_explicit(v72 + 2, 1u, memory_order_relaxed);
      }
      if (*v69) {
        sub_1DC2FF57C(*v69);
      }
      *int64_t v69 = v72;
      int64_t v69 = v71;
      if (v68 > (uint64_t)((unint64_t)(v66 - 2) >> 1))
      {
        float v77 = a2 - 1;
        BOOL v5 = v71 == --a2;
        if (v5)
        {
          uint64_t v87 = v95;
          if (v95) {
            atomic_fetch_add_explicit(v95 + 2, 1u, memory_order_relaxed);
          }
          if (*v71) {
            sub_1DC2FF57C(*v71);
          }
          *int64_t v71 = v87;
        }
        else
        {
          char v78 = *v77;
          if (*v77) {
            atomic_fetch_add_explicit(v78 + 2, 1u, memory_order_relaxed);
          }
          if (*v71) {
            sub_1DC2FF57C(*v71);
          }
          *int64_t v71 = v78;
          uint64_t v79 = v95;
          if (v95) {
            atomic_fetch_add_explicit(v95 + 2, 1u, memory_order_relaxed);
          }
          if (*a2) {
            sub_1DC2FF57C(*a2);
          }
          *a2 = v79;
          uint64_t v80 = (char *)v71 - (char *)v8 + 8;
          if (v80 >= 9)
          {
            unint64_t v81 = (((unint64_t)v80 >> 3) - 2) >> 1;
            uint64_t v82 = &v8[v81];
            int v83 = *v71;
            if (*((float *)*v82 + 6) > *((float *)*v71 + 6))
            {
              atomic_fetch_add_explicit(v83 + 2, 1u, memory_order_relaxed);
              unint64_t v96 = v83;
              uint64_t v84 = *v82;
              while (1)
              {
                float v85 = v82;
                if (v84) {
                  atomic_fetch_add_explicit(v84 + 2, 1u, memory_order_relaxed);
                }
                if (*v71) {
                  sub_1DC2FF57C(*v71);
                }
                *int64_t v71 = v84;
                if (!v81) {
                  break;
                }
                unint64_t v81 = (v81 - 1) >> 1;
                uint64_t v82 = &v8[v81];
                uint64_t v84 = *v82;
                float v86 = v96;
                int64_t v71 = v85;
                if (*((float *)*v82 + 6) <= *((float *)v96 + 6)) {
                  goto LABEL_164;
                }
              }
              float v86 = v96;
              if (!v96) {
                goto LABEL_165;
              }
LABEL_164:
              atomic_fetch_add_explicit(v86 + 2, 1u, memory_order_relaxed);
LABEL_165:
              if (*v85) {
                sub_1DC2FF57C(*v85);
              }
              int *v85 = v86;
              sub_1DC35D870(&v96);
            }
          }
        }
        BOOL result = (uint64_t)sub_1DC35D870(&v95);
        if (v66-- <= 2) {
          return result;
        }
        continue;
      }
      goto LABEL_131;
    }
  }
  return result;
}

void sub_1DC38E8B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1DC35D870((atomic_uint **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC38E924(atomic_uint **a1, atomic_uint **a2)
{
  BOOL v4 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      if (*((float *)*(a2 - 1) + 6) > *((float *)*a1 + 6)) {
        sub_1DC38A538(a1, a2 - 1);
      }
      return v4;
    case 3:
      sub_1DC38A5E8(a1, a1 + 1, a2 - 1);
      return v4;
    case 4:
      sub_1DC38A6C4(a1, a1 + 1, a1 + 2, a2 - 1);
      return v4;
    case 5:
      sub_1DC38A784(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return v4;
    default:
      BOOL v5 = a1 + 2;
      sub_1DC38A5E8(a1, a1 + 1, a1 + 2);
      unint64_t v6 = a1 + 3;
      BOOL v4 = 1;
      if (a1 + 3 == a2) {
        return v4;
      }
      int v7 = 0;
      uint64_t v8 = -16;
      break;
  }
  while (1)
  {
    uint64_t v9 = *v6;
    if (*((float *)*v6 + 6) > *((float *)*v5 + 6)) {
      break;
    }
LABEL_21:
    BOOL v5 = v6;
    v8 -= 8;
    if (++v6 == a2) {
      return 1;
    }
  }
  unint64_t v10 = 0;
  atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
  uint64_t v16 = v9;
  int v11 = *v5;
  while (1)
  {
    if (v11) {
      atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v12 = v6[v10 / 8];
    if (v12) {
      sub_1DC2FF57C(v12);
    }
    v6[v10 / 8] = v11;
    uint64_t v13 = v16;
    if (v8 == v10) {
      break;
    }
    int v11 = v6[v10 / 8 - 2];
    v10 -= 8;
    if (*((float *)v16 + 6) <= *((float *)v11 + 6))
    {
      unint64_t v14 = &v6[v10 / 8];
      goto LABEL_16;
    }
  }
  unint64_t v14 = a1;
  if (!v16) {
    goto LABEL_17;
  }
LABEL_16:
  atomic_fetch_add_explicit(v16 + 2, 1u, memory_order_relaxed);
LABEL_17:
  if (*v14) {
    sub_1DC2FF57C(*v14);
  }
  atomic_uint *v14 = v13;
  if (++v7 != 8)
  {
    sub_1DC35D870(&v16);
    goto LABEL_21;
  }
  BOOL v4 = v6 + 1 == a2;
  sub_1DC35D870(&v16);
  return v4;
}

void sub_1DC38EB24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC35D870((atomic_uint **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC38EB54(atomic_uint **a1, atomic_uint **a2)
{
  BOOL v4 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      if (*((float *)*(a2 - 1) + 6) > *((float *)*a1 + 6)) {
        sub_1DC38A538(a1, a2 - 1);
      }
      return v4;
    case 3:
      sub_1DC38A5E8(a1, a1 + 1, a2 - 1);
      return v4;
    case 4:
      sub_1DC38A6C4(a1, a1 + 1, a1 + 2, a2 - 1);
      return v4;
    case 5:
      sub_1DC38A784(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return v4;
    default:
      BOOL v5 = a1 + 2;
      sub_1DC38A5E8(a1, a1 + 1, a1 + 2);
      unint64_t v6 = a1 + 3;
      BOOL v4 = 1;
      if (a1 + 3 == a2) {
        return v4;
      }
      int v7 = 0;
      uint64_t v8 = -16;
      break;
  }
  while (1)
  {
    uint64_t v9 = *v6;
    if (*((float *)*v6 + 6) > *((float *)*v5 + 6)) {
      break;
    }
LABEL_21:
    BOOL v5 = v6;
    v8 -= 8;
    if (++v6 == a2) {
      return 1;
    }
  }
  unint64_t v10 = 0;
  atomic_fetch_add_explicit(v9 + 2, 1u, memory_order_relaxed);
  uint64_t v16 = v9;
  int v11 = *v5;
  while (1)
  {
    if (v11) {
      atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v12 = v6[v10 / 8];
    if (v12) {
      sub_1DC2FF57C(v12);
    }
    v6[v10 / 8] = v11;
    uint64_t v13 = v16;
    if (v8 == v10) {
      break;
    }
    int v11 = v6[v10 / 8 - 2];
    v10 -= 8;
    if (*((float *)v16 + 6) <= *((float *)v11 + 6))
    {
      unint64_t v14 = &v6[v10 / 8];
      goto LABEL_16;
    }
  }
  unint64_t v14 = a1;
  if (!v16) {
    goto LABEL_17;
  }
LABEL_16:
  atomic_fetch_add_explicit(v16 + 2, 1u, memory_order_relaxed);
LABEL_17:
  if (*v14) {
    sub_1DC2FF57C(*v14);
  }
  atomic_uint *v14 = v13;
  if (++v7 != 8)
  {
    sub_1DC35D870(&v16);
    goto LABEL_21;
  }
  BOOL v4 = v6 + 1 == a2;
  sub_1DC35D870(&v16);
  return v4;
}

void sub_1DC38ED54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC35D870((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_uint *sub_1DC38ED84(atomic_uint *result, atomic_uint **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = (atomic_uint **)*((void *)result + 1);
  atomic_uint *v3 = 0;
  BOOL v4 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    BOOL result = *v3;
    if (*v3) {
      BOOL result = sub_1DC2FF57C(result);
    }
  }
  atomic_uint *v3 = v4;
  *((void *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1DC38EDDC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1DC38EDE4(uint64_t a1, atomic_uint **a2)
{
  uint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  uint64_t v6 = a1 + 16;
  uint64_t v7 = *(void *)(a1 + 16) - *(void *)a1;
  if (v7 >> 2 > v3) {
    unint64_t v3 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v3;
  }
  uint64_t v18 = v6;
  if (v8) {
    unint64_t v8 = (unint64_t)sub_1DC2FFD7C(v8);
  }
  else {
    uint64_t v9 = 0;
  }
  unint64_t v10 = (atomic_uint **)(v8 + 8 * v2);
  v15[0] = v8;
  v15[1] = v10;
  uint64_t v16 = v10;
  unint64_t v17 = v8 + 8 * v9;
  *unint64_t v10 = 0;
  int v11 = *a2;
  uint64_t v12 = v10;
  if (v11)
  {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    uint64_t v12 = v10;
    if (*v10)
    {
      sub_1DC2FF57C(*v10);
      uint64_t v12 = v16;
    }
  }
  *unint64_t v10 = v11;
  uint64_t v16 = v12 + 1;
  sub_1DC38A3F0((atomic_uint *)a1, v15);
  uint64_t v13 = *(void *)(a1 + 8);
  sub_1DC38A4E8((uint64_t)v15);
  return v13;
}

void sub_1DC38EED8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC38A4E8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DC38EEEC(uint64_t a1)
{
  sub_1DC38EF24(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC38EF24(uint64_t a1)
{
  *(void *)a1 = &unk_1F36615C8;
  uint64_t v2 = (void **)(a1 + 16);
  BOOL v4 = (void **)(a1 + 152);
  sub_1DC3853C0(&v4);
  BOOL v4 = (void **)(a1 + 128);
  sub_1DC3853C0(&v4);
  sub_1DC3122B8((atomic_uint **)(a1 + 120));
  BOOL v4 = (void **)(a1 + 88);
  sub_1DC312234(&v4);
  BOOL v4 = (void **)(a1 + 64);
  sub_1DC3853C0(&v4);
  BOOL v4 = (void **)(a1 + 40);
  sub_1DC312234(&v4);
  BOOL v4 = v2;
  sub_1DC3853C0(&v4);
  sub_1DC2FF548((atomic_uint **)(a1 + 8));
  return a1;
}

uint64_t sub_1DC38EFEC(uint64_t a1, atomic_uint *a2, uint64_t *a3)
{
  uint64_t v4 = a1 + 8;
  if (a2) {
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v6 = a2;
  sub_1DC3A81F8(v4, (uint64_t *)&v6, a3);
  sub_1DC2FF548(&v6);
  *(void *)a1 = &unk_1F36615C8;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 100;
  return a1;
}

void sub_1DC38F070(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC2FF548((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC38F084(CVPixelBufferPoolRef *a1, uint64_t a2, atomic_ullong *a3)
{
  if (*(_DWORD *)a2 != 4) {
    goto LABEL_4;
  }
  int v5 = 1278226534;
  int v6 = *(_DWORD *)(a2 + 4);
  if (v6 == 3)
  {
    int v5 = 1278226536;
  }
  else if (v6 != 6)
  {
LABEL_4:
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    uint64_t v7 = qword_1EBFFC3D8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v10) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v7, OS_LOG_TYPE_ERROR, "Unsupported input tensor data type", (uint8_t *)&v10, 2u);
    }
    uint64_t v10 = -2001;
    int v32 = @"Unsupported input tensor data type.";
    BOOL result = (atomic_ullong *)sub_1DC306334(a3, &v10, (CFTypeRef *)&v32);
    *a1 = 0;
    return result;
  }
  char v18 = 0;
  char v19 = 0;
  __int16 v31 = 0;
  int v20 = 0;
  __int16 v21 = 0;
  uint64_t v9 = *(void *)(a2 + 56);
  uint64_t v10 = *(void *)(a2 + 64);
  char v11 = 1;
  uint64_t v12 = *(void *)(a2 + 48) * v9;
  char v13 = 1;
  int v14 = v5;
  char v15 = 1;
  char v17 = 1;
  uint64_t v16 = 64;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  char v30 = 1;
  BOOL result = sub_1DC37120C(a1, &v10, (uint64_t)a3);
  if (v30) {
    return sub_1DC31FA90((atomic_ullong *)&v29 + 1);
  }
  return result;
}

void sub_1DC38F200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  if (a35) {
    sub_1DC31FA90(&a34);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC38F220(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((*a1 & 0xF) != 0 || (a1[3] & 0xF) != 0)
  {
    size_t v11 = a1[1];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = sub_1DC38F3D4;
    block[3] = &unk_1E6C3A8C8;
    void block[4] = v1;
    block[5] = a1;
    __int16 v13 = 23544;
    dispatch_apply(v11, 0, block);
  }
  else if (a1[1])
  {
    unint64_t v2 = 0;
    unint64_t v3 = a1[2];
    float16x4_t v4 = (float16x4_t)vdup_n_s16(0x5BF8u);
    float16x8_t v5 = (float16x8_t)vdupq_n_s16(0x5BF8u);
    do
    {
      uint64_t v6 = a1[3];
      if (v3 >= 8)
      {
        unint64_t v7 = 0;
        unint64_t v8 = (float16x8_t *)(v1 + v6 * v2);
        do
        {
          float16x8_t *v8 = vmulq_f16(*v8, v5);
          ++v8;
          v7 += 8;
          unint64_t v3 = a1[2];
        }
        while (v7 < (v3 & 0xFFFFFFFFFFFFFFF8));
      }
      else
      {
        unint64_t v7 = 0;
      }
      if (v7 < (v3 & 0xFFFFFFFFFFFFFFFCLL))
      {
        *(float16x4_t *)(v1 + v6 * v2 + 2 * v7) = vmul_f16(*(float16x4_t *)(v1 + v6 * v2 + 2 * v7), v4);
        v7 |= 4uLL;
        unint64_t v3 = a1[2];
      }
      unint64_t v9 = v3 - v7;
      if (v3 > v7)
      {
        uint64_t v10 = (short float *)(v1 + v6 * v2 + 2 * v7);
        do
        {
          *uint64_t v10 = *v10 * COERCE_SHORT_FLOAT(23544);
          ++v10;
          --v9;
        }
        while (v9);
      }
      ++v2;
    }
    while (v2 < a1[1]);
  }
}

atomic_ullong *sub_1DC38F37C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    *(unsigned char *)(a1 + 16) = sub_1DC36FD3C((atomic_ullong *)a1, 0, *(void *)(a1 + 8)) ^ 1;
  }
  return sub_1DC307370((atomic_ullong *)a1);
}

__int16 sub_1DC38F3D4@<H0>(uint64_t a1@<X0>, uint64_t a2@<X1>)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(v2 + 16);
  if (v3)
  {
    float16x4_t v4 = (short float *)(*(void *)(a1 + 32) + *(void *)(v2 + 24) * a2);
    do
    {
      *(short float *)&__int16 result = *v4 * *(short float *)(a1 + 48);
      *v4++ = *(short float *)&result;
      --v3;
    }
    while (v3);
  }
  return result;
}

void *sub_1DC38F408()
{
  return &unk_1F365DAA8;
}

uint64_t sub_1DC38F414(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference7helpers39createNetworkInputPixelBufferFrom32BGRAERKNS0_4e5rt20E5RTTensorDescriptorERK13vImage_BufferRKNS_5CFRefIP19__CVPixelBufferPoolEERNSt3__18optionalINS_5ErrorEEERKNSG_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC38F450(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)float16x4_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "createNetworkInputPixelBufferFrom32BGRA", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC38F4FC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365E3C0;
}

void *sub_1DC38F51C()
{
  __int16 result = operator new(0x10uLL);
  *__int16 result = &unk_1F365E3C0;
  return result;
}

void sub_1DC38F554()
{
}

void *sub_1DC38F56C()
{
  return &unk_1F365DA98;
}

uint64_t sub_1DC38F578(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference7helpers39createNetworkInputPixelBufferFrom32BGRAERKNS0_4e5rt20E5RTTensorDescriptorERK13vImage_BufferRKNS_5CFRefIP19__CVPixelBufferPoolEERNSt3__18optionalINS_5ErrorEEERKNSG_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC38F5B4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)float16x4_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "createNetworkInputPixelBufferFrom32BGRA", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC38F660(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365E368;
}

void *sub_1DC38F680()
{
  __int16 result = operator new(0x10uLL);
  *__int16 result = &unk_1F365E368;
  return result;
}

void sub_1DC38F6B8()
{
}

uint64_t sub_1DC38F6D0(uint64_t a1, atomic_ullong *a2, uint64_t a3)
{
  CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(a2, memory_order_acquire);
  if (explicit) {
    CFTypeRef explicit = CFRetain(explicit);
  }
  *(void *)a1 = explicit;
  *(void *)(a1 + 8) = a3;
  *(unsigned char *)(a1 + 16) = sub_1DC36FB80((atomic_ullong *)a1, 0, a3);
  return a1;
}

void sub_1DC38F71C(_Unwind_Exception *a1)
{
  sub_1DC307370(v1);
  _Unwind_Resume(a1);
}

void sub_1DC38F730(const vImage_Buffer *a1, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Buffer *a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  data = (char *)a1->data;
  if (((uint64_t)a1->data & 0xF) != 0
    || (a1->rowBytes & 0xF) != 0
    || (unint64_t v9 = (char *)a2->data, ((uint64_t)a2->data & 0xF) != 0)
    || (a2->rowBytes & 0xF) != 0
    || (uint64_t v10 = (char *)a3->data, ((uint64_t)a3->data & 0xF) != 0)
    || (a3->rowBytes & 0xF) != 0
    || (size_t v11 = (char *)a4->data, ((uint64_t)a4->data & 0xF) != 0)
    || (a4->rowBytes & 0xF) != 0)
  {
    uint64_t v34 = MEMORY[0x1E019D900](&v39, a1->height, a1->width, 16, 0);
    if (v34)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      uint64_t v35 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::string buf = 134349056;
        uint64_t v41 = (const char *)v34;
        _os_log_fault_impl(&dword_1DC2FE000, v35, OS_LOG_TYPE_FAULT, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
      }
    }
    else
    {
      float v36 = v39.data;
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      float v37 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::string buf = 136447234;
        uint64_t v41 = "temporaryAlpha";
        __int16 v42 = 2050;
        uint64_t v43 = v36;
        __int16 v44 = 2050;
        vImagePixelCount height = v39.height;
        __int16 v46 = 2050;
        vImagePixelCount width = v39.width;
        __int16 v48 = 2050;
        size_t rowBytes = v39.rowBytes;
        _os_log_debug_impl(&dword_1DC2FE000, v37, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
      }
      vImage_Error v38 = vImageConvert_ARGB16UtoPlanar16U(a1, a2, a3, a4, &v39, 0);
      if (v38)
      {
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)std::string buf = 134349056;
          uint64_t v41 = (const char *)v38;
          _os_log_fault_impl(&dword_1DC2FE000, v37, OS_LOG_TYPE_FAULT, "vImageConvert_ARGB16UtoPlanar16U failed: %{public}zd", buf, 0xCu);
        }
      }
      else
      {
        sub_1DC38F220((uint64_t *)a2);
        sub_1DC38F220((uint64_t *)a3);
        sub_1DC38F220((uint64_t *)a4);
      }
      if (v36) {
        free(v36);
      }
    }
  }
  else if (a1->height)
  {
    vImagePixelCount v12 = 0;
    unint64_t v13 = a1->width;
    float16x4_t v14 = (float16x4_t)vdup_n_s16(0x5BF8u);
    float16x8_t v15 = (float16x8_t)vdupq_n_s16(0x5BF8u);
    do
    {
      size_t v16 = a1->rowBytes;
      size_t v17 = a2->rowBytes;
      size_t v18 = a3->rowBytes;
      size_t v19 = a4->rowBytes;
      if (v13 >= 8)
      {
        unint64_t v20 = 0;
        __int16 v21 = (const __int16 *)&data[v16 * v12];
        long long v22 = (float16x8_t *)&v9[v17 * v12];
        long long v23 = (float16x8_t *)&v10[v18 * v12];
        long long v24 = (float16x8_t *)&v11[v19 * v12];
        do
        {
          int16x8x4_t v52 = vld4q_s16(v21);
          v21 += 32;
          *v22++ = vmulq_f16((float16x8_t)v52.val[0], v15);
          *v23++ = vmulq_f16((float16x8_t)v52.val[1], v15);
          *v24++ = vmulq_f16((float16x8_t)v52.val[2], v15);
          v20 += 8;
          unint64_t v13 = a1->width;
        }
        while (v20 < (v13 & 0xFFFFFFFFFFFFFFF8));
      }
      else
      {
        unint64_t v20 = 0;
      }
      if (v20 < (v13 & 0xFFFFFFFFFFFFFFFCLL))
      {
        long long v25 = (const __int16 *)&data[8 * v20 + v16 * v12];
        int16x4x4_t v51 = vld4_s16(v25);
        uint64_t v26 = 2 * v20;
        *(float16x4_t *)&v9[v17 * v12 + v26] = vmul_f16((float16x4_t)v51.val[0], v14);
        *(float16x4_t *)&v10[v18 * v12 + v26] = vmul_f16((float16x4_t)v51.val[1], v14);
        *(float16x4_t *)&v11[v19 * v12 + v26] = vmul_f16((float16x4_t)v51.val[2], v14);
        v20 |= 4uLL;
        unint64_t v13 = a1->width;
      }
      unint64_t v27 = v13 - v20;
      if (v13 > v20)
      {
        long long v28 = &v11[2 * v20 + v19 * v12];
        long long v29 = &v10[2 * v20 + v18 * v12];
        char v30 = &v9[2 * v20 + v17 * v12];
        __int16 v31 = (float16x4_t *)&data[8 * v20 + v16 * v12];
        do
        {
          float16x4_t v32 = *v31++;
          float16x4_t v33 = vmul_f16(v32, v14);
          *(_WORD *)char v30 = v33.i16[0];
          v30 += 2;
          *(_WORD *)long long v29 = v33.i16[1];
          v29 += 2;
          *(_WORD *)long long v28 = v33.i16[2];
          v28 += 2;
          --v27;
        }
        while (v27);
      }
      ++v12;
    }
    while (v12 < a1->height);
  }
}

void sub_1DC38FB04(_Unwind_Exception *exception_object)
{
  if (v1) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC38FB24(uint64_t a1)
{
  float __B = 255.0;
  unint64_t v1 = *(void *)(a1 + 24);
  if ((v1 & 3) != 0 || v1 >= 4 * *(void *)(a1 + 16) + 64)
  {
    uint64_t v3 = *(const float **)a1;
    size_t v2 = *(void *)(a1 + 8);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = sub_1DC38FC44;
    block[3] = &unk_1E6C3A8E8;
    void block[4] = v3;
    block[5] = a1;
    int v5 = 1132396544;
    dispatch_apply(v2, 0, block);
  }
  else
  {
    vDSP_vsmul(*(const float **)a1, 1, &__B, *(float **)a1, 1, *(void *)(a1 + 8) * (v1 >> 2));
  }
}

atomic_ullong *sub_1DC38FBEC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    *(unsigned char *)(a1 + 16) = sub_1DC36FD3C((atomic_ullong *)a1, 1, *(void *)(a1 + 8)) ^ 1;
  }
  return sub_1DC307370((atomic_ullong *)a1);
}

void sub_1DC38FC44(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = (const float *)(a1 + 48);
  float16x4_t v4 = (float *)(*(void *)(a1 + 32) + *(void *)(v2 + 24) * a2);
  vDSP_vsmul(v4, 1, v3, v4, 1, *(void *)(v2 + 16));
}

void *sub_1DC38FC64()
{
  return &unk_1F3664C08;
}

uint64_t sub_1DC38FC70(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference7helpers44createNetworkInputPixelBufferFromInterleavedERKNS0_4e5rt20E5RTTensorDescriptorERKNS_5CFRefIP10__CVBufferEERKNS6_IP19__CVPixelBufferPoolEERNSt3__18optionalINS_5ErrorEEERKNSI_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC38FCAC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)float16x4_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "createNetworkInputPixelBufferFromInterleaved", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC38FD58(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664BA8;
}

void *sub_1DC38FD78()
{
  __int16 result = operator new(0x10uLL);
  *__int16 result = &unk_1F3664BA8;
  return result;
}

void sub_1DC38FDB0()
{
}

void *sub_1DC38FDC8()
{
  return &unk_1F3664B88;
}

uint64_t sub_1DC38FDD4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference7helpers44createNetworkInputPixelBufferFromInterleavedERKNS0_4e5rt20E5RTTensorDescriptorERKNS_5CFRefIP10__CVBufferEERKNS6_IP19__CVPixelBufferPoolEERNSt3__18optionalINS_5ErrorEEERKNSI_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC38FE10(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)float16x4_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "createNetworkInputPixelBufferFromInterleaved", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC38FEBC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3664B28;
}

void *sub_1DC38FEDC()
{
  __int16 result = operator new(0x10uLL);
  *__int16 result = &unk_1F3664B28;
  return result;
}

void sub_1DC38FF14()
{
}

void *sub_1DC38FF2C()
{
  return &unk_1F365DAC8;
}

uint64_t sub_1DC38FF38(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference7helpers46createNetworkInputPixelBufferFromOneComponent8ERKNS0_4e5rt20E5RTTensorDescriptorERK13vImage_BufferRKNS_5CFRefIP19__CVPixelBufferPoolEERNSt3__18optionalINS_5ErrorEEERKNSG_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC38FF74(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)float16x4_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "createNetworkInputPixelBufferFromOneComponent8", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC390020(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365E470;
}

void *sub_1DC390040()
{
  __int16 result = operator new(0x10uLL);
  *__int16 result = &unk_1F365E470;
  return result;
}

void sub_1DC390078()
{
}

void *sub_1DC390090()
{
  return &unk_1F365DAB8;
}

uint64_t sub_1DC39009C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference7helpers46createNetworkInputPixelBufferFromOneComponent8ERKNS0_4e5rt20E5RTTensorDescriptorERK13vImage_BufferRKNS_5CFRefIP19__CVPixelBufferPoolEERNSt3__18optionalINS_5ErrorEEERKNSG_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3900D8(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)float16x4_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "createNetworkInputPixelBufferFromOneComponent8", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC390184(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365E418;
}

void *sub_1DC3901A4()
{
  __int16 result = operator new(0x10uLL);
  *__int16 result = &unk_1F365E418;
  return result;
}

void sub_1DC3901DC()
{
}

atomic_uint **sub_1DC3901F4(void *a1, uint64_t a2, uint64_t *a3, long long *a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  (*(void (**)(atomic_uint **__return_ptr, uint64_t))(*(void *)a2 + 16))(&v28, a2);
  uint64_t v6 = (void **)v28;
  if (v28) {
    atomic_fetch_add_explicit(v28 + 2, 1u, memory_order_relaxed);
  }
  size_t v17 = v6;
  sub_1DC3A1018((uint64_t)v29, (uint64_t *)&v17);
  sub_1DC2FF548((atomic_uint **)&v17);
  v29[0] = &unk_1F3661590;
  sub_1DC2FF548(&v28);
  long long v24 = *a4;
  char v25 = *((unsigned char *)a4 + 16);
  uint64_t v26 = 0;
  unint64_t v7 = (atomic_uint *)*((void *)a4 + 3);
  if (v7)
  {
    atomic_fetch_add_explicit(v7 + 2, 1u, memory_order_relaxed);
    if (v26) {
      sub_1DC2FF57C(v26);
    }
  }
  uint64_t v26 = v7;
  sub_1DC383D6C(v29, a3, v27);
  sub_1DC3122B8(&v26);
  if (v27[1] != v27[0])
  {
    uint64_t v8 = *(void *)v27[0];
    size_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    sub_1DC2FFB5C((atomic_uint *)&v17, *(void *)(v8 + 16), *(void *)(v8 + 24), (uint64_t)(*(void *)(v8 + 24) - *(void *)(v8 + 16)) >> 3);
    uint64_t v9 = *(void *)(*(void *)v27[0] + 64);
    if (v9) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 1u, memory_order_relaxed);
    }
    __int16 v21 = (atomic_uint *)v9;
    unint64_t v10 = *(void *)(v9 + 16);
    sub_1DC2FF548(&v21);
    long long v23 = 0;
    size_t v11 = v17;
    if ((unint64_t)(v18 - (void)v17) >= 0x19)
    {
      vImagePixelCount v12 = (atomic_uint *)v17[3];
      if (v12) {
        atomic_fetch_add_explicit(v12 + 2, 1u, memory_order_relaxed);
      }
      long long v23 = v12;
    }
    uint64_t v13 = *(void *)(*(void *)v27[0] + 72);
    if (v13) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v13 + 8), 1u, memory_order_relaxed);
    }
    uint64_t v22 = v13;
    sub_1DC34AB34(&v21, ((v18 - (uint64_t)v11) >> 3) + 4);
    sub_1DC320A5C(&__p, 8uLL);
    float16x4_t v14 = (char *)__p;
    *(void *)std::string __p = 0;
    *((_DWORD *)v14 + 2) = 0;
    *(float *)v15.i32 = (float)v10;
    *(int32x4_t *)(v14 + 12) = vdupq_lane_s32(v15, 0);
    *((_DWORD *)v14 + 7) = 0;
    (*(void (**)(uint64_t, void **))(*(void *)v22 + 16))(v22, &__p);
    operator new();
  }
  size_t v17 = (void **)v27;
  sub_1DC385498(&v17);
  v29[0] = &unk_1F3661868;
  sub_1DC3122B8(&v31);
  return sub_1DC2FF548(&v30);
}

void sub_1DC3909D0()
{
}

void sub_1DC3909F0()
{
  sub_1DC385E30(v0 - 128);
  JUMPOUT(0x1DC390A2CLL);
}

void sub_1DC3909F8()
{
  sub_1DC3122B8(v0);
  JUMPOUT(0x1DC390A04);
}

void sub_1DC390A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9)
{
  sub_1DC2FF548(&a9);
  sub_1DC2FF548((atomic_uint **)(v10 - 136));
  *(void *)(v10 - 128) = v9;
  sub_1DC311C68((void ***)(v10 - 128));
  _Unwind_Resume(a1);
}

uint64_t sub_1DC390A40(uint64_t a1, uint64_t a2, CFTypeRef cf)
{
  *(void *)a1 = a2;
  if (cf) {
    CFTypeRef v4 = CFRetain(cf);
  }
  else {
    CFTypeRef v4 = 0;
  }
  CFTypeRef v7 = v4;
  if (atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire)) {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire));
  }
  else {
    CFStringRef Copy = 0;
  }
  *(void *)(a1 + 8) = Copy;
  sub_1DC31FA90((atomic_ullong *)&v7);
  *(unsigned char *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 20) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 28) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 52) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 60) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  return a1;
}

void sub_1DC390AEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC31FA90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC390B00(atomic_ullong *a1)
{
  return a1;
}

uint64_t sub_1DC390B4C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire);
  int v5 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (explicit) {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire));
  }
  else {
    CFStringRef Copy = 0;
  }
  *(void *)(a1 + 8) = Copy;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  CFTypeRef v7 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 64), memory_order_acquire);
  if (v7) {
    CFTypeRef v7 = CFRetain(v7);
  }
  *(void *)(a1 + 64) = v7;
  CFTypeRef v8 = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 72), memory_order_acquire);
  if (v8) {
    CFTypeRef v8 = CFRetain(v8);
  }
  *(void *)(a1 + 72) = v8;
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 80), memory_order_acquire)) {
    CFStringRef v9 = CFStringCreateCopy(*v5, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 80), memory_order_acquire));
  }
  else {
    CFStringRef v9 = 0;
  }
  *(void *)(a1 + 80) = v9;
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 88), memory_order_acquire)) {
    CFDictionaryRef v10 = CFDictionaryCreateCopy(*v5, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 88), memory_order_acquire));
  }
  else {
    CFDictionaryRef v10 = 0;
  }
  *(void *)(a1 + 88) = v10;
  return a1;
}

void sub_1DC390C5C(_Unwind_Exception *a1)
{
  sub_1DC31FA90(v3);
  sub_1DC378320((atomic_ullong *)(v2 + 72));
  sub_1DC306854((atomic_ullong *)(v2 + 64));
  sub_1DC31FA90(v1);
  _Unwind_Resume(a1);
}

void *sub_1DC390CA0(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = -1;
  *__int16 result = v2;
  result[1] = atomic_exchange(a2 + 1, 0);
  uint64_t v3 = a2[2];
  if ((v3 & 0xFF00000000) != 0) {
    *((unsigned char *)a2 + 20) = 0;
  }
  result[2] = v3;
  uint64_t v4 = a2[3];
  if ((v4 & 0xFF00000000) != 0) {
    *((unsigned char *)a2 + 28) = 0;
  }
  result[3] = v4;
  uint64_t v6 = a2[4];
  uint64_t v5 = a2[5];
  if ((_BYTE)v5) {
    *((unsigned char *)a2 + 40) = 0;
  }
  result[4] = v6;
  result[5] = v5;
  uint64_t v7 = a2[6];
  if ((v7 & 0xFF00000000) != 0) {
    *((unsigned char *)a2 + 52) = 0;
  }
  result[6] = v7;
  uint64_t v8 = a2[7];
  if ((v8 & 0xFF00000000) != 0) {
    *((unsigned char *)a2 + 60) = 0;
  }
  result[7] = v8;
  result[8] = atomic_exchange(a2 + 8, 0);
  result[9] = atomic_exchange(a2 + 9, 0);
  result[10] = atomic_exchange(a2 + 10, 0);
  result[11] = atomic_exchange(a2 + 11, 0);
  return result;
}

void sub_1DC390D54(uint64_t a1, int a2)
{
  if (a2)
  {
    CFErrorRef v5 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], a2, 0);
    uint64_t v3 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 64), atomic_exchange((atomic_ullong *volatile)&v5, 0));
    if (v3) {
      CFRelease(v3);
    }
    sub_1DC306854((atomic_ullong *)&v5);
  }
  else
  {
    uint64_t v4 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 64), 0);
    if (v4)
    {
      CFRelease(v4);
    }
  }
}

void sub_1DC390DF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC306854((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void sub_1DC390E0C(uint64_t a1, int a2)
{
  if (a2)
  {
    CFErrorRef v5 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D158], a2, 0);
    uint64_t v3 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 64), atomic_exchange((atomic_ullong *volatile)&v5, 0));
    if (v3) {
      CFRelease(v3);
    }
    sub_1DC306854((atomic_ullong *)&v5);
  }
  else
  {
    uint64_t v4 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 64), 0);
    if (v4)
    {
      CFRelease(v4);
    }
  }
}

void sub_1DC390EB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC306854((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void sub_1DC390EC4(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    if (!a2[1]) {
      goto LABEL_10;
    }
    a2 = (uint64_t *)*a2;
  }
  else if (!*((unsigned char *)a2 + 23))
  {
LABEL_10:
    uint64_t v4 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 80), 0);
    if (v4)
    {
      CFRelease(v4);
    }
    return;
  }
  CFStringRef v5 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)a2);
  uint64_t v3 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 80), atomic_exchange((atomic_ullong *volatile)&v5, 0));
  if (v3) {
    CFRelease(v3);
  }
  sub_1DC31FA90((atomic_ullong *)&v5);
}

void sub_1DC390F68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC31FA90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC390F7C(CFErrorRef *a1, uint64_t a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire))
  {
    unint64_t explicit = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    CFDictionarySetValue(explicit, (const void *)*MEMORY[0x1E4F1D140], (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire));
  }
  if (*(unsigned char *)(a2 + 20) && *(_DWORD *)(a2 + 16))
  {
    atomic_ullong valuePtr = (atomic_ullong)CFNumberCreate(v4, kCFNumberIntType, (const void *)(a2 + 16));
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MRCErrorACBSReturnKey", (const void *)atomic_load_explicit(&valuePtr, memory_order_acquire));
    sub_1DC3065B8(&valuePtr);
  }
  if (*(unsigned char *)(a2 + 28) && *(_DWORD *)(a2 + 24))
  {
    atomic_ullong valuePtr = (atomic_ullong)CFNumberCreate(v4, kCFNumberSInt32Type, (const void *)(a2 + 24));
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MRCErrorCVReturnKey", (const void *)atomic_load_explicit(&valuePtr, memory_order_acquire));
    sub_1DC3065B8(&valuePtr);
  }
  if (*(unsigned char *)(a2 + 40) && *(void *)(a2 + 32))
  {
    atomic_ullong valuePtr = (atomic_ullong)CFNumberCreate(v4, kCFNumberCFIndexType, (const void *)(a2 + 32));
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MRCErrorvImaggeErrorKey", (const void *)atomic_load_explicit(&valuePtr, memory_order_acquire));
    sub_1DC3065B8(&valuePtr);
  }
  if (*(unsigned char *)(a2 + 52) && *(_DWORD *)(a2 + 48))
  {
    uint64_t v6 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    atomic_ullong valuePtr = *(unsigned int *)(a2 + 48);
    CFNumberRef v17 = CFNumberCreate(v4, kCFNumberSInt64Type, &valuePtr);
    CFDictionarySetValue(v6, @"MRCErrorE5RTErrorCodeKey", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire));
    sub_1DC3065B8((atomic_ullong *)&v17);
    uint64_t v7 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    uint64_t v8 = *(unsigned int *)(a2 + 48);
    CFStringRef v9 = (uint64_t (**)(uint64_t))sub_1DC3154F4();
    uint64_t v10 = (*v9)(v8);
    if (v10) {
      size_t v11 = (const char *)v10;
    }
    else {
      size_t v11 = "";
    }
    atomic_ullong valuePtr = (atomic_ullong)CFStringCreateWithCStringNoCopy(v4, v11, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFDictionarySetValue(v7, @"MRCErrorE5RTErrorCodeStringKey", (const void *)atomic_load_explicit(&valuePtr, memory_order_acquire));
    sub_1DC31FA90(&valuePtr);
  }
  if (*(unsigned char *)(a2 + 60) && *(_DWORD *)(a2 + 56))
  {
    vImagePixelCount v12 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    LODWORD(v17) = *(_DWORD *)(a2 + 56);
    atomic_ullong valuePtr = (atomic_ullong)CFNumberCreate(v4, kCFNumberSInt32Type, &v17);
    CFDictionarySetValue(v12, @"MRCErrorKernReturnKey", (const void *)atomic_load_explicit(&valuePtr, memory_order_acquire));
    sub_1DC3065B8(&valuePtr);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 64), memory_order_acquire))
  {
    uint64_t v13 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E4F1D190], (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 64), memory_order_acquire));
  }
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 72), memory_order_acquire))
  {
    float16x4_t v14 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    CFDictionarySetValue(v14, (const void *)*MEMORY[0x1E4F1D188], (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 72), memory_order_acquire));
  }
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 80), memory_order_acquire))
  {
    int32x2_t v15 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    CFDictionarySetValue(v15, (const void *)*MEMORY[0x1E4F1D168], (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 80), memory_order_acquire));
  }
  if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 88), memory_order_acquire)) {
    CFDictionaryApplyFunction((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 88), memory_order_acquire), (CFDictionaryApplierFunction)sub_1DC391338, (void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  }
  *a1 = CFErrorCreate(v4, @"MRCErrorDomain", *(void *)a2, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  return sub_1DC306584((atomic_ullong *)&Mutable);
}

void sub_1DC3912D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  atomic_ullong v4 = va_arg(va1, void);
  sub_1DC3065B8((atomic_ullong *)va1);
  sub_1DC306584((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void sub_1DC391338(void *key, const void *a2, CFDictionaryRef theDict)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (CFDictionaryGetValue(theDict, key))
  {
    if (qword_1EBFFC270 != -1) {
      dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
    }
    uint64_t v6 = qword_1EBFFC278;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC278, OS_LOG_TYPE_DEBUG))
    {
      int v7 = 138543362;
      uint64_t v8 = key;
      _os_log_debug_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_DEBUG, "MRCError: extraUserInfo: key \"%{public}@\" already exists, skipping...", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    CFDictionarySetValue(theDict, key, a2);
  }
}

void sub_1DC39146C(std::exception *a1)
{
  sub_1DC379B0C(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3914A8(void *a1, char *a2)
{
  __int16 result = sub_1DC379B70(a1, a2);
  *__int16 result = &unk_1F3661208;
  return result;
}

atomic_uint **sub_1DC3914DC(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC391510(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661798;
  unint64_t v1 = (atomic_uint **)(a1 + 16);
  sub_1DC3914DC((atomic_uint **)(a1 + 32));
  sub_1DC2FF548(v1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC391584(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661798;
  uint64_t v2 = (atomic_uint **)(a1 + 16);
  sub_1DC3914DC((atomic_uint **)(a1 + 32));
  sub_1DC2FF548(v2);
  return a1;
}

uint64_t sub_1DC3915D8(uint64_t a1, uint64_t *a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661798;
  *(void *)(a1 + 16) = 0;
  atomic_ullong v4 = (atomic_uint **)(a1 + 16);
  uint64_t v5 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
    if (*v4) {
      sub_1DC2FF57C(*v4);
    }
  }
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = v5;
  *(unsigned char *)(a1 + 40) = 0;
  if (*(void *)(*a2 + 16) < 0x15uLL || (*(void *)(*a2 + 16) & 3) != 1)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC379B70(exception, "Dimension must be 1 mod 4 and >= 21");
    void *exception = &unk_1F36611E0;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
  return a1;
}

void sub_1DC3916CC(_Unwind_Exception *a1)
{
  sub_1DC3914DC((atomic_uint **)(v1 + 32));
  sub_1DC2FF548(v2);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC3916F8(atomic_uint **result, uint64_t a2)
{
  uint64_t v2 = *(atomic_uint **)(a2 + 32);
  if (v2)
  {
    atomic_fetch_add_explicit(v2 + 2, 1u, memory_order_relaxed);
    *__int16 result = v2;
  }
  else
  {
    char v45 = result;
    uint64_t v4 = 0;
    int v5 = 0;
    uint64_t v6 = *(void **)(a2 + 16);
    do
      int v5 = sub_1DC2FF924(v6, v4++, 8) | (2 * v5);
    while (v4 != 6);
    uint64_t v8 = v6[3];
    uint64_t v7 = v6[4];
    uint64_t v9 = v6[6];
    uint64_t v10 = v6[7];
    uint64_t v11 = -v10;
    uint64_t v12 = (v7 - 8) & -v10;
    LOBYTE(v10) = v10 - 1;
    uint64_t v13 = v6[2];
    uint64_t v14 = (v13 - 9) & v11;
    unint64_t v15 = (v14 | v10 & 7) + (v12 | v10 & 8) * v8;
    int v16 = (4 * v5) | (2 * ((*(_DWORD *)(v9 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v15) & 1));
    uint64_t v17 = (v7 - 9) & v11;
    unint64_t v18 = (v14 | v10 & 8) + (v17 | v10 & 8) * v8;
    unsigned int v19 = v16 & 0xFFFFFFFE | (*(_DWORD *)(v9 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v18) & 1;
    unint64_t v20 = ((v13 - 8) & v11 | v10 & 8) + (v17 | v10 & 7) * v8;
    int v21 = (*(_DWORD *)(v9 + ((v20 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v20) & 1 | (2 * v19);
    unint64_t v22 = ((v13 - 6) & v11 | v10 & 8) + (v17 | v10 & 5) * v8;
    int v23 = (*(_DWORD *)(v9 + ((v22 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v22) & 1;
    for (uint64_t i = 4; ; --i)
    {
      unsigned int v25 = v23 & 1 | (2 * v21);
      if (i == -1) {
        break;
      }
      LOBYTE(v23) = sub_1DC2FF924(v6, 8, i);
      int v21 = v25;
    }
    unsigned int v26 = 0;
    unsigned int v27 = 65793
        * (((2 * ((unsigned __int16)v21 >> 7)) | ((2 * v21) >> 8 << 11)) & 0x22110 | ((32 * ((unsigned __int16)v21 >> 7)) | ((2 * v21) >> 8 << 15)) & 0x88440);
    unsigned int v46 = (65793
         * (((2 * (v23 & 1 | (2 * v21))) | ((v23 & 1 | (2 * v21)) << 11)) & 0x22110 | ((32 * (v23 & 1 | (2 * v21))) | ((v23 & 1 | (2 * v21)) << 15)) & 0x88440u)) >> 9;
    uint64_t v28 = v13 << 32;
    uint64_t v29 = ((v13 << 32) - 0x100000000) >> 32;
    uint64_t v30 = (v13 << 32) - 0x700000000;
    uint64_t v31 = v29;
    uint64_t v32 = v30 >> 32;
    do
    {
      unsigned int v26 = sub_1DC2FF924(v6, 8, v31) | (2 * v26);
      BOOL v33 = v31-- <= v32;
    }
    while (!v33);
    int v34 = (v27 >> 17) & 0x7F;
    uint64_t v35 = (v28 - 0x800000000) >> 32;
    uint64_t v36 = v28 >> 32;
    uint64_t v37 = v35;
    do
      unsigned int v26 = sub_1DC2FF924(v6, v37++, 8) | (2 * v26);
    while (v37 < v36);
    unsigned int v38 = 0;
    do
    {
      unsigned int v38 = sub_1DC2FF924(v6, v29, 8) | (2 * v38);
      BOOL v33 = v29-- <= v32;
    }
    while (!v33);
    do
      unsigned int v38 = sub_1DC2FF924(v6, 8, v35++) | (2 * v38);
    while (v35 < v36);
    int16x4x4_t v51 = 0;
    int v52 = 0;
    unint64_t v49 = 0;
    int v50 = 0;
    sub_1DC3AA2E8((uint64_t)&v47, v25, v26);
    vImage_Buffer v39 = v47;
    if (v47) {
      atomic_fetch_add_explicit(v47 + 2, 1u, memory_order_relaxed);
    }
    if (v51) {
      sub_1DC2FF57C(v51);
    }
    int16x4x4_t v51 = v39;
    int v52 = v48;
    sub_1DC3914DC(&v47);
    sub_1DC3AA2E8((uint64_t)&v47, v34 | v46 & 0x7F80, v38);
    uint64_t v40 = v47;
    if (v47) {
      atomic_fetch_add_explicit(v47 + 2, 1u, memory_order_relaxed);
    }
    if (v49) {
      sub_1DC2FF57C(v49);
    }
    unint64_t v49 = v40;
    int v50 = v48;
    sub_1DC3914DC(&v47);
    uint64_t v41 = v51;
    if (v51) {
      atomic_fetch_add_explicit(v51 + 2, 1u, memory_order_relaxed);
    }
    __int16 v42 = *(atomic_uint **)(a2 + 32);
    if (v42) {
      sub_1DC2FF57C(v42);
    }
    *(void *)(a2 + 32) = v41;
    if (v50 < v52)
    {
      uint64_t v43 = v49;
      if (v49)
      {
        atomic_fetch_add_explicit(v49 + 2, 1u, memory_order_relaxed);
        uint64_t v41 = *(atomic_uint **)(a2 + 32);
      }
      if (v41) {
        sub_1DC2FF57C(v41);
      }
      *(void *)(a2 + 32) = v43;
      *(unsigned char *)(a2 + 40) = 1;
      uint64_t v41 = v43;
    }
    if (!v41)
    {
      exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
      sub_1DC379B70(exception, "Could not decode format information");
      void *exception = &unk_1F36611E0;
      __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
    }
    atomic_fetch_add_explicit(v41 + 2, 1u, memory_order_relaxed);
    *char v45 = v41;
    sub_1DC3914DC(&v49);
    return sub_1DC3914DC(&v51);
  }
  return result;
}

void sub_1DC391B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, atomic_uint *a13, uint64_t a14, atomic_uint *a15)
{
  __cxa_free_exception(v15);
  sub_1DC3914DC(&a13);
  sub_1DC3914DC(&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC391B9C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (!result)
  {
    uint64_t v3 = *(void **)(a1 + 16);
    uint64_t v4 = v3[2];
    if ((int)v4 >= 45)
    {
      unsigned int v5 = 0;
      uint64_t v6 = ((v4 << 32) - 0xB00000000) >> 32;
      uint64_t v7 = 5;
      do
      {
        uint64_t v8 = v7;
        uint64_t v9 = ((v4 << 32) - 0x900000000) >> 32;
        do
        {
          unsigned int v5 = sub_1DC2FF924(v3, v9, v8) | (2 * v5);
          BOOL v10 = v9-- <= v6;
        }
        while (!v10);
        uint64_t v7 = v8 - 1;
      }
      while (v8);
      uint64_t result = sub_1DC3B3024(v5);
      *(void *)(a1 + 24) = result;
      if (!result || 4 * *(_DWORD *)(result + 12) + 17 != v4)
      {
        unsigned int v11 = 0;
        uint64_t v12 = *(void **)(a1 + 16);
        uint64_t v13 = 5;
        do
        {
          uint64_t v14 = v13;
          uint64_t v15 = ((v4 << 32) - 0x900000000) >> 32;
          do
          {
            unsigned int v11 = sub_1DC2FF924(v12, v14, v15) | (2 * v11);
            BOOL v10 = v15-- <= v6;
          }
          while (!v10);
          uint64_t v13 = v14 - 1;
        }
        while (v14);
        uint64_t result = sub_1DC3B3024(v11);
        *(void *)(a1 + 24) = result;
        if (!result || 4 * *(_DWORD *)(result + 12) + 17 != v4)
        {
          exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
          sub_1DC3B430C(exception, "Could not decode version");
          __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
        }
      }
    }
    else
    {
      return sub_1DC3AC32C(((int)v4 - 17) >> 2);
    }
  }
  return result;
}

void sub_1DC391D38(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC391D4C(uint64_t a1, atomic_ullong *a2, uint64_t a3, __CFString *a4)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 64))
  {
    v47[0] = &unk_1F365F1E0;
    int v48 = v47;
    unint64_t v49 = a4;
    v46[0] = &unk_1F365F238;
    void v46[3] = v46;
    sub_1DC31AD78((uint64_t)v50, (uint64_t)v46);
    if (LOBYTE(v49->info)) {
      BOOL v8 = v48 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8) {
      sub_1DC31AE10((uint64_t)v48, (uint64_t)v49->isa);
    }
    sub_1DC31AE60(v46);
    sub_1DC31AE60(v47);
    if (atomic_load_explicit(a2, memory_order_acquire))
    {
      OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
      if (PixelFormatType == 875704422 || PixelFormatType == 875704438 || PixelFormatType == 1278226488)
      {
        if (sub_1DC38379C(a2, a3))
        {
          v57[0] = &unk_1F365F130;
          uint64_t v58 = v57;
          int v59 = a4;
          v56[0] = &unk_1F365F188;
          CFTypeRef v56[3] = v56;
          sub_1DC31AD78((uint64_t)v60, (uint64_t)v56);
          if (LOBYTE(v59->info) && v58) {
            sub_1DC31AE10((uint64_t)v58, (uint64_t)v59->isa);
          }
          sub_1DC31AE60(v56);
          sub_1DC31AE60(v57);
          CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
          int IsPlanar = CVPixelBufferIsPlanar((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
          unint64_t explicit = (__CVBuffer *)atomic_load_explicit(a2, memory_order_acquire);
          if (IsPlanar)
          {
            BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(explicit, 0);
            vImagePixelCount HeightOfPlane = CVPixelBufferGetHeightOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
            vImagePixelCount WidthOfPlane = CVPixelBufferGetWidthOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
            size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), 0);
          }
          else
          {
            BaseAddressOfPlane = CVPixelBufferGetBaseAddress(explicit);
            vImagePixelCount HeightOfPlane = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
            vImagePixelCount WidthOfPlane = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
            size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
          }
          size_t v22 = BytesPerRowOfPlane;
          if (*(unsigned char *)(a1 + 104))
          {
            uint64_t v43 = BaseAddressOfPlane;
            int v23 = *(char **)(a1 + 72);
            vImagePixelCount v24 = *(void *)(a1 + 80);
            if ((unint64_t)v23 > v24
              || v24 > WidthOfPlane
              || (v26 = *(void *)(a1 + 88), vImagePixelCount v25 = *(void *)(a1 + 96), v26 > v25)
              || v25 > HeightOfPlane)
            {
              if (qword_1EAA94CB0 != -1) {
                dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
              }
              uint64_t v28 = qword_1EAA94CA8;
              if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
              {
                size_t v41 = *(void *)(a1 + 88);
                vImagePixelCount v42 = *(void *)(a1 + 96);
                LODWORD(buf.data) = 134349824;
                *(void **)((char *)&buf.data + 4) = v23;
                WORD2(buf.height) = 2050;
                *(vImagePixelCount *)((char *)&buf.height + 6) = v24;
                HIWORD(buf.width) = 2050;
                buf.size_t rowBytes = v41;
                __int16 v54 = 2050;
                vImagePixelCount v55 = v42;
                _os_log_error_impl(&dword_1DC2FE000, v28, OS_LOG_TYPE_ERROR, "Invalid cropRect: xStart=%{public}zu, xEnd=%{public}zu, yStart=%{public}zu, yEnd=%{public}zu", (uint8_t *)&buf, 0x2Au);
              }
              buf.data = (void *)-6008;
              *(void *)int v52 = @"Invalid cropRect.";
              sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, (CFTypeRef *)v52);
              uint64_t v17 = 0;
              goto LABEL_83;
            }
            if (qword_1EAA94CB0 != -1) {
              dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
            }
            unsigned int v27 = qword_1EAA94CA8;
            if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_DEBUG))
            {
              LODWORD(buf.data) = 134349824;
              *(void **)((char *)&buf.data + 4) = v23;
              WORD2(buf.height) = 2050;
              *(vImagePixelCount *)((char *)&buf.height + 6) = v24;
              HIWORD(buf.width) = 2050;
              buf.size_t rowBytes = v26;
              __int16 v54 = 2050;
              vImagePixelCount v55 = v25;
              _os_log_debug_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_DEBUG, "cropRect: xStart=%{public}zu, xEnd=%{public}zu, yStart=%{public}zu, yEnd=%{public}zu", (uint8_t *)&buf, 0x2Au);
              size_t v26 = *(void *)(a1 + 88);
              vImagePixelCount v25 = *(void *)(a1 + 96);
              int v23 = *(char **)(a1 + 72);
              vImagePixelCount v24 = *(void *)(a1 + 80);
            }
            vImagePixelCount HeightOfPlane = v25 - v26;
            src.data = &v23[v26 * v22 + (void)v43];
            src.unint64_t height = v25 - v26;
            vImagePixelCount WidthOfPlane = v24 - (void)v23;
            src.unint64_t width = v24 - (void)v23;
          }
          else
          {
            if (qword_1EAA94CB0 != -1) {
              dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
            }
            uint64_t v29 = qword_1EAA94CA8;
            if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_DEBUG))
            {
              LOWORD(buf.data) = 0;
              _os_log_debug_impl(&dword_1DC2FE000, v29, OS_LOG_TYPE_DEBUG, "cropRect: not set", (uint8_t *)&buf, 2u);
            }
            src.data = BaseAddressOfPlane;
            src.unint64_t height = HeightOfPlane;
            src.unint64_t width = WidthOfPlane;
          }
          src.size_t rowBytes = v22;
          long long v30 = *(_OWORD *)(a1 + 48);
          *(_OWORD *)&buf.data = *(_OWORD *)(a1 + 32);
          *(_OWORD *)&buf.unint64_t width = v30;
          if (HeightOfPlane <= WidthOfPlane)
          {
            unint64_t width = buf.width;
            unint64_t height = vcvtas_u32_f32((float)((float)buf.width / (float)WidthOfPlane) * (float)HeightOfPlane);
            buf.unint64_t height = height;
          }
          else
          {
            unint64_t height = buf.height;
            unint64_t width = vcvtas_u32_f32((float)((float)buf.height / (float)HeightOfPlane) * (float)WidthOfPlane);
            buf.unint64_t width = width;
          }
          if (WidthOfPlane == width && HeightOfPlane == height)
          {
            vImage_Error v33 = vImageCopyBuffer(&src, &buf, 1uLL, 0);
            if (v33)
            {
              if (qword_1EAA94CB0 != -1) {
                dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
              }
              int v34 = qword_1EAA94CA8;
              if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)int v52 = 134349056;
                *(void *)&v52[4] = v33;
                _os_log_error_impl(&dword_1DC2FE000, v34, OS_LOG_TYPE_ERROR, "vImageCopyBuffer failed: %{public}zd", v52, 0xCu);
              }
              *(void *)int v52 = -6008;
              __int16 v44 = @"vImageCopyBuffer failed.";
              sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v52, (CFTypeRef *)&v44);
LABEL_75:
              uint64_t v17 = 0;
              *(void *)(a3 + 32) = v33;
              *(unsigned char *)(a3 + 40) = 1;
              goto LABEL_83;
            }
          }
          else
          {
            vImage_Error v33 = vImageScale_Planar8(&src, &buf, 0, 0);
            if (v33)
            {
              if (qword_1EAA94CB0 != -1) {
                dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
              }
              uint64_t v35 = qword_1EAA94CA8;
              if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)int v52 = 134349056;
                *(void *)&v52[4] = v33;
                _os_log_error_impl(&dword_1DC2FE000, v35, OS_LOG_TYPE_ERROR, "vImageScale_Planar8 failed: %{public}zd", v52, 0xCu);
              }
              *(void *)int v52 = -2004;
              __int16 v44 = @"vImageScale_Planar8 failed.";
              sub_1DC306334((atomic_ullong *)a3, (uint64_t *)v52, (CFTypeRef *)&v44);
              goto LABEL_75;
            }
            if (HeightOfPlane <= WidthOfPlane)
            {
              bzero((char *)buf.data + buf.rowBytes * buf.height, (*(void *)(a1 + 40) - buf.height) * buf.rowBytes);
            }
            else if (buf.height)
            {
              vImagePixelCount v36 = 0;
              do
                bzero((char *)buf.data + buf.width + buf.rowBytes * v36++, *(void *)(a1 + 48) - buf.width);
              while (v36 < buf.height);
              uint64_t v17 = 1;
LABEL_83:
              if (LOBYTE(v59->info)) {
                BOOL v37 = v61 == 0;
              }
              else {
                BOOL v37 = 1;
              }
              if (!v37) {
                sub_1DC31AE10(v61, (uint64_t)v59->isa);
              }
              sub_1DC31AE60(v60);
              sub_1DC3836F8(a2, a3);
              goto LABEL_89;
            }
          }
          uint64_t v17 = 1;
          goto LABEL_83;
        }
        if (qword_1EAA94CB0 != -1) {
          dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
        }
        unsigned int v19 = qword_1EAA94CA8;
        if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
        {
          int v20 = *(_DWORD *)(a3 + 24);
          LODWORD(buf.data) = 67240192;
          HIDWORD(buf.data) = v20;
          _os_log_error_impl(&dword_1DC2FE000, v19, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&buf, 8u);
        }
      }
      else
      {
        if (qword_1EAA94CB0 != -1) {
          dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
        }
        int v21 = qword_1EAA94CA8;
        if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
        {
          OSType v40 = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
          LODWORD(buf.data) = 67240192;
          HIDWORD(buf.data) = v40;
          _os_log_error_impl(&dword_1DC2FE000, v21, OS_LOG_TYPE_ERROR, "Unsupported pixel format: %{public}u", (uint8_t *)&buf, 8u);
        }
        buf.data = (void *)-2001;
        int v59 = @"Unsupported pixel format.";
        sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, (CFTypeRef *)&v59);
      }
    }
    else
    {
      if (qword_1EAA94CB0 != -1) {
        dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
      }
      unint64_t v18 = qword_1EAA94CA8;
      if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.data) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v18, OS_LOG_TYPE_ERROR, "Missing pixel buffer.", (uint8_t *)&buf, 2u);
      }
      buf.data = (void *)-6008;
      int v59 = @"Missing pixel buffer.";
      sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, (CFTypeRef *)&v59);
    }
    uint64_t v17 = 0;
LABEL_89:
    if (LOBYTE(v49->info)) {
      BOOL v38 = v51 == 0;
    }
    else {
      BOOL v38 = 1;
    }
    if (!v38) {
      sub_1DC31AE10(v51, (uint64_t)v49->isa);
    }
    sub_1DC31AE60(v50);
    return v17;
  }
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  int v16 = qword_1EAA94CA8;
  if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.data) = 0;
    _os_log_error_impl(&dword_1DC2FE000, v16, OS_LOG_TYPE_ERROR, "IIEImagePreprocessor is not ready.", (uint8_t *)&buf, 2u);
  }
  buf.data = (void *)-6008;
  int v59 = @"IIEImagePreprocessor is not ready.";
  sub_1DC306334((atomic_ullong *)a3, (uint64_t *)&buf, (CFTypeRef *)&v59);
  return 0;
}

void sub_1DC392710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t *a28)
{
  sub_1DC31AEE4((uint64_t **)(v28 - 144));
  sub_1DC32D374((uint64_t)&a12);
  sub_1DC31AEE4(&a28);
  _Unwind_Resume(a1);
}

void *sub_1DC3927D0()
{
  return &unk_1F365EC98;
}

uint64_t sub_1DC3927DC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie20IIEImagePreprocessor17resampleIfNeeded_ERKNS_6Sample11PixelBufferERKNS3_21ScopedPixelBufferLockILb1EEERNSt3__18optionalINS_5ErrorEEERKNSC_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC392818(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "IIEImagePreprocessor::resampleIfNeeded_", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3928C4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F188;
}

void *sub_1DC3928E4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F188;
  return result;
}

void sub_1DC39291C()
{
}

void *sub_1DC392934()
{
  return &unk_1F365EC88;
}

uint64_t sub_1DC392940(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie20IIEImagePreprocessor17resampleIfNeeded_ERKNS_6Sample11PixelBufferERKNS3_21ScopedPixelBufferLockILb1EEERNSt3__18optionalINS_5ErrorEEERKNSC_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC39297C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "IIEImagePreprocessor::resampleIfNeeded_", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC392A28(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F130;
}

void *sub_1DC392A48()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F130;
  return result;
}

void sub_1DC392A80()
{
}

void *sub_1DC392A98()
{
  return &unk_1F365ECB8;
}

uint64_t sub_1DC392AA4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie20IIEImagePreprocessor3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC392AE0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "IIEImagePreprocessor::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC392B8C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F238;
}

void *sub_1DC392BAC()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F238;
  return result;
}

void sub_1DC392BE4()
{
}

void *sub_1DC392BFC()
{
  return &unk_1F365ECA8;
}

uint64_t sub_1DC392C08(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie20IIEImagePreprocessor3runERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC392C44(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "IIEImagePreprocessor::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC392CF0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F1E0;
}

void *sub_1DC392D10()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F1E0;
  return result;
}

void sub_1DC392D48()
{
}

uint64_t sub_1DC392D60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 64)) {
    return 1;
  }
  v31[0] = &unk_1F365F290;
  uint64_t v32 = v31;
  v30[0] = &unk_1F365F2E8;
  void v30[3] = v30;
  uint64_t v33 = a3;
  sub_1DC31AD78((uint64_t)v34, (uint64_t)v30);
  if (*(unsigned char *)(v33 + 8)) {
    BOOL v6 = v32 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    sub_1DC31AE10((uint64_t)v32, *(void *)v33);
  }
  sub_1DC31AE60(v30);
  sub_1DC31AE60(v31);
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 16);
  if (!v7 || (v7 & 0xF) != 0 || !v8 || (v8 & 0xF) != 0)
  {
    if (qword_1EAA94CB0 != -1) {
      dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
    }
    uint64_t v12 = qword_1EAA94CA8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 134349312;
      *(void *)&uint8_t buf[4] = v7;
      __int16 v22 = 2050;
      uint64_t v23 = v8;
      _os_log_error_impl(&dword_1DC2FE000, v12, OS_LOG_TYPE_ERROR, "Invalid image size: width=%{public}zu, height=%{public}zu", buf, 0x16u);
    }
    int v20 = @"Invalid image size.";
    *(void *)vImage_Buffer buf = -6008;
    sub_1DC306334((atomic_ullong *)a2, (uint64_t *)buf, (CFTypeRef *)&v20);
  }
  else
  {
    int v9 = *(_DWORD *)(a1 + 24);
    if (v9 == 1278226488)
    {
      uint64_t v3 = 1;
      if (!*(unsigned char *)(a1 + 64))
      {
        *(_OWORD *)(a1 + 32) = 0u;
        *(_OWORD *)(a1 + 48) = 0u;
        *(unsigned char *)(a1 + 64) = 1;
        uint64_t v10 = MEMORY[0x1E019D900]();
        if (v10)
        {
          if (*(unsigned char *)(a1 + 64)) {
            *(unsigned char *)(a1 + 64) = 0;
          }
          if (qword_1EAA94CB0 != -1) {
            dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
          }
          unsigned int v11 = qword_1EAA94CA8;
          if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)vImage_Buffer buf = 134349056;
            *(void *)&uint8_t buf[4] = v10;
            _os_log_error_impl(&dword_1DC2FE000, v11, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", buf, 0xCu);
          }
          int v20 = @"vImageBuffer_Init failed.";
          *(void *)vImage_Buffer buf = -2003;
          sub_1DC306334((atomic_ullong *)a2, (uint64_t *)buf, (CFTypeRef *)&v20);
          uint64_t v3 = 0;
          *(void *)(a2 + 32) = v10;
          *(unsigned char *)(a2 + 40) = 1;
        }
        else
        {
          if (qword_1EAA94CB0 != -1) {
            dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
          }
          uint64_t v15 = qword_1EAA94CA8;
          if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v16 = *(void *)(a1 + 32);
            uint64_t v17 = *(void *)(a1 + 40);
            uint64_t v18 = *(void *)(a1 + 48);
            uint64_t v19 = *(void *)(a1 + 56);
            *(_DWORD *)vImage_Buffer buf = 136447234;
            *(void *)&uint8_t buf[4] = "420Yp8";
            __int16 v22 = 2050;
            uint64_t v23 = v16;
            __int16 v24 = 2050;
            uint64_t v25 = v17;
            __int16 v26 = 2050;
            uint64_t v27 = v18;
            __int16 v28 = 2050;
            uint64_t v29 = v19;
            _os_log_debug_impl(&dword_1DC2FE000, v15, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", buf, 0x34u);
          }
        }
      }
      goto LABEL_28;
    }
    if (qword_1EAA94CB0 != -1) {
      dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
    }
    uint64_t v14 = qword_1EAA94CA8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)vImage_Buffer buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v9;
      _os_log_error_impl(&dword_1DC2FE000, v14, OS_LOG_TYPE_ERROR, "Unsupported pixel format type: %{public}u", buf, 8u);
    }
    int v20 = @"Unsupported pixel format type.";
    *(void *)vImage_Buffer buf = -6008;
    sub_1DC306334((atomic_ullong *)a2, (uint64_t *)buf, (CFTypeRef *)&v20);
  }
  uint64_t v3 = 0;
LABEL_28:
  if (*(unsigned char *)(v33 + 8) && v35) {
    sub_1DC31AE10(v35, *(void *)v33);
  }
  sub_1DC31AE60(v34);
  return v3;
}

void sub_1DC3931A0(_Unwind_Exception *a1)
{
  sub_1DC31AEE4((uint64_t **)(v1 - 96));
  _Unwind_Resume(a1);
}

void *sub_1DC3931F8()
{
  return &unk_1F365ECD8;
}

uint64_t sub_1DC393204(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie20IIEImagePreprocessor7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC393240(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "IIEImagePreprocessor::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3932EC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F2E8;
}

void *sub_1DC39330C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F2E8;
  return result;
}

void sub_1DC393344()
{
}

void *sub_1DC39335C()
{
  return &unk_1F365ECC8;
}

uint64_t sub_1DC393368(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie20IIEImagePreprocessor7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3933A4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "IIEImagePreprocessor::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC393450(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F290;
}

void *sub_1DC393470()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F290;
  return result;
}

void sub_1DC3934A8()
{
}

uint64_t sub_1DC3934C0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

BOOL sub_1DC3934C8(uint64_t a1, atomic_ullong *a2)
{
  BOOL result = 0;
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
    BOOL v3 = PixelFormatType == 875704422 || PixelFormatType == 1278226488;
    if (v3 || PixelFormatType == 875704438) {
      return 1;
    }
  }
  return result;
}

void sub_1DC393520(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64)) {
    free(*(void **)(a1 + 32));
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC393574(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64)) {
    free(*(void **)(a1 + 32));
  }
  return a1;
}