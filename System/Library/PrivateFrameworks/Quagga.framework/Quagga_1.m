uint64_t sub_1DC3935A8(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)a1;
  if (v2) {
    free(v2);
  }
  v3 = *(void **)(a1 + 32);
  if (v3)
  {
    *(void *)(a1 + 40) = v3;
    operator delete(v3);
  }
  return a1;
}

BOOL sub_1DC3935E8(uint64_t a1, uint64_t a2, atomic_ullong *a3, atomic_ullong *a4, atomic_ullong *a5, atomic_ullong *a6, atomic_ullong *a7, void *a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v250 = *MEMORY[0x1E4F143B8];
  CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(a3, memory_order_acquire);
  if (explicit) {
    CFTypeRef explicit = CFRetain(explicit);
  }
  CFTypeRef v232 = explicit;
  char v233 = 0;
  *(_DWORD *)v234 = src.data;
  *(_DWORD *)&v234[3] = *(_DWORD *)((char *)&src.data + 3);
  char v235 = 0;
  *(_DWORD *)v236 = v225;
  *(_DWORD *)&v236[3] = *(_DWORD *)((char *)&v225 + 3);
  uint64_t v237 = a13;
  char v238 = sub_1DC36FEF8((atomic_ullong *)&v232, (uint64_t)&v233, 1, a13);
  CFTypeRef v24 = (CFTypeRef)atomic_load_explicit(a4, memory_order_acquire);
  if (v24) {
    CFTypeRef v24 = CFRetain(v24);
  }
  CFTypeRef v225 = v24;
  char v226 = 0;
  *(_DWORD *)v227 = src.data;
  *(_DWORD *)&v227[3] = *(_DWORD *)((char *)&src.data + 3);
  char v228 = 0;
  *(_DWORD *)v229 = v218;
  *(_DWORD *)&v229[3] = *(_DWORD *)((char *)&v218 + 3);
  uint64_t v230 = a13;
  char v231 = sub_1DC36FEF8((atomic_ullong *)&v225, (uint64_t)&v226, 0, a13);
  CFTypeRef v25 = (CFTypeRef)atomic_load_explicit(a5, memory_order_acquire);
  uint64_t v186 = a1;
  if (v25) {
    CFTypeRef v25 = CFRetain(v25);
  }
  CFTypeRef v218 = v25;
  char v219 = 0;
  *(_DWORD *)v220 = src.data;
  *(_DWORD *)&v220[3] = *(_DWORD *)((char *)&src.data + 3);
  char v221 = 0;
  *(_DWORD *)v222 = v211;
  *(_DWORD *)&v222[3] = *(_DWORD *)((char *)&v211 + 3);
  uint64_t v223 = a13;
  char v224 = sub_1DC36FEF8((atomic_ullong *)&v218, (uint64_t)&v219, 1, a13);
  CFTypeRef v26 = (CFTypeRef)atomic_load_explicit(a6, memory_order_acquire);
  if (v26) {
    CFTypeRef v26 = CFRetain(v26);
  }
  CFTypeRef v211 = v26;
  char v212 = 0;
  *(_DWORD *)v213 = src.data;
  *(_DWORD *)&v213[3] = *(_DWORD *)((char *)&src.data + 3);
  char v214 = 0;
  *(_DWORD *)v215 = v204;
  *(_DWORD *)&v215[3] = *(_DWORD *)((char *)&v204 + 3);
  uint64_t v216 = a13;
  char v217 = sub_1DC36FEF8((atomic_ullong *)&v211, (uint64_t)&v212, 1, a13);
  CFTypeRef v27 = (CFTypeRef)atomic_load_explicit(a7, memory_order_acquire);
  if (v27) {
    CFTypeRef v27 = CFRetain(v27);
  }
  CFTypeRef v204 = v27;
  char v205 = 0;
  *(_DWORD *)v206 = src.data;
  *(_DWORD *)&v206[3] = *(_DWORD *)((char *)&src.data + 3);
  char v207 = 0;
  *(_DWORD *)v208 = dest.data;
  *(_DWORD *)&v208[3] = *(_DWORD *)((char *)&dest.data + 3);
  uint64_t v209 = a13;
  int v28 = sub_1DC36FEF8((atomic_ullong *)&v204, (uint64_t)&v205, 1, a13);
  char v210 = v28;
  if (!v238 || !v231 || !v224 || !v217 || v28 != 1)
  {
    if (qword_1EAA94CB0 != -1) {
      dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
    }
    v55 = qword_1EAA94CA8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
    {
      int v181 = *(_DWORD *)(a13 + 56);
      LODWORD(src.data) = 67240192;
      HIDWORD(src.data) = v181;
      _os_log_error_impl(&dword_1DC2FE000, v55, OS_LOG_TYPE_ERROR, "IOSurfaceLock failed: %{public}d", (uint8_t *)&src, 8u);
    }
    goto LABEL_34;
  }
  BaseAddress = (char *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a3, memory_order_acquire));
  v29 = (short float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a4, memory_order_acquire));
  v198 = (short float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a5, memory_order_acquire));
  v197 = (short float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a6, memory_order_acquire));
  v30 = IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a7, memory_order_acquire));
  unint64_t v33 = 0;
  char v34 = 0;
  vImagePixelCount v189 = a8[8];
  uint64_t v188 = a8[7];
  unint64_t v35 = a8[2];
  unint64_t v36 = a8[12];
  unint64_t v37 = a8[13];
  unint64_t v39 = a9[7];
  unint64_t v38 = a9[8];
  uint64_t v194 = a9[6];
  unint64_t v40 = a9[2];
  unint64_t v41 = a9[11];
  unint64_t v42 = a9[12];
  unint64_t v43 = a10[2];
  _Q0.n128_u64[0] = 0;
  unint64_t v46 = a10[11];
  unint64_t v45 = a10[12];
  unint64_t v47 = a11[2];
  unint64_t v48 = a11[11];
  unint64_t v49 = a11[12];
  uint64_t v50 = *(void *)(a12 + 88) / *(void *)(a12 + 16);
  unint64_t v51 = -1;
  do
  {
    v31.n128_u16[0] = v30[v33 * v50];
    BOOL v52 = v34 == 0;
    if (*(short float *)v31.n128_u16 > *(short float *)_Q0.n128_u16) {
      BOOL v52 = 1;
    }
    if (v52)
    {
      _Q0.n128_u16[0] = v30[v33 * v50];
      char v34 = 1;
      unint64_t v51 = v33;
    }
    ++v33;
  }
  while (v33 != 6);
  __int16 v53 = v51 | 0x100;
  if (v51 > 5) {
    __int16 v53 = 0;
  }
  __int16 v203 = v53;
  if (v51 >= 6)
  {
    if (qword_1EAA94CB0 != -1) {
      dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
    }
    v54 = qword_1EAA94CA8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(src.data) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v54, OS_LOG_TYPE_ERROR, "Invalid category yielded from attributes.", (uint8_t *)&src, 2u);
    }
    src.data = (void *)-6009;
    dest.data = @"Invalid category yielded from attributes.";
    sub_1DC306334((atomic_ullong *)a13, (uint64_t *)&src, (CFTypeRef *)&dest.data);
LABEL_34:
    BOOL v56 = 0;
    goto LABEL_35;
  }
  unint64_t v58 = v42 / v40;
  short float v59 = *(short float *)&v30[6 * v50];
  unint64_t v196 = v45 / v43;
  unint64_t v60 = *(void *)(a2 + 8);
  __asm { FCMP            H0, #0 }
  if (_NF ^ _VF | _ZF) {
    char v64 = 0;
  }
  else {
    char v64 = 1;
  }
  char v202 = v64;
  unint64_t v65 = v49 / v47;
  unint64_t v193 = v49 / v47;
  unint64_t v185 = v60;
  unint64_t v183 = v36;
  unint64_t v184 = v35;
  unint64_t v182 = v37;
  if ((v51 & 0xFE) == 4)
  {
    __p = 0;
    v66 = 0;
    unint64_t v67 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = v39 - 1;
    do
    {
      LOWORD(v14) &= 0xFF00u;
      if (v39)
      {
        uint64_t v70 = 0;
        uint64_t v71 = 0;
        uint64_t v72 = 0;
        int v73 = 0;
        do
        {
          if (v38)
          {
            uint64_t v74 = 0;
            uint64_t v75 = v70 * v58;
            do
            {
              _ZF = v29[v74 + v75] > v14 || v73 == 0;
              if (_ZF)
              {
                short float v14 = v29[v74 + v75];
                uint64_t v72 = v70;
                uint64_t v71 = v74;
              }
              ++v74;
              int v73 = 1;
            }
            while (v38 != v74);
          }
          ++v70;
        }
        while (v70 != v39);
      }
      else
      {
        uint64_t v72 = 0;
        uint64_t v71 = 0;
      }
      if (v72 <= 1) {
        uint64_t v78 = 1;
      }
      else {
        uint64_t v78 = v72;
      }
      unint64_t v79 = v78 - 1;
      if (v69 >= v72 + 1) {
        unint64_t v80 = v72 + 1;
      }
      else {
        unint64_t v80 = v69;
      }
      if (v71 <= 1) {
        uint64_t v81 = 1;
      }
      else {
        uint64_t v81 = v71;
      }
      if ((uint64_t)(v38 - 1) >= v71 + 1) {
        unint64_t v82 = v71 + 1;
      }
      else {
        unint64_t v82 = v38 - 1;
      }
      if (v79 <= v80)
      {
        unint64_t v83 = v81 - 1;
        do
        {
          if (v83 <= v82)
          {
            unint64_t v84 = v83;
            do
            {
              LOWORD(v29[v84 + v79 * v58]) = -1024;
              ++v84;
            }
            while (v84 <= v82);
          }
          ++v79;
        }
        while (v79 <= v80);
      }
      *(short float *)v32.n128_u16 = (short float)(v198[v71 + v72 * v196] + (short float)(unint64_t)v71)
                                   / (short float)v38;
      *(short float *)&v32.n128_u16[1] = (short float)(v197[v71 + v72 * v65] + (short float)(unint64_t)v72)
                                       / (short float)v39;
      if ((unint64_t)v66 >= v67)
      {
        unint64_t v195 = v32.n128_u64[0];
        uint64_t v85 = (v66 - __p) >> 2;
        unint64_t v86 = v85 + 1;
        if ((unint64_t)(v85 + 1) >> 62) {
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v67 - (void)__p) >> 1 > v86) {
          unint64_t v86 = (uint64_t)(v67 - (void)__p) >> 1;
        }
        if (v67 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v87 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v87 = v86;
        }
        if (v87) {
          unint64_t v87 = (unint64_t)sub_1DC314E5C(v87);
        }
        else {
          uint64_t v88 = 0;
        }
        v89 = (char *)(v87 + 4 * v85);
        _Q0.n128_u32[1] = HIDWORD(v195);
        *(_DWORD *)v89 = v195;
        v90 = v89 + 4;
        if (v66 == __p)
        {
          v91 = __p;
        }
        else
        {
          v91 = __p;
          do
          {
            int v92 = *((_DWORD *)v66 - 1);
            v66 -= 4;
            *((_DWORD *)v89 - 1) = v92;
            v89 -= 4;
          }
          while (v66 != __p);
        }
        unint64_t v67 = v87 + 4 * v88;
        if (v91)
        {
          unint64_t v93 = v67;
          operator delete(v91);
          unint64_t v67 = v93;
        }
        __p = v89;
        v66 = v90;
        unint64_t v65 = v193;
        uint64_t v69 = v39 - 1;
      }
      else
      {
        *(_DWORD *)v66 = v32.n128_u32[0];
        v66 += 4;
      }
      ++v68;
    }
    while (v68 != 4);
    v94 = (unsigned __int32 *)__p;
    uint64_t v95 = v67;
    float16x4_t v96 = (float16x4_t)0x3800380038003800;
    while (v94 != (unsigned __int32 *)v66)
    {
      unsigned __int32 v97 = *v94++;
      _Q0.n128_u32[0] = v97;
      float16x4_t v96 = vadd_f16(v96, (float16x4_t)_Q0.n128_u64[0]);
    }
    memset(&src, 0, 24);
    v119 = (__int32 *)__p;
    size_t v120 = v66 - __p;
    sub_1DC37E438(&src.data, (v66 - __p) >> 2);
    if (__p == v66)
    {
      vImagePixelCount height = src.height;
    }
    else
    {
      v121.i32[1] = 872428544;
      float16x4_t v122 = vmul_f16(v96, (float16x4_t)0x3400340034003400);
      v123 = (float *)src.height;
      vImagePixelCount width = src.width;
      do
      {
        v121.i32[0] = *v119;
        _S1 = vsub_f16(v121, v122).u32[0];
        _H0 = HIWORD(_S1);
        __asm
        {
          FCVT            S0, H0; float
          FCVT            S1, H1; float
        }
        float v129 = atan2f(_S0, _S1) + 2.3562;
        if ((unint64_t)v123 >= width)
        {
          data = (float *)src.data;
          uint64_t v132 = ((char *)v123 - (char *)src.data) >> 2;
          unint64_t v133 = v132 + 1;
          if ((unint64_t)(v132 + 1) >> 62) {
            sub_1DC2FF97C();
          }
          if ((uint64_t)(width - (unint64_t)src.data) >> 1 > v133) {
            unint64_t v133 = (uint64_t)(width - (unint64_t)src.data) >> 1;
          }
          if (width - (unint64_t)src.data >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v133 = 0x3FFFFFFFFFFFFFFFLL;
          }
          if (v133)
          {
            unint64_t v133 = (unint64_t)sub_1DC314E5C(v133);
            data = (float *)src.data;
            v123 = (float *)src.height;
          }
          else
          {
            uint64_t v134 = 0;
          }
          v135 = (float *)(v133 + 4 * v132);
          float *v135 = v129;
          vImagePixelCount height = (vImagePixelCount)(v135 + 1);
          while (v123 != data)
          {
            int v136 = *((_DWORD *)v123-- - 1);
            *((_DWORD *)v135-- - 1) = v136;
          }
          vImagePixelCount width = v133 + 4 * v134;
          src.data = v135;
          src.vImagePixelCount width = width;
          if (data) {
            operator delete(data);
          }
        }
        else
        {
          float *v123 = v129;
          vImagePixelCount height = (vImagePixelCount)(v123 + 1);
        }
        src.vImagePixelCount height = height;
        ++v119;
        v123 = (float *)height;
      }
      while (v119 != (__int32 *)v66);
    }
    sub_1DC3958B4(&dest, (uint64_t)(height - (unint64_t)src.data) >> 2);
    v137 = (uint64_t *)dest.data;
    v138 = (uint64_t *)dest.height;
    if (dest.data != (void *)dest.height)
    {
      uint64_t v139 = 0;
      v140 = (uint64_t *)dest.data;
      do
        *v140++ = v139++;
      while (v140 != v138);
    }
    unint64_t v141 = 126 - 2 * __clz(v138 - v137);
    __src.n128_u64[0] = (unint64_t)&src;
    if (v138 == v137) {
      uint64_t v142 = 0;
    }
    else {
      uint64_t v142 = v141;
    }
    sub_1DC39656C((uint64_t)v137, v138, (uint64_t **)&__src, v142, 1);
    __src.n128_u32[0] = *(_DWORD *)&__p[4 * *(void *)dest.data];
    uint64_t v143 = *((void *)dest.data + 2);
    __src.n128_u32[1] = *(_DWORD *)&__p[4 * *((void *)dest.data + 3)];
    __src.n128_u32[2] = *(_DWORD *)&__p[4 * v143];
    __src.n128_u32[3] = *(_DWORD *)&__p[4 * *((void *)dest.data + 1)];
    if ((unint64_t)(v95 - (void)__p) >= 0x10)
    {
      if (v120 <= 0xF)
      {
        v146 = __p;
        v147 = __p;
        if (__p != v66)
        {
          memmove(__p, &__src, v120);
          v147 = v66;
        }
        size_t v148 = 16 - v120;
        memmove(v147, (char *)&__src + 4 * ((v66 - __p) >> 2), v148);
        goto LABEL_188;
      }
      _Q0 = __src;
      v146 = __p;
    }
    else
    {
      if (__p)
      {
        operator delete(__p);
        uint64_t v95 = 0;
      }
      uint64_t v144 = v95 >> 1;
      if ((unint64_t)(v95 >> 1) <= 4) {
        uint64_t v144 = 4;
      }
      if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v145 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v145 = v144;
      }
      if (v145 >> 62) {
        sub_1DC2FF97C();
      }
      v146 = (char *)sub_1DC314E5C(v145);
      _Q0 = __src;
    }
    *(__n128 *)v146 = _Q0;
    size_t v148 = 16;
    v147 = v146;
LABEL_188:
    if (dest.data)
    {
      dest.vImagePixelCount height = (vImagePixelCount)dest.data;
      operator delete(dest.data);
    }
    __pa = v146;
    v111 = &v147[v148];
    if (src.data)
    {
      src.vImagePixelCount height = (vImagePixelCount)src.data;
      operator delete(src.data);
    }
    goto LABEL_192;
  }
  if (v194)
  {
    __pa = 0;
    v98 = 0;
    unint64_t v99 = 0;
    uint64_t v100 = 0;
    unint64_t v190 = v41 / v40;
    unint64_t v101 = v46 / v43;
    unint64_t v102 = v48 / v47;
    do
    {
      LOWORD(v13) &= 0xFF00u;
      if (v39)
      {
        unint64_t v103 = 0;
        unint64_t v104 = 0;
        unint64_t v105 = 0;
        int v106 = 0;
        do
        {
          if (v38)
          {
            unint64_t v107 = 0;
            unint64_t v108 = v100 * v190 + v103 * v58;
            do
            {
              if (v29[v108 + v107] > v13 || v106 == 0)
              {
                short float v13 = v29[v108 + v107];
                unint64_t v105 = v103;
                unint64_t v104 = v107;
              }
              ++v107;
              int v106 = 1;
            }
            while (v38 != v107);
          }
          ++v103;
        }
        while (v103 != v39);
      }
      else
      {
        unint64_t v105 = 0;
        unint64_t v104 = 0;
      }
      *(short float *)v32.n128_u16 = (short float)(v198[v100 * v101 + v105 * v196 + v104] + (short float)v104)
                                   / (short float)v38;
      *(short float *)v31.n128_u16 = (short float)v105;
      *(short float *)_Q0.n128_u16 = (short float)(v197[v100 * v102 + v105 * v65 + v104] + (short float)v105)
                                   / (short float)v39;
      v32.n128_u16[1] = _Q0.n128_u16[0];
      if ((unint64_t)v98 >= v99)
      {
        __n128 v191 = v32;
        uint64_t v112 = (v98 - __pa) >> 2;
        unint64_t v113 = v112 + 1;
        if ((unint64_t)(v112 + 1) >> 62) {
          sub_1DC2FF97C();
        }
        unint64_t v114 = v102;
        if ((uint64_t)(v99 - (void)__pa) >> 1 > v113) {
          unint64_t v113 = (uint64_t)(v99 - (void)__pa) >> 1;
        }
        if (v99 - (unint64_t)__pa >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v115 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v115 = v113;
        }
        if (v115) {
          unint64_t v115 = (unint64_t)sub_1DC314E5C(v115);
        }
        else {
          uint64_t v116 = 0;
        }
        v117 = (char *)(v115 + 4 * v112);
        _Q0 = v191;
        *(_DWORD *)v117 = v191.n128_u32[0];
        v192 = v117 + 4;
        while (v98 != __pa)
        {
          int v118 = *((_DWORD *)v98 - 1);
          v98 -= 4;
          *((_DWORD *)v117 - 1) = v118;
          v117 -= 4;
        }
        unint64_t v99 = v115 + 4 * v116;
        if (__pa) {
          operator delete(__pa);
        }
        __pa = v117;
        unint64_t v65 = v193;
        unint64_t v102 = v114;
        v111 = v192;
      }
      else
      {
        *(_DWORD *)v98 = v32.n128_u32[0];
        v111 = v98 + 4;
      }
      ++v100;
      v98 = v111;
    }
    while (v100 != v194);
  }
  else
  {
    __pa = 0;
    v111 = 0;
  }
LABEL_192:
  v149 = (void *)MEMORY[0x1E019D900](&__src, v188, v189, 8, 0, _Q0, v31, v32);
  BOOL v56 = v149 == 0;
  v150 = BaseAddress;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  v151 = qword_1EAA94CA8;
  if (!v149)
  {
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(src.data) = 136447234;
      *(void **)((char *)&src.data + 4) = "thresmap";
      WORD2(src.height) = 2050;
      *(vImagePixelCount *)((char *)&src.height + 6) = __src.n128_u64[0];
      HIWORD(src.width) = 2050;
      src.rowBytes = __src.n128_u64[1];
      __int16 v241 = 2050;
      uint64_t v242 = v246;
      __int16 v243 = 2050;
      uint64_t v244 = v247;
      _os_log_debug_impl(&dword_1DC2FE000, v151, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", (uint8_t *)&src, 0x34u);
    }
    uint64_t v154 = v188;
    vImagePixelCount v153 = v189;
    if (!v188)
    {
LABEL_222:
      memset(&src, 0, 24);
      sub_1DC300D68(&src.data, (v111 - __pa) >> 2);
      if (__pa != v111)
      {
        v168 = (char *)src.height;
        v169 = (__int32 *)__pa;
        do
        {
          v167.i32[0] = *v169;
          float16x4_t v167 = (float16x4_t)vcvtq_f32_f16(v167).u64[0];
          if ((unint64_t)v168 >= src.width)
          {
            float16x4_t v199 = v167;
            v171 = (char *)src.data;
            uint64_t v172 = (v168 - (char *)src.data) >> 3;
            unint64_t v173 = v172 + 1;
            if ((unint64_t)(v172 + 1) >> 61) {
              sub_1DC2FF97C();
            }
            int64_t v174 = src.width - (unint64_t)src.data;
            if ((uint64_t)(src.width - (unint64_t)src.data) >> 2 > v173) {
              unint64_t v173 = v174 >> 2;
            }
            if ((unint64_t)v174 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v175 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v175 = v173;
            }
            if (v175) {
              unint64_t v175 = (unint64_t)sub_1DC2FFD7C(v175);
            }
            else {
              uint64_t v176 = 0;
            }
            v177 = (float16x4_t *)(v175 + 8 * v172);
            v167.i32[1] = v199.i32[1];
            float16x4_t *v177 = v199;
            vImagePixelCount v170 = (vImagePixelCount)&v177[1];
            if (v168 != v171)
            {
              do
              {
                float16x4_t v178 = *(float16x4_t *)(v168 - 8);
                v168 -= 8;
                v167.i32[1] = v178.i32[1];
                v177[-1] = v178;
                --v177;
              }
              while (v168 != v171);
              v168 = (char *)src.data;
            }
            src.data = v177;
            src.vImagePixelCount height = v170;
            src.vImagePixelCount width = v175 + 8 * v176;
            if (v168) {
              operator delete(v168);
            }
          }
          else
          {
            *(float16x4_t *)v168 = v167;
            vImagePixelCount v170 = (vImagePixelCount)(v168 + 8);
          }
          src.vImagePixelCount height = v170;
          ++v169;
          v168 = (char *)v170;
        }
        while (v169 != (__int32 *)v111);
      }
      _H0 = v59 / (short float)v185;
      __asm { FCVT            S0, H0 }
      LODWORD(dest.data) = _S0;
      sub_1DC39592C(v186, (uint64_t *)&__src, (uint64_t)&src, (char *)&v203, (float *)&dest, &v202);
      if (src.data) {
        operator delete(src.data);
      }
      goto LABEL_243;
    }
    uint64_t v155 = 0;
    unint64_t v156 = v182 / v184;
    unint64_t v157 = v183 / v184;
    while (1)
    {
      v158 = (short float *)&v150[2 * v155 * v157];
      v159 = (int8x8_t *)(__src.n128_u64[0] + v247 * v155);
      if (v156 != 1) {
        goto LABEL_210;
      }
      if (((v159 | v158) & 0xF) != 0)
      {
        src.data = &v150[2 * v155 * v157];
        src.vImagePixelCount height = 1;
        src.vImagePixelCount width = v153;
        src.rowBytes = 2 * v189;
        dest.data = (void *)(__src.n128_u64[0] + v247 * v155);
        dest.vImagePixelCount height = 1;
        dest.vImagePixelCount width = v153;
        dest.rowBytes = v153;
        vImage_Error v160 = vImageConvert_Planar16FtoPlanar8(&src, &dest, 0);
        if (v160)
        {
          if (qword_1EBFFC3D0 != -1) {
            dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
          }
          v161 = qword_1EBFFC3D8;
          if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
          {
            int buf = 134349056;
            vImage_Error v249 = v160;
            _os_log_error_impl(&dword_1DC2FE000, v161, OS_LOG_TYPE_ERROR, "vImageConvert_Planar16FtoPlanar8 failed: %{public}zd", (uint8_t *)&buf, 0xCu);
          }
          v150 = BaseAddress;
          uint64_t v154 = v188;
          vImagePixelCount v153 = v189;
LABEL_210:
          if (v153)
          {
            vImagePixelCount v162 = v153;
            do
            {
              v159->i8[0] = *v158;
              v159 = (int8x8_t *)((char *)v159 + 1);
              v158 += v156;
              --v162;
            }
            while (v162);
          }
          goto LABEL_221;
        }
        uint64_t v154 = v188;
        vImagePixelCount v153 = v189;
      }
      else
      {
        unint64_t v163 = v153;
        if (v153 >= 9)
        {
          do
          {
            float16x8_t v164 = *(float16x8_t *)v158;
            v158 += 8;
            int16x8_t v152 = (int16x8_t)vcvtq_u16_f16(v164);
            *v159++ = vmovn_s16(v152);
            v163 -= 8;
          }
          while (v163 > 8);
        }
        if (v163 >= 5)
        {
          float16x4_t v165 = *(float16x4_t *)v158;
          v158 += 4;
          *(uint16x4_t *)v152.i8 = vcvt_u16_f16(v165);
          v159->i32[0] = vmovn_s16(v152).u32[0];
          v159 = (int8x8_t *)((char *)v159 + 4);
          v163 -= 4;
          do
          {
LABEL_220:
            short float v166 = *v158++;
            v159->i8[0] = v166;
            v159 = (int8x8_t *)((char *)v159 + 1);
            --v163;
          }
          while (v163);
          goto LABEL_221;
        }
        if (v163) {
          goto LABEL_220;
        }
      }
LABEL_221:
      if (++v155 == v154) {
        goto LABEL_222;
      }
    }
  }
  if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
  {
    LODWORD(src.data) = 134349056;
    *(void **)((char *)&src.data + 4) = v149;
    _os_log_error_impl(&dword_1DC2FE000, v151, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", (uint8_t *)&src, 0xCu);
  }
  src.data = (void *)-2003;
  dest.data = @"vImageBuffer_Init failed.";
  sub_1DC306334((atomic_ullong *)a13, (uint64_t *)&src, (CFTypeRef *)&dest.data);
  *(void *)(a13 + 32) = v149;
  *(unsigned char *)(a13 + 40) = 1;
LABEL_243:
  if (__pa) {
    operator delete(__pa);
  }
LABEL_35:
  if (v210) {
    char v210 = sub_1DC370168((atomic_ullong *)&v204, (uint64_t)&v205, 1, v209) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v204);
  if (v217) {
    char v217 = sub_1DC370168((atomic_ullong *)&v211, (uint64_t)&v212, 1, v216) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v211);
  if (v224) {
    char v224 = sub_1DC370168((atomic_ullong *)&v218, (uint64_t)&v219, 1, v223) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v218);
  if (v231) {
    char v231 = sub_1DC370168((atomic_ullong *)&v225, (uint64_t)&v226, 0, v230) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v225);
  if (v238) {
    char v238 = sub_1DC370168((atomic_ullong *)&v232, (uint64_t)&v233, 1, v237) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v232);
  return v56;
}

void sub_1DC394708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
  if (*(void *)(v58 + 112)) {
    operator delete(*(void **)(v58 + 112));
  }
  if (__p) {
    operator delete(__p);
  }
  sub_1DC345504((uint64_t)&a38);
  sub_1DC345504((uint64_t)&a43);
  sub_1DC345504((uint64_t)&a48);
  sub_1DC3959D4((uint64_t)&a53);
  sub_1DC345504((uint64_t)&a58);
  _Unwind_Resume(a1);
}

BOOL sub_1DC394878(uint64_t a1, uint64_t a2, atomic_ullong *a3, atomic_ullong *a4, atomic_ullong *a5, atomic_ullong *a6, atomic_ullong *a7, void *a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13)
{
  uint64_t v217 = *MEMORY[0x1E4F143B8];
  CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(a3, memory_order_acquire);
  if (explicit) {
    CFTypeRef explicit = CFRetain(explicit);
  }
  CFTypeRef v205 = explicit;
  char v206 = 0;
  *(_DWORD *)char v207 = *(_DWORD *)__src;
  *(_DWORD *)&v207[3] = *(_DWORD *)&__src[3];
  char v208 = 0;
  *(_DWORD *)uint64_t v209 = v198;
  *(_DWORD *)&v209[3] = *(_DWORD *)((char *)&v198 + 3);
  uint64_t v210 = a13;
  char v211 = sub_1DC36FEF8((atomic_ullong *)&v205, (uint64_t)&v206, 1, a13);
  CFTypeRef v23 = (CFTypeRef)atomic_load_explicit(a4, memory_order_acquire);
  uint64_t v155 = a1;
  if (v23) {
    CFTypeRef v23 = CFRetain(v23);
  }
  CFTypeRef v198 = v23;
  char v199 = 0;
  *(_DWORD *)v200 = *(_DWORD *)__src;
  *(_DWORD *)&v200[3] = *(_DWORD *)&__src[3];
  char v201 = 0;
  *(_DWORD *)char v202 = v191;
  *(_DWORD *)&v202[3] = *(_DWORD *)((char *)&v191 + 3);
  uint64_t v203 = a13;
  char v204 = sub_1DC36FEF8((atomic_ullong *)&v198, (uint64_t)&v199, 0, a13);
  CFTypeRef v24 = (CFTypeRef)atomic_load_explicit(a5, memory_order_acquire);
  if (v24) {
    CFTypeRef v24 = CFRetain(v24);
  }
  CFTypeRef v191 = v24;
  char v192 = 0;
  *(_DWORD *)unint64_t v193 = *(_DWORD *)__src;
  *(_DWORD *)&v193[3] = *(_DWORD *)&__src[3];
  char v194 = 0;
  *(_DWORD *)unint64_t v195 = v184;
  *(_DWORD *)&v195[3] = *(_DWORD *)((char *)&v184 + 3);
  uint64_t v196 = a13;
  char v197 = sub_1DC36FEF8((atomic_ullong *)&v191, (uint64_t)&v192, 1, a13);
  CFTypeRef v25 = (CFTypeRef)atomic_load_explicit(a6, memory_order_acquire);
  if (v25) {
    CFTypeRef v25 = CFRetain(v25);
  }
  CFTypeRef v184 = v25;
  char v185 = 0;
  *(_DWORD *)uint64_t v186 = *(_DWORD *)__src;
  *(_DWORD *)&v186[3] = *(_DWORD *)&__src[3];
  char v187 = 0;
  *(_DWORD *)uint64_t v188 = v177;
  *(_DWORD *)&v188[3] = *(_DWORD *)((char *)&v177 + 3);
  uint64_t v189 = a13;
  char v190 = sub_1DC36FEF8((atomic_ullong *)&v184, (uint64_t)&v185, 1, a13);
  CFTypeRef v26 = (CFTypeRef)atomic_load_explicit(a7, memory_order_acquire);
  if (v26) {
    CFTypeRef v26 = CFRetain(v26);
  }
  CFTypeRef v177 = v26;
  char v178 = 0;
  *(_DWORD *)v179 = *(_DWORD *)__src;
  *(_DWORD *)&v179[3] = *(_DWORD *)&__src[3];
  char v180 = 0;
  *(_DWORD *)int v181 = __p;
  *(_DWORD *)&v181[3] = *(_DWORD *)((char *)&__p + 3);
  uint64_t v182 = a13;
  int v27 = sub_1DC36FEF8((atomic_ullong *)&v177, (uint64_t)&v178, 1, a13);
  char v183 = v27;
  if (!v211 || !v204 || !v197 || !v190 || v27 != 1)
  {
    if (qword_1EAA94CB0 != -1) {
      dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
    }
    __int16 v53 = qword_1EAA94CA8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
    {
      int v147 = *(_DWORD *)(a13 + 56);
      *(_DWORD *)__vImage_Buffer src = 67240192;
      *(_DWORD *)&__src[4] = v147;
      _os_log_error_impl(&dword_1DC2FE000, v53, OS_LOG_TYPE_ERROR, "IOSurfaceLock failed: %{public}d", __src, 8u);
    }
    goto LABEL_34;
  }
  BaseAddress = (const float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a3, memory_order_acquire));
  v29 = (float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a4, memory_order_acquire));
  unint64_t v163 = (float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a5, memory_order_acquire));
  vImagePixelCount v162 = (float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a6, memory_order_acquire));
  v30 = (float *)IOSurfaceGetBaseAddress((IOSurfaceRef)atomic_load_explicit(a7, memory_order_acquire));
  unint64_t v31 = 0;
  char v32 = 0;
  vDSP_Length v154 = a8[8];
  uint64_t v153 = a8[7];
  unint64_t v33 = a8[2];
  unint64_t v34 = a8[12];
  unint64_t v35 = a8[13];
  unint64_t v37 = a9[7];
  unint64_t v36 = a9[8];
  uint64_t v159 = a9[6];
  unint64_t v38 = a9[2];
  unint64_t v39 = a9[11];
  unint64_t v40 = a9[12];
  unint64_t v41 = a10[2];
  float v42 = 0.0;
  unint64_t v44 = a10[11];
  unint64_t v43 = a10[12];
  unint64_t v45 = a11[2];
  unint64_t v46 = a11[11];
  unint64_t v47 = a11[12];
  uint64_t v48 = *(void *)(a12 + 88) / *(void *)(a12 + 16);
  unint64_t v49 = -1;
  do
  {
    BOOL v50 = v32 == 0;
    if (v30[v31 * v48] > v42) {
      BOOL v50 = 1;
    }
    if (v50)
    {
      float v42 = v30[v31 * v48];
      char v32 = 1;
      unint64_t v49 = v31;
    }
    ++v31;
  }
  while (v31 != 6);
  __int16 v51 = v49 | 0x100;
  if (v49 > 5) {
    __int16 v51 = 0;
  }
  __int16 v176 = v51;
  if (v49 >= 6)
  {
    if (qword_1EAA94CB0 != -1) {
      dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
    }
    BOOL v52 = qword_1EAA94CA8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__vImage_Buffer src = 0;
      _os_log_error_impl(&dword_1DC2FE000, v52, OS_LOG_TYPE_ERROR, "Invalid category yielded from attributes.", __src, 2u);
    }
    *(void *)__vImage_Buffer src = -6009;
    __p = @"Invalid category yielded from attributes.";
    sub_1DC306334((atomic_ullong *)a13, (uint64_t *)__src, (CFTypeRef *)&__p);
LABEL_34:
    BOOL v54 = 0;
    goto LABEL_35;
  }
  unint64_t v56 = v40 / v38;
  float v57 = v30[6 * v48];
  unint64_t v161 = v43 / v41;
  unint64_t v58 = *(void *)(a2 + 8);
  BOOL v175 = v30[7 * v48] > 0.0;
  unint64_t v59 = v47 / v45;
  unint64_t v158 = v47 / v45;
  unint64_t v151 = v58;
  int16x8_t v152 = BaseAddress;
  unint64_t v149 = v34;
  unint64_t v150 = v33;
  unint64_t v148 = v35;
  if ((v49 & 0xFE) == 4)
  {
    unint64_t v60 = 0;
    v61 = 0;
    uint64_t v62 = 0;
    uint64_t v63 = v36 - 1;
    float16x4_t v165 = 0;
    do
    {
      LODWORD(v13) &= 0xFFFFFF00;
      if (v37)
      {
        uint64_t v64 = 0;
        uint64_t v65 = 0;
        uint64_t v66 = 0;
        int v67 = 0;
        do
        {
          if (v36)
          {
            uint64_t v68 = 0;
            uint64_t v69 = v64 * v56;
            do
            {
              if (v29[v68 + v69] > v13 || v67 == 0)
              {
                float v13 = v29[v68 + v69];
                uint64_t v66 = v64;
                uint64_t v65 = v68;
              }
              ++v68;
              int v67 = 1;
            }
            while (v36 != v68);
          }
          ++v64;
        }
        while (v64 != v37);
      }
      else
      {
        uint64_t v66 = 0;
        uint64_t v65 = 0;
      }
      if (v66 <= 1) {
        uint64_t v71 = 1;
      }
      else {
        uint64_t v71 = v66;
      }
      unint64_t v72 = v71 - 1;
      if ((uint64_t)(v37 - 1) >= v66 + 1) {
        unint64_t v73 = v66 + 1;
      }
      else {
        unint64_t v73 = v37 - 1;
      }
      if (v65 <= 1) {
        uint64_t v74 = 1;
      }
      else {
        uint64_t v74 = v65;
      }
      if (v63 >= v65 + 1) {
        unint64_t v75 = v65 + 1;
      }
      else {
        unint64_t v75 = v63;
      }
      if (v72 <= v73)
      {
        unint64_t v76 = v74 - 1;
        do
        {
          if (v76 <= v75)
          {
            unint64_t v77 = v76;
            do
            {
              v29[v77 + v72 * v56] = -INFINITY;
              ++v77;
            }
            while (v77 <= v75);
          }
          ++v72;
        }
        while (v72 <= v73);
      }
      v78.f32[0] = (float)(v163[v65 + v66 * v161] + (float)(unint64_t)v65) / (float)v36;
      v78.f32[1] = (float)(v162[v65 + v66 * v59] + (float)(unint64_t)v66) / (float)v37;
      if ((unint64_t)v61 >= v60)
      {
        float32x2_t v160 = v78;
        uint64_t v80 = v61 - v165;
        unint64_t v81 = v80 + 1;
        if ((unint64_t)(v80 + 1) >> 61) {
          sub_1DC2FF97C();
        }
        if ((uint64_t)(v60 - (void)v165) >> 2 > v81) {
          unint64_t v81 = (uint64_t)(v60 - (void)v165) >> 2;
        }
        if (v60 - (unint64_t)v165 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v82 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v82 = v81;
        }
        if (v82) {
          unint64_t v82 = (unint64_t)sub_1DC2FFD7C(v82);
        }
        else {
          uint64_t v83 = 0;
        }
        unint64_t v84 = (float32x2_t *)(v82 + 8 * v80);
        *unint64_t v84 = v160;
        uint64_t v85 = v84 + 1;
        if (v61 != v165)
        {
          do
          {
            float32x2_t v86 = v61[-1];
            --v61;
            v84[-1] = v86;
            --v84;
          }
          while (v61 != v165);
          v61 = v165;
        }
        unint64_t v60 = v82 + 8 * v83;
        unint64_t v79 = v84;
        if (v61)
        {
          short float v166 = v84;
          operator delete(v61);
          unint64_t v79 = v166;
        }
        v61 = v85;
        unint64_t v59 = v158;
        uint64_t v63 = v36 - 1;
      }
      else
      {
        *v61++ = v78;
        unint64_t v79 = v165;
      }
      float16x4_t v165 = v79;
      ++v62;
    }
    while (v62 != 4);
    float16x8_t v164 = (float32x2_t *)v60;
    unint64_t v87 = v79;
    float32x2_t v88 = (float32x2_t)0x3F0000003F000000;
    if (v79 != v61)
    {
      v89 = v79;
      do
      {
        float32x2_t v90 = *v89++;
        float32x2_t v88 = vadd_f32(v88, v90);
      }
      while (v89 != v61);
    }
    __p = 0;
    vImagePixelCount v170 = 0;
    unint64_t v171 = 0;
    unint64_t v91 = (char *)v61 - (char *)v79;
    sub_1DC37E438(&__p, v61 - v79);
    if (v87 == v61)
    {
      unint64_t v102 = v170;
    }
    else
    {
      __asm { FMOV            V0.2S, #0.25 }
      float32x2_t v96 = vmul_f32(v88, _D0);
      unsigned __int32 v97 = v170;
      unint64_t v98 = v171;
      unint64_t v99 = v87;
      do
      {
        float32x2_t v100 = vsub_f32(*v99, v96);
        float v101 = atan2f(v100.f32[1], v100.f32[0]) + 2.3562;
        if ((unint64_t)v97 >= v98)
        {
          unint64_t v103 = (float *)__p;
          uint64_t v104 = ((char *)v97 - (unsigned char *)__p) >> 2;
          unint64_t v105 = v104 + 1;
          if ((unint64_t)(v104 + 1) >> 62) {
            sub_1DC2FF97C();
          }
          if ((uint64_t)(v98 - (void)__p) >> 1 > v105) {
            unint64_t v105 = (uint64_t)(v98 - (void)__p) >> 1;
          }
          if (v98 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v105 = 0x3FFFFFFFFFFFFFFFLL;
          }
          if (v105)
          {
            unint64_t v105 = (unint64_t)sub_1DC314E5C(v105);
            unint64_t v103 = (float *)__p;
            unsigned __int32 v97 = v170;
          }
          else
          {
            uint64_t v106 = 0;
          }
          unint64_t v107 = (float *)(v105 + 4 * v104);
          *unint64_t v107 = v101;
          unint64_t v102 = v107 + 1;
          while (v97 != v103)
          {
            int v108 = *((_DWORD *)v97-- - 1);
            *((_DWORD *)v107-- - 1) = v108;
          }
          unint64_t v98 = v105 + 4 * v106;
          __p = v107;
          unint64_t v171 = v98;
          if (v103) {
            operator delete(v103);
          }
        }
        else
        {
          *unsigned __int32 v97 = v101;
          unint64_t v102 = v97 + 1;
        }
        vImagePixelCount v170 = v102;
        ++v99;
        unsigned __int32 v97 = v102;
      }
      while (v99 != v61);
    }
    sub_1DC3958B4(&v173, ((char *)v102 - (unsigned char *)__p) >> 2);
    v130 = (uint64_t *)v173;
    v131 = v174;
    if (v173 != v174)
    {
      uint64_t v132 = 0;
      unint64_t v133 = (uint64_t *)v173;
      do
        *v133++ = v132++;
      while (v133 != v131);
    }
    unint64_t v134 = 126 - 2 * __clz(v131 - v130);
    *(void *)__vImage_Buffer src = &__p;
    if (v131 == v130) {
      uint64_t v135 = 0;
    }
    else {
      uint64_t v135 = v134;
    }
    sub_1DC395A30((uint64_t)v130, v131, (uint64_t **)__src, v135, 1);
    *(float32x2_t *)__vImage_Buffer src = v87[*(void *)v173];
    uint64_t v136 = *((void *)v173 + 2);
    *(float32x2_t *)&__src[8] = v87[*((void *)v173 + 3)];
    *(float32x2_t *)&__src[16] = v87[v136];
    *(float32x2_t *)&__src[24] = v87[*((void *)v173 + 1)];
    if ((unint64_t)((char *)v164 - (char *)v87) >= 0x20)
    {
      if (v91 > 0x1F)
      {
        long long v140 = *(_OWORD *)&__src[16];
        *(_OWORD *)v87->f32 = *(_OWORD *)__src;
        *(_OWORD *)v87[2].f32 = v140;
        size_t v139 = 32;
        v61 = v87;
      }
      else
      {
        if (v87 != v61) {
          memcpy(v87, __src, (char *)v61 - (char *)v87);
        }
        size_t v139 = 32 - v91;
        memmove(v61, &__src[8 * (v61 - v87)], v139);
      }
      *(void *)&long long v137 = v165;
      v109 = v164;
    }
    else
    {
      operator delete(v87);
      v61 = (float32x2_t *)sub_1DC2FFD7C(4uLL);
      *(void *)&long long v137 = v61;
      v109 = &v61[v138];
      *(_OWORD *)v61->f32 = *(_OWORD *)__src;
      *(_OWORD *)v61[2].f32 = *(_OWORD *)&__src[16];
      size_t v139 = 32;
    }
    uint64_t v168 = v137;
    if (v173)
    {
      int64_t v174 = (uint64_t *)v173;
      operator delete(v173);
      *(void *)&long long v137 = v168;
    }
    unint64_t v141 = (char *)v61 + v139;
    if (__p)
    {
      vImagePixelCount v170 = (float *)__p;
      operator delete(__p);
      *(void *)&long long v137 = v168;
    }
    *((void *)&v137 + 1) = v141;
    long long v167 = v137;
  }
  else if (v159)
  {
    v109 = 0;
    v110 = 0;
    uint64_t v111 = 0;
    unint64_t v156 = v39 / v38;
    unint64_t v112 = v44 / v41;
    *(void *)&long long v167 = 0;
    unint64_t v113 = v46 / v45;
    do
    {
      LODWORD(v13) &= 0xFFFFFF00;
      if (v37)
      {
        unint64_t v114 = 0;
        unint64_t v115 = 0;
        unint64_t v116 = 0;
        int v117 = 0;
        do
        {
          if (v36)
          {
            unint64_t v118 = 0;
            unint64_t v119 = v111 * v156 + v114 * v56;
            do
            {
              if (v29[v119 + v118] > v13 || v117 == 0)
              {
                float v13 = v29[v119 + v118];
                unint64_t v116 = v114;
                unint64_t v115 = v118;
              }
              ++v118;
              int v117 = 1;
            }
            while (v36 != v118);
          }
          ++v114;
        }
        while (v114 != v37);
      }
      else
      {
        unint64_t v116 = 0;
        unint64_t v115 = 0;
      }
      v121.f32[0] = (float)(v163[v111 * v112 + v116 * v161 + v115] + (float)v115) / (float)v36;
      v121.f32[1] = (float)(v162[v111 * v113 + v116 * v59 + v115] + (float)v116) / (float)v37;
      if (v110 >= v109)
      {
        float32x2_t v157 = v121;
        uint64_t v123 = (uint64_t)((uint64_t)v110 - v167) >> 3;
        unint64_t v124 = v123 + 1;
        if ((unint64_t)(v123 + 1) >> 61) {
          sub_1DC2FF97C();
        }
        if ((uint64_t)((uint64_t)v109 - v167) >> 2 > v124) {
          unint64_t v124 = (uint64_t)((uint64_t)v109 - v167) >> 2;
        }
        if ((unint64_t)((unint64_t)v109 - v167) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v125 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v125 = v124;
        }
        if (v125) {
          unint64_t v125 = (unint64_t)sub_1DC2FFD7C(v125);
        }
        else {
          uint64_t v126 = 0;
        }
        v127 = (float32x2_t *)(v125 + 8 * v123);
        float32x2_t *v127 = v157;
        float16x4_t v122 = v127 + 1;
        if (v110 != (float32x2_t *)v167)
        {
          do
          {
            float32x2_t v128 = v110[-1];
            --v110;
            v127[-1] = v128;
            --v127;
          }
          while (v110 != (float32x2_t *)v167);
          v110 = (float32x2_t *)v167;
        }
        v109 = (float32x2_t *)(v125 + 8 * v126);
        *(void *)&long long v167 = v127;
        if (v110) {
          operator delete(v110);
        }
        unint64_t v59 = v158;
      }
      else
      {
        float32x2_t *v110 = v121;
        float16x4_t v122 = v110 + 1;
      }
      *(void *)&long long v129 = v167;
      *((void *)&v129 + 1) = v122;
      long long v167 = v129;
      ++v111;
      v110 = v122;
    }
    while (v111 != v159);
  }
  else
  {
    v109 = 0;
    long long v167 = 0u;
  }
  uint64_t v142 = MEMORY[0x1E019D900](&__p, v153, v154, 8, 0);
  BOOL v54 = v142 == 0;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  uint64_t v143 = qword_1EAA94CA8;
  if (!v142)
  {
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__vImage_Buffer src = 136447234;
      *(void *)&__src[4] = "thresmap";
      *(_WORD *)&__src[12] = 2050;
      *(void *)&__src[14] = __p;
      *(_WORD *)&__src[22] = 2050;
      *(void *)&__src[24] = v170;
      __int16 v213 = 2050;
      unint64_t v214 = v171;
      __int16 v215 = 2050;
      uint64_t v216 = v172;
      _os_log_debug_impl(&dword_1DC2FE000, v143, OS_LOG_TYPE_DEBUG, "Allocated %{public}s image buffer: data=%{public}p, height=%{public}zu, width=%{public}zu, rowBytes=%{public}zu", __src, 0x34u);
      if (!v153) {
        goto LABEL_185;
      }
    }
    else if (!v153)
    {
      goto LABEL_185;
    }
    for (uint64_t i = 0; i != v153; ++i)
      vDSP_vfixu8(&v152[i * (v149 / v150)], v148 / v150, (unsigned __int8 *)__p + v172 * i, 1, v154);
LABEL_185:
    *(_OWORD *)__vImage_Buffer src = v167;
    *(void *)&__src[16] = v109;
    *(float *)&unint64_t v173 = v57 / (float)v151;
    sub_1DC39592C(v155, (uint64_t *)&__p, (uint64_t)__src, (char *)&v176, (float *)&v173, (char *)&v175);
    unint64_t v145 = *(void **)__src;
    if (!*(void *)__src) {
      goto LABEL_35;
    }
    goto LABEL_186;
  }
  if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__vImage_Buffer src = 134349056;
    *(void *)&__src[4] = v142;
    _os_log_error_impl(&dword_1DC2FE000, v143, OS_LOG_TYPE_ERROR, "vImageBuffer_Init failed: %{public}zd", __src, 0xCu);
  }
  *(void *)__vImage_Buffer src = -2003;
  unint64_t v173 = @"vImageBuffer_Init failed.";
  uint64_t v144 = sub_1DC306334((atomic_ullong *)a13, (uint64_t *)__src, (CFTypeRef *)&v173);
  *(void *)(v144 + 32) = v142;
  *(unsigned char *)(v144 + 40) = 1;
  unint64_t v145 = (void *)v167;
  if ((void)v167) {
LABEL_186:
  }
    operator delete(v145);
LABEL_35:
  if (v183) {
    char v183 = sub_1DC370168((atomic_ullong *)&v177, (uint64_t)&v178, 1, v182) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v177);
  if (v190) {
    char v190 = sub_1DC370168((atomic_ullong *)&v184, (uint64_t)&v185, 1, v189) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v184);
  if (v197) {
    char v197 = sub_1DC370168((atomic_ullong *)&v191, (uint64_t)&v192, 1, v196) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v191);
  if (v204) {
    char v204 = sub_1DC370168((atomic_ullong *)&v198, (uint64_t)&v199, 0, v203) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v198);
  if (v211) {
    char v211 = sub_1DC370168((atomic_ullong *)&v205, (uint64_t)&v206, 1, v210) ^ 1;
  }
  sub_1DC315BA8((atomic_ullong *)&v205);
  return v54;
}

void sub_1DC395764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,long long a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
  if (__p) {
    operator delete(__p);
  }
  if (a35) {
    operator delete(a35);
  }
  sub_1DC345504((uint64_t)&a43);
  sub_1DC345504((uint64_t)&a48);
  sub_1DC345504((uint64_t)&a53);
  sub_1DC3959D4((uint64_t)&a58);
  sub_1DC345504(v58 - 232);
  _Unwind_Resume(a1);
}

void *sub_1DC3958B4(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DC2FFD3C(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1DC395910(_Unwind_Exception *exception_object)
{
  v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float sub_1DC39592C(uint64_t a1, uint64_t *a2, uint64_t a3, char *a4, float *a5, char *a6)
{
  if (*(unsigned char *)(a1 + 72))
  {
    a1 = sub_1DC3935A8(a1);
    *(unsigned char *)(a1 + 72) = 0;
  }
  char v11 = *a4;
  float result = *a5;
  char v13 = *a6;
  uint64_t v14 = *a2;
  *a2 = 0;
  *(void *)a1 = v14;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 1);
  uint64_t v15 = a2[3];
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 24) = v15;
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)a3;
  *(void *)(a1 + 48) = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(unsigned char *)(a1 + 56) = v11;
  *(float *)(a1 + 60) = result;
  *(unsigned char *)(a1 + 64) = v13;
  *(unsigned char *)(a1 + 72) = 1;
  return result;
}

atomic_ullong *sub_1DC3959D4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 32)) {
    *(unsigned char *)(a1 + 32) = sub_1DC370168((atomic_ullong *)a1, a1 + 8, 0, *(void *)(a1 + 24)) ^ 1;
  }
  return sub_1DC315BA8((atomic_ullong *)a1);
}

uint64_t sub_1DC395A30(uint64_t result, uint64_t *a2, uint64_t **a3, uint64_t a4, char a5)
{
  char v11 = (uint64_t *)result;
  while (2)
  {
    v12 = a2 - 1;
    char v13 = v11;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          char v11 = v13;
          uint64_t v14 = (char *)a2 - (char *)v13;
          unint64_t v15 = a2 - v13;
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v45 = *v13;
                if (*(float *)(**a3 + 4 * *v12) < *(float *)(**a3 + 4 * *v13))
                {
                  *char v13 = *v12;
                  uint64_t *v12 = v45;
                }
                break;
              case 3uLL:
                uint64_t v46 = **a3;
                float result = (uint64_t)sub_1DC3961F0(v13, v13 + 1, a2 - 1, v46);
                break;
              case 4uLL:
                float result = (uint64_t)sub_1DC396278(v13, v13 + 1, v13 + 2, a2 - 1, a3);
                break;
              case 5uLL:
                unint64_t v47 = v13 + 1;
                uint64_t v48 = v13 + 2;
                unint64_t v49 = v13 + 3;
                float result = (uint64_t)sub_1DC396278(v13, v13 + 1, v13 + 2, v13 + 3, a3);
                uint64_t v50 = v13[3];
                uint64_t v51 = **a3;
                if (*(float *)(v51 + 4 * *v12) < *(float *)(v51 + 4 * v50))
                {
                  *unint64_t v49 = *v12;
                  uint64_t *v12 = v50;
                  uint64_t v52 = *v49;
                  uint64_t v53 = *v48;
                  float v54 = *(float *)(v51 + 4 * *v49);
                  if (v54 < *(float *)(v51 + 4 * *v48))
                  {
                    *uint64_t v48 = v52;
                    *unint64_t v49 = v53;
                    uint64_t v55 = *v47;
                    if (v54 < *(float *)(v51 + 4 * *v47))
                    {
                      v13[1] = v52;
                      v13[2] = v55;
                      uint64_t v56 = *v13;
                      if (v54 < *(float *)(v51 + 4 * *v13))
                      {
                        *char v13 = v52;
                        v13[1] = v56;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v14 <= 191)
          {
            if (a5)
            {
              if (v13 != a2)
              {
                float v57 = v13 + 1;
                if (v13 + 1 != a2)
                {
                  uint64_t v58 = **a3;
                  uint64_t v59 = 8;
                  unint64_t v60 = v13;
                  do
                  {
                    uint64_t v62 = *v60;
                    uint64_t v61 = v60[1];
                    unint64_t v60 = v57;
                    float v63 = *(float *)(v58 + 4 * v61);
                    if (v63 < *(float *)(v58 + 4 * v62))
                    {
                      uint64_t v64 = v59;
                      do
                      {
                        *(uint64_t *)((char *)v13 + v64) = v62;
                        uint64_t v65 = v64 - 8;
                        if (v64 == 8)
                        {
                          uint64_t v66 = v13;
                          goto LABEL_78;
                        }
                        uint64_t v62 = *(uint64_t *)((char *)v13 + v64 - 16);
                        v64 -= 8;
                      }
                      while (v63 < *(float *)(v58 + 4 * v62));
                      uint64_t v66 = (uint64_t *)((char *)v13 + v65);
LABEL_78:
                      uint64_t *v66 = v61;
                    }
                    float v57 = v60 + 1;
                    v59 += 8;
                  }
                  while (v60 + 1 != a2);
                }
              }
            }
            else if (v13 != a2)
            {
              unint64_t v98 = v13 + 1;
              if (v13 + 1 != a2)
              {
                uint64_t v99 = **a3;
                do
                {
                  uint64_t v101 = *v11;
                  uint64_t v100 = v11[1];
                  char v11 = v98;
                  float v102 = *(float *)(v99 + 4 * v100);
                  if (v102 < *(float *)(v99 + 4 * v101))
                  {
                    do
                    {
                      uint64_t *v98 = v101;
                      uint64_t v101 = *(v98 - 2);
                      --v98;
                    }
                    while (v102 < *(float *)(v99 + 4 * v101));
                    uint64_t *v98 = v100;
                  }
                  unint64_t v98 = v11 + 1;
                }
                while (v11 + 1 != a2);
              }
            }
            return result;
          }
          if (!a4)
          {
            if (v13 != a2)
            {
              int64_t v67 = (v15 - 2) >> 1;
              uint64_t v68 = *a3;
              int64_t v69 = v67;
              do
              {
                int64_t v70 = v69;
                if (v67 >= v69)
                {
                  uint64_t v71 = (2 * v69) | 1;
                  unint64_t v72 = &v13[v71];
                  uint64_t v73 = 2 * v69 + 2;
                  uint64_t v74 = *v68;
                  if (v73 < (uint64_t)v15 && *(float *)(v74 + 4 * *v72) < *(float *)(v74 + 4 * v72[1]))
                  {
                    ++v72;
                    uint64_t v71 = 2 * v70 + 2;
                  }
                  unint64_t v75 = &v13[v70];
                  float result = *v72;
                  uint64_t v76 = *v75;
                  float v77 = *(float *)(v74 + 4 * *v75);
                  if (*(float *)(v74 + 4 * *v72) >= v77)
                  {
                    do
                    {
                      float32x2_t v78 = v72;
                      *unint64_t v75 = result;
                      if (v67 < v71) {
                        break;
                      }
                      uint64_t v79 = 2 * v71;
                      uint64_t v71 = (2 * v71) | 1;
                      unint64_t v72 = &v13[v71];
                      uint64_t v80 = v79 + 2;
                      if (v80 < (uint64_t)v15 && *(float *)(v74 + 4 * *v72) < *(float *)(v74 + 4 * v72[1]))
                      {
                        ++v72;
                        uint64_t v71 = v80;
                      }
                      float result = *v72;
                      unint64_t v75 = v78;
                    }
                    while (*(float *)(v74 + 4 * *v72) >= v77);
                    *float32x2_t v78 = v76;
                  }
                }
                int64_t v69 = v70 - 1;
              }
              while (v70);
              uint64_t v81 = (unint64_t)v14 >> 3;
              do
              {
                uint64_t v82 = 0;
                uint64_t v83 = *v13;
                unint64_t v84 = *a3;
                uint64_t v85 = v13;
                do
                {
                  float32x2_t v86 = v85;
                  v85 += v82 + 1;
                  uint64_t v87 = 2 * v82;
                  uint64_t v82 = (2 * v82) | 1;
                  uint64_t v88 = v87 + 2;
                  if (v88 < v81)
                  {
                    float result = v85[1];
                    if (*(float *)(*v84 + 4 * *v85) < *(float *)(*v84 + 4 * result))
                    {
                      ++v85;
                      uint64_t v82 = v88;
                    }
                  }
                  *float32x2_t v86 = *v85;
                }
                while (v82 <= (uint64_t)((unint64_t)(v81 - 2) >> 1));
                if (v85 == --a2)
                {
                  *uint64_t v85 = v83;
                }
                else
                {
                  *uint64_t v85 = *a2;
                  *a2 = v83;
                  uint64_t v89 = (char *)v85 - (char *)v13 + 8;
                  if (v89 >= 9)
                  {
                    unint64_t v90 = (((unint64_t)v89 >> 3) - 2) >> 1;
                    unint64_t v91 = &v13[v90];
                    uint64_t v92 = *v91;
                    uint64_t v93 = *v85;
                    uint64_t v94 = *v84;
                    float v95 = *(float *)(v94 + 4 * *v85);
                    if (*(float *)(v94 + 4 * *v91) < v95)
                    {
                      do
                      {
                        float32x2_t v96 = v91;
                        *uint64_t v85 = v92;
                        if (!v90) {
                          break;
                        }
                        unint64_t v90 = (v90 - 1) >> 1;
                        unint64_t v91 = &v13[v90];
                        uint64_t v92 = *v91;
                        uint64_t v85 = v96;
                      }
                      while (*(float *)(v94 + 4 * *v91) < v95);
                      *float32x2_t v96 = v93;
                    }
                  }
                }
              }
              while (v81-- > 2);
            }
            return result;
          }
          unint64_t v16 = v15 >> 1;
          v17 = &v13[v15 >> 1];
          uint64_t v18 = **a3;
          if ((unint64_t)v14 >= 0x401)
          {
            sub_1DC3961F0(v11, &v11[v15 >> 1], a2 - 1, v18);
            sub_1DC3961F0(v11 + 1, v17 - 1, a2 - 2, **a3);
            sub_1DC3961F0(v11 + 2, &v11[v16 + 1], a2 - 3, **a3);
            float result = (uint64_t)sub_1DC3961F0(v17 - 1, v17, &v11[v16 + 1], **a3);
            uint64_t v19 = *v11;
            *char v11 = *v17;
            uint64_t *v17 = v19;
          }
          else
          {
            float result = (uint64_t)sub_1DC3961F0(&v11[v15 >> 1], v11, a2 - 1, v18);
          }
          --a4;
          uint64_t v20 = *v11;
          uint64_t v21 = **a3;
          if (a5) {
            break;
          }
          float v22 = *(float *)(v21 + 4 * v20);
          if (*(float *)(v21 + 4 * *(v11 - 1)) < v22) {
            goto LABEL_13;
          }
          if (v22 >= *(float *)(v21 + 4 * *v12))
          {
            unint64_t v37 = v11 + 1;
            do
            {
              char v13 = v37;
              if (v37 >= a2) {
                break;
              }
              ++v37;
            }
            while (v22 >= *(float *)(v21 + 4 * *v13));
          }
          else
          {
            char v13 = v11;
            do
            {
              uint64_t v36 = v13[1];
              ++v13;
            }
            while (v22 >= *(float *)(v21 + 4 * v36));
          }
          unint64_t v38 = a2;
          if (v13 < a2)
          {
            unint64_t v38 = a2;
            do
              uint64_t v39 = *--v38;
            while (v22 < *(float *)(v21 + 4 * v39));
          }
          if (v13 < v38)
          {
            uint64_t v40 = *v13;
            uint64_t v41 = *v38;
            do
            {
              *char v13 = v41;
              *unint64_t v38 = v40;
              do
              {
                uint64_t v42 = v13[1];
                ++v13;
                uint64_t v40 = v42;
              }
              while (v22 >= *(float *)(v21 + 4 * v42));
              do
              {
                uint64_t v43 = *--v38;
                uint64_t v41 = v43;
              }
              while (v22 < *(float *)(v21 + 4 * v43));
            }
            while (v13 < v38);
          }
          unint64_t v44 = v13 - 1;
          BOOL v5 = v13 - 1 >= v11;
          BOOL v6 = v13 - 1 == v11;
          if (v13 - 1 != v11) {
            *char v11 = *v44;
          }
          a5 = 0;
          *unint64_t v44 = v20;
        }
        float v22 = *(float *)(v21 + 4 * v20);
LABEL_13:
        CFTypeRef v23 = v11;
        do
        {
          CFTypeRef v24 = v23;
          uint64_t v26 = v23[1];
          ++v23;
          uint64_t v25 = v26;
        }
        while (*(float *)(v21 + 4 * v26) < v22);
        int v27 = a2;
        if (v24 == v11)
        {
          int v27 = a2;
          do
          {
            if (v23 >= v27) {
              break;
            }
            uint64_t v29 = *--v27;
          }
          while (*(float *)(v21 + 4 * v29) >= v22);
        }
        else
        {
          do
            uint64_t v28 = *--v27;
          while (*(float *)(v21 + 4 * v28) >= v22);
        }
        if (v23 < v27)
        {
          uint64_t v30 = *v27;
          unint64_t v31 = v23;
          char v32 = v27;
          do
          {
            *unint64_t v31 = v30;
            *char v32 = v25;
            do
            {
              CFTypeRef v24 = v31;
              uint64_t v33 = v31[1];
              ++v31;
              uint64_t v25 = v33;
            }
            while (*(float *)(v21 + 4 * v33) < v22);
            do
            {
              uint64_t v34 = *--v32;
              uint64_t v30 = v34;
            }
            while (*(float *)(v21 + 4 * v34) >= v22);
          }
          while (v31 < v32);
        }
        if (v24 != v11) {
          *char v11 = *v24;
        }
        *CFTypeRef v24 = v20;
        if (v23 >= v27) {
          break;
        }
LABEL_32:
        float result = sub_1DC395A30(v11, v24, a3, a4, a5 & 1);
        a5 = 0;
        char v13 = v24 + 1;
      }
      BOOL v35 = sub_1DC39632C(v11, v24, a3);
      char v13 = v24 + 1;
      float result = sub_1DC39632C(v24 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v35) {
        goto LABEL_32;
      }
    }
    a2 = v24;
    if (!v35) {
      continue;
    }
    return result;
  }
}

uint64_t *sub_1DC3961F0(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *result;
  float v6 = *(float *)(a4 + 4 * *a2);
  float v7 = *(float *)(a4 + 4 * *result);
  uint64_t v8 = *a3;
  float v9 = *(float *)(a4 + 4 * *a3);
  if (v6 >= v7)
  {
    if (v9 < v6)
    {
      *a2 = v8;
      *a3 = v4;
      uint64_t v10 = *result;
      if (*(float *)(a4 + 4 * *a2) < *(float *)(a4 + 4 * *result))
      {
        *float result = *a2;
        *a2 = v10;
      }
    }
  }
  else
  {
    if (v9 >= v6)
    {
      *float result = v4;
      *a2 = v5;
      if (*(float *)(a4 + 4 * *a3) >= v7) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *float result = v8;
    }
    *a3 = v5;
  }
  return result;
}

uint64_t *sub_1DC396278(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t **a5)
{
  float result = sub_1DC3961F0(a1, a2, a3, **a5);
  uint64_t v11 = *a3;
  uint64_t v12 = **a5;
  if (*(float *)(v12 + 4 * *a4) < *(float *)(v12 + 4 * *a3))
  {
    *a3 = *a4;
    *a4 = v11;
    uint64_t v13 = *a2;
    if (*(float *)(v12 + 4 * *a3) < *(float *)(v12 + 4 * *a2))
    {
      *a2 = *a3;
      *a3 = v13;
      uint64_t v14 = *a1;
      if (*(float *)(v12 + 4 * *a2) < *(float *)(v12 + 4 * *a1))
      {
        *a1 = *a2;
        *a2 = v14;
      }
    }
  }
  return result;
}

BOOL sub_1DC39632C(uint64_t *a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(float *)(**a3 + 4 * v8) < *(float *)(**a3 + 4 * *a1))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      sub_1DC3961F0(a1, a1 + 1, a2 - 1, **a3);
      return 1;
    case 4:
      sub_1DC396278(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      uint64_t v21 = a1 + 1;
      float v22 = a1 + 2;
      CFTypeRef v23 = a1 + 3;
      sub_1DC396278(a1, a1 + 1, a1 + 2, a1 + 3, a3);
      uint64_t v24 = *(a2 - 1);
      uint64_t v25 = a1[3];
      uint64_t v26 = **a3;
      if (*(float *)(v26 + 4 * v24) < *(float *)(v26 + 4 * v25))
      {
        *CFTypeRef v23 = v24;
        *(a2 - 1) = v25;
        uint64_t v27 = *v23;
        uint64_t v28 = *v22;
        float v29 = *(float *)(v26 + 4 * *v23);
        if (v29 < *(float *)(v26 + 4 * *v22))
        {
          *float v22 = v27;
          *CFTypeRef v23 = v28;
          uint64_t v30 = *v21;
          if (v29 < *(float *)(v26 + 4 * *v21))
          {
            a1[1] = v27;
            a1[2] = v30;
            uint64_t v31 = *a1;
            if (v29 < *(float *)(v26 + 4 * *a1))
            {
              *a1 = v27;
              a1[1] = v31;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      sub_1DC3961F0(a1, a1 + 1, a1 + 2, **a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = **a3;
      uint64_t v14 = 24;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v11;
    uint64_t v16 = *v10;
    float v17 = *(float *)(v13 + 4 * *v11);
    if (v17 < *(float *)(v13 + 4 * *v10))
    {
      uint64_t v18 = v14;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v18) = v16;
        uint64_t v19 = v18 - 8;
        if (v18 == 8) {
          break;
        }
        uint64_t v16 = *(uint64_t *)((char *)a1 + v18 - 16);
        v18 -= 8;
        if (v17 >= *(float *)(v13 + 4 * v16))
        {
          uint64_t v20 = (uint64_t *)((char *)a1 + v19);
          goto LABEL_13;
        }
      }
      uint64_t v20 = a1;
LABEL_13:
      *uint64_t v20 = v15;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v14 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

uint64_t sub_1DC39656C(uint64_t result, uint64_t *a2, uint64_t **a3, uint64_t a4, char a5)
{
  uint64_t v11 = (uint64_t *)result;
  while (2)
  {
    int v12 = a2 - 1;
    uint64_t v13 = v11;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v11 = v13;
          uint64_t v14 = (char *)a2 - (char *)v13;
          unint64_t v15 = a2 - v13;
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v45 = *v13;
                if (*(float *)(**a3 + 4 * *v12) < *(float *)(**a3 + 4 * *v13))
                {
                  *uint64_t v13 = *v12;
                  uint64_t *v12 = v45;
                }
                break;
              case 3uLL:
                uint64_t v46 = **a3;
                BOOL result = (uint64_t)sub_1DC3961F0(v13, v13 + 1, a2 - 1, v46);
                break;
              case 4uLL:
                BOOL result = (uint64_t)sub_1DC396278(v13, v13 + 1, v13 + 2, a2 - 1, a3);
                break;
              case 5uLL:
                unint64_t v47 = v13 + 1;
                uint64_t v48 = v13 + 2;
                unint64_t v49 = v13 + 3;
                BOOL result = (uint64_t)sub_1DC396278(v13, v13 + 1, v13 + 2, v13 + 3, a3);
                uint64_t v50 = v13[3];
                uint64_t v51 = **a3;
                if (*(float *)(v51 + 4 * *v12) < *(float *)(v51 + 4 * v50))
                {
                  *unint64_t v49 = *v12;
                  uint64_t *v12 = v50;
                  uint64_t v52 = *v49;
                  uint64_t v53 = *v48;
                  float v54 = *(float *)(v51 + 4 * *v49);
                  if (v54 < *(float *)(v51 + 4 * *v48))
                  {
                    *uint64_t v48 = v52;
                    *unint64_t v49 = v53;
                    uint64_t v55 = *v47;
                    if (v54 < *(float *)(v51 + 4 * *v47))
                    {
                      v13[1] = v52;
                      v13[2] = v55;
                      uint64_t v56 = *v13;
                      if (v54 < *(float *)(v51 + 4 * *v13))
                      {
                        *uint64_t v13 = v52;
                        v13[1] = v56;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v14 <= 191)
          {
            if (a5)
            {
              if (v13 != a2)
              {
                float v57 = v13 + 1;
                if (v13 + 1 != a2)
                {
                  uint64_t v58 = **a3;
                  uint64_t v59 = 8;
                  unint64_t v60 = v13;
                  do
                  {
                    uint64_t v62 = *v60;
                    uint64_t v61 = v60[1];
                    unint64_t v60 = v57;
                    float v63 = *(float *)(v58 + 4 * v61);
                    if (v63 < *(float *)(v58 + 4 * v62))
                    {
                      uint64_t v64 = v59;
                      do
                      {
                        *(uint64_t *)((char *)v13 + v64) = v62;
                        uint64_t v65 = v64 - 8;
                        if (v64 == 8)
                        {
                          uint64_t v66 = v13;
                          goto LABEL_78;
                        }
                        uint64_t v62 = *(uint64_t *)((char *)v13 + v64 - 16);
                        v64 -= 8;
                      }
                      while (v63 < *(float *)(v58 + 4 * v62));
                      uint64_t v66 = (uint64_t *)((char *)v13 + v65);
LABEL_78:
                      uint64_t *v66 = v61;
                    }
                    float v57 = v60 + 1;
                    v59 += 8;
                  }
                  while (v60 + 1 != a2);
                }
              }
            }
            else if (v13 != a2)
            {
              unint64_t v98 = v13 + 1;
              if (v13 + 1 != a2)
              {
                uint64_t v99 = **a3;
                do
                {
                  uint64_t v101 = *v11;
                  uint64_t v100 = v11[1];
                  uint64_t v11 = v98;
                  float v102 = *(float *)(v99 + 4 * v100);
                  if (v102 < *(float *)(v99 + 4 * v101))
                  {
                    do
                    {
                      uint64_t *v98 = v101;
                      uint64_t v101 = *(v98 - 2);
                      --v98;
                    }
                    while (v102 < *(float *)(v99 + 4 * v101));
                    uint64_t *v98 = v100;
                  }
                  unint64_t v98 = v11 + 1;
                }
                while (v11 + 1 != a2);
              }
            }
            return result;
          }
          if (!a4)
          {
            if (v13 != a2)
            {
              int64_t v67 = (v15 - 2) >> 1;
              uint64_t v68 = *a3;
              int64_t v69 = v67;
              do
              {
                int64_t v70 = v69;
                if (v67 >= v69)
                {
                  uint64_t v71 = (2 * v69) | 1;
                  unint64_t v72 = &v13[v71];
                  uint64_t v73 = 2 * v69 + 2;
                  uint64_t v74 = *v68;
                  if (v73 < (uint64_t)v15 && *(float *)(v74 + 4 * *v72) < *(float *)(v74 + 4 * v72[1]))
                  {
                    ++v72;
                    uint64_t v71 = 2 * v70 + 2;
                  }
                  unint64_t v75 = &v13[v70];
                  BOOL result = *v72;
                  uint64_t v76 = *v75;
                  float v77 = *(float *)(v74 + 4 * *v75);
                  if (*(float *)(v74 + 4 * *v72) >= v77)
                  {
                    do
                    {
                      float32x2_t v78 = v72;
                      *unint64_t v75 = result;
                      if (v67 < v71) {
                        break;
                      }
                      uint64_t v79 = 2 * v71;
                      uint64_t v71 = (2 * v71) | 1;
                      unint64_t v72 = &v13[v71];
                      uint64_t v80 = v79 + 2;
                      if (v80 < (uint64_t)v15 && *(float *)(v74 + 4 * *v72) < *(float *)(v74 + 4 * v72[1]))
                      {
                        ++v72;
                        uint64_t v71 = v80;
                      }
                      BOOL result = *v72;
                      unint64_t v75 = v78;
                    }
                    while (*(float *)(v74 + 4 * *v72) >= v77);
                    *float32x2_t v78 = v76;
                  }
                }
                int64_t v69 = v70 - 1;
              }
              while (v70);
              uint64_t v81 = (unint64_t)v14 >> 3;
              do
              {
                uint64_t v82 = 0;
                uint64_t v83 = *v13;
                unint64_t v84 = *a3;
                uint64_t v85 = v13;
                do
                {
                  float32x2_t v86 = v85;
                  v85 += v82 + 1;
                  uint64_t v87 = 2 * v82;
                  uint64_t v82 = (2 * v82) | 1;
                  uint64_t v88 = v87 + 2;
                  if (v88 < v81)
                  {
                    BOOL result = v85[1];
                    if (*(float *)(*v84 + 4 * *v85) < *(float *)(*v84 + 4 * result))
                    {
                      ++v85;
                      uint64_t v82 = v88;
                    }
                  }
                  *float32x2_t v86 = *v85;
                }
                while (v82 <= (uint64_t)((unint64_t)(v81 - 2) >> 1));
                if (v85 == --a2)
                {
                  *uint64_t v85 = v83;
                }
                else
                {
                  *uint64_t v85 = *a2;
                  *a2 = v83;
                  uint64_t v89 = (char *)v85 - (char *)v13 + 8;
                  if (v89 >= 9)
                  {
                    unint64_t v90 = (((unint64_t)v89 >> 3) - 2) >> 1;
                    unint64_t v91 = &v13[v90];
                    uint64_t v92 = *v91;
                    uint64_t v93 = *v85;
                    uint64_t v94 = *v84;
                    float v95 = *(float *)(v94 + 4 * *v85);
                    if (*(float *)(v94 + 4 * *v91) < v95)
                    {
                      do
                      {
                        float32x2_t v96 = v91;
                        *uint64_t v85 = v92;
                        if (!v90) {
                          break;
                        }
                        unint64_t v90 = (v90 - 1) >> 1;
                        unint64_t v91 = &v13[v90];
                        uint64_t v92 = *v91;
                        uint64_t v85 = v96;
                      }
                      while (*(float *)(v94 + 4 * *v91) < v95);
                      *float32x2_t v96 = v93;
                    }
                  }
                }
              }
              while (v81-- > 2);
            }
            return result;
          }
          unint64_t v16 = v15 >> 1;
          float v17 = &v13[v15 >> 1];
          uint64_t v18 = **a3;
          if ((unint64_t)v14 >= 0x401)
          {
            sub_1DC3961F0(v11, &v11[v15 >> 1], a2 - 1, v18);
            sub_1DC3961F0(v11 + 1, v17 - 1, a2 - 2, **a3);
            sub_1DC3961F0(v11 + 2, &v11[v16 + 1], a2 - 3, **a3);
            BOOL result = (uint64_t)sub_1DC3961F0(v17 - 1, v17, &v11[v16 + 1], **a3);
            uint64_t v19 = *v11;
            *uint64_t v11 = *v17;
            uint64_t *v17 = v19;
          }
          else
          {
            BOOL result = (uint64_t)sub_1DC3961F0(&v11[v15 >> 1], v11, a2 - 1, v18);
          }
          --a4;
          uint64_t v20 = *v11;
          uint64_t v21 = **a3;
          if (a5) {
            break;
          }
          float v22 = *(float *)(v21 + 4 * v20);
          if (*(float *)(v21 + 4 * *(v11 - 1)) < v22) {
            goto LABEL_13;
          }
          if (v22 >= *(float *)(v21 + 4 * *v12))
          {
            unint64_t v37 = v11 + 1;
            do
            {
              uint64_t v13 = v37;
              if (v37 >= a2) {
                break;
              }
              ++v37;
            }
            while (v22 >= *(float *)(v21 + 4 * *v13));
          }
          else
          {
            uint64_t v13 = v11;
            do
            {
              uint64_t v36 = v13[1];
              ++v13;
            }
            while (v22 >= *(float *)(v21 + 4 * v36));
          }
          unint64_t v38 = a2;
          if (v13 < a2)
          {
            unint64_t v38 = a2;
            do
              uint64_t v39 = *--v38;
            while (v22 < *(float *)(v21 + 4 * v39));
          }
          if (v13 < v38)
          {
            uint64_t v40 = *v13;
            uint64_t v41 = *v38;
            do
            {
              *uint64_t v13 = v41;
              *unint64_t v38 = v40;
              do
              {
                uint64_t v42 = v13[1];
                ++v13;
                uint64_t v40 = v42;
              }
              while (v22 >= *(float *)(v21 + 4 * v42));
              do
              {
                uint64_t v43 = *--v38;
                uint64_t v41 = v43;
              }
              while (v22 < *(float *)(v21 + 4 * v43));
            }
            while (v13 < v38);
          }
          unint64_t v44 = v13 - 1;
          BOOL v5 = v13 - 1 >= v11;
          BOOL v6 = v13 - 1 == v11;
          if (v13 - 1 != v11) {
            *uint64_t v11 = *v44;
          }
          a5 = 0;
          *unint64_t v44 = v20;
        }
        float v22 = *(float *)(v21 + 4 * v20);
LABEL_13:
        CFTypeRef v23 = v11;
        do
        {
          uint64_t v24 = v23;
          uint64_t v26 = v23[1];
          ++v23;
          uint64_t v25 = v26;
        }
        while (*(float *)(v21 + 4 * v26) < v22);
        uint64_t v27 = a2;
        if (v24 == v11)
        {
          uint64_t v27 = a2;
          do
          {
            if (v23 >= v27) {
              break;
            }
            uint64_t v29 = *--v27;
          }
          while (*(float *)(v21 + 4 * v29) >= v22);
        }
        else
        {
          do
            uint64_t v28 = *--v27;
          while (*(float *)(v21 + 4 * v28) >= v22);
        }
        if (v23 < v27)
        {
          uint64_t v30 = *v27;
          uint64_t v31 = v23;
          char v32 = v27;
          do
          {
            *uint64_t v31 = v30;
            *char v32 = v25;
            do
            {
              uint64_t v24 = v31;
              uint64_t v33 = v31[1];
              ++v31;
              uint64_t v25 = v33;
            }
            while (*(float *)(v21 + 4 * v33) < v22);
            do
            {
              uint64_t v34 = *--v32;
              uint64_t v30 = v34;
            }
            while (*(float *)(v21 + 4 * v34) >= v22);
          }
          while (v31 < v32);
        }
        if (v24 != v11) {
          *uint64_t v11 = *v24;
        }
        *uint64_t v24 = v20;
        if (v23 >= v27) {
          break;
        }
LABEL_32:
        BOOL result = sub_1DC39656C(v11, v24, a3, a4, a5 & 1);
        a5 = 0;
        uint64_t v13 = v24 + 1;
      }
      BOOL v35 = sub_1DC396D2C(v11, v24, a3);
      uint64_t v13 = v24 + 1;
      BOOL result = sub_1DC396D2C(v24 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v35) {
        goto LABEL_32;
      }
    }
    a2 = v24;
    if (!v35) {
      continue;
    }
    return result;
  }
}

BOOL sub_1DC396D2C(uint64_t *a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(float *)(**a3 + 4 * v8) < *(float *)(**a3 + 4 * *a1))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      sub_1DC3961F0(a1, a1 + 1, a2 - 1, **a3);
      return 1;
    case 4:
      sub_1DC396278(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      uint64_t v21 = a1 + 1;
      float v22 = a1 + 2;
      CFTypeRef v23 = a1 + 3;
      sub_1DC396278(a1, a1 + 1, a1 + 2, a1 + 3, a3);
      uint64_t v24 = *(a2 - 1);
      uint64_t v25 = a1[3];
      uint64_t v26 = **a3;
      if (*(float *)(v26 + 4 * v24) < *(float *)(v26 + 4 * v25))
      {
        *CFTypeRef v23 = v24;
        *(a2 - 1) = v25;
        uint64_t v27 = *v23;
        uint64_t v28 = *v22;
        float v29 = *(float *)(v26 + 4 * *v23);
        if (v29 < *(float *)(v26 + 4 * *v22))
        {
          *float v22 = v27;
          *CFTypeRef v23 = v28;
          uint64_t v30 = *v21;
          if (v29 < *(float *)(v26 + 4 * *v21))
          {
            a1[1] = v27;
            a1[2] = v30;
            uint64_t v31 = *a1;
            if (v29 < *(float *)(v26 + 4 * *a1))
            {
              *a1 = v27;
              a1[1] = v31;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      sub_1DC3961F0(a1, a1 + 1, a1 + 2, **a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = **a3;
      uint64_t v14 = 24;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v11;
    uint64_t v16 = *v10;
    float v17 = *(float *)(v13 + 4 * *v11);
    if (v17 < *(float *)(v13 + 4 * *v10))
    {
      uint64_t v18 = v14;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v18) = v16;
        uint64_t v19 = v18 - 8;
        if (v18 == 8) {
          break;
        }
        uint64_t v16 = *(uint64_t *)((char *)a1 + v18 - 16);
        v18 -= 8;
        if (v17 >= *(float *)(v13 + 4 * v16))
        {
          uint64_t v20 = (uint64_t *)((char *)a1 + v19);
          goto LABEL_13;
        }
      }
      uint64_t v20 = a1;
LABEL_13:
      *uint64_t v20 = v15;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v14 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

void *sub_1DC396F6C()
{
  return &unk_1F365EDD8;
}

uint64_t sub_1DC396F78(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc9inference3iie16IIEPostprocessor3runERKNS1_20IIEImagePreprocessorERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNSB_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC396FB4(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "IIEPostprocessor::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC397060(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F868;
}

void *sub_1DC397080()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365F868;
  return result;
}

void sub_1DC3970B8()
{
}

void *sub_1DC3970D0()
{
  return &unk_1F365DB28;
}

uint64_t sub_1DC3970DC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc9inference3iie16IIEPostprocessor3runERKNS1_20IIEImagePreprocessorERKNS_6Sample11PixelBufferERNSt3__18optionalINS_5ErrorEEERKNSB_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC397118(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "IIEPostprocessor::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3971C4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365E680;
}

void *sub_1DC3971E4()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365E680;
  return result;
}

void sub_1DC39721C()
{
}

uint64_t sub_1DC397234(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = atomic_exchange((atomic_ullong *volatile)(a2 + 8), 0);
  *(void *)(a1 + 16) = atomic_exchange((atomic_ullong *volatile)(a2 + 16), 0);
  long long v4 = *(_OWORD *)(a2 + 24);
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(_OWORD *)(a1 + 24) = v4;
  uint64_t v6 = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  uint64_t v7 = a1 + 72;
  *(void *)(v7 - 8) = v6;
  *(unsigned char *)(v7 + 128) = 0;
  if (*(unsigned char *)(a2 + 200))
  {
    sub_1DC31931C(v7, (long long *)(a2 + 72));
    *(unsigned char *)(a1 + 200) = 1;
    if (*(unsigned char *)(a2 + 200))
    {
      sub_1DC3191E0(a2 + 72);
      *(unsigned char *)(a2 + 200) = 0;
    }
  }
  uint64_t v8 = *(void *)(a2 + 208);
  *(void *)(a2 + 208) = 0;
  *(void *)(a1 + 208) = v8;
  uint64_t v9 = *(void *)(a2 + 216);
  *(void *)(a2 + 216) = 0;
  *(void *)(a1 + 216) = v9;
  uint64_t v10 = *(void *)(a2 + 224);
  *(void *)(a2 + 224) = 0;
  *(void *)(a1 + 224) = v10;
  uint64_t v11 = *(void *)(a2 + 232);
  *(void *)(a2 + 232) = 0;
  *(void *)(a1 + 232) = v11;
  uint64_t v12 = *(void *)(a2 + 240);
  *(void *)(a2 + 240) = 0;
  *(void *)(a1 + 240) = v12;
  uint64_t v13 = *(void *)(a2 + 248);
  *(void *)(a2 + 248) = 0;
  *(void *)(a1 + 248) = v13;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
  *(void *)(a1 + 272) = *(void *)(a2 + 272);
  *(void *)(a2 + 256) = 0;
  *(void *)(a2 + 264) = 0;
  *(void *)(a2 + 272) = 0;
  *(unsigned char *)(a1 + 280) = 0;
  *(unsigned char *)(a1 + 392) = 0;
  if (*(unsigned char *)(a2 + 392))
  {
    *(void *)(a1 + 280) = &unk_1F3660D18;
    long long v14 = *(_OWORD *)(a2 + 288);
    *(_DWORD *)(a1 + 304) = *(_DWORD *)(a2 + 304);
    *(_OWORD *)(a1 + 288) = v14;
    *(void *)(a1 + 280) = &unk_1F3660D78;
    long long v15 = *(_OWORD *)(a2 + 312);
    long long v16 = *(_OWORD *)(a2 + 328);
    *(void *)(a1 + 344) = *(void *)(a2 + 344);
    *(_OWORD *)(a1 + 312) = v15;
    *(_OWORD *)(a1 + 328) = v16;
    if (*(unsigned char *)(a2 + 344)) {
      *(unsigned char *)(a2 + 344) = 0;
    }
    long long v17 = *(_OWORD *)(a2 + 352);
    long long v18 = *(_OWORD *)(a2 + 368);
    *(void *)(a1 + 384) = *(void *)(a2 + 384);
    *(_OWORD *)(a1 + 352) = v17;
    *(_OWORD *)(a1 + 368) = v18;
    if (*(unsigned char *)(a2 + 384)) {
      *(unsigned char *)(a2 + 384) = 0;
    }
    *(unsigned char *)(a1 + 392) = 1;
    if (*(unsigned char *)(a2 + 392))
    {
      if (*(unsigned char *)(a2 + 344)) {
        free(*(void **)(a2 + 312));
      }
      *(unsigned char *)(a2 + 392) = 0;
    }
  }
  *(void *)(a1 + 400) = atomic_exchange((atomic_ullong *volatile)(a2 + 400), 0);
  return a1;
}

uint64_t sub_1DC39740C(uint64_t a1)
{
  sub_1DC330114((atomic_ullong *)(a1 + 400));
  if (*(unsigned char *)(a1 + 392) && *(unsigned char *)(a1 + 344)) {
    free(*(void **)(a1 + 312));
  }
  long long v4 = (void **)(a1 + 256);
  sub_1DC345A14(&v4);
  sub_1DC345A9C((uint64_t *)(a1 + 248), 0);
  sub_1DC345A9C((uint64_t *)(a1 + 240), 0);
  sub_1DC345A9C((uint64_t *)(a1 + 232), 0);
  sub_1DC345A9C((uint64_t *)(a1 + 224), 0);
  sub_1DC345A9C((uint64_t *)(a1 + 216), 0);
  sub_1DC345A9C((uint64_t *)(a1 + 208), 0);
  if (*(unsigned char *)(a1 + 200)) {
    sub_1DC3191E0(a1 + 72);
  }
  uint64_t v2 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 16));
  sub_1DC31EB58((atomic_ullong *)(a1 + 8));
  return a1;
}

void *sub_1DC397500()
{
  return &unk_1F365ED28;
}

uint64_t sub_1DC39750C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie8IIEModel7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC397548(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "IIEModel::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3975F4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F4A0;
}

void *sub_1DC397614()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365F4A0;
  return result;
}

void sub_1DC39764C()
{
}

void *sub_1DC397664()
{
  return &unk_1F365ED18;
}

uint64_t sub_1DC397670(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie8IIEModel7prepareERNSt3__18optionalINS_5ErrorEEERKNS4_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3976AC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "IIEModel::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC397758(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F448;
}

void *sub_1DC397778()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365F448;
  return result;
}

void sub_1DC3977B0()
{
}

void *sub_1DC3977C8()
{
  return &unk_1F365ED08;
}

uint64_t sub_1DC3977D4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie8IIEModel3runERKNS_6SampleERKNSt3__18optionalINS1_11IIECropRectEEERNS7_INS_5ErrorEEERKNS7_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC397810(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "IIEModel::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3978BC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F3F0;
}

void *sub_1DC3978DC()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365F3F0;
  return result;
}

void sub_1DC397914()
{
}

void *sub_1DC39792C()
{
  return &unk_1F365ECF8;
}

uint64_t sub_1DC397938(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie8IIEModel3runERKNS_6SampleERKNSt3__18optionalINS1_11IIECropRectEEERNS7_INS_5ErrorEEERKNS7_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC397974(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "IIEModel::run", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC397A20(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F398;
}

void *sub_1DC397A40()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365F398;
  return result;
}

void sub_1DC397A78()
{
}

char **sub_1DC397A90()
{
  return &off_1E6C3A950;
}

const char *sub_1DC397AA0()
{
  return "attributes";
}

const char *sub_1DC397AB4()
{
  return "offset_y";
}

const char *sub_1DC397AC8()
{
  return "offset_x";
}

const char *sub_1DC397ADC()
{
  return "heatmap";
}

const char *sub_1DC397AF0()
{
  return "thresmap";
}

const char *sub_1DC397B04()
{
  return "input";
}

const char *sub_1DC397B18()
{
  return "main";
}

const char *sub_1DC397B24()
{
  return "MRCIIE";
}

uint64_t sub_1DC397B30()
{
  return 0;
}

uint64_t sub_1DC397B38()
{
  return 1;
}

const char *sub_1DC397B40()
{
  return "model_0099999_3sym_noidle2-10_nodivide";
}

void sub_1DC397B50()
{
}

void *sub_1DC397B68()
{
  return &unk_1F365D968;
}

uint64_t sub_1DC397B74(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie8IIEModel6createERKNS_7Context7OptionsEbRNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC397BB0(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "IIEModel::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC397C5C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365DCE0;
}

void *sub_1DC397C7C()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365DCE0;
  return result;
}

void sub_1DC397CB4()
{
}

void *sub_1DC397CCC()
{
  return &unk_1F365D958;
}

uint64_t sub_1DC397CD8(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie8IIEModel6createERKNS_7Context7OptionsEbRNSt3__18optionalINS_5ErrorEEERKNS8_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC397D14(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = qword_1EAA94CA8;
    if (os_signpost_enabled((os_log_t)qword_1EAA94CA8))
    {
      *(_WORD *)long long v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "IIEModel::create", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC397DC0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365DC88;
}

void *sub_1DC397DE0()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F365DC88;
  return result;
}

void sub_1DC397E18()
{
}

void sub_1DC397E30(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v2 = a2 + 3;
  if (!a2[3]) {
    return;
  }
  long long v4 = (std::__shared_weak_count *)a1;
  long long v5 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock_with_options();
  uint64_t v6 = sub_1DC32E728(&v4[1].__vftable, (unint64_t)&unk_1DC40EE40);
  if (!v6) {
    operator new();
  }
  if ((_UNKNOWN *)v6[3] != &unk_1DC40EE40)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_38;
  }
  uint64_t v7 = (atomic_ullong *)v6[6];
  if (!v7)
  {
LABEL_38:
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_39:
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
LABEL_13:
    uint64_t v9 = qword_1EAA94CA8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(context[0]) = 0;
      _os_log_error_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_ERROR, "Unable to retrieve or instantiate concrete IIE context.", (uint8_t *)context, 2u);
    }
    LOBYTE(v15) = 0;
    char v16 = 0;
    sub_1DC390A40((uint64_t)v17, -1, 0);
    sub_1DC390CA0(context, v17);
    char v19 = 1;
    if (!*v2) {
      sub_1DC307C38();
    }
    (*(void (**)(void, uint64_t *, atomic_ullong *))(*(void *)*v2 + 48))(*v2, &v15, context);
    if (v19) {
      sub_1DC390B00(context);
    }
    sub_1DC390B00(v17);
    if (v4) {
      goto LABEL_35;
    }
    return;
  }
  atomic_ullong v8 = *v7;
  long long v4 = (std::__shared_weak_count *)v7[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  if (!v8)
  {
    if (qword_1EAA94CB0 == -1) {
      goto LABEL_13;
    }
    goto LABEL_39;
  }
  if (!*v2)
  {
    os_signpost_id_t v2 = &v14;
    goto LABEL_21;
  }
  if ((void *)*v2 != a2)
  {
    long long v14 = (void *)*v2;
LABEL_21:
    *os_signpost_id_t v2 = 0;
    goto LABEL_23;
  }
  long long v14 = v13;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v13);
LABEL_23:
  if (v14)
  {
    uint64_t v10 = *(NSObject **)(v8 + 608);
    dispatch_time_t v11 = dispatch_time(0, 3000000000);
    if (dispatch_group_wait(v10, v11))
    {
      if (qword_1EAA94CB0 != -1) {
        dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
      }
      uint64_t v12 = qword_1EAA94CA8;
      if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(context[0]) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v12, OS_LOG_TYPE_ERROR, "Timed out waiting for model to be loaded.", (uint8_t *)context, 2u);
      }
      LOBYTE(v15) = 0;
      char v16 = 0;
      sub_1DC390A40((uint64_t)v17, -6010, @"Timed out waiting for model to be loaded.");
      sub_1DC390CA0(context, v17);
      char v19 = 1;
      if (!v14) {
        sub_1DC307C38();
      }
      (*(void (**)(void *, uint64_t *, atomic_ullong *))(*v14 + 48))(v14, &v15, context);
      if (v19) {
        sub_1DC390B00(context);
      }
      sub_1DC390B00(v17);
    }
    else
    {
      context[0] = (atomic_ullong)&unk_1F3661CD8;
      context[1] = v8;
      context[2] = (atomic_ullong)v13;
      context[3] = (atomic_ullong)context;
      dispatch_barrier_async_and_wait_f(*(dispatch_queue_t *)(v8 + 8), context, (dispatch_function_t)sub_1DC398690);
      sub_1DC307968(context);
    }
  }
  sub_1DC39860C(v13);
  if (v4) {
LABEL_35:
  }
    sub_1DC32EEF4(v4);
}

void sub_1DC39841C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  if (a2) {
    sub_1DC2FFA58(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC398550(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 608);
    *(void *)(v1 + 608) = 0;
    if (v2) {
      (*(void (**)(void))(v1 + 616))();
    }
    if (*(unsigned char *)(v1 + 600)) {
      sub_1DC390B00((atomic_ullong *)(v1 + 504));
    }
    if (*(unsigned char *)(v1 + 496)) {
      sub_1DC39740C(v1 + 88);
    }
    sub_1DC31EB58((atomic_ullong *)(v1 + 40));
    sub_1DC31EB58((atomic_ullong *)(v1 + 32));
    uint64_t v3 = *(void *)(v1 + 8);
    *(void *)uint64_t v1 = &unk_1F3660CD8;
    *(void *)(v1 + 8) = 0;
    if (v3) {
      (*(void (**)(void))(v1 + 16))();
    }
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

void *sub_1DC39860C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1DC398690(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    sub_1DC307C38();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

void *sub_1DC3986E0()
{
  return &unk_1F3660998;
}

uint64_t sub_1DC3986EC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie12_GLOBAL__N_110IIEContext7performENSt3__18functionIFvONS4_8optionalINS4_17reference_wrapperINS1_8IIEModelEEEEEONS6_INS_5ErrorEEEEEEEUlvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC398728(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v1 + 600))
  {
    uint64_t v2 = *(void *)(a1 + 16);
    LOBYTE(__p) = 0;
    char v15 = 0;
    sub_1DC390B4C((uint64_t)&v12, v1 + 504);
    char v13 = 1;
    uint64_t v3 = *(void *)(v2 + 24);
    if (!v3) {
      sub_1DC307C38();
    }
LABEL_3:
    BOOL result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, void **, atomic_ullong *))(*(void *)v3 + 48))(v3, &__p, &v12);
    if (!v13) {
      return result;
    }
    p_p = &v12;
    return sub_1DC390B00(p_p);
  }
  if (!*(unsigned char *)(v1 + 496))
  {
    dispatch_group_enter(*(dispatch_group_t *)(v1 + 608));
    if (qword_1EAA94CB0 != -1) {
      dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
    }
    os_signpost_id_t v10 = os_signpost_id_make_with_pointer((os_log_t)qword_1EAA94CA8, (const void *)v1);
    char v11 = 1;
    v17[0] = &unk_1F365DC88;
    long long v18 = v17;
    v16[0] = &unk_1F365DCE0;
    v16[3] = v16;
    char v19 = &v10;
    sub_1DC31AD78((uint64_t)&v20, (uint64_t)v16);
    if (*((unsigned char *)v19 + 8) && v18) {
      sub_1DC31AE10((uint64_t)v18, *v19);
    }
    sub_1DC31AE60(v16);
    sub_1DC31AE60(v17);
    operator new();
  }
  if (*(unsigned char *)(v1 + 288)
    && *(unsigned char *)(v1 + 480)
    && *(unsigned char *)(v1 + 432)
    && atomic_load_explicit((atomic_ullong *volatile)(v1 + 488), memory_order_acquire))
  {
    uint64_t v6 = *(void *)(a1 + 16);
    __p = (void *)(v1 + 88);
    char v15 = 1;
    LOBYTE(v12) = 0;
    char v13 = 0;
    uint64_t v3 = *(void *)(v6 + 24);
    if (!v3) {
      sub_1DC307C38();
    }
    goto LABEL_3;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  LOBYTE(v21) = 0;
  char v22 = 0;
  int v8 = *(unsigned __int8 *)(v1 + 600);
  if (*(unsigned char *)(v1 + 600))
  {
    sub_1DC390B4C((uint64_t)&v12, v1 + 504);
  }
  else
  {
    sub_1DC390A40((uint64_t)&__p, -1, 0);
    sub_1DC390CA0(&v12, (uint64_t *)&__p);
  }
  char v13 = 1;
  uint64_t v9 = *(void *)(v7 + 24);
  if (!v9) {
    sub_1DC307C38();
  }
  BOOL result = (atomic_ullong *)(*(uint64_t (**)(uint64_t, uint64_t *, atomic_ullong *))(*(void *)v9 + 48))(v9, &v21, &v12);
  if (v13) {
    BOOL result = sub_1DC390B00(&v12);
  }
  if (!v8)
  {
    p_p = (atomic_ullong *)&__p;
    return sub_1DC390B00(p_p);
  }
  return result;
}

void sub_1DC3997B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1DC330114((atomic_ullong *)&__p);
  sub_1DC31AEE4((uint64_t **)(v69 - 144));
  if (a66) {
    sub_1DC39740C((uint64_t)&a15);
  }
  sub_1DC31AEE4((uint64_t **)(v69 - 248));
  _Unwind_Resume(a1);
}

__n128 sub_1DC39999C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3661CD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3999C4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3661CD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC399A10()
{
}

void *sub_1DC399A28()
{
  return &unk_1F3660978;
}

uint64_t sub_1DC399A34(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7Context3Any4makeINS_9inference3iie12_GLOBAL__N_110IIEContextEvEES1_RKNS0_7OptionsEP16dispatch_queue_sEUlPvE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC399A70(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(*(void *)a2 + 8);
    if (v2) {
      sub_1DC32EEF4(v2);
    }
    JUMPOUT(0x1E019CE90);
  }
}

void sub_1DC399AD8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3661C28;
}

void *sub_1DC399AF8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3661C28;
  return result;
}

void sub_1DC399B30()
{
}

uint64_t sub_1DC399B4C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN3mrc9inference3iie12_GLOBAL__N_110IIEContextEE27__shared_ptr_default_deleteIS5_S5_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1DC399B88(uint64_t a1)
{
  return sub_1DC398550(*(void *)(a1 + 24));
}

void sub_1DC399B90(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC399BCC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 608);
  *(void *)(a1 + 608) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 616))();
  }
  if (*(unsigned char *)(a1 + 600)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 504));
  }
  if (*(unsigned char *)(a1 + 496)) {
    sub_1DC39740C(a1 + 88);
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CD8;
  *(void *)(a1 + 8) = 0;
  if (v3) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC399C80(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 608);
  *(void *)(a1 + 608) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 616))();
  }
  if (*(unsigned char *)(a1 + 600)) {
    sub_1DC390B00((atomic_ullong *)(a1 + 504));
  }
  if (*(unsigned char *)(a1 + 496)) {
    sub_1DC39740C(a1 + 88);
  }
  sub_1DC31EB58((atomic_ullong *)(a1 + 40));
  sub_1DC31EB58((atomic_ullong *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CD8;
  *(void *)(a1 + 8) = 0;
  if (v3) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

void sub_1DC399D14(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CD8;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC399D84(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a1 = &unk_1F3660CD8;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 16))();
  }
  return a1;
}

atomic_ullong *sub_1DC399DD4@<X0>(uint64_t a1@<X0>, CFErrorRef *a2@<X8>)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  LOBYTE(v4[0]) = 0;
  char v5 = 0;
  v6[0] = &unk_1F365F340;
  v6[1] = v4;
  v6[3] = v6;
  sub_1DC397E30(a1, v6);
  __n128 result = sub_1DC39860C(v6);
  if (v5)
  {
    __n128 result = sub_1DC390F7C(a2, (uint64_t)v4);
    if (v5) {
      return sub_1DC390B00(v4);
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_1DC399E94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a21) {
    sub_1DC390B00(&a9);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC399EC0()
{
  return &unk_1F365ECE8;
}

uint64_t sub_1DC399ECC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference3iie8IIEModel19preflightForContextERNS_7ContextEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

atomic_ullong *sub_1DC399F08(atomic_ullong *result, unsigned char *a2, uint64_t a3)
{
  if (!a2[8]) {
    return sub_1DC3070F0((atomic_ullong *)result[1], a3);
  }
  uint64_t v3 = *(void *)a2;
  if (!*(unsigned char *)(*(void *)a2 + 200)
    || !*(unsigned char *)(v3 + 392)
    || !*(unsigned char *)(v3 + 344)
    || !atomic_load_explicit((atomic_ullong *volatile)(v3 + 400), memory_order_acquire))
  {
    return sub_1DC3070F0((atomic_ullong *)result[1], a3);
  }
  return result;
}

uint64_t sub_1DC399F50(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365F340;
  a2[1] = v2;
  return result;
}

void *sub_1DC399F74(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F365F340;
  result[1] = v3;
  return result;
}

void sub_1DC399FBC()
{
}

uint64_t sub_1DC399FD4(int *a1, unsigned int a2, int a3, char a4)
{
  char v4 = a4;
  LODWORD(v6) = 0;
  uint64_t v7 = 4 * a2;
  int v8 = a1;
  do
  {
    int v9 = *v8++;
    uint64_t v6 = (v9 + v6);
    v7 -= 4;
  }
  while (v7);
  uint64_t v10 = 0;
  int v36 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = a2 - 1;
  int v31 = a2 - 3;
  uint64_t v27 = v12;
  uint64_t v28 = a1;
  do
  {
    int v13 = 1 << v10;
    int v14 = a1[v10];
    if (v14 < 2)
    {
      v36 |= v13;
      int v14 = 1;
    }
    else
    {
      int v34 = a2 - v10 - 1;
      int v35 = a2 - v10;
      int v15 = a2 - v10 - 3;
      uint64_t v30 = v10;
      int v33 = v10 - v12;
      v36 &= ~v13;
      int v37 = a2 - v10 - 2;
      int v16 = 1;
      int v17 = 1;
      do
      {
        uint64_t v18 = v6;
        int v19 = v6 - v16;
        int v20 = sub_1DC30F458((int)v6 - v16 - 1, v37);
        if ((v4 & 1) != 0 || v17)
        {
          int v21 = v35;
        }
        else
        {
          int v21 = v35;
          if (v19 - v34 >= v34) {
            v20 -= sub_1DC30F458(v19 - v35, v37);
          }
        }
        if (v21 < 3)
        {
          int v25 = v20 - (v19 > a3);
        }
        else
        {
          int v22 = v19 - v37;
          if (v19 - v37 <= a3)
          {
            int v23 = 0;
          }
          else
          {
            int v23 = 0;
            int v24 = v31;
            do
            {
              v23 += sub_1DC30F458(v24, v15);
              --v22;
              ++v24;
            }
            while (v22 > a3);
          }
          int v25 = v20 + v23 * v33;
          char v4 = a4;
        }
        uint64_t v6 = v18;
        uint64_t v11 = (v25 + v11);
        ++v16;
        int v17 = v36;
      }
      while (v16 != v14);
      uint64_t v12 = v27;
      a1 = v28;
      uint64_t v10 = v30;
    }
    uint64_t v6 = (v6 - v14);
    ++v10;
    --v31;
  }
  while (v10 != v12);
  return v11;
}

void sub_1DC39A1AC(void *a1)
{
  *a1 = &unk_1F3661890;
  sub_1DC311968(a1 + 2);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC39A210(void *a1)
{
  *a1 = &unk_1F3661890;
  sub_1DC311968(a1 + 2);
  return a1;
}

atomic_uint **sub_1DC39A254(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void sub_1DC39A288(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (atomic_uint **)**a1;
  if (v2)
  {
    char v4 = (atomic_uint **)v1[1];
    char v5 = v2;
    if (v4 != v2)
    {
      do
        char v4 = sub_1DC39A254(v4 - 1);
      while (v4 != v2);
      char v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DC39A30C()
{
}

void sub_1DC39A790(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC39A9E0((atomic_uint **)va);
  _Unwind_Resume(a1);
}

atomic_uint *sub_1DC39A7C0(atomic_uint *result, atomic_uint **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = (atomic_uint **)*((void *)result + 1);
  NSObject *v3 = 0;
  char v4 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    __n128 result = *v3;
    if (*v3) {
      __n128 result = sub_1DC2FF57C(result);
    }
  }
  NSObject *v3 = v4;
  *((void *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1DC39A818(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC39A820(atomic_uint ***a1, atomic_uint **a2)
{
  uint64_t v2 = a1[1] - *a1;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  uint64_t v6 = (char *)a1[2] - (char *)*a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v26 = a1 + 2;
  if (v7)
  {
    if (v7 >> 61) {
      sub_1DC2FF994();
    }
    int v8 = (char *)operator new(8 * v7);
  }
  else
  {
    int v8 = 0;
  }
  int v9 = (atomic_uint **)&v8[8 * v2];
  int v23 = v8;
  v24.i64[0] = (uint64_t)v9;
  v24.i64[1] = (uint64_t)v9;
  int v25 = &v8[8 * v7];
  *int v9 = 0;
  uint64_t v10 = *a2;
  uint64_t v11 = v9;
  uint64_t v12 = v9;
  if (v10)
  {
    atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
    uint64_t v11 = v9;
    uint64_t v12 = v9;
    if (*v9)
    {
      sub_1DC2FF57C(*v9);
      uint64_t v12 = (atomic_uint **)v24.i64[1];
      uint64_t v11 = (atomic_uint **)v24.i64[0];
    }
  }
  *int v9 = v10;
  int v13 = v12 + 1;
  v24.i64[1] = (uint64_t)(v12 + 1);
  int v15 = *a1;
  unint64_t v14 = (unint64_t)a1[1];
  if ((atomic_uint **)v14 == *a1)
  {
    int64x2_t v20 = vdupq_n_s64(v14);
  }
  else
  {
    uint64_t v16 = 0;
    do
    {
      int v17 = &v11[v16];
      v11[v16 - 1] = 0;
      uint64_t v18 = *(atomic_uint **)(v14 + v16 * 8 - 8);
      if (v18)
      {
        atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
        int v19 = *(v17 - 1);
        if (v19) {
          sub_1DC2FF57C(v19);
        }
      }
      *(v17 - 1) = v18;
      --v16;
    }
    while ((atomic_uint **)(v14 + v16 * 8) != v15);
    uint64_t v11 = (atomic_uint **)((char *)v11 + v16 * 8);
    int64x2_t v20 = *(int64x2_t *)a1;
    int v13 = (atomic_uint **)v24.i64[1];
  }
  *a1 = v11;
  a1[1] = v13;
  int64x2_t v24 = v20;
  int v21 = (char *)a1[2];
  a1[2] = (atomic_uint **)v25;
  int v25 = v21;
  int v23 = (char *)v20.i64[0];
  sub_1DC39ABA8((uint64_t)&v23);
  return v13;
}

void sub_1DC39A9AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC39ABA8((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC39A9E0(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

BOOL sub_1DC39AA14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ((a3
         + a2
         + a3 * a2
         - ((((unint64_t)(a3 * a2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64) >> 1)) & 1) == 0;
}

void sub_1DC39AA3C()
{
}

BOOL sub_1DC39AA54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ((a3 * a2
         - ((((unint64_t)(a3 * a2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64) >> 1)
         + a3 * a2) & 1) == 0;
}

void sub_1DC39AA78()
{
}

BOOL sub_1DC39AA90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ((a3 * a2) & 1) == 3 * (a3 * a2 / 3uLL) - a3 * a2;
}

void sub_1DC39AAC0()
{
}

BOOL sub_1DC39AAD8(uint64_t a1, unsigned int a2, unint64_t a3)
{
  return ((((a3 / 3) & 0x7FFFFFFF) + (a2 >> 1)) & 1) == 0;
}

void sub_1DC39AAF8()
{
}

BOOL sub_1DC39AB10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 0xAAAAAAAAAAAAAAABLL * (a3 + a2) < 0x5555555555555556;
}

void sub_1DC39AB34()
{
}

BOOL sub_1DC39AB4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 0xAAAAAAAAAAAAAAABLL * a3 < 0x5555555555555556;
}

void sub_1DC39AB6C()
{
}

BOOL sub_1DC39AB84(uint64_t a1, char a2)
{
  return (a2 & 1) == 0;
}

void sub_1DC39AB90()
{
}

uint64_t sub_1DC39ABA8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC39A9E0((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL sub_1DC39ABF8(uint64_t a1, int a2, int a3)
{
  return ((a3 + a2) & 1) == 0;
}

void sub_1DC39AC08()
{
}

std::string *sub_1DC39AC20(std::string *result, const std::string::value_type *a2, std::string::size_type a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    unint64_t v7 = result;
    if (MEMORY[0x1E019D3A0]("UTF-8", a4) != -1) {
      operator new[]();
    }
    if (qword_1EAA94CD0 != -1) {
      dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
    }
    int v8 = qword_1EAA94CC8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR))
    {
      int v9 = *__error();
      v10[0] = 136446722;
      *(void *)&v10[1] = "UTF-8";
      __int16 v11 = 2082;
      uint64_t v12 = a4;
      __int16 v13 = 1026;
      int v14 = v9;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "[QR] iconv_open(\"%{public}s\", \"%{public}s\") failed: %{public, errno}d", (uint8_t *)v10, 0x1Cu);
    }
    return std::string::append(v7, a2, a3);
  }
  return result;
}

void sub_1DC39AEE0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC39AEFC()
{
}

void sub_1DC39B020(uint64_t a1, uint64_t a2, int a3)
{
  if (8 * (*(_DWORD *)(*(void *)(a1 + 32) + 24) - *(_DWORD *)(*(void *)(a1 + 32) + 16) - *(_DWORD *)(a1 + 40))
     - *(_DWORD *)(a1 + 44) >= 8 * a3)
    sub_1DC31465C((uint64_t)v4);
  exception = __cxa_allocate_exception(0x20uLL);
  exception[2] = 0;
  exception[3] = 0;
  void *exception = &unk_1F3661188;
  exception[1] = 0;
  __cxa_throw(exception, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
}

void sub_1DC39B640()
{
}

void sub_1DC39B648()
{
  *(void *)(v1 + 24) = v0;
  JUMPOUT(0x1DC39B70CLL);
}

void sub_1DC39B6B0()
{
}

void sub_1DC39B6C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1DC311968(&a15);
  _Unwind_Resume(a1);
}

std::string *sub_1DC39B734(std::string *a1, char *__s)
{
  size_t v4 = strlen(__s);
  return sub_1DC39B7E8(a1, __s, v4);
}

uint64_t sub_1DC39B77C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    size_t v4 = *(void (***)(void))(i - 24);
    *(void *)(a1 + 16) = i - 24;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

std::string *sub_1DC39B7E8(std::string *__dst, const std::string::value_type *__src, size_t __len)
{
  LODWORD(v6) = SHIBYTE(__dst->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = __dst->__r_.__value_.__r.__words[2];
    std::string::size_type v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __len)
    {
      std::string::size_type size = __dst->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    unint64_t v7 = (std::string *)__dst->__r_.__value_.__r.__words[0];
  }
  else
  {
    unint64_t v7 = __dst;
    if (__len > 0x16)
    {
      std::string::size_type size = HIBYTE(__dst->__r_.__value_.__r.__words[2]);
      std::string::size_type v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(__dst, v9, __len - v9, size, 0, size, __len, __src);
      return __dst;
    }
  }
  if (__len)
  {
    memmove(v7, __src, __len);
    LOBYTE(v6) = *((unsigned char *)&__dst->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0) {
    __dst->__r_.__value_.__l.__size_ = __len;
  }
  else {
    *((unsigned char *)&__dst->__r_.__value_.__s + 23) = __len & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__len] = 0;
  return __dst;
}

void sub_1DC39B8A8()
{
}

void sub_1DC39BE58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (v17 < 0)
  {
    operator delete(v16);
    if ((v18 & 1) == 0)
    {
LABEL_6:
      sub_1DC32B90C((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v18)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t sub_1DC39BECC(unint64_t a1)
{
  if (a1 >= 0x2D)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    exception[2] = 0;
    exception[3] = 0;
    void *exception = &unk_1F3661188;
    exception[1] = 0;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
  }
  return a0123456789abcd[a1];
}

uint64_t sub_1DC39BF38(uint64_t a1, std::string *a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(void *)(a6 + 8);
  uint64_t v10 = a6 + 8;
  uint64_t v11 = v12;
  if (!v12) {
    goto LABEL_11;
  }
  uint64_t v13 = v10;
  do
  {
    int v14 = *(_DWORD *)(v11 + 32) >> 30;
    BOOL v15 = v14 == 0;
    if (v14) {
      uint64_t v16 = (uint64_t *)v11;
    }
    else {
      uint64_t v16 = (uint64_t *)(v11 + 8);
    }
    if (!v15) {
      uint64_t v13 = v11;
    }
    uint64_t v11 = *v16;
  }
  while (*v16);
  if (v13 == v10 || *(_DWORD *)(v13 + 32) >= 0x40000001u) {
LABEL_11:
  }
    uint64_t v13 = v10;
  if (a5)
  {
    int v17 = *(const char **)(a5 + 8);
LABEL_14:
    int v17 = *(const char **)v17;
    goto LABEL_15;
  }
  if (v13 == v10)
  {
    int v17 = 0;
  }
  else
  {
    int v17 = (const char *)(v13 + 40);
    if (*(char *)(v13 + 63) < 0) {
      goto LABEL_14;
    }
  }
LABEL_15:
  if (v17) {
    int v18 = v17;
  }
  else {
    int v18 = "ASCII";
  }
  sub_1DC32B69C((uint64_t)&v43);
  if (a3 < 2)
  {
    int v20 = a3;
  }
  else
  {
    do
    {
      if (8
         * (*(_DWORD *)(*(void *)(a1 + 32) + 24) - *(_DWORD *)(*(void *)(a1 + 32) + 16) - *(_DWORD *)(a1 + 40))
         - *(_DWORD *)(a1 + 44) <= 10)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        exception[2] = 0;
        exception[3] = 0;
        void *exception = &unk_1F3661188;
        exception[1] = 0;
        __cxa_throw(exception, (struct type_info *)&unk_1F365FF50, (void (*)(void *))sub_1DC379C00);
      }
      int v19 = sub_1DC33BCD4(a1, 11);
      LOBYTE(v37) = sub_1DC39BECC(v19 / 45);
      sub_1DC31FC84(&v43, (uint64_t)&v37, 1);
      LOBYTE(v37) = sub_1DC39BECC(v19 % 45);
      sub_1DC31FC84(&v43, (uint64_t)&v37, 1);
      int v20 = a3 - 2;
      BOOL v21 = a3 <= 3;
      a3 -= 2;
    }
    while (!v21);
  }
  if (v20 == 1)
  {
    int v22 = sub_1DC33BCD4(a1, 6);
    LOBYTE(v37) = sub_1DC39BECC(v22);
    sub_1DC31FC84(&v43, (uint64_t)&v37, 1);
  }
  sub_1DC32B834(__p, (uint64_t)v44);
  int v23 = (uint64_t *)MEMORY[0x1E4FBA418];
  if (a4)
  {
    sub_1DC32B69C((uint64_t)&v37);
    int64x2_t v24 = (char *)HIBYTE(v42);
    int v25 = (char *)__p[1];
    if (v42 >= 0) {
      uint64_t v26 = (void *)HIBYTE(v42);
    }
    else {
      uint64_t v26 = __p[1];
    }
    if (v26)
    {
      for (unint64_t i = 0; i < (unint64_t)v26; ++i)
      {
        if ((v24 & 0x80) != 0)
        {
          int v28 = *((unsigned __int8 *)__p[0] + i);
          float v29 = v25;
        }
        else
        {
          int v28 = *((unsigned __int8 *)__p + i);
          float v29 = v24;
        }
        if (v28 == 37)
        {
          if (i < (unint64_t)(v29 - 1)
            && ((char)v24 >= 0 ? (uint64_t v30 = __p) : (uint64_t v30 = (void **)__p[0]), *((unsigned char *)v30 + i + 1) == 37))
          {
            LOBYTE(__dst) = *((unsigned char *)v30 + i);
            sub_1DC31FC84(&v37, (uint64_t)&__dst, 1);
            ++i;
          }
          else
          {
            LOBYTE(__dst) = 29;
            sub_1DC31FC84(&v37, (uint64_t)&__dst, 1);
          }
        }
        else
        {
          LOBYTE(__dst) = v28;
          sub_1DC31FC84(&v37, (uint64_t)&__dst, 1);
        }
      }
    }
    sub_1DC32B834(&__dst, (uint64_t)v38);
    if ((v24 & 0x80) != 0) {
      operator delete(__p[0]);
    }
    *(_OWORD *)__p = __dst;
    uint64_t v42 = v36;
    uint64_t v37 = *v23;
    *(void *)((char *)&v38[-1] + *(void *)(v37 - 24)) = v23[3];
    v38[0] = MEMORY[0x1E4FBA470] + 16;
    if (v39 < 0) {
      operator delete((void *)v38[8]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x1E019CE10](&v40);
  }
  if (v42 >= 0) {
    int v31 = __p;
  }
  else {
    int v31 = (void **)__p[0];
  }
  if (v42 >= 0) {
    std::string::size_type v32 = HIBYTE(v42);
  }
  else {
    std::string::size_type v32 = (std::string::size_type)__p[1];
  }
  sub_1DC39AC20(a2, (const std::string::value_type *)v31, v32, (uint64_t)v18);
  if (SHIBYTE(v42) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v43 = *v23;
  *(void *)((char *)&v44[-1] + *(void *)(v43 - 24)) = v23[3];
  v44[0] = MEMORY[0x1E4FBA470] + 16;
  if (v45 < 0) {
    operator delete((void *)v44[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E019CE10](&v46);
}

void sub_1DC39C454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,char a54)
{
  if (a52 < 0) {
    operator delete(__p);
  }
  sub_1DC32B90C((uint64_t)&a54);
  _Unwind_Resume(a1);
}

void sub_1DC39C4A0()
{
}

void sub_1DC39C544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, atomic_uint *a10)
{
  sub_1DC314B30(&a10);
  sub_1DC314A14(&a9);
  MEMORY[0x1E019CE90](v10, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

void sub_1DC39C580(uint64_t a1, atomic_uint *a2)
{
  if (a2) {
    atomic_fetch_add_explicit(a2 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v12 = a2;
  sub_1DC3915D8((uint64_t)v13, (uint64_t *)&v12);
  sub_1DC2FF548(&v12);
  sub_1DC391B9C((uint64_t)v13);
  sub_1DC3916F8(&v16, (uint64_t)v13);
  sub_1DC3914DC(&v16);
  sub_1DC3916F8(&v17, (uint64_t)v13);
  sub_1DC391B9C((uint64_t)v13);
  unint64_t v2 = *((unsigned __int8 *)v17 + 24);
  if (v2 < 8)
  {
    if (atomic_load_explicit((atomic_ullong *volatile)qword_1EBFFC2C8, memory_order_acquire) != -1)
    {
      uint64_t v16 = (atomic_uint *)sub_1DC39A30C;
      *(void *)&long long v18 = &v16;
      std::__call_once(qword_1EBFFC2C8, &v18, (void (__cdecl *)(void *))sub_1DC371FE8);
    }
    uint64_t v3 = v14;
    uint64_t v4 = *(void *)(v14 + 16);
    if (v4 << 32)
    {
      uint64_t v5 = 0;
      uint64_t v6 = *(void *)(*(void *)qword_1EBFFC2A0 + 8 * v2);
      int v7 = v15;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 16))(v6, v5, v8))
          {
            if (v7) {
              uint64_t v9 = v8;
            }
            else {
              uint64_t v9 = v5;
            }
            if (v7) {
              uint64_t v10 = v5;
            }
            else {
              uint64_t v10 = v8;
            }
            *(_DWORD *)(*(void *)(v3 + 48)
                      + (((unint64_t)(v10 + *(void *)(v3 + 24) * v9) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) ^= 1 << (v10 + *(unsigned char *)(v3 + 24) * v9);
          }
          ++v8;
        }
        while ((int)v4 != v8);
        ++v5;
      }
      while (v5 != (int)v4);
    }
    operator new();
  }
  exception = __cxa_allocate_exception(0x20uLL);
  sub_1DC379B70(exception, "reference must be between 0 and 7");
  void *exception = &unk_1F36613B0;
  __cxa_throw(exception, (struct type_info *)&unk_1F36600B8, (void (*)(void *))sub_1DC353C10);
}

void sub_1DC39D364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  if (*(char *)(v41 - 113) < 0) {
    operator delete(*(void **)(v41 - 136));
  }
  MEMORY[0x1E019CE90](v40, 0x1093C40E92185C3);
  sub_1DC311968(&a20);
  MEMORY[0x1E019CE90](v39, 0x10B3C40E71DBE67);
  sub_1DC31191C(*(void **)(v41 - 184));
  sub_1DC311968(&a30);
  *(void *)(v41 - 192) = &a36;
  sub_1DC39A288((void ***)(v41 - 192));
  sub_1DC311968(&a39);
  sub_1DC391584(v41 - 240);
  _Unwind_Resume(a1);
}

void sub_1DC39D4F8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,atomic_uint *a29)
{
  sub_1DC314BD0((void *)(v29 - 160));
  if (a2 == 1)
  {
    std::string::size_type v32 = __cxa_begin_catch(a1);
    int v33 = (char *)(*(uint64_t (**)(void *))(*(void *)v32 + 16))(v32);
    sub_1DC379B70((void *)(v29 - 192), v33);
    *(void *)(v29 - 192) = &unk_1F36611E0;
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC379EF4(exception, v29 - 192);
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
  sub_1DC314BD0((void *)(v29 - 136));
  sub_1DC311968(&a23);
  sub_1DC311968(&a26);
  sub_1DC39A254(&a29);
  JUMPOUT(0x1DC39D60CLL);
}

void sub_1DC39D5C4()
{
  sub_1DC379B0C((std::exception *)(v0 - 192));
  __cxa_end_catch();
  JUMPOUT(0x1DC39D5ECLL);
}

void sub_1DC39D644()
{
  sub_1DC39A254((atomic_uint **)(v0 - 160));
  sub_1DC311968((void *)(v0 - 192));
  JUMPOUT(0x1DC39D6A8);
}

void sub_1DC39D664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  *(void *)(v40 - 192) = &a36;
  sub_1DC39A288(v40 - 192);
  if (v39) {
    operator delete(v39);
  }
  sub_1DC311968(&a33);
  sub_1DC311968(&a39);
  sub_1DC391584(v40 - 240);
  _Unwind_Resume(a1);
}

void sub_1DC39D66C()
{
  MEMORY[0x1E019CE90](v0, 0x10A1C40FB604211);
  sub_1DC311968((void *)(v1 - 192));
  JUMPOUT(0x1DC39D6A8);
}

void *sub_1DC39D6E4(uint64_t **a1, _DWORD *a2)
{
  uint64_t v5 = a1 + 1;
  uint64_t v4 = (unsigned int *)a1[1];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = v4;
        unsigned int v7 = v4[8];
        if (v7 < 0x40000001) {
          break;
        }
        uint64_t v4 = (unsigned int *)*v6;
        uint64_t v5 = (uint64_t **)v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if (v7 == 0x40000000) {
        break;
      }
      uint64_t v4 = (unsigned int *)v6[1];
      if (!v4)
      {
        uint64_t v5 = (uint64_t **)(v6 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v6 = a1 + 1;
LABEL_9:
    uint64_t v8 = v6;
    uint64_t v6 = operator new(0x40uLL);
    *((_DWORD *)v6 + 8) = *a2;
    v6[6] = 0;
    v6[7] = 0;
    void v6[5] = 0;
    *uint64_t v6 = 0;
    v6[1] = 0;
    v6[2] = v8;
    *uint64_t v5 = v6;
    uint64_t v9 = (uint64_t *)**a1;
    uint64_t v10 = v6;
    if (v9)
    {
      *a1 = v9;
      uint64_t v10 = *v5;
    }
    sub_1DC311DD0(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6;
}

void sub_1DC39D7C8(char *a1)
{
  if (a1)
  {
    sub_1DC39D7C8(*(void *)a1);
    sub_1DC39D7C8(*((void *)a1 + 1));
    if (a1[63] < 0) {
      operator delete(*((void **)a1 + 5));
    }
    operator delete(a1);
  }
}

void sub_1DC39D824(uint64_t a1, uint64_t a2, uint64_t **a3, char *a4)
{
  sub_1DC314778((uint64_t)v9, a2);
  int v6 = *((_DWORD *)sub_1DC3116FC(a3, 12, &dword_1DC41629C) + 8);
  unsigned int v7 = *((_DWORD *)sub_1DC3116FC(a3, 13, &dword_1DC4162A0) + 8);
  v12[0] = 0;
  v12[1] = 0;
  uint64_t v11 = v12;
  if (a4)
  {
    uint64_t v8 = sub_1DC39D6E4(&v11, dword_1DC410178);
    sub_1DC39B734((std::string *)(v8 + 5), a4);
  }
  sub_1DC314778((uint64_t)v10, (uint64_t)v9);
  sub_1DC3AC32C(v6);
  sub_1DC3AA034(v7);
  operator new();
}

void sub_1DC39E080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char *a20,uint64_t a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,atomic_uint *a28,__int16 a29,char a30,char a31,int a32,__int16 a33,char a34,char a35,int a36,__int16 a37,char a38,char a39,int a40,uint64_t a41,uint64_t a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49,atomic_uint *a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,char a58)
{
  if (a49 < 0) {
    operator delete(__p);
  }
  sub_1DC34EC90(&a50);
  sub_1DC311968(&a16);
  sub_1DC39D7C8(a20);
  sub_1DC311968(&a13);
  _Unwind_Resume(a1);
}

void sub_1DC39E258()
{
}

void sub_1DC39E26C()
{
}

void sub_1DC39E2C4()
{
}

uint64_t MRCDecoderResultGetTypeID()
{
  if (qword_1EBFFB7A8[0] != -1) {
    dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
  }
  return qword_1EBFFB790;
}

uint64_t MRCDecoderResultGetDescriptorCount(CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v2 != qword_1EBFFB790) {
      _os_assumes_log();
    }
  }
  return (uint64_t)(*((void *)cf + 3) - *((void *)cf + 2)) >> 3;
}

unint64_t MRCDecoderResultGetDescriptorAtIndex(CFTypeRef cf, unint64_t a2)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v4 != qword_1EBFFB790) {
      _os_assumes_log();
    }
  }
  uint64_t v5 = *((void *)cf + 2);
  if (a2 >= (*((void *)cf + 3) - v5) >> 3)
  {
    _os_assumes_log();
    uint64_t v5 = *((void *)cf + 2);
  }
  return atomic_load_explicit((atomic_ullong *volatile)(v5 + 8 * a2), memory_order_acquire);
}

CFDictionaryRef MRCDecoderResultCopyAttributes(atomic_ullong *cf)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v3 != qword_1EBFFB790) {
      _os_assumes_log();
    }
  }
  CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(cf + 5, memory_order_acquire);
  if (explicit) {
    CFTypeRef explicit = CFRetain(explicit);
  }
  CFTypeRef v7 = explicit;
  CFDictionaryRef Copy = CFDictionaryCreateCopy(v2, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire));
  sub_1DC306584((atomic_ullong *)&v7);
  return Copy;
}

void sub_1DC39E588(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC306584((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

unint64_t MRCDecoderResultCopyAttribute(atomic_ullong *cf, void *key)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (qword_1EBFFB7A8[0] != -1) {
      dispatch_once_f(qword_1EBFFB7A8, 0, (dispatch_function_t)sub_1DC30E950);
    }
    if (v4 != qword_1EBFFB790) {
      _os_assumes_log();
    }
  }
  CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(cf + 5, memory_order_acquire);
  if (explicit) {
    CFTypeRef explicit = CFRetain(explicit);
  }
  CFTypeRef v9 = explicit;
  Value = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire), key);
  if (Value) {
    Value = CFRetain(Value);
  }
  atomic_ullong v10 = (atomic_ullong)Value;
  unint64_t v7 = atomic_exchange(&v10, 0);
  sub_1DC31EB58(&v10);
  sub_1DC306584((atomic_ullong *)&v9);
  return v7;
}

void sub_1DC39E67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

CFStringRef sub_1DC39E690(void *a1, int a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"<%s %p> {\n", "MRCDecoderResult", a1 - 2);
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    descriptors [%zu] {\n", (uint64_t)(a1[1] - *a1) >> 3);
    uint64_t v5 = (atomic_ullong *)*a1;
    int v6 = (atomic_ullong *)a1[1];
    if ((atomic_ullong *)*a1 != v6)
    {
      do
      {
        CFStringRef v11 = sub_1DC3C5500(atomic_load_explicit(v5, memory_order_acquire) + 16, a2);
        if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
        {
          CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v4, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire), @"\n");
          if (atomic_load_explicit((atomic_ullong *volatile)&ArrayBySeparatingStrings, memory_order_acquire))
          {
            CFStringRef v9 = CFStringCreateByCombiningStrings(v4, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&ArrayBySeparatingStrings, memory_order_acquire), @"\n        ");
            if (atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire)) {
              CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        %@\n", atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));
            }
            sub_1DC31FA90((atomic_ullong *)&v9);
          }
          sub_1DC3065EC((atomic_ullong *)&ArrayBySeparatingStrings);
        }
        sub_1DC31FA90((atomic_ullong *)&v11);
        ++v5;
      }
      while (v5 != v6);
    }
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    if (atomic_load_explicit(a1 + 3, memory_order_acquire)
      && CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit(a1 + 3, memory_order_acquire)) >= 1)
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    attributes {\n");
      CFDictionaryApplyFunction((CFDictionaryRef)atomic_load_explicit(a1 + 3, memory_order_acquire), (CFDictionaryApplierFunction)sub_1DC39E90C, (void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    }
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"}");
    CFStringRef Copy = CFStringCreateCopy(v4, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  }
  else
  {
    CFStringRef Copy = 0;
  }
  sub_1DC326F90((atomic_ullong *)&Mutable);
  return Copy;
}

void sub_1DC39E8C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1DC326F90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void sub_1DC39E90C(uint64_t a1, uint64_t a2, CFMutableStringRef theString)
{
}

void sub_1DC39E944(void *key, const void *a2, CFDictionaryRef theDict)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (CFDictionaryGetValue(theDict, key))
  {
    if (qword_1EBFFC270 != -1) {
      dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
    }
    int v6 = qword_1EBFFC278;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC278, OS_LOG_TYPE_DEBUG))
    {
      int v7 = 138543362;
      uint64_t v8 = key;
      _os_log_debug_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_DEBUG, "MRCDecoderResult: consolidation: attribute key \"%{public}@\" already exists, skipping...", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    CFDictionarySetValue(theDict, key, a2);
  }
}

void sub_1DC39EA78()
{
}

void sub_1DC39ECE8(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x1012C407D69FF4CLL);
  _Unwind_Resume(a1);
}

void sub_1DC39ED30()
{
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EAA94D58, memory_order_acquire) != -1)
  {
    uint64_t v0 = &v1;
    uint64_t v1 = sub_1DC39EA78;
    std::__call_once(&qword_1EAA94D58, &v0, (void (__cdecl *)(void *))sub_1DC33DA8C);
  }
}

void sub_1DC39ED94()
{
}

long long *sub_1DC39EDAC(int a1)
{
  if ((a1 - 5) < 0xFFFFFFFC) {
    return 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EAA94DE0, memory_order_acquire) & 1) == 0)
  {
    int v3 = a1;
    int v2 = __cxa_guard_acquire(qword_1EAA94DE0);
    a1 = v3;
    if (v2)
    {
      xmmword_1EAA94D60[0] = xmmword_1DC3FDD40;
      qword_1EAA94D70 = 0;
      unk_1EAA94D78 = 0;
      xmmword_1EAA94D80 = xmmword_1DC3FDD50;
      unk_1EAA94D90 = xmmword_1DC40F694;
      xmmword_1EAA94DA0 = xmmword_1DC3FDD60;
      unk_1EAA94DB0 = xmmword_1DC40F6AC;
      xmmword_1EAA94DC0 = xmmword_1DC3FDD70;
      unk_1EAA94DD0 = xmmword_1DC40F6C4;
      __cxa_guard_release(qword_1EAA94DE0);
      a1 = v3;
    }
  }
  return &xmmword_1EAA94D60[2 * (a1 - 1)];
}

void sub_1DC39EE9C(uint64_t a1)
{
  sub_1DC39EED4(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC39EED4(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661828;
  int v2 = *(atomic_uint ****)(a1 + 24);
  int v3 = v2[1];
  if (v3 != *v2)
  {
    unint64_t v4 = 0;
    int v3 = *v2;
    do
    {
      sub_1DC2FF57C(v3[v4]);
      *(void *)(**(void **)(a1 + 24) + 8 * v4++) = 0;
      int v2 = *(atomic_uint ****)(a1 + 24);
      int v3 = *v2;
    }
    while (v4 < v2[1] - *v2);
  }
  if (v3)
  {
    v2[1] = v3;
    operator delete(v3);
  }
  MEMORY[0x1E019CE90](v2, 0x80C40D6874129);
  sub_1DC3122B8((atomic_uint **)(a1 + 72));
  sub_1DC2FF548((atomic_uint **)(a1 + 16));
  return a1;
}

float sub_1DC39EF9C(uint64_t a1, int *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v2 = *a2;
  if (!*a2) {
    return NAN;
  }
  int v3 = a2[1];
  if (!v3) {
    return NAN;
  }
  int v4 = a2[2];
  if (!v4) {
    return NAN;
  }
  uint64_t v5 = 0;
  int v6 = 0;
  v10[0] = *a2;
  v10[1] = v3;
  v10[2] = v4;
  do
  {
    v6 += v10[v5] * v10[v5];
    ++v5;
  }
  while (v5 != 3);
  int v7 = v4 + v3 + v2;
  float v8 = vabds_f32((float)v6 / (float)v7, *(float *)(a1 + 64)) / *(float *)(a1 + 64);
  if (v8 > 0.5) {
    float v8 = NAN;
  }
  return (float)((float)(-3 * v6 + v7 * v7) / (float)((float)v6 + (float)v6)) + (float)(v8 * -0.1);
}

atomic_uint **sub_1DC39F09C(atomic_uint **a1, uint64_t a2, int **a3, unint64_t a4, int a5, int a6)
{
  uint64_t v114 = 0;
  unint64_t v115 = 0;
  unint64_t v112 = 0;
  uint64_t v113 = 0;
  int v11 = **a3;
  int v10 = (*a3)[1];
  int v12 = (*a3)[2];
  uint64_t v13 = *(_DWORD **)(a2 + 16);
  int v14 = v13[14];
  int v15 = v13[4];
  int v16 = v13[8];
  LODWORD(v111[0]) = 0;
  sub_1DC314D98(&__p, 3uLL, v111);
  unint64_t v17 = a4;
  if ((a4 & 0x80000000) != 0)
  {
    int64x2_t v24 = (int *)__p;
    int v28 = a1;
LABEL_9:
    if (v24)
    {
LABEL_19:
      int v117 = v24;
      operator delete(v24);
    }
    goto LABEL_20;
  }
  unint64_t v107 = a1;
  uint64_t v18 = a2;
  int v19 = 0;
  __int32 v100 = v10 + v11 + v12;
  float v20 = (float)(a5 - v12) + (float)((float)v10 * -0.5);
  int v102 = (int)v20;
  uint64_t v103 = v18;
  int v21 = 2 * v10;
  int v109 = v16 & (v14 - 1) | v15 & -v14;
  uint64_t v22 = v17;
  int v23 = *(void **)(v18 + 16);
  int64x2_t v24 = (int *)__p;
  int v25 = *((_DWORD *)__p + 1);
  unint64_t v104 = v17;
  int v26 = v17 + 1;
  while (1)
  {
    int v27 = v25 + v19;
    if (sub_1DC2FF924(v23, v102, v22) == a6 || v27 > v21) {
      break;
    }
    v24[1] = v25 + v19++ + 1;
    BOOL v96 = v22-- <= 0;
    if (v96) {
      goto LABEL_18;
    }
  }
  if (v27 > v21) {
    goto LABEL_18;
  }
  if ((v22 & 0x80000000) == 0)
  {
    int v29 = v26 - v19;
    do
    {
      if (sub_1DC2FF924(v23, v102, v22) != a6) {
        break;
      }
      if (*v24 > v21) {
        break;
      }
      ++*v24;
      --v22;
      --v29;
    }
    while (v29 > 0);
  }
  if (*v24 > v21) {
    goto LABEL_18;
  }
  LODWORD(v32) = v104 + 1;
  int v33 = v109;
  if ((int)v104 + 1 < v109)
  {
    int v34 = 0;
    uint64_t v32 = (int)v32;
    int v35 = v25 + v19;
    while (1)
    {
      int v27 = v35 + v34;
      if (sub_1DC2FF924(v23, v102, v32) == a6 || v27 > v21) {
        break;
      }
      v24[1] = v35 + v34 + 1;
      ++v32;
      if (~v104 + v109 == ++v34) {
        goto LABEL_18;
      }
    }
    int v33 = v109;
  }
  if (v33 == v32 || v27 > v21) {
    goto LABEL_18;
  }
  int v36 = v33 - v32;
  if (v33 > (int)v32)
  {
    uint64_t v32 = (int)v32;
    while (sub_1DC2FF924(v23, v102, v32) == a6)
    {
      int v37 = v24[2];
      if (v37 > v21) {
        break;
      }
      v24[2] = v37 + 1;
      ++v32;
      if (!--v36)
      {
        LODWORD(v32) = v109;
        break;
      }
    }
  }
  if (v24[2] > v21)
  {
LABEL_18:
    int v28 = v107;
    goto LABEL_19;
  }
  uint64_t v113 = 0;
  sub_1DC361CAC((uint64_t)&v112, v24);
  int v28 = v107;
  sub_1DC361CAC((uint64_t)&v112, (_DWORD *)__p + 1);
  sub_1DC361CAC((uint64_t)&v112, (_DWORD *)__p + 2);
  int64x2_t v24 = (int *)__p;
  if (sub_1DC39EF9C(v103, (int *)__p) <= -0.5) {
    goto LABEL_9;
  }
  float v38 = (float)(v32 - v24[2]) + (float)((float)v24[1] * -0.5);
  int v117 = v24;
  operator delete(v24);
  if (vabds_f32(v38, (float)v104) > *(float *)(v103 + 64)
    || (uint64_t v39 = (int *)v112,
        int v40 = *(_DWORD *)v112,
        int v41 = *((_DWORD *)v112 + 1),
        int v42 = *((_DWORD *)v112 + 2),
        float v43 = sub_1DC39EF9C(v103, *a3),
        (float)(v43 + sub_1DC39EF9C(v103, v39)) < -0.5))
  {
LABEL_20:
    *int v28 = 0;
    uint64_t v30 = v115;
    if (v115) {
      atomic_fetch_add_explicit(v115 + 2, 1u, memory_order_relaxed);
    }
    *int v28 = v30;
    goto LABEL_23;
  }
  __p = 0;
  int v117 = 0;
  uint64_t v118 = 0;
  memset(v111, 0, sizeof(v111));
  sub_1DC3556D4((char **)&__p, 3uLL);
  sub_1DC3556D4(v111, 3uLL);
  uint64_t v44 = 0;
  v45.i32[0] = v100;
  v45.i32[1] = v41 + v40 + v42;
  __asm { FMOV            V1.2S, #3.0 }
  float32x2_t v99 = vdiv_f32(vcvt_f32_s32(v45), _D1);
  uint64_t v51 = *(void **)(v103 + 16);
  uint64_t v52 = v51[7];
  uint64_t v53 = -v52;
  uint64_t v54 = v51[2];
  uint64_t v55 = v54 & -v52;
  LODWORD(v52) = v52 - 1;
  uint64_t v56 = v51[4];
  int v105 = v56 & v52 | v55;
  LODWORD(v57) = (int)v38;
  int v58 = a6 ^ 1;
  int v101 = v54 & v52 | v56 & v53;
  uint64_t v59 = (int *)__p;
  unint64_t v60 = (int *)v111[0];
  do
  {
    v59[v44] = 0;
    v60[v44++] = 0;
  }
  while (v44 != 3);
  uint64_t v61 = 1;
  unsigned int v62 = (int)v20;
  LODWORD(v63) = (int)v38;
  do
  {
    uint64_t v64 = v61;
    if ((v63 & 0x80000000) == 0 && (v62 & 0x80000000) == 0)
    {
      int v65 = v61 & 1;
      if ((int)v64 >= 0) {
        int v66 = v65;
      }
      else {
        int v66 = -v65;
      }
      uint64_t v67 = v62;
      uint64_t v63 = v63;
      while (1)
      {
        char v68 = sub_1DC2FF924(v51, v67, v63);
        if (v66 == v58)
        {
          if ((v68 & 1) == 0) {
            goto LABEL_63;
          }
        }
        else if (v68)
        {
LABEL_63:
          unsigned int v62 = v67;
          break;
        }
        ++v59[v64];
        unsigned int v62 = v67 - 1;
        BOOL v96 = v63-- < 1;
        if (!v96)
        {
          BOOL v96 = v67-- <= 0;
          if (!v96) {
            continue;
          }
        }
        break;
      }
    }
    uint64_t v61 = v64 - 1;
  }
  while (v64);
  LODWORD(v69) = v57 + 1;
  LODWORD(v70) = v102 + 1;
  uint64_t v71 = 1;
  LODWORD(v72) = v57 + 1;
  do
  {
    if ((int)v72 < v105 && (int)v70 < v101)
    {
      if ((int)v71 >= 0) {
        int v73 = v71 & 1;
      }
      else {
        int v73 = -(v71 & 1);
      }
      uint64_t v70 = (int)v70;
      uint64_t v72 = (int)v72;
      do
      {
        char v74 = sub_1DC2FF924(v51, v70, v72);
        if (v73 == v58)
        {
          if ((v74 & 1) == 0) {
            break;
          }
        }
        else if (v74)
        {
          break;
        }
        ++v59[v71];
        ++v72;
        ++v70;
      }
      while (v72 < v105 && v70 < v101);
    }
    ++v71;
  }
  while (v71 != 3);
  if (sub_1DC39EF9C(v103, v59) >= -0.5)
  {
    uint64_t v75 = 1;
    LODWORD(v76) = (int)v20;
    do
    {
      uint64_t v77 = v75;
      if ((v57 & 0x80000000) == 0 && (int)v76 < v101)
      {
        int v78 = v75 & 1;
        if ((int)v77 >= 0) {
          int v79 = v77 & 1;
        }
        else {
          int v79 = -v78;
        }
        uint64_t v76 = (int)v76;
        uint64_t v57 = v57;
        do
        {
          char v80 = sub_1DC2FF924(v51, v76, v57);
          if (v79 == v58)
          {
            if ((v80 & 1) == 0) {
              break;
            }
          }
          else if (v80)
          {
            break;
          }
          ++v60[v77];
          ++v76;
          BOOL v96 = v57-- < 1;
        }
        while (!v96 && v76 < v101);
      }
      uint64_t v75 = v77 - 1;
    }
    while (v77);
    unsigned int v81 = v102 - 1;
    for (uint64_t i = 1; i != 3; ++i)
    {
      if ((int)v69 < v105 && (v81 & 0x80000000) == 0)
      {
        if ((int)i >= 0) {
          int v83 = i & 1;
        }
        else {
          int v83 = -(i & 1);
        }
        uint64_t v84 = v81;
        uint64_t v69 = (int)v69;
        while (1)
        {
          char v85 = sub_1DC2FF924(v51, v84, v69);
          if (v83 == v58)
          {
            if ((v85 & 1) == 0) {
              goto LABEL_109;
            }
          }
          else if (v85)
          {
LABEL_109:
            unsigned int v81 = v84;
            break;
          }
          ++v60[i];
          ++v69;
          unsigned int v81 = v84 - 1;
          if (v69 < v105)
          {
            BOOL v96 = v84-- <= 0;
            if (!v96) {
              continue;
            }
          }
          break;
        }
      }
    }
  }
  float v86 = sub_1DC39EF9C(v103, v59);
  if ((float)((float)(v86 + sub_1DC39EF9C(v103, v60)) * 0.6) >= -0.5)
  {
    unint64_t v88 = *(void *)(*(void *)(v103 + 24) + 8) - **(void **)(v103 + 24);
    if ((int)(v88 >> 3) >= 1)
    {
      uint64_t v89 = 0;
      uint64_t v90 = (v88 >> 3);
      do
      {
        uint64_t v91 = *(void *)(**(void **)(v103 + 24) + 8 * v89);
        if (v91) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v91 + 8), 1u, memory_order_relaxed);
        }
        v110 = (atomic_uint *)v91;
        if (vabds_f32(v38, (*(float (**)(uint64_t))(*(void *)v91 + 24))(v91)) <= v99.f32[1]
          && vabds_f32(v20, (*(float (**)(uint64_t))(*(void *)v91 + 16))(v91)) <= v99.f32[0])
        {
          float v92 = *(float *)(v91 + 20);
          float v93 = *(float *)(v91 + 24);
          float v94 = vabds_f32(v99.f32[0], v92);
          float v95 = vabds_f32(v99.f32[1], v93);
          BOOL v96 = v94 > 1.0 || v95 > 1.0;
          if (!v96 || (v94 <= v92 ? (BOOL v97 = v95 > v93) : (BOOL v97 = 1), !v97))
          {
            unint64_t v98 = v110;
            (*(void (**)(atomic_uint *))(*(void *)v110 + 16))(v110);
            (*(void (**)(atomic_uint *))(*(void *)v98 + 24))(v98);
            operator new();
          }
        }
        sub_1DC39FBFC(&v110);
        ++v89;
      }
      while (v90 != v89);
    }
    operator new();
  }
  *unint64_t v107 = 0;
  uint64_t v87 = v115;
  if (v115) {
    atomic_fetch_add_explicit(v115 + 2, 1u, memory_order_relaxed);
  }
  *unint64_t v107 = v87;
  if (v60) {
    operator delete(v60);
  }
  if (__p) {
    operator delete(__p);
  }
LABEL_23:
  if (v112) {
    operator delete(v112);
  }
  return sub_1DC39FBFC(&v115);
}

void sub_1DC39FB80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, atomic_uint *a19, void *__p,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,atomic_uint *a26,void *a27,uint64_t a28)
{
  sub_1DC39FBFC(v28);
  sub_1DC39FBFC(&a19);
  if (__p) {
    operator delete(__p);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a23) {
    operator delete(a23);
  }
  sub_1DC39FBFC(&a26);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC39FBFC(atomic_uint **a1)
{
  int v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t sub_1DC39FC30(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = (uint64_t *)result;
  while (2)
  {
    int v10 = a2 - 1;
    int v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v11;
          uint64_t v12 = (char *)a2 - (char *)v11;
          unint64_t v13 = a2 - v11;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v41 = *v11;
                if (*(float *)(*v10 + 28) > *(float *)(*v11 + 28))
                {
                  *int v11 = *v10;
                  *int v10 = v41;
                }
                break;
              case 3uLL:
                __n128 result = (uint64_t)sub_1DC3A03EC(v11, v11 + 1, a2 - 1);
                break;
              case 4uLL:
                __n128 result = (uint64_t)sub_1DC3A0474(v11, v11 + 1, v11 + 2, a2 - 1);
                break;
              case 5uLL:
                int v42 = v11 + 1;
                float v43 = v11 + 2;
                uint64_t v44 = v11 + 3;
                __n128 result = (uint64_t)sub_1DC3A0474(v11, v11 + 1, v11 + 2, v11 + 3);
                uint64_t v45 = v11[3];
                if (*(float *)(*v10 + 28) > *(float *)(v45 + 28))
                {
                  *uint64_t v44 = *v10;
                  *int v10 = v45;
                  uint64_t v46 = *v44;
                  uint64_t v47 = *v43;
                  float v48 = *(float *)(*v44 + 28);
                  if (v48 > *(float *)(*v43 + 28))
                  {
                    *float v43 = v46;
                    *uint64_t v44 = v47;
                    uint64_t v49 = *v42;
                    if (v48 > *(float *)(*v42 + 28))
                    {
                      v11[1] = v46;
                      v11[2] = v49;
                      uint64_t v50 = *v11;
                      if (v48 > *(float *)(*v11 + 28))
                      {
                        *int v11 = v46;
                        v11[1] = v50;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 191)
          {
            uint64_t v51 = v11 + 1;
            BOOL v53 = v11 == a2 || v51 == a2;
            if (a4)
            {
              if (!v53)
              {
                uint64_t v54 = 8;
                uint64_t v55 = v11;
                do
                {
                  uint64_t v57 = *v55;
                  uint64_t v56 = v55[1];
                  uint64_t v55 = v51;
                  float v58 = *(float *)(v56 + 28);
                  if (v58 > *(float *)(v57 + 28))
                  {
                    uint64_t v59 = v54;
                    do
                    {
                      *(uint64_t *)((char *)v11 + v59) = v57;
                      uint64_t v60 = v59 - 8;
                      if (v59 == 8)
                      {
                        uint64_t v61 = v11;
                        goto LABEL_83;
                      }
                      uint64_t v57 = *(uint64_t *)((char *)v11 + v59 - 16);
                      v59 -= 8;
                    }
                    while (v58 > *(float *)(v57 + 28));
                    uint64_t v61 = (uint64_t *)((char *)v11 + v60);
LABEL_83:
                    uint64_t *v61 = v56;
                  }
                  uint64_t v51 = v55 + 1;
                  v54 += 8;
                }
                while (v55 + 1 != a2);
              }
            }
            else if (!v53)
            {
              do
              {
                uint64_t v90 = *v9;
                uint64_t v89 = v9[1];
                uint64_t v9 = v51;
                float v91 = *(float *)(v89 + 28);
                if (v91 > *(float *)(v90 + 28))
                {
                  do
                  {
                    *uint64_t v51 = v90;
                    uint64_t v90 = *(v51 - 2);
                    --v51;
                  }
                  while (v91 > *(float *)(v90 + 28));
                  *uint64_t v51 = v89;
                }
                uint64_t v51 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v62 = (v13 - 2) >> 1;
              int64_t v63 = v62;
              do
              {
                int64_t v64 = v63;
                if (v62 >= v63)
                {
                  uint64_t v65 = (2 * v63) | 1;
                  int v66 = &v11[v65];
                  if (2 * v64 + 2 < (uint64_t)v13 && *(float *)(*v66 + 28) > *(float *)(v66[1] + 28))
                  {
                    ++v66;
                    uint64_t v65 = 2 * v64 + 2;
                  }
                  uint64_t v67 = &v11[v64];
                  uint64_t v68 = *v66;
                  uint64_t v69 = *v67;
                  float v70 = *(float *)(*v67 + 28);
                  if (*(float *)(*v66 + 28) <= v70)
                  {
                    do
                    {
                      uint64_t v71 = v66;
                      *uint64_t v67 = v68;
                      if (v62 < v65) {
                        break;
                      }
                      uint64_t v72 = 2 * v65;
                      uint64_t v65 = (2 * v65) | 1;
                      int v66 = &v11[v65];
                      uint64_t v73 = v72 + 2;
                      if (v73 < (uint64_t)v13)
                      {
                        __n128 result = *v66;
                        if (*(float *)(*v66 + 28) > *(float *)(v66[1] + 28))
                        {
                          ++v66;
                          uint64_t v65 = v73;
                        }
                      }
                      uint64_t v68 = *v66;
                      uint64_t v67 = v71;
                    }
                    while (*(float *)(*v66 + 28) <= v70);
                    *uint64_t v71 = v69;
                  }
                }
                int64_t v63 = v64 - 1;
              }
              while (v64);
              uint64_t v74 = (unint64_t)v12 >> 3;
              do
              {
                uint64_t v75 = 0;
                uint64_t v76 = *v11;
                uint64_t v77 = v11;
                do
                {
                  int v78 = v77;
                  v77 += v75 + 1;
                  uint64_t v79 = 2 * v75;
                  uint64_t v75 = (2 * v75) | 1;
                  uint64_t v80 = v79 + 2;
                  if (v80 < v74 && *(float *)(*v77 + 28) > *(float *)(v77[1] + 28))
                  {
                    ++v77;
                    uint64_t v75 = v80;
                  }
                  *int v78 = *v77;
                }
                while (v75 <= (uint64_t)((unint64_t)(v74 - 2) >> 1));
                if (v77 == --a2)
                {
                  *uint64_t v77 = v76;
                }
                else
                {
                  *uint64_t v77 = *a2;
                  *a2 = v76;
                  uint64_t v81 = (char *)v77 - (char *)v11 + 8;
                  if (v81 >= 9)
                  {
                    unint64_t v82 = (((unint64_t)v81 >> 3) - 2) >> 1;
                    int v83 = &v11[v82];
                    uint64_t v84 = *v83;
                    uint64_t v85 = *v77;
                    float v86 = *(float *)(*v77 + 28);
                    if (*(float *)(*v83 + 28) > v86)
                    {
                      do
                      {
                        uint64_t v87 = v83;
                        *uint64_t v77 = v84;
                        if (!v82) {
                          break;
                        }
                        unint64_t v82 = (v82 - 1) >> 1;
                        int v83 = &v11[v82];
                        uint64_t v84 = *v83;
                        uint64_t v77 = v87;
                      }
                      while (*(float *)(*v83 + 28) > v86);
                      *uint64_t v87 = v85;
                    }
                  }
                }
              }
              while (v74-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          int v15 = &v11[v13 >> 1];
          if ((unint64_t)v12 >= 0x401)
          {
            sub_1DC3A03EC(v9, &v9[v13 >> 1], a2 - 1);
            sub_1DC3A03EC(v9 + 1, v15 - 1, a2 - 2);
            sub_1DC3A03EC(v9 + 2, &v9[v14 + 1], a2 - 3);
            __n128 result = (uint64_t)sub_1DC3A03EC(v15 - 1, v15, &v9[v14 + 1]);
            uint64_t v16 = *v9;
            *uint64_t v9 = *v15;
            *int v15 = v16;
          }
          else
          {
            __n128 result = (uint64_t)sub_1DC3A03EC(&v9[v13 >> 1], v9, a2 - 1);
          }
          --a3;
          uint64_t v17 = *v9;
          if (a4) {
            break;
          }
          float v18 = *(float *)(v17 + 28);
          if (*(float *)(*(v9 - 1) + 28) > v18) {
            goto LABEL_13;
          }
          if (v18 <= *(float *)(*v10 + 28))
          {
            int v33 = v9 + 1;
            do
            {
              int v11 = v33;
              if (v33 >= a2) {
                break;
              }
              ++v33;
            }
            while (v18 <= *(float *)(*v11 + 28));
          }
          else
          {
            int v11 = v9;
            do
            {
              uint64_t v32 = v11[1];
              ++v11;
            }
            while (v18 <= *(float *)(v32 + 28));
          }
          int v34 = a2;
          if (v11 < a2)
          {
            int v34 = a2;
            do
              uint64_t v35 = *--v34;
            while (v18 > *(float *)(v35 + 28));
          }
          if (v11 < v34)
          {
            uint64_t v36 = *v11;
            uint64_t v37 = *v34;
            do
            {
              *int v11 = v37;
              *int v34 = v36;
              do
              {
                uint64_t v38 = v11[1];
                ++v11;
                uint64_t v36 = v38;
              }
              while (v18 <= *(float *)(v38 + 28));
              do
              {
                uint64_t v39 = *--v34;
                uint64_t v37 = v39;
              }
              while (v18 > *(float *)(v39 + 28));
            }
            while (v11 < v34);
          }
          int v40 = v11 - 1;
          BOOL v4 = v11 - 1 >= v9;
          BOOL v5 = v11 - 1 == v9;
          if (v11 - 1 != v9) {
            *uint64_t v9 = *v40;
          }
          a4 = 0;
          *int v40 = v17;
        }
        float v18 = *(float *)(v17 + 28);
LABEL_13:
        int v19 = v9;
        do
        {
          float v20 = v19;
          uint64_t v22 = v19[1];
          ++v19;
          uint64_t v21 = v22;
        }
        while (*(float *)(v22 + 28) > v18);
        int v23 = a2;
        if (v20 == v9)
        {
          int v23 = a2;
          do
          {
            if (v19 >= v23) {
              break;
            }
            uint64_t v25 = *--v23;
          }
          while (*(float *)(v25 + 28) <= v18);
        }
        else
        {
          do
            uint64_t v24 = *--v23;
          while (*(float *)(v24 + 28) <= v18);
        }
        if (v19 < v23)
        {
          uint64_t v26 = *v23;
          int v27 = v19;
          int v28 = v23;
          do
          {
            *int v27 = v26;
            *int v28 = v21;
            do
            {
              float v20 = v27;
              uint64_t v29 = v27[1];
              ++v27;
              uint64_t v21 = v29;
            }
            while (*(float *)(v29 + 28) > v18);
            do
            {
              uint64_t v30 = *--v28;
              uint64_t v26 = v30;
            }
            while (*(float *)(v30 + 28) <= v18);
          }
          while (v27 < v28);
        }
        if (v20 != v9) {
          *uint64_t v9 = *v20;
        }
        *float v20 = v17;
        if (v19 >= v23) {
          break;
        }
LABEL_32:
        __n128 result = sub_1DC39FC30(v9, v20, a3, a4 & 1);
        a4 = 0;
        int v11 = v20 + 1;
      }
      BOOL v31 = sub_1DC3A050C(v9, v20);
      int v11 = v20 + 1;
      __n128 result = sub_1DC3A050C(v20 + 1, a2);
      if (result) {
        break;
      }
      if (!v31) {
        goto LABEL_32;
      }
    }
    a2 = v20;
    if (!v31) {
      continue;
    }
    return result;
  }
}

void sub_1DC3A0368(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (atomic_uint **)**a1;
  if (v2)
  {
    BOOL v4 = (atomic_uint **)v1[1];
    BOOL v5 = v2;
    if (v4 != v2)
    {
      do
        BOOL v4 = sub_1DC39FBFC(v4 - 1);
      while (v4 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_1DC3A03EC(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  float v5 = *(float *)(*a2 + 28);
  float v6 = *(float *)(*result + 28);
  uint64_t v7 = *a3;
  float v8 = *(float *)(*a3 + 28);
  if (v5 <= v6)
  {
    if (v8 > v5)
    {
      *a2 = v7;
      *a3 = v3;
      uint64_t v9 = *result;
      if (*(float *)(*a2 + 28) > *(float *)(*result + 28))
      {
        *__n128 result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 <= v5)
    {
      *__n128 result = v3;
      *a2 = v4;
      if (*(float *)(*a3 + 28) <= v6) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *__n128 result = v7;
    }
    *a3 = v4;
  }
  return result;
}

uint64_t *sub_1DC3A0474(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  __n128 result = sub_1DC3A03EC(a1, a2, a3);
  uint64_t v9 = *a3;
  if (*(float *)(*a4 + 28) > *(float *)(*a3 + 28))
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v10 = *a2;
    if (*(float *)(*a3 + 28) > *(float *)(*a2 + 28))
    {
      *a2 = *a3;
      *a3 = v10;
      uint64_t v11 = *a1;
      if (*(float *)(*a2 + 28) > *(float *)(*a1 + 28))
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

BOOL sub_1DC3A050C(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      if (*(float *)(v6 + 28) > *(float *)(*a1 + 28))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_1DC3A03EC(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1DC3A0474(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      float v18 = a1 + 1;
      int v19 = a1 + 2;
      float v20 = a1 + 3;
      sub_1DC3A0474(a1, a1 + 1, a1 + 2, a1 + 3);
      uint64_t v21 = *(a2 - 1);
      uint64_t v22 = a1[3];
      if (*(float *)(v21 + 28) > *(float *)(v22 + 28))
      {
        *float v20 = v21;
        *(a2 - 1) = v22;
        uint64_t v23 = *v20;
        uint64_t v24 = *v19;
        float v25 = *(float *)(*v20 + 28);
        if (v25 > *(float *)(*v19 + 28))
        {
          *int v19 = v23;
          *float v20 = v24;
          uint64_t v26 = *v18;
          if (v25 > *(float *)(*v18 + 28))
          {
            a1[1] = v23;
            a1[2] = v26;
            uint64_t v27 = *a1;
            if (v25 > *(float *)(*a1 + 28))
            {
              *a1 = v23;
              a1[1] = v27;
            }
          }
        }
      }
      return 1;
    default:
      float v8 = a1 + 2;
      sub_1DC3A03EC(a1, a1 + 1, a1 + 2);
      uint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = *v8;
    float v14 = *(float *)(*v9 + 28);
    if (v14 > *(float *)(*v8 + 28))
    {
      uint64_t v15 = v11;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15) = v13;
        uint64_t v16 = v15 - 8;
        if (v15 == 8) {
          break;
        }
        uint64_t v13 = *(uint64_t *)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 <= *(float *)(v13 + 28))
        {
          uint64_t v17 = (uint64_t *)((char *)a1 + v16);
          goto LABEL_13;
        }
      }
      uint64_t v17 = a1;
LABEL_13:
      uint64_t *v17 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    float v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

uint64_t sub_1DC3A0718(uint64_t a1, float *a2, int a3, float a4)
{
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  size_t v8 = 4 * a3;
  *(void *)(a1 + 48) = malloc_type_malloc(v8, 0x100004052888210uLL);
  *(void *)(a1 + 16) = malloc_type_malloc(v8, 0x100004052888210uLL);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 32) = 0;
  sub_1DC3A0830((uint64_t)a2, a3, 0, 0, *(void *)(a1 + 48));
  if (fabsf(a4 + -0.5) <= 0.001)
  {
    uint64_t v9 = *(float **)(a1 + 48);
  }
  else
  {
    uint64_t v9 = *(float **)(a1 + 48);
    if (a3 >= 1)
    {
      uint64_t v10 = 0;
      do
      {
        v9[v10] = (float)(0.5 / (float)(1.0 - a4)) * v9[v10];
        ++v10;
      }
      while (a3 != v10);
    }
  }
  uint64_t result = sub_1DC3A08BC(a3, a2, v9, *(void *)(a1 + 16));
  *(_DWORD *)(a1 + 24) = result;
  return result;
}

uint64_t sub_1DC3A0830(uint64_t result, int a2, uint64_t a3, int a4, uint64_t a5)
{
  if ((a4 & 0x80000000) == 0)
  {
    uint64_t v5 = 0;
    int v6 = 0;
    do
    {
      float v7 = (float)a2;
      if (v5 != a4) {
        float v7 = ceilf(*(float *)(a3 + 4 * v5));
      }
      int v8 = (int)v7;
      int v9 = (int)v7 - v6;
      if ((int)v7 > v6)
      {
        uint64_t v10 = v8 - (uint64_t)v6;
        uint64_t v11 = 4 * v6;
        uint64_t v12 = (float *)(result + v11);
        float v13 = 0.0;
        uint64_t v14 = v10;
        do
        {
          float v15 = *v12++;
          float v13 = v13 + v15;
          --v14;
        }
        while (v14);
        float v16 = v13 / (float)v9;
        uint64_t v17 = (float *)(a5 + v11);
        do
        {
          *v17++ = v16;
          --v10;
        }
        while (v10);
      }
      ++v5;
      int v6 = v8;
    }
    while (v5 != a4 + 1);
  }
  return result;
}

uint64_t sub_1DC3A08BC(int a1, float *a2, float *a3, uint64_t a4)
{
  if (a1 < 2) {
    return 0;
  }
  uint64_t result = 0;
  float v6 = *a2 - *a3;
  BOOL v7 = v6 > 0.0;
  for (uint64_t i = 1; i != a1; ++i)
  {
    float v9 = a2[i] - a3[i];
    if (v7 != v9 > 0.0)
    {
      *(float *)(a4 + 4 * (int)result) = (float)((float)(v9 / (float)(v6 - v9)) + (float)(int)i) + 0.5;
      uint64_t result = (result + 1);
      BOOL v7 = v9 > 0.0;
    }
    float v6 = v9;
  }
  return result;
}

uint64_t sub_1DC3A0948(uint64_t a1, float a2)
{
  if (a2 < 0.5) {
    return 0xFFFFFFFFLL;
  }
  float v4 = a2 * 0.4;
  int v5 = (int)(float)((float)(a2 * 0.4) * 6.0);
  int v6 = v5 | 1;
  if (*(_DWORD *)(a1 + 8) < (v5 | 1)) {
    return 0xFFFFFFFFLL;
  }
  BOOL v7 = *(void **)(a1 + 32);
  if (v7 && (*(_DWORD *)(a1 + 40) == v6 || (free(v7), *(void *)(a1 + 32))))
  {
    int v8 = *(void **)(a1 + 56);
  }
  else
  {
    *(_DWORD *)(a1 + 40) = v6;
    float v9 = (float *)malloc_type_malloc(4 * v6, 0x100004052888210uLL);
    uint64_t v10 = v9;
    *(void *)(a1 + 32) = v9;
    if (v5 >= 0) {
      int v11 = v5 | 1;
    }
    else {
      int v11 = v6 + 1;
    }
    uint64_t v12 = (v11 >> 1);
    v9[(int)v12] = 1.0;
    float v13 = 1.0;
    if (v6 >= 2)
    {
      float v14 = (float)(v4 * v4) + (float)(v4 * v4);
      int v15 = v6 - 1;
      float v16 = v9;
      do
      {
        float v17 = expf((float)-(float)((float)(int)v12 * (float)(int)v12) / v14);
        v10[v15] = v17;
        *v16++ = v17;
        float v13 = v13 + (float)(v17 + v17);
        --v15;
        --v12;
      }
      while (v12);
    }
    if ((v5 & 0x80000000) == 0)
    {
      uint64_t v18 = v5 | 1u;
      do
      {
        *uint64_t v10 = *v10 / v13;
        ++v10;
        --v18;
      }
      while (v18);
    }
    int v8 = malloc_type_malloc(4 * *(int *)(a1 + 8), 0x100004052888210uLL);
    *(void *)(a1 + 56) = v8;
  }
  sub_1DC3A0830(*(void *)a1, *(_DWORD *)(a1 + 8), *(void *)(a1 + 16), *(_DWORD *)(a1 + 24), (uint64_t)v8);
  int v19 = *(_DWORD *)(a1 + 8);
  float v20 = *(float **)(a1 + 48);
  if (v19 >= 1)
  {
    uint64_t v21 = *(float **)(a1 + 56);
    uint64_t v22 = *(float **)(a1 + 48);
    uint64_t v23 = *(unsigned int *)(a1 + 8);
    do
    {
      float v24 = *v21++;
      *uint64_t v22 = (float)(v24 * 0.4) + (float)(*v22 * 0.6);
      ++v22;
      --v23;
    }
    while (v23);
  }
  if (v6 >= 0) {
    int v25 = v6;
  }
  else {
    int v25 = v6 + 1;
  }
  vDSP_conv(v20, 1, *(const float **)(a1 + 32), 1, v20, 1, v19 - v6 + 1, v6);
  LODWORD(v26) = v19 + ~(v25 >> 1);
  if ((int)v26 >= v25 >> 1)
  {
    uint64_t v26 = (int)v26;
    uint64_t v27 = v25 >> 1;
    do
      v20[v26] = v20[v26 - v27];
    while (v26-- > v27);
  }
  uint64_t result = sub_1DC3A08BC(*(_DWORD *)(a1 + 8), *(float **)a1, *(float **)(a1 + 48), *(void *)(a1 + 16));
  *(_DWORD *)(a1 + 24) = result;
  return result;
}

void sub_1DC3A0B9C(uint64_t a1)
{
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 16));
  free(*(void **)(a1 + 32));
  int v2 = *(void **)(a1 + 56);
  free(v2);
}

std::logic_error *sub_1DC3A0BE8(std::logic_error *a1)
{
  uint64_t result = std::logic_error::logic_error(a1, "Unsupported rotation");
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4E8] + 16);
  return result;
}

void sub_1DC3A0C24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (*a5)
  {
    (*(void (**)(void))(*(void *)*a5 + 16))(*a5);
    (*(void (**)(void))(*(void *)*a5 + 24))();
  }
  else
  {
    (*(void (**)(void))(**(void **)a3 + 16))();
    (*(float (**)(void))(**(void **)a2 + 16))();
    (*(float (**)(void))(**(void **)a4 + 16))();
    (*(void (**)(void))(**(void **)a3 + 24))();
    (*(float (**)(void))(**(void **)a2 + 24))();
    (*(float (**)(void))(**(void **)a4 + 24))();
  }
  (*(void (**)(void))(**(void **)a2 + 16))();
  (*(void (**)(void))(**(void **)a2 + 24))();
  (*(void (**)(void))(**(void **)a3 + 16))();
  (*(void (**)(void))(**(void **)a3 + 24))();
  (*(void (**)(void))(**(void **)a4 + 16))();
  (*(void (**)(void))(**(void **)a4 + 24))();
  sub_1DC353CE0();
}

void sub_1DC3A0F50(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661868;
  uint64_t v1 = (atomic_uint **)(a1 + 16);
  sub_1DC3122B8((atomic_uint **)(a1 + 24));
  sub_1DC2FF548(v1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC3A0FC4(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661868;
  int v2 = (atomic_uint **)(a1 + 16);
  sub_1DC3122B8((atomic_uint **)(a1 + 24));
  sub_1DC2FF548(v2);
  return a1;
}

uint64_t sub_1DC3A1018(uint64_t a1, uint64_t *a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661868;
  *(void *)(a1 + 16) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 8), 1u, memory_order_relaxed);
    float v4 = *(atomic_uint **)(a1 + 16);
    if (v4) {
      sub_1DC2FF57C(v4);
    }
  }
  *(void *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = 0;
  return a1;
}

atomic_uint **sub_1DC3A1084(void *a1, uint64_t a2, uint64_t a3, float *a4, int *a5)
{
  float v9 = *(void **)a3;
  int v10 = *(unsigned __int8 *)(*(void *)a3 + 52);
  int v11 = *(unsigned __int8 *)(*(void *)a3 + 53);
  uint64_t v12 = *(void *)(*(void *)a3 + 24);
  if (v12)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v12 + 8), 1u, memory_order_relaxed);
    float v9 = *(void **)a3;
  }
  uint64_t v84 = (atomic_uint *)v12;
  uint64_t v13 = v9[4];
  if (v13)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v13 + 8), 1u, memory_order_relaxed);
    float v9 = *(void **)a3;
  }
  int v83 = (atomic_uint *)v13;
  uint64_t v14 = v9[2];
  if (v14)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v14 + 8), 1u, memory_order_relaxed);
    float v9 = *(void **)a3;
  }
  unint64_t v82 = (atomic_uint *)v14;
  int v15 = (atomic_uint *)v9[5];
  if (v15) {
    atomic_fetch_add_explicit(v15 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v81 = v15;
  if (*(float *)(v12 + 20) < 1.0 || *(float *)(v13 + 20) < 1.0 || *(float *)(v14 + 20) < 1.0)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    sub_1DC379B70(exception, "bad module size");
    void *exception = &unk_1F36611E0;
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)(v12 + 8), 1u, memory_order_relaxed);
  uint64_t v79 = (atomic_uint *)v13;
  uint64_t v80 = (atomic_uint *)v12;
  atomic_fetch_add_explicit((atomic_uint *volatile)(v13 + 8), 1u, memory_order_relaxed);
  atomic_fetch_add_explicit((atomic_uint *volatile)(v14 + 8), 1u, memory_order_relaxed);
  int v78 = (atomic_uint *)v14;
  atomic_fetch_add_explicit((atomic_uint *volatile)(v12 + 8), 1u, memory_order_relaxed);
  v74[0] = (atomic_uint *)v12;
  atomic_fetch_add_explicit((atomic_uint *volatile)(v13 + 8), 1u, memory_order_relaxed);
  v93[0] = (atomic_uint *)v13;
  sub_1DC3A64CC(a2, (uint64_t)v74, (uint64_t *)v93, v10 != 0, v11 != 0);
  float v17 = v16;
  sub_1DC2FFD08(v93);
  sub_1DC2FFD08(v74);
  uint64_t v18 = v80;
  if (v80) {
    atomic_fetch_add_explicit(v80 + 2, 1u, memory_order_relaxed);
  }
  float v92 = v18;
  int v19 = v78;
  if (v78) {
    atomic_fetch_add_explicit(v78 + 2, 1u, memory_order_relaxed);
  }
  *(void *)int buf = v19;
  sub_1DC3A64CC(a2, (uint64_t)&v92, (uint64_t *)buf, v10 != 0, v11 != 0);
  float v21 = v20;
  sub_1DC2FFD08((atomic_uint **)buf);
  sub_1DC2FFD08(&v92);
  float v22 = (float)(v17 + v21) * 0.5;
  sub_1DC2FFD08(&v78);
  sub_1DC2FFD08(&v79);
  sub_1DC2FFD08(&v80);
  uint64_t v23 = v84;
  if (v84) {
    atomic_fetch_add_explicit(v84 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v77 = v23;
  float v24 = v83;
  if (v83) {
    atomic_fetch_add_explicit(v83 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v76 = v24;
  int v25 = v82;
  if (v82) {
    atomic_fetch_add_explicit(v82 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v75 = v25;
  float v26 = v17;
  if (v23) {
    atomic_fetch_add_explicit(v23 + 2, 1u, memory_order_relaxed);
  }
  v74[0] = v23;
  if (v24) {
    atomic_fetch_add_explicit(v24 + 2, 1u, memory_order_relaxed);
  }
  v93[0] = v24;
  float v27 = sub_1DC3A8110(v74, (uint64_t)v93);
  sub_1DC2FFD08(v93);
  sub_1DC2FFD08(v74);
  int v28 = v77;
  if (v77) {
    atomic_fetch_add_explicit(v77 + 2, 1u, memory_order_relaxed);
  }
  float v92 = v28;
  uint64_t v29 = v75;
  if (v75) {
    atomic_fetch_add_explicit(v75 + 2, 1u, memory_order_relaxed);
  }
  *(void *)int buf = v29;
  float v30 = sub_1DC3A8110(&v92, (uint64_t)buf);
  sub_1DC2FFD08((atomic_uint **)buf);
  sub_1DC2FFD08(&v92);
  unsigned int v31 = llroundf(v27 / v26);
  unsigned int v32 = llroundf(v30 / v21);
  if ((int)(v31 - v32) >= 0) {
    unsigned int v33 = v31 - v32;
  }
  else {
    unsigned int v33 = v32 - v31;
  }
  if (v33 > 8) {
    goto LABEL_34;
  }
  float v73 = v22;
  BOOL v35 = __OFADD__(v32, v31);
  int v36 = v32 + v31;
  if (v36 < 0 != v35) {
    int v37 = v36 + 1;
  }
  else {
    int v37 = v36;
  }
  float v38 = (*(float (**)(atomic_uint *))(*(void *)v77 + 16))(v77);
  int v39 = v37 >> 1;
  float v40 = (float)(v37 >> 1);
  if (vabds_f32(v38, (*(float (**)(atomic_uint *))(*(void *)v76 + 16))(v76)) < v40)
  {
    float v41 = (*(float (**)(atomic_uint *))(*(void *)v77 + 16))(v77);
    if (vabds_f32(v41, (*(float (**)(atomic_uint *))(*(void *)v75 + 16))(v75)) < v40) {
      goto LABEL_48;
    }
  }
  float v42 = (*(float (**)(atomic_uint *))(*(void *)v77 + 24))(v77);
  if (vabds_f32(v42, (*(float (**)(atomic_uint *))(*(void *)v76 + 24))(v76)) < v40)
  {
    float v43 = (*(float (**)(atomic_uint *))(*(void *)v77 + 24))(v77);
    if (vabds_f32(v43, (*(float (**)(atomic_uint *))(*(void *)v75 + 24))(v75)) < v40) {
      goto LABEL_48;
    }
  }
  uint64_t v44 = v76;
  if (v76) {
    atomic_fetch_add_explicit(v76 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v90 = v44;
  uint64_t v45 = v75;
  if (v75) {
    atomic_fetch_add_explicit(v75 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v89 = v45;
  float v46 = sub_1DC3A8110(&v90, (uint64_t)&v89);
  sub_1DC2FFD08(&v89);
  sub_1DC2FFD08(&v90);
  if (v46 < v40) {
    goto LABEL_48;
  }
  float v72 = (*(float (**)(atomic_uint *))(*(void *)v77 + 16))(v77);
  float v71 = (*(float (**)(atomic_uint *))(*(void *)v76 + 24))(v76);
  float v70 = (*(float (**)(atomic_uint *))(*(void *)v76 + 16))(v76);
  float v69 = (*(float (**)(atomic_uint *))(*(void *)v75 + 24))(v75);
  float v68 = (*(float (**)(atomic_uint *))(*(void *)v77 + 24))(v77);
  float v67 = (*(float (**)(atomic_uint *))(*(void *)v75 + 16))(v75);
  float v66 = (*(float (**)(atomic_uint *))(*(void *)v77 + 16))(v77);
  float v47 = (*(float (**)(atomic_uint *))(*(void *)v75 + 24))(v75);
  float v48 = (*(float (**)(atomic_uint *))(*(void *)v77 + 24))(v77);
  float v49 = (*(float (**)(atomic_uint *))(*(void *)v76 + 16))(v76);
  float v50 = (*(float (**)(atomic_uint *))(*(void *)v76 + 24))(v76);
  if (fabsf((float)((float)((float)((float)((float)(v70 * v69) + (float)(v72 * v71)) + (float)(v68 * v67))- (float)(v66 * v47))- (float)(v48 * v49))- (float)(v50 * (*(float (**)(atomic_uint *))(*(void *)v75 + 16))(v75))) >= (float)(v39 * v39))
  {
    int v34 = v39 + 7;
    int v52 = v34 & 3;
    if (v33 > 4 || v52 == 3)
    {
      BOOL v53 = v77;
      if (v77) {
        atomic_fetch_add_explicit(v77 + 2, 1u, memory_order_relaxed);
      }
      unint64_t v88 = v53;
      uint64_t v54 = v76;
      float v22 = v73;
      if (v76) {
        atomic_fetch_add_explicit(v76 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v87 = v54;
      float v55 = sub_1DC3A5C9C(a2, (uint64_t)&v88, (uint64_t)&v87, v26);
      sub_1DC2FFD08(&v87);
      sub_1DC2FFD08(&v88);
      uint64_t v56 = v77;
      if (v77) {
        atomic_fetch_add_explicit(v77 + 2, 1u, memory_order_relaxed);
      }
      float v86 = v56;
      uint64_t v57 = v75;
      if (v75) {
        atomic_fetch_add_explicit(v75 + 2, 1u, memory_order_relaxed);
      }
      uint64_t v85 = v57;
      float v58 = sub_1DC3A5C9C(a2, (uint64_t)&v86, (uint64_t)&v85, v21);
      sub_1DC2FFD08(&v85);
      sub_1DC2FFD08(&v86);
      unsigned int v59 = llroundf(v27 / v55);
      unsigned int v60 = llroundf(v30 / v58);
      if ((int)(v59 - v60) >= 0) {
        unsigned int v61 = v59 - v60;
      }
      else {
        unsigned int v61 = v60 - v59;
      }
      BOOL v62 = v33 > 4 && v61 > 8;
      char v63 = v62;
      if (!v62 && v61 <= v33)
      {
        BOOL v35 = __OFADD__(v60, v59);
        int v64 = v60 + v59;
        if (v64 < 0 != v35) {
          ++v64;
        }
        int v34 = (v64 >> 1) + 7;
        int v52 = v34 & 3;
      }
      if (v63)
      {
LABEL_34:
        int v34 = -1;
        goto LABEL_49;
      }
    }
    else
    {
      float v22 = v73;
    }
    switch(v52)
    {
      case 3:
        v34 -= 2;
        break;
      case 2:
        --v34;
        break;
      case 0:
        ++v34;
        break;
    }
  }
  else
  {
LABEL_48:
    int v34 = -1;
    float v22 = v73;
  }
LABEL_49:
  sub_1DC2FFD08(&v75);
  sub_1DC2FFD08(&v76);
  sub_1DC2FFD08(&v77);
  sub_1DC3AC32C((v34 - 17) >> 2);
  *a1 = 0;
  v93[0] = 0;
  if (v81) {
    operator new();
  }
  sub_1DC39FBFC(v93);
  *a4 = v22;
  *a5 = v34;
  sub_1DC35D870(&v81);
  sub_1DC35D870(&v82);
  sub_1DC35D870(&v83);
  return sub_1DC35D870(&v84);
}

void sub_1DC3A1F98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,atomic_uint *a33,atomic_uint *a34,atomic_uint *a35,uint64_t a36,uint64_t a37,uint64_t a38,atomic_uint *a39,atomic_uint *a40)
{
  sub_1DC2FFD08((atomic_uint **)(v40 - 224));
  sub_1DC2FFD08((atomic_uint **)(v40 - 216));
  sub_1DC2FFD08(&a33);
  sub_1DC2FFD08(&a34);
  sub_1DC2FFD08(&a35);
  sub_1DC35D870(&a39);
  sub_1DC35D870(&a40);
  sub_1DC35D870((atomic_uint **)(v40 - 240));
  sub_1DC35D870((atomic_uint **)(v40 - 232));
  _Unwind_Resume(a1);
}

void sub_1DC3A21AC(float a1, uint64_t a2, void *a3, uint64_t a4, unsigned int a5, atomic_uint **a6)
{
  v82[7] = *(atomic_uint **)MEMORY[0x1E4F143B8];
  float v9 = *(void **)a4;
  int v10 = *(atomic_uint **)(*(void *)a4 + 24);
  if (v10)
  {
    atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
    float v9 = *(void **)a4;
  }
  uint64_t v74 = v10;
  int v11 = (atomic_uint *)v9[4];
  if (v11)
  {
    atomic_fetch_add_explicit(v11 + 2, 1u, memory_order_relaxed);
    float v9 = *(void **)a4;
  }
  float v73 = v11;
  uint64_t v12 = (atomic_uint *)v9[2];
  if (v12)
  {
    atomic_fetch_add_explicit(v12 + 2, 1u, memory_order_relaxed);
    float v9 = *(void **)a4;
  }
  float v72 = v12;
  uint64_t v13 = v9[5];
  if (v13) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v13 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v70 = 0;
  uint64_t v71 = v13;
  if ((a5 & 0x80000003) == 1)
  {
    uint64_t v14 = *(void *)(sub_1DC3AC32C((int)(a5 - 17) >> 2) + 16);
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    float v67 = 0;
    sub_1DC320BFC(&v67, *(const void **)v14, *(void *)(v14 + 8), (uint64_t)(*(void *)(v14 + 8) - *(void *)v14) >> 2);
    unint64_t v15 = (unint64_t)(v68 - (void)v67) >> 2;
    if ((int)v15 <= 0) {
      int v16 = 0;
    }
    else {
      int v16 = v15 * v15 - 3;
    }
    memset(v66, 0, sizeof(v66));
    unint64_t v17 = 2 * v16;
    sub_1DC37E438(v66, v17);
    LODWORD(v76) = -1082130432;
    sub_1DC32021C(&v65, v17, &v76);
    LODWORD(v76) = -1082130432;
    sub_1DC32021C(&__p, v17, &v76);
    if (v16 >= 1)
    {
      uint64_t v18 = *a6;
      if (*a6)
      {
        atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
        BOOL v62 = v18;
        sub_1DC3A3758(&v67, (uint64_t)v66, (uint64_t)&v62, (char *)&v65);
        sub_1DC34E8D0(&v62);
      }
      else
      {
        uint64_t v76 = 0;
        int v19 = v74;
        if (v74) {
          atomic_fetch_add_explicit(v74 + 2, 1u, memory_order_relaxed);
        }
        unsigned int v61 = v19;
        float v20 = v73;
        if (v73) {
          atomic_fetch_add_explicit(v73 + 2, 1u, memory_order_relaxed);
        }
        unsigned int v60 = v20;
        float v21 = v72;
        if (v72) {
          atomic_fetch_add_explicit(v72 + 2, 1u, memory_order_relaxed);
        }
        float v58 = 0;
        unsigned int v59 = v21;
        (*(void (**)(atomic_uint **__return_ptr, void *, atomic_uint **, atomic_uint **, atomic_uint **, atomic_uint **, void))(*a3 + 16))(v82, a3, &v61, &v60, &v59, &v58, a5);
        sub_1DC2FFD08(&v58);
        sub_1DC2FFD08(&v59);
        sub_1DC2FFD08(&v60);
        sub_1DC2FFD08(&v61);
        float v22 = v82[0];
        if (v82[0]) {
          atomic_fetch_add_explicit(v82[0] + 2, 1u, memory_order_relaxed);
        }
        uint64_t v57 = v22;
        sub_1DC3A3758(&v67, (uint64_t)v66, (uint64_t)&v57, (char *)&v65);
        sub_1DC34E8D0(&v57);
        sub_1DC30184C(v82);
        sub_1DC39FBFC((atomic_uint **)&v76);
      }
      float v23 = a1 * 3.0;
      float v24 = *(float *)v65;
      float v25 = *((float *)v65 + 1);
      v82[3] = (atomic_uint *)0x500000003;
      int v26 = (int)v25;
      int v27 = (int)(float)((float)3 * a1);
      uint64_t v28 = a3[2];
      uint64_t v29 = *(void *)(v28 + 56);
      uint64_t v30 = -v29;
      uint64_t v31 = *(void *)(v28 + 32);
      int v32 = v31 & -(int)v29;
      int v33 = v29 - 1;
      uint64_t v34 = *(void *)(v28 + 16);
      int v35 = (v34 & v33 | v32) - 1;
      if (v27 + (int)v24 < v35) {
        int v35 = v27 + (int)v24;
      }
      if (v23 <= (float)(v35 - (((int)v24 - v27) & ~(((int)v24 - v27) >> 31))))
      {
        int v36 = (v26 - v27) & ~((v26 - v27) >> 31);
        int v37 = (v31 & v33 | v34 & v30) - 1;
        int v38 = v27 + v26;
        if (v38 >= v37) {
          int v38 = v37;
        }
        if (v23 <= (float)(v38 - v36))
        {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v28 + 8), 1u, memory_order_relaxed);
          uint64_t v75 = v28;
          LODWORD(v77) = 0;
          uint64_t v76 = (atomic_uint **)&unk_1F3661828;
          int v78 = 0;
          atomic_fetch_add_explicit((atomic_uint *volatile)(v28 + 8), 1u, memory_order_relaxed);
          if (v78) {
            sub_1DC2FF57C(v78);
          }
          int v78 = (atomic_uint *)v28;
          operator new();
        }
      }
      exception = __cxa_allocate_exception(0x20uLL);
      sub_1DC379B70(exception, "region too small to hold alignment pattern");
      void *exception = &unk_1F36611E0;
      __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
    }
    if (v70) {
      unint64_t v40 = 4;
    }
    else {
      unint64_t v40 = 3;
    }
    sub_1DC34AB34(&v76, v40);
    float v41 = v76;
    float v42 = v72;
    if (v72) {
      atomic_fetch_add_explicit(v72 + 2, 1u, memory_order_relaxed);
    }
    float v43 = (atomic_uint *)v41;
    if (*v41)
    {
      sub_1DC2FF57C(*v41);
      float v43 = (atomic_uint *)v76;
    }
    *float v41 = v42;
    uint64_t v44 = v74;
    if (v74) {
      atomic_fetch_add_explicit(v74 + 2, 1u, memory_order_relaxed);
    }
    uint64_t v45 = (atomic_uint *)*((void *)v43 + 1);
    float v46 = v43;
    if (v45)
    {
      sub_1DC2FF57C(v45);
      float v46 = (atomic_uint *)v76;
    }
    *((void *)v43 + 1) = v44;
    float v47 = v73;
    if (v73) {
      atomic_fetch_add_explicit(v73 + 2, 1u, memory_order_relaxed);
    }
    float v48 = (atomic_uint *)*((void *)v46 + 2);
    if (v48) {
      sub_1DC2FF57C(v48);
    }
    *((void *)v46 + 2) = v47;
    uint64_t v49 = v70;
    if (v70)
    {
      float v50 = (atomic_uint *)v76;
      atomic_fetch_add_explicit((atomic_uint *volatile)(v70 + 8), 1u, memory_order_relaxed);
      uint64_t v51 = (atomic_uint *)*((void *)v50 + 3);
      if (v51) {
        sub_1DC2FF57C(v51);
      }
      *((void *)v50 + 3) = v49;
    }
    else if (v71)
    {
      operator new();
    }
    uint64_t v79 = 0;
    uint64_t v80 = 0;
    unint64_t v81 = 0;
    int v52 = (void *)sub_1DC3A39D4(&v79, (uint64_t)v66);
    BOOL v53 = v52;
    uint64_t v80 = v52;
    if ((unint64_t)v52 >= v81)
    {
      uint64_t v54 = sub_1DC3A39D4(&v79, (uint64_t)&__p);
    }
    else
    {
      *int v52 = 0;
      v52[1] = 0;
      v52[2] = 0;
      sub_1DC3219D0(v52, __p, v64, (v64 - (uint64_t)__p) >> 2);
      uint64_t v54 = (uint64_t)(v53 + 3);
    }
    uint64_t v80 = (void *)v54;
    operator new();
  }
  float v55 = __cxa_allocate_exception(0x20uLL);
  sub_1DC379B70(v55, "Dimension must be 1 mod 4");
  void *v55 = &unk_1F36611E0;
  __cxa_throw(v55, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
}

void sub_1DC3A304C()
{
  __cxa_end_catch();
  if (v0) {
    operator delete(v0);
  }
  if (v1) {
    operator delete(v1);
  }
  if (v2) {
    operator delete(v2);
  }
  if (v3) {
    operator delete(v3);
  }
  JUMPOUT(0x1DC3A3728);
}

void sub_1DC3A3058()
{
  sub_1DC39FBFC((atomic_uint **)(v0 - 232));
  *(void *)(v0 - 232) = &STACK[0x208];
  sub_1DC2FFC48((void ***)(v0 - 232));
  JUMPOUT(0x1DC3A36E4);
}

void sub_1DC3A306C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,atomic_uint *a50)
{
  sub_1DC34E8D0(&a50);
  sub_1DC30184C((atomic_uint **)(v50 - 200));
  sub_1DC39FBFC((atomic_uint **)&STACK[0x208]);
  if (v51) {
    operator delete(v51);
  }
  if (v52) {
    operator delete(v52);
  }
  if (v53) {
    operator delete(v53);
  }
  if (v54) {
    operator delete(v54);
  }
  JUMPOUT(0x1DC3A3728);
}

void sub_1DC3A30B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,atomic_uint *a55)
{
  sub_1DC34E8D0(&a55);
  if (v55) {
    operator delete(v55);
  }
  if (v56) {
    operator delete(v56);
  }
  if (v57) {
    operator delete(v57);
  }
  if (v58) {
    operator delete(v58);
  }
  JUMPOUT(0x1DC3A3728);
}

void sub_1DC3A30C4()
{
  MEMORY[0x1E019CE90](v0, 0x1081C40ABB4582ELL);
  *(void *)(v1 - 232) = &STACK[0x208];
  sub_1DC2FFC48(v1 - 232);
  JUMPOUT(0x1DC3A36E4);
}

void sub_1DC3A30E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void **a40)
{
  *(void *)(v41 - 224) = v40;
  a40 = (void **)(v41 - 232);
  sub_1DC2FF82C(&a40);
  *(void *)(v41 - 232) = &STACK[0x208];
  sub_1DC2FFC48((void ***)(v41 - 232));
  JUMPOUT(0x1DC3A36E4);
}

void sub_1DC3A30F0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  sub_1DC39FBFC(&v3);
  sub_1DC35D870(&v4);
  sub_1DC35D870(&v5);
  sub_1DC35D870(&v6);
  sub_1DC35D870(&v7);
  _Unwind_Resume(a1);
}

void sub_1DC3A3100(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10, uint64_t a11, int a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,uint64_t a33,atomic_uint *a34,atomic_uint *a35,atomic_uint *a36,atomic_uint *a37,atomic_uint *a38,atomic_uint *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  if (a2)
  {
    sub_1DC34E8D0(&a38);
    sub_1DC30184C((atomic_uint **)(v73 - 176));
    sub_1DC2FFD08(&a34);
    sub_1DC2FFD08(&a35);
    sub_1DC2FFD08(&a36);
    sub_1DC2FFD08(&a37);
    sub_1DC36176C(&a39);
    __cxa_begin_catch(a1);
    int v76 = sub_1DC3A3CDC((uint64_t)&a62, &a56);
    int v77 = v76;
    if (v74 > 2.5 && v72 <= 1)
    {
      if (qword_1EBFFC220 != -1) {
        dispatch_once(&qword_1EBFFC220, &unk_1F3662588);
      }
      int v78 = qword_1EBFFC288;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC288, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)(v73 - 176) = 0;
        _os_log_debug_impl(&dword_1DC2FE000, v78, OS_LOG_TYPE_DEBUG, "QR with 0 or 1 alignment pattern: try to search 12 finder pattern corners and estimate polynomial transform.", (uint8_t *)(v73 - 176), 2u);
      }
      *(void *)(v73 - 176) = 0;
      *(void *)(v73 - 168) = 0;
      *(void *)(v73 - 160) = 0;
      __p = 0;
      a32 = 0;
      a33 = 0;
      uint64_t v79 = *(void *)(a15 + 16);
      if (v79) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v79 + 8), 1u, memory_order_relaxed);
      }
      a30 = v79;
      uint64_t v80 = *a10;
      if (*a10) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v80 + 8), 1u, memory_order_relaxed);
      }
      a29 = v80;
      int v81 = sub_1DC3A411C(&a30, &a29);
      sub_1DC385238((atomic_uint **)&a29);
      sub_1DC2FF548((atomic_uint **)&a30);
      if (v81 <= 8)
      {
        uint64_t v82 = a72;
        if (a72) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(a72 + 8), 1u, memory_order_relaxed);
        }
        a28 = v82;
        uint64_t v83 = a71;
        if (a71) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(a71 + 8), 1u, memory_order_relaxed);
        }
        a27 = v83;
        uint64_t v84 = a70;
        if (a70) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(a70 + 8), 1u, memory_order_relaxed);
        }
        a26 = v84;
        sub_1DC3A5078(v73 - 176, (uint64_t)&__p, (uint64_t)&a28, (uint64_t)&a27, &a26, a12);
        sub_1DC2FFD08((atomic_uint **)&a26);
        sub_1DC2FFD08((atomic_uint **)&a27);
        sub_1DC2FFD08((atomic_uint **)&a28);
      }
      if (v77 == 1)
      {
        uint64_t v85 = a68;
        if (a68) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(a68 + 8), 1u, memory_order_relaxed);
        }
        a25 = v85;
        sub_1DC3A5248(v73 - 176, (uint64_t)&__p, (uint64_t)&a25, a12);
        sub_1DC39FBFC((atomic_uint **)&a25);
      }
      sub_1DC3A5588();
    }
    if (v72 == 6 && v76 >= 4)
    {
      if (qword_1EBFFC220 != -1) {
        dispatch_once(&qword_1EBFFC220, &unk_1F3662588);
      }
      float v86 = qword_1EBFFC288;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC288, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)(v73 - 176) = 67240192;
        *(_DWORD *)(v73 - 172) = v77;
        _os_log_debug_impl(&dword_1DC2FE000, v86, OS_LOG_TYPE_DEBUG, "QR with 6 algiment patterns: try estimate polynomial transform using %{public}d valid alignment patterns.", (uint8_t *)(v73 - 176), 8u);
      }
      uint64_t v87 = a72;
      if (a72) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(a72 + 8), 1u, memory_order_relaxed);
      }
      a24 = v87;
      uint64_t v88 = a71;
      if (a71) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(a71 + 8), 1u, memory_order_relaxed);
      }
      a23 = v88;
      uint64_t v89 = a70;
      if (a70) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(a70 + 8), 1u, memory_order_relaxed);
      }
      a22 = v89;
      uint64_t v90 = &a24;
      float v91 = &a23;
      float v92 = &a22;
      sub_1DC3A5078((uint64_t)&a62, (uint64_t)&a56, (uint64_t)&a24, (uint64_t)&a23, &a22, a12);
    }
    else
    {
      if (v72 < 13 || v76 < 6)
      {
        exception = __cxa_allocate_exception(0x20uLL);
        sub_1DC379B70(exception, "transform for this case not implemented.");
        void *exception = &unk_1F36611E0;
        __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
      }
      uint64_t v93 = a72;
      if (a72) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(a72 + 8), 1u, memory_order_relaxed);
      }
      a21 = v93;
      uint64_t v94 = a71;
      if (a71) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(a71 + 8), 1u, memory_order_relaxed);
      }
      a20 = v94;
      uint64_t v95 = a70;
      if (a70) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(a70 + 8), 1u, memory_order_relaxed);
      }
      a19 = v95;
      uint64_t v90 = &a21;
      float v91 = &a20;
      float v92 = &a19;
      sub_1DC3A5078((uint64_t)&a62, (uint64_t)&a56, (uint64_t)&a21, (uint64_t)&a20, &a19, a12);
    }
    sub_1DC2FFD08((atomic_uint **)v92);
    sub_1DC2FFD08((atomic_uint **)v91);
    sub_1DC2FFD08((atomic_uint **)v90);
    sub_1DC3A5588();
  }
  JUMPOUT(0x1DC3A3750);
}

void sub_1DC3A3554(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void **a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,atomic_uint *a49)
{
  __cxa_free_exception(v49);
  __cxa_end_catch();
  sub_1DC36176C(&a49);
  a40 = (void **)(v50 - 232);
  sub_1DC2FF82C(&a40);
  JUMPOUT(0x1DC3A36D4);
}

void sub_1DC3A3624(void *a1, int a2)
{
  if (a2) {
    sub_1DC2FFA58(a1);
  }
  JUMPOUT(0x1DC3A3750);
}

void sub_1DC3A3634(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void **a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,char a46)
{
  sub_1DC2FFC48(&a40);
  a40 = (void **)&a43;
  sub_1DC2FF82C(&a40);
  a40 = (void **)&a46;
  sub_1DC2FFC48(&a40);
  MEMORY[0x1E019CE90](v46, 0x10A1C400C341749);
  a40 = (void **)(v47 - 232);
  sub_1DC2FF82C(&a40);
  JUMPOUT(0x1DC3A36D4);
}

void sub_1DC3A369C()
{
  if (v0) {
    operator delete(v0);
  }
  if (v1) {
    operator delete(v1);
  }
  if (v2) {
    operator delete(v2);
  }
  if (v3) {
    operator delete(v3);
  }
  JUMPOUT(0x1DC3A3728);
}

void sub_1DC3A36A4()
{
}

void sub_1DC3A36AC()
{
}

uint64_t sub_1DC3A3758(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5 = a1[1] - *a1;
  if ((int)(v5 >> 2) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (v5 >> 2) - 1;
    uint64_t v9 = (v5 >> 2);
    do
    {
      uint64_t v10 = 0;
      do
      {
        if (v10 | v7)
        {
          BOOL v11 = v7 == v8 && v10 == 0;
          BOOL v12 = v11;
          BOOL v13 = v10 == v8 && v7 == 0;
          if (!v13 && !v12)
          {
            float v14 = (float)*(int *)(*a1 + 4 * v10) + 0.5;
            int v16 = *(float **)(a2 + 8);
            unint64_t v15 = *(void *)(a2 + 16);
            if ((unint64_t)v16 >= v15)
            {
              uint64_t v18 = *(char **)a2;
              uint64_t v19 = ((uint64_t)v16 - *(void *)a2) >> 2;
              unint64_t v20 = v19 + 1;
              if ((unint64_t)(v19 + 1) >> 62) {
                goto LABEL_56;
              }
              uint64_t v21 = v15 - (void)v18;
              if (v21 >> 1 > v20) {
                unint64_t v20 = v21 >> 1;
              }
              if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v22 = v20;
              }
              if (v22)
              {
                unint64_t v22 = (unint64_t)sub_1DC314E5C(v22);
                uint64_t v18 = *(char **)a2;
                int v16 = *(float **)(a2 + 8);
              }
              else
              {
                uint64_t v23 = 0;
              }
              float v24 = (float *)(v22 + 4 * v19);
              *float v24 = v14;
              unint64_t v17 = v24 + 1;
              while (v16 != (float *)v18)
              {
                int v25 = *((_DWORD *)v16-- - 1);
                *((_DWORD *)v24-- - 1) = v25;
              }
              unint64_t v15 = v22 + 4 * v23;
              *(void *)a2 = v24;
              *(void *)(a2 + 8) = v17;
              *(void *)(a2 + 16) = v15;
              if (v18)
              {
                operator delete(v18);
                unint64_t v15 = *(void *)(a2 + 16);
              }
            }
            else
            {
              *int v16 = v14;
              unint64_t v17 = v16 + 1;
            }
            *(void *)(a2 + 8) = v17;
            float v26 = (float)*(int *)(*a1 + 4 * v7) + 0.5;
            if ((unint64_t)v17 >= v15)
            {
              uint64_t v28 = *(char **)a2;
              uint64_t v29 = ((uint64_t)v17 - *(void *)a2) >> 2;
              unint64_t v30 = v29 + 1;
              if ((unint64_t)(v29 + 1) >> 62) {
LABEL_56:
              }
                sub_1DC2FF97C();
              uint64_t v31 = v15 - (void)v28;
              if (v31 >> 1 > v30) {
                unint64_t v30 = v31 >> 1;
              }
              if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v32 = v30;
              }
              if (v32)
              {
                unint64_t v32 = (unint64_t)sub_1DC314E5C(v32);
                uint64_t v28 = *(char **)a2;
                unint64_t v17 = *(float **)(a2 + 8);
              }
              else
              {
                uint64_t v33 = 0;
              }
              uint64_t v34 = (float *)(v32 + 4 * v29);
              *uint64_t v34 = v26;
              int v27 = v34 + 1;
              while (v17 != (float *)v28)
              {
                int v35 = *((_DWORD *)v17-- - 1);
                *((_DWORD *)v34-- - 1) = v35;
              }
              *(void *)a2 = v34;
              *(void *)(a2 + 8) = v27;
              *(void *)(a2 + 16) = v32 + 4 * v33;
              if (v28) {
                operator delete(v28);
              }
            }
            else
            {
              float *v17 = v26;
              int v27 = v17 + 1;
            }
            *(void *)(a2 + 8) = v27;
          }
        }
        ++v10;
      }
      while (v10 != v9);
      ++v7;
    }
    while (v7 != v9);
  }
  if (a4 != (char *)a2) {
    sub_1DC36B53C(a4, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  }
  int v36 = *(uint64_t (**)(void))(**(void **)a3 + 16);
  return v36();
}

uint64_t sub_1DC3A39D4(void *a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_1DC2FF97C();
  }
  int v6 = a1 + 2;
  if (0x5555555555555556 * ((uint64_t)(a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((uint64_t)(a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[2] - *a1) >> 3) >= 0x555555555555555) {
    unint64_t v7 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v7 = v3;
  }
  unint64_t v15 = v6;
  if (v7) {
    unint64_t v7 = (unint64_t)sub_1DC34EB60(v7);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (void *)(v7 + 24 * v2);
  v12[0] = v7;
  v12[1] = v9;
  BOOL v13 = v9;
  unint64_t v14 = v7 + 24 * v8;
  *uint64_t v9 = 0;
  v9[1] = 0;
  v9[2] = 0;
  sub_1DC3219D0(v9, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  v13 += 3;
  sub_1DC3A5B0C(a1, v12);
  uint64_t v10 = a1[1];
  sub_1DC3A5B7C((uint64_t)v12);
  return v10;
}

void sub_1DC3A3AD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3A5B7C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DC3A3AE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v7 = a2;
  uint64_t v5 = *a4;
  if (*a4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
  }
  uint64_t v6 = v5;
  sub_1DC3A5BE0((uint64_t)&v8, &v7, a5, &v6);
}

void sub_1DC3A3C80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  unint64_t v3 = va_arg(va1, atomic_uint *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, atomic_uint *);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  sub_1DC311C34((atomic_uint **)va1);
  sub_1DC2FF548((atomic_uint **)va);
  sub_1DC2FF548((atomic_uint **)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3A3CDC(uint64_t a1, void *a2)
{
  unint64_t v2 = *(_DWORD **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8)) {
    return 0;
  }
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 == v3) {
    return 0;
  }
  if ((unint64_t)(v3 - v4) >= 8)
  {
    unint64_t v8 = 0;
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    unint64_t v5 = 0;
    uint64_t v9 = 0;
    unint64_t v11 = 0;
    long long v65 = 0u;
    uint64_t v63 = a1;
    do
    {
      if (*(float *)(v4 + 8 * v11) >= 0.0)
      {
        uint64_t v12 = (2 * v11) | 1;
        if (*(float *)(v4 + 4 * v12) >= 0.0)
        {
          int v62 = v9;
          BOOL v13 = *(_DWORD **)a1;
          uint64_t v14 = *((void *)&v65 + 1);
          unint64_t v15 = (_DWORD *)v65;
          if (*((void *)&v65 + 1) >= v8)
          {
            unint64_t v17 = v8;
            unint64_t v18 = v5;
            uint64_t v19 = (void *)v65;
            uint64_t v20 = (uint64_t)(*((void *)&v65 + 1) - v65) >> 2;
            unint64_t v21 = v20 + 1;
            if ((unint64_t)(v20 + 1) >> 62) {
              goto LABEL_87;
            }
            unint64_t v22 = v17 - v65;
            unint64_t v23 = (uint64_t)(v17 - v65) >> 1;
            if (v23 > v21) {
              unint64_t v21 = v23;
            }
            if (v22 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v24 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v24 = v21;
            }
            if (v24) {
              unint64_t v24 = (unint64_t)sub_1DC314E5C(v24);
            }
            else {
              uint64_t v25 = 0;
            }
            float v26 = (_DWORD *)(v24 + 4 * v20);
            *float v26 = v13[2 * v11];
            int v16 = v26 + 1;
            unint64_t v5 = v18;
            while (v14 != (void)v65)
            {
              int v27 = *(_DWORD *)(v14 - 4);
              v14 -= 4;
              *--float v26 = v27;
            }
            unint64_t v8 = v24 + 4 * v25;
            unint64_t v15 = v26;
            if ((void)v65)
            {
              float v66 = v26;
              operator delete(v19);
              unint64_t v15 = v66;
            }
            a1 = v63;
          }
          else
          {
            **((_DWORD **)&v65 + 1) = v13[2 * v11];
            int v16 = (_DWORD *)(*((void *)&v65 + 1) + 4);
          }
          float v67 = v15;
          uint64_t v28 = *(_DWORD **)a1;
          if ((unint64_t)v16 >= v8)
          {
            unint64_t v30 = v8;
            unint64_t v31 = v5;
            unint64_t v32 = v15;
            uint64_t v33 = v16 - v15;
            unint64_t v34 = v33 + 1;
            if ((unint64_t)(v33 + 1) >> 62) {
              goto LABEL_87;
            }
            unint64_t v35 = v30 - (void)v15;
            unint64_t v36 = (uint64_t)(v30 - (void)v15) >> 1;
            if (v36 > v34) {
              unint64_t v34 = v36;
            }
            if (v35 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v37 = v34;
            }
            if (v37) {
              unint64_t v37 = (unint64_t)sub_1DC314E5C(v37);
            }
            else {
              uint64_t v38 = 0;
            }
            int v39 = (_DWORD *)(v37 + 4 * v33);
            *int v39 = v28[v12];
            uint64_t v29 = v39 + 1;
            unint64_t v5 = v31;
            while (v16 != v32)
            {
              int v40 = *--v16;
              *--int v39 = v40;
            }
            unint64_t v8 = v37 + 4 * v38;
            float v67 = v39;
            if (v32) {
              operator delete(v32);
            }
            a1 = v63;
          }
          else
          {
            *int v16 = v28[v12];
            uint64_t v29 = v16 + 1;
          }
          uint64_t v41 = a2;
          *(void *)&long long v42 = v67;
          *((void *)&v42 + 1) = v29;
          long long v65 = v42;
          uint64_t v43 = *a2;
          if ((unint64_t)v6 >= v5)
          {
            uint64_t v45 = v6 - v7;
            unint64_t v46 = v45 + 1;
            if ((unint64_t)(v45 + 1) >> 62) {
              goto LABEL_87;
            }
            if ((uint64_t)(v5 - (void)v7) >> 1 > v46) {
              unint64_t v46 = (uint64_t)(v5 - (void)v7) >> 1;
            }
            if (v5 - (unint64_t)v7 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v47 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v47 = v46;
            }
            if (v47) {
              unint64_t v47 = (unint64_t)sub_1DC314E5C(v47);
            }
            else {
              uint64_t v48 = 0;
            }
            uint64_t v49 = (_DWORD *)(v47 + 4 * v45);
            *uint64_t v49 = *(_DWORD *)(v43 + 8 * v11);
            uint64_t v44 = v49 + 1;
            while (v6 != v7)
            {
              int v50 = *--v6;
              *--uint64_t v49 = v50;
            }
            unint64_t v5 = v47 + 4 * v48;
            if (v7) {
              operator delete(v7);
            }
            uint64_t v7 = v49;
            a1 = v63;
            uint64_t v41 = a2;
          }
          else
          {
            *uint64_t v6 = *(_DWORD *)(v43 + 8 * v11);
            uint64_t v44 = v6 + 1;
          }
          uint64_t v51 = *v41;
          if ((unint64_t)v44 >= v5)
          {
            uint64_t v53 = v44 - v7;
            unint64_t v54 = v53 + 1;
            if ((unint64_t)(v53 + 1) >> 62) {
LABEL_87:
            }
              sub_1DC2FF97C();
            if ((uint64_t)(v5 - (void)v7) >> 1 > v54) {
              unint64_t v54 = (uint64_t)(v5 - (void)v7) >> 1;
            }
            if (v5 - (unint64_t)v7 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v55 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v55 = v54;
            }
            if (v55) {
              unint64_t v55 = (unint64_t)sub_1DC314E5C(v55);
            }
            else {
              uint64_t v56 = 0;
            }
            uint64_t v57 = (_DWORD *)(v55 + 4 * v53);
            *uint64_t v57 = *(_DWORD *)(v51 + 4 * v12);
            uint64_t v6 = v57 + 1;
            if (v44 == v7)
            {
              int v52 = v62;
            }
            else
            {
              int v52 = v62;
              do
              {
                int v58 = *--v44;
                *--uint64_t v57 = v58;
              }
              while (v44 != v7);
            }
            unint64_t v5 = v55 + 4 * v56;
            if (v7) {
              operator delete(v7);
            }
            uint64_t v7 = v57;
            a1 = v63;
            uint64_t v41 = a2;
          }
          else
          {
            *uint64_t v44 = *(_DWORD *)(v51 + 4 * v12);
            uint64_t v6 = v44 + 1;
            int v52 = v62;
          }
          uint64_t v9 = (v52 + 1);
          unsigned int v59 = v41;
          uint64_t v4 = *v41;
          uint64_t v3 = v59[1];
        }
      }
      ++v11;
    }
    while (v11 < (unint64_t)((v3 - v4) >> 2) >> 1);
    unint64_t v2 = *(_DWORD **)a1;
    long long v10 = v65;
  }
  else
  {
    unint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    uint64_t v9 = 0;
    long long v10 = 0uLL;
  }
  *(_OWORD *)a1 = v10;
  *(void *)(a1 + 16) = v8;
  unsigned int v60 = (void *)*a2;
  *a2 = v7;
  a2[1] = v6;
  a2[2] = v5;
  if (v60) {
    operator delete(v60);
  }
  if (v2) {
    operator delete(v2);
  }
  return v9;
}

void sub_1DC3A40F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, long long a13)
{
  if (v13) {
    operator delete(v13);
  }
  if ((void)a13) {
    operator delete((void *)a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3A411C(uint64_t *a1, uint64_t *a2)
{
  sub_1DC36B188((uint64_t)v19, a1, *(unsigned char *)(*a2 + 52));
  uint64_t v3 = *a2;
  uint64_t v4 = *(atomic_uint **)(*a2 + 24);
  if (v4)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    uint64_t v3 = *a2;
  }
  unint64_t v18 = v4;
  unint64_t v5 = *(atomic_uint **)(v3 + 32);
  if (v5)
  {
    atomic_fetch_add_explicit(v5 + 2, 1u, memory_order_relaxed);
    uint64_t v3 = *a2;
  }
  unint64_t v17 = v5;
  uint64_t v6 = *(atomic_uint **)(v3 + 16);
  if (v6) {
    atomic_fetch_add_explicit(v6 + 2, 1u, memory_order_relaxed);
  }
  int v16 = v6;
  float v7 = (*(float (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  float v8 = (*(float (**)(atomic_uint *))(*(void *)v17 + 16))(v17);
  float v9 = (*(float (**)(atomic_uint *))(*(void *)v18 + 16))(v18);
  float v10 = (*(float (**)(atomic_uint *))(*(void *)v16 + 16))(v16);
  float v11 = (*(float (**)(atomic_uint *))(*(void *)v18 + 24))(v18);
  float v12 = (*(float (**)(atomic_uint *))(*(void *)v17 + 24))(v17);
  float v13 = (*(float (**)(atomic_uint *))(*(void *)v18 + 24))(v18);
  float v14 = (*(float (**)(atomic_uint *))(*(void *)v16 + 24))(v16);
  if (sqrtf((float)((float)((float)((float)(v11 - v12) + v13) - v14) * (float)((float)((float)(v11 - v12) + v13) - v14))+ (float)((float)((float)((float)(v7 - v8) + v9) - v10) * (float)((float)((float)(v7 - v8) + v9) - v10))) >= 0.00000011921)operator new(); {
  sub_1DC35D870(&v16);
  }
  sub_1DC35D870(&v17);
  sub_1DC35D870(&v18);
  sub_1DC2FF548(&v20);
  return 0;
}

void sub_1DC3A4F84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char **__p, uint64_t a14, uint64_t a15, char *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,atomic_uint *a22,atomic_uint *a23,atomic_uint *a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  operator delete(v31);
  __p = &a16;
  sub_1DC2FF82C((void ***)&__p);
  a16 = &a19;
  sub_1DC2FF82C((void ***)&a16);
  MEMORY[0x1E019CE90](a10, 0x1060C40B96495EDLL);
  sub_1DC35D870(&a22);
  sub_1DC35D870(&a23);
  sub_1DC35D870(&a24);
  sub_1DC2FF548((atomic_uint **)&a30);
  _Unwind_Resume(a1);
}

void sub_1DC3A5078(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, int a6)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  float v10 = *(char **)(a1 + 8);
  float v17 = 3.5;
  float v18 = (float)a6 + -3.5;
  __asm { FMOV            V1.2S, #3.5 }
  uint64_t v19 = _D1;
  float v20 = v18;
  float v21 = 3.5;
  sub_1DC3A58FC(a1, v10, (char *)&v17, (char *)&v22);
  int v16 = *(char **)(a2 + 8);
  float v17 = (*(float (**)(void))(*(void *)*a5 + 16))();
  float v18 = (*(float (**)(void))(*(void *)*a5 + 24))(*a5);
  LODWORD(v19) = (*(float (**)(void))(**(void **)a3 + 16))();
  HIDWORD(v19) = (*(float (**)(void))(**(void **)a3 + 24))();
  float v20 = (*(float (**)(void))(**(void **)a4 + 16))();
  float v21 = (*(float (**)(void))(**(void **)a4 + 24))();
  sub_1DC3A58FC(a2, v16, (char *)&v17, (char *)&v22);
}

void sub_1DC3A5248(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(void *)a3)
  {
    float v7 = (float)a4 + -6.5;
    float v9 = *(float **)(a1 + 8);
    unint64_t v8 = *(void *)(a1 + 16);
    if ((unint64_t)v9 >= v8)
    {
      float v11 = *(float **)a1;
      uint64_t v12 = ((uint64_t)v9 - *(void *)a1) >> 2;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 62) {
        goto LABEL_64;
      }
      uint64_t v14 = v8 - (void)v11;
      if (v14 >> 1 > v13) {
        unint64_t v13 = v14 >> 1;
      }
      BOOL v15 = (unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL;
      unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v15) {
        unint64_t v16 = v13;
      }
      if (v16)
      {
        unint64_t v16 = (unint64_t)sub_1DC314E5C(v16);
        float v11 = *(float **)a1;
        float v9 = *(float **)(a1 + 8);
      }
      else
      {
        uint64_t v17 = 0;
      }
      float v18 = (float *)(v16 + 4 * v12);
      unint64_t v8 = v16 + 4 * v17;
      *float v18 = v7;
      float v10 = v18 + 1;
      while (v9 != v11)
      {
        int v19 = *((_DWORD *)v9-- - 1);
        *((_DWORD *)v18-- - 1) = v19;
      }
      *(void *)a1 = v18;
      *(void *)(a1 + 8) = v10;
      *(void *)(a1 + 16) = v8;
      if (v11)
      {
        operator delete(v11);
        unint64_t v8 = *(void *)(a1 + 16);
      }
    }
    else
    {
      *float v9 = v7;
      float v10 = v9 + 1;
    }
    *(void *)(a1 + 8) = v10;
    if ((unint64_t)v10 >= v8)
    {
      float v21 = *(float **)a1;
      uint64_t v22 = ((uint64_t)v10 - *(void *)a1) >> 2;
      unint64_t v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 62) {
        goto LABEL_64;
      }
      uint64_t v24 = v8 - (void)v21;
      if (v24 >> 1 > v23) {
        unint64_t v23 = v24 >> 1;
      }
      BOOL v15 = (unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL;
      unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v15) {
        unint64_t v25 = v23;
      }
      if (v25)
      {
        unint64_t v25 = (unint64_t)sub_1DC314E5C(v25);
        float v21 = *(float **)a1;
        float v10 = *(float **)(a1 + 8);
      }
      else
      {
        uint64_t v26 = 0;
      }
      int v27 = (float *)(v25 + 4 * v22);
      unint64_t v28 = v25 + 4 * v26;
      *int v27 = v7;
      float v20 = v27 + 1;
      while (v10 != v21)
      {
        int v29 = *((_DWORD *)v10-- - 1);
        *((_DWORD *)v27-- - 1) = v29;
      }
      *(void *)a1 = v27;
      *(void *)(a1 + 8) = v20;
      *(void *)(a1 + 16) = v28;
      if (v21) {
        operator delete(v21);
      }
    }
    else
    {
      *float v10 = v7;
      float v20 = v10 + 1;
    }
    *(void *)(a1 + 8) = v20;
    float v30 = (*(float (**)(void))(**(void **)a3 + 16))();
    float v31 = v30;
    uint64_t v33 = *(float **)(a2 + 8);
    unint64_t v32 = *(void *)(a2 + 16);
    if ((unint64_t)v33 >= v32)
    {
      unint64_t v35 = *(float **)a2;
      uint64_t v36 = ((uint64_t)v33 - *(void *)a2) >> 2;
      unint64_t v37 = v36 + 1;
      if ((unint64_t)(v36 + 1) >> 62) {
        goto LABEL_64;
      }
      uint64_t v38 = v32 - (void)v35;
      if (v38 >> 1 > v37) {
        unint64_t v37 = v38 >> 1;
      }
      BOOL v15 = (unint64_t)v38 >= 0x7FFFFFFFFFFFFFFCLL;
      unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v15) {
        unint64_t v39 = v37;
      }
      if (v39)
      {
        unint64_t v39 = (unint64_t)sub_1DC314E5C(v39);
        unint64_t v35 = *(float **)a2;
        uint64_t v33 = *(float **)(a2 + 8);
      }
      else
      {
        uint64_t v40 = 0;
      }
      uint64_t v41 = (float *)(v39 + 4 * v36);
      unint64_t v42 = v39 + 4 * v40;
      *uint64_t v41 = v31;
      unint64_t v34 = v41 + 1;
      while (v33 != v35)
      {
        int v43 = *((_DWORD *)v33-- - 1);
        *((_DWORD *)v41-- - 1) = v43;
      }
      *(void *)a2 = v41;
      *(void *)(a2 + 8) = v34;
      *(void *)(a2 + 16) = v42;
      if (v35) {
        operator delete(v35);
      }
    }
    else
    {
      *uint64_t v33 = v30;
      unint64_t v34 = v33 + 1;
    }
    *(void *)(a2 + 8) = v34;
    float v44 = (*(float (**)(void))(**(void **)a3 + 24))();
    float v45 = v44;
    unint64_t v47 = *(float **)(a2 + 8);
    unint64_t v46 = *(void *)(a2 + 16);
    if ((unint64_t)v47 < v46)
    {
      *unint64_t v47 = v44;
      uint64_t v48 = v47 + 1;
LABEL_62:
      *(void *)(a2 + 8) = v48;
      return;
    }
    uint64_t v49 = *(float **)a2;
    uint64_t v50 = ((uint64_t)v47 - *(void *)a2) >> 2;
    unint64_t v51 = v50 + 1;
    if (!((unint64_t)(v50 + 1) >> 62))
    {
      uint64_t v52 = v46 - (void)v49;
      if (v52 >> 1 > v51) {
        unint64_t v51 = v52 >> 1;
      }
      BOOL v15 = (unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL;
      unint64_t v53 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v15) {
        unint64_t v53 = v51;
      }
      if (v53)
      {
        unint64_t v53 = (unint64_t)sub_1DC314E5C(v53);
        uint64_t v49 = *(float **)a2;
        unint64_t v47 = *(float **)(a2 + 8);
      }
      else
      {
        uint64_t v54 = 0;
      }
      unint64_t v55 = (float *)(v53 + 4 * v50);
      unint64_t v56 = v53 + 4 * v54;
      float *v55 = v45;
      uint64_t v48 = v55 + 1;
      while (v47 != v49)
      {
        int v57 = *((_DWORD *)v47-- - 1);
        *((_DWORD *)v55-- - 1) = v57;
      }
      *(void *)a2 = v55;
      *(void *)(a2 + 8) = v48;
      *(void *)(a2 + 16) = v56;
      if (v49) {
        operator delete(v49);
      }
      goto LABEL_62;
    }
LABEL_64:
    sub_1DC2FF97C();
  }
}

void sub_1DC3A5588()
{
}

void sub_1DC3A5710()
{
}

void sub_1DC3A58B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1DC358EE4((atomic_uint **)va);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1DC3A58FC(uint64_t a1, char *__dst, char *__src, char *a4)
{
  unint64_t v8 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  if ((uint64_t)(v7 - v8) < 24)
  {
    float v9 = *(char **)a1;
    unint64_t v10 = ((uint64_t)(v8 - *(void *)a1) >> 2) + 6;
    if (v10 >> 62) {
      sub_1DC2FF97C();
    }
    uint64_t v11 = (__dst - v9) >> 2;
    uint64_t v12 = v7 - (void)v9;
    uint64_t v13 = v12 >> 1;
    if (v12 >> 1 <= v10) {
      uint64_t v13 = ((uint64_t)(v8 - *(void *)a1) >> 2) + 6;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      unint64_t v14 = (unint64_t)sub_1DC314E5C(v14);
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v24 = 0;
    unint64_t v25 = v14 + 4 * v11;
    unint64_t v26 = v14 + 4 * v15;
    do
    {
      *(_DWORD *)(v25 + v24) = *(_DWORD *)&__src[v24];
      v24 += 4;
    }
    while (v24 != 24);
    int v27 = *(char **)a1;
    if (*(char **)a1 == __dst)
    {
      unint64_t v29 = v14 + 4 * v11;
    }
    else
    {
      unint64_t v28 = __dst;
      unint64_t v29 = v14 + 4 * v11;
      do
      {
        int v30 = *((_DWORD *)v28 - 1);
        v28 -= 4;
        *(_DWORD *)(v29 - 4) = v30;
        v29 -= 4;
      }
      while (v28 != v27);
    }
    float v31 = (char *)(v25 + 24);
    unint64_t v32 = *(unsigned char **)(a1 + 8);
    uint64_t v33 = v32 - __dst;
    if (v32 != __dst) {
      memmove(v31, __dst, v32 - __dst);
    }
    unint64_t v34 = *(char **)a1;
    *(void *)a1 = v29;
    *(void *)(a1 + 8) = &v31[v33];
    *(void *)(a1 + 16) = v26;
    if (v34)
    {
      operator delete(v34);
    }
    return;
  }
  uint64_t v16 = v8 - (void)__dst;
  if ((uint64_t)(v8 - (void)__dst) > 23)
  {
    uint64_t v17 = __src + 24;
    int v19 = *(char **)(a1 + 8);
LABEL_16:
    float v20 = __dst + 24;
    float v21 = v19 - 24;
    uint64_t v22 = v19;
    if ((unint64_t)(v19 - 24) < v8)
    {
      uint64_t v22 = v19;
      do
      {
        int v23 = *(_DWORD *)v21;
        v21 += 4;
        *(_DWORD *)uint64_t v22 = v23;
        v22 += 4;
      }
      while ((unint64_t)v21 < v8);
    }
    *(void *)(a1 + 8) = v22;
    if (v19 != v20) {
      memmove(&v19[-4 * ((v19 - v20) >> 2)], __dst, v19 - v20);
    }
    if (v17 != __src)
    {
      memmove(__dst, __src, v17 - __src);
    }
    return;
  }
  uint64_t v17 = &__src[v16];
  int64_t v18 = a4 - &__src[v16];
  if (a4 != &__src[v16]) {
    memmove(*(void **)(a1 + 8), &__src[v16], a4 - &__src[v16]);
  }
  int v19 = (char *)(v8 + v18);
  *(void *)(a1 + 8) = v8 + v18;
  if (v16 >= 1) {
    goto LABEL_16;
  }
}

void *sub_1DC3A5B0C(void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  unint64_t v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0;
    *(void *)(v4 - 16) = 0;
    v4 -= 24;
    *(void *)(v4 + 16) = 0;
    long long v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(v4 + 16) = v2[2];
    *unint64_t v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *uint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DC3A5B7C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DC3A5BE0(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  sub_1DC350558();
  uint64_t v8 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v8 + 8), 1u, memory_order_relaxed);
  }
  v10[1] = v8;
  uint64_t v9 = *a4;
  if (*a4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 8), 1u, memory_order_relaxed);
  }
  v10[0] = v9;
  sub_1DC350088(a1, v8, a3, v10);
}

void sub_1DC3A5C80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, atomic_uint *a10)
{
}

float sub_1DC3A5C9C(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  int v8 = (int)(*(float (**)(void))(**(void **)a2 + 16))();
  int v9 = (int)(*(float (**)(void))(**(void **)a2 + 24))();
  int v10 = sub_1DC2FF924(*(void **)(a1 + 16), v8, v9);
  int v11 = (int)(*(float (**)(void))(**(void **)a3 + 16))();
  int v12 = (int)(*(float (**)(void))(**(void **)a3 + 24))();
  int v13 = v12 - v9;
  if (v12 - v9 >= 0) {
    unsigned int v14 = v12 - v9;
  }
  else {
    unsigned int v14 = v9 - v12;
  }
  if (v11 - v8 >= 0) {
    unsigned int v15 = v11 - v8;
  }
  else {
    unsigned int v15 = v8 - v11;
  }
  if (v14 > v15) {
    unsigned int v16 = v15;
  }
  else {
    unsigned int v16 = v14;
  }
  unsigned int v109 = v16;
  if (v14 > v15) {
    int v17 = v11 - v8;
  }
  else {
    int v17 = v12 - v9;
  }
  unsigned int __p = v15;
  if (v14 > v15) {
    uint64_t v18 = v14;
  }
  else {
    uint64_t v18 = v15;
  }
  if (v14 <= v15) {
    int v13 = v11 - v8;
  }
  int v100 = v13;
  int v101 = v17;
  if (v14 > v15) {
    int v19 = v11;
  }
  else {
    int v19 = v12;
  }
  if (v14 <= v15)
  {
    int v20 = v9;
  }
  else
  {
    int v11 = v12;
    int v20 = v8;
  }
  if (v14 > v15) {
    int v8 = v9;
  }
  if (v8 < v11) {
    int v21 = 1;
  }
  else {
    int v21 = -1;
  }
  if (v20 < v19) {
    int v22 = 1;
  }
  else {
    int v22 = -1;
  }
  int v104 = v22;
  int v105 = v19;
  int v23 = (int *)operator new(4uLL);
  uint64_t v24 = v23;
  *int v23 = 0x7FFFFFFF;
  unint64_t v25 = v23 + 1;
  int v107 = v21;
  int v108 = v11;
  if (v8 == v21 + v11)
  {
    int v26 = 0;
    unint64_t v27 = (unint64_t)(v23 + 1);
LABEL_68:
    uint64_t v41 = v25 - v24;
    unint64_t v42 = v41 + 1;
    if ((unint64_t)(v41 + 1) >> 62) {
      sub_1DC2FF97C();
    }
    if ((uint64_t)(v27 - (void)v24) >> 1 > v42) {
      unint64_t v42 = (uint64_t)(v27 - (void)v24) >> 1;
    }
    if (v27 - (unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v43 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v43 = v42;
    }
    if (v43) {
      unint64_t v43 = (unint64_t)sub_1DC314E5C(v43);
    }
    else {
      uint64_t v44 = 0;
    }
    float v45 = (int *)(v43 + 4 * v41);
    unint64_t v27 = v43 + 4 * v44;
    *float v45 = v26;
    unint64_t v46 = v45;
    if (v25 != v24)
    {
      unint64_t v46 = v45;
      do
      {
        int v47 = *--v25;
        *--unint64_t v46 = v47;
      }
      while (v25 != v24);
    }
    if (v24) {
      operator delete(v24);
    }
    uint64_t v24 = v46;
    unint64_t v25 = v45;
    goto LABEL_83;
  }
  int v26 = 0;
  int v28 = -(int)v18 >> 1;
  uint64_t v106 = v23 + 1;
  unsigned int v103 = v14;
  do
  {
    if (v14 <= __p) {
      int v29 = v8;
    }
    else {
      int v29 = v20;
    }
    if (v14 <= __p) {
      int v30 = v20;
    }
    else {
      int v30 = v8;
    }
    if ((v10 ^ sub_1DC2FF924(*(void **)(a1 + 16), v29, v30)))
    {
      if (v25 >= v106)
      {
        int v102 = v10;
        uint64_t v32 = a1;
        uint64_t v33 = v18;
        uint64_t v34 = v25 - v24;
        unint64_t v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) >> 62) {
          sub_1DC2FF97C();
        }
        if (((char *)v106 - (char *)v24) >> 1 > v35) {
          unint64_t v35 = ((char *)v106 - (char *)v24) >> 1;
        }
        if ((unint64_t)((char *)v106 - (char *)v24) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v36 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v35;
        }
        if (v36) {
          unint64_t v36 = (unint64_t)sub_1DC314E5C(v36);
        }
        else {
          uint64_t v37 = 0;
        }
        uint64_t v38 = (int *)(v36 + 4 * v34);
        *uint64_t v38 = v26;
        float v31 = v38 + 1;
        while (v25 != v24)
        {
          int v39 = *--v25;
          *--uint64_t v38 = v39;
        }
        uint64_t v106 = (int *)(v36 + 4 * v37);
        if (v24) {
          operator delete(v24);
        }
        uint64_t v24 = v38;
        uint64_t v18 = v33;
        a1 = v32;
        int v10 = v102;
      }
      else
      {
        *unint64_t v25 = v26;
        float v31 = v25 + 1;
      }
      v10 ^= 1u;
      int v26 = 1;
      unint64_t v25 = v31;
      unsigned int v14 = v103;
    }
    else
    {
      ++v26;
    }
    v28 += v109;
    if (v28 >= 1)
    {
      if (v20 == v105) {
        break;
      }
      v20 += v104;
      v28 -= v18;
    }
    BOOL v40 = v8 == v108;
    v8 += v107;
  }
  while (!v40);
  unint64_t v27 = (unint64_t)v106;
  if (v25 >= v106) {
    goto LABEL_68;
  }
  *unint64_t v25 = v26;
LABEL_83:
  uint64_t v48 = v25 + 1;
  if ((unint64_t)(v25 + 1) >= v27)
  {
    uint64_t v50 = v48 - v24;
    unint64_t v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 62) {
      sub_1DC2FF97C();
    }
    if ((uint64_t)(v27 - (void)v24) >> 1 > v51) {
      unint64_t v51 = (uint64_t)(v27 - (void)v24) >> 1;
    }
    if (v27 - (unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v52 = v51;
    }
    if (v52) {
      unint64_t v52 = (unint64_t)sub_1DC314E5C(v52);
    }
    unint64_t v53 = (int *)(v52 + 4 * v50);
    *unint64_t v53 = 0x7FFFFFFF;
    uint64_t v49 = (char *)(v53 + 1);
    while (v48 != v24)
    {
      int v54 = *--v48;
      *--unint64_t v53 = v54;
    }
    if (v24) {
      operator delete(v24);
    }
    uint64_t v24 = v53;
  }
  else
  {
    v25[1] = 0x7FFFFFFF;
    uint64_t v49 = (char *)(v25 + 2);
  }
  if ((int)((unint64_t)(v49 - (char *)v24) >> 2) < 3)
  {
    __pa = 0;
    unint64_t v55 = 0;
    int v57 = 0;
  }
  else
  {
    __pa = 0;
    unint64_t v55 = 0;
    unint64_t v56 = 0;
    int v57 = 0;
    float v58 = (double)(int)v18 / sqrt((double)(v101 * v101 + v100 * v100));
    int v59 = (int)(float)((float)(v58 * a4) * 0.5);
    uint64_t v60 = 1;
    do
    {
      if (v24[v60 - 1] > v59)
      {
        int v61 = v24[v60];
        if (v61 > v59 && v24[v60 + 1] > v59)
        {
          float v62 = (float)v61 / v58;
          if ((unint64_t)v57 >= v56)
          {
            uint64_t v63 = v57 - __pa;
            unint64_t v64 = v63 + 1;
            if ((unint64_t)(v63 + 1) >> 62) {
              sub_1DC2FF97C();
            }
            if ((uint64_t)(v56 - (void)__pa) >> 1 > v64) {
              unint64_t v64 = (uint64_t)(v56 - (void)__pa) >> 1;
            }
            if (v56 - (unint64_t)__pa >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v65 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v65 = v64;
            }
            if (v65)
            {
              unint64_t v65 = (unint64_t)sub_1DC314E5C(v65);
              int v57 = v55;
            }
            else
            {
              uint64_t v66 = 0;
            }
            float v67 = (float *)(v65 + 4 * v63);
            *float v67 = v62;
            unint64_t v55 = v67 + 1;
            while (v57 != __pa)
            {
              int v68 = *((_DWORD *)v57-- - 1);
              *((_DWORD *)v67-- - 1) = v68;
            }
            unint64_t v56 = v65 + 4 * v66;
            if (__pa) {
              operator delete(__pa);
            }
            __pa = v67;
            int v57 = v55;
          }
          else
          {
            *v57++ = v62;
            unint64_t v55 = v57;
          }
        }
      }
      ++v60;
    }
    while (v60 < (((v49 - (char *)v24) << 30) - 0x100000000) >> 32);
  }
  uint64_t v69 = __pa;
  if ((int)((unint64_t)((char *)v57 - (char *)__pa) >> 2) < 3) {
    goto LABEL_176;
  }
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  unint64_t v72 = 0;
  uint64_t v73 = 0;
  float v74 = 0;
  unint64_t v75 = 0;
  uint64_t v76 = 2;
  if (((((char *)v55 - (char *)__pa) << 30) - 0x100000000) >> 32 > 2) {
    uint64_t v76 = ((((char *)v55 - (char *)__pa) << 30) - 0x100000000) >> 32;
  }
  uint64_t v77 = 1;
  uint64_t v110 = v76;
  do
  {
    float v78 = __pa[v77];
    if (v78 >= (float)(a4 * 1.5))
    {
      if ((unint64_t)v74 < v75)
      {
        *v74++ = v78;
        goto LABEL_164;
      }
      uint64_t v83 = v74 - v73;
      unint64_t v84 = v83 + 1;
      if ((unint64_t)(v83 + 1) >> 62) {
LABEL_183:
      }
        sub_1DC2FF97C();
      if ((uint64_t)(v75 - (void)v73) >> 1 > v84) {
        unint64_t v84 = (uint64_t)(v75 - (void)v73) >> 1;
      }
      if (v75 - (unint64_t)v73 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v85 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v85 = v84;
      }
      if (v85) {
        unint64_t v85 = (unint64_t)sub_1DC314E5C(v85);
      }
      else {
        uint64_t v86 = 0;
      }
      uint64_t v90 = (float *)(v85 + 4 * v83);
      float *v90 = v78;
      float v91 = v90 + 1;
      while (v74 != v73)
      {
        int v92 = *((_DWORD *)v74-- - 1);
        *((_DWORD *)v90-- - 1) = v92;
      }
      unint64_t v75 = v85 + 4 * v86;
      if (v73) {
        operator delete(v73);
      }
      uint64_t v73 = v90;
      float v74 = v91;
    }
    else
    {
      if ((unint64_t)v70 < v72)
      {
        *v70++ = v78;
        goto LABEL_164;
      }
      uint64_t v79 = v70 - v71;
      unint64_t v80 = v79 + 1;
      if ((unint64_t)(v79 + 1) >> 62) {
        goto LABEL_183;
      }
      if ((uint64_t)(v72 - (void)v71) >> 1 > v80) {
        unint64_t v80 = (uint64_t)(v72 - (void)v71) >> 1;
      }
      if (v72 - (unint64_t)v71 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v81 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v81 = v80;
      }
      if (v81) {
        unint64_t v81 = (unint64_t)sub_1DC314E5C(v81);
      }
      else {
        uint64_t v82 = 0;
      }
      uint64_t v87 = (float *)(v81 + 4 * v79);
      *uint64_t v87 = v78;
      uint64_t v88 = v87 + 1;
      while (v70 != v71)
      {
        int v89 = *((_DWORD *)v70-- - 1);
        *((_DWORD *)v87-- - 1) = v89;
      }
      unint64_t v72 = v81 + 4 * v82;
      if (v71) {
        operator delete(v71);
      }
      uint64_t v70 = v88;
      uint64_t v71 = v87;
    }
    uint64_t v76 = v110;
LABEL_164:
    ++v77;
  }
  while (v77 != v76);
  if (v70 == v71)
  {
    uint64_t v71 = v70;
    uint64_t v69 = __pa;
    if (v73) {
      goto LABEL_173;
    }
  }
  else
  {
    float v93 = 0.0;
    uint64_t v94 = v71;
    do
    {
      float v95 = *v94++;
      float v93 = v93 + v95;
    }
    while (v94 != v70);
    unint64_t v96 = (unint64_t)((char *)v70 - (char *)v71) >> 2;
    a4 = v93 / (float)(int)v96;
    uint64_t v69 = __pa;
    if (v73 != v74)
    {
      BOOL v97 = v73;
      do
      {
        float v98 = *v97++;
        LODWORD(v96) = (int)(float)(roundf(v98 / a4) + (float)(int)v96);
        float v93 = v93 + v98;
      }
      while (v97 != v74);
      a4 = v93 / (float)(int)v96;
    }
    if (v73) {
LABEL_173:
    }
      operator delete(v73);
  }
  if (v71) {
    operator delete(v71);
  }
LABEL_176:
  if (v69) {
    operator delete(v69);
  }
  if (v24) {
    operator delete(v24);
  }
  return a4;
}

void sub_1DC3A6468(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  if (v16) {
    operator delete(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC3A64CC(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, int a5)
{
  int v9 = (int)(*(float (**)(void))(**(void **)a2 + 16))();
  int v10 = (int)(*(float (**)(void))(**(void **)a2 + 24))();
  int v11 = (int)(*(float (**)(void))(*(void *)*a3 + 16))();
  int v12 = (int)(*(float (**)(void))(*(void *)*a3 + 24))();
  uint64_t v13 = *a3;
  unsigned int v14 = *(float (**)(uint64_t))(*(void *)*a3 + 16);
  if (a5)
  {
    sub_1DC3A67E4(a1, v9, v10, v11, v12, a4);
    int v15 = (int)v14(v13);
    int v16 = (int)(*(float (**)(void))(*(void *)*a3 + 24))();
    int v17 = (int)(*(float (**)(void))(**(void **)a2 + 16))();
    float v18 = (*(float (**)(void))(**(void **)a2 + 24))();
    sub_1DC3A67E4(a1, v15, v16, v17, (int)v18, a4);
  }
  else
  {
    sub_1DC3A6950(a1, v9, v10, v11, v12, a4);
    int v19 = (int)v14(v13);
    int v20 = (int)(*(float (**)(void))(*(void *)*a3 + 24))();
    int v21 = (int)(*(float (**)(void))(**(void **)a2 + 16))();
    float v22 = (*(float (**)(void))(**(void **)a2 + 24))();
    sub_1DC3A6950(a1, v19, v20, v21, (int)v22, a4);
  }
}

float sub_1DC3A67E4(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  if (a5 - a3 >= 0) {
    unsigned int v6 = a5 - a3;
  }
  else {
    unsigned int v6 = a3 - a5;
  }
  if (a4 - a2 >= 0) {
    unsigned int v7 = a4 - a2;
  }
  else {
    unsigned int v7 = a2 - a4;
  }
  if (v6 > v7) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = v6;
  }
  unsigned int v34 = v8;
  if (v6 > v7) {
    int v9 = a4 - a2;
  }
  else {
    int v9 = a5 - a3;
  }
  if (v6 > v7) {
    unsigned int v10 = v6;
  }
  else {
    unsigned int v10 = v7;
  }
  if (v6 > v7) {
    int v11 = a4;
  }
  else {
    int v11 = a5;
  }
  if (v6 > v7) {
    int v12 = a5;
  }
  else {
    int v12 = a4;
  }
  if (v6 > v7) {
    int v13 = a2;
  }
  else {
    int v13 = a3;
  }
  if (v6 > v7) {
    int v14 = a3;
  }
  else {
    int v14 = a2;
  }
  if (v14 < v12) {
    int v15 = 1;
  }
  else {
    int v15 = -1;
  }
  if (v13 < v11) {
    int v16 = 1;
  }
  else {
    int v16 = -1;
  }
  int v32 = v16;
  int v33 = v11;
  int v17 = v15 + v12;
  int v18 = v15 + v12 - v14;
  if (v17 == v14) {
    return NAN;
  }
  int v29 = v18;
  int v30 = v9;
  int v19 = 0;
  unsigned int v31 = v10;
  int v20 = (signed int)-v10 >> 1;
  int v21 = *(void **)(a1 + 16);
  int v27 = v14;
  int v28 = v13;
  do
  {
    if (v6 <= v7) {
      int v22 = v14;
    }
    else {
      int v22 = v13;
    }
    if (v6 <= v7) {
      int v23 = v13;
    }
    else {
      int v23 = v14;
    }
    if ((((v19 == 1) ^ a6 ^ sub_1DC2FF924(v21, v22, v23)) & 1) == 0)
    {
      if (v19 == 2)
      {
        int v24 = v14 - v27;
        int v25 = v13 - v28;
        return sqrt((double)(v24 * v24 + v25 * v25));
      }
      ++v19;
    }
    v20 += v34;
    if (v20 >= 1)
    {
      if (v13 == v33) {
        break;
      }
      v13 += v32;
      v20 -= v31;
    }
    v14 += v15;
  }
  while (v17 != v14);
  if (v19 != 2) {
    return NAN;
  }
  int v25 = v29;
  int v24 = v30;
  return sqrt((double)(v24 * v24 + v25 * v25));
}

void sub_1DC3A6950(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  if (sub_1DC3A67E4(a1, a2, a3, a4, a5, a6) > 0.0)
  {
    int v12 = a2 - a4 + a2;
    int v13 = *(_DWORD **)(a1 + 16);
    int v14 = v13[14];
    int v15 = -v14;
    int v16 = v13[8];
    int v17 = v14 - 1;
    int v18 = v13[4];
    float v19 = (float)a2;
    if (v12 < 0)
    {
      int v12 = 0;
      float v21 = v19 / (float)(a4 - a2);
    }
    else
    {
      int v20 = v18 & v17 | v16 & v15;
      if (v12 >= v20)
      {
        int v12 = v20 - 1;
        float v21 = (float)(v20 - 1 - a2) / (float)(a2 - a4);
      }
      else
      {
        float v21 = 1.0;
      }
    }
    int v22 = (int)(float)((float)a3 + (float)((float)(a3 - a5) * v21));
    if (v22 < 0)
    {
      int v25 = a3 - v22;
      int v22 = 0;
      float v24 = (float)a3 / (float)v25;
    }
    else
    {
      int v23 = v16 & v17 | v18 & v15;
      if (v22 >= v23)
      {
        int v26 = v22 - a3;
        int v22 = v23 - 1;
        float v24 = (float)(v23 - 1 - a3) / (float)v26;
      }
      else
      {
        float v24 = 1.0;
      }
    }
    sub_1DC3A67E4(a1, a2, a3, (int)(float)(v19 + (float)((float)(v12 - a2) * v24)), v22, a6);
  }
}

float sub_1DC3A6ACC(uint64_t a1, int a2, signed int a3)
{
  unint64_t v3 = (a3 - 1);
  unsigned int v4 = v3 >> 1;
  float result = (float)a2;
  if ((int)((v3 >> 1) + 1) < a3)
  {
    unint64_t v6 = v3 >> 1;
    unint64_t v7 = ~(v3 >> 1) + a3;
    unsigned int v8 = (int *)(a1 + 4 * v6 + 4);
    do
    {
      int v9 = *v8++;
      float result = result - (float)v9;
      --v7;
    }
    while (v7);
  }
  if ((a3 & 0x80000001) == 1) {
    return result + (float)((float)*(int *)(a1 + 4 * v4) * -0.5);
  }
  return result;
}

uint64_t sub_1DC3A6B34(uint64_t result, __n128 a2)
{
  uint64_t v2 = 0;
  int v3 = 0;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  a2.n128_u32[0] = -10.0;
  while (1)
  {
    int v4 = *(_DWORD *)(result + v2);
    if (!v4) {
      break;
    }
    v3 += v4;
    v2 += 4;
    if (v2 == 20)
    {
      if (v3 >= 5)
      {
        float result = MEMORY[0x1F4188790](a2);
        for (uint64_t i = 0; i != 20; i += 4)
          *(float *)((char *)&v21 + i) = (float)*(int *)(result + i);
        float v9 = (float)v7;
        if ((v6 & 1) != 0
          && ((float v10 = (float)(v9 - v21) / 6.0, v21 >= (float)(v10 + v10))
           && (float v11 = v10 * 0.5, vabds_f32(v10, v22) < (float)(v10 * 0.5))
           && fabsf(-(float)(v23 - (float)(v10 * 3.0))) < (float)(v11 + v11)
           && vabds_f32(v10, v24) < v11
           && vabds_f32(v10, v25) < v11
           || (float v10 = (float)(v9 - v25) / 6.0, v12 = v10 * 0.5, vabds_f32(v10, v21) < (float)(v10 * 0.5))
           && vabds_f32(v10, v22) < v12
           && fabsf(-(float)(v23 - (float)(v10 * 3.0))) < (float)(v12 + v12)
           && ((float v13 = vabds_f32(v10, v24), v25 >= (float)(v10 + v10)) ? (v14 = v13 < v12) : (v14 = 0), v14)))
        {
          if (v5) {
            *long long v5 = v10;
          }
        }
        else
        {
          uint64_t v15 = 0;
          float v16 = 0.0;
          do
          {
            float v16 = v16 + (float)(*(float *)((char *)&v21 + v15 * 4) * *(float *)&dword_1DC40F738[v15]);
            ++v15;
          }
          while (v15 != 5);
          uint64_t v17 = 0;
          float v18 = 0.0;
          do
          {
            float v18 = v18 + (float)(*(float *)((char *)&v21 + v17) * *(float *)((char *)&v21 + v17));
            v17 += 4;
          }
          while (v17 != 20);
          uint64_t v19 = 0;
          float v20 = 0.0;
          do
          {
            float v20 = v20 + (float)(*(float *)&dword_1DC40F738[v19] * *(float *)&dword_1DC40F738[v19]);
            ++v19;
          }
          while (v19 != 5);
          if (v5) {
            *long long v5 = v9 / 7.0;
          }
        }
      }
      return result;
    }
  }
  return result;
}

float sub_1DC3A6D54(uint64_t a1)
{
  uint64_t v1 = 0;
  int v2 = 0;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  float result = -10.0;
  while (1)
  {
    int v4 = *(_DWORD *)(a1 + v1);
    if (!v4) {
      break;
    }
    v2 += v4;
    v1 += 4;
    if (v1 == 36)
    {
      if (v2 >= 9)
      {
        uint64_t v5 = 0;
        int v30 = 1065353216;
        v29[0] = xmmword_1DC40F74C;
        v29[1] = unk_1DC40F75C;
        do
        {
          *(float *)&v28[v5] = (float)*(int *)(a1 + v5);
          v5 += 4;
        }
        while (v5 != 36);
        float v6 = 0.0;
        uint64_t v7 = 1u;
        do
        {
          float v6 = v6 + (float)(*(float *)&dword_1DC40F770[v7] * *(float *)&dword_1DC40F770[v7]);
          ++v7;
        }
        while (v7 != 8);
        float v8 = 0.0;
        uint64_t v9 = 1u;
        do
        {
          float v8 = v8 + (float)(*(float *)((char *)v29 + v9 * 4) * *(float *)&dword_1DC40F770[v9]);
          ++v9;
        }
        while (v9 != 8);
        float v10 = 0.0;
        uint64_t v11 = 1u;
        do
        {
          float v10 = v10 + (float)(*(float *)&v28[v11 * 4] * *(float *)&dword_1DC40F770[v11]);
          ++v11;
        }
        while (v11 != 8);
        float v12 = 0.0;
        for (uint64_t i = 4; i != 32; i += 4)
          float v12 = v12 + (float)(*(float *)&v28[i] * *(float *)&v28[i]);
        float v14 = 0.0;
        for (uint64_t j = 4; j != 32; j += 4)
          float v14 = v14 + (float)(*(float *)&v28[j] * *(float *)((char *)v29 + j));
        float v16 = (float)((float)(v10 * v14) - (float)(v8 * v12)) / (float)((float)(v6 * v12) - (float)(v10 * v10));
        float result = -10.0;
        if (v16 >= -0.5 && v16 <= 0.5)
        {
          for (uint64_t k = 0; k != 9; ++k)
            *(float *)((char *)v29 + k * 4) = *(float *)((char *)v29 + k * 4)
                                            + (float)(v16 * *(float *)&dword_1DC40F770[k]);
          float v19 = 0.0;
          for (uint64_t m = 4; m != 32; m += 4)
            float v19 = v19 + (float)(*(float *)&v28[m] * *(float *)((char *)v29 + m));
          float v21 = 0.0;
          for (uint64_t n = 4; n != 32; n += 4)
            float v21 = v21 + (float)(*(float *)&v28[n] * *(float *)&v28[n]);
          float v23 = 0.0;
          for (iuint64_t i = 4; ii != 32; ii += 4)
            float v23 = v23 + (float)(*(float *)((char *)v29 + ii) * *(float *)((char *)v29 + ii));
          uint64_t v25 = 0;
          float v26 = -v21;
          float v27 = 0.0;
          do
          {
            float v27 = v27 + (float)(*(float *)&v28[v25] * *(float *)&v28[v25]);
            v25 += 4;
          }
          while (v25 != 36);
          return (float)((float)(v23 * v26) + (float)(v19 * v19)) / (float)(v27 + v27);
        }
      }
      return result;
    }
  }
  return result;
}

float sub_1DC3A6FA0(uint64_t a1, uint64_t a2)
{
  int v2 = 0;
  for (uint64_t i = 4; i != 32; i += 4)
    v2 += *(_DWORD *)(a1 + i) * *(_DWORD *)(a1 + i);
  int v4 = 0;
  for (uint64_t j = 4; j != 32; j += 4)
    v4 += *(_DWORD *)(a2 + j);
  int v6 = 0;
  for (uint64_t k = 4; k != 32; k += 4)
    v6 += *(_DWORD *)(a2 + k) * *(_DWORD *)(a2 + k);
  int v8 = 0;
  for (uint64_t m = 4; m != 32; m += 4)
    v8 += *(_DWORD *)(a1 + m);
  float result = (float)((float)(v4 * v2) - (float)(v8 * v6)) / (float)((float)(v4 * v2) + (float)(v8 * v6));
  if (result > 0.0) {
    return -result;
  }
  return result;
}

float sub_1DC3A703C(void *a1, int a2, uint64_t a3, unint64_t a4, int *a5, unsigned int a6, int a7)
{
  uint64_t v12 = (a6 - 1) >> 1;
  unint64_t v35 = a6 - 1;
  unsigned int v13 = a7 ^ (((a6 - 1) & 2) >> 1);
  uint64_t v36 = a1[4] & (a1[7] - 1) | a1[2] & -a1[7];
  bzero(a5, 4 * a6);
  uint64_t v14 = v12;
  LODWORD(v15) = a2;
  uint64_t v37 = v12;
  while (1)
  {
    if ((v15 & 0x80000000) != 0)
    {
LABEL_24:
      if (v14 > 1) {
        return NAN;
      }
    }
    else
    {
      int v16 = (int)v14 >= 0 ? v14 & 1 : -(v14 & 1);
      BOOL v17 = v14 == v12 || v14 == 0;
      BOOL v18 = !v17;
      uint64_t v15 = v15;
      while (1)
      {
        char v19 = sub_1DC2FF924(a1, a3, v15);
        if (v16 == v13)
        {
          if ((v19 & 1) == 0) {
            break;
          }
        }
        else if (v19)
        {
          break;
        }
        unint64_t v20 = a5[v14];
        if (v20 > a4 && v18) {
          break;
        }
        a5[v14] = v20 + 1;
        BOOL v22 = v15-- <= 0;
        if (v22)
        {
          LODWORD(v15) = -1;
          uint64_t v12 = v37;
          goto LABEL_24;
        }
      }
      uint64_t v12 = v37;
    }
    if (v14 >= 1 && v14 < v12 && a5[v14] > a4) {
      return NAN;
    }
    BOOL v22 = v14-- <= 0;
    if (v22)
    {
      int v23 = a2 + 1;
      unint64_t v24 = a6 - 2;
      unint64_t v25 = v12;
      while (1)
      {
        if (v23 < (int)v36)
        {
          if ((v25 & 0x80000000) == 0) {
            int v26 = v25 & 1;
          }
          else {
            int v26 = -(v25 & 1);
          }
          BOOL v28 = v25 != v12 && v25 != v35;
          uint64_t v29 = v23;
          while (1)
          {
            char v30 = sub_1DC2FF924(a1, a3, v29);
            if (v26 == v13)
            {
              if ((v30 & 1) == 0) {
                break;
              }
            }
            else if (v30)
            {
              break;
            }
            unint64_t v31 = a5[v25];
            if (v31 > a4 && v28) {
              break;
            }
            a5[v25] = v31 + 1;
            if ((int)v36 == ++v29)
            {
              int v23 = v36;
              goto LABEL_55;
            }
          }
          int v23 = v29;
LABEL_55:
          uint64_t v12 = v37;
          unint64_t v24 = a6 - 2;
        }
        if (v25 < v24 && v23 == v36 || v25 > v12 && v25 < v35 && a5[v25] > a4) {
          return NAN;
        }
        if (++v25 == a6)
        {
          return sub_1DC3A6ACC((uint64_t)a5, v23, a6);
        }
      }
    }
  }
}

float sub_1DC3A72B8(void *a1, int a2, uint64_t a3, unint64_t a4, int *a5, unsigned int a6, int a7)
{
  uint64_t v12 = (a6 - 1) >> 1;
  unint64_t v35 = a6 - 1;
  unsigned int v13 = a7 ^ (((a6 - 1) & 2) >> 1);
  uint64_t v36 = a1[2] & (a1[7] - 1) | a1[4] & -a1[7];
  bzero(a5, 4 * a6);
  uint64_t v14 = v12;
  LODWORD(v15) = a2;
  uint64_t v37 = v12;
  while (1)
  {
    if ((v15 & 0x80000000) != 0)
    {
LABEL_24:
      if (v14 > 1) {
        return NAN;
      }
    }
    else
    {
      int v16 = (int)v14 >= 0 ? v14 & 1 : -(v14 & 1);
      BOOL v17 = v14 == v12 || v14 == 0;
      BOOL v18 = !v17;
      uint64_t v15 = v15;
      while (1)
      {
        char v19 = sub_1DC2FF924(a1, v15, a3);
        if (v16 == v13)
        {
          if ((v19 & 1) == 0) {
            break;
          }
        }
        else if (v19)
        {
          break;
        }
        unint64_t v20 = a5[v14];
        if (v20 > a4 && v18) {
          break;
        }
        a5[v14] = v20 + 1;
        BOOL v22 = v15-- <= 0;
        if (v22)
        {
          LODWORD(v15) = -1;
          uint64_t v12 = v37;
          goto LABEL_24;
        }
      }
      uint64_t v12 = v37;
    }
    if (v14 >= 1 && v14 < v12 && a5[v14] > a4) {
      return NAN;
    }
    BOOL v22 = v14-- <= 0;
    if (v22)
    {
      int v23 = a2 + 1;
      unint64_t v24 = a6 - 2;
      unint64_t v25 = v12;
      while (1)
      {
        if (v23 < (int)v36)
        {
          if ((v25 & 0x80000000) == 0) {
            int v26 = v25 & 1;
          }
          else {
            int v26 = -(v25 & 1);
          }
          BOOL v28 = v25 != v12 && v25 != v35;
          uint64_t v29 = v23;
          while (1)
          {
            char v30 = sub_1DC2FF924(a1, v29, a3);
            if (v26 == v13)
            {
              if ((v30 & 1) == 0) {
                break;
              }
            }
            else if (v30)
            {
              break;
            }
            unint64_t v31 = a5[v25];
            if (v31 > a4 && v28) {
              break;
            }
            a5[v25] = v31 + 1;
            if ((int)v36 == ++v29)
            {
              int v23 = v36;
              goto LABEL_55;
            }
          }
          int v23 = v29;
LABEL_55:
          uint64_t v12 = v37;
          unint64_t v24 = a6 - 2;
        }
        if (v25 < v24 && v23 == v36 || v25 > v12 && v25 < v35 && a5[v25] > a4) {
          return NAN;
        }
        if (++v25 == a6)
        {
          return sub_1DC3A6ACC((uint64_t)a5, v23, a6);
        }
      }
    }
  }
}

float sub_1DC3A7534(uint64_t a1, int a2, unsigned int a3, unint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, __n128 a9, char a10)
{
  uint64_t v10 = a6;
  float v13 = a9.n128_f32[0];
  uint64_t v14 = 0;
  unint64_t v77 = (a7 - 1);
  int v15 = a8 ^ (((a7 - 1) & 2) >> 1);
  int v16 = *(void **)a1;
  uint64_t v17 = *(void *)(*(void *)a1 + 56);
  uint64_t v18 = -v17;
  uint64_t v19 = *(void *)(*(void *)a1 + 16);
  uint64_t v20 = v19 & -v17;
  LODWORD(v17) = v17 - 1;
  uint64_t v21 = *(void *)(*(void *)a1 + 32);
  int v74 = v21 & v17 | v20;
  int v73 = v19 & v17 | v21 & v18;
  do
  {
    *(_DWORD *)(a5 + 4 * v14) = 0;
    *(_DWORD *)(a6 + 4 * v14++) = 0;
  }
  while (a7 != v14);
  a9.n128_u32[0] = -1.0;
  float v22 = v13 + -1.0;
  uint64_t v23 = v77 >> 1;
  uint64_t v78 = v23;
  unsigned int v24 = a3;
  LODWORD(v25) = a2;
  while (1)
  {
    if ((v25 & 0x80000000) == 0 && (v24 & 0x80000000) == 0)
    {
      if ((int)v23 >= 0) {
        int v26 = v23 & 1;
      }
      else {
        int v26 = -(v23 & 1);
      }
      BOOL v28 = v23 != v78 && v23 != 0;
      uint64_t v29 = v24;
      uint64_t v25 = v25;
      while (1)
      {
        char v30 = sub_1DC2FF924(v16, v29, v25);
        if (v26 == v15)
        {
          if ((v30 & 1) == 0) {
            break;
          }
        }
        else if (v30)
        {
          break;
        }
        unint64_t v31 = *(int *)(a5 + 4 * v23);
        if (v31 > a4 && v28) {
          break;
        }
        *(_DWORD *)(a5 + 4 * v23) = v31 + 1;
        unsigned int v24 = v29 - 1;
        BOOL v33 = v25-- < 1;
        if (!v33)
        {
          BOOL v33 = v29-- <= 0;
          if (!v33) {
            continue;
          }
        }
        goto LABEL_29;
      }
      unsigned int v24 = v29;
    }
LABEL_29:
    if (v23 > 1 && ((v24 | v25) & 0x80000000) != 0
      || v23 >= 1 && v23 < v78 && *(int *)(a5 + 4 * v23) > a4)
    {
      return v22;
    }
    BOOL v33 = v23-- <= 0;
    if (v33)
    {
      uint64_t v69 = v10;
      LODWORD(v34) = a2 + 1;
      LODWORD(v10) = a3 + 1;
      unint64_t v75 = (a7 - 2);
      int v36 = v73;
      int v35 = v74;
      unint64_t v37 = v77 >> 1;
      while (1)
      {
        if ((int)v34 < v35 && (int)v10 < v36)
        {
          if ((v37 & 0x80000000) == 0) {
            int v38 = v37 & 1;
          }
          else {
            int v38 = -(v37 & 1);
          }
          BOOL v40 = v37 != v78 && v37 != v77;
          uint64_t v10 = (int)v10;
          uint64_t v34 = (int)v34;
          do
          {
            char v41 = sub_1DC2FF924(v16, v10, v34);
            if (v38 == v15)
            {
              if ((v41 & 1) == 0) {
                break;
              }
            }
            else if (v41)
            {
              break;
            }
            unint64_t v42 = *(int *)(a5 + 4 * v37);
            if (v42 > a4 && v40) {
              break;
            }
            *(_DWORD *)(a5 + 4 * v37) = v42 + 1;
            ++v34;
            ++v10;
            if (v34 >= v74) {
              break;
            }
          }
          while (v10 < v73);
          int v36 = v73;
          int v35 = v74;
        }
        if (v37 < v75 && (v34 == v35 || v10 == v36)
          || v37 > v78 && v37 < v77 && *(int *)(a5 + 4 * v37) > a4)
        {
          return v22;
        }
        if (++v37 == a7)
        {
          if (a10) {
            v44.n128_f32[0] = sub_1DC3A6D54(a5);
          }
          else {
            sub_1DC3A6B34(a5, a9);
          }
          float v45 = v44.n128_f32[0];
          if (v44.n128_f32[0] >= v13)
          {
            uint64_t v47 = v77 >> 1;
            LODWORD(v49) = a2;
            LODWORD(v48) = a3;
            while (1)
            {
              if ((v49 & 0x80000000) == 0 && (int)v48 < v36)
              {
                if ((int)v47 >= 0) {
                  int v50 = v47 & 1;
                }
                else {
                  int v50 = -(v47 & 1);
                }
                BOOL v52 = v47 != v78 && v47 != 0;
                uint64_t v48 = (int)v48;
                uint64_t v49 = v49;
                unint64_t v53 = *(void **)a1;
                do
                {
                  char v54 = sub_1DC2FF924(v53, v48, v49);
                  if (v50 == v15)
                  {
                    if ((v54 & 1) == 0) {
                      break;
                    }
                  }
                  else if (v54)
                  {
                    break;
                  }
                  unint64_t v55 = *(int *)(v69 + 4 * v47);
                  if (v55 > a4 && v52) {
                    break;
                  }
                  *(_DWORD *)(v69 + 4 * v47) = v55 + 1;
                  ++v48;
                  BOOL v33 = v49-- < 1;
                  if (v33) {
                    break;
                  }
                }
                while (v48 < v73);
                int v36 = v73;
                int v35 = v74;
              }
              if (v47 > 1 && ((v49 & 0x80000000) != 0 || v48 == v36)
                || v47 >= 1 && v47 < v78 && *(int *)(v69 + 4 * v47) > a4)
              {
                break;
              }
              BOOL v33 = v47-- <= 0;
              if (v33)
              {
                unsigned int v57 = a3 - 1;
                unint64_t v58 = v77 >> 1;
                LODWORD(v59) = a2 + 1;
                while (1)
                {
                  if ((int)v59 < v35 && (v57 & 0x80000000) == 0)
                  {
                    if ((v58 & 0x80000000) == 0) {
                      int v60 = v58 & 1;
                    }
                    else {
                      int v60 = -(v58 & 1);
                    }
                    BOOL v62 = v58 != v78 && v58 != v77;
                    uint64_t v63 = v57;
                    uint64_t v59 = (int)v59;
                    unint64_t v64 = *(void **)a1;
                    while (1)
                    {
                      char v65 = sub_1DC2FF924(v64, v63, v59);
                      if (v60 == v15)
                      {
                        if ((v65 & 1) == 0) {
                          break;
                        }
                      }
                      else if (v65)
                      {
                        break;
                      }
                      unint64_t v66 = *(int *)(v69 + 4 * v58);
                      if (v66 > a4 && v62) {
                        break;
                      }
                      *(_DWORD *)(v69 + 4 * v58) = v66 + 1;
                      ++v59;
                      unsigned int v57 = v63 - 1;
                      if (v59 < v74)
                      {
                        BOOL v33 = v63-- <= 0;
                        if (!v33) {
                          continue;
                        }
                      }
                      goto LABEL_130;
                    }
                    unsigned int v57 = v63;
LABEL_130:
                    int v35 = v74;
                  }
                  if (v58 < v75 && (v59 == v35 || (v57 & 0x80000000) != 0)
                    || v58 > v78 && v58 < v77 && *(int *)(v69 + 4 * v58) > a4)
                  {
                    return v22;
                  }
                  if (++v58 == a7)
                  {
                    if (a10) {
                      float v68 = sub_1DC3A6D54(v69);
                    }
                    else {
                      sub_1DC3A6B34(v69, v44);
                    }
                    return v45 + v68;
                  }
                }
              }
            }
          }
          return v22;
        }
      }
    }
  }
}

void sub_1DC3A7A48()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1DC3A7DAC(_Unwind_Exception *a1)
{
  sub_1DC35D870((atomic_uint **)(v1 - 160));
  _Unwind_Resume(a1);
}

BOOL sub_1DC3A7DC0(uint64_t a1, atomic_uint **a2, atomic_uint *a3)
{
  float v4 = *((float *)*a2 + 5);
  if (v4 > 0.0)
  {
    float v7 = (*(float (**)(atomic_uint *))(*(void *)*a2 + 16))(*a2);
    (*(void (**)(void))(*(void *)*a2 + 24))();
    unint64_t v9 = *((void *)a3 + 1);
    uint64_t v10 = v9 - *(void *)a3;
    if (v9 != *(void *)a3)
    {
      float v11 = v8;
      uint64_t v12 = 0;
      float v13 = *((float *)*a2 + 6);
      unint64_t v14 = v10 >> 3;
      if (v14 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = v14;
      }
      do
      {
        uint64_t v16 = *(void *)a3;
        v33[0] = 0;
        uint64_t v17 = *(atomic_uint **)(v16 + 8 * v12);
        if (v17) {
          atomic_fetch_add_explicit(v17 + 2, 1u, memory_order_relaxed);
        }
        v33[0] = v17;
        if (sub_1DC379C50((float *)v17, v4, v11, v7))
        {
          uint64_t v31 = 0;
          uint64_t v32 = 0;
          int v30 = 0;
          sub_1DC379D1C((uint64_t)v33[0], (float *)&v32, (float *)&v31 + 1, (float *)&v31, (float *)&v30, (int *)&v32 + 1, v11, v7, v4, v13);
          operator new();
        }
        sub_1DC35D870(v33);
        ++v12;
      }
      while (v15 != v12);
      unint64_t v9 = *((void *)a3 + 1);
    }
    unint64_t v18 = *((void *)a3 + 2);
    if (v9 >= v18)
    {
      uint64_t v20 = (uint64_t)(v9 - *(void *)a3) >> 3;
      if ((unint64_t)(v20 + 1) >> 61) {
        sub_1DC2FF97C();
      }
      uint64_t v21 = v18 - *(void *)a3;
      uint64_t v22 = v21 >> 2;
      if (v21 >> 2 <= (unint64_t)(v20 + 1)) {
        uint64_t v22 = v20 + 1;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v22;
      }
      int v36 = (uint64_t *)(a3 + 4);
      if (v23) {
        unint64_t v23 = (unint64_t)sub_1DC2FFD7C(v23);
      }
      else {
        uint64_t v24 = 0;
      }
      uint64_t v25 = (atomic_uint *)(v23 + 8 * v20);
      v33[0] = (atomic_uint *)v23;
      v33[1] = v25;
      uint64_t v34 = v25;
      unint64_t v35 = v23 + 8 * v24;
      *(void *)uint64_t v25 = 0;
      int v26 = *a2;
      float v27 = v25;
      if (*a2)
      {
        atomic_fetch_add_explicit(v26 + 2, 1u, memory_order_relaxed);
        float v27 = v25;
        if (*(void *)v25)
        {
          sub_1DC2FF57C(*(atomic_uint **)v25);
          float v27 = v34;
        }
      }
      *(void *)uint64_t v25 = v26;
      uint64_t v34 = v27 + 2;
      sub_1DC38A3F0(a3, v33);
      unint64_t v19 = *((void *)a3 + 1);
      sub_1DC38A4E8((uint64_t)v33);
    }
    else
    {
      sub_1DC38A390(a3, a2);
      unint64_t v19 = v9 + 8;
    }
    *((void *)a3 + 1) = v19;
    uint64_t v28 = *(void *)(a1 + 112);
    if (v28) {
      (*(void (**)(uint64_t, atomic_uint *))(*(void *)v28 + 16))(v28, *a2);
    }
  }
  return v4 > 0.0;
}

void sub_1DC3A80D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, atomic_uint *);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1DC35D870((atomic_uint **)va);
  sub_1DC35D870((atomic_uint **)va1);
  _Unwind_Resume(a1);
}

float sub_1DC3A8110(void *a1, uint64_t a2)
{
  float v4 = (*(float (**)(void))(*(void *)*a1 + 16))(*a1);
  float v5 = v4 - (*(float (**)(void))(**(void **)a2 + 16))();
  float v6 = (*(float (**)(void))(*(void *)*a1 + 24))();
  float v7 = (*(float (**)(void))(**(void **)a2 + 24))();
  return sqrtf((float)((float)(v6 - v7) * (float)(v6 - v7)) + (float)(v5 * v5));
}

uint64_t sub_1DC3A81F8(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)a1 = 0;
  uint64_t v5 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
    float v6 = *(atomic_uint **)a1;
    if (*(void *)a1) {
      sub_1DC2FF57C(v6);
    }
  }
  *(void *)a1 = v5;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(unsigned char *)(a1 + 104) = 0;
  uint64_t v7 = *a3;
  if (v7)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 8), 1u, memory_order_relaxed);
    float v8 = *(atomic_uint **)(a1 + 112);
    if (v8) {
      sub_1DC2FF57C(v8);
    }
  }
  *(void *)(a1 + 112) = v7;
  return a1;
}

void sub_1DC3A82AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v10 + 80);
  sub_1DC312234(&a10);
  a10 = (void **)(v10 + 56);
  sub_1DC3853C0(&a10);
  a10 = (void **)(v10 + 32);
  sub_1DC312234(&a10);
  sub_1DC3853C0(&a10);
  sub_1DC2FF548((atomic_uint **)v10);
  _Unwind_Resume(a1);
}

void sub_1DC3A82FC()
{
}

void sub_1DC3A838C(_Unwind_Exception *a1)
{
  sub_1DC30184C((atomic_uint **)(v1 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3A83A0(void *a1, uint64_t a2, uint64_t *a3)
{
  (*(void (**)(void, uint64_t *))(**(void **)(a2 + 288) + 16))(*(void *)(a2 + 288), a3);
  uint64_t result = (uint64_t)sub_1DC314F54(a1, (unint64_t)((a3[1] - *a3) >> 2) >> 1);
  uint64_t v8 = *a3;
  if ((unint64_t)(a3[1] - *a3) >= 5)
  {
    char v9 = 0;
    unint64_t v10 = 0;
    __int16 v37 = 0;
    do
    {
      float v11 = (const float *)(v8 + 4 * v10);
      float32x4_t v12 = vld1q_dup_f32(v11++);
      *(float *)v7.i32 = *v11;
      int32x4_t v13 = *(int32x4_t *)(a2 + 96);
      int32x4_t v14 = *(int32x4_t *)(a2 + 112);
      int32x4_t v15 = *(int32x4_t *)(a2 + 128);
      int32x4_t v34 = *(int32x4_t *)(a2 + 144);
      int32x2_t v35 = v7;
      int32x4_t v16 = vzip2q_s32(v13, v15);
      float32x4_t v17 = (float32x4_t)vzip1q_s32(vzip1q_s32(v13, v15), v14);
      float32x4_t v18 = (float32x4_t)vtrn2q_s32(v13, v14);
      v18.i32[2] = HIDWORD(*(void *)(a2 + 128));
      float32x4_t v36 = v12;
      int32x4_t v19 = (int32x4_t)vaddq_f32((float32x4_t)vzip1q_s32(v16, vdupq_laneq_s32(v14, 2)), vmlaq_n_f32(vmulq_f32(v12, v17), v18, *v11));
      int32x4_t v32 = *(int32x4_t *)(a2 + 176);
      int32x4_t v33 = *(int32x4_t *)(a2 + 160);
      if (sub_1DC3A85D8(*(void *)(a2 + 24), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 48), (unsigned char *)&v37 + 1, COERCE_DOUBLE(vdiv_f32(*(float32x2_t *)v19.i8, (float32x2_t)vdup_laneq_s32(v19, 2))), *(double *)(a2 + 176), *(double *)v33.i64, *(double *)v17.i64, *(double *)v16.i64, v12.f32[0], *v11)&& (v21 = (float32x4_t)vtrn2q_s32(v34, v33), v21.i32[2] = v32.i32[1], v22 = vmlaq_f32(vmulq_f32(v36, (float32x4_t)vzip1q_s32(vzip1q_s32(v34, v32), v33)), (float32x4_t)vdupq_lane_s32(v35, 0), v21), int32x4_t v23 = (int32x4_t)vaddq_f32((float32x4_t)vzip1q_s32(vzip2q_s32(v34, v32), vdupq_laneq_s32(v33, 2)), v22),
            float32x2_t v24 = (float32x2_t)vdup_laneq_s32(v23, 2),
            uint64_t result = sub_1DC3A85D8(*(void *)(a2 + 56), *(_DWORD *)(a2 + 64), *(_DWORD *)(a2 + 72), *(_DWORD *)(a2 + 80), &v37, COERCE_DOUBLE(vdiv_f32(*(float32x2_t *)v23.i8, v24)), *(double *)&v24, *(double *)v22.i64, *(double *)v21.i64, *(double *)v36.i64, *(float *)v32.i32, v20), result))
      {
        uint64_t v25 = (void *)*a1;
        unint64_t v26 = v10 >> 7;
        uint64_t v27 = 1 << v9;
        if (HIBYTE(v37) > v37) {
          goto LABEL_8;
        }
      }
      else
      {
        uint64_t result = rand();
        uint64_t v25 = (void *)*a1;
        unint64_t v26 = v10 >> 7;
        uint64_t v27 = 1 << v9;
        if ((result & 1) == 0)
        {
LABEL_8:
          uint64_t v28 = v25[v26] & ~v27;
          goto LABEL_9;
        }
      }
      uint64_t v28 = v25[v26] | v27;
LABEL_9:
      v25[v26] = v28;
      unint64_t v29 = v10 + 3;
      v10 += 2;
      uint64_t v8 = *a3;
      ++v9;
    }
    while (v29 < (a3[1] - *a3) >> 2);
  }
  if (*(unsigned char *)a2)
  {
    int v30 = (void *)*a1;
    unint64_t v31 = a1[1];
    if (v31 >= 0x40)
    {
      do
      {
        void *v30 = ~*v30;
        ++v30;
        v31 -= 64;
      }
      while (v31 > 0x3F);
    }
    if (v31) {
      *v30 ^= 0xFFFFFFFFFFFFFFFFLL >> -(char)v31;
    }
  }
  return result;
}

void sub_1DC3A85C0(_Unwind_Exception *exception_object)
{
  if (*v1) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3A85D8(uint64_t a1, int a2, int a3, int a4, unsigned char *a5, double a6, double a7, double a8, double a9, double a10, float a11, float a12)
{
  uint64_t v12 = 0;
  int v13 = (int)*((float *)&a6 + 1);
  if (((int)*((float *)&a6 + 1) & 0x80000000) == 0 && v13 < a3)
  {
    int v14 = (int)*(float *)&a6;
    if (((int)*(float *)&a6 & 0x80000000) == 0 && v14 < a2)
    {
      float v15 = *((float *)&a6 + 1) - (float)((float)v13 + 0.5);
      float v16 = (float)v14 + 0.5;
      float v17 = *(float *)&a6 - v16;
      if (v15 <= 0.0)
      {
        int v28 = 0;
        int v29 = v13 - 1;
        float32x4_t v18 = &v29;
        if (!v13) {
          float32x4_t v18 = &v28;
        }
      }
      else
      {
        int v28 = a3 - 1;
        int v29 = v13 + 1;
        float32x4_t v18 = &v28;
        if (v13 + 1 < a3) {
          float32x4_t v18 = &v29;
        }
      }
      int v19 = *v18;
      if (v17 <= 0.0)
      {
        int v28 = 0;
        int v29 = v14 - 1;
        float v20 = &v29;
        if (!v14) {
          float v20 = &v28;
        }
      }
      else
      {
        int v28 = a2 - 1;
        int v29 = v14 + 1;
        float v20 = &v28;
        if (v14 + 1 < a2) {
          float v20 = &v29;
        }
      }
      uint64_t v21 = *v20;
      float v22 = fabsf(v15);
      LOBYTE(v16) = *(unsigned char *)(a1 + v21 + v19 * (uint64_t)a4);
      float v23 = fabsf(v17);
      LOBYTE(a11) = *(unsigned char *)(a1 + v14 + v19 * (uint64_t)a4);
      *(float *)&unsigned int v24 = (float)(1.0 - v23) * (float)LODWORD(a11);
      float v25 = *(float *)&v24 + (float)(v23 * (float)LODWORD(v16));
      uint64_t v26 = v13 * a4;
      LOBYTE(v24) = *(unsigned char *)(a1 + v21 + v26);
      LOBYTE(a12) = *(unsigned char *)(a1 + v26 + v14);
      *a5 = (int)(float)((float)((float)(1.0 - v22)
                               * (float)((float)((float)(1.0 - v23) * (float)LODWORD(a12)) + (float)(v23 * (float)v24)))
                       + (float)(v22 * v25));
      return 1;
    }
  }
  return v12;
}

BOOL sub_1DC3A8728(int32x4_t *a1, double a2)
{
  int v2 = a1->u8[0];
  BOOL v3 = a1->i8[0] != 0;
  if ((LODWORD(a2) & 0x80000000) == 0
    && SLODWORD(a2) < a1[2].i32[0]
    && (HIDWORD(a2) & 0x80000000) == 0
    && SHIDWORD(a2) < a1[2].i32[2])
  {
    uint64_t v4 = a1[3].i64[1];
    unsigned int v5 = *(unsigned __int8 *)(a1[1].i64[1] + a1[3].i64[0] * HIDWORD(a2) + LODWORD(a2));
    unsigned __int8 v16 = 0;
    int32x4_t v6 = a1[12];
    int32x4_t v7 = a1[13];
    int32x4_t v8 = a1[14];
    int32x4_t v9 = vzip2q_s32(v6, v8);
    float32x4_t v10 = (float32x4_t)vzip1q_s32(vzip1q_s32(v6, v8), v7);
    float32x4_t v11 = (float32x4_t)vtrn2q_s32(v6, v7);
    v11.i32[2] = HIDWORD(a1[14].i64[0]);
    float32x4_t v12 = (float32x4_t)vzip1q_s32(v9, vdupq_laneq_s32(v7, 2));
    int32x4_t v13 = (int32x4_t)vaddq_f32(v12, vmlaq_n_f32(vmulq_n_f32(v10, (float)SLODWORD(a2)), v11, (float)SHIDWORD(a2)));
    float32x2_t v14 = (float32x2_t)vdup_laneq_s32(v13, 2);
    if (sub_1DC3A85D8(v4, a1[4].i32[0], a1[4].i32[2], a1[5].i32[0], &v16, COERCE_DOUBLE(vdiv_f32(*(float32x2_t *)v13.i8, v14)), *(double *)&v14, *(double *)v11.i64, *(double *)v12.i64, *(double *)v8.i64, v10.f32[0], *(float *)v9.i32))return v2 != v5 <= v16; {
  }
    }
  return v3;
}

uint64_t sub_1DC3A8814(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DC3A8890(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    unsigned int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      while (v4 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1DC3A8938(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >> 61) {
      sub_1DC2FF97C();
    }
    uint64_t v4 = 8 * a2;
    unsigned int v5 = (char *)operator new(8 * a2);
    *a1 = v5;
    a1[2] = &v5[8 * a2];
    bzero(v5, 8 * a2);
    a1[1] = &v5[v4];
  }
  return a1;
}

void sub_1DC3A89C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_1DC3A89D4(void *a1)
{
  if (a1)
  {
    sub_1DC3A89D4(*a1);
    sub_1DC3A89D4(a1[1]);
    int v2 = (std::__shared_weak_count *)a1[6];
    if (v2) {
      sub_1DC32EEF4(v2);
    }
    operator delete(a1);
  }
}

double sub_1DC3A8A2C(uint64_t a1, int a2, uint64_t a3, int a4, float32x4_t a5)
{
  if (a4 && !*(_DWORD *)a1)
  {
    if (a4 == 1)
    {
      uint64_t v6 = (float *)(a1 + 32);
      *(float32x4x2_t *)a5.f32 = vld2q_f32(v6);
      v22.val[1] = a5;
      vst2q_f32(v6, v22);
    }
    else
    {
      if (a2 >= 0) {
        unsigned int v9 = a2;
      }
      else {
        unsigned int v9 = -a2;
      }
      long double v10 = tan((double)a2 * 3.14159265 / 180.0);
      *(float *)&long double v10 = v10;
      int32x2_t v19 = *(int32x2_t *)&v10;
      int v11 = sub_1DC34F9F0(a1 + 96);
      sub_1DC34FA60((uint64_t **)(a1 + 96), (int)(v11+ (a2 + 360 * (((a2 & ~(a2 >> 31)) - (a2 + (a2 >> 31))) / 0x168 + (a2 >> 31)))% 0x168)% 360);
      long long v12 = *(_OWORD *)(a1 + 48);
      long long v20 = *(_OWORD *)(a1 + 32);
      long long v21 = v12;
      *(float *)v13.i32 = (float)(*(int (**)(uint64_t))(*(void *)a3 + 16))(a3) * 0.5;
      *(float *)v14.i32 = (float)SDWORD1(v20);
      if (v9 <= 0x2D)
      {
        for (uint64_t i = 0; i != 32; i += 8)
          *(_DWORD *)((char *)&v20 + i + 4) = llroundf(*(float *)v14.i32+ (float)((float)((float)*(int *)((char *)&v20 + i) - *(float *)v13.i32)* *(float *)v19.i32));
      }
      else
      {
        v23.val[1].i64[0] = __PAIR64__(DWORD2(v20), v20);
        float v15 = (float *)&v20;
        v23.val[1].i64[1] = __PAIR64__(DWORD2(v21), v21);
        v23.val[0] = (float32x4_t)vcvtq_s32_f32(vrndaq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v13, 0), vdivq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)v23.val[1]), (float32x4_t)vdupq_lane_s32(v14, 0)), (float32x4_t)vdupq_lane_s32(v19, 0)))));
        vst2q_f32(v15, v23);
      }
      a5.i64[0] = v20;
      long long v17 = v21;
      *(_OWORD *)(a1 + 32) = v20;
      *(_OWORD *)(a1 + 48) = v17;
    }
  }
  return *(double *)a5.i64;
}

void sub_1DC3A8C10(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    unsigned int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      while (v4 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1DC3A8CB8(void *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >= 0x1E1E1E1E1E1E1E2) {
      sub_1DC2FF97C();
    }
    uint64_t v6 = (char *)operator new(136 * a2);
    uint64_t v26 = v3;
    void *v3 = v6;
    v3[1] = v6;
    uint64_t v27 = &v6[136 * a2];
    v3[2] = v27;
    uint64_t v7 = (void *)(a3 + 104);
    do
    {
      *(void *)uint64_t v6 = *(void *)a3;
      if (*(char *)(a3 + 31) < 0)
      {
        sub_1DC34FC5C(v6 + 8, *(void **)(a3 + 8), *(void *)(a3 + 16));
      }
      else
      {
        *(_OWORD *)(v6 + 8) = *(_OWORD *)(a3 + 8);
        *((void *)v6 + 3) = *(void *)(a3 + 24);
      }
      *((void *)v6 + 8) = 0;
      long long v8 = *(_OWORD *)(a3 + 48);
      *((_OWORD *)v6 + 2) = *(_OWORD *)(a3 + 32);
      *((_OWORD *)v6 + 3) = v8;
      *((void *)v6 + 9) = 0;
      *((void *)v6 + 10) = 0;
      sub_1DC352C78((void *)v6 + 8, *(const void **)(a3 + 64), *(void *)(a3 + 72), *(void *)(a3 + 72) - *(void *)(a3 + 64));
      int v9 = *(_DWORD *)(a3 + 88);
      *((void *)v6 + 13) = 0;
      long double v10 = (uint64_t **)(v6 + 104);
      *((void *)v6 + 12) = v6 + 104;
      *((_DWORD *)v6 + 22) = v9;
      *((void *)v6 + 14) = 0;
      int v11 = *(void **)(a3 + 96);
      if (v11 != v7)
      {
        long long v12 = 0;
        while (1)
        {
          int32x2_t v13 = v6 + 104;
          if (*((uint64_t ***)v6 + 12) == v10) {
            goto LABEL_15;
          }
          int32x2_t v14 = v12;
          float v15 = v6 + 104;
          if (v12)
          {
            do
            {
              int32x2_t v13 = (char *)v14;
              int32x2_t v14 = (uint64_t *)v14[1];
            }
            while (v14);
          }
          else
          {
            do
            {
              int32x2_t v13 = (char *)*((void *)v15 + 2);
              BOOL v16 = *(void *)v13 == (void)v15;
              float v15 = v13;
            }
            while (v16);
          }
          int v17 = *((_DWORD *)v11 + 8);
          if (*((_DWORD *)v13 + 8) < v17)
          {
LABEL_15:
            float32x4_t v18 = (uint64_t **)(v12 ? v13 : v6 + 104);
            int32x2_t v19 = (uint64_t **)(v12 ? v13 + 8 : v6 + 104);
          }
          else
          {
            float32x4_t v18 = (uint64_t **)(v6 + 104);
            int32x2_t v19 = (uint64_t **)(v6 + 104);
            if (v12)
            {
              int32x2_t v19 = (uint64_t **)(v6 + 104);
              while (1)
              {
                while (1)
                {
                  float32x4_t v18 = (uint64_t **)v12;
                  int v24 = *((_DWORD *)v12 + 8);
                  if (v17 >= v24) {
                    break;
                  }
                  long long v12 = *v18;
                  int32x2_t v19 = v18;
                  if (!*v18) {
                    goto LABEL_22;
                  }
                }
                if (v24 >= v17) {
                  break;
                }
                int32x2_t v19 = v18 + 1;
                long long v12 = v18[1];
                if (!v12) {
                  goto LABEL_22;
                }
              }
            }
          }
          if (!*v19)
          {
LABEL_22:
            long long v20 = operator new(0x38uLL);
            v20[8] = *((_DWORD *)v11 + 8);
            *((void *)v20 + 5) = v11[5];
            uint64_t v21 = v11[6];
            *((void *)v20 + 6) = v21;
            if (v21) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
            }
            sub_1DC311D78((uint64_t **)v6 + 12, (uint64_t)v18, v19, (uint64_t *)v20);
          }
          float32x4x2_t v22 = (void *)v11[1];
          if (v22)
          {
            do
            {
              float32x4x2_t v23 = v22;
              float32x4x2_t v22 = (void *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              float32x4x2_t v23 = (void *)v11[2];
              BOOL v16 = *v23 == (void)v11;
              int v11 = v23;
            }
            while (!v16);
          }
          if (v23 == v7) {
            break;
          }
          long long v12 = *v10;
          int v11 = v23;
        }
      }
      *((void *)v6 + 15) = *(void *)(a3 + 120);
      *((_DWORD *)v6 + 32) = *(_DWORD *)(a3 + 128);
      v6 += 136;
    }
    while (v6 != v27);
    uint64_t v3 = v26;
    v26[1] = v27;
  }
  return v3;
}

void sub_1DC3A8F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DC3A99F8((void ***)va);
  _Unwind_Resume(a1);
}

void sub_1DC3A8FC4(void *a1, uint64_t *a2, uint64_t a3, int a4)
{
  sub_1DC3A8938(v65, (a2[1] - *a2) >> 2);
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3);
  int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 24))(a3);
  if (a4) {
    char v10 = 8;
  }
  else {
    char v10 = 5;
  }
  int v11 = v9 >> v10;
  if (a4) {
    int v12 = v9;
  }
  else {
    int v12 = 15;
  }
  int v42 = v12;
  int v43 = v9;
  if (v11 <= 1) {
    int v11 = 1;
  }
  int v41 = v11;
  LOBYTE(v47) = 0;
  sub_1DC314894(&v63, v8, &v47);
  LOBYTE(v47) = 0;
  sub_1DC314894(&v61, v8, &v47);
  int v13 = v43;
  uint64_t v14 = a3;
  if (v42 >= 1)
  {
    int v15 = 0;
    unint64_t v46 = a1;
    do
    {
      int v16 = v15 + 1;
      if (v15) {
        unsigned int v17 = -((v15 + 1) >> 1);
      }
      else {
        unsigned int v17 = (v15 + 1) >> 1;
      }
      uint64_t v18 = (v43 >> 1) + v17 * v41;
      if ((v18 & 0x80000000) != 0 || (int)v18 >= v13) {
        break;
      }
      int v44 = v16;
      if ((*(uint64_t (**)(uint64_t, uint64_t, char **, char **, uint64_t))(*(void *)v14 + 32))(v14, v18, &v63, &v61, 1))
      {
        char v19 = 0;
        uint64_t v20 = 0;
        __int16 v60 = 256;
        do
        {
          char v45 = v19;
          int v21 = *((unsigned __int8 *)&v60 + v20);
          if (*((unsigned char *)&v60 + v20))
          {
            float32x4x2_t v22 = v64 - 1;
            if (v63 != v64 && v22 > v63)
            {
              int v24 = v63 + 1;
              do
              {
                char v25 = *(v24 - 1);
                *(v24 - 1) = *v22;
                *v22-- = v25;
                BOOL v26 = v24++ >= v22;
              }
              while (!v26);
            }
            uint64_t v27 = v62 - 1;
            if (v61 != v62 && v27 > v61)
            {
              int v29 = v61 + 1;
              do
              {
                char v30 = *(v29 - 1);
                *(v29 - 1) = *v27;
                *v27-- = v30;
                BOOL v26 = v29++ >= v27;
              }
              while (!v26);
            }
          }
          uint64_t v32 = *a2;
          uint64_t v31 = a2[1];
          if (v31 != *a2)
          {
            unint64_t v33 = 0;
            do
            {
              if (*(_DWORD *)(*a1 + 136 * v33))
              {
                (*(void (**)(void ***__return_ptr))(**(void **)(v32 + 8 * v33) + 16))(&v49);
                if (!v49)
                {
                  if (v21)
                  {
                    sub_1DC34FA60(&v56, 180);
                    uint64_t v34 = 0;
                    long long v47 = v51;
                    long long v48 = v52;
                    do
                    {
                      *(void *)((char *)&v47 + v34) = (v8 + ~*(_DWORD *)((char *)&v47 + v34)) | ((unint64_t)*(unsigned int *)((char *)&v47 + v34 + 4) << 32);
                      v34 += 8;
                    }
                    while (v34 != 32);
                    long long v51 = v47;
                    long long v52 = v48;
                    a1 = v46;
                  }
                  uint64_t v35 = *a1;
                  uint64_t v36 = *a1 + 136 * v33;
                  *(void *)uint64_t v36 = v49;
                  std::wstring::operator=((std::wstring *)(v36 + 8), &v50);
                  long long v37 = v52;
                  uint64_t v38 = v35 + 136 * v33;
                  *(_OWORD *)(v38 + 32) = v51;
                  *(_OWORD *)(v38 + 48) = v37;
                  if ((void ***)v36 == &v49)
                  {
                    *(_DWORD *)(v35 + 136 * v33 + 88) = v55;
                  }
                  else
                  {
                    sub_1DC3A9480((void *)(v35 + 136 * v33 + 64), (char *)__p, v54, v54 - (unsigned char *)__p);
                    uint64_t v39 = v35 + 136 * v33;
                    *(_DWORD *)(v39 + 88) = v55;
                    sub_1DC3A958C(v39 + 96, v56, &v57);
                  }
                  uint64_t v40 = v35 + 136 * v33;
                  *(unsigned char *)(v40 + 120) = v58;
                  *(void *)(v40 + 124) = v59;
                  a1 = v46;
                }
                sub_1DC3A89D4(v57);
                if (__p)
                {
                  char v54 = (char *)__p;
                  operator delete(__p);
                }
                if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v50.__r_.__value_.__l.__data_);
                }
                uint64_t v32 = *a2;
                uint64_t v31 = a2[1];
              }
              ++v33;
            }
            while (v33 < (v31 - v32) >> 3);
          }
          char v19 = 1;
          uint64_t v20 = 1;
        }
        while ((v45 & 1) == 0);
        uint64_t v14 = a3;
      }
      int v15 = v44;
      int v13 = v43;
    }
    while (v44 != v42);
  }
  if (v61)
  {
    BOOL v62 = v61;
    operator delete(v61);
  }
  if (v63)
  {
    unint64_t v64 = v63;
    operator delete(v63);
  }
  uint64_t v49 = (void **)v65;
  sub_1DC3A8C10(&v49);
}

void sub_1DC3A93F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  uint64_t v39 = *(void **)(v37 - 136);
  if (v39)
  {
    *(void *)(v37 - 128) = v39;
    operator delete(v39);
  }
  a21 = v37 - 112;
  sub_1DC3A8C10((void ***)&a21);
  _Unwind_Resume(a1);
}

void *sub_1DC3A9480(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  int v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      sub_1DC2FF97C();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    uint64_t result = sub_1DC314914(v7, v11);
    int v9 = (char *)v7[1];
    goto LABEL_17;
  }
  int v12 = (unsigned char *)result[1];
  size_t v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v16 = a3 - __src;
    if (v16) {
      uint64_t result = memmove(v9, __src, v16);
    }
    int v15 = &v9[v16];
    goto LABEL_20;
  }
  uint64_t v14 = &__src[v13];
  if (v12 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v13);
    int v9 = (char *)v7[1];
  }
  if (a3 != v14) {
    uint64_t result = memmove(v9, v14, a3 - v14);
  }
  int v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

void sub_1DC3A958C(uint64_t a1, void *a2, void *a3)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v6 = *(uint64_t **)a1;
    unint64_t v8 = (uint64_t **)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
    if (v6[1]) {
      int v9 = (uint64_t *)v6[1];
    }
    else {
      int v9 = v6;
    }
    if (!v9)
    {
      float32x4x2_t v22 = 0;
LABEL_33:
      sub_1DC3A89D4(v22);
      goto LABEL_34;
    }
    uint64_t v10 = sub_1DC3A9EF8((uint64_t)v9);
    if (a2 != a3)
    {
      size_t v11 = v9;
      int v12 = a2;
      do
      {
        int v9 = v10;
        *((_DWORD *)v11 + 8) = *((_DWORD *)v12 + 8);
        uint64_t v14 = v12[5];
        uint64_t v13 = v12[6];
        if (v13) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
        }
        int v15 = (std::__shared_weak_count *)v11[6];
        v11[5] = v14;
        v11[6] = v13;
        if (v15) {
          sub_1DC32EEF4(v15);
        }
        size_t v16 = *v8;
        unsigned int v17 = (uint64_t **)(a1 + 8);
        uint64_t v18 = (uint64_t **)(a1 + 8);
        if (*v8)
        {
          do
          {
            while (1)
            {
              unsigned int v17 = (uint64_t **)v16;
              if (*((_DWORD *)v11 + 8) >= *((_DWORD *)v16 + 8)) {
                break;
              }
              size_t v16 = (uint64_t *)*v16;
              uint64_t v18 = v17;
              if (!*v17) {
                goto LABEL_18;
              }
            }
            size_t v16 = (uint64_t *)v16[1];
          }
          while (v16);
          uint64_t v18 = v17 + 1;
        }
LABEL_18:
        sub_1DC311D78((uint64_t **)a1, (uint64_t)v17, v18, v11);
        if (v10) {
          uint64_t v10 = sub_1DC3A9EF8((uint64_t)v10);
        }
        else {
          uint64_t v10 = 0;
        }
        char v19 = (void *)v12[1];
        if (v19)
        {
          do
          {
            a2 = v19;
            char v19 = (void *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            a2 = (void *)v12[2];
            BOOL v20 = *a2 == (void)v12;
            int v12 = a2;
          }
          while (!v20);
        }
        if (!v9) {
          break;
        }
        size_t v11 = v9;
        int v12 = a2;
      }
      while (a2 != a3);
    }
    sub_1DC3A89D4(v9);
    if (v10)
    {
      for (uint64_t i = (uint64_t *)v10[2]; i; uint64_t i = (uint64_t *)i[2])
        uint64_t v10 = i;
      float32x4x2_t v22 = v10;
      goto LABEL_33;
    }
  }
LABEL_34:
  if (a2 != a3)
  {
    float32x4x2_t v23 = (uint64_t **)(a1 + 8);
    do
    {
      int v24 = operator new(0x38uLL);
      int v25 = *((_DWORD *)a2 + 8);
      v24[8] = v25;
      uint64_t v26 = a2[6];
      *((void *)v24 + 5) = a2[5];
      *((void *)v24 + 6) = v26;
      if (v26) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v27 = *v23;
      int v28 = (uint64_t **)(a1 + 8);
      int v29 = (uint64_t **)(a1 + 8);
      if (*v23)
      {
        do
        {
          while (1)
          {
            int v28 = (uint64_t **)v27;
            if (v25 >= *((_DWORD *)v27 + 8)) {
              break;
            }
            uint64_t v27 = (uint64_t *)*v27;
            int v29 = v28;
            if (!*v28) {
              goto LABEL_44;
            }
          }
          uint64_t v27 = (uint64_t *)v27[1];
        }
        while (v27);
        int v29 = v28 + 1;
      }
LABEL_44:
      sub_1DC311D78((uint64_t **)a1, (uint64_t)v28, v29, (uint64_t *)v24);
      char v30 = (void *)a2[1];
      if (v30)
      {
        do
        {
          uint64_t v31 = v30;
          char v30 = (void *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          uint64_t v31 = (void *)a2[2];
          BOOL v20 = *v31 == (void)a2;
          a2 = v31;
        }
        while (!v20);
      }
      a2 = v31;
    }
    while (v31 != a3);
  }
}

void sub_1DC3A97DC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v1 = a1[1];
  if (*a1 != v1)
  {
    while (!*(_DWORD *)v2)
    {
      v2 += 136;
      if (v2 == v1) {
        return;
      }
    }
    if (v2 != v1)
    {
      uint64_t v4 = v2 + 136;
      if (v2 + 136 != v1)
      {
        do
        {
          if (!*(_DWORD *)v4)
          {
            *(void *)uint64_t v2 = *(void *)v4;
            unsigned int v5 = (void **)(v2 + 8);
            if (*(char *)(v2 + 31) < 0) {
              operator delete(*v5);
            }
            long long v6 = *(_OWORD *)(v4 + 8);
            *(void *)(v2 + 24) = *(void *)(v4 + 24);
            *(_OWORD *)unsigned int v5 = v6;
            *(unsigned char *)(v4 + 31) = 0;
            *(_DWORD *)(v4 + 8) = 0;
            long long v7 = *(_OWORD *)(v4 + 48);
            unint64_t v8 = *(void **)(v2 + 64);
            *(_OWORD *)(v2 + 32) = *(_OWORD *)(v4 + 32);
            *(_OWORD *)(v2 + 48) = v7;
            if (v8)
            {
              *(void *)(v2 + 72) = v8;
              operator delete(v8);
              *(void *)(v2 + 64) = 0;
              *(void *)(v2 + 72) = 0;
              *(void *)(v2 + 80) = 0;
            }
            *(_OWORD *)(v2 + 64) = *(_OWORD *)(v4 + 64);
            *(void *)(v2 + 80) = *(void *)(v4 + 80);
            *(void *)(v4 + 64) = 0;
            *(void *)(v4 + 72) = 0;
            *(void *)(v4 + 80) = 0;
            *(_DWORD *)(v2 + 88) = *(_DWORD *)(v4 + 88);
            sub_1DC3A9E8C((void *)(v2 + 96), (void *)(v4 + 96));
            *(unsigned char *)(v2 + 120) = *(unsigned char *)(v4 + 120);
            *(_DWORD *)(v2 + 124) = *(_DWORD *)(v4 + 124);
            *(_DWORD *)(v2 + 128) = *(_DWORD *)(v4 + 128);
            v2 += 136;
          }
          v4 += 136;
        }
        while (v4 != v1);
        uint64_t v1 = a1[1];
      }
    }
    if (v2 != v1)
    {
      while (v1 != v2)
      {
        v1 -= 136;
        sub_1DC3A9E2C(v1);
      }
      a1[1] = v2;
    }
  }
}

void sub_1DC3A99F8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unsigned int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 136;
        sub_1DC3A9E2C(v4);
      }
      while ((void *)v4 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1DC3A9A7C(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a2) {
    return 0;
  }
  int v11 = (*(int (**)(uint64_t))(*(void *)a4 + 24))(a4) / 10;
  int v12 = v11 >= 10 ? 10 : v11;
  if (v12 < 1) {
    return 0;
  }
  char v13 = 0;
  uint64_t v14 = 0;
  v48[0] = v12;
  v48[1] = -v12;
  float v15 = (float)a3 * 3.14159265 / 180.0;
  while (1)
  {
    char v16 = v13;
    uint64_t v17 = v48[v14];
    char v45 = 0;
    unint64_t v46 = 0;
    uint64_t v47 = 0;
    int v42 = 0;
    int v43 = 0;
    uint64_t v44 = 0;
    if (((*(uint64_t (**)(uint64_t, uint64_t, char **, void **, float))(*(void *)a4 + 48))(a4, v17, &v45, &v42, v15) & 1) == 0)
    {
      int v33 = 3;
      goto LABEL_44;
    }
    if (a5)
    {
      uint64_t v18 = v46 - 1;
      if (v45 != v46 && v18 > v45)
      {
        BOOL v20 = v45 + 1;
        do
        {
          char v21 = *(v20 - 1);
          *(v20 - 1) = *v18;
          *v18-- = v21;
        }
        while (v20++ < v18);
      }
    }
    uint64_t v41 = 0;
    uint64_t v23 = *a1;
    int v24 = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 24))(a4);
    if (v24 >= 0) {
      int v25 = v24;
    }
    else {
      int v25 = v24 + 1;
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void, char **, void **, void, uint64_t *))(*(void *)v23 + 16))(&v35, v23, (v17 + (v25 >> 1)), &v45, &v42, 0, &v41);
    if (!v35)
    {
      if ((v37 & 0x80u) == 0) {
        uint64_t v26 = v36;
      }
      else {
        uint64_t v26 = (void **)v36[0];
      }
      if ((v37 & 0x80u) == 0) {
        size_t v27 = v37;
      }
      else {
        size_t v27 = (size_t)v36[1];
      }
      uint64_t v28 = *(unsigned __int8 *)(a2 + 31);
      int v29 = (char)v28;
      if ((v28 & 0x80u) != 0) {
        uint64_t v28 = *(void *)(a2 + 16);
      }
      if (v27 == v28)
      {
        if (!v27)
        {
          size_t v32 = 0;
LABEL_53:
          int v33 = v32 == v27;
          goto LABEL_37;
        }
        if (v29 >= 0) {
          char v30 = (const __int32 *)(a2 + 8);
        }
        else {
          char v30 = *(const __int32 **)(a2 + 8);
        }
        int v31 = wmemcmp((const __int32 *)v26, v30, v27);
        size_t v32 = v27;
        if (!v31) {
          goto LABEL_53;
        }
      }
    }
    int v33 = 0;
LABEL_37:
    sub_1DC3A89D4(v40);
    if (__p)
    {
      uint64_t v39 = __p;
      operator delete(__p);
    }
    if ((char)v37 < 0) {
      operator delete(v36[0]);
    }
    uint64_t v34 = v41;
    uint64_t v41 = 0;
    if (v34) {
      (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
    }
LABEL_44:
    if (v42)
    {
      int v43 = v42;
      operator delete(v42);
    }
    if (v45)
    {
      unint64_t v46 = v45;
      operator delete(v45);
    }
    if (v33 != 3 && v33) {
      return 1;
    }
    char v13 = 1;
    uint64_t v14 = 1;
    if (v16) {
      return 0;
    }
  }
}

void sub_1DC3A9DC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  if (a27) {
    (*(void (**)(uint64_t))(*(void *)a27 + 8))(a27);
  }
  if (__p) {
    operator delete(__p);
  }
  int v31 = *(void **)(v29 - 144);
  if (v31)
  {
    *(void *)(v29 - 136) = v31;
    operator delete(v31);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC3A9E2C(uint64_t a1)
{
  sub_1DC3A89D4(*(void **)(a1 + 104));
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 8);
    operator delete(v3);
  }
}

void sub_1DC3A9E8C(void *a1, void *a2)
{
  uint64_t v4 = a1 + 1;
  sub_1DC3A89D4((void *)a1[1]);
  *a1 = *a2;
  unsigned int v5 = a2 + 1;
  uint64_t v6 = a2[1];
  void *v4 = v6;
  uint64_t v7 = a2[2];
  a1[2] = v7;
  if (v7)
  {
    *(void *)(v6 + 16) = v4;
    *a2 = v5;
    *unsigned int v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *a1 = v4;
  }
}

void *sub_1DC3A9EF8(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *uint64_t result = 0;
      while (1)
      {
        uint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          uint64_t result = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          uint64_t result = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

void sub_1DC3A9F4C(uint64_t a1)
{
  *(void *)a1 = &unk_1F36617E8;
  uint64_t v2 = (atomic_uint **)(a1 + 16);
  sub_1DC35D870((atomic_uint **)(a1 + 40));
  sub_1DC35D870((atomic_uint **)(a1 + 32));
  sub_1DC35D870((atomic_uint **)(a1 + 24));
  sub_1DC35D870(v2);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC3A9FD0(uint64_t a1)
{
  *(void *)a1 = &unk_1F36617E8;
  uint64_t v2 = (atomic_uint **)(a1 + 16);
  sub_1DC35D870((atomic_uint **)(a1 + 40));
  sub_1DC35D870((atomic_uint **)(a1 + 32));
  sub_1DC35D870((atomic_uint **)(a1 + 24));
  sub_1DC35D870(v2);
  return a1;
}

uint64_t sub_1DC3AA034(unsigned int a1)
{
  if (a1 >= 4)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC3B430C(exception, "Illegal error correction level bits");
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBFFC238, memory_order_acquire) != -1)
  {
    uint64_t v4 = &v5;
    unsigned int v5 = sub_1DC3AA104;
    std::__call_once(&qword_1EBFFC238, &v4, (void (__cdecl *)(void *))sub_1DC33DA8C);
  }
  return qword_1EBFFC300[a1];
}

void sub_1DC3AA0F0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC3AA104()
{
}

void sub_1DC3AA234(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x1012C404EF22A49);
  _Unwind_Resume(a1);
}

void sub_1DC3AA264()
{
}

uint64_t sub_1DC3AA27C(unsigned int a1, int a2)
{
  return (dword_1DC40F8F0[(a2 ^ a1) >> 4]
                      + dword_1DC40F8F0[(a2 ^ a1) & 0xF]
                      + dword_1DC40F8F0[((a2 ^ a1) >> 8) & 0xF]
                      + dword_1DC40F8F0[(unsigned __int16)(a2 ^ a1) >> 12]
                      + dword_1DC40F8F0[((a2 ^ a1) >> 16) & 0xF]
                      + dword_1DC40F8F0[((a2 ^ a1) >> 20) & 0xF]
                      + dword_1DC40F8F0[((a2 ^ a1) >> 24) & 0xF]
                      + dword_1DC40F8F0[(a2 ^ a1) >> 28]);
}

atomic_uint **sub_1DC3AA2E8(uint64_t a1, unsigned int a2, unsigned int a3)
{
  sub_1DC3AA37C((uint64_t)&v8, a2, a3);
  uint64_t v6 = v8;
  if (v8)
  {
    atomic_fetch_add_explicit(v8 + 2, 1u, memory_order_relaxed);
    *(void *)a1 = v6;
    *(_DWORD *)(a1 + 8) = v9;
  }
  else
  {
    sub_1DC3AA37C(a1, a2 ^ 0x5412, a3 ^ 0x5412);
  }
  return sub_1DC3914DC(&v8);
}

void sub_1DC3AA368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9)
{
}

atomic_uint **sub_1DC3AA37C(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = 0;
  int v7 = 0x7FFFFFFF;
  do
  {
    int v8 = *(_DWORD *)((char *)&unk_1DC40F7F0 + v6);
    if (v8 == a2 || v8 == a3) {
      operator new();
    }
    int v10 = sub_1DC3AA27C(a2, *(_DWORD *)((char *)&unk_1DC40F7F0 + v6));
    if (v10 < v7) {
      int v7 = v10;
    }
    if (a2 != a3)
    {
      int v11 = sub_1DC3AA27C(a3, v8);
      if (v11 < v7) {
        int v7 = v11;
      }
    }
    v6 += 8;
  }
  while (v6 != 256);
  if (v7 <= 3) {
    operator new();
  }
  char v13 = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = v7;
  return sub_1DC3914DC(&v13);
}

void sub_1DC3AA544(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x10E1C40E6D3758ALL);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3AA56C(atomic_ullong *a1, uint64_t a2, atomic_ullong *a3, void *a4, void *a5)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  if (atomic_load_explicit(a3, memory_order_acquire))
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(a3, memory_order_acquire), @"MRCDescriptorPayloadDecodingOptionDefaultEncoding");
    if (Value)
    {
      int v10 = Value;
      CFTypeID v11 = CFGetTypeID(Value);
      if (v11 != CFStringGetTypeID()) {
        _os_assumes_log();
      }
      Value = CFRetain(v10);
    }
  }
  else
  {
    Value = 0;
  }
  atomic_ullong v56 = (atomic_ullong)Value;
  __int16 v57 = 0;
  unsigned __int16 v12 = sub_1DC3ABA58(a3, @"MRCDescriptorPayloadDecodingOptionShouldForceInProcessDecoding");
  if (v12 >= 0x100u) {
    LOBYTE(v57) = v12;
  }
  unsigned __int16 v13 = sub_1DC3ABA58(a3, @"_MRCDescriptorPayloadDecodingOptionShouldDecodeSupplementalPayload");
  if (v13 >= 0x100u) {
    HIBYTE(v57) = v13;
  }
  if (!atomic_load_explicit(a3, memory_order_acquire)
    || !CFDictionaryContainsKey((CFDictionaryRef)atomic_load_explicit(a3, memory_order_acquire), @"_MRCDescriptorPayloadDecodingOptionShouldDecodeSupplementalPayload"))
  {
    HIBYTE(v57) = a4 != 0;
  }
  atomic_ullong v55 = 0;
  LOBYTE(v53[0]) = 0;
  unsigned __int8 v54 = 0;
  if (qword_1EAA94C70 != -1) {
    dispatch_once(&qword_1EAA94C70, &unk_1F3662448);
  }
  os_signpost_id_t v51 = os_signpost_id_make_with_pointer((os_log_t)qword_1EAA94C68, (const void *)a2);
  char v52 = 1;
  v64[0] = &unk_1F3661EE8;
  char v65 = v64;
  v63[0] = &unk_1F3661F40;
  v63[3] = v63;
  unint64_t v66 = &v51;
  sub_1DC31AD78((uint64_t)v67, (uint64_t)v63);
  if (*((unsigned char *)v66 + 8) && v65) {
    sub_1DC31AE10((uint64_t)v65, *v66);
  }
  sub_1DC31AE60(v63);
  sub_1DC31AE60(v64);
  sub_1DC3D566C();
  if (!atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire)
    || (uint64_t v14 = (atomic_ullong *)(a2 + 8), !atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire)))
  {
    *(void *)&long long buf = -3001;
    __dst.__locale_ = (std::locale::__imp *)@"Missing symbology and/or raw payload data.";
    sub_1DC306334(v53, (uint64_t *)&buf, (CFTypeRef *)&__dst.__locale_);
LABEL_46:
    *a1 = 0;
    goto LABEL_47;
  }
  if (v52)
  {
    if (qword_1EAA94C70 != -1) {
      dispatch_once(&qword_1EAA94C70, &unk_1F3662448);
    }
    os_signpost_id_t v15 = v51;
    if (v51 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      char v16 = qword_1EAA94C68;
      if (os_signpost_enabled((os_log_t)qword_1EAA94C68))
      {
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire);
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = explicit;
        _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v16, OS_SIGNPOST_EVENT, v15, "PayloadDecoding", "symbology=%{public, signpost.description:attribute}@", (uint8_t *)&buf, 0xCu);
      }
    }
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)atomic_load_explicit(v14, memory_order_acquire));
  CFIndex Length = CFDataGetLength((CFDataRef)atomic_load_explicit(v14, memory_order_acquire));
  CFStringRef v20 = (const __CFString *)atomic_load_explicit(&v56, memory_order_acquire);
  if (v20)
  {
    CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
    if (!CStringPtr)
    {
      CFIndex v22 = CFStringGetLength(v20);
      CFIndex v23 = CFStringGetMaximumSizeForEncoding(v22, 0x8000100u) + 1;
      int v24 = (char *)malloc_type_malloc(v23, 0xDDF3B767uLL);
      int CString = CFStringGetCString(v20, v24, v23, 0x8000100u);
      BOOL v26 = CString != 1;
      if (CString == 1) {
        CStringPtr = v24;
      }
      else {
        CStringPtr = 0;
      }
      size_t v27 = v24;
      if (!BytePtr) {
        goto LABEL_45;
      }
      goto LABEL_37;
    }
  }
  else
  {
    CStringPtr = 0;
  }
  size_t v27 = 0;
  BOOL v26 = 0;
  if (!BytePtr)
  {
LABEL_45:
    *(void *)&long long buf = -3001;
    __dst.__locale_ = (std::locale::__imp *)@"Empty or bogus raw payload data.";
    sub_1DC306334(v53, (uint64_t *)&buf, (CFTypeRef *)&__dst.__locale_);
    goto LABEL_46;
  }
LABEL_37:
  if (!Length || v26) {
    goto LABEL_45;
  }
  uint64_t v49 = (uint64_t)CStringPtr;
  *a1 = 0;
  int v62 = 0;
  if (sub_1DC3D60C4((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire), &v62))
  {
    LOBYTE(buf) = 0;
    BYTE8(buf) = 0;
    if (*(unsigned char *)(a2 + 192))
    {
      *(void *)&long long buf = *(void *)(a2 + 160);
      BYTE8(buf) = 1;
    }
    sub_1DC3AB54C((atomic_ullong *)&__dst, v62, (uint64_t)&buf, (atomic_ullong *)(a2 + 8), v49);
    uint64_t v28 = (const void *)atomic_exchange(a1, atomic_exchange((atomic_ullong *volatile)&__dst, 0));
    if (v28) {
      CFRelease(v28);
    }
    sub_1DC31FA90((atomic_ullong *)&__dst);
    goto LABEL_74;
  }
  unint64_t v31 = sub_1DC328800((atomic_ullong *)a2);
  if (HIDWORD(v31) && v31 == 2)
  {
    size_t v32 = (const void *)atomic_exchange(a1, (unint64_t)CFStringCreateFromExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFDataRef)atomic_load_explicit(v14, memory_order_acquire), 0x8000100u));
    if (v32) {
      CFRelease(v32);
    }
    goto LABEL_74;
  }
  if (!atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire)
    || CFStringCompare((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire), @"AppClipCode", 0))
  {
    *((void *)&buf + 1) = 0;
    uint64_t v70 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    LODWORD(numBytes) = 0;
    __dst.__locale_ = (std::locale::__imp *)&unk_1F3661908;
    uint64_t v61 = 0;
    operator new();
  }
  if (atomic_load_explicit(v14, memory_order_acquire))
  {
    int v33 = CFDataGetBytePtr((CFDataRef)atomic_load_explicit(v14, memory_order_acquire));
    CFIndex v34 = CFDataGetLength((CFDataRef)atomic_load_explicit(v14, memory_order_acquire));
    sub_1DC377978((uint64_t)&buf);
    if (v34 >= 1)
    {
      do
      {
        uint64_t v35 = v70;
        uint64_t v36 = v70;
        *(void *)&v71[*(void *)(v70 - 24) + 16] = 2;
        unsigned __int8 v37 = (const std::ios_base *)&v71[*(void *)(v36 - 24) - 8];
        if (v37[1].__fmtflags_ == -1)
        {
          std::ios_base::getloc(v37);
          uint64_t v38 = std::locale::use_facet(&__dst, MEMORY[0x1E4FBA258]);
          ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 32);
          std::locale::~locale(&__dst);
          uint64_t v35 = v70;
        }
        v37[1].__fmtflags_ = 48;
        *(_DWORD *)&v71[*(void *)(v35 - 24)] = *(_DWORD *)&v71[*(void *)(v35 - 24)] & 0xFFFFFFB5 | 8;
        std::ostream::operator<<();
        ++v33;
        --v34;
      }
      while (v34);
    }
    sub_1DC32B834(&__dst, (uint64_t)v71);
    if (SHIBYTE(v61) < 0)
    {
      CFIndex v39 = numBytes;
      if (!numBytes)
      {
LABEL_115:
        operator delete(__dst.__locale_);
        goto LABEL_116;
      }
      locale = (const UInt8 *)__dst.__locale_;
    }
    else
    {
      CFIndex v39 = HIBYTE(v61);
      if (!HIBYTE(v61))
      {
LABEL_116:
        sub_1DC377C50((uint64_t)&buf);
        goto LABEL_74;
      }
      locale = (const UInt8 *)&__dst;
    }
    v58[0] = (atomic_ullong)CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], locale, v39, 0x8000100u, 0);
    long long v48 = (const void *)atomic_exchange(a1, atomic_exchange(v58, 0));
    if (v48) {
      CFRelease(v48);
    }
    sub_1DC31FA90(v58);
    if ((SHIBYTE(v61) & 0x80000000) == 0) {
      goto LABEL_116;
    }
    goto LABEL_115;
  }
LABEL_74:
  if (HIBYTE(v57) && *(unsigned char *)(a2 + 192))
  {
    if (*(unsigned char *)(a2 + 176))
    {
LABEL_77:
      unint64_t v41 = *(void *)(a2 + 168) - 3;
      if (v41 >= 3)
      {
        if (qword_1EAA94C70 != -1) {
          dispatch_once(&qword_1EAA94C70, &unk_1F3662448);
        }
        uint64_t v44 = qword_1EAA94C68;
        if (os_log_type_enabled((os_log_t)qword_1EAA94C68, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl(&dword_1DC2FE000, v44, OS_LOG_TYPE_ERROR, "Invalid supplemental composite flag.", (uint8_t *)&buf, 2u);
        }
        *(void *)&long long buf = -3001;
        __dst.__locale_ = (std::locale::__imp *)@"Invalid supplemental composite flag.";
        sub_1DC306334(v53, (uint64_t *)&buf, (CFTypeRef *)&__dst.__locale_);
      }
      else
      {
        int v42 = dword_1DC40FBE4[v41];
        if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 184), memory_order_acquire))
        {
          if (CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 184), memory_order_acquire)))
          {
            *(void *)&long long buf = *(void *)(a2 + 168);
            BYTE8(buf) = 1;
            sub_1DC3AB54C((atomic_ullong *)&__dst, v42, (uint64_t)&buf, (atomic_ullong *)(a2 + 184), v49);
            int v43 = (const void *)atomic_exchange(&v55, atomic_exchange((atomic_ullong *volatile)&__dst, 0));
            if (v43) {
              CFRelease(v43);
            }
            sub_1DC31FA90((atomic_ullong *)&__dst);
          }
          else
          {
            if (qword_1EAA94C70 != -1) {
              dispatch_once(&qword_1EAA94C70, &unk_1F3662448);
            }
            uint64_t v47 = qword_1EAA94C68;
            if (os_log_type_enabled((os_log_t)qword_1EAA94C68, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl(&dword_1DC2FE000, v47, OS_LOG_TYPE_ERROR, "Empty supplemental raw payload data.", (uint8_t *)&buf, 2u);
            }
            *(void *)&long long buf = -3001;
            __dst.__locale_ = (std::locale::__imp *)@"Empty supplemental raw payload data.";
            sub_1DC306334(v53, (uint64_t *)&buf, (CFTypeRef *)&__dst.__locale_);
          }
        }
        else
        {
          if (qword_1EAA94C70 != -1) {
            dispatch_once(&qword_1EAA94C70, &unk_1F3662448);
          }
          unint64_t v46 = qword_1EAA94C68;
          if (os_log_type_enabled((os_log_t)qword_1EAA94C68, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl(&dword_1DC2FE000, v46, OS_LOG_TYPE_ERROR, "Missing supplemental raw payload data.", (uint8_t *)&buf, 2u);
          }
          *(void *)&long long buf = -3001;
          __dst.__locale_ = (std::locale::__imp *)@"Missing supplemental raw payload data.";
          sub_1DC306334(v53, (uint64_t *)&buf, (CFTypeRef *)&__dst.__locale_);
        }
      }
      goto LABEL_105;
    }
    if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 184), memory_order_acquire))
    {
      if (!*(unsigned char *)(a2 + 176))
      {
        if (qword_1EAA94C70 != -1) {
          dispatch_once(&qword_1EAA94C70, &unk_1F3662448);
        }
        char v45 = qword_1EAA94C68;
        if (os_log_type_enabled((os_log_t)qword_1EAA94C68, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl(&dword_1DC2FE000, v45, OS_LOG_TYPE_ERROR, "Missing supplemental composite flag.", (uint8_t *)&buf, 2u);
        }
        *(void *)&long long buf = -3001;
        __dst.__locale_ = (std::locale::__imp *)@"Missing supplemental composite flag.";
        sub_1DC306334(v53, (uint64_t *)&buf, (CFTypeRef *)&__dst.__locale_);
        goto LABEL_105;
      }
      goto LABEL_77;
    }
  }
LABEL_105:
  if (v27) {
    free(v27);
  }
  if (!atomic_load_explicit(a1, memory_order_acquire) && !v54)
  {
    *(void *)&long long buf = -3001;
    __dst.__locale_ = (std::locale::__imp *)@"Unable to decode the raw payload data as string value.";
    sub_1DC306334(v53, (uint64_t *)&buf, (CFTypeRef *)&__dst.__locale_);
  }
LABEL_47:
  if (*((unsigned char *)v66 + 8) && v68) {
    sub_1DC31AE10(v68, *v66);
  }
  sub_1DC31AE60(v67);
  if (a4 && HIBYTE(v57)) {
    *a4 = atomic_exchange(&v55, 0);
  }
  int v29 = v54;
  if (a5 && v54)
  {
    sub_1DC390F7C((CFErrorRef *)&buf, (uint64_t)v53);
    *a5 = atomic_exchange((atomic_ullong *volatile)&buf, 0);
    sub_1DC306854((atomic_ullong *)&buf);
    int v29 = v54;
  }
  if (v29) {
    sub_1DC390B00(v53);
  }
  sub_1DC31FA90(&v55);
  return sub_1DC31FA90(&v56);
}

void sub_1DC3AB330(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_ullong *a11, uint64_t a12, uint64_t a13, atomic_ullong a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,atomic_ullong a27,atomic_ullong a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,atomic_uint *a33,atomic_uint *a34,atomic_uint *a35,void *__p,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1DC3AAF54);
  }
  sub_1DC31FA90(a11);
  sub_1DC31AEE4(&a48);
  if (a26) {
    sub_1DC390B00(&a14);
  }
  sub_1DC31FA90(&a27);
  sub_1DC31FA90(&a28);
  _Unwind_Resume(a1);
}

void sub_1DC3AB54C(atomic_ullong *a1, int a2, uint64_t a3, atomic_ullong *a4, uint64_t a5)
{
  BytePtr = CFDataGetBytePtr((CFDataRef)atomic_load_explicit(a4, memory_order_acquire));
  CFIndex Length = CFDataGetLength((CFDataRef)atomic_load_explicit(a4, memory_order_acquire));
  *a1 = 0;
  uint64_t v29 = 0;
  CFIndex v20 = 0;
  char v21 = 0;
  uint64_t v19 = 0;
  int v22 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  char v28 = 0;
  unsigned __int16 v12 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
  int v25 = v12;
  long long v23 = 0u;
  long long v24 = 0u;
  *((void *)v12 + 8) = 0;
  *((_DWORD *)v12 + 18) = 0;
  *((void *)v12 + 10) = 0;
  *(_OWORD *)(v12 + 44) = 0u;
  *((_OWORD *)v12 + 1) = 0u;
  *((_OWORD *)v12 + 2) = 0u;
  *(_OWORD *)unsigned __int16 v12 = 0u;
  if (*(unsigned char *)(a3 + 8) && (unint64_t)(*(void *)a3 - 3) <= 2) {
    HIDWORD(v19) = *(_DWORD *)a3 - 2;
  }
  LODWORD(v19) = a2;
  CFIndex v20 = Length;
  char v21 = BytePtr;
  size_t v13 = (4 * Length) | 1;
  uint64_t v14 = (UInt8 *)malloc_type_malloc(v13, 0x51117F6FuLL);
  os_signpost_id_t v15 = v14;
  CFIndex numBytes = 0x7FFFFFFFLL;
  if (a2 < 0 || dword_1EBFFC218 <= a2)
  {
    *uint64_t v14 = 0;
    goto LABEL_12;
  }
  (*(void (**)(uint64_t *, UInt8 *, size_t, CFIndex *, uint64_t))&dword_1EBFFBA10[16
                                                                                         * (unint64_t)a2
                                                                                         + 8])(&v19, v14, v13, &numBytes, a5);
  if (!v15) {
    goto LABEL_17;
  }
  if (numBytes)
  {
    if (numBytes != 0x7FFFFFFF)
    {
      CFStringRef v17 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v15, numBytes, 0x8000100u, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
      char v16 = (const void *)atomic_exchange(a1, atomic_exchange((atomic_ullong *volatile)&v17, 0));
      if (v16) {
        goto LABEL_13;
      }
      goto LABEL_14;
    }
LABEL_12:
    CFStringRef v17 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)v15, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
    char v16 = (const void *)atomic_exchange(a1, atomic_exchange((atomic_ullong *volatile)&v17, 0));
    if (v16) {
LABEL_13:
    }
      CFRelease(v16);
LABEL_14:
    sub_1DC31FA90((atomic_ullong *)&v17);
  }
  if (!atomic_load_explicit(a1, memory_order_acquire)) {
    free(v15);
  }
LABEL_17:
  CFIndex v20 = 0;
  char v21 = 0;
  sub_1DC3D5860((uint64_t)&v19);
}

void sub_1DC3AB760(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC31FA90((atomic_ullong *)va);
  sub_1DC31FA90(v2);
  _Unwind_Resume(a1);
}

void *sub_1DC3AB790()
{
  return &unk_1F3660A08;
}

uint64_t sub_1DC3AB79C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc10Descriptor13decodePayloadERKNS0_22PayloadDecodingOptionsERNS_5CFRefIPK10__CFStringEERNSt3__18optionalINS_5ErrorEEERKNSB_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3AB7D8(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94C70 != -1) {
    dispatch_once(&qword_1EAA94C70, &unk_1F3662448);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EAA94C68;
    if (os_signpost_enabled((os_log_t)qword_1EAA94C68))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "Descriptor::decodePayload", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3AB884(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3661F40;
}

void *sub_1DC3AB8A4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F3661F40;
  return result;
}

void sub_1DC3AB8DC()
{
}

void *sub_1DC3AB8F4()
{
  return &unk_1F36609F8;
}

uint64_t sub_1DC3AB900(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc10Descriptor13decodePayloadERKNS0_22PayloadDecodingOptionsERNS_5CFRefIPK10__CFStringEERNSt3__18optionalINS_5ErrorEEERKNSB_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3AB93C(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EAA94C70 != -1) {
    dispatch_once(&qword_1EAA94C70, &unk_1F3662448);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EAA94C68;
    if (os_signpost_enabled((os_log_t)qword_1EAA94C68))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "Descriptor::decodePayload", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3AB9E8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3661EE8;
}

void *sub_1DC3ABA08()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F3661EE8;
  return result;
}

void sub_1DC3ABA40()
{
}

uint64_t sub_1DC3ABA58(atomic_ullong *a1, const void *a2)
{
  unint64_t explicit = atomic_load_explicit(a1, memory_order_acquire);
  if (!explicit) {
    goto LABEL_7;
  }
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(a1, memory_order_acquire), a2);
  if (!Value)
  {
    LODWORD(explicit) = 0;
LABEL_7:
    int v6 = 0;
    return explicit | (v6 << 8);
  }
  CFBooleanRef v4 = Value;
  CFTypeID v5 = CFGetTypeID(Value);
  if (v5 != CFBooleanGetTypeID()) {
    _os_assumes_log();
  }
  LODWORD(explicit) = CFBooleanGetValue(v4) != 0;
  int v6 = 1;
  return explicit | (v6 << 8);
}

uint64_t sub_1DC3ABAD0()
{
  return 1;
}

uint64_t sub_1DC3ABAD8()
{
  return 1;
}

uint64_t sub_1DC3ABAE8()
{
  uint64_t result = MGIsQuestionValid();
  if (result) {
    uint64_t result = MGGetBoolAnswer();
  }
  byte_1EBFFC390 = result;
  return result;
}

void *sub_1DC3ABB20()
{
  return &unk_1F365EC78;
}

uint64_t sub_1DC3ABB2C(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference25YpCbCrToRGBImageConverter7prepareERKNSt3__18optionalImEES6_RNS3_INS_5ErrorEEERKNS3_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3ABB68(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)CFBooleanRef v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "YpCbCrToRGBImageConverter::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3ABC14(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F0D8;
}

void *sub_1DC3ABC34()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F0D8;
  return result;
}

void sub_1DC3ABC6C()
{
}

void *sub_1DC3ABC84()
{
  return &unk_1F365EC68;
}

uint64_t sub_1DC3ABC90(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc9inference25YpCbCrToRGBImageConverter7prepareERKNSt3__18optionalImEES6_RNS3_INS_5ErrorEEERKNS3_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3ABCCC(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)CFBooleanRef v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "YpCbCrToRGBImageConverter::prepare", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3ABD78(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F080;
}

void *sub_1DC3ABD98()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F080;
  return result;
}

void sub_1DC3ABDD0()
{
}

void *sub_1DC3ABDE8()
{
  return &unk_1F365EDC8;
}

uint64_t sub_1DC3ABDF4(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc9inference25YpCbCrToRGBImageConverter7convertEjRK13vImage_BufferS4_jS4_RNSt3__18optionalINS_5ErrorEEERKNS6_IyEEE3$_1"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3ABE30(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)CFBooleanRef v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_END, v2, "YpCbCrToRGBImageConverter::convert", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3ABEDC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F810;
}

void *sub_1DC3ABEFC()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F810;
  return result;
}

void sub_1DC3ABF34()
{
}

void *sub_1DC3ABF4C()
{
  return &unk_1F365EDB8;
}

uint64_t sub_1DC3ABF58(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc9inference25YpCbCrToRGBImageConverter7convertEjRK13vImage_BufferS4_jS4_RNSt3__18optionalINS_5ErrorEEERKNS6_IyEEE3$_0"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_1DC3ABF94(uint64_t a1, os_signpost_id_t *a2)
{
  os_signpost_id_t v2 = *a2;
  if (qword_1EBFFC3D0 != -1) {
    dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
  }
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = qword_1EBFFC3D8;
    if (os_signpost_enabled((os_log_t)qword_1EBFFC3D8))
    {
      *(_WORD *)CFBooleanRef v4 = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v2, "YpCbCrToRGBImageConverter::convert", (const char *)&unk_1DC429899, v4, 2u);
    }
  }
}

void sub_1DC3AC040(uint64_t a1, void *a2)
{
  *a2 = &unk_1F365F7B8;
}

void *sub_1DC3AC060()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F365F7B8;
  return result;
}

void sub_1DC3AC098()
{
}

void sub_1DC3AC0B0(void *a1)
{
  sub_1DC3AC0E8(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3AC0E8(void *a1)
{
  *a1 = &unk_1F3661848;
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x1E019CE90](v2, 0x10C402FEFCB83);
  }
  CFBooleanRef v4 = (void *)a1[3];
  CFTypeID v5 = (unsigned char *)a1[4];
  if (v5 != (unsigned char *)v4)
  {
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = v4[v6];
      if (v7) {
        break;
      }
LABEL_16:
      if (++v6 >= (unint64_t)((v5 - (unsigned char *)v4) >> 3)) {
        goto LABEL_21;
      }
    }
    int v8 = *(void **)(v7 + 8);
    int v9 = *(unsigned char **)(v7 + 16);
    if (v9 == (unsigned char *)v8)
    {
      int v8 = *(void **)(v7 + 16);
      if (!v9) {
        goto LABEL_15;
      }
    }
    else
    {
      unint64_t v10 = 0;
      do
      {
        if (v8[v10])
        {
          MEMORY[0x1E019CE90](v8[v10], 0x1000C4000313F17);
          int v8 = *(void **)(v7 + 8);
          int v9 = *(unsigned char **)(v7 + 16);
        }
        ++v10;
      }
      while (v10 < (v9 - (unsigned char *)v8) >> 3);
      if (!v8) {
        goto LABEL_15;
      }
    }
    *(void *)(v7 + 16) = v8;
    operator delete(v8);
LABEL_15:
    MEMORY[0x1E019CE90](v7, 0x1080C406BDE4C18);
    CFBooleanRef v4 = (void *)a1[3];
    CFTypeID v5 = (unsigned char *)a1[4];
    goto LABEL_16;
  }
  CFBooleanRef v4 = (void *)a1[4];
LABEL_21:
  if (v4)
  {
    a1[4] = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1DC3AC218(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = a3;
  *(_DWORD *)a1 = a2;
  uint64_t v6 = (char **)(a1 + 8);
  sub_1DC371F24((void *)(a1 + 8), &v21);
  int v8 = *(void **)(a1 + 16);
  unint64_t v7 = *(void *)(a1 + 24);
  if ((unint64_t)v8 >= v7)
  {
    uint64_t v10 = ((char *)v8 - *v6) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      sub_1DC2FF97C();
    }
    uint64_t v11 = v7 - (void)*v6;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13) {
      unint64_t v13 = (unint64_t)sub_1DC2FFD7C(v13);
    }
    else {
      uint64_t v14 = 0;
    }
    os_signpost_id_t v15 = (void *)(v13 + 8 * v10);
    unint64_t v16 = v13 + 8 * v14;
    *os_signpost_id_t v15 = a4;
    int v9 = v15 + 1;
    uint64_t v18 = *(char **)(a1 + 8);
    CFStringRef v17 = *(char **)(a1 + 16);
    if (v17 != v18)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *--os_signpost_id_t v15 = v19;
      }
      while (v17 != v18);
      CFStringRef v17 = *v6;
    }
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v9;
    *(void *)(a1 + 24) = v16;
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    *int v8 = a4;
    int v9 = v8 + 1;
  }
  *(void *)(a1 + 16) = v9;
  return a1;
}

void sub_1DC3AC310(_Unwind_Exception *exception_object)
{
  CFBooleanRef v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3AC32C(int a1)
{
  if (atomic_load_explicit((atomic_ullong *volatile)qword_1EBFFC240, memory_order_acquire) != -1)
  {
    CFBooleanRef v4 = &v5;
    CFTypeID v5 = sub_1DC3AC410;
    std::__call_once(qword_1EBFFC240, &v4, (void (__cdecl *)(void *))sub_1DC371FE8);
  }
  if (a1 < 1
    || a1 > (unint64_t)((uint64_t)(*(void *)(qword_1EBFFC2A8 + 8) - *(void *)qword_1EBFFC2A8) >> 3))
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x20uLL);
    sub_1DC3B430C(exception, "versionNumber must be between 1 and 40");
    __cxa_throw(exception, (struct type_info *)&unk_1F365FF98, (void (*)(void *))sub_1DC3B4308);
  }
  return *(void *)(*(void *)qword_1EBFFC2A8 + 8 * (a1 - 1));
}

void sub_1DC3AC3FC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DC3AC410()
{
}

void sub_1DC3B27EC(_Unwind_Exception *a1)
{
  sub_1DC3B2FA0((atomic_uint **)(v1 - 152));
  _Unwind_Resume(a1);
}

void sub_1DC3B2C14()
{
}

void sub_1DC3B2C90(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3B2CB4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = a2;
  *(void *)a1 = &unk_1F3661848;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v12 = operator new(0x20uLL);
  *(void *)(a1 + 32) = v12 + 4;
  *(void *)(a1 + 40) = v12 + 4;
  *(void *)(a1 + 24) = v12;
  void *v12 = a4;
  v12[1] = a5;
  void v12[2] = a6;
  v12[3] = a7;
  uint64_t v14 = *(char **)(a4 + 8);
  unint64_t v13 = *(char **)(a4 + 16);
  uint64_t v15 = v13 - v14;
  if (v13 == v14)
  {
    int v16 = 0;
  }
  else
  {
    int v16 = 0;
    unint64_t v17 = v15 >> 3;
    if (v17 <= 1) {
      unint64_t v17 = 1;
    }
    do
    {
      uint64_t v18 = *(_DWORD **)v14;
      v14 += 8;
      v16 += (v18[1] + *(_DWORD *)a4) * *v18;
      --v17;
    }
    while (v17);
  }
  *(_DWORD *)(a1 + 48) = v16;
  return a1;
}

atomic_uint *sub_1DC3B2D80(atomic_uint *result, atomic_uint **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = (atomic_uint **)*((void *)result + 1);
  void *v3 = 0;
  CFBooleanRef v4 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit(v4 + 2, 1u, memory_order_relaxed);
    uint64_t result = *v3;
    if (*v3) {
      uint64_t result = sub_1DC2FF57C(result);
    }
  }
  void *v3 = v4;
  *((void *)v2 + 1) = v3 + 1;
  return result;
}

void sub_1DC3B2DD8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC3B2DE0(atomic_uint ***a1, atomic_uint **a2)
{
  uint64_t v2 = a1[1] - *a1;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    sub_1DC2FF97C();
  }
  uint64_t v6 = (char *)a1[2] - (char *)*a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v26 = a1 + 2;
  if (v7)
  {
    if (v7 >> 61) {
      sub_1DC2FF994();
    }
    int v8 = (char *)operator new(8 * v7);
  }
  else
  {
    int v8 = 0;
  }
  int v9 = (atomic_uint **)&v8[8 * v2];
  long long v23 = v8;
  v24.i64[0] = (uint64_t)v9;
  v24.i64[1] = (uint64_t)v9;
  int v25 = &v8[8 * v7];
  *int v9 = 0;
  uint64_t v10 = *a2;
  uint64_t v11 = v9;
  uint64_t v12 = v9;
  if (v10)
  {
    atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
    uint64_t v11 = v9;
    uint64_t v12 = v9;
    if (*v9)
    {
      sub_1DC2FF57C(*v9);
      uint64_t v12 = (atomic_uint **)v24.i64[1];
      uint64_t v11 = (atomic_uint **)v24.i64[0];
    }
  }
  *int v9 = v10;
  unint64_t v13 = v12 + 1;
  v24.i64[1] = (uint64_t)(v12 + 1);
  uint64_t v15 = *a1;
  unint64_t v14 = (unint64_t)a1[1];
  if ((atomic_uint **)v14 == *a1)
  {
    int64x2_t v20 = vdupq_n_s64(v14);
  }
  else
  {
    uint64_t v16 = 0;
    do
    {
      unint64_t v17 = &v11[v16];
      v11[v16 - 1] = 0;
      uint64_t v18 = *(atomic_uint **)(v14 + v16 * 8 - 8);
      if (v18)
      {
        atomic_fetch_add_explicit(v18 + 2, 1u, memory_order_relaxed);
        uint64_t v19 = *(v17 - 1);
        if (v19) {
          sub_1DC2FF57C(v19);
        }
      }
      *(v17 - 1) = v18;
      --v16;
    }
    while ((atomic_uint **)(v14 + v16 * 8) != v15);
    uint64_t v11 = (atomic_uint **)((char *)v11 + v16 * 8);
    int64x2_t v20 = *(int64x2_t *)a1;
    unint64_t v13 = (atomic_uint **)v24.i64[1];
  }
  *a1 = v11;
  a1[1] = v13;
  int64x2_t v24 = v20;
  uint64_t v21 = (char *)a1[2];
  a1[2] = (atomic_uint **)v25;
  int v25 = v21;
  long long v23 = (char *)v20.i64[0];
  sub_1DC3B2FD4((uint64_t)&v23);
  return v13;
}

void sub_1DC3B2F6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3B2FD4((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC3B2FA0(atomic_uint **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

uint64_t sub_1DC3B2FD4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_1DC3B2FA0((atomic_uint **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1DC3B3024(unsigned int a1)
{
  uint64_t v2 = 0;
  int v3 = 0;
  int v4 = 0x7FFFFFFF;
  do
  {
    int v5 = dword_1DC4100C8[v2];
    if (v5 == a1)
    {
      int v3 = v2 + 7;
      goto LABEL_9;
    }
    int v6 = sub_1DC3AA27C(a1, v5);
    if (v6 < v4)
    {
      int v4 = v6;
      int v3 = v2 + 7;
    }
    ++v2;
  }
  while (v2 != 34);
  if (v4 > 3) {
    return 0;
  }
LABEL_9:
  return sub_1DC3AC32C(v3);
}

atomic_uint **sub_1DC3B30D0(uint64_t a1, atomic_uint **a2)
{
  int v3 = *a2;
  if (*a2) {
    atomic_fetch_add_explicit(v3 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v11 = v3;
  uint64_t v4 = sub_1DC37968C();
  long long v5 = *(_OWORD *)v4;
  char v9 = *(unsigned char *)(v4 + 16);
  long long v8 = v5;
  int v6 = *(atomic_uint **)(v4 + 24);
  if (v6) {
    atomic_fetch_add_explicit(v6 + 2, 1u, memory_order_relaxed);
  }
  uint64_t v10 = v6;
  (*(void (**)(uint64_t, atomic_uint **, long long *))(*(void *)a1 + 24))(a1, &v11, &v8);
  sub_1DC3122B8(&v10);
  return sub_1DC3122EC(&v11);
}

void sub_1DC3B3194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1DC3122B8(v6);
  sub_1DC3122EC((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1DC3B31B8()
{
}

void sub_1DC3B325C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9, atomic_uint *a10)
{
  sub_1DC314B30(&a10);
  sub_1DC314A14(&a9);
  MEMORY[0x1E019CE90](v10, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

atomic_uint **sub_1DC3B3298(atomic_uint **a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  char v30 = 0;
  atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 8), 1u, memory_order_relaxed);
  int v25 = (atomic_uint *)a2;
  atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 8), 1u, memory_order_relaxed);
  uint64_t v26 = (atomic_uint *)a2;
  long long v28 = 0u;
  long long v27 = 0u;
  LODWORD(v28) = 3;
  char v29 = 0;
  uint64_t v3 = *(void *)(a2 + 16);
  if ((unint64_t)(v3 - 18) < 0xFFFFFFFFFFFFFFF9 || (*(void *)(a2 + 16) & 1) == 0)
  {
    if (qword_1EAA94CC0 != -1) {
      dispatch_once(&qword_1EAA94CC0, &unk_1F36625A8);
    }
    long long v5 = qword_1EAA94CB8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CB8, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v3;
      _os_log_debug_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_DEBUG, "Invalid BitMatrixParser intialization: dimensiouint64_t n = %zu", (uint8_t *)&buf, 0xCu);
    }
  }
  sub_1DC2FF548(&v25);
  sub_1DC3B4A6C(&v24, (uint64_t)&v26);
  if (DWORD2(v24) != 3)
  {
    uint64_t v7 = v27;
    if ((void)v27) {
      goto LABEL_16;
    }
    sub_1DC3B4A6C(&buf, (uint64_t)&v26);
    if (DWORD2(buf) == 3) {
      goto LABEL_11;
    }
    *(void *)&long long v27 = buf;
    atomic_uint v16 = v26[4];
    if ((*(_DWORD *)buf - 5) < 0xFFFFFFFC) {
      int v17 = -1;
    }
    else {
      int v17 = 2 * *(_DWORD *)buf + 9;
    }
    if (v17 != v16)
    {
      if (v17 >= v16) {
        goto LABEL_11;
      }
      if (qword_1EAA94CC0 != -1) {
        dispatch_once(&qword_1EAA94CC0, &unk_1F36625A8);
      }
      uint64_t v18 = qword_1EAA94CB8;
      if (os_log_type_enabled((os_log_t)qword_1EAA94CB8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)size_t v32 = 67109376;
        *(_DWORD *)&v32[4] = v17;
        __int16 v33 = 1024;
        atomic_uint v34 = v16;
        _os_log_debug_impl(&dword_1DC2FE000, v18, OS_LOG_TYPE_DEBUG, "Using read dimension %d instead of geometry dimension %d", v32, 0xEu);
      }
    }
    uint64_t v7 = v27;
    if ((void)v27)
    {
LABEL_16:
      if (v7 && v28 != 3)
      {
        int v8 = BYTE8(v28);
        if (BYTE8(v28) >= 4u)
        {
          if (qword_1EAA94CC0 != -1) {
            dispatch_once(&qword_1EAA94CC0, &unk_1F36625A8);
          }
          char v9 = qword_1EAA94CB8;
          if (os_log_type_enabled((os_log_t)qword_1EAA94CB8, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf) = 67109120;
            DWORD1(buf) = v8;
            _os_log_debug_impl(&dword_1DC2FE000, v9, OS_LOG_TYPE_DEBUG, "Invalid DataMask intialization: reference = %d", (uint8_t *)&buf, 8u);
          }
        }
        uint64_t v10 = v26;
        if ((int)*((void *)v26 + 2) >= 1)
        {
          uint64_t v11 = 0;
          uint64_t v12 = off_1F365F9A0[v8];
          uint64_t v13 = *((void *)v26 + 2);
          do
          {
            uint64_t v14 = 0;
            do
            {
              if (((unsigned int (*)(uint64_t, uint64_t))v12)(v11, v14)) {
                *(_DWORD *)(*((void *)v10 + 6)
              }
                          + (((unint64_t)(v14 + v11 * *((void *)v10 + 3)) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) ^= 1 << (v14 + v11 * *((void *)v10 + 3));
              ++v14;
            }
            while (v13 != v14);
            ++v11;
          }
          while (v11 != v13);
        }
        if ((*(_DWORD *)v27 - 5) < 0xFFFFFFFC) {
          int v15 = -1;
        }
        else {
          int v15 = 2 * *(_DWORD *)v27 + 9;
        }
        sub_1DC32B428((uint64_t)&buf, v15);
      }
      int v22 = 0;
      uint64_t v21 = &unk_1F3661908;
      uint64_t v23 = 0;
      sub_1DC31465C((uint64_t)v20);
    }
  }
LABEL_11:
  *a1 = 0;
  int v6 = v30;
  if (v30) {
    atomic_fetch_add_explicit(v30 + 2, 1u, memory_order_relaxed);
  }
  *a1 = v6;
  sub_1DC2FF548(&v26);
  return sub_1DC311C34(&v30);
}

void sub_1DC3B3BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,atomic_uint *a37)
{
  if (*(char *)(v39 - 105) < 0) {
    operator delete(*(void **)(v39 - 128));
  }
  MEMORY[0x1E019CE90](v38, 0x1093C40E92185C3);
  sub_1DC311968(&a18);
  MEMORY[0x1E019CE90](v37, 0x10B3C40E71DBE67);
  sub_1DC31191C(*(void **)(v39 - 184));
  sub_1DC311968(&a27);
  sub_1DC311968(&a30);
  sub_1DC2FF548(&a37);
  sub_1DC311C34((atomic_uint **)(v39 - 224));
  _Unwind_Resume(a1);
}

void sub_1DC3B3D98(void *a1, uint64_t a2, uint64_t **a3, char *a4)
{
  v15[0] = 0;
  v15[1] = 0;
  uint64_t v14 = v15;
  if (a4)
  {
    int v8 = sub_1DC39D6E4((uint64_t **)&v14, dword_1DC410178);
    sub_1DC39B734((std::string *)(v8 + 5), a4);
  }
  sub_1DC314778((uint64_t)v13, a2);
  char v9 = sub_1DC3116FC(a3, 12, &dword_1DC41629C);
  uint64_t v10 = sub_1DC39EDAC(*((_DWORD *)v9 + 8));
  int v11 = sub_1DC3116FC(a3, 13, &dword_1DC4162A0)[4] & 3;
  atomic_uint v16 = 0;
  if (v10) {
    BOOL v12 = v11 == 2;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12) {
    operator new();
  }
  *a1 = 0;
  sub_1DC311C34(&v16);
  sub_1DC311968(v13);
  sub_1DC39D7C8(v15[0]);
}

void sub_1DC3B4204(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  MEMORY[0x1E019CE90](v32, 0x1093C40E92185C3);
  sub_1DC311968(&a24);
  MEMORY[0x1E019CE90](v31, 0x10B3C40E71DBE67);
  sub_1DC348814(&a31);
  JUMPOUT(0x1DC3B4280);
}

void sub_1DC3B42D0(std::exception *a1)
{
  sub_1DC379B0C(a1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3B430C(void *a1, char *a2)
{
  uint64_t result = sub_1DC379B70(a1, a2);
  *uint64_t result = &unk_1F36611E0;
  return result;
}

uint64_t sub_1DC3B4340(uint64_t a1, signed int a2, int a3, float *a4, float *a5, float *a6)
{
  uint64_t result = 0;
  int v8 = a3 - a2;
  if (a3 >= a2) {
    int v9 = a3 - a2;
  }
  else {
    int v9 = v8 + 1;
  }
  if (a1)
  {
    if ((a2 & 0x80000000) == 0)
    {
      uint64_t result = 0;
      if (a3 >= a2 && a4 && a5 && a6)
      {
        int v79 = v9 >> 1;
        int v80 = a3 - a2;
        LODWORD(v11) = (v9 >> 1) + a2;
        if (v8 < 2)
        {
          unint64_t v12 = 0;
          uint64_t v13 = 0;
          uint64_t v14 = 0;
          float v16 = 0.0;
          float v15 = 0.0;
        }
        else
        {
          unint64_t v12 = 0;
          uint64_t v13 = 0;
          uint64_t v14 = 0;
          float v15 = 0.0;
          float v16 = 0.0;
          uint64_t v17 = a2;
          do
          {
            float v18 = *(float *)(a1 + 4 * v17);
            if ((unint64_t)v13 >= v12)
            {
              uint64_t v19 = v13 - v14;
              unint64_t v20 = v19 + 1;
              if ((unint64_t)(v19 + 1) >> 62) {
                sub_1DC2FF97C();
              }
              if ((uint64_t)(v12 - (void)v14) >> 1 > v20) {
                unint64_t v20 = (uint64_t)(v12 - (void)v14) >> 1;
              }
              if (v12 - (unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v21 = v20;
              }
              if (v21) {
                unint64_t v21 = (unint64_t)sub_1DC314E5C(v21);
              }
              else {
                uint64_t v22 = 0;
              }
              uint64_t v23 = (float *)(v21 + 4 * v19);
              *uint64_t v23 = v18;
              long long v24 = v23 + 1;
              while (v13 != v14)
              {
                int v25 = *((_DWORD *)v13-- - 1);
                *((_DWORD *)v23-- - 1) = v25;
              }
              unint64_t v12 = v21 + 4 * v22;
              if (v14) {
                operator delete(v14);
              }
              uint64_t v14 = v23;
              uint64_t v13 = v24;
            }
            else
            {
              *v13++ = v18;
            }
            if ((char *)v13 - (char *)v14 >= 5)
            {
              unint64_t v26 = (((unint64_t)((char *)v13 - (char *)v14) >> 2) - 2) >> 1;
              long long v27 = &v14[v26];
              long long v28 = v13 - 1;
              float v29 = *(v13 - 1);
              float v30 = *v27;
              if (*v27 < v29)
              {
                do
                {
                  *long long v28 = v30;
                  long long v28 = v27;
                  if (!v26) {
                    break;
                  }
                  unint64_t v26 = (v26 - 1) >> 1;
                  long long v27 = &v14[v26];
                  float v30 = *v27;
                }
                while (*v27 < v29);
                *long long v28 = v29;
              }
            }
            float v16 = v16 + v18;
            float v15 = v15 + (float)(v18 * v18);
            ++v17;
          }
          while ((int)v11 > (int)v17);
        }
        if ((int)v11 < a3)
        {
          uint64_t v11 = (int)v11;
          while (1)
          {
            float v31 = *(float *)(a1 + 4 * v11);
            float v32 = *v14;
            if (*v14 > v31) {
              break;
            }
LABEL_72:
            float v16 = v16 + v31;
            float v15 = v15 + (float)(v31 * v31);
            if (++v11 == a3) {
              goto LABEL_73;
            }
          }
          uint64_t v33 = (char *)v13 - (char *)v14;
          if ((char *)v13 - (char *)v14 >= 5)
          {
            uint64_t v34 = 0;
            uint64_t v35 = v33 >> 2;
            int64_t v36 = (unint64_t)((v33 >> 2) - 2) >> 1;
            uint64_t v37 = v14;
            do
            {
              uint64_t v38 = v37;
              v37 += v34 + 1;
              uint64_t v39 = 2 * v34;
              uint64_t v34 = (2 * v34) | 1;
              uint64_t v40 = v39 + 2;
              if (v40 < v35 && *v37 < v37[1])
              {
                ++v37;
                uint64_t v34 = v40;
              }
              *uint64_t v38 = *v37;
            }
            while (v34 <= v36);
            unint64_t v41 = v13 - 1;
            if (v37 != v13 - 1)
            {
              *uint64_t v37 = *v41;
              *unint64_t v41 = v32;
              uint64_t v42 = (char *)v37 - (char *)v14 + 4;
              if (v42 < 5) {
                goto LABEL_52;
              }
              unint64_t v43 = (((unint64_t)v42 >> 2) - 2) >> 1;
              uint64_t v44 = &v14[v43];
              float v45 = *v44;
              float v32 = *v37;
              if (*v44 >= *v37) {
                goto LABEL_52;
              }
              do
              {
                *uint64_t v37 = v45;
                uint64_t v37 = v44;
                if (!v43) {
                  break;
                }
                unint64_t v43 = (v43 - 1) >> 1;
                uint64_t v44 = &v14[v43];
                float v45 = *v44;
              }
              while (*v44 < v32);
            }
            *uint64_t v37 = v32;
          }
LABEL_52:
          unint64_t v46 = v13 - 1;
          if ((unint64_t)(v13 - 1) >= v12)
          {
            uint64_t v47 = v46 - v14;
            unint64_t v48 = v47 + 1;
            if ((unint64_t)(v47 + 1) >> 62) {
              sub_1DC2FF97C();
            }
            if ((uint64_t)(v12 - (void)v14) >> 1 > v48) {
              unint64_t v48 = (uint64_t)(v12 - (void)v14) >> 1;
            }
            if (v12 - (unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v49 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v49 = v48;
            }
            if (v49) {
              unint64_t v49 = (unint64_t)sub_1DC314E5C(v49);
            }
            else {
              uint64_t v50 = 0;
            }
            os_signpost_id_t v51 = (float *)(v49 + 4 * v47);
            *os_signpost_id_t v51 = v31;
            uint64_t v13 = v51 + 1;
            while (v46 != v14)
            {
              int v52 = *((_DWORD *)v46-- - 1);
              *((_DWORD *)v51-- - 1) = v52;
            }
            unint64_t v12 = v49 + 4 * v50;
            operator delete(v14);
            uint64_t v14 = v51;
          }
          else
          {
            *unint64_t v46 = v31;
          }
          if ((char *)v13 - (char *)v14 >= 5)
          {
            unint64_t v53 = (((unint64_t)((char *)v13 - (char *)v14) >> 2) - 2) >> 1;
            unsigned __int8 v54 = &v14[v53];
            atomic_ullong v55 = v13 - 1;
            float v56 = *(v13 - 1);
            float v57 = *v54;
            if (*v54 < v56)
            {
              do
              {
                float *v55 = v57;
                atomic_ullong v55 = v54;
                if (!v53) {
                  break;
                }
                unint64_t v53 = (v53 - 1) >> 1;
                unsigned __int8 v54 = &v14[v53];
                float v57 = *v54;
              }
              while (*v54 < v56);
              float *v55 = v56;
            }
          }
          goto LABEL_72;
        }
LABEL_73:
        float v58 = 0.0;
        if (v13 == v14)
        {
          __int16 v60 = a5;
          uint64_t v59 = a4;
          uint64_t v61 = a6;
          int v63 = v79;
          int v62 = v80;
        }
        else
        {
          __int16 v60 = a5;
          uint64_t v59 = a4;
          uint64_t v61 = a6;
          int v63 = v79;
          int v62 = v80;
          do
          {
            uint64_t v64 = (char *)v13 - (char *)v14;
            float v65 = *v14;
            if ((char *)v13 - (char *)v14 >= 5)
            {
              uint64_t v66 = 0;
              uint64_t v67 = v64 >> 2;
              int64_t v68 = (unint64_t)((v64 >> 2) - 2) >> 1;
              uint64_t v69 = v14;
              do
              {
                uint64_t v70 = v69;
                v69 += v66 + 1;
                uint64_t v71 = 2 * v66;
                uint64_t v66 = (2 * v66) | 1;
                uint64_t v72 = v71 + 2;
                if (v72 < v67 && *v69 < v69[1])
                {
                  ++v69;
                  uint64_t v66 = v72;
                }
                *uint64_t v70 = *v69;
              }
              while (v66 <= v68);
              int v73 = v13 - 1;
              if (v69 == v13 - 1)
              {
                *uint64_t v69 = v65;
              }
              else
              {
                *uint64_t v69 = *v73;
                *int v73 = v65;
                uint64_t v74 = (char *)v69 - (char *)v14 + 4;
                if (v74 >= 5)
                {
                  unint64_t v75 = (((unint64_t)v74 >> 2) - 2) >> 1;
                  uint64_t v76 = &v14[v75];
                  float v77 = *v76;
                  float v78 = *v69;
                  if (*v76 < *v69)
                  {
                    do
                    {
                      *uint64_t v69 = v77;
                      uint64_t v69 = v76;
                      if (!v75) {
                        break;
                      }
                      unint64_t v75 = (v75 - 1) >> 1;
                      uint64_t v76 = &v14[v75];
                      float v77 = *v76;
                    }
                    while (*v76 < v78);
                    *uint64_t v69 = v78;
                  }
                }
              }
            }
            float v58 = v58 + v65;
            --v13;
          }
          while (v13 != v14);
        }
        float *v61 = v58 / (float)v63;
        *__int16 v60 = (float)(v16 - v58) / (float)(v62 - v63);
        *uint64_t v59 = (float)(v15 / (float)v62) - (float)((float)(v16 / (float)v62) * (float)(v16 / (float)v62));
        if (v14) {
          operator delete(v14);
        }
        return 1;
      }
    }
  }
  return result;
}

void sub_1DC3B4884(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC3B48A8(uint64_t a1)
{
  sub_1DC3B48E0(a1);
  JUMPOUT(0x1E019CE90);
}

uint64_t sub_1DC3B48E0(uint64_t a1)
{
  *(void *)a1 = &unk_1F3661618;
  sub_1DC31191C(*(void **)(a1 + 88));
  uint64_t v3 = (void **)(a1 + 48);
  sub_1DC2FFC48(&v3);
  sub_1DC311968((void *)(a1 + 24));
  sub_1DC3119BC((atomic_uint **)(a1 + 16));
  return a1;
}

uint64_t sub_1DC3B4954(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, int a5, void *a6)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F3661618;
  *(void *)(a1 + 16) = 0;
  uint64_t v11 = (atomic_uint **)(a1 + 16);
  uint64_t v12 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v12 + 8), 1u, memory_order_relaxed);
    if (*v11) {
      sub_1DC2FF57C(*v11);
    }
  }
  *(void *)(a1 + 16) = v12;
  sub_1DC314778(a1 + 24, a3);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  sub_1DC2FFB5C((atomic_uint *)(a1 + 48), *a4, a4[1], (a4[1] - *a4) >> 3);
  *(_DWORD *)(a1 + 72) = a5;
  sub_1DC3117A4(a1 + 80, a6);
  return a1;
}

void sub_1DC3B4A34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC2FFC48((void ***)va);
  sub_1DC311968(v3);
  sub_1DC3119BC(v2);
  _Unwind_Resume(a1);
}

long long *sub_1DC3B4A6C(long long *result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = a2 + 16;
  if (*(_DWORD *)(a2 + 24) != 3) {
    goto LABEL_17;
  }
  unsigned int v5 = 0;
  for (uint64_t i = 1; i != 9; ++i)
  {
    uint64_t v7 = *(atomic_uint **)a2;
    if (*(void *)a2)
    {
      atomic_fetch_add_explicit(v7 + 2, 1u, memory_order_relaxed);
      long long v24 = v7;
    }
    else
    {
      long long v24 = 0;
    }
    unsigned int v5 = sub_1DC2FF924(v7, i, 8) | (2 * v5);
    sub_1DC2FF548(&v24);
  }
  unint64_t v8 = 7;
  do
  {
    unsigned int v9 = v5;
    uint64_t v10 = *(atomic_uint **)a2;
    if (*(void *)a2)
    {
      atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
      uint64_t v23 = v10;
    }
    else
    {
      uint64_t v23 = 0;
    }
    unsigned int v5 = sub_1DC2FF924(v10, 8, v8) & 1 | (2 * v5);
    sub_1DC2FF548(&v23);
  }
  while (v8-- > 1);
  uint64_t result = sub_1DC373FB0((uint64_t)&v20, v5);
  int v12 = v22;
  if (v22)
  {
    v13.i32[0] = (2 * v9) >> 8;
    v13.i32[1] = v5;
    int32x2_t v14 = (int32x2_t)vand_s8(v13, (int8x8_t)0xFF000000FFLL);
    int32x2_t v15 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vmul_s32((int32x2_t)vorr_s8(vand_s8((int8x8_t)vmul_s32(v14, (int32x2_t)0x80200008020), (int8x8_t)0x2211000088440), vand_s8((int8x8_t)vmul_s32(v14, (int32x2_t)0x802000000802), (int8x8_t)0x8844000022110)), vdup_n_s32(0x10101u)), (uint32x2_t)0xFFFFFFF7FFFFFFEFLL), (int8x8_t)0x7F800000007FLL);
    uint64_t result = sub_1DC373FB0((uint64_t)&v17, vorr_s8((int8x8_t)v15, (int8x8_t)vdup_lane_s32(v15, 1)).u32[0]);
    if (v19 >= v12)
    {
      *(_OWORD *)uint64_t v3 = v20;
      *(unsigned char *)(v3 + 16) = v21;
    }
    else
    {
      *(_OWORD *)uint64_t v3 = v17;
      *(unsigned char *)(v3 + 16) = v18;
      *(unsigned char *)(a2 + 40) = 1;
    }
LABEL_17:
    long long v16 = *(_OWORD *)v3;
    goto LABEL_18;
  }
  *(unsigned char *)(v3 + 16) = v21;
  long long v16 = v20;
  *(_OWORD *)uint64_t v3 = v20;
LABEL_18:
  *uint64_t v2 = v16;
  *((void *)v2 + 2) = *(void *)(v3 + 16);
  return result;
}

float sub_1DC3B4C50(uint64_t a1)
{
  return *(float *)(a1 + 16);
}

float sub_1DC3B4C58(uint64_t a1)
{
  return *(float *)(a1 + 12);
}

void sub_1DC3B4C60()
{
}

float sub_1DC3B4C78(void *a1, uint64_t a2)
{
  float v4 = (*(float (**)(void))(*(void *)*a1 + 16))(*a1);
  float v5 = (*(float (**)(void))(*(void *)*a1 + 24))();
  float v6 = (*(float (**)(void))(**(void **)a2 + 16))();
  float v7 = (*(float (**)(void))(**(void **)a2 + 24))();
  return sqrtf((float)((float)(v5 - v7) * (float)(v5 - v7)) + (float)((float)(v4 - v6) * (float)(v4 - v6)));
}

void sub_1DC3B4D6C(unsigned char *a1, atomic_ullong *a2, int *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
LABEL_7:
    *a1 = 0;
    a1[8] = 0;
    return;
  }
  float v6 = (void *)MEMORY[0x1E019D500]();
  atomic_load_explicit(a2, memory_order_acquire);
  *a3 = e5rt_compute_gpu_device_retain_from_mtl_device();
  int v7 = *a3;
  if (*a3)
  {
    if (qword_1EBFFC3D0 != -1) {
      dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
    }
    unint64_t v8 = (id)qword_1EBFFC3D8;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      unsigned int v9 = (uint64_t (**)(void))sub_1DC3154F4();
      uint64_t v10 = (*v9)(*a3);
      uint64_t v11 = "";
      if (v10) {
        uint64_t v11 = (const char *)v10;
      }
      *(_DWORD *)long long buf = 67240450;
      *(_DWORD *)&buf[4] = v7;
      __int16 v13 = 2082;
      int32x2_t v14 = v11;
      _os_log_error_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_ERROR, "e5rt_compute_gpu_device_retain_from_mtl_device failed: (%{public}d): %{public}s", buf, 0x12u);
    }

    goto LABEL_7;
  }
  *(void *)long long buf = 0;
  *(void *)a1 = 0;
  a1[8] = 1;
  sub_1DC31EC30(buf);
}

void sub_1DC3B4EE4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1DC2FFA58(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t MRCContextCopySupportedComputeDevicesForDecoderUsingOptions(CFTypeRef a1)
{
  if (a1) {
    a1 = CFRetain(a1);
  }
  v11[0] = (atomic_ullong)a1;
  sub_1DC375140((uint64_t)v10, v11);
  sub_1DC31EBFC(v11);
  LOBYTE(v11[0]) = 0;
  BYTE4(v11[0]) = 0;
  if ((sub_1DC3778A8(v10, @"AppClipCode", (uint64_t)v11) & 1) == 0
    && (!_os_feature_enabled_impl() || v10[7] < 196608)
    && (sub_1DC379140(v10) & 1) == 0)
  {
    uint64_t v8 = (uint64_t)CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
    goto LABEL_11;
  }
  uint64_t v1 = (void *)MEMORY[0x1E019D500]();
  uint64_t v13 = 0;
  int32x2_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  uint64_t v2 = (void (*)(void))off_1EBFFB730;
  long long v16 = off_1EBFFB730;
  if (!off_1EBFFB730)
  {
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = (atomic_ullong)sub_1DC3B50F8;
    v11[3] = (atomic_ullong)&unk_1E6C3AA10;
    int v12 = &v13;
    uint64_t v3 = (void *)sub_1DC3B5148();
    float v4 = dlsym(v3, "MLAllComputeDevices");
    *(void *)(v12[1] + 24) = v4;
    off_1EBFFB730 = *(_UNKNOWN **)(v12[1] + 24);
    uint64_t v2 = (void (*)(void))v14[3];
  }
  _Block_object_dispose(&v13, 8);
  if (v2)
  {
    float v5 = v2();
    uint64_t v8 = objc_msgSend_copy(v5, v6, v7);

LABEL_11:
    sub_1DC374E0C(v10);
    return v8;
  }
  dlerror();
  uint64_t result = abort_report_np();
  __break(1u);
  return result;
}

void sub_1DC3B50B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose((const void *)(v3 - 64), 8);
  sub_1DC374E0C((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC3B50F8(uint64_t a1)
{
  uint64_t v2 = (void *)sub_1DC3B5148();
  uint64_t result = dlsym(v2, "MLAllComputeDevices");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EBFFB730 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_1DC3B5148()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!qword_1EBFFB708)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = sub_1DC3B5258;
    v3[4] = &unk_1E6C3AA48;
    v3[5] = v3;
    long long v4 = xmmword_1E6C3AA30;
    uint64_t v5 = 0;
    qword_1EBFFB708 = _sl_dlopen();
    uint64_t v1 = (void *)v3[0];
    uint64_t v0 = qword_1EBFFB708;
    if (qword_1EBFFB708)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      uint64_t v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return qword_1EBFFB708;
}

uint64_t sub_1DC3B5258()
{
  uint64_t result = _sl_dlopen();
  qword_1EBFFB708 = result;
  return result;
}

unint64_t sub_1DC3B52CC(void *a1)
{
  uint64_t v1 = a1 + 2;
  unint64_t explicit = atomic_load_explicit(a1 + 2, memory_order_acquire);
  unint64_t v3 = *a1;
  if (explicit)
  {
    uint64_t v5 = (void *)MEMORY[0x1E019D500]();
    id v6 = (id)atomic_load_explicit(v1, memory_order_acquire);
    sub_1DC3B5394();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v7 = 50331652;
    }
    else
    {
      sub_1DC3B5478();
      if (objc_opt_isKindOfClass())
      {
        uint64_t v7 = 0x1000000;
      }
      else
      {
        sub_1DC3B555C();
        objc_opt_isKindOfClass();
        uint64_t v7 = 1;
      }
    }
    unint64_t v3 = v3 & 0xFFFFFFFFFCFFFFF8 | v7;
  }
  return v3;
}

void sub_1DC3B5384(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1DC3B5394()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)qword_1EBFFB720;
  uint64_t v7 = qword_1EBFFB720;
  if (!qword_1EBFFB720)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = sub_1DC3B5720;
    v3[3] = &unk_1E6C3AA10;
    v3[4] = &v4;
    sub_1DC3B5720((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1DC3B5460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1DC3B5478()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)qword_1EBFFB728;
  uint64_t v7 = qword_1EBFFB728;
  if (!qword_1EBFFB728)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = sub_1DC3B56B0;
    v3[3] = &unk_1E6C3AA10;
    v3[4] = &v4;
    sub_1DC3B56B0((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1DC3B5544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1DC3B555C()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)qword_1EBFFB740;
  uint64_t v7 = qword_1EBFFB740;
  if (!qword_1EBFFB740)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = sub_1DC3B5640;
    v3[3] = &unk_1E6C3AA10;
    v3[4] = &v4;
    sub_1DC3B5640((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1DC3B5628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class sub_1DC3B5640(uint64_t a1)
{
  sub_1DC3B5148();
  Class result = objc_getClass("MLNeuralEngineComputeDevice");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_1EBFFB740 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return sub_1DC3B56B0(v3);
  }
  return result;
}

Class sub_1DC3B56B0(uint64_t a1)
{
  sub_1DC3B5148();
  Class result = objc_getClass("MLGPUComputeDevice");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_1EBFFB728 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return sub_1DC3B5720(v3);
  }
  return result;
}

Class sub_1DC3B5720(uint64_t a1)
{
  sub_1DC3B5148();
  Class result = objc_getClass("MLCPUComputeDevice");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_1EBFFB720 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return (Class)sub_1DC3B5790(v3);
  }
  return result;
}

void sub_1DC3B5790(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (atomic_ullong *)(a2 + 16);
  if (!atomic_load_explicit((atomic_ullong *volatile)(a2 + 16), memory_order_acquire))
  {
LABEL_2:
    CFTypeRef explicit = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire);
    if (explicit) {
      CFTypeRef explicit = CFRetain(explicit);
    }
    *a1 = (uint64_t)explicit;
    return;
  }
  uint64_t v6 = (void *)MEMORY[0x1E019D500]();
  id v7 = (id)atomic_load_explicit(v4, memory_order_acquire);
  sub_1DC3B5478();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {

    goto LABEL_2;
  }
  *a1 = objc_msgSend_metalDevice(v7, v8, v9);
}

void sub_1DC3B584C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1DC3B585C()
{
  uint64_t v0 = (void *)MEMORY[0x1E019D500]();
  id v1 = (void *)MEMORY[0x1E4F28B50];
  uint64_t v2 = objc_opt_class();
  objc_msgSend_bundleForClass_(v1, v3, v2);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  id v7 = v4;
  if (v4)
  {
    uint64_t v8 = objc_msgSend_bundleURL(v4, v5, v6);

    if (v8)
    {
      CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFURLRef v12 = (const __CFURL *)objc_msgSend_bundleURL(v7, v9, v10);
      uint64_t v8 = CFBundleCreate(v11, v12);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }

  qword_1EBFFC358 = (uint64_t)v8;
}

void sub_1DC3B5924()
{
  if (os_variant_has_internal_content())
  {
    uint64_t v2 = objc_msgSend_processInfo(MEMORY[0x1E4F28F80], v0, v1);
    uint64_t v5 = objc_msgSend_environment(v2, v3, v4);
    uint64_t v7 = objc_msgSend_objectForKey_(v5, v6, @"_MRC_OVERRIDDEN_RESOURCE_BASE_PATH");
    uint64_t v8 = (void *)qword_1EBFFBA08;
    qword_1EBFFBA08 = v7;

    uint64_t v9 = sub_1DC3B5AC4((void *)qword_1EBFFBA08);
    uint64_t v10 = (void *)qword_1EBFFBA08;
    qword_1EBFFBA08 = v9;

    if (!v9)
    {
      CFPropertyListRef v11 = CFPreferencesCopyAppValue(@"_MRCOverriddenResourceBasePath", (CFStringRef)*MEMORY[0x1E4F1D3D8]);
      if (v11)
      {
        CFURLRef v12 = (void *)v11;
        CFTypeID v13 = CFGetTypeID(v11);
        if (v13 == CFStringGetTypeID())
        {
          uint64_t v14 = sub_1DC3B5AC4(v12);
          uint64_t v15 = (void *)qword_1EBFFBA08;
          qword_1EBFFBA08 = v14;

          if (v14) {
            return;
          }
        }
        else
        {
          CFRelease(v12);
        }
      }
      CFPropertyListRef v16 = CFPreferencesCopyAppValue(@"_MRCOverriddenResourceBasePath", @"com.apple.Quagga");
      if (v16)
      {
        cf = (void *)v16;
        CFTypeID v17 = CFGetTypeID(v16);
        if (v17 == CFStringGetTypeID())
        {
          uint64_t v18 = sub_1DC3B5AC4(cf);
          int v19 = (void *)qword_1EBFFBA08;
          qword_1EBFFBA08 = v18;
        }
        else
        {
          CFRelease(cf);
        }
      }
    }
  }
}

id sub_1DC3B5AC4(void *a1)
{
  id v1 = a1;
  uint64_t v4 = v1;
  if (v1
    && objc_msgSend_length(v1, v2, v3)
    && ((unsigned __int8 v16 = 0,
         objc_msgSend_defaultManager(MEMORY[0x1E4F28CB8], v5, v6),
         uint64_t v7 = objc_claimAutoreleasedReturnValue(),
         int isDirectory = objc_msgSend_fileExistsAtPath_isDirectory_(v7, v8, (uint64_t)v4, &v16),
         int v10 = v16,
         v7,
         isDirectory)
      ? (BOOL v13 = v10 == 0)
      : (BOOL v13 = 1),
        !v13))
  {
    uint64_t v14 = objc_msgSend_copy(v4, v11, v12);
  }
  else
  {
    uint64_t v14 = 0;
  }

  return v14;
}

uint64_t MRCSampleWriteOpaqueRepresentationToFile(char *ptr, const __CFURL *a2, void *a3)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  LOBYTE(v44[0]) = 0;
  unsigned __int8 v46 = 0;
  if (qword_1EAA94C50 != -1) {
    dispatch_once(&qword_1EAA94C50, &unk_1F3662548);
  }
  os_signpost_id_make_with_pointer((os_log_t)qword_1EAA94C48, ptr);
  sub_1DC3B6668((atomic_ullong *)__p, a2);
  if (!ptr)
  {
    error[0] = (CFErrorRef)-2006;
    v55.value = (CMTimeValue)@"Invalid sample.";
    sub_1DC306334(v44, (uint64_t *)error, (CFTypeRef *)&v55);
LABEL_17:
    BOOL v13 = 0;
    goto LABEL_77;
  }
  unint64_t v6 = v43;
  if ((v43 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  if (!v6)
  {
    error[0] = (CFErrorRef)-2006;
    v55.value = (CMTimeValue)@"Invalid file URL.";
    sub_1DC306334(v44, (uint64_t *)error, (CFTypeRef *)&v55);
    goto LABEL_17;
  }
  CFTypeID v7 = CFGetTypeID(ptr);
  if (qword_1EBFFB800 != -1) {
    dispatch_once_f(&qword_1EBFFB800, 0, (dispatch_function_t)sub_1DC378354);
  }
  if (v7 != qword_1EBFFB9F8) {
    _os_assumes_log();
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v9 = ptr + 16;
  CFMutableStringRef Mutable = (__CFString *)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  sub_1DC3B67E0((atomic_ullong *)error, *((atomic_ullong **)ptr + 2));
  if (!v53) {
    goto LABEL_55;
  }
  CFStringRef v10 = sub_1DC386224(@"pixelBuffer");
  if (!v10) {
    goto LABEL_55;
  }
  CFDictionaryRef v11 = sub_1DC3B6DE4((uint64_t *)error);
  if (v11)
  {
    char v12 = sub_1DC3863F4((CFDictionaryRef *)&Mutable, v10, v11);
    CFRelease(v10);
  }
  else
  {
    char v12 = 0;
    CFDictionaryRef v11 = (CFDictionaryRef)v10;
  }
  CFRelease(v11);
  if ((v12 & 1) == 0) {
    goto LABEL_55;
  }
  valuePtr.value = (CMTimeValue)CFRetain(@"MRCSampleAttributeRegionOfInterest");
  sub_1DC382DD0(&v55, (uint64_t)(ptr + 16), &valuePtr.value);
  unint64_t explicit = atomic_load_explicit(&v55.value, memory_order_acquire);
  sub_1DC31EB58(&v55.value);
  sub_1DC31FA90(&valuePtr.value);
  if (explicit)
  {
    long long v39 = *((_OWORD *)ptr + 3);
    long long v40 = *((_OWORD *)ptr + 2);
    if (sub_1DC386224(@"regionOfInterest"))
    {
      for (uint64_t i = 0; i != 4; ++i)
      {
        v41[0] = v40;
        v41[1] = v39;
        *(&v55.value + i) = *((void *)v41 + (i & 3));
      }
      operator new[]();
    }
    goto LABEL_55;
  }
  if (atomic_load_explicit((atomic_ullong *volatile)ptr + 8, memory_order_acquire))
  {
    memset(&valuePtr, 0, sizeof(valuePtr));
    unsigned __int8 v16 = (void *)*((void *)ptr + 9);
    if (v16) {
      unint64_t v17 = 0x84BDA12F684BDA13 * ((uint64_t)(v16[1] - *v16) >> 3);
    }
    else {
      unint64_t v17 = 0;
    }
    sub_1DC3B732C(&valuePtr.value, v17);
    unint64_t v18 = 0;
    for (uint64_t j = 8; ; j += 216)
    {
      long long v20 = (void *)*((void *)ptr + 9);
      unint64_t v21 = v20 ? 0x84BDA12F684BDA13 * ((uint64_t)(v20[1] - *v20) >> 3) : 0;
      if (v18 >= v21) {
        break;
      }
      sub_1DC3B67E0(&v55.value, (atomic_ullong *)(*v20 + j));
      if (!v59) {
        goto LABEL_88;
      }
      sub_1DC3B73F8(&valuePtr.value, (long long *)&v55.value);
      if (v59)
      {
        sub_1DC3B757C(&v57);
        sub_1DC31EBFC(v56);
      }
      ++v18;
    }
    long long v22 = *(_OWORD *)&valuePtr.value;
    CFStringRef v23 = sub_1DC386224(@"pyramid");
    if (v23)
    {
      if (*((void *)&v22 + 1) != (void)v22) {
        operator new[]();
      }
      CFArrayRef v24 = CFArrayCreate(v8, 0, 0, MEMORY[0x1E4F1D510]);
      if (v24)
      {
        char v25 = sub_1DC3863F4((CFDictionaryRef *)&Mutable, v23, v24);
        CFRelease(v23);
      }
      else
      {
        char v25 = 0;
        CFArrayRef v24 = (CFArrayRef)v23;
      }
      CFRelease(v24);
      if (v25)
      {
        sub_1DC3B75E4((void **)&valuePtr);
        goto LABEL_46;
      }
    }
LABEL_88:
    CFDictionaryRef v47 = 0;
    sub_1DC3B75E4((void **)&valuePtr);
  }
  else
  {
LABEL_46:
    sub_1DC3834D8((const __CFDictionary *)&v55, (uint64_t)v9);
    if (LOBYTE(v56[0]))
    {
      sub_1DC3834D8((const __CFDictionary *)&v55, (uint64_t)v9);
      CMTime valuePtr = v55;
      CFDictionaryRef v48 = CMTimeCopyAsDictionary(&valuePtr, v8);
      if (!atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire)
        || (v55.value = atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire),
            (sub_1DC3B7654((CFDictionaryRef *)&Mutable, @"presentationTimeStamp", (const void **)&v55) & 1) == 0))
      {
        CFDictionaryRef v47 = 0;
        sub_1DC31EBFC((atomic_ullong *)&v48);
        goto LABEL_56;
      }
      sub_1DC31EBFC((atomic_ullong *)&v48);
    }
    sub_1DC38358C((const __CFData *)&v55, (uint64_t)v9);
    if (v58)
    {
      sub_1DC38358C((const __CFData *)&v55, (uint64_t)v9);
      if ((sub_1DC3B76DC((uint64_t)&Mutable, @"cameraIntrinsicMatrix", (uint64_t)&v55) & 1) == 0)
      {
LABEL_55:
        CFDictionaryRef v47 = 0;
        goto LABEL_56;
      }
    }
    if (Mutable) {
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v8, (CFDictionaryRef)Mutable);
    }
    else {
      CFDictionaryRef Copy = 0;
    }
    CFDictionaryRef v47 = Copy;
  }
LABEL_56:
  if (v53)
  {
    sub_1DC3B757C(&v52);
    sub_1DC31EBFC(v51);
  }
  sub_1DC3863C0((const void **)&Mutable);
  if (atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire))
  {
    error[0] = 0;
    v55.value = (CMTimeValue)CFPropertyListCreateData(v8, (CFPropertyListRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire), kCFPropertyListBinaryFormat_v1_0, 0, error);
    if (atomic_load_explicit(&v55.value, memory_order_acquire))
    {
      if ((v43 & 0x80u) == 0) {
        long long v27 = __p;
      }
      else {
        long long v27 = (void **)__p[0];
      }
      long long v28 = fopen((const char *)v27, "wb");
      if (v28)
      {
        BytePtr = CFDataGetBytePtr((CFDataRef)atomic_load_explicit(&v55.value, memory_order_acquire));
        CFIndex Length = CFDataGetLength((CFDataRef)atomic_load_explicit(&v55.value, memory_order_acquire));
        size_t v31 = fwrite(BytePtr, Length, 1uLL, v28);
        BOOL v13 = v31 == 1;
        if (v31 != 1)
        {
          int v32 = *__error();
          valuePtr.value = -2007;
          CFMutableStringRef Mutable = @"Unable to write to file.";
          sub_1DC306334(v44, &valuePtr.value, (CFTypeRef *)&Mutable);
          sub_1DC3B7A18(&valuePtr.value, (uint64_t)__p, v32);
          uint64_t v33 = (const void *)atomic_exchange(v45, atomic_exchange(&valuePtr.value, 0));
          if (v33) {
            CFRelease(v33);
          }
          sub_1DC306854(&valuePtr.value);
        }
        fclose(v28);
        goto LABEL_75;
      }
      int v35 = *__error();
      valuePtr.value = -2007;
      CFMutableStringRef Mutable = @"Unable to open file for writing.";
      sub_1DC306334(v44, &valuePtr.value, (CFTypeRef *)&Mutable);
      sub_1DC3B7A18(&valuePtr.value, (uint64_t)__p, v35);
      uint64_t v34 = (const void *)atomic_exchange(v45, atomic_exchange(&valuePtr.value, 0));
      if (v34) {
        goto LABEL_73;
      }
    }
    else
    {
      valuePtr.value = -2008;
      CFMutableStringRef Mutable = @"Unable to serialize sample.";
      sub_1DC306334(v44, &valuePtr.value, (CFTypeRef *)&Mutable);
      valuePtr.value = (CMTimeValue)error[0];
      uint64_t v34 = (const void *)atomic_exchange(v45, atomic_exchange(&valuePtr.value, 0));
      if (v34) {
LABEL_73:
      }
        CFRelease(v34);
    }
    sub_1DC306854(&valuePtr.value);
    BOOL v13 = 0;
LABEL_75:
    sub_1DC34D854(&v55.value);
    goto LABEL_76;
  }
  error[0] = (CFErrorRef)-2008;
  v55.value = (CMTimeValue)@"Unable to serialize sample.";
  sub_1DC306334(v44, (uint64_t *)error, (CFTypeRef *)&v55);
  BOOL v13 = 0;
LABEL_76:
  sub_1DC31EBFC((atomic_ullong *)&v47);
LABEL_77:
  if ((char)v43 < 0)
  {
    operator delete(__p[0]);
    if (v13) {
      goto LABEL_79;
    }
  }
  else if (v13)
  {
LABEL_79:
    uint64_t v36 = 1;
LABEL_84:
    int v37 = v46;
    goto LABEL_85;
  }
  uint64_t v36 = 0;
  int v37 = v46;
  if (a3 && v46)
  {
    sub_1DC390F7C(error, (uint64_t)v44);
    *a3 = atomic_exchange((atomic_ullong *volatile)error, 0);
    sub_1DC306854((atomic_ullong *)error);
    uint64_t v36 = 0;
    goto LABEL_84;
  }
LABEL_85:
  if (v37) {
    sub_1DC390B00(v44);
  }
  return v36;
}

void sub_1DC3B64E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,atomic_ullong a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,int a36,__int16 a37,char a38,char a39,int a40,__int16 a41,char a42,char a43,int a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  MEMORY[0x1E019CE70](v49, 0x60C8044C4A2DFLL);
  sub_1DC3B75E4(&a45);
  sub_1DC3B73BC((uint64_t)&a49);
  sub_1DC3863C0((const void **)(v50 - 168));
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a35) {
    sub_1DC390B00(&a23);
  }
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3B6668(atomic_ullong *result, const __CFURL *a2)
{
  uint64_t v2 = result;
  if (a2 && (Class result = (atomic_ullong *)_CFURLIsFileURL(), result))
  {
    CFURLRef v5 = CFURLCopyAbsoluteURL(a2);
    if (atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire))
    {
      CFStringRef v4 = CFURLCopyFileSystemPath((CFURLRef)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire), kCFURLPOSIXPathStyle);
      if (atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire))
      {
        CFStringGetMaximumSizeOfFileSystemRepresentation((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire));
        operator new[]();
      }
      *uint64_t v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      sub_1DC31FA90((atomic_ullong *)&v4);
    }
    else
    {
      *uint64_t v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
    }
    return sub_1DC378320((atomic_ullong *)&v5);
  }
  else
  {
    *uint64_t v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  return result;
}

void sub_1DC3B6794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  atomic_ullong v7 = va_arg(va1, void);
  MEMORY[0x1E019CE70](v5, 0x1000C8077774924);
  sub_1DC31FA90((atomic_ullong *)va);
  sub_1DC378320((atomic_ullong *)va1);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3B67E0(atomic_ullong *result, atomic_ullong *a2)
{
  uint64_t v2 = result;
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    *(unsigned char *)Class result = 0;
    *((unsigned char *)result + 64) = 0;
    return result;
  }
  uint64_t v3 = a2;
  size_t Width = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
  size_t Height = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire));
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire));
  v66[0] = (atomic_ullong)CVPixelBufferCopyCreationAttributes((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire));
  int IsPlanar = CVPixelBufferIsPlanar((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire));
  int64x2_t v64 = 0uLL;
  v65[0] = 0;
  unint64_t explicit = (void *)atomic_load_explicit(v3, memory_order_acquire);
  context.versiouint64_t n = 0;
  context.info = explicit;
  context.retaiuint64_t n = (CFAllocatorRetainCallBack)j__CVPixelBufferRetain;
  context.release = (CFAllocatorReleaseCallBack)j__CVPixelBufferRelease;
  memset(&context.copyDescription, 0, 24);
  context.deallocate = (CFAllocatorDeallocateCallBack)sub_1DC3B7DF0;
  context.preferredSize = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v62 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &context);
  if (atomic_load_explicit((atomic_ullong *volatile)&v62, memory_order_acquire))
  {
    atomic_ullong v7 = (__CVBuffer *)atomic_load_explicit(v3, memory_order_acquire);
    if (IsPlanar)
    {
      size_t v48 = Width;
      uint64_t v49 = v2;
      size_t PlaneCount = CVPixelBufferGetPlaneCount(v7);
      size_t v9 = PlaneCount;
      if (PlaneCount)
      {
        size_t v10 = 0;
        CFAllocatorRef v51 = v6;
        size_t v50 = PlaneCount;
        CMTime v55 = v3;
        while (1)
        {
          size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire), v10);
          size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire), v10);
          size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire), v10);
          if (CVPixelBufferLockBaseAddress((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire), 1uLL)
            || (BaseAddressOfPlane = (UInt8 *)CVPixelBufferGetBaseAddressOfPlane((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire), v10)) == 0)
          {
            *(unsigned char *)uint64_t v49 = 0;
            *((unsigned char *)v49 + 64) = 0;
            goto LABEL_51;
          }
          CFDataRef v61 = CFDataCreateWithBytesNoCopy(v6, BaseAddressOfPlane, BytesPerRowOfPlane * HeightOfPlane, (CFAllocatorRef)atomic_load_explicit((atomic_ullong *volatile)&v62, memory_order_acquire));
          if (!atomic_load_explicit((atomic_ullong *volatile)&v61, memory_order_acquire)) {
            break;
          }
          unint64_t v15 = atomic_exchange((atomic_ullong *volatile)&v61, 0);
          unsigned __int8 v16 = (void *)v64.i64[1];
          unint64_t v17 = v65[0];
          if (v64.i64[1] >= v65[0])
          {
            int v19 = (void *)v64.i64[0];
            uint64_t v20 = (v64.i64[1] - v64.i64[0]) >> 5;
            unint64_t v21 = v20 + 1;
            if ((unint64_t)(v20 + 1) >> 59) {
              sub_1DC2FF97C();
            }
            if ((v65[0] - v64.i64[0]) >> 4 > v21) {
              unint64_t v21 = (v65[0] - v64.i64[0]) >> 4;
            }
            if (v65[0] - v64.i64[0] >= 0x7FFFFFFFFFFFFFE0uLL) {
              unint64_t v22 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v22 = v21;
            }
            char v58 = v65;
            if (v22 >> 59) {
              sub_1DC2FF994();
            }
            CFStringRef v23 = (char *)operator new(32 * v22);
            CFArrayRef v24 = (size_t *)&v23[32 * v20];
            *(void *)float v56 = v23;
            *(void *)&v56[8] = v24;
            *CFArrayRef v24 = WidthOfPlane;
            v24[1] = HeightOfPlane;
            atomic_ullong v25 = (atomic_ullong)&v23[32 * v22];
            v24[2] = BytesPerRowOfPlane;
            v24[3] = v15;
            unint64_t v18 = v24 + 4;
            *(void *)&v56[16] = v24 + 4;
            unint64_t v57 = v25;
            if (v16 == v19)
            {
              int64x2_t v29 = vdupq_n_s64((unint64_t)v16);
              size_t v9 = v50;
              CFAllocatorRef v6 = v51;
              uint64_t v3 = v55;
            }
            else
            {
              size_t v9 = v50;
              CFAllocatorRef v6 = v51;
              uint64_t v3 = v55;
              do
              {
                size_t v26 = *(v16 - 4);
                v16 -= 4;
                *unsigned __int8 v16 = 0;
                *(v24 - 4) = v26;
                v24 -= 4;
                size_t v27 = v16[1];
                v16[1] = 0;
                v24[1] = v27;
                size_t v28 = v16[2];
                v16[2] = 0;
                v24[2] = v28;
                v24[3] = atomic_exchange(v16 + 3, 0);
              }
              while (v16 != v19);
              int64x2_t v29 = v64;
              unint64_t v17 = v65[0];
              unint64_t v18 = *(void **)&v56[16];
              atomic_ullong v25 = v57;
            }
            v64.i64[0] = (uint64_t)v24;
            v64.i64[1] = (uint64_t)v18;
            *(int64x2_t *)&v56[8] = v29;
            v65[0] = v25;
            unint64_t v57 = v17;
            *(void *)float v56 = v29.i64[0];
            sub_1DC3B7D68((uint64_t)v56);
          }
          else
          {
            *(void *)v64.i64[1] = WidthOfPlane;
            v16[1] = HeightOfPlane;
            unint64_t v18 = v16 + 4;
            v16[2] = BytesPerRowOfPlane;
            v16[3] = v15;
            uint64_t v3 = v55;
          }
          v64.i64[1] = (uint64_t)v18;
          sub_1DC34D854((atomic_ullong *)&v61);
          if (++v10 == v9) {
            goto LABEL_50;
          }
        }
        CFAllocatorDeallocate((CFAllocatorRef)atomic_load_explicit((atomic_ullong *volatile)&v62, memory_order_acquire), BaseAddressOfPlane);
        *(unsigned char *)uint64_t v49 = 0;
        *((unsigned char *)v49 + 64) = 0;
        goto LABEL_36;
      }
      goto LABEL_50;
    }
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(v7);
    if (!CVPixelBufferLockBaseAddress((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire), 1uLL))
    {
      BaseAddress = (UInt8 *)CVPixelBufferGetBaseAddress((CVPixelBufferRef)atomic_load_explicit(v3, memory_order_acquire));
      if (BaseAddress)
      {
        CFDataRef v61 = CFDataCreateWithBytesNoCopy(v6, BaseAddress, Height * BytesPerRow, (CFAllocatorRef)atomic_load_explicit((atomic_ullong *volatile)&v62, memory_order_acquire));
        if (!atomic_load_explicit((atomic_ullong *volatile)&v61, memory_order_acquire))
        {
          CFAllocatorDeallocate((CFAllocatorRef)atomic_load_explicit((atomic_ullong *volatile)&v62, memory_order_acquire), BaseAddress);
          *(unsigned char *)uint64_t v2 = 0;
          *((unsigned char *)v2 + 64) = 0;
LABEL_36:
          sub_1DC34D854((atomic_ullong *)&v61);
          goto LABEL_51;
        }
        unint64_t v32 = atomic_exchange((atomic_ullong *volatile)&v61, 0);
        uint64_t v33 = (void *)v64.i64[1];
        unint64_t v34 = v65[0];
        size_t v48 = Width;
        uint64_t v49 = v2;
        if (v64.i64[1] >= v65[0])
        {
          uint64_t v36 = (void *)v64.i64[0];
          uint64_t v37 = (v64.i64[1] - v64.i64[0]) >> 5;
          unint64_t v38 = v37 + 1;
          if ((unint64_t)(v37 + 1) >> 59) {
            sub_1DC2FF97C();
          }
          if ((v65[0] - v64.i64[0]) >> 4 > v38) {
            unint64_t v38 = (v65[0] - v64.i64[0]) >> 4;
          }
          if (v65[0] - v64.i64[0] >= 0x7FFFFFFFFFFFFFE0uLL) {
            unint64_t v39 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v39 = v38;
          }
          char v58 = v65;
          if (v39 >> 59) {
            sub_1DC2FF994();
          }
          long long v40 = (char *)operator new(32 * v39);
          unint64_t v41 = (size_t *)&v40[32 * v37];
          *(void *)float v56 = v40;
          *(void *)&v56[8] = v41;
          *unint64_t v41 = Width;
          v41[1] = Height;
          atomic_ullong v42 = (atomic_ullong)&v40[32 * v39];
          _OWORD v41[2] = BytesPerRow;
          v41[3] = v32;
          int v35 = v41 + 4;
          *(void *)&v56[16] = v41 + 4;
          unint64_t v57 = v42;
          if (v33 == v36)
          {
            int64x2_t v46 = vdupq_n_s64((unint64_t)v33);
          }
          else
          {
            do
            {
              size_t v43 = *(v33 - 4);
              v33 -= 4;
              *uint64_t v33 = 0;
              *(v41 - 4) = v43;
              v41 -= 4;
              size_t v44 = v33[1];
              v33[1] = 0;
              v41[1] = v44;
              size_t v45 = v33[2];
              v33[2] = 0;
              _OWORD v41[2] = v45;
              v41[3] = atomic_exchange(v33 + 3, 0);
            }
            while (v33 != v36);
            int64x2_t v46 = v64;
            unint64_t v34 = v65[0];
            int v35 = *(void **)&v56[16];
            atomic_ullong v42 = v57;
          }
          v64.i64[0] = (uint64_t)v41;
          v64.i64[1] = (uint64_t)v35;
          *(int64x2_t *)&v56[8] = v46;
          v65[0] = v42;
          unint64_t v57 = v34;
          *(void *)float v56 = v46.i64[0];
          sub_1DC3B7D68((uint64_t)v56);
        }
        else
        {
          *(void *)v64.i64[1] = Width;
          v33[1] = Height;
          int v35 = v33 + 4;
          v33[2] = BytesPerRow;
          v33[3] = v32;
        }
        v64.i64[1] = (uint64_t)v35;
        sub_1DC34D854((atomic_ullong *)&v61);
LABEL_50:
        unint64_t v57 = atomic_exchange(v66, 0);
        LOBYTE(v58) = IsPlanar != 0;
        int64x2_t v59 = v64;
        atomic_ullong v60 = v65[0];
        int64x2_t v64 = 0u;
        v65[0] = 0;
        *(_OWORD *)float v56 = 0u;
        *uint64_t v49 = v48;
        v49[1] = Height;
        *(_DWORD *)&v56[16] = 0;
        *((_DWORD *)v49 + 4) = PixelFormatType;
        v49[3] = atomic_exchange((atomic_ullong *volatile)&v57, 0);
        char v47 = (char)v58;
        LOBYTE(v58) = 0;
        *((unsigned char *)v49 + 32) = v47;
        *(int64x2_t *)(v49 + 5) = v59;
        v49[7] = v60;
        int64x2_t v59 = 0u;
        atomic_ullong v60 = 0;
        *((unsigned char *)v49 + 64) = 1;
        sub_1DC3B757C((void **)&v59);
        sub_1DC31EBFC((atomic_ullong *)&v57);
        goto LABEL_51;
      }
    }
  }
  *(unsigned char *)uint64_t v2 = 0;
  *((unsigned char *)v2 + 64) = 0;
LABEL_51:
  sub_1DC3B7DBC((atomic_ullong *)&v62);
  sub_1DC3B757C((void **)&v64);
  return sub_1DC31EBFC(v66);
}

void sub_1DC3B6D70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,atomic_ullong a28,atomic_ullong a29)
{
  sub_1DC34D854(&a28);
  sub_1DC3B7DBC(&a29);
  sub_1DC3B757C((void **)(v29 - 128));
  sub_1DC31EBFC((atomic_ullong *)(v29 - 96));
  _Unwind_Resume(a1);
}

CFDictionaryRef sub_1DC3B6DE4(uint64_t *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v25 = *a1;
  CFDictionaryRef theDict = Mutable;
  if (!sub_1DC3B7C7C(&theDict, (UInt8 *)"width", 5, &v25)) {
    goto LABEL_29;
  }
  uint64_t v24 = sub_1DC3B7D3C((uint64_t)a1);
  if (!sub_1DC3B7C7C(&theDict, (UInt8 *)"height", 6, &v24)) {
    goto LABEL_29;
  }
  unsigned int v4 = sub_1DC3B7D60((uint64_t)a1);
  CFStringRef v5 = sub_1DC3861F0((UInt8 *)"pixelFormatType", 15);
  if (!v5) {
    goto LABEL_29;
  }
  uint64_t valuePtr = v4;
  CFNumberRef v6 = CFNumberCreate(v2, kCFNumberSInt64Type, &valuePtr);
  if (v6)
  {
    int v7 = sub_1DC3863F4(&theDict, v5, v6);
    CFRelease(v5);
  }
  else
  {
    int v7 = 0;
    CFNumberRef v6 = (CFNumberRef)v5;
  }
  CFRelease(v6);
  if (!v7) {
    goto LABEL_29;
  }
  CFAllocatorRef v8 = (const void *)sub_1DC3B7D28((uint64_t)a1);
  CFStringRef v9 = sub_1DC3861F0((UInt8 *)"pixelBufferAttributes", 21);
  if (!v9) {
    goto LABEL_29;
  }
  CFDictionaryRef v10 = sub_1DC38628C(v8);
  if (v10)
  {
    int v11 = sub_1DC3863F4(&theDict, v9, v10);
    CFRelease(v9);
  }
  else
  {
    int v11 = 0;
    CFDictionaryRef v10 = (CFDictionaryRef)v9;
  }
  CFRelease(v10);
  if (!v11) {
    goto LABEL_29;
  }
  int v12 = sub_1DC3B7D58((uint64_t)a1);
  CFStringRef v13 = sub_1DC3861F0((UInt8 *)"isPlanar", 8);
  if (!v13) {
    goto LABEL_29;
  }
  uint64_t v14 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (!v12) {
    uint64_t v14 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
  }
  CFTypeRef v15 = CFRetain(*v14);
  if (v15)
  {
    int v16 = sub_1DC3863F4(&theDict, v13, v15);
    CFRelease(v13);
  }
  else
  {
    int v16 = 0;
    CFTypeRef v15 = v13;
  }
  CFRelease(v15);
  if (!v16) {
    goto LABEL_29;
  }
  sub_1DC3B7D44((uint64_t)a1);
  uint64_t v18 = v17;
  CFStringRef v19 = sub_1DC3861F0((UInt8 *)"planes", 6);
  if (!v19) {
    goto LABEL_29;
  }
  if (v18) {
    operator new[]();
  }
  CFArrayRef v20 = CFArrayCreate(v2, 0, 0, MEMORY[0x1E4F1D510]);
  if (v20)
  {
    int v21 = sub_1DC3863F4(&theDict, v19, v20);
    CFRelease(v19);
  }
  else
  {
    int v21 = 0;
    CFArrayRef v20 = (CFArrayRef)v19;
  }
  CFRelease(v20);
  if (v21 && theDict) {
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v2, theDict);
  }
  else {
LABEL_29:
  }
    CFDictionaryRef Copy = 0;
  sub_1DC3863C0((const void **)&theDict);
  return Copy;
}

void sub_1DC3B72B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  MEMORY[0x1E019CE70](v4, 0x60C8044C4A2DFLL);
  sub_1DC3863C0((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1DC3B732C(uint64_t *result, unint64_t a2)
{
  if (a2 > (result[2] - *result) >> 6)
  {
    if (a2 >> 58) {
      sub_1DC2FF97C();
    }
    uint64_t v3 = result;
    uint64_t v4 = result[1] - *result;
    v5[4] = result + 2;
    v5[0] = operator new(a2 << 6);
    v5[1] = v5[0] + v4;
    v5[2] = v5[0] + v4;
    v5[3] = v5[0] + (a2 << 6);
    sub_1DC3B7B50(v3, v5);
    return (uint64_t *)sub_1DC3B7C18((uint64_t)v5);
  }
  return result;
}

uint64_t sub_1DC3B73BC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    sub_1DC3B757C((void **)(a1 + 40));
    sub_1DC31EBFC((atomic_ullong *)(a1 + 24));
  }
  return a1;
}

uint64_t *sub_1DC3B73F8(uint64_t *result, long long *a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  unint64_t v5 = result[1];
  if (v5 >= v4)
  {
    uint64_t v9 = (uint64_t)(v5 - *result) >> 6;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 58) {
      sub_1DC2FF97C();
    }
    uint64_t v11 = v4 - *result;
    if (v11 >> 5 > v10) {
      unint64_t v10 = v11 >> 5;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    CFArrayRef v20 = result + 2;
    if (v12 >> 58) {
      sub_1DC2FF994();
    }
    CFStringRef v13 = (char *)operator new(v12 << 6);
    uint64_t v14 = &v13[64 * v9];
    v17[0] = v13;
    v17[1] = v14;
    uint64_t v18 = v14;
    CFStringRef v19 = &v13[64 * v12];
    long long v15 = *a2;
    *a2 = 0u;
    *(_OWORD *)uint64_t v14 = v15;
    int v16 = *((_DWORD *)a2 + 4);
    *((_DWORD *)a2 + 4) = 0;
    *((_DWORD *)v14 + 4) = v16;
    *((void *)v14 + 3) = atomic_exchange((atomic_ullong *volatile)a2 + 3, 0);
    LOBYTE(v16) = *((unsigned char *)a2 + 32);
    *((unsigned char *)a2 + 32) = 0;
    v14[32] = v16;
    *(_OWORD *)(v14 + 40) = *(long long *)((char *)a2 + 40);
    *((void *)v14 + 7) = *((void *)a2 + 7);
    *(long long *)((char *)a2 + 40) = 0u;
    *((void *)a2 + 7) = 0;
    v18 += 64;
    sub_1DC3B7B50(v3, v17);
    uint64_t v8 = v3[1];
    Class result = (uint64_t *)sub_1DC3B7C18((uint64_t)v17);
  }
  else
  {
    uint64_t v6 = *(void *)a2;
    *(void *)a2 = 0;
    *(void *)unint64_t v5 = v6;
    uint64_t v7 = *((void *)a2 + 1);
    *((void *)a2 + 1) = 0;
    *(void *)(v5 + 8) = v7;
    LODWORD(v7) = *((_DWORD *)a2 + 4);
    *((_DWORD *)a2 + 4) = 0;
    *(_DWORD *)(v5 + 16) = v7;
    *(void *)(v5 + 24) = atomic_exchange((atomic_ullong *volatile)a2 + 3, 0);
    LOBYTE(v7) = *((unsigned char *)a2 + 32);
    *((unsigned char *)a2 + 32) = 0;
    *(unsigned char *)(v5 + 32) = v7;
    *(void *)(v5 + 48) = 0;
    *(void *)(v5 + 56) = 0;
    *(void *)(v5 + 40) = 0;
    *(_OWORD *)(v5 + 40) = *(long long *)((char *)a2 + 40);
    *(void *)(v5 + 56) = *((void *)a2 + 7);
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 6) = 0;
    *((void *)a2 + 7) = 0;
    uint64_t v8 = v5 + 64;
  }
  v3[1] = v8;
  return result;
}

void **sub_1DC3B757C(void **a1)
{
  CFAllocatorRef v2 = (atomic_ullong *)*a1;
  if (*a1)
  {
    uint64_t v3 = (atomic_ullong *)a1[1];
    unint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = v3 - 4;
        sub_1DC34D854(v3 - 1);
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void **sub_1DC3B75E4(void **a1)
{
  CFAllocatorRef v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    unint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        sub_1DC3B757C(v3 - 3);
        sub_1DC31EBFC((atomic_ullong *)v3 - 5);
        v3 -= 8;
      }
      while (v3 != v2);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1DC3B7654(CFDictionaryRef *a1, const __CFString *a2, const void **a3)
{
  CFStringRef v5 = sub_1DC386224(a2);
  if (!v5) {
    return 0;
  }
  CFStringRef v6 = v5;
  CFDictionaryRef v7 = sub_1DC38628C(*a3);
  if (v7)
  {
    CFStringRef v8 = (const __CFString *)v7;
    uint64_t v9 = sub_1DC3863F4(a1, v6, v7);
    CFRelease(v6);
    CFStringRef v6 = v8;
  }
  else
  {
    uint64_t v9 = 0;
  }
  CFRelease(v6);
  return v9;
}

uint64_t sub_1DC3B76DC(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  if (sub_1DC386224(a2))
  {
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v5 = 0;
      long long v6 = *(_OWORD *)(a3 + 16 * v4);
      CFDictionaryRef v7 = &v12[v4 + 1];
      long long v8 = *v7;
      do
      {
        long long v11 = v6;
        int v9 = *(_DWORD *)((unint64_t)&v11 & 0xFFFFFFFFFFFFFFF3 | (4 * (v5 & 3)));
        v12[0] = v8;
        *(_DWORD *)((unint64_t)v12 & 0xFFFFFFFFFFFFFFF3 | (4 * (v5 & 3))) = v9;
        long long v8 = v12[0];
        ++v5;
      }
      while (v5 != 3);
      *((_DWORD *)v7 + 2) = DWORD2(v12[0]);
      *(void *)CFDictionaryRef v7 = v8;
      if (++v4 == 3) {
        operator new[]();
      }
    }
  }
  return 0;
}

void sub_1DC3B79BC(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE70](v1, 0x60C8044C4A2DFLL);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3B7A18(atomic_ullong *result, uint64_t a2, int a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  if (v4)
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
    {
      if (*(char *)(a2 + 23) >= 0) {
        long long v8 = (const char *)a2;
      }
      else {
        long long v8 = *(const char **)a2;
      }
      CFStringRef v11 = CFStringCreateWithFileSystemRepresentation(v7, v8);
      if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
      {
        unint64_t explicit = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        CFDictionarySetValue(explicit, (const void *)*MEMORY[0x1E4F1D168], (const void *)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire));
        CFErrorRef v10 = CFErrorCreate(v7, (CFErrorDomain)*MEMORY[0x1E4F1D160], a3, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
      }
      else
      {
        CFErrorRef v10 = 0;
      }
      void *v3 = v10;
      sub_1DC31FA90((atomic_ullong *)&v11);
    }
    else
    {
      void *v3 = 0;
    }
    return sub_1DC306584((atomic_ullong *)&Mutable);
  }
  else
  {
    *Class result = 0;
  }
  return result;
}

void sub_1DC3B7B2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC306584((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1DC3B7B50(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      uint64_t v8 = *(void *)(v2 + v5 - 64);
      *(void *)(v7 - 64) = 0;
      *(void *)(v6 - 64) = v8;
      uint64_t v9 = *(void *)(v2 + v5 - 56);
      *(void *)(v7 - 56) = 0;
      *(void *)(v6 - 56) = v9;
      LODWORD(v9) = *(_DWORD *)(v2 + v5 - 48);
      *(_DWORD *)(v7 - 48) = 0;
      *(_DWORD *)(v6 - 48) = v9;
      *(void *)(v6 - 40) = atomic_exchange((atomic_ullong *volatile)(v2 + v5 - 40), 0);
      LOBYTE(v9) = *(unsigned char *)(v2 + v5 - 32);
      *(unsigned char *)(v7 - 32) = 0;
      *(unsigned char *)(v6 - 32) = v9;
      *(void *)(v6 - 16) = 0;
      *(void *)(v6 - 8) = 0;
      *(void *)(v6 - 24) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      v5 -= 64;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v10 = *result;
  *Class result = v4;
  a2[1] = v10;
  uint64_t v11 = result[1];
  result[1] = a2[2];
  a2[2] = v11;
  uint64_t v12 = result[2];
  result[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DC3B7C18(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 64;
    sub_1DC3B757C((void **)(i - 24));
    sub_1DC31EBFC((atomic_ullong *)(i - 40));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1DC3B7C7C(CFDictionaryRef *a1, UInt8 *bytes, CFIndex numBytes, uint64_t *a4)
{
  CFStringRef v6 = sub_1DC3861F0(bytes, numBytes);
  if (!v6) {
    return 0;
  }
  CFStringRef v7 = v6;
  uint64_t v8 = *a4;
  v13[0] = 0;
  v13[1] = v8;
  CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberMaxType|kCFNumberSInt8Type, v13);
  if (v9)
  {
    CFStringRef v10 = (const __CFString *)v9;
    uint64_t v11 = sub_1DC3863F4(a1, v7, v9);
    CFRelease(v7);
    CFStringRef v7 = v10;
  }
  else
  {
    uint64_t v11 = 0;
  }
  CFRelease(v7);
  return v11;
}

unint64_t sub_1DC3B7D28(uint64_t a1)
{
  return atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire);
}

uint64_t sub_1DC3B7D34(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_1DC3B7D3C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_1DC3B7D44(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_1DC3B7D58(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 32);
}

uint64_t sub_1DC3B7D60(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_1DC3B7D68(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    sub_1DC34D854((atomic_ullong *)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

atomic_ullong *sub_1DC3B7DBC(atomic_ullong *a1)
{
  uint64_t v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1DC3B7DF0(int a1, CVPixelBufferRef pixelBuffer)
{
  if (pixelBuffer) {
    return CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
  }
  return result;
}

unint64_t MRCSampleCreateByReadingOpaqueRepresentationFromFile(void *ptr, void *a2)
{
  LOBYTE(v24[0]) = 0;
  char v26 = 0;
  if (qword_1EAA94C50 != -1) {
    dispatch_once(&qword_1EAA94C50, &unk_1F3662548);
  }
  os_signpost_id_make_with_pointer((os_log_t)qword_1EAA94C48, ptr);
  sub_1DC3B6668((atomic_ullong *)v21, (const __CFURL *)ptr);
  if ((v22 & 0x80000000) == 0)
  {
    if (v22)
    {
      uint64_t v4 = (const char *)v21;
      goto LABEL_8;
    }
LABEL_12:
    *(void *)&v35.st_dev = -2006;
    context.versiouint64_t n = (CFIndex)@"Invalid file URL.";
    sub_1DC306334(v24, (uint64_t *)&v35.st_dev, (CFTypeRef *)&context);
LABEL_37:
    unint64_t v23 = 0;
    goto LABEL_38;
  }
  if (!v21[1]) {
    goto LABEL_12;
  }
  uint64_t v4 = v21[0];
LABEL_8:
  int v5 = open(v4, 0);
  int v6 = v5;
  if (v5 < 0)
  {
    int v9 = *__error();
    *(void *)&v35.st_dev = -2007;
    context.versiouint64_t n = (CFIndex)@"Unable to open file for reading.";
    sub_1DC306334(v24, (uint64_t *)&v35.st_dev, (CFTypeRef *)&context);
    sub_1DC3B7A18((atomic_ullong *)&v35.st_dev, (uint64_t)v21, v9);
    CFStringRef v10 = (const void *)atomic_exchange(v25, atomic_exchange((atomic_ullong *volatile)&v35.st_dev, 0));
    if (v10) {
      CFRelease(v10);
    }
    p_CFAllocatorContext context = (atomic_ullong *)&v35;
    goto LABEL_36;
  }
  fcntl(v5, 48, 1);
  if (fstat(v6, &v35))
  {
    int v7 = *__error();
    close(v6);
    context.versiouint64_t n = -2007;
    unint64_t v34 = @"Unable to get file status.";
    sub_1DC306334(v24, &context.version, (CFTypeRef *)&v34);
    sub_1DC3B7A18(&context.version, (uint64_t)v21, v7);
    uint64_t v8 = (const void *)atomic_exchange(v25, atomic_exchange(&context.version, 0));
    if (v8) {
      goto LABEL_34;
    }
    goto LABEL_35;
  }
  int v12 = v35.st_mode & 0xF000;
  if (v12 != 0x8000)
  {
    if (v12 == 0x4000) {
      int v16 = 21;
    }
    else {
      int v16 = 13;
    }
    close(v6);
    context.versiouint64_t n = -2007;
    unint64_t v34 = @"Unexpected file type.";
    sub_1DC306334(v24, &context.version, (CFTypeRef *)&v34);
    sub_1DC3B7A18(&context.version, (uint64_t)v21, v16);
    uint64_t v8 = (const void *)atomic_exchange(v25, atomic_exchange(&context.version, 0));
    if (!v8) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  if (v35.st_size < 0)
  {
    close(v6);
    context.versiouint64_t n = -2007;
    unint64_t v34 = @"Unexpected file size.";
    sub_1DC306334(v24, &context.version, (CFTypeRef *)&v34);
    sub_1DC3B7A18(&context.version, (uint64_t)v21, 12);
    uint64_t v8 = (const void *)atomic_exchange(v25, atomic_exchange(&context.version, 0));
    if (v8) {
      goto LABEL_34;
    }
    goto LABEL_35;
  }
  if (!v35.st_size)
  {
    close(v6);
    context.versiouint64_t n = -2007;
    unint64_t v34 = @"Empty file.";
    sub_1DC306334(v24, &context.version, (CFTypeRef *)&v34);
    goto LABEL_37;
  }
  CFStringRef v13 = (UInt8 *)mmap(0, v35.st_size, 1, 2, v6, 0);
  if (v13 == (UInt8 *)-1)
  {
    int v17 = *__error();
    close(v6);
    context.versiouint64_t n = -2007;
    unint64_t v34 = @"Unable to map file.";
    sub_1DC306334(v24, &context.version, (CFTypeRef *)&v34);
    sub_1DC3B7A18(&context.version, (uint64_t)v21, v17);
    uint64_t v8 = (const void *)atomic_exchange(v25, atomic_exchange(&context.version, 0));
    if (v8) {
LABEL_34:
    }
      CFRelease(v8);
LABEL_35:
    p_CFAllocatorContext context = (atomic_ullong *)&context;
LABEL_36:
    sub_1DC306854(p_context);
    goto LABEL_37;
  }
  close(v6);
  context.versiouint64_t n = 0;
  context.info = (void *)v35.st_size;
  memset(&context.retain, 0, 40);
  context.deallocate = (CFAllocatorDeallocateCallBack)j__munmap;
  context.preferredSize = 0;
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  unint64_t v34 = (__CFString *)CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &context);
  if (atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire))
  {
    uint64_t v32 = (uint64_t)CFDataCreateWithBytesNoCopy(v14, v13, v35.st_size, (CFAllocatorRef)atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire));
    if (atomic_load_explicit(&v32, memory_order_acquire))
    {
      CFErrorRef error = 0;
      float v30 = (__CFString *)CFPropertyListCreateWithData(v14, (CFDataRef)atomic_load_explicit(&v32, memory_order_acquire), 0, 0, &error);
      if (atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire))
      {
        sub_1DC3B848C(&v29, (atomic_ullong *)&v30);
        if (atomic_load_explicit(&v29, memory_order_acquire))
        {
          unint64_t v15 = atomic_exchange(&v29, 0);
        }
        else
        {
          size_t v27 = @"Unable to deserialize sample.";
          uint64_t v28 = -2009;
          sub_1DC306334(v24, &v28, (CFTypeRef *)&v27);
          unint64_t v15 = 0;
        }
        unint64_t v23 = v15;
        sub_1DC3B907C(&v29);
      }
      else
      {
        uint64_t v28 = @"Unable to deserialize sample.";
        uint64_t v29 = -2009;
        sub_1DC306334(v24, &v29, (CFTypeRef *)&v28);
        uint64_t v29 = (uint64_t)error;
        CFArrayRef v20 = (const void *)atomic_exchange(v25, atomic_exchange(&v29, 0));
        if (v20) {
          CFRelease(v20);
        }
        sub_1DC306854(&v29);
        unint64_t v23 = 0;
      }
      sub_1DC31EB58((atomic_ullong *)&v30);
    }
    else
    {
      CFAllocatorDeallocate((CFAllocatorRef)atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire), v13);
      float v30 = @"Unable to create data.";
      CFErrorRef error = (CFErrorRef)-2003;
      sub_1DC306334(v24, (uint64_t *)&error, (CFTypeRef *)&v30);
      unint64_t v23 = 0;
    }
    sub_1DC34D854(&v32);
  }
  else
  {
    munmap(v13, v35.st_size);
    CFErrorRef error = (CFErrorRef)@"Unable to create bytes deallocator.";
    uint64_t v32 = -2003;
    sub_1DC306334(v24, &v32, (CFTypeRef *)&error);
    unint64_t v23 = 0;
  }
  sub_1DC3B7DBC((atomic_ullong *)&v34);
LABEL_38:
  if (v22 < 0) {
    operator delete(v21[0]);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire))
  {
    unint64_t v18 = atomic_exchange((atomic_ullong *volatile)&v23, 0);
  }
  else
  {
    unint64_t v18 = 0;
    if (a2 && v26)
    {
      sub_1DC390F7C((CFErrorRef *)&v35, (uint64_t)v24);
      *a2 = atomic_exchange((atomic_ullong *volatile)&v35.st_dev, 0);
      sub_1DC306854((atomic_ullong *)&v35.st_dev);
      unint64_t v18 = 0;
    }
  }
  sub_1DC3B907C((atomic_ullong *)&v23);
  if (v26) {
    sub_1DC390B00(v24);
  }
  return v18;
}

void sub_1DC3B83BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, atomic_ullong a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,atomic_ullong a33,atomic_ullong a34,uint64_t a35,atomic_ullong a36,__int16 a37,char a38,char a39)
{
  sub_1DC3B907C(&a33);
  sub_1DC31EB58(&a34);
  sub_1DC34D854(&a36);
  sub_1DC3B7DBC((atomic_ullong *)(v39 - 184));
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a30) {
    sub_1DC390B00(&a18);
  }
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3B848C(atomic_ullong *result, atomic_ullong *a2)
{
  int v5 = result;
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  if (!atomic_load_explicit(a2, memory_order_acquire)
    || (CFTypeID v7 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire)),
        uint64_t result = (atomic_ullong *)CFDictionaryGetTypeID(),
        (atomic_ullong *)v7 != result))
  {
    *int v5 = 0;
    return result;
  }
  CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(a2, memory_order_acquire);
  if (explicit) {
    CFTypeRef explicit = CFRetain(explicit);
  }
  CFTypeRef v89 = explicit;
  sub_1DC38648C((CFDictionaryRef *)&v100, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v89, memory_order_acquire));
  atomic_ullong v98 = 0;
  atomic_ullong v99 = 0;
  atomic_ullong v97 = 0;
  bytes[0] = 0;
  char v108 = 0;
  CFStringRef v9 = sub_1DC386224(@"pixelBuffer");
  if (!v9
    || (CFTypeRef v10 = sub_1DC38652C((CFDictionaryRef *)&v100, v9), CFRelease(v9), !v10)
    || (sub_1DC3B90B0(v93, v10), CFRelease(v10), !v96))
  {
    *int v5 = 0;
    goto LABEL_24;
  }
  sub_1DC3B9A08((unint64_t *)v109, (uint64_t)v93);
  uint64_t v11 = (const void *)atomic_exchange(&v99, atomic_exchange((atomic_ullong *volatile)v109, 0));
  if (v11) {
    CFRelease(v11);
  }
  sub_1DC307370((atomic_ullong *)v109);
  if (!atomic_load_explicit(&v99, memory_order_acquire))
  {
    *int v5 = 0;
    goto LABEL_123;
  }
  CFStringRef v12 = sub_1DC386224(@"regionOfInterest");
  double v13 = 0.0;
  if (v12 && (CFTypeRef v14 = sub_1DC38652C((CFDictionaryRef *)&v100, v12), CFRelease(v12), v14))
  {
    CFTypeID v15 = CFGetTypeID(v14);
    if (v15 != CFArrayGetTypeID() || CFArrayGetCount((CFArrayRef)v14) != 4) {
      goto LABEL_27;
    }
    BOOL v16 = 0;
    for (unint64_t i = 0; i != 4; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v14, i);
      uint64_t v19 = sub_1DC386094(ValueAtIndex);
      if (!v20) {
        break;
      }
      *((void *)v101 + i) = v19;
      BOOL v16 = i > 2;
    }
    if (v16)
    {
      uint64_t v21 = 0;
      *(_OWORD *)unsigned int v109 = v101[0];
      *(_OWORD *)&v109[16] = v101[1];
      LOBYTE(v110) = 1;
      long long v22 = 0uLL;
      long long v23 = 0uLL;
      do
      {
        uint64_t v24 = *(void *)&v109[8 * v21];
        long long v87 = v22;
        long long v88 = v23;
        *((void *)&v87 + (v21 & 3)) = v24;
        long long v22 = v87;
        long long v23 = v88;
        ++v21;
      }
      while (v21 != 4);
      *(_OWORD *)otherNumber = v88;
      *(_OWORD *)cf = v87;
      int v25 = 1;
    }
    else
    {
LABEL_27:
      int v25 = 0;
      *(_OWORD *)otherNumber = 0u;
      *(_OWORD *)cf = 0u;
    }
    CFRelease(v14);
    BOOL v83 = v25 == 0;
    if (v25) {
      double v13 = *(double *)cf;
    }
    else {
      double v13 = 0.0;
    }
    if (v25) {
      double v2 = *(double *)&cf[1];
    }
    else {
      double v2 = 0.0;
    }
    if (v25) {
      double v3 = *(double *)otherNumber;
    }
    else {
      double v3 = 0.0;
    }
    if (v25) {
      double v4 = *(double *)&otherNumber[1];
    }
    else {
      double v4 = 0.0;
    }
  }
  else
  {
    BOOL v83 = 1;
  }
  CFStringRef v26 = sub_1DC386224(@"pyramid");
  if (v26 && (CFTypeRef v27 = sub_1DC38652C((CFDictionaryRef *)&v100, v26), CFRelease(v26), v27))
  {
    CFTypeID v28 = CFGetTypeID(v27);
    if (v28 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)v27);
      if (Count)
      {
        memset(v101, 0, 24);
        sub_1DC3B732C((uint64_t *)v101, Count);
        if (Count < 1)
        {
LABEL_50:
          long long v90 = v101[0];
          uint64_t v91 = *(void *)&v101[1];
          memset(v101, 0, 24);
          char v92 = 1;
        }
        else
        {
          CFIndex v30 = 0;
          while (1)
          {
            size_t v31 = CFArrayGetValueAtIndex((CFArrayRef)v27, v30);
            sub_1DC3B90B0((void **)v109, v31);
            if (!v112) {
              break;
            }
            sub_1DC3B73F8((uint64_t *)v101, (long long *)v109);
            if (v112)
            {
              sub_1DC3B757C((void **)&v110 + 1);
              sub_1DC31EBFC((atomic_ullong *)&v109[24]);
            }
            if (Count == ++v30) {
              goto LABEL_50;
            }
          }
          LOBYTE(v90) = 0;
          char v92 = 0;
        }
        uint64_t v32 = (void **)v101;
      }
      else
      {
        uint64_t v91 = 0;
        long long v90 = 0uLL;
        memset(v109, 0, 24);
        char v92 = 1;
        uint64_t v32 = (void **)v109;
      }
      sub_1DC3B75E4(v32);
    }
    else
    {
      LOBYTE(v90) = 0;
      char v92 = 0;
    }
    CFRelease(v27);
    if (v92)
    {
      CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      *(void *)unsigned int v109 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (uint64_t)(*((void *)&v90 + 1) - v90) >> 6, MEMORY[0x1E4F1D510]);
      uint64_t v35 = *((void *)&v90 + 1);
      for (uint64_t j = v90; j != v35; j += 64)
      {
        sub_1DC3B9A08((unint64_t *)v101, j);
        if (!atomic_load_explicit((atomic_ullong *volatile)v101, memory_order_acquire))
        {
          *int v5 = 0;
          sub_1DC307370((atomic_ullong *)v101);
          sub_1DC3070BC((atomic_ullong *)v109);
          goto LABEL_121;
        }
        CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)v109, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)v101, memory_order_acquire));
        sub_1DC307370((atomic_ullong *)v101);
      }
      *(void *)&v101[0] = CFArrayCreateCopy(v33, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)v109, memory_order_acquire));
      uint64_t v36 = (const void *)atomic_exchange(&v98, atomic_exchange((atomic_ullong *volatile)v101, 0));
      if (v36) {
        CFRelease(v36);
      }
      sub_1DC3065EC((atomic_ullong *)v101);
      sub_1DC3070BC((atomic_ullong *)v109);
    }
  }
  else
  {
    LOBYTE(v90) = 0;
    char v92 = 0;
  }
  CFStringRef v37 = sub_1DC386224(@"presentationTimeStamp");
  if (v37)
  {
    CFTypeRef v38 = sub_1DC38652C((CFDictionaryRef *)&v100, v37);
    CFRelease(v37);
    if (v38)
    {
      CFStringRef v37 = (const __CFString *)sub_1DC386304(v38);
      CFRelease(v38);
    }
    else
    {
      CFStringRef v37 = 0;
    }
  }
  *(void *)unsigned int v109 = v37;
  uint64_t v39 = (const void *)atomic_exchange(&v97, atomic_exchange((atomic_ullong *volatile)v109, 0));
  if (v39) {
    CFRelease(v39);
  }
  sub_1DC31EBFC((atomic_ullong *)v109);
  if (atomic_load_explicit(&v97, memory_order_acquire))
  {
    CMTimeMakeFromDictionary((CMTime *)v109, (CFDictionaryRef)atomic_load_explicit(&v97, memory_order_acquire));
    if ((v109[12] & 1) == 0) {
      goto LABEL_72;
    }
  }
  CFStringRef v40 = sub_1DC386224(@"cameraIntrinsicMatrix");
  if (!v40 || (CFTypeRef v41 = sub_1DC38652C((CFDictionaryRef *)&v100, v40), CFRelease(v40), !v41))
  {
    bytes[0] = 0;
    *(_OWORD *)&bytes[1] = v105;
    *(_OWORD *)&bytes[17] = v106[0];
    *(_OWORD *)&bytes[32] = *(_OWORD *)((char *)v106 + 15);
    char v108 = 0;
    goto LABEL_112;
  }
  CFTypeID v42 = CFGetTypeID(v41);
  cfa = v41;
  if (v42 != CFArrayGetTypeID() || CFArrayGetCount((CFArrayRef)v41) != 3) {
    goto LABEL_107;
  }
  BOOL v78 = 0;
  CFIndex v43 = 0;
  CFNumberRef v44 = (const __CFNumber *)*MEMORY[0x1E4F1D3A8];
  CFNumberRef v45 = (const __CFNumber *)*MEMORY[0x1E4F1D3A0];
  CFNumberRef otherNumbera = (const __CFNumber *)*MEMORY[0x1E4F1D398];
  do
  {
    unint64_t v46 = v43;
    CFArrayRef v47 = (const __CFArray *)CFArrayGetValueAtIndex((CFArrayRef)v41, v43);
    CFArrayRef v48 = v47;
    if (!v47) {
      break;
    }
    CFTypeID v49 = CFGetTypeID(v47);
    if (v49 != CFArrayGetTypeID() || CFArrayGetCount(v48) != 3) {
      break;
    }
    BOOL v50 = 0;
    for (unint64_t k = 0; k != 3; ++k)
    {
      CFNumberRef v52 = (const __CFNumber *)CFArrayGetValueAtIndex(v48, k);
      CFNumberRef v53 = v52;
      if (!v52) {
        break;
      }
      CFTypeID v54 = CFGetTypeID(v52);
      if (v54 != CFNumberGetTypeID()) {
        break;
      }
      if (v44 == v53 || CFNumberCompare(v53, v44, 0) == kCFCompareEqualTo)
      {
        int v57 = 2139095040;
LABEL_100:
        float v55 = *(float *)&v57;
        goto LABEL_101;
      }
      if (v45 == v53 || CFNumberCompare(v53, v45, 0) == kCFCompareEqualTo)
      {
        int v57 = -8388608;
        goto LABEL_100;
      }
      if (otherNumbera == v53 || CFNumberCompare(v53, otherNumbera, 0) == kCFCompareEqualTo)
      {
        int v57 = 2143289344;
        goto LABEL_100;
      }
      if (!CFNumberGetValue(v53, kCFNumberFloatType, &valuePtr)) {
        break;
      }
      float v55 = valuePtr;
      BOOL v56 = valuePtr < -3.4028e38;
      if (valuePtr > 3.4028e38) {
        BOOL v56 = 1;
      }
      if (v56) {
        float v55 = 0.0;
      }
      if (v56) {
        break;
      }
LABEL_101:
      *((float *)&Mutable + k) = v55;
      BOOL v50 = k > 1;
    }
    if (!v50) {
      break;
    }
    uint64_t v58 = 0;
    *(void *)unsigned int v109 = Mutable;
    *(void *)&v109[8] = v103 | 0x100000000;
    long long v59 = 0uLL;
    CFTypeRef v41 = cfa;
    do
    {
      int v60 = *(_DWORD *)&v109[4 * v58];
      long long v86 = v59;
      *(_DWORD *)((unint64_t)&v86 & 0xFFFFFFFFFFFFFFF3 | (4 * (v58 & 3))) = v60;
      long long v61 = v86;
      HIDWORD(v61) = HIDWORD(v59);
      ++v58;
      long long v59 = v61;
    }
    while (v58 != 3);
    v101[v46] = v86;
    CFIndex v43 = v46 + 1;
    BOOL v78 = v46 > 1;
  }
  while (v46 != 2);
  if (!v78)
  {
LABEL_107:
    int v62 = 0;
    char v63 = 0;
    goto LABEL_108;
  }
  uint64_t v72 = 0;
  *(_OWORD *)unsigned int v109 = v101[0];
  *(_OWORD *)&v109[16] = v101[1];
  long long v110 = v101[2];
  char v111 = 1;
  memset(v101, 0, sizeof(v101));
  do
  {
    uint64_t v73 = 0;
    long long v74 = *(_OWORD *)&v109[16 * v72];
    unint64_t v75 = &v101[v72];
    long long v76 = *v75;
    do
    {
      long long v84 = v74;
      int v77 = *(_DWORD *)((unint64_t)&v84 & 0xFFFFFFFFFFFFFFF3 | (4 * (v73 & 3)));
      long long v85 = v76;
      *(_DWORD *)((unint64_t)&v85 & 0xFFFFFFFFFFFFFFF3 | (4 * (v73 & 3))) = v77;
      long long v76 = v85;
      ++v73;
    }
    while (v73 != 3);
    *((_DWORD *)v75 + 2) = DWORD2(v85);
    *(void *)unint64_t v75 = v76;
    ++v72;
  }
  while (v72 != 3);
  char v63 = v101[0];
  long long v105 = *(_OWORD *)((char *)v101 + 1);
  v106[0] = *(_OWORD *)((char *)&v101[1] + 1);
  *(_OWORD *)((char *)v106 + 15) = v101[2];
  int v62 = 1;
LABEL_108:
  CFRelease(cfa);
  bytes[0] = v63;
  *(_OWORD *)&bytes[1] = v105;
  *(_OWORD *)&bytes[17] = v106[0];
  *(_OWORD *)&bytes[32] = *(_OWORD *)((char *)v106 + 15);
  char v108 = v62;
  if (v62)
  {
    v64.i64[0] = 0x3400000034000000;
    v64.i64[1] = 0x3400000034000000;
    uint32x4_t v65 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v64, vabsq_f32(*(float32x4_t *)&bytes[16])), (int8x16_t)vcgeq_f32(v64, vabsq_f32(*(float32x4_t *)bytes))), (int8x16_t)vcgeq_f32(v64, vabsq_f32(*(float32x4_t *)&bytes[32])));
    v65.i32[3] = v65.i32[2];
    if ((vminvq_u32(v65) & 0x80000000) != 0)
    {
LABEL_72:
      *int v5 = 0;
      goto LABEL_121;
    }
  }
LABEL_112:
  CFAllocatorRef v66 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v83)
  {
    uint64_t v67 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    v114.origin.x = v13;
    v114.origin.y = v2;
    v114.size.vImagePixelCount width = v3;
    v114.size.vImagePixelCount height = v4;
    *(void *)unsigned int v109 = CGRectCreateDictionaryRepresentation(v114);
    CFDictionarySetValue(v67, @"MRCSampleAttributeRegionOfInterest", (const void *)atomic_load_explicit((atomic_ullong *volatile)v109, memory_order_acquire));
    sub_1DC31EBFC((atomic_ullong *)v109);
  }
  if (atomic_load_explicit(&v98, memory_order_acquire)) {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MRCSampleAttributePyramid", (const void *)atomic_load_explicit(&v98, memory_order_acquire));
  }
  if (atomic_load_explicit(&v97, memory_order_acquire)) {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"MRCSampleAttributePresentationTimeStamp", (const void *)atomic_load_explicit(&v97, memory_order_acquire));
  }
  if (v108)
  {
    int64_t v68 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    *(void *)unsigned int v109 = CFDataCreate(v66, bytes, 48);
    CFDictionarySetValue(v68, @"MRCSampleAttributeCameraIntrinsicMatrix", (const void *)atomic_load_explicit((atomic_ullong *volatile)v109, memory_order_acquire));
    sub_1DC34D854((atomic_ullong *)v109);
  }
  unint64_t v69 = atomic_load_explicit(&v99, memory_order_acquire);
  unint64_t v70 = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  *(void *)unsigned int v109 = v69;
  *(void *)&v101[0] = v70;
  *(void *)&long long v105 = sub_1DC382094((CFTypeRef *)v109);
  unint64_t v71 = atomic_exchange((atomic_ullong *volatile)&v105, 0);
  sub_1DC3823EC((atomic_ullong *)&v105);
  *int v5 = v71;
  sub_1DC306584((atomic_ullong *)&Mutable);
LABEL_121:
  if (v92) {
    sub_1DC3B75E4((void **)&v90);
  }
LABEL_123:
  if (v96)
  {
    sub_1DC3B757C(&v95);
    sub_1DC31EBFC(v94);
  }
LABEL_24:
  sub_1DC31EBFC(&v97);
  sub_1DC3065EC(&v98);
  sub_1DC307370(&v99);
  sub_1DC3864F8(&v100);
  return sub_1DC31EBFC((atomic_ullong *)&v89);
}

void sub_1DC3B8F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,atomic_ullong a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,atomic_ullong a43,atomic_ullong a44,atomic_ullong a45,const void *a46,void *a47)
{
}

atomic_ullong *sub_1DC3B907C(atomic_ullong *a1)
{
  double v2 = (const void *)atomic_exchange(a1, 0);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void **sub_1DC3B90B0(void **result, CFTypeRef cf)
{
  uint64_t v2 = (uint64_t)result;
  if (!cf) {
    goto LABEL_92;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  uint64_t result = (void **)CFDictionaryGetTypeID();
  if ((void **)v4 != result) {
    goto LABEL_92;
  }
  LOBYTE(v91) = 0;
  BYTE8(v91) = 0;
  LOBYTE(v92) = 0;
  LOBYTE(v93) = 0;
  LOBYTE(v94) = 0;
  char v95 = 0;
  v96.i8[0] = 0;
  v96.i8[8] = 0;
  LOWORD(v97) = 0;
  v98.i8[0] = 0;
  unsigned __int8 v100 = 0;
  int v5 = sub_1DC38648C((CFDictionaryRef *)&v90, (const __CFDictionary *)cf);
  *(void *)&long long v91 = sub_1DC3B9DAC(v5, (UInt8 *)"width", 5);
  BYTE8(v91) = v6;
  unint64_t v92 = sub_1DC3B9DAC((CFDictionaryRef *)&v90, (UInt8 *)"height", 6);
  LOBYTE(v93) = v7;
  CFStringRef v8 = sub_1DC3861F0((UInt8 *)"pixelFormatType", 15);
  if (v8 && (CFTypeRef v9 = sub_1DC38652C((CFDictionaryRef *)&v90, v8), CFRelease(v8), v9))
  {
    uint64_t v10 = sub_1DC385E84(v9);
    CFRelease(v9);
    uint64_t v11 = v10 & 0x100000000;
    int v12 = v10 & 0xFFFFFF00;
    int v13 = v10;
  }
  else
  {
    int v12 = 0;
    uint64_t v11 = 0;
    int v13 = 0;
  }
  char v95 = BYTE4(v11);
  int v94 = v12 | v11 | v13;
  CFStringRef v14 = sub_1DC3861F0((UInt8 *)"pixelBufferAttributes", 21);
  if (v14)
  {
    CFTypeRef v15 = sub_1DC38652C((CFDictionaryRef *)&v90, v14);
    CFRelease(v14);
    if (v15)
    {
      CFStringRef v14 = (const __CFString *)sub_1DC386304(v15);
      CFRelease(v15);
    }
    else
    {
      CFStringRef v14 = 0;
    }
  }
  v96.i64[0] = (uint64_t)v14;
  v96.i8[8] = 1;
  CFStringRef v16 = sub_1DC3861F0((UInt8 *)"isPlanar", 8);
  if (v16)
  {
    CFTypeRef v17 = sub_1DC38652C((CFDictionaryRef *)&v90, v16);
    CFRelease(v16);
    if (v17)
    {
      LOWORD(v16) = sub_1DC386368(v17);
      CFRelease(v17);
      unsigned __int8 v18 = BYTE1(v16);
    }
    else
    {
      unsigned __int8 v18 = 0;
      LOBYTE(v16) = 0;
    }
  }
  else
  {
    unsigned __int8 v18 = 0;
  }
  LOWORD(v97) = v16 | (v18 << 8);
  CFStringRef v19 = sub_1DC3861F0((UInt8 *)"planes", 6);
  if (v19 && (CFTypeRef cfa = sub_1DC38652C((CFDictionaryRef *)&v90, v19), CFRelease(v19), cfa))
  {
    CFTypeID v20 = CFGetTypeID(cfa);
    if (v20 == CFArrayGetTypeID())
    {
      unint64_t Count = CFArrayGetCount((CFArrayRef)cfa);
      unint64_t v22 = Count;
      if (Count)
      {
        int64x2_t v101 = 0uLL;
        v102[0] = 0;
        if (Count >> 59) {
          sub_1DC2FF97C();
        }
        BOOL v78 = v102;
        CFArrayRef v23 = (const __CFArray *)cfa;
        unint64_t v75 = Count;
        v101.i64[0] = (uint64_t)operator new(32 * Count);
        v101.i64[1] = v101.i64[0];
        v102[0] = v101.i64[0] + 32 * v22;
        memset(v77, 0, sizeof(v77));
        sub_1DC3B7D68((uint64_t)v77);
        CFIndex v24 = 0;
        CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v23, v24);
          CFDictionaryRef v26 = ValueAtIndex;
          if (!ValueAtIndex) {
            break;
          }
          CFTypeID v27 = CFGetTypeID(ValueAtIndex);
          if (v27 != CFDictionaryGetTypeID()) {
            break;
          }
          sub_1DC38648C((CFDictionaryRef *)v77, v26);
          unint64_t v28 = sub_1DC3B9DAC((CFDictionaryRef *)v77, (UInt8 *)"width", 5);
          char v30 = v29;
          unint64_t v31 = sub_1DC3B9DAC((CFDictionaryRef *)v77, (UInt8 *)"height", 6);
          char v33 = v32;
          unint64_t v34 = sub_1DC3B9DAC((CFDictionaryRef *)v77, (UInt8 *)"bytesPerRow", 11);
          char v36 = v35;
          CFStringRef Copy = sub_1DC3861F0((UInt8 *)"data", 4);
          if (Copy)
          {
            CFTypeRef v38 = sub_1DC38652C((CFDictionaryRef *)v77, Copy);
            CFRelease(Copy);
            if (v38)
            {
              CFTypeID v39 = CFGetTypeID(v38);
              if (v39 == CFDataGetTypeID()) {
                CFStringRef Copy = (const __CFString *)CFDataCreateCopy(allocator, (CFDataRef)v38);
              }
              else {
                CFStringRef Copy = 0;
              }
              CFRelease(v38);
            }
            else
            {
              CFStringRef Copy = 0;
            }
          }
          if (!v30 || !v33 || !v36)
          {
            if (Copy) {
              CFRelease(Copy);
            }
LABEL_59:
            sub_1DC3864F8((const void **)v77);
            break;
          }
          if (!Copy) {
            goto LABEL_59;
          }
          sub_1DC3864F8((const void **)v77);
          memset(v77, 0, 24);
          *(void *)&long long v82 = v28;
          *((void *)&v82 + 1) = v31;
          *((void *)&v77[1] + 1) = Copy;
          unint64_t v40 = atomic_exchange((atomic_ullong *volatile)&v77[1] + 1, 0);
          unint64_t v83 = v34;
          unint64_t v84 = v40;
          char v85 = 1;
          sub_1DC34D854((atomic_ullong *)&v77[1] + 1);
          if (!v85) {
            break;
          }
          CFTypeRef v41 = (void *)v101.i64[1];
          if (v101.i64[1] >= v102[0])
          {
            uint64_t v46 = (v101.i64[1] - v101.i64[0]) >> 5;
            unint64_t v47 = v46 + 1;
            if ((unint64_t)(v46 + 1) >> 59) {
              sub_1DC2FF97C();
            }
            uint64_t v48 = v102[0] - v101.i64[0];
            if ((v102[0] - v101.i64[0]) >> 4 > v47) {
              unint64_t v47 = v48 >> 4;
            }
            if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v49 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v49 = v47;
            }
            BOOL v78 = v102;
            if (v49 >> 59) {
              sub_1DC2FF994();
            }
            BOOL v50 = (char *)operator new(32 * v49);
            CFAllocatorRef v51 = &v50[32 * v46];
            *(void *)&v77[0] = v50;
            *((void *)&v77[0] + 1) = v51;
            *(void *)&v77[1] = v51;
            *((void *)&v77[1] + 1) = &v50[32 * v49];
            long long v52 = v82;
            long long v82 = 0uLL;
            *(_OWORD *)CFAllocatorRef v51 = v52;
            unint64_t v53 = v83;
            unint64_t v83 = 0;
            unint64_t v54 = atomic_exchange((atomic_ullong *volatile)&v84, 0);
            *((void *)v51 + 2) = v53;
            *((void *)v51 + 3) = v54;
            CFNumberRef v45 = v51 + 32;
            *(void *)&v77[1] = v51 + 32;
            float v55 = (void *)v101.i64[1];
            BOOL v56 = (void *)v101.i64[0];
            if (v101.i64[1] == v101.i64[0])
            {
              int64x2_t v60 = vdupq_n_s64(v101.u64[1]);
            }
            else
            {
              do
              {
                uint64_t v57 = *(v55 - 4);
                v55 -= 4;
                void *v55 = 0;
                *((void *)v51 - 4) = v57;
                v51 -= 32;
                uint64_t v58 = v55[1];
                v55[1] = 0;
                *((void *)v51 + 1) = v58;
                uint64_t v59 = v55[2];
                v55[2] = 0;
                *((void *)v51 + 2) = v59;
                *((void *)v51 + 3) = atomic_exchange(v55 + 3, 0);
              }
              while (v55 != v56);
              int64x2_t v60 = v101;
              CFNumberRef v45 = *(void **)&v77[1];
            }
            v101.i64[0] = (uint64_t)v51;
            v101.i64[1] = (uint64_t)v45;
            *(int64x2_t *)((char *)v77 + 8) = v60;
            uint64_t v61 = v102[0];
            v102[0] = *((void *)&v77[1] + 1);
            *((void *)&v77[1] + 1) = v61;
            *(void *)&v77[0] = v60.i64[0];
            sub_1DC3B7D68((uint64_t)v77);
          }
          else
          {
            uint64_t v42 = v82;
            *(void *)&long long v82 = 0;
            *(void *)v101.i64[1] = v42;
            uint64_t v43 = *((void *)&v82 + 1);
            *((void *)&v82 + 1) = 0;
            v41[1] = v43;
            unint64_t v44 = v83;
            unint64_t v83 = 0;
            _OWORD v41[2] = v44;
            v41[3] = atomic_exchange((atomic_ullong *volatile)&v84, 0);
            CFNumberRef v45 = v41 + 4;
          }
          v101.i64[1] = (uint64_t)v45;
          if (v85) {
            sub_1DC34D854((atomic_ullong *)&v84);
          }
          CFArrayRef v23 = (const __CFArray *)cfa;
          if (++v24 == v75)
          {
            int64x2_t v87 = v101;
            uint64_t v88 = v102[0];
            v102[0] = 0;
            int64x2_t v101 = 0uLL;
            unsigned __int8 v89 = 1;
            goto LABEL_61;
          }
        }
        v87.i8[0] = 0;
        unsigned __int8 v89 = 0;
LABEL_61:
        char v63 = (void **)&v101;
      }
      else
      {
        uint64_t v88 = 0;
        int64x2_t v87 = 0uLL;
        memset(v77, 0, 24);
        unsigned __int8 v89 = 1;
        char v63 = (void **)v77;
      }
      sub_1DC3B757C(v63);
    }
    else
    {
      v87.i8[0] = 0;
      unsigned __int8 v89 = 0;
    }
    CFRelease(cfa);
    int v62 = v89;
  }
  else
  {
    int v62 = 0;
    v87.i8[0] = 0;
    unsigned __int8 v89 = 0;
  }
  if (v100 == v62)
  {
    if (!v100) {
      goto LABEL_77;
    }
    uint64_t v64 = v98.i64[0];
    if (v98.i64[0])
    {
      uint64_t v65 = v98.i64[1];
      CFAllocatorRef v66 = (void *)v98.i64[0];
      if (v98.i64[1] != v98.i64[0])
      {
        do
        {
          uint64_t v67 = v65 - 32;
          sub_1DC34D854((atomic_ullong *)(v65 - 8));
          uint64_t v65 = v67;
        }
        while (v67 != v64);
        CFAllocatorRef v66 = (void *)v98.i64[0];
      }
      v98.i64[1] = v64;
      operator delete(v66);
    }
    int64x2_t v98 = v87;
    uint64_t v99 = v88;
    uint64_t v88 = 0;
    int64x2_t v87 = 0uLL;
  }
  else if (v100)
  {
    sub_1DC3B757C((void **)&v98);
    unsigned __int8 v100 = 0;
  }
  else
  {
    int64x2_t v98 = v87;
    uint64_t v99 = v88;
    uint64_t v88 = 0;
    int64x2_t v87 = 0uLL;
    unsigned __int8 v100 = 1;
  }
  if (v89) {
    sub_1DC3B757C((void **)&v87);
  }
LABEL_77:
  if (BYTE8(v91) && (_BYTE)v93 && v95 && v96.i8[8] && v96.i64[0] && BYTE1(v97) && v100)
  {
    *(void *)&long long v82 = v91;
    *((void *)&v82 + 1) = v92;
    LODWORD(v83) = v94;
    unint64_t v84 = v96.i64[0];
    char v85 = v97;
    uint64_t v68 = v99;
    int64x2_t v69 = v98;
    uint64_t v99 = 0;
    int64x2_t v98 = 0uLL;
    *(void *)&v77[0] = v91;
    *((void *)&v77[0] + 1) = v92;
    LODWORD(v77[1]) = v94;
    *((void *)&v77[1] + 1) = v96.i64[0];
    LOBYTE(v78) = v97;
    int64x2_t v79 = v69;
    uint64_t v80 = v68;
    memset(v86, 0, sizeof(v86));
    char v81 = 1;
    sub_1DC3B757C(v86);
    int v70 = 0;
  }
  else
  {
    if (v96.i8[8] && v96.i64[0]) {
      CFRelease((CFTypeRef)v96.i64[0]);
    }
    LOBYTE(v77[0]) = 0;
    char v81 = 0;
    int v70 = 1;
  }
  uint64_t result = (void **)sub_1DC3864F8(&v90);
  if (v100) {
    uint64_t result = sub_1DC3B757C((void **)&v98);
  }
  if (!v70)
  {
    int v71 = v77[1];
    char v72 = (char)v78;
    atomic_ullong v93 = *((void *)&v77[1] + 1);
    LOBYTE(v94) = (_BYTE)v78;
    int64x2_t v96 = v79;
    uint64_t v73 = v80;
    uint64_t v97 = v80;
    int64x2_t v79 = 0u;
    uint64_t v80 = 0;
    long long v91 = 0u;
    *(_OWORD *)uint64_t v2 = v77[0];
    LODWORD(v92) = 0;
    *(_DWORD *)(v2 + 16) = v71;
    *(void *)(v2 + 24) = atomic_exchange(&v93, 0);
    LOBYTE(v94) = 0;
    *(unsigned char *)(v2 + 32) = v72;
    *(int64x2_t *)(v2 + 40) = v96;
    *(void *)(v2 + 56) = v73;
    int64x2_t v96 = 0u;
    uint64_t v97 = 0;
    *(unsigned char *)(v2 + 64) = 1;
    sub_1DC3B757C((void **)&v96);
    sub_1DC31EBFC(&v93);
    return sub_1DC3B757C((void **)&v79);
  }
LABEL_92:
  *(unsigned char *)uint64_t v2 = 0;
  *(unsigned char *)(v2 + 64) = 0;
  return result;
}

void sub_1DC3B995C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void **a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_1DC3864F8((const void **)va);
  sub_1DC3B757C((void **)(v9 - 128));
  sub_1DC3864F8((const void **)(v9 - 232));
  if (*(unsigned char *)(v9 - 136)) {
    sub_1DC3B757C(a8);
  }
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3B9A08(unint64_t *a1, uint64_t a2)
{
  CVPixelBufferRef pixelBufferOut = 0;
  uint64_t result = (atomic_ullong *)CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(void *)a2, *(void *)(a2 + 8), *(_DWORD *)(a2 + 16), (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 24), memory_order_acquire), &pixelBufferOut);
  if (result)
  {
    *a1 = 0;
    return result;
  }
  CVPixelBufferRef v39 = pixelBufferOut;
  CVPixelBufferRef pixelBufferOut = 0;
  if (!atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire)) {
    goto LABEL_36;
  }
  int v5 = *(unsigned __int8 *)(a2 + 32);
  CFTypeRef explicit = (__CVBuffer *)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire);
  if (v5)
  {
    size_t PlaneCount = CVPixelBufferGetPlaneCount(explicit);
    if (CVPixelBufferIsPlanar((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire))&& PlaneCount == (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 5)
    {
      if (PlaneCount)
      {
        size_t v8 = 0;
        while (1)
        {
          uint64_t v9 = *(void *)(a2 + 40);
          size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire), v8);
          size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire), v8);
          size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire), v8);
          if (*(void *)(v9 + 32 * v8) != WidthOfPlane) {
            goto LABEL_36;
          }
          size_t v13 = PlaneCount;
          size_t v14 = v9 + 32 * v8;
          CFTypeRef v15 = (unint64_t *)(v14 + 8);
          if (*(void *)(v14 + 8) != HeightOfPlane) {
            goto LABEL_36;
          }
          unint64_t v18 = *(void *)(v14 + 16);
          CFTypeRef v17 = (size_t *)(v14 + 16);
          unint64_t v16 = v18;
          if (!v18) {
            goto LABEL_37;
          }
          CFStringRef v19 = (atomic_ullong *)(v9 + 32 * v8 + 24);
          unint64_t v16 = atomic_load_explicit(v19, memory_order_acquire);
          if (!v16) {
            goto LABEL_37;
          }
          size_t v20 = BytesPerRowOfPlane;
          if (CFDataGetLength((CFDataRef)atomic_load_explicit(v19, memory_order_acquire)) != *v15 * *v17) {
            goto LABEL_36;
          }
          BytePtr = CFDataGetBytePtr((CFDataRef)atomic_load_explicit(v19, memory_order_acquire));
          if (!BytePtr) {
            goto LABEL_36;
          }
          if (CVPixelBufferLockBaseAddress((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire), 0))
          {
            goto LABEL_36;
          }
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire), v8);
          CFArrayRef v23 = BaseAddressOfPlane;
          if (!BaseAddressOfPlane) {
            goto LABEL_36;
          }
          unint64_t v24 = *v15;
          if (*v17 == v20)
          {
            memcpy(BaseAddressOfPlane, BytePtr, v24 * v20);
          }
          else if (v24)
          {
            unint64_t v25 = 0;
            do
            {
              if (*v17 >= v20) {
                size_t v26 = v20;
              }
              else {
                size_t v26 = *v17;
              }
              memcpy(v23, &BytePtr[*v17 * v25++], v26);
              v23 += v20;
            }
            while (v25 < *v15);
          }
          CVPixelBufferUnlockBaseAddress((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire), 0);
          ++v8;
          size_t PlaneCount = v13;
          if (v8 == v13) {
            goto LABEL_26;
          }
        }
      }
      goto LABEL_26;
    }
LABEL_36:
    unint64_t v16 = 0;
    goto LABEL_37;
  }
  if (CVPixelBufferIsPlanar(explicit)) {
    goto LABEL_36;
  }
  CFTypeID v27 = *(void **)(a2 + 40);
  if (*(void *)(a2 + 48) - (void)v27 != 32 || *v27 != *(void *)a2 || v27[1] != *(void *)(a2 + 8) || !v27[2]) {
    goto LABEL_36;
  }
  unint64_t v16 = atomic_load_explicit(v27 + 3, memory_order_acquire);
  if (!v16) {
    goto LABEL_37;
  }
  CFIndex Length = CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)(*(void *)(a2 + 40) + 24), memory_order_acquire));
  char v29 = *(void **)(a2 + 40);
  if (Length != v29[1] * v29[2]) {
    goto LABEL_36;
  }
  char v30 = CFDataGetBytePtr((CFDataRef)atomic_load_explicit(v29 + 3, memory_order_acquire));
  if (!v30) {
    goto LABEL_36;
  }
  if (CVPixelBufferLockBaseAddress((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire), 0))
  {
    goto LABEL_36;
  }
  BaseAddress = (char *)CVPixelBufferGetBaseAddress((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire));
  if (!BaseAddress) {
    goto LABEL_36;
  }
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire));
  size_t v33 = BytesPerRow;
  uint64_t v34 = *(void *)(a2 + 40);
  uint64_t v35 = *(void *)(v34 + 8);
  if (*(void *)(v34 + 16) == BytesPerRow)
  {
    memcpy(BaseAddress, v30, v35 * BytesPerRow);
  }
  else if (v35)
  {
    unint64_t v36 = 0;
    do
    {
      size_t v37 = *(void *)(v34 + 16);
      if (v37 >= v33) {
        size_t v38 = v33;
      }
      else {
        size_t v38 = v37;
      }
      memcpy(BaseAddress, &v30[v37 * v36++], v38);
      uint64_t v34 = *(void *)(a2 + 40);
      BaseAddress += v33;
    }
    while (v36 < *(void *)(v34 + 8));
  }
  CVPixelBufferUnlockBaseAddress((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire), 0);
LABEL_26:
  unint64_t v16 = atomic_exchange((atomic_ullong *volatile)&v39, 0);
LABEL_37:
  *a1 = v16;
  return sub_1DC307370((atomic_ullong *)&v39);
}

void sub_1DC3B9D70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

unint64_t sub_1DC3B9DAC(CFDictionaryRef *a1, UInt8 *bytes, CFIndex numBytes)
{
  CFStringRef v4 = sub_1DC3861F0(bytes, numBytes);
  if (v4 && (CFStringRef v5 = v4, v6 = sub_1DC38652C(a1, v4), CFRelease(v5), v6))
  {
    unint64_t v7 = sub_1DC386000(v6);
    unsigned __int8 v8 = v7;
    unint64_t v9 = v7 & 0xFFFFFFFFFFFFFF00;
    CFRelease(v6);
    uint64_t v10 = v8;
  }
  else
  {
    unint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  return v10 | v9;
}

uint64_t sub_1DC3B9E54(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(int32x2_t *)(a1 + 40) = vdup_n_s32(0x7FC00000u);
  *(_DWORD *)(a1 + 48) = 2143289344;
  uint64_t v2 = (char *)operator new(0x100uLL);
  *(void *)a1 = v2;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = v2 + 256;
  return a1;
}

BOOL sub_1DC3B9EA8(double *a1, uint64_t a2, double a3, double a4)
{
  double v8 = sqrt(a4 * a4 + a3 * a3);
  *(double *)(a2 + 24) = a3 / v8;
  *(double *)(a2 + 32) = a4 / v8;
  while (1)
  {
    sub_1DC3BB218(a2, a1[1], a1[2]);
    unint64_t v9 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4;
    if (__ROR8__(0x6666666666666666 - 0x70A3D70A3D70A3D7 * v9, 1) <= 0x51EB851EB851EB8uLL)
    {
      BOOL result = sub_1DC3BB0E4(a2, *(float64x2_t **)a2, v9);
      if (!result) {
        break;
      }
      double v11 = a1[1];
      double v12 = a1[2];
      double v13 = sub_1DC3BB09C((float *)a2, v11, v12);
      BOOL result = sub_1DC3BA0B8(a1, v11 - v13 + **(double **)a2, v12 - v14 + *(double *)(*(void *)a2 + 8));
      if (!result) {
        break;
      }
    }
    int v15 = sub_1DC3BB344(a1, 1, 1, a3, a4);
    if (v15) {
      return v15 == 1 && *(void *)(a2 + 8) - *(void *)a2 > 0x10uLL;
    }
  }
  return result;
}

BOOL sub_1DC3B9FE0(uint64_t a1, uint64_t a2, double a3, double a4)
{
  CFTypeRef v6 = (double *)(a1 + 8);
  *(float64x2_t *)(a1 + 8) = vaddq_f64(*(float64x2_t *)(a1 + 24), *(float64x2_t *)(a1 + 8));
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 8);
  double v7 = *(double *)(a1 + 24);
  double v8 = *(double *)(a1 + 32);
  *(double *)(a1 + 24) = a3;
  *(double *)(a1 + 32) = a4;
  sub_1DC3BB344((double *)a1, 2, 0, -v7, -v8);
  BOOL result = 0;
  if (*(double *)a2 >= 0.0)
  {
    BOOL result = 0;
    double v10 = (double)*(unint64_t *)(*(void *)a1 + 8);
    if (*(double *)a2 < v10)
    {
      double v11 = *(double *)(a2 + 8);
      if (v11 >= 0.0)
      {
        double v12 = (double)*(unint64_t *)(*(void *)a1 + 16);
        if (v11 < v12 && *v6 >= 0.0)
        {
          double v13 = *(double *)(a1 + 16);
          BOOL v14 = *v6 < v10;
          if (v13 < 0.0) {
            BOOL v14 = 0;
          }
          return v13 < v12 && v14;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

BOOL sub_1DC3BA0B8(double *a1, double a2, double a3)
{
  double v3 = a1[3];
  double v4 = a1[4];
  double v5 = a1[1];
  double v6 = a1[2];
  double v7 = v5 - a2;
  double v8 = v6 - a3;
  double v9 = vabdd_f64(v5, a2);
  double v10 = vabdd_f64(v6, a3);
  if (v9 < v10) {
    double v9 = v10;
  }
  double v11 = v7 / v9;
  double v12 = v8 / v9;
  a1[3] = v7 / v9;
  a1[4] = v8 / v9;
  double v13 = v4 * (v8 / v9) + v7 / v9 * v3;
  if (v13 >= 0.0)
  {
    double v14 = fabs(v11);
    double v15 = fabs(v12);
    if (v14 == v15)
    {
      if (fabs(v3) <= fabs(v4)) {
        double v3 = 0.0;
      }
      else {
        double v4 = 0.0;
      }
      double v11 = v11 - v3;
      double v12 = v12 - v4;
LABEL_19:
      a1[3] = v3 + v11 * 0.99000001;
      a1[4] = v4 + v12 * 0.99000001;
      return v13 >= 0.0;
    }
    if (v14 <= v15) {
      double v11 = 0.0;
    }
    else {
      double v12 = 0.0;
    }
    if (fabs(v3) <= fabs(v4)) {
      double v3 = 0.0;
    }
    else {
      double v4 = 0.0;
    }
    if (v11 != v3 || v12 != v4) {
      goto LABEL_19;
    }
  }
  return v13 >= 0.0;
}

BOOL sub_1DC3BA17C(double *a1, uint64_t a2, int a3, float *a4, double a5, double a6)
{
  uint64_t v12 = 0;
  double v13 = sqrt(a6 * a6 + a5 * a5);
  *(double *)(a2 + 24) = a5 / v13;
  *(double *)(a2 + 32) = a6 / v13;
  double v14 = a1[1];
  double v15 = a1[2];
  double v16 = 3.0;
  do
  {
    float v17 = *(float *)(a2 + 40);
    if (v15 * *(float *)(a2 + 44) + v17 * v14 - *(float *)(a2 + 48) < -5.0)
    {
      BOOL result = sub_1DC3BB0E4(a2, *(float64x2_t **)a2, (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
      if (!result) {
        return result;
      }
      float v17 = *(float *)(a2 + 40);
      double v14 = a1[1];
      double v15 = a1[2];
      if (v15 * *(float *)(a2 + 44) + v17 * v14 - *(float *)(a2 + 48) < -5.0) {
        break;
      }
    }
    double v19 = v17;
    double v20 = *(float *)(a2 + 44);
    if (v15 * v20 + v19 * v14 - *(float *)(a2 + 48) > v16)
    {
      double v22 = a1[3];
      double v21 = a1[4];
      double v23 = sqrt(v21 * v21 + v22 * v22);
      if (fabs(v21 / v23 * v20 + v22 / v23 * v19) > 0.7) {
        return 0;
      }
      double v24 = sub_1DC3BB09C((float *)a2, v14, v15);
      double v26 = v25;
      double v27 = sub_1DC3BB09C((float *)a2, *(double *)(*(void *)(a2 + 8) - 16), *(double *)(*(void *)(a2 + 8) - 8));
      while (sqrt((v26 - v28) * (v26 - v28) + (v24 - v27) * (v24 - v27)) < 1.0)
      {
        double v24 = v24 + v22;
        double v26 = v26 + v21;
      }
      a1[1] = floor(v24) + 0.5;
      a1[2] = floor(v26) + 0.5;
      double v16 = 3.0;
      goto LABEL_27;
    }
    uint64_t v29 = *(void *)(a2 + 8);
    if (*(void *)a2 == v29)
    {
      double v32 = 0.0;
    }
    else
    {
      double v30 = a1[3];
      double v31 = a1[4];
      if (fabs(v30) <= fabs(v31)) {
        double v30 = 0.0;
      }
      else {
        double v31 = 0.0;
      }
      double v32 = v31 * (v15 - *(double *)(v29 - 8)) + v30 * (v14 - *(double *)(v29 - 16));
    }
    sub_1DC3BB218(a2, v14, v15);
    if (v32 <= 1.0)
    {
      if (!v12 && 2 * a3 <= (unint64_t)((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4)) {
        return 0;
      }
      goto LABEL_27;
    }
    uint64_t v33 = (v12 + 1);
    if ((int)v12 <= 0 && *(void *)(a2 + 8) - *(void *)a2 < 0x51uLL)
    {
      uint64_t v12 = (v12 + 1);
LABEL_27:
      float v38 = a4[10];
      uint64_t v33 = v12;
      goto LABEL_28;
    }
    BOOL result = sub_1DC3BA544(a2, 0, 1.5);
    if (!result) {
      return result;
    }
    double v34 = a1[1];
    double v35 = a1[2];
    double v36 = sub_1DC3BB09C((float *)a2, v34, v35);
    BOOL result = sub_1DC3BA0B8(a1, v34 - v36 + **(double **)a2, v35 - v37 + *(double *)(*(void *)a2 + 8));
    if (!result) {
      return result;
    }
    float v38 = a4[10];
LABEL_28:
    if (a3 >= (int)(a1[2] * a4[11] + v38 * a1[1] - a4[12])) {
      a3 = (int)(a1[2] * a4[11] + v38 * a1[1] - a4[12]);
    }
    int v39 = sub_1DC3BB344(a1, a3, 1, a5, a6);
    if (v39)
    {
      if (v39 == 1) {
        return a3 + 1 >= (int)(a1[2] * a4[11] + a4[10] * a1[1] - a4[12]);
      }
      return 0;
    }
    uint64_t v40 = *(void *)(a2 + 8);
    double v14 = a1[1];
    double v15 = a1[2];
    BOOL v41 = v14 == *(double *)(v40 - 16) && v15 == *(double *)(v40 - 8);
    uint64_t v12 = v33;
  }
  while (!v41);
  return 0;
}

BOOL sub_1DC3BA544(uint64_t a1, int a2, float a3)
{
  BOOL v6 = sub_1DC3BB0E4(a1, *(float64x2_t **)a1, (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4);
  if (a3 > 0.0)
  {
    double v8 = *(float64x2_t **)a1;
    uint64_t v7 = *(void *)(a1 + 8);
    int64_t v9 = v7 - *(void *)a1;
    if (v7 == *(void *)a1)
    {
      uint64_t v12 = 0;
      double v10 = 0;
    }
    else
    {
      if (v9 < 0) {
        sub_1DC2FF97C();
      }
      double v10 = (float64x2_t *)sub_1DC300068(v9 >> 4);
      uint64_t v12 = &v10[v11];
      memmove(v10, v8, v9);
      int64_t v9 = (int64_t)&v10[v9 >> 4];
    }
    double v13 = a3;
    while (1)
    {
      double v14 = (double *)v10;
      uint64_t v15 = v9 - (void)v10;
      if ((float64x2_t *)v9 != v10)
      {
        double v14 = (double *)v10;
        while (v14[1] * *(float *)(a1 + 44) + *(float *)(a1 + 40) * *v14 - *(float *)(a1 + 48) <= v13)
        {
          v14 += 2;
          if (v14 == (double *)v9)
          {
            float v17 = (char *)v9;
            goto LABEL_18;
          }
        }
      }
      float v17 = (char *)v9;
      if (v14 != (double *)v9)
      {
        double v16 = v14 + 2;
        float v17 = (char *)v14;
        while (v16 != (double *)v9)
        {
          if (v16[1] * *(float *)(a1 + 44) + *(float *)(a1 + 40) * *v16 - *(float *)(a1 + 48) <= v13)
          {
            *(_OWORD *)float v17 = *(_OWORD *)v16;
            v17 += 16;
          }
          v16 += 2;
        }
      }
LABEL_18:
      if ((char *)v9 == v17) {
        break;
      }
      int64_t v9 = (int64_t)v17;
      if (v15 >> 4 == (v17 - (char *)v10) >> 4) {
        break;
      }
      BOOL v6 = sub_1DC3BB0E4(a1, v10, (v17 - (char *)v10) >> 4);
    }
    if (a2)
    {
      unint64_t v18 = *(float64x2_t **)a1;
      if (*(void *)a1)
      {
        *(void *)(a1 + 8) = v18;
        operator delete(v18);
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
      }
      *(void *)a1 = v10;
      *(void *)(a1 + 8) = v9;
      *(void *)(a1 + 16) = v12;
    }
    else if (v10)
    {
      operator delete(v10);
    }
  }
  return v6;
}

double sub_1DC3BA748(uint64_t a1, double a2, double a3, double a4, double a5)
{
  sub_1DC3BA544(a1, 1, 1.0);
  double v10 = *(double **)a1;
  uint64_t v11 = *(void *)(a1 + 8);
  uint64_t v12 = v11 - *(void *)a1;
  if (v11 == *(void *)a1)
  {
    uint64_t v15 = 0;
LABEL_30:
    BOOL v33 = 1;
    double v39 = NAN;
    float v17 = v15;
    goto LABEL_31;
  }
  if (v12 < 0) {
    sub_1DC2FF97C();
  }
  double v13 = (double *)sub_1DC2FFD7C(v12 >> 4);
  uint64_t v15 = v13;
  double v10 = *(double **)a1;
  uint64_t v11 = *(void *)(a1 + 8);
  if ((unint64_t)(v11 - *(void *)a1) < 0x11) {
    goto LABEL_30;
  }
  unint64_t v16 = 1;
  float v17 = v13;
  unint64_t v18 = &v13[v14];
  do
  {
    double v19 = &v10[2 * v16];
    double v20 = sub_1DC3BB09C((float *)a1, *v19, v19[1]);
    double v22 = v21;
    double v23 = sub_1DC3BB09C((float *)a1, *(v19 - 2), *(v19 - 1));
    double v25 = sqrt((v22 - v24) * (v22 - v24) + (v20 - v23) * (v20 - v23));
    if (v15 >= v18)
    {
      uint64_t v26 = v15 - v17;
      unint64_t v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 61) {
        sub_1DC2FF97C();
      }
      if (((char *)v18 - (char *)v17) >> 2 > v27) {
        unint64_t v27 = ((char *)v18 - (char *)v17) >> 2;
      }
      if ((unint64_t)((char *)v18 - (char *)v17) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v27;
      }
      if (v28) {
        unint64_t v28 = (unint64_t)sub_1DC2FFD7C(v28);
      }
      else {
        uint64_t v29 = 0;
      }
      double v30 = (double *)(v28 + 8 * v26);
      double *v30 = v25;
      double v31 = v30 + 1;
      while (v15 != v17)
      {
        uint64_t v32 = *((void *)v15-- - 1);
        *((void *)v30-- - 1) = v32;
      }
      unint64_t v18 = (double *)(v28 + 8 * v29);
      if (v17) {
        operator delete(v17);
      }
      float v17 = v30;
      uint64_t v15 = v31;
    }
    else
    {
      *v15++ = v25;
    }
    ++v16;
    double v10 = *(double **)a1;
    uint64_t v11 = *(void *)(a1 + 8);
  }
  while (v16 < (v11 - *(void *)a1) >> 4);
  BOOL v33 = v17 == v15;
  if (v17 == v15)
  {
    double v39 = NAN;
  }
  else
  {
    int v34 = 0;
    double v35 = 0.0;
    double v36 = v17;
    do
    {
      double v37 = *v36++;
      double v38 = v37;
      v34 += v37 > 0.75 && v37 < 1.5;
      if (v37 <= 0.75 || v37 >= 1.5) {
        double v38 = -0.0;
      }
      double v35 = v35 + v38;
    }
    while (v36 != v15);
    double v39 = v35 / (double)v34;
  }
LABEL_31:
  double v40 = sub_1DC3BB09C((float *)a1, *v10, v10[1]);
  double v42 = sqrt((a3 - v41) * (a3 - v41) + (a2 - v40) * (a2 - v40)) - v39;
  if (v33)
  {
    uint64_t v43 = v17;
  }
  else
  {
    uint64_t v43 = v17;
    unint64_t v44 = v17;
    do
    {
      double v42 = v42 + *v44;
      if (*v44 > v39 * 1.9)
      {
        *v43++ = v42;
        double v42 = 0.0;
      }
      ++v44;
    }
    while (v44 != v15);
  }
  double v45 = sub_1DC3BB09C((float *)a1, *(double *)(v11 - 16), *(double *)(v11 - 8));
  *uint64_t v43 = v42 + sqrt((a5 - v46) * (a5 - v46) + (a4 - v45) * (a4 - v45));
  unint64_t v47 = v43 + 1;
  if (v47 != v15) {
    uint64_t v15 = v47;
  }
  double v48 = sqrt((a3 - a5) * (a3 - a5) + (a2 - a4) * (a2 - a4)) - v39;
  if (v17 == v15)
  {
    double v54 = NAN;
    if (!v17) {
      return v48 / v54;
    }
    goto LABEL_46;
  }
  int v49 = 0;
  double v50 = 0.0;
  CFAllocatorRef v51 = v17;
  do
  {
    double v52 = *v51++;
    double v53 = v52;
    if (vabdd_f64(v52, v48 / (double)(unint64_t)(v47 - v17)) >= v48
                                                                      / (double)(unint64_t)(v47 - v17)
                                                                      * 0.5)
      double v53 = -0.0;
    else {
      ++v49;
    }
    double v50 = v50 + v53;
  }
  while (v51 != v15);
  double v54 = v50 / (double)v49;
  if (v17) {
LABEL_46:
  }
    operator delete(v17);
  return v48 / v54;
}

void sub_1DC3BAAAC(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

double sub_1DC3BAAC8(double a1, double a2, double a3, double a4, double a5, double a6, float a7)
{
  double v7 = a3 - a1;
  double v8 = a4 - a2;
  double v9 = sqrt(v8 * v8 + v7 * v7);
  double v10 = v7 / v9;
  double v11 = v8 / v9;
  double v12 = a5 - a1;
  double v13 = a6 - a2;
  double v14 = sqrt(v13 * v13 + v12 * v12);
  return (v10 + v12 / v14) / sqrt((v11 + v13 / v14) * (v11 + v13 / v14) + (v10 + v12 / v14) * (v10 + v12 / v14)) * a7
       + a1;
}

void sub_1DC3BAB34()
{
}

void sub_1DC3BABB4()
{
}

void sub_1DC3BADE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, atomic_uint **a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
}

void sub_1DC3BAE2C()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1DC3BB044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  *(void *)(v12 + 8) = v13;
  sub_1DC2FFC48(&a10);
  for (uint64_t i = 24; i != -8; i -= 8)
    sub_1DC2FFD08((atomic_uint **)(&a12 + i));
  _Unwind_Resume(a1);
}

double sub_1DC3BB09C(float *a1, double a2, double a3)
{
  return a2 - (a3 * a1[11] + a1[10] * a2 - a1[12]) * a1[10];
}

BOOL sub_1DC3BB0E4(uint64_t a1, float64x2_t *a2, unint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = 16 * a3;
    float64x2_t v4 = 0uLL;
    uint64_t v5 = 16 * a3;
    BOOL v6 = a2;
    do
    {
      float64x2_t v7 = *v6++;
      float64x2_t v4 = vaddq_f64(v4, v7);
      v5 -= 16;
    }
    while (v5);
    float64x2_t v8 = vdivq_f64(v4, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)a3), 0));
    float32x2_t v9 = 0;
    float v10 = 0.0;
    do
    {
      float64x2_t v11 = vcvtq_f64_f32(v9);
      float64x2_t v12 = *a2++;
      float64x2_t v13 = vsubq_f64(v12, v8);
      float v10 = vmlad_n_f64(v10, v13.f64[0], v13.f64[0]);
      float32x2_t v9 = vcvt_f32_f64(vmlaq_laneq_f64(v11, v13, v13, 1));
      v3 -= 16;
    }
    while (v3);
    double v14 = v8.f64[1];
    float v15 = v9.f32[1];
    if (v9.f32[1] < v10)
    {
      float v16 = sqrtf(vmul_f32(v9, v9).f32[0] + (float)(v10 * v10));
      float v17 = v9.f32[0] / v16;
      goto LABEL_10;
    }
  }
  else
  {
    float v15 = 0.0;
    v8.f64[0] = NAN;
    v9.i32[0] = 0;
    double v14 = NAN;
  }
  float v16 = sqrtf((float)(v9.f32[0] * v9.f32[0]) + (float)(v15 * v15));
  float v17 = v15 / v16;
  float v10 = v9.f32[0];
LABEL_10:
  float v18 = (float)-v10 / v16;
  *(float *)(a1 + 40) = v17;
  *(float *)(a1 + 44) = v18;
  double v19 = *(double *)(a1 + 24);
  double v20 = *(double *)(a1 + 32);
  if (v18 * v20 + v19 * v17 < 0.0)
  {
    float v17 = -v17;
    float v18 = -v18;
    *(float *)(a1 + 40) = v17;
    *(float *)(a1 + 44) = v18;
  }
  float v21 = v14 * v18 + v17 * v8.f64[0];
  *(float *)(a1 + 48) = v21;
  return v20 * v18 + v19 * v17 > 0.5;
}

void sub_1DC3BB218(uint64_t a1, double a2, double a3)
{
  float64x2_t v7 = *(double **)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  if ((unint64_t)v7 >= v6)
  {
    float32x2_t v9 = *(double **)a1;
    uint64_t v10 = ((uint64_t)v7 - *(void *)a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_1DC2FF97C();
    }
    uint64_t v12 = v6 - (void)v9;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    BOOL v13 = (unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    if (!v13) {
      unint64_t v14 = v11;
    }
    if (v14)
    {
      unint64_t v14 = (unint64_t)sub_1DC300068(v14);
      float32x2_t v9 = *(double **)a1;
      float64x2_t v7 = *(double **)(a1 + 8);
    }
    else
    {
      uint64_t v15 = 0;
    }
    float v16 = (double *)(v14 + 16 * v10);
    unint64_t v17 = v14 + 16 * v15;
    *float v16 = a2;
    v16[1] = a3;
    float64x2_t v8 = v16 + 2;
    if (v7 != v9)
    {
      do
      {
        *((_OWORD *)v16 - 1) = *((_OWORD *)v7 - 1);
        v16 -= 2;
        v7 -= 2;
      }
      while (v7 != v9);
      float32x2_t v9 = *(double **)a1;
    }
    *(void *)a1 = v16;
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 16) = v17;
    if (v9) {
      operator delete(v9);
    }
  }
  else
  {
    *float64x2_t v7 = a2;
    v7[1] = a3;
    float64x2_t v8 = v7 + 2;
  }
  *(void *)(a1 + 8) = v8;
  if ((double *)((char *)v8 - *(void *)a1) == (double *)16)
  {
    float v18 = a3 * *(float *)(a1 + 44) + *(float *)(a1 + 40) * a2;
    *(float *)(a1 + 48) = v18;
  }
}

uint64_t sub_1DC3BB344(double *a1, int a2, char a3, double a4, double a5)
{
  BOOL v8 = fabs(a4) <= fabs(a5);
  if (v8) {
    double v9 = a5;
  }
  else {
    double v9 = 0.0;
  }
  if (v8) {
    double v10 = 0.0;
  }
  else {
    double v10 = a4;
  }
  if (a2 == 1) {
    unsigned int v11 = 2;
  }
  else {
    unsigned int v11 = 3;
  }
  unsigned int v12 = 1;
  while (a2 < 1)
  {
LABEL_22:
    uint64_t result = 1;
    if ((a3 & 1) == 0)
    {
      BOOL v8 = v11 > v12++;
      if (v8) {
        continue;
      }
    }
    return result;
  }
  double v13 = a1[3];
  double v14 = a1[4];
  int v15 = 1;
  double v16 = a1[1];
  double v17 = a1[2];
  double v40 = v17;
  double v41 = v16;
LABEL_13:
  unsigned int v18 = 0;
  double v19 = v13 * (double)v15 + v16;
  double v20 = v14 * (double)v15 + v17;
  do
  {
    if (((v12 * (((v15 >> 1) & 0x7FFFFFFE) + 2)) | 1) == v18)
    {
      BOOL v26 = v15++ == a2;
      double v17 = v40;
      double v16 = v41;
      if (v26) {
        goto LABEL_22;
      }
      goto LABEL_13;
    }
    unsigned int v21 = v18 + 1;
    if (v18) {
      int v22 = v21 >> 1;
    }
    else {
      int v22 = -(v18 >> 1);
    }
    double v23 = v10 * (double)v22 + v19;
    double v24 = v9 * (double)v22 + v20;
    BOOL v25 = sub_1DC3BB5C4(a1, v10 + v23, v9 + v24);
    unsigned int v18 = v21;
  }
  while (!v25);
  if (a2 <= 3) {
    int v28 = 3;
  }
  else {
    int v28 = a2;
  }
  uint64_t v29 = *(unint64_t **)a1;
  while (1)
  {
    if (v23 < 0.0) {
      return 2;
    }
    uint64_t result = 2;
    if (v23 >= (double)v29[1] || v24 < 0.0 || v24 >= (double)v29[2]) {
      return result;
    }
    if (*((_DWORD *)a1 + 11) == (*(unsigned __int8 *)v29 != sub_1DC2FF924((void *)v29[3], (int)v23, (int)v24)))break; {
    double v30 = v23 - v10;
    }
    double v31 = v24 - v9;
    BOOL v32 = sub_1DC3BB5C4(a1, v30 - v13, v31 - v14);
    if (v32) {
      double v33 = v13;
    }
    else {
      double v33 = 0.0;
    }
    double v23 = v30 - v33;
    if (v32) {
      double v34 = v14;
    }
    else {
      double v34 = 0.0;
    }
    double v24 = v31 - v34;
    if (!--v28) {
      return 2;
    }
  }
  uint64_t result = 0;
  double v35 = floor(v23) + 0.5;
  double v36 = floor(v24) + 0.5;
  a1[1] = v35;
  a1[2] = v36;
  if (a2 == 1)
  {
    double v37 = (unint64_t *)*((void *)a1 + 6);
    if (v37)
    {
      uint64_t v38 = (int)v35;
      uint64_t v39 = (int)v36;
      if (sub_1DC2FF924(v37, v38, v39)) {
        return 2;
      }
      uint64_t result = 0;
      *(_DWORD *)(v37[6] + (((v38 + v37[3] * v39) >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << (v38
                                                                                        + *((unsigned char *)v37 + 24) * v39);
    }
  }
  return result;
}

BOOL sub_1DC3BB5C4(_DWORD *a1, double a2, double a3)
{
  if (a2 >= 0.0)
  {
    uint64_t v5 = *(unsigned __int8 **)a1;
    int v4 = -1;
    if (a2 < (double)*(unint64_t *)(*(void *)a1 + 8)
      && a3 >= 0.0
      && a3 < (double)*((unint64_t *)v5 + 2))
    {
      int v4 = *v5 != sub_1DC2FF924(*((void **)v5 + 3), (int)a2, (int)a3);
    }
  }
  else
  {
    int v4 = -1;
  }
  return v4 == a1[10];
}

uint64_t sub_1DC3BB654(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  double v31 = a1;
  uint64_t v32 = a2;
  *(void *)&long long v30 = a3;
  *((void *)&v30 + 1) = a4;
  sub_1DC3ED678(&v31, &v30, a6, a7);
  int v8 = (int)v31;
  if ((int)v31 >= (int)v30) {
    int v8 = v30;
  }
  if (v8 < 11) {
    return 16;
  }
  *(_DWORD *)(a5 + 24) = 0;
  *(void *)(a5 + 8) = 0;
  int v29 = 0;
  int v27 = 0;
  int v28 = 0;
  uint64_t v25 = 0;
  int v24 = 0;
  uint64_t v10 = v32;
  uint64_t v11 = *((void *)&v30 + 1);
  int v12 = sub_1DC3BB7E4((uint64_t)v31, v32, v30, *((uint64_t *)&v30 + 1), *(unsigned __int8 *)(*(void *)(a5 + 64) + 30), &v28, &v27, &v26, (_DWORD *)&v25 + 1, (int *)&v25, &v24, (float *)&v29, (float *)(a5 + 24));
  if (!v12) {
    return 6;
  }
  uint64_t v13 = *(void *)(a5 + 64);
  if (!*(unsigned char *)(v13 + 30) && *(float *)(a5 + 24) < 0.75) {
    return 6;
  }
  int v14 = v29;
  *(_DWORD *)(a5 + 72) = v29;
  *(_DWORD *)(a5 + 76) = v14;
  switch(v12)
  {
    case 3:
      int v18 = HIDWORD(v25);
      *(_DWORD *)(v13 + 48) = *(_DWORD *)(v10 + 4 * SHIDWORD(v25));
      int v19 = v24;
      *(_DWORD *)(v13 + 52) = *(_DWORD *)(v11 + 4 * (v24 + 2));
      int v20 = v19 - v18 + 3;
LABEL_19:
      *(_DWORD *)(v13 + 20) = v20;
      return 1;
    case 2:
      int v21 = v24;
      if (v24 <= 9) {
        int v22 = 9;
      }
      else {
        int v22 = v24;
      }
      *(_DWORD *)(v13 + 48) = *(_DWORD *)(v10 + 4 * (v22 - 9));
      int v23 = v25;
      *(_DWORD *)(v13 + 52) = *(_DWORD *)(v11 + 4 * (int)v25);
      int v17 = v23 - v21;
      goto LABEL_18;
    case 1:
      uint64_t v16 = (int)v25;
      int v15 = HIDWORD(v25);
      *(_DWORD *)(v13 + 48) = *(_DWORD *)(v10 + 4 * SHIDWORD(v25));
      *(_DWORD *)(v13 + 52) = *(_DWORD *)(v11 + 4 * v16);
      int v17 = v16 - v15;
LABEL_18:
      int v20 = v17 + 1;
      goto LABEL_19;
  }
  return 1;
}

uint64_t sub_1DC3BB7E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, int *a10, _DWORD *a11, float *a12, float *a13)
{
  uint64_t result = 0;
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  *a8 = -1;
  *a7 = -1;
  *a6 = -1;
  *a11 = -1;
  *a10 = -1;
  *a9 = -1;
  int v15 = a13;
  v75[0] = a1;
  v75[1] = a2;
  v74[0] = a3;
  v74[1] = a4;
  *a12 = 0.0;
  *a13 = 0.0;
  if ((int)a1 >= 11)
  {
    uint64_t v16 = a8;
    if ((int)a1 >= (int)a3) {
      LODWORD(v19) = a3;
    }
    else {
      LODWORD(v19) = a1;
    }
    BOOL v20 = __OFSUB__(v19, 10);
    if ((int)v19 > 10)
    {
      uint64_t v30 = 0;
      char v71 = (v19 > 0xC) & a5;
      if (v71) {
        uint64_t v31 = 5;
      }
      else {
        uint64_t v31 = (v19 - 7);
      }
      while (1)
      {
        uint64_t v32 = (float *)(a2 + 4 * v30);
        float v33 = v32[3];
        float v34 = v33 - *v32;
        float v35 = v32[7] - v33;
        BOOL v36 = v34 < 7.0 || v35 < 12.0;
        if (!v36 && fabsf((float)(v35 / v34) + -1.7) < 0.2)
        {
          float v22 = (float)(v34 + v35) / 27.0;
          double v37 = (float *)(a4 + 4 * v30);
          float v38 = *v37 - *v32;
          if ((float)(v22 * 1.5) < v38 && v38 < (float)(v22 * 4.5))
          {
            uint64_t v40 = 0;
            char v41 = 1;
            do
            {
              if (v41) {
                double v42 = v32;
              }
              else {
                double v42 = v37;
              }
              if (v41) {
                ++v32;
              }
              else {
                ++v37;
              }
              v81[v40] = v42[1] - *v42;
              v41 ^= 1u;
              ++v40;
            }
            while (v40 != 5);
            float v43 = sub_1DC3BBDD4(v81, 5, &v76, v34);
            if (v43 < 0.25)
            {
              uint64_t v44 = 0;
              while (dword_1DC4104E8[v44] != 10000 * LODWORD(v76) + 1000 * v77 + 100 * v78 + 10 * v79 + v80)
              {
                if (++v44 == 52) {
                  goto LABEL_34;
                }
              }
              if ((v44 & 0x80000000) == 0) {
                break;
              }
            }
          }
        }
LABEL_34:
        if (++v30 == v31)
        {
          LODWORD(v44) = -1;
          float v70 = 0.0;
          float v22 = 0.0;
          goto LABEL_36;
        }
      }
      *a9 = v30;
      float v70 = 1.0 - v43;
LABEL_36:
      *a6 = v44;
      if (v71) {
        int v45 = v19 - 5;
      }
      else {
        int v45 = 7;
      }
      float v46 = 27.0;
      float v47 = 0.5;
      while (1)
      {
        uint64_t v48 = (v19 - 4);
        unsigned int v49 = v19 - 8;
        uint64_t v19 = (v19 - 1);
        float v50 = *(float *)(a2 + 4 * v19);
        CFAllocatorRef v51 = (float *)(a2 + 4 * v48);
        float v52 = v50 - *v51;
        float v53 = *v51 - *(float *)(a2 + 4 * v49);
        BOOL v54 = v52 < 7.0 || v53 < 12.0;
        if (!v54 && fabsf((float)(v53 / v52) + -1.7) < 0.2)
        {
          float v25 = (float)(v52 + v53) / v46;
          float v55 = (float *)(a4 + 4 * v48);
          float v56 = *v55 - *v51;
          BOOL v57 = (float)(v25 * 1.5) < v56 && v56 < (float)(v25 * 4.5);
          if (v57 && vabds_f32(*(float *)(a4 + 4 * v19) - v50, v25) < (float)(v25 * v47))
          {
            uint64_t v58 = 0;
            char v59 = 1;
            do
            {
              if (v59) {
                int64x2_t v60 = v51;
              }
              else {
                int64x2_t v60 = v55;
              }
              if (v59) {
                ++v51;
              }
              else {
                ++v55;
              }
              v81[v58] = v60[1] - *v60;
              v59 ^= 1u;
              ++v58;
            }
            while (v58 != 5);
            float v61 = sub_1DC3BBDD4(v81, 5, &v76, v52);
            float v46 = 27.0;
            float v47 = 0.5;
            if (v61 < 0.25)
            {
              uint64_t v21 = 0;
              int v62 = 10000 * LODWORD(v76) + 1000 * v77 + 100 * v78 + 10 * v79 + v80;
              while (1)
              {
                int v63 = dword_1DC4104E8[v21];
                BOOL v20 = __OFSUB__(v63, v62);
                if (v63 == v62) {
                  break;
                }
                if (++v21 == 52) {
                  goto LABEL_65;
                }
              }
              if ((v21 & 0x80000000) == 0) {
                break;
              }
            }
          }
        }
LABEL_65:
        BOOL v20 = __OFSUB__(v19, v45);
        if ((int)v19 <= v45)
        {
          LODWORD(v21) = -1;
          float v24 = 0.0;
          float v25 = 0.0;
          int v26 = a10;
          goto LABEL_67;
        }
      }
      int v26 = a10;
      *a10 = v19;
      float v24 = 1.0 - v61;
LABEL_67:
      int v15 = a13;
      uint64_t v16 = a8;
      int v27 = a5;
      float v23 = v70;
    }
    else
    {
      LODWORD(v21) = -1;
      *a6 = -1;
      float v22 = 0.0;
      float v23 = 0.0;
      float v24 = 0.0;
      float v25 = 0.0;
      int v26 = a10;
      int v27 = a5;
    }
    *a7 = v21;
    if ((int)(*a6 & v21) < 0 != v20) {
      return 0;
    }
    if ((*a6 & 0x80000000) != 0)
    {
      if ((v21 & 0x80000000) == 0)
      {
        int v64 = *v26;
LABEL_76:
        int v65 = v64 - 14;
        goto LABEL_78;
      }
    }
    else if ((v21 & 0x80000000) == 0)
    {
      int v64 = *v26;
      if (*a9 + 10 <= *v26 && (float)(vabds_f32(v22, v25) / (float)(v22 + v25)) < 0.2)
      {
        *a12 = (float)(v22 + v25) * 0.5;
        *int v15 = v23 * v24;
        return 1;
      }
      goto LABEL_76;
    }
    int v65 = *a9 + 9;
LABEL_78:
    *a11 = 0;
    v81[0] = 0.0;
    float v76 = 0.0;
    int v66 = sub_1DC3BBE58((uint64_t)v75, (uint64_t)v74, v65, v27, 0xFFFFFFFF, 0xFFFFFFFF, a11, &v76, v81);
    *uint64_t v16 = v66;
    if ((v66 & 0x80000000) == 0)
    {
      if ((*a7 & 0x80000000) == 0 && *a11 + 14 <= *v26)
      {
        float v67 = v25 + v76;
        if ((float)(vabds_f32(v76, v25) / (float)(v25 + v76)) < 0.2)
        {
          *a6 = -1;
          *a12 = v67 * 0.5;
          float v68 = v24 * v81[0];
          uint64_t result = 2;
LABEL_87:
          *int v15 = v68;
          return result;
        }
      }
      if ((*a6 & 0x80000000) == 0 && *a9 + 7 <= *a11)
      {
        float v69 = v22 + v76;
        if ((float)(vabds_f32(v76, v22) / (float)(v22 + v76)) < 0.2)
        {
          *a7 = -1;
          *a12 = v69 * 0.5;
          float v68 = v23 * v81[0];
          uint64_t result = 3;
          goto LABEL_87;
        }
      }
    }
    return 0;
  }
  return result;
}

float sub_1DC3BBDD4(float *a1, int a2, _DWORD *a3, float a4)
{
  float v4 = -1.0;
  if (a4 > 0.0)
  {
    if (a2 == 5) {
      int v5 = 10;
    }
    else {
      int v5 = 17;
    }
    float v4 = (float)v5 / a4;
  }
  uint64_t v6 = a2;
  float v7 = 0.0;
  do
  {
    float v8 = v4 * *a1;
    if (v8 < 1.5 || v8 > 9.5) {
      return 1.0;
    }
    *a3++ = llroundf(v8);
    float v7 = v7 + vabds_f32(v8, (float)(int)roundf(v8));
    ++a1;
    --v6;
  }
  while (v6);
  return v7 / (float)a2;
}

uint64_t sub_1DC3BBE58(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5, unsigned int a6, _DWORD *a7, float *a8, float *a9)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 >= *(_DWORD *)a2) {
    int v9 = *(_DWORD *)a2;
  }
  else {
    int v9 = *(_DWORD *)a1;
  }
  if (v9 < 11) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = 0;
  uint64_t v15 = *(void *)(a1 + 8);
  unsigned int v16 = a6 + 52;
  int v17 = a6 | a5;
  uint64_t v18 = *(void *)(a2 + 8);
  while (1)
  {
    uint64_t v19 = (dword_1DC4105B8[v13] + a3);
    int v20 = v19 + 7;
    if ((int)v19 < 4 || v20 >= v9) {
      goto LABEL_12;
    }
    float v22 = (float *)(v15 + 4 * v19);
    float v23 = *v22 - *(float *)(v15 + 4 * (v19 - 4));
    float v24 = *(float *)(v15 + 4 * (v19 + 3));
    float v25 = v24 - *v22;
    float v26 = *(float *)(v15 + 4 * v20) - v24;
    BOOL v27 = v23 < 12.0 || v25 < 7.0;
    BOOL v28 = v27 || v26 < 7.0;
    if (v28 || fabsf((float)(v23 / v25) + -1.7) >= 0.2 || fabsf((float)(v26 / v25) + -1.7) >= 0.2) {
      goto LABEL_12;
    }
    float v29 = (float)((float)(v23 + v25) + v26) / 44.0;
    uint64_t v30 = (float *)(v18 + 4 * v19);
    float v31 = *v30 - *v22;
    if ((float)(v29 * 0.5) >= v31 || v31 >= (float)(v29 * 1.5)) {
      goto LABEL_12;
    }
    uint64_t v48 = v18;
    int v49 = v17;
    unsigned int v50 = v16;
    int v51 = a4;
    float v52 = a9;
    unsigned int v53 = a5;
    float v33 = a7;
    float v34 = a8;
    uint64_t v35 = 0;
    char v36 = 1;
    do
    {
      if (v36) {
        double v37 = v22;
      }
      else {
        double v37 = v30;
      }
      if (v36) {
        ++v22;
      }
      else {
        ++v30;
      }
      v55[v35] = v37[1] - *v37;
      v36 ^= 1u;
      ++v35;
    }
    while (v35 != 5);
    float v38 = sub_1DC3BBDD4(v55, 5, v54, v25);
    a8 = v34;
    a7 = v33;
    a5 = v53;
    a9 = v52;
    unsigned int v16 = v50;
    a4 = v51;
    int v17 = v49;
    uint64_t v18 = v48;
    if (v38 >= 0.25) {
      goto LABEL_12;
    }
    uint64_t result = 0;
    while (dword_1DC410418[result] != 10000 * v54[0] + 1000 * v54[1] + 100 * v54[2] + 10 * v54[3] + v54[4])
    {
      if (++result == 52) {
        goto LABEL_12;
      }
    }
    if ((result & 0x80000000) != 0) {
      goto LABEL_12;
    }
    if (!v51) {
      goto LABEL_77;
    }
    if ((v53 & 0x80000000) != 0) {
      break;
    }
    int v39 = result + 52;
    if (result >= v53) {
      int v39 = result;
    }
    int v40 = v39 - v53;
    if (v40 <= 0) {
      unsigned int v41 = -(-v40 & 7);
    }
    else {
      unsigned int v41 = v40 & 7;
    }
    if (((1 << v41) & 0x83) != 0) {
      int v42 = 0;
    }
    else {
      int v42 = 4;
    }
    if (v41 > 7)
    {
      int v42 = 4;
      goto LABEL_70;
    }
    if (((1 << v41) & 0x83) != 0) {
      goto LABEL_57;
    }
LABEL_70:
    if (v42 != 4) {
      goto LABEL_77;
    }
LABEL_12:
    if (++v13 == 5) {
      return 0xFFFFFFFFLL;
    }
  }
  int v40 = 0;
LABEL_57:
  if ((a6 & 0x80000000) == 0)
  {
    if (result <= a6) {
      unsigned int v43 = a6;
    }
    else {
      unsigned int v43 = v50;
    }
    int v44 = v43 - result;
    unsigned int v45 = (v43 - result) & 7;
    if (v44 <= 0) {
      unsigned int v46 = -(-v44 & 7);
    }
    else {
      unsigned int v46 = v45;
    }
    if (((1 << v46) & 0x83) != 0) {
      int v42 = 0;
    }
    else {
      int v42 = 4;
    }
    if (v46 <= 7)
    {
      if (((1 << v46) & 0x83) != 0) {
        goto LABEL_73;
      }
    }
    else
    {
      int v42 = 4;
    }
    goto LABEL_70;
  }
  int v44 = 0;
LABEL_73:
  if ((v49 & 0x80000000) == 0)
  {
    int v47 = v40 - v44;
    if (v47 < 0) {
      int v47 = -v47;
    }
    if (v47 > 2) {
      goto LABEL_12;
    }
  }
LABEL_77:
  *float v33 = v19;
  if (v34) {
    *float v34 = v29;
  }
  if (v52) {
    *float v52 = 1.0 - v38;
  }
  return result;
}

uint64_t sub_1DC3BC1E8(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v216 = *MEMORY[0x1E4F143B8];
  pthread_once(&stru_1EAA94B50, (void (*)(void))sub_1DC3BE6BC);
  uint64_t v7 = 0;
  uint64_t v8 = *(void *)(a2 + 64);
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  long long v191 = xmmword_1DC410650;
  long long v192 = unk_1DC410660;
  long long v193 = xmmword_1DC410670;
  long long v187 = xmmword_1DC410610;
  long long v188 = unk_1DC410620;
  long long v189 = xmmword_1DC410630;
  long long v190 = unk_1DC410640;
  long long v183 = xmmword_1DC4105D0;
  long long v184 = unk_1DC4105E0;
  long long v185 = xmmword_1DC4105F0;
  long long v186 = unk_1DC410600;
  *((float *)&v193 + 3) = (float)(*(float *)(a2 + 72) + *(float *)(a2 + 76)) * 0.5;
  float v9 = *(float *)(a3 + 40);
  if (v9 < 0.0) {
    float v9 = v9 + 6.2832;
  }
  float v10 = flt_1DC3FDA00[v9 > 3.1416];
  if (!*(unsigned char *)(v8 + 28)) {
    float v10 = -0.0;
  }
  float v11 = v9 + v10;
  *(unsigned char *)(v8 + 28) = 0;
  float32x2_t v181 = 0;
  float32x2_t v182 = 0;
  float32x2_t v179 = 0;
  float32x2_t v180 = 0;
  float v12 = (float)*(int *)(a3 + 32);
  float v13 = (float)*(int *)(a3 + 36);
  float v14 = *(float *)(a3 + 44);
  signed int v204 = -1;
  float v170 = v14;
  float v15 = v14 * 0.5;
  while (1)
  {
    long long v201 = 0u;
    long long v202 = 0u;
    long long v199 = 0u;
    long long v200 = 0u;
    long long v198 = 0u;
    unsigned int v16 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
    uint64_t v203 = v16;
    *((void *)v16 + 8) = 0;
    *((_DWORD *)v16 + 18) = 0;
    *((void *)v16 + 10) = 0;
    *(_OWORD *)unsigned int v16 = 0u;
    *((_OWORD *)v16 + 1) = 0u;
    *((_OWORD *)v16 + 2) = 0u;
    int v17 = dword_1DC410680[v7];
    *(_OWORD *)(v16 + 44) = 0u;
    float v18 = v11 + (float)((float)((float)v17 * 3.1416) / 180.0);
    __float2 v19 = __sincosf_stret(v18);
    sub_1DC3BD0A8((uint64_t)a4, 0, v8, (uint64_t)&v198, (uint64_t)&v183, &v204, v12 - (float)(v15 * v19.__cosval), v13 - (float)(v15 * v19.__sinval), (float)(v15 * v19.__cosval) + v12, (float)(v15 * v19.__sinval) + v13);
    signed int v20 = v204;
    if ((v204 & 0x80000000) == 0 && *(float *)(v8 + 48) >= 0.0)
    {
      float v21 = *(float *)(v8 + 52);
      if (v21 >= 0.0) {
        break;
      }
    }
    sub_1DC3D5988((uint64_t)&v198);
LABEL_10:
    if (++v7 == 11)
    {
      uint64_t v29 = 20;
      goto LABEL_18;
    }
  }
  int v210 = *(_DWORD *)(v8 + 48);
  float v211 = v21;
  int v22 = sub_1DC3F02E0(*a4, a4[1], (float *)&v199 + 3, 2u, (float *)&v210, &v214, &v212);
  sub_1DC3D5988((uint64_t)&v198);
  if (!v22) {
    goto LABEL_10;
  }
  float v23 = *(float *)(v8 + 32);
  if (v23 <= 0.0)
  {
    float v24 = v214;
    float v25 = v212;
    float v26 = v170;
  }
  else
  {
    float v24 = v214;
    float v25 = v212;
    float v26 = v170;
    if (*(float *)(v8 + 36) > 0.0)
    {
      float v12 = (float)(v214 + v215) * 0.5;
      float v13 = (float)(v212 + v213) * 0.5;
      float v27 = sqrtf((float)((float)(v212 - v213) * (float)(v212 - v213))+ (float)((float)(v214 - v215) * (float)(v214 - v215)));
      float v28 = v27 + v27;
      if (v28 <= v170) {
        float v26 = v28;
      }
    }
  }
  v205[0] = v20;
  *(float *)uint64_t v209 = v24;
  *(float *)&v209[1] = v25;
  *(float *)char v208 = v215;
  *(float *)&v208[1] = v213;
  if (v23 >= 0.0)
  {
    if (*(float *)(v8 + 36) >= 0.0)
    {
      int v31 = 0;
      int v167 = 0;
    }
    else
    {
      int v167 = 0;
      v206[0] = 0;
      int v31 = 1;
    }
  }
  else
  {
    int v31 = 0;
    v207[0] = 0;
    int v167 = 1;
  }
  int v165 = v31;
  float v32 = *((float *)&v193 + 3) + *((float *)&v193 + 3);
  float v33 = v18 + -1.57079633;
  __float2 v34 = __sincosf_stret(v33);
  float v35 = v34.__cosval * v32;
  float v171 = v34.__sinval * v32;
  float v36 = v19.__cosval * (float)(v26 * 0.5);
  float v37 = v19.__sinval * (float)(v26 * 0.5);
  float v38 = (float)(v34.__cosval * v32) + v12;
  if (v38 >= 1.0)
  {
    unsigned int v46 = 0;
    int v47 = 0;
    int v39 = 1;
    float v48 = v13;
    while (1)
    {
      float v48 = v171 + v48;
      BOOL v49 = v38 > (float)(*a4 - 2) || v48 < 1.0;
      if (v49 || v48 > (float)(a4[1] - 2)) {
        goto LABEL_31;
      }
      long long v201 = 0u;
      long long v202 = 0u;
      long long v199 = 0u;
      long long v200 = 0u;
      long long v198 = 0u;
      unsigned int v50 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
      uint64_t v203 = v50;
      *((void *)v50 + 8) = 0;
      *((_DWORD *)v50 + 18) = 0;
      *((void *)v50 + 10) = 0;
      *(_OWORD *)unsigned int v50 = 0u;
      *((_OWORD *)v50 + 1) = 0u;
      *((_OWORD *)v50 + 2) = 0u;
      *(_OWORD *)(v50 + 44) = 0u;
      sub_1DC3BD0A8((uint64_t)a4, 0, v8, (uint64_t)&v198, (uint64_t)&v183, &v204, v38 - v36, v48 - v37, v36 + v38, v37 + v48);
      signed int v51 = v204;
      if ((v204 & 0x80000000) == 0) {
        break;
      }
      sub_1DC3D5988((uint64_t)&v198);
      if (v47 > 3) {
        goto LABEL_31;
      }
      ++v47;
LABEL_58:
      if (BYTE8(v193))
      {
        if ((float)((float)(int)v184 * 0.2) < (float)(v39 - 1) || v46 >= 9) {
          goto LABEL_31;
        }
      }
      else if (v46 > 8)
      {
        goto LABEL_31;
      }
      ++v46;
      float v38 = v35 + v38;
      if (v38 < 1.0) {
        goto LABEL_31;
      }
    }
    if (*(float *)(v8 + 48) < 0.0
      || (float v52 = *(float *)(v8 + 52), v52 < 0.0)
      || (int v210 = *(_DWORD *)(v8 + 48),
          float v211 = v52,
          !sub_1DC3F02E0(*a4, a4[1], (float *)&v199 + 3, 2u, (float *)&v210, &v214, &v212)))
    {
LABEL_57:
      sub_1DC3D5988((uint64_t)&v198);
      int v47 = 0;
      goto LABEL_58;
    }
    v205[v39] = v51;
    unsigned int v53 = (float *)&v209[2 * v39];
    float v54 = v215;
    float v55 = v212;
    float v56 = v213;
    *unsigned int v53 = v214;
    v53[1] = v55;
    BOOL v57 = (float *)&v208[2 * v39];
    *BOOL v57 = v54;
    v57[1] = v56;
    if (*(float *)(v8 + 32) >= 0.0)
    {
      if (*(float *)(v8 + 36) >= 0.0)
      {
LABEL_56:
        ++v39;
        goto LABEL_57;
      }
      int v58 = v165;
      char v59 = v206;
      ++v165;
    }
    else
    {
      int v58 = v167;
      char v59 = v207;
      ++v167;
    }
    v59[v58] = v39;
    goto LABEL_56;
  }
  int v39 = 1;
LABEL_31:
  float v40 = v12 - v35;
  if (v40 >= 1.0)
  {
    unsigned int v61 = 0;
    int v62 = 0;
    int v41 = v39;
    while (1)
    {
      float v13 = v13 - v171;
      BOOL v63 = v40 > (float)(*a4 - 2) || v13 < 1.0;
      if (v63 || v13 > (float)(a4[1] - 2)) {
        goto LABEL_33;
      }
      long long v201 = 0u;
      long long v202 = 0u;
      long long v199 = 0u;
      long long v200 = 0u;
      long long v198 = 0u;
      int v64 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
      uint64_t v203 = v64;
      *((void *)v64 + 8) = 0;
      *((_DWORD *)v64 + 18) = 0;
      *((void *)v64 + 10) = 0;
      *(_OWORD *)int v64 = 0u;
      *((_OWORD *)v64 + 1) = 0u;
      *((_OWORD *)v64 + 2) = 0u;
      *(_OWORD *)(v64 + 44) = 0u;
      sub_1DC3BD0A8((uint64_t)a4, 0, v8, (uint64_t)&v198, (uint64_t)&v183, &v204, v40 - v36, v13 - v37, v36 + v40, v37 + v13);
      signed int v65 = v204;
      if ((v204 & 0x80000000) == 0) {
        break;
      }
      sub_1DC3D5988((uint64_t)&v198);
      if (v62 > 3) {
        goto LABEL_33;
      }
      ++v62;
LABEL_87:
      if (BYTE8(v193))
      {
        if ((float)((float)(int)v184 * 0.2) < (float)(v41 - v39) || v61 >= 9) {
          goto LABEL_33;
        }
      }
      else if (v61 > 8)
      {
        goto LABEL_33;
      }
      ++v61;
      float v40 = v40 - v35;
      if (v40 < 1.0) {
        goto LABEL_33;
      }
    }
    if (*(float *)(v8 + 48) < 0.0
      || (float v66 = *(float *)(v8 + 52), v66 < 0.0)
      || (int v210 = *(_DWORD *)(v8 + 48),
          float v211 = v66,
          !sub_1DC3F02E0(*a4, a4[1], (float *)&v199 + 3, 2u, (float *)&v210, &v214, &v212)))
    {
LABEL_86:
      sub_1DC3D5988((uint64_t)&v198);
      int v62 = 0;
      goto LABEL_87;
    }
    v205[v41] = v65;
    float v67 = (float *)&v209[2 * v41];
    float v68 = v215;
    float v69 = v212;
    float v70 = v213;
    *float v67 = v214;
    v67[1] = v69;
    char v71 = (float *)&v208[2 * v41];
    *char v71 = v68;
    v71[1] = v70;
    if (*(float *)(v8 + 32) >= 0.0)
    {
      if (*(float *)(v8 + 36) >= 0.0)
      {
LABEL_85:
        ++v41;
        goto LABEL_86;
      }
      int v72 = v165;
      uint64_t v73 = v206;
      ++v165;
    }
    else
    {
      int v72 = v167;
      uint64_t v73 = v207;
      ++v167;
    }
    v73[v72] = v41;
    goto LABEL_85;
  }
  int v41 = v39;
LABEL_33:
  if (BYTE8(v193)) {
    BOOL v42 = v41 < 2;
  }
  else {
    BOOL v42 = 1;
  }
  int v43 = v165;
  if (v42) {
    goto LABEL_157;
  }
  int v44 = v167;
  if (v167 == v41) {
    goto LABEL_38;
  }
  if (v165 == v41)
  {
    char v45 = 1;
    goto LABEL_99;
  }
  if (v167 + v165 < 1)
  {
    char v45 = 0;
    int v43 = v41;
    goto LABEL_100;
  }
  if (v41 - (v167 + v165) < 2) {
    goto LABEL_157;
  }
  uint64_t v100 = 0;
  int v101 = 0;
  int v102 = 0;
  int v44 = 0;
  do
  {
    if (v102 < v167 && v100 == v207[v102])
    {
      ++v102;
    }
    else if (v101 < v165 && v100 == v206[v101])
    {
      ++v101;
    }
    else
    {
      *(void *)&v209[2 * v44] = *(void *)&v209[2 * v100];
      *(void *)&v208[2 * v44] = *(void *)&v208[2 * v100];
      v205[v44++] = v205[v100];
    }
    ++v100;
  }
  while (v41 != v100);
LABEL_38:
  char v45 = 0;
  int v43 = v44;
LABEL_99:
  if (v43 < 1)
  {
LABEL_157:
    uint64_t v29 = 21;
  }
  else
  {
LABEL_100:
    uint64_t v75 = 0;
    unsigned int v76 = -1;
    int v77 = 0x7FFFFFFF;
    signed int v78 = 0x80000000;
    unsigned int v79 = -1;
    int v80 = v43;
    do
    {
      int v81 = v205[v75];
      if (v81 <= v77) {
        unsigned int v82 = v75;
      }
      else {
        unsigned int v82 = v79;
      }
      if (v81 >= v77) {
        int v83 = v77;
      }
      else {
        int v83 = v205[v75];
      }
      if (v81 >= v78) {
        unsigned int v84 = v75;
      }
      else {
        unsigned int v84 = v76;
      }
      if (v81 <= v78) {
        signed int v85 = v78;
      }
      else {
        signed int v85 = v205[v75];
      }
      BOOL v86 = SDWORD2(v183) <= v81 && v81 <= SHIDWORD(v183);
      if (v86) {
        unsigned int v79 = v82;
      }
      if (v86) {
        unsigned int v76 = v84;
      }
      if (v86) {
        int v77 = v83;
      }
      if (v86) {
        signed int v78 = v85;
      }
      ++v75;
    }
    while (v43 != v75);
    if ((v79 & 0x80000000) != 0) {
      goto LABEL_157;
    }
    if ((v76 & 0x80000000) != 0) {
      goto LABEL_157;
    }
    int v87 = v78 - v77;
    if (v78 == v77) {
      goto LABEL_157;
    }
    int v88 = v78 - DWORD2(v183);
    float v89 = (float)((float)v88 + 0.5) / (float)v87;
    float v90 = (float)(HIDWORD(v183) - v77) + 0.5;
    float v91 = v90 / (float)v87;
    float v92 = v89 <= v91 ? v90 / (float)v87 : (float)((float)v88 + 0.5) / (float)v87;
    int v93 = v184;
    sub_1DC3BD64C((uint64_t)v209, v43, v79, v76, (uint64_t)&v182, (uint64_t)&v181, (float)((float)v88 + 0.5) / (float)v87, v90 / (float)v87);
    sub_1DC3BD64C((uint64_t)v208, v80, v79, v76, (uint64_t)&v179, (uint64_t)&v180, v89, v91);
    if (v167 == v41)
    {
      *(float32x2_t *)v94.f32 = v182;
      float v95 = v179.f32[0];
      int32x2_t v96 = (int32x2_t)v180;
      *(float32x2_t *)v97.f32 = vsub_f32(v182, v179);
      *(float32x2_t *)&v97.u32[2] = vsub_f32(v181, v180);
      *(float32x2_t *)&v94.u32[2] = v181;
      int8x16_t v98 = (int8x16_t)vmlaq_n_f32(v94, v97, (float)(17 * v183 - 41) / 71.0);
      float v99 = v179.f32[1];
    }
    else
    {
      float v95 = v179.f32[0];
      v98.i32[0] = v182.i32[0];
      if (v45)
      {
        float v103 = 27.0 / (float)(17 * v183 + 3);
        float v95 = v179.f32[0] + (float)(v103 * (float)(v179.f32[0] - v182.f32[0]));
        float v99 = v179.f32[1] + (float)(v103 * (float)(v179.f32[1] - v182.f32[1]));
        float32x2_t v104 = v181;
        int32x2_t v96 = (int32x2_t)vmla_n_f32(v180, vsub_f32(v180, v181), v103);
      }
      else
      {
        float v99 = v179.f32[1];
        int32x2_t v96 = (int32x2_t)v180;
        float32x2_t v104 = v181;
      }
      v98.i32[1] = v182.i32[1];
      v98.u64[1] = (unint64_t)v104;
    }
    float32x2_t v105 = (float32x2_t)vdup_lane_s32(v96, 0);
    v105.f32[0] = v95;
    int32x2_t v106 = (int32x2_t)vextq_s8(v98, v98, 8uLL).u64[0];
    float32x2_t v107 = vsub_f32(v105, (float32x2_t)vzip1_s32(*(int32x2_t *)v98.i8, v106));
    float32x2_t v108 = vsub_f32((float32x2_t)__PAIR64__(v96.u32[1], LODWORD(v99)), (float32x2_t)vzip2_s32(*(int32x2_t *)v98.i8, v106));
    float32x2_t v109 = vmla_f32(vmul_f32(v108, v108), v107, v107);
    float32x2_t v110 = vsqrt_f32(v109);
    if ((float)(vabds_f32(v110.f32[0], v110.f32[1]) / vaddv_f32(v110)) > 0.2) {
      goto LABEL_157;
    }
    float v111 = *(float *)&v96.i32[1];
    float v112 = (float)((float)(*(float *)&v96.i32[1] - v99) * (float)(*(float *)&v96.i32[1] - v99))
         + (float)((float)(*(float *)v96.i32 - v95) * (float)(*(float *)v96.i32 - v95));
    float v113 = sqrtf(v112);
    float v114 = *(float *)&v98.i32[2];
    float v115 = *(float *)&v98.i32[1];
    float v116 = *(float *)&v98.i32[3];
    float v117 = (float)((float)(*(float *)&v98.i32[3] - *(float *)&v98.i32[1])
                 * (float)(*(float *)&v98.i32[3] - *(float *)&v98.i32[1]))
         + (float)((float)(*(float *)&v98.i32[2] - *(float *)v98.i32)
                 * (float)(*(float *)&v98.i32[2] - *(float *)v98.i32));
    float v118 = sqrtf(v117);
    if ((float)(vabds_f32(v118, v113) / (float)(v113 + v118)) > 0.2) {
      goto LABEL_157;
    }
    float32x4_t v168 = (float32x4_t)v98;
    float v169 = v95;
    float32x2_t v172 = (float32x2_t)v96;
    float32x2_t v164 = v109;
    float v166 = v99;
    if (sub_1DC3EFD04(&v197, &v196, &v195, &v194, *(float *)v98.i32, *(float *)&v98.i32[1], v95, v99, *(float *)&v98.i32[2], *(float *)&v98.i32[3], *(float *)v96.i32, *(float *)&v96.i32[1]) == 2)goto LABEL_157; {
    if (!sub_1DC3BD7BC((int *)&v183, a2))
    }
    {
      *(int32x4_t *)(a2 + 28) = vcvtq_s32_f32(vrndaq_f32(v168));
      *(int32x2_t *)(a2 + 44) = vcvt_s32_f32(vrnda_f32(v172));
      *(_DWORD *)(a2 + 52) = llroundf(v169);
      *(_DWORD *)(a2 + 56) = llroundf(v166);
      goto LABEL_183;
    }
    float v119 = v164.f32[1];
    if (v164.f32[0] > v164.f32[1]) {
      float v119 = v164.f32[0];
    }
    float v120 = sqrtf(v119);
    if (v117 <= v112) {
      float v121 = v112;
    }
    else {
      float v121 = v117;
    }
    float v122 = sqrtf(v121);
    float v123 = 4.0;
    if ((float)(3.0 / *((float *)&v193 + 3)) <= 4.0) {
      float v123 = 3.0 / *((float *)&v193 + 3);
    }
    if ((float)(3.0 / *((float *)&v193 + 3)) >= 0.5) {
      float v124 = v123;
    }
    else {
      float v124 = 0.5;
    }
    float v125 = *((float *)&v193 + 3) * v124;
    signed int v126 = (int)(float)(ceilf(v124 * v120) + 1.0);
    *((float *)&v193 + 3) = *((float *)&v193 + 3) * v124;
    signed int v127 = (int)(float)(ceilf(v124 * v122) + 1.0);
    memset(v176, 0, sizeof(v176));
    long long v177 = 0u;
    memset(v178, 0, sizeof(v178));
    sub_1DC3EE07C(v126, v127, (uint64_t)v176, v168.f32[0], v115, v114, v116, v172.f32[0], v111, v169, v166);
    signed int v173 = 0;
    int v129 = v127 - 1;
    if (v93 < 1)
    {
      int v131 = 0;
    }
    else
    {
      int v130 = 0;
      int v131 = 0;
      float v132 = (float)((float)(v92 * 0.5) / (float)v93) * (float)v127;
      float v133 = ceilf(v125) + 1.0;
      float v134 = (float)-(int)v133;
      float v135 = (float)(int)(v127 + 2 * vcvtps_s32_f32(v132));
      float v136 = -(float)(int)ceilf(v132);
      float v137 = (float)(v126 + (int)v133);
      if (2 * v93 <= 1) {
        int v138 = 1;
      }
      else {
        int v138 = 2 * v93;
      }
      do
      {
        float v139 = v136 + (float)((float)((float)v130 / (float)(2 * v93 - 1)) * v135);
        memset(v174, 0, sizeof(v174));
        long long v140 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
        BOOL v175 = v140;
        *((void *)v140 + 8) = 0;
        *((_DWORD *)v140 + 18) = 0;
        *((void *)v140 + 10) = 0;
        *(_OWORD *)long long v140 = 0u;
        *((_OWORD *)v140 + 1) = 0u;
        *((_OWORD *)v140 + 2) = 0u;
        *(_OWORD *)(v140 + 44) = 0u;
        sub_1DC3BD0A8((uint64_t)a4, (float *)v176, 0, (uint64_t)v174, (uint64_t)&v183, &v173, v134, v139, v137, v139);
        sub_1DC3D5988((uint64_t)v174);
        if ((v173 & 0x80000000) == 0)
        {
          if (v139 < (float)v131) {
            int v131 = (int)v139;
          }
          if (v139 > (float)v129) {
            int v129 = (int)v139;
          }
        }
        ++v130;
      }
      while (v138 != v130);
    }
    v142.i32[0] = HIDWORD(v177);
    LODWORD(v141) = DWORD2(v177);
    float v143 = *((float *)&v177 + 3) * (float)v131;
    *(float *)&uint64_t v144 = v178[0];
    float v145 = v178[1];
    __int32 v146 = LODWORD(v178[2]);
    float v147 = v178[3];
    float v148 = v178[2] * (float)v131;
    float v149 = v178[4];
    float v150 = v178[5] * (float)v131;
    *(float *)v128.i32 = v178[6];
    float v151 = v178[6] + (float)(v150 + (float)(v178[4] * 0.0));
    float v152 = (float)(v178[0] + (float)(v143 + (float)(*((float *)&v177 + 2) * 0.0))) / v151;
    float v153 = v178[6] + (float)(v150 + (float)(v178[4] * (float)v126));
    float v154 = (float)(v178[0] + (float)(v143 + (float)(*((float *)&v177 + 2) * (float)v126))) / v153;
    float v155 = (float)(v178[3] + (float)(v148 + (float)(v178[1] * (float)v126))) / v153;
    unsigned int v156 = llroundf((float)(v178[3] + (float)(v148 + (float)(v178[1] * 0.0))) / v151);
    *(float *)&unsigned int v157 = v178[5] * (float)v129;
    *(_DWORD *)(a2 + 28) = llroundf(v152);
    *(_DWORD *)(a2 + 32) = v156;
    v142.i32[1] = v146;
    *(float32x2_t *)v158.f32 = vmul_n_f32(v142, (float)v129);
    v158.i64[1] = v158.i64[0];
    *((float *)&v141 + 1) = v145;
    v159.i64[0] = 0;
    v159.f32[2] = (float)v126;
    v159.f32[3] = (float)v126;
    *((float *)&v144 + 1) = v147;
    float32x4_t v160 = vmlaq_f32(v158, v159, (float32x4_t)vdupq_lane_s64(v141, 0));
    int32x4_t v161 = (int32x4_t)vdupq_lane_s64(v144, 0);
    v159.f32[1] = (float)v126;
    float32x4_t v162 = vaddq_f32((float32x4_t)v161, v160);
    *(float32x2_t *)v161.i8 = vadd_f32((float32x2_t)vdup_lane_s32(v128, 0), vmla_n_f32((float32x2_t)vdup_lane_s32((int32x2_t)v157, 0), *(float32x2_t *)v159.f32, v149));
    *(int32x4_t *)(a2 + 36) = vcvtq_s32_f32(vrndaq_f32(vdivq_f32(v162, (float32x4_t)vzip1q_s32(v161, v161))));
    *(_DWORD *)(a2 + 52) = llroundf(v154);
    *(_DWORD *)(a2 + 56) = llroundf(v155);
    uint64_t v29 = sub_1DC3BD7BC((int *)&v183, a2);
    if (!v29)
    {
LABEL_183:
      if (DWORD1(v183) == 32)
      {
        uint64_t v29 = 0;
        int v163 = 1;
        goto LABEL_187;
      }
      if (**((_WORD **)&v192 + 1) == 920)
      {
        uint64_t v29 = 0;
        int v163 = 2;
LABEL_187:
        *(_DWORD *)(a2 + 4) = v163;
      }
      else
      {
        uint64_t v29 = 0;
      }
    }
  }
LABEL_18:
  if (*((void *)&v192 + 1)) {
    free(*((void **)&v192 + 1));
  }
  if ((void)v193) {
    free((void *)v193);
  }
  return v29;
}

void sub_1DC3BD0A8(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, signed int *a6, float a7, float a8, float a9, float a10)
{
  float v15 = *(uint64_t **)(a4 + 80);
  *a6 = -1;
  if (!sub_1DC3ED600(a1, a2, (void *)a4, a7, a8, a9, a10))
  {
    long long v74 = 0u;
    long long v75 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    int v16 = sub_1DC3A0718((uint64_t)&v72, *(float **)a4, *(_DWORD *)(a4 + 8), 0.5);
    if (!v16)
    {
LABEL_20:
      sub_1DC3A0B9C((uint64_t)&v72);
      return;
    }
    int v17 = v16;
    uint64_t v62 = a3;
    uint64_t v63 = (uint64_t)(v15 + 9);
    unsigned int v61 = a6;
    if (a2)
    {
      int v18 = *(int *)a5 <= 2 ? 6 : 9;
      int v19 = v18 + 4 * *(_DWORD *)a5 + 4;
    }
    else
    {
      int v19 = 42;
    }
    int v64 = v15 + 7;
    uint64_t v71 = 0;
    int v20 = 2 * v19;
    int v65 = -1;
    int v66 = -1;
    int v67 = -1;
    unsigned int v68 = -1;
    unsigned int v21 = 1;
    int v69 = -1;
    int v70 = -1;
    while (1)
    {
      if (v17 >= 22 && v17 <= v20)
      {
        int v22 = (float *)(*(void *)a4 + 4 * (int)(float)(*(float *)v73 + -0.5));
        LODWORD(v22) = *v22 <= v22[1];
        sub_1DC3DAAE8((int *)(v73 + 4 * v22), (v17 - v22) & 0xFFFFFFFE, (uint64_t)v64, v63);
        int v23 = *(unsigned __int8 *)(a5 + 168);
        if (sub_1DC3BB7E4(v15[7], v15[8], v15[9], v15[10], v23, &v70, &v69, &v68, &v67, &v66, &v65, (float *)&v71 + 1, (float *)&v71)|| v23 && ((v70 & 0x80000000) == 0 || (v68 & 0x80000000) == 0 || (v69 & 0x80000000) == 0))
        {
          break;
        }
      }
      if (v21 <= 2) {
        int v17 = sub_1DC3A0948((uint64_t)&v72, *(float *)(a5 + 172));
      }
      if (++v21 == 4) {
        goto LABEL_20;
      }
    }
    sub_1DC3A0B9C((uint64_t)&v72);
    v24.i32[0] = *(_DWORD *)(a5 + 172);
    if (*(float *)v24.i32 >= 0.75
      && vabds_f32(*((float *)&v71 + 1), *(float *)v24.i32) <= (float)(*(float *)v24.i32 * 0.25))
    {
      *(float *)v24.i32 = (float)(*(float *)v24.i32 + *((float *)&v71 + 1)) * 0.5;
      *(_DWORD *)(a5 + 172) = v24.i32[0];
      float v25 = *(float *)v24.i32 * 17.0;
      if (!*(unsigned char *)(a5 + 168))
      {
        *(float *)v24.i32 = *(float *)v24.i32 * 17.0;
        int v35 = sub_1DC3BD9DC((uint64_t)v64, v63, &v70, &v69, (int *)&v68, &v67, &v66, &v65, v24, (_WORD *)a5);
        *a6 = v35;
        if (v35 < 0) {
          return;
        }
        sub_1DC3BE070((int *)a5);
        if (!*(unsigned char *)(a5 + 168))
        {
LABEL_86:
          if (v62)
          {
            __asm { FMOV            V0.2S, #-1.0 }
            *(void *)(v62 + 48) = _D0;
            int v55 = v70;
            unsigned int v56 = v69;
            float v57 = (float)((v69 >> 31) | 1);
            *(float *)(v62 + 32) = (float)((v70 >> 31) | 1);
            *(float *)(v62 + 36) = v57;
            if ((v55 & 0x80000000) == 0 && (v56 & 0x80000000) == 0)
            {
              int v58 = *(_DWORD *)(v15[8] + 4 * v67);
LABEL_97:
              *(_DWORD *)(v62 + 48) = v58;
              int v60 = *(_DWORD *)(v15[10] + 4 * v66);
LABEL_98:
              *(_DWORD *)(v62 + 52) = v60;
              return;
            }
            if ((v68 & 0x80000000) == 0 && (v56 & 0x80000000) == 0)
            {
              unsigned int v59 = v56 + 52;
              if (v56 >= v68) {
                unsigned int v59 = v56;
              }
              if (v59 - v68 == 32) {
                *(_DWORD *)(v62 + 32) = 1065353216;
              }
              int v58 = *(_DWORD *)(v15[8] + 4 * v65 - 16);
              goto LABEL_97;
            }
            if (((v68 | v55) & 0x80000000) == 0)
            {
              *(_DWORD *)(v62 + 48) = *(_DWORD *)(v15[8] + 4 * v67);
              int v60 = *(_DWORD *)(v15[10] + 4 * v65 + 28);
              goto LABEL_98;
            }
          }
          return;
        }
      }
      unsigned int v26 = v70;
      if ((v70 & 0x80000000) == 0)
      {
        if (v70 >= *(_DWORD *)(a5 + 8))
        {
          signed int v27 = v70;
          if (v70 <= *(_DWORD *)(a5 + 12))
          {
LABEL_30:
            unsigned int v28 = v69;
            int v29 = *(_DWORD *)a5;
            if ((v69 & 0x80000000) == 0)
            {
              int v30 = *(_DWORD *)(a5 + 4);
              int v31 = v69 - v30 - 52;
              if (v69 - v30 <= 51) {
                int v31 = v69 - v30;
              }
              if (v69 - v30 >= 0) {
                signed int v32 = v31;
              }
              else {
                signed int v32 = v69 - v30 + 52;
              }
              if (v29 >= 3)
              {
                if (v32 < 0)
                {
                  signed int v32 = -1;
                }
                else
                {
                  int v33 = v32 - v30;
                  signed int v34 = v33 - 52;
                  if (v33 <= 51) {
                    signed int v34 = v33;
                  }
                  if (v33 >= 0) {
                    signed int v32 = v34;
                  }
                  else {
                    signed int v32 = v33 + 52;
                  }
                }
              }
              if (v32 >= *(_DWORD *)(a5 + 8) && v32 <= *(_DWORD *)(a5 + 12)) {
                goto LABEL_51;
              }
              unsigned int v28 = -1;
              int v69 = -1;
            }
            signed int v32 = -1;
LABEL_51:
            int v36 = v68;
            _VF = __OFSUB__(v29, 3);
            if (v29 < 3)
            {
LABEL_72:
              signed int v40 = -1;
LABEL_73:
              if (((v26 & v28 & 0x80000000) != 0) != _VF && v36 < 0) {
                return;
              }
              uint64_t v46 = v15[8];
              uint64_t v47 = v15[10];
              if ((v27 & 0x80000000) == 0) {
                sub_1DC3BE358((float *)(v46 + 4 * v67 + 12), (float *)(v47 + 4 * v67 + 12), v27, 0, a5, v25);
              }
              if ((v40 & 0x80000000) == 0)
              {
                uint64_t v48 = v46 + 4 * v65;
                uint64_t v49 = v47 + 4 * v65;
                sub_1DC3BE358((float *)(v48 - 16), (float *)(v49 - 16), v40, *(_DWORD *)a5 - 3, a5, v25);
                sub_1DC3BE358((float *)(v48 + 12), (float *)(v49 + 12), v40, *(_DWORD *)a5 - 2, a5, v25);
              }
              if ((v32 & 0x80000000) == 0)
              {
                sub_1DC3BE358((float *)(v46 + 4 * v66 - 28), (float *)(v47 + 4 * v66 - 28), v32, *(_DWORD *)a5 - 1, a5, v25);
                signed int v40 = v32;
              }
              if (v27 < 0) {
                signed int v50 = v40;
              }
              else {
                signed int v50 = v27;
              }
              signed int *v61 = v50;
              goto LABEL_86;
            }
            if ((v68 & 0x80000000) == 0) {
              goto LABEL_53;
            }
            if (v32 < 0) {
              int v43 = *v64 - 4;
            }
            else {
              int v43 = v66 - 14;
            }
            if ((v32 | v27) < 0)
            {
              BOOL v45 = 0;
            }
            else
            {
              unsigned int v44 = v27 - v32;
              if (v27 - v32 < 0) {
                unsigned int v44 = v32 - v27;
              }
              BOOL v45 = v44 < 3;
            }
            int v36 = sub_1DC3BBE58((uint64_t)v64, v63, v43, v45, v26, v28, &v65, (float *)&v71 + 1, 0);
            unsigned int v68 = v36;
            _VF = 0;
            if (*((float *)&v71 + 1) < 0.75
              || (_VF = 0, vabds_f32(*((float *)&v71 + 1), *(float *)(a5 + 172)) > (float)(*(float *)(a5 + 172) * 0.25)))
            {
LABEL_71:
              int v36 = -1;
              unsigned int v68 = -1;
              goto LABEL_72;
            }
            if (v36 < 0)
            {
              signed int v40 = -1;
            }
            else
            {
LABEL_53:
              int v38 = v36 - *(_DWORD *)(a5 + 4);
              signed int v39 = v38 - 52;
              if (v38 <= 51) {
                signed int v39 = v36 - *(_DWORD *)(a5 + 4);
              }
              if (v38 >= 0) {
                signed int v40 = v39;
              }
              else {
                signed int v40 = v38 + 52;
              }
            }
            signed int v41 = *(_DWORD *)(a5 + 8);
            _VF = __OFSUB__(v41, v40);
            if (v41 <= v40)
            {
              signed int v42 = *(_DWORD *)(a5 + 12);
              _VF = __OFSUB__(v40, v42);
              if (v40 <= v42) {
                goto LABEL_73;
              }
            }
            goto LABEL_71;
          }
        }
        unsigned int v26 = -1;
        int v70 = -1;
      }
      signed int v27 = -1;
      goto LABEL_30;
    }
  }
}

uint64_t sub_1DC3BD64C(uint64_t result, int a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, float a7, float a8)
{
  float v8 = 0.0;
  float v9 = 0.0;
  float v10 = 0.0;
  if (a2 >= 2)
  {
    uint64_t v11 = a2;
    float v12 = (float *)(result + 4);
    float v13 = 0.0;
    float v14 = 0.0;
    do
    {
      float v15 = *(v12 - 1);
      float v14 = v14 + v15;
      float v13 = v13 + *v12;
      float v8 = v8 + (float)(v15 * *v12);
      float v10 = v10 + (float)(v15 * v15);
      float v9 = v9 + (float)(*v12 * *v12);
      v12 += 2;
      --v11;
    }
    while (v11);
    float v16 = v14 / (float)a2;
    float v17 = v13 / (float)a2;
    float v18 = -(float)((float)(v8 / (float)a2) + (float)((float)-v16 * v17));
    float v19 = (float)(v10 / (float)a2) - (float)(v16 * v16);
    float v20 = (float)(v9 / (float)a2) - (float)(v17 * v17);
    float v21 = fabsf(v19);
    float v22 = fabsf(v20);
    BOOL v23 = v21 < v22;
    if (v21 >= v22) {
      float v8 = v18;
    }
    else {
      float v8 = v20;
    }
    if (v23) {
      float v9 = v18;
    }
    else {
      float v9 = v19;
    }
    float v10 = -(float)((float)(v17 * v9) + (float)(v8 * v16));
  }
  int32x4_t v24 = (float *)(result + 8 * a3);
  float v25 = (float *)(result + 8 * a4);
  if (fabsf(v8) <= 0.1)
  {
    float v34 = *v24 - *v25;
    float v35 = *v25 + (float)(a7 * v34);
    *(_DWORD *)(a5 + 4) = *(_DWORD *)(result + 8 * a3 + 4);
    *(_DWORD *)(a6 + 4) = *(_DWORD *)(result + 8 * a4 + 4);
    *(float *)a5 = v35;
    float v33 = *v24 - (float)(a8 * v34);
  }
  else
  {
    float v26 = v8 * v8;
    float v27 = 1.0 / v8;
    float v28 = 1.0 / (float)((float)(v8 * v8) + (float)(v9 * v9));
    float v29 = -(float)(v8 * v9);
    float v30 = v28
        * (float)((float)((float)(v29 * *v24) + (float)(v26 * *(float *)(result + 8 * a3 + 4))) - (float)(v9 * v10));
    float v31 = v28
        * (float)((float)((float)(v29 * *v25) + (float)(v26 * *(float *)(result + 8 * a4 + 4))) - (float)(v9 * v10));
    *(float *)(a5 + 4) = v31 + (float)(a7 * (float)(v30 - v31));
    float v32 = v30 - (float)(a8 * (float)(v30 - v31));
    *(float *)(a6 + 4) = v32;
    *(float *)a5 = v27 * (float)-(float)(v10 + (float)(v9 * *(float *)(a5 + 4)));
    float v33 = v27 * (float)-(float)(v10 + (float)(v9 * v32));
  }
  *(float *)a6 = v33;
  return result;
}

uint64_t sub_1DC3BD7BC(int *a1, uint64_t a2)
{
  unsigned int v2 = a1[5];
  size_t v3 = *a1 * (uint64_t)a1[4];
  if ((int)v3 - a1[6] > (int)(v2 - 2)) {
    return 6;
  }
  signed int v7 = v3 - v2;
  *(void *)(a2 + 8) = 2 * (int)(v3 - v2);
  float v8 = *(void **)(a2 + 16);
  if (v8)
  {
    free(v8);
    *(void *)(a2 + 16) = 0;
  }
  float v9 = malloc_type_calloc(v3, 2uLL, 0x1000040BDFB0063uLL);
  float v10 = (unsigned int *)malloc_type_calloc(v3, 4uLL, 0x100004052888210uLL);
  uint64_t v11 = v10;
  float v12 = (char *)*((void *)a1 + 19);
  if (v12)
  {
    if (v9 && v10 != 0)
    {
      int v14 = a1[4];
      if (v14 < 1)
      {
        signed int v17 = 0;
      }
      else
      {
        int v15 = 0;
        int v16 = 0;
        signed int v17 = 0;
        int v18 = *a1;
        do
        {
          if (v18 >= 1)
          {
            uint64_t v19 = 0;
            int v20 = v16;
            int v21 = v16;
            uint64_t v22 = *((void *)a1 + 20) + 2 * v16;
            do
            {
              if (!*(_WORD *)(v22 + 2 * v19))
              {
                v10[v17++] = v21 + v19;
                int v18 = *a1;
              }
              ++v19;
            }
            while ((int)v19 < v18);
            int v16 = v20 + v19;
            int v14 = a1[4];
          }
          ++v15;
        }
        while (v15 < v14);
      }
      int v26 = 0;
      if (sub_1DC3C6864(qword_1EAA94E30, v12, v7, &v12[2 * v7], v2, v10, v17, &v26, v9, &v9[v7]))
      {
LABEL_26:
        free(v9);
        *(void *)(a2 + 8) = 0;
        uint64_t v4 = 5;
        if (!v11) {
          return v4;
        }
LABEL_27:
        free(v11);
        return v4;
      }
      int v24 = v17 + 2 * (v26 - v17);
      if (v26 - v17 > 3)
      {
        if (v24 > (int)(v2 - 2)) {
          goto LABEL_26;
        }
      }
      else if (v24 > (int)(v2 - 3))
      {
        goto LABEL_26;
      }
      uint64_t v4 = 0;
      *(_DWORD *)(a2 + 24) = 1065353216;
      *(void *)(a2 + 16) = v9;
      int v25 = *a1;
      *(_DWORD *)(a2 + 80) = a1[4];
      *(_DWORD *)(a2 + 84) = v25;
      if (!v11) {
        return v4;
      }
      goto LABEL_27;
    }
  }
  if (v9) {
    free(v9);
  }
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v4 = 15;
  if (v11) {
    goto LABEL_27;
  }
  return v4;
}

uint64_t sub_1DC3BD9DC(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4, int *a5, int *a6, int *a7, _DWORD *a8, int32x4_t a9, _WORD *a10)
{
  float v10 = *(float *)a9.i32;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = *a3;
  if ((v19 & 0x80000000) != 0)
  {
LABEL_27:
    if ((*a4 & 0x80000000) == 0 && (*a5 & 0x80000000) == 0)
    {
      *a3 = -1;
      int v33 = *a5;
      int v34 = *a4;
      if (*a4 < *a5) {
        int v34 = *a4 + 52;
      }
      int v35 = v34 - v33;
      if ((*a4 | *a5) < 0) {
        int v35 = -1;
      }
      if (v35 == 32)
      {
        if (v33 <= 0x53) {
          int v36 = -32;
        }
        else {
          int v36 = -84;
        }
        if (v33 < 0x20) {
          int v36 = 20;
        }
        unsigned int v37 = v36 + v33;
        if (v33 >= 0) {
          uint64_t v19 = v37;
        }
        else {
          uint64_t v19 = 0xFFFFFFFFLL;
        }
        ++a10[16];
        ++a10[23];
LABEL_43:
        int v38 = &a10[(int)v19];
LABEL_44:
        ++v38[24];
        return v19;
      }
      if ((v35 & 7) == 0
        && v35 <= 31
        && fabsf((float)((float)(*(float *)(*(void *)(a1 + 8) + 4 * *a7 - 12)- *(float *)(*(void *)(a1 + 8) + 4 * (int)*a8 + 12))/ v10)+ -2.0) <= 0.5)
      {
        int v60 = v33 - v35 - 52;
        if (v33 - v35 <= 51) {
          int v60 = v33 - v35;
        }
        if (v33 - v35 >= 0) {
          unsigned int v61 = v60;
        }
        else {
          unsigned int v61 = v33 - v35 + 52;
        }
        if (v33 >= 0) {
          uint64_t v19 = v61;
        }
        else {
          uint64_t v19 = 0xFFFFFFFFLL;
        }
        ++a10[18];
        ++a10[v35 / 8 + 19];
        goto LABEL_43;
      }
    }
    if ((*a3 & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
    goto LABEL_47;
  }
  unsigned int v20 = *a4;
  if (*a4 < 0)
  {
LABEL_47:
    uint64_t v19 = 0xFFFFFFFFLL;
    if (*a5 < 0) {
      return v19;
    }
    *a4 = -1;
    uint64_t v39 = *a3;
    int v40 = *a5;
    if (*a5 < (int)v39) {
      int v40 = *a5 + 52;
    }
    int v41 = v40 - v39;
    if ((int)(*a5 | v39) < 0) {
      int v41 = -1;
    }
    if (v41 == 32)
    {
      ++a10[17];
      ++a10[23];
LABEL_54:
      ++a10[(int)v39 + 24];
      return v39;
    }
    if ((v41 & 7) == 0)
    {
      uint64_t v19 = 0xFFFFFFFFLL;
      if (v41 > 31) {
        return v19;
      }
      float v56 = (float)(*(float *)(*(void *)(a2 + 8) + 4 * (int)*a8) - *(float *)(*(void *)(a1 + 8) + 4 * *a6 + 12))
          / v10;
      if (v56 < 0.5 || v56 > 2.5) {
        return v19;
      }
      int v58 = v41 / 8;
      uint64_t v59 = 3;
      if (fabsf(v56 + -1.0) < fabsf(v56 + -2.0)) {
        uint64_t v59 = 2;
      }
      ++a10[v59 + 14];
      ++a10[v58 + 19];
      goto LABEL_54;
    }
    return 0xFFFFFFFFLL;
  }
  int v21 = *a7;
  float v22 = *(float *)(*(void *)(a1 + 8) + 4 * (*a7 - 3)) - *(float *)(*(void *)(a1 + 8) + 4 * *a6 + 12);
  if (v19 <= 0x13) {
    int v23 = 32;
  }
  else {
    int v23 = -20;
  }
  int v24 = v23 + v19;
  if (v24 >= 0)
  {
    int v25 = v24 <= 0x13 ? 32 : -20;
    if (v20 == v25 + v24)
    {
      *(float *)a9.i32 = v22 / v10;
      if (*(float *)a9.i32 >= 0.5 && *(float *)a9.i32 <= 5.0882)
      {
        uint64_t v26 = 0;
        *(float *)&a9.i32[1] = *(float *)a9.i32 + -0.58824;
        float32x4_t v66 = vabsq_f32(vaddq_f32((float32x4_t)vzip1q_s32(a9, a9), (float32x4_t)xmmword_1DC3FDDA0));
        int v27 = -1;
        float v28 = 0.5;
        do
        {
          if (v66.f32[v26] < v28)
          {
            int v27 = v26;
            float v28 = v66.f32[v26];
          }
          ++v26;
        }
        while (v26 != 4);
        if (v27 == 3)
        {
          int v29 = sub_1DC3BBE58(a1, a2, v21 - 14, 1, v19, v20, a8, 0, 0);
          *a5 = v29;
          uint64_t v19 = *a3;
          int v30 = v29 + 52;
          if (v29 >= (int)v19) {
            int v30 = v29;
          }
          if (((v19 | v29) & 0x80000000) == 0 && v30 - v19 == 32)
          {
            a10[17] += 2;
            a10[23] += 2;
            a10[(int)v19 + 24] += 2;
            return v19;
          }
        }
      }
      goto LABEL_26;
    }
  }
  unsigned int v31 = v20 + 52;
  if (v20 >= v19) {
    unsigned int v31 = *a4;
  }
  int v32 = v31 - v19;
  if ((v32 & 7) != 0) {
    goto LABEL_26;
  }
  *(float *)a9.i32 = v22 / v10;
  if (*(float *)a9.i32 < 0.5 || *(float *)a9.i32 > 5.0882) {
    goto LABEL_26;
  }
  uint64_t v43 = 0;
  *(float *)&a9.i32[1] = *(float *)a9.i32 + -0.58824;
  float32x4_t v66 = vabsq_f32(vaddq_f32((float32x4_t)vzip1q_s32(a9, a9), (float32x4_t)xmmword_1DC3FDDA0));
  unsigned int v44 = -1;
  float v45 = 0.5;
  do
  {
    if (v66.f32[v43] < v45)
    {
      unsigned int v44 = v43;
      float v45 = v66.f32[v43];
    }
    ++v43;
  }
  while (v43 != 4);
  if ((v44 & 0x80000000) != 0) {
    goto LABEL_26;
  }
  if (v44 < 2)
  {
    if (v32 < 16 || (v32 & 0xFFFFFFF8) == 0x20)
    {
      ++a10[v44 + 14];
      ++a10[v32 / 8 + 19];
      int v38 = &a10[(int)v19];
      goto LABEL_44;
    }
    return 0xFFFFFFFFLL;
  }
  int v46 = sub_1DC3BBE58(a1, a2, v21 - 14, 1, v19, v20, a8, 0, 0);
  *a5 = v46;
  uint64_t v47 = *a3;
  if (v46 < 0)
  {
    int v62 = *a4;
    if (*a4 < (int)v47) {
      int v62 = *a4 + 52;
    }
    BOOL v63 = __OFSUB__(v62, v47);
    int v64 = v62 - v47;
    if (v64 < 0 != v63) {
      ++v64;
    }
    int v65 = v64 >> 1;
    if ((int)(*a4 | v47) >= 0) {
      int v50 = v65;
    }
    else {
      int v50 = 0;
    }
    if ((v50 & 7) == 0)
    {
      uint64_t v53 = (uint64_t)a10;
      int v54 = v44;
      __int16 v55 = 1;
      goto LABEL_110;
    }
LABEL_26:
    *a5 = sub_1DC3BBE58(a1, a2, 4, 0, 0xFFFFFFFF, 0xFFFFFFFF, a8, 0, 0);
    goto LABEL_27;
  }
  int v48 = v46 + 52;
  if (v46 >= (int)v47) {
    int v48 = v46;
  }
  int v49 = v48 - v47;
  if ((int)(v47 | v46) < 0) {
    int v50 = -1;
  }
  else {
    int v50 = v49;
  }
  int v51 = *a4;
  if (*a4 < v46) {
    int v51 = *a4 + 52;
  }
  int v52 = v51 - v46;
  if ((*a4 | v46) < 0) {
    int v52 = -1;
  }
  if (v50 != v52 || (v50 & 7) != 0) {
    goto LABEL_26;
  }
  uint64_t v53 = (uint64_t)a10;
  int v54 = v44;
  __int16 v55 = 2;
LABEL_110:
  return sub_1DC3BE648(v53, v54, v50, v47, v55);
}

uint64_t sub_1DC3BE070(int *a1)
{
  v34[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (uint64_t)(a1 + 7);
  __int16 v3 = *((_WORD *)a1 + 18);
  if (!v3) {
    goto LABEL_7;
  }
  unsigned int v4 = *((unsigned __int16 *)a1 + 16);
  unsigned int v5 = *((unsigned __int16 *)a1 + 17);
  if (v4 <= v5)
  {
    if (v5 <= v4) {
      goto LABEL_7;
    }
    *((_WORD *)a1 + 17) = v5 + v3;
  }
  else
  {
    *((_WORD *)a1 + 16) = v4 + v3;
  }
  *((_WORD *)a1 + 18) = 0;
LABEL_7:
  uint64_t v33 = 0;
  uint64_t result = sub_1DC3BE5CC(v2, 4, (int *)&v33 + 1);
  if (result)
  {
    uint64_t result = sub_1DC3BE5CC((uint64_t)a1 + 38, 5, (int *)&v33);
    if (result)
    {
      int v7 = HIDWORD(v33);
      uint64_t v8 = (int)v33;
      int v9 = HIDWORD(v33) + 1;
      int v10 = 8 * v33;
      *a1 = HIDWORD(v33) + 1;
      a1[1] = v10;
      if (v8 == 4)
      {
        if (!v7) {
          return result;
        }
        uint64_t v11 = (char *)&unk_1DC4106AC + 56 * v7 - 56;
        uint64_t v12 = 7;
      }
      else if (v7 || (int)v8 > 1)
      {
        if (v9 == 2 && (int)v8 <= 1)
        {
          uint64_t v11 = (char *)&unk_1DC410784 + 32 * v8;
          uint64_t v12 = 4;
        }
        else
        {
          if ((v7 & 0xFFFFFFFE) != 2) {
            return result;
          }
          uint64_t v11 = (char *)&unk_1DC4107C4 + 40 * (int)v8;
          uint64_t v12 = 5;
        }
      }
      else
      {
        uint64_t v11 = (char *)&unk_1DC410754 + 24 * (int)v8;
        uint64_t v12 = 3;
      }
      uint64_t v13 = 0;
      memset(v34, 0, 14);
      do
      {
        int v14 = &v11[8 * v13];
        uint64_t v15 = *(unsigned int *)v14;
        if ((v15 & 0x80000000) == 0)
        {
          int v16 = *((_DWORD *)v14 + 1);
          if ((v16 & 0x80000000) == 0 && (int)v15 <= v16)
          {
            __int16 v17 = *((_WORD *)v34 + v13);
            int v18 = v16 - v15 + 1;
            uint64_t v19 = (__int16 *)a1 + v15 + 24;
            do
            {
              __int16 v20 = *v19++;
              v17 += v20;
              --v18;
            }
            while (v18);
            *((_WORD *)v34 + v13) = v17;
          }
        }
        ++v13;
      }
      while (v13 != v12);
      int v32 = 0;
      uint64_t result = sub_1DC3BE5CC((uint64_t)v34, 7, &v32);
      if (result)
      {
        int v21 = 0;
        int v22 = v32;
        int v23 = *(_DWORD *)&v11[8 * v32];
        a1[2] = v23;
        int v24 = *(_DWORD *)&v11[4 * ((2 * v22) | 1)];
        int v25 = v24 - v23 + 1;
        a1[3] = v24;
        a1[4] = v25;
        uint64_t v26 = &unk_1DC4108A8;
        if (v8 == 4)
        {
          uint64_t v26 = &unk_1DC410864;
          int v27 = 16;
        }
        else
        {
          int v27 = 33;
        }
        unsigned int v28 = v25 + 100 * v9;
        do
        {
          int v29 = v21 + ((v27 - v21) >> 1);
          unsigned int v30 = v26[v29];
          if (v30 <= v28)
          {
            if (v30 >= v28)
            {
              if ((v29 & 0x80000000) == 0)
              {
                unsigned int v31 = &unk_1DC410974;
                if (v8 == 4) {
                  unsigned int v31 = &unk_1DC410930;
                }
                a1[5] = v31[v29];
                *((void *)a1 + 19) = malloc_type_calloc(v25 * v9, 2uLL, 0x1000040BDFB0063uLL);
                uint64_t result = (uint64_t)malloc_type_calloc(*a1 * (uint64_t)a1[4], 2uLL, 0x1000040BDFB0063uLL);
                *((void *)a1 + 20) = result;
                if (*((void *)a1 + 19))
                {
                  if (result) {
                    *((unsigned char *)a1 + 168) = 1;
                  }
                }
              }
              return result;
            }
            int v21 = v29 + 1;
          }
          else
          {
            int v27 = v29 - 1;
          }
        }
        while (v21 <= v27);
      }
    }
  }
  return result;
}

void sub_1DC3BE358(float *a1, float *a2, unsigned int a3, int a4, uint64_t a5, float a6)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  float v7 = a1[4] - *a1;
  if ((float)(vabds_f32(v7, a6) / a6) > 0.5) {
    return;
  }
  uint64_t v11 = 0;
  char v12 = 1;
  do
  {
    if (v12) {
      uint64_t v13 = a1;
    }
    else {
      uint64_t v13 = a2;
    }
    if (v12) {
      ++a1;
    }
    else {
      ++a2;
    }
    v35[v11] = v13[1] - *v13;
    v12 ^= 1u;
    ++v11;
  }
  while (v11 != 6);
  if (sub_1DC3BBDD4(v35, 6, &v29, v7) >= 0.25) {
    return;
  }
  unsigned int v14 = (v29 + v33 - (v30 + v34) + 9) % 9;
  BOOL v15 = v14 > 6 || ((1 << v14) & 0x49) == 0;
  if (v15 || v14 != 3 * (a3 % 3)) {
    return;
  }
  int v16 = 0;
  unsigned int v17 = ((v29 + v33 - (v30 + v34) + 9) % 9) / 3u;
  uint64_t v18 = (uint64_t)*(&off_1E6C3AAA8 + v17);
  unsigned int v19 = 100000 * v29 + 10000 * v30 + 10 * v33 + v34 + 1000 * v31 + 100 * v32;
  uint64_t v20 = (uint64_t)*(&off_1E6C3AAC0 + v17);
  int v21 = 928;
  while (1)
  {
    unsigned int v22 = v16 + ((v21 - v16) >> 1);
    unsigned int v23 = *(_DWORD *)(v18 + 4 * (int)v22);
    if (v23 <= v19) {
      break;
    }
    int v21 = v22 - 1;
LABEL_21:
    if (v16 > v21) {
      return;
    }
  }
  if (v23 < v19)
  {
    int v16 = v22 + 1;
    goto LABEL_21;
  }
  if ((v22 & 0x80000000) == 0)
  {
    int v24 = *(_DWORD *)(v20 + 4 * v22);
    if ((v24 & 0x80000000) == 0)
    {
      uint64_t v25 = *(void *)(a5 + 160);
      uint64_t v26 = (int)(a4 + *(_DWORD *)a5 * (a3 - *(_DWORD *)(a5 + 8)));
      __int16 v27 = *(_WORD *)(v25 + 2 * v26);
      if (v27)
      {
        if (v24 == *(unsigned __int16 *)(*(void *)(a5 + 152) + 2 * v26))
        {
          __int16 v28 = v27 + 1;
          goto LABEL_29;
        }
        *(_WORD *)(v25 + 2 * v26) = v27 - 1;
        if (v27 == 1) {
          --*(_DWORD *)(a5 + 24);
        }
      }
      else
      {
        ++*(_DWORD *)(a5 + 24);
        *(_WORD *)(*(void *)(a5 + 152) + 2 * v26) = v24;
        __int16 v28 = *(_WORD *)(v25 + 2 * v26) + 1;
LABEL_29:
        *(_WORD *)(v25 + 2 * v26) = v28;
      }
    }
  }
}

uint64_t sub_1DC3BE5CC(uint64_t a1, int a2, int *a3)
{
  uint64_t v3 = 0;
  int v4 = 0;
  unsigned __int16 v5 = 0;
  LOWORD(v6) = 0;
  int v7 = -1;
  do
  {
    unsigned int v8 = *(unsigned __int16 *)(a1 + 2 * v3);
    v4 += v8;
    if (v8 > v5) {
      unsigned __int16 v5 = *(_WORD *)(a1 + 2 * v3);
    }
    BOOL v9 = v8 >= (unsigned __int16)v6;
    if (v8 >= (unsigned __int16)v6) {
      unsigned __int16 v5 = v6;
    }
    if (v8 <= (unsigned __int16)v6) {
      unsigned int v6 = (unsigned __int16)v6;
    }
    else {
      unsigned int v6 = *(unsigned __int16 *)(a1 + 2 * v3);
    }
    if (v9) {
      int v7 = v3;
    }
    ++v3;
  }
  while (a2 != v3);
  if ((int)(v6 - v5) <= 2)
  {
    int v10 = v4 - v6;
    if (v6 < 3 || v10 >= (int)v6) {
      return 0;
    }
  }
  *a3 = v7;
  return 1;
}

uint64_t sub_1DC3BE648(uint64_t a1, int a2, int a3, uint64_t a4, __int16 a5)
{
  int v5 = a3 / 8;
  if (a2 >= 2) {
    int v6 = 4;
  }
  else {
    int v6 = 2;
  }
  if (v5 >= v6 && (a3 & 0xFFFFFFF8) != 0x20) {
    return 0xFFFFFFFFLL;
  }
  *(_WORD *)(a1 + 2 * a2 + 28) += a5;
  *(_WORD *)(a1 + 2 * v5 + 38) += a5;
  *(_WORD *)(a1 + 2 * (int)a4 + 48) += a5;
  return a4;
}

void sub_1DC3BE6BC()
{
}

size_t sub_1DC3BE6E4(size_t result, char *a2, std::string::size_type a3, size_t *a4, const char *a5)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *(int *)(result + 8);
  unint64_t v6 = v5 >> 1;
  if ((v5 >> 1) - 177 >= 0xFFFFFF50)
  {
    unsigned int v8 = a4;
    std::string::size_type v9 = a3;
    size_t v11 = result;
    uint64_t v12 = *(void *)(result + 16);
    int v13 = *(_DWORD *)(v11 + 4);
    if (v6 <= 0x14 && v13 == 1)
    {
      uint64_t v15 = 0;
      memset(v47, 0, sizeof(v47));
      __int16 v48 = 0;
      if (v12) {
        BOOL v16 = v6 == 0;
      }
      else {
        BOOL v16 = 1;
      }
      if (!v16)
      {
        unint64_t v17 = (v5 >> 1);
        uint64_t v18 = (unsigned __int16 *)v12;
        unint64_t v19 = v17;
        do
        {
          unsigned int v20 = *v18++;
          if (v20 > 0x3A0)
          {
            uint64_t v15 = 0;
            goto LABEL_50;
          }
          --v19;
        }
        while (v19);
        int v21 = 0;
        int v22 = 0;
        int v23 = -2;
        int v24 = v6;
        do
        {
          int v25 = v24 - 7;
          if (v24 >= 7) {
            unsigned int v26 = 7;
          }
          else {
            unsigned int v26 = v24;
          }
          if (v26 <= 2) {
            uint64_t v27 = 2;
          }
          else {
            uint64_t v27 = v26;
          }
          uint64_t v50 = *(unsigned __int16 *)(v12 + 2 * v19);
          if ((int)v6 - (int)v19 >= 7) {
            int v28 = 7;
          }
          else {
            int v28 = v6 - v19;
          }
          memset(v49, 0, sizeof(v49));
          if (v28 > 1)
          {
            for (uint64_t i = 1; i != v27; ++i)
            {
              unint64_t v30 = 4;
              do
              {
                *((void *)v49 + v30) *= 928;
                BOOL v41 = v30-- > 1;
              }
              while (v41);
              uint64_t v31 = 0;
              uint64_t v32 = v50 + *(unsigned __int16 *)(v12 + 2 * (i + v19));
              uint64_t v50 = v32;
              do
              {
                int v33 = (char *)v49 + 8 * v31;
                uint64_t v34 = (unsigned __int16)v32;
                uint64_t v32 = *((void *)v33 + 3) + (v32 >> 16);
                *((void *)v33 + 3) = v32;
                *((void *)v33 + 4) = v34;
                unint64_t v35 = v31 + 4;
                --v31;
              }
              while (v35 > 1);
            }
          }
          int v36 = 10 * v28 - 1;
          if ((int)v6 - (int)v19 >= 1)
          {
            unsigned int v37 = v23 + 10 * v26;
            uint64_t v38 = 4;
            int v39 = 10 * v28 - 1;
            do
            {
              if (v39 >= 16) {
                int v40 = 16;
              }
              else {
                int v40 = v39;
              }
              BOOL v41 = v39 + v22 - v40 > 1600 || (v40 - 1) > 0xF;
              if (!v41)
              {
                unsigned int v42 = v40 + 1;
                unsigned int v43 = (unsigned __int16)*((void *)v49 + v38);
                signed int v44 = v37;
                do
                {
                  int v45 = *((unsigned __int16 *)v47 + v44 / 16);
                  unsigned int v46 = v45 | (0x8000u >> (v44 & 0xF));
                  if ((v43 & 1) == 0) {
                    LOWORD(v46) = v45 & (-32769 >> (v44 & 0xF));
                  }
                  *((_WORD *)v47 + v44 / 16) = v46;
                  v43 >>= 1;
                  --v42;
                  --v44;
                }
                while (v42 > 1);
              }
              --v38;
              v37 -= 16;
              BOOL v41 = v39 <= 15;
              v39 -= 16;
            }
            while (!v41);
          }
          v21 += v36;
          v22 += 69;
          v19 += 7;
          v23 += 69;
          int v24 = v25;
        }
        while (v19 < v17);
        uint64_t v15 = v21;
        unsigned int v8 = a4;
        std::string::size_type v9 = a3;
      }
LABEL_50:
      sub_1DC36F420((uint64_t)v47, v15, a2, v9);
      uint64_t result = strlen(a2);
      *unsigned int v8 = result;
    }
    else
    {
      uint64_t result = sub_1DC3EE6F0(v12, 0, (v5 >> 1), a2, a3, a4, a5);
      if ((result & 1) == 0)
      {
        *unsigned int v8 = 0;
        *a2 = 0;
      }
    }
  }
  return result;
}

BOOL sub_1DC3BE9B8(int a1, uint64_t a2, int a3)
{
  return a1 > 10 && a3 > 11;
}

uint64_t sub_1DC3BE9C8(uint64_t result, _DWORD *a2)
{
  if (result)
  {
    if ((int)result >= 0) {
      int v2 = result;
    }
    else {
      int v2 = -(int)result;
    }
    int v3 = v2;
    for (uint64_t i = a2; !*i; ++i)
    {
      if (!--v3) {
        return 0;
      }
    }
    int v5 = a2[v2 - 1];
    if (!v5) {
      return 0;
    }
    int v6 = 32;
    if ((v5 & 0x80000000) == 0)
    {
      unsigned int v7 = 0x80000000;
      do
      {
        --v6;
        BOOL v8 = (v5 & (v7 >> 1)) == 0;
        v7 >>= 1;
      }
      while (v8);
    }
    return (v6 + 32 * v2 - 32);
  }
  return result;
}

uint64_t sub_1DC3BEA30(uint64_t a1, int a2, _DWORD *a3)
{
  int v3 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    if (v3 >= 0) {
      int v4 = *(_DWORD *)a1;
    }
    else {
      int v4 = -v3;
    }
    int v5 = *(_DWORD **)(a1 + 8);
    while (!*v5)
    {
      ++v5;
      if (!--v4) {
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    if (!a2) {
      return 0;
    }
    if (a2 >= 0) {
      LODWORD(v6) = a2;
    }
    else {
      LODWORD(v6) = -a2;
    }
    for (uint64_t i = a3; !*i; ++i)
    {
      uint64_t v6 = (v6 - 1);
      if (!v6) {
        return v6;
      }
    }
  }
  if (v3 <= a2)
  {
    uint64_t v6 = 0xFFFFFFFFLL;
    if (v3 < a2) {
      return v6;
    }
    if (v3 >= 0) {
      uint64_t v8 = v3;
    }
    else {
      uint64_t v8 = -v3;
    }
    if (v3 >= 0) {
      uint64_t v9 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v9 = 1;
    }
    uint64_t v6 = (v3 >> 31) | 1u;
    while ((int)v8 >= 1)
    {
      unsigned int v10 = *(_DWORD *)(*(void *)(a1 + 8) + 4 * v8 - 4);
      unsigned int v11 = a3[v8 - 1];
      if (v10 > v11) {
        return v6;
      }
      --v8;
      if (v10 < v11) {
        return v9;
      }
    }
    return 0;
  }
  return 1;
}

uint64_t sub_1DC3BEAF0(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)a2;
  if (*(int *)a2 >= 0) {
    unint64_t v3 = v2;
  }
  else {
    unint64_t v3 = -v2;
  }
  if (v2)
  {
    int v4 = *(_DWORD **)(a2 + 8);
    int v5 = v3;
    uint64_t v6 = v4;
    while (!*v6)
    {
      ++v6;
      if (!--v5) {
        goto LABEL_8;
      }
    }
    if (result)
    {
      unint64_t v8 = 0;
      do
      {
        int v9 = v4[v8];
        BOOL v10 = __CFADD__(v9, result);
        unsigned int v11 = v9 + result;
        unsigned int v12 = v10;
        if (v11 < result) {
          uint64_t result = 1;
        }
        else {
          uint64_t result = v12;
        }
        v4[v8++] = v11;
      }
      while (v8 < v3 && (result & 1) != 0);
      if (result)
      {
        ++*(_DWORD *)a2;
        v4[v3] = result;
      }
    }
  }
  else
  {
LABEL_8:
    *(_DWORD *)a2 = 0;
    if (result)
    {
      if ((int)result >= 0) {
        int v7 = result;
      }
      else {
        int v7 = -(int)result;
      }
      **(_DWORD **)(a2 + 8) = v7;
      *(_DWORD *)a2 = 1;
    }
    else
    {
      **(_DWORD **)(a2 + 8) = 0;
    }
  }
  return result;
}

uint64_t sub_1DC3BEB98(unsigned int *a1, uint64_t a2)
{
  uint64_t result = *a1;
  if (!result) {
    return result;
  }
  int v5 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2)
  {
    int v7 = (const void *)*((void *)a1 + 1);
    if (v7 == *(const void **)(a2 + 8)) {
      return result;
    }
    if ((int)result >= 0) {
      unsigned int v8 = result;
    }
    else {
      unsigned int v8 = -(int)result;
    }
    uint64_t result = (uint64_t)memcpy(*(void **)(a2 + 8), v7, 4 * v8);
    int v9 = *a1;
    goto LABEL_24;
  }
  long long v11 = *(_OWORD *)a1;
  if (((v5 ^ result) & 0x80000000) != 0)
  {
    if (v5 < 1)
    {
      *(_DWORD *)a2 = -v5;
      if ((sub_1DC3BEA30(a2, v11, *((_DWORD **)&v11 + 1)) & 0x80000000) != 0) {
        return (uint64_t)sub_1DC3BEF08((uint64_t)&v11, (int *)a2);
      }
      uint64_t result = (uint64_t)sub_1DC3BEE48((int *)&v11, (unsigned int *)a2);
    }
    else
    {
      LODWORD(v11) = -(int)v11;
      if ((sub_1DC3BEA30(a2, v11, *((_DWORD **)&v11 + 1)) & 0x80000000) == 0) {
        return (uint64_t)sub_1DC3BEE48((int *)&v11, (unsigned int *)a2);
      }
      uint64_t result = (uint64_t)sub_1DC3BEF08((uint64_t)&v11, (int *)a2);
    }
LABEL_23:
    int v9 = -*(_DWORD *)a2;
LABEL_24:
    *(_DWORD *)a2 = v9;
    return result;
  }
  if (v5 >= 1)
  {
    uint64_t v6 = (unsigned int *)*((void *)a1 + 1);
    return sub_1DC3BED04(result, v6, (int *)a2);
  }
  uint64_t v10 = -(int)v11;
  if (*((void *)a1 + 1) != *(void *)(a2 + 8)) {
    *(_DWORD *)a2 = -v5;
  }
  uint64_t result = sub_1DC3BED04(v10, *((unsigned int **)&v11 + 1), (int *)a2);
  if (*((void *)a1 + 1) != *(void *)(a2 + 8)) {
    goto LABEL_23;
  }
  return result;
}

uint64_t sub_1DC3BED04(uint64_t result, unsigned int *a2, int *a3)
{
  uint64_t v3 = *a3;
  uint64_t v4 = *((void *)a3 + 1);
  if ((int)result >= (int)v3) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = result;
  }
  if ((int)result <= (int)v3) {
    int v6 = *a3;
  }
  else {
    int v6 = result;
  }
  if ((int)v5 < 1)
  {
    int v8 = 0;
    uint64_t v5 = 0;
    int v17 = 1;
  }
  else
  {
    LOBYTE(v7) = 0;
    LOBYTE(v8) = 0;
    int v9 = (unsigned int *)*((void *)a3 + 1);
    uint64_t v10 = a2;
    uint64_t v11 = v5;
    do
    {
      unsigned __int8 v12 = v8 | v7;
      int v8 = v12 & (*v9 == -1);
      int v13 = *v9 + (v12 & 1);
      unsigned int v15 = *v10++;
      unsigned int v14 = v15;
      unsigned int v16 = v15 + v13;
      BOOL v7 = __CFADD__(v15, v13);
      if (v16 < v14) {
        BOOL v7 = 1;
      }
      *v9++ = v16;
      --v11;
    }
    while (v11);
    int v17 = !v7;
  }
  if ((int)v3 > (int)result)
  {
    if (v8) {
      char v18 = 0;
    }
    else {
      char v18 = v17;
    }
    if (v18) {
      goto LABEL_39;
    }
    if ((int)v5 < (int)v3)
    {
      uint64_t v19 = v3 - v5;
      unsigned int v20 = (_DWORD *)(v4 + 4 * v5);
      while (__CFADD__((*v20)++, 1))
      {
        ++v20;
        if (!--v19)
        {
          uint64_t v5 = v3;
          goto LABEL_28;
        }
      }
      goto LABEL_39;
    }
LABEL_28:
    *a3 = v6;
    uint64_t result = v5;
LABEL_38:
    *(_DWORD *)(v4 + 4 * result) = 1;
    int v6 = *a3 + 1;
LABEL_39:
    *a3 = v6;
    return result;
  }
  if (v17) {
    int v22 = v8;
  }
  else {
    int v22 = 1;
  }
  if ((int)v5 >= (int)result)
  {
    uint64_t result = v5;
  }
  else
  {
    LOBYTE(v22) = v22 != 0;
    unint64_t v23 = result - (unint64_t)v5;
    int v24 = (_DWORD *)(v4 + 4 * v5);
    int v25 = (int *)&a2[v5];
    do
    {
      int v26 = *v25++;
      int v27 = v26 + (v22 & 1);
      int v22 = v22 & (v26 == -1);
      *v24++ = v27;
      --v23;
    }
    while (v23);
  }
  *a3 = v6;
  if (v22) {
    goto LABEL_38;
  }
  return result;
}

int *sub_1DC3BEE48(int *result, unsigned int *a2)
{
  if (*result)
  {
    uint64_t v2 = *a2;
    uint64_t v3 = *((void *)a2 + 1);
    if (*result >= 1)
    {
      uint64_t v4 = 0;
      BOOL v5 = 0;
      LOBYTE(v6) = 0;
      uint64_t v7 = *((void *)result + 1);
      do
      {
        unsigned __int8 v8 = v6 | v5;
        int v9 = *(_DWORD *)(v3 + 4 * v4);
        int v6 = v8 & (v9 == 0);
        unsigned int v10 = v9 - (v8 & 1);
        unsigned int v11 = *(_DWORD *)(v7 + 4 * v4);
        BOOL v5 = v10 < v11;
        *(_DWORD *)(v3 + 4 * v4++) = v10 - v11;
        uint64_t v12 = *result;
      }
      while (v4 < v12);
      int v13 = v10 < v11 ? 1 : v6;
      if (v13 == 1 && (int)v12 < (int)v2)
      {
        do
        {
          int v15 = *(_DWORD *)(v3 + 4 * v12);
          *(_DWORD *)(v3 + 4 * v12++) = v15 - 1;
        }
        while (v12 < (int)v2 && !v15);
      }
    }
    unsigned int v16 = v2 & ((int)v2 >> 31);
    int v17 = (_DWORD *)(v3 + 4 * v2 - 4);
    while (1)
    {
      BOOL v18 = __OFSUB__(v2, 1);
      LODWORD(v2) = v2 - 1;
      if ((int)v2 < 0 != v18) {
        break;
      }
      if (*v17--)
      {
        unsigned int v16 = v2 + 1;
        break;
      }
    }
    *a2 = v16;
  }
  return result;
}

_DWORD *sub_1DC3BEF08(uint64_t a1, int *a2)
{
  int v4 = *(_DWORD *)a1;
  BOOL v5 = *(_DWORD **)(a1 + 8);
  uint64_t result = (_DWORD *)*((void *)a2 + 1);
  LODWORD(v7) = *a2;
  if (*a2)
  {
    if ((int)v7 < 1)
    {
      int v10 = 0;
      char v9 = 0;
    }
    else
    {
      uint64_t v8 = 0;
      char v9 = 0;
      LOBYTE(v10) = 0;
      do
      {
        unsigned __int8 v11 = v10 | v9;
        int v12 = v5[v8];
        int v10 = v11 & (v12 == 0);
        unsigned int v13 = v12 - (v11 & 1);
        unsigned int v14 = result[v8];
        BOOL v15 = v13 >= v14;
        unsigned int v16 = v13 - v14;
        char v9 = !v15;
        result[v8++] = v16;
        uint64_t v7 = *a2;
      }
      while (v8 < v7);
    }
    uint64_t v18 = v4;
    if ((int)v7 < v4)
    {
      BOOL v19 = v10 == 0;
      uint64_t v20 = v4 - (uint64_t)(int)v7;
      if (!v19) {
        char v9 = 1;
      }
      int v21 = &result[(int)v7];
      int v22 = &v5[(int)v7];
      do
      {
        int v23 = *v22++;
        int v24 = v23 - (v9 & 1);
        v9 &= v23 == 0;
        *v21++ = v24;
        --v20;
      }
      while (v20);
    }
    *a2 = v4;
    do
      uint64_t v17 = v18--;
    while (!result[v17 - 1]);
  }
  else
  {
    if (v5 == result) {
      return result;
    }
    if (v4 < 0) {
      int v4 = -v4;
    }
    uint64_t result = memcpy(result, v5, 4 * v4);
    LODWORD(v17) = *(_DWORD *)a1;
  }
  *a2 = v17;
  return result;
}

int *sub_1DC3BF01C(int *result, uint64_t a2)
{
  int v2 = *result;
  if (*result)
  {
    int v4 = result;
    int v5 = *(_DWORD *)a2;
    if (!*(_DWORD *)a2)
    {
      int v6 = (int *)*((void *)result + 1);
      uint64_t result = *(int **)(a2 + 8);
      if (v6 == result)
      {
        int v8 = 0;
      }
      else
      {
        if (v2 >= 0) {
          unsigned int v7 = v2;
        }
        else {
          unsigned int v7 = -v2;
        }
        uint64_t result = (int *)memcpy(result, v6, 4 * v7);
        int v8 = *v4;
      }
      goto LABEL_22;
    }
    long long v10 = *(_OWORD *)result;
    if (((v5 ^ v2) & 0x80000000) == 0)
    {
      if (v5 < 1)
      {
        LODWORD(v10) = -(int)v10;
        int v9 = v10;
        *(_DWORD *)a2 = -v5;
        if ((sub_1DC3BEA30(a2, v9, *((_DWORD **)&v10 + 1)) & 0x80000000) != 0) {
          return sub_1DC3BEF08((uint64_t)&v10, (int *)a2);
        }
        uint64_t result = sub_1DC3BEE48((int *)&v10, (unsigned int *)a2);
      }
      else
      {
        if ((sub_1DC3BEA30(a2, v10, *((_DWORD **)&v10 + 1)) & 0x80000000) == 0) {
          return sub_1DC3BEE48((int *)&v10, (unsigned int *)a2);
        }
        uint64_t result = sub_1DC3BEF08((uint64_t)&v10, (int *)a2);
      }
      goto LABEL_21;
    }
    if (v5 < 1)
    {
      *(_DWORD *)a2 = -v5;
      uint64_t result = (int *)sub_1DC3BED04(v10, *((unsigned int **)&v10 + 1), (int *)a2);
LABEL_21:
      int v8 = *(_DWORD *)a2;
LABEL_22:
      *(_DWORD *)a2 = -v8;
      return result;
    }
    return (int *)sub_1DC3BED04(-(int)v10, *((unsigned int **)&v10 + 1), (int *)a2);
  }
  return result;
}

void sub_1DC3BF170(unsigned int a1, uint64_t a2)
{
  int v2 = *(_DWORD *)a2;
  if (*(int *)a2 >= 0) {
    int v3 = *(_DWORD *)a2;
  }
  else {
    int v3 = -v2;
  }
  if (v2)
  {
    unint64_t v5 = ((unint64_t)a1 + 31) >> 5;
    int v6 = *(_DWORD **)(a2 + 8);
    int v7 = v3;
    int v8 = v6;
    while (!*v8)
    {
      ++v8;
      if (!--v7)
      {
        int v9 = 0;
        if (!a1) {
          return;
        }
        goto LABEL_14;
      }
    }
    int v9 = v2 < 1 ? -1 : 1;
    if (a1)
    {
LABEL_14:
      LODWORD(v10) = v5 + v3 - 1;
      uint64_t v11 = (int)v10;
      if ((a1 & 0x1F) != 0)
      {
        int v12 = 0;
        int v13 = v3 + 1;
        uint64_t v14 = (v3 - 1);
        uint64_t v15 = v11;
        do
        {
          unsigned int v16 = v6[v14];
          v6[v15] = (v16 >> (32 - (a1 & 0x1F))) | v12;
          int v17 = v15 - 1;
          int v12 = v16 << (a1 & 0x1F);
          --v13;
          --v14;
          --v15;
        }
        while (v13 > 1);
        uint64_t v18 = v17;
        do
        {
          v6[v18] = v12;
          int v12 = 0;
        }
        while (v18-- > 0);
      }
      else
      {
        int v20 = v3 + 1;
        uint64_t v21 = (v3 - 1);
        uint64_t v10 = (int)v10;
        do
        {
          v6[v10--] = v6[v21];
          --v20;
          --v21;
        }
        while (v20 > 1);
        bzero(&v6[(int)v10 - (v10 & ~((int)v10 >> 31))], 4 * (v10 & ~((int)v10 >> 31)) + 4);
      }
      *(_DWORD *)a2 = ((__PAIR64__(v3 + (int)v5, v6[v11]) - 1) >> 32) * v9;
    }
  }
}

uint64_t sub_1DC3BF2D8(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)a2;
  if (*(int *)a2 >= 0) {
    unsigned int v3 = *(_DWORD *)a2;
  }
  else {
    unsigned int v3 = -v2;
  }
  if (result && v2)
  {
    uint64_t v4 = result >> 5;
    char v5 = result & 0x1F;
    char v6 = 32 - (result & 0x1F);
    int v7 = *(_DWORD **)(a2 + 8);
    unsigned int v8 = v3;
    for (uint64_t i = v7; !*i; ++i)
    {
      if (!--v8) {
        return result;
      }
    }
    BOOL v10 = v3 >= v4;
    uint64_t v11 = v3 - v4;
    if (v11 == 0 || !v10)
    {
      int v17 = 0;
LABEL_25:
      *(_DWORD *)a2 = v17;
      return result;
    }
    if ((result & 0x1F) != 0)
    {
      if ((int)v11 >= 1)
      {
        uint64_t v12 = result >> 5;
        uint64_t v13 = (v11 - 1);
        uint64_t v14 = *(_DWORD **)(a2 + 8);
        uint64_t v15 = v11;
        do
        {
          if (v13) {
            int v16 = v14[v12 + 1] << v6;
          }
          else {
            int v16 = 0;
          }
          uint64_t result = (v14[v12] >> v5);
          *v14++ = result | v16;
          --v13;
          --v15;
        }
        while (v15);
        int v2 = *(_DWORD *)a2;
      }
      if (v7[(int)v11 - 1]) {
        int v17 = v11;
      }
      else {
        int v17 = v11 - 1;
      }
      if (v2 <= 0) {
        int v17 = -v17;
      }
      goto LABEL_25;
    }
    if (v2 > 0) {
      int v18 = v11;
    }
    else {
      int v18 = -(int)v11;
    }
    *(_DWORD *)a2 = v18;
    if ((int)v11 >= 1)
    {
      do
      {
        *int v7 = v7[v4];
        ++v7;
        --v11;
      }
      while (v11);
    }
  }
  return result;
}

int *sub_1DC3BF3C8(int *result, int *a2)
{
  int v2 = *result;
  if (*result >= 0) {
    unsigned int v3 = *result;
  }
  else {
    unsigned int v3 = -v2;
  }
  uint64_t v4 = *a2;
  if ((int)v4 >= 0) {
    int v5 = *a2;
  }
  else {
    int v5 = -(int)v4;
  }
  if (v4)
  {
    uint64_t v7 = (uint64_t)result;
    uint64_t v8 = 0;
    uint64_t result = (int *)*((void *)a2 + 1);
    if (v4 <= -(int)v4) {
      LODWORD(v4) = -(int)v4;
    }
    while (!result[v8])
    {
      if (v4 == ++v8) {
        return result;
      }
    }
    int v9 = *(int **)(v7 + 8);
    if (v2)
    {
      unsigned int v10 = v3;
      uint64_t v11 = *(_DWORD **)(v7 + 8);
      while (!*v11)
      {
        ++v11;
        if (!--v10) {
          goto LABEL_17;
        }
      }
      if ((int *)v7 == a2)
      {
        int v15 = 2 * v5;
        uint64_t v18 = 0;
        uint64_t result = (int *)off_1EAA94E20(qword_1EAA94E28, 0, 4 * (2 * v5));
        __vImage_Buffer src = result;
        if (result)
        {
          HIDWORD(v18) = v15;
          sub_1DC3BF828(a2, (uint64_t)&v18);
          int v16 = __src;
          uint64_t result = (int *)*((void *)a2 + 1);
          if (__src != result)
          {
            unsigned int v17 = v18;
            if ((int)v18 < 0) {
              unsigned int v17 = -(int)v18;
            }
            uint64_t result = (int *)memcpy(result, __src, 4 * v17);
            *a2 = v18;
            int v16 = __src;
          }
          if (v16) {
            return (int *)((uint64_t (*)(uint64_t))off_1EAA94E18)(qword_1EAA94E28);
          }
        }
      }
      else
      {
        unsigned int v12 = v5 + v3;
        uint64_t v18 = 0;
        uint64_t result = (int *)off_1EAA94E20(qword_1EAA94E28, 0, 4 * (v5 + v3));
        __vImage_Buffer src = result;
        if (result)
        {
          HIDWORD(v18) = v12;
          sub_1DC3BF594(v7, (uint64_t)a2, (uint64_t)&v18);
          uint64_t v13 = __src;
          uint64_t result = (int *)*((void *)a2 + 1);
          if (__src != result)
          {
            unsigned int v14 = v18;
            if ((int)v18 < 0) {
              unsigned int v14 = -(int)v18;
            }
            uint64_t result = (int *)memcpy(result, __src, 4 * v14);
            *a2 = v18;
            uint64_t v13 = __src;
          }
          if (v13) {
            return (int *)((uint64_t (*)(uint64_t))off_1EAA94E18)(qword_1EAA94E28);
          }
        }
      }
    }
    else
    {
LABEL_17:
      if (v9 != result)
      {
        uint64_t result = (int *)memcpy(result, v9, 4 * v3);
        *a2 = *(_DWORD *)v7;
      }
    }
  }
  return result;
}

void sub_1DC3BF594(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)a1;
  if (*(int *)a1 >= 0) {
    unsigned int v5 = *(_DWORD *)a1;
  }
  else {
    unsigned int v5 = -v4;
  }
  int v6 = *(_DWORD *)a2;
  if (*(int *)a2 >= 0) {
    unsigned int v7 = *(_DWORD *)a2;
  }
  else {
    unsigned int v7 = -v6;
  }
  if (!v4) {
    goto LABEL_16;
  }
  unsigned int v10 = *(_DWORD **)(a1 + 8);
  unsigned int v11 = v5;
  while (!*v10)
  {
    ++v10;
    if (!--v11) {
      goto LABEL_16;
    }
  }
  if (v6)
  {
    unsigned int v12 = *(_DWORD **)(a2 + 8);
    unsigned int v13 = v7;
    while (!*v12)
    {
      ++v12;
      if (!--v13) {
        goto LABEL_16;
      }
    }
    if (a1 == a2)
    {
      sub_1DC3BF828((int *)a1, a3);
    }
    else if (a1 != a3 && a2 != a3)
    {
      bzero(*(void **)(a3 + 8), 4 * (v7 + v5));
      unsigned int v14 = *(_DWORD **)(a2 + 8);
      if (v7 == 1)
      {
        LODWORD(v15) = 0;
        unint64_t v36 = 0;
        BOOL v19 = *(unsigned int **)(a2 + 8);
      }
      else
      {
        unint64_t v15 = 0;
        int v16 = *(unsigned int **)(a1 + 8);
        uint64_t v17 = *(void *)(a3 + 8);
        if (v5 <= 1) {
          int v18 = 1;
        }
        else {
          int v18 = v5;
        }
        BOOL v19 = *(unsigned int **)(a2 + 8);
        do
        {
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          unint64_t v22 = 0;
          unsigned int v23 = *v19;
          uint64_t v24 = v19[1];
          int v25 = (unsigned int *)(v17 + 4 * v15);
          uint64_t v26 = *v25;
          int v27 = v18;
          int v28 = v16;
          do
          {
            int v29 = v25;
            unint64_t v30 = v20 * v24;
            unsigned int v31 = *v28++;
            uint64_t v20 = v31;
            unint64_t v32 = v31 * (unint64_t)v23;
            unint64_t v33 = v21 + v22 + v26 + v30 + v32;
            unint64_t v22 = HIDWORD(v33) + HIDWORD(v32);
            unsigned int v34 = v25[1];
            ++v25;
            uint64_t v26 = v34;
            _DWORD *v29 = v33;
            uint64_t v21 = HIDWORD(v30);
            --v27;
          }
          while (v27);
          v19 += 2;
          unint64_t v35 = HIDWORD(v30) + v22 + v26 + v20 * (unint64_t)v24;
          *(void *)int v25 = v35;
          v15 += 2;
        }
        while (v15 < v7 - 1);
        unint64_t v36 = HIDWORD(v35);
      }
      if (v15 < v7)
      {
        unsigned int v37 = *v19;
        if (v37)
        {
          unint64_t v36 = 0;
          uint64_t v38 = *(unsigned int **)(a1 + 8);
          int v39 = (_DWORD *)(*(void *)(a3 + 8) + 4 * v15);
          if (v5 <= 1) {
            int v40 = 1;
          }
          else {
            int v40 = v5;
          }
          do
          {
            unsigned int v41 = *v38++;
            unint64_t v42 = v36 + *v39 + v41 * (unint64_t)v37;
            *v39++ = v42;
            unint64_t v36 = HIDWORD(v42);
            --v40;
          }
          while (v40);
          *int v39 = v36;
        }
      }
      int v43 = v7 + v5 - (v36 == 0);
      *(_DWORD *)a3 = v43;
      int v44 = *(_DWORD *)a1;
      if (*(_DWORD *)a1)
      {
        if (v44 >= 0) {
          int v45 = *(_DWORD *)a1;
        }
        else {
          int v45 = -v44;
        }
        unsigned int v46 = *(_DWORD **)(a1 + 8);
        while (!*v46)
        {
          ++v46;
          if (!--v45)
          {
            int v44 = 0;
            goto LABEL_52;
          }
        }
        if (v44 < 1) {
          int v44 = -1;
        }
        else {
          int v44 = 1;
        }
      }
LABEL_52:
      int v47 = *(_DWORD *)a2;
      if (*(_DWORD *)a2)
      {
        if (v47 >= 0) {
          int v48 = *(_DWORD *)a2;
        }
        else {
          int v48 = -v47;
        }
        while (!*v14)
        {
          ++v14;
          if (!--v48) {
            goto LABEL_58;
          }
        }
        if (v47 < 1) {
          int v49 = -1;
        }
        else {
          int v49 = 1;
        }
      }
      else
      {
LABEL_58:
        int v49 = 0;
      }
      if (v44 != v49) {
        *(_DWORD *)a3 = -v43;
      }
    }
  }
  else
  {
LABEL_16:
    *(_DWORD *)a3 = 0;
  }
}

int *sub_1DC3BF828(int *result, uint64_t a2)
{
  uint64_t v2 = *result;
  if ((int)v2 >= 0) {
    unint64_t v3 = v2;
  }
  else {
    unint64_t v3 = -(int)v2;
  }
  if (v2)
  {
    if (result == (int *)a2) {
      return result;
    }
    uint64_t v4 = *(void *)(a2 + 8);
    unsigned int v5 = (unsigned int *)*((void *)result + 1);
    if (v3 <= 1) {
      int v6 = 1;
    }
    else {
      int v6 = v3;
    }
    unsigned int v7 = *(void **)(a2 + 8);
    uint64_t v8 = (unsigned int *)*((void *)result + 1);
    do
    {
      unsigned int v9 = *v8++;
      *v7++ = v9 * (unint64_t)v9;
      --v6;
    }
    while (v6);
    if (v3 != 1)
    {
      unint64_t v10 = 0;
      if (v2 <= -(int)v2) {
        LODWORD(v2) = -(int)v2;
      }
      do
      {
        uint64_t v11 = v4 + 8 * v10++;
        unsigned int v12 = (_DWORD *)(v11 + 4);
        if (v10 >= v3)
        {
          unint64_t v13 = 0;
        }
        else
        {
          unint64_t v13 = 0;
          unsigned int v14 = *v5;
          uint64_t v15 = 1;
          do
          {
            unint64_t v16 = (v5[v15] * (unint64_t)v14) >> 32;
            uint64_t result = (int *)(2 * v5[v15] * v14);
            unint64_t v17 = (unint64_t)result + v13 + *v12;
            *v12++ = v17;
            unint64_t v13 = HIDWORD(v17) + 2 * v16;
            ++v15;
          }
          while (v2 != v15);
        }
        ++v5;
        do
        {
          unint64_t v18 = *v12 + (unint64_t)v13;
          *v12++ = v18;
          unint64_t v13 = HIDWORD(v18) + HIDWORD(v13);
        }
        while (v13);
        LODWORD(v2) = v2 - 1;
      }
      while (v10 != v3 - 1);
    }
    int v19 = 2 * v3;
    if (!*(_DWORD *)(v4 + 4 * (v19 - 1))) {
      --v19;
    }
  }
  else
  {
    int v19 = 0;
  }
  *(_DWORD *)a2 = v19;
  return result;
}

_DWORD *sub_1DC3BF930(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)a1;
  if (*(int *)a1 < 0) {
    int v4 = -v4;
  }
  unsigned int v5 = 4 * v4;
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v16 = 0;
  unint64_t v17 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  if (4 * v4)
  {
    uint64_t result = (_DWORD *)off_1EAA94E20(qword_1EAA94E28, 0, 4 * (4 * v4));
    uint64_t v21 = result;
    if (!result) {
      goto LABEL_30;
    }
    HIDWORD(v20) = v5;
    uint64_t result = (_DWORD *)off_1EAA94E20(qword_1EAA94E28, 0, 4 * v5);
    int v19 = result;
    if (!result) {
      goto LABEL_30;
    }
    unsigned int v7 = result;
    HIDWORD(v18) = v5;
  }
  else
  {
    unsigned int v7 = 0;
  }
  int v8 = *(_DWORD *)a1;
  if (*(int *)a1 >= 0) {
    unsigned int v9 = *(_DWORD *)a1;
  }
  else {
    unsigned int v9 = -v8;
  }
  if (v8)
  {
    uint64_t result = (_DWORD *)off_1EAA94E20(qword_1EAA94E28, 0, 4 * v9);
    unint64_t v17 = result;
    if (!result) {
      goto LABEL_30;
    }
    HIDWORD(v16) = v9;
  }
  else
  {
    uint64_t result = 0;
  }
  unint64_t v10 = *(_DWORD **)(a1 + 8);
  if (v10 != result)
  {
    unsigned int v11 = *(_DWORD *)a1;
    if (*(int *)a1 < 0) {
      unsigned int v11 = -v11;
    }
    memcpy(result, v10, 4 * v11);
    LODWORD(v16) = *(_DWORD *)a1;
  }
  **(_DWORD **)(a2 + 8) = 1;
  *(_DWORD *)a2 = 1;
  sub_1DC3BF01C((int *)a2, (uint64_t)&v16);
  uint64_t v12 = sub_1DC3BE9C8(v16, v17);
  sub_1DC3BEB98((unsigned int *)a2, (uint64_t)&v16);
  sub_1DC3BF170(v12, a2);
  unint64_t v13 = *(_DWORD **)(a2 + 8);
  if (v13 != v7) {
    goto LABEL_21;
  }
  int v14 = 0;
  while (1)
  {
    sub_1DC3BF828((int *)a2, (uint64_t)&v20);
    sub_1DC3BF2D8(v12, (uint64_t)&v20);
    sub_1DC3BF3C8((int *)&v16, (int *)&v20);
    sub_1DC3BF2D8(v12, (uint64_t)&v20);
    sub_1DC3BEB98((unsigned int *)a2, a2);
    sub_1DC3BF01C((int *)&v20, a2);
    if ((int)sub_1DC3BEA30(a2, v14, v7) < 1) {
      break;
    }
    unint64_t v13 = *(_DWORD **)(a2 + 8);
    if (v13 != v7)
    {
LABEL_21:
      unsigned int v15 = *(_DWORD *)a2;
      if (*(int *)a2 < 0) {
        unsigned int v15 = -v15;
      }
      memcpy(v7, v13, 4 * v15);
      int v14 = *(_DWORD *)a2;
      LODWORD(v18) = *(_DWORD *)a2;
    }
  }
  *uint64_t v21 = 1;
  LODWORD(v20) = 1;
  sub_1DC3BF170(2 * v12, (uint64_t)&v20);
  sub_1DC3BF594(a2, (uint64_t)&v16, (uint64_t)&v18);
  uint64_t result = sub_1DC3BF01C((int *)&v18, (uint64_t)&v20);
  *int v19 = 1;
  LODWORD(v18) = 1;
  while ((v20 & 0x80000000) != 0)
  {
    sub_1DC3BF01C((int *)&v18, a2);
    uint64_t result = (_DWORD *)sub_1DC3BEB98((unsigned int *)&v16, (uint64_t)&v20);
  }
LABEL_30:
  if (v21) {
    uint64_t result = (_DWORD *)off_1EAA94E18(qword_1EAA94E28);
  }
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  if (v19) {
    uint64_t result = (_DWORD *)off_1EAA94E18(qword_1EAA94E28);
  }
  uint64_t v18 = 0;
  int v19 = 0;
  if (v17) {
    return (_DWORD *)off_1EAA94E18(qword_1EAA94E28);
  }
  return result;
}

uint64_t MRCContextGetTypeID()
{
  if (qword_1EBFFB7E0 != -1) {
    dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
  }
  return qword_1EBFFB818;
}

unint64_t MRCContextCreate()
{
  return MRCContextCreateWithOptions(0);
}

unint64_t MRCContextCreateWithOptions(CFTypeRef a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a1) {
    a1 = CFRetain(a1);
  }
  CFTypeRef v6 = a1;
  if (qword_1EBFFB7E0 != -1) {
    dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
  }
  Instance = (const void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    CFTypeID v2 = CFGetTypeID(Instance);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v2 != qword_1EBFFB818) {
      _os_assumes_log();
    }
    operator new();
  }
  atomic_ullong v7 = 0;
  unint64_t v3 = atomic_exchange(&v7, 0);
  int v4 = (const void *)atomic_exchange(&v7, 0);
  if (v4) {
    CFRelease(v4);
  }
  sub_1DC31EBFC((atomic_ullong *)&v6);
  return v3;
}

void sub_1DC3C0400(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  atomic_ullong v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);

  sub_1DC3864F8((const void **)va1);
  sub_1DC31EB58(v4);
  sub_1DC31EB58(v3);
  MEMORY[0x1E019CE90](v2, 0x10C0C40B18511C9);
  sub_1DC31EBFC((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void sub_1DC3C04E8()
{
}

uint64_t sub_1DC3C04F0(uint64_t a1)
{
  sub_1DC3C0594(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

uint64_t *sub_1DC3C052C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1DC31EB58((atomic_ullong *)(v1 + 16));
    sub_1DC31EB58((atomic_ullong *)(v1 + 8));
    JUMPOUT(0x1E019CE90);
  }
  return result;
}

void sub_1DC3C0594(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      uint64_t v2 = (void *)*v1;
      sub_1DC32E940(v1 + 6);
      sub_1DC32E9A8(v1 + 7);
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

uint64_t MRCContextPreflightForDecoderUsingOptions(const void *a1, const __CFDictionary *a2, const void *a3)
{
  if (a2)
  {
    CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    if (a3)
    {
LABEL_3:
      CFTypeRef v6 = _Block_copy(a3);
      goto LABEL_6;
    }
  }
  else
  {
    CFDictionaryRef Copy = 0;
    if (a3) {
      goto LABEL_3;
    }
  }
  CFTypeRef v6 = 0;
LABEL_6:
  sub_1DC377978((uint64_t)v17);
  sub_1DC31FC84(&v18, (uint64_t)"com.apple.Quagga.MRCContext-", 28);
  *(_DWORD *)((char *)v19 + *(void *)(v18 - 24)) = *(_DWORD *)((unsigned char *)v19 + *(void *)(v18 - 24)) & 0xFFFFFFB5 | 8;
  atomic_ullong v7 = (void *)std::ostream::operator<<();
  sub_1DC31FC84(v7, (uint64_t)".preflight", 10);
  uint64_t v8 = __p;
  sub_1DC32B834(__p, (uint64_t)v19);
  if (v16 < 0) {
    uint64_t v8 = (void **)__p[0];
  }
  uint64_t v9 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  unint64_t v10 = dispatch_queue_attr_make_with_qos_class(v9, QOS_CLASS_UTILITY, -15);
  unsigned int v11 = dispatch_queue_create((const char *)v8, v10);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  CFRetain(a1);
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 0x40000000;
  v14[2] = sub_1DC3C08AC;
  v14[3] = &unk_1E6C3AB08;
  v14[4] = v6;
  v14[5] = a1;
  v14[6] = Copy;
  v14[7] = v11;
  dispatch_async(v11, v14);
  v17[0] = *MEMORY[0x1E4FBA408];
  uint64_t v12 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v17 + *(void *)(v17[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  uint64_t v18 = v12;
  v19[0] = MEMORY[0x1E4FBA470] + 16;
  if (v20 < 0) {
    operator delete((void *)v19[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1E019CE10](&v21);
}

void sub_1DC3C0890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  sub_1DC377C50((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3C08AC(uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    CFTypeID v3 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v3 != qword_1EBFFB818) {
      _os_assumes_log();
    }
  }
  atomic_ullong v19 = *(void *)(a1 + 48);
  if (qword_1EBFFC370 != -1) {
    dispatch_once(&qword_1EBFFC370, &unk_1F3662408);
  }
  uint64_t v4 = v2 + 16;
  unsigned int v5 = qword_1EBFFC3C8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3C8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)unint64_t v30 = 138543362;
    unint64_t v31 = v4 - 16;
    _os_log_debug_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_DEBUG, "Preflighting context: %{public}@", v30, 0xCu);
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    unint64_t v18 = atomic_load_explicit(&v19, memory_order_acquire);
    *(_DWORD *)unint64_t v30 = 138543362;
    unint64_t v31 = v18;
    _os_log_debug_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_DEBUG, "    for decoder using options: %{public}@", v30, 0xCu);
  }
  sub_1DC375140((uint64_t)v30, &v19);
  unint64_t v22 = 0;
  unsigned int v23 = 0;
  uint64_t v24 = 0;
  buf[0] = 0;
  buf[4] = 0;
  if (sub_1DC3778A8((atomic_ullong *)v30, @"AppClipCode", (uint64_t)buf)) {
    sub_1DC3796F8(&v22, (uint64_t)sub_1DC34ABB4);
  }
  if (v32 < 196608)
  {
    sub_1DC3796F8(&v22, (uint64_t)sub_1DC33BAFC);
  }
  else if (v34 || (_os_feature_enabled_impl() & 1) == 0)
  {
    sub_1DC3796F8(&v22, (uint64_t)sub_1DC335170);
  }
  if (_os_feature_enabled_impl() && v32 > 196607) {
    sub_1DC3796F8(&v22, (uint64_t)sub_1DC3485C8);
  }
  if (sub_1DC379140((atomic_ullong *)v30)) {
    sub_1DC3796F8(&v22, (uint64_t)sub_1DC399DD4);
  }
  if (_os_feature_enabled_impl()) {
    sub_1DC3796F8(&v22, (uint64_t)sub_1DC35A630);
  }
  os_signpost_id_t v6 = os_signpost_id_make_with_pointer(v5, (const void *)(v4 - 16));
  atomic_ullong v21 = 0;
  if (os_signpost_enabled(v5))
  {
    *(void *)long long buf = 0;
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v30, memory_order_acquire);
    uint64_t v8 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (explicit
      && CFSetGetCount((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)v30, memory_order_acquire)) >= 1)
    {
      operator new[]();
    }
    if (atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire)) {
      uint64_t v9 = (void *)CFStringCreateByCombiningStrings(*v8, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)buf, memory_order_acquire), @",");
    }
    else {
      uint64_t v9 = (void *)CFRetain(@"<empty>");
    }
    unint64_t v10 = (const void *)atomic_exchange(&v21, (unint64_t)v9);
    if (v10) {
      CFRelease(v10);
    }
    sub_1DC3065EC((atomic_ullong *)buf);
  }
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    unint64_t v11 = atomic_load_explicit(&v21, memory_order_acquire);
    *(_DWORD *)long long buf = 138543874;
    if (v33) {
      uint64_t v12 = "true";
    }
    else {
      uint64_t v12 = "false";
    }
    *(void *)&buf[4] = v11;
    __int16 v26 = 2050;
    uint64_t v27 = v32;
    __int16 v28 = 2082;
    int v29 = v12;
    _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v6, "Context::preflightForDecoderUsingOptions", "symbologies=%{public, signpost.description:attribute}@, algorithmVersion=%{public, signpost.description:attribute}ld, allowsAlgorithmicVersioningFallback=%{public, signpost.description:attribute}s", buf, 0x20u);
  }
  unint64_t v13 = v22;
  int v14 = v23;
  if (v22 == v23)
  {
LABEL_46:
    if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1DC2FE000, v5, OS_SIGNPOST_INTERVAL_END, v6, "Context::preflightForDecoderUsingOptions", (const char *)&unk_1DC429899, buf, 2u);
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138543362;
      *(void *)&buf[4] = v4 - 16;
      _os_log_debug_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_DEBUG, "Preflighted context: %{public}@", buf, 0xCu);
    }
    atomic_ullong v20 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v15 = *((void *)v13 + 3);
      if (!v15) {
        sub_1DC307C38();
      }
      (*(void (**)(atomic_ullong *__return_ptr))(*(void *)v15 + 48))(&v20);
      if (atomic_load_explicit(&v20, memory_order_acquire)) {
        break;
      }
      sub_1DC306854(&v20);
      v13 += 32;
      if (v13 == v14) {
        goto LABEL_46;
      }
    }
  }
  sub_1DC31FA90(&v21);
  *(void *)long long buf = &v22;
  sub_1DC3798D0((void ***)buf);
  sub_1DC374E0C((atomic_ullong *)v30);
  sub_1DC31EBFC(&v19);
  uint64_t v16 = *(void *)(a1 + 32);
  if (v16)
  {
    (*(void (**)(uint64_t, void, unint64_t))(v16 + 16))(v16, *(void *)(a1 + 40), atomic_load_explicit(&v20, memory_order_acquire));
    _Block_release(*(const void **)(a1 + 32));
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 56));
  return sub_1DC306854(&v20);
}

void sub_1DC3C0EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9, uint64_t a10, atomic_ullong a11, char a12, uint64_t a13, uint64_t a14, void **a15, uint64_t a16, uint64_t a17, uint64_t a18, atomic_ullong a19)
{
  a15 = (void **)&a12;
  sub_1DC3798D0(&a15);
  sub_1DC374E0C(&a19);
  sub_1DC31EBFC(&a9);
  _Unwind_Resume(a1);
}

void *MRCContextPurge(char *cf)
{
  context[4] = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v2 != qword_1EBFFB818) {
      _os_assumes_log();
    }
  }
  context[0] = &unk_1F365F028;
  context[1] = cf + 16;
  context[3] = context;
  sub_1DC3C1030((uint64_t)(cf + 16), 0, context);
  return sub_1DC307968(context);
}

void sub_1DC3C101C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC307968((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1DC3C1030(uint64_t a1, char a2, void *context)
{
  if (!context[3]) {
    _os_assumes_log();
  }
  os_signpost_id_t v6 = *(NSObject **)(a1 + 16);
  if (a2)
  {
    dispatch_sync_f(v6, context, (dispatch_function_t)sub_1DC3C1124);
  }
  else
  {
    dispatch_barrier_sync_f(v6, context, (dispatch_function_t)sub_1DC3C10D4);
  }
}

uint64_t sub_1DC3C10D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    sub_1DC307C38();
  }
  CFTypeID v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

uint64_t sub_1DC3C1124(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    sub_1DC307C38();
  }
  CFTypeID v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

void *sub_1DC3C1174()
{
  return &unk_1F365EC58;
}

uint64_t sub_1DC3C1180(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZN3mrc7Context5purgeEvE3$_0")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_1DC3C11BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  os_unfair_lock_lock_with_options();
  if (*(void *)(v1 + 48))
  {
    sub_1DC3C0594(*(void **)(v1 + 40));
    *(void *)(v1 + 40) = 0;
    uint64_t v2 = *(void *)(v1 + 32);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)(v1 + 24) + 8 * i) = 0;
    }
    *(void *)(v1 + 48) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 8));
}

uint64_t sub_1DC3C1240(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F365F028;
  a2[1] = v2;
  return result;
}

void *sub_1DC3C1264(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F365F028;
  result[1] = v3;
  return result;
}

void sub_1DC3C12AC()
{
}

void *MRCContextPerform(void *cf, char a2, uint64_t a3)
{
  context[4] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a3;
  atomic_ullong v7 = cf;
  if (a3)
  {
    uint64_t v4 = cf;
    if (cf)
    {
      CFTypeID v5 = CFGetTypeID(cf);
      if (qword_1EBFFB7E0 != -1) {
        dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
      }
      if (v5 != qword_1EBFFB818) {
        _os_assumes_log();
      }
    }
    context[0] = &unk_1F3661B20;
    context[1] = &v6;
    context[2] = &v7;
    context[3] = context;
    sub_1DC3C1030((uint64_t)(v4 + 2), a2, context);
    return sub_1DC307968(context);
  }
  return cf;
}

void sub_1DC3C13D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1DC307968((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC3C13E4()
{
  return &unk_1F3660948;
}

uint64_t sub_1DC3C13F0(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"Z17MRCContextPerformE3$_0")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void *sub_1DC3C142C(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 8) + 16))(*(void **)(a1 + 8));
}

__n128 sub_1DC3C144C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3661B20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3C1474(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3661B20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC3C14C0()
{
}

void MRCContextPerformAsync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (a3) {
    operator new();
  }
}

void sub_1DC3C1618(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC307968((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1DC3C164C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a3 + 24)) {
    _os_assumes_log();
  }
  operator new();
}

void sub_1DC3C1714(void *a1)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    sub_1DC307968(a1);
    JUMPOUT(0x1E019CE90);
  }
  sub_1DC307C38();
}

void sub_1DC3C178C(void *a1)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    sub_1DC307968(a1);
    JUMPOUT(0x1E019CE90);
  }
  sub_1DC307C38();
}

void *sub_1DC3C1804()
{
  return &unk_1F365EBF8;
}

uint64_t sub_1DC3C1810(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"Z22MRCContextPerformAsyncE3$_0")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_1DC3C184C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  id WeakRetained = objc_loadWeakRetained(*(id **)(a1 + 16));
  (*(void (**)(uint64_t, unint64_t))(v2 + 16))(v2, atomic_load_explicit((atomic_ullong *volatile)&WeakRetained, memory_order_acquire));
  sub_1DC3599F8((atomic_ullong *)&WeakRetained);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    objc_destroyWeak(*(id **)(a1 + 16));
    MEMORY[0x1E019CE90](v3, 0x20C4093837F09);
  }
  _Block_release(*(const void **)(a1 + 8));
}

void sub_1DC3C18D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3599F8((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

__n128 sub_1DC3C18F0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F365EE18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3C1918(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F365EE18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_1DC3C1964()
{
}

void sub_1DC3C197C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*(unsigned char *)(*a1 + 32))
  {
    if (qword_1EAA94E48 != -1) {
      dispatch_once_f(&qword_1EAA94E48, 0, (dispatch_function_t)sub_1DC3C1ABC);
    }
    uint64_t v1 = *a1;
  }
  if (*(unsigned char *)(v1 + 33) && qword_1EAA94E50 != -1)
  {
    dispatch_once_f(&qword_1EAA94E50, 0, (dispatch_function_t)sub_1DC3C1A30);
  }
}

void sub_1DC3C1A30()
{
  if (qword_1EBFFC370 != -1) {
    dispatch_once(&qword_1EBFFC370, &unk_1F3662408);
  }
  uint64_t v0 = qword_1EBFFC3C8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3C8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl(&dword_1DC2FE000, v0, OS_LOG_TYPE_INFO, "Usage of one shot context could bring negative impact in terms of performance due to expensive resource acquisitions. Please consider creating you own context and share them across decoders appropriately.", v1, 2u);
  }
}

void sub_1DC3C1ABC()
{
  if (qword_1EBFFC370 != -1) {
    dispatch_once(&qword_1EBFFC370, &unk_1F3662408);
  }
  uint64_t v0 = qword_1EBFFC3C8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3C8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl(&dword_1DC2FE000, v0, OS_LOG_TYPE_INFO, "Usage of global context could leave resources without deallocations during the entire process lifecycle. Please consider creating your own context as needed.", v1, 2u);
  }
}

atomic_ullong *sub_1DC3C1B48(void *a1, int a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    if (a2) {
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"usesANEOnly");
    }
    if ((a2 & 2) != 0) {
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"prohibitsIntegratedGPU");
    }
    if ((a2 & 4) != 0) {
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"allowsCPU");
    }
    if ((a2 & 0x1000000) != 0) {
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"_prohibitsANE");
    }
    if ((a2 & 0x2000000) != 0) {
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"_prohibitsGPU");
    }
    if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))) {
      CFTypeID v5 = (void *)CFStringCreateByCombiningStrings(v4, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @", ");
    }
    else {
      CFTypeID v5 = (void *)CFRetain(@"<empty>");
    }
  }
  else
  {
    CFTypeID v5 = 0;
  }
  *a1 = v5;
  return sub_1DC3070BC((atomic_ullong *)&Mutable);
}

void sub_1DC3C1C70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3070BC((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3C1C84(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if (!v1) {
    sub_1DC307C38();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
  return v2();
}

void *sub_1DC3C1CD4(uint64_t a1)
{
  return sub_1DC307968((void *)(a1 + 32));
}

uint64_t sub_1DC3C1CDC(uint64_t a1, uint64_t a2)
{
  return sub_1DC307AF0(a1 + 32, a2 + 32);
}

uint64_t sub_1DC3C1CE8(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t *a4)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = *a3;
  uint64_t v5 = *a4;
  *a4 = 0;
  *(void *)(a1 + 24) = v5;
  uint64_t v6 = (void *)(a1 + 24);
  sub_1DC32E8C0(a1 + 32, (uint64_t)(a4 + 1));
  if (!*(void *)a1) {
    _os_assumes_log();
  }
  if (!*v6) {
    _os_assumes_log();
  }
  return a1;
}

void sub_1DC3C1D60(_Unwind_Exception *a1)
{
  sub_1DC32E940(v2);
  sub_1DC32E9A8(v1);
  _Unwind_Resume(a1);
}

void sub_1DC3C1D80()
{
}

void sub_1DC3C1EDC(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  MEMORY[0x1E019CE90](v3, 0x20C40A4A59CD2);
  sub_1DC3599F8(v1);
  MEMORY[0x1E019CE90](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

void sub_1DC3C1F54(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)(a1 + 8));
  objc_destroyWeak((id *)a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC3C1FAC(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uintptr_t data = dispatch_source_get_data(*(dispatch_source_t *)(a1 + 8));
  if (data == 1)
  {
    int v4 = 0;
    uint64_t v3 = "normal";
  }
  else
  {
    if (data == 4) {
      uint64_t v3 = "critical";
    }
    else {
      uint64_t v3 = "warn";
    }
    int v4 = 1;
  }
  if (qword_1EBFFC370 != -1) {
    dispatch_once(&qword_1EBFFC370, &unk_1F3662408);
  }
  uint64_t v5 = qword_1EBFFC3C8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136446210;
    unint64_t v10 = (unint64_t)v3;
    _os_log_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_DEFAULT, "GlobalContext: received memory pressure: %{public}s", buf, 0xCu);
  }
  if (v4)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_DEBUG, "GlobalContext: will purge", buf, 2u);
    }
    id WeakRetained = objc_loadWeakRetained((id *)a1);
    if (atomic_load_explicit((atomic_ullong *volatile)&WeakRetained, memory_order_acquire))
    {
      MRCContextPurge((char *)atomic_load_explicit((atomic_ullong *volatile)&WeakRetained, memory_order_acquire));
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&WeakRetained, memory_order_acquire);
        *(_DWORD *)long long buf = 138543362;
        unint64_t v10 = explicit;
        _os_log_debug_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_DEBUG, "GlobalContext: %{public}@", buf, 0xCu);
      }
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_20;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v6 = "GlobalContext: purged";
    }
    else
    {
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
LABEL_20:
        sub_1DC3599F8((atomic_ullong *)&WeakRetained);
        return;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v6 = "GlobalContext: already deallocated";
    }
    _os_log_debug_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_DEBUG, v6, buf, 2u);
    goto LABEL_20;
  }
}

void sub_1DC3C21D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3599F8((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

uint64_t MRCDescriptorGetTypeID()
{
  if (qword_1EAA94E90 != -1) {
    dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
  }
  return qword_1EAA94E98;
}

unint64_t MRCDescriptorCreateWithAttributes(const void *a1)
{
  uint64_t v8 = sub_1DC34D67C();
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire);
  if (a1) {
    CFTypeRef v3 = CFRetain(a1);
  }
  else {
    CFTypeRef v3 = 0;
  }
  CFTypeRef v7 = v3;
  CFDictionaryRef v4 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire);
  if (v4)
  {
    context[0] = 1;
    unint64_t v10 = explicit + 16;
    CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)sub_1DC3C2308, context);
  }
  sub_1DC31EBFC((atomic_ullong *)&v7);
  unint64_t v5 = atomic_exchange((atomic_ullong *volatile)&v8, 0);
  sub_1DC3073A4((atomic_ullong *)&v8);
  return v5;
}

void sub_1DC3C22E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9, atomic_ullong a10)
{
}

atomic_ullong *sub_1DC3C2308(CFTypeRef a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 8);
  if (a1) {
    a1 = CFRetain(a1);
  }
  CFTypeRef v13 = a1;
  if (cf) {
    CFTypeRef v6 = CFRetain(cf);
  }
  else {
    CFTypeRef v6 = 0;
  }
  CFTypeRef v12 = v6;
  if (qword_1EAA94E70 != -1) {
    dispatch_once_f(&qword_1EAA94E70, 0, (dispatch_function_t)sub_1DC3C2414);
  }
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
  if (explicit
    && (CFBooleanRef Value = (uint64_t (*)(uint64_t, CFTypeRef *))CFDictionaryGetValue((CFDictionaryRef)qword_1EAA94E68, explicit)) != 0)
  {
    char v9 = Value(v5, &v12);
  }
  else
  {
    char v9 = 0;
  }
  sub_1DC31EB58((atomic_ullong *)&v12);
  __n128 result = sub_1DC31FA90((atomic_ullong *)&v13);
  if (*(unsigned char *)a3) {
    char v11 = v9;
  }
  else {
    char v11 = 0;
  }
  *(unsigned char *)a3 = v11;
  return result;
}

void sub_1DC3C23F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC31FA90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

CFDictionaryRef sub_1DC3C2414()
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  long long v10 = xmmword_1F3664E28;
  long long v11 = *(_OWORD *)&off_1F3664E38;
  long long v12 = xmmword_1F3664E48;
  long long v13 = *(_OWORD *)off_1F3664E58;
  long long v6 = xmmword_1F3664DE8;
  long long v7 = *(_OWORD *)&off_1F3664DF8;
  long long v8 = xmmword_1F3664E08;
  long long v9 = *(_OWORD *)&off_1F3664E18;
  *(_OWORD *)values = xmmword_1F3664DA8;
  long long v3 = *(_OWORD *)&off_1F3664DB8;
  long long v4 = xmmword_1F3664DC8;
  long long v5 = *(_OWORD *)&off_1F3664DD8;
  memset(&v1, 0, sizeof(v1));
  CFDictionaryRef result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)off_1E6C3ABF0, (const void **)values, 24, MEMORY[0x1E4F1D530], &v1);
  qword_1EAA94E68 = (uint64_t)result;
  return result;
}

uint64_t sub_1DC3C24DC(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 204) && *(unsigned char *)(a1 + 203)) {
      *(unsigned char *)(a1 + 203) = 0;
    }
    return 1;
  }
  unsigned int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      __int16 v7 = valuePtr;
      if (valuePtr > 0xFF) {
        return 0;
      }
      if (!*(unsigned char *)(a1 + 204))
      {
        *(_DWORD *)(a1 + 200) = 0;
        *(unsigned char *)(a1 + 204) = 1;
      }
      *(_WORD *)(a1 + 202) = v7 | 0x100;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1DC3C259C(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 204) && *(unsigned char *)(a1 + 201)) {
      *(unsigned char *)(a1 + 201) = 0;
    }
    return 1;
  }
  unsigned int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      __int16 v7 = valuePtr;
      if (valuePtr > 0xFF) {
        return 0;
      }
      if (!*(unsigned char *)(a1 + 204))
      {
        *(_DWORD *)(a1 + 200) = 0;
        *(unsigned char *)(a1 + 204) = 1;
      }
      *(_WORD *)(a1 + 200) = v7 | 0x100;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1DC3C265C(uint64_t a1, atomic_ullong *a2)
{
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    if (!*(unsigned char *)(a1 + 192))
    {
      *(void *)(a1 + 184) = 0;
      *(_OWORD *)(a1 + 168) = 0u;
      *(_OWORD *)(a1 + 152) = 0u;
      *(unsigned char *)(a1 + 192) = 1;
    }
    sub_1DC32D8E8((atomic_ullong *)(a1 + 184), (CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  }
  else if (*(unsigned char *)(a1 + 192))
  {
    uint64_t v2 = (const void *)atomic_exchange((atomic_ullong *volatile)(a1 + 184), 0);
    if (v2) {
      CFRelease(v2);
    }
  }
  return 1;
}

uint64_t sub_1DC3C26C0(uint64_t a1, atomic_ullong *a2)
{
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    uint64_t valuePtr = 0;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
    if (v4 == CFNumberGetTypeID())
    {
      uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberCFIndexType, &valuePtr);
      if (result)
      {
        if (!*(unsigned char *)(a1 + 192))
        {
          *(void *)(a1 + 184) = 0;
          *(_OWORD *)(a1 + 168) = 0u;
          *(_OWORD *)(a1 + 152) = 0u;
          *(unsigned char *)(a1 + 192) = 1;
        }
        *(void *)(a1 + 168) = valuePtr;
        uint64_t result = 1;
        *(unsigned char *)(a1 + 176) = 1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 192) && *(unsigned char *)(a1 + 176)) {
      *(unsigned char *)(a1 + 176) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_1DC3C2780(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 192)) {
      *(void *)(a1 + 160) = 0;
    }
    return 1;
  }
  uint64_t valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  if (v4 == CFNumberGetTypeID())
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberCFIndexType, &valuePtr);
    if (!result) {
      return result;
    }
    if (!*(unsigned char *)(a1 + 192))
    {
      *(void *)(a1 + 184) = 0;
      *(_OWORD *)(a1 + 168) = 0u;
      *(_OWORD *)(a1 + 152) = 0u;
      *(unsigned char *)(a1 + 192) = 1;
    }
    *(void *)(a1 + 160) = valuePtr;
    return 1;
  }
  return 0;
}

uint64_t sub_1DC3C2830(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 192)) {
      *(unsigned char *)(a1 + 152) = 0;
    }
    return 1;
  }
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  if (v4 == CFBooleanGetTypeID())
  {
    long long v5 = (_OWORD *)(a1 + 152);
    if (!*(unsigned char *)(a1 + 192))
    {
      *(void *)(a1 + 184) = 0;
      *long long v5 = 0u;
      *(_OWORD *)(a1 + 168) = 0u;
      *(unsigned char *)(a1 + 192) = 1;
    }
    *(unsigned char *)long long v5 = CFBooleanGetValue((CFBooleanRef)atomic_load_explicit(a2, memory_order_acquire)) != 0;
    return 1;
  }
  return 0;
}

uint64_t sub_1DC3C28CC(uint64_t a1, atomic_ullong *a2)
{
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    int valuePtr = 0;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
    CFTypeID TypeID = CFNumberGetTypeID();
    uint64_t result = 0;
    if (v4 == TypeID)
    {
      uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
      if (result)
      {
        if (!*(unsigned char *)(a1 + 148))
        {
          *(void *)(a1 + 128) = 0;
          *(void *)(a1 + 136) = 0;
          *(_DWORD *)(a1 + 144) = 0;
          *(unsigned char *)(a1 + 148) = 1;
        }
        *(_DWORD *)(a1 + 136) = valuePtr;
        uint64_t result = 1;
        *(unsigned char *)(a1 + 140) = 1;
      }
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 148) && *(unsigned char *)(a1 + 140)) {
      *(unsigned char *)(a1 + 140) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_1DC3C2984(uint64_t a1, atomic_ullong *a2)
{
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    int valuePtr = 0;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
    CFTypeID TypeID = CFNumberGetTypeID();
    uint64_t result = 0;
    if (v4 == TypeID)
    {
      uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
      if (result)
      {
        if (!*(unsigned char *)(a1 + 148))
        {
          *(void *)(a1 + 128) = 0;
          *(void *)(a1 + 136) = 0;
          *(_DWORD *)(a1 + 144) = 0;
          *(unsigned char *)(a1 + 148) = 1;
        }
        *(_DWORD *)(a1 + 128) = valuePtr;
        uint64_t result = 1;
        *(unsigned char *)(a1 + 132) = 1;
      }
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 148) && *(unsigned char *)(a1 + 132)) {
      *(unsigned char *)(a1 + 132) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_1DC3C2A40(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 148) && *(unsigned char *)(a1 + 145)) {
      *(unsigned char *)(a1 + 145) = 0;
    }
    return 1;
  }
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  if (v4 == CFBooleanGetTypeID())
  {
    if (!*(unsigned char *)(a1 + 148))
    {
      *(void *)(a1 + 128) = 0;
      *(void *)(a1 + 136) = 0;
      *(_DWORD *)(a1 + 144) = 0;
      *(unsigned char *)(a1 + 148) = 1;
    }
    *(_WORD *)(a1 + 144) = (CFBooleanGetValue((CFBooleanRef)atomic_load_explicit(a2, memory_order_acquire)) != 0) | 0x100;
    return 1;
  }
  return 0;
}

uint64_t sub_1DC3C2AE0(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 120)) {
      sub_1DC3C2BA4((void **)(a1 + 96), 20);
    }
    return 1;
  }
  int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      __int16 v7 = (uint64_t **)(a1 + 96);
      if (!*(unsigned char *)(a1 + 120))
      {
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        uint64_t v8 = a1 + 104;
        *(void *)(v8 - 8) = v8;
        *(unsigned char *)(v8 + 16) = 1;
      }
      int v9 = valuePtr;
      *((_DWORD *)sub_1DC3116FC(v7, 20, &dword_1DC4162B8) + 8) = v9;
      return 1;
    }
  }
  return result;
}

void sub_1DC3C2BA4(void **a1, int a2)
{
  long long v3 = a1 + 1;
  uint64_t v2 = (char *)a1[1];
  if (!v2) {
    return;
  }
  long long v5 = a1 + 1;
  long long v6 = v2;
  do
  {
    int v7 = *((_DWORD *)v6 + 7);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (void **)v6;
    }
    else {
      int v9 = (void **)(v6 + 8);
    }
    if (!v8) {
      long long v5 = v6;
    }
    long long v6 = (char *)*v9;
  }
  while (*v9);
  if (v5 == (_DWORD *)v3 || v5[7] > a2) {
    return;
  }
  long long v10 = (void *)*((void *)v5 + 1);
  if (v10)
  {
    do
    {
      long long v11 = v10;
      long long v10 = (void *)*v10;
    }
    while (v10);
  }
  else
  {
    long long v12 = v5;
    do
    {
      long long v11 = (void *)*((void *)v12 + 2);
      BOOL v32 = *v11 == (void)v12;
      long long v12 = v11;
    }
    while (!v32);
  }
  if (*a1 == v5) {
    *a1 = v11;
  }
  a1[2] = (char *)a1[2] - 1;
  uint64_t v13 = *(void *)v5;
  uint64_t v14 = (char *)v5;
  if (*(void *)v5)
  {
    uint64_t v15 = (char *)*((void *)v5 + 1);
    if (!v15)
    {
      uint64_t v14 = (char *)v5;
      goto LABEL_26;
    }
    do
    {
      uint64_t v14 = v15;
      uint64_t v15 = *(char **)v15;
    }
    while (v15);
  }
  uint64_t v13 = *((void *)v14 + 1);
  if (v13)
  {
LABEL_26:
    int v16 = 0;
    *(void *)(v13 + 16) = *((void *)v14 + 2);
    goto LABEL_27;
  }
  int v16 = 1;
LABEL_27:
  unint64_t v17 = (char **)*((void *)v14 + 2);
  unint64_t v18 = *v17;
  if (*v17 == v14)
  {
    _DWORD *v17 = (char *)v13;
    if (v14 == v2)
    {
      unint64_t v18 = 0;
      uint64_t v2 = (char *)v13;
    }
    else
    {
      unint64_t v18 = v17[1];
    }
  }
  else
  {
    v17[1] = (char *)v13;
  }
  int v19 = v14[24];
  if (v14 != (char *)v5)
  {
    uint64_t v20 = *((void *)v5 + 2);
    *((void *)v14 + 2) = v20;
    *(void *)(v20 + 8 * (**((void **)v5 + 2) != (void)v5)) = v14;
    uint64_t v22 = *(void *)v5;
    uint64_t v21 = *((void *)v5 + 1);
    *(void *)(v22 + 16) = v14;
    *(void *)uint64_t v14 = v22;
    *((void *)v14 + 1) = v21;
    if (v21) {
      *(void *)(v21 + 16) = v14;
    }
    v14[24] = *((unsigned char *)v5 + 24);
    if (v2 == (char *)v5) {
      uint64_t v2 = v14;
    }
  }
  if (!v19 || !v2) {
    goto LABEL_70;
  }
  if (!v16)
  {
    *(unsigned char *)(v13 + 24) = 1;
    goto LABEL_70;
  }
  while (1)
  {
    uint64_t v23 = *((void *)v18 + 2);
    if (*(char **)v23 != v18) {
      break;
    }
    if (!v18[24])
    {
      v18[24] = 1;
      *(unsigned char *)(v23 + 24) = 0;
      uint64_t v29 = *((void *)v18 + 1);
      *(void *)uint64_t v23 = v29;
      if (v29) {
        *(void *)(v29 + 16) = v23;
      }
      *((void *)v18 + 2) = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v18;
      *((void *)v18 + 1) = v23;
      *(void *)(v23 + 16) = v18;
      if (v2 == (char *)v23) {
        uint64_t v2 = v18;
      }
      unint64_t v18 = *(char **)v23;
    }
    unint64_t v30 = *(char **)v18;
    if (*(void *)v18 && !v30[24]) {
      goto LABEL_87;
    }
    unint64_t v31 = (uint64_t *)*((void *)v18 + 1);
    if (v31 && !*((unsigned char *)v31 + 24))
    {
      if (v30 && !v30[24])
      {
LABEL_87:
        unint64_t v31 = (uint64_t *)v18;
      }
      else
      {
        *((unsigned char *)v31 + 24) = 1;
        v18[24] = 0;
        uint64_t v37 = *v31;
        *((void *)v18 + 1) = *v31;
        if (v37) {
          *(void *)(v37 + 16) = v18;
        }
        v31[2] = *((void *)v18 + 2);
        *(void *)(*((void *)v18 + 2) + 8 * (**((void **)v18 + 2) != (void)v18)) = v31;
        *unint64_t v31 = (uint64_t)v18;
        *((void *)v18 + 2) = v31;
        unint64_t v30 = v18;
      }
      uint64_t v34 = v31[2];
      *((unsigned char *)v31 + 24) = *(unsigned char *)(v34 + 24);
      *(unsigned char *)(v34 + 24) = 1;
      v30[24] = 1;
      uint64_t v35 = *(uint64_t **)v34;
      uint64_t v38 = *(void *)(*(void *)v34 + 8);
      *(void *)uint64_t v34 = v38;
      if (v38) {
        *(void *)(v38 + 16) = v34;
      }
      v35[2] = *(void *)(v34 + 16);
      *(void *)(*(void *)(v34 + 16) + 8 * (**(void **)(v34 + 16) != v34)) = v35;
      v35[1] = v34;
      goto LABEL_91;
    }
    v18[24] = 0;
    __int16 v28 = (char *)*((void *)v18 + 2);
    if (v28[24]) {
      BOOL v32 = v28 == v2;
    }
    else {
      BOOL v32 = 1;
    }
    if (v32) {
      goto LABEL_72;
    }
LABEL_68:
    unint64_t v18 = *(char **)(*((void *)v28 + 2) + 8 * (**((void **)v28 + 2) == (void)v28));
  }
  if (!v18[24])
  {
    v18[24] = 1;
    *(unsigned char *)(v23 + 24) = 0;
    uint64_t v24 = *(uint64_t **)(v23 + 8);
    uint64_t v25 = *v24;
    *(void *)(v23 + 8) = *v24;
    if (v25) {
      *(void *)(v25 + 16) = v23;
    }
    v24[2] = *(void *)(v23 + 16);
    *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
    *uint64_t v24 = v23;
    *(void *)(v23 + 16) = v24;
    if (v2 == *(char **)v18) {
      uint64_t v2 = v18;
    }
    unint64_t v18 = *(char **)(*(void *)v18 + 8);
  }
  __int16 v26 = *(char **)v18;
  if (!*(void *)v18 || v26[24])
  {
    uint64_t v27 = (char *)*((void *)v18 + 1);
    if (v27 && !v27[24]) {
      goto LABEL_78;
    }
    v18[24] = 0;
    __int16 v28 = (char *)*((void *)v18 + 2);
    if (v28 == v2)
    {
      __int16 v28 = v2;
LABEL_72:
      v28[24] = 1;
      goto LABEL_70;
    }
    if (!v28[24]) {
      goto LABEL_72;
    }
    goto LABEL_68;
  }
  uint64_t v27 = (char *)*((void *)v18 + 1);
  if (v27 && !v27[24])
  {
LABEL_78:
    __int16 v26 = v18;
  }
  else
  {
    v26[24] = 1;
    v18[24] = 0;
    uint64_t v33 = *((void *)v26 + 1);
    *(void *)unint64_t v18 = v33;
    if (v33) {
      *(void *)(v33 + 16) = v18;
    }
    *((void *)v26 + 2) = *((void *)v18 + 2);
    *(void *)(*((void *)v18 + 2) + 8 * (**((void **)v18 + 2) != (void)v18)) = v26;
    *((void *)v26 + 1) = v18;
    *((void *)v18 + 2) = v26;
    uint64_t v27 = v18;
  }
  uint64_t v34 = *((void *)v26 + 2);
  v26[24] = *(unsigned char *)(v34 + 24);
  *(unsigned char *)(v34 + 24) = 1;
  v27[24] = 1;
  uint64_t v35 = *(uint64_t **)(v34 + 8);
  uint64_t v36 = *v35;
  *(void *)(v34 + 8) = *v35;
  if (v36) {
    *(void *)(v36 + 16) = v34;
  }
  v35[2] = *(void *)(v34 + 16);
  *(void *)(*(void *)(v34 + 16) + 8 * (**(void **)(v34 + 16) != v34)) = v35;
  *uint64_t v35 = v34;
LABEL_91:
  *(void *)(v34 + 16) = v35;
LABEL_70:
  operator delete(v5);
}

uint64_t sub_1DC3C2FC0(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 120)) {
      sub_1DC3C2BA4((void **)(a1 + 96), 21);
    }
    return 1;
  }
  int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      int v7 = (uint64_t **)(a1 + 96);
      if (!*(unsigned char *)(a1 + 120))
      {
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        uint64_t v8 = a1 + 104;
        *(void *)(v8 - 8) = v8;
        *(unsigned char *)(v8 + 16) = 1;
      }
      int v9 = valuePtr;
      *((_DWORD *)sub_1DC3116FC(v7, 21, &dword_1DC4162BC) + 8) = v9;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1DC3C3084(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 120)) {
      sub_1DC3C2BA4((void **)(a1 + 96), 22);
    }
    return 1;
  }
  int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      int v7 = (uint64_t **)(a1 + 96);
      if (!*(unsigned char *)(a1 + 120))
      {
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        uint64_t v8 = a1 + 104;
        *(void *)(v8 - 8) = v8;
        *(unsigned char *)(v8 + 16) = 1;
      }
      int v9 = valuePtr;
      *((_DWORD *)sub_1DC3116FC(v7, 22, dword_1DC4162C0) + 8) = v9;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1DC3C3148(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 120)) {
      sub_1DC3C2BA4((void **)(a1 + 96), 17);
    }
    return 1;
  }
  int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      int v7 = (uint64_t **)(a1 + 96);
      if (!*(unsigned char *)(a1 + 120))
      {
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        uint64_t v8 = a1 + 104;
        *(void *)(v8 - 8) = v8;
        *(unsigned char *)(v8 + 16) = 1;
      }
      int v9 = valuePtr;
      *((_DWORD *)sub_1DC3116FC(v7, 17, &dword_1DC4162AC) + 8) = v9;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1DC3C320C(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 120)) {
      sub_1DC3C2BA4((void **)(a1 + 96), 16);
    }
    return 1;
  }
  int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      int v7 = (uint64_t **)(a1 + 96);
      if (!*(unsigned char *)(a1 + 120))
      {
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        uint64_t v8 = a1 + 104;
        *(void *)(v8 - 8) = v8;
        *(unsigned char *)(v8 + 16) = 1;
      }
      int v9 = valuePtr;
      *((_DWORD *)sub_1DC3116FC(v7, 16, &dword_1DC4162A8) + 8) = v9;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1DC3C32D0(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 120)) {
      sub_1DC3C2BA4((void **)(a1 + 96), 18);
    }
    return 1;
  }
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  if (v4 == CFBooleanGetTypeID())
  {
    long long v5 = (uint64_t **)(a1 + 96);
    if (!*(unsigned char *)(a1 + 120))
    {
      *(void *)(a1 + 104) = 0;
      *(void *)(a1 + 112) = 0;
      uint64_t v6 = a1 + 104;
      *(void *)(v6 - 8) = v6;
      *(unsigned char *)(v6 + 16) = 1;
    }
    int Value = CFBooleanGetValue((CFBooleanRef)atomic_load_explicit(a2, memory_order_acquire));
    *((_DWORD *)sub_1DC3116FC(v5, 18, &dword_1DC4162B0) + 8) = Value;
    return 1;
  }
  return 0;
}

uint64_t sub_1DC3C3380(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 120)) {
      sub_1DC3C2BA4((void **)(a1 + 96), 13);
    }
    return 1;
  }
  int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      int v7 = (uint64_t **)(a1 + 96);
      if (!*(unsigned char *)(a1 + 120))
      {
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        uint64_t v8 = a1 + 104;
        *(void *)(v8 - 8) = v8;
        *(unsigned char *)(v8 + 16) = 1;
      }
      int v9 = valuePtr;
      *((_DWORD *)sub_1DC3116FC(v7, 13, &dword_1DC4162A0) + 8) = v9;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1DC3C3444(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 120)) {
      sub_1DC3C2BA4((void **)(a1 + 96), 8);
    }
    return 1;
  }
  int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      int v7 = (uint64_t **)(a1 + 96);
      if (!*(unsigned char *)(a1 + 120))
      {
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        uint64_t v8 = a1 + 104;
        *(void *)(v8 - 8) = v8;
        *(unsigned char *)(v8 + 16) = 1;
      }
      int v9 = valuePtr;
      *((_DWORD *)sub_1DC3116FC(v7, 8, (unsigned int *)"\b") + 8) = v9;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1DC3C3508(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 120)) {
      sub_1DC3C2BA4((void **)(a1 + 96), 12);
    }
    return 1;
  }
  int valuePtr = 0;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  CFTypeID TypeID = CFNumberGetTypeID();
  uint64_t result = 0;
  if (v4 == TypeID)
  {
    uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberIntType, &valuePtr);
    if (result)
    {
      int v7 = (uint64_t **)(a1 + 96);
      if (!*(unsigned char *)(a1 + 120))
      {
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        uint64_t v8 = a1 + 104;
        *(void *)(v8 - 8) = v8;
        *(unsigned char *)(v8 + 16) = 1;
      }
      int v9 = valuePtr;
      *((_DWORD *)sub_1DC3116FC(v7, 12, &dword_1DC41629C) + 8) = v9;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1DC3C35CC(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (*(unsigned char *)(a1 + 89)) {
      *(unsigned char *)(a1 + 89) = 0;
    }
    return 1;
  }
  CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
  if (v4 == CFBooleanGetTypeID())
  {
    *(_WORD *)(a1 + 88) = (CFBooleanGetValue((CFBooleanRef)atomic_load_explicit(a2, memory_order_acquire)) != 0) | 0x100;
    return 1;
  }
  return 0;
}

BOOL sub_1DC3C364C(uint64_t a1, atomic_ullong *a2)
{
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
    if (v4 == CFArrayGetTypeID())
    {
      unsigned int __p = 0;
      __int16 v26 = 0;
      unint64_t v27 = 0;
      CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(a2, memory_order_acquire));
      sub_1DC3C3878(&__p, Count);
      CFIndex v6 = CFArrayGetCount((CFArrayRef)atomic_load_explicit(a2, memory_order_acquire));
      if (v6 < 1)
      {
        BOOL v7 = 1;
LABEL_33:
        sub_1DC3C392C(a1 + 56, (uint64_t)&__p);
      }
      else
      {
        BOOL v7 = 0;
        CFIndex v8 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(a2, memory_order_acquire), v8);
          CFDictionaryRef v10 = ValueAtIndex;
          if (!ValueAtIndex) {
            break;
          }
          CFTypeID v11 = CFGetTypeID(ValueAtIndex);
          if (v11 != CFDictionaryGetTypeID() || !CGPointMakeWithDictionaryRepresentation(v10, &point)) {
            break;
          }
          long long v12 = v26;
          if ((unint64_t)v26 >= v27)
          {
            uint64_t v14 = (CGPoint *)__p;
            uint64_t v15 = ((char *)v26 - (unsigned char *)__p) >> 4;
            unint64_t v16 = v15 + 1;
            if ((unint64_t)(v15 + 1) >> 60) {
              sub_1DC2FF97C();
            }
            uint64_t v17 = v27 - (void)__p;
            if ((uint64_t)(v27 - (void)__p) >> 3 > v16) {
              unint64_t v16 = v17 >> 3;
            }
            if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v18 = v16;
            }
            if (v18) {
              unint64_t v18 = (unint64_t)sub_1DC300068(v18);
            }
            else {
              uint64_t v19 = 0;
            }
            uint64_t v20 = (CGPoint *)(v18 + 16 * v15);
            *uint64_t v20 = point;
            uint64_t v21 = v20;
            if (v12 != v14)
            {
              do
              {
                v21[-1] = v12[-1];
                --v21;
                --v12;
              }
              while (v12 != v14);
              long long v12 = (CGPoint *)__p;
            }
            uint64_t v13 = v20 + 1;
            unsigned int __p = v21;
            unint64_t v27 = v18 + 16 * v19;
            if (v12) {
              operator delete(v12);
            }
          }
          else
          {
            *__int16 v26 = point;
            uint64_t v13 = v12 + 1;
          }
          __int16 v26 = v13;
          BOOL v7 = ++v8 >= v6;
          if (v8 == v6) {
            goto LABEL_33;
          }
        }
      }
      if (__p) {
        operator delete(__p);
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 80))
    {
      uint64_t v22 = *(void **)(a1 + 56);
      if (v22)
      {
        *(void *)(a1 + 64) = v22;
        operator delete(v22);
      }
      *(unsigned char *)(a1 + 80) = 0;
    }
    return 1;
  }
  return v7;
}

void sub_1DC3C3850(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC3C3878(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4)
  {
    if (a2 >> 60) {
      sub_1DC2FF97C();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    CFTypeID v4 = (char *)sub_1DC300068(a2);
    long long v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF0];
    BOOL v7 = &v4[16 * v6];
    int v9 = (char *)*a1;
    CFIndex v8 = (char *)a1[1];
    CFDictionaryRef v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        *((_OWORD *)v10 - 1) = *((_OWORD *)v8 - 1);
        v10 -= 16;
        v8 -= 16;
      }
      while (v8 != v9);
      CFIndex v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t sub_1DC3C392C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    CFTypeID v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v4;
      operator delete(v4);
    }
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  return a1;
}

BOOL sub_1DC3C3994(uint64_t a1, atomic_ullong *a2)
{
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
    if (v4 == CFArrayGetTypeID())
    {
      unsigned int __p = 0;
      __int16 v26 = 0;
      unint64_t v27 = 0;
      CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(a2, memory_order_acquire));
      sub_1DC3C3878(&__p, Count);
      CFIndex v6 = CFArrayGetCount((CFArrayRef)atomic_load_explicit(a2, memory_order_acquire));
      if (v6 < 1)
      {
        BOOL v7 = 1;
LABEL_33:
        sub_1DC3C392C(a1 + 24, (uint64_t)&__p);
      }
      else
      {
        BOOL v7 = 0;
        CFIndex v8 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(a2, memory_order_acquire), v8);
          CFDictionaryRef v10 = ValueAtIndex;
          if (!ValueAtIndex) {
            break;
          }
          CFTypeID v11 = CFGetTypeID(ValueAtIndex);
          if (v11 != CFDictionaryGetTypeID() || !CGPointMakeWithDictionaryRepresentation(v10, &point)) {
            break;
          }
          long long v12 = v26;
          if ((unint64_t)v26 >= v27)
          {
            uint64_t v14 = (CGPoint *)__p;
            uint64_t v15 = ((char *)v26 - (unsigned char *)__p) >> 4;
            unint64_t v16 = v15 + 1;
            if ((unint64_t)(v15 + 1) >> 60) {
              sub_1DC2FF97C();
            }
            uint64_t v17 = v27 - (void)__p;
            if ((uint64_t)(v27 - (void)__p) >> 3 > v16) {
              unint64_t v16 = v17 >> 3;
            }
            if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v18 = v16;
            }
            if (v18) {
              unint64_t v18 = (unint64_t)sub_1DC300068(v18);
            }
            else {
              uint64_t v19 = 0;
            }
            uint64_t v20 = (CGPoint *)(v18 + 16 * v15);
            *uint64_t v20 = point;
            uint64_t v21 = v20;
            if (v12 != v14)
            {
              do
              {
                v21[-1] = v12[-1];
                --v21;
                --v12;
              }
              while (v12 != v14);
              long long v12 = (CGPoint *)__p;
            }
            uint64_t v13 = v20 + 1;
            unsigned int __p = v21;
            unint64_t v27 = v18 + 16 * v19;
            if (v12) {
              operator delete(v12);
            }
          }
          else
          {
            *__int16 v26 = point;
            uint64_t v13 = v12 + 1;
          }
          __int16 v26 = v13;
          BOOL v7 = ++v8 >= v6;
          if (v8 == v6) {
            goto LABEL_33;
          }
        }
      }
      if (__p) {
        operator delete(__p);
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 48))
    {
      uint64_t v22 = *(void **)(a1 + 24);
      if (v22)
      {
        *(void *)(a1 + 32) = v22;
        operator delete(v22);
      }
      *(unsigned char *)(a1 + 48) = 0;
    }
    return 1;
  }
  return v7;
}

void sub_1DC3C3B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3C3BC0(uint64_t a1, atomic_ullong *a2)
{
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    int valuePtr = 0;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)atomic_load_explicit(a2, memory_order_acquire));
    CFTypeID TypeID = CFNumberGetTypeID();
    uint64_t result = 0;
    if (v4 == TypeID)
    {
      uint64_t result = CFNumberGetValue((CFNumberRef)atomic_load_explicit(a2, memory_order_acquire), kCFNumberFloatType, &valuePtr);
      if (result)
      {
        *(_DWORD *)(a1 + 16) = valuePtr;
        uint64_t result = 1;
        *(unsigned char *)(a1 + 20) = 1;
      }
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 20)) {
      *(unsigned char *)(a1 + 20) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_1DC3C3C58(uint64_t a1, atomic_ullong *a2)
{
  return 1;
}

uint64_t sub_1DC3C3C7C(atomic_ullong *a1, atomic_ullong *a2)
{
  return 1;
}

unint64_t MRCDescriptorCopyAttributes(char *cf)
{
  void (*v8)(CFDictionaryRef *__return_ptr, char *);
  unint64_t v9;
  CFTypeRef v11;
  CFDictionaryRef Copy;

  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (qword_1EAA94E90 != -1) {
      dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
    }
    if (v2 != qword_1EAA94E98) {
      _os_assumes_log();
    }
  }
  int64_t v3 = cf + 16;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 24, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  for (uint64_t i = 0; i != 24; ++i)
  {
    BOOL v7 = off_1E6C3ABF0[i];
    CFTypeID v11 = CFRetain(v7);
    CFIndex v8 = (void (*)(CFDictionaryRef *__return_ptr, char *))sub_1DC3C3E44((atomic_ullong *)&v11);
    if (v8) {
      v8(&Copy, v3);
    }
    else {
      CFDictionaryRef Copy = 0;
    }
    sub_1DC31FA90((atomic_ullong *)&v11);
    if (atomic_load_explicit((atomic_ullong *volatile)&Copy, memory_order_acquire)) {
      CFDictionarySetValue(Mutable, v7, (const void *)atomic_load_explicit((atomic_ullong *volatile)&Copy, memory_order_acquire));
    }
    sub_1DC31EB58((atomic_ullong *)&Copy);
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy(v4, Mutable);
  CFRelease(Mutable);
  int v9 = atomic_exchange((atomic_ullong *volatile)&Copy, 0);
  sub_1DC31EBFC((atomic_ullong *)&Copy);
  return v9;
}

void sub_1DC3C3E10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC31EBFC((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

const void *sub_1DC3C3E44(atomic_ullong *a1)
{
  if (qword_1EAA94E60 != -1) {
    dispatch_once_f(&qword_1EAA94E60, 0, (dispatch_function_t)sub_1DC3C3EC8);
  }
  unint64_t explicit = (const void *)atomic_load_explicit(a1, memory_order_acquire);
  if (!explicit) {
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)qword_1EAA94E58;
  return CFDictionaryGetValue(v3, explicit);
}

CFDictionaryRef sub_1DC3C3EC8()
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  long long v10 = xmmword_1F3664D68;
  long long v11 = *(_OWORD *)&off_1F3664D78;
  long long v12 = xmmword_1F3664D88;
  long long v13 = *(_OWORD *)&off_1F3664D98;
  long long v6 = xmmword_1F3664D28;
  long long v7 = *(_OWORD *)&off_1F3664D38;
  long long v8 = xmmword_1F3664D48;
  long long v9 = *(_OWORD *)&off_1F3664D58;
  *(_OWORD *)values = xmmword_1F3664CE8;
  long long v3 = *(_OWORD *)&off_1F3664CF8;
  long long v4 = xmmword_1F3664D08;
  long long v5 = *(_OWORD *)&off_1F3664D18;
  memset(&v1, 0, sizeof(v1));
  CFDictionaryRef result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)off_1E6C3ABF0, (const void **)values, 24, MEMORY[0x1E4F1D530], &v1);
  qword_1EAA94E58 = (uint64_t)result;
  return result;
}

CFNumberRef sub_1DC3C3F90@<X0>(unsigned __int8 *a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (a1[204]) {
    BOOL v3 = a1[203] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    CFNumberRef result = 0;
  }
  else
  {
    int valuePtr = a1[202];
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  }
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C3FF8@<X0>(unsigned __int8 *a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (a1[204]) {
    BOOL v3 = a1[201] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    CFNumberRef result = 0;
  }
  else
  {
    int valuePtr = a1[200];
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  }
  *a2 = result;
  return result;
}

CFTypeRef sub_1DC3C4060@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 192))
  {
    CFTypeRef result = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 184), memory_order_acquire);
    if (result) {
      CFTypeRef result = CFRetain(result);
    }
  }
  else
  {
    CFTypeRef result = 0;
  }
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C40A4@<X0>(unsigned char *a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (a1[192]) {
    BOOL v3 = a1[176] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    CFNumberRef result = 0;
  }
  else {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, a1 + 168);
  }
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C40FC@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 192)) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, (const void *)(a1 + 160));
  }
  else {
    CFNumberRef result = 0;
  }
  *a2 = result;
  return result;
}

CFTypeRef sub_1DC3C414C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 192))
  {
    BOOL v3 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
    if (!*(unsigned char *)(a1 + 152)) {
      BOOL v3 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
    }
    CFTypeRef result = *v3;
    if (*v3) {
      CFTypeRef result = CFRetain(result);
    }
  }
  else
  {
    CFTypeRef result = 0;
  }
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C41A8@<X0>(unsigned char *a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (a1[148]) {
    BOOL v3 = a1[140] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    CFNumberRef result = 0;
  }
  else {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, a1 + 136);
  }
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C4200@<X0>(unsigned char *a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (a1[148]) {
    BOOL v3 = a1[132] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    CFNumberRef result = 0;
  }
  else {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, a1 + 128);
  }
  *a2 = result;
  return result;
}

CFTypeRef sub_1DC3C4258@<X0>(unsigned char *a1@<X0>, void *a2@<X8>)
{
  if (a1[148]) {
    BOOL v3 = a1[145] == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    CFTypeRef result = 0;
  }
  else
  {
    long long v5 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
    if (!a1[144]) {
      long long v5 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
    }
    CFTypeRef result = *v5;
    if (*v5) {
      CFTypeRef result = CFRetain(result);
    }
  }
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C42C0@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 120)) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v3 = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 < 20;
    if (v7 >= 20) {
      long long v9 = (uint64_t *)v4;
    }
    else {
      long long v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 28) <= 20) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(v6 + 32));
  }
  else {
LABEL_12:
  }
    CFNumberRef result = 0;
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C4348@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 120)) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v3 = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 < 21;
    if (v7 >= 21) {
      long long v9 = (uint64_t *)v4;
    }
    else {
      long long v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 28) <= 21) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(v6 + 32));
  }
  else {
LABEL_12:
  }
    CFNumberRef result = 0;
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C43D0@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 120)) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v3 = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 < 22;
    if (v7 >= 22) {
      long long v9 = (uint64_t *)v4;
    }
    else {
      long long v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 28) <= 22) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(v6 + 32));
  }
  else {
LABEL_12:
  }
    CFNumberRef result = 0;
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C4458@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 120)) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v3 = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 < 17;
    if (v7 >= 17) {
      long long v9 = (uint64_t *)v4;
    }
    else {
      long long v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 28) <= 17) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(v6 + 32));
  }
  else {
LABEL_12:
  }
    CFNumberRef result = 0;
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C44E0@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 120)) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v3 = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 < 16;
    if (v7 >= 16) {
      long long v9 = (uint64_t *)v4;
    }
    else {
      long long v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 28) <= 16) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(v6 + 32));
  }
  else {
LABEL_12:
  }
    CFNumberRef result = 0;
  *a2 = result;
  return result;
}

CFTypeRef sub_1DC3C4568@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 120)) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v3 = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 < 18;
    if (v7 >= 18) {
      long long v9 = (uint64_t *)v4;
    }
    else {
      long long v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 28) <= 18)
  {
    if (*(_DWORD *)(v6 + 32)) {
      long long v11 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
    }
    else {
      long long v11 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
    }
    CFTypeRef result = *v11;
    if (*v11) {
      CFTypeRef result = CFRetain(result);
    }
  }
  else
  {
LABEL_12:
    CFTypeRef result = 0;
  }
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C4600@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 120)) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v3 = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 < 13;
    if (v7 >= 13) {
      long long v9 = (uint64_t *)v4;
    }
    else {
      long long v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 28) <= 13) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(v6 + 32));
  }
  else {
LABEL_12:
  }
    CFNumberRef result = 0;
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C4688@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 120)) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v3 = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 < 8;
    if (v7 >= 8) {
      long long v9 = (uint64_t *)v4;
    }
    else {
      long long v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 28) <= 8) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(v6 + 32));
  }
  else {
LABEL_12:
  }
    CFNumberRef result = 0;
  *a2 = result;
  return result;
}

CFNumberRef sub_1DC3C4710@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (!*(unsigned char *)(a1 + 120)) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v3 = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 < 12;
    if (v7 >= 12) {
      long long v9 = (uint64_t *)v4;
    }
    else {
      long long v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 28) <= 12) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(v6 + 32));
  }
  else {
LABEL_12:
  }
    CFNumberRef result = 0;
  *a2 = result;
  return result;
}

CFTypeRef sub_1DC3C4798@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 89))
  {
    uint64_t v3 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
    if (!*(unsigned char *)(a1 + 88)) {
      uint64_t v3 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
    }
    CFTypeRef result = *v3;
    if (*v3) {
      CFTypeRef result = CFRetain(result);
    }
  }
  else
  {
    CFTypeRef result = 0;
  }
  *a2 = result;
  return result;
}

void sub_1DC3C47F4(uint64_t a1@<X0>, CFArrayRef *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 80))
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 4, MEMORY[0x1E4F1D510]);
    int v7 = *(CGPoint **)(a1 + 56);
    for (uint64_t i = *(CGPoint **)(a1 + 64); v7 != i; ++v7)
    {
      DictionaryRepresentatiouint64_t n = CGPointCreateDictionaryRepresentation(*v7);
      CFArrayAppendValue(Mutable, (const void *)atomic_load_explicit((atomic_ullong *volatile)&DictionaryRepresentation, memory_order_acquire));
      sub_1DC31EBFC((atomic_ullong *)&DictionaryRepresentation);
    }
    *a2 = CFArrayCreateCopy(v4, Mutable);
    CFRelease(Mutable);
  }
  else
  {
    *a2 = 0;
  }
}

void sub_1DC3C48C0(_Unwind_Exception *a1)
{
  sub_1DC3065EC(v1);
  _Unwind_Resume(a1);
}

void sub_1DC3C48E4(uint64_t a1@<X0>, CFArrayRef *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 48))
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 4, MEMORY[0x1E4F1D510]);
    int v7 = *(CGPoint **)(a1 + 24);
    for (uint64_t i = *(CGPoint **)(a1 + 32); v7 != i; ++v7)
    {
      DictionaryRepresentatiouint64_t n = CGPointCreateDictionaryRepresentation(*v7);
      CFArrayAppendValue(Mutable, (const void *)atomic_load_explicit((atomic_ullong *volatile)&DictionaryRepresentation, memory_order_acquire));
      sub_1DC31EBFC((atomic_ullong *)&DictionaryRepresentation);
    }
    *a2 = CFArrayCreateCopy(v4, Mutable);
    CFRelease(Mutable);
  }
  else
  {
    *a2 = 0;
  }
}

void sub_1DC3C49B0(_Unwind_Exception *a1)
{
  sub_1DC3065EC(v1);
  _Unwind_Resume(a1);
}

CFNumberRef sub_1DC3C49D4@<X0>(uint64_t a1@<X0>, CFNumberRef *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 20)) {
    CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (const void *)(a1 + 16));
  }
  else {
    CFNumberRef result = 0;
  }
  *a2 = result;
  return result;
}

CFTypeRef sub_1DC3C4A20@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFTypeRef result = (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *a2 = result;
  return result;
}

CFTypeRef sub_1DC3C4A54@<X0>(atomic_ullong *a1@<X0>, void *a2@<X8>)
{
  CFTypeRef result = (CFTypeRef)atomic_load_explicit(a1, memory_order_acquire);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *a2 = result;
  return result;
}

unint64_t MRCDescriptorCopyAttribute(char *cf, CFTypeRef a2)
{
  void (*v6)(atomic_ullong *__return_ptr, char *);
  unint64_t v7;
  CFTypeRef v9;
  atomic_ullong v10;

  if (!cf) {
    goto LABEL_5;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (qword_1EAA94E90 != -1) {
    dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
  }
  if (v4 != qword_1EAA94E98)
  {
    _os_assumes_log();
    if (a2) {
      goto LABEL_6;
    }
  }
  else
  {
LABEL_5:
    if (a2)
    {
LABEL_6:
      CFTypeRef v5 = CFRetain(a2);
      goto LABEL_7;
    }
  }
  CFTypeRef v5 = 0;
LABEL_7:
  long long v9 = v5;
  uint64_t v6 = (void (*)(atomic_ullong *__return_ptr, char *))sub_1DC3C3E44((atomic_ullong *)&v9);
  if (v6) {
    v6(&v10, cf + 16);
  }
  else {
    long long v10 = 0;
  }
  int v7 = atomic_exchange(&v10, 0);
  sub_1DC31EB58(&v10);
  sub_1DC31FA90((atomic_ullong *)&v9);
  return v7;
}

void sub_1DC3C4B70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_ullong a9)
{
}

unint64_t MRCDescriptorDecodePayload(const void *a1, void *a2)
{
  return MRCDescriptorDecodePayloadWithOptions(a1, 0, a2);
}

unint64_t MRCDescriptorDecodePayloadWithOptions(const void *a1, const void *a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFC270 != -1) {
    dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
  }
  uint64_t v6 = qword_1EBFFC278;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC278, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadWithOptions: enter", buf, 2u);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 138739971;
    uint64_t v13 = (uint64_t)a1;
    _os_log_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadWithOptions: descriptor: %{sensitive}@", buf, 0xCu);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 138543362;
    uint64_t v13 = (uint64_t)a2;
    _os_log_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadWithOptions: options: %{public}@", buf, 0xCu);
  }
  if (!a1) {
    goto LABEL_13;
  }
  CFTypeID v7 = CFGetTypeID(a1);
  if (qword_1EAA94E90 != -1) {
    dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
  }
  if (v7 != qword_1EAA94E98)
  {
    _os_assumes_log();
    if (a2) {
      goto LABEL_14;
    }
  }
  else
  {
LABEL_13:
    if (a2)
    {
LABEL_14:
      CFTypeRef v8 = CFRetain(a2);
      goto LABEL_15;
    }
  }
  CFTypeRef v8 = 0;
LABEL_15:
  CFTypeRef v11 = v8;
  sub_1DC3AA56C((atomic_ullong *)buf, (uint64_t)a1 + 16, (atomic_ullong *)&v11, 0, a3);
  unint64_t v9 = atomic_exchange((atomic_ullong *volatile)buf, 0);
  sub_1DC31FA90((atomic_ullong *)buf);
  sub_1DC31EBFC((atomic_ullong *)&v11);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 141558275;
    uint64_t v13 = 1752392040;
    __int16 v14 = 2117;
    unint64_t v15 = v9;
    _os_log_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadWithOptions: decodedPayloadString: %{sensitive, mask.hash}@", buf, 0x16u);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC2FE000, v6, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadWithOptions: leave", buf, 2u);
  }
  return v9;
}

void sub_1DC3C4E28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

unint64_t MRCDescriptorDecodePayloadAndSupplementalPayload(const void *a1, __CFString **a2, void *a3)
{
  return MRCDescriptorDecodePayloadAndSupplementalPayloadWithOptions(a1, a2, 0, a3);
}

unint64_t MRCDescriptorDecodePayloadAndSupplementalPayloadWithOptions(const void *a1, __CFString **a2, const void *a3, void *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (qword_1EBFFC270 != -1) {
    dispatch_once(&qword_1EBFFC270, &unk_1F3664AF8);
  }
  CFTypeRef v8 = qword_1EBFFC278;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC278, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadAndSupplementalPayloadWithOptions: enter", buf, 2u);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 138739971;
    uint64_t v16 = (uint64_t)a1;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadAndSupplementalPayloadWithOptions: descriptor: %{sensitive}@", buf, 0xCu);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 138543362;
    uint64_t v16 = (uint64_t)a3;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadAndSupplementalPayloadWithOptions: options: %{public}@", buf, 0xCu);
  }
  if (!a1) {
    goto LABEL_13;
  }
  CFTypeID v9 = CFGetTypeID(a1);
  if (qword_1EAA94E90 != -1) {
    dispatch_once_f(&qword_1EAA94E90, 0, (dispatch_function_t)sub_1DC34D8C8);
  }
  if (v9 != qword_1EAA94E98)
  {
    _os_assumes_log();
    if (a3) {
      goto LABEL_14;
    }
  }
  else
  {
LABEL_13:
    if (a3)
    {
LABEL_14:
      CFTypeRef v10 = CFRetain(a3);
      goto LABEL_15;
    }
  }
  CFTypeRef v10 = 0;
LABEL_15:
  CFTypeRef v14 = v10;
  sub_1DC3AA56C((atomic_ullong *)buf, (uint64_t)a1 + 16, (atomic_ullong *)&v14, a2, a4);
  unint64_t v11 = atomic_exchange((atomic_ullong *volatile)buf, 0);
  sub_1DC31FA90((atomic_ullong *)buf);
  sub_1DC31EBFC((atomic_ullong *)&v14);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 141558275;
    uint64_t v16 = 1752392040;
    __int16 v17 = 2117;
    unint64_t v18 = v11;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadAndSupplementalPayloadWithOptions: decodedPayloadString: %{sensitive, mask.hash}@", buf, 0x16u);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    if (a2)
    {
      long long v12 = *a2;
      if (!*a2) {
        long long v12 = @"<null>";
      }
    }
    else
    {
      long long v12 = @"<N/A>";
    }
    *(_DWORD *)long long buf = 141558275;
    uint64_t v16 = 1752392040;
    __int16 v17 = 2117;
    unint64_t v18 = (unint64_t)v12;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadAndSupplementalPayloadWithOptions: supplementalPayloadStringValue: %{sensitive, mask.hash}@", buf, 0x16u);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1DC2FE000, v8, OS_LOG_TYPE_INFO, "MRCDescriptorDecodePayloadAndSupplementalPayloadWithOptions: leave", buf, 2u);
  }
  return v11;
}

void sub_1DC3C515C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_1DC3C5178(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 24)) {
    return !*(unsigned char *)(a2 + 24);
  }
  if (!*(unsigned char *)(a2 + 24)) {
    return 0;
  }
  uint64_t v3 = *(double **)a1;
  CFTypeID v2 = *(double **)(a1 + 8);
  unint64_t v4 = ((uint64_t)v2 - *(void *)a1) >> 4;
  CFTypeRef v5 = *(double **)a2;
  if (v4 != (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4) {
    return 0;
  }
  if (v2 == v3) {
    return 1;
  }
  if (v4 <= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = ((uint64_t)v2 - *(void *)a1) >> 4;
  }
  if (*v3 != *v5 || v3[1] != v5[1]) {
    return 0;
  }
  unint64_t v8 = 0;
  CFTypeID v9 = v3 + 2;
  CFTypeRef v10 = v5 + 2;
  while (v6 - 1 != v8)
  {
    int32x2_t v11 = vmovn_s64(vceqq_f64(*(float64x2_t *)&v9[2 * v8], *(float64x2_t *)&v10[2 * v8]));
    ++v8;
    if ((v11.i32[0] & v11.i32[1] & 1) == 0) {
      return v8 >= v4;
    }
  }
  unint64_t v8 = v6;
  return v8 >= v4;
}

uint64_t sub_1DC3C522C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24)) {
    BOOL v2 = *(unsigned char *)(a2 + 24) == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return (*(unsigned char *)(a1 + 24) != 0) ^ (*(unsigned char *)(a2 + 24) != 0);
  }
  if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    return 1;
  }
  uint64_t v6 = *(void **)a1;
  unint64_t v4 = (void *)(a1 + 8);
  CFTypeRef v5 = v6;
  if (v6 == v4) {
    return 0;
  }
  CFTypeID v7 = *(void **)a2;
  while (1)
  {
    BOOL v8 = *((_DWORD *)v5 + 7) == *((_DWORD *)v7 + 7) && *((_DWORD *)v5 + 8) == *((_DWORD *)v7 + 8);
    BOOL v3 = !v8;
    if (!v8) {
      break;
    }
    CFTypeID v9 = (void *)v5[1];
    CFTypeRef v10 = v5;
    if (v9)
    {
      do
      {
        CFTypeRef v5 = v9;
        CFTypeID v9 = (void *)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        CFTypeRef v5 = (void *)v10[2];
        BOOL v2 = *v5 == (void)v10;
        CFTypeRef v10 = v5;
      }
      while (!v2);
    }
    int32x2_t v11 = (void *)v7[1];
    if (v11)
    {
      do
      {
        long long v12 = v11;
        int32x2_t v11 = (void *)*v11;
      }
      while (v11);
    }
    else
    {
      do
      {
        long long v12 = (void *)v7[2];
        BOOL v2 = *v12 == (void)v7;
        CFTypeID v7 = v12;
      }
      while (!v2);
    }
    CFTypeID v7 = v12;
    if (v5 == v4) {
      return 0;
    }
  }
  return v3;
}

BOOL sub_1DC3C530C(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a2 + 4);
  if (*(unsigned char *)(a1 + 4)) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if ((*(unsigned char *)(a1 + 4) != 0) != (v2 != 0)) {
      return 0;
    }
  }
  else if (*(_DWORD *)a1 != *(_DWORD *)a2)
  {
    return 0;
  }
  int v4 = *(unsigned __int8 *)(a2 + 12);
  if (*(unsigned char *)(a1 + 12)) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if ((*(unsigned char *)(a1 + 12) != 0) != (v4 != 0)) {
      return 0;
    }
  }
  else if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8))
  {
    return 0;
  }
  if (*(unsigned char *)(a1 + 17) && *(unsigned char *)(a2 + 17))
  {
    int v6 = *(unsigned __int8 *)(a1 + 16);
    int v7 = *(unsigned __int8 *)(a2 + 16);
  }
  else
  {
    int v7 = *(unsigned __int8 *)(a2 + 17) != 0;
    int v6 = *(unsigned __int8 *)(a1 + 17) != 0;
  }
  return v6 == v7;
}

BOOL sub_1DC3C53D0(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 != *a2 || *((void *)a1 + 1) != *((void *)a2 + 1)) {
    return 0;
  }
  int v2 = a2[24];
  if (a1[24]) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if ((a1[24] != 0) != (v2 != 0)) {
      return 0;
    }
  }
  else if (*((void *)a1 + 2) != *((void *)a2 + 2))
  {
    return 0;
  }
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire);
  BOOL v5 = (const void *)atomic_load_explicit((atomic_ullong *volatile)a1 + 4, memory_order_acquire);
  return v5 == explicit || explicit && v5 && CFEqual(v5, explicit);
}

BOOL sub_1DC3C5478(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = a2[1];
  if (a1[1]) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if ((a1[1] != 0) != (v2 != 0)) {
      return 0;
    }
  }
  else if (*a1 != *a2)
  {
    return 0;
  }
  int v4 = a2[3];
  if (a1[3]) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    int v7 = v4 != 0;
    int v6 = a1[3] != 0;
  }
  else
  {
    int v6 = a1[2];
    int v7 = a2[2];
  }
  return v6 == v7;
}

CFStringRef sub_1DC3C5500(uint64_t a1, int a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
  {
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"<%s %p> {\n", "MRCDescriptor", a1 - 16);
    if (atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire)) {
      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    symbology %@\n", atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire));
    }
    if (atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire))
    {
      unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      if (a2)
      {
        CFStringAppendFormat(explicit, 0, @"    rawPayloadData %@\n", @"<redacted>");
      }
      else
      {
        sub_1DC3C6384(&v137, (atomic_ullong *)(a1 + 8));
        CFStringAppendFormat(explicit, 0, @"    rawPayloadData %@\n", atomic_load_explicit(&v137, memory_order_acquire));
        sub_1DC31FA90(&v137);
      }
    }
    if (*(unsigned char *)(a1 + 20)) {
      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"    confidence %f\n", *(float *)(a1 + 16));
    }
    if (*(unsigned char *)(a1 + 48))
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    cornerPoints {\n");
      int v7 = *(void **)(a1 + 24);
      for (uint64_t i = *(void **)(a1 + 32); v7 != i; v7 += 2)
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        {%.*g, %.*g}\n", 17, *v7, 17, v7[1]);
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    }
    if (*(unsigned char *)(a1 + 80))
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    finderPatternPoints {\n");
      CFTypeID v9 = *(void **)(a1 + 56);
      for (uint64_t j = *(void **)(a1 + 64); v9 != j; v9 += 2)
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        {%.*g, %.*g}\n", 17, *v9, 17, v9[1]);
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    }
    if (*(unsigned char *)(a1 + 89))
    {
      int32x2_t v11 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      if (*(unsigned char *)(a1 + 88)) {
        long long v12 = "true";
      }
      else {
        long long v12 = "false";
      }
      CFStringAppendFormat(v11, 0, @"    isColorInverted %s\n", v12);
    }
    if (*(unsigned char *)(a1 + 120))
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    zxingSymbolMetadata {\n");
      CFTypeRef v14 = (uint64_t *)(a1 + 104);
      uint64_t v13 = *(void *)(a1 + 104);
      if (v13)
      {
        uint64_t v15 = a1 + 104;
        uint64_t v16 = *(void *)(a1 + 104);
        do
        {
          int v17 = *(_DWORD *)(v16 + 28);
          BOOL v18 = v17 < 0;
          if (v17 >= 0) {
            uint64_t v19 = (uint64_t *)v16;
          }
          else {
            uint64_t v19 = (uint64_t *)(v16 + 8);
          }
          if (!v18) {
            uint64_t v15 = v16;
          }
          uint64_t v16 = *v19;
        }
        while (*v19);
        if ((uint64_t *)v15 == v14
          || *(int *)(v15 + 28) > 0
          || (CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        upperLeftX %d\n", *(unsigned int *)(v15 + 32)), (uint64_t v13 = *v14) != 0))
        {
          uint64_t v20 = a1 + 104;
          uint64_t v21 = v13;
          do
          {
            int v22 = *(_DWORD *)(v21 + 28);
            BOOL v23 = v22 < 1;
            if (v22 >= 1) {
              uint64_t v24 = (uint64_t *)v21;
            }
            else {
              uint64_t v24 = (uint64_t *)(v21 + 8);
            }
            if (!v23) {
              uint64_t v20 = v21;
            }
            uint64_t v21 = *v24;
          }
          while (*v24);
          if ((uint64_t *)v20 != v14 && *(int *)(v20 + 28) <= 1)
          {
            CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        upperLeftY %d\n", *(unsigned int *)(v20 + 32));
            uint64_t v13 = *v14;
          }
          if (v13)
          {
            uint64_t v25 = a1 + 104;
            uint64_t v26 = v13;
            do
            {
              int v27 = *(_DWORD *)(v26 + 28);
              BOOL v28 = v27 < 2;
              if (v27 >= 2) {
                uint64_t v29 = (uint64_t *)v26;
              }
              else {
                uint64_t v29 = (uint64_t *)(v26 + 8);
              }
              if (!v28) {
                uint64_t v25 = v26;
              }
              uint64_t v26 = *v29;
            }
            while (*v29);
            if ((uint64_t *)v25 != v14 && *(int *)(v25 + 28) <= 2)
            {
              CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        upperRightX %d\n", *(unsigned int *)(v25 + 32));
              uint64_t v13 = *v14;
            }
            if (v13)
            {
              uint64_t v30 = a1 + 104;
              uint64_t v31 = v13;
              do
              {
                int v32 = *(_DWORD *)(v31 + 28);
                BOOL v33 = v32 < 3;
                if (v32 >= 3) {
                  uint64_t v34 = (uint64_t *)v31;
                }
                else {
                  uint64_t v34 = (uint64_t *)(v31 + 8);
                }
                if (!v33) {
                  uint64_t v30 = v31;
                }
                uint64_t v31 = *v34;
              }
              while (*v34);
              if ((uint64_t *)v30 != v14 && *(int *)(v30 + 28) <= 3)
              {
                CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        upperRightY %d\n", *(unsigned int *)(v30 + 32));
                uint64_t v13 = *v14;
              }
              if (v13)
              {
                uint64_t v35 = a1 + 104;
                uint64_t v36 = v13;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < 4;
                  if (v37 >= 4) {
                    int v39 = (uint64_t *)v36;
                  }
                  else {
                    int v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    uint64_t v35 = v36;
                  }
                  uint64_t v36 = *v39;
                }
                while (*v39);
                if ((uint64_t *)v35 != v14 && *(int *)(v35 + 28) <= 4)
                {
                  CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        lowerRightX %d\n", *(unsigned int *)(v35 + 32));
                  uint64_t v13 = *v14;
                }
                if (v13)
                {
                  uint64_t v40 = a1 + 104;
                  uint64_t v41 = v13;
                  do
                  {
                    int v42 = *(_DWORD *)(v41 + 28);
                    BOOL v43 = v42 < 5;
                    if (v42 >= 5) {
                      int v44 = (uint64_t *)v41;
                    }
                    else {
                      int v44 = (uint64_t *)(v41 + 8);
                    }
                    if (!v43) {
                      uint64_t v40 = v41;
                    }
                    uint64_t v41 = *v44;
                  }
                  while (*v44);
                  if ((uint64_t *)v40 != v14 && *(int *)(v40 + 28) <= 5)
                  {
                    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        lowerRightY %d\n", *(unsigned int *)(v40 + 32));
                    uint64_t v13 = *v14;
                  }
                  if (v13)
                  {
                    uint64_t v45 = a1 + 104;
                    uint64_t v46 = v13;
                    do
                    {
                      int v47 = *(_DWORD *)(v46 + 28);
                      BOOL v48 = v47 < 6;
                      if (v47 >= 6) {
                        int v49 = (uint64_t *)v46;
                      }
                      else {
                        int v49 = (uint64_t *)(v46 + 8);
                      }
                      if (!v48) {
                        uint64_t v45 = v46;
                      }
                      uint64_t v46 = *v49;
                    }
                    while (*v49);
                    if ((uint64_t *)v45 != v14 && *(int *)(v45 + 28) <= 6)
                    {
                      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        lowerLeftX %d\n", *(unsigned int *)(v45 + 32));
                      uint64_t v13 = *v14;
                    }
                    if (v13)
                    {
                      uint64_t v50 = a1 + 104;
                      uint64_t v51 = v13;
                      do
                      {
                        int v52 = *(_DWORD *)(v51 + 28);
                        BOOL v53 = v52 < 7;
                        if (v52 >= 7) {
                          int v54 = (uint64_t *)v51;
                        }
                        else {
                          int v54 = (uint64_t *)(v51 + 8);
                        }
                        if (!v53) {
                          uint64_t v50 = v51;
                        }
                        uint64_t v51 = *v54;
                      }
                      while (*v54);
                      if ((uint64_t *)v50 != v14 && *(int *)(v50 + 28) <= 7)
                      {
                        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        lowerLeftY %d\n", *(unsigned int *)(v50 + 32));
                        uint64_t v13 = *v14;
                      }
                      if (v13)
                      {
                        uint64_t v55 = a1 + 104;
                        uint64_t v56 = v13;
                        do
                        {
                          int v57 = *(_DWORD *)(v56 + 28);
                          BOOL v58 = v57 < 8;
                          if (v57 >= 8) {
                            uint64_t v59 = (uint64_t *)v56;
                          }
                          else {
                            uint64_t v59 = (uint64_t *)(v56 + 8);
                          }
                          if (!v58) {
                            uint64_t v55 = v56;
                          }
                          uint64_t v56 = *v59;
                        }
                        while (*v59);
                        if ((uint64_t *)v55 != v14 && *(int *)(v55 + 28) <= 8)
                        {
                          CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        qrMaskingPattern %d\n", *(unsigned int *)(v55 + 32));
                          uint64_t v13 = *v14;
                        }
                        if (v13)
                        {
                          uint64_t v60 = a1 + 104;
                          uint64_t v61 = v13;
                          do
                          {
                            int v62 = *(_DWORD *)(v61 + 28);
                            BOOL v63 = v62 < 9;
                            if (v62 >= 9) {
                              int v64 = (uint64_t *)v61;
                            }
                            else {
                              int v64 = (uint64_t *)(v61 + 8);
                            }
                            if (!v63) {
                              uint64_t v60 = v61;
                            }
                            uint64_t v61 = *v64;
                          }
                          while (*v64);
                          if ((uint64_t *)v60 != v14 && *(int *)(v60 + 28) <= 9)
                          {
                            CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        inversionState %d\n", *(unsigned int *)(v60 + 32));
                            uint64_t v13 = *v14;
                          }
                          if (v13)
                          {
                            uint64_t v65 = a1 + 104;
                            uint64_t v66 = v13;
                            do
                            {
                              int v67 = *(_DWORD *)(v66 + 28);
                              BOOL v68 = v67 < 10;
                              if (v67 >= 10) {
                                int v69 = (uint64_t *)v66;
                              }
                              else {
                                int v69 = (uint64_t *)(v66 + 8);
                              }
                              if (!v68) {
                                uint64_t v65 = v66;
                              }
                              uint64_t v66 = *v69;
                            }
                            while (*v69);
                            if ((uint64_t *)v65 != v14 && *(int *)(v65 + 28) <= 10)
                            {
                              CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        dataRows %d\n", *(unsigned int *)(v65 + 32));
                              uint64_t v13 = *v14;
                            }
                            if (v13)
                            {
                              uint64_t v70 = a1 + 104;
                              uint64_t v71 = v13;
                              do
                              {
                                int v72 = *(_DWORD *)(v71 + 28);
                                BOOL v73 = v72 < 11;
                                if (v72 >= 11) {
                                  long long v74 = (uint64_t *)v71;
                                }
                                else {
                                  long long v74 = (uint64_t *)(v71 + 8);
                                }
                                if (!v73) {
                                  uint64_t v70 = v71;
                                }
                                uint64_t v71 = *v74;
                              }
                              while (*v74);
                              if ((uint64_t *)v70 != v14 && *(int *)(v70 + 28) <= 11)
                              {
                                CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        dataColumns %d\n", *(unsigned int *)(v70 + 32));
                                uint64_t v13 = *v14;
                              }
                              if (v13)
                              {
                                uint64_t v75 = a1 + 104;
                                uint64_t v76 = v13;
                                do
                                {
                                  int v77 = *(_DWORD *)(v76 + 28);
                                  BOOL v78 = v77 < 12;
                                  if (v77 >= 12) {
                                    unsigned int v79 = (uint64_t *)v76;
                                  }
                                  else {
                                    unsigned int v79 = (uint64_t *)(v76 + 8);
                                  }
                                  if (!v78) {
                                    uint64_t v75 = v76;
                                  }
                                  uint64_t v76 = *v79;
                                }
                                while (*v79);
                                if ((uint64_t *)v75 != v14 && *(int *)(v75 + 28) <= 12)
                                {
                                  CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        symbolVersion %d\n", *(unsigned int *)(v75 + 32));
                                  uint64_t v13 = *v14;
                                }
                                if (v13)
                                {
                                  uint64_t v80 = a1 + 104;
                                  uint64_t v81 = v13;
                                  do
                                  {
                                    int v82 = *(_DWORD *)(v81 + 28);
                                    BOOL v83 = v82 < 13;
                                    if (v82 >= 13) {
                                      unsigned int v84 = (uint64_t *)v81;
                                    }
                                    else {
                                      unsigned int v84 = (uint64_t *)(v81 + 8);
                                    }
                                    if (!v83) {
                                      uint64_t v80 = v81;
                                    }
                                    uint64_t v81 = *v84;
                                  }
                                  while (*v84);
                                  if ((uint64_t *)v80 != v14 && *(int *)(v80 + 28) <= 13)
                                  {
                                    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        ecLevel %d\n", *(unsigned int *)(v80 + 32));
                                    uint64_t v13 = *v14;
                                  }
                                  if (v13)
                                  {
                                    uint64_t v85 = a1 + 104;
                                    uint64_t v86 = v13;
                                    do
                                    {
                                      int v87 = *(_DWORD *)(v86 + 28);
                                      BOOL v88 = v87 < 14;
                                      if (v87 >= 14) {
                                        float v89 = (uint64_t *)v86;
                                      }
                                      else {
                                        float v89 = (uint64_t *)(v86 + 8);
                                      }
                                      if (!v88) {
                                        uint64_t v85 = v86;
                                      }
                                      uint64_t v86 = *v89;
                                    }
                                    while (*v89);
                                    if ((uint64_t *)v85 != v14 && *(int *)(v85 + 28) <= 14)
                                    {
                                      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        isMirrored %d\n", *(unsigned int *)(v85 + 32));
                                      uint64_t v13 = *v14;
                                    }
                                    if (v13)
                                    {
                                      uint64_t v90 = a1 + 104;
                                      uint64_t v91 = v13;
                                      do
                                      {
                                        int v92 = *(_DWORD *)(v91 + 28);
                                        BOOL v93 = v92 < 15;
                                        if (v92 >= 15) {
                                          float32x4_t v94 = (uint64_t *)v91;
                                        }
                                        else {
                                          float32x4_t v94 = (uint64_t *)(v91 + 8);
                                        }
                                        if (!v93) {
                                          uint64_t v90 = v91;
                                        }
                                        uint64_t v91 = *v94;
                                      }
                                      while (*v94);
                                      if ((uint64_t *)v90 != v14 && *(int *)(v90 + 28) <= 15)
                                      {
                                        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        messageBits %d\n", *(unsigned int *)(v90 + 32));
                                        uint64_t v13 = *v14;
                                      }
                                      if (v13)
                                      {
                                        uint64_t v95 = a1 + 104;
                                        uint64_t v96 = v13;
                                        do
                                        {
                                          int v97 = *(_DWORD *)(v96 + 28);
                                          BOOL v98 = v97 < 16;
                                          if (v97 >= 16) {
                                            float v99 = (uint64_t *)v96;
                                          }
                                          else {
                                            float v99 = (uint64_t *)(v96 + 8);
                                          }
                                          if (!v98) {
                                            uint64_t v95 = v96;
                                          }
                                          uint64_t v96 = *v99;
                                        }
                                        while (*v99);
                                        if ((uint64_t *)v95 != v14 && *(int *)(v95 + 28) <= 16)
                                        {
                                          CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        aztecDataLayers %d\n", *(unsigned int *)(v95 + 32));
                                          uint64_t v13 = *v14;
                                        }
                                        if (v13)
                                        {
                                          uint64_t v100 = a1 + 104;
                                          uint64_t v101 = v13;
                                          do
                                          {
                                            int v102 = *(_DWORD *)(v101 + 28);
                                            BOOL v103 = v102 < 17;
                                            if (v102 >= 17) {
                                              float32x2_t v104 = (uint64_t *)v101;
                                            }
                                            else {
                                              float32x2_t v104 = (uint64_t *)(v101 + 8);
                                            }
                                            if (!v103) {
                                              uint64_t v100 = v101;
                                            }
                                            uint64_t v101 = *v104;
                                          }
                                          while (*v104);
                                          if ((uint64_t *)v100 != v14 && *(int *)(v100 + 28) <= 17)
                                          {
                                            CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        aztecDataCodewords %d\n", *(unsigned int *)(v100 + 32));
                                            uint64_t v13 = *v14;
                                          }
                                          if (v13)
                                          {
                                            uint64_t v105 = a1 + 104;
                                            uint64_t v106 = v13;
                                            do
                                            {
                                              int v107 = *(_DWORD *)(v106 + 28);
                                              BOOL v108 = v107 < 18;
                                              if (v107 >= 18) {
                                                float32x2_t v109 = (uint64_t *)v106;
                                              }
                                              else {
                                                float32x2_t v109 = (uint64_t *)(v106 + 8);
                                              }
                                              if (!v108) {
                                                uint64_t v105 = v106;
                                              }
                                              uint64_t v106 = *v109;
                                            }
                                            while (*v109);
                                            if ((uint64_t *)v105 != v14 && *(int *)(v105 + 28) <= 18)
                                            {
                                              CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        aztecIsCompact %d\n", *(unsigned int *)(v105 + 32));
                                              uint64_t v13 = *v14;
                                            }
                                            if (v13)
                                            {
                                              uint64_t v110 = a1 + 104;
                                              uint64_t v111 = v13;
                                              do
                                              {
                                                int v112 = *(_DWORD *)(v111 + 28);
                                                BOOL v113 = v112 < 19;
                                                if (v112 >= 19) {
                                                  float v114 = (uint64_t *)v111;
                                                }
                                                else {
                                                  float v114 = (uint64_t *)(v111 + 8);
                                                }
                                                if (!v113) {
                                                  uint64_t v110 = v111;
                                                }
                                                uint64_t v111 = *v114;
                                              }
                                              while (*v114);
                                              if ((uint64_t *)v110 != v14 && *(int *)(v110 + 28) <= 19)
                                              {
                                                CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        aztecMessageBits %d\n", *(unsigned int *)(v110 + 32));
                                                uint64_t v13 = *v14;
                                              }
                                              if (v13)
                                              {
                                                uint64_t v115 = a1 + 104;
                                                uint64_t v116 = v13;
                                                do
                                                {
                                                  int v117 = *(_DWORD *)(v116 + 28);
                                                  BOOL v118 = v117 < 20;
                                                  if (v117 >= 20) {
                                                    float v119 = (uint64_t *)v116;
                                                  }
                                                  else {
                                                    float v119 = (uint64_t *)(v116 + 8);
                                                  }
                                                  if (!v118) {
                                                    uint64_t v115 = v116;
                                                  }
                                                  uint64_t v116 = *v119;
                                                }
                                                while (*v119);
                                                if ((uint64_t *)v115 != v14 && *(int *)(v115 + 28) <= 20)
                                                {
                                                  CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        datamatrixECC %d\n", *(unsigned int *)(v115 + 32));
                                                  uint64_t v13 = *v14;
                                                }
                                                if (v13)
                                                {
                                                  uint64_t v120 = a1 + 104;
                                                  uint64_t v121 = v13;
                                                  do
                                                  {
                                                    int v122 = *(_DWORD *)(v121 + 28);
                                                    BOOL v123 = v122 < 21;
                                                    if (v122 >= 21) {
                                                      float v124 = (uint64_t *)v121;
                                                    }
                                                    else {
                                                      float v124 = (uint64_t *)(v121 + 8);
                                                    }
                                                    if (!v123) {
                                                      uint64_t v120 = v121;
                                                    }
                                                    uint64_t v121 = *v124;
                                                  }
                                                  while (*v124);
                                                  if ((uint64_t *)v120 != v14 && *(int *)(v120 + 28) <= 21)
                                                  {
                                                    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        modulesWide %d\n", *(unsigned int *)(v120 + 32));
                                                    uint64_t v13 = *v14;
                                                  }
                                                  if (v13)
                                                  {
                                                    uint64_t v125 = a1 + 104;
                                                    do
                                                    {
                                                      int v126 = *(_DWORD *)(v13 + 28);
                                                      BOOL v127 = v126 < 22;
                                                      if (v126 >= 22) {
                                                        int32x2_t v128 = (uint64_t *)v13;
                                                      }
                                                      else {
                                                        int32x2_t v128 = (uint64_t *)(v13 + 8);
                                                      }
                                                      if (!v127) {
                                                        uint64_t v125 = v13;
                                                      }
                                                      uint64_t v13 = *v128;
                                                    }
                                                    while (*v128);
                                                    if ((uint64_t *)v125 != v14 && *(int *)(v125 + 28) <= 22) {
                                                      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        modulesHigh %d\n", *(unsigned int *)(v125 + 32));
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    }
    if (*(unsigned char *)(a1 + 148))
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    PDF417Metadata {\n");
      if (*(unsigned char *)(a1 + 132)) {
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        rowCount %d\n", *(unsigned int *)(a1 + 128));
      }
      if (*(unsigned char *)(a1 + 140)) {
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        columnCount %d\n", *(unsigned int *)(a1 + 136));
      }
      if (*(unsigned char *)(a1 + 145))
      {
        int v129 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        if (*(unsigned char *)(a1 + 144)) {
          int v130 = "true";
        }
        else {
          int v130 = "false";
        }
        CFStringAppendFormat(v129, 0, @"        isCompact %s\n", v130);
      }
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    }
    if (*(unsigned char *)(a1 + 192))
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    GS1Metadata {\n");
      int v131 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      if (*(unsigned char *)(a1 + 152)) {
        float v132 = "true";
      }
      else {
        float v132 = "false";
      }
      CFStringAppendFormat(v131, 0, @"        isGS1DataCarrier %s\n", v132);
      float v133 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      sub_1DC3C6488(&v137, *(void *)(a1 + 160));
      CFStringAppendFormat(v133, 0, @"        compositeFlag %@\n", atomic_load_explicit(&v137, memory_order_acquire));
      sub_1DC31FA90(&v137);
      if (*(unsigned char *)(a1 + 176))
      {
        float v134 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        sub_1DC3C6488(&v137, *(void *)(a1 + 168));
        CFStringAppendFormat(v134, 0, @"        supplementalCompositeFlag %@\n", atomic_load_explicit(&v137, memory_order_acquire));
        sub_1DC31FA90(&v137);
      }
      if (atomic_load_explicit((atomic_ullong *volatile)(a1 + 184), memory_order_acquire))
      {
        float v135 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        sub_1DC3C6384(&v137, (atomic_ullong *)(a1 + 184));
        CFStringAppendFormat(v135, 0, @"        supplementalRawPayloadData %@\n", atomic_load_explicit(&v137, memory_order_acquire));
        sub_1DC31FA90(&v137);
      }
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    }
    if (*(unsigned char *)(a1 + 204))
    {
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    appClipCodeMetadata {\n");
      if (*(unsigned char *)(a1 + 201)) {
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        metadata %hhu\n", *(unsigned __int8 *)(a1 + 200));
      }
      if (*(unsigned char *)(a1 + 203)) {
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, @"        dataVersion %hhu\n", *(unsigned __int8 *)(a1 + 202));
      }
      CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"    }\n");
    }
    CFStringAppend((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"}");
    CFStringRef Copy = CFStringCreateCopy(v4, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  }
  else
  {
    CFStringRef Copy = 0;
  }
  sub_1DC326F90((atomic_ullong *)&Mutable);
  return Copy;
}

void sub_1DC3C62E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1DC326F90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3C6384(void *a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    long long v12 = @"<null>";
LABEL_9:
    CFTypeRef result = (atomic_ullong *)CFRetain(v12);
    *a1 = result;
    return result;
  }
  CFIndex Length = CFDataGetLength((CFDataRef)atomic_load_explicit(a2, memory_order_acquire));
  if (!Length)
  {
    long long v12 = @"<empty>";
    goto LABEL_9;
  }
  uint64_t v5 = Length;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2 * Length);
  BytePtr = CFDataGetBytePtr((CFDataRef)atomic_load_explicit(a2, memory_order_acquire));
  if (v5 >= 1)
  {
    BOOL v8 = BytePtr;
    do
    {
      unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      unsigned int v10 = *v8++;
      CFStringAppendFormat(explicit, 0, @"%02hhx", v10, Mutable);
      --v5;
    }
    while (v5);
  }
  *a1 = CFStringCreateCopy(v6, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  return sub_1DC326F90((atomic_ullong *)&Mutable);
}

void sub_1DC3C6470(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC326F90((atomic_ullong *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC3C6488(void *a1, uint64_t a2)
{
  switch(a2)
  {
    case 0:
      BOOL v3 = @"none";
      goto LABEL_9;
    case 1:
      BOOL v3 = @"unknown";
      goto LABEL_9;
    case 2:
      BOOL v3 = @"linked";
      goto LABEL_9;
    case 3:
      BOOL v3 = @"GS1-type-A";
      goto LABEL_9;
    case 4:
      BOOL v3 = @"GS1-type-B";
      goto LABEL_9;
    case 5:
      BOOL v3 = @"GS1-type-C";
LABEL_9:
      CFTypeRef result = (void *)CFRetain(v3);
      break;
    default:
      CFTypeRef result = (void *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%ld", a2);
      break;
  }
  *a1 = result;
  return result;
}

void *sub_1DC3C6564(void *result, uint64_t a2)
{
  uint64_t v2 = 3317042773;
  if (*(unsigned char *)(a2 + 24))
  {
    BOOL v3 = *(double **)a2;
    CFAllocatorRef v4 = *(double **)(a2 + 8);
    if (*(double **)a2 != v4)
    {
      unint64_t v5 = 0;
      do
      {
        double v6 = *v3;
        double v7 = v3[1];
        v3 += 2;
        unint64_t v8 = *(void *)&v6 + 2654435769;
        if (v6 == 0.0) {
          unint64_t v8 = 2654435769;
        }
        uint64_t v9 = *(void *)&v7 + 2654435769;
        if (v7 == 0.0) {
          uint64_t v9 = 2654435769;
        }
        v5 ^= (v5 << 6) + 2654435769u + (v5 >> 2) + (((v8 >> 2) + (v8 << 6) + v9) ^ v8);
      }
      while (v3 != v4);
      uint64_t v2 = v5 + 2654435769u;
    }
  }
  *result ^= v2 + (*result << 6) + (*result >> 2);
  return result;
}

void sub_1DC3C65F4()
{
}

void sub_1DC3C681C(void *a1)
{
  __cxa_free_exception(v2);
  MEMORY[0x1E019CE90](v1, 0x1091C40433B895BLL);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1DC3C67CCLL);
}

uint64_t sub_1DC3C6864(uint64_t a1, char *a2, unsigned int a3, char *a4, unsigned int a5, unsigned int *a6, unsigned int a7, _DWORD *a8, _WORD *a9, _WORD *a10)
{
  uint64_t v10 = 1;
  if (a2)
  {
    if (a3)
    {
      if (a4)
      {
        if (a5)
        {
          if (a8)
          {
            if (a9)
            {
              if (a10)
              {
                uint64_t v15 = a6;
                if (a6 || !a7)
                {
                  unsigned int v18 = *(_DWORD *)(a1 + 60);
                  BOOL v19 = a5 >= v18;
                  unsigned int v20 = a5 - v18;
                  if (v19)
                  {
                    BOOL v19 = v20 >= a7;
                    unsigned int v21 = v20 - a7;
                    if (v19)
                    {
                      unsigned int v101 = v21 >> 1;
                      *a8 = 0;
                      float32x4_t v162 = 0;
                      uint64_t v163 = 0;
                      int32x4_t v161 = &unk_1F3660AE0;
                      sub_1DC3CA460(&v161, 0, 1);
                      unsigned int v22 = 0;
                      __int16 v23 = *(_WORD *)(a1 + 8);
                      int32x4_t v161 = &unk_1F3660B68;
                      uint64_t v105 = (unsigned __int16 *)(a1 + 8);
                      uint64_t v164 = a1 + 8;
                      uint64_t v99 = a5;
                      unsigned __int16 v24 = v23 - 1;
                      uint64_t v25 = 2 * a5 - 2;
                      do
                      {
                        unsigned int v26 = *(unsigned __int16 *)&a4[v25];
                        if (v26 > v24) {
                          LOWORD(v26) = 1;
                        }
                        sub_1DC3CA3B4(&v161, v22++, (__int16)v26);
                        v25 -= 2;
                      }
                      while (a5 != v22);
                      int v27 = 0;
                      uint64_t v100 = a3;
                      uint64_t v28 = 2 * a3 - 2;
                      do
                      {
                        unsigned int v29 = *(unsigned __int16 *)&a2[v28];
                        if (v29 > v24) {
                          LOWORD(v29) = 1;
                        }
                        sub_1DC3CA3B4(&v161, a5 + v27++, (__int16)v29);
                        v28 -= 2;
                      }
                      while (a3 != v27);
                      float32x4_t v158 = 0;
                      uint64_t v159 = 0;
                      unsigned int v157 = &unk_1F3660AE0;
                      sub_1DC3CA460(&v157, 0, 1);
                      unsigned int v157 = &unk_1F3660B68;
                      uint64_t v160 = a1 + 8;
                      uint64_t v30 = *(unsigned __int16 *)(a1 + 10);
                      if (*(_WORD *)(a1 + 56))
                      {
                        unsigned int v31 = 0;
                        unsigned __int16 v32 = 1;
                        do
                        {
                          __int16 v33 = 0;
                          if (v32 && *(_WORD *)(a1 + 10)) {
                            __int16 v33 = *(_WORD *)(*(void *)(a1 + 32)
                          }
                                           + 2
                                           * *(unsigned __int16 *)(*(void *)(a1 + 24)
                                                                 + 2
                                                                 * (*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v30)
                                                                  + (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v32))));
                          ++v31;
                          unsigned __int16 v32 = v33;
                        }
                        while (v31 < *(unsigned __int16 *)(a1 + 56));
                      }
                      else
                      {
                        __int16 v33 = 1;
                      }
                      BOOL v98 = a8;
                      unsigned int v34 = 0;
                      int v35 = 0;
                      do
                      {
                        int v36 = sub_1DC3CAFC0((uint64_t)&v161, v33);
                        sub_1DC3CA3B4(&v157, v34, v36);
                        __int16 v37 = 0;
                        if (v30 && v33) {
                          __int16 v37 = *(_WORD *)(*(void *)(a1 + 32)
                        }
                                         + 2
                                         * *(unsigned __int16 *)(*(void *)(a1 + 24)
                                                               + 2
                                                               * (*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v30)
                                                                + (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * (unsigned __int16)v33))));
                        unsigned int v34 = (unsigned __int16)++v35;
                        __int16 v33 = v37;
                      }
                      while ((unsigned __int16)v35 < a5);
                      unsigned int v38 = 1;
                      int v39 = v158;
                      do
                      {
                        int v40 = v158[v38 - 1];
                        if (v158[v38 - 1]) {
                          BOOL v41 = 1;
                        }
                        else {
                          BOOL v41 = v38 > v159;
                        }
                        ++v38;
                      }
                      while (!v41);
                      if (v40)
                      {
                        sub_1DC3CC0B8(v156, a7);
                        sub_1DC3CC0B8(v155, a7);
                        unsigned int v42 = a5 + a3;
                        if (a7)
                        {
                          BOOL v43 = v156[0];
                          uint64_t v44 = a7;
                          while (1)
                          {
                            unsigned int v46 = *v15++;
                            unsigned int v45 = v46;
                            if (v46 >= v42) {
                              break;
                            }
                            *v43++ = v42 + ~v45;
                            if (!--v44) {
                              goto LABEL_46;
                            }
                          }
                          uint64_t v10 = 1;
                        }
                        else
                        {
LABEL_46:
                          sub_1DC3CB998((uint64_t)&v153, (uint64_t)v105, 0);
                          if (a7)
                          {
                            uint64_t v151 = 0;
                            float v149 = &unk_1F3660AE0;
                            float v150 = 0;
                            sub_1DC3CA460(&v149, 0, 1);
                            float v149 = &unk_1F3660B68;
                            uint64_t v152 = a1 + 8;
                            sub_1DC3CB998((uint64_t)&v145, (uint64_t)v105, 0);
                            float32x2_t v142 = 0;
                            uint64_t v143 = 0;
                            uint64_t v141 = &unk_1F3660AE0;
                            sub_1DC3CA460(&v141, 0, 1);
                            uint64_t v47 = 0;
                            uint64_t v141 = &unk_1F3660B68;
                            uint64_t v144 = a1 + 8;
                            do
                            {
                              uint64_t v48 = *(unsigned __int16 *)(*(void *)(a1 + 32)
                                                        + 2
                                                        * (*(_DWORD *)((char *)v156[0] + v47)
                                                         % *(unsigned __int16 *)(a1 + 8)));
                              sub_1DC3CA460(&v149, 0, 1);
                              *(_WORD *)float v150 = 0;
                              sub_1DC3CA3B4(&v149, 1u, (__int16)v48);
                              *(_DWORD *)((char *)v155[0] + v47) = *(unsigned __int16 *)(*(void *)(a1 + 48) + 2 * v48);
                              sub_1DC3CB69C((uint64_t)&v145, (uint64_t)&v149, &v141);
                              sub_1DC3CB518((uint64_t)&v153, (uint64_t)&v141, (uint64_t)&v153);
                              v47 += 4;
                            }
                            while (4 * a7 != v47);
                            operator new();
                          }
                          sub_1DC3CB998((uint64_t)&v149, (uint64_t)v105, a5);
                          int v49 = &unk_1F3660AE0;
                          uint64_t v147 = 0;
                          float v145 = &unk_1F3660AE0;
                          __int32 v146 = 0;
                          sub_1DC3CA9F4((uint64_t)&v145, (uint64_t)&v149);
                          float v145 = &unk_1F3660B68;
                          uint64_t v148 = v152;
                          float32x2_t v142 = 0;
                          uint64_t v143 = 0;
                          uint64_t v141 = &unk_1F3660AE0;
                          sub_1DC3CA460(&v141, 0, 1);
                          uint64_t v141 = &unk_1F3660B68;
                          uint64_t v144 = a1 + 8;
                          sub_1DC3CB998((uint64_t)&v139, (uint64_t)v105, 0);
                          sub_1DC3CB998((uint64_t)&v136, (uint64_t)v105, 0);
                          float v133 = 0;
                          uint64_t v134 = 0;
                          float v132 = &unk_1F3660AE0;
                          sub_1DC3CA460(&v132, 0, 1);
                          float v132 = &unk_1F3660B68;
                          uint64_t v135 = a1 + 8;
                          int v129 = 0;
                          uint64_t v130 = 0;
                          int32x2_t v128 = &unk_1F3660AE0;
                          sub_1DC3CA460(&v128, 0, 1);
                          int32x2_t v128 = &unk_1F3660B68;
                          uint64_t v131 = a1 + 8;
                          uint64_t v125 = 0;
                          uint64_t v126 = 0;
                          float v124 = &unk_1F3660AE0;
                          sub_1DC3CA9F4((uint64_t)&v124, (uint64_t)&v157);
                          float v124 = &unk_1F3660B68;
                          uint64_t v127 = v160;
                          while (v126 > (a5 - 2) >> 1)
                          {
                            sub_1DC3CB06C((uint64_t)&v145, (uint64_t)&v124, (uint64_t)&v132, (uint64_t)&v128);
                            sub_1DC3CB518((uint64_t)&v132, (uint64_t)&v139, (uint64_t)&v136);
                            sub_1DC3CB69C((uint64_t)&v141, (uint64_t)&v136, &v136);
                            sub_1DC3CBA40((uint64_t)&v141, (uint64_t)&v139);
                            sub_1DC3CBA40((uint64_t)&v139, (uint64_t)&v136);
                            sub_1DC3CBA40((uint64_t)&v145, (uint64_t)&v124);
                            sub_1DC3CBA40((uint64_t)&v124, (uint64_t)&v128);
                          }
                          unsigned int v50 = v138;
                          if (v138 <= v101)
                          {
                            unint64_t v51 = v138 + a7;
                            _DWORD *v98 = v51;
                            sub_1DC3CC0B8(v123, v50 + a7);
                            sub_1DC3CC0B8(__p, v51);
                            if (v51)
                            {
                              int v52 = 0;
                              BOOL v53 = v123[0];
                              int v54 = __p[0];
                              do
                              {
                                v53[(unsigned __int16)v52] = 0;
                                v54[(unsigned __int16)v52++] = 0;
                              }
                              while (v51 > (unsigned __int16)v52);
                            }
                            unsigned int v102 = a5 + a3;
                            unsigned int v55 = *v105;
                            unsigned __int16 v56 = 0;
                            unsigned int v57 = v55 - 2;
                            if (v55 >= 2)
                            {
                              uint64_t v58 = *(unsigned __int16 *)(a1 + 10);
                              uint64_t v59 = __p[0];
                              uint64_t v60 = v123[0];
                              unsigned __int16 v61 = *(_WORD *)(a1 + 10);
                              do
                              {
                                if (!sub_1DC3CAFC0((uint64_t)&v136, (__int16)v61))
                                {
                                  v59[v56] = v57;
                                  v60[v56++] = v61;
                                }
                                unsigned __int16 v62 = 0;
                                if (v61 && v58) {
                                  unsigned __int16 v62 = *(_WORD *)(*(void *)(a1 + 32)
                                }
                                                 + 2
                                                 * *(unsigned __int16 *)(*(void *)(a1 + 24)
                                                                       + 2
                                                                       * (*(unsigned __int16 *)(*(void *)(a1 + 40)
                                                                                              + 2 * v58)
                                                                        + (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v61))));
                                --v57;
                                unsigned __int16 v61 = v62;
                              }
                              while (v57 != -1);
                            }
                            if (v138 == v56)
                            {
                              sub_1DC3CB518((uint64_t)&v136, (uint64_t)&v153, (uint64_t)&v136);
                              if (v138 == v51 && (int v63 = sub_1DC3CAFC0((uint64_t)&v136, 0)) != 0)
                              {
                                __int16 v64 = *(_WORD *)(*(void *)(a1 + 48) + 2 * (unsigned __int16)v63);
                                float v119 = 0;
                                uint64_t v120 = 0;
                                BOOL v118 = &unk_1F3660AE0;
                                sub_1DC3CA460(&v118, 0, 1);
                                BOOL v118 = &unk_1F3660B68;
                                uint64_t v121 = a1 + 8;
                                uint64_t v115 = 0;
                                uint64_t v116 = 0;
                                float v114 = &unk_1F3660AE0;
                                sub_1DC3CA460(&v114, 0, 1);
                                float v114 = &unk_1F3660B68;
                                uint64_t v117 = a1 + 8;
                                sub_1DC3CB76C((uint64_t)&v136, v64, &v118);
                                sub_1DC3CB76C((uint64_t)&v124, v64, &v114);
                                uint64_t v10 = 3;
                                if (*(_WORD *)v119 && v51 == v120)
                                {
                                  uint64_t v65 = *v98;
                                  if (v65)
                                  {
                                    uint64_t v66 = (unsigned __int16 *)sub_1DC3CC130(*v98);
                                    bzero(v66, 2 * v65);
                                    uint64_t v67 = *v98;
                                    if (v67)
                                    {
                                      uint64_t v68 = 0;
                                      uint64_t v69 = *(void *)(a1 + 48);
                                      float32x2_t v104 = v123[0];
                                      do
                                      {
                                        uint64_t v70 = v49;
                                        uint64_t v71 = *(unsigned __int16 *)(a1 + 8);
                                        uint64_t v72 = v104[v68] % v71;
                                        uint64_t v73 = *(unsigned __int16 *)(v69 + 2 * v72);
                                        int v74 = sub_1DC3CAFC0((uint64_t)&v114, (__int16)v72);
                                        unsigned int v75 = *(unsigned __int16 *)(a1 + 56);
                                        if (*(_WORD *)(a1 + 56))
                                        {
                                          if (v75 == 1)
                                          {
                                            unsigned __int16 v76 = 1;
                                          }
                                          else
                                          {
                                            unsigned int v77 = 1;
                                            unsigned __int16 v78 = 1;
                                            do
                                            {
                                              unsigned __int16 v76 = 0;
                                              if (v73 && v78) {
                                                unsigned __int16 v76 = *(_WORD *)(*(void *)(a1 + 32)
                                              }
                                                               + 2
                                                               * *(unsigned __int16 *)(*(void *)(a1 + 24)
                                                                                     + 2
                                                                                     * (*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v73)
                                                                                      + (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v78))));
                                              ++v77;
                                              unsigned __int16 v78 = v76;
                                            }
                                            while (v77 < v75);
                                          }
                                        }
                                        else
                                        {
                                          unsigned __int16 v76 = v72;
                                        }
                                        unsigned __int16 v79 = 0;
                                        uint64_t v80 = v68;
                                        do
                                        {
                                          unsigned __int16 v81 = v76;
                                          if (v80)
                                          {
                                            uint64_t v82 = 0;
                                            if ((_WORD)v72
                                              && *(_WORD *)(v69 + 2 * (*((_DWORD *)v123[0] + v79) % v71)))
                                            {
                                              uint64_t v82 = *(unsigned __int16 *)(*(void *)(a1 + 32)
                                                                        + 2
                                                                        * *(unsigned __int16 *)(*(void *)(a1 + 24)
                                                                                              + 2
                                                                                              * (*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v72)
                                                                                               + (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * *(unsigned __int16 *)(v69 + 2 * (*((_DWORD *)v123[0] + v79) % v71))))));
                                            }
                                            unsigned __int16 v76 = 0;
                                            if (v81)
                                            {
                                              uint64_t v83 = *(unsigned __int16 *)(*(void *)(a1 + 16) + 2 * (v71 + 1 - v82));
                                              if (v83) {
                                                unsigned __int16 v76 = *(_WORD *)(*(void *)(a1 + 32)
                                              }
                                                               + 2
                                                               * *(unsigned __int16 *)(*(void *)(a1 + 24)
                                                                                     + 2
                                                                                     * (*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v83)
                                                                                      + (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v81))));
                                            }
                                          }
                                          ++v79;
                                          --v80;
                                        }
                                        while (v67 > v79);
                                        uint64_t v84 = 0;
                                        if (v73)
                                        {
                                          int v49 = v70;
                                          if (v76) {
                                            uint64_t v84 = *(unsigned __int16 *)(*(void *)(a1 + 32)
                                          }
                                                                      + 2
                                                                      * *(unsigned __int16 *)(*(void *)(a1 + 24)
                                                                                            + 2
                                                                                            * (*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v76)
                                                                                             + (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v73))));
                                        }
                                        else
                                        {
                                          int v49 = v70;
                                        }
                                        unsigned __int16 v85 = 0;
                                        if (v74)
                                        {
                                          uint64_t v86 = *(unsigned __int16 *)(v69 + 2 * v84);
                                          if (v86) {
                                            unsigned __int16 v85 = *(_WORD *)(*(void *)(a1 + 32)
                                          }
                                                           + 2
                                                           * *(unsigned __int16 *)(*(void *)(a1 + 24)
                                                                                 + 2
                                                                                 * (*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v86)
                                                                                  + (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * (unsigned __int16)v74))));
                                        }
                                        v66[v68++] = v85;
                                      }
                                      while (v68 != v67);
                                    }
                                  }
                                  else
                                  {
                                    uint64_t v66 = 0;
                                  }
                                  uint64_t v111 = 0;
                                  uint64_t v112 = 0;
                                  uint64_t v110 = &unk_1F3660AE0;
                                  sub_1DC3CA460(&v110, 0, 1);
                                  uint64_t v110 = &unk_1F3660B68;
                                  uint64_t v113 = a1 + 8;
                                  if (*v98)
                                  {
                                    int v88 = 0;
                                    do
                                    {
                                      sub_1DC3CA3B4(&v110, *((_DWORD *)__p[0] + (unsigned __int16)v88), *(__int16 *)(*(void *)(a1 + 16)+ 2* (*(unsigned __int16 *)(a1 + 8)- (unint64_t)v66[(unsigned __int16)v88])));
                                      ++v88;
                                    }
                                    while (*v98 > (unsigned __int16)v88);
                                  }
                                  int v107 = 0;
                                  uint64_t v108 = 0;
                                  uint64_t v106 = &unk_1F3660AE0;
                                  sub_1DC3CA460(&v106, 0, 1);
                                  uint64_t v106 = &unk_1F3660B68;
                                  uint64_t v109 = a1 + 8;
                                  sub_1DC3CB450((uint64_t)&v161, (uint64_t)&v110, &v106);
                                  uint64_t v89 = v100;
                                  unsigned int v90 = v108;
                                  uint64_t v91 = v107;
                                  BOOL v93 = a9;
                                  int v92 = a10;
                                  if (v102 >= (int)v108 + 1)
                                  {
                                    unsigned int v94 = v102 - 1;
                                    do
                                    {
                                      if (v90 >= v94) {
                                        __int16 v95 = v91[v94];
                                      }
                                      else {
                                        __int16 v95 = 0;
                                      }
                                      *v93++ = v95;
                                      --v94;
                                      --v89;
                                    }
                                    while (v89);
                                    uint64_t v96 = v99;
                                    do
                                    {
                                      if (v90 >= v94) {
                                        __int16 v97 = v91[v94];
                                      }
                                      else {
                                        __int16 v97 = 0;
                                      }
                                      *v92++ = v97;
                                      --v94;
                                      --v96;
                                    }
                                    while (v96);
                                    uint64_t v10 = 0;
                                  }
                                  else
                                  {
                                    uint64_t v10 = 3;
                                  }
                                  uint64_t v106 = &unk_1F3660AE0;
                                  if (v91) {
                                    free(v91);
                                  }
                                  uint64_t v110 = &unk_1F3660AE0;
                                  if (v111) {
                                    free(v111);
                                  }
                                  if (v66) {
                                    operator delete(v66);
                                  }
                                }
                                float v114 = &unk_1F3660AE0;
                                if (v115) {
                                  free(v115);
                                }
                                BOOL v118 = &unk_1F3660AE0;
                                if (v119) {
                                  free(v119);
                                }
                              }
                              else
                              {
                                uint64_t v10 = 3;
                              }
                            }
                            else
                            {
                              uint64_t v10 = 3;
                            }
                            if (__p[0])
                            {
                              __p[1] = __p[0];
                              operator delete(__p[0]);
                            }
                            if (v123[0])
                            {
                              v123[1] = v123[0];
                              operator delete(v123[0]);
                            }
                          }
                          else
                          {
                            uint64_t v10 = 3;
                          }
                          float v124 = &unk_1F3660AE0;
                          if (v125) {
                            free(v125);
                          }
                          int32x2_t v128 = &unk_1F3660AE0;
                          if (v129) {
                            free(v129);
                          }
                          float v132 = &unk_1F3660AE0;
                          if (v133) {
                            free(v133);
                          }
                          float v136 = &unk_1F3660AE0;
                          if (v137) {
                            free(v137);
                          }
                          float v139 = &unk_1F3660AE0;
                          if (v140) {
                            free(v140);
                          }
                          uint64_t v141 = &unk_1F3660AE0;
                          if (v142) {
                            free(v142);
                          }
                          float v145 = v49;
                          if (v146) {
                            free(v146);
                          }
                          float v149 = &unk_1F3660AE0;
                          if (v150) {
                            free(v150);
                          }
                          float v153 = &unk_1F3660AE0;
                          if (v154) {
                            free(v154);
                          }
                        }
                        if (v155[0])
                        {
                          v155[1] = v155[0];
                          operator delete(v155[0]);
                        }
                        if (v156[0])
                        {
                          v156[1] = v156[0];
                          operator delete(v156[0]);
                        }
                        int v39 = v158;
                        unsigned int v157 = &unk_1F3660AE0;
                        if (!v158) {
                          goto LABEL_133;
                        }
                      }
                      else
                      {
                        memmove(a9, a2, 2 * a3);
                        memmove(a10, a4, 2 * a5);
                        uint64_t v10 = 0;
                        unsigned int v157 = &unk_1F3660AE0;
                      }
                      free(v39);
LABEL_133:
                      int32x4_t v161 = &unk_1F3660AE0;
                      if (v162) {
                        free(v162);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v10;
}

void sub_1DC3C7AF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  if (a35) {
    free(a35);
  }
  if (a39) {
    free(a39);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a45) {
    operator delete(a45);
  }
  if (a49) {
    free(a49);
  }
  if (a53) {
    free(a53);
  }
  if (a57) {
    free(a57);
  }
  if (a61) {
    free(a61);
  }
  if (a65) {
    free(a65);
  }
  if (a69) {
    free(a69);
  }
  if (STACK[0x200]) {
    free((void *)STACK[0x200]);
  }
  STACK[0x218] = (unint64_t)&unk_1F3660AE0;
  if (STACK[0x220]) {
    free((void *)STACK[0x220]);
  }
  *(void *)(v69 - 232) = &unk_1F3660AE0;
  uint64_t v71 = *(void **)(v69 - 224);
  if (v71) {
    free(v71);
  }
  uint64_t v72 = *(void **)(v69 - 200);
  if (v72)
  {
    *(void *)(v69 - 192) = v72;
    operator delete(v72);
  }
  uint64_t v73 = *(void **)(v69 - 176);
  if (v73)
  {
    *(void *)(v69 - 168) = v73;
    operator delete(v73);
  }
  *(void *)(v69 - 152) = a22;
  int v74 = *(void **)(v69 - 144);
  if (v74) {
    free(v74);
  }
  *(void *)(v69 - 120) = a23;
  unsigned int v75 = *(void **)(v69 - 112);
  if (v75) {
    free(v75);
  }
  _Unwind_Resume(a1);
}

_WORD *sub_1DC3C7E58(unsigned int a1)
{
  CFTypeRef result = malloc_type_malloc(4 * a1, 0xA395E199uLL);
  if (!result)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1E019CAC0](exception, "Malloc failure");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  char v3 = 1;
  CFAllocatorRef v4 = result;
  do
  {
    char v5 = v3;
    if (a1)
    {
      unsigned int v6 = 0;
      do
        *v4++ = v6++;
      while (v6 < a1);
    }
    char v3 = 0;
  }
  while ((v5 & 1) != 0);
  return result;
}

void sub_1DC3C7EF0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DC3C7F04(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    free(v2);
    a1[1] = 0;
  }
  char v3 = (void *)a1[2];
  if (v3)
  {
    free(v3);
    a1[2] = 0;
  }
  CFAllocatorRef v4 = (void *)a1[3];
  if (v4)
  {
    free(v4);
    a1[3] = 0;
  }
  char v5 = (void *)a1[4];
  if (v5)
  {
    free(v5);
    a1[4] = 0;
  }
  unsigned int v6 = (void *)a1[5];
  if (v6)
  {
    free(v6);
    a1[5] = 0;
  }
  return a1;
}

void sub_1DC3C7F78(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)long long v190 = 2;
  v190[4] = 1;
  CFAllocatorRef v4 = *(atomic_ullong **)(a1 + 8);
  if (sub_1DC3778A8(v4, @"Codabar", (uint64_t)v190)) {
    int v5 = 2;
  }
  else {
    int v5 = 0;
  }
  *(_DWORD *)long long v190 = 2;
  v190[4] = 1;
  if (sub_1DC3778A8(v4, @"GS1DataBar", (uint64_t)v190)) {
    v5 |= 0x1000u;
  }
  *(_DWORD *)long long v190 = 2;
  v190[4] = 1;
  if (sub_1DC3778A8(v4, @"GS1DataBarExpanded", (uint64_t)v190)) {
    v5 |= 0x2000u;
  }
  *(_DWORD *)long long v190 = 2;
  v190[4] = 1;
  if (sub_1DC3778A8(v4, @"GS1DataBarLimited", (uint64_t)v190)) {
    int v6 = v5 | 0x20000;
  }
  else {
    int v6 = v5;
  }
  if (!v6) {
    goto LABEL_30;
  }
  uint64_t v7 = **(void **)(a2 + 8);
  unint64_t v8 = sub_1DC383CD0((atomic_ullong *)v7);
  v203.origin.CGFloat x = *(CGFloat *)(v7 + 8);
  v203.origin.CGFloat y = *(CGFloat *)(v7 + 16);
  uint64_t v9 = v7 + 8;
  v203.size.vImagePixelCount width = *(CGFloat *)(v9 + 16);
  v203.size.vImagePixelCount height = *(CGFloat *)(v9 + 24);
  double Width = CGRectGetWidth(v203);
  double Height = CGRectGetHeight(*(CGRect *)v9);
  uint64_t v12 = *(void *)(v9 + 32);
  uint64_t v13 = *(void *)(a2 + 8);
  CGSize v14 = *(CGSize *)(v13 + 32);
  CGPoint v183 = *(CGPoint *)(v13 + 16);
  CGSize v184 = v14;
  v213.origiuint64_t n = v183;
  v213.std::string::size_type size = v14;
  BOOL IsInfinite = CGRectIsInfinite(v213);
  uint64_t v16 = &v183;
  if (IsInfinite) {
    uint64_t v16 = (CGPoint *)v9;
  }
  CGPoint v17 = v16[1];
  CGPoint v183 = *v16;
  CGSize v184 = (CGSize)v17;
  BOOL v18 = *(uint64_t *)(*(void *)(a1 + 8) + 56) < 196608 || *(unsigned char *)(a2 + 32) == 0;
  BOOL v19 = v18;
  if (v18)
  {
    double v21 = *(double *)(MEMORY[0x1E4F1DB20] + 16);
    double v20 = *(double *)(MEMORY[0x1E4F1DB20] + 24);
    double v169 = *MEMORY[0x1E4F1DB20];
    double v170 = *(double *)(MEMORY[0x1E4F1DB20] + 8);
    CGFloat y = v183.y;
    CGFloat x = v183.x;
    float __str = 0.0;
    CGFloat v25 = v184.height;
    CGFloat v24 = v184.width;
  }
  else
  {
    uint64_t v26 = *(void *)(a2 + 24);
    float v27 = *(double *)(v26 + 72);
    float v28 = *(double *)(v26 + 64);
    double v29 = (float)(atan2f(v27, v28) * -180.0) / 3.14159265;
    float v30 = *(double *)(v26 + 112);
    float v31 = v29 + fmodf(v30, 180.0);
    if (v31 > 90.0) {
      float v31 = v31 + -180.0;
    }
    if (v31 < -90.0) {
      float v31 = v31 + 180.0;
    }
    float __str = v31;
    v204.origin.CGFloat x = sub_1DC326F34(v26, 0.0);
    long long v32 = *(_OWORD *)(v26 + 80);
    *(_OWORD *)&v182.a = *(_OWORD *)(v26 + 64);
    *(_OWORD *)&v182.c = v32;
    *(_OWORD *)&v182.tCGFloat x = *(_OWORD *)(v26 + 96);
    CGRect v205 = CGRectApplyAffineTransform(v204, &v182);
    double v21 = v205.size.width;
    double v20 = v205.size.height;
    double v169 = v205.origin.x;
    double v170 = v205.origin.y;
    CGRect v206 = CGRectInset(v205, v205.size.width * -0.1, v205.size.height * -0.1);
    CGFloat x = v206.origin.x;
    CGFloat y = v206.origin.y;
    CGFloat v24 = v206.size.width;
    CGFloat v25 = v206.size.height;
    v183.CGFloat x = v206.origin.x;
    v183.CGFloat y = v206.origin.y;
    v184.vImagePixelCount width = v206.size.width;
    v184.vImagePixelCount height = v206.size.height;
  }
  v207.origin.CGFloat x = x;
  v207.origin.CGFloat y = y;
  v207.size.vImagePixelCount width = v24;
  v207.size.vImagePixelCount height = v25;
  if (CGRectIsNull(v207)
    || (v208.origin.x = x, v208.origin.y = y, v208.size.vImagePixelCount width = v24, v208.size.height = v25, CGRectIsEmpty(v208)))
  {
LABEL_30:
    **(_WORD **)(a2 + 64) = 256;
    return;
  }
  v209.origin.CGFloat x = x;
  v209.origin.CGFloat y = y;
  v209.size.vImagePixelCount width = v24;
  v209.size.vImagePixelCount height = v25;
  unint64_t v33 = vcvtmd_s64_f64(CGRectGetMinX(v209));
  v210.origin.CGFloat x = x;
  v210.origin.CGFloat y = y;
  v210.size.vImagePixelCount width = v24;
  v210.size.vImagePixelCount height = v25;
  int64_t v34 = vcvtpd_s64_f64(CGRectGetMaxX(v210));
  v211.origin.CGFloat x = x;
  v211.origin.CGFloat y = y;
  v211.size.vImagePixelCount width = v24;
  v211.size.vImagePixelCount height = v25;
  uint64_t v35 = vcvtmd_s64_f64(CGRectGetMinY(v211));
  v212.origin.CGFloat x = x;
  v212.origin.CGFloat y = y;
  v212.size.vImagePixelCount width = v24;
  v212.size.vImagePixelCount height = v25;
  int64_t v36 = vcvtpd_s64_f64(CGRectGetMaxY(v212));
  if ((uint64_t)(unint64_t)Width >= v34) {
    LODWORD(v37) = v34;
  }
  else {
    unint64_t v37 = (unint64_t)Width;
  }
  if ((uint64_t)(unint64_t)Height < v36) {
    int64_t v36 = (unint64_t)Height;
  }
  uint64_t v38 = ((_BYTE)v8 + (_BYTE)v33) & 0xF;
  if ((v12 & 0xF) != 0) {
    uint64_t v38 = 0;
  }
  int v39 = (v33 - v38) & ~((uint64_t)(v33 - v38) >> 63);
  int v40 = v35 & ~(v35 >> 63);
  int v41 = v37 - v39;
  int v42 = v36 - v40;
  BOOL v43 = (char *)operator new(0x48uLL);
  int v44 = v39;
  *(_OWORD *)(v43 + 8) = 0u;
  *(void *)BOOL v43 = &unk_1F3662270;
  unsigned int v45 = v43 + 24;
  *((void *)v43 + 3) = &unk_1F3660E08;
  *((void *)v43 + 4) = 0;
  *(_OWORD *)(v43 + 40) = 0u;
  *((_DWORD *)v43 + 14) = v41;
  *((_DWORD *)v43 + 15) = v42;
  float32x4_t v168 = v43;
  *((_DWORD *)v43 + 16) = v41;
  if ((v40 | v44 | v41 | v42) < 0)
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Requested offset is outside the image");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E6C39918, MEMORY[0x1E4FBA1D0]);
  }
  int v166 = v44;
  int v164 = v40;
  sub_1DC3D8F1C(v190, (uint64_t)v8, v12, v44, v40, v41, v42);
  unsigned int v46 = (std::__shared_weak_count *)*((void *)v168 + 5);
  *((_OWORD *)v168 + 2) = *(_OWORD *)v190;
  if (v46) {
    sub_1DC32EEF4(v46);
  }
  *(void *)&long long v47 = v45;
  *((void *)&v47 + 1) = v168;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v168 + 1, 1uLL, memory_order_relaxed);
  float32x2_t v180 = (char *)&unk_1F3660E70;
  long long v181 = v47;
  uint64_t v175 = 0;
  uint64_t v176 = 0;
  uint64_t v177 = 0;
  unsigned __int8 v178 = 1;
  BOOL v179 = v19;
  *(void *)&v190[32] = &v177;
  *(void *)long long v190 = operator new(0x40uLL);
  *(void *)&v190[8] = *(void *)v190;
  *(void *)&v190[16] = *(void *)v190;
  *(void *)&v190[24] = *(void *)v190 + 64;
  sub_1DC3068F8(&v175, v190);
  sub_1DC3A8814((uint64_t)v190);
  if ((v6 & 2) != 0) {
    operator new();
  }
  if ((v6 & 0x1000) != 0) {
    operator new();
  }
  if ((v6 & 0x2000) != 0) {
    operator new();
  }
  if ((v6 & 0x20000) != 0) {
    operator new();
  }
  v173[0] = 0;
  v173[1] = 0;
  uint64_t v174 = 0;
  if (v19)
  {
    int v48 = v178;
    BOOL v49 = v179;
    *(_DWORD *)long long v190 = 1;
    long long v193 = 0;
    uint64_t v194 = 0;
    memset(&v190[4], 0, 80);
    uint64_t v191 = 0;
    long long v192 = (uint64_t *)&v193;
    char v195 = 0;
    uint64_t v196 = 0;
    sub_1DC3A8CB8(v188, (v176 - v175) >> 3, (uint64_t)v190);
    sub_1DC3A89D4(v193);
    if (*(void *)&v190[64])
    {
      *(void *)&v190[72] = *(void *)&v190[64];
      operator delete(*(void **)&v190[64]);
    }
    if ((v190[31] & 0x80000000) != 0) {
      operator delete(*(void **)&v190[8]);
    }
    sub_1DC3A8FC4(v188, &v175, (uint64_t)&v180, v48 != 0);
    for (uint64_t i = v188[0]; ; i += 34)
    {
      if (i == v188[1]) {
        goto LABEL_232;
      }
      if (*i) {
        break;
      }
    }
    if (!v49 || !(*((unsigned int (**)(char **))v180 + 10))(&v180))
    {
LABEL_170:
      v185[0] = 0;
      v185[1] = 0;
      *(void *)&long long v186 = 0;
      long long v200 = 0;
      long long v201 = 0;
      uint64_t v202 = 0;
      sub_1DC3A8938(&v197, (v176 - v175) >> 3);
      uint64_t v110 = 0;
      while (1)
      {
        int v111 = dword_1DC40F794[v110];
        float v112 = (float)v111 * 3.14159265 / 180.0;
        if ((*((unsigned int (**)(char **, void, void **, std::__shared_weak_count **, float))v180 + 6))(&v180, 0, v185, &v200, v112))
        {
          break;
        }
LABEL_227:
        if (++v110 == 14) {
          goto LABEL_228;
        }
      }
      uint64_t v114 = v175;
      uint64_t v113 = v176;
      if (v176 == v175)
      {
        uint64_t v114 = v176;
      }
      else
      {
        unint64_t v115 = 0;
        do
        {
          if (*((_DWORD *)v188[0] + 34 * v115))
          {
            uint64_t v116 = *(void *)(v114 + 8 * v115);
            int v117 = (*((uint64_t (**)(char **))v180 + 3))(&v180);
            if (v117 >= 0) {
              int v118 = v117;
            }
            else {
              int v118 = v117 + 1;
            }
            (*(void (**)(unsigned char *__return_ptr, uint64_t, void, void **, std::__shared_weak_count **, void, char *))(*(void *)v116 + 16))(v190, v116, (v118 >> 1), v185, &v200, 0, &v197[8 * v115]);
            if (!*(_DWORD *)v190
              && sub_1DC3A9A7C((uint64_t *)(v175 + 8 * v115), (uint64_t)v190, v111, (uint64_t)&v180, 0))
            {
              sub_1DC3A8A2C((uint64_t)v190, v111, (uint64_t)&v180, 2, v119);
              uint64_t v120 = v188[0];
              uint64_t v121 = (char *)v188[0] + 136 * v115;
              *(void *)uint64_t v121 = *(void *)v190;
              std::wstring::operator=((std::wstring *)(v121 + 8), (const std::wstring *)&v190[8]);
              long long v122 = *(_OWORD *)&v190[48];
              BOOL v123 = (char *)&v120[34 * v115];
              *((_OWORD *)v123 + 2) = *(_OWORD *)&v190[32];
              *((_OWORD *)v123 + 3) = v122;
              if (v121 == v190)
              {
                v120[34 * v115 + 22] = HIDWORD(v191);
              }
              else
              {
                sub_1DC3A9480(&v120[34 * v115 + 16], *(char **)&v190[64], *(char **)&v190[72], *(void *)&v190[72] - *(void *)&v190[64]);
                float v124 = (char *)&v120[34 * v115];
                *((_DWORD *)v124 + 22) = HIDWORD(v191);
                sub_1DC3A958C((uint64_t)(v124 + 96), v192, &v193);
              }
              uint64_t v125 = (char *)&v120[34 * v115];
              v125[120] = v195;
              *(void *)(v125 + 124) = v196;
            }
            sub_1DC3A89D4(v193);
            if (*(void *)&v190[64])
            {
              *(void *)&v190[72] = *(void *)&v190[64];
              operator delete(*(void **)&v190[64]);
            }
            if ((v190[31] & 0x80000000) != 0) {
              operator delete(*(void **)&v190[8]);
            }
            uint64_t v114 = v175;
            uint64_t v113 = v176;
          }
          ++v115;
        }
        while (v115 < (v113 - v114) >> 3);
      }
      for (uint64_t j = v188[0]; j != v188[1]; j += 34)
      {
        if (*j)
        {
          uint64_t v127 = (char *)v185[1] - 1;
          if (v185[0] != v185[1] && v127 > v185[0])
          {
            int v129 = (char *)v185[0] + 1;
            do
            {
              char v130 = *(v129 - 1);
              *(v129 - 1) = *v127;
              *v127-- = v130;
              BOOL v78 = v129++ >= v127;
            }
            while (!v78);
            uint64_t v114 = v175;
            uint64_t v113 = v176;
          }
          if (v113 != v114)
          {
            unint64_t v131 = 0;
            do
            {
              if (*((_DWORD *)v188[0] + 34 * v131))
              {
                uint64_t v132 = *(void *)(v114 + 8 * v131);
                int v133 = (*((uint64_t (**)(char **))v180 + 3))(&v180);
                if (v133 >= 0) {
                  int v134 = v133;
                }
                else {
                  int v134 = v133 + 1;
                }
                (*(void (**)(unsigned char *__return_ptr, uint64_t, void, void **, std::__shared_weak_count **, void, char *))(*(void *)v132 + 16))(v190, v132, (v134 >> 1), v185, &v200, 0, &v197[8 * v131]);
                if (!*(_DWORD *)v190
                  && sub_1DC3A9A7C((uint64_t *)(v175 + 8 * v131), (uint64_t)v190, v111, (uint64_t)&v180, 1))
                {
                  sub_1DC3A8A2C((uint64_t)v190, (v111 + 180) % 360, (uint64_t)&v180, 2, v135);
                  float v136 = v188[0];
                  atomic_ullong v137 = (char *)v188[0] + 136 * v131;
                  *(void *)atomic_ullong v137 = *(void *)v190;
                  std::wstring::operator=((std::wstring *)(v137 + 8), (const std::wstring *)&v190[8]);
                  long long v138 = *(_OWORD *)&v190[48];
                  float v139 = (char *)&v136[34 * v131];
                  *((_OWORD *)v139 + 2) = *(_OWORD *)&v190[32];
                  *((_OWORD *)v139 + 3) = v138;
                  if (v137 == v190)
                  {
                    v136[34 * v131 + 22] = HIDWORD(v191);
                  }
                  else
                  {
                    sub_1DC3A9480(&v136[34 * v131 + 16], *(char **)&v190[64], *(char **)&v190[72], *(void *)&v190[72] - *(void *)&v190[64]);
                    long long v140 = (char *)&v136[34 * v131];
                    *((_DWORD *)v140 + 22) = HIDWORD(v191);
                    sub_1DC3A958C((uint64_t)(v140 + 96), v192, &v193);
                  }
                  uint64_t v141 = (char *)&v136[34 * v131];
                  v141[120] = v195;
                  *(void *)(v141 + 124) = v196;
                }
                sub_1DC3A89D4(v193);
                if (*(void *)&v190[64])
                {
                  *(void *)&v190[72] = *(void *)&v190[64];
                  operator delete(*(void **)&v190[64]);
                }
                if ((v190[31] & 0x80000000) != 0) {
                  operator delete(*(void **)&v190[8]);
                }
                uint64_t v114 = v175;
                uint64_t v113 = v176;
              }
              ++v131;
            }
            while (v131 < (v113 - v114) >> 3);
          }
          for (unint64_t k = v188[0]; k != v188[1]; k += 34)
          {
            if (*k) {
              goto LABEL_227;
            }
          }
          break;
        }
      }
LABEL_228:
      *(void *)long long v190 = &v197;
      sub_1DC3A8C10((void ***)v190);
      if (v200)
      {
        long long v201 = v200;
        operator delete(v200);
      }
      if (v185[0])
      {
        v185[1] = v185[0];
        operator delete(v185[0]);
      }
LABEL_232:
      sub_1DC3A97DC((uint64_t *)v188);
      goto LABEL_233;
    }
    *(_DWORD *)long long v190 = 1;
    long long v193 = 0;
    uint64_t v194 = 0;
    memset(&v190[4], 0, 80);
    uint64_t v191 = 0;
    long long v192 = (uint64_t *)&v193;
    char v195 = 0;
    uint64_t v196 = 0;
    sub_1DC3A8CB8(v185, (v176 - v175) >> 3, (uint64_t)v190);
    sub_1DC3A89D4(v193);
    if (*(void *)&v190[64])
    {
      *(void *)&v190[72] = *(void *)&v190[64];
      operator delete(*(void **)&v190[64]);
    }
    if ((v190[31] & 0x80000000) != 0) {
      operator delete(*(void **)&v190[8]);
    }
    (*((void (**)(std::__shared_weak_count **__return_ptr, char **, uint64_t))v180 + 11))(&v200, &v180, 270);
    sub_1DC3A8FC4(v185, &v175, (uint64_t)v200, v48 != 0);
    BOOL v93 = (uint64_t **)v185[0];
    for (uint64_t m = (uint64_t **)v185[1]; v93 != m; v93 += 17)
    {
      if (!*(_DWORD *)v93)
      {
        int v95 = sub_1DC34F9F0((uint64_t)(v93 + 12));
        sub_1DC34FA60(v93 + 12, (v95 + 270) % 360);
        long long v96 = *((_OWORD *)v93 + 3);
        *(_OWORD *)long long v190 = *((_OWORD *)v93 + 2);
        *(_OWORD *)&v190[16] = v96;
        int v97 = ((uint64_t (*)(std::__shared_weak_count *))v200->__get_deleter)(v200);
        for (uint64_t n = 0; n != 32; n += 8)
          *(void *)&v190[n] = (v97 + ~*(_DWORD *)&v190[n + 4]) | ((unint64_t)*(unsigned int *)&v190[n] << 32);
        long long v99 = *(_OWORD *)&v190[16];
        *((_OWORD *)v93 + 2) = *(_OWORD *)v190;
        *((_OWORD *)v93 + 3) = v99;
      }
    }
    unsigned int v101 = (char *)v188[0];
    uint64_t v100 = (char *)v188[1];
    if (v188[1] != v188[0])
    {
      unint64_t v102 = 0;
      uint64_t v103 = 124;
      do
      {
        if (*(_DWORD *)&v101[v103 - 124])
        {
          float32x2_t v104 = (char *)v185[0];
          uint64_t v105 = (char *)v185[0] + v103;
          if (!*(_DWORD *)((char *)v185[0] + v103 - 124))
          {
            *(void *)&v101[v103 - 124] = *(void *)(v105 - 124);
            uint64_t v106 = &v101[v103];
            std::wstring::operator=((std::wstring *)&v101[v103 - 116], (const std::wstring *)(v105 - 116));
            int v107 = &v104[v103];
            long long v108 = *(_OWORD *)&v104[v103 - 92];
            *(_OWORD *)(v106 - 76) = *(_OWORD *)&v104[v103 - 76];
            *(_OWORD *)(v106 - 92) = v108;
            if (v101 != v104)
            {
              sub_1DC3A9480(&v101[v103 - 60], *(char **)(v107 - 60), *(char **)(v107 - 52), *(void *)(v107 - 52) - *(void *)(v107 - 60));
              *(_DWORD *)&v101[v103 - 36] = *(_DWORD *)&v104[v103 - 36];
              sub_1DC3A958C((uint64_t)&v101[v103 - 28], *(void **)&v104[v103 - 28], &v104[v103 - 20]);
            }
            uint64_t v109 = &v101[v103];
            *(v109 - 4) = *(v107 - 4);
            *(void *)uint64_t v109 = *(void *)v107;
            unsigned int v101 = (char *)v188[0];
            uint64_t v100 = (char *)v188[1];
          }
        }
        ++v102;
        v103 += 136;
      }
      while (v102 < 0xF0F0F0F0F0F0F0F1 * ((v100 - v101) >> 3));
      while (v101 != v100)
      {
        if (*(_DWORD *)v101)
        {
          if (v201) {
            sub_1DC32EEF4(v201);
          }
          *(void *)long long v190 = v185;
          sub_1DC3A99F8((void ***)v190);
          goto LABEL_170;
        }
        v101 += 136;
      }
    }
    sub_1DC3A97DC((uint64_t *)v188);
    if (v201) {
      sub_1DC32EEF4(v201);
    }
    *(void *)long long v190 = v185;
    sub_1DC3A99F8((void ***)v190);
LABEL_233:
    if (v173[0])
    {
      uint64_t v143 = (char *)v173[1];
      uint64_t v144 = v173[0];
      if (v173[1] != v173[0])
      {
        do
        {
          v143 -= 136;
          sub_1DC3A9E2C((uint64_t)v143);
        }
        while (v143 != v173[0]);
        uint64_t v144 = v173[0];
      }
      v173[1] = v173[0];
      operator delete(v144);
    }
    *(_OWORD *)signed int v173 = *(_OWORD *)v188;
    uint64_t v174 = v189;
    v188[1] = 0;
    uint64_t v189 = 0;
    v188[0] = 0;
    *(void *)long long v190 = v188;
    sub_1DC3A99F8((void ***)v190);
    __int32 v146 = (int32x4_t *)v173[0];
    float v145 = (int32x4_t *)v173[1];
    if (v173[0] != v173[1])
    {
      *(void *)&long long v147 = __PAIR64__(v164, v166);
      *((void *)&v147 + 1) = __PAIR64__(v164, v166);
      *(_OWORD *)__stra = v147;
      while (1)
      {
        int32x4_t v148 = vaddq_s32(v146[3], *(int32x4_t *)__stra);
        v146[2] = vaddq_s32(v146[2], *(int32x4_t *)__stra);
        v146[3] = v148;
        memset(v190, 0, 24);
        sub_1DC3C9AAC((unint64_t *)v185, (uint64_t)v146, (uint64_t)v190, 0.0);
        if (!atomic_load_explicit((atomic_ullong *volatile)v185, memory_order_acquire)) {
          break;
        }
        float v149 = *(uint64_t **)a2;
        float v150 = *(void **)(*(void *)a2 + 8);
        unint64_t v151 = *(void *)(*(void *)a2 + 16);
        if ((unint64_t)v150 >= v151)
        {
          uint64_t v153 = ((uint64_t)v150 - *v149) >> 3;
          if ((unint64_t)(v153 + 1) >> 61) {
            sub_1DC2FF97C();
          }
          uint64_t v154 = v151 - *v149;
          uint64_t v155 = v154 >> 2;
          if (v154 >> 2 <= (unint64_t)(v153 + 1)) {
            uint64_t v155 = v153 + 1;
          }
          if ((unint64_t)v154 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v156 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v156 = v155;
          }
          *(void *)&v190[32] = *(void *)a2 + 16;
          if (v156) {
            unint64_t v156 = (unint64_t)sub_1DC2FFD7C(v156);
          }
          else {
            uint64_t v157 = 0;
          }
          *(void *)long long v190 = v156;
          *(void *)&v190[8] = v156 + 8 * v153;
          *(void *)&v190[16] = *(void *)&v190[8];
          *(void *)&v190[24] = v156 + 8 * v157;
          **(void **)&v190[8] = atomic_exchange((atomic_ullong *volatile)v185, 0);
          *(void *)&v190[16] += 8;
          sub_1DC34D7DC(v149, v190);
          uint64_t v152 = (void *)v149[1];
          sub_1DC308428((uint64_t)v190);
        }
        else
        {
          void *v150 = atomic_exchange((atomic_ullong *volatile)v185, 0);
          uint64_t v152 = v150 + 1;
          v149[1] = (uint64_t)v152;
        }
        v149[1] = (uint64_t)v152;
        sub_1DC3073A4((atomic_ullong *)v185);
        __int32 v146 = (int32x4_t *)((char *)v146 + 136);
        if (v146 == v145) {
          goto LABEL_254;
        }
      }
      **(_WORD **)(a2 + 64) = 256;
      sub_1DC3073A4((atomic_ullong *)v185);
      goto LABEL_258;
    }
    float32x4_t v158 = *(__int16 **)(a2 + 64);
    __int16 v159 = 256;
  }
  else
  {
    sub_1DC3A8938(&v200, (v176 - v175) >> 2);
    int v51 = llroundf(__str);
    if (v51 >= 0) {
      unsigned int v52 = v51;
    }
    else {
      unsigned int v52 = -v51;
    }
    if (v52 > 0x58) {
      int v53 = 1;
    }
    else {
      int v53 = 2;
    }
    if (v52 <= 1) {
      int v54 = 0;
    }
    else {
      int v54 = v53;
    }
    if (v52 < 0x59) {
      unsigned int v55 = (uint64_t (**)(void **))(v180 + 24);
    }
    else {
      unsigned int v55 = (uint64_t (**)(void **))(v180 + 16);
    }
    int v56 = (*v55)((void **)&v180);
    int v57 = v56;
    if (v56 / 40 <= 1) {
      unsigned int v58 = 1;
    }
    else {
      unsigned int v58 = v56 / 40;
    }
    if (v56 >= 0) {
      int v59 = v56;
    }
    else {
      int v59 = v56 + 1;
    }
    int v60 = v59 >> 1;
    float v197 = 0;
    long long v198 = 0;
    uint64_t v199 = 0;
    float v61 = (double)v51 * 3.14159265 / 180.0;
    v188[0] = 0;
    v188[1] = 0;
    uint64_t v189 = 0;
    float v62 = cosf(v61);
    unsigned int v63 = 0;
    __int16 v64 = (uint64_t *)&v193;
    while (1)
    {
      BOOL v18 = (v63++ & 1) == 0;
      int v65 = v63 >> 1;
      if (!v18) {
        int v65 = -v65;
      }
      int v66 = v65 * v58;
      uint64_t v67 = (v66 + v60);
      if (v66 + v60 < 0 || (int)v67 >= v57)
      {
LABEL_117:
        *(_DWORD *)long long v190 = 1;
        *__int16 v64 = 0;
        v64[1] = 0;
        memset(&v190[4], 0, 80);
        uint64_t v191 = 0;
        long long v192 = v64;
        char v195 = 0;
        uint64_t v196 = 0;
        goto LABEL_123;
      }
      if (v54 == 2)
      {
        int v69 = (*((uint64_t (**)(char **, void, char **, void **, float))v180 + 6))(&v180, (int)(float)(v62 * (float)v66), &v197, v188, v61);
      }
      else
      {
        uint64_t v68 = v54 == 1 ? v180 + 40 : v180 + 32;
        int v69 = (*(uint64_t (**)(char **, uint64_t, char **, void **, BOOL))v68)(&v180, v67, &v197, v188, v58 > 2);
      }
      if (v69) {
        break;
      }
LABEL_116:
      if (v63 == 41) {
        goto LABEL_117;
      }
    }
    int32x4_t v161 = v64;
    int v162 = v60;
    int v163 = v51;
    char v70 = 0;
    uint64_t v71 = 0;
    __int16 v187 = 256;
    while (1)
    {
      char v72 = v70;
      uint64_t v73 = *((unsigned __int8 *)&v187 + v71);
      if (*((unsigned char *)&v187 + v71))
      {
        int v74 = v198 - 1;
        if (v197 != v198 && v74 > v197)
        {
          unsigned __int16 v76 = v197 + 1;
          do
          {
            char v77 = *(v76 - 1);
            *(v76 - 1) = *v74;
            *v74-- = v77;
            BOOL v78 = v76++ >= v74;
          }
          while (!v78);
        }
        unsigned __int16 v79 = (char *)v188[1] - 1;
        if (v188[0] != v188[1] && v79 > v188[0])
        {
          unsigned __int16 v81 = (char *)v188[0] + 1;
          do
          {
            char v82 = *(v81 - 1);
            *(v81 - 1) = *v79;
            *v79-- = v82;
            BOOL v78 = v81++ >= v79;
          }
          while (!v78);
        }
      }
      uint64_t v83 = v175;
      if (v176 != v175) {
        break;
      }
LABEL_114:
      char v70 = 1;
      uint64_t v71 = 1;
      if (v72)
      {
        int v51 = v163;
        int v60 = v162;
        __int16 v64 = v161;
        goto LABEL_116;
      }
    }
    unint64_t v84 = 0;
    uint64_t v85 = 8 * v73;
    while (1)
    {
      (*(void (**)(unsigned char *__return_ptr))(**(void **)(v83 + 8 * v84) + 16))(v190);
      if (!*(_DWORD *)v190) {
        break;
      }
      sub_1DC3A89D4(v193);
      if (*(void *)&v190[64])
      {
        *(void *)&v190[72] = *(void *)&v190[64];
        operator delete(*(void **)&v190[64]);
      }
      if ((v190[31] & 0x80000000) != 0) {
        operator delete(*(void **)&v190[8]);
      }
      ++v84;
      uint64_t v83 = v175;
      v85 += 16;
      if (v84 >= (v176 - v175) >> 3) {
        goto LABEL_114;
      }
    }
    if (v73)
    {
      sub_1DC34FA60(&v192, 180);
      uint64_t v87 = 0;
      *(_OWORD *)long long v185 = *(_OWORD *)&v190[32];
      long long v186 = *(_OWORD *)&v190[48];
      int v88 = v198 - v197;
      do
      {
        v185[v87] = (void *)((~LODWORD(v185[v87]) + v88) | ((unint64_t)HIDWORD(v185[v87]) << 32));
        ++v87;
      }
      while (v87 != 4);
      float32x4_t v86 = *(float32x4_t *)v185;
      *(_OWORD *)&v190[32] = *(_OWORD *)v185;
      *(_OWORD *)&v190[48] = v186;
    }
    sub_1DC3A8A2C((uint64_t)v190, v163, (uint64_t)&v180, v54, v86);
LABEL_123:
    if (v188[0])
    {
      v188[1] = v188[0];
      operator delete(v188[0]);
    }
    if (v197)
    {
      long long v198 = v197;
      operator delete(v197);
    }
    v185[0] = &v200;
    sub_1DC3A8C10((void ***)v185);
    if (*(_DWORD *)v190)
    {
      **(_WORD **)(a2 + 64) = 256;
      int v89 = 1;
    }
    else
    {
      v90.i64[0] = __PAIR64__(v164, v166);
      v90.i64[1] = __PAIR64__(v164, v166);
      int32x4_t v165 = vaddq_s32(*(int32x4_t *)&v190[48], v90);
      int32x4_t v167 = vaddq_s32(*(int32x4_t *)&v190[32], v90);
      *(int32x4_t *)&v190[32] = v167;
      *(int32x4_t *)&v190[48] = v165;
      uint64_t v91 = operator new(0x40uLL);
      v185[1] = v91 + 4;
      *(void *)&long long v186 = v91 + 4;
      _OWORD *v91 = 0u;
      v91[1] = 0u;
      v91[2] = 0u;
      v91[3] = 0u;
      v185[0] = v91;
      sub_1DC3ED744((double *)v91, v169, v170, v21, v20, __str, (double)v167.i32[0], (double)v167.i32[1], v92, (double)v165.i32[0], (double)v165.i32[1]);
      sub_1DC3C9AAC((unint64_t *)&v200, (uint64_t)v190, (uint64_t)v185, __str);
      if (atomic_load_explicit((atomic_ullong *volatile)&v200, memory_order_acquire))
      {
        sub_1DC3C9F40(*(uint64_t **)a2, (atomic_ullong *)&v200);
        int v89 = 0;
      }
      else
      {
        **(_WORD **)(a2 + 64) = 256;
        int v89 = 1;
      }
      sub_1DC3073A4((atomic_ullong *)&v200);
      if (v185[0]) {
        operator delete(v185[0]);
      }
    }
    sub_1DC3A89D4(v193);
    if (*(void *)&v190[64])
    {
      *(void *)&v190[72] = *(void *)&v190[64];
      operator delete(*(void **)&v190[64]);
    }
    if ((v190[31] & 0x80000000) != 0) {
      operator delete(*(void **)&v190[8]);
    }
    if (v89) {
      goto LABEL_258;
    }
LABEL_254:
    float32x4_t v158 = *(__int16 **)(a2 + 64);
    __int16 v159 = 257;
  }
  __int16 *v158 = v159;
LABEL_258:
  *(void *)long long v190 = v173;
  sub_1DC3A99F8((void ***)v190);
  *(void *)long long v190 = &v175;
  sub_1DC3A8890((void ***)v190);
  float32x2_t v180 = (char *)&unk_1F3660E70;
  if (*((void *)&v181 + 1)) {
    sub_1DC32EEF4(*((std::__shared_weak_count **)&v181 + 1));
  }
  sub_1DC32EEF4((std::__shared_weak_count *)v168);
}

void sub_1DC3C9818(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55)
{
  int v57 = *(std::__shared_weak_count **)(v55 - 176);
  if (v57) {
    sub_1DC32EEF4(v57);
  }
  a55 = (uint64_t)&a45;
  sub_1DC3A99F8((void ***)&a55);
  a55 = (uint64_t)&a51;
  sub_1DC3A99F8((void ***)&a55);
  a45 = &a25;
  sub_1DC3A99F8((void ***)&a45);
  a45 = &a28;
  sub_1DC3A8890((void ***)&a45);
  a32 = a19;
  if (a34) {
    sub_1DC32EEF4((std::__shared_weak_count *)a34);
  }
  sub_1DC32EEF4(a20);
  _Unwind_Resume(a1);
}

atomic_ullong *sub_1DC3C9AAC(unint64_t *a1, uint64_t a2, uint64_t a3, float a4)
{
  unsigned int v52 = sub_1DC34D67C();
  int v8 = *(_DWORD *)(a2 + 4);
  if (v8 >= 0x2000)
  {
    if (v8 == 0x2000)
    {
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
      uint64_t v10 = &MRCSymbologyGS1DataBarExpanded;
      goto LABEL_13;
    }
    if (v8 == 0x20000)
    {
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
      uint64_t v10 = MRCSymbologyGS1DataBarLimited;
      goto LABEL_13;
    }
LABEL_8:
    *a1 = 0;
    return sub_1DC3073A4((atomic_ullong *)&v52);
  }
  if (v8 == 2)
  {
    int32x2_t v11 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire)+ 16), (unint64_t)CFRetain(@"Codabar"));
    if (v11) {
      CFRelease(v11);
    }
    int v12 = 0;
    goto LABEL_14;
  }
  if (v8 != 4096) {
    goto LABEL_8;
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
  uint64_t v10 = MRCSymbologyGS1DataBar;
LABEL_13:
  sub_1DC32D8E8((atomic_ullong *)(explicit + 16), *v10);
  int v12 = 1;
LABEL_14:
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int v14 = *(char *)(a2 + 31);
  if (v14 >= 0) {
    uint64_t v15 = (const UInt8 *)(a2 + 8);
  }
  else {
    uint64_t v15 = *(const UInt8 **)(a2 + 8);
  }
  if (v14 >= 0) {
    uint64_t v16 = *(unsigned __int8 *)(a2 + 31);
  }
  else {
    uint64_t v16 = *(void *)(a2 + 16);
  }
  CFStringRef v51 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v15, 4 * v16, 0x1C000100u, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire))
  {
    ExternalRepresentatiouint64_t n = CFStringCreateExternalRepresentation(v13, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire), 0x8000100u, 0);
    if (atomic_load_explicit((atomic_ullong *volatile)&ExternalRepresentation, memory_order_acquire))
    {
      CGPoint v17 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire)+ 24), atomic_exchange((atomic_ullong *volatile)&ExternalRepresentation, 0));
      if (v17) {
        CFRelease(v17);
      }
      unint64_t v18 = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
      *(_DWORD *)(v18 + 32) = 1065353216;
      *(unsigned char *)(v18 + 36) = 1;
      if (*(unsigned char *)(a2 + 120))
      {
        unint64_t v19 = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
        if (*(unsigned char *)(v19 + 208)) {
          sub_1DC34D854((atomic_ullong *)(v19 + 200));
        }
        *(void *)(v19 + 200) = 0;
        *(_OWORD *)(v19 + 168) = 0u;
        *(_OWORD *)(v19 + 184) = 0u;
        *(unsigned char *)(v19 + 208) = 1;
        *(void *)(v19 + 176) = 2;
      }
      if (v12)
      {
        if (!*(unsigned char *)(atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire) + 208))
        {
          unint64_t v20 = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
          if (*(unsigned char *)(v20 + 208)) {
            sub_1DC34D854((atomic_ullong *)(v20 + 200));
          }
          *(void *)(v20 + 200) = 0;
          *(_OWORD *)(v20 + 168) = 0u;
          *(_OWORD *)(v20 + 184) = 0u;
          *(unsigned char *)(v20 + 208) = 1;
        }
        *(unsigned char *)(atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire) + 168) = 1;
      }
      unint64_t v21 = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
      uint64_t v22 = *(void *)(a2 + 124);
      if (!*(unsigned char *)(v21 + 280)) {
        *(unsigned char *)(v21 + 280) = 1;
      }
      *(void *)(v21 + 272) = v22;
      unint64_t v23 = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
      *(float *)(v23 + 224) = a4;
      *(unsigned char *)(v23 + 228) = 1;
      CGFloat v25 = (int *)(a2 + 32);
      uint64_t v24 = *(void *)(a2 + 32);
      double v26 = (double)*(int *)(a2 + 48);
      double v27 = (double)*(int *)(a2 + 52);
      unint64_t v28 = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
      if (!*(unsigned char *)(v28 + 264)) {
        *(unsigned char *)(v28 + 264) = 1;
      }
      *(double *)(v28 + 232) = (double)(int)v24;
      *(double *)(v28 + 240) = (double)SHIDWORD(v24);
      *(double *)(v28 + 248) = v26;
      *(double *)(v28 + 256) = v27;
      if (*(void *)a3 == *(void *)(a3 + 8))
      {
        unint64_t v33 = 0;
        unsigned int __p = 0;
        int v48 = 0;
        int64_t v34 = (int *)(a2 + 64);
        unint64_t v49 = 0;
        do
        {
          double v35 = (double)*v25;
          double v36 = (double)v25[1];
          if ((unint64_t)v33 >= v49)
          {
            uint64_t v38 = (double *)__p;
            uint64_t v39 = ((char *)v33 - (unsigned char *)__p) >> 4;
            unint64_t v40 = v39 + 1;
            if ((unint64_t)(v39 + 1) >> 60) {
              sub_1DC2FF97C();
            }
            uint64_t v41 = v49 - (void)__p;
            if ((uint64_t)(v49 - (void)__p) >> 3 > v40) {
              unint64_t v40 = v41 >> 3;
            }
            if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v42 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v42 = v40;
            }
            if (v42) {
              unint64_t v42 = (unint64_t)sub_1DC300068(v42);
            }
            else {
              uint64_t v43 = 0;
            }
            int v44 = (double *)(v42 + 16 * v39);
            *int v44 = v35;
            v44[1] = v36;
            unsigned int v45 = v44;
            if (v33 != v38)
            {
              do
              {
                *((_OWORD *)v45 - 1) = *((_OWORD *)v33 - 1);
                v45 -= 2;
                v33 -= 2;
              }
              while (v33 != v38);
              unint64_t v33 = (double *)__p;
            }
            unint64_t v37 = v44 + 2;
            unsigned int __p = v45;
            int v48 = v44 + 2;
            unint64_t v49 = v42 + 16 * v43;
            if (v33) {
              operator delete(v33);
            }
          }
          else
          {
            *unint64_t v33 = v35;
            v33[1] = v36;
            unint64_t v37 = v33 + 2;
          }
          int v48 = v37;
          v25 += 2;
          unint64_t v33 = v37;
        }
        while (v25 != v34);
        sub_1DC3C392C(atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire) + 40, (uint64_t)&__p);
        if (__p) {
          operator delete(__p);
        }
      }
      else
      {
        unint64_t v29 = atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
        float v30 = (void **)(v29 + 40);
        if (*(unsigned char *)(v29 + 64))
        {
          float v31 = *v30;
          if (*v30)
          {
            *(void *)(v29 + 48) = v31;
            operator delete(v31);
          }
          *(unsigned char *)(v29 + 64) = 0;
        }
        char *v30 = 0;
        *(void *)(v29 + 48) = 0;
        *(void *)(v29 + 56) = 0;
        sub_1DC3CA088((void *)(v29 + 40), *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4);
        *(unsigned char *)(v29 + 64) = 1;
      }
      unint64_t v32 = atomic_exchange((atomic_ullong *volatile)&v52, 0);
    }
    else
    {
      unint64_t v32 = 0;
    }
    *a1 = v32;
    sub_1DC34D854((atomic_ullong *)&ExternalRepresentation);
  }
  else
  {
    *a1 = 0;
  }
  sub_1DC31FA90((atomic_ullong *)&v51);
  return sub_1DC3073A4((atomic_ullong *)&v52);
}

void sub_1DC3C9EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  atomic_ullong v6 = va_arg(va1, void);
  sub_1DC31FA90((atomic_ullong *)va);
  sub_1DC3073A4((atomic_ullong *)va1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1DC3C9F40(uint64_t *result, atomic_ullong *a2)
{
  char v3 = result;
  CFAllocatorRef v4 = result + 2;
  unint64_t v5 = result[2];
  atomic_ullong v6 = (void *)result[1];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = ((uint64_t)v6 - *result) >> 3;
    if ((unint64_t)(v8 + 1) >> 61) {
      sub_1DC2FF97C();
    }
    uint64_t v9 = v5 - *result;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    CGPoint v17 = v4;
    if (v11) {
      unint64_t v11 = (unint64_t)sub_1DC2FFD7C(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    unint64_t v13 = v11;
    int v14 = (void *)(v11 + 8 * v8);
    uint64_t v15 = v14;
    unint64_t v16 = v11 + 8 * v12;
    *int v14 = atomic_exchange(a2, 0);
    ++v15;
    sub_1DC34D7DC(v3, &v13);
    uint64_t v7 = (void *)v3[1];
    CFTypeRef result = (uint64_t *)sub_1DC308428((uint64_t)&v13);
  }
  else
  {
    *atomic_ullong v6 = atomic_exchange(a2, 0);
    uint64_t v7 = v6 + 1;
    result[1] = (uint64_t)v7;
  }
  v3[1] = (uint64_t)v7;
  return result;
}

void sub_1DC3CA028(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC308428((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3CA03C(uint64_t a1)
{
  sub_1DC3A89D4(*(void **)(a1 + 104));
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *sub_1DC3CA088(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    atomic_ullong v6 = result;
    CFTypeRef result = sub_1DC34D888(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      CFTypeRef result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1DC3CA0E8(_Unwind_Exception *exception_object)
{
  char v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3CA108(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1DC3CA12C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3662270;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC3CA180(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3662270;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *sub_1DC3CA1A4(void *result, unsigned __int8 *a2, unsigned __int8 *a3, unint64_t a4)
{
  if (a4 >= 0x3FFFFFFFFFFFFFF8) {
    sub_1DC3127EC();
  }
  uint64_t v7 = result;
  if (a4 > 4)
  {
    uint64_t v8 = (a4 & 0xFFFFFFFFFFFFFFFELL) + 2;
    if ((a4 | 1) != 5) {
      uint64_t v8 = a4 | 1;
    }
    CFTypeRef result = sub_1DC314E5C(v8 + 1);
    v7[1] = a4;
    v7[2] = v9 | 0x8000000000000000;
    *uint64_t v7 = result;
    uint64_t v7 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    int v10 = *a2++;
    *(_DWORD *)uint64_t v7 = v10;
    uint64_t v7 = (void *)((char *)v7 + 4);
  }
  *(_DWORD *)uint64_t v7 = 0;
  return result;
}

uint64_t sub_1DC3CA23C(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6)
{
  unint64_t v11 = *((void *)a2 + 1);
  if ((a2[23] & 0x80u) == 0)
  {
    unint64_t v12 = a2[23];
  }
  else
  {
    a2 = *(unsigned __int8 **)a2;
    unint64_t v12 = v11;
  }
  sub_1DC3CA1A4(&v16, a2, &a2[v12], v12);
  unint64_t v13 = a4 | ((unint64_t)a3 << 32);
  unint64_t v14 = a5 | (unint64_t)(a3 << 32);
  *(void *)a1 = 0x200000000;
  *(_OWORD *)(a1 + 8) = v16;
  *(void *)(a1 + 24) = v17;
  *(void *)(a1 + 32) = v13;
  *(void *)(a1 + 40) = v14;
  *(void *)(a1 + 48) = v14;
  *(void *)(a1 + 56) = v13;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)a6;
  *(void *)(a1 + 80) = *(void *)(a6 + 16);
  *(void *)a6 = 0;
  *(void *)(a6 + 8) = 0;
  *(void *)(a6 + 16) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  *(unsigned char *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 88) = 8 * (*(_DWORD *)(a1 + 72) - *(_DWORD *)(a1 + 64));
  return a1;
}

void **sub_1DC3CA328(uint64_t a1, __int16 a2, int a3, uint64_t a4)
{
  unsigned int v8 = 0;
  do
  {
    unsigned int v9 = a3 + v8;
    if (*(_DWORD *)(a4 + 16) >= a3 + v8) {
      __int16 v10 = *(_WORD *)(*(void *)(a4 + 8) + 2 * v9);
    }
    else {
      __int16 v10 = 0;
    }
    CFTypeRef result = sub_1DC3CA3B4((void **)a4, v9, (__int16)(v10 + *(_WORD *)(*(void *)(a1 + 8) + 2 * v8++) * a2));
  }
  while (v8 <= *(_DWORD *)(a1 + 16));
  return result;
}

void **sub_1DC3CA3B4(void **result, unsigned int a2, int a3)
{
  CFAllocatorRef v4 = result;
  unsigned int v5 = *((_DWORD *)result + 4);
  if (a3)
  {
    __int16 v6 = a3;
    if (v5 < a2) {
      CFTypeRef result = sub_1DC3CA460(result, a2, 0);
    }
    *((_WORD *)v4[1] + a2) = v6;
  }
  else if (v5 >= a2)
  {
    if (v5 != a2 || v5 == 0)
    {
      *((_WORD *)result[1] + a2) = 0;
    }
    else
    {
      uint64_t v8 = a2 - 1;
      *((_DWORD *)result + 4) = v8;
      if (a2 != 1)
      {
        unsigned int v9 = result[1];
        if (!v9[v8])
        {
          __int16 v10 = (char *)(v9 - 1);
          do
          {
            int v11 = v8 - 1;
            if (v8 == 1) {
              break;
            }
          }
          while (!*(unsigned __int16 *)&v10[2 * v8--]);
          *((_DWORD *)result + 4) = v11;
        }
      }
    }
  }
  return result;
}

void **sub_1DC3CA460(void **result, unsigned int a2, int a3)
{
  unsigned int v5 = result;
  unsigned int v6 = *((_DWORD *)result + 4);
  if (v6 >= a2 && (uint64_t v7 = result[1]) != 0)
  {
    *((_DWORD *)result + 4) = a2;
    if (a2 && a3 && !v7[a2])
    {
      uint64_t v8 = a2;
      unsigned int v9 = v7 - 1;
      do
      {
        int v10 = v8 - 1;
        if (v8 == 1) {
          break;
        }
      }
      while (!v9[v8--]);
      goto LABEL_31;
    }
  }
  else
  {
    unsigned int v12 = *((_DWORD *)result + 5);
    if (v12 <= a2)
    {
      unint64_t v13 = result[1];
      if (v13)
      {
        int v14 = 2 * v12;
        unsigned int v15 = a2;
        if (2 * v12)
        {
          do
          {
            unsigned int v15 = v14;
            v14 *= 2;
          }
          while (v15 <= a2);
        }
      }
      else
      {
        unsigned int v15 = a2 + 1;
      }
      CFTypeRef result = (void **)malloc_type_realloc(result[1], 2 * v15, 0xF8274CFDuLL);
      v5[1] = result;
      if (!result)
      {
        exceptiouint64_t n = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x1E019CAC0](exception, "Malloc failure");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      if (!v13) {
        *(_WORD *)CFTypeRef result = 0;
      }
      *((_DWORD *)v5 + 5) = v15;
      unsigned int v6 = *((_DWORD *)v5 + 4);
    }
    unsigned int v16 = v6 + 1;
    if (v16 <= a2)
    {
      uint64_t v17 = v5[1];
      do
        v17[v16++] = 0;
      while (v16 <= a2);
    }
    if (!a2)
    {
      int v10 = 0;
      *(_WORD *)v5[1] = 0;
LABEL_31:
      *((_DWORD *)v5 + 4) = v10;
      return result;
    }
    *((_DWORD *)v5 + 4) = a2;
    if (a3)
    {
      unint64_t v18 = v5[1];
      if (!v18[a2])
      {
        uint64_t v19 = a2;
        unint64_t v20 = v18 - 1;
        do
        {
          int v21 = v19 - 1;
          if (v19 == 1) {
            break;
          }
        }
        while (!v20[v19--]);
        int v10 = v21;
        goto LABEL_31;
      }
    }
  }
  return result;
}

void sub_1DC3CA5E8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3CA5FC(uint64_t a1, __int16 a2)
{
  __int16 v2 = 0;
  int v3 = *(_DWORD *)(a1 + 16);
  CFAllocatorRef v4 = *(__int16 **)(a1 + 8);
  __int16 v5 = 1;
  if ((v3 + 1) > 1) {
    uint64_t v6 = (v3 + 1);
  }
  else {
    uint64_t v6 = 1;
  }
  do
  {
    __int16 v7 = *v4++;
    v2 += v7 * v5;
    v5 *= a2;
    --v6;
  }
  while (v6);
  return v2;
}

void sub_1DC3CA63C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 == a3 || a4 == a1 || a4 == a2)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1E019CAC0](exception, "Invalid rem argument");
    goto LABEL_42;
  }
  uint64_t v8 = *(void *)(a2 + 8);
  unsigned int v9 = 1;
  do
  {
    int v10 = *(unsigned __int16 *)(v8 + 2 * (v9 - 1));
    if (*(_WORD *)(v8 + 2 * (v9 - 1))) {
      BOOL v11 = 1;
    }
    else {
      BOOL v11 = v9 > *(_DWORD *)(a2 + 16);
    }
    ++v9;
  }
  while (!v11);
  if (!v10)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1E019CAC0](exception, "Divide by zero");
LABEL_42:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  if (a3 == a1) {
    operator new();
  }
  sub_1DC3CA460((void **)a3, 0, 1);
  **(_WORD **)(a3 + 8) = 0;
  sub_1DC3CA9F4(a4, a1);
  unint64_t v12 = *(unsigned int *)(a2 + 16);
  int v13 = *(__int16 *)(*(void *)(a2 + 8) + 2 * v12);
  float v30 = 0;
  uint64_t v31 = 0;
  unint64_t v29 = &unk_1F3660AE0;
  sub_1DC3CA460(&v29, 0, 1);
  double v27 = 0;
  uint64_t v28 = 0;
  double v26 = &unk_1F3660AE0;
  sub_1DC3CA460(&v26, 0, 1);
  while (1)
  {
    unint64_t v14 = *(unsigned int *)(a4 + 16);
    uint64_t v15 = *(void *)(a4 + 8);
    unsigned int v16 = 1;
    do
    {
      int v17 = *(unsigned __int16 *)(v15 + 2 * (v16 - 1));
      if (*(_WORD *)(v15 + 2 * (v16 - 1))) {
        BOOL v18 = 1;
      }
      else {
        BOOL v18 = v16 > v14;
      }
      ++v16;
    }
    while (!v18);
    if (!v17 || v14 < v12) {
      break;
    }
    int v20 = *(__int16 *)(v15 + 2 * v14) / v13;
    if (!(_WORD)v20)
    {
      uint64_t v21 = v15 - 2;
      unint64_t v22 = *(unsigned int *)(a4 + 16);
      while (v22)
      {
        unint64_t v23 = v22 - 1;
        if (v22 - 1 < v12) {
          break;
        }
        if (v23 <= v14) {
          __int16 v24 = *(_WORD *)(v21 + 2 * v22);
        }
        else {
          __int16 v24 = 0;
        }
        int v20 = v24 / v13;
        unint64_t v22 = v23;
        if ((_WORD)v20)
        {
          LODWORD(v14) = v23;
          goto LABEL_26;
        }
      }
      break;
    }
LABEL_26:
    sub_1DC3CA460(&v29, 0, 1);
    *(_WORD *)float v30 = 0;
    sub_1DC3CA3B4(&v29, v14 - v12, (__int16)v20);
    sub_1DC3CAA98((uint64_t)&v29, a3, (void **)a3);
    sub_1DC3CAB58((uint64_t)&v29, a2, (uint64_t)&v26);
    (*(void (**)(uint64_t, void **, uint64_t))(*(void *)a4 + 24))(a4, &v26, a4);
  }
  double v26 = &unk_1F3660AE0;
  if (v27) {
    free(v27);
  }
  unint64_t v29 = &unk_1F3660AE0;
  if (v30) {
    free(v30);
  }
}

void sub_1DC3CA984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{
  MEMORY[0x1E019CE90](v15, 0x1091C403BDA009ALL);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3CA9F4(uint64_t a1, uint64_t a2)
{
  sub_1DC3CA460((void **)a1, *(_DWORD *)(a2 + 16), 0);
  unint64_t v4 = 0;
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  unint64_t v6 = *(unsigned int *)(a2 + 16);
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a2 + 8);
  if ((v5 + 1) > 1) {
    uint64_t v9 = (v5 + 1);
  }
  else {
    uint64_t v9 = 1;
  }
  do
  {
    if (v4 <= v6) {
      __int16 v10 = *(_WORD *)(v8 + 2 * v4);
    }
    else {
      __int16 v10 = 0;
    }
    *(_WORD *)(v7 + 2 * v4++) = v10;
  }
  while (v9 != v4);
  if (v5 && !*(_WORD *)(v7 + 2 * v5))
  {
    uint64_t v11 = v7 - 2;
    do
    {
      int v12 = v5 - 1;
      if (v5 == 1) {
        break;
      }
    }
    while (!*(unsigned __int16 *)(v11 + 2 * v5--));
    *(_DWORD *)(a1 + 16) = v12;
  }
  return a1;
}

void **sub_1DC3CAA98(uint64_t a1, uint64_t a2, void **a3)
{
  unsigned int v6 = 0;
  if (*(_DWORD *)(a2 + 16) <= *(_DWORD *)(a1 + 16)) {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
  }
  else {
    unsigned int v7 = *(_DWORD *)(a2 + 16);
  }
  do
  {
    if (*(_DWORD *)(a2 + 16) >= v6) {
      __int16 v8 = *(_WORD *)(*(void *)(a2 + 8) + 2 * v6);
    }
    else {
      __int16 v8 = 0;
    }
    if (*(_DWORD *)(a1 + 16) >= v6) {
      __int16 v9 = *(_WORD *)(*(void *)(a1 + 8) + 2 * v6);
    }
    else {
      __int16 v9 = 0;
    }
    sub_1DC3CA3B4(a3, v6++, (__int16)(v9 + v8));
  }
  while (v6 <= v7);
  return sub_1DC3CA460(a3, v7, 1);
}

uint64_t sub_1DC3CAB58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 == a1) {
    operator new();
  }
  sub_1DC3CA460((void **)a3, 0, 1);
  **(_WORD **)(a3 + 8) = 0;
  uint64_t v6 = 0;
  do
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 72))(a1, *(__int16 *)(*(void *)(a2 + 8) + 2 * v6), v6, a3);
    uint64_t v6 = (v6 + 1);
  }
  while (v6 <= *(_DWORD *)(a2 + 16));
  return result;
}

void sub_1DC3CACB8(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x1091C403BDA009ALL);
  _Unwind_Resume(a1);
}

void *sub_1DC3CACDC(void *a1)
{
  *a1 = &unk_1F3660AE0;
  __int16 v2 = (void *)a1[1];
  if (v2)
  {
    free(v2);
    a1[1] = 0;
  }
  a1[2] = 0;
  return a1;
}

void **sub_1DC3CAD30(uint64_t a1, __int16 a2, void **a3)
{
  unsigned int v6 = 0;
  do
  {
    uint64_t result = sub_1DC3CA3B4(a3, v6, (__int16)(*(_WORD *)(*(void *)(a1 + 8) + 2 * v6) * a2));
    ++v6;
  }
  while (v6 <= *(_DWORD *)(a1 + 16));
  return result;
}

uint64_t sub_1DC3CAD90(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, a1);
}

void **sub_1DC3CADC0(uint64_t a1, uint64_t a2, void **a3)
{
  unsigned int v6 = 0;
  if (*(_DWORD *)(a2 + 16) <= *(_DWORD *)(a1 + 16)) {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
  }
  else {
    unsigned int v7 = *(_DWORD *)(a2 + 16);
  }
  do
  {
    if (*(_DWORD *)(a1 + 16) >= v6) {
      __int16 v8 = *(_WORD *)(*(void *)(a1 + 8) + 2 * v6);
    }
    else {
      __int16 v8 = 0;
    }
    if (*(_DWORD *)(a2 + 16) >= v6) {
      __int16 v9 = *(_WORD *)(*(void *)(a2 + 8) + 2 * v6);
    }
    else {
      __int16 v9 = 0;
    }
    sub_1DC3CA3B4(a3, v6++, (__int16)(v8 - v9));
  }
  while (v6 <= v7);
  return sub_1DC3CA460(a3, v7, 1);
}

void sub_1DC3CAE80(void *a1)
{
  *a1 = &unk_1F3660AE0;
  __int16 v2 = (void *)a1[1];
  if (v2)
  {
    free(v2);
    a1[1] = 0;
  }
  a1[2] = 0;
  JUMPOUT(0x1E019CE90);
}

void **sub_1DC3CAEF4(uint64_t a1, int a2, unsigned __int16 a3, uint64_t a4)
{
  unsigned __int16 v7 = 0;
  uint64_t v8 = (unsigned __int16)a2;
  uint64_t v9 = a3;
  do
  {
    __int16 v10 = *(void **)(a1 + 24);
    uint64_t v11 = v7;
    if (a2 && *(_WORD *)(*(void *)(a1 + 8) + 2 * v7))
    {
      uint64_t v12 = v10[4];
      uint64_t v13 = *(unsigned __int16 *)(v12 + 2 * *(unsigned __int16 *)(*(void *)(a1 + 8) + 2 * v7));
      uint64_t v14 = *(unsigned __int16 *)(v12 + 2 * v8);
      uint64_t v15 = v10[2];
      uint64_t v16 = *(unsigned __int16 *)(v10[3] + 2 * *(unsigned __int16 *)(v15 + 2 * (v14 + v13)));
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v15 = v10[2];
    }
    unsigned int v17 = *(unsigned __int16 *)(v15 + 2 * (v11 + v9));
    if (*(_DWORD *)(a4 + 16) >= v17) {
      uint64_t v18 = *(unsigned __int16 *)(*(void *)(a4 + 8) + 2 * *(unsigned __int16 *)(v15 + 2 * (v11 + v9)));
    }
    else {
      uint64_t v18 = 0;
    }
    uint64_t result = sub_1DC3CA3B4((void **)a4, v17, *(__int16 *)(v10[1] + 2 * (v18 + v16)));
    unsigned __int16 v7 = v11 + 1;
  }
  while (*(_DWORD *)(a1 + 16) >= (unsigned __int16)(v11 + 1));
  return result;
}

uint64_t sub_1DC3CAFC0(uint64_t a1, int a2)
{
  uint64_t v2 = 0;
  int v3 = *(unsigned __int16 **)(a1 + 24);
  int v4 = *(_DWORD *)(a1 + 16);
  uint64_t v5 = *(unsigned __int16 **)(a1 + 8);
  unsigned int v6 = 1;
  if ((v4 + 1) > 1) {
    uint64_t v7 = (v4 + 1);
  }
  else {
    uint64_t v7 = 1;
  }
  do
  {
    uint64_t v8 = 0;
    unsigned int v10 = *v5++;
    uint64_t v9 = v10;
    if (v6 && v9) {
      uint64_t v8 = *(unsigned __int16 *)(*((void *)v3 + 3)
    }
                               + 2
                               * *(unsigned __int16 *)(*((void *)v3 + 2)
                                                     + 2
                                                     * (*(unsigned __int16 *)(*((void *)v3 + 4) + 2 * v6)
                                                      + (unint64_t)*(unsigned __int16 *)(*((void *)v3 + 4)
                                                                                              + 2 * v9))));
    unsigned int v11 = 0;
    if ((*v3 & (unsigned __int16)((a2 % *v3) >> 31)) + (unsigned __int16)(a2 % *v3) && v6) {
      unsigned int v11 = *(unsigned __int16 *)(*((void *)v3 + 3)
    }
                                + 2
                                * *(unsigned __int16 *)(*((void *)v3 + 2)
                                                      + 2
                                                      * (*(unsigned __int16 *)(*((void *)v3 + 4)
                                                                             + 2
                                                                             * (unsigned __int16)((*v3 & ((a2 % *v3) >> 31))
                                                                                                + a2 % *v3))
                                                       + (unint64_t)*(unsigned __int16 *)(*((void *)v3 + 4)
                                                                                               + 2 * v6))));
    LOWORD(v2) = *(_WORD *)(*((void *)v3 + 1) + 2 * (v8 + v2));
    unsigned int v6 = v11;
    --v7;
  }
  while (v7);
  return (__int16)v2;
}

void sub_1DC3CB06C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a2 + 8);
  unsigned int v7 = 1;
  do
  {
    int v8 = *(unsigned __int16 *)(v6 + 2 * (v7 - 1));
    if (*(_WORD *)(v6 + 2 * (v7 - 1))) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = v7 > *(_DWORD *)(a2 + 16);
    }
    ++v7;
  }
  while (!v9);
  if (!v8)
  {
    exceptiouint64_t n = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1E019CAC0](exception, "Divide by zero");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  uint64_t v10 = *(void *)(a1 + 24);
  unint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v39 = &unk_1F3660AE0;
  sub_1DC3CA460(&v39, 0, 1);
  uint64_t v39 = &unk_1F3660B68;
  uint64_t v42 = v10;
  uint64_t v11 = *(unsigned int *)(a2 + 16);
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t v13 = *(unsigned __int16 *)(*(void *)(v12 + 40) + 2 * *(unsigned __int16 *)(*(void *)(a2 + 8) + 2 * v11));
  double v36 = 0;
  uint64_t v37 = 0;
  double v35 = &unk_1F3660AE0;
  sub_1DC3CA460(&v35, 0, 1);
  double v35 = &unk_1F3660B68;
  uint64_t v38 = v12;
  uint64_t v14 = *(void *)(a1 + 24);
  unint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v31 = &unk_1F3660AE0;
  sub_1DC3CA460(&v31, 0, 1);
  uint64_t v31 = &unk_1F3660B68;
  uint64_t v34 = v14;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  double v27 = &unk_1F3660AE0;
  sub_1DC3CA9F4((uint64_t)&v27, a1);
  uint64_t v15 = *(void *)(a1 + 24);
  double v27 = &unk_1F3660B68;
  uint64_t v30 = v15;
  while (1)
  {
    unsigned int v16 = 1;
    do
    {
      int v17 = *((unsigned __int16 *)v28 + v16 - 1);
      if (*((_WORD *)v28 + v16 - 1)) {
        BOOL v18 = 1;
      }
      else {
        BOOL v18 = v16 > v29;
      }
      ++v16;
    }
    while (!v18);
    if (!v17 || v29 < v11) {
      break;
    }
    __int16 v20 = 0;
    uint64_t v21 = *(void **)(a1 + 24);
    uint64_t v22 = v21[2];
    if (v13 && *((_WORD *)v28 + v29)) {
      __int16 v20 = *(_WORD *)(v21[3]
    }
                     + 2
                     * *(unsigned __int16 *)(v22
                                           + 2
                                           * (*(unsigned __int16 *)(v21[4] + 2 * v13)
                                            + (unint64_t)*(unsigned __int16 *)(v21[4]
                                                                                    + 2
                                                                                    * *((unsigned __int16 *)v28
                                                                                      + v29)))));
    unsigned int v23 = *(unsigned __int16 *)(v22
                              + 2
                              * ((~v11 | 0xFFFFFFFFFFFF0000)
                               + (unsigned __int16)v29
                               + *(unsigned __int16 *)v21));
    sub_1DC3CA460(&v35, 0, 1);
    *(_WORD *)double v36 = 0;
    sub_1DC3CA3B4(&v35, v23, v20);
    sub_1DC3CB450((uint64_t)&v35, (uint64_t)&v39, &v39);
    sub_1DC3CB518((uint64_t)&v35, a2, (uint64_t)&v31);
    sub_1DC3CB69C((uint64_t)&v27, (uint64_t)&v31, &v27);
  }
  sub_1DC3CA9F4(a4, (uint64_t)&v27);
  sub_1DC3CA9F4(a3, (uint64_t)&v39);
  double v27 = &unk_1F3660AE0;
  if (v28) {
    free(v28);
  }
  uint64_t v31 = &unk_1F3660AE0;
  if (v32) {
    free(v32);
  }
  double v35 = &unk_1F3660AE0;
  if (v36) {
    free(v36);
  }
  uint64_t v39 = &unk_1F3660AE0;
  if (v40) {
    free(v40);
  }
}

void sub_1DC3CB3D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  __cxa_free_exception(v25);
  _Unwind_Resume(a1);
}

void **sub_1DC3CB450(uint64_t a1, uint64_t a2, void **a3)
{
  unsigned int v6 = 0;
  if (*(_DWORD *)(a2 + 16) <= *(_DWORD *)(a1 + 16)) {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
  }
  else {
    unsigned int v7 = *(_DWORD *)(a2 + 16);
  }
  do
  {
    if (*(_DWORD *)(a2 + 16) >= v6) {
      uint64_t v8 = *(unsigned __int16 *)(*(void *)(a2 + 8) + 2 * v6);
    }
    else {
      uint64_t v8 = 0;
    }
    if (*(_DWORD *)(a1 + 16) >= v6) {
      uint64_t v9 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 2 * v6);
    }
    else {
      uint64_t v9 = 0;
    }
    sub_1DC3CA3B4(a3, v6++, *(__int16 *)(*(void *)(*(void *)(a1 + 24) + 8) + 2 * (v9 + v8)));
  }
  while (v6 <= v7);
  return sub_1DC3CA460(a3, v7, 1);
}

uint64_t sub_1DC3CB518(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 == a1) {
    operator new();
  }
  sub_1DC3CA460((void **)a3, 0, 1);
  **(_WORD **)(a3 + 8) = 0;
  uint64_t v6 = 0;
  do
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 72))(a1, *(__int16 *)(*(void *)(a2 + 8) + 2 * v6), v6, a3);
    uint64_t v6 = (v6 + 1);
  }
  while (v6 <= *(_DWORD *)(a2 + 16));
  return result;
}

void sub_1DC3CB678(_Unwind_Exception *a1)
{
  MEMORY[0x1E019CE90](v1, 0x1091C403BDA009ALL);
  _Unwind_Resume(a1);
}

void **sub_1DC3CB69C(uint64_t a1, uint64_t a2, void **a3)
{
  unsigned int v6 = 0;
  if (*(_DWORD *)(a2 + 16) <= *(_DWORD *)(a1 + 16)) {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
  }
  else {
    unsigned int v7 = *(_DWORD *)(a2 + 16);
  }
  do
  {
    if (*(_DWORD *)(a1 + 16) >= v6) {
      uint64_t v8 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 2 * v6);
    }
    else {
      uint64_t v8 = 0;
    }
    if (*(_DWORD *)(a2 + 16) >= v6) {
      uint64_t v9 = *(unsigned __int16 *)(*(void *)(a2 + 8) + 2 * v6);
    }
    else {
      uint64_t v9 = 0;
    }
    sub_1DC3CA3B4(a3, v6++, *(__int16 *)(*(void *)(*(void *)(a1 + 24) + 8) + 2 * (v8 - v9 + **(unsigned __int16 **)(a1 + 24))));
  }
  while (v6 <= v7);
  return sub_1DC3CA460(a3, v7, 1);
}

void **sub_1DC3CB76C(uint64_t a1, int a2, void **a3)
{
  unsigned int v6 = 0;
  uint64_t v7 = (unsigned __int16)a2;
  do
  {
    __int16 v8 = 0;
    if (a2)
    {
      if (*(_WORD *)(*(void *)(a1 + 8) + 2 * v6))
      {
        uint64_t v9 = *(void **)(a1 + 24);
        __int16 v8 = *(_WORD *)(v9[3]
                      + 2
                      * *(unsigned __int16 *)(v9[2]
                                            + 2
                                            * (*(unsigned __int16 *)(v9[4]
                                                                   + 2
                                                                   * *(unsigned __int16 *)(*(void *)(a1 + 8) + 2 * v6))
                                             + (unint64_t)*(unsigned __int16 *)(v9[4] + 2 * v7))));
      }
    }
    uint64_t result = sub_1DC3CA3B4(a3, v6++, v8);
  }
  while (v6 <= *(_DWORD *)(a1 + 16));
  return result;
}

void **sub_1DC3CB800(uint64_t a1, uint64_t a2, void **a3)
{
  unsigned int v6 = 0;
  if (*(_DWORD *)(a2 + 16) <= *(_DWORD *)(a1 + 16)) {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
  }
  else {
    unsigned int v7 = *(_DWORD *)(a2 + 16);
  }
  do
  {
    if (*(_DWORD *)(a2 + 16) >= v6) {
      uint64_t v8 = *(unsigned __int16 *)(*(void *)(a2 + 8) + 2 * v6);
    }
    else {
      uint64_t v8 = 0;
    }
    if (*(_DWORD *)(a1 + 16) >= v6) {
      uint64_t v9 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 2 * v6);
    }
    else {
      uint64_t v9 = 0;
    }
    sub_1DC3CA3B4(a3, v6++, *(__int16 *)(*(void *)(*(void *)(a1 + 24) + 8) + 2 * (v8 - v9 + **(unsigned __int16 **)(a1 + 24))));
  }
  while (v6 <= v7);
  return sub_1DC3CA460(a3, v7, 1);
}

void sub_1DC3CB8D0(void *a1)
{
  *a1 = &unk_1F3660AE0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    free(v2);
    a1[1] = 0;
  }
  a1[2] = 0;
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3CB944(void *a1)
{
  *a1 = &unk_1F3660AE0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    free(v2);
    a1[1] = 0;
  }
  a1[2] = 0;
  return a1;
}

uint64_t sub_1DC3CB998(uint64_t a1, uint64_t a2, unsigned int a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F3660AE0;
  sub_1DC3CA460((void **)a1, a3, 1);
  if (*(_DWORD *)(a1 + 16) < a3) {
    sub_1DC3CA460((void **)a1, a3, 0);
  }
  *(_WORD *)(*(void *)(a1 + 8) + 2 * a3) = 1;
  *(void *)a1 = &unk_1F3660B68;
  *(void *)(a1 + 24) = a2;
  return a1;
}

uint64_t sub_1DC3CBA40(uint64_t a1, uint64_t a2)
{
  sub_1DC3CA460((void **)a1, *(_DWORD *)(a2 + 16), 0);
  unsigned int v4 = 0;
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v8 = *(void *)(a1 + 8);
  do
  {
    if (v6 >= v4) {
      __int16 v9 = *(_WORD *)(v7 + 2 * (unsigned __int16)v4);
    }
    else {
      __int16 v9 = 0;
    }
    *(_WORD *)(v8 + 2 * (unsigned __int16)v4++) = v9;
  }
  while (v5 >= (unsigned __int16)v4);
  if (v5 && !*(_WORD *)(v8 + 2 * v5))
  {
    uint64_t v10 = v8 - 2;
    do
    {
      int v11 = v5 - 1;
      if (v5 == 1) {
        break;
      }
    }
    while (!*(unsigned __int16 *)(v10 + 2 * v5--));
    *(_DWORD *)(a1 + 16) = v11;
  }
  return a1;
}

atomic_ullong *sub_1DC3CBAD8(atomic_ullong *a1, atomic_ullong *a2)
{
  if (atomic_load_explicit(a1, memory_order_acquire))
  {
    if (atomic_load_explicit(a2, memory_order_acquire))
    {
      OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
      size_t Width = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
      size_t Height = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"<CVPixelBuffer %p: ", atomic_load_explicit(a2, memory_order_acquire));
      unint64_t explicit = (__CFString *)atomic_load_explicit(a1, memory_order_acquire);
      int v8 = HIBYTE(PixelFormatType);
      if (HIBYTE(PixelFormatType) - 32 >= 0x5Fu) {
        int v8 = 46;
      }
      if (PixelFormatType - 32 >= 0x5F) {
        uint64_t v9 = 46;
      }
      else {
        uint64_t v9 = PixelFormatType;
      }
      int32x2_t v10 = (int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(PixelFormatType), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
      int8x8_t v11 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x5F0000005FLL, (uint32x2_t)vand_s8((int8x8_t)vadd_s32(v10, (int32x2_t)0xE0000000E0), (int8x8_t)0xFF000000FFLL)), (int8x8_t)v10, (int8x8_t)0x2E0000002ELL);
      v12.i64[0] = v11.u32[0];
      v12.i64[1] = v11.u32[1];
      v13.i64[0] = 255;
      v13.i64[1] = 255;
      uint64x2_t v14 = vshlq_u64((uint64x2_t)vandq_s8(v12, v13), (uint64x2_t)xmmword_1DC3FDC10);
      uint64_t v15 = v14.i64[0] | (v9 << 24) | v14.i64[1];
      char v34 = BYTE4(v15);
      int v33 = v15 | v8;
      CFStringAppendFormat(explicit, 0, @"pixelFormatType=%.4s, ", &v33);
      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"width=%zu, ", Width);
      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"height=%zu, ", Height);
      int IsPlanar = CVPixelBufferIsPlanar((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
      int v17 = (__CFString *)atomic_load_explicit(a1, memory_order_acquire);
      if (IsPlanar)
      {
        CFStringAppend(v17, @"planar, ");
        size_t PlaneCount = CVPixelBufferGetPlaneCount((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"planeCount=%zu, ", PlaneCount);
        if (PlaneCount)
        {
          size_t v19 = 0;
          do
          {
            size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), v19);
            size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), v19);
            BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), v19);
            size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire), v19);
            CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"widthOfPlane%zu=%zu, ", v19, WidthOfPlane);
            CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"heightOfPlane%zu=%zu, ", v19, HeightOfPlane);
            CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"baseAddressOfPlane%zu=%p, ", v19, BaseAddressOfPlane);
            CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"bytesPerRowOfPlane%zu=%zu", v19++, BytesPerRowOfPlane);
            if (v19 < PlaneCount) {
              CFStringAppend((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), @", ");
            }
          }
          while (PlaneCount != v19);
        }
      }
      else
      {
        CFStringAppend(v17, @"non-planar, ");
        BaseAddress = CVPixelBufferGetBaseAddress((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
        size_t BytesPerRow = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"baseAddress=%p, ", BaseAddress);
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"bytesPerRow=%zu", BytesPerRow);
      }
      IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface((CVPixelBufferRef)atomic_load_explicit(a2, memory_order_acquire));
      if (IOSurface)
      {
        uint64_t v29 = IOSurface;
        CFStringAppend((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), @", ");
        CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"surface=%p, ", v29);
        uint64_t v30 = (__CFString *)atomic_load_explicit(a1, memory_order_acquire);
        uint64_t ID = IOSurfaceGetID(v29);
        CFStringAppendFormat(v30, 0, @"surfaceID=%#x", ID);
      }
      __int16 v24 = (__CFString *)atomic_load_explicit(a1, memory_order_acquire);
      CFStringRef v25 = @">";
    }
    else
    {
      __int16 v24 = (__CFString *)atomic_load_explicit(a1, memory_order_acquire);
      CFStringRef v25 = @"<null>";
    }
    CFStringAppend(v24, v25);
  }
  return a1;
}

atomic_ullong *sub_1DC3CBE3C(atomic_ullong *a1, double a2)
{
  if (atomic_load_explicit(a1, memory_order_acquire))
  {
    if (fabs(a2) == INFINITY)
    {
      if ((*(void *)&a2 & 0x8000000000000000) != 0) {
        CFStringAppend((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), @"-");
      }
      CFStringAppend((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), @"Infinity");
    }
    else
    {
      CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), 0, @"%.*g", 17, *(void *)&a2);
    }
  }
  return a1;
}

atomic_ullong *sub_1DC3CBEE8(atomic_ullong *a1, double *a2)
{
  if (atomic_load_explicit(a1, memory_order_acquire))
  {
    CFStringAppend((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), @"{x=");
    sub_1DC3CBE3C(a1, *a2);
    CFStringAppend((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), @", y=");
    sub_1DC3CBE3C(a1, a2[1]);
    CFStringAppend((CFMutableStringRef)atomic_load_explicit(a1, memory_order_acquire), @"}");
  }
  return a1;
}

uint64_t sub_1DC3CBF60(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 56) = a2;
  return result;
}

void sub_1DC3CBF68(void *a1)
{
  *a1 = &unk_1F3660B40;
  sub_1DC3C7F04(a1 + 1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3CBFCC(void *a1)
{
  *a1 = &unk_1F3660B40;
  sub_1DC3C7F04(a1 + 1);
  return a1;
}

void sub_1DC3CC010(void *a1)
{
  *a1 = &unk_1F3660B40;
  sub_1DC3C7F04(a1 + 1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3CC074(void *a1)
{
  *a1 = &unk_1F3660B40;
  sub_1DC3C7F04(a1 + 1);
  return a1;
}

void *sub_1DC3CC0B8(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DC314E1C(a1, a2);
    unsigned int v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_1DC3CC114(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DC3CC130(uint64_t a1)
{
  if (a1 < 0) {
    sub_1DC2FF994();
  }
  return operator new(2 * a1);
}

double ACBSConfigCreate()
{
  sub_1DC3D566C();
  uint64_t v0 = malloc_type_calloc(1uLL, 0x28uLL, 0x1060040CBFE3DCFuLL);
  v0[1] = 8;
  v0[8] = 0;
  *(_WORD *)uint64_t v0 = 0;
  double result = NAN;
  *((_OWORD *)v0 + 1) = xmmword_1DC3FDDB0;
  *((unsigned char *)v0 + 36) = 0;
  return result;
}

void ACBSConfigFree(void *a1)
{
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  free(a1);
}

CFTypeRef ACBSConfigCopy(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  long long v2 = a2[1];
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(_OWORD *)a1 = v3;
  *(_OWORD *)(a1 + 16) = v2;
  CFTypeRef result = *(CFTypeRef *)(a1 + 8);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t ACBSConfigSetMaxQRModuleSamples(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t ACBSConfigSetMaxQRPatternSets(uint64_t result, int a2)
{
  *(_DWORD *)(result + 20) = a2;
  return result;
}

uint64_t ACBSConfigSetLocateMode(uint64_t result, int a2)
{
  *(_DWORD *)(result + 4) = a2;
  return result;
}

uint64_t ACBSConfigSetWantedLinearDecodeScanlines(uint64_t result, int a2)
{
  *(_DWORD *)(result + 28) = a2;
  return result;
}

uint64_t ACBSConfigSetMaxLinearDecodeScanlines(uint64_t result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  return result;
}

uint64_t ACBSConfigSetMaxLinearDecodeTime(uint64_t result, float a2)
{
  *(float *)(result + 32) = a2;
  return result;
}

CFArrayRef ACBSConfigSetSymbologiesEnabled(uint64_t a1, CFArrayRef theArray)
{
  unsigned int v4 = *(const void **)(a1 + 8);
  if (v4) {
    CFRelease(v4);
  }
  CFArrayRef result = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theArray);
  *(void *)(a1 + 8) = result;
  return result;
}

CFArrayRef ACBSConfigCopySymbologiesEnabled(uint64_t a1)
{
  CFArrayRef v1 = *(const __CFArray **)(a1 + 8);
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v1) {
    return CFArrayCreateCopy(v2, v1);
  }
  else {
    return CFArrayCreate(v2, 0, 0, MEMORY[0x1E4F1D510]);
  }
}

unsigned char *ACBSConfigSetDebuggingEnabled(unsigned char *result, char a2)
{
  *CFArrayRef result = a2;
  return result;
}

uint64_t ACBSConfigSetFailedLocationsEnabled(uint64_t result, char a2)
{
  *(unsigned char *)(result + 1) = a2;
  return result;
}

uint64_t ACBSConfigSetStopsAtFirstPyramidWith2DCode(uint64_t result, char a2)
{
  *(unsigned char *)(result + 36) = a2;
  return result;
}

__CFDictionary *ACBSCreateFrameInfoBySearchingForBarcodesInCGImage(uint64_t a1, CGImage *a2, uint64_t a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (CGRectIsNull(*(CGRect *)&a4)) {
    goto LABEL_4;
  }
  v29.origin.CGFloat x = a4;
  v29.origin.CGFloat y = a5;
  v29.size.vImagePixelCount width = a6;
  v29.size.vImagePixelCount height = a7;
  if (CGRectIsEmpty(v29)
    || (v30.origin.x = a4, v30.origin.y = a5, v30.size.vImagePixelCount width = a6, v30.size.height = a7, CGRectIsInfinite(v30)))
  {
LABEL_4:
    uint64x2_t v14 = 0;
  }
  else
  {
    v32.origin.CGFloat x = a4;
    v32.origin.CGFloat y = a5;
    v32.size.vImagePixelCount width = a6;
    v32.size.vImagePixelCount height = a7;
    a2 = CGImageCreateWithImageInRect(a2, v32);
    uint64x2_t v14 = a2;
  }
  unint64_t Width = CGImageGetWidth(a2);
  unint64_t Height = CGImageGetHeight(a2);
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  BOOL v18 = CGBitmapContextCreate(0, Width, Height, 8uLL, (4 * Width + 15) & 0xFFFFFFFFFFFFFFF0, DeviceRGB, 2u);
  if (!v18)
  {
    __int16 v20 = 0;
    if (!v14) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  size_t v19 = v18;
  v31.origin.CGFloat x = 0.0;
  v31.origin.CGFloat y = 0.0;
  v31.size.vImagePixelCount width = (double)Width;
  v31.size.vImagePixelCount height = (double)Height;
  CGContextDrawImage(v18, v31, a2);
  CVPixelBufferRef pixelBufferOut = 0;
  __int16 v20 = 0;
  if (!CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Width, Height, 0x34323066u, 0, &pixelBufferOut))
  {
    __int16 v20 = 0;
    if (!CVPixelBufferLockBaseAddress(pixelBufferOut, 0))
    {
      src.uintptr_t data = CGBitmapContextGetData(v19);
      src.vImagePixelCount height = CGBitmapContextGetHeight(v19);
      src.vImagePixelCount width = CGBitmapContextGetWidth(v19);
      src.rowBytes = CGBitmapContextGetBytesPerRow(v19);
      destYp.uintptr_t data = CVPixelBufferGetBaseAddressOfPlane(pixelBufferOut, 0);
      destYp.vImagePixelCount height = CVPixelBufferGetHeightOfPlane(pixelBufferOut, 0);
      destYp.vImagePixelCount width = CVPixelBufferGetWidthOfPlane(pixelBufferOut, 0);
      destYp.rowBytes = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferOut, 0);
      destCbCr.uintptr_t data = CVPixelBufferGetBaseAddressOfPlane(pixelBufferOut, 1uLL);
      destCbCr.vImagePixelCount height = CVPixelBufferGetHeightOfPlane(pixelBufferOut, 1uLL);
      destCbCr.vImagePixelCount width = CVPixelBufferGetWidthOfPlane(pixelBufferOut, 1uLL);
      destCbCr.rowBytes = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferOut, 1uLL);
      vImage_YpCbCrPixelRange v22 = *(vImage_YpCbCrPixelRange *)ymmword_1DC416308;
      __int16 v20 = 0;
      if (!vImageConvert_ARGBToYpCbCr_GenerateConversion((const vImage_ARGBToYpCbCrMatrix *)*MEMORY[0x1E4F167C8], &v22, &outInfo, kvImageARGB8888, kvImage420Yp8_CbCr8, 0))
      {
        __int16 v20 = 0;
        if (!vImageConvert_ARGB8888To420Yp8_CbCr8(&src, &destYp, &destCbCr, &outInfo, 0, 0)) {
          __int16 v20 = ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer(a1, pixelBufferOut, a3, 0.0, 0.0, (double)Width, (double)Height);
        }
      }
      CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
    }
  }
  if (pixelBufferOut) {
    CVPixelBufferRelease(pixelBufferOut);
  }
  CGContextRelease(v19);
  if (v14) {
LABEL_15:
  }
    CGImageRelease(v14);
LABEL_16:
  CGColorSpaceRelease(DeviceRGB);
  return v20;
}

__CFDictionary *ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer(uint64_t a1, CVPixelBufferRef pixelBuffer, uint64_t a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  if (CVPixelBufferGetPixelFormatType(pixelBuffer) == 1111970369)
  {
    if (CVPixelBufferIsPlanar(pixelBuffer)) {
      size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
    }
    else {
      size_t WidthOfPlane = CVPixelBufferGetWidth(pixelBuffer);
    }
    unint64_t v30 = WidthOfPlane;
    if (CVPixelBufferIsPlanar(pixelBuffer)) {
      size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
    }
    else {
      size_t HeightOfPlane = CVPixelBufferGetHeight(pixelBuffer);
    }
    unint64_t v32 = HeightOfPlane;
    v89.origin.double x = a4;
    v89.origin.double y = a5;
    v89.size.double width = a6;
    v89.size.double height = a7;
    if (CGRectIsNull(v89)) {
      goto LABEL_20;
    }
    v90.origin.double x = a4;
    v90.origin.double y = a5;
    v90.size.double width = a6;
    v90.size.double height = a7;
    if (CGRectIsEmpty(v90)
      || (v91.origin.x = a4, v91.origin.y = a5, v91.size.double width = a6, v91.size.height = a7, CGRectIsInfinite(v91)))
    {
LABEL_20:
      double v33 = (double)v30;
      double v34 = (double)v32;
      double x = 0.0;
      double y = 0.0;
      double width = (double)v30;
      double height = (double)v32;
      if (!pixelBuffer) {
        goto LABEL_50;
      }
    }
    else
    {
      double v33 = (double)v30;
      double v34 = (double)v32;
      v97.origin.double x = 0.0;
      v97.origin.double y = 0.0;
      v95.origin.double x = a4;
      v95.origin.double y = a5;
      v95.size.double width = a6;
      v95.size.double height = a7;
      v97.size.double width = (double)v30;
      v97.size.double height = (double)v32;
      CGRect v96 = CGRectIntersection(v95, v97);
      double x = v96.origin.x;
      double y = v96.origin.y;
      double width = v96.size.width;
      double height = v96.size.height;
      if (!pixelBuffer) {
        goto LABEL_50;
      }
    }
    CFTypeID TypeID = CVPixelBufferGetTypeID();
    if (TypeID == CFGetTypeID(pixelBuffer))
    {
      if (CVPixelBufferGetPixelFormatType(pixelBuffer) == 1111970369 && !CVPixelBufferLockBaseAddress(pixelBuffer, 0))
      {
        double v40 = x / v33;
        double v41 = y / v34;
        double v42 = width / v33;
        double v43 = height / v34;
        DeviceRGB = (CGColorSpace *)CVBufferCopyAttachment(pixelBuffer, (CFStringRef)*MEMORY[0x1E4F24A00], 0);
        if (!DeviceRGB) {
          DeviceRGB = CGColorSpaceCreateDeviceRGB();
        }
        CFDictionaryRef theDict = DeviceRGB;
        BaseAddress = (char *)CVPixelBufferGetBaseAddress(pixelBuffer);
        size_t v46 = CVPixelBufferGetHeight(pixelBuffer);
        size_t v47 = CVPixelBufferGetWidth(pixelBuffer);
        size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
        double v49 = v40 * (double)v47;
        double v50 = v41 * (double)v46;
        double v51 = v42 * (double)v47;
        double v52 = v43 * (double)v46;
        v92.origin.double x = v49;
        v92.origin.double y = v50;
        v92.size.double width = v51;
        v92.size.double height = v52;
        CGRect v93 = CGRectIntegral(v92);
        double v53 = v93.origin.x;
        double v54 = v93.origin.y;
        size_t v55 = (uint64_t)rint(v93.size.height);
        size_t v81 = (uint64_t)rint(v93.size.width);
        size_t v56 = (4 * v81 + 15) & 0xFFFFFFFFFFFFFFF0;
        std::locale __dst = (char *)malloc_type_malloc(v56 * v55, 0x113C99A5uLL);
        if (v55)
        {
          uint64_t v57 = (uint64_t)rint(v53);
          double v58 = rint(v54);
          if (v56 >= BytesPerRow) {
            size_t v59 = BytesPerRow;
          }
          else {
            size_t v59 = (4 * v81 + 15) & 0xFFFFFFFFFFFFFFF0;
          }
          int v60 = &BaseAddress[4 * v57 + BytesPerRow * (uint64_t)v58];
          float v61 = __dst;
          size_t v62 = v55;
          do
          {
            memcpy(v61, v60, v59);
            v61 += v56;
            v60 += BytesPerRow;
            --v62;
          }
          while (v62);
        }
        unsigned int v63 = CGDataProviderCreateWithData(0, __dst, v56 * v55, (CGDataProviderReleaseDataCallback)sub_1DC3DDD24);
        __int16 v64 = CGImageCreate(v81, v55, 8uLL, 0x20uLL, v56, theDict, 0x2002u, v63, 0, 0, kCGRenderingIntentPerceptual);
        v94.origin.double x = v49 - v53;
        v94.origin.double y = v50 - v54;
        v94.size.double width = v51;
        v94.size.double height = v52;
        int v65 = CGImageCreateWithImageInRect(v64, v94);
        CGImageRelease(v64);
        CGDataProviderRelease(v63);
        CGColorSpaceRelease(theDict);
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
        if (v65)
        {
          double v66 = (double)CGImageGetWidth(v65);
          size_t v67 = CGImageGetHeight(v65);
          uint64_t v68 = ACBSCreateFrameInfoBySearchingForBarcodesInCGImage(a1, v65, a3, 0.0, 0.0, v66, (double)v67);
          CGImageRelease(v65);
          return (__CFDictionary *)v68;
        }
        return 0;
      }
      goto LABEL_51;
    }
LABEL_50:
    CVPixelBufferGetTypeID();
    CFGetTypeID(pixelBuffer);
LABEL_51:
    CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
    return 0;
  }
  CFTypeRef v15 = CMGetAttachment(pixelBuffer, @"ImagePyramidArray", 0);
  unsigned int v16 = (atomic_ullong *)MRCSampleCreateWithCVPixelBufferAndPyramid(pixelBuffer, v15, a4, a5, a6, a7);
  if (v16)
  {
    int v17 = v16;
    MRCSampleGeneratePyramidIfNotPresent(v16);
    CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFArrayRef v20 = ACBSConfigCopySymbologiesEnabled(a1);
    CFDictionarySetValue(Mutable, @"MRCDecoderOptionSymbologies", v20);
    CFRelease(v20);
    sub_1DC3D5600(Mutable, @"MRCDecoderOptionLocatingMode", *(_DWORD *)(a1 + 4));
    sub_1DC3D5600(Mutable, @"MRCDecoderOptionMaximumQRModuleSamplingCount", *(_DWORD *)(a1 + 16));
    sub_1DC3D5600(Mutable, @"MRCDecoderOptionMaximumQRFinderPatternTripletCount", *(_DWORD *)(a1 + 20));
    LODWORD(valuePtr) = *(_DWORD *)(a1 + 32);
    CFNumberRef v21 = CFNumberCreate(v18, kCFNumberFloat32Type, &valuePtr);
    CFDictionarySetValue(Mutable, @"MRCDecoderOptionMaximum1DSymbologyDecodingTime", v21);
    CFRelease(v21);
    sub_1DC3D5600(Mutable, @"MRCDecoderOptionMaximum1DSymbologyDecodingScanlineCount", *(_DWORD *)(a1 + 24));
    sub_1DC3D5600(Mutable, @"MRCDecoderOptionMinimum1DSymbologyDecodingScanlineCount", *(_DWORD *)(a1 + 28));
    vImage_YpCbCrPixelRange v22 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!*(unsigned char *)(a1 + 36)) {
      vImage_YpCbCrPixelRange v22 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    CFDictionarySetValue(Mutable, @"MRCDecoderOptionShouldStopAtFirstPyramidWith2DSymbologies", *v22);
    unsigned int v23 = CFArrayCreateMutable(v18, 0, MEMORY[0x1E4F1D510]);
    CFArrayAppendValue(v23, @"LocatorPoints");
    CFArrayAppendValue(v23, @"FocusSharpness");
    if (*(unsigned char *)(a1 + 1)) {
      CFArrayAppendValue(v23, @"FrameFailedLocations");
    }
    if (*(unsigned char *)a1) {
      CFArrayAppendValue(v23, @"FrameDebugData");
    }
    CFDictionarySetValue(Mutable, @"MRCDecoderOptionNeededResultAttributes", v23);
    CFRelease(v23);
    uint64_t valuePtr = 0;
    CFNumberRef v24 = CFNumberCreate(v18, kCFNumberCFIndexType, &valuePtr);
    CFDictionarySetValue(Mutable, @"MRCDecoderOptionAlgorithmVersion", v24);
    CFRelease(v24);
    CFStringRef v25 = (const void *)MRCDecoderCreateWithOptions(Mutable);
    CFRelease(Mutable);
    CFErrorRef err = 0;
    double v27 = (atomic_ullong *)MRCDecoderDecodeSampleWithRegions(v26);
    CFRelease(v25);
    if (v27)
    {
      CFDictionaryRef v28 = MRCDecoderResultCopyAttributes(v27);
      MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(v18, 0, v28);
      CFRelease(v28);
    }
    else
    {
      MutableCFStringRef Copy = CFDictionaryCreateMutable(v18, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    int v86 = 0;
    sub_1DC3D5600(MutableCopy, @"FrameResultErrorCode", 0);
    if (v27)
    {
      DescriptorCFIndex Count = MRCDecoderResultGetDescriptorCount(v27);
      if (DescriptorCount >= 1)
      {
        CFIndex v71 = DescriptorCount;
        theDicta = MutableCopy;
        __dsta = v17;
        char v72 = CFArrayCreateMutable(v18, DescriptorCount, MEMORY[0x1E4F1D510]);
        for (unint64_t i = 0; i != v71; ++i)
        {
          DescriptorAtIndedouble x = (char *)MRCDecoderResultGetDescriptorAtIndex(v27, i);
          if (DescriptorAtIndex)
          {
            CFDictionaryRef v75 = (const __CFDictionary *)MRCDescriptorCopyAttributes(DescriptorAtIndex);
            CFDictionaryRef v76 = CFDictionaryCreateMutableCopy(v18, 0, v75);
            CFRelease(v75);
            char v77 = CFDictionaryCreateMutable(v18, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            for (uint64_t j = 0; j != 13; ++j)
            {
              unsigned __int16 v79 = *off_1E6C3AD88[j];
              int Value = CFDictionaryGetValue(v76, v79);
              if (Value)
              {
                CFDictionarySetValue(v77, v79, Value);
                CFDictionaryRemoveValue(v76, v79);
              }
            }
            CFDictionarySetValue(v76, @"CodeProperties", v77);
            CFRelease(v77);
            if (v76)
            {
              CFArrayAppendValue(v72, v76);
              CFRelease(v76);
            }
          }
        }
        MutableCFStringRef Copy = theDicta;
        CFDictionarySetValue(theDicta, @"SymbolDescriptionArray", v72);
        CFRelease(v72);
        int v17 = __dsta;
      }
      CFRelease(v27);
    }
    CFRelease(v17);
    return MutableCopy;
  }
  return 0;
}

CFDictionaryRef ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding(CFDictionaryRef theDict, const void *a2)
{
  if (!theDict) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  MutableCFStringRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theDict);
  if (MutableCopy)
  {
    CFDictionaryRef v5 = CFDictionaryCreateMutableCopy(v3, 0, MutableCopy);
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v5, @"CodeProperties");
    if (Value)
    {
      CFDictionaryRef v7 = Value;
      CFTypeID v8 = CFGetTypeID(Value);
      if (v8 == CFDictionaryGetTypeID())
      {
        for (uint64_t i = 0; i != 13; ++i)
        {
          int32x2_t v10 = *off_1E6C3AD88[i];
          int8x8_t v11 = CFDictionaryGetValue(v7, v10);
          if (v11) {
            CFDictionarySetValue(v5, v10, v11);
          }
        }
      }
      CFDictionaryRemoveValue(v5, @"CodeProperties");
    }
    int8x16_t v12 = (const void *)MRCDescriptorCreateWithAttributes(v5);
    CFRelease(v5);
    if (v12)
    {
      CFMutableStringRef Mutable = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      uint64x2_t v14 = Mutable;
      if (a2) {
        CFDictionarySetValue(Mutable, @"MRCDescriptorPayloadDecodingOptionDefaultEncoding", a2);
      }
      CFTypeRef v15 = (const void *)MRCDescriptorDecodePayloadWithOptions(v12, v14, 0);
      CFRelease(v12);
      CFRelease(v14);
      if (v15)
      {
        CFDictionarySetValue(MutableCopy, @"BarcodeString", v15);
        CFRelease(v15);
      }
    }
  }
  return MutableCopy;
}

CFDictionaryRef ACBSCreateSymbolDescriptorFromBasicDescriptor(const __CFDictionary *a1)
{
  return ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding(a1, 0);
}

uint64_t sub_1DC3CD004(uint64_t result, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  double v7 = floor(a4 + a6 * 0.5) + -10.0;
  if (v7 <= 0.0) {
    double v7 = 0.0;
  }
  int v8 = (int)v7;
  int v9 = (int)a5;
  unint64_t v10 = a3 - (int)v7;
  if (v10 >= 0x14) {
    LODWORD(v10) = 20;
  }
  int v11 = (int)a7;
  *(_DWORD *)(result + 40) = -1077342245;
  *(float *)(result + 44) = (float)(int)a7;
  *(float *)(result + 48) = (float)(int)v10;
  if ((int)a7 >= 0) {
    int v12 = (int)a7;
  }
  else {
    int v12 = v11 + 1;
  }
  *(_DWORD *)(result + 32) = v8 + (v10 >> 1);
  *(_DWORD *)(result + 36) = v9 + (v12 >> 1);
  *(_DWORD *)CFArrayRef result = v8;
  *(_DWORD *)(result + 4) = v9;
  int v13 = v9 + v11;
  *(_DWORD *)(result + 8) = v8;
  *(_DWORD *)(result + 12) = v13;
  int v14 = v10 + v8;
  *(_DWORD *)(result + 16) = v14;
  *(_DWORD *)(result + 20) = v13;
  *(_DWORD *)(result + 24) = v14;
  *(_DWORD *)(result + 28) = v9;
  ++*a2;
  return result;
}

uint64_t sub_1DC3CD098(uint64_t result, _DWORD *a2, int a3, double a4, double a5, double a6, double a7)
{
  int v7 = (int)a6;
  if ((int)a6 >= 5) {
    int v7 = 5;
  }
  int v8 = (int)a7;
  int v9 = (int)a5;
  double v10 = a4 + a6 * 0.5;
  if (v7 >= 0) {
    int v11 = v7;
  }
  else {
    int v11 = v7 + 1;
  }
  unsigned int v12 = vcvtmd_s64_f64(v10 - (double)(v11 >> 1));
  uint64_t v13 = result + 56 * a3;
  *(_DWORD *)(v13 + 40) = -1077342245;
  *(float *)(v13 + 44) = (float)v8;
  *(float *)(v13 + 48) = (float)v7;
  unsigned int v14 = v12 + (v11 >> 1);
  if (v8 >= 0) {
    int v15 = (int)a7;
  }
  else {
    int v15 = v8 + 1;
  }
  *(_DWORD *)(v13 + 32) = v14;
  *(_DWORD *)(v13 + 36) = v9 + (v15 >> 1);
  *(_DWORD *)uint64_t v13 = v12;
  *(_DWORD *)(v13 + 4) = v9;
  int v16 = v8 + v9 - 1;
  *(_DWORD *)(v13 + 8) = v12;
  *(_DWORD *)(v13 + 12) = v16;
  int v17 = v7 + v12 - 1;
  *(_DWORD *)(v13 + 16) = v17;
  *(_DWORD *)(v13 + 20) = v16;
  *(_DWORD *)(v13 + 24) = v17;
  *(_DWORD *)(v13 + 28) = v9;
  ++*a2;
  return result;
}

uint64_t sub_1DC3CD138(uint64_t result, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  double v7 = a5 + a7 * 0.5 + -10.0;
  if (v7 <= 0.0) {
    double v7 = 0.0;
  }
  int v8 = (int)v7;
  int v9 = (int)a4;
  int v10 = (int)a6;
  unint64_t v11 = a3 - (int)v7;
  if (v11 >= 0x14) {
    LODWORD(v11) = 20;
  }
  *(float *)(result + 44) = (float)v10;
  *(float *)(result + 48) = (float)(int)v11;
  if (v10 >= 0) {
    int v12 = (int)a6;
  }
  else {
    int v12 = v10 + 1;
  }
  *(_DWORD *)(result + 28) = v8;
  *(_DWORD *)(result + 32) = v9 + (v12 >> 1);
  *(void *)(result + 36) = v8 + (v11 >> 1);
  *(_DWORD *)CFArrayRef result = v9;
  *(_DWORD *)(result + 4) = v8;
  int v13 = v11 + v8;
  *(_DWORD *)(result + 8) = v9;
  *(_DWORD *)(result + 12) = v13;
  int v14 = v9 + v10;
  *(_DWORD *)(result + 16) = v14;
  *(_DWORD *)(result + 20) = v13;
  *(_DWORD *)(result + 24) = v14;
  ++*a2;
  return result;
}

uint64_t sub_1DC3CD1C0(uint64_t result, _DWORD *a2, int a3, double a4, double a5, double a6, double a7)
{
  int v7 = (int)a7;
  int v8 = (int)a6;
  int v9 = (int)a4;
  if ((int)a7 >= 5) {
    int v7 = 5;
  }
  if (v7 >= 0) {
    int v10 = v7;
  }
  else {
    int v10 = v7 + 1;
  }
  unsigned int v11 = vcvtmd_s64_f64(a5 + a7 * 0.5 - (double)(v10 >> 1));
  uint64_t v12 = result + 56 * a3;
  *(float *)(v12 + 44) = (float)v8;
  *(float *)(v12 + 48) = (float)v7;
  if (v8 >= 0) {
    int v13 = (int)a6;
  }
  else {
    int v13 = v8 + 1;
  }
  *(_DWORD *)(v12 + 28) = v11;
  *(_DWORD *)(v12 + 32) = v9 + (v13 >> 1);
  *(_DWORD *)(v12 + 36) = v11 + (v10 >> 1);
  *(_DWORD *)(v12 + 40) = 0;
  *(_DWORD *)uint64_t v12 = v9;
  *(_DWORD *)(v12 + 4) = v11;
  int v14 = v7 + v11 - 1;
  *(_DWORD *)(v12 + 8) = v9;
  *(_DWORD *)(v12 + 12) = v14;
  int v15 = v8 + v9 - 1;
  *(_DWORD *)(v12 + 16) = v15;
  *(_DWORD *)(v12 + 20) = v14;
  *(_DWORD *)(v12 + 24) = v15;
  ++*a2;
  return result;
}

uint64_t sub_1DC3CD258(uint64_t result, _DWORD *a2, int a3, int a4, double a5, double a6, double a7, double a8)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((int)a7 >= 3)
  {
    if (a4 >= 0) {
      int v8 = a4;
    }
    else {
      int v8 = -a4;
    }
    if (!a4) {
      int v8 = 1;
    }
    unsigned int v9 = vcvtmd_s64_f64(a5 + a7 * 0.5);
    int v10 = v9 - v8;
    int v11 = v8 + v9 - 1;
    v25[0] = v10;
    v25[1] = v11;
    int v12 = (int)(a5 + a7 + -1.0);
    if (v10 >= (int)a5 && v10 + 2 <= v12 && v11 >= (int)a5 && v11 + 2 <= v12)
    {
      uint64_t v16 = 0;
      int v17 = (int)a8;
      int v18 = (int)a6;
      if ((int)a8 >= 0) {
        int v19 = (int)a8;
      }
      else {
        int v19 = v17 + 1;
      }
      int v20 = v18 + (v19 >> 1);
      int v21 = v17 + v18 - 1;
      float v22 = (float)v17;
      uint64_t v23 = result + 56 * a3 + 28;
      do
      {
        *(float *)(v23 + 16) = v22;
        *(_DWORD *)(v23 + 20) = 1077936128;
        int v24 = v25[v16];
        *(_DWORD *)(v23 + 8) = v20;
        *(_DWORD *)(v23 + 12) = -1077342245;
        *(_DWORD *)(v23 - 28) = v24;
        *(_DWORD *)(v23 - 24) = v18;
        *(_DWORD *)(v23 - 20) = v24;
        *(int64x2_t *)(v23 - 16) = vdupq_lane_s64(__SPAIR64__(v24 + 2, v21), 0);
        *(_DWORD *)uint64_t v23 = v18;
        *(_DWORD *)(v23 + 4) = v24 + 1;
        v23 += 56;
        ++v16;
      }
      while (v16 != 2);
      *a2 += 2;
    }
  }
  return result;
}

uint64_t sub_1DC3CD398(uint64_t a1, int *a2, int a3, double a4, double a5, double a6, double a7)
{
  int v14 = *a2;
  uint64_t result = sub_1DC3CD098(a1, a2, a3, a4, a5, a6, a7);
  int v16 = *a2 - v14;
  if (v16 >= 1)
  {
    return sub_1DC3CD258(a1, a2, v16 + a3, 10, a4, a5, a6, a7);
  }
  return result;
}

void sub_1DC3CD448(uint64_t a1, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  sub_1DC3CD098(a1, a2, 0, a4, a5, a6, a7);
  double v14 = floor(a4 + a6 * 0.5) + -10.0;
  if (v14 <= 0.0) {
    double v14 = 0.0;
  }
  int v15 = (int)v14;
  int v16 = (int)a5;
  if ((unint64_t)(a3 - (int)v14) >= 0x14) {
    int v17 = 20;
  }
  else {
    int v17 = a3 - v15;
  }
  int v18 = (int)a7;
  float v19 = atan2f((float)(int)a7, (float)v17);
  uint64_t v20 = 0;
  *(float *)(a1 + 96) = v19;
  *(float *)(a1 + 152) = -v19;
  if ((int)a7 >= 0) {
    int v21 = (int)a7;
  }
  else {
    int v21 = v18 + 1;
  }
  int v22 = v16 + (v21 >> 1);
  float v23 = sqrtf((float)(v18 * v18 + v17 * v17));
  do
  {
    uint64_t v24 = a1 + v20;
    *(_DWORD *)(v24 + 88) = v15 + (v17 >> 1);
    *(_DWORD *)(v24 + 92) = v22;
    *(float *)(v24 + 100) = v23;
    *(_DWORD *)(v24 + 104) = 1065353216;
    v20 += 56;
  }
  while (v20 == 56);
  *(_DWORD *)(a1 + 56) = v15;
  *(_DWORD *)(a1 + 60) = v16 + v18;
  *(_DWORD *)(a1 + 64) = v15;
  *(_DWORD *)(a1 + 68) = v16 + v18;
  *(_DWORD *)(a1 + 72) = v17 + v15;
  *(_DWORD *)(a1 + 76) = v16;
  *(_DWORD *)(a1 + 80) = v17 + v15;
  *(_DWORD *)(a1 + 84) = v16;
  *(_DWORD *)(a1 + 112) = v15;
  *(_DWORD *)(a1 + 116) = v16;
  *(_DWORD *)(a1 + 120) = v15;
  *(_DWORD *)(a1 + 124) = v16;
  *(_DWORD *)(a1 + 128) = v17 + v15;
  *(_DWORD *)(a1 + 132) = v16 + v18;
  *(_DWORD *)(a1 + 136) = v17 + v15;
  *(_DWORD *)(a1 + 140) = v16 + v18;
  *a2 += 2;
}

uint64_t sub_1DC3CD578(uint64_t result, _DWORD *a2, int a3, int a4, double a5, double a6, double a7, double a8)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((int)a8 >= 3)
  {
    if (a4 >= 0) {
      int v8 = a4;
    }
    else {
      int v8 = -a4;
    }
    if (!a4) {
      int v8 = 1;
    }
    unsigned int v9 = vcvtmd_s64_f64(a6 + a8 * 0.5);
    int v10 = v9 - v8;
    int v11 = v8 + v9 - 1;
    v25[0] = v10;
    v25[1] = v11;
    int v12 = (int)(a6 + a8 + -1.0);
    if (v10 >= (int)a6 && v10 + 2 <= v12 && v11 >= (int)a6 && v11 + 2 <= v12)
    {
      uint64_t v16 = 0;
      int v17 = (int)a7;
      int v18 = (int)a5;
      if ((int)a7 >= 0) {
        int v19 = (int)a7;
      }
      else {
        int v19 = v17 + 1;
      }
      int v20 = v18 + (v19 >> 1);
      int v21 = v17 + v18 - 1;
      uint64_t v22 = result + 56 * a3 + 28;
      do
      {
        *(float *)(v22 + 16) = (float)(int)a7;
        *(_DWORD *)(v22 + 20) = 1077936128;
        int v23 = v25[v16];
        *(_DWORD *)(v22 + 8) = v23 + 1;
        *(_DWORD *)(v22 + 12) = 0;
        *(_DWORD *)(v22 - 28) = v18;
        *(_DWORD *)(v22 - 24) = v23;
        *(_DWORD *)(v22 - 20) = v18;
        LODWORD(v24) = v23 + 2;
        HIDWORD(v24) = v21;
        *(int64x2_t *)(v22 - 16) = vdupq_lane_s64(v24, 0);
        *(_DWORD *)uint64_t v22 = v23;
        *(_DWORD *)(v22 + 4) = v20;
        v22 += 56;
        ++v16;
      }
      while (v16 != 2);
      *a2 += 2;
    }
  }
  return result;
}

uint64_t sub_1DC3CD6AC(uint64_t a1, int *a2, int a3, double a4, double a5, double a6, double a7)
{
  int v14 = *a2;
  uint64_t result = sub_1DC3CD1C0(a1, a2, a3, a4, a5, a6, a7);
  int v16 = *a2 - v14;
  if (v16 >= 1)
  {
    return sub_1DC3CD578(a1, a2, v16 + a3, 10, a4, a5, a6, a7);
  }
  return result;
}

void sub_1DC3CD75C(uint64_t a1, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  sub_1DC3CD1C0(a1, a2, 0, a4, a5, a6, a7);
  int v14 = (int)a4;
  double v15 = a5 + a7 * 0.5 + -10.0;
  if (v15 <= 0.0) {
    double v15 = 0.0;
  }
  int v16 = (int)v15;
  int v17 = (int)a6;
  if ((unint64_t)(a3 - (int)v15) >= 0x14) {
    int v18 = 20;
  }
  else {
    int v18 = a3 - v16;
  }
  float v19 = atan2f((float)v18, (float)v17);
  uint64_t v20 = 0;
  *(float *)(a1 + 96) = v19;
  *(float *)(a1 + 152) = -v19;
  float v21 = sqrtf((float)(v17 * v17 + v18 * v18));
  if (v17 >= 0) {
    int v22 = (int)a6;
  }
  else {
    int v22 = v17 + 1;
  }
  int v23 = v14 + (v22 >> 1);
  do
  {
    uint64_t v24 = a1 + v20;
    *(float *)(v24 + 100) = v21;
    *(_DWORD *)(v24 + 104) = 1065353216;
    *(_DWORD *)(v24 + 88) = v23;
    *(_DWORD *)(v24 + 92) = v16 + (v18 >> 1);
    v20 += 56;
  }
  while (v20 == 56);
  *(_DWORD *)(a1 + 56) = v14;
  *(_DWORD *)(a1 + 60) = v18 + v16;
  *(_DWORD *)(a1 + 64) = v14;
  *(_DWORD *)(a1 + 68) = v18 + v16;
  *(_DWORD *)(a1 + 72) = v14 + v17;
  *(_DWORD *)(a1 + 76) = v16;
  *(_DWORD *)(a1 + 80) = v14 + v17;
  *(_DWORD *)(a1 + 84) = v16;
  *(_DWORD *)(a1 + 112) = v14;
  *(_DWORD *)(a1 + 116) = v16;
  *(_DWORD *)(a1 + 120) = v14;
  *(_DWORD *)(a1 + 124) = v16;
  *(_DWORD *)(a1 + 128) = v14 + v17;
  *(_DWORD *)(a1 + 132) = v18 + v16;
  *(_DWORD *)(a1 + 136) = v14 + v17;
  *(_DWORD *)(a1 + 140) = v18 + v16;
  *a2 += 2;
}

void sub_1DC3CD888(uint64_t a1, _DWORD *a2, int a3, int a4, int a5, double a6, double a7, double a8, double a9, float a10)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  float v15 = a8;
  int v16 = vcvtmd_s64_f64(a6 + v15 * 0.5);
  float v17 = a9;
  int v18 = vcvtmd_s64_f64(a7 + v17 * 0.5);
  float v19 = atan2f(v17, v15);
  float v20 = fabsf(a10);
  if (v20 <= 1.5708) {
    float v21 = v20;
  }
  else {
    float v21 = 1.5708;
  }
  int v22 = a3;
  uint64_t v23 = a1 + 56 * a3;
  *(float *)(v23 + 40) = v21;
  *(float *)(v23 + 96) = -v21;
  __float2 v24 = __sincosf_stret(v21);
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  v74[0] = LODWORD(v24.__cosval);
  v74[1] = LODWORD(v24.__cosval);
  v73[0] = LODWORD(v24.__sinval);
  *(float *)&v73[1] = -v24.__sinval;
  float v27 = v15 / v24.__cosval;
  if (v21 >= v19) {
    float v27 = v17 / v24.__sinval;
  }
  float v71 = (float)v16;
  float v72 = v27;
  float v28 = v27 * 0.5;
  float v29 = -(float)(v27 * 0.5);
  int v30 = a4 - 1;
  float v31 = (float)v18;
  int v32 = a5 - 1;
  uint64_t v33 = a1 + 56 * v22;
  do
  {
    uint64_t v34 = v33 + v26;
    *(float *)(v34 + 44) = v72;
    *(void *)(v34 + 48) = 0x140400000;
    *(_DWORD *)(v34 + 32) = v16;
    *(_DWORD *)(v34 + 36) = v18;
    double v35 = *(float *)(v33 + v26 + 40);
    float v36 = v35 + -1.57079633;
    __float2 v37 = __sincosf_stret(v36);
    float v38 = *(float *)&v74[v25];
    float v39 = v71 + (float)(v29 * v38);
    int v40 = (int)(float)(v39 + v37.__cosval);
    if (v30 >= v40) {
      int v41 = (int)(float)(v39 + v37.__cosval);
    }
    else {
      int v41 = v30;
    }
    if (v40 >= 0) {
      int v42 = v41;
    }
    else {
      int v42 = 0;
    }
    float v43 = *(float *)&v73[v25];
    float v44 = v31 + (float)(v29 * v43);
    int v45 = (int)(float)(v37.__sinval + v44);
    if (v32 >= v45) {
      int v46 = (int)(float)(v37.__sinval + v44);
    }
    else {
      int v46 = v32;
    }
    if (v45 >= 0) {
      int v47 = v46;
    }
    else {
      int v47 = 0;
    }
    *(_DWORD *)uint64_t v34 = v42;
    *(_DWORD *)(v34 + 4) = v47;
    float v48 = v71 + (float)(v28 * v38);
    int v49 = (int)(float)(v48 + v37.__cosval);
    if (v30 >= v49) {
      int v50 = (int)(float)(v48 + v37.__cosval);
    }
    else {
      int v50 = v30;
    }
    if (v49 >= 0) {
      int v51 = v50;
    }
    else {
      int v51 = 0;
    }
    float v52 = v31 + (float)(v28 * v43);
    int v53 = (int)(float)(v37.__sinval + v52);
    if (v32 >= v53) {
      int v54 = (int)(float)(v37.__sinval + v52);
    }
    else {
      int v54 = v32;
    }
    if (v53 >= 0) {
      int v55 = v54;
    }
    else {
      int v55 = 0;
    }
    *(_DWORD *)(v34 + 24) = v51;
    *(_DWORD *)(v34 + 28) = v55;
    float v56 = v35 + 1.57079633;
    __float2 v57 = __sincosf_stret(v56);
    int v58 = (int)(float)(v39 + v57.__cosval);
    if (v30 >= v58) {
      int v59 = (int)(float)(v39 + v57.__cosval);
    }
    else {
      int v59 = v30;
    }
    if (v58 >= 0) {
      int v60 = v59;
    }
    else {
      int v60 = 0;
    }
    int v61 = (int)(float)(v57.__sinval + v44);
    if (v32 >= v61) {
      int v62 = (int)(float)(v57.__sinval + v44);
    }
    else {
      int v62 = v32;
    }
    if (v61 >= 0) {
      int v63 = v62;
    }
    else {
      int v63 = 0;
    }
    *(_DWORD *)(v34 + 8) = v60;
    *(_DWORD *)(v34 + 12) = v63;
    int v64 = (int)(float)(v48 + v57.__cosval);
    if (v30 >= v64) {
      int v65 = (int)(float)(v48 + v57.__cosval);
    }
    else {
      int v65 = v30;
    }
    if (v64 >= 0) {
      int v66 = v65;
    }
    else {
      int v66 = 0;
    }
    int v67 = (int)(float)(v57.__sinval + v52);
    if (v32 >= v67) {
      int v68 = (int)(float)(v57.__sinval + v52);
    }
    else {
      int v68 = v32;
    }
    if (v67 >= 0) {
      int v69 = v68;
    }
    else {
      int v69 = 0;
    }
    *(_DWORD *)(v34 + 16) = v66;
    *(_DWORD *)(v34 + 20) = v69;
    v26 += 56;
    ++v25;
  }
  while (v26 != 112);
  *a2 += 2;
}

uint64_t sub_1DC3CDB5C(uint64_t a1, int *a2, double a3, double a4, double a5, double a6, float a7, float a8, float a9)
{
  if (a5 <= a6) {
    double v17 = a6;
  }
  else {
    double v17 = a5;
  }
  float v18 = v17 + v17;
  __float2 v19 = __sincosf_stret(a9);
  float v20 = a7 - (float)(v19.__cosval * v18);
  float v21 = a8 - (float)(v19.__sinval * v18);
  float v53 = v21 - v19.__cosval;
  float v54 = v19.__sinval + v20;
  float v22 = (float)(v19.__cosval * v18) + a7;
  float v23 = (float)(v19.__sinval * v18) + a8;
  float v47 = v23 - v19.__cosval;
  float v48 = v19.__sinval + v22;
  float v46 = v20 - v19.__sinval;
  float v52 = v20 - v19.__sinval;
  float v44 = v22 - v19.__sinval;
  float v45 = v19.__cosval + v21;
  float v50 = v22 - v19.__sinval;
  float v51 = v19.__cosval + v21;
  float v24 = v19.__cosval + v23;
  float v49 = v19.__cosval + v23;
  float v25 = a3;
  float v26 = a4;
  float v27 = a3 + a5;
  float v28 = a4 + a6;
  uint64_t result = sub_1DC3EFD88(&v54, &v53, &v48, &v47, v19.__sinval + v20, v21 - v19.__cosval, v19.__sinval + v22, v23 - v19.__cosval, v25, v27, v26, v28);
  if (result)
  {
    float v30 = a3;
    float v31 = a4;
    float v32 = a4 + a6;
    uint64_t result = sub_1DC3EFD88(&v52, &v51, &v50, &v49, v46, v45, v44, v24, v30, v27, v31, v32);
    if (result)
    {
      float v33 = v53;
      float v34 = v54;
      float v35 = v47;
      float v36 = v48;
      float v37 = v51;
      float v38 = v52;
      float v39 = v49;
      float v40 = v50;
      float v41 = (float)(sqrtf((float)((float)(v53 - v47) * (float)(v53 - v47))+ (float)((float)(v54 - v48) * (float)(v54 - v48)))+ sqrtf((float)((float)(v51 - v49) * (float)(v51 - v49))+ (float)((float)(v52 - v50) * (float)(v52 - v50))))* 0.5;
      if (v41 >= 20.0)
      {
        uint64_t v42 = a1 + 56 * *a2;
        *(_DWORD *)uint64_t v42 = (int)v54;
        *(_DWORD *)(v42 + 4) = (int)v33;
        *(_DWORD *)(v42 + 24) = (int)v36;
        *(_DWORD *)(v42 + 28) = (int)v35;
        *(_DWORD *)(v42 + 8) = (int)v38;
        *(_DWORD *)(v42 + 12) = (int)v37;
        *(_DWORD *)(v42 + 16) = (int)v40;
        *(_DWORD *)(v42 + 20) = (int)v39;
        *(_DWORD *)(v42 + 32) = (int)(float)((float)(v36 + (float)((float)(v34 + v38) + v40)) * 0.25);
        *(_DWORD *)(v42 + 36) = (int)(float)((float)(v35 + (float)((float)(v33 + v37) + v39)) * 0.25);
        *(float *)(v42 + 40) = a9;
        *(float *)(v42 + 44) = v41;
        *(_DWORD *)(v42 + 48) = 1077936128;
        ++*a2;
      }
    }
  }
  return result;
}

uint64_t sub_1DC3CDD84(uint64_t a1, const UInt8 *a2, unint64_t a3, unint64_t a4, size_t a5, int a6, int a7, uint64_t *a8, double a9, double a10, double a11, double a12, float a13)
{
  int v494 = a7;
  v480 = a2;
  size_t v481 = a5;
  double v18 = a12;
  uint64_t v559 = *MEMORY[0x1E4F143B8];
  double v505 = a9;
  CGRect v564 = CGRectInset(*(CGRect *)&a9, a11 * -0.100000001, a12 * -0.100000001);
  unint64_t v491 = a3;
  unint64_t v492 = a4;
  v570.size.double width = (double)a3;
  v570.size.double height = (double)a4;
  v570.origin.double x = 0.0;
  v570.origin.double y = 0.0;
  double v467 = (double)a4;
  double v468 = (double)a3;
  CGRect v565 = CGRectIntersection(v564, v570);
  double x = v565.origin.x;
  double y = v565.origin.y;
  double width = v565.size.width;
  double height = v565.size.height;
  if (CGRectIsEmpty(v565)) {
    return 11;
  }
  v566.origin.double x = x;
  v566.origin.double y = y;
  v566.size.double width = width;
  v566.size.double height = height;
  if (CGRectIsInfinite(v566)) {
    return 11;
  }
  v567.origin.double x = x;
  v567.origin.double y = y;
  v567.size.double width = width;
  v567.size.double height = height;
  if (CGRectIsNull(v567)) {
    return 11;
  }
  LODWORD(v547.realp) = 0;
  BYTE4(v547.realp) = 1;
  uint64_t v26 = *(void *)(a1 + 8);
  unsigned int v27 = sub_1DC3777A8((atomic_ullong *)v26, (uint64_t)&v547) & a6;
  if (!v27) {
    return 11;
  }
  uint64_t v497 = *(void *)(v26 + 56);
  BOOL v493 = v497 >= 0x20000;
  v523[0] = v491;
  v523[1] = v492;
  v523[3] = 0x100000000;
  v523[2] = v481;
  v523[4] = v480;
  if (*(unsigned char *)(v26 + 53))
  {
    CFMutableStringRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v26 = *(void *)(a1 + 8);
  }
  else
  {
    CFMutableStringRef Mutable = 0;
  }
  float v522 = -1.0;
  int v521 = 0;
  int v30 = *(_DWORD *)(v26 + 44);
  v485 = a8;
  uint64_t v490 = a1;
  unsigned int v499 = v27;
  if (!v494)
  {
    float v35 = 0;
    switch(*(_DWORD *)(v26 + 8))
    {
      case 2:
        float v36 = (char *)malloc_type_malloc(0x38uLL, 0x100004021716A34uLL);
        sub_1DC3CD098((uint64_t)v36, &v521, 0, x, y, width, height);
        goto LABEL_215;
      case 3:
        float v36 = (char *)malloc_type_malloc(0x38uLL, 0x100004021716A34uLL);
        sub_1DC3CD004((uint64_t)v36, &v521, v491, x, y, width, height);
        goto LABEL_215;
      case 4:
        uint64_t v121 = (char *)malloc_type_malloc(0xA8uLL, 0x100004021716A34uLL);
        sub_1DC3CD398((uint64_t)v121, &v521, 0, x, y, width, height);
        goto LABEL_213;
      case 5:
        uint64_t v121 = (char *)malloc_type_malloc(0xA8uLL, 0x100004021716A34uLL);
        sub_1DC3CD448((uint64_t)v121, &v521, v491, x, y, width, height);
        goto LABEL_213;
      case 6:
        float v36 = (char *)malloc_type_malloc(0x38uLL, 0x100004021716A34uLL);
        sub_1DC3CD1C0((uint64_t)v36, &v521, 0, x, y, width, height);
        goto LABEL_215;
      case 7:
        float v36 = (char *)malloc_type_malloc(0x38uLL, 0x100004021716A34uLL);
        sub_1DC3CD138((uint64_t)v36, &v521, v492, x, y, width, height);
LABEL_215:
        float v35 = v36;
        int v30 = 1;
        goto LABEL_223;
      case 8:
        uint64_t v121 = (char *)malloc_type_malloc(0xA8uLL, 0x100004021716A34uLL);
        sub_1DC3CD6AC((uint64_t)v121, &v521, 0, x, y, width, height);
        goto LABEL_213;
      case 9:
        uint64_t v121 = (char *)malloc_type_malloc(0xA8uLL, 0x100004021716A34uLL);
        sub_1DC3CD75C((uint64_t)v121, &v521, v492, x, y, width, height);
LABEL_213:
        float v35 = v121;
        goto LABEL_222;
      case 0xA:
        int32x4_t v148 = (char *)malloc_type_malloc(0x70uLL, 0x100004021716A34uLL);
        sub_1DC3CD098((uint64_t)v148, &v521, 0, x, y, width, height);
        sub_1DC3CD1C0((uint64_t)v148, &v521, 1, x, y, width, height);
        float v35 = v148;
        int v30 = 2;
        goto LABEL_223;
      case 0xB:
        uint64_t v109 = (char *)malloc_type_malloc(0x150uLL, 0x100004021716A34uLL);
        sub_1DC3CD398((uint64_t)v109, &v521, 0, x, y, width, height);
        sub_1DC3CD6AC((uint64_t)v109, &v521, v521, x, y, width, height);
        goto LABEL_217;
      case 0xC:
        uint64_t v109 = (char *)malloc_type_malloc(0x230uLL, 0x100004021716A34uLL);
        sub_1DC3CD398((uint64_t)v109, &v521, 0, x, y, width, height);
        sub_1DC3CD6AC((uint64_t)v109, &v521, v521, x, y, width, height);
        sub_1DC3CD258((uint64_t)v109, &v521, v521, 20, x, y, width, height);
        sub_1DC3CD578((uint64_t)v109, &v521, v521, 20, x, y, width, height);
LABEL_217:
        float v35 = v109;
        goto LABEL_218;
      case 0xD:
        int v122 = (int)(height * 0.5);
        BOOL v123 = (char *)malloc_type_malloc(0x8C0uLL, 0x100004021716A34uLL);
        sub_1DC3CD398((uint64_t)v123, &v521, 0, x, y, width, height);
        sub_1DC3CD6AC((uint64_t)v123, &v521, v521, x, y, width, height);
        sub_1DC3CD888((uint64_t)v123, &v521, v521, v491, v492, x, y, width, height, 0.17453);
        sub_1DC3CD888((uint64_t)v123, &v521, v521, v491, v492, x, y, width, height, 1.3963);
        float v124 = (float)(int)(width * 0.5);
        if ((float)(v124 * 0.125) > 10.0 && height > 20.0)
        {
          float v126 = width;
          sub_1DC3CD258((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v126 * 0.0625)), x, y, width, height);
        }
        *(float *)&long long v508 = (float)v122;
        if ((float)((float)v122 * 0.125) > 10.0 && width > 20.0)
        {
          float v128 = height;
          sub_1DC3CD578((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v128 * 0.0625)), x, y, width, height);
        }
        sub_1DC3CD888((uint64_t)v123, &v521, v521, v491, v492, x, y, width, height, 0.34907);
        sub_1DC3CD888((uint64_t)v123, &v521, v521, v491, v492, x, y, width, height, 1.2217);
        if ((float)(v124 * 0.25) > 10.0 && height > 20.0)
        {
          float v130 = width;
          sub_1DC3CD258((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v130 * 0.125)), x, y, width, height);
        }
        if ((float)(*(float *)&v508 * 0.25) > 10.0 && width > 20.0)
        {
          float v132 = height;
          sub_1DC3CD578((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v132 * 0.125)), x, y, width, height);
        }
        sub_1DC3CD888((uint64_t)v123, &v521, v521, v491, v492, x, y, width, height, 0.5236);
        sub_1DC3CD888((uint64_t)v123, &v521, v521, v491, v492, x, y, width, height, 1.0472);
        if ((float)(v124 * 0.375) > 10.0 && height > 20.0)
        {
          float v134 = width;
          sub_1DC3CD258((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v134 * 0.1875)), x, y, width, height);
        }
        if ((float)(*(float *)&v508 * 0.375) > 10.0 && width > 20.0)
        {
          float v136 = height;
          sub_1DC3CD578((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v136 * 0.1875)), x, y, width, height);
        }
        sub_1DC3CD888((uint64_t)v123, &v521, v521, v491, v492, x, y, width, height, 0.7854);
        if ((float)(v124 * 0.5) > 10.0 && height > 20.0)
        {
          float v138 = width;
          sub_1DC3CD258((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v138 * 0.25)), x, y, width, height);
        }
        if ((float)(*(float *)&v508 * 0.5) > 10.0 && width > 20.0)
        {
          float v140 = height;
          sub_1DC3CD578((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v140 * 0.25)), x, y, width, height);
        }
        if ((float)(v124 * 0.75) > 10.0 && height > 20.0)
        {
          float v142 = width;
          sub_1DC3CD258((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v142 * 0.375)), x, y, width, height);
        }
        v28.n128_f32[0] = *(float *)&v508 * 0.75;
        if ((float)(*(float *)&v508 * 0.75) <= 10.0 || width <= 20.0)
        {
          int v30 = 6;
          float v35 = v123;
        }
        else
        {
          float v451 = height;
          sub_1DC3CD578((uint64_t)v123, &v521, v521, (int)fabsf(roundf(v451 * 0.375)), x, y, width, height);
          float v35 = v123;
LABEL_218:
          int v30 = 6;
        }
        goto LABEL_223;
      case 0xE:
        uint64_t v110 = (char *)malloc_type_malloc(0x498uLL, 0x100004021716A34uLL);
        sub_1DC3CD398((uint64_t)v110, &v521, 0, x, y, width, height);
        sub_1DC3CD888((uint64_t)v110, &v521, v521, v491, v492, x, y, width, height, 1.3963);
        float v111 = (float)(int)(width * 0.5);
        if ((float)(v111 * 0.125) > 10.0 && height > 20.0)
        {
          float v113 = width;
          sub_1DC3CD258((uint64_t)v110, &v521, v521, (int)fabsf(roundf(v113 * 0.0625)), x, y, width, height);
        }
        sub_1DC3CD888((uint64_t)v110, &v521, v521, v491, v492, x, y, width, height, 1.2217);
        if ((float)(v111 * 0.25) > 10.0 && height > 20.0)
        {
          float v115 = width;
          sub_1DC3CD258((uint64_t)v110, &v521, v521, (int)fabsf(roundf(v115 * 0.125)), x, y, width, height);
        }
        sub_1DC3CD888((uint64_t)v110, &v521, v521, v491, v492, x, y, width, height, 1.0472);
        if ((float)(v111 * 0.375) > 10.0 && height > 20.0)
        {
          float v117 = width;
          sub_1DC3CD258((uint64_t)v110, &v521, v521, (int)fabsf(roundf(v117 * 0.1875)), x, y, width, height);
        }
        float32x2_t v104 = v110;
        sub_1DC3CD888((uint64_t)v110, &v521, v521, v491, v492, x, y, width, height, 0.7854);
        if ((float)(v111 * 0.5) > 10.0 && height > 20.0)
        {
          float v119 = width;
          sub_1DC3CD258((uint64_t)v110, &v521, v521, (int)fabsf(roundf(v119 * 0.25)), x, y, width, height);
        }
        v28.n128_u64[0] = 20.0;
        if ((float)(v111 * 0.75) <= 10.0 || height <= 20.0) {
          goto LABEL_147;
        }
        float v149 = width;
        sub_1DC3CD258((uint64_t)v110, &v521, v521, (int)fabsf(roundf(v149 * 0.375)), x, y, width, height);
        goto LABEL_221;
      case 0xF:
        CGRect v96 = (char *)malloc_type_malloc(0x498uLL, 0x100004021716A34uLL);
        sub_1DC3CD6AC((uint64_t)v96, &v521, 0, x, y, width, height);
        sub_1DC3CD888((uint64_t)v96, &v521, v521, v491, v492, x, y, width, height, 0.17453);
        float v97 = (float)(int)(height * 0.5);
        if ((float)(v97 * 0.125) > 10.0 && width > 20.0)
        {
          float v99 = height;
          sub_1DC3CD578((uint64_t)v96, &v521, v521, (int)fabsf(roundf(v99 * 0.0625)), x, y, width, height);
        }
        sub_1DC3CD888((uint64_t)v96, &v521, v521, v491, v492, x, y, width, height, 0.34907);
        if ((float)(v97 * 0.25) > 10.0 && width > 20.0)
        {
          float v101 = height;
          sub_1DC3CD578((uint64_t)v96, &v521, v521, (int)fabsf(roundf(v101 * 0.125)), x, y, width, height);
        }
        sub_1DC3CD888((uint64_t)v96, &v521, v521, v491, v492, x, y, width, height, 0.5236);
        if ((float)(v97 * 0.375) > 10.0 && width > 20.0)
        {
          float v103 = height;
          sub_1DC3CD578((uint64_t)v96, &v521, v521, (int)fabsf(roundf(v103 * 0.1875)), x, y, width, height);
        }
        float32x2_t v104 = v96;
        sub_1DC3CD888((uint64_t)v96, &v521, v521, v491, v492, x, y, width, height, 0.7854);
        if ((float)(v97 * 0.5) > 10.0 && width > 20.0)
        {
          float v106 = height;
          sub_1DC3CD578((uint64_t)v96, &v521, v521, (int)fabsf(roundf(v106 * 0.25)), x, y, width, height);
        }
        v28.n128_u64[0] = 20.0;
        if ((float)(v97 * 0.75) <= 10.0 || width <= 20.0)
        {
LABEL_147:
          int v30 = 3;
          float v35 = v104;
        }
        else
        {
          float v108 = height;
          sub_1DC3CD578((uint64_t)v96, &v521, v521, (int)fabsf(roundf(v108 * 0.375)), x, y, width, height);
LABEL_221:
          float v35 = v104;
LABEL_222:
          int v30 = 3;
        }
        goto LABEL_223;
      case 0x11:
        v479 = (char *)malloc_type_malloc((112 * v30) | 1, 0x5554779DuLL);
        sub_1DC3CD1C0((uint64_t)v479, &v521, 0, x, y, width, height);
        if (v30 < 1) {
          goto LABEL_220;
        }
        double v486 = a10;
        double v487 = a11;
        *(float *)&v483 = a13;
        for (int i = 0;
              i != v30;
              sub_1DC3CD578((uint64_t)v479, &v521, v521, (int)fabsf(roundf((float)((float)((float)i / (float)v30) * 0.5) * v145)), x, y, width, height))
        {
          ++i;
          float v145 = height;
        }
        goto LABEL_211;
      case 0x12:
        v479 = (char *)malloc_type_malloc((112 * v30) | 1, 0x7B640BCAuLL);
        sub_1DC3CD098((uint64_t)v479, &v521, 0, x, y, width, height);
        if (v30 >= 1)
        {
          double v486 = a10;
          double v487 = a11;
          *(float *)&v483 = a13;
          for (int j = 0;
                j != v30;
                sub_1DC3CD258((uint64_t)v479, &v521, v521, (int)fabsf(roundf((float)((float)((float)j / (float)v30) * 0.5) * v147)), x, y, width, height))
          {
            ++j;
            float v147 = width;
          }
LABEL_211:
          double v502 = x;
          double v503 = y;
          double v504 = width;
          goto LABEL_27;
        }
LABEL_220:
        float v35 = v479;
LABEL_223:
        int v53 = v521;
        if (v521 > 0)
        {
          v479 = v35;
          goto LABEL_225;
        }
        break;
      default:
        goto LABEL_223;
    }
    goto LABEL_227;
  }
  int v31 = 0;
  double v32 = height;
  if (fabsf(a13) > 5.0)
  {
    int v31 = 1070141403;
    if ((float)(90.0 - a13) <= 5.0)
    {
      double v32 = width;
    }
    else
    {
      double v32 = width;
      if ((float)(a13 + 90.0) > 5.0)
      {
        float v33 = a13 * 3.14159265 / 180.0;
        *(float *)&double v502 = v33;
        __float2 v34 = __sincosf_stret(v33);
        int v31 = LODWORD(v502);
        double v32 = width / fabsf(v34.__sinval);
        if (height / v34.__cosval < v32) {
          double v32 = height / v34.__cosval;
        }
      }
    }
  }
  LODWORD(v502) = v31;
  double v486 = a10;
  double v487 = a11;
  double v484 = v18;
  *(float *)&v483 = a13;
  float v37 = v32;
  float v38 = fmaxf(v37 / 20.0, 3.0);
  int v39 = vcvtms_s32_f32((float)(v37 * 0.5) / v38);
  float v40 = (char *)malloc_type_malloc(0x968uLL, 0x100004021716A34uLL);
  float v41 = x + width * 0.5;
  double v42 = x;
  double v43 = width;
  float v44 = y + height * 0.5;
  __float2 v45 = __sincosf_stret(*(float *)&v502);
  *(float *)&long long v508 = -(float)(v38 * v45.__sinval);
  *(float *)&v506 = v45.__cosval * v38;
  sub_1DC3CDB5C((uint64_t)v40, &v521, x, y, v43, height, v41, v44, *(float *)&v502);
  if (v39 >= 1)
  {
    int v46 = 0;
    *(float *)&double v504 = -*(float *)&v508;
    *(float *)&double v503 = -*(float *)&v506;
    do
    {
      ++v46;
      sub_1DC3CDB5C((uint64_t)v40, &v521, x, y, v43, height, v41 + (float)(*(float *)&v508 * (float)v46), v44 + (float)(*(float *)&v506 * (float)v46), *(float *)&v502);
      sub_1DC3CDB5C((uint64_t)v40, &v521, x, y, v43, height, v41 + (float)(*(float *)&v504 * (float)v46), v44 + (float)(*(float *)&v503 * (float)v46), *(float *)&v502);
    }
    while (v39 != v46);
  }
  float v47 = *(float *)&v502 + 0.087266;
  float v48 = *(float *)&v502 + -0.087266;
  sub_1DC3CDB5C((uint64_t)v40, &v521, v42, y, v43, height, v41, v44, *(float *)&v502 + 0.087266);
  v479 = v40;
  double v502 = v42;
  double v503 = y;
  double v504 = v43;
  sub_1DC3CDB5C((uint64_t)v40, &v521, v42, y, v43, height, v41, v44, v48);
  if (v39 > 1)
  {
    int v49 = 0;
    unsigned int v50 = v39 >> 1;
    *(float *)&uint64_t v500 = *(float *)&v508 + *(float *)&v508;
    *(float *)&unsigned int v496 = -(float)(*(float *)&v508 + *(float *)&v508);
    double v501 = height;
    *(float *)&CFAllocatorRef v498 = *(float *)&v506 + *(float *)&v506;
    *(float *)&size_t v495 = -(float)(*(float *)&v506 + *(float *)&v506);
    *(float *)&uint64_t v489 = v41;
    *(float *)&long long v508 = v48;
    *(float *)&v506 = v47;
    *(float *)&uint64_t v507 = y + height * 0.5;
    do
    {
      ++v49;
      sub_1DC3CDB5C((uint64_t)v479, &v521, v502, v503, v504, v501, *(float *)&v489 + (float)(*(float *)&v500 * (float)v49), *(float *)&v507 + (float)(*(float *)&v498 * (float)v49), *(float *)&v506);
      sub_1DC3CDB5C((uint64_t)v479, &v521, v502, v503, v504, v501, *(float *)&v489 + (float)(*(float *)&v500 * (float)v49), *(float *)&v507 + (float)(*(float *)&v498 * (float)v49), *(float *)&v508);
      sub_1DC3CDB5C((uint64_t)v479, &v521, v502, v503, v504, v501, *(float *)&v489 + (float)(*(float *)&v496 * (float)v49), *(float *)&v507 + (float)(*(float *)&v495 * (float)v49), *(float *)&v506);
      sub_1DC3CDB5C((uint64_t)v479, &v521, v502, v503, v504, v501, *(float *)&v489 + (float)(*(float *)&v496 * (float)v49), *(float *)&v507 + (float)(*(float *)&v495 * (float)v49), *(float *)&v508);
    }
    while (v50 != v49);
    double height = v501;
  }
  double v18 = v484;
LABEL_27:
  double v52 = v486;
  double v51 = v487;
  int v53 = v521;
  if (!v494 || v521 < 1)
  {
    float v35 = v479;
    if (v521 < 1)
    {
LABEL_227:
      CFMutableArrayRef v95 = 0;
      unsigned int v496 = 19;
      uint64_t v87 = Mutable;
      goto LABEL_549;
    }
LABEL_225:
    v452[1] = v452;
    memset(v520, 0, sizeof(v520));
    MEMORY[0x1F4188790](v28);
    v466 = (char *)v452 - v150;
    MEMORY[0x1F4188790](v151);
    v469 = (char *)v452 - v152;
    v473 = (char *)malloc_type_malloc(104 * v53, 0x1030040C2A760F9uLL);
    v474 = (char *)malloc_type_malloc(88 * v53, 0x10A0040F0082B6AuLL);
    uint64_t v153 = *(void *)(a1 + 8);
    double v465 = *(double *)(v153 + 32);
    if (v465 > 0.0)
    {
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      uint64_t v153 = *(void *)(a1 + 8);
    }
    else
    {
      CFAbsoluteTime Current = 0.0;
    }
    if (*(unsigned char *)(v153 + 51))
    {
      CFMutableArrayRef v464 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      uint64_t v153 = *(void *)(a1 + 8);
    }
    else
    {
      CFMutableArrayRef v464 = 0;
    }
    LODWORD(v153) = *(_DWORD *)(v153 + 40);
    if (v53 < (int)v153 || (int)v153 < 1) {
      uint64_t v153 = v53;
    }
    else {
      uint64_t v153 = v153;
    }
    uint64_t v461 = v153;
    if ((int)v153 < 1)
    {
      unsigned int v496 = 19;
      goto LABEL_548;
    }
    uint64_t v155 = 0;
    unsigned int v470 = 0;
    unint64_t v156 = v491;
    if (v491 <= v492) {
      unint64_t v156 = v492;
    }
    float v460 = (float)v156;
    CFIndex v454 = v481 * v492;
    CFAllocatorRef v498 = (CFAllocatorRef)*MEMORY[0x1E4F1CF80];
    v455 = a8 + 2;
    int v157 = v30 & 1;
    if (v30 < 0) {
      int v157 = -v157;
    }
    int v456 = v157;
    uint64_t v458 = v30 - 1;
    double v486 = COERCE_DOUBLE(&v541);
    double v487 = COERCE_DOUBLE(v544);
    double v502 = COERCE_DOUBLE(&v549[4]);
    double v503 = COERCE_DOUBLE(v552);
    v462 = (_OWORD *)((char *)&v529[1] + 12);
    v463 = (char *)&v530 + 8;
    v453 = (char *)&v550 + 12;
    int v158 = 19;
    float v159 = 0.5;
    CFAbsoluteTime v459 = Current;
    while (1)
    {
      if (v465 > 0.0 && v459 - Current >= *(double *)(*(void *)(a1 + 8) + 32))
      {
LABEL_512:
        unsigned int v496 = v158;
        if (v470)
        {
          uint64_t v404 = 0;
          uint64_t v405 = v470;
          do
          {
            v406 = (float *)&v474[88 * v404];
            float v407 = (float)(v406[5] + v406[6]) * 0.5;
            *(float *)v535 = (float)(*((_DWORD *)v406 + 4) + *((_DWORD *)v406 + 3)) * 0.5;
            *((float *)v535 + 1) = v407;
            int v408 = *(_DWORD *)&v469[4 * v404];
            sub_1DC3F02E0(v491, v492, (float *)&v466[52 * v408], 2u, (float *)v535, (float *)&v537, (float *)v529);
            v409 = (atomic_ullong *)*v485;
            uint64_t v410 = v485[1];
            if (*v485 == v410)
            {
              v413 = v479;
LABEL_530:
              v433 = &v474[88 * v404];
              *((_DWORD *)v433 + 14) = v537;
              *((_DWORD *)v433 + 15) = v529[0];
              v434 = (unsigned int *)&v473[104 * v404];
              v435 = *(unsigned int (**)(float *, char *, char *, void *))&dword_1EBFFBA10[16 * (unint64_t)*v434 + 14];
              if (v435 && !v435(v406, &v473[104 * v404], &v413[56 * v408], v523))
              {
                v547.imagp = 0;
                v547.realp = 0;
                imagp = 0;
                sub_1DC3D1A6C((atomic_ullong *)&v510, v434, (uint64_t)&v547, 0.0);
                v436 = v485;
                v438 = (void *)v485[1];
                unint64_t v437 = v485[2];
                if ((unint64_t)v438 >= v437)
                {
                  uint64_t v440 = ((uint64_t)v438 - *v485) >> 3;
                  if ((unint64_t)(v440 + 1) >> 61) {
                    sub_1DC2FF97C();
                  }
                  uint64_t v441 = v437 - *v485;
                  uint64_t v442 = v441 >> 2;
                  if (v441 >> 2 <= (unint64_t)(v440 + 1)) {
                    uint64_t v442 = v440 + 1;
                  }
                  if ((unint64_t)v441 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v443 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v443 = v442;
                  }
                  *(void *)&v549[8] = v455;
                  if (v443) {
                    unint64_t v443 = (unint64_t)sub_1DC2FFD7C(v443);
                  }
                  else {
                    uint64_t v444 = 0;
                  }
                  v547.realp = (float *)v443;
                  v547.imagp = (float *)(v443 + 8 * v440);
                  imagp = v547.imagp;
                  *(void *)v549 = v443 + 8 * v444;
                  *(void *)v547.imagp = atomic_exchange((atomic_ullong *volatile)&v510, 0);
                  imagp += 2;
                  sub_1DC34D7DC(v436, &v547);
                  v439 = (void *)v436[1];
                  sub_1DC308428((uint64_t)&v547);
                }
                else
                {
                  void *v438 = atomic_exchange((atomic_ullong *volatile)&v510, 0);
                  v439 = v438 + 1;
                  v436[1] = (uint64_t)v439;
                }
                v436[1] = (uint64_t)v439;
                sub_1DC3073A4((atomic_ullong *)&v510);
                *(float *)&unsigned int v496 = 0.0;
              }
            }
            else
            {
              double v411 = *((float *)&v537 + 1);
              double v412 = *((float *)v529 + 1);
              v413 = v479;
              while (1)
              {
                unint64_t explicit = atomic_load_explicit(v409, memory_order_acquire);
                if (*(unsigned char *)(explicit + 64))
                {
                  unint64_t v416 = explicit + 40;
                  v415 = *(double **)(explicit + 40);
                  if (*(void *)(v416 + 8) - (void)v415 >= 0x31uLL) {
                    break;
                  }
                }
LABEL_527:
                if (++v409 == (atomic_ullong *)v410)
                {
                  int v408 = *(_DWORD *)&v469[4 * v404];
                  goto LABEL_530;
                }
              }
              double v417 = v415[1];
              char v418 = 1;
              uint64_t v419 = 2;
              double v420 = v415[2];
              double v421 = v415[3];
              while (1)
              {
                char v422 = v418;
                double v423 = v420;
                double v424 = v421;
                v425 = &v415[2 * v419];
                double v420 = *v425;
                double v421 = v425[1];
                double v426 = v424 - v421;
                double v427 = *v415 - *v425;
                double v428 = *v425 - v423;
                double v429 = v428 * (v417 - v421) + v426 * v427;
                if (v429 != 0.0)
                {
                  double v430 = (v428 * (v412 - v421) + v426 * (v411 - v420)) / v429;
                  if (v430 > -0.0299999993 && v430 < 1.02999997)
                  {
                    double v431 = (v427 * (v412 - v421) + (v421 - v417) * (v411 - v420)) / v429;
                    if (v431 > -0.0299999993 && v431 < 1.02999997)
                    {
                      double v432 = 1.0 - (v430 + v431);
                      if (v432 > -0.0299999993 && v432 < 1.02999997) {
                        break;
                      }
                    }
                  }
                }
                char v418 = 0;
                uint64_t v419 = 3;
                if ((v422 & 1) == 0) {
                  goto LABEL_527;
                }
              }
            }
            sub_1DC3D5860((uint64_t)&v473[104 * v404]);
            sub_1DC3D5988((uint64_t)v406);
            ++v404;
          }
          while (v404 != v405);
        }
LABEL_548:
        free(v474);
        free(v473);
        a8 = v485;
        a1 = v490;
        uint64_t v87 = Mutable;
        float v35 = v479;
        CFMutableArrayRef v95 = v464;
        goto LABEL_549;
      }
      unsigned int v496 = v158;
      memset(v535, 0, sizeof(v535));
      uint64_t v160 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
      v536 = v160;
      *((void *)v160 + 8) = 0;
      *((_DWORD *)v160 + 18) = 0;
      *((void *)v160 + 10) = 0;
      *(_OWORD *)uint64_t v160 = 0u;
      *((_OWORD *)v160 + 1) = 0u;
      *((_OWORD *)v160 + 2) = 0u;
      *(_OWORD *)(v160 + 44) = 0u;
      int32x4_t v161 = v479;
      int v162 = (float *)&v479[56 * v155];
      float v163 = v162[12];
      v475 = v162 + 12;
      if (v163 <= 0.0 || v163 >= v460)
      {
        _DWORD *v475 = 1065353216;
        float v163 = 1.0;
      }
      int32x4_t v165 = (float *)&v161[56 * v155];
      float v166 = v165[10];
      v165 += 10;
      float v167 = (float)*((int *)v165 - 2);
      float v168 = (float)*((int *)v165 - 1);
      v471 = v165;
      float v169 = v165[1];
      v472 = (float *)&v466[52 * v155];
      int v170 = sub_1DC3F0940((uint64_t)v480, v491, v492, v481, v535, v472, v167, v168, v169, v166, v163);
      LODWORD(v535[1]) = v170;
      if (v170 <= 21)
      {
        if (v535[0]) {
          free(v535[0]);
        }
        v535[0] = 0;
        int v158 = v496;
        if (v496 == 19 || v496 == 11)
        {
          unsigned int v173 = 16;
          int v158 = 16;
        }
        else
        {
          unsigned int v173 = 16;
        }
        goto LABEL_504;
      }
      int v171 = v170;
      uint64_t v489 = v155;
      if (!v155) {
        break;
      }
      uint64_t v519 = 0;
      float32x2_t v172 = v535[0];
LABEL_295:
      pthread_once(&stru_1EAA94B90, (void (*)(void))sub_1DC3EFCB8);
      unsigned int v211 = v171 & 0xFFFFFFFE;
      unsigned int v212 = (v171 & 0xFFFFFFFE) - 1;
      if ((v171 & 0xFFFFFFFE) == 0) {
        unsigned int v212 = 0;
      }
      unsigned int v213 = v212 | (v212 >> 1) | ((v212 | (v212 >> 1)) >> 2);
      unsigned int v214 = v213 | (v213 >> 4) | ((v213 | (v213 >> 4)) >> 8);
      unsigned int v215 = (v214 | HIWORD(v214)) + 1;
      vDSP_Length v216 = __clz(v215) ^ 0x1F;
      unsigned int v217 = v215 >> 1;
      CFTypeRef v218 = (DSPComplex *)malloc_type_calloc(v171 & 0xFFFFFFFE, 4uLL, 0x100004052888210uLL);
      v547.realp = (float *)malloc_type_calloc(v215 >> 1, 4uLL, 0x100004052888210uLL);
      v547.imagp = (float *)malloc_type_calloc(v215 >> 1, 4uLL, 0x100004052888210uLL);
      char v219 = (FFTSetup *)qword_1EAA94EA8;
      if (v216 > *(_DWORD *)(qword_1EAA94EA8 + 4))
      {
        char v219 = (FFTSetup *)malloc_type_calloc(1uLL, 0x10uLL, 0x10200405730B0C9uLL);
        sub_1DC3EFC6C((uint64_t)v219, v216);
      }
      if (v211 >= 3)
      {
        uint64_t v220 = v211 - 2;
        char v221 = v172 + 2;
        v222 = (float *)v218;
        do
        {
          *v222++ = *v221 - *(v221 - 2);
          ++v221;
          --v220;
        }
        while (v220);
      }
      vDSP_ctoz(v218, 2, &v547, 1, v171 >> 1);
      vDSP_fft_zrip(v219[1], &v547, 1, v216, 1);
      vDSP_zvcmul(&v547, 1, &v547, 1, &v547, 1, v215 >> 1);
      float v223 = (float)v215;
      int v224 = (int)(float)((float)v215 / 40.0);
      if (v224 <= 1) {
        int v224 = 1;
      }
      unsigned int v225 = v217 - 1;
      if (v217 - 1 >= (int)(float)(v223 * v159)) {
        unsigned int v225 = (int)(float)(v223 * v159);
      }
      if (v224 <= v225)
      {
        float v227 = -INFINITY;
        unsigned int v226 = v224;
        uint64_t v155 = v489;
        a1 = v490;
        do
        {
          if (v547.realp[v224] > v227)
          {
            float v227 = v547.realp[v224];
            unsigned int v226 = v224;
          }
          ++v224;
        }
        while (v224 <= v225);
      }
      else
      {
        unsigned int v226 = v224;
        uint64_t v155 = v489;
        a1 = v490;
      }
      if (v219 != (FFTSetup *)qword_1EAA94EA8)
      {
        vDSP_destroy_fftsetup(v219[1]);
        free(v219);
      }
      float v210 = v223 / (float)v226;
      free(v547.realp);
      free(v547.imagp);
      free(v218);
LABEL_315:
      sub_1DC3F0FCC(v172, v171, (float *)&v519 + 1, (float *)&v519);
      int v518 = 0;
      v517 = 0;
      v516 = 0;
      if (v228 != 0.0)
      {
        v229 = v535[0];
        signed int v230 = (signed int)v535[1];
        CFDataRef v231 = CFDataCreate(v498, (const UInt8 *)v535[0], 4 * SLODWORD(v535[1]));
        CFDataRef v232 = v231;
        if (Mutable && v231)
        {
          CFDictionarySetValue(Mutable, @"NormalizedDetrendedProfile", v231);
          goto LABEL_321;
        }
        if (v231) {
LABEL_321:
        }
          CFRelease(v232);
        LODWORD(v547.realp) = HIDWORD(v519);
        CFNumberRef v233 = CFNumberCreate(v498, kCFNumberFloat32Type, &v547);
        CFNumberRef v234 = v233;
        if (Mutable && v233)
        {
          CFDictionarySetValue(Mutable, @"ProfileUnNormalizedVariance", v233);
          goto LABEL_326;
        }
        if (v233) {
LABEL_326:
        }
          CFRelease(v234);
        int v235 = llroundf(v210 * 1.5);
        float v236 = v522;
        if (v522 <= *(float *)&v519) {
          float v236 = *(float *)&v519;
        }
        float v522 = v236;
        *((_DWORD *)v536 + 1) = v235;
        sub_1DC3F0BD0(v229, v230, v235, &v518, (void **)&v517, &v516);
        if (v518 >= 1)
        {
          uint64_t v500 = 0;
          uint64_t v237 = Mutable;
          while (1)
          {
            long long v513 = 0u;
            long long v514 = 0u;
            long long v511 = 0u;
            long long v512 = 0u;
            long long v510 = 0u;
            char v238 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
            v515 = (unsigned __int8 *)v238;
            *((void *)v238 + 8) = 0;
            *((_DWORD *)v238 + 18) = 0;
            *((void *)v238 + 10) = 0;
            *(_OWORD *)char v238 = 0u;
            *((_OWORD *)v238 + 1) = 0u;
            *((_OWORD *)v238 + 2) = 0u;
            *(_OWORD *)(v238 + 44) = 0u;
            sub_1DC3D59D0((uint64_t)v535, (uint64_t)&v510);
            v538 = 0;
            v537 = 0;
            float v540 = 0.0;
            v539 = 0;
            double v239 = v487;
            **(void **)&double v487 = 0;
            *(void *)(*(void *)&v239 + 8) = 0;
            *(unsigned char *)(*(void *)&v239 + 16) = 0;
            v240 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
            __int16 v241 = (int *)v240;
            v543 = (int *)v240;
            double v242 = v486;
            **(_OWORD **)&double v486 = 0u;
            *(_OWORD *)(*(void *)&v242 + 16) = 0u;
            *((void *)v240 + 8) = 0;
            *((_DWORD *)v240 + 18) = 0;
            *((void *)v240 + 10) = 0;
            *(_OWORD *)v240 = 0u;
            *((_OWORD *)v240 + 1) = 0u;
            *((_OWORD *)v240 + 2) = 0u;
            *(_OWORD *)(v240 + 44) = 0u;
            if (v497 >= 0x20000)
            {
              if (dword_1EBFFC218 < 1)
              {
                int v244 = 0x7FFFFFFF;
              }
              else
              {
                uint64_t v243 = 0;
                int v244 = 0x7FFFFFFF;
                v245 = &dword_1EBFFBA28;
                do
                {
                  if (((v27 >> v243) & 1) != 0 && v244 >= *v245) {
                    int v244 = *v245;
                  }
                  ++v243;
                  v245 += 16;
                }
                while (dword_1EBFFC218 != v243);
              }
              *((_DWORD *)v240 + 5) = v244;
            }
            v240[30] = v494;
            v240[29] = v493;
            v546 = (uint64_t *)v520;
            int v246 = v517[v500];
            HIDWORD(v510) = v246;
            int v247 = v516[v500];
            LODWORD(v511) = v247;
            LODWORD(v248) = v247 - v246 + 1;
            uint64_t v249 = (uint64_t)v515;
            *((_DWORD *)v515 + 2) = LODWORD(v248);
            int v250 = DWORD2(v510);
            sub_1DC3F106C((float *)v510, SDWORD2(v510), v246, v247);
            LODWORD(v547.realp) = v246;
            CFNumberRef v251 = CFNumberCreate(v498, kCFNumberIntType, &v547);
            CFNumberRef v252 = v251;
            if (v237)
            {
              if (v251) {
                break;
              }
            }
            if (v251) {
              goto LABEL_345;
            }
LABEL_346:
            LODWORD(v547.realp) = v247;
            CFNumberRef v253 = CFNumberCreate(v498, kCFNumberIntType, &v547);
            CFNumberRef v254 = v253;
            if (v237 && v253)
            {
              CFDictionarySetValue(v237, @"ProfileCropRight", v253);
            }
            else if (!v253)
            {
              goto LABEL_351;
            }
            CFRelease(v254);
LABEL_351:
            if (v497 >= 0x20000)
            {
              unsigned int v173 = sub_1DC3DABE8((uint64_t)&v510, (uint64_t)&v537, v27);
              a1 = v490;
              goto LABEL_353;
            }
            if (v247 <= v246)
            {
              unsigned int v173 = 15;
              goto LABEL_372;
            }
            if (SLODWORD(v248) < 41)
            {
              unsigned int v173 = 16;
LABEL_372:
              uint64_t v155 = v489;
              a1 = v490;
LABEL_373:
              if (v496 > 0x13) {
                goto LABEL_425;
              }
              if (((1 << v496) & 0x1B704) != 0)
              {
                if ((v173 & 0xFFFFFFFC) != 4) {
                  goto LABEL_436;
                }
                goto LABEL_379;
              }
              if (((1 << v496) & 0xE0800) == 0)
              {
LABEL_425:
                BOOL v330 = (v496 & 0xFFFFFFFD) == 4 || v496 == 7;
                if (!v330 || v173 != 5) {
                  goto LABEL_436;
                }
              }
LABEL_379:
              unsigned int v496 = v173;
              goto LABEL_436;
            }
            *(void *)&v529[0] = 0;
            uint64_t v524 = 0;
            *((void *)&v529[0] + 1) = malloc_type_malloc(4 * (v247 - v246 + 1), 0x100004052888210uLL);
            v525 = malloc_type_malloc(4 * (v247 - v246 + 1), 0x100004052888210uLL);
            unint64_t v557 = 0;
            uint64_t v555 = 0;
            v558 = (int *)malloc_type_malloc(4 * (v247 - v246 + 1), 0x100004052888210uLL);
            v556 = malloc_type_malloc(4 * (v247 - v246 + 1), 0x100004052888210uLL);
            unsigned int v299 = sub_1DC37F038((uint64_t)&v510, (uint64_t)&v557, (uint64_t)&v555);
            if (*(float *)&v299 == 0.0)
            {
              unsigned int v299 = sub_1DC37F104((uint64_t *)&v510, (unsigned int *)&v557, (int *)&v555, SLODWORD(v248), 0.8, 0.0);
              if (*(float *)&v299 == 0.0)
              {
                v331 = v453;
                *((void *)v453 + 4) = 0;
                _OWORD *v331 = 0u;
                v331[1] = 0u;
                uint64_t v332 = *(void *)((char *)&v511 + 4);
                if (LODWORD(v248) < 0x2C)
                {
                  unsigned int v173 = 14;
                  a1 = v490;
LABEL_501:
                  *(void *)((char *)&v511 + 4) = v332;
                  goto LABEL_383;
                }
                int v333 = v555;
                uint64_t v507 = (int)v555;
                *(void *)&long long v508 = v556;
                int v334 = v557;
                *(void *)&double v505 = (int)v557;
                v506 = v558;
                size_t v495 = 4 * v250;
                unsigned int v173 = 14;
                float v335 = 0.0;
                v336 = &qword_1DC3FD000;
                *(void *)&double v501 = v555;
                while (2)
                {
                  unsigned int v476 = LODWORD(v248);
                  *(void *)&double v248 = LODWORD(v248) >> 2;
                  float v337 = 0.6;
                  double v504 = v248;
LABEL_441:
                  LODWORD(v524) = v333;
                  if (v333 >= 1)
                  {
                    v338 = v525;
                    uint64_t v340 = v507;
                    v339 = (int *)v508;
                    do
                    {
                      int v341 = *v339++;
                      *v338++ = v341;
                      --v340;
                    }
                    while (v340);
                  }
                  LODWORD(v529[0]) = v334;
                  if (v334 >= 1)
                  {
                    v342 = (_DWORD *)*((void *)&v529[0] + 1);
                    double v344 = v505;
                    v343 = v506;
                    do
                    {
                      int v345 = *v343++;
                      *v342++ = v345;
                      --*(void *)&v344;
                    }
                    while (v344 != 0.0);
                  }
                  unsigned int v346 = sub_1DC37F104((uint64_t *)&v510, (unsigned int *)v529, (int *)&v524, SLODWORD(v248), v337, *((float *)v336 + 722));
                  if (*(float *)&v346 != 0.0)
                  {
                    unsigned int v347 = v346;
                    goto LABEL_491;
                  }
                  uint64_t v554 = 0;
                  imagp = 0;
                  v547.realp = 0;
                  v547.imagp = 0;
                  *(_DWORD *)v549 = 0;
                  v348 = *(int **)&v503;
                  **(void **)&double v503 = 0;
                  *((void *)v348 + 1) = 0;
                  *((unsigned char *)v348 + 16) = 0;
                  v349 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
                  v551 = (float *)v349;
                  double v350 = v502;
                  **(_OWORD **)&double v502 = 0u;
                  *(_OWORD *)(*(void *)&v350 + 16) = 0u;
                  *((void *)v349 + 8) = 0;
                  *((_DWORD *)v349 + 18) = 0;
                  *((void *)v349 + 10) = 0;
                  *(_OWORD *)v349 = 0u;
                  *((_OWORD *)v349 + 1) = 0u;
                  *((_OWORD *)v349 + 2) = 0u;
                  *(_OWORD *)(v349 + 44) = 0u;
                  int v351 = v529[0];
                  uint64_t v352 = *((void *)&v529[0] + 1);
                  uint64_t v353 = (uint64_t)v525;
                  sub_1DC3D6370(*(uint64_t *)&v529[0], *((uint64_t *)&v529[0] + 1), v524, (uint64_t)v525, (_DWORD *)v249, v27);
                  uint64_t v249 = (uint64_t)v515;
                  if (*(_DWORD *)v515)
                  {
                    v354 = (void *)*((void *)v515 + 8);
                    if (v354) {
                      free(v354);
                    }
                    *(void *)(v249 + 64) = 0;
                    *(_DWORD *)(v249 + 56) = 0;
                    v355 = *(void **)(v249 + 80);
                    if (v355) {
                      free(v355);
                    }
                    *(void *)(v249 + 80) = 0;
                    *(_DWORD *)(v249 + 72) = 0;
                    size_t v356 = v495;
                    *(void *)(v249 + 64) = malloc_type_malloc(v495, 0x100004052888210uLL);
                    *(void *)(v249 + 80) = malloc_type_malloc(v356, 0x100004052888210uLL);
                    uint64_t v357 = v510;
                    unsigned int v358 = sub_1DC37F87C(v510, v351, v352, v353, v249 + 56, v249 + 72);
                    unsigned int v347 = v358;
                    v359 = *(float **)(v249 + 64);
                    float v360 = *v359;
                    v361 = *(float **)(v249 + 80);
                    if (*v359 >= *v361) {
                      float v360 = *v361;
                    }
                    *((float *)&v511 + 1) = v360;
                    float v362 = v359[*(int *)(v249 + 56) - 1];
                    v363 = &v361[*(int *)(v249 + 72)];
                    if (v362 <= *(v363 - 1)) {
                      float v362 = *(v363 - 1);
                    }
                    *((float *)&v511 + 2) = v362;
                    unsigned int v27 = v499;
                    if (*(float *)&v358 != 0.0)
                    {
LABEL_459:
                      uint64_t v364 = (uint64_t)v551;
                      v336 = &qword_1DC3FD000;
                      LODWORD(v248) = LODWORD(v504);
                      if (v347 <= 1)
                      {
LABEL_482:
                        *(_DWORD *)(v364 + 12) = LODWORD(v248);
                        *(float *)(v364 + 16) = v337;
                        float v391 = *(float *)v549;
                        if (*(float *)v549 > v335)
                        {
                          uint64_t v332 = *(void *)((char *)&v511 + 4);
                          sub_1DC3D58A4((uint64_t)&v547, (uint64_t)&v537);
                          unsigned int v173 = v347;
                          float v335 = v391;
                        }
                        sub_1DC3D5738(v364);
LABEL_485:
                        free((void *)v364);
LABEL_486:
                        v551 = 0;
                        if (imagp == v539)
                        {
                          int v333 = LODWORD(v501);
                        }
                        else
                        {
                          int v333 = LODWORD(v501);
                          if (imagp) {
                            free(imagp);
                          }
                          imagp = 0;
                        }
LABEL_491:
                        if (v173 == 14) {
                          unsigned int v173 = v347;
                        }
                        float v337 = v337 + -0.15;
                        if (v337 <= 0.25)
                        {
                          if (v476 < 0xB0)
                          {
                            __int16 v241 = v543;
                            a1 = v490;
                            uint64_t v237 = Mutable;
                            goto LABEL_501;
                          }
                          continue;
                        }
                        goto LABEL_441;
                      }
LABEL_463:
                      sub_1DC3D5738(v364);
                      if (v364) {
                        goto LABEL_485;
                      }
                      goto LABEL_486;
                    }
                    sub_1DC3D5788((int *)v249, (uint64_t)v551);
                    int v365 = DWORD2(v510);
                    unsigned int v347 = sub_1DC3D619C(*(void *)(v249 + 56), *(void *)(v249 + 64), *(void *)(v249 + 72), *(void *)(v249 + 80), (uint64_t)&v547, v357, DWORD2(v510), 0);
                    if (v347 < 2)
                    {
                      char v366 = 0;
LABEL_481:
                      v336 = &qword_1DC3FD000;
                      LODWORD(v248) = LODWORD(v504);
                      uint64_t v364 = (uint64_t)v551;
                      *((unsigned char *)v551 + 28) = v366;
                      goto LABEL_482;
                    }
                    uint64_t v367 = *(void *)(v249 + 56);
                    uint64_t v478 = *(void *)(v249 + 64);
                    uint64_t v368 = *(void *)(v249 + 72);
                    uint64_t v369 = *(void *)(v249 + 80);
                    double v484 = COERCE_DOUBLE(malloc_type_malloc(4 * (int)v368, 0x100004052888210uLL));
                    v370 = malloc_type_malloc(4 * (int)v367, 0x100004052888210uLL);
                    uint64_t v482 = v367;
                    v483 = v370;
                    uint64_t v477 = (v367 << 32) - 0x100000000;
                    if (v365 <= (int)(*(float *)(v369 + (v477 >> 30)) + 2.0)) {
                      int v371 = v365 - 1;
                    }
                    else {
                      int v371 = (int)(*(float *)(v369 + (v477 >> 30)) + 2.0);
                    }
                    v372 = malloc_type_malloc(4 * v371, 0x100004052888210uLL);
                    unsigned int v373 = v371;
                    if (v371 >= 1)
                    {
                      uint64_t v374 = v371;
                      v375 = (int *)(v357 + 4 * v371);
                      v376 = v372;
                      do
                      {
                        int v377 = *v375--;
                        *v376++ = v377;
                        --v374;
                      }
                      while (v374);
                    }
                    float v378 = (float)v371;
                    double v379 = v484;
                    if ((int)v368 >= 1)
                    {
                      int64_t v380 = ((unint64_t)v368 << 32) - 0x100000000;
                      v381 = *(float **)&v484;
                      uint64_t v382 = v368;
                      do
                      {
                        *v381++ = v378 - *(float *)(v369 + (v380 >> 30));
                        v380 -= 0x100000000;
                        --v382;
                      }
                      while (v382);
                    }
                    v383 = v483;
                    uint64_t v384 = v482;
                    if ((int)v482 >= 1)
                    {
                      v385 = (float *)(v478 + 4 * (v477 >> 32));
                      v386 = (float *)v483;
                      uint64_t v387 = v482;
                      do
                      {
                        float v388 = *v385--;
                        *v386++ = v378 - v388;
                        --v387;
                      }
                      while (v387);
                    }
                    v389 = v372;
                    unsigned int v390 = sub_1DC3D619C(v368, *(uint64_t *)&v379, v384, (uint64_t)v383, (uint64_t)&v547, (uint64_t)v372, v373, 0);
                    free(v389);
                    free(*(void **)&v379);
                    free(v383);
                    unsigned int v27 = v499;
                    if (v390 < 2)
                    {
                      char v366 = 1;
                      unsigned int v347 = v390;
                      goto LABEL_481;
                    }
                    if ((v347 & 0xFFFFFFFD) != 4 || v390 != 5) {
                      goto LABEL_459;
                    }
                    unsigned int v347 = 5;
                    v336 = &qword_1DC3FD000;
                  }
                  else
                  {
                    unsigned int v347 = 2;
                  }
                  break;
                }
                LODWORD(v248) = LODWORD(v504);
                uint64_t v364 = (uint64_t)v551;
                goto LABEL_463;
              }
            }
            unsigned int v173 = v299;
            a1 = v490;
LABEL_383:
            sub_1DC3D5788(v241, v249);
            free(*((void **)&v529[0] + 1));
            free(v525);
            free(v558);
            free(v556);
LABEL_353:
            v256 = v485;
            uint64_t v155 = v489;
            if (v173 != 1)
            {
              if (*(float *)&v173 == 0.0)
              {
                *(void *)&long long v255 = *(void *)((char *)&v511 + 4);
                long long v508 = v255;
                unint64_t v557 = *(void *)((char *)&v511 + 4);
                LODWORD(v506) = *v475;
                v257 = v472;
                float v258 = *v471;
                BOOL v259 = v515[28] == 0;
                unint64_t v261 = v491;
                unint64_t v260 = v492;
                sub_1DC3F02E0(v491, v492, v472, 2u, (float *)&v557, (float *)&v555, &v533);
                float v262 = v258 + flt_1DC3FDA30[v259];
                LODWORD(v501) = v555;
                __float2 v263 = __sincosf_stret(v262);
                unsigned int v496 = HIDWORD(v555);
                *(float *)&size_t v495 = v533;
                *(float *)&double v505 = v534;
                float v264 = (float)(*(float *)v544 + *(float *)v544) * v159;
                float v265 = v264 * 4.0;
                float v266 = *((float *)&v508 + 1);
                if (*(float *)&v508 >= *((float *)&v508 + 1)) {
                  float v267 = *((float *)&v508 + 1);
                }
                else {
                  float v267 = *(float *)&v508;
                }
                float v268 = v267 - v265;
                int v269 = HIDWORD(v510) & ~(SHIDWORD(v510) >> 31);
                if (*(float *)&v508 > *((float *)&v508 + 1)) {
                  float v266 = *(float *)&v508;
                }
                if (v268 <= (float)v269) {
                  float v268 = (float)v269;
                }
                float v270 = v265 + v266;
                float v271 = (float)(int)v511;
                if ((float)((float)SDWORD2(v510) + -1.0) <= (float)(int)v511) {
                  float v271 = (float)SDWORD2(v510) + -1.0;
                }
                if (v270 >= v271) {
                  float v270 = v271;
                }
                unint64_t v557 = __PAIR64__(LODWORD(v270), LODWORD(v268));
                sub_1DC3F02E0(v261, v260, v257, 2u, (float *)&v557, (float *)&v555, &v533);
                *(float *)&double v504 = v263.__cosval;
                float v272 = roundf(v263.__cosval * (float)(v264 + v264));
                *(float *)&uint64_t v507 = v263.__sinval;
                float v273 = roundf(v263.__sinval * (float)(v264 + v264));
                float v274 = v272 + *(float *)&v555;
                float v275 = v273 + v533;
                float v276 = v272 + *((float *)&v555 + 1);
                float v277 = v273 + v534;
                *(float *)&long long v508 = *(float *)&v555 - v272;
                float v278 = v533 - v273;
                float v279 = *((float *)&v555 + 1) - v272;
                uint64_t v554 = 0;
                imagp = 0;
                v547.realp = 0;
                v547.imagp = 0;
                float v280 = v534 - v273;
                *(_DWORD *)v549 = 0;
                v281 = *(int **)&v503;
                **(void **)&double v503 = 0;
                *((void *)v281 + 1) = 0;
                *((unsigned char *)v281 + 16) = 0;
                v282 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
                v551 = (float *)v282;
                double v283 = v502;
                **(_OWORD **)&double v502 = 0u;
                *(_OWORD *)(*(void *)&v283 + 16) = 0u;
                *((void *)v282 + 8) = 0;
                *((_DWORD *)v282 + 18) = 0;
                *((void *)v282 + 10) = 0;
                *(_OWORD *)v282 = 0u;
                *((_OWORD *)v282 + 1) = 0u;
                *((_OWORD *)v282 + 2) = 0u;
                *(_OWORD *)(v282 + 44) = 0u;
                uint64_t v532 = 0;
                memset(v529, 0, 28);
                v284 = v463;
                v463[16] = 0;
                void *v284 = 0;
                v284[1] = 0;
                v285 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
                *(void *)&long long v530 = v285;
                v286 = v462;
                _OWORD *v462 = 0u;
                v286[1] = 0u;
                *((void *)v285 + 8) = 0;
                *((_DWORD *)v285 + 18) = 0;
                *((void *)v285 + 10) = 0;
                *(_OWORD *)v285 = 0u;
                *((_OWORD *)v285 + 1) = 0u;
                *((_OWORD *)v285 + 2) = 0u;
                *(_OWORD *)(v285 + 44) = 0u;
                LODWORD(v529[0]) = v537;
                LODWORD(v547.realp) = v537;
                uint64_t v287 = v530;
                if (v497 < 0x20000)
                {
                  char v300 = v494;
                  *(unsigned char *)(v530 + 30) = v494;
                  uint64_t v301 = (uint64_t)v551;
                  *((unsigned char *)v551 + 30) = v300;
                  BOOL v302 = v493;
                  *(unsigned char *)(v287 + 29) = v493;
                  *(unsigned char *)(v301 + 29) = v302;
                  v303 = v515;
                  int v291 = sub_1DC3ED978((uint64_t)v523, v515[28], *((_DWORD *)v515 + 1), *((_DWORD *)v515 + 3), (unsigned int *)&v547, v274, v275, v276, v277, *((float *)v515 + 4));
                  int v292 = sub_1DC3ED978((uint64_t)v523, v303[28], *((_DWORD *)v303 + 1), *((_DWORD *)v303 + 3), (unsigned int *)v529, *(float *)&v508, v278, v279, v280, *((float *)v303 + 4));
                }
                else
                {
                  *(float *)(v530 + 24) = v264;
                  uint64_t v288 = (uint64_t)v551;
                  v551[6] = v264;
                  int v289 = v543[5];
                  *(_DWORD *)(v287 + 20) = v289;
                  *(_DWORD *)(v288 + 20) = v289;
                  LOBYTE(v289) = v494;
                  *(unsigned char *)(v287 + 30) = v494;
                  *(unsigned char *)(v288 + 30) = v289;
                  LOBYTE(v289) = v493;
                  *(unsigned char *)(v287 + 29) = v493;
                  *(unsigned char *)(v288 + 29) = v289;
                  v290 = v515;
                  int v291 = sub_1DC3ED4DC((uint64_t)v523, v515[28], (uint64_t)&v547, v274, v275, v276, v277);
                  int v292 = sub_1DC3ED4DC((uint64_t)v523, v290[28], (uint64_t)v529, *(float *)&v508, v278, v279, v280);
                }
                int v304 = v292;
                float v159 = 0.5;
                if (v291 || v547.imagp != v538)
                {
                  BOOL v305 = 0;
                }
                else
                {
                  BOOL v305 = memcmp(imagp, v539, (size_t)v547.imagp) == 0;
                  float v306 = *(float *)v549;
                  if (*(float *)v549 <= v540) {
                    float v306 = v540;
                  }
                  float v540 = v306;
                  if (v305)
                  {
LABEL_397:
                    if (v291 || v305)
                    {
                      uint64_t v237 = Mutable;
                    }
                    else
                    {
                      uint64_t v237 = Mutable;
                      if (!v304 && v547.imagp == (float *)*((void *)&v529[0] + 1) && *((void *)&v529[0] + 1))
                      {
                        int v308 = memcmp(*(const void **)&v529[1], imagp, (size_t)v547.imagp);
                        sub_1DC3D58A4((uint64_t)v529, (uint64_t)&v537);
                        BOOL v330 = v308 == 0;
                        uint64_t v237 = Mutable;
                        BOOL v305 = v330;
                        float v309 = *(float *)v549;
                        if (*(float *)v549 <= *((float *)&v529[1] + 2)) {
                          float v309 = *((float *)&v529[1] + 2);
                        }
                        float v540 = v309;
                      }
                    }
                    sub_1DC3D5860((uint64_t)&v547);
                    sub_1DC3D5860((uint64_t)v529);
                    if (!v305) {
                      goto LABEL_435;
                    }
                    v310 = (double *)operator new(0x40uLL);
                    float v311 = *(float *)&v506 * 0.5;
                    float v312 = *(float *)&v507;
                    double v313 = (float)(*(float *)&v495 - (float)((float)(*(float *)&v506 * 0.5) * *(float *)&v507));
                    double v314 = (float)(*(float *)&v501 + (float)((float)(*(float *)&v506 * 0.5) * *(float *)&v504));
                    double v315 = (float)(*(float *)&v495 + (float)((float)(*(float *)&v506 * 0.5) * *(float *)&v507));
                    double v316 = (float)(*(float *)&v496 + (float)((float)(*(float *)&v506 * 0.5) * *(float *)&v504));
                    float v317 = *(float *)&v505;
                    double v318 = (float)(*(float *)&v505 + (float)((float)(*(float *)&v506 * 0.5) * *(float *)&v507));
                    double v319 = (float)(*(float *)&v496 - (float)((float)(*(float *)&v506 * 0.5) * *(float *)&v504));
                    v526 = v310 + 8;
                    double *v310 = (float)(*(float *)&v501 - (float)((float)(*(float *)&v506 * 0.5) * *(float *)&v504));
                    v310[1] = v313;
                    v310[2] = v314;
                    v310[3] = v315;
                    v310[4] = v316;
                    v310[5] = v318;
                    v310[6] = v319;
                    v310[7] = (float)(v317 - (float)(v311 * v312));
                    uint64_t v524 = (uint64_t)v310;
                    v525 = v310 + 8;
                    sub_1DC3D1A6C(&v509, (unsigned int *)&v537, (uint64_t)&v524, 0.0);
                    operator delete(v310);
                    *(float *)&uint64_t v524 = v540;
                    CFNumberRef v320 = CFNumberCreate(v498, kCFNumberFloat32Type, &v524);
                    CFNumberRef v321 = v320;
                    if (Mutable && v320)
                    {
                      CFDictionarySetValue(Mutable, @"Score", v320);
                    }
                    else if (!v320)
                    {
LABEL_415:
                      v323 = (void *)v256[1];
                      unint64_t v322 = v256[2];
                      if ((unint64_t)v323 >= v322)
                      {
                        uint64_t v325 = ((uint64_t)v323 - *v256) >> 3;
                        if ((unint64_t)(v325 + 1) >> 61) {
                          sub_1DC2FF97C();
                        }
                        uint64_t v326 = v322 - *v256;
                        uint64_t v327 = v326 >> 2;
                        if (v326 >> 2 <= (unint64_t)(v325 + 1)) {
                          uint64_t v327 = v325 + 1;
                        }
                        if ((unint64_t)v326 >= 0x7FFFFFFFFFFFFFF8) {
                          unint64_t v328 = 0x1FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          unint64_t v328 = v327;
                        }
                        v528 = v455;
                        if (v328) {
                          unint64_t v328 = (unint64_t)sub_1DC2FFD7C(v328);
                        }
                        else {
                          uint64_t v329 = 0;
                        }
                        uint64_t v524 = v328;
                        v525 = (void *)(v328 + 8 * v325);
                        v526 = v525;
                        unint64_t v527 = v328 + 8 * v329;
                        void *v525 = atomic_exchange(&v509, 0);
                        ++v526;
                        sub_1DC34D7DC(v256, &v524);
                        v324 = (void *)v256[1];
                        sub_1DC308428((uint64_t)&v524);
                      }
                      else
                      {
                        void *v323 = atomic_exchange(&v509, 0);
                        v324 = v323 + 1;
                        v256[1] = (uint64_t)v324;
                      }
                      v256[1] = (uint64_t)v324;
                      sub_1DC3073A4(&v509);
                      uint64_t v237 = Mutable;
LABEL_435:
                      *(float *)&unsigned int v173 = 0.0;
                      *(float *)&unsigned int v496 = 0.0;
                      goto LABEL_436;
                    }
                    CFRelease(v321);
                    goto LABEL_415;
                  }
                }
                if (!v304 && *((float **)&v529[0] + 1) == v538)
                {
                  BOOL v305 = memcmp(*(const void **)&v529[1], v539, *((size_t *)&v529[0] + 1)) == 0;
                  float v307 = *((float *)&v529[1] + 2);
                  if (*((float *)&v529[1] + 2) <= v540) {
                    float v307 = v540;
                  }
                  float v540 = v307;
                }
                goto LABEL_397;
              }
              goto LABEL_373;
            }
            unsigned int v293 = v470;
            v294 = &v473[104 * v470];
            *((void *)v294 + 12) = 0;
            *((void *)v294 + 1) = 0;
            *((void *)v294 + 2) = 0;
            *(void *)v294 = 0;
            *((_DWORD *)v294 + 6) = 0;
            *((void *)v294 + 9) = 0;
            *((void *)v294 + 10) = 0;
            v294[88] = 0;
            v295 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
            *((void *)v294 + 8) = v295;
            *(_OWORD *)(v294 + 28) = 0u;
            *(_OWORD *)(v294 + 44) = 0u;
            *((void *)v295 + 8) = 0;
            *((_DWORD *)v295 + 18) = 0;
            *((void *)v295 + 10) = 0;
            *(_OWORD *)(v295 + 44) = 0u;
            *((_OWORD *)v295 + 1) = 0u;
            *((_OWORD *)v295 + 2) = 0u;
            *(_OWORD *)v295 = 0u;
            v296 = &v474[88 * v293];
            *((_OWORD *)v296 + 3) = 0u;
            *((_OWORD *)v296 + 4) = 0u;
            *((_OWORD *)v296 + 1) = 0u;
            *((_OWORD *)v296 + 2) = 0u;
            *(_OWORD *)v296 = 0u;
            v297 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
            *((void *)v296 + 10) = v297;
            *((void *)v297 + 8) = 0;
            *((_DWORD *)v297 + 18) = 0;
            *((void *)v297 + 10) = 0;
            *(_OWORD *)(v297 + 44) = 0u;
            *((_OWORD *)v297 + 1) = 0u;
            *((_OWORD *)v297 + 2) = 0u;
            *(_OWORD *)v297 = 0u;
            uint64_t v298 = (uint64_t)v294;
            uint64_t v237 = Mutable;
            sub_1DC3D58A4((uint64_t)&v537, v298);
            sub_1DC3D59D0((uint64_t)&v510, (uint64_t)v296);
            *(_DWORD *)&v469[4 * v293] = v155;
            unsigned int v470 = v293 + 1;
LABEL_436:
            sub_1DC3D5988((uint64_t)&v510);
            sub_1DC3D5860((uint64_t)&v537);
            if (++v500 >= v518) {
              goto LABEL_503;
            }
          }
          CFDictionarySetValue(v237, @"ProfileCropLeft", v251);
LABEL_345:
          CFRelease(v252);
          goto LABEL_346;
        }
        *(float *)&unsigned int v173 = 0.0;
        goto LABEL_503;
      }
      unsigned int v173 = 18;
LABEL_503:
      sub_1DC3D55EC((void **)&v516);
      sub_1DC3D55EC((void **)&v517);
      int v158 = v496;
LABEL_504:
      if (*(float *)&v173 != 0.0 && v464)
      {
        LODWORD(v547.realp) = 0;
        *((float *)&v547.realp + 1) = (float)SLODWORD(v535[1]) + -1.0;
        float v392 = *(float *)v475;
        float v393 = *v471 + 1.5708;
        sub_1DC3F02E0(v491, v492, v472, 2u, (float *)&v547, (float *)&v537, (float *)v529);
        float v394 = *(float *)&v537;
        __float2 v395 = __sincosf_stret(v393);
        float v396 = *((float *)&v537 + 1);
        uint64_t v397 = *(void *)&v529[0];
        v398 = CFArrayCreateMutable(v498, 4, MEMORY[0x1E4F1D510]);
        float v399 = v392 * v159;
        v560.double x = (float)(v394 + (float)(v399 * v395.__cosval));
        v560.double y = (float)(*(float *)&v397 + (float)(v399 * v395.__sinval));
        DictionaryRepresentatiouint64_t n = CGPointCreateDictionaryRepresentation(v560);
        CFArrayAppendValue(v398, DictionaryRepresentation);
        CFRelease(DictionaryRepresentation);
        v561.double x = (float)(v396 + (float)(v399 * v395.__cosval));
        v561.double y = (float)(*((float *)&v397 + 1) + (float)(v399 * v395.__sinval));
        CFDictionaryRef v401 = CGPointCreateDictionaryRepresentation(v561);
        CFArrayAppendValue(v398, v401);
        CFRelease(v401);
        v562.double x = (float)(v396 - (float)(v399 * v395.__cosval));
        v562.double y = (float)(*((float *)&v397 + 1) - (float)(v399 * v395.__sinval));
        CFDictionaryRef v402 = CGPointCreateDictionaryRepresentation(v562);
        CFArrayAppendValue(v398, v402);
        CFRelease(v402);
        v563.double x = (float)(v394 - (float)(v399 * v395.__cosval));
        v563.double y = (float)(*(float *)&v397 - (float)(v399 * v395.__sinval));
        CFDictionaryRef v403 = CGPointCreateDictionaryRepresentation(v563);
        CFArrayAppendValue(v398, v403);
        CFRelease(v403);
        CFArrayAppendValue(v464, v398);
        CFRelease(v398);
      }
      sub_1DC3D5988((uint64_t)v535);
      if (v465 > 0.0 && v155 >= v458 && ((v155 & 1) == 0) == v456) {
        CFAbsoluteTime v459 = CFAbsoluteTimeGetCurrent();
      }
      if (++v155 == v461) {
        goto LABEL_512;
      }
    }
    if (Mutable)
    {
      int32x2_t v174 = vcvt_s32_f32(*(float32x2_t *)(v466 + 36));
      int32x2_t v175 = vcvt_s32_f32(*(float32x2_t *)(v466 + 44));
      int32x2_t v176 = vmin_s32(v174, v175);
      int32x2_t v177 = vabd_s32(v174, v175);
      int v178 = v176.i32[1];
      int v179 = v176.i32[0];
      if (v176.i32[0] <= 25) {
        int v180 = 25;
      }
      else {
        int v180 = v176.i32[0];
      }
      uint64_t v181 = (v180 - 25);
      int32x2_t v182 = vceqz_s32(v177);
      if (v178 <= 25) {
        int v183 = 25;
      }
      else {
        int v183 = v178;
      }
      uint64_t v184 = v491 - v181;
      if (v491 - v181 >= 0x33) {
        uint64_t v184 = 51;
      }
      int32x2_t v185 = vaba_s32((int32x2_t)0x100000001, v174, v175);
      uint64_t v186 = (v183 - 25);
      if (v182.i8[0]) {
        int v179 = v181;
      }
      double v187 = (double)v179;
      unint64_t v188 = v185.i32[0];
      if (v182.i8[0]) {
        unint64_t v188 = v184;
      }
      uint64_t v189 = v492 - v186;
      if (v492 - v186 >= 0x33) {
        uint64_t v189 = 51;
      }
      if (v182.i8[4]) {
        int v178 = v183 - 25;
      }
      double v190 = (double)v178;
      unint64_t v192 = v185.i32[1];
      if (v182.i8[4]) {
        unint64_t v192 = v189;
      }
      double v193 = (double)v192;
      v571.origin.double x = 0.0;
      v571.origin.double y = 0.0;
      v571.size.double height = v467;
      v571.size.double width = v468;
      double v191 = (double)v188;
      CGRect v568 = CGRectIntersection(*(CGRect *)&v187, v571);
      CGFloat v194 = v568.origin.x;
      CGFloat v195 = v568.origin.y;
      CGFloat v196 = v568.size.width;
      CGFloat v197 = v568.size.height;
      DeviceGradouble y = CGColorSpaceCreateDeviceGray();
      CFDataRef v199 = CFDataCreate(0, v480, v454);
      long long v200 = CGDataProviderCreateWithCFData(v199);
      CFRelease(v199);
      long long v201 = CGImageCreate(v491, v492, 8uLL, 8uLL, v481, DeviceGray, 0, v200, 0, 0, kCGRenderingIntentDefault);
      CGDataProviderRelease(v200);
      v569.origin.double x = v194;
      v569.origin.double y = v195;
      v569.size.double width = v196;
      v569.size.double height = v197;
      uint64_t v202 = CGImageCreateWithImageInRect(v201, v569);
      if (v202)
      {
        CGRect v203 = CFDataCreateMutable(v498, 0);
        CGRect v204 = CGImageDestinationCreateWithData(v203, @"public.tiff", 1uLL, 0);
        CGRect v205 = v204;
        if (v204)
        {
          CGImageDestinationAddImage(v204, v202, 0);
          CGImageDestinationFinalize(v205);
          CFRelease(v205);
        }
        else
        {
          CFRelease(v203);
          CGRect v203 = 0;
        }
        CGImageRelease(v202);
      }
      else
      {
        CGRect v203 = 0;
      }
      CGColorSpaceRelease(DeviceGray);
      CGImageRelease(v201);
      if (v203)
      {
        CFDictionarySetValue(Mutable, @"CroppedImage", v203);
        CFRelease(v203);
        int v171 = (int)v535[1];
      }
    }
    BOOL v206 = Mutable != 0;
    float32x2_t v172 = v535[0];
    CFDataRef v207 = CFDataCreate(v498, (const UInt8 *)v535[0], 4 * v171);
    CFDataRef v208 = v207;
    if (v207) {
      BOOL v209 = v206;
    }
    else {
      BOOL v209 = 0;
    }
    if (v209)
    {
      CFDictionarySetValue(Mutable, @"Profile", v207);
    }
    else if (!v207)
    {
      goto LABEL_294;
    }
    CFRelease(v208);
LABEL_294:
    uint64_t v519 = 0;
    float v210 = 1.0;
    if (v171 < 2) {
      goto LABEL_315;
    }
    goto LABEL_295;
  }
  uint64_t v554 = 0;
  imagp = 0;
  v547.realp = 0;
  v547.imagp = 0;
  *(_DWORD *)v549 = 0;
  v552[1] = 0;
  v552[0] = 0;
  char v553 = 0;
  float v54 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
  v551 = (float *)v54;
  *(_OWORD *)&v549[4] = 0u;
  long long v550 = 0u;
  *((void *)v54 + 8) = 0;
  *((_DWORD *)v54 + 18) = 0;
  *((void *)v54 + 10) = 0;
  *(_OWORD *)float v54 = 0u;
  *((_OWORD *)v54 + 1) = 0u;
  *((_OWORD *)v54 + 2) = 0u;
  *(_OWORD *)(v54 + 44) = 0u;
  v54[30] = v494;
  v54[29] = v493;
  if (dword_1EBFFC218 <= 0)
  {
    *((_DWORD *)v54 + 5) = 0x7FFFFFFF;
    v525 = 0;
    uint64_t v524 = 0;
    v526 = 0;
    LOBYTE(v510) = 0;
    LOBYTE(v512) = 0;
    *(double *)&int v59 = v503;
    double v58 = v504;
    double v60 = v502;
    float v61 = *(float *)&v483;
  }
  else
  {
    uint64_t v55 = 0;
    int v56 = 0x7FFFFFFF;
    __float2 v57 = &dword_1EBFFBA28;
    *(double *)&int v59 = v503;
    double v58 = v504;
    double v60 = v502;
    float v61 = *(float *)&v483;
    do
    {
      if (((v27 >> v55) & 1) != 0 && v56 >= *v57) {
        int v56 = *v57;
      }
      ++v55;
      v57 += 16;
    }
    while (dword_1EBFFC218 != v55);
    *((_DWORD *)v54 + 5) = v56;
    v525 = 0;
    uint64_t v524 = 0;
    v526 = 0;
    LOBYTE(v510) = 0;
    LOBYTE(v512) = 0;
  }
  uint64_t v62 = 0;
  double v503 = COERCE_DOUBLE(&v549[4]);
  float v63 = v60;
  LODWORD(v508) = llroundf(v63);
  float v64 = *(double *)&v59;
  LODWORD(v507) = llroundf(v64);
  float v65 = v60 + v58;
  LODWORD(v506) = llroundf(v65);
  float v66 = *(double *)&v59 + height;
  LODWORD(v504) = llroundf(v66);
  do
  {
    long long v530 = 0u;
    memset(v529, 0, sizeof(v529));
    int v67 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
    v531 = v67;
    *((void *)v67 + 8) = 0;
    *((_DWORD *)v67 + 18) = 0;
    *((void *)v67 + 10) = 0;
    *(_OWORD *)(v67 + 44) = 0u;
    *((_OWORD *)v67 + 1) = 0u;
    *((_OWORD *)v67 + 2) = 0u;
    *(_OWORD *)int v67 = 0u;
    int v68 = sub_1DC3F0940((uint64_t)v480, v491, v492, v481, (float **)v529, (float *)v535, (float)*(int *)&v479[56 * v62 + 32], (float)*(int *)&v479[56 * v62 + 36], *(float *)&v479[56 * v62 + 44], *(float *)&v479[56 * v62 + 40], *(float *)&v479[56 * v62 + 48]);
    BOOL v69 = 0;
    DWORD2(v529[0]) = v68;
    if (v68 >= 22)
    {
      HIDWORD(v529[0]) = 0;
      LODWORD(v529[1]) = v68 - 1;
      v546 = 0;
      v539 = 0;
      v537 = 0;
      v538 = 0;
      float v540 = 0.0;
      v544[0] = 0;
      v544[1] = 0;
      char v545 = 0;
      char v70 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
      v543 = (int *)v70;
      long long v541 = 0u;
      long long v542 = 0u;
      *((void *)v70 + 8) = 0;
      *((_DWORD *)v70 + 18) = 0;
      *((void *)v70 + 10) = 0;
      *(_OWORD *)char v70 = 0u;
      *((_OWORD *)v70 + 1) = 0u;
      *((_OWORD *)v70 + 2) = 0u;
      *(_OWORD *)(v70 + 44) = 0u;
      float v71 = v543;
      *((unsigned char *)v543 + 30) = v494;
      *((unsigned char *)v71 + 29) = v493;
      if (dword_1EBFFC218 < 1)
      {
        int v73 = 0x7FFFFFFF;
      }
      else
      {
        uint64_t v72 = 0;
        int v73 = 0x7FFFFFFF;
        int v74 = &dword_1EBFFBA28;
        do
        {
          if (((v27 >> v72) & 1) != 0 && v73 >= *v74) {
            int v73 = *v74;
          }
          ++v72;
          v74 += 16;
        }
        while (dword_1EBFFC218 != v72);
      }
      v71[5] = v73;
      int v75 = v27;
      int v76 = v512;
      *((unsigned char *)v71 + 31) = v512;
      v546 = &v524;
      int v77 = sub_1DC3DABE8((uint64_t)v529, (uint64_t)&v537, v75);
      uint64_t v78 = v537;
      if (v76)
      {
        unsigned __int16 v79 = v479;
      }
      else
      {
        unsigned __int16 v79 = v479;
        if (v537 == 16)
        {
          if (*((unsigned char *)v543 + 31))
          {
            long long v510 = 0u;
            long long v511 = 0u;
            LOBYTE(v512) = 1;
            BOOL v80 = sub_1DC3D18B8(v491, v492, (float *)v535, (int *)&v510, *((float *)&v529[1] + 1), *((float *)&v529[1] + 2));
            unsigned __int16 v79 = v479;
            if ((_BYTE)v512) {
              int v81 = v80;
            }
            else {
              int v81 = 1;
            }
            if (v81) {
              int v76 = v512;
            }
            else {
              int v76 = 0;
            }
            LOBYTE(v512) = v76;
          }
          else
          {
            int v76 = 0;
          }
        }
      }
      if (v77 == 1)
      {
        if ((v78 - 13) <= 1)
        {
          *(void *)&long long v541 = __PAIR64__(v507, v508);
          *((void *)&v542 + 1) = __PAIR64__(v507, v506);
          *(void *)&long long v542 = __PAIR64__(LODWORD(v504), v506);
          *((void *)&v541 + 1) = __PAIR64__(LODWORD(v504), v508);
          unint64_t v84 = *(unsigned int (**)(_OWORD *, double **, char *, void *))&dword_1EBFFBA10[16 * v78 + 14];
          unsigned int v27 = v499;
          if (!v84)
          {
            BOOL v69 = 0;
            a1 = v490;
            goto LABEL_76;
          }
          a1 = v490;
          if (!v84(v529, &v537, &v79[56 * v62], v523))
          {
            sub_1DC3D58A4((uint64_t)&v537, (uint64_t)&v547);
            BOOL v69 = 1;
            goto LABEL_76;
          }
          goto LABEL_72;
        }
      }
      else if (!v77)
      {
        if (imagp)
        {
          char v82 = v538;
          uint64_t v83 = v547.imagp;
          if (v538 == v547.imagp && !memcmp(v539, imagp, (size_t)v538))
          {
            a1 = v490;
            if (v76)
            {
              long long v85 = v511;
              int v86 = *(int **)&v503;
              **(_OWORD **)&double v503 = v510;
              *((_OWORD *)v86 + 1) = v85;
              BOOL v69 = 1;
            }
            else
            {
              BOOL v69 = sub_1DC3D18B8(v491, v492, (float *)v535, *(int **)&v503, *((float *)&v529[1] + 1), *((float *)&v529[1] + 2));
            }
            goto LABEL_75;
          }
          if (v82 >= v83)
          {
            a1 = v490;
            unsigned int v27 = v499;
            if (v540 >= *(float *)v549) {
              sub_1DC3D58A4((uint64_t)&v537, (uint64_t)&v547);
            }
LABEL_72:
            BOOL v69 = 0;
LABEL_76:
            sub_1DC3D5860((uint64_t)&v537);
            goto LABEL_77;
          }
        }
        else
        {
          sub_1DC3D58A4((uint64_t)&v537, (uint64_t)&v547);
        }
      }
      BOOL v69 = 0;
      a1 = v490;
LABEL_75:
      unsigned int v27 = v499;
      goto LABEL_76;
    }
LABEL_77:
    sub_1DC3D5988((uint64_t)v529);
    ++v62;
  }
  while (v62 < v521 && !v69);
  a8 = v485;
  if (v524 && v525) {
    ((void (*)(void))v525)();
  }
  uint64_t v87 = Mutable;
  if (v69)
  {
    int v88 = 0;
    v538 = 0;
    v537 = 0;
    v539 = 0;
    if ((LODWORD(v547.realp) - 15) <= 0xFFFFFFFD)
    {
      int v89 = *(_DWORD *)&v549[4];
      int v90 = *(_DWORD *)&v549[8];
      int v91 = v550;
      int v92 = DWORD1(v550);
      sub_1DC3D1958((char **)&v537);
      double v93 = (double)v90;
      int v88 = (char *)v537;
      sub_1DC3ED744(v537, v505, v52, v51, v18, v61, (double)v89, v93, v94, (double)v91, (double)v92);
      uint64_t v87 = Mutable;
    }
    sub_1DC3D1A6C((atomic_ullong *)v529, (unsigned int *)&v547, (uint64_t)&v537, v61);
    sub_1DC3C9F40(v485, (atomic_ullong *)v529);
    float v522 = 1.0;
    sub_1DC3073A4((atomic_ullong *)v529);
    if (v88) {
      operator delete(v88);
    }
    *(float *)&unsigned int v496 = 0.0;
  }
  else
  {
    unsigned int v496 = 19;
  }
  sub_1DC3D5860((uint64_t)&v547);
  CFMutableArrayRef v95 = 0;
  float v35 = v479;
LABEL_549:
  if (v35) {
    free(v35);
  }
  if (v95)
  {
    v445 = (void *)atomic_load_explicit(a8 + 3, memory_order_acquire);
    if (v445) {
      v445 = (void *)CFRetain(v445);
    }
    v547.realp = (float *)v445;
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v547, memory_order_acquire), @"FrameFailedLocations", v95);
    sub_1DC306584((atomic_ullong *)&v547);
    CFRelease(v95);
    uint64_t v87 = Mutable;
  }
  if (v87)
  {
    v446 = (void *)atomic_load_explicit(a8 + 3, memory_order_acquire);
    if (v446) {
      v446 = (void *)CFRetain(v446);
    }
    v547.realp = (float *)v446;
    v447 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v547, memory_order_acquire);
    v448 = Mutable;
    CFDictionarySetValue(v447, @"FrameDebugData", Mutable);
    sub_1DC306584((atomic_ullong *)&v547);
    CFRelease(v448);
  }
  if (*(unsigned char *)(*(void *)(a1 + 8) + 50) && v522 >= 0.0)
  {
    v449 = (void *)atomic_load_explicit(a8 + 3, memory_order_acquire);
    if (v449) {
      v449 = (void *)CFRetain(v449);
    }
    v547.realp = (float *)v449;
    v450 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v547, memory_order_acquire);
    v537 = (double *)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v522);
    CFDictionarySetValue(v450, @"FocusSharpness", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v537, memory_order_acquire));
    sub_1DC3065B8((atomic_ullong *)&v537);
    sub_1DC306584((atomic_ullong *)&v547);
  }
  return v496;
}

void sub_1DC3D1770(_Unwind_Exception *exception_object)
{
  CFAllocatorRef v3 = *(void **)(v1 + 920);
  if (v3)
  {
    *(void *)(v1 + 928) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1DC3D18B8(unint64_t a1, unint64_t a2, float *a3, int *a4, float a5, float a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v15[0] = a5;
  v15[1] = a6;
  int v7 = sub_1DC3F02E0(a1, a2, a3, 2u, v15, v14, v13);
  if (v7)
  {
    int v8 = (int)v14[0];
    float v9 = v13[1];
    int v10 = (int)v13[0];
    int v11 = (int)v14[1];
    a4[2] = (int)v14[0];
    a4[3] = v10;
    *a4 = v8;
    a4[1] = v10;
    a4[6] = v11;
    a4[7] = (int)v9;
    a4[4] = v11;
    a4[5] = (int)v9;
  }
  return v7 != 0;
}

void sub_1DC3D1958(char **a1)
{
  CFAllocatorRef v2 = *a1;
  CFAllocatorRef v3 = a1[1];
  uint64_t v4 = v3 - *a1;
  if ((unint64_t)v4 > 0x3F)
  {
    if (v4 == 64) {
      return;
    }
    double v18 = v2 + 64;
    goto LABEL_18;
  }
  unint64_t v5 = 4 - (v4 >> 4);
  unsigned int v6 = a1[2];
  if (v5 <= (v6 - v3) >> 4)
  {
    bzero(a1[1], 16 * v5);
    double v18 = &v3[16 * v5];
LABEL_18:
    a1[1] = v18;
    return;
  }
  uint64_t v7 = v4 >> 4;
  uint64_t v8 = v6 - v2;
  uint64_t v9 = v8 >> 3;
  if ((unint64_t)(v8 >> 3) <= 4) {
    uint64_t v9 = 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  int v11 = (char *)sub_1DC300068(v10);
  int v12 = &v11[16 * v7];
  int v14 = &v11[16 * v13];
  bzero(v12, 16 * v5);
  float v15 = &v12[16 * v5];
  double v17 = *a1;
  uint64_t v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      *((_OWORD *)v12 - 1) = *((_OWORD *)v16 - 1);
      v12 -= 16;
      v16 -= 16;
    }
    while (v16 != v17);
    uint64_t v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
  {
    operator delete(v16);
  }
}

void *sub_1DC3D1A6C(atomic_ullong *a1, unsigned int *a2, uint64_t a3, float a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1DC34D67C();
  *a1 = (atomic_ullong)result;
  if (!atomic_load_explicit(a1, memory_order_acquire)) {
    return result;
  }
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v10 = *a2;
  int v11 = "";
  if ((v10 & 0x80000000) == 0 && dword_1EBFFC218 > (int)v10) {
    int v11 = *(const char **)&dword_1EBFFBA10[16 * v10 + 2];
  }
  *(void *)&v51.f64[0] = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v11, 0x8000100u);
  int v12 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit(a1, memory_order_acquire) + 16), atomic_exchange((atomic_ullong *volatile)&v51, 0));
  if (v12) {
    CFRelease(v12);
  }
  sub_1DC31FA90((atomic_ullong *)&v51);
  *(void *)&v51.f64[0] = CFDataCreate(v9, *((const UInt8 **)a2 + 2), *((void *)a2 + 1));
  uint64_t v13 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit(a1, memory_order_acquire) + 24), atomic_exchange((atomic_ullong *volatile)&v51, 0));
  if (v13) {
    CFRelease(v13);
  }
  sub_1DC34D854((atomic_ullong *)&v51);
  unsigned int v14 = a2[6];
  unint64_t explicit = atomic_load_explicit(a1, memory_order_acquire);
  *(_DWORD *)(explicit + 32) = v14;
  *(unsigned char *)(explicit + 36) = 1;
  LOWORD(explicit) = *((unsigned __int8 *)a2 + 88);
  *(_WORD *)(atomic_load_explicit(a1, memory_order_acquire) + 104) = explicit | 0x100;
  uint64_t v16 = *((void *)a2 + 9);
  unint64_t v17 = atomic_load_explicit(a1, memory_order_acquire);
  if (!*(unsigned char *)(v17 + 280)) {
    *(unsigned char *)(v17 + 280) = 1;
  }
  *(void *)(v17 + 272) = v16;
  uint64_t v18 = *(void *)(a2 + 7);
  v19.i64[0] = (int)v18;
  v19.i64[1] = SHIDWORD(v18);
  float64x2_t v20 = vcvtq_f64_s64(v19);
  uint64_t v21 = *(void *)(a2 + 11);
  v19.i64[0] = (int)v21;
  v19.i64[1] = SHIDWORD(v21);
  float64x2_t v22 = vcvtq_f64_s64(v19);
  unint64_t v23 = atomic_load_explicit(a1, memory_order_acquire);
  if (!*(unsigned char *)(v23 + 264)) {
    *(unsigned char *)(v23 + 264) = 1;
  }
  *(float64x2_t *)(v23 + 232) = v20;
  *(float64x2_t *)(v23 + 248) = v22;
  if (*a2 - 13 <= 1)
  {
    unint64_t v24 = atomic_load_explicit(a1, memory_order_acquire);
    *(void *)(v24 + 144) = 0;
    *(void *)(v24 + 152) = 0;
    *(_DWORD *)(v24 + 160) = 0;
    *(unsigned char *)(v24 + 164) = 1;
    unint64_t v25 = atomic_load_explicit(a1, memory_order_acquire);
    unsigned int v26 = a2[20];
    if (!*(unsigned char *)(v25 + 148)) {
      *(unsigned char *)(v25 + 148) = 1;
    }
    *(_DWORD *)(v25 + 144) = v26;
    unint64_t v27 = atomic_load_explicit(a1, memory_order_acquire);
    unsigned int v28 = a2[21];
    if (!*(unsigned char *)(v27 + 156)) {
      *(unsigned char *)(v27 + 156) = 1;
    }
    *(_DWORD *)(v27 + 152) = v28;
    int v29 = *a2;
    if (*a2 == 13)
    {
      *(_WORD *)(atomic_load_explicit(a1, memory_order_acquire) + 160) = 256;
      if (a2[1] == 3)
      {
        unint64_t v30 = atomic_load_explicit(a1, memory_order_acquire);
        if (*(unsigned char *)(v30 + 208)) {
          sub_1DC34D854((atomic_ullong *)(v30 + 200));
        }
        *(void *)(v30 + 200) = 0;
        *(_OWORD *)(v30 + 168) = 0u;
        *(_OWORD *)(v30 + 184) = 0u;
        *(unsigned char *)(v30 + 208) = 1;
        *(unsigned char *)(atomic_load_explicit(a1, memory_order_acquire) + 168) = 1;
        *(void *)(atomic_load_explicit(a1, memory_order_acquire) + 176) = 5;
      }
      int v29 = *a2;
    }
    if (v29 == 14 && a2[1])
    {
      unint64_t v31 = atomic_load_explicit(a1, memory_order_acquire);
      if (*(unsigned char *)(v31 + 208)) {
        sub_1DC34D854((atomic_ullong *)(v31 + 200));
      }
      *(void *)(v31 + 200) = 0;
      *(_OWORD *)(v31 + 168) = 0u;
      *(_OWORD *)(v31 + 184) = 0u;
      *(unsigned char *)(v31 + 208) = 1;
      *(unsigned char *)(atomic_load_explicit(a1, memory_order_acquire) + 168) = 1;
      unsigned int v32 = a2[1];
      if (v32 == 1)
      {
        uint64_t v33 = 3;
      }
      else
      {
        if (v32 != 2) {
          goto LABEL_33;
        }
        uint64_t v33 = 4;
      }
      *(void *)(atomic_load_explicit(a1, memory_order_acquire) + 176) = v33;
    }
  }
LABEL_33:
  int v34 = *a2;
  if (*a2 == 9 && *((void *)a2 + 1) >= 2uLL)
  {
    if (*(unsigned char *)(*((void *)a2 + 2) + 1) == 102)
    {
      unint64_t v35 = atomic_load_explicit(a1, memory_order_acquire);
      if (*(unsigned char *)(v35 + 208)) {
        sub_1DC34D854((atomic_ullong *)(v35 + 200));
      }
      *(void *)(v35 + 200) = 0;
      *(_OWORD *)(v35 + 168) = 0u;
      *(_OWORD *)(v35 + 184) = 0u;
      *(unsigned char *)(v35 + 208) = 1;
      *(unsigned char *)(atomic_load_explicit(a1, memory_order_acquire) + 168) = 1;
      if (a2[1] == 4) {
        *(void *)(atomic_load_explicit(a1, memory_order_acquire) + 176) = 2;
      }
    }
    int v34 = *a2;
  }
  if (v34 == 16)
  {
    unint64_t v36 = atomic_load_explicit(a1, memory_order_acquire);
    if (*(unsigned char *)(v36 + 208)) {
      sub_1DC34D854((atomic_ullong *)(v36 + 200));
    }
    *(void *)(v36 + 200) = 0;
    *(_OWORD *)(v36 + 168) = 0u;
    *(_OWORD *)(v36 + 184) = 0u;
    *(unsigned char *)(v36 + 208) = 1;
    *(unsigned char *)(atomic_load_explicit(a1, memory_order_acquire) + 168) = 1;
    if (a2[1] == 4) {
      *(void *)(atomic_load_explicit(a1, memory_order_acquire) + 176) = 2;
    }
  }
  float v37 = *(const void **)a3;
  float v38 = *(const void **)(a3 + 8);
  unint64_t v39 = atomic_load_explicit(a1, memory_order_acquire);
  float v40 = (void **)(v39 + 40);
  if (v37 == v38)
  {
    uint64_t v42 = *(void *)(a2 + 7);
    v43.i64[0] = (int)v42;
    v43.i64[1] = SHIDWORD(v42);
    float64x2_t v44 = vcvtq_f64_s64(v43);
    uint64_t v45 = *(void *)(a2 + 9);
    v43.i64[0] = (int)v45;
    v43.i64[1] = SHIDWORD(v45);
    float64x2_t v51 = v44;
    float64x2_t v52 = vcvtq_f64_s64(v43);
    v44.f64[0] = *(float64_t *)(a2 + 11);
    v43.i64[0] = SLODWORD(v44.f64[0]);
    v43.i64[1] = SHIDWORD(v44.f64[0]);
    float64x2_t v46 = vcvtq_f64_s64(v43);
    uint64_t v47 = *(void *)(a2 + 13);
    v43.i64[0] = (int)v47;
    v43.i64[1] = SHIDWORD(v47);
    float64x2_t v53 = v46;
    float64x2_t v54 = vcvtq_f64_s64(v43);
    if (*(unsigned char *)(v39 + 64))
    {
      float v48 = *v40;
      if (*v40)
      {
        *(void *)(v39 + 48) = v48;
        operator delete(v48);
      }
      *(unsigned char *)(v39 + 64) = 0;
    }
    *float v40 = 0;
    *(void *)(v39 + 48) = 0;
    *(void *)(v39 + 56) = 0;
    uint64_t result = sub_1DC34D888((void *)(v39 + 40), 4uLL);
    int v49 = *(float64x2_t **)(v39 + 48);
    *int v49 = v51;
    v49[1] = v52;
    _OWORD v49[2] = v53;
    v49[3] = v54;
    *(void *)(v39 + 48) = v49 + 4;
  }
  else
  {
    if (*(unsigned char *)(v39 + 64))
    {
      float v41 = *v40;
      if (*v40)
      {
        *(void *)(v39 + 48) = v41;
        operator delete(v41);
      }
      *(unsigned char *)(v39 + 64) = 0;
    }
    *float v40 = 0;
    *(void *)(v39 + 48) = 0;
    *(void *)(v39 + 56) = 0;
    uint64_t result = sub_1DC3CA088((void *)(v39 + 40), *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4);
  }
  *(unsigned char *)(v39 + 64) = 1;
  unint64_t v50 = atomic_load_explicit(a1, memory_order_acquire);
  *(float *)(v50 + 224) = a4;
  *(unsigned char *)(v50 + 228) = 1;
  return result;
}

void sub_1DC3D1F00(_Unwind_Exception *a1)
{
  unint64_t v5 = *v2;
  if (*v2)
  {
    *(void *)(v3 + 48) = v5;
    operator delete(v5);
  }
  sub_1DC3073A4(v1);
  _Unwind_Resume(a1);
}

void sub_1DC3D1F54()
{
}

void sub_1DC3D4C04(_Unwind_Exception *a1)
{
  sub_1DC3070BC((atomic_ullong *)&STACK[0x4C0]);
  sub_1DC3122B8(v2);
  sub_1DC3D5360(&v4);
  if (v5)
  {
    unsigned int v6 = v5;
    operator delete(v5);
  }
  if (v3) {
    operator delete(v3);
  }
  _Unwind_Resume(a1);
}

void sub_1DC3D4D1C()
{
}

void sub_1DC3D4D40()
{
}

void sub_1DC3D4D6C()
{
}

void sub_1DC3D4D98()
{
}

atomic_uint *sub_1DC3D4E20(atomic_uint *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 61) {
      sub_1DC2FF97C();
    }
    unsigned int v6 = result;
    uint64_t result = (atomic_uint *)sub_1DC2FFD7C(a4);
    uint64_t v7 = result;
    *unsigned int v6 = result;
    v6[1] = result;
    v6[2] = &result[2 * v8];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v10 = (atomic_uint **)&v7[v9];
        *(void *)&v7[v9] = 0;
        uint64_t v11 = *(void *)(a2 + v9 * 4);
        if (v11)
        {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v11 + 8), 1u, memory_order_relaxed);
          uint64_t result = *v10;
          if (*v10) {
            uint64_t result = sub_1DC2FF57C(result);
          }
        }
        *(void *)&v7[v9] = v11;
        v9 += 2;
      }
      while (a2 + v9 * 4 != a3);
      uint64_t v7 = (atomic_uint *)((char *)v7 + v9 * 4);
    }
    v6[1] = v7;
  }
  return result;
}

void sub_1DC3D4EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_1DC3D4F28(void *a1, uint64_t *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_1DC2FF97C();
  }
  unsigned int v6 = a1 + 2;
  if (0x5555555555555556 * ((uint64_t)(a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((uint64_t)(a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[2] - *a1) >> 3) >= 0x555555555555555) {
    unint64_t v7 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v7 = v3;
  }
  float v15 = v6;
  if (v7) {
    unint64_t v7 = (unint64_t)sub_1DC34EB60(v7);
  }
  else {
    uint64_t v8 = 0;
  }
  unint64_t v9 = v7 + 24 * v2;
  v12[0] = v7;
  v12[1] = v9;
  unint64_t v13 = v9;
  unint64_t v14 = v7 + 24 * v8;
  *(void *)unint64_t v9 = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  sub_1DC3D4E20((atomic_uint *)v9, *a2, a2[1], (a2[1] - *a2) >> 3);
  v13 += 24;
  sub_1DC3A5B0C(a1, v12);
  uint64_t v10 = a1[1];
  sub_1DC3D53E4((uint64_t)v12);
  return v10;
}

void sub_1DC3D5028(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3D53E4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3D503C(uint64_t a1, void *a2)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    sub_1DC3117A4(a1, a2);
    *(unsigned char *)(a1 + 24) = 1;
    return a1;
  }
  if ((void *)a1 != a2)
  {
    unint64_t v3 = a2 + 1;
    uint64_t v4 = (void *)*a2;
    if (*(void *)(a1 + 16))
    {
      unint64_t v5 = *(uint64_t **)a1;
      unint64_t v7 = (uint64_t **)(a1 + 8);
      uint64_t v6 = *(void *)(a1 + 8);
      *(void *)a1 = a1 + 8;
      *(void *)(v6 + 16) = 0;
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 8) = 0;
      if (v5[1]) {
        uint64_t v8 = v5[1];
      }
      else {
        uint64_t v8 = (uint64_t)v5;
      }
      if (v8)
      {
        unint64_t v9 = sub_1DC3A9EF8(v8);
        if (v4 == v3)
        {
          uint64_t v11 = (void *)v8;
        }
        else
        {
          uint64_t v10 = v4;
          do
          {
            uint64_t v11 = v9;
            int v12 = *((_DWORD *)v10 + 7);
            *(_DWORD *)(v8 + 28) = v12;
            *(_DWORD *)(v8 + 32) = *((_DWORD *)v10 + 8);
            unint64_t v13 = *v7;
            unint64_t v14 = (uint64_t **)(a1 + 8);
            float v15 = (uint64_t **)(a1 + 8);
            if (*v7)
            {
              do
              {
                while (1)
                {
                  unint64_t v14 = (uint64_t **)v13;
                  if (v12 >= *((_DWORD *)v13 + 7)) {
                    break;
                  }
                  unint64_t v13 = (uint64_t *)*v13;
                  float v15 = v14;
                  if (!*v14) {
                    goto LABEL_16;
                  }
                }
                unint64_t v13 = (uint64_t *)v13[1];
              }
              while (v13);
              float v15 = v14 + 1;
            }
LABEL_16:
            sub_1DC311D78((uint64_t **)a1, (uint64_t)v14, v15, (uint64_t *)v8);
            if (v9) {
              unint64_t v9 = sub_1DC3A9EF8((uint64_t)v9);
            }
            else {
              unint64_t v9 = 0;
            }
            uint64_t v16 = (void *)v10[1];
            if (v16)
            {
              do
              {
                uint64_t v4 = v16;
                uint64_t v16 = (void *)*v16;
              }
              while (v16);
            }
            else
            {
              do
              {
                uint64_t v4 = (void *)v10[2];
                BOOL v17 = *v4 == (void)v10;
                uint64_t v10 = v4;
              }
              while (!v17);
            }
            if (!v11) {
              break;
            }
            uint64_t v8 = (uint64_t)v11;
            uint64_t v10 = v4;
          }
          while (v4 != v3);
        }
        sub_1DC31191C(v11);
        if (!v9) {
          goto LABEL_35;
        }
        for (int i = (void *)v9[2]; i; int i = (void *)i[2])
          unint64_t v9 = i;
        uint64_t v18 = v9;
      }
      else
      {
        uint64_t v18 = 0;
      }
      sub_1DC31191C(v18);
    }
LABEL_35:
    if (v4 != v3)
    {
      float64x2_t v20 = (uint64_t **)(a1 + 8);
      do
      {
        uint64_t v21 = (uint64_t *)operator new(0x28uLL);
        uint64_t v22 = *(void *)((char *)v4 + 28);
        *(uint64_t *)((char *)v21 + 28) = v22;
        unint64_t v23 = *v20;
        unint64_t v24 = (uint64_t **)(a1 + 8);
        unint64_t v25 = (uint64_t **)(a1 + 8);
        if (*v20)
        {
          do
          {
            while (1)
            {
              unint64_t v24 = (uint64_t **)v23;
              if (*((_DWORD *)v23 + 7) <= (int)v22) {
                break;
              }
              unint64_t v23 = (uint64_t *)*v23;
              unint64_t v25 = v24;
              if (!*v24) {
                goto LABEL_43;
              }
            }
            unint64_t v23 = (uint64_t *)v23[1];
          }
          while (v23);
          unint64_t v25 = v24 + 1;
        }
LABEL_43:
        sub_1DC311D78((uint64_t **)a1, (uint64_t)v24, v25, v21);
        unsigned int v26 = (void *)v4[1];
        if (v26)
        {
          do
          {
            unint64_t v27 = v26;
            unsigned int v26 = (void *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            unint64_t v27 = (void *)v4[2];
            BOOL v17 = *v27 == (void)v4;
            uint64_t v4 = v27;
          }
          while (!v17);
        }
        uint64_t v4 = v27;
      }
      while (v27 != v3);
    }
  }
  return a1;
}

uint64_t *sub_1DC3D527C(uint64_t *a1)
{
  if (!a1) {
LABEL_7:
  }
    sub_1DC32BA10("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      int v1 = *((_DWORD *)a1 + 7);
      if (v1 < 10) {
        break;
      }
      a1 = (uint64_t *)*a1;
      if (!a1) {
        goto LABEL_7;
      }
    }
    if (v1 == 9) {
      return a1 + 4;
    }
    a1 = (uint64_t *)a1[1];
    if (!a1) {
      goto LABEL_7;
    }
  }
}

void sub_1DC3D52CC(void ***a1)
{
  int v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        sub_1DC311C68(&v6);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

atomic_uint **sub_1DC3D5360(atomic_uint **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    sub_1DC2FF57C(v2);
  }
  return a1;
}

void *sub_1DC3D5394(unint64_t a1)
{
  if (a1 >> 59) {
    sub_1DC2FF994();
  }
  return operator new(32 * a1);
}

void sub_1DC3D53CC()
{
}

uint64_t sub_1DC3D53E4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v6 = v4;
    sub_1DC311C68(&v6);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DC3D5444(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  double v5 = (*(float (**)(uint64_t))(*(void *)a2 + 16))(a2);
  double v6 = (*(float (**)(uint64_t))(*(void *)a2 + 24))(a2);
  double v7 = *(double *)(a1 + 24);
  double v8 = *(double *)(a1 + 32);
  double v9 = *(double *)(a1 + 40);
  double v10 = *(double *)(a1 + 48);
  double v11 = *(double *)(a1 + 56) + v9 * v6 + v7 * v5;
  double v12 = *(double *)(a1 + 64) + v10 * v6 + v8 * v5;
  double v13 = v9 * 0.5 + v7 * 0.5;
  double v14 = v10 * 0.5 + v8 * 0.5;
  uint64_t v16 = *(double **)(v4 + 8);
  unint64_t v15 = *(void *)(v4 + 16);
  if ((unint64_t)v16 >= v15)
  {
    uint64_t v18 = *(double **)v4;
    uint64_t v19 = ((uint64_t)v16 - *(void *)v4) >> 5;
    unint64_t v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 59) {
      sub_1DC2FF97C();
    }
    uint64_t v21 = v15 - (void)v18;
    if (v21 >> 4 > v20) {
      unint64_t v20 = v21 >> 4;
    }
    BOOL v22 = (unint64_t)v21 >= 0x7FFFFFFFFFFFFFE0;
    unint64_t v23 = 0x7FFFFFFFFFFFFFFLL;
    if (!v22) {
      unint64_t v23 = v20;
    }
    if (v23)
    {
      unint64_t v23 = (unint64_t)sub_1DC3D5394(v23);
      uint64_t v18 = *(double **)v4;
      uint64_t v16 = *(double **)(v4 + 8);
    }
    else
    {
      uint64_t v24 = 0;
    }
    unint64_t v25 = (double *)(v23 + 32 * v19);
    *unint64_t v25 = v11;
    v25[1] = v12;
    unint64_t v26 = v23 + 32 * v24;
    _DWORD v25[2] = v13;
    v25[3] = v14;
    BOOL v17 = v25 + 4;
    if (v16 != v18)
    {
      do
      {
        long long v27 = *((_OWORD *)v16 - 1);
        *((_OWORD *)v25 - 2) = *((_OWORD *)v16 - 2);
        *((_OWORD *)v25 - 1) = v27;
        v25 -= 4;
        v16 -= 4;
      }
      while (v16 != v18);
      uint64_t v18 = *(double **)v4;
    }
    *(void *)uint64_t v4 = v25;
    *(void *)(v4 + 8) = v17;
    *(void *)(v4 + 16) = v26;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *uint64_t v16 = v11;
    v16[1] = v12;
    BOOL v17 = v16 + 4;
    v16[2] = v13;
    v16[3] = v14;
  }
  *(void *)(v4 + 8) = v17;
}

void sub_1DC3D55D4()
{
}

void sub_1DC3D55EC(void **a1)
{
  if (a1)
  {
    int v1 = *a1;
    if (v1) {
      free(v1);
    }
  }
}

void sub_1DC3D5600(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

uint64_t sub_1DC3D566C()
{
  uint64_t result = pthread_once(&stru_1EBFFB558, (void (*)(void))sub_1DC3D5BAC);
  if (result) {
    exit(1);
  }
  return result;
}

void sub_1DC3D56A8(int *a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 8);
  if (v4) {
    free(v4);
  }
  if (*((void *)a1 + 1))
  {
    CFNumberRef v5 = malloc_type_malloc(4 * *a1, 0x100004052888210uLL);
    *(void *)(a2 + 8) = v5;
    *(_DWORD *)a2 = *a1;
    double v6 = (const void *)*((void *)a1 + 1);
    size_t v7 = 4 * *a1;
    memcpy(v5, v6, v7);
  }
  else
  {
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)a2 = 0;
  }
}

void sub_1DC3D5738(uint64_t a1)
{
  if (a1)
  {
    unint64_t v2 = *(void **)(a1 + 64);
    if (v2) {
      free(v2);
    }
    *(void *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 56) = 0;
    uint64_t v3 = *(void **)(a1 + 80);
    if (v3) {
      free(v3);
    }
    *(void *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 72) = 0;
  }
}

void sub_1DC3D5788(int *a1, uint64_t a2)
{
  uint64_t v4 = a2 + 56;
  CFNumberRef v5 = *(void **)(a2 + 64);
  if (v5) {
    free(v5);
  }
  *(void *)(a2 + 64) = 0;
  *(_DWORD *)(a2 + 56) = 0;
  double v6 = *(void **)(a2 + 80);
  if (v6) {
    free(v6);
  }
  *(void *)(a2 + 80) = 0;
  *(_DWORD *)(a2 + 72) = 0;
  long long v7 = *((_OWORD *)a1 + 1);
  long long v8 = *((_OWORD *)a1 + 2);
  long long v9 = *((_OWORD *)a1 + 3);
  *(_OWORD *)(a2 + 64) = *((_OWORD *)a1 + 4);
  long long v10 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 32) = v8;
  *(_OWORD *)(a2 + 48) = v9;
  *(_OWORD *)a2 = v10;
  *(_OWORD *)(a2 + 16) = v7;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 80) = 0;
  sub_1DC3D56A8(a1 + 14, v4);
  sub_1DC3D56A8(a1 + 18, a2 + 72);
}

void sub_1DC3D5828(uint64_t a1)
{
  sub_1DC3D5738(*(void *)(a1 + 64));
  unint64_t v2 = *(void **)(a1 + 64);
  if (v2) {
    free(v2);
  }
  *(void *)(a1 + 64) = 0;
}

void sub_1DC3D5860(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2) {
    free(v2);
  }
  *(void *)(a1 + 16) = 0;
  sub_1DC3D5828(a1);
}

void sub_1DC3D58A4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = *(void *)a1;
  uint64_t v4 = *(void **)(a1 + 16);
  *(void *)(a2 + 8) = *(void *)(a1 + 8);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 80);
  *(void *)(a2 + 72) = *(void *)(a1 + 72);
  *(void *)(a2 + 80) = v5;
  *(unsigned char *)(a2 + 88) = *(unsigned char *)(a1 + 88);
  *(void *)(a2 + 96) = *(void *)(a1 + 96);
  double v6 = *(void **)(a2 + 16);
  if (v6 != v4)
  {
    if (v6) {
      free(v6);
    }
    long long v7 = malloc_type_malloc(*(void *)(a1 + 8) + 1, 0x100004077774924uLL);
    *(void *)(a2 + 16) = v7;
    unint64_t v8 = *(void *)(a1 + 8);
    if (v8)
    {
      for (unint64_t i = 0; i < v8; ++i)
      {
        *(unsigned char *)(*(void *)(a2 + 16) + i) = *(unsigned char *)(*(void *)(a1 + 16) + i);
        unint64_t v8 = *(void *)(a1 + 8);
      }
      long long v7 = *(unsigned char **)(a2 + 16);
    }
    v7[v8] = 0;
  }
  long long v10 = *(_OWORD *)(a1 + 28);
  *(_OWORD *)(a2 + 44) = *(_OWORD *)(a1 + 44);
  *(_OWORD *)(a2 + 28) = v10;
  double v11 = *(int **)(a1 + 64);
  uint64_t v12 = *(void *)(a2 + 64);
  sub_1DC3D5788(v11, v12);
}

void sub_1DC3D5988(uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  if (v2) {
    free(v2);
  }
  *(void *)a1 = 0;
  sub_1DC3D5738(*(void *)(a1 + 80));
  uint64_t v3 = *(void **)(a1 + 80);
  if (v3) {
    free(v3);
  }
  *(void *)(a1 + 80) = 0;
}

void sub_1DC3D59D0(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2) {
    free(*(void **)a2);
  }
  uint64_t v4 = malloc_type_malloc(4 * *(int *)(a1 + 8), 0x100004052888210uLL);
  *(void *)a2 = v4;
  int v5 = *(_DWORD *)(a1 + 8);
  if (v5 >= 1)
  {
    double v6 = *(int **)a1;
    uint64_t v7 = *(unsigned int *)(a1 + 8);
    do
    {
      int v8 = *v6++;
      *v4++ = v8;
      --v7;
    }
    while (v7);
  }
  *(_DWORD *)(a2 + 8) = v5;
  *(void *)(a2 + 12) = *(void *)(a1 + 12);
  *(void *)(a2 + 20) = *(void *)(a1 + 20);
  long long v9 = *(_OWORD *)(a1 + 28);
  long long v10 = *(_OWORD *)(a1 + 44);
  long long v11 = *(_OWORD *)(a1 + 60);
  *(_DWORD *)(a2 + 76) = *(_DWORD *)(a1 + 76);
  *(_OWORD *)(a2 + 60) = v11;
  *(_OWORD *)(a2 + 44) = v10;
  *(_OWORD *)(a2 + 28) = v9;
  uint64_t v12 = *(int **)(a1 + 80);
  uint64_t v13 = *(void *)(a2 + 80);
  sub_1DC3D5788(v12, v13);
}

uint64_t sub_1DC3D5A90(int a1, CFStringRef theString, int a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v16 = CFStringGetLength(theString) + 1;
  BOOL v17 = (char *)malloc_type_malloc(v16, 0x100004077774924uLL);
  uint64_t result = CFStringGetCString(theString, v17, v16, 0x600u);
  if (dword_1EBFFB550) {
    exit(1);
  }
  int v19 = dword_1EBFFC218;
  if (dword_1EBFFC218 <= 31)
  {
    if (dword_1EBFFC218 < 1)
    {
LABEL_7:
      unint64_t v23 = &dword_1EBFFBA10[16 * (uint64_t)dword_1EBFFC218];
      *unint64_t v23 = a1;
      v23[1] = 0;
      *((void *)v23 + 1) = v17;
      *((void *)v23 + 2) = theString;
      v23[6] = a3;
      *((unsigned char *)v23 + 28) = a4;
      *(_WORD *)((char *)v23 + 29) = 0;
      *((unsigned char *)v23 + 31) = 0;
      *((void *)v23 + 4) = a5;
      *((void *)v23 + 5) = a6;
      *((void *)v23 + 6) = a7;
      *((void *)v23 + 7) = a8;
      dword_1EBFFC218 = v19 + 1;
    }
    else
    {
      unint64_t v20 = dword_1EBFFBA10;
      uint64_t v21 = dword_1EBFFC218;
      while (1)
      {
        int v22 = *v20;
        v20 += 16;
        if (v22 == a1) {
          break;
        }
        if (!--v21) {
          goto LABEL_7;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1DC3D5BAC()
{
  if (dword_1EBFFB550 == -1)
  {
    dword_1EBFFB550 = 0;
    sub_1DC3D5A90(0, @"EAN13", 30, 1, (uint64_t)sub_1DC3DDBDC, (uint64_t)sub_1DC3DC058, (uint64_t)sub_1DC3DDCF0, 0);
    sub_1DC3D5A90(1, @"EAN8", 22, 1, (uint64_t)sub_1DC3DDC38, (uint64_t)sub_1DC3DD548, (uint64_t)sub_1DC3DDD0C, 0);
    sub_1DC3D5A90(2, @"UPCE", 17, 1, (uint64_t)sub_1DC3DDC94, (uint64_t)sub_1DC3DD71C, (uint64_t)sub_1DC3DDD18, 0);
    sub_1DC3D5A90(3, @"Code93", 16, 0, (uint64_t)sub_1DC3DFA20, (uint64_t)sub_1DC3DF3B0, (uint64_t)sub_1DC3DFA70, 0);
    sub_1DC3D5A90(4, @"Code93i", 16, 0, (uint64_t)sub_1DC3E18D0, (uint64_t)sub_1DC3E1214, (uint64_t)sub_1DC3E3294, 0);
    sub_1DC3D5A90(5, @"Code39", 15, 1, (uint64_t)sub_1DC3DF268, (uint64_t)sub_1DC3DF238, (uint64_t)sub_1DC3DF2B0, 0);
    sub_1DC3D5A90(6, @"Code39_fullAscii", 15, 1, (uint64_t)sub_1DC3DF268, (uint64_t)sub_1DC3DF244, (uint64_t)sub_1DC3DF2B0, 0);
    sub_1DC3D5A90(7, @"Code39_checksum", 20, 1, (uint64_t)sub_1DC3DF268, (uint64_t)sub_1DC3DF250, (uint64_t)sub_1DC3DF2D8, 0);
    sub_1DC3D5A90(8, @"Code39_fullAscii_checksum", 20, 1, (uint64_t)sub_1DC3DF268, (uint64_t)sub_1DC3DF25C, (uint64_t)sub_1DC3DF2D8, 0);
    sub_1DC3D5A90(9, @"Code128", 13, 1, (uint64_t)sub_1DC3DE448, (uint64_t)sub_1DC3DE03C, (uint64_t)sub_1DC3DEA44, 0);
    sub_1DC3D5A90(10, @"I2of5", 14, 0, (uint64_t)sub_1DC3ED454, (uint64_t)sub_1DC3ED3A4, (uint64_t)sub_1DC3ED498, 0);
    sub_1DC3D5A90(11, @"I2of5_checksum", 14, 0, (uint64_t)sub_1DC3ED454, (uint64_t)sub_1DC3ED3EC, (uint64_t)sub_1DC3ED498, 0);
    sub_1DC3D5A90(12, @"ITF14", 39, 0, (uint64_t)sub_1DC3ED454, (uint64_t)sub_1DC3ED434, (uint64_t)sub_1DC3ED4C8, 0);
    sub_1DC3D5A90(13, @"PDF417", 12, 1, (uint64_t)sub_1DC3E8054, (uint64_t)sub_1DC3E3BF8, (uint64_t)sub_1DC3E80E0, (uint64_t)sub_1DC3E5690);
    sub_1DC3D5A90(14, @"MicroPDF417", 11, 1, (uint64_t)sub_1DC3BE6E4, (uint64_t)sub_1DC3BB654, (uint64_t)sub_1DC3BE9B8, (uint64_t)sub_1DC3BC1E8);
    sub_1DC3D5A90(15, @"MSIPlessey", 15, 0, (uint64_t)sub_1DC354D6C, (uint64_t)sub_1DC3549C4, (uint64_t)sub_1DC354DA8, 0);
    uint64_t result = sub_1DC3D5A90(16, @"GS1DataBarExpanded", 12, 1, (uint64_t)sub_1DC381ED0, (uint64_t)sub_1DC37FD08, (uint64_t)sub_1DC381F0C, 0);
    dword_1EBFFB550 = 1;
  }
  return result;
}

BOOL sub_1DC3D60C4(const __CFString *a1, _DWORD *a2)
{
  CFIndex v4 = CFStringGetLength(a1) + 1;
  int v5 = (char *)malloc_type_malloc(v4, 0x100004077774924uLL);
  if (CFStringGetCString(a1, v5, v4, 0x600u) && (unint64_t v6 = dword_1EBFFC218, dword_1EBFFC218 >= 1))
  {
    uint64_t v7 = 0;
    BOOL v8 = 1;
    long long v9 = (const char **)&qword_1EBFFBA18;
    while (strcmp(v5, *v9))
    {
      BOOL v8 = ++v7 < v6;
      v9 += 8;
      if (v6 == v7) {
        goto LABEL_8;
      }
    }
    if (a2) {
      *a2 = v7;
    }
  }
  else
  {
    BOOL v8 = 0;
  }
LABEL_8:
  free(v5);
  return v8;
}

uint64_t sub_1DC3D619C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int a8)
{
  *(_OWORD *)unint64_t v26 = 0u;
  long long v27 = 0u;
  memset(v25, 0, sizeof(v25));
  uint64_t v13 = malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
  v26[0] = v13;
  *((void *)v13 + 8) = 0;
  *((_DWORD *)v13 + 18) = 0;
  *((void *)v13 + 10) = 0;
  *uint64_t v13 = 0u;
  v13[1] = 0u;
  float v13[2] = 0u;
  *(_OWORD *)((char *)v13 + 44) = 0u;
  sub_1DC3D5788(*(int **)(a5 + 64), (uint64_t)v13);
  uint64_t v28 = *(void *)(a5 + 96);
  if (dword_1EBFFC218 < 1)
  {
    uint64_t v15 = 14;
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v15 = 14;
    CFIndex v16 = &qword_1EBFFBA38;
    do
    {
      LODWORD(v25[0]) = v14;
      int v17 = *(_DWORD *)v26[0] & (1 << v14);
      if (v17) {
        BOOL v18 = a8 == 0;
      }
      else {
        BOOL v18 = 1;
      }
      if (!v18) {
        int v17 = *((unsigned __int8 *)v16 - 12);
      }
      if (v17)
      {
        BYTE8(v27) = a8;
        uint64_t v19 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t, void))*v16)(a1, a2, a3, a4, v25, a6, a7);
        uint64_t v15 = v15 == 14 ? v19 : v15;
        if (v19 <= 1)
        {
          uint64_t v20 = v19;
          sub_1DC3D58A4((uint64_t)v25, a5);
          uint64_t v15 = v20;
          if (*((float *)&v25[1] + 2) > 0.8) {
            break;
          }
        }
      }
      ++v14;
      v16 += 8;
    }
    while (v14 < dword_1EBFFC218);
    uint64_t v13 = v26[0];
  }
  sub_1DC3D5738((uint64_t)v13);
  if (v26[0]) {
    free(v26[0]);
  }
  v26[0] = 0;
  if (*(void *)&v25[1] != *(void *)(a5 + 16) && *(void *)&v25[1]) {
    free(*(void **)&v25[1]);
  }
  return v15;
}

uint64_t sub_1DC3D6370(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, int a6)
{
  int v6 = dword_1EBFFC218;
  if (dword_1EBFFC218 < 1)
  {
    int v13 = 0;
  }
  else
  {
    uint64_t v11 = result;
    uint64_t v12 = 0;
    int v13 = 0;
    uint64_t v14 = &qword_1EBFFBA40;
    do
    {
      if (((1 << v12) & a6) != 0)
      {
        uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))*v14)(v11, a2, a3, a4);
        if (result) {
          int v15 = 1 << v12;
        }
        else {
          int v15 = 0;
        }
        v13 |= v15;
        int v6 = dword_1EBFFC218;
      }
      ++v12;
      v14 += 8;
    }
    while (v12 < v6);
  }
  *a5 = v13;
  return result;
}

void sub_1DC3D6448(int a1@<W1>, uint64_t *a2@<X2>, uint64_t a3@<X3>, uint64_t *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v9 = *a4;
  if (!*a4) {
    operator new();
  }
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  unsigned int v32 = 0;
  sub_1DC352C78(&v32, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  sub_1DC3D6718(&v19, a1, a2, (uint64_t)&v32, 0, (uint64_t *)(v9 + 8));
  sub_1DC3D75B4(a5, &v19);
  sub_1DC353B08(&v19);
  if (v32)
  {
    uint64_t v33 = v32;
    operator delete(v32);
  }
  if (*(_DWORD *)a5)
  {
    memset(v17, 0, sizeof(v17));
    sub_1DC352C78(v17, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    sub_1DC3D6718(v18, a1, a2, (uint64_t)v17, 1, (uint64_t *)(v9 + 8));
    sub_1DC3D75B4((uint64_t)&v19, v18);
    *(void *)a5 = v19;
    long long v10 = (void **)(a5 + 8);
    if (*(char *)(a5 + 31) < 0) {
      operator delete(*v10);
    }
    *(_OWORD *)long long v10 = *(_OWORD *)v20;
    *(void *)(a5 + 24) = v21;
    HIBYTE(v21) = 0;
    LODWORD(v20[0]) = 0;
    uint64_t v11 = *(void **)(a5 + 64);
    long long v12 = v23;
    *(_OWORD *)(a5 + 32) = v22;
    *(_OWORD *)(a5 + 48) = v12;
    if (v11)
    {
      *(void *)(a5 + 72) = v11;
      operator delete(v11);
      *(void *)(a5 + 64) = 0;
      *(void *)(a5 + 72) = 0;
      *(void *)(a5 + 80) = 0;
    }
    uint64_t v14 = a5 + 104;
    int v13 = *(void **)(a5 + 104);
    *(_OWORD *)(a5 + 64) = *(_OWORD *)__p;
    *(void *)(a5 + 80) = v25;
    __p[1] = 0;
    uint64_t v25 = 0;
    __p[0] = 0;
    *(_DWORD *)(a5 + 88) = v26;
    sub_1DC3A89D4(v13);
    int v15 = v28;
    *(void *)(a5 + 96) = v27;
    *(void *)(a5 + 104) = v15;
    uint64_t v16 = v29;
    *(void *)(a5 + 112) = v29;
    if (v16)
    {
      float v15[2] = v14;
      long long v27 = &v28;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      int v15 = 0;
    }
    else
    {
      *(void *)(a5 + 96) = v14;
    }
    *(unsigned char *)(a5 + 120) = v30;
    *(void *)(a5 + 124) = v31;
    sub_1DC3A89D4(v15);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(v20[0]);
    }
    sub_1DC353B08(v18);
    if (v17[0]) {
      operator delete(v17[0]);
    }
  }
}

void sub_1DC3D66BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  sub_1DC353B08(&a12);
  if (__p) {
    operator delete(__p);
  }
  sub_1DC3CA03C(v15);
  _Unwind_Resume(a1);
}

void *sub_1DC3D6718(uint64_t *a1, int a2, uint64_t *a3, uint64_t a4, int a5, uint64_t *a6)
{
  unint64_t v8 = 0;
  uint64_t v198 = *MEMORY[0x1E4F143B8];
  int v183 = (char *)&v183;
  uint64_t v184 = &v183;
  unint64_t v185 = 0;
  long long v9 = 0uLL;
  *(_OWORD *)((char *)v193 + 4) = 0u;
  *(_OWORD *)((char *)&v193[1] + 4) = 0u;
  long long v10 = &v189[8];
  uint64_t v11 = (int *)&v187 + 1;
  long long v12 = (int *)&v187;
  double v13 = (double)a2;
  int v14 = -1105618534;
  *(double *)&uint64_t v15 = 0.3;
  while (2)
  {
    unint64_t v188 = -1;
    *(_DWORD *)uint64_t v189 = -1;
    int v16 = ((v8 & 1) == 0) ^ a5;
    *long long v10 = v9;
    v10[1] = v9;
    uint64_t v186 = 0;
    uint64_t v187 = 0;
    while (2)
    {
      uint64_t v17 = *a3;
      BOOL v18 = (unsigned char *)a3[1];
      if (v8)
      {
        int v40 = *((_DWORD *)v183 + 10);
        unint64_t v41 = 715827883 * (v40 - *((_DWORD *)v183 + 9));
        int v42 = HIDWORD(v41) + (v41 >> 63) + v40;
        unint64_t v19 = v8;
        BOOL v20 = v8;
        unint64_t i = (unsigned char *)*a3;
        long long v23 = (unsigned char *)a3[1];
        if (v42 >= (int)v18 - (int)v17) {
          goto LABEL_73;
        }
      }
      else
      {
        unint64_t v19 = 0;
        BOOL v20 = 0;
        int v42 = 0;
      }
LABEL_4:
      if (a5) {
        BOOL v20 = !v20;
      }
      uint64_t v21 = (unsigned char *)(v17 + v42);
      if (v18 == v21) {
        goto LABEL_152;
      }
      while (*v21 != 1)
      {
        if (++v21 == v18)
        {
          uint64_t v21 = v18;
          break;
        }
      }
      if (v21 == v18)
      {
LABEL_152:
        unint64_t v8 = v19;
        goto LABEL_153;
      }
      uint64_t v22 = 0;
      long long v23 = v21;
      for (unint64_t i = v21; ; v21 = i)
      {
        do
        {
          if (*i == (*v21 == 0)) {
            goto LABEL_15;
          }
          ++i;
        }
        while (i != v18);
        unint64_t i = v18;
LABEL_15:
        *((_DWORD *)&v186 + v22) = i - v21;
        if (i == v18) {
          goto LABEL_152;
        }
        if (++v22 == 4) {
          break;
        }
LABEL_66:
        ;
      }
      int v25 = HIDWORD(v186);
      int v26 = HIDWORD(v186) + v186;
      if (v20) {
        int v27 = HIDWORD(v187) + v187;
      }
      else {
        int v27 = HIDWORD(v186) + v186;
      }
      float v28 = (float)v27 / (float)(HIDWORD(v187) + v187 + HIDWORD(v186) + v186);
      if (v28 < 0.79167 || v28 > 0.89286) {
        goto LABEL_65;
      }
      if ((int)v186 <= SHIDWORD(v186)) {
        uint64_t v29 = (int *)&v186;
      }
      else {
        uint64_t v29 = (int *)&v186 + 1;
      }
      if ((int)v186 <= SHIDWORD(v186)) {
        char v30 = (int *)&v186 + 1;
      }
      else {
        char v30 = (int *)&v186;
      }
      if ((int)v187 <= SHIDWORD(v187))
      {
        if (SHIDWORD(v186) >= (int)v186) {
          int v33 = v186;
        }
        else {
          int v33 = HIDWORD(v186);
        }
        if (SHIDWORD(v186) <= (int)v186) {
          int v25 = v186;
        }
        if ((int)v187 >= v33) {
          uint64_t v31 = v29;
        }
        else {
          uint64_t v31 = v12;
        }
        if (SHIDWORD(v187) >= v25) {
          unsigned int v32 = v11;
        }
        else {
          unsigned int v32 = v30;
        }
      }
      else
      {
        if (SHIDWORD(v187) >= *v29) {
          uint64_t v31 = v29;
        }
        else {
          uint64_t v31 = v11;
        }
        if ((int)v187 >= *v30) {
          unsigned int v32 = v12;
        }
        else {
          unsigned int v32 = v30;
        }
      }
      int v34 = *v32;
      if (!v20)
      {
        if ((int)v187 - HIDWORD(v187) >= 0) {
          unsigned int v38 = v187 - HIDWORD(v187);
        }
        else {
          unsigned int v38 = HIDWORD(v187) - v187;
        }
        if (v38 >= 3) {
          int v39 = 3 * *v31;
        }
        else {
          int v39 = ((HIDWORD(v187) + v187 + (HIDWORD(v187) + (int)v187 < 0)) & 0xFFFFFFFE)
        }
              + (HIDWORD(v187) + (int)v187) / 2;
        if (v34 < 4 * v39) {
          goto LABEL_73;
        }
        goto LABEL_65;
      }
      unsigned int v35 = (int)v186 - HIDWORD(v186) >= 0 ? v186 - HIDWORD(v186) : HIDWORD(v186) - (int)v186;
      if (v35 >= 3)
      {
        unsigned int v37 = 3 * *v31;
      }
      else
      {
        int v36 = v26 >= 0 ? HIDWORD(v186) + v186 : v26 + 1;
        unsigned int v37 = (v36 & 0xFFFFFFFE) + (v36 >> 1);
      }
      if (v34 >= (int)(4 * v37))
      {
LABEL_65:
        v23 += v26;
        uint64_t v186 = v187;
        uint64_t v22 = 2;
        goto LABEL_66;
      }
      int64x2_t v43 = (char *)&v186 + 4;
      float64x2_t v44 = (char *)v11;
      do
      {
        int v45 = *((_DWORD *)v43 - 1);
        *((_DWORD *)v43 - 1) = *(_DWORD *)v44;
        *(_DWORD *)float64x2_t v44 = v45;
        v44 -= 4;
        BOOL v46 = v43 >= v44;
        v43 += 4;
      }
      while (!v46);
LABEL_73:
      if (v23 >= i) {
        goto LABEL_152;
      }
      int32x2_t v177 = a1;
      if (v16)
      {
        uint64_t v47 = v23;
        while (v47 != (unsigned char *)v17)
        {
          int v48 = *--v47;
          if (v48 == *v23)
          {
            int v49 = v47 + 1;
            goto LABEL_85;
          }
        }
        int v49 = v17;
      }
      else if (v18 == ++i)
      {
LABEL_82:
        int v49 = (int)v23;
        LODWORD(i) = v18;
      }
      else
      {
        while (*i)
        {
          if (++i == v18) {
            goto LABEL_82;
          }
        }
        int v49 = (int)v23;
      }
LABEL_85:
      float32x2_t v172 = (char *)v11;
      unsigned int v173 = v10;
      int v50 = i - v17;
      int v51 = i - v49;
      double v52 = 0.0;
      int v174 = a5;
      if ((int)i - v49 >= 23)
      {
        int v170 = v49 - v17;
        double v168 = *(double *)&v15;
        float v166 = a3;
        unsigned int __p = 0;
        uint64_t v191 = 0;
        uint64_t v192 = 0;
        uint64_t v58 = a4;
        sub_1DC352C78(&__p, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
        float v59 = 0.0;
        double v60 = __p;
        int v57 = v50;
        double v165 = v13;
        float v164 = *(float *)&v14;
        if (v50 <= v170)
        {
          float v61 = 0.0;
          float v62 = 0.0;
          a5 = v174;
          a4 = v58;
        }
        else
        {
          a5 = v174;
          a4 = v58;
          if (v170 < 0)
          {
            float v61 = 0.0;
            float v62 = 0.0;
          }
          else
          {
            float v61 = 0.0;
            float v62 = 0.0;
            if (v191 - (uint64_t)__p >= (unint64_t)v50)
            {
              int v162 = (char *)__p;
              bzero(&v194, 0x400uLL);
              double v60 = v162;
              int v57 = v50;
              int v63 = v170;
              float v64 = &v162[v170];
              double v65 = 0.0;
              float v66 = 0.0;
              do
              {
                unsigned int v67 = *v64++;
                float v66 = v66 + (float)v67;
                double v65 = v65 + (double)(int)(v67 * v67);
                ++*((_DWORD *)&v194 + v67);
                ++v63;
              }
              while (v63 < v50);
              uint64_t v68 = 0;
              int v69 = 0;
              int v70 = 0;
              float v62 = v65 / (double)(v51 + 1) - (float)((float)(v66 / (float)(v51 + 1)) * (float)(v66 / (float)(v51 + 1)));
              int v71 = (int)((double)v51 * v168);
              a5 = v174;
              a4 = v58;
              while (1)
              {
                int v72 = *((_DWORD *)&v194 + v68);
                if (v72 + v69 >= v71) {
                  break;
                }
                v70 += v72 * v68++;
                v69 += v72;
                if (v68 == 256) {
                  goto LABEL_99;
                }
              }
              v70 += (v71 - v69) * v68;
LABEL_99:
              int v73 = 0;
              int v74 = 0;
              float v61 = (float)(v70 / v71);
              unsigned int v75 = 255;
              while (1)
              {
                int v76 = *((_DWORD *)&v194 + v75);
                if (v76 + v73 >= v71) {
                  break;
                }
                v74 += v76 * v75--;
                v73 += v76;
                if (v75 == -1) {
                  goto LABEL_104;
                }
              }
              v74 += (v71 - v73) * v75;
LABEL_104:
              float v59 = (float)(v74 / v71);
            }
          }
        }
        if (v60)
        {
          operator delete(v60);
          int v57 = v50;
          a4 = v58;
          a5 = v174;
        }
        uint64_t v77 = 0;
        float v78 = (float)v51;
        float v79 = (float)v51 / 15.0;
        float v80 = 1.0 / (float)(v62 + v62);
        int v54 = v170;
        uint64_t v81 = *(void *)a4 + v170;
        int v53 = -1;
        char v82 = (char *)&unk_1DC416448;
        int v14 = LODWORD(v164);
        float v83 = v164;
        a3 = v166;
        do
        {
          if (v16)
          {
            uint64_t v84 = 0;
            int v85 = 0;
            do
            {
              v85 += *(_DWORD *)&v82[v84];
              *(_DWORD *)((char *)&v194 + v84) = (int)(float)((float)((float)v85 * v79) + 0.5);
              v84 += 4;
            }
            while (v84 != 16);
            LODWORD(v195) = (int)(float)((float)((float)(v85 + 1) * v79) + 0.5);
          }
          else
          {
            LODWORD(v194) = (int)(float)(v79 + 0.5);
            int v86 = 1;
            uint64_t v87 = (_DWORD *)&v194 + 1;
            for (uint64_t j = 12; j != -4; j -= 4)
            {
              v86 += *(_DWORD *)&v82[j];
              *v87++ = (int)(float)((float)((float)v86 * v79) + 0.5);
            }
          }
          uint64_t v89 = 0;
          float v90 = 0.0;
          do
          {
            if (v89) {
              int v91 = *((_DWORD *)&v194 + (v89 - 1));
            }
            else {
              int v91 = 0;
            }
            uint64_t v92 = *((int *)&v194 + v89);
            if (v91 < (int)v92)
            {
              uint64_t v93 = v92 - v91;
              double v94 = (unsigned __int8 *)(v81 + v91);
              do
              {
                unsigned int v95 = *v94++;
                float v96 = (float)v95;
                if ((v16 ^ v89)) {
                  double v97 = fmin((float)(v96 - v59), 0.0);
                }
                else {
                  double v97 = fmax((float)(v96 - v61), 0.0);
                }
                float v98 = v97;
                float v90 = v90 + (float)(v80 * (float)(v98 * v98));
                --v93;
              }
              while (v93);
            }
            ++v89;
          }
          while (v89 != 5);
          float v99 = (float)-v90 / v78;
          if (v99 > v83)
          {
            int v53 = v77;
            float v83 = v99;
          }
          ++v77;
          v82 += 16;
        }
        while (v77 != 6);
        if (v53 < 0)
        {
          int v57 = -1;
          int v53 = -1;
          int v54 = -1;
          double v55 = 0.0;
          double v56 = 0.0;
          double v13 = v165;
        }
        else
        {
          double v56 = (double)v170;
          double v55 = (double)v57;
          double v13 = v165;
          double v52 = v165;
        }
        *(double *)&uint64_t v15 = v168;
      }
      else
      {
        int v53 = -1;
        int v54 = -1;
        double v55 = 0.0;
        double v56 = 0.0;
        int v57 = -1;
      }
      unint64_t v188 = __PAIR64__(v54, v53);
      *(void *)uint64_t v189 = v57;
      *(double *)&v189[8] = v56;
      *(double *)&v189[16] = v52;
      *(double *)&v189[24] = v55;
      *(double *)&v189[32] = v52;
      uint64_t v100 = (unsigned char *)a3[1];
      if (v53 < 0)
      {
LABEL_135:
        a1 = v177;
        uint64_t v11 = (int *)v172;
        long long v10 = v173;
        if (v100 != v23)
        {
          int v105 = *v23 == 0;
          while (*v23 != v105)
          {
            if (++v23 == v100)
            {
              long long v23 = v100;
              break;
            }
          }
          if (v100 == v23)
          {
LABEL_144:
            LODWORD(v23) = v100;
          }
          else
          {
            int v106 = *v23 == 0;
            while (*v23 != v106)
            {
              if (++v23 == v100) {
                goto LABEL_144;
              }
            }
          }
        }
        int v42 = v23 - *(_DWORD *)a3;
        unint64_t v8 = v185;
        if (v42 < 0) {
          continue;
        }
        uint64_t v17 = *a3;
        BOOL v18 = (unsigned char *)a3[1];
        unint64_t v19 = v185;
        BOOL v20 = v185;
        goto LABEL_4;
      }
      break;
    }
    float v101 = v12;
    int v102 = v54;
    int v169 = v57;
    uint64_t v171 = a4;
    LODWORD(v194) = 0;
    LODWORD(__p) = 0;
    float v103 = a3;
    unint64_t v104 = sub_1DC3D7924(*a3, v100, (int *)&v188, v16, 1, (int *)&v194);
    if (v104 == 0x7FFFFFFF)
    {
      uint64_t v100 = (unsigned char *)v103[1];
      a5 = v174;
      a4 = v171;
      a3 = v103;
      long long v12 = v101;
      goto LABEL_135;
    }
    float v167 = v103;
    unint64_t v107 = sub_1DC3D7924(*v103, (unsigned char *)v103[1], (int *)&v188, v16, 0, (int *)&__p);
    int v108 = v102 - v194;
    HIDWORD(v188) = v102 - v194;
    float v109 = v52;
    *(double *)&v189[8] = (float)(v102 - v194);
    *(double *)&v189[16] = v109;
    unint64_t v163 = v107;
    uint64_t v110 = v107;
    if (v107 != 0x7FFFFFFFLL)
    {
      *(_DWORD *)uint64_t v189 = __p + v169;
      v169 += (int)__p;
      *(double *)&v189[24] = (float)v169;
      *(double *)&v189[32] = v109;
    }
    long long v12 = v101;
    v193[0] = *(_OWORD *)&v189[4];
    v193[1] = *(_OWORD *)&v189[20];
    LODWORD(v193[2]) = *(_DWORD *)&v189[36];
    float v111 = (char *)operator new(0x58uLL);
    uint64_t v11 = (int *)v172;
    *((void *)v111 + 2) = v104;
    *((void *)v111 + 3) = v163;
    *((_DWORD *)v111 + 8) = v53;
    *((_DWORD *)v111 + 9) = v108;
    *((_DWORD *)v111 + 10) = v169;
    *((_DWORD *)v111 + 19) = v193[2];
    *(_OWORD *)(v111 + 60) = v193[1];
    *(_OWORD *)(v111 + 44) = v193[0];
    *((_WORD *)v111 + 40) = 1;
    *(_DWORD *)(v111 + 82) = v181;
    *((_WORD *)v111 + 43) = v182;
    float v112 = v183;
    *(void *)float v111 = v183;
    *((void *)v111 + 1) = &v183;
    *((void *)v112 + 1) = v111;
    unint64_t v8 = v185 + 1;
    int v183 = v111;
    ++v185;
    BOOL v113 = v110 == 0x7FFFFFFF;
    a1 = v177;
    a5 = v174;
    a4 = v171;
    a3 = v167;
    long long v9 = 0uLL;
    long long v10 = v173;
    if (!v113) {
      continue;
    }
    break;
  }
LABEL_153:
  if (!v8)
  {
LABEL_225:
    *a1 = (uint64_t)a1;
    a1[1] = (uint64_t)a1;
    int v118 = (unint64_t *)(a1 + 2);
    goto LABEL_226;
  }
  if (!sub_1DC3D7E24((uint64_t)&v183))
  {
    float v119 = a6;
    unint64_t v175 = v8;
    uint64_t v176 = a6[2];
    uint64_t v120 = a6[1];
    uint64_t v121 = a6;
    int v122 = a2;
    int v178 = a1;
    if ((uint64_t *)v120 != a6)
    {
      BOOL v123 = v184;
      float v124 = (uint64_t *)a6[1];
      do
      {
        if (v123 != &v183)
        {
          uint64_t v125 = v124[2];
          uint64_t v126 = v124[3];
          uint64_t v127 = v123;
          do
          {
            if (v125 != v126)
            {
              uint64_t v128 = v125;
              do
              {
                if (sub_1DC3D7EC8((_DWORD *)v127 + 4, (_DWORD *)v128))
                {
                  *((unsigned char *)v127 + 81) = 1;
                  *(unsigned char *)(v128 + 65) = 1;
                }
                v128 += 72;
              }
              while (v128 != v126);
            }
            uint64_t v127 = (char **)v127[1];
          }
          while (v127 != &v183);
        }
        float v124 = (uint64_t *)v124[1];
      }
      while (v124 != a6);
      int v129 = (void *)(v120 + 16);
      if (*(_DWORD *)(v120 + 40) <= a2)
      {
        uint64_t v121 = (uint64_t *)v120;
        float v119 = a6;
        while (1)
        {
          BOOL v131 = sub_1DC3D7F24((char *)v121[2], (char *)v129[1], (uint64_t)&v183);
          BOOL v130 = v131;
          uint64_t v121 = (uint64_t *)v121[1];
          if (v121 == a6) {
            break;
          }
          int v129 = v121 + 2;
          if (*((_DWORD *)v121 + 10) > a2) {
            goto LABEL_172;
          }
        }
        uint64_t v121 = a6;
        if (v131) {
          goto LABEL_213;
        }
      }
      else
      {
        BOOL v130 = 0;
        uint64_t v121 = (uint64_t *)v120;
        float v119 = a6;
LABEL_172:
        if (sub_1DC3D7F24((char *)v121[2], (char *)v129[1], (uint64_t)&v183) || v130) {
          goto LABEL_213;
        }
      }
      if ((uint64_t *)v120 != v119)
      {
        float v132 = v184;
        while (v132 != &v183)
        {
          int v133 = *(_DWORD **)(v120 + 16);
          float v134 = *(_DWORD **)(v120 + 24);
          float32x4_t v135 = v132;
          while (v133 != v134)
          {
            float v136 = v133;
            while (!sub_1DC3D7EC8((_DWORD *)v135 + 4, v136))
            {
              v136 += 18;
              if (v136 == v134) {
                goto LABEL_187;
              }
            }
            float32x4_t v135 = (char **)v135[1];
            if (v135 == &v183) {
              goto LABEL_213;
            }
          }
LABEL_187:
          uint64_t v120 = *(void *)(v120 + 8);
          if ((uint64_t *)v120 == v119) {
            goto LABEL_188;
          }
        }
        goto LABEL_213;
      }
LABEL_188:
      int v122 = a2;
    }
    long long v194 = 0uLL;
    CGFloat v195 = 0;
    int v196 = v122;
    char v197 = 0;
    if (v175 <= 0x38E38E38E38E38ELL)
    {
      atomic_ullong v137 = (char *)operator new(72 * v175);
      *(void *)&long long v194 = v137;
      *((void *)&v194 + 1) = v137;
      CGFloat v195 = &v137[72 * v175];
      float v138 = v184;
      if (v184 == &v183)
      {
        uint64_t v146 = 0;
        goto LABEL_202;
      }
      unint64_t v139 = -1;
      float v140 = v184;
      do
      {
        unint64_t v141 = v139;
        float v140 = (char **)v140[1];
        ++v139;
      }
      while (v140 != &v183);
      if (v175 > v139)
      {
        float v142 = v137;
        do
        {
          *(_OWORD *)float v142 = *((_OWORD *)v138 + 1);
          long long v143 = *((_OWORD *)v138 + 2);
          long long v144 = *((_OWORD *)v138 + 3);
          long long v145 = *((_OWORD *)v138 + 4);
          *((void *)v142 + 8) = v138[10];
          *((_OWORD *)v142 + 2) = v144;
          *((_OWORD *)v142 + 3) = v145;
          *((_OWORD *)v142 + 1) = v143;
          float v138 = (char **)v138[1];
          v142 += 72;
        }
        while (v138 != &v183);
LABEL_201:
        uint64_t v146 = v142 - v137;
LABEL_202:
        *((void *)&v194 + 1) = &v137[v146];
        uint64_t v150 = operator new(0x30uLL);
        v150[1] = v194;
        *((void *)v150 + 4) = v195;
        CGFloat v195 = 0;
        long long v194 = 0uLL;
        *((_DWORD *)v150 + 10) = v196;
        *((unsigned char *)v150 + 44) = v197;
        uint64_t v151 = *v121;
        *(void *)(v151 + 8) = v150;
        *(void *)uint64_t v150 = v151;
        *uint64_t v121 = (uint64_t)v150;
        *((void *)v150 + 1) = v121;
        uint64_t v152 = (uint64_t *)v119[1];
        ++v119[2];
        if (v152 == v119)
        {
LABEL_213:
          a1 = v178;
          if (v176)
          {
            sub_1DC3D7FF8(v178, v119, 0);
            if (v178[2])
            {
              float v159 = v178;
              while (1)
              {
                float v159 = (uint64_t *)v159[1];
                if (v159 == v178) {
                  break;
                }
                if (*((unsigned char *)v159 + 81)) {
                  return sub_1DC353B08(&v183);
                }
              }
            }
            sub_1DC3D7FF8((uint64_t *)&v194, v119, 1);
            sub_1DC3D80B4(v178, &v194);
            sub_1DC353B08(&v194);
            if (v178[2])
            {
              uint64_t v160 = v178;
              while (1)
              {
                uint64_t v160 = (uint64_t *)v160[1];
                if (v160 == v178) {
                  break;
                }
                if (*((unsigned char *)v160 + 81)) {
                  return sub_1DC353B08(&v183);
                }
              }
            }
            sub_1DC353B08(v178);
          }
          goto LABEL_225;
        }
        while (1)
        {
          uint64_t v153 = (char *)v152[2];
          uint64_t v154 = (char *)v152[3];
          if (0x8E38E38E38E38E39 * ((v154 - v153) >> 3) != v185)
          {
LABEL_207:
            if (v153 == v154)
            {
              uint64_t v157 = *v152;
              int v158 = (uint64_t *)v152[1];
              *(void *)(v157 + 8) = v158;
              *(void *)v152[1] = v157;
              --v119[2];
              sub_1DC3D7FB4(v152);
              uint64_t v152 = v158;
              goto LABEL_205;
            }
            uint64_t v155 = &v184;
            while (1)
            {
              unint64_t v156 = *v155;
              if (*v155 == &v183) {
                break;
              }
              uint64_t v155 = (char ***)(v156 + 1);
              if (sub_1DC3D7EC8(v153, (_DWORD *)v156 + 4))
              {
                v153 += 72;
                goto LABEL_207;
              }
            }
          }
          uint64_t v152 = (uint64_t *)v152[1];
LABEL_205:
          if (v152 == v119) {
            goto LABEL_213;
          }
        }
      }
      operator delete(v137);
      long long v194 = 0uLL;
      CGFloat v195 = 0;
      if (v139 <= 0x38E38E38E38E38DLL)
      {
        sub_1DC3D8858(&v194, v141 + 2);
        atomic_ullong v137 = (char *)*((void *)&v194 + 1);
        float v142 = (char *)*((void *)&v194 + 1);
        do
        {
          *(_OWORD *)float v142 = *((_OWORD *)v138 + 1);
          long long v147 = *((_OWORD *)v138 + 2);
          long long v148 = *((_OWORD *)v138 + 3);
          long long v149 = *((_OWORD *)v138 + 4);
          *((void *)v142 + 8) = v138[10];
          *((_OWORD *)v142 + 2) = v148;
          *((_OWORD *)v142 + 3) = v149;
          *((_OWORD *)v142 + 1) = v147;
          float v138 = (char **)v138[1];
          v142 += 72;
        }
        while (v138 != &v183);
        goto LABEL_201;
      }
    }
    sub_1DC2FF97C();
  }
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  float v115 = v183;
  uint64_t v114 = (uint64_t *)v184;
  uint64_t v116 = *v184;
  *((void *)v116 + 1) = *((void *)v183 + 1);
  **((void **)v115 + 1) = v116;
  uint64_t v117 = *a1;
  *(void *)(v117 + 8) = v114;
  *uint64_t v114 = v117;
  *a1 = (uint64_t)v115;
  *((void *)v115 + 1) = a1;
  a1[2] = v8;
  int v118 = &v185;
LABEL_226:
  *int v118 = 0;
  return sub_1DC353B08(&v183);
}

void sub_1DC3D7570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

double sub_1DC3D75B4(uint64_t a1, void *a2)
{
  uint64_t v3 = a2[2];
  if (!v3)
  {
    *(_DWORD *)a1 = 1;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    double result = 0.0;
    *(_OWORD *)(a1 + 4) = 0u;
    *(_OWORD *)(a1 + 20) = 0u;
    *(_OWORD *)(a1 + 36) = 0u;
    *(_OWORD *)(a1 + 52) = 0u;
    *(_OWORD *)(a1 + 68) = 0u;
    *(void *)(a1 + 84) = 0;
    *(void *)(a1 + 96) = a1 + 104;
    *(unsigned char *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 124) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    return result;
  }
  if (*(_DWORD *)(*a2 + 24) == 0x7FFFFFFF) {
    int v5 = -2;
  }
  else {
    int v5 = -1;
  }
  __p.__r_.__value_.__s.__data_[0] = 0;
  sub_1DC314894(&v36, 12 * (v5 + 2 * (int)v3), &__p);
  unint64_t v6 = 0;
  uint64_t v7 = a2[1];
  unsigned int v8 = *(_DWORD *)(v7 + 24);
  char v9 = 11;
  do
  {
    if ((v8 >> v9))
    {
      if (v37 - (unsigned char *)v36 <= v6) {
        sub_1DC351420();
      }
      *((unsigned char *)v36 + v6) = 1;
    }
    ++v6;
    --v9;
  }
  while (v6 != 12);
  uint64_t v10 = *(void *)(v7 + 8);
  if ((void *)v10 != a2)
  {
    LODWORD(v11) = 12;
    do
    {
      unsigned int v12 = *(_DWORD *)(v10 + 16);
      int v13 = v11 + 12;
      unint64_t v11 = (int)v11;
      for (int i = 11; i != -1; --i)
      {
        if ((v12 >> i))
        {
          if (v37 - (unsigned char *)v36 <= v11) {
            sub_1DC351420();
          }
          *((unsigned char *)v36 + v11) = 1;
        }
        ++v11;
      }
      unsigned int v15 = *(_DWORD *)(v10 + 24);
      if (v15 != 0x7FFFFFFF)
      {
        unint64_t v11 = v13;
        for (int j = 11; j != -1; --j)
        {
          if ((v15 >> j))
          {
            if (v37 - (unsigned char *)v36 <= v11) {
              sub_1DC351420();
            }
            *((unsigned char *)v36 + v11) = 1;
          }
          ++v11;
        }
      }
      uint64_t v10 = *(void *)(v10 + 8);
    }
    while ((void *)v10 != a2);
  }
  sub_1DC350DD0(&__p, (uint64_t *)&v36);
  char v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    uint64_t v21 = a2;
    uint64_t v19 = *a2;
    uint64_t v20 = v21[1];
    int v23 = *(_DWORD *)(v20 + 36);
    int v22 = *(_DWORD *)(v20 + 40);
    int v25 = *(_DWORD *)(v19 + 36);
    int v24 = *(_DWORD *)(v19 + 40);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1DC3CA1A4(&v33, (unsigned __int8 *)p_p, (unsigned __int8 *)p_p + size, size);
    *(float *)&double result = (float)(v24 - v25) / 49.0;
    unint64_t v28 = (int)*(double *)(v20 + 48) | ((unint64_t)(int)*(double *)(v20 + 56) << 32);
    unint64_t v29 = (int)*(double *)(v19 + 64) | ((unint64_t)(int)*(double *)(v19 + 72) << 32);
    *(void *)a1 = 0x200000000000;
    *(_OWORD *)(a1 + 8) = v33;
    uint64_t v30 = v34;
    long long v33 = 0uLL;
    uint64_t v34 = 0;
    *(void *)(a1 + 24) = v30;
    *(void *)(a1 + 32) = v28;
    *(void *)(a1 + 40) = v29;
    *(void *)(a1 + 48) = v29;
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 56) = v28;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 96) = a1 + 104;
    *(unsigned char *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 124) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    uint64_t v31 = v36;
    unsigned int v32 = v37;
    *(float *)(a1 + 124) = (float)(v22 - v23) / 49.0;
    *(_DWORD *)(a1 + 128) = LODWORD(result);
    if (v32 == v31) {
      sub_1DC351420();
    }
    *(unsigned char *)(a1 + 120) = *v31 != 0;
    if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) == 0) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  *(_DWORD *)a1 = 1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 20) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(void *)(a1 + 84) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  *(unsigned char *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  if (v17 < 0) {
LABEL_33:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_34:
  if (v36)
  {
    unsigned int v37 = v36;
    operator delete(v36);
  }
  return result;
}

void sub_1DC3D78D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20)
{
  sub_1DC3CA03C(v20);
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  _Unwind_Resume(a1);
}

unint64_t sub_1DC3D7924(uint64_t a1, unsigned char *a2, int *a3, int a4, int a5, int *a6)
{
  int32x4_t v78 = 0u;
  int32x4_t v79 = 0u;
  if (a5)
  {
    unint64_t v10 = sub_1DC353964(a1, a1 + a3[1], (uint64_t)&v78);
    if (v10 >= v11) {
      goto LABEL_18;
    }
  }
  else
  {
    int v13 = (unsigned char *)(a1 + a3[2]);
    int v14 = sub_1DC353A28(v13, a2, (uint64_t)&v78);
    BOOL v16 = v15 != a2 || v79.i32[3] == 0;
    if (v16) {
      char v17 = v14;
    }
    else {
      char v17 = v13;
    }
    if (v16) {
      BOOL v18 = v15;
    }
    else {
      BOOL v18 = a2;
    }
    if (v17 >= v18) {
      goto LABEL_18;
    }
    uint64_t v19 = &v79.i8[12];
    uint64_t v20 = &v78.i8[4];
    do
    {
      int v21 = *((_DWORD *)v20 - 1);
      *((_DWORD *)v20 - 1) = *(_DWORD *)v19;
      *(_DWORD *)uint64_t v19 = v21;
      v19 -= 4;
      BOOL v22 = v20 >= v19;
      v20 += 4;
    }
    while (!v22);
  }
  int v23 = vaddvq_s32(vaddq_s32(v79, v78));
  *a6 = v23;
  float v24 = (float)v23 / 17.0;
  float v25 = (float)(a3[2] - a3[1]) / 15.0;
  if ((float)(vabds_f32(v24, v25) / v25) > 0.3)
  {
LABEL_18:
    uint64_t v26 = 0;
    unsigned int v27 = 0x7FFFFFFF;
    return v27 | (unint64_t)(v26 << 32);
  }
  for (uint64_t i = 0; i != 8; ++i)
  {
    float v30 = (float)v78.i32[i] / v24;
    int v31 = (int)(float)(v30 + 0.5);
    if (v31 <= 0)
    {
      if (v30 < 0.3) {
        goto LABEL_18;
      }
      int v31 = 1;
    }
    else if (v31 >= 9)
    {
      if (v30 > 8.7) {
        goto LABEL_18;
      }
      int v31 = 8;
    }
    uint64_t v32 = i >> 1;
    float v33 = v30 - (float)v31;
    if (i) {
      uint64_t v34 = &v76;
    }
    else {
      uint64_t v34 = &v77;
    }
    if (i) {
      unsigned int v35 = v74;
    }
    else {
      unsigned int v35 = v75;
    }
    v34->i32[v32] = v31;
    *(float *)&v35[v32] = v33;
  }
  int v36 = vaddvq_s32(v77);
  int v37 = vaddvq_s32(v76);
  int v38 = vaddvq_s32(vaddq_s32(v76, v77));
  BOOL v39 = v36 > 13;
  BOOL v40 = v37 > 13;
  BOOL v41 = v37 < 4;
  if (v38 == 16)
  {
    if (v36)
    {
      uint64_t v26 = 0;
      unsigned int v27 = 0x7FFFFFFF;
      if ((v37 & 1) == 0 || v36 > 13) {
        return v27 | (unint64_t)(v26 << 32);
      }
      goto LABEL_53;
    }
    if (v37) {
      goto LABEL_18;
    }
    BOOL v41 = 1;
LABEL_48:
    if (v36 <= 3) {
      goto LABEL_49;
    }
    goto LABEL_70;
  }
  if (v38 != 17)
  {
    if (v38 != 18) {
      goto LABEL_18;
    }
    if (v36)
    {
      if ((v37 & 1) == 0) {
        goto LABEL_18;
      }
      BOOL v39 = 1;
    }
    else
    {
      if (v37) {
        goto LABEL_18;
      }
      BOOL v40 = 1;
    }
    goto LABEL_48;
  }
  if ((v36 & 1) == 0)
  {
    if ((v37 & 1) == 0) {
      goto LABEL_18;
    }
    goto LABEL_48;
  }
  if (v37) {
    goto LABEL_18;
  }
  BOOL v39 = v36 >= v37 || v36 > 13;
  BOOL v41 = v36 >= v37 || v37 < 4;
  BOOL v40 = v37 > 13 || v36 < v37;
  if (v36 < 4 || v36 < v37)
  {
LABEL_49:
    if (v39) {
      goto LABEL_18;
    }
LABEL_53:
    float v42 = *(float *)v75;
    uint64_t v43 = 1;
    float64x2_t v44 = (char *)v75;
    do
    {
      if (v42 < *(float *)&v75[v43])
      {
        float v42 = *(float *)&v75[v43];
        float64x2_t v44 = (char *)&v75[v43];
      }
      ++v43;
    }
    while (v43 != 4);
    int64_t v45 = v44 - (char *)v75;
    __int32 v46 = *(__int32 *)((char *)v77.i32 + v44 - (char *)v75) + 1;
    goto LABEL_76;
  }
LABEL_70:
  if (!v39)
  {
    if (v41) {
      goto LABEL_77;
    }
    goto LABEL_84;
  }
  float v47 = *(float *)v75;
  uint64_t v48 = 1;
  int v49 = (char *)v75;
  do
  {
    if (*(float *)&v75[v48] < v47)
    {
      float v47 = *(float *)&v75[v48];
      int v49 = (char *)&v75[v48];
    }
    ++v48;
  }
  while (v48 != 4);
  int64_t v45 = v49 - (char *)v75;
  __int32 v46 = *(__int32 *)((char *)v77.i32 + v49 - (char *)v75) - 1;
LABEL_76:
  *(__int32 *)((char *)v77.i32 + v45) = v46;
  if (v41)
  {
LABEL_77:
    if (v40) {
      goto LABEL_18;
    }
    float v50 = *(float *)v74;
    uint64_t v51 = 1;
    double v52 = (char *)v74;
    do
    {
      if (v50 < *(float *)&v74[v51])
      {
        float v50 = *(float *)&v74[v51];
        double v52 = (char *)&v74[v51];
      }
      ++v51;
    }
    while (v51 != 4);
    int v53 = 1;
    goto LABEL_90;
  }
LABEL_84:
  if (!v40) {
    goto LABEL_91;
  }
  float v54 = *(float *)v74;
  uint64_t v55 = 1;
  double v52 = (char *)v74;
  do
  {
    if (*(float *)&v74[v55] < v54)
    {
      float v54 = *(float *)&v74[v55];
      double v52 = (char *)&v74[v55];
    }
    ++v55;
  }
  while (v55 != 4);
  int v53 = -1;
LABEL_90:
  *(__int32 *)((char *)v76.i32 + v52 - (char *)v74) += v53;
LABEL_91:
  int v56 = 0;
  int v57 = 0;
  int v58 = *a3;
  if (a4) {
    int v59 = (a5 ^ 1) - 1;
  }
  else {
    int v59 = (a5 ^ 1) + 1;
  }
  int v60 = v59 + 4 * v58;
  if (v58) {
    int v61 = 0;
  }
  else {
    int v61 = a5;
  }
  int v62 = v61 & a4;
  uint64_t v63 = v60;
  float v64 = (_DWORD *)((char *)&unk_1DC4164A8 + 32 * v60 + 24);
  for (uint64_t j = 3; j != -1; --j)
  {
    __int32 v66 = v77.i32[j];
    if (!v62) {
      v57 += v66 * *v64;
    }
    v56 += v66;
    v64 -= 2;
  }
  int v67 = 0;
  uint64_t v68 = (_DWORD *)((char *)&unk_1DC4164A8 + 32 * v63 + 28);
  for (uint64_t k = 3; k != -1; --k)
  {
    if ((v62 & 1) == 0) {
      v67 += v76.i32[k] * *v68;
    }
    v68 -= 2;
  }
  uint64_t v26 = 0;
  unsigned int v27 = 0x7FFFFFFF;
  if ((v56 & 1) == 0 && (v56 - 14) >= 0xFFFFFFF6)
  {
    uint64_t v26 = (v67 + v57);
    unsigned int v70 = (13 - v56) >> 1;
    int v71 = dword_1DC416788[v70];
    int v72 = 9 - v71;
    int v73 = sub_1DC399FD4(v77.i32, 4u, v71, 0);
    unsigned int v27 = sub_1DC399FD4(v76.i32, 4u, v72, 1) + dword_1DC41679C[v70] * v73 + dword_1DC4167B0[v70];
  }
  return v27 | (unint64_t)(v26 << 32);
}

BOOL sub_1DC3D7E24(uint64_t a1)
{
  if (!*(void *)(a1 + 16)) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(_DWORD *)(v1 + 24) == 0x7FFFFFFF) {
    return 0;
  }
  int v3 = *(_DWORD *)(v1 + 28);
  uint64_t v4 = *(void *)(v1 + 8);
  for (int i = 2; v4 != a1; v4 = *(void *)(v4 + 8))
  {
    v3 += *(_DWORD *)(v4 + 20);
    if (*(_DWORD *)(v4 + 24) == 0x7FFFFFFF)
    {
      ++i;
    }
    else
    {
      v3 += *(_DWORD *)(v4 + 28);
      i += 2;
    }
  }
  return v3 % 211 + 211 * i - 844 == *(_DWORD *)(v1 + 16);
}

BOOL sub_1DC3D7EC8(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] && a1[4] == a2[4];
}

BOOL sub_1DC3D7F24(char *a1, char *a2, uint64_t a3)
{
  if (0x8E38E38E38E38E39 * ((a2 - a1) >> 3) != *(void *)(a3 + 16)) {
    return 0;
  }
  uint64_t v4 = a1;
  if (a1 == a2) {
    return 1;
  }
  uint64_t v5 = a3;
  do
  {
    uint64_t v5 = *(void *)(v5 + 8);
    BOOL result = sub_1DC3D7EC8(v4, (_DWORD *)(v5 + 16));
    v4 += 72;
  }
  while (result && v4 != a2);
  return result;
}

void sub_1DC3D7FB4(void *__p)
{
  unint64_t v2 = (void *)__p[2];
  if (v2)
  {
    __p[3] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

void *sub_1DC3D7FF8(uint64_t *a1, void *a2, int a3)
{
  if (a2[2] < 0x1AuLL)
  {
    if (a3)
    {
      unint64_t v6 = (void *)a2[1];
      uint64_t v8 = (uint64_t)&v8;
      char v9 = &v8;
      uint64_t v10 = 0;
      sub_1DC3D8180(a1, (uint64_t)a2, a2, (uint64_t)v6, v6, (uint64_t)&v8);
    }
    else
    {
      uint64_t v7 = (void *)a2[1];
      uint64_t v8 = (uint64_t)&v8;
      char v9 = &v8;
      uint64_t v10 = 0;
      sub_1DC3D8320(a1, v7, a2, (uint64_t)&v8);
    }
    return sub_1DC3D8120(&v8);
  }
  else
  {
    BOOL result = sub_1DC3D8120(a2);
    *a1 = (uint64_t)a1;
    a1[1] = (uint64_t)a1;
    a1[2] = 0;
  }
  return result;
}

void sub_1DC3D809C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DC3D8120((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DC3D80B4(uint64_t *a1, void *a2)
{
  BOOL result = sub_1DC353B08(a1);
  uint64_t v5 = a2[2];
  if (v5)
  {
    uint64_t v7 = *a2;
    unint64_t v6 = (uint64_t *)a2[1];
    uint64_t v8 = *v6;
    *(void *)(v8 + 8) = *(void *)(*a2 + 8);
    **(void **)(v7 + 8) = v8;
    uint64_t v9 = *a1;
    *(void *)(v9 + 8) = v6;
    *unint64_t v6 = v9;
    *a1 = v7;
    *(void *)(v7 + 8) = a1;
    a1[2] += v5;
    a2[2] = 0;
  }
  return result;
}

void *sub_1DC3D8120(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    BOOL result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    while (result != v1)
    {
      uint64_t v4 = (void *)result[1];
      sub_1DC3D7FB4(result);
      BOOL result = v4;
    }
  }
  return result;
}

void *sub_1DC3D8180(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6)
{
  v20[0] = (uint64_t)v20;
  v20[1] = (uint64_t)v20;
  v20[2] = 0;
  for (int i = (void *)a6; ; sub_1DC3D84A4(v20, v20, i[2], i[3]))
  {
    int i = (void *)i[1];
    if (i == (void *)a6) {
      break;
    }
  }
  if (a3 == a5)
  {
LABEL_9:
    *a1 = (uint64_t)a1;
    a1[1] = (uint64_t)a1;
    a1[2] = 0;
  }
  else
  {
    while (1)
    {
      sub_1DC3D85D4(a1, (uint64_t)v20);
      sub_1DC3D84A4(a1, a1, *(void *)(*a3 + 16), *(void *)(*a3 + 24));
      if (sub_1DC3D8688((uint64_t)a1))
      {
        if (sub_1DC3D7E24((uint64_t)a1)) {
          break;
        }
        sub_1DC3D86F8(v18, a6);
        int v13 = sub_1DC3D8780(*a3 + 16);
        uint64_t v14 = v18[0];
        *int v13 = v18[0];
        v13[1] = v18;
        *(void *)(v14 + 8) = v13;
        v18[0] = (uint64_t)v13;
        ++v19;
        sub_1DC3D8180(v17, a2, *a3, a4, a5, v18);
        sub_1DC3D80B4(a1, v17);
        sub_1DC353B08(v17);
        uint64_t v15 = a1[2];
        sub_1DC3D8120(v18);
        if (v15) {
          break;
        }
      }
      sub_1DC353B08(a1);
      a3 = (void *)*a3;
      if (a3 == a5) {
        goto LABEL_9;
      }
    }
  }
  return sub_1DC353B08(v20);
}

void sub_1DC3D82E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  sub_1DC3D8120((uint64_t *)va);
  sub_1DC353B08(v5);
  sub_1DC353B08((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void *sub_1DC3D8320(uint64_t *a1, void *a2, void *a3, uint64_t a4)
{
  v16[0] = (uint64_t)v16;
  v16[1] = (uint64_t)v16;
  v16[2] = 0;
  for (int i = (void *)a4; ; sub_1DC3D84A4(v16, v16, i[2], i[3]))
  {
    int i = (void *)i[1];
    if (i == (void *)a4) {
      break;
    }
  }
  if (a2 == a3)
  {
LABEL_9:
    *a1 = (uint64_t)a1;
    a1[1] = (uint64_t)a1;
    a1[2] = 0;
  }
  else
  {
    while (1)
    {
      sub_1DC3D85D4(a1, (uint64_t)v16);
      sub_1DC3D84A4(a1, a1, a2[2], a2[3]);
      if (sub_1DC3D8688((uint64_t)a1))
      {
        if (sub_1DC3D7E24((uint64_t)a1)) {
          break;
        }
        sub_1DC3D86F8(v14, a4);
        uint64_t v9 = sub_1DC3D8780((uint64_t)(a2 + 2));
        uint64_t v10 = v14[0];
        *uint64_t v9 = v14[0];
        v9[1] = v14;
        *(void *)(v10 + 8) = v9;
        v14[0] = (uint64_t)v9;
        ++v15;
        sub_1DC3D8320(v13, a2[1], a3, v14);
        sub_1DC3D80B4(a1, v13);
        sub_1DC353B08(v13);
        uint64_t v11 = a1[2];
        sub_1DC3D8120(v14);
        if (v11) {
          break;
        }
      }
      sub_1DC353B08(a1);
      a2 = (void *)a2[1];
      if (a2 == a3) {
        goto LABEL_9;
      }
    }
  }
  return sub_1DC353B08(v16);
}

void sub_1DC3D8464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  sub_1DC3D8120((uint64_t *)va);
  sub_1DC353B08(v5);
  sub_1DC353B08((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void *sub_1DC3D84A4(void *result, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a4)
  {
    uint64_t v7 = result;
    BOOL result = operator new(0x58uLL);
    uint64_t v8 = result;
    *BOOL result = 0;
    result[1] = 0;
    long long v9 = *(_OWORD *)(a3 + 16);
    long long v10 = *(_OWORD *)(a3 + 32);
    long long v11 = *(_OWORD *)(a3 + 48);
    result[10] = *(void *)(a3 + 64);
    *((_OWORD *)result + 3) = v10;
    *((_OWORD *)result + 4) = v11;
    *((_OWORD *)result + 2) = v9;
    *((_OWORD *)result + 1) = *(_OWORD *)a3;
    uint64_t v12 = a3 + 72;
    uint64_t v13 = 1;
    if (a3 + 72 != a4)
    {
      uint64_t v14 = result;
      do
      {
        BOOL result = operator new(0x58uLL);
        *BOOL result = v14;
        result[1] = 0;
        *((_OWORD *)result + 1) = *(_OWORD *)v12;
        long long v15 = *(_OWORD *)(v12 + 16);
        long long v16 = *(_OWORD *)(v12 + 32);
        long long v17 = *(_OWORD *)(v12 + 48);
        result[10] = *(void *)(v12 + 64);
        *((_OWORD *)result + 3) = v16;
        *((_OWORD *)result + 4) = v17;
        *((_OWORD *)result + 2) = v15;
        v14[1] = result;
        ++v13;
        v12 += 72;
        uint64_t v14 = result;
      }
      while (v12 != a4);
    }
    uint64_t v18 = *a2;
    *(void *)(v18 + 8) = v8;
    *uint64_t v8 = v18;
    *a2 = (uint64_t)result;
    result[1] = a2;
    v7[2] += v13;
  }
  return result;
}

void sub_1DC3D85A0(void *a1)
{
  __cxa_begin_catch(a1);
  do
  {
    uint64_t v2 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1DC3D85C0(_Unwind_Exception *a1)
{
}

void *sub_1DC3D85D4(void *a1, uint64_t a2)
{
  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 != a2)
  {
    uint64_t v5 = 1;
    unint64_t v6 = a1;
    do
    {
      uint64_t v7 = operator new(0x58uLL);
      v7[1] = *(_OWORD *)(v3 + 16);
      long long v8 = *(_OWORD *)(v3 + 32);
      long long v9 = *(_OWORD *)(v3 + 48);
      long long v10 = *(_OWORD *)(v3 + 64);
      *((void *)v7 + 10) = *(void *)(v3 + 80);
      v7[3] = v9;
      v7[4] = v10;
      v7[2] = v8;
      *(void *)uint64_t v7 = v6;
      *((void *)v7 + 1) = a1;
      *((void *)v6 + 1) = v7;
      *a1 = v7;
      a1[2] = v5;
      uint64_t v3 = *(void *)(v3 + 8);
      ++v5;
      unint64_t v6 = v7;
    }
    while (v3 != a2);
  }
  return a1;
}

void sub_1DC3D8674(_Unwind_Exception *a1)
{
  sub_1DC353B08(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3D8688(uint64_t a1)
{
  uint64_t v1 = &off_1E6C3AE98;
  while (*(void *)(a1 + 16) > (unint64_t)v1[1])
  {
LABEL_3:
    v1 += 2;
    if (v1 == &off_1E6C3AF38) {
      return 0;
    }
  }
  if (*(void *)(a1 + 8) != a1)
  {
    uint64_t v2 = *v1;
    uint64_t v3 = *(void *)(a1 + 8);
    while (*(_DWORD *)(v3 + 32) == *v2)
    {
      uint64_t v3 = *(void *)(v3 + 8);
      ++v2;
      if (v3 == a1) {
        return 1;
      }
    }
    goto LABEL_3;
  }
  return 1;
}

uint64_t *sub_1DC3D86F8(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = *(void *)(a2 + 8); i != a2; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v5 = sub_1DC3D8780(i + 16);
    uint64_t v6 = *a1;
    *uint64_t v5 = *a1;
    v5[1] = a1;
    *(void *)(v6 + 8) = v5;
    *a1 = (uint64_t)v5;
    ++a1[2];
  }
  return a1;
}

void sub_1DC3D876C(_Unwind_Exception *a1)
{
  sub_1DC3D8120(v1);
  _Unwind_Resume(a1);
}

_OWORD *sub_1DC3D8780(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = v2;
  v2[1] = 0u;
  *uint64_t v2 = 0u;
  *((void *)v2 + 4) = 0;
  uint64_t v5 = *(const void **)a1;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v6 = v4 - *(void *)a1;
  if (v4 != *(void *)a1)
  {
    sub_1DC3D8858((void *)v2 + 2, 0x8E38E38E38E38E39 * (v6 >> 3));
    uint64_t v7 = (char *)*((void *)v3 + 3);
    memmove(v7, v5, v6 - 6);
    *((void *)v3 + 3) = &v7[8 * (v6 >> 3)];
  }
  *((_DWORD *)v3 + 10) = *(_DWORD *)(a1 + 24);
  *((unsigned char *)v3 + 44) = *(unsigned char *)(a1 + 28);
  return v3;
}

void sub_1DC3D8834(_Unwind_Exception *a1)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    v1[3] = v4;
    operator delete(v4);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_1DC3D8858(void *a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    sub_1DC2FF97C();
  }
  uint64_t v3 = 9 * a2;
  BOOL result = (char *)operator new(72 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v3];
  return result;
}

void sub_1DC3D88AC(void *a1)
{
  *a1 = &unk_1F3660FE8;
  sub_1DC3D8120(a1 + 1);
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3D8910(void *a1)
{
  *a1 = &unk_1F3660FE8;
  sub_1DC3D8120(a1 + 1);
  return a1;
}

void sub_1DC3D8954()
{
}

void sub_1DC3D896C(uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  int v5 = (a2 + 360) % 360;
  if (v5 > 179)
  {
    if (v5 == 180)
    {
      float v30 = (int *)(a1 + 32);
      int v29 = *(_DWORD *)(a1 + 32);
      int v31 = *(uint64_t **)(a1 + 8);
      int v32 = *(_DWORD *)(a1 + 36);
      float v33 = (const void *)*v31;
      if (*(void *)(a1 + 24) || (uint64_t v34 = v31[1], v32 * v29 != v34 - v33))
      {
        sub_1DC3D8F1C(&v49, *v31, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 28), v29, v32);
        int v36 = (unint64_t *)v49.n128_u64[0];
      }
      else
      {
        unsigned int v35 = (char *)operator new(0x30uLL);
        *(_OWORD *)(v35 + 8) = 0u;
        *(void *)unsigned int v35 = &unk_1F36622E0;
        *((void *)v35 + 3) = 0;
        int v36 = (unint64_t *)(v35 + 24);
        *((_OWORD *)v35 + 2) = 0u;
        sub_1DC352C78((void *)v35 + 3, v33, v34, v34 - (void)v33);
        v49.n128_u64[1] = (unint64_t)v35;
      }
      unint64_t v37 = *v36;
      unint64_t v38 = v36[1];
      BOOL v39 = (unsigned char *)(v38 - 1);
      if (*v36 != v38 && (unint64_t)v39 > v37)
      {
        unint64_t v41 = v37 + 1;
        do
        {
          char v42 = *(unsigned char *)(v41 - 1);
          *(unsigned char *)(v41 - 1) = *v39;
          *v39-- = v42;
        }
        while (v41++ < (unint64_t)v39);
      }
      int v44 = *(_DWORD *)(a1 + 32);
      int v45 = *(_DWORD *)(a1 + 36);
      __int32 v46 = (std::__shared_weak_count *)v49.n128_u64[1];
      sub_1DC3D8E20(&v48, 0, 0, v44, v45, (unint64_t)v36, v49.n128_u64[1], v30);
      goto LABEL_43;
    }
    if (v5 == 270)
    {
      uint64_t v6 = (int *)(a1 + 36);
      sub_1DC3D8D94(&v49, *(_DWORD *)(a1 + 36) * *(_DWORD *)(a1 + 32));
      unint64_t v7 = v49.n128_u64[0];
      int v8 = *v6;
      if (*v6 <= 0)
      {
        LODWORD(v13) = *(_DWORD *)(a1 + 32);
      }
      else
      {
        int v15 = 0;
        uint64_t v16 = *(void *)v49.n128_u64[0];
        int v17 = *(_DWORD *)(a1 + 40);
        uint64_t v18 = **(void **)(a1 + 8) + v17 * (uint64_t)*(int *)(a1 + 28) + *(int *)(a1 + 24);
        LODWORD(v13) = *(_DWORD *)(a1 + 32);
        do
        {
          if ((int)v13 >= 1)
          {
            uint64_t v19 = 0;
            int v20 = -1;
            do
            {
              *(unsigned char *)(v16 + v15 + *(_DWORD *)(a1 + 36) * ((int)v13 + v20)) = *(unsigned char *)(v18 + v19++);
              uint64_t v13 = *(int *)(a1 + 32);
              --v20;
            }
            while (v19 < v13);
            int v8 = *(_DWORD *)(a1 + 36);
            int v17 = *(_DWORD *)(a1 + 40);
          }
          ++v15;
          v18 += v17;
        }
        while (v15 < v8);
      }
      goto LABEL_42;
    }
LABEL_46:
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DC3A0BE8(exception);
    __cxa_throw(exception, (struct type_info *)off_1E6C39928, MEMORY[0x1E4FBA1E8]);
  }
  if (v5)
  {
    if (v5 == 90)
    {
      uint64_t v6 = (int *)(a1 + 36);
      sub_1DC3D8D94(&v49, *(_DWORD *)(a1 + 36) * *(_DWORD *)(a1 + 32));
      unint64_t v7 = v49.n128_u64[0];
      int v8 = *v6;
      if (*v6 <= 0)
      {
        LODWORD(v13) = *(_DWORD *)(a1 + 32);
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = *(void *)v49.n128_u64[0];
        int v11 = *(_DWORD *)(a1 + 40);
        uint64_t v12 = **(void **)(a1 + 8) + v11 * (uint64_t)*(int *)(a1 + 28) + *(int *)(a1 + 24);
        LODWORD(v13) = *(_DWORD *)(a1 + 32);
        do
        {
          if ((int)v13 >= 1)
          {
            uint64_t v14 = 0;
            do
            {
              *(unsigned char *)(v10 + *(_DWORD *)(a1 + 36) + ~v9 + *(_DWORD *)(a1 + 36) * (int)v14) = *(unsigned char *)(v12 + v14);
              ++v14;
              uint64_t v13 = *(int *)(a1 + 32);
            }
            while (v14 < v13);
            int v8 = *(_DWORD *)(a1 + 36);
            int v11 = *(_DWORD *)(a1 + 40);
          }
          ++v9;
          v12 += v11;
        }
        while (v9 < v8);
      }
LABEL_42:
      __int32 v46 = (std::__shared_weak_count *)v49.n128_u64[1];
      sub_1DC3D8E20(&v48, 0, 0, v8, v13, v7, v49.n128_u64[1], v6);
LABEL_43:
      *a3 = v48;
      if (v46) {
        sub_1DC32EEF4(v46);
      }
      return;
    }
    goto LABEL_46;
  }
  int v21 = operator new(0x48uLL);
  BOOL v22 = v21;
  v21[1] = 0;
  v21[2] = 0;
  *int v21 = &unk_1F3662270;
  int v23 = v21 + 3;
  int v24 = *(_DWORD *)(a1 + 32);
  int v25 = *(_DWORD *)(a1 + 36);
  unint64_t v26 = *(void *)(a1 + 16);
  v49.n128_u64[0] = *(void *)(a1 + 8);
  v49.n128_u64[1] = v26;
  int v27 = v24;
  if (v26)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
    int v27 = *(_DWORD *)(a1 + 32);
  }
  sub_1DC3D9018((uint64_t)(v21 + 3), 0, 0, v24, v25, &v49, v27);
  if (v49.n128_u64[1]) {
    sub_1DC32EEF4((std::__shared_weak_count *)v49.n128_u64[1]);
  }
  *(void *)&long long v28 = v23;
  *((void *)&v28 + 1) = v22;
  *a3 = v28;
}

void sub_1DC3D8D38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  std::__shared_weak_count::~__shared_weak_count(v12);
  operator delete(v14);
  _Unwind_Resume(a1);
}

void *sub_1DC3D8D94(void *a1, int a2)
{
  uint64_t v4 = operator new(0x30uLL);
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = &unk_1F36622E0;
  char v6 = 0;
  BOOL result = sub_1DC314894(v4 + 3, a2, &v6);
  *a1 = result;
  a1[1] = v4;
  return result;
}

void sub_1DC3D8E08(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1DC3D8E20(void *a1, int a2, int a3, int a4, int a5, unint64_t a6, unint64_t a7, int *a8)
{
  uint64_t v16 = operator new(0x48uLL);
  int v17 = v16;
  v16[1] = 0;
  v16[2] = 0;
  *uint64_t v16 = &unk_1F3662270;
  uint64_t v18 = v16 + 3;
  v19.n128_u64[0] = a6;
  v19.n128_u64[1] = a7;
  if (a7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1DC3D9018((uint64_t)(v16 + 3), a2, a3, a4, a5, &v19, *a8);
  if (v19.n128_u64[1]) {
    sub_1DC32EEF4((std::__shared_weak_count *)v19.n128_u64[1]);
  }
  *a1 = v18;
  a1[1] = v17;
}

void sub_1DC3D8EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1DC32EEF4(a10);
  }
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);
  _Unwind_Resume(a1);
}

void sub_1DC3D8F1C(void *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7)
{
  uint64_t v14 = operator new(0x30uLL);
  v14[1] = 0;
  uint64_t v14[2] = 0;
  v14[3] = 0;
  int v15 = (void **)(v14 + 3);
  *uint64_t v14 = &unk_1F36622E0;
  v14[4] = 0;
  v14[5] = 0;
  *a1 = v14 + 3;
  a1[1] = v14;
  if (a7 * a6) {
    sub_1DC3D9108(v14 + 3, a7 * a6);
  }
  if (a7 >= 1)
  {
    uint64_t v16 = (char *)*v15;
    int v17 = (char *)(a2 + a5 * (uint64_t)a3 + a4);
    do
    {
      if (a6) {
        memmove(v16, v17, a6);
      }
      v17 += a3;
      v16 += a6;
      --a7;
    }
    while (a7);
  }
}

void sub_1DC3D9004(_Unwind_Exception *a1)
{
  sub_1DC32EEF4(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1DC3D9018(uint64_t a1, int a2, int a3, int a4, int a5, __n128 *a6, int a7)
{
  *(void *)a1 = &unk_1F3660E08;
  __n128 result = *a6;
  *(__n128 *)(a1 + 8) = *a6;
  a6->n128_u64[0] = 0;
  a6->n128_u64[1] = 0;
  *(_DWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 28) = a3;
  *(_DWORD *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 36) = a5;
  *(_DWORD *)(a1 + 40) = a7;
  if ((a3 | a2 | a4 | a5) < 0)
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Requested offset is outside the image");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E6C39918, MEMORY[0x1E4FBA1D0]);
  }
  return result;
}

void sub_1DC3D90DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  int v11 = *(std::__shared_weak_count **)(a10 + 16);
  if (v11) {
    sub_1DC32EEF4(v11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DC3D9108(unint64_t *a1, size_t a2)
{
  int v5 = (char *)a1[1];
  uint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    unint64_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      sub_1DC2FF97C();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    uint64_t v12 = &v7[v11];
    uint64_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      uint64_t v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      int v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_1DC3D9244(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void sub_1DC3D925C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F36622E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC3D92B0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F36622E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_1DC3D92D0()
{
  return 1;
}

__n128 sub_1DC3D92D8@<Q0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, __n128 *a6@<X8>)
{
  if ((a3 | a2 | a4 | a5) < 0 || a4 + a2 > *(_DWORD *)(a1 + 32) || a5 + a3 > *(_DWORD *)(a1 + 36))
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DC32BA6C(exception, "Crop rectangle does not fit within image data.");
    __cxa_throw(exception, (struct type_info *)off_1E6C39918, MEMORY[0x1E4FBA1D0]);
  }
  int v10 = *(_DWORD *)(a1 + 24) + a2;
  int v11 = *(_DWORD *)(a1 + 28) + a3;
  uint64_t v12 = operator new(0x48uLL);
  unint64_t v13 = (unint64_t)v12;
  v12[1] = 0;
  void v12[2] = 0;
  void *v12 = &unk_1F3662270;
  unint64_t v14 = (unint64_t)(v12 + 3);
  unint64_t v15 = *(void *)(a1 + 16);
  v18.n128_u64[0] = *(void *)(a1 + 8);
  v18.n128_u64[1] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1DC3D9018((uint64_t)(v12 + 3), v10, v11, a4, a5, &v18, *(_DWORD *)(a1 + 40));
  if (v18.n128_u64[1]) {
    sub_1DC32EEF4((std::__shared_weak_count *)v18.n128_u64[1]);
  }
  result.n128_u64[0] = v14;
  result.n128_u64[1] = v13;
  *a6 = result;
  return result;
}

void sub_1DC3D9418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1DC32EEF4(a10);
  }
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3D944C()
{
  return 1;
}

void sub_1DC3D9454(int32x2_t *a1, unint64_t *a2, int a3, float a4)
{
  unint64_t v7 = a1;
  a2[1] = *a2;
  int32x2_t v8 = a1[4];
  _S8 = tanf(a4);
  if (a3) {
    float v10 = (float)a3 / cosf(a4);
  }
  else {
    float v10 = 0.0;
  }
  _D2 = vmul_f32(vcvt_f32_s32(v8), (float32x2_t)0x3F0000003F000000);
  float v12 = -_D2.f32[0];
  __asm { FMLS            S12, S8, V2.S[0] }
  float v17 = _D2.f32[1];
  float v18 = -_D2.f32[1];
  BOOL v19 = _S12 < (float)-_D2.f32[1] || _S12 > _D2.f32[1];
  float v108 = -_D2.f32[1];
  float32x2_t v110 = _D2;
  if (v19)
  {
    int v21 = 0;
    BOOL v22 = 0;
  }
  else
  {
    int v20 = (int32x2_t *)operator new(8uLL);
    float v18 = v108;
    _D2 = v110;
    int v21 = v20;
    BOOL v22 = (int *)&v20[1];
    v20->i32[0] = (int)v12;
    v20->i32[1] = (int)_S12;
  }
  float v23 = v10 + (float)(_D2.f32[0] * _S8);
  BOOL v24 = v23 < v18 || v23 > v17;
  float v112 = a2;
  if (v24)
  {
    int v25 = v22;
    unint64_t v26 = (int32x2_t *)v22;
  }
  else
  {
    float v105 = v10 + (float)(_D2.f32[0] * _S8);
    uint64_t v27 = (char *)v22 - (char *)v21;
    uint64_t v28 = ((char *)v22 - (char *)v21) >> 3;
    unint64_t v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 61) {
      goto LABEL_171;
    }
    if (v27 >> 2 > v29) {
      unint64_t v29 = v27 >> 2;
    }
    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v29;
    }
    int v31 = (char *)sub_1DC2FFD7C(v30);
    int v32 = (int32x2_t *)&v31[8 * v28];
    _D2 = v110;
    unint64_t v26 = (int32x2_t *)&v31[8 * v33];
    *int v32 = vcvt_s32_f32((float32x2_t)__PAIR64__(LODWORD(v105), v110.u32[0]));
    int v25 = (int *)&v32[1];
    while (v22 != (int *)v21)
    {
      int32x2_t v34 = *(int32x2_t *)(v22 - 2);
      v22 -= 2;
      v32[-1] = v34;
      --v32;
    }
    if (v21)
    {
      operator delete(v21);
      _D2 = v110;
    }
    int v21 = v32;
    float v18 = v108;
  }
  if (fabsf(_S8) < 0.00000011921) {
    goto LABEL_68;
  }
  float v35 = (float)(v17 - v10) / _S8;
  if (v35 < v12 || v35 > _D2.f32[0]) {
    goto LABEL_35;
  }
  if (v25 < (int *)v26)
  {
    v37.i32[1] = _D2.i32[1];
    v37.f32[0] = (float)(v17 - v10) / _S8;
    *(int32x2_t *)int v25 = vcvt_s32_f32(v37);
    v25 += 2;
LABEL_35:
    unint64_t v38 = (int32x2_t *)v25;
    goto LABEL_48;
  }
  uint64_t v39 = ((char *)v25 - (char *)v21) >> 3;
  unint64_t v40 = v39 + 1;
  if ((unint64_t)(v39 + 1) >> 61) {
    goto LABEL_171;
  }
  if (((char *)v26 - (char *)v21) >> 2 > v40) {
    unint64_t v40 = ((char *)v26 - (char *)v21) >> 2;
  }
  if ((unint64_t)((char *)v26 - (char *)v21) >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v41 = v40;
  }
  char v42 = (char *)sub_1DC2FFD7C(v41);
  uint64_t v43 = (int32x2_t *)&v42[8 * v39];
  _D2.i32[0] = v110.i32[0];
  unint64_t v26 = (int32x2_t *)&v42[8 * v44];
  *uint64_t v43 = vcvt_s32_f32((float32x2_t)__PAIR64__(v110.u32[1], (float)(v17 - v10) / _S8));
  unint64_t v38 = v43 + 1;
  while (v25 != (int *)v21)
  {
    int32x2_t v45 = *(int32x2_t *)(v25 - 2);
    v25 -= 2;
    v43[-1] = v45;
    --v43;
  }
  if (v21)
  {
    operator delete(v21);
    _D2.i32[0] = v110.i32[0];
  }
  int v21 = v43;
  float v18 = v108;
LABEL_48:
  float v46 = (float)(v18 - v10) / _S8;
  if (v46 < v12 || v46 > _D2.f32[0])
  {
    int v25 = (int *)v38;
    goto LABEL_68;
  }
  if (v38 < v26)
  {
    v38->i32[0] = (int)v46;
    v38->i32[1] = (int)v18;
    int v25 = (int *)&v38[1];
    goto LABEL_68;
  }
  float v106 = (float)(v18 - v10) / _S8;
  uint64_t v48 = v38 - v21;
  unint64_t v49 = v48 + 1;
  if ((unint64_t)(v48 + 1) >> 61) {
LABEL_171:
  }
    sub_1DC2FF97C();
  if (((char *)v26 - (char *)v21) >> 2 > v49) {
    unint64_t v49 = ((char *)v26 - (char *)v21) >> 2;
  }
  if ((unint64_t)((char *)v26 - (char *)v21) >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v50 = v49;
  }
  uint64_t v51 = (int32x2_t *)((char *)sub_1DC2FFD7C(v50) + 8 * v48);
  *uint64_t v51 = vcvt_s32_f32((float32x2_t)__PAIR64__(LODWORD(v108), LODWORD(v106)));
  int v25 = (int *)&v51[1];
  while (v38 != v21)
  {
    int32x2_t v52 = v38[-1];
    --v38;
    v51[-1] = v52;
    --v51;
  }
  if (v21) {
    operator delete(v21);
  }
  int v21 = v51;
LABEL_68:
  unint64_t v53 = 126 - 2 * __clz(((char *)v25 - (char *)v21) >> 3);
  if (v25 == (int *)v21) {
    uint64_t v54 = 0;
  }
  else {
    uint64_t v54 = v53;
  }
  sub_1DC3D9AC8((unint64_t)v21, v25, v54, 1);
  uint64_t v55 = v21;
  if (v25 != (int *)v21)
  {
    int v56 = v21 - 1;
    while (&v56[2] != (int32x2_t *)v25)
    {
      __int32 v58 = v56[1].i32[0];
      ++v56;
      v57.i32[0] = v58;
      if (v58 == v56[1].i32[0] && v56->i32[1] == v56[1].i32[1])
      {
        for (uint64_t i = (int *)&v56[2]; i != v25; i += 2)
        {
          if (v57.i32[0] != *i || v56->i32[1] != i[1])
          {
            int32x2_t v57 = *(int32x2_t *)i;
            v56[1] = *(int32x2_t *)i;
            ++v56;
          }
        }
        if (&v56[1] != (int32x2_t *)v25)
        {
          uint64_t v55 = v56 + 1;
          goto LABEL_90;
        }
        break;
      }
    }
    uint64_t v55 = (int32x2_t *)v25;
  }
LABEL_90:
  if ((char *)v55 - (char *)v21 == 16)
  {
    if (v21 != v55)
    {
      int v62 = v21;
      do
      {
        *int v62 = vcvt_s32_f32(vadd_f32(v110, vcvt_f32_s32(*v62)));
        ++v62;
      }
      while (v62 != v55);
    }
    uint64_t v63 = (uint64_t)*v21;
    uint64_t v64 = (uint64_t)v21[1];
    operator delete(v21);
    unint64_t v65 = HIDWORD(v64);
    unint64_t v66 = HIDWORD(v63);
    int v67 = v7[4].i32[0] - 1;
    if (v67 >= (int)v63) {
      int v68 = v63;
    }
    else {
      int v68 = v7[4].i32[0] - 1;
    }
    if ((int)v63 < 0) {
      int v68 = 0;
    }
    int v69 = v7[4].i32[1] - 1;
    if (v69 < SHIDWORD(v63)) {
      LODWORD(v66) = v7[4].i32[1] - 1;
    }
    if (v63 >= 0) {
      int v70 = v66;
    }
    else {
      int v70 = 0;
    }
    if (v67 >= (int)v64) {
      int v71 = v64;
    }
    else {
      int v71 = v7[4].i32[0] - 1;
    }
    if ((int)v64 >= 0) {
      int v72 = v71;
    }
    else {
      int v72 = 0;
    }
    if (v69 < SHIDWORD(v64)) {
      LODWORD(v65) = v7[4].i32[1] - 1;
    }
    if (v64 >= 0) {
      int v73 = v65;
    }
    else {
      int v73 = 0;
    }
    if (v72 > v68) {
      int v74 = 1;
    }
    else {
      int v74 = -1;
    }
    if (v72 - v68 >= 0) {
      unsigned int v75 = v72 - v68;
    }
    else {
      unsigned int v75 = v68 - v72;
    }
    int v111 = v73;
    if (v73 > v70) {
      int v76 = 1;
    }
    else {
      int v76 = -1;
    }
    if (v73 - v70 >= 0) {
      int v77 = v73 - v70;
    }
    else {
      int v77 = v70 - v73;
    }
    if (v75 <= v77) {
      int v78 = -v77;
    }
    else {
      int v78 = v75;
    }
    int v79 = v78 / 2;
    int v80 = -v75;
    uint64_t v81 = a2;
    char v82 = (unsigned char *)a2[1];
    int v109 = v72;
    unsigned int v104 = v75;
    int v107 = v74;
    int v102 = -v75;
    int v103 = v76;
    while (1)
    {
      uint64_t v83 = **(void **)&v7[1] + (v7[3].i32[1] + (uint64_t)v70) * v7[5].i32[0] + v7[3].i32[0];
      uint64_t v84 = v68;
      unint64_t v85 = v81[2];
      if ((unint64_t)v82 >= v85)
      {
        int v86 = v7;
        unint64_t v87 = *v81;
        int v88 = &v82[-v87];
        uint64_t v89 = (uint64_t)&v82[-v87 + 1];
        if (v89 < 0) {
          sub_1DC2FF97C();
        }
        unint64_t v90 = v85 - v87;
        if (2 * v90 > v89) {
          uint64_t v89 = 2 * v90;
        }
        if (v90 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v91 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v91 = v89;
        }
        if (v91) {
          uint64_t v92 = (char *)operator new(v91);
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v93 = &v88[(void)v92];
        v88[(void)v92] = *(unsigned char *)(v83 + v84);
        uint64_t v94 = (uint64_t)&v88[(void)v92 + 1];
        if (v82 == (unsigned char *)v87)
        {
          unint64_t v7 = v86;
          uint64_t v81 = v112;
        }
        else
        {
          unsigned int v95 = &v82[~v87];
          unint64_t v7 = v86;
          do
          {
            char v96 = *--v82;
            (v95--)[(void)v92] = v96;
          }
          while (v82 != (unsigned char *)v87);
          uint64_t v81 = v112;
          char v82 = (unsigned char *)*v112;
          uint64_t v93 = v92;
        }
        *uint64_t v81 = (unint64_t)v93;
        v81[1] = v94;
        v81[2] = (unint64_t)&v92[v91];
        if (v82) {
          operator delete(v82);
        }
        char v82 = (unsigned char *)v94;
        int v72 = v109;
        unsigned int v75 = v104;
        int v74 = v107;
        int v80 = v102;
        int v76 = v103;
      }
      else
      {
        *v82++ = *(unsigned char *)(v83 + v84);
      }
      v81[1] = (unint64_t)v82;
      if (v84 == v72 && v70 == v111) {
        break;
      }
      if (v79 <= v80) {
        int v97 = 0;
      }
      else {
        int v97 = v74;
      }
      int v68 = v97 + v84;
      if (v79 <= v80) {
        int v98 = 0;
      }
      else {
        int v98 = v77;
      }
      int v99 = v79 - v98;
      if (v79 >= v77) {
        int v100 = 0;
      }
      else {
        int v100 = v76;
      }
      v70 += v100;
      if (v79 >= v77) {
        unsigned int v101 = 0;
      }
      else {
        unsigned int v101 = v75;
      }
      int v79 = v99 + v101;
    }
  }
  else if (v21)
  {
    operator delete(v21);
  }
}

void sub_1DC3D9AB0(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1DC3D9AC8(unint64_t result, int *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (int *)result;
  while (2)
  {
    float v10 = a2 - 2;
    int v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v11;
          uint64_t v12 = (char *)a2 - (char *)v11;
          unint64_t v13 = ((char *)a2 - (char *)v11) >> 3;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                int v71 = *(a2 - 2);
                BOOL v5 = v71 == *v11;
                BOOL v72 = v71 < *v11;
                if (v5) {
                  BOOL v72 = *(a2 - 1) < v11[1];
                }
                if (v72)
                {
                  int32x2_t v73 = *(int32x2_t *)v11;
                  *(void *)int v11 = *(void *)v10;
                  *(int32x2_t *)float v10 = v73;
                }
                break;
              case 3uLL:
                __n128 result = (unint64_t)sub_1DC3DA3EC(v11, v11 + 2, a2 - 2);
                break;
              case 4uLL:
                __n128 result = (unint64_t)sub_1DC3DA4C4(v11, v11 + 2, v11 + 4, a2 - 2);
                break;
              case 5uLL:
                __n128 result = (unint64_t)sub_1DC3DA4C4(v11, v11 + 2, v11 + 4, v11 + 6);
                int v74 = *(a2 - 2);
                int v75 = v11[6];
                BOOL v5 = v74 == v75;
                BOOL v76 = v74 < v75;
                if (v5) {
                  BOOL v76 = *(a2 - 1) < v11[7];
                }
                if (v76)
                {
                  uint64_t v77 = *((void *)v11 + 3);
                  *((void *)v11 + 3) = *(void *)v10;
                  *(void *)float v10 = v77;
                  LODWORD(v77) = v11[6];
                  int v78 = v11[4];
                  BOOL v5 = v77 == v78;
                  BOOL v79 = (int)v77 < v78;
                  if (v5) {
                    BOOL v79 = v11[7] < v11[5];
                  }
                  if (v79)
                  {
                    uint64_t v81 = *((void *)v11 + 2);
                    uint64_t v80 = *((void *)v11 + 3);
                    *((void *)v11 + 2) = v80;
                    *((void *)v11 + 3) = v81;
                    int v82 = v11[2];
                    BOOL v5 = v82 == v80;
                    BOOL v83 = v82 > (int)v80;
                    if (v5) {
                      BOOL v83 = v11[3] > SHIDWORD(v80);
                    }
                    if (v83)
                    {
                      uint64_t v84 = *((void *)v11 + 1);
                      *((void *)v11 + 1) = v80;
                      *((void *)v11 + 2) = v84;
                      BOOL v85 = v11[1] > SHIDWORD(v80);
                      if (*v11 != v80) {
                        BOOL v85 = *v11 > (int)v80;
                      }
                      if (v85)
                      {
                        int32x2_t v86 = *(int32x2_t *)v11;
                        *(void *)int v11 = v80;
                        *((int32x2_t *)v11 + 1) = v86;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 191)
          {
            unint64_t v87 = v11 + 2;
            BOOL v89 = v11 == a2 || v87 == a2;
            if (a4)
            {
              if (!v89)
              {
                uint64_t v90 = 0;
                size_t v91 = v11;
                do
                {
                  int v92 = v91[2];
                  int v93 = v91[3];
                  int v94 = *v91;
                  int v95 = v91[1];
                  size_t v91 = v87;
                  BOOL v96 = v93 < v95;
                  BOOL v5 = v92 == v94;
                  BOOL v97 = v92 < v94;
                  if (!v5) {
                    BOOL v96 = v97;
                  }
                  if (v96)
                  {
                    uint64_t v98 = *(void *)v91;
                    uint64_t v99 = HIDWORD(*(void *)v91);
                    uint64_t v100 = v90;
                    while (1)
                    {
                      unsigned int v101 = (char *)v11 + v100;
                      *(void *)((char *)v11 + v100 + 8) = *(void *)((char *)v11 + v100);
                      if (!v100) {
                        break;
                      }
                      int v102 = *((_DWORD *)v101 - 2);
                      BOOL v103 = *((_DWORD *)v101 - 1) > (int)v99;
                      BOOL v5 = v102 == v98;
                      BOOL v104 = v102 > (int)v98;
                      if (!v5) {
                        BOOL v103 = v104;
                      }
                      v100 -= 8;
                      if (!v103)
                      {
                        float v105 = (int *)((char *)v11 + v100 + 8);
                        goto LABEL_119;
                      }
                    }
                    float v105 = v11;
LABEL_119:
                    *(void *)float v105 = v98;
                  }
                  unint64_t v87 = v91 + 2;
                  v90 += 8;
                }
                while (v91 + 2 != a2);
              }
            }
            else if (!v89)
            {
              do
              {
                int v147 = v9[2];
                int v148 = v9[3];
                int v149 = *v9;
                int v150 = v9[1];
                unint64_t v9 = v87;
                BOOL v151 = v148 < v150;
                BOOL v5 = v147 == v149;
                BOOL v152 = v147 < v149;
                if (v5) {
                  BOOL v152 = v151;
                }
                if (v152)
                {
                  uint64_t v153 = *(void *)v87;
                  uint64_t v154 = HIDWORD(*(void *)v87);
                  do
                  {
                    uint64_t v155 = v87;
                    uint64_t v156 = *((void *)v87 - 1);
                    v87 -= 2;
                    *(void *)uint64_t v155 = v156;
                    int v157 = *(v155 - 4);
                    BOOL v158 = *(v155 - 3) > (int)v154;
                    BOOL v5 = v157 == v153;
                    BOOL v159 = v157 > (int)v153;
                    if (!v5) {
                      BOOL v158 = v159;
                    }
                  }
                  while (v158);
                  *(void *)unint64_t v87 = v153;
                }
                unint64_t v87 = v9 + 2;
              }
              while (v9 + 2 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v106 = (v13 - 2) >> 1;
              int64_t v107 = v106;
              do
              {
                int64_t v108 = v107;
                if (v106 >= v107)
                {
                  uint64_t v109 = (2 * v107) | 1;
                  float32x2_t v110 = (int32x2_t *)&v11[2 * v109];
                  if (2 * v108 + 2 < (uint64_t)v13)
                  {
                    int32x2_t v111 = v110[1];
                    int32x2_t v112 = vcgt_s32(v111, *v110);
                    __int32 v114 = (__int32)*v110;
                    __int8 v113 = v112.i8[4];
                    if (v114 != v111.i32[0]) {
                      __int8 v113 = v112.i8[0];
                    }
                    if (v113)
                    {
                      __int32 v114 = (__int32)v110[1];
                      ++v110;
                      uint64_t v109 = 2 * v108 + 2;
                    }
                  }
                  else
                  {
                    __int32 v114 = v110->i32[0];
                  }
                  float v115 = (int32x2_t *)&v11[2 * v108];
                  __n128 result = v115->u32[1];
                  BOOL v5 = v114 == v115->i32[0];
                  BOOL v116 = v114 < v115->i32[0];
                  if (v5) {
                    BOOL v116 = v110->i32[1] < (int)result;
                  }
                  if (!v116)
                  {
                    int32x2_t v117 = *v115;
                    unint64_t v118 = HIDWORD(*(unint64_t *)v115);
                    do
                    {
                      float v119 = v115;
                      float v115 = v110;
                      int32x2_t *v119 = *v110;
                      if (v106 < v109) {
                        break;
                      }
                      uint64_t v120 = (2 * v109) | 1;
                      float32x2_t v110 = (int32x2_t *)&v11[2 * v120];
                      uint64_t v109 = 2 * v109 + 2;
                      if (v109 < (uint64_t)v13)
                      {
                        int32x2_t v121 = v110[1];
                        int32x2_t v122 = vcgt_s32(v121, *v110);
                        int v124 = (int)*v110;
                        __int8 v123 = v122.i8[4];
                        if (v124 != v121.i32[0]) {
                          __int8 v123 = v122.i8[0];
                        }
                        if (v123)
                        {
                          int v124 = (int)v110[1];
                          ++v110;
                        }
                        else
                        {
                          uint64_t v109 = v120;
                        }
                      }
                      else
                      {
                        int v124 = v110->i32[0];
                        uint64_t v109 = v120;
                      }
                      BOOL v125 = v110->i32[1] < (int)v118;
                      BOOL v5 = v124 == v117.i32[0];
                      __n128 result = v124 < v117.i32[0];
                      if (!v5) {
                        BOOL v125 = result;
                      }
                    }
                    while (!v125);
                    *float v115 = v117;
                  }
                }
                int64_t v107 = v108 - 1;
              }
              while (v108);
              uint64_t v126 = (unint64_t)v12 >> 3;
              do
              {
                uint64_t v127 = 0;
                int32x2_t v128 = *(int32x2_t *)v11;
                int v129 = (int32x2_t *)v11;
                do
                {
                  BOOL v130 = &v129[v127 + 1];
                  uint64_t v131 = (2 * v127) | 1;
                  uint64_t v132 = 2 * v127 + 2;
                  if (v132 < v126)
                  {
                    int32x2_t v133 = v130[1];
                    unsigned __int8 v134 = vceq_s32(*v130, v133).u8[0];
                    int32x2_t v135 = vcgt_s32(v133, *v130);
                    __n128 result = v135.u32[0];
                    __int8 v136 = (v134 & 1) != 0 ? v135.i8[4] : v135.i8[0];
                    if (v136)
                    {
                      ++v130;
                      uint64_t v131 = v132;
                    }
                  }
                  *int v129 = *v130;
                  int v129 = v130;
                  uint64_t v127 = v131;
                }
                while (v131 <= (uint64_t)((unint64_t)(v126 - 2) >> 1));
                a2 -= 2;
                if (v130 == (int32x2_t *)a2)
                {
                  int32x2_t *v130 = v128;
                }
                else
                {
                  int32x2_t *v130 = *(int32x2_t *)a2;
                  *(int32x2_t *)a2 = v128;
                  uint64_t v137 = (char *)v130 - (char *)v11 + 8;
                  if (v137 >= 9)
                  {
                    unint64_t v138 = (((unint64_t)v137 >> 3) - 2) >> 1;
                    unint64_t v139 = (int32x2_t *)&v11[2 * v138];
                    int32x2_t v140 = *v130;
                    int32x2_t v141 = vcgt_s32(*v130, *v139);
                    __int8 v142 = (vceq_s32(*v139, *v130).u8[0] & 1) != 0 ? v141.i8[4] : v141.i8[0];
                    if (v142)
                    {
                      do
                      {
                        long long v143 = v130;
                        BOOL v130 = v139;
                        *long long v143 = *v139;
                        if (!v138) {
                          break;
                        }
                        unint64_t v138 = (v138 - 1) >> 1;
                        unint64_t v139 = (int32x2_t *)&v11[2 * v138];
                        int32x2_t v144 = vcgt_s32(v140, *v139);
                        __int8 v145 = (vceq_s32(*v139, v140).u8[0] & 1) != 0 ? v144.i8[4] : v144.i8[0];
                      }
                      while ((v145 & 1) != 0);
                      int32x2_t *v130 = v140;
                    }
                  }
                }
              }
              while (v126-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          unint64_t v15 = &v11[2 * (v13 >> 1)];
          if ((unint64_t)v12 >= 0x401)
          {
            sub_1DC3DA3EC(v9, &v9[2 * (v13 >> 1)], a2 - 2);
            sub_1DC3DA3EC(v9 + 2, v15 - 2, a2 - 4);
            sub_1DC3DA3EC(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            __n128 result = (unint64_t)sub_1DC3DA3EC(v15 - 2, v15, &v9[2 * v14 + 2]);
            uint64_t v16 = *(void *)v9;
            *(void *)unint64_t v9 = *(void *)v15;
            *(void *)unint64_t v15 = v16;
          }
          else
          {
            __n128 result = (unint64_t)sub_1DC3DA3EC(&v9[2 * (v13 >> 1)], v9, a2 - 2);
          }
          --a3;
          if (a4) {
            break;
          }
          int v17 = *(v9 - 2);
          BOOL v5 = v17 == *v9;
          BOOL v18 = v17 < *v9;
          if (v5) {
            BOOL v18 = *(v9 - 1) < v9[1];
          }
          if (v18) {
            break;
          }
          uint64_t v44 = *(void *)v9;
          uint64_t v45 = HIDWORD(*(void *)v9);
          int v46 = *(a2 - 2);
          BOOL v5 = v46 == *(void *)v9;
          BOOL v47 = v46 > (int)*(void *)v9;
          if (v5) {
            BOOL v47 = *(a2 - 1) > (int)v45;
          }
          if (v47)
          {
            int v11 = v9;
            do
            {
              int v48 = v11[2];
              int v49 = v11[3];
              v11 += 2;
              BOOL v50 = v49 > (int)v45;
              BOOL v5 = v48 == v44;
              BOOL v51 = v48 > (int)v44;
              if (v5) {
                BOOL v51 = v50;
              }
            }
            while (!v51);
          }
          else
          {
            int32x2_t v52 = v9 + 2;
            do
            {
              int v11 = v52;
              if (v52 >= a2) {
                break;
              }
              int v53 = *v52;
              BOOL v54 = v11[1] > (int)v45;
              BOOL v5 = v53 == v44;
              BOOL v55 = v53 > (int)v44;
              if (!v5) {
                BOOL v54 = v55;
              }
              int32x2_t v52 = v11 + 2;
            }
            while (!v54);
          }
          int v56 = a2;
          if (v11 < a2)
          {
            int v56 = a2;
            do
            {
              int v57 = *(v56 - 2);
              int v58 = *(v56 - 1);
              v56 -= 2;
              BOOL v59 = v58 > (int)v45;
              BOOL v5 = v57 == v44;
              BOOL v60 = v57 > (int)v44;
              if (v5) {
                BOOL v60 = v59;
              }
            }
            while (v60);
          }
          while (v11 < v56)
          {
            int32x2_t v61 = *(int32x2_t *)v11;
            *(void *)int v11 = *(void *)v56;
            *(int32x2_t *)int v56 = v61;
            do
            {
              int v62 = v11[2];
              int v63 = v11[3];
              v11 += 2;
              BOOL v64 = v63 > (int)v45;
              BOOL v5 = v62 == v44;
              BOOL v65 = v62 > (int)v44;
              if (v5) {
                BOOL v65 = v64;
              }
            }
            while (!v65);
            do
            {
              int v66 = *(v56 - 2);
              int v67 = *(v56 - 1);
              v56 -= 2;
              BOOL v68 = v67 > (int)v45;
              BOOL v5 = v66 == v44;
              BOOL v69 = v66 > (int)v44;
              if (v5) {
                BOOL v69 = v68;
              }
            }
            while (v69);
          }
          int v70 = v11 - 2;
          BOOL v4 = v11 - 2 >= v9;
          BOOL v5 = v11 - 2 == v9;
          if (v11 - 2 != v9) {
            *(void *)unint64_t v9 = *(void *)v70;
          }
          a4 = 0;
          *(void *)int v70 = v44;
        }
        uint64_t v19 = *(void *)v9;
        uint64_t v20 = HIDWORD(*(void *)v9);
        int v21 = v9;
        do
        {
          BOOL v22 = v21;
          int v23 = v21[2];
          v21 += 2;
          BOOL v24 = v23 < (int)v19;
          if (v23 == v19) {
            BOOL v24 = v22[3] < (int)v20;
          }
        }
        while (v24);
        int v25 = a2;
        if (v22 == v9)
        {
          int v25 = a2;
          do
          {
            if (v21 >= v25) {
              break;
            }
            int v30 = *(v25 - 2);
            int v31 = *(v25 - 1);
            v25 -= 2;
            BOOL v32 = v31 < (int)v20;
            BOOL v5 = v30 == v19;
            BOOL v33 = v30 < (int)v19;
            if (v5) {
              BOOL v33 = v32;
            }
          }
          while (!v33);
        }
        else
        {
          do
          {
            int v26 = *(v25 - 2);
            int v27 = *(v25 - 1);
            v25 -= 2;
            BOOL v28 = v27 < (int)v20;
            BOOL v5 = v26 == v19;
            BOOL v29 = v26 < (int)v19;
            if (v5) {
              BOOL v29 = v28;
            }
          }
          while (!v29);
        }
        if (v21 < v25)
        {
          int32x2_t v34 = v21;
          float v35 = v25;
          do
          {
            uint64_t v36 = *(void *)v34;
            *(void *)int32x2_t v34 = *(void *)v35;
            *(void *)float v35 = v36;
            do
            {
              BOOL v22 = v34;
              int v37 = v34[2];
              v34 += 2;
              BOOL v38 = v37 < (int)v19;
              if (v37 == v19) {
                BOOL v38 = v22[3] < (int)v20;
              }
            }
            while (v38);
            do
            {
              int v39 = *(v35 - 2);
              int v40 = *(v35 - 1);
              v35 -= 2;
              BOOL v41 = v40 < (int)v20;
              BOOL v5 = v39 == v19;
              BOOL v42 = v39 < (int)v19;
              if (v5) {
                BOOL v42 = v41;
              }
            }
            while (!v42);
          }
          while (v34 < v35);
        }
        if (v22 != v9) {
          *(void *)unint64_t v9 = *(void *)v22;
        }
        *(void *)BOOL v22 = v19;
        if (v21 >= v25) {
          break;
        }
LABEL_43:
        __n128 result = sub_1DC3D9AC8(v9, v22, a3, a4 & 1);
        a4 = 0;
        int v11 = v22 + 2;
      }
      BOOL v43 = sub_1DC3DA598(v9, v22);
      int v11 = v22 + 2;
      __n128 result = sub_1DC3DA598(v22 + 2, a2);
      if (result) {
        break;
      }
      if (!v43) {
        goto LABEL_43;
      }
    }
    a2 = v22;
    if (!v43) {
      continue;
    }
    return result;
  }
}

int *sub_1DC3DA3EC(int *result, int *a2, _DWORD *a3)
{
  int v3 = *a2;
  int v4 = a2[1];
  BOOL v5 = *a2 < *result;
  if (*a2 == *result) {
    BOOL v5 = v4 < result[1];
  }
  BOOL v6 = a3[1] < v4;
  BOOL v7 = *a3 == v3;
  BOOL v8 = *a3 < v3;
  if (!v7) {
    BOOL v6 = v8;
  }
  if (v5)
  {
    uint64_t v9 = *(void *)result;
    if (v6)
    {
      *(void *)__n128 result = *(void *)a3;
LABEL_17:
      *(void *)a3 = v9;
      return result;
    }
    *(void *)__n128 result = *(void *)a2;
    *(void *)a2 = v9;
    BOOL v13 = *a3 < (int)v9;
    if (*a3 == v9) {
      BOOL v13 = a3[1] < SHIDWORD(v9);
    }
    if (v13)
    {
      *(void *)a2 = *(void *)a3;
      goto LABEL_17;
    }
  }
  else if (v6)
  {
    uint64_t v10 = *(void *)a2;
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v10;
    BOOL v11 = *a2 < *result;
    if (*a2 == *result) {
      BOOL v11 = a2[1] < result[1];
    }
    if (v11)
    {
      uint64_t v12 = *(void *)result;
      *(void *)__n128 result = *(void *)a2;
      *(void *)a2 = v12;
    }
  }
  return result;
}

int *sub_1DC3DA4C4(int *a1, int *a2, int *a3, int *a4)
{
  __n128 result = sub_1DC3DA3EC(a1, a2, a3);
  BOOL v9 = *a4 < *a3;
  if (*a4 == *a3) {
    BOOL v9 = a4[1] < a3[1];
  }
  if (v9)
  {
    uint64_t v10 = *(void *)a3;
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v10;
    BOOL v11 = *a3 < *a2;
    if (*a3 == *a2) {
      BOOL v11 = a3[1] < a2[1];
    }
    if (v11)
    {
      uint64_t v12 = *(void *)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v12;
      BOOL v13 = *a2 < *a1;
      if (*a2 == *a1) {
        BOOL v13 = a2[1] < a1[1];
      }
      if (v13)
      {
        uint64_t v14 = *(void *)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v14;
      }
    }
  }
  return result;
}

BOOL sub_1DC3DA598(int *a1, int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *(a2 - 2);
      BOOL v7 = v6 == *a1;
      BOOL v8 = v6 < *a1;
      if (v7) {
        BOOL v8 = *(a2 - 1) < a1[1];
      }
      if (v8)
      {
        uint64_t v9 = *(void *)a1;
        *(void *)a1 = *((void *)a2 - 1);
        *((void *)a2 - 1) = v9;
      }
      return result;
    case 3:
      sub_1DC3DA3EC(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      sub_1DC3DA4C4(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      sub_1DC3DA4C4(a1, a1 + 2, a1 + 4, a1 + 6);
      int v23 = *(a2 - 2);
      int v24 = a1[6];
      BOOL v7 = v23 == v24;
      BOOL v25 = v23 < v24;
      if (v7) {
        BOOL v25 = *(a2 - 1) < a1[7];
      }
      if (v25)
      {
        uint64_t v26 = *((void *)a1 + 3);
        *((void *)a1 + 3) = *((void *)a2 - 1);
        *((void *)a2 - 1) = v26;
        LODWORD(v26) = a1[6];
        int v27 = a1[4];
        BOOL v7 = v26 == v27;
        BOOL v28 = (int)v26 < v27;
        if (v7) {
          BOOL v28 = a1[7] < a1[5];
        }
        if (v28)
        {
          uint64_t v30 = *((void *)a1 + 2);
          uint64_t v29 = *((void *)a1 + 3);
          *((void *)a1 + 2) = v29;
          *((void *)a1 + 3) = v30;
          int v31 = a1[2];
          BOOL v7 = v31 == v29;
          BOOL v32 = v31 > (int)v29;
          if (v7) {
            BOOL v32 = a1[3] > SHIDWORD(v29);
          }
          if (v32)
          {
            uint64_t v33 = *((void *)a1 + 1);
            *((void *)a1 + 1) = v29;
            *((void *)a1 + 2) = v33;
            BOOL v34 = a1[1] > SHIDWORD(v29);
            if (*a1 != v29) {
              BOOL v34 = *a1 > (int)v29;
            }
            if (v34)
            {
              uint64_t v35 = *(void *)a1;
              *(void *)a1 = v29;
              *((void *)a1 + 1) = v35;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v10 = a1 + 4;
      sub_1DC3DA3EC(a1, a1 + 2, a1 + 4);
      BOOL v11 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    BOOL v14 = *v11 < *v10;
    if (*v11 == *v10) {
      BOOL v14 = v11[1] < v10[1];
    }
    if (v14)
    {
      uint64_t v15 = *(void *)v11;
      uint64_t v16 = HIDWORD(*(void *)v11);
      uint64_t v17 = v12;
      while (1)
      {
        BOOL v18 = (char *)a1 + v17;
        *(void *)((char *)a1 + v17 + 24) = *(void *)((char *)a1 + v17 + 16);
        if (v17 == -16) {
          break;
        }
        int v19 = *((_DWORD *)v18 + 2);
        BOOL v20 = *((_DWORD *)v18 + 3) > (int)v16;
        BOOL v7 = v19 == v15;
        BOOL v21 = v19 > (int)v15;
        if (!v7) {
          BOOL v20 = v21;
        }
        v17 -= 8;
        if (!v20)
        {
          BOOL v22 = (int *)((char *)a1 + v17 + 24);
          goto LABEL_19;
        }
      }
      BOOL v22 = a1;
LABEL_19:
      *(void *)BOOL v22 = v15;
      if (++v13 == 8) {
        return v11 + 2 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 8;
    v11 += 2;
    if (v11 == a2) {
      return 1;
    }
  }
}

void sub_1DC3DA818(uint64_t a1, unsigned int a2, unint64_t *a3)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 32) <= (signed int)a2)
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DC32BA6C(exception, "Requested row is outside the image");
    __cxa_throw(exception, (struct type_info *)off_1E6C39918, MEMORY[0x1E4FBA1D0]);
  }
  unint64_t v6 = *(int *)(a1 + 36);
  unint64_t v7 = *a3;
  unint64_t v8 = a3[1];
  unint64_t v9 = v8 - *a3;
  if (v6 <= v9)
  {
    if (v6 < v9)
    {
      unint64_t v8 = v7 + v6;
      a3[1] = v7 + v6;
    }
  }
  else
  {
    sub_1DC3D9108(a3, v6 - v9);
    unint64_t v7 = *a3;
    unint64_t v8 = a3[1];
  }
  if (v8 != v7)
  {
    unint64_t v10 = 0;
    do
    {
      *(unsigned char *)(v7 + v10) = *(unsigned char *)(**(void **)(a1 + 8)
                                      + *(int *)(a1 + 40) * (uint64_t)((int)v10 + *(_DWORD *)(a1 + 28))
                                      + *(int *)(a1 + 24)
                                      + a2);
      ++v10;
      unint64_t v7 = *a3;
    }
    while (a3[1] - *a3 > v10);
  }
}

void sub_1DC3DA90C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DC3DA920(uint64_t a1, int a2, unint64_t *a3, int a4)
{
  if (a2 < 0 || *(_DWORD *)(a1 + 36) <= a2)
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DC32BA6C(exception, "Requested row is outside the image");
    __cxa_throw(exception, (struct type_info *)off_1E6C39918, MEMORY[0x1E4FBA1D0]);
  }
  BOOL v5 = (const void *)(**(void **)(a1 + 8) + (*(int *)(a1 + 28) + (uint64_t)a2) * *(int *)(a1 + 40) + *(int *)(a1 + 24));
  if (a4)
  {
    int v7 = *(_DWORD *)(a1 + 32);
    unint64_t v8 = (void *)*a3;
    unint64_t v9 = a3[1] - *a3;
    if (v7 <= v9)
    {
      if (v7 < v9) {
        a3[1] = (unint64_t)v8 + v7;
      }
    }
    else
    {
      sub_1DC3D9108(a3, v7 - v9);
      int v7 = *(_DWORD *)(a1 + 32);
      unint64_t v8 = (void *)*a3;
    }
    if (v7)
    {
      memmove(v8, v5, v7);
      return (void *)*a3;
    }
    else
    {
      return v8;
    }
  }
  return (void *)v5;
}

void sub_1DC3DAA0C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3DAA20(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_1DC3DAA28(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

void sub_1DC3DAA30(void *a1)
{
  *a1 = &unk_1F3660E08;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_1DC32EEF4(v1);
  }
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3DAA9C(void *a1)
{
  *a1 = &unk_1F3660E08;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_1DC32EEF4(v2);
  }
  return a1;
}

void *sub_1DC3DAAE8(int *a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= 0) {
    int v8 = a2;
  }
  else {
    int v8 = a2 + 1;
  }
  int v9 = v8 >> 1;
  int v10 = a2 - (v8 >> 1);
  if (*(_DWORD *)a3 < v10)
  {
    BOOL v11 = *(void **)(a3 + 8);
    if (v11) {
      free(v11);
    }
    *(void *)(a3 + 8) = malloc_type_malloc(4 * v10, 0x100004052888210uLL);
  }
  BOOL result = *(void **)(a4 + 8);
  if (*(_DWORD *)a4 < v9)
  {
    if (result) {
      free(result);
    }
    BOOL result = malloc_type_malloc(4 * v9, 0x100004052888210uLL);
    *(void *)(a4 + 8) = result;
  }
  *(_DWORD *)a3 = v10;
  *(_DWORD *)a4 = v9;
  if (a2 >= 1)
  {
    int v13 = 0;
    int v14 = 0;
    uint64_t v15 = *(_DWORD **)(a3 + 8);
    char v16 = 1;
    uint64_t v17 = a2;
    do
    {
      int v18 = *a1++;
      int v19 = v18;
      if (v16) {
        int v20 = v14;
      }
      else {
        int v20 = v13;
      }
      if (v16) {
        BOOL v21 = v15;
      }
      else {
        BOOL v21 = result;
      }
      if (v16) {
        ++v14;
      }
      else {
        ++v13;
      }
      v21[v20] = v19;
      v16 ^= 1u;
      --v17;
    }
    while (v17);
  }
  return result;
}

uint64_t sub_1DC3DABE8(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(int *)(a1 + 12);
  if (v3 <= (int)v4) {
    return 15;
  }
  int v5 = v3 - v4 + 1;
  if (v5 < 41) {
    return 16;
  }
  int v10 = (float *)(*(void *)a1 + 4 * v4);
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  int v11 = sub_1DC3A0718((uint64_t)&v28, v10, v5, 0.5);
  uint64_t v12 = *(int **)(a2 + 64);
  int v13 = *v12;
  BOOL v14 = *v12 != a3;
  int *v12 = a3;
  uint64_t v6 = sub_1DC3DADC4((int *)v29, v11, a2, v14, (uint64_t)v10, v5);
  if (v6 >= 2)
  {
    float v22 = *(float *)(*(void *)(a2 + 64) + 24);
    if (v22 <= 0.5)
    {
      float v22 = 0.5;
      if ((float)((float)v5 / 104.5) > 0.5) {
        float v22 = (float)v5 / 104.5;
      }
    }
    int v23 = 2 * v11;
    int v24 = 3;
    do
    {
      int v25 = sub_1DC3A0948((uint64_t)&v28, v22);
      if (v25 < 1 || v25 > v23) {
        break;
      }
      uint64_t v6 = sub_1DC3DADC4((int *)v29, v25, a2, v13 != a3, (uint64_t)v10, v5);
      if (v6 <= 1) {
        goto LABEL_6;
      }
      --v24;
    }
    while (v24);
    sub_1DC3A0B9C((uint64_t)&v28);
  }
  else
  {
LABEL_6:
    sub_1DC3A0B9C((uint64_t)&v28);
    float v15 = *(float *)(a2 + 72);
    float v16 = *(float *)(a2 + 76);
    if (v15 <= v16) {
      float v17 = *(float *)(a2 + 76);
    }
    else {
      float v17 = *(float *)(a2 + 72);
    }
    BOOL v18 = v16 <= 0.0 || v15 <= 0.0;
    float v19 = (float)(v15 + v16) * 0.5;
    if (v18) {
      float v19 = v17;
    }
    uint64_t v20 = *(void *)(a2 + 64);
    *(float *)(v20 + 24) = v19;
    sub_1DC3D5788((int *)v20, *(void *)(a1 + 80));
    *(float *)v21.i32 = (float)*(int *)(a1 + 12);
    *(float32x2_t *)(a1 + 20) = vadd_f32(*(float32x2_t *)(*(void *)(a2 + 64) + 48), (float32x2_t)vdup_lane_s32(v21, 0));
  }
  return v6;
}

uint64_t sub_1DC3DADC4(int *a1, int a2, uint64_t a3, int a4, uint64_t a5, signed int a6)
{
  if (a2 < 2 * *(_DWORD *)(*(void *)(a3 + 64) + 20)) {
    return 16;
  }
  int v7 = (float *)a1;
  unsigned int v8 = (int)(float)(*(float *)a1 + -0.5);
  if ((v8 & 0x80000000) != 0) {
    return 15;
  }
  uint64_t v6 = 15;
  if ((int)(v8 + 1) < a6)
  {
    int v11 = a2 - 1;
    unsigned int v12 = (int)(float)(*(float *)&a1[a2 - 1] + -0.5);
    if ((v12 & 0x80000000) == 0 && (int)(v12 + 1) < a6)
    {
      float v16 = *(float *)(a5 + 4 * v12);
      float v17 = *(float *)(a5 + 4 * (v12 + 1));
      BOOL v18 = *(float *)(a5 + 4 * v8) < *(float *)(a5 + 4 * (v8 + 1));
      uint64_t v30 = 0;
      long long v31 = 0;
      uint64_t v28 = 0;
      long long v29 = 0;
      sub_1DC3DAAE8(a1, a2, (uint64_t)&v30, (uint64_t)&v28);
      float v19 = v31;
      uint64_t v20 = v29;
      uint64_t v6 = sub_1DC3DAFD0(v30, (uint64_t)v31, v28, (uint64_t)v29, a3, a5, a6, v18);
      if (v6 > 1)
      {
        if (a4)
        {
          int32x2_t v21 = (int *)malloc_type_malloc(4 * a2, 0x100004052888210uLL);
          float v22 = v21;
          if (a2 >= 1)
          {
            uint64_t v23 = a2;
            int v24 = (float *)&v21[v11];
            do
            {
              float v25 = *v7++;
              *v24-- = -v25;
              --v23;
            }
            while (v23);
          }
          sub_1DC3DAAE8(v21, a2, (uint64_t)&v30, (uint64_t)&v28);
          free(v22);
          float v19 = v31;
          uint64_t v20 = v29;
          uint64_t v6 = sub_1DC3DAFD0(v30, (uint64_t)v31, v28, (uint64_t)v29, a3, a5, a6, v16 > v17);
          if (v6 < 2)
          {
            uint64_t v26 = *(float32x2_t **)(a3 + 64);
            v26[3].i8[4] = 1;
            v26[6] = vneg_f32(v26[6]);
          }
        }
      }
      else
      {
        *(unsigned char *)(*(void *)(a3 + 64) + 28) = 0;
      }
      if (v19) {
        free(v19);
      }
      if (v20) {
        free(v20);
      }
    }
  }
  return v6;
}

uint64_t sub_1DC3DAFD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int a8)
{
  unint64_t v8 = a3;
  int v9 = *(_DWORD *)(*(void *)(a5 + 64) + 20);
  if (v9 > (int)a3) {
    return 16;
  }
  char v11 = a8;
  float v15 = (float *)a4;
  float v16 = (float *)a2;
  uint64_t v17 = a1;
  uint64_t result = sub_1DC3D619C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    if (result == 1) {
      return result;
    }
    BOOL v18 = *(float **)(a5 + 64);
  }
  else
  {
    BOOL v18 = *(float **)(a5 + 64);
    int v19 = *((_DWORD *)v18 + 11);
    if (v19 < 3 || (float)(v16[(int)v17 - v19 + 2] - v18[13]) >= (float)(*(float *)(a5 + 76) * 10.0)) {
      return 0;
    }
  }
  float v20 = *v18;
  *(_DWORD *)v18 &= 0xFFFE9FFF;
  if ((LODWORD(v20) & 0xFFFE9FFF) != 0)
  {
    float v29 = v20;
    long long v31 = v15;
    uint64_t v32 = a6;
    unsigned int v33 = a7;
    uint64_t v30 = v16;
    if (*((unsigned char *)v18 + 30)) {
      int v21 = 5;
    }
    else {
      int v21 = 65;
    }
    unsigned int v22 = 1;
    uint64_t v23 = v17;
    while ((int)v17 > v9)
    {
      int v24 = v16;
      uint64_t v25 = v8;
      float v16 = v15;
      float v15 = v24 + 1;
      v11 ^= 1u;
      unint64_t v8 = v23 & 0xFFFFFFFF00000000 | (v17 - 1);
      LODWORD(v17) = v25;
      if (v22 < 5) {
        goto LABEL_29;
      }
      uint64_t v26 = &v31[(v22 >> 1) - 3];
      if (v22) {
        uint64_t v26 = &v30[(v22 >> 1) - 2];
      }
      if ((float)(*v16 - *v26) >= (float)((float)((float)(v15[v9 - 1] - *v16) / (float)(3 * v9)) * 10.0))
      {
LABEL_29:
        uint64_t result = sub_1DC3D619C(v25, (uint64_t)v16, v8, (uint64_t)(v24 + 1), a5, v32, v33, v11 & 1);
        if (!result)
        {
          uint64_t v27 = *(void *)(a5 + 64);
          int v28 = *(_DWORD *)(v27 + 44);
          if (v28 < 3)
          {
            uint64_t result = 0;
            break;
          }
          uint64_t result = 0;
          if ((float)(v16[(int)v25 - v28 + 2] - *(float *)(v27 + 52)) >= (float)(*(float *)(a5 + 76) * 10.0)) {
            break;
          }
        }
      }
      ++v22;
      uint64_t v23 = v25;
      if (v21 == v22) {
        break;
      }
    }
    BOOL v18 = *(float **)(a5 + 64);
    float v20 = v29;
  }
  *BOOL v18 = v20;
  return result;
}

float sub_1DC3DB208(float *a1, int a2, float *a3, float *a4, int a5, int a6)
{
  float v6 = 3.0;
  if (!a6) {
    float v6 = 2.0;
  }
  if (a2 < 1)
  {
    float result = 3.4028e38;
    float v15 = 0.0;
    float v14 = 0.0;
    if ((float)(v6 * 3.4028e38) < 1.1755e-38) {
      return result;
    }
  }
  else
  {
    float v7 = 3.4028e38;
    float v8 = 1.1755e-38;
    int v9 = a1;
    uint64_t v10 = a2;
    do
    {
      float v11 = *v9++;
      float v12 = v11;
      if (v7 >= v11) {
        float v7 = v12;
      }
      if (v8 <= v12) {
        float v8 = v12;
      }
      --v10;
    }
    while (v10);
    if (v8 > (float)(v6 * v7)) {
      return 3.4028e38;
    }
    uint64_t v13 = 0;
    float v14 = 0.0;
    float v15 = 0.0;
    do
    {
      float v16 = a1[v13];
      float v15 = v15 + v16;
      if (v13) {
        float v16 = -v16;
      }
      float v14 = v14 + v16;
      ++v13;
    }
    while (a2 != v13);
  }
  float v18 = v15 / (float)a2;
  float v19 = (float)-(float)(v14 - (float)((float)a2 * v15)) / (float)(a2 * a2 - 1);
  float v20 = v14 - v19;
  if (a2)
  {
    float v21 = v19;
  }
  else
  {
    float v20 = v14;
    float v21 = v18;
  }
  float v22 = v20 / (float)(2 * a2);
  *a3 = v21;
  float v23 = -v22;
  if (a5) {
    float v23 = v22;
  }
  *a4 = v23;
  float v24 = *a3;
  if (fabsf(v22) > (float)(*a3 * 0.2)) {
    return 3.4028e38;
  }
  float v25 = (float)(v24 * 0.4) + 0.5;
  if (!a6) {
    float v25 = v24 * 0.4;
  }
  float result = 0.0;
  if (a2 >= 1)
  {
    uint64_t v26 = a2;
    uint64_t v27 = a2;
    for (uint64_t i = a1; vabds_f32(*i, v24) <= v25; ++i)
    {
      if (!--v27) {
        return result;
      }
    }
    float v29 = 0.0;
    do
    {
      float v30 = *a1++;
      float v31 = v30;
      if (a5) {
        float v32 = -v23;
      }
      else {
        float v32 = v23;
      }
      float v29 = v29
          + (float)((float)((float)((float)(v31 + (float)(v32 * 2.0)) / v24) + -1.0)
                  * (float)((float)((float)(v31 + (float)(v32 * 2.0)) / v24) + -1.0));
      LOBYTE(a5) = a5 ^ 1;
      --v26;
    }
    while (v26);
    return v29 / (float)a2;
  }
  return result;
}

BOOL sub_1DC3DB3C4(uint64_t a1, float *a2, uint64_t a3, float *a4, int a5)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (a5)
  {
    if (a5 == 1)
    {
      float v8 = 67.0;
      uint64_t v9 = 21;
    }
    else
    {
      if (a5 != 2) {
        return 0;
      }
      float v8 = 51.0;
      uint64_t v9 = 16;
    }
  }
  else
  {
    float v8 = 95.0;
    uint64_t v9 = 29;
  }
  uint64_t v10 = 0;
  float v11 = &a4[v9];
  float v12 = *v11 - *a2;
  uint64_t v13 = a4;
  float v14 = a2;
  do
  {
    float v15 = v13;
    v44[v10++] = *v13 - *v14;
    uint64_t v13 = v14 + 1;
    float v14 = v15;
  }
  while (v10 != 4);
  float v16 = v12 / v8;
  float v17 = v45[0];
  uint64_t v43 = 0;
  float v18 = sub_1DC3DB208(v44, 3, (float *)&v43 + 1, (float *)&v43, 1, (float)(v12 / v8) < 5.0);
  BOOL result = 0;
  if (v18 > 0.01) {
    return result;
  }
  float v20 = v16 * 0.5;
  if (vabds_f32(*((float *)&v43 + 1), v16) > (float)(v16 * 0.5)) {
    return 0;
  }
  float v21 = *(float *)&v43;
  float v22 = v17 + (float)(*(float *)&v43 * 2.0);
  float v23 = (float)(*((float *)&v43 + 1) * 0.5) + 0.5;
  if (v16 >= 5.0) {
    float v23 = *((float *)&v43 + 1) * 0.5;
  }
  if (v22 < (float)(*((float *)&v43 + 1) - v23)) {
    return 0;
  }
  int v24 = a5 == 2 ? 4 : 3;
  if (v22 > (float)(v23 + (float)((float)v24 * *((float *)&v43 + 1)))) {
    return 0;
  }
  if (a5 == 2)
  {
    unsigned int v25 = 6;
    unsigned int v26 = 3;
  }
  else
  {
    uint64_t v37 = 13;
    if (a5) {
      uint64_t v37 = 9;
    }
    BOOL v38 = &a4[v37];
    int v39 = &a2[v37];
    for (uint64_t i = 3; i != 8; ++i)
    {
      BOOL v41 = v39 + 1;
      v44[i] = v39[1] - *v38;
      int v39 = v38;
      BOOL v38 = v41;
    }
    uint64_t v42 = 0;
    if (sub_1DC3DB208(v45, 5, (float *)&v42 + 1, (float *)&v42, 0, v16 < 5.0) > 0.01
      || vabds_f32(*((float *)&v42 + 1), v16) > v20
      || vabds_f32(*(float *)&v42, v21) > (float)(v16 * 0.3))
    {
      return 0;
    }
    unsigned int v25 = 3;
    unsigned int v26 = 8;
  }
  uint64_t v27 = &a2[v9];
  uint64_t v28 = v25 + 1;
  uint64_t v29 = v26;
  do
  {
    float v30 = v27;
    uint64_t v31 = v29++;
    v44[v31] = *v11 - *v27;
    uint64_t v27 = v11 - 1;
    float v11 = v30;
    --v28;
  }
  while (v28);
  float v32 = v44[(int)v31];
  uint64_t v42 = 0;
  float v33 = sub_1DC3DB208(&v44[v26], v31 - v26, (float *)&v42 + 1, (float *)&v42, 1, v16 < 5.0);
  BOOL result = 0;
  if (v33 > 0.01) {
    return result;
  }
  if (vabds_f32(*((float *)&v42 + 1), v16) > v20) {
    return 0;
  }
  float v34 = *(float *)&v42;
  if (vabds_f32(*(float *)&v42, v21) > (float)(v16 * 0.3)) {
    return 0;
  }
  if ((v25 & 1) == 0) {
    float v34 = -*(float *)&v42;
  }
  float v35 = v32 + (float)(v34 * 2.0);
  float v36 = (float)(*((float *)&v42 + 1) * 0.5) + 0.5;
  if (v16 >= 5.0) {
    float v36 = *((float *)&v42 + 1) * 0.5;
  }
  return v35 <= (float)(v36 + (float)(*((float *)&v42 + 1) * 4.0)) && v35 >= (float)(*((float *)&v42 + 1) - v36);
}

void sub_1DC3DB738(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, float *a6, double a7, double a8, int32x2_t a9)
{
  uint64_t v9 = a6;
  uint64_t v10 = a5;
  uint64_t v11 = 0;
  uint64_t v143 = *MEMORY[0x1E4F143B8];
  float v12 = *(float *)(a3 + 4);
  float v13 = *(float *)(a4 + 4);
  float v14 = v12 - *(float *)a4;
  float v136 = *(float *)a4 - *(float *)a3;
  float v137 = v14;
  int v15 = a2[1];
  uint64_t v16 = *a2;
  int v17 = a2[2];
  float v138 = v13 - v12;
  float v18 = 0.0;
  uint64_t v19 = 1;
  uint64_t v20 = 4;
  do
  {
    float v21 = *(&v136 + v11);
    uint64_t v22 = v20;
    do
    {
      float v23 = *(float *)((char *)&v136 + v22);
      BOOL v122 = v21 <= v23;
      float v24 = v23 / v21;
      float v25 = v21 / v23;
      if (v122) {
        float v25 = v24;
      }
      if (v18 <= v25) {
        float v18 = v25;
      }
      v22 += 4;
    }
    while (v22 != 12);
    ++v19;
    v20 += 4;
    uint64_t v11 = 1;
  }
  while (v19 != 3);
  if (v18 >= 1.0) {
    float v26 = v18;
  }
  else {
    float v26 = 100.0;
  }
  if (v17 < 1)
  {
    uint64_t v69 = 0;
    v70.i64[0] = *(void *)(a4 + 52);
    v71.i64[0] = *(void *)(a3 + 56);
    v70.i64[1] = v71.i64[0];
    v71.i32[2] = vdup_lane_s32(*(int32x2_t *)v70.f32, 1).u32[0];
    float v72 = *(float *)(a4 + 60);
    v71.f32[3] = v72;
    float32x2x2_t v73 = (float32x2x2_t)vsubq_f32(v71, v70);
    unint64_t v74 = vextq_s8((int8x16_t)v73, (int8x16_t)v73, 8uLL).u64[0];
    int v75 = &v136;
    vst2_f32(v75, v73);
    v75 += 4;
    v70.i32[0] = *(_DWORD *)(a3 + 64);
    *int v75 = v70.f32[0] - v72;
    float v139 = *(float *)(a4 + 64) - v70.f32[0];
    float v76 = 0.0;
    uint64_t v77 = 4;
    do
    {
      float v78 = *(&v136 + v69);
      uint64_t v79 = v77;
      do
      {
        float v80 = *(float *)((char *)&v136 + v79);
        BOOL v122 = v78 <= v80;
        float v81 = v80 / v78;
        float v82 = v78 / v80;
        if (v122) {
          float v82 = v81;
        }
        if (v76 <= v82) {
          float v76 = v82;
        }
        v79 += 4;
      }
      while (v79 != 24);
      ++v69;
      v77 += 4;
    }
    while (v69 != 5);
    if (v76 < 1.0) {
      float v76 = 100.0;
    }
    if (v26 <= v76)
    {
      uint64_t v83 = 0;
      float v62 = 0.0;
      uint64_t v84 = 4;
      do
      {
        float v85 = *(&v136 + v83);
        uint64_t v86 = v84;
        do
        {
          float v87 = *(float *)((char *)&v136 + v86);
          BOOL v122 = v85 <= v87;
          float v88 = v87 / v85;
          float v89 = v85 / v87;
          if (v122) {
            float v89 = v88;
          }
          if (v62 <= v89) {
            float v62 = v89;
          }
          v86 += 4;
        }
        while (v86 != 24);
        ++v83;
        v84 += 4;
      }
      while (v83 != 5);
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v27 = 0;
    uint64_t v28 = 4 * (2 * v15 + 2);
    float32x2_t v29 = *(float32x2_t *)(a3 + v28);
    float32x2_t v30 = *(float32x2_t *)(a4 + v28);
    a9.i32[0] = *(_DWORD *)(a4 + 4 * ((2 * v15) | 1));
    v144.val[0] = vsub_f32(v29, (float32x2_t)vzip1_s32(a9, (int32x2_t)v30));
    v144.val[1] = vsub_f32(v30, v29);
    uint64_t v31 = &v136;
    vst2_f32(v31, v144);
    v31 += 4;
    *uint64_t v31 = *(float *)(a3 + 4 * (2 * v15 + 4)) - v30.f32[1];
    float v32 = 0.0;
    uint64_t v33 = 4;
    do
    {
      float v34 = *(&v136 + v27);
      uint64_t v35 = v33;
      do
      {
        float v36 = *(float *)((char *)&v136 + v35);
        BOOL v122 = v34 <= v36;
        float v37 = v36 / v34;
        float v38 = v34 / v36;
        if (v122) {
          float v38 = v37;
        }
        if (v32 <= v38) {
          float v32 = v38;
        }
        v35 += 4;
      }
      while (v35 != 20);
      ++v27;
      v33 += 4;
    }
    while (v27 != 4);
    int v39 = 2 * (v15 + 2 + v17);
    if (v32 < 1.0) {
      float v32 = 100.0;
    }
    if (v26 <= v32)
    {
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      float v42 = 0.0;
      do
      {
        float v43 = *(&v136 + v41);
        uint64_t v44 = v40;
        do
        {
          float v45 = *(float *)((char *)&v137 + v44);
          BOOL v122 = v43 <= v45;
          float v46 = v45 / v43;
          float v47 = v43 / v45;
          if (v122) {
            float v47 = v46;
          }
          if (v42 <= v47) {
            float v42 = v47;
          }
          v44 += 4;
        }
        while (v44 != 16);
        ++v41;
        v40 += 4;
      }
      while (v41 != 4);
      if (v42 >= 1.0) {
        float v26 = v42;
      }
      else {
        float v26 = 100.0;
      }
    }
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    float v50 = *(float *)(a4 + 4 * v39);
    uint64_t v51 = (8 * (v15 + 2 + v17)) | 4;
    float v52 = *(float *)(a3 + v51);
    float v136 = v50 - *(float *)(a3 + 4 * v39);
    float v137 = v52 - v50;
    float v138 = *(float *)(a4 + v51) - v52;
    float v53 = 0.0;
    for (uint64_t i = 1; i != 3; ++i)
    {
      float v55 = *(&v136 + v49);
      uint64_t v56 = v48;
      do
      {
        float v57 = *(float *)((char *)&v137 + v56);
        BOOL v122 = v55 <= v57;
        float v58 = v57 / v55;
        float v59 = v55 / v57;
        if (v122) {
          float v59 = v58;
        }
        if (v53 <= v59) {
          float v53 = v59;
        }
        v56 += 4;
      }
      while (v56 != 8);
      v48 += 4;
      uint64_t v49 = 1;
    }
    if (v53 < 1.0) {
      float v53 = 100.0;
    }
    if (v26 <= v53)
    {
      uint64_t v60 = 0;
      uint64_t v61 = 0;
      float v62 = 0.0;
      for (uint64_t j = 1; j != 3; ++j)
      {
        float v64 = *(&v136 + v61);
        uint64_t v65 = v60;
        do
        {
          float v66 = *(float *)((char *)&v137 + v65);
          BOOL v122 = v64 <= v66;
          float v67 = v66 / v64;
          float v68 = v64 / v66;
          if (v122) {
            float v68 = v67;
          }
          if (v62 <= v68) {
            float v62 = v68;
          }
          v65 += 4;
        }
        while (v65 != 8);
        v60 += 4;
        uint64_t v61 = 1;
      }
LABEL_74:
      if (v62 >= 1.0) {
        float v26 = v62;
      }
      else {
        float v26 = 100.0;
      }
    }
  }
  uint64_t v133 = 0;
  int v90 = v15 + v16;
  if (v15 < 1)
  {
    LODWORD(v91) = 0;
    float v97 = 0.0;
    float v100 = INFINITY;
    uint64_t v110 = 2;
    float v98 = INFINITY;
  }
  else
  {
    int v127 = v17;
    uint64_t v91 = 0;
    int v126 = v15 + v16;
    uint64_t v92 = v90;
    uint64_t v93 = a1 + v16;
    uint64_t v94 = a5 + v16;
    uint64_t v128 = a4;
    uint64_t v129 = a3;
    int v95 = (float *)(a3 + 12);
    BOOL v96 = (float *)(a4 + 12);
    float v97 = 0.0;
    float v98 = INFINITY;
    int v99 = 2;
    float v100 = INFINITY;
    do
    {
      float v101 = v100;
      float v102 = *(v96 - 1);
      float v103 = 1.0 / (float)(*v96 - *(v96 - 2));
      float v105 = *(v95 - 1);
      float v104 = *v95;
      float v106 = v103 * (float)(*v96 - v102);
      float v140 = v103 * (float)((float)(*v96 + v102) - (float)(*v95 + v105));
      float v141 = v106;
      float v142 = v103 * (float)(v104 - v105);
      sub_1DC3DDD2C(20, 3u, 6u, v135, v134, &v140, flt_1DC416CE4, (_DWORD *)&v133 + 1, (float *)&v133);
      float v97 = v97 + *(float *)&v133;
      if (*(float *)&v133 <= v98) {
        float v107 = *(float *)&v133;
      }
      else {
        float v107 = v98;
      }
      if (*(float *)&v133 > v100)
      {
        float v98 = v107;
      }
      else
      {
        float v100 = *(float *)&v133;
        float v98 = v101;
      }
      char v108 = BYTE4(v133);
      BOOL v109 = SHIDWORD(v133) > 9;
      if (SHIDWORD(v133) > 9) {
        char v108 = BYTE4(v133) - 10;
      }
      *(unsigned char *)(v93 + v91) = v108;
      *(unsigned char *)(v94 + v91) = v109;
      v99 += 2;
      ++v91;
      v95 += 2;
      v96 += 2;
    }
    while (v16 + v91 < v92);
    uint64_t v110 = v99 & 0xFFFFFFFE;
    uint64_t v10 = a5;
    uint64_t v9 = a6;
    a4 = v128;
    a3 = v129;
    int v17 = v127;
    int v90 = v126;
  }
  if (v17 < 1)
  {
    float v120 = v100;
  }
  else
  {
    uint64_t v111 = v90;
    uint64_t v112 = v90 + v17;
    __int8 v113 = (float *)(a4 + 4 * v110 + 12);
    __int32 v114 = (float *)(a3 + 4 * v110 + 16);
    do
    {
      float v115 = *(v114 - 1);
      float v116 = *(v114 - 2);
      float v117 = 1.0 / (float)(*v114 - v116);
      float v118 = *(v113 - 1);
      float v119 = *v113;
      float v140 = v117 * (float)((float)(v118 + *v113) - (float)(v116 + v115));
      float v141 = v117 * (float)(v115 - v116);
      float v142 = v117 * (float)(v119 - v118);
      sub_1DC3DDD2C(10, 3u, 5u, v135, v134, &v140, flt_1DC416F74, (_DWORD *)&v133 + 1, (float *)&v133);
      float v120 = *(float *)&v133;
      float v97 = v97 + *(float *)&v133;
      if (*(float *)&v133 <= v98) {
        float v121 = *(float *)&v133;
      }
      else {
        float v121 = v98;
      }
      BOOL v122 = *(float *)&v133 > v100;
      if (*(float *)&v133 > v100) {
        float v120 = v100;
      }
      *(unsigned char *)(a1 + v111) = BYTE4(v133);
      *(unsigned char *)(v10 + v111++) = 0;
      v113 += 2;
      if (v122) {
        float v98 = v121;
      }
      else {
        float v98 = v100;
      }
      v114 += 2;
      LODWORD(v91) = v91 + 1;
      float v100 = v120;
    }
    while (v111 < v112);
  }
  float v123 = (float)((float)(v98 * 0.3) + (float)(v120 * 0.55)) + (float)((float)(v97 / (float)(int)v91) * 0.15);
  float v124 = 0.0;
  if (v26 >= 2.0) {
    float v124 = (float)(2.0 - v26) * 0.1;
  }
  float v125 = v124 + v123;
  if (v125 > 1.0) {
    float v125 = 1.0;
  }
  *uint64_t v9 = v125;
}

uint64_t sub_1DC3DBE3C(uint64_t a1, uint64_t a2, unsigned __int8 *a3, float *a4, double a5, double a6, int32x2_t a7)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  sub_1DC3DB738((uint64_t)a3, dword_1DC4169A4, a1, a2, (uint64_t)v13, a4, a5, a6, a7);
  if (*a4 < 0.1) {
    return 2;
  }
  uint64_t v10 = 0;
  int v11 = 0;
  do
  {
    v11 |= v13[v10 + 1] << v10;
    ++v10;
  }
  while (v10 != 6);
  uint64_t result = 4;
  if ((char)v11 > 37)
  {
    if ((char)v11 <= 43)
    {
      if ((char)v11 == 38)
      {
        LOBYTE(v11) = 5;
      }
      else
      {
        if ((char)v11 != 42) {
          return result;
        }
        LOBYTE(v11) = 7;
      }
    }
    else
    {
      switch((char)v11)
      {
        case ',':
          LOBYTE(v11) = 2;
          break;
        case '2':
          LOBYTE(v11) = 4;
          break;
        case '4':
          LOBYTE(v11) = 1;
          break;
        default:
          return result;
      }
    }
  }
  else if ((char)v11 <= 21)
  {
    if ((_BYTE)v11)
    {
      if ((char)v11 != 14) {
        return result;
      }
      LOBYTE(v11) = 6;
    }
  }
  else
  {
    switch((char)v11)
    {
      case 22:
        LOBYTE(v11) = 9;
        break;
      case 26:
        LOBYTE(v11) = 8;
        break;
      case 28:
        LOBYTE(v11) = 3;
        break;
      default:
        return result;
    }
  }
  *a3 = v11;
  int v12 = a3[12];
  if (v12 == sub_1DC3DBFCC(a3)) {
    return 0;
  }
  else {
    return 5;
  }
}

uint64_t sub_1DC3DBFCC(unsigned __int8 *a1)
{
  __int16 v1 = (unsigned __int16)(a1[2]
                        + *a1
                        + a1[4]
                        + a1[6]
                        + a1[8]
                        + a1[10]
                        + 3 * (a1[3] + a1[1] + a1[5] + a1[7] + a1[9] + a1[11]))
     % 0xAu;
  if (v1) {
    return (char)(10 - v1);
  }
  else {
    return 0;
  }
}

uint64_t sub_1DC3DC058(uint64_t a1, float *a2, uint64_t a3, float *a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v225 = *MEMORY[0x1E4F143B8];
  if ((int)a3 < 30) {
    return 16;
  }
  int v12 = a4;
  float v13 = a2;
  int v202 = a3 - 30;
  if (!sub_1DC3DB3C4(a1, a2, a3, a4, 0)) {
    return 23;
  }
  size_t v14 = 13;
  *(void *)(a5 + 8) = 13;
  *(void *)(a5 + 80) = 0xD00000001;
  if (*(void *)(a5 + 16))
  {
    free(*(void **)(a5 + 16));
    size_t v14 = *(void *)(a5 + 8);
  }
  *(void *)(a5 + 16) = 0;
  int v15 = (unsigned __int8 *)malloc_type_malloc(v14, 0x100004077774924uLL);
  *(void *)(a5 + 16) = v15;
  CFDataRef v199 = (float *)(a5 + 24);
  if (!sub_1DC3DBE3C((uint64_t)v13, (uint64_t)v12, v15, (float *)(a5 + 24), v16, v17, v18))
  {
LABEL_185:
    uint64_t v8 = 0;
    *(float *)(a5 + 72) = (float)(v12[1] - *v13) / 3.0;
    *(float *)(a5 + 76) = (float)(v12[29] - v13[28]) / 3.0;
    uint64_t v192 = *(_DWORD **)(a5 + 64);
    v192[10] = 0;
    v192[11] = v202;
    v192[12] = *(_DWORD *)v13;
    v192[13] = *((_DWORD *)v12 + 29);
    v192[5] = 30;
    return v8;
  }
  uint64_t v223 = 0;
  float v222 = 0.0;
  float v19 = *(float *)((char *)v12 + (((a3 << 32) - 0x100000000) >> 30));
  uint64_t v20 = *(unsigned __int8 **)(a5 + 16);
  float v21 = v19 - *v12;
  if (v21 < 300.0) {
    sub_1DC3B4340(a6, (int)*v13, (int)v19, (float *)&v223 + 1, (float *)&v223, &v222);
  }
  long long v201 = v13;
  uint64_t v22 = 0;
  float v23 = v224;
  uint64_t v24 = 1;
  do
  {
    if (v21 >= 300.0)
    {
      uint64_t v25 = v22 + 3;
      sub_1DC3B4340(a6, (int)v12[v22 + 1], (int)v12[v22 + 3], (float *)&v223 + 1, (float *)&v223, &v222);
    }
    else
    {
      uint64_t v25 = (2 * v24) | 1;
    }
    uint64_t v26 = v223;
    float v27 = v222;
    sub_1DC3DCEC0(a6, a7, 0, (uint64_t)v23, v12[v22 + 1], v12[v25], *((float *)&v223 + 1), *(float *)&v223, v222);
    ++v24;
    v22 += 2;
    v23 += 72;
  }
  while (v22 != 12);
  uint64_t v28 = v201 + 18;
  for (uint64_t i = 432; i != 864; i += 72)
  {
    float v30 = *(v28 - 2);
    float v31 = *v28;
    v28 += 2;
    sub_1DC3DCEC0(a6, a7, 1, (uint64_t)&v224[i], v30, v31, *((float *)&v26 + 1), *(float *)&v26, v27);
  }
  float v32 = 100.0;
  unint64_t v33 = 1;
  float v34 = v224;
  float v13 = v201;
  while (1)
  {
    uint64_t v35 = 0;
    char v36 = -1;
    float v37 = -1.0;
    do
    {
      if (*(float *)&v34[v35 + 4] > v37)
      {
        char v36 = v34[v35];
        float v37 = *(float *)&v34[v35 + 4];
      }
      v35 += 8;
    }
    while (v35 != 64);
    if (v36 == -1) {
      break;
    }
    if (v33 > 6)
    {
      v36 -= 20;
    }
    else
    {
      v221[v33] = v36 > 9;
      if (v36 > 9) {
        v36 -= 10;
      }
    }
    v20[v33] = v36;
    float v38 = (float *)&v224[72 * v33 - 72];
    if (v32 > v38[9]) {
      float v32 = v38[9];
    }
    ++v33;
    v34 += 72;
    if (v33 == 13)
    {
      if (v32 > -0.15) {
        *CFDataRef v199 = v32 + 0.5;
      }
      int v39 = 0;
      for (uint64_t j = 1; j != 7; ++j)
        v39 |= v221[j] << (j - 1);
      if ((char)v39 > 37)
      {
        if ((char)v39 <= 43)
        {
          if ((char)v39 == 38)
          {
            LOBYTE(v39) = 5;
          }
          else
          {
            if ((char)v39 != 42) {
              break;
            }
            LOBYTE(v39) = 7;
          }
        }
        else
        {
          switch((char)v39)
          {
            case ',':
              LOBYTE(v39) = 2;
              break;
            case '2':
              LOBYTE(v39) = 4;
              break;
            case '4':
              LOBYTE(v39) = 1;
              break;
            default:
              goto LABEL_58;
          }
        }
      }
      else if ((char)v39 <= 21)
      {
        if ((_BYTE)v39)
        {
          if ((char)v39 != 14) {
            break;
          }
          LOBYTE(v39) = 6;
        }
      }
      else
      {
        switch((char)v39)
        {
          case 22:
            LOBYTE(v39) = 9;
            break;
          case 26:
            LOBYTE(v39) = 8;
            break;
          case 28:
            LOBYTE(v39) = 3;
            break;
          default:
            goto LABEL_58;
        }
      }
      *uint64_t v20 = v39;
      int v41 = v20[12];
      BOOL v42 = v41 == sub_1DC3DBFCC(v20);
      float v13 = v201;
      if (v42) {
        goto LABEL_185;
      }
      break;
    }
  }
LABEL_58:
  int v196 = *(unsigned __int8 **)(a5 + 16);
  float v43 = (char *)malloc_type_malloc(0x300uLL, 0x100004052888210uLL);
  uint64_t v44 = (float *)v43;
  uint64_t v45 = 0;
  float v46 = (float *)(v43 + 240);
  uint64_t v195 = (uint64_t)(v43 + 600);
  float v47 = v43 + 744;
  uint64_t v48 = v12;
  do
  {
    float v49 = *v13++;
    float v50 = (float *)&v43[v45];
    *float v50 = v49;
    int v51 = *(_DWORD *)v48++;
    *((_DWORD *)v50 + 1) = v51;
    v45 += 8;
  }
  while (v45 != 240);
  uint64_t v52 = 0;
  float v53 = (float)(*((float *)v43 + 59) - *(float *)v43) / 95.0;
  *((void *)v43 + 90) = 0;
  *((float *)v43 + 182) = v53;
  *(void *)(v43 + 732) = 0;
  *((float *)v43 + 185) = v53;
  *((_OWORD *)v43 + 27) = xmmword_1DC416A70;
  *((_OWORD *)v43 + 28) = unk_1DC416A80;
  *((_OWORD *)v43 + 29) = xmmword_1DC416A90;
  *((_OWORD *)v43 + 23) = xmmword_1DC416A30;
  *((_OWORD *)v43 + 24) = unk_1DC416A40;
  BOOL v209 = v43 + 720;
  BOOL v54 = (float *)(v43 + 756);
  *((_OWORD *)v43 + 25) = xmmword_1DC416A50;
  *((_OWORD *)v43 + 26) = unk_1DC416A60;
  *((_OWORD *)v43 + 19) = xmmword_1DC4169F0;
  *((_OWORD *)v43 + 20) = unk_1DC416A00;
  *((_OWORD *)v43 + 21) = xmmword_1DC416A10;
  *((_OWORD *)v43 + 22) = unk_1DC416A20;
  *(_OWORD *)float v46 = xmmword_1DC4169B0;
  *((_OWORD *)v43 + 16) = unk_1DC4169C0;
  *((_OWORD *)v43 + 17) = xmmword_1DC4169D0;
  *((_OWORD *)v43 + 18) = unk_1DC4169E0;
  do
  {
    uint64_t v55 = dword_1DC416AA0[v52];
    uint64_t v56 = &v43[v52 * 4];
    *((_DWORD *)v56 + 186) = *(_DWORD *)&v43[4 * v55];
    *((float *)v56 + 189) = v46[v55];
    ++v52;
  }
  while (v52 != 3);
  int v57 = 0;
  uint64_t v58 = 0;
  do
  {
    uint64_t v59 = v58 + 1;
    int v60 = dword_1DC416AA0[v58 + 1];
    if (v57 < v60)
    {
      uint64_t v61 = v60 - (uint64_t)v57;
      float v62 = (float *)&v43[4 * v57];
      do
      {
        *float v62 = *v62 - *(float *)&v47[4 * v58];
        ++v62;
        --v61;
      }
      while (v61);
    }
    int v57 = v60;
    uint64_t v58 = 1;
  }
  while (v59 != 2);
  uint64_t v194 = (uint64_t)(v43 + 480);
  uint64_t v198 = malloc_type_malloc(0xECuLL, 0x100004052888210uLL);
  int v66 = 0;
  long long v200 = v44 + 61;
  CFDataRef v207 = v12;
  uint64_t v208 = a5;
  CGRect v205 = v46;
  BOOL v206 = v44;
  CGRect v203 = v44 + 189;
  CGRect v204 = v47;
  do
  {
    int v197 = v66;
    uint64_t v67 = 0;
    float v68 = v209;
    while (v67 != 2)
    {
      uint64_t v69 = dword_1DC416AA0[v67];
      uint64_t v70 = dword_1DC416AA0[v67 + 1];
      float32x4_t v71 = &v44[v69];
      *float32x4_t v71 = 0.0;
      v44[v70] = *(float *)&v47[4 * v67 + 4] - *(float *)&v47[4 * v67];
      float v72 = &v46[v69];
      *float v72 = 0.0;
      unsigned int v73 = v70 - v69;
      if ((int)v70 > (int)v69)
      {
        uint64_t v74 = v70 - v69;
        int v75 = &v200[v69];
        do
        {
          *int v75 = *v75 - v54[v67];
          ++v75;
          --v74;
        }
        while (v74);
      }
      uint64_t v76 = v73 + 1;
      if ((int)v76 < 3
        || (unsigned int v215 = v73,
            uint64_t v218 = (uint64_t)v72,
            uint64_t v210 = v67 + 1,
            int v77 = 3 * v76,
            (float v78 = (char *)malloc_type_malloc(4 * (5 * (int)v76 + 30), 0x100004052888210uLL)) == 0))
      {
        uint64_t v8 = 15;
        float v13 = v201;
        a5 = v208;
        goto LABEL_182;
      }
      float v80 = (float *)&v209[12 * v67];
      float v81 = &v78[4 * v76];
      uint64_t v82 = (uint64_t)&v81[4 * v76];
      uint64_t v83 = v77;
      uint64_t v84 = v82 + 12 + 4 * v77;
      uint64_t v85 = v84 + 36;
      uint64_t v219 = v84;
      uint64_t v220 = v78;
      uint64_t v211 = v84 + 60;
      uint64_t v217 = v82 + 12;
      sub_1DC303254(v80, v82 + 12, v79, 3, v76, v218);
      uint64_t v86 = 0;
      float v87 = v80[2];
      unsigned int v212 = v80;
      float v88 = -*v80;
      float v89 = -v80[1];
      do
      {
        if (v86) {
          float v90 = -1.0;
        }
        else {
          float v90 = 1.0;
        }
        float v91 = *(float *)(v218 + 4 * v86) + (float)(v88 * v90);
        *(float *)&v81[4 * v86++] = (float)(v87 * v91) / (float)((float)(v89 * v91) + 1.0);
      }
      while (v76 != v86);
      unint64_t v92 = 0;
      uint64_t v93 = 4 * v76;
      float v94 = 0.0;
      do
      {
        float v95 = v71[v92 / 4] - *(float *)&v220[4 * v76 + v92];
        *(float *)&v220[v92] = v95;
        float v94 = v94 + (float)(v95 * v95);
        v92 += 4;
      }
      while (v93 != v92);
      float v96 = fabsf(v94);
      if (v96 >= INFINITY && v96 <= INFINITY)
      {
        free(v220);
        uint64_t v8 = 15;
        int v12 = v207;
        a5 = v208;
        float v13 = v201;
        uint64_t v44 = v206;
        goto LABEL_182;
      }
      uint64_t v97 = v219 + 72;
      uint64_t v216 = v76;
      unsigned int v214 = v81;
      sub_1DC2FF464(v217, (uint64_t)v220, v219, v82, v76);
      float v98 = v81;
      uint64_t v100 = v219;
      int v99 = v220;
      uint64_t v101 = v76;
      int v102 = 0;
      float v103 = *(float *)(v217 + 4 * v83);
      if (*(float *)(v219 + 16) > v103) {
        float v103 = *(float *)(v219 + 16);
      }
      if (*(float *)(v219 + 32) > v103) {
        float v103 = *(float *)(v219 + 32);
      }
      float v104 = v103 * 0.001;
      float v105 = &v220[8 * v76 + 4 * v83];
      float v106 = v105 + 48;
      float v107 = &v220[v93];
      uint64_t v108 = v82 + 4 * v83;
      int v109 = 2;
      unsigned int v110 = v215;
      while (2)
      {
        if (v94 <= 0.000001) {
          goto LABEL_154;
        }
        uint64_t v111 = 0;
        float v112 = 0.0;
        float v113 = 0.0;
        do
        {
          float v114 = *(float *)(v82 + v111);
          if (v114 < 0.0) {
            float v114 = -v114;
          }
          if (v112 < v114) {
            float v112 = v114;
          }
          *(_DWORD *)&v105[v111 + 60] = *(_DWORD *)&v105[4 * v111 + 12];
          float v113 = v113 + (float)(*(float *)&v68[v111] * *(float *)&v68[v111]);
          v111 += 4;
        }
        while (v111 != 12);
        if (v112 <= 0.000001)
        {
LABEL_154:
          int v160 = v102;
          break;
        }
        for (uint64_t k = 12; k != 60; k += 16)
          *(float *)&v105[k] = v104 + *(float *)&v105[k];
        unint64_t v116 = 0;
        uint64_t v117 = 1;
        float v118 = (float *)(v219 + 84);
        float v119 = (float *)v100;
        do
        {
          float v120 = *v119;
          *float v118 = *v119;
          if (v116)
          {
            uint64_t v121 = -(uint64_t)v116;
            do
            {
              float v120 = v120 - (float)(v118[v121] * v118[v121]);
              *float v118 = v120;
              BOOL v122 = __CFADD__(v121++, 1);
            }
            while (!v122);
            *float v118 = sqrtf(v120);
            uint64_t v123 = v116 + 1;
            if (v116 > 1) {
              goto LABEL_114;
            }
          }
          else
          {
            *float v118 = sqrtf(v120);
            uint64_t v123 = 1;
          }
          float v124 = &v118[v116 + 1];
          uint64_t v125 = v117;
          do
          {
            float v126 = v119[1];
            ++v119;
            float v127 = v126;
            *float v124 = v126;
            if (v116)
            {
              uint64_t v128 = &v124[-v116];
              uint64_t v129 = -(uint64_t)v116;
              do
              {
                float v130 = *v128++;
                float v127 = v127 - (float)(v130 * v118[v129]);
                *float v124 = v127;
                BOOL v122 = __CFADD__(v129++, 1);
              }
              while (!v122);
            }
            *float v124 = v127 / *v118;
            v124 += ++v125;
          }
          while (v125 != 3);
LABEL_114:
          v118 += v116 + 2;
          v119 += v123 + 1;
          ++v117;
          unint64_t v116 = v123;
        }
        while (v123 != 3);
        uint64_t v131 = 0;
        uint64_t v132 = (float *)(v219 + 84);
        do
        {
          float v133 = *(float *)(v82 + 4 * v131);
          *(float *)(v97 + 4 * v131) = v133;
          if (v131)
          {
            unsigned __int8 v134 = (float *)(v219 + 72);
            uint64_t v135 = v131;
            float v136 = v132;
            do
            {
              float v137 = *v136++;
              float v138 = v137;
              float v139 = *v134++;
              float v133 = v133 - (float)(v138 * v139);
              *(float *)(v97 + 4 * v131) = v133;
              --v135;
            }
            while (v135);
          }
          else
          {
            float v136 = v132;
          }
          uint64_t v132 = v136 + 1;
          *(float *)(v97 + 4 * v131++) = v133 / *v136;
        }
        while (v131 != 3);
        uint64_t v140 = 15;
        unint64_t v141 = 3;
        do
        {
          unint64_t v142 = v141 - 1;
          float v143 = *(float *)(v97 + 4 * (v141 - 1));
          *(float *)(v85 + 4 * (v141 - 1)) = v143;
          if (v141 <= 2)
          {
            float32x2x2_t v144 = &v136[v141];
            uint64_t v145 = v140;
            do
            {
              float v143 = v143 - (float)(*v144 * *(float *)&v105[4 * v145]);
              *(float *)(v85 + 4 * v142) = v143;
              int v146 = v145 - 11;
              v144 += v145 - 11;
              ++v145;
            }
            while (v146 != 3);
          }
          *(float *)(v85 + 4 * v142) = v143 / *v136;
          v136 -= v141;
          --v140;
        }
        while (v141-- > 1);
        uint64_t v148 = 0;
        float v149 = 0.0;
        do
        {
          float v150 = *(float *)&v106[v148];
          *(float *)&v106[v148 + 24] = *(float *)&v68[v148] + v150;
          float v149 = v149 + (float)(v150 * v150);
          v148 += 4;
        }
        while (v148 != 12);
        if (v149 <= (float)(v113 * 1.0e-12)) {
          goto LABEL_154;
        }
        if ((float)(v149 * 1.0e-12) >= (float)(v113 + 0.000001))
        {
          int v160 = -7;
        }
        else
        {
          if (v110 <= 0x7FFFFFFE)
          {
            uint64_t v151 = 0;
            float v152 = *(float *)(v100 + 68);
            float v153 = -*(float *)(v100 + 60);
            float v154 = -*(float *)(v100 + 64);
            do
            {
              if (v151) {
                float v155 = -1.0;
              }
              else {
                float v155 = 1.0;
              }
              float v156 = *(float *)(v218 + 4 * v151) + (float)(v153 * v155);
              *(float *)&v98[4 * v151++] = (float)(v152 * v156) / (float)((float)(v154 * v156) + 1.0);
            }
            while (v101 != v151);
          }
          unint64_t v157 = 0;
          float v158 = 0.0;
          do
          {
            float v159 = v71[v157 / 4] - *(float *)&v107[v157];
            *(float *)&v107[v157] = v159;
            float v158 = v158 + (float)(v159 * v159);
            v157 += 4;
          }
          while (v93 != v157);
          int v160 = -8;
          if (fabsf(v158) == INFINITY) {
            break;
          }
          if (v158 >= v94) {
            goto LABEL_154;
          }
          uint64_t v161 = 0;
          float v162 = 0.0;
          do
          {
            float v162 = v162
                 + (float)(*(float *)(v108 + v161 + 48)
                         * (float)(*(float *)(v82 + v161) + (float)(v104 * *(float *)(v108 + v161 + 48))));
            v161 += 4;
          }
          while (v161 != 12);
          if (v162 > 0.0 && (float)(v94 - v158) > 0.0)
          {
            uint64_t v163 = 0;
            float v164 = (float)((float)((float)(v94 - v158) + (float)(v94 - v158)) / v162) + -1.0;
            float v165 = (float)((float)-(float)(v164 * v164) * v164) + 1.0;
            do
            {
              *(_DWORD *)&v68[v163] = *(_DWORD *)(v211 + v163);
              v163 += 4;
            }
            while (v163 != 12);
            int v213 = v102;
            uint64_t v166 = 0;
            do
            {
              *(_DWORD *)&v99[v166] = *(_DWORD *)&v107[v166];
              v166 += 4;
            }
            while (v93 != v166);
            float v167 = fmaxf(v165, 0.3333);
            sub_1DC303254(v212, v217, v165, 3, v101, v218);
            sub_1DC2FF464(v217, (uint64_t)v220, v219, v82, v216);
            uint64_t v100 = v219;
            int v99 = v220;
            uint64_t v101 = v216;
            int v109 = 2;
            float v94 = v158;
            unsigned int v110 = v215;
            float v98 = v214;
            int v102 = v213;
LABEL_152:
            float v104 = v104 * v167;
            if (++v102 == 50)
            {
              int v160 = 50;
              break;
            }
            continue;
          }
          if (2 * v109 > v109)
          {
            float v167 = (float)v109;
            int v168 = *(_DWORD *)(v100 + 52);
            *(_DWORD *)uint64_t v100 = *(_DWORD *)(v100 + 48);
            *(_DWORD *)(v100 + 16) = v168;
            *(_DWORD *)(v100 + 32) = *(_DWORD *)(v100 + 56);
            v109 *= 2;
            goto LABEL_152;
          }
          int v160 = -6;
        }
        break;
      }
      int v169 = *(_DWORD *)(v100 + 52);
      *(_DWORD *)uint64_t v100 = *(_DWORD *)(v100 + 48);
      *(_DWORD *)(v100 + 16) = v169;
      *(_DWORD *)(v100 + 32) = *(_DWORD *)(v100 + 56);
      int v170 = v160;
      free(v99);
      v68 += 12;
      int v12 = v207;
      a5 = v208;
      float v46 = v205;
      uint64_t v44 = v206;
      BOOL v54 = v203;
      float v47 = v204;
      uint64_t v67 = v210;
      if (v170 < 0)
      {
        uint64_t v8 = 15;
        float v13 = v201;
        goto LABEL_182;
      }
    }
    int v171 = 0;
    uint64_t v172 = 0;
    char v173 = 1;
    int v174 = v46;
    float v13 = v201;
    do
    {
      float v175 = *v174;
      uint64_t v176 = v172 + 1;
      int v177 = dword_1DC416AA0[v172 + 1];
      int v178 = &v44[v171];
      *int v178 = 0.0;
      v65.i32[0] = *(_DWORD *)&v47[4 * v172];
      v44[v177] = *(float *)&v47[4 * v172 + 4] - *(float *)v65.i32;
      if (v177 - v171 >= 0)
      {
        uint64_t v179 = 0;
        int v180 = &v209[12 * v172];
        float v181 = *(float *)v180;
        v65.i32[0] = *((_DWORD *)v180 + 1);
        float v182 = *((float *)v180 + 2);
        do
        {
          if (v179) {
            float v183 = -1.0;
          }
          else {
            float v183 = 1.0;
          }
          v178[v179 + 60] = (float)(v178[v179] / (float)(v182 + (float)(*(float *)v65.i32 * v178[v179])))
                          + (float)(v181 * v183);
          ++v179;
        }
        while (v177 - v171 + 1 != v179);
      }
      uint64_t v184 = &v46[v171];
      *(float *)&double v64 = fabsf(*v184);
      if (*(float *)&v64 > 1.0)
      {
LABEL_181:
        uint64_t v8 = 13;
        goto LABEL_182;
      }
      if ((v173 & 1) == 0)
      {
        uint64_t v185 = v171;
        if (v177 >= v171)
        {
          int v186 = v177 - v171 + 1;
          uint64_t v187 = v184;
          do
          {
            v65.i32[0] = *(__int32 *)v187;
            *uint64_t v187 = v44[190] + *v187;
            ++v187;
            --v186;
          }
          while (v186);
        }
        if (v175 > v46[v185 + 1]) {
          goto LABEL_181;
        }
        LODWORD(v64) = 0.5;
        *uint64_t v184 = (float)(v175 + *v184) * 0.5;
      }
      char v173 = 0;
      int v174 = &v46[v177];
      int v171 = v177;
      uint64_t v172 = 1;
    }
    while (v176 != 2);
    uint64_t v188 = 0;
    uint64_t v189 = v200;
    do
    {
      double v190 = (_DWORD *)(v194 + v188);
      *double v190 = *((_DWORD *)v189 - 1);
      int v191 = *(_DWORD *)v189;
      v189 += 2;
      LODWORD(v63) = v191;
      v190[30] = v191;
      v188 += 4;
    }
    while (v188 != 120);
    uint64_t v8 = sub_1DC3DBE3C(v194, v195, v196, v199, v63, v64, v65);
    if (!v8) {
      break;
    }
    if (!sub_1DC3DD324(v46, (uint64_t)v198)) {
      break;
    }
    int v66 = v197 + 1;
  }
  while (v197 != 3);
LABEL_182:
  if (v198) {
    free(v198);
  }
  free(v44);
  if (!v8) {
    goto LABEL_185;
  }
  return v8;
}

uint64_t sub_1DC3DCEC0(uint64_t result, int a2, int a3, uint64_t a4, float a5, float a6, float a7, float a8, float a9)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  *(void *)(a4 + 64) = 0;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  for (uint64_t i = 4; i != 76; i += 8)
    *(_DWORD *)(a4 + i) = -1082130432;
  if (a5 >= 0.0)
  {
    BOOL v10 = (float)a2 < a6 || (float)(a2 - 1) < a5;
    if (!v10 && a6 >= 0.0)
    {
      float v11 = (float)(a6 - a5) / 7.0;
      unint64_t v12 = 20;
      if (a3) {
        unint64_t v13 = 20;
      }
      else {
        unint64_t v13 = 0;
      }
      if (a3) {
        unint64_t v12 = 30;
      }
      float v14 = 1.0 / (float)(a7 + a7);
      char v15 = a3;
      double v16 = (char *)&unk_1DC416B04 + 16 * v13;
      do
      {
        uint64_t v17 = 0;
        *(float *)float v91 = a5;
        float v18 = a5;
        do
        {
          float v18 = v18 + (float)(*(float *)&v16[v17 * 4] * v11);
          *(float *)&v91[++v17] = v18;
        }
        while (v17 != 4);
        if (result)
        {
          uint64_t v19 = 0;
          float v20 = 0.0;
          float v21 = a5;
          do
          {
            float v22 = v21;
            signed int v23 = vcvtms_s32_f32(v21);
            uint64_t v24 = v19 + 1;
            float v21 = *(float *)&v91[v19 + 1];
            signed int v25 = vcvtps_s32_f32(v21);
            if (v23 == v25)
            {
              float v26 = *(float *)(result + 4 * v23);
              float v27 = fmaxf(v26 - a9, 0.0);
              float v28 = v26 - a8;
              if (v28 > 0.0) {
                float v28 = 0.0;
              }
              if ((((_BYTE)v19 + v15) & 1) == 0) {
                float v28 = v27;
              }
              float v20 = v20 + (float)((float)(v21 - v22) * (float)(v14 * (float)(v28 * v28)));
            }
            else if (v23 < v25)
            {
              uint64_t v29 = 0;
              float v30 = (float)(v23 + 1) - v22;
              float v31 = (float)(v21 - (float)(int)ceilf(v21)) + 1.0;
              char v32 = v19 + v15;
              uint64_t v33 = v25 - (uint64_t)v23;
              uint64_t v34 = result + 4 * v23;
              do
              {
                float v35 = *(float *)(v34 + 4 * v29);
                if (v32)
                {
                  float v36 = fmaxf(v35 - a9, 0.0);
                }
                else
                {
                  float v36 = v35 - a8;
                  if (v36 > 0.0) {
                    float v36 = 0.0;
                  }
                }
                float v37 = v14 * (float)(v36 * v36);
                if (v33 - 1 == v29) {
                  float v38 = v31;
                }
                else {
                  float v38 = 1.0;
                }
                if (!v29) {
                  float v38 = v30;
                }
                float v20 = v20 + (float)(v38 * v37);
                ++v29;
              }
              while (v33 != v29);
            }
            uint64_t v19 = v24;
          }
          while (v24 != 4);
          float v39 = (float)-v20 / (float)(a6 - a5);
        }
        else
        {
          float v39 = -100.0;
        }
        float v40 = *(float *)(a4 + 36);
        if (v40 == 0.0 || v40 < v39)
        {
          *(float *)(a4 + 36) = v39;
          *(unsigned char *)(a4 + 32) = v13;
        }
        unint64_t v42 = 0;
        float v43 = -(float)(v39 * (float)(*(float *)&v91[4] - a5));
        do
        {
          uint64_t v44 = 0;
          uint64_t v45 = (float *)((char *)&unk_1DC416AC4 + 8 * v42);
          float v46 = (float)((float)((float)(a6 + (float)(v11 * v45[1])) - a5) + (float)((float)-v11 * *v45)) / 7.0;
          float v47 = a5 + (float)(v11 * *v45);
          *(float *)float v90 = v47;
          float v48 = v47;
          do
          {
            float v48 = v48 + (float)(*(float *)&v16[v44 * 4] * v46);
            *(float *)&v90[++v44] = v48;
          }
          while (v44 != 4);
          if (result)
          {
            uint64_t v49 = 0;
            float v50 = v43;
            do
            {
              float v51 = *(float *)&v91[v49];
              float v52 = *(float *)&v90[v49];
              if (vabds_f32(v51, v52) >= 0.1)
              {
                if (v51 <= v52) {
                  float v53 = *(float *)&v91[v49];
                }
                else {
                  float v53 = *(float *)&v90[v49];
                }
                if (v51 <= v52) {
                  float v54 = *(float *)&v90[v49];
                }
                else {
                  float v54 = *(float *)&v91[v49];
                }
                int v55 = (int)v53;
                int v56 = (int)v54;
                if (SLODWORD(v53) == SLODWORD(v54))
                {
                  float v57 = *(float *)(result + 4 * v55);
                  float v58 = v54 - v53;
                  float v59 = fmaxf(v57 - a9, 0.0);
                  float v60 = v57 - a8;
                  if (v60 > 0.0) {
                    float v60 = 0.0;
                  }
                  float v61 = v58 * (float)(v14 * (float)(v59 * v59));
                  float v62 = v58 * (float)(v14 * (float)(v60 * v60));
                }
                else
                {
                  float v62 = 0.0;
                  float v61 = 0.0;
                  if (v55 <= v56)
                  {
                    uint64_t v63 = 0;
                    uint64_t v64 = v56;
                    float v65 = v54 - (float)v56;
                    float v66 = (float)(v55 + 1) - v53;
                    int v67 = v56 - v55 + 1;
                    uint64_t v68 = v64 - v55;
                    uint64_t v69 = result + 4 * v55;
                    float v62 = 0.0;
                    do
                    {
                      float v70 = *(float *)(v69 + 4 * v63);
                      float v71 = v70 - a8;
                      if ((float)(v70 - a8) > 0.0) {
                        float v71 = 0.0;
                      }
                      float v72 = fmaxf(v70 - a9, 0.0);
                      float v73 = v14 * (float)(v72 * v72);
                      float v74 = v14 * (float)(v71 * v71);
                      float v75 = v65 * v73;
                      float v76 = v65 * v74;
                      if (v68 != v63)
                      {
                        float v76 = v74;
                        float v75 = v73;
                      }
                      float v77 = v66 * v73;
                      float v78 = v66 * v74;
                      if (v63)
                      {
                        float v78 = v76;
                        float v77 = v75;
                      }
                      float v62 = v62 + v78;
                      float v61 = v61 + v77;
                      ++v63;
                    }
                    while (v67 != v63);
                  }
                }
                if ((v49 & 0x7FFFFFFFFFFFFFFBLL) != 0) {
                  float v79 = v62;
                }
                else {
                  float v79 = 0.0;
                }
                float v80 = v61 - v79;
                if ((v49 & 0x7FFFFFFFFFFFFFFBLL) == 0) {
                  float v61 = 0.0;
                }
                float v81 = v62 - v61;
                if (v49) {
                  float v81 = v80;
                }
                if (v51 <= v52) {
                  float v82 = -v81;
                }
                else {
                  float v82 = v81;
                }
                float v50 = v50 + v82;
              }
              ++v49;
            }
            while (v49 != 5);
            float v83 = (float)-v50 / (float)(*(float *)&v90[4] - v47);
          }
          else
          {
            float v83 = -100.0;
          }
          if (v42 <= 3) {
            unsigned int v84 = v42;
          }
          else {
            unsigned int v84 = v42 + 1;
          }
          uint64_t v85 = a4 + 8 * v84;
          float v87 = *(float *)(v85 + 4);
          uint64_t v86 = (float *)(v85 + 4);
          float v88 = v87;
          if (v87 == 0.0 || v88 < v83)
          {
            *uint64_t v86 = v83;
            *(unsigned char *)(a4 + 8 * v84) = v13;
          }
          ++v42;
        }
        while (v42 != 8);
        ++v13;
        v16 += 16;
      }
      while (v13 < v12);
    }
  }
  return result;
}

uint64_t sub_1DC3DD324(float *a1, uint64_t a2)
{
  uint64_t result = 0;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    uint64_t v5 = 0;
    float v6 = *a1;
    float v7 = 0.0;
    do
    {
      float v8 = a1[v5 + 1];
      *(_DWORD *)(a2 + v5 * 4) = 1;
      float v7 = v7 + fabsf((float)(v8 - v6) + -1.0);
      ++v5;
      float v6 = v8;
    }
    while (v5 != 3);
    if (v7 < 2.1)
    {
      uint64_t v9 = 0;
      while (1)
      {
        BOOL v10 = &a1[v9 + 3];
        int8x16_t v11 = (int8x16_t)vld1q_dup_f32(v10);
        float32x4_t v26 = vsubq_f32(*(float32x4_t *)&a1[v9 + 4], (float32x4_t)vextq_s8(v11, *(int8x16_t *)&a1[v9 + 4], 0xCuLL));
        if (sub_1DC30EFD4(&v26, (int32x4_t *)(a2 + 12 + v9 * 4)) >= 4.9) {
          break;
        }
        v9 += 4;
        if ((v9 * 4) == 96)
        {
          uint64_t v12 = 0;
          float v13 = a1[27];
          float v14 = 0.0;
          do
          {
            float v15 = a1[v12 + 28];
            *(_DWORD *)(a2 + 108 + v12 * 4) = 1;
            float v14 = v14 + fabsf((float)(v15 - v13) + -1.0);
            ++v12;
            float v13 = v15;
          }
          while (v12 != 5);
          if (v14 < 3.5)
          {
            uint64_t v16 = 0;
            while (1)
            {
              uint64_t v17 = &a1[v16 + 32];
              int8x16_t v18 = (int8x16_t)vld1q_dup_f32(v17);
              float32x4_t v26 = vsubq_f32(*(float32x4_t *)&a1[v16 + 33], (float32x4_t)vextq_s8(v18, *(int8x16_t *)&a1[v16 + 33], 0xCuLL));
              if (sub_1DC30EFD4(&v26, (int32x4_t *)(a2 + 128 + v16 * 4)) >= 4.9) {
                break;
              }
              v16 += 4;
              if ((v16 * 4) == 96)
              {
                uint64_t v19 = 0;
                float v20 = a1[56];
                float v21 = 0.0;
                do
                {
                  float v22 = a1[v19 + 57];
                  *(_DWORD *)(a2 + 224 + v19 * 4) = 1;
                  float v21 = v21 + fabsf((float)(v22 - v20) + -1.0);
                  ++v19;
                  float v20 = v22;
                }
                while (v19 != 3);
                if (v21 < 2.1)
                {
                  uint64_t v23 = 0;
                  *a1 = 0.0;
                  uint64_t v24 = a1 + 1;
                  float v25 = 0.0;
                  uint64_t result = 1;
                  do
                  {
                    float v25 = v25 + (float)*(int *)(a2 + v23 * 4);
                    v24[v23++] = v25;
                  }
                  while (v23 != 59);
                  return result;
                }
                return 0;
              }
            }
          }
          return 0;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_1DC3DD548(uint64_t a1, float *a2, uint64_t a3, float *a4, uint64_t a5)
{
  int v5 = a3;
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if ((a3 - 25) < 0xFFFFFFFD) {
    return 16;
  }
  if (!sub_1DC3DB3C4(a1, a2, a3, a4, 1)) {
    return 23;
  }
  *(void *)(a5 + 8) = 13;
  v10.n128_u64[0] = 0x800000001;
  *(void *)(a5 + 80) = 0x800000001;
  MEMORY[0x1F4188790](v10);
  int8x16_t v11 = (unsigned __int8 *)malloc_type_malloc(*(void *)(a5 + 8), 0x100004077774924uLL);
  float v15 = *(void **)(a5 + 16);
  if (v15) {
    free(v15);
  }
  *(void *)(a5 + 16) = v11;
  float v19 = 0.0;
  sub_1DC3DB738((uint64_t)v11, dword_1DC416AAC, (uint64_t)a2, (uint64_t)a4, (uint64_t)&v18, &v19, v12, v13, v14);
  if (v19 < 0.65) {
    return 2;
  }
  *(float *)(a5 + 24) = v19;
  atomic_ullong v11[4] = 0;
  *(_DWORD *)int8x16_t v11 = 0;
  int v16 = v11[12];
  if (v16 != sub_1DC3DBFCC(v11)) {
    return 5;
  }
  uint64_t result = 0;
  *(float *)(a5 + 72) = (float)(a4[1] - *a2) / 3.0;
  *(float *)(a5 + 76) = (float)(a4[21] - a2[20]) / 3.0;
  uint64_t v17 = *(_DWORD **)(a5 + 64);
  v17[10] = 0;
  v17[11] = v5 - 22;
  uint64_t v17[12] = *(_DWORD *)a2;
  v17[13] = *((_DWORD *)a4 + 21);
  v17[5] = 22;
  *(void *)int8x16_t v11 = *(void *)(v11 + 5);
  *((_DWORD *)v11 + 2) = 0;
  v11[12] = 0;
  return result;
}

uint64_t sub_1DC3DD71C(uint64_t a1, float *a2, uint64_t a3, float *a4, uint64_t a5)
{
  int v5 = a3;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if ((a3 - 20) < 0xFFFFFFFD) {
    return 16;
  }
  if (!sub_1DC3DB3C4(a1, a2, a3, a4, 2)) {
    return 23;
  }
  *(void *)(a5 + 8) = 13;
  v10.n128_u64[0] = 0x700000001;
  *(void *)(a5 + 80) = 0x700000001;
  MEMORY[0x1F4188790](v10);
  int8x16_t v11 = (char *)malloc_type_malloc(*(void *)(a5 + 8), 0x100004077774924uLL);
  float v15 = *(void **)(a5 + 16);
  if (v15) {
    free(v15);
  }
  *(void *)(a5 + 16) = v11;
  float v33 = 0.0;
  sub_1DC3DB738((uint64_t)v11, dword_1DC416AB8, (uint64_t)a2, (uint64_t)a4, (uint64_t)v30, &v33, v12, v13, v14);
  if (v33 < 0.65) {
    return 2;
  }
  uint64_t v16 = 0;
  int v17 = 0;
  *(float *)(a5 + 24) = v33;
  do
  {
    v17 |= v30[v16 + 1] << v16;
    ++v16;
  }
  while (v16 != 6);
  uint64_t v18 = ((char)v17 - 7);
  if (v18 >= 0x32 || ((0x22C2CD02CD0D1uLL >> v18) & 1) == 0) {
    return 4;
  }
  int v19 = byte_1DC4170B4[v18];
  int v20 = byte_1DC4170E6[v18];
  unsigned __int8 v21 = v11[5];
  unsigned int v22 = *(_DWORD *)(v11 + 1);
  int v23 = v11[6];
  int v31 = v21;
  int v32 = v20;
  switch(v23)
  {
    case 0:
      *int8x16_t v11 = 0;
      unsigned int v24 = HIBYTE(v22);
      v11[1] = v20;
      unsigned int v25 = HIWORD(v22);
      *((_WORD *)v11 + 1) = v22;
      *((_DWORD *)v11 + 1) = 0;
      v11[8] = 0;
      goto LABEL_21;
    case 1:
      *int8x16_t v11 = 0;
      unsigned int v24 = HIBYTE(v22);
      v11[1] = v20;
      unsigned int v25 = HIWORD(v22);
      *((_WORD *)v11 + 1) = v22;
      char v27 = 1;
      goto LABEL_20;
    case 2:
      *int8x16_t v11 = 0;
      unsigned int v24 = HIBYTE(v22);
      v11[1] = v20;
      unsigned int v25 = HIWORD(v22);
      *((_WORD *)v11 + 1) = v22;
      char v27 = 2;
LABEL_20:
      atomic_ullong v11[4] = v27;
      *(_DWORD *)(v11 + 5) = 0;
LABEL_21:
      v11[9] = v25;
      v11[10] = v24;
      goto LABEL_24;
    case 3:
      *int8x16_t v11 = 0;
      v11[1] = v20;
      *((_WORD *)v11 + 1) = v22;
      atomic_ullong v11[4] = BYTE2(v22);
      *(_DWORD *)(v11 + 5) = 0;
      v11[9] = 0;
      v11[10] = HIBYTE(v22);
      goto LABEL_24;
    case 4:
      *int8x16_t v11 = 0;
      v11[1] = v20;
      *(_DWORD *)(v11 + 2) = v22;
      *(_DWORD *)(v11 + 6) = 0;
      v11[10] = 0;
LABEL_24:
      v11[11] = v21;
      goto LABEL_31;
    case 5:
      *int8x16_t v11 = 0;
      v11[1] = v20;
      *(_DWORD *)(v11 + 2) = v22;
      v11[6] = v21;
      *(_DWORD *)(v11 + 7) = 0;
      char v28 = 5;
      goto LABEL_30;
    case 6:
      *int8x16_t v11 = 0;
      v11[1] = v20;
      *(_DWORD *)(v11 + 2) = v22;
      v11[6] = v21;
      *(_DWORD *)(v11 + 7) = 0;
      char v28 = 6;
      goto LABEL_30;
    case 7:
      *int8x16_t v11 = 0;
      v11[1] = v20;
      *(_DWORD *)(v11 + 2) = v22;
      v11[6] = v21;
      *(_DWORD *)(v11 + 7) = 0;
      char v28 = 7;
      goto LABEL_30;
    case 8:
      *int8x16_t v11 = 0;
      v11[1] = v20;
      *(_DWORD *)(v11 + 2) = v22;
      v11[6] = v21;
      *(_DWORD *)(v11 + 7) = 0;
      char v28 = 8;
      goto LABEL_30;
    case 9:
      *int8x16_t v11 = 0;
      v11[1] = v20;
      *(_DWORD *)(v11 + 2) = v22;
      v11[6] = v21;
      *(_DWORD *)(v11 + 7) = 0;
      char v28 = 9;
LABEL_30:
      v11[11] = v28;
LABEL_31:
      int v26 = v19;
      v11[12] = v19;
      break;
    default:
      int v26 = v11[12];
      break;
  }
  if (v26 != sub_1DC3DBFCC((unsigned __int8 *)v11)) {
    return 5;
  }
  uint64_t result = 0;
  *(float *)(a5 + 72) = (float)(a4[1] - *a2) / 3.0;
  *(float *)(a5 + 76) = (float)(a4[16] - a2[14]) / 5.0;
  uint64_t v29 = *(_DWORD **)(a5 + 64);
  v29[10] = 0;
  v29[11] = v5 - 17;
  v29[12] = *(_DWORD *)a2;
  v29[13] = *((_DWORD *)a4 + 16);
  v29[5] = 17;
  *int8x16_t v11 = v32;
  *(_DWORD *)(v11 + 1) = v22;
  v11[5] = v31;
  v11[6] = v23;
  v11[7] = v19;
  *((_DWORD *)v11 + 2) = 0;
  v11[12] = 0;
  return result;
}

uint64_t sub_1DC3DDBDC(uint64_t result, unsigned char *a2, uint64_t a3)
{
  unint64_t v3 = a3 - 1;
  if (*(void *)(result + 8) < (unint64_t)(a3 - 1)) {
    unint64_t v3 = *(void *)(result + 8);
  }
  if (v3 >= 0xD) {
    unint64_t v3 = 13;
  }
  if (v3)
  {
    uint64_t v4 = *(unsigned __int8 **)(result + 16);
    int v5 = a2;
    unint64_t v6 = v3;
    do
    {
      int v7 = *v4++;
      *v5++ = (v7 - 10 * ((205 * v7) >> 11)) | 0x30;
      --v6;
    }
    while (v6);
  }
  a2[v3] = 0;
  return result;
}

uint64_t sub_1DC3DDC38(uint64_t result, unsigned char *a2, uint64_t a3)
{
  unint64_t v3 = a3 - 1;
  if (*(void *)(result + 8) < (unint64_t)(a3 - 1)) {
    unint64_t v3 = *(void *)(result + 8);
  }
  if (v3 >= 8) {
    unint64_t v3 = 8;
  }
  if (v3)
  {
    uint64_t v4 = *(unsigned __int8 **)(result + 16);
    int v5 = a2;
    unint64_t v6 = v3;
    do
    {
      int v7 = *v4++;
      *v5++ = (v7 - 10 * ((205 * v7) >> 11)) | 0x30;
      --v6;
    }
    while (v6);
  }
  a2[v3] = 0;
  return result;
}

uint64_t sub_1DC3DDC94(uint64_t result, unsigned char *a2, uint64_t a3)
{
  unint64_t v3 = a3 - 1;
  if (*(void *)(result + 8) < (unint64_t)(a3 - 1)) {
    unint64_t v3 = *(void *)(result + 8);
  }
  if (v3 >= 8) {
    unint64_t v3 = 8;
  }
  if (v3)
  {
    uint64_t v4 = *(unsigned __int8 **)(result + 16);
    int v5 = a2;
    unint64_t v6 = v3;
    do
    {
      int v7 = *v4++;
      *v5++ = (v7 - 10 * ((205 * v7) >> 11)) | 0x30;
      --v6;
    }
    while (v6);
  }
  a2[v3] = 0;
  return result;
}

uint64_t sub_1DC3DDCF0(unsigned int a1)
{
  return (a1 < 0x2F) & (0x402040000000uLL >> a1);
}

BOOL sub_1DC3DDD0C(int a1)
{
  return a1 == 22;
}

BOOL sub_1DC3DDD18(int a1)
{
  return a1 == 17;
}

void sub_1DC3DDD24(int a1, void *a2)
{
}

void sub_1DC3DDD2C(int a1, unsigned int a2, unsigned int a3, float *a4, float *a5, float *a6, float *a7, _DWORD *a8, float *a9)
{
  uint64_t v9 = a7;
  uint64_t v14 = 0;
  float v15 = &a7[a3 * a2];
  uint64_t v16 = a3;
  uint64_t v46 = a3 * a1;
  uint64_t v17 = a2;
  uint64_t v18 = 4 * a2;
  do
  {
    float v19 = 0.0;
    int v20 = v9;
    unsigned __int8 v21 = a6;
    uint64_t v22 = v17;
    do
    {
      float v23 = *v20++;
      float v24 = v23;
      float v25 = *v21++;
      float v19 = v19 + (float)(v24 * v25);
      --v22;
    }
    while (v22);
    a4[v14] = 1.0 / (float)(expf(-(float)(v19 + v15[v14])) + 1.0);
    ++v14;
    uint64_t v9 = (float *)((char *)v9 + v18);
  }
  while (v14 != v16);
  uint64_t v26 = 0;
  char v27 = &v15[v16];
  char v28 = &v27[v46];
  do
  {
    float v29 = 0.0;
    float v30 = v27;
    int v31 = a4;
    uint64_t v32 = v16;
    do
    {
      float v33 = *v30++;
      float v34 = v33;
      float v35 = *v31++;
      float v29 = v29 + (float)(v34 * v35);
      --v32;
    }
    while (v32);
    a5[v26] = v29 + v28[v26];
    ++v26;
    v27 += v16;
  }
  while (v26 != a1);
  float v36 = *a5;
  uint64_t v37 = 1;
  float v38 = *a5;
  do
  {
    if (a5[v37] > v38) {
      float v38 = a5[v37];
    }
    ++v37;
  }
  while (a1 != v37);
  uint64_t v39 = 0;
  float v40 = 0.0;
  do
    float v40 = v40 + expf(a5[v39++] - v38);
  while (a1 != v39);
  float v41 = v38 + logf(v40);
  float v42 = expf(v36 - v41);
  int v43 = 0;
  *a5 = v42;
  uint64_t v44 = 1;
  do
  {
    float v45 = expf(a5[v44] - v41);
    a5[v44] = v45;
    if (v45 > v42)
    {
      float v42 = v45;
      int v43 = v44;
    }
    ++v44;
  }
  while (a1 != v44);
  *a8 = v43;
  *a9 = v42;
}

uint64_t sub_1DC3DDF0C(int *a1, size_t count, uint64_t a3)
{
  if ((int)count < 4) {
    return 6;
  }
  int v5 = *a1;
  if ((*a1 - 106) < 0xFFFFFFFD || a1[(count - 1)] != 106) {
    return 6;
  }
  uint64_t v7 = 0;
  int v8 = count - 2;
  do
  {
    int v9 = a1[v7 + 1];
    if (v9 > 102) {
      return 5;
    }
    v5 += v9 + v9 * v7++;
  }
  while (count - 3 != v7);
  if (v5 % 103 != a1[v8]) {
    return 5;
  }
  size_t v10 = count;
  *(void *)(a3 + 8) = count;
  *(_DWORD *)(a3 + 80) = 1;
  *(_DWORD *)(a3 + 84) = v8;
  int8x16_t v11 = *(void **)(a3 + 16);
  if (v11) {
    free(v11);
  }
  *(void *)(a3 + 16) = 0;
  double v12 = malloc_type_calloc(v10, 1uLL, 0x100004077774924uLL);
  uint64_t v13 = 0;
  *(void *)(a3 + 16) = v12;
  do
  {
    uint64_t result = 0;
    *(unsigned char *)(*(void *)(a3 + 16) + v13) = a1[v13];
    ++v13;
  }
  while (v10 != v13);
  return result;
}

uint64_t sub_1DC3DE03C(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t *a6, int a7, float32x2_t *a8, uint64_t a9)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (a7 < 13) {
    return 16;
  }
  *(_DWORD *)(a9 + 24) = 0;
  *(void *)(a9 + 8) = 0;
  uint64_t v49 = 0;
  float32x2_t v14 = *a8;
  uint64_t v15 = *a6;
  __int32 v16 = *((_DWORD *)a6 + 2);
  float v48 = *((float *)a6 + 3);
  float v17 = a8[1].f32[0];
  *(float32x2_t *)v18.f32 = *a8;
  v18.f32[2] = v17;
  v18.i32[3] = HIDWORD(*a6);
  *(float *)&a4 = 1.0 / (float)(v48 - COERCE_FLOAT(*a6));
  v19.i64[0] = *a6;
  v19.i64[1] = __PAIR64__(*a6, v16);
  *(float32x4_t *)float v53 = vmulq_n_f32(vsubq_f32(v18, v19), *(float *)&a4);
  v19.i32[0] = v14.i32[1];
  v20.i32[0] = vdup_lane_s32((int32x2_t)v14, 1).u32[0];
  v20.i32[1] = v16;
  v14.i32[1] = HIDWORD(v15);
  *(float32x2_t *)&v53[16] = vmul_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)&a4, 0), vsub_f32(v20, v14));
  float v54 = *(float *)&a4 * (float)(v17 - v19.f32[0]);
  sub_1DC3DDD2C(107, 7u, 0xFu, v52, v51, (float *)v53, flt_1DC417118, (_DWORD *)&v49 + 1, (float *)&v49);
  uint64_t result = 6;
  if ((HIDWORD(v49) - 106) >= 0xFFFFFFFD)
  {
    float v21 = *(float *)&v49;
    if (*(float *)&v49 >= 0.4)
    {
      int v46 = a7;
      uint64_t v47 = a9;
      v50[0] = HIDWORD(v49);
      uint64_t v22 = a7;
      unint64_t v23 = 1;
      uint64_t v24 = 3;
      float v25 = *(float *)&v49;
      int v26 = -1;
      int v27 = -1;
      float v28 = v48;
      while (1)
      {
        if (v24 + 3 >= v22 || v23 > 0x7F)
        {
          int v42 = v46;
          int v43 = v46;
          size_t v41 = v23;
          goto LABEL_26;
        }
        float v29 = *((float *)a6 + v24 + 3);
        float v30 = 1.0 / (float)(v29 - v28);
        float v31 = a8->f32[v24];
        uint64_t v32 = 4 * v24 + 4;
        *(float32x2_t *)v33.f32 = *(float32x2_t *)((char *)a8 + v32);
        float32x2_t v34 = *(float32x2_t *)((char *)a6 + v32);
        *(float *)float v53 = v30 * (float)(v31 - v28);
        *(float *)&v53[4] = v30 * vsub_f32(*(float32x2_t *)v33.f32, v34).f32[0];
        *(float32x2_t *)&v33.u32[2] = v34;
        v35.i64[0] = __PAIR64__(v34.u32[1], LODWORD(v31));
        v35.i64[1] = __PAIR64__(v34.u32[0], LODWORD(v28));
        int32x4_t v36 = (int32x4_t)vmulq_n_f32(vsubq_f32(v33, v35), v30);
        *(int32x4_t *)&v53[8] = vzip2q_s32(vzip1q_s32(v36, (int32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v36, 0xCuLL)), v36);
        float v54 = v30 * vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.f32, 1), *(float32x2_t *)v33.f32).f32[0];
        sub_1DC3DDD2C(107, 7u, 0xFu, v52, v51, (float *)v53, flt_1DC417118, (_DWORD *)&v49 + 1, (float *)&v49);
        float v37 = *(float *)&v49;
        if (*(float *)&v49 >= 0.4)
        {
          int v39 = HIDWORD(v49);
        }
        else
        {
          if (v27 != -1) {
            return 13;
          }
          int v26 = 0;
          float v38 = v51[0];
          int v39 = HIDWORD(v49);
          for (uint64_t i = 1; i != 107; ++i)
          {
            if (HIDWORD(v49) != i && v51[i] > v38)
            {
              int v26 = i;
              float v38 = v51[i];
            }
          }
          int v27 = (float)(*(float *)&v49 - v38) > 0.1 ? -1 : v23;
        }
        size_t v41 = v23 + 1;
        v50[v23] = v39;
        float v21 = v21 + v37;
        if (v37 < v25) {
          float v25 = v37;
        }
        if (v39 == 106) {
          break;
        }
        v24 += 3;
        float v28 = v29;
        ++v23;
        if (v39 > 102) {
          return 6;
        }
      }
      int v43 = v24 + 4;
      int v42 = v46;
LABEL_26:
      uint64_t result = sub_1DC3DDF0C(v50, v41, v47);
      if (result && v27 != -1)
      {
        v50[v27] = v26;
        uint64_t result = sub_1DC3DDF0C(v50, v41, v47);
      }
      if (!result)
      {
        if ((*(int *)((char *)v50 + ((uint64_t)((v41 << 32) - 0x300000000) >> 30)) - 98) <= 3) {
          *(_DWORD *)(v47 + 4) = 4;
        }
        uint64_t result = 0;
        *(float *)(v47 + 24) = (float)((float)(v21 / (float)(int)v41) * 0.3) + (float)(v25 * 0.7);
        *(float *)(v47 + 72) = (float)(*((float *)a6 + 6) - *(float *)a6) / 22.0;
        uint64_t v44 = 4 * v43 - 4;
        *(float *)(v47 + 76) = (float)(*(float *)((char *)a6 + v44) - *((float *)a6 + v43 - 7)) / 22.0;
        float v45 = *(_DWORD **)(v47 + 64);
        v45[10] = 0;
        v45[11] = v42 - v43;
        v45[12] = *(_DWORD *)a6;
        v45[13] = *(__int32 *)((char *)a8->i32 + v44);
        v45[5] = v43;
      }
    }
  }
  return result;
}

void sub_1DC3DE448(uint64_t a1, unsigned char *a2, uint64_t a3, void *a4, const char *a5)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 8);
  if ((int)v5 < 4) {
    return;
  }
  unint64_t v6 = *(char **)(a1 + 16);
  unsigned int v7 = *v6 - 103;
  if (v7 > 2 || v6[(v5 - 1)] != 106) {
    return;
  }
  double v12 = malloc_type_calloc((2 * v5), 1uLL, 0x100004077774924uLL);
  uint64_t v13 = 0;
  char v14 = 0;
  int v15 = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  int v18 = -1;
  int v19 = -1;
  int v20 = -1;
  while (1)
  {
    char v21 = v6[v13 + 1];
    if (!v7 && (v16 & 1) == 0 || v7 == 1 && ((v16 ^ 1) & 1) == 0)
    {
      if (v6[v13 + 1] > 0x3Fu)
      {
        if ((v21 & 0xE0) != 0x40)
        {
          int v22 = 0;
          uint64_t v16 = 0;
          switch(v6[v13 + 1])
          {
            case 'a':
              goto LABEL_15;
            case 'b':
              goto LABEL_33;
            case 'c':
              goto LABEL_39;
            case 'd':
              int v22 = 0;
              uint64_t v16 = 0;
              unsigned int v7 = 1;
              break;
            case 'e':
              int v28 = v15 ^ 1;
              int v29 = v17 - 1;
              BOOL v30 = v6[v13] == 101;
              goto LABEL_47;
            case 'f':
              goto LABEL_40;
            default:
              goto LABEL_38;
          }
          goto LABEL_15;
        }
        int v22 = 0;
        uint64_t v16 = 0;
        char v23 = v21 - 64;
        goto LABEL_13;
      }
LABEL_10:
      int v22 = 0;
      uint64_t v16 = 0;
      char v23 = v21 + 32;
LABEL_13:
      v12[v17] = v23;
LABEL_14:
      ++v17;
      goto LABEL_15;
    }
    if (!((v7 != 1) | v16 & 1) || !((v7 != 0) | (v16 ^ 1) & 1)) {
      break;
    }
    if (v7 != 2) {
      goto LABEL_59;
    }
    unsigned int v25 = v6[v13 + 1];
    if (v25 <= 0x63)
    {
      char v26 = v6[v13 + 1] / 0xAu;
      int v27 = &v12[v17];
      *int v27 = v26 + 48;
      v17 += 2;
      v27[1] = (v21 - 10 * v26) | 0x30;
LABEL_28:
      unsigned int v7 = 2;
      goto LABEL_21;
    }
    if (v25 == 100)
    {
      unsigned int v7 = 1;
      goto LABEL_21;
    }
    if (v25 == 102)
    {
      if (v13 >= 2)
      {
        v12[v17] = 29;
        unsigned int v7 = 2;
        ++v17;
        goto LABEL_21;
      }
      goto LABEL_28;
    }
    if (v25 != 101) {
      goto LABEL_59;
    }
    unsigned int v7 = 0;
LABEL_21:
    if ((v5 - 2) - 1 == ++v13)
    {
      if (v14)
      {
        if (a5) {
          float v31 = a5;
        }
        else {
          float v31 = "ISO-8859-1";
        }
        uint64_t v32 = MEMORY[0x1E019D3A0]("UTF-8", v31, v16);
        if (v32 == -1)
        {
          if (qword_1EAA94CD0 != -1) {
            dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
          }
          float v40 = qword_1EAA94CC8;
          if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR))
          {
            int v41 = *__error();
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "UTF-8";
            __int16 v50 = 2082;
            float v51 = v31;
            __int16 v52 = 1026;
            int v53 = v41;
            _os_log_error_impl(&dword_1DC2FE000, v40, OS_LOG_TYPE_ERROR, "[Code128] iconv_open(\"%{public}s\", \"%{public}s\") failed: %{public, errno}d", buf, 0x1Cu);
          }
        }
        else
        {
          uint64_t v33 = v32;
          *(void *)long long buf = v17;
          float v45 = a2;
          uint64_t v46 = a3;
          uint64_t v44 = v12;
          if (MEMORY[0x1E019D380](v32, &v44, buf, &v45, &v46) == -1)
          {
            if (qword_1EAA94CD0 != -1) {
              dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
            }
            int v42 = qword_1EAA94CC8;
            if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR))
            {
              int v43 = *__error();
              *(_DWORD *)uint64_t v47 = 67240192;
              int v48 = v43;
              _os_log_error_impl(&dword_1DC2FE000, v42, OS_LOG_TYPE_ERROR, "[Code128] iconv failed: %{public, errno}d", v47, 8u);
            }
            MEMORY[0x1E019D390](v33);
          }
          else
          {
            MEMORY[0x1E019D390](v33);
            if (v46)
            {
              uint64_t v34 = a3 - v46;
              *a4 = a3 - v46;
              a2[v34] = 0;
            }
          }
        }
      }
      else
      {
        int v35 = v17;
        if (a3 - 1 < (unint64_t)v17) {
          int v35 = a3 - 1;
        }
        if (v35 >= 1)
        {
          uint64_t v36 = v35;
          float v37 = v12;
          float v38 = a2;
          do
          {
            char v39 = *v37++;
            *v38++ = v39;
            --v36;
          }
          while (v36);
        }
        a2[v35] = 0;
        *a4 = v35;
      }
      goto LABEL_84;
    }
  }
  if (v6[v13 + 1] <= 0x5Fu) {
    goto LABEL_10;
  }
  int v22 = 0;
  uint64_t v16 = 0;
  switch(v6[v13 + 1])
  {
    case 'a':
      break;
    case 'b':
LABEL_33:
      int v22 = 0;
      uint64_t v16 = 1;
      break;
    case 'c':
LABEL_39:
      int v22 = 0;
      uint64_t v16 = 0;
      unsigned int v7 = 2;
      break;
    case 'd':
      int v28 = v15 ^ 1;
      int v29 = v17 - 1;
      BOOL v30 = v6[v13] == 100;
LABEL_47:
      int v22 = 0;
      uint64_t v16 = 0;
      if (v30) {
        int v19 = v17;
      }
      else {
        int v20 = v17;
      }
      if (v30) {
        int v18 = v29;
      }
      if (v30) {
        int v15 = v28;
      }
      break;
    case 'e':
      unsigned int v7 = 0;
      goto LABEL_57;
    case 'f':
LABEL_40:
      if (v13 >= 2)
      {
        int v22 = 0;
        uint64_t v16 = 0;
        v12[v17] = 29;
        goto LABEL_14;
      }
LABEL_57:
      int v22 = 0;
      uint64_t v16 = 0;
      break;
    default:
LABEL_38:
      uint64_t v16 = 0;
      int v22 = 7;
      break;
  }
LABEL_15:
  int v24 = v17 - 1;
  if (v20 == v17 - 1 && v19 < v24)
  {
    v12[v20] ^= 0x80u;
    char v14 = 1;
    int v19 = v20;
  }
  if ((v15 & (v18 < v24)) != 0)
  {
    v12[v24] ^= 0x80u;
    int v15 = 1;
    int v18 = v17 - 1;
    char v14 = 1;
  }
  if (!v22) {
    goto LABEL_21;
  }
LABEL_59:
  if (a3) {
    *a2 = 0;
  }
LABEL_84:
  free(v12);
}

BOOL sub_1DC3DEA44(int a1)
{
  return a1 > 12 && a1 % 3 == 1;
}

float sub_1DC3DEA74(uint64_t a1, uint64_t a2, int a3, float *a4)
{
  uint64_t v4 = 4 * a3;
  uint64_t v5 = v4 + 16;
  float v6 = *(float *)(a1 + v4);
  float v7 = 1.0 / (float)(*(float *)(a2 + v4 + 16) - v6);
  *a4 = v7 * (float)(*(float *)(a2 + v4) - v6);
  uint64_t v8 = v4 + 4;
  a4[1] = v7 * (float)(*(float *)(a2 + v4 + 4) - *(float *)(a1 + v4 + 4));
  uint64_t v9 = v4 + 8;
  a4[2] = v7 * (float)(*(float *)(a2 + v4 + 8) - *(float *)(a1 + v4 + 8));
  v4 += 12;
  a4[3] = v7 * (float)(*(float *)(a2 + v4) - *(float *)(a1 + v4));
  a4[4] = v7 * (float)(*(float *)(a2 + v5) - *(float *)(a1 + v5));
  a4[5] = v7 * (float)(*(float *)(a1 + v8) - *(float *)(a1 + 4 * a3));
  a4[6] = v7 * (float)(*(float *)(a2 + v8) - *(float *)(a2 + 4 * a3));
  a4[7] = v7 * (float)(*(float *)(a1 + v9) - *(float *)(a1 + v8));
  a4[8] = v7 * (float)(*(float *)(a2 + v9) - *(float *)(a2 + v8));
  a4[9] = v7 * (float)(*(float *)(a1 + v4) - *(float *)(a1 + v9));
  a4[10] = v7 * (float)(*(float *)(a2 + v4) - *(float *)(a2 + v9));
  a4[11] = v7 * (float)(*(float *)(a1 + v5) - *(float *)(a1 + v4));
  float result = v7 * (float)(*(float *)(a2 + v5) - *(float *)(a2 + v4));
  a4[12] = result;
  return result;
}

uint64_t sub_1DC3DEBA0(uint64_t a1, float *a2, int a3, float *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (a3 < 20) {
    char v8 = a7;
  }
  else {
    char v8 = 0;
  }
  uint64_t v9 = 16;
  if (a3 < 15 || (v8 & 1) != 0) {
    return v9;
  }
  unsigned int v10 = a3 / 5u;
  if (a3 % 5u) {
    return 2;
  }
  uint64_t v13 = (unsigned int *)malloc_type_malloc(4 * v10, 0x100004052888210uLL);
  float v48 = 0.0;
  sub_1DC3DEA74((uint64_t)a2, (uint64_t)a4, 5 * (v10 - 1), v51);
  unsigned int v46 = v10 - 1;
  char v14 = &v13[v10 - 1];
  sub_1DC3DDD2C(44, 0xDu, 0x14u, v50, v49, v51, flt_1DC418DB8, v14, &v48);
  if (*v14 != 43) {
    goto LABEL_89;
  }
  int v15 = 0;
  uint64_t v16 = 0;
  float v17 = v48 + 0.0;
  float v18 = fminf(v48, INFINITY);
  uint64_t v19 = v10 - 1;
  do
  {
    sub_1DC3DEA74((uint64_t)a2, (uint64_t)a4, v15, v51);
    sub_1DC3DDD2C(44, 0xDu, 0x14u, v50, v49, v51, flt_1DC418DB8, &v13[v16], &v48);
    if (!(v16 * 4) && *v13 != 43) {
      goto LABEL_89;
    }
    float v17 = v17 + v48;
    if (v48 < v18) {
      float v18 = v48;
    }
    ++v16;
    v15 += 5;
    --v19;
  }
  while (v19);
  float v20 = (float)((float)(v17 / (float)(int)v10) * 0.2) + (float)(v18 * 0.8);
  *(float *)(a5 + 24) = v20;
  BOOL v21 = v20 > 0.65 && a3 > 0x1D;
  if (!v21 && v20 <= 0.85 || *v13 != 43 || v13[v46] != 43)
  {
LABEL_89:
    *(_DWORD *)(a5 + 24) = 0;
    *(void *)(a5 + 8) = 0;
    uint64_t v9 = 6;
    goto LABEL_90;
  }
  int v22 = malloc_type_malloc(v10, 0x100004077774924uLL);
  uint64_t v23 = v10 - 2;
  if (a7) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = v46;
  }
  if ((int)v24 < 2)
  {
    int v26 = 0;
    int v33 = 0;
    uint64_t v29 = a5;
    if (a7) {
      goto LABEL_80;
    }
    goto LABEL_81;
  }
  unsigned int v25 = 0;
  int v26 = 0;
  uint64_t v27 = v24 - 1;
  int v28 = v13 + 1;
  uint64_t v29 = a5;
  while (2)
  {
    unsigned int v31 = *v28++;
    unsigned int v30 = v31;
    switch(v25)
    {
      case 0u:
        if (v30 - 39 > 3)
        {
          if (v30 <= 9)
          {
            unsigned int v25 = 0;
            char v32 = v30 + 48;
            goto LABEL_56;
          }
          if (v30 - 10 <= 0x19)
          {
            unsigned int v25 = 0;
            char v32 = v30 + 55;
            goto LABEL_56;
          }
          switch(v30)
          {
            case '&':
              unsigned int v25 = 0;
              v22[v26] = 32;
              break;
            case '%':
              unsigned int v25 = 0;
              v22[v26] = 46;
              break;
            case '$':
              unsigned int v25 = 0;
              v22[v26] = 45;
              break;
            default:
              goto LABEL_88;
          }
        }
        else
        {
          if (a6)
          {
            unsigned int v25 = v30 - 38;
            goto LABEL_58;
          }
          if (v30 == 41)
          {
            unsigned int v25 = 0;
            v22[v26] = 43;
          }
          else if (v30 == 40)
          {
            unsigned int v25 = 0;
            v22[v26] = 47;
          }
          else
          {
            unsigned int v25 = 0;
            if (v30 == 39) {
              v22[v26] = 36;
            }
            else {
              v22[v26] = 37;
            }
          }
        }
        goto LABEL_57;
      case 1u:
        if (v30 - 10 > 0x19) {
          goto LABEL_88;
        }
        unsigned int v25 = 0;
        char v32 = v30 - 9;
        goto LABEL_56;
      case 2u:
        if (v30 - 10 <= 4)
        {
          unsigned int v25 = 0;
          char v32 = v30 + 17;
LABEL_56:
          v22[v26] = v32;
          goto LABEL_57;
        }
        if (v30 - 15 <= 4)
        {
          unsigned int v25 = 0;
          char v32 = v30 + 44;
          goto LABEL_56;
        }
        if (v30 - 20 <= 4)
        {
          unsigned int v25 = 0;
          char v32 = v30 + 71;
          goto LABEL_56;
        }
        if (v30 - 25 <= 4)
        {
          unsigned int v25 = 0;
          char v32 = v30 + 98;
          goto LABEL_56;
        }
        switch(v30)
        {
          case 0x20u:
            unsigned int v25 = 0;
            v22[v26] = 96;
            break;
          case 0x1Fu:
            unsigned int v25 = 0;
            v22[v26] = 64;
            break;
          case 0x1Eu:
            unsigned int v25 = 0;
            v22[v26] = 0;
            break;
          default:
            if (v30 - 33 > 2) {
              goto LABEL_88;
            }
            unsigned int v25 = 0;
            v22[v26] = 127;
            break;
        }
LABEL_57:
        ++v26;
LABEL_58:
        if (--v27) {
          continue;
        }
        if (a7)
        {
          int v34 = 0;
          uint64_t v35 = v23 - 1;
          uint64_t v36 = (int *)(v13 + 1);
          do
          {
            int v37 = *v36++;
            v34 += v37;
            --v35;
          }
          while (v35);
          int v33 = v34 % 43;
LABEL_80:
          if (v33 != v13[(int)v24])
          {
LABEL_88:
            *(_DWORD *)(v29 + 24) = 0;
            *(void *)(v29 + 8) = 0;
            free(v22);
            goto LABEL_89;
          }
        }
LABEL_81:
        uint64_t v38 = v26;
        *(void *)(v29 + 8) = v26;
        *(_DWORD *)(v29 + 80) = 1;
        *(_DWORD *)(v29 + 84) = v26;
        char v39 = *(void **)(v29 + 16);
        if (v39) {
          free(v39);
        }
        *(void *)(v29 + 16) = 0;
        float v40 = malloc_type_malloc((int)v38 + 1, 0x100004077774924uLL);
        *(void *)(v29 + 16) = v40;
        if ((int)v38 >= 1)
        {
          uint64_t v41 = 0;
          do
          {
            *(unsigned char *)(*(void *)(v29 + 16) + v41) = v22[v41];
            ++v41;
          }
          while (v38 != v41);
          float v40 = *(unsigned char **)(v29 + 16);
        }
        v40[v38] = 0;
        free(v22);
        uint64_t v9 = 0;
        *(float *)(v29 + 72) = (float)((float)((float)((float)(*a4 - *a2) + (float)(a2[2] - a2[1]))
                                             + (float)(a2[3] - a4[2]))
                                     + (float)(a4[4] - a4[3]))
                             / 6.0;
        *(float *)(v29 + 76) = (float)((float)((float)((float)(a4[a3 - 5] - a2[a3 - 5])
                                                     + (float)(a2[a3 - 3] - a2[a3 - 4]))
                                             + (float)(a2[a3 - 2] - a4[a3 - 3]))
                                     + (float)(a4[a3 - 1] - a4[a3 - 2]))
                             / 6.0;
        uint64_t v42 = *(void *)(v29 + 64);
        *(void *)(v42 + 40) = 0;
        *(float *)(v42 + 48) = *a2;
        *(float *)(v42 + 52) = a4[a3 - 1];
        *(_DWORD *)(v42 + 20) = a3;
LABEL_90:
        free(v13);
        return v9;
      case 3u:
        if (v30 - 10 > 0x19) {
          goto LABEL_88;
        }
        unsigned int v25 = 0;
        char v32 = v30 + 23;
        goto LABEL_56;
      case 4u:
        if (v30 - 10 > 0x19) {
          goto LABEL_88;
        }
        unsigned int v25 = 0;
        char v32 = v30 + 87;
        goto LABEL_56;
      default:
        goto LABEL_88;
    }
  }
}

uint64_t sub_1DC3DF238(uint64_t a1, float *a2, int a3, float *a4, uint64_t a5)
{
  return sub_1DC3DEBA0(a1, a2, a3, a4, a5, 0, 0);
}

uint64_t sub_1DC3DF244(uint64_t a1, float *a2, int a3, float *a4, uint64_t a5)
{
  return sub_1DC3DEBA0(a1, a2, a3, a4, a5, 1, 0);
}

uint64_t sub_1DC3DF250(uint64_t a1, float *a2, int a3, float *a4, uint64_t a5)
{
  return sub_1DC3DEBA0(a1, a2, a3, a4, a5, 0, 1);
}

uint64_t sub_1DC3DF25C(uint64_t a1, float *a2, int a3, float *a4, uint64_t a5)
{
  return sub_1DC3DEBA0(a1, a2, a3, a4, a5, 1, 1);
}

uint64_t sub_1DC3DF268(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a3 - 1;
  unint64_t v4 = *(void *)(result + 8);
  if (v4) {
    BOOL v5 = a3 == 1;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    unint64_t v6 = 0;
    do
    {
      *(unsigned char *)(a2 + v6) = *(unsigned char *)(*(void *)(result + 16) + v6);
      ++v6;
      unint64_t v4 = *(void *)(result + 8);
    }
    while (v4 > v6 && v3 > v6);
  }
  if (v4 < v3) {
    unint64_t v3 = v4;
  }
  *(unsigned char *)(a2 + v3) = 0;
  return result;
}

BOOL sub_1DC3DF2B0(int a1)
{
  return a1 > 14 && (-858993459 * a1 + 429496729) < 0x33333333;
}

BOOL sub_1DC3DF2D8(int a1)
{
  return a1 > 19 && (-858993459 * a1 + 429496729) < 0x33333333;
}

float sub_1DC3DF300(uint64_t a1, uint64_t a2, int a3, float *a4)
{
  unint64_t v4 = (float *)(a1 + 4 * a3);
  uint64_t v5 = 4 * a3;
  float v6 = 1.0 / (float)(v4[3] - *v4);
  *a4 = v6 * (float)(*(float *)(a2 + v5) - *v4);
  uint64_t v7 = v5 + 4;
  a4[1] = v6 * (float)(*(float *)(a2 + v5 + 4) - *(float *)(a1 + v5 + 4));
  v5 += 8;
  a4[2] = v6 * (float)(*(float *)(a2 + v5) - *(float *)(a1 + v5));
  a4[3] = v6 * (float)(*(float *)(a1 + v7) - *v4);
  a4[4] = v6 * (float)(*(float *)(a2 + v7) - *(float *)(a2 + 4 * a3));
  a4[5] = v6 * (float)(*(float *)(a1 + v5) - *(float *)(a1 + v7));
  float result = v6 * (float)(*(float *)(a2 + v5) - *(float *)(a2 + v7));
  a4[6] = result;
  return result;
}

uint64_t sub_1DC3DF3B0(uint64_t a1, float *a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (a3 < 16) {
    return 16;
  }
  if ((-1431655765 * a3 + 1431655765) > 0x55555554) {
    return 2;
  }
  unsigned int v40 = a3 - 1;
  unint64_t v9 = (a3 - 1) / 3uLL;
  unsigned int v10 = (unsigned int *)malloc_type_malloc(4 * v9, 0x100004052888210uLL);
  float v43 = 0.0;
  size_t v41 = v9;
  uint64_t v11 = (v9 - 1);
  sub_1DC3DF300((uint64_t)a2, a4, 3 * v11, v46);
  double v12 = &v10[v11];
  sub_1DC3DDD2C(48, 7u, 0xFu, v45, v44, v46, flt_1DC41A088, v12, &v43);
  if (*v12 != 47)
  {
LABEL_56:
    *(_DWORD *)(a5 + 24) = 0;
    *(void *)(a5 + 8) = 0;
    uint64_t v6 = 6;
    goto LABEL_72;
  }
  int v13 = 0;
  uint64_t v14 = 0;
  float v15 = v43 + 0.0;
  float v16 = fminf(v43, INFINITY);
  do
  {
    sub_1DC3DF300((uint64_t)a2, a4, v13, v46);
    sub_1DC3DDD2C(48, 7u, 0xFu, v45, v44, v46, flt_1DC41A088, &v10[v14], &v43);
    if (!(v14 * 4) && *v10 != 47) {
      goto LABEL_56;
    }
    float v15 = v15 + v43;
    if (v43 < v16) {
      float v16 = v43;
    }
    ++v14;
    v13 += 3;
    --v11;
  }
  while (v11);
  float v17 = (float)((float)(v15 / (float)(int)v41) * 0.3) + (float)(v16 * 0.7);
  *(float *)(a5 + 24) = v17;
  if (*v10 != 47 || *v12 != 47)
  {
    uint64_t v6 = 6;
LABEL_71:
    *(float *)(a5 + 24) = v17 / 100.0;
    goto LABEL_72;
  }
  float v18 = malloc_type_malloc(v41, 0x100004077774924uLL);
  unsigned int v19 = 0;
  int v20 = 0;
  uint64_t v21 = (v41 - 3);
  uint64_t v22 = v21 - 1;
  uint64_t v23 = v10 + 1;
  while (2)
  {
    unsigned int v25 = *v23++;
    unsigned int v24 = v25;
    switch(v19)
    {
      case 0u:
        if (v24 - 43 <= 3)
        {
          unsigned int v19 = v24 - 42;
          goto LABEL_39;
        }
        if (v24 > 9)
        {
          if (v24 - 10 > 0x19)
          {
            switch(v24)
            {
              case '$':
                unsigned int v19 = 0;
                v18[v20] = 45;
                goto LABEL_38;
              case '%':
                unsigned int v19 = 0;
                v18[v20] = 46;
                goto LABEL_38;
              case '&':
                unsigned int v19 = 0;
                v18[v20] = 32;
                goto LABEL_38;
              case '\'':
                unsigned int v19 = 0;
                v18[v20] = 36;
                goto LABEL_38;
              case '(':
                unsigned int v19 = 0;
                v18[v20] = 47;
                goto LABEL_38;
              case ')':
                unsigned int v19 = 0;
                v18[v20] = 43;
                goto LABEL_38;
              case '*':
                unsigned int v19 = 0;
                v18[v20] = 37;
                goto LABEL_38;
              default:
                goto LABEL_68;
            }
          }
          unsigned int v19 = 0;
          char v26 = v24 + 55;
        }
        else
        {
          unsigned int v19 = 0;
          char v26 = v24 + 48;
        }
        goto LABEL_37;
      case 1u:
        if (v24 - 10 > 0x19) {
          goto LABEL_68;
        }
        unsigned int v19 = 0;
        char v26 = v24 - 9;
        goto LABEL_37;
      case 2u:
        if (v24 - 10 <= 4)
        {
          unsigned int v19 = 0;
          char v26 = v24 + 17;
LABEL_37:
          v18[v20] = v26;
          goto LABEL_38;
        }
        if (v24 - 15 <= 4)
        {
          unsigned int v19 = 0;
          char v26 = v24 + 44;
          goto LABEL_37;
        }
        if (v24 - 20 <= 4)
        {
          unsigned int v19 = 0;
          char v26 = v24 + 71;
          goto LABEL_37;
        }
        if (v24 - 25 <= 4)
        {
          unsigned int v19 = 0;
          char v26 = v24 + 98;
          goto LABEL_37;
        }
        switch(v24)
        {
          case 0x20u:
            unsigned int v19 = 0;
            v18[v20] = 96;
            break;
          case 0x1Fu:
            unsigned int v19 = 0;
            v18[v20] = 64;
            break;
          case 0x1Eu:
            unsigned int v19 = 0;
            v18[v20] = 0;
            break;
          default:
            if (v24 - 33 > 2)
            {
LABEL_68:
              uint64_t v6 = 7;
LABEL_70:
              *(void *)(a5 + 8) = 0;
              free(v18);
              float v17 = *(float *)(a5 + 24);
              goto LABEL_71;
            }
            unsigned int v19 = 0;
            v18[v20] = 127;
            break;
        }
LABEL_38:
        ++v20;
LABEL_39:
        if (--v22) {
          continue;
        }
        unint64_t v27 = (v41 - 4);
        int32x2_t v28 = (int32x2_t)1;
        int32x2_t v29 = 0;
        do
        {
          int8x8_t v30 = (int8x8_t)vadd_s32(v28, (int32x2_t)0x100000001);
          int32x2_t v31 = vcgt_s32(v28, (int32x2_t)0x130000000ELL);
          char v32 = (const float *)&v10[v27];
          int32x2_t v28 = vsub_s32((int32x2_t)vbic_s8(v30, (int8x8_t)v31), v31);
          int32x2_t v33 = (int32x2_t)vld1_dup_f32(v32);
          int32x2_t v29 = vmla_s32(v29, v33, v28);
        }
        while (v27-- > 1);
        if (v29.i32[1] % 47 != v10[v21] || (v29.i32[0] + v29.i32[1] % 47) % 47 != v10[(v41 - 2)])
        {
          uint64_t v6 = 5;
          goto LABEL_70;
        }
        *(void *)(a5 + 8) = v20;
        uint64_t v35 = *(void **)(a5 + 16);
        if (v35) {
          free(v35);
        }
        *(void *)(a5 + 16) = 0;
        uint64_t v36 = malloc_type_malloc(v20 + 1, 0x100004077774924uLL);
        *(void *)(a5 + 16) = v36;
        if (v20 >= 1)
        {
          for (uint64_t i = 0; i != v20; ++i)
            *(unsigned char *)(*(void *)(a5 + 16) + i) = v18[i];
          uint64_t v36 = *(unsigned char **)(a5 + 16);
        }
        v36[v20] = 0;
        *(_DWORD *)(a5 + 80) = 1;
        *(_DWORD *)(a5 + 84) = v41;
        free(v18);
        uint64_t v6 = 0;
        *(float *)(a5 + 72) = (float)(a2[6] - *a2) / 18.0;
        *(float *)(a5 + 76) = (float)(a2[v40] - a2[a3 - 7]) / 18.0;
        uint64_t v38 = *(void *)(a5 + 64);
        *(void *)(v38 + 40) = 0;
        *(float *)(v38 + 48) = *a2;
        *(_DWORD *)(v38 + 52) = *(_DWORD *)(a4 + 4 * v40);
        *(_DWORD *)(v38 + 20) = a3;
LABEL_72:
        free(v10);
        return v6;
      case 3u:
        if (v24 - 10 > 0x19) {
          goto LABEL_68;
        }
        unsigned int v19 = 0;
        char v26 = v24 + 23;
        goto LABEL_37;
      case 4u:
        if (v24 - 10 > 0x19) {
          goto LABEL_68;
        }
        unsigned int v19 = 0;
        char v26 = v24 + 87;
        goto LABEL_37;
      default:
        goto LABEL_68;
    }
  }
}

uint64_t sub_1DC3DFA20(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  unint64_t v4 = *(void *)(result + 8);
  if (v4 >= a3 - 1) {
    unint64_t v4 = a3 - 1;
  }
  if (v4)
  {
    unint64_t v5 = 0;
    do
    {
      *(unsigned char *)(a2 + v5) = *(unsigned char *)(*(void *)(result + 16) + v5);
      ++v5;
      unint64_t v6 = *(void *)(result + 8);
      if (v6 >= a3 - 1) {
        unint64_t v6 = a3 - 1;
      }
    }
    while (v6 > v5);
  }
  else
  {
    unint64_t v6 = 0;
  }
  *a4 = v6;
  *(unsigned char *)(a2 + v6) = 0;
  return result;
}

BOOL sub_1DC3DFA70(int a1)
{
  return a1 > 15 && a1 % 3 == 1;
}

__n128 sub_1DC3DFAA0@<Q0>(uint64_t *a1@<X1>, __n128 *a2@<X8>)
{
  unint64_t v4 = operator new(0x30uLL);
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = &unk_1F36622A8;
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  v4[3] = &unk_1F3660E70;
  v4[4] = v6;
  v4[5] = v5;
  result.n128_u64[0] = (unint64_t)(v4 + 3);
  result.n128_u64[1] = (unint64_t)v4;
  *a2 = result;
  return result;
}

uint64_t sub_1DC3DFB34(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1DC3DFB58(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F36622A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1E019CE90);
}

void sub_1DC3DFBAC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F36622A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1DC3DFBCC(void **a1)
{
  (*(void (**)(long long *__return_ptr))(*a1[1] + 80))(&v2);
  long long v3 = v2;
  long long v2 = 0uLL;
  ((void (*)(void **, long long *))(*a1)[12])(a1, &v3);
  if (*((void *)&v3 + 1)) {
    sub_1DC32EEF4(*((std::__shared_weak_count **)&v3 + 1));
  }
  if (*((void *)&v2 + 1)) {
    sub_1DC32EEF4(*((std::__shared_weak_count **)&v2 + 1));
  }
}

void sub_1DC3DFC78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1DC32EEF4(a12);
  }
  if (a10) {
    sub_1DC32EEF4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3DFC9C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72))();
}

void sub_1DC3DFCC4(void **a1)
{
  (*(void (**)(long long *__return_ptr))(*a1[1] + 64))(&v2);
  long long v3 = v2;
  long long v2 = 0uLL;
  ((void (*)(void **, long long *))(*a1)[12])(a1, &v3);
  if (*((void *)&v3 + 1)) {
    sub_1DC32EEF4(*((std::__shared_weak_count **)&v3 + 1));
  }
  if (*((void *)&v2 + 1)) {
    sub_1DC32EEF4(*((std::__shared_weak_count **)&v2 + 1));
  }
}

void sub_1DC3DFD70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1DC32EEF4(a12);
  }
  if (a10) {
    sub_1DC32EEF4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3DFD94(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))();
}

BOOL sub_1DC3DFDBC(uint64_t a1, uint64_t a2, void *a3)
{
  int v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8));
  if (v6 < 3) {
    return 0;
  }
  unsigned int v8 = v6;
  a3[1] = *a3;
  uint64_t v92 = 0;
  uint64_t v93 = 0;
  uint64_t v94 = 0;
  uint64_t v9 = (*(uint64_t (**)(void, uint64_t, void **, void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), a2, &v92, 0);
  unsigned int v10 = (unsigned __int8 *)v9;
  uint64_t v11 = 0;
  uint64_t v12 = v8;
  memset(v91, 0, sizeof(v91));
  do
  {
    unint64_t v13 = ((unint64_t)*(unsigned __int8 *)(v9 + v11) >> 1) & 0x7C;
    ++*(_DWORD *)((char *)v91 + v13);
    ++v11;
  }
  while (v8 != v11);
  int v14 = sub_1DC3E0318((char *)v91);
  BOOL v7 = v14 > 0;
  if (v14 > 0)
  {
    int v15 = v14;
    unsigned int v16 = *v10;
    BOOL v17 = v14 > v16;
    if (v14 > v16)
    {
      unsigned int v19 = (_WORD *)a3[1];
      unint64_t v18 = a3[2];
      if ((unint64_t)v19 >= v18)
      {
        uint64_t v21 = (_WORD *)*a3;
        uint64_t v22 = (uint64_t)v19 - *a3;
        if (v22 <= -3) {
          sub_1DC2FF97C();
        }
        uint64_t v23 = v22 >> 1;
        unint64_t v24 = v18 - (void)v21;
        if (v24 <= (v22 >> 1) + 1) {
          unint64_t v25 = v23 + 1;
        }
        else {
          unint64_t v25 = v24;
        }
        BOOL v26 = v24 >= 0x7FFFFFFFFFFFFFFELL;
        uint64_t v27 = 0x7FFFFFFFFFFFFFFFLL;
        if (!v26) {
          uint64_t v27 = v25;
        }
        if (v27)
        {
          uint64_t v27 = (uint64_t)sub_1DC3CC130(v27);
          uint64_t v21 = (_WORD *)*a3;
          unsigned int v19 = (_WORD *)a3[1];
        }
        else
        {
          uint64_t v28 = 0;
        }
        int32x2_t v29 = (_WORD *)(v27 + 2 * v23);
        uint64_t v30 = v27 + 2 * v28;
        _WORD *v29 = 0;
        int v20 = v29 + 1;
        while (v19 != v21)
        {
          __int16 v31 = *--v19;
          *--int32x2_t v29 = v31;
        }
        *a3 = v29;
        a3[1] = v20;
        a3[2] = v30;
        if (v21) {
          operator delete(v21);
        }
      }
      else
      {
        *unsigned int v19 = 0;
        int v20 = v19 + 1;
      }
      a3[1] = v20;
    }
    char v32 = &v10[v12 - 1];
    int32x2_t v33 = v10 + 1;
    __int16 v34 = (__int16)v10;
    do
    {
      int v35 = *v10;
      int v36 = v10[1];
      int v37 = v10[2];
      unsigned int v10 = v33;
      BOOL v38 = v15 > (int)(4 * v36 - (v37 + v35) + (((4 * v36 - (v37 + v35)) & 0x8000u) >> 15)) >> 1;
      if (v38 != v17)
      {
        __int16 v39 = (_WORD)v33 - v34;
        size_t v41 = (_WORD *)a3[1];
        unint64_t v40 = a3[2];
        if ((unint64_t)v41 >= v40)
        {
          float v43 = (_WORD *)*a3;
          uint64_t v44 = (uint64_t)v41 - *a3;
          if (v44 <= -3) {
            sub_1DC2FF97C();
          }
          uint64_t v45 = v44 >> 1;
          unint64_t v46 = v40 - (void)v43;
          if (v46 <= (v44 >> 1) + 1) {
            unint64_t v47 = v45 + 1;
          }
          else {
            unint64_t v47 = v46;
          }
          if (v46 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v48 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v48 = v47;
          }
          if (v48)
          {
            uint64_t v48 = (uint64_t)sub_1DC3CC130(v48);
            float v43 = (_WORD *)*a3;
            size_t v41 = (_WORD *)a3[1];
          }
          else
          {
            uint64_t v49 = 0;
          }
          __int16 v50 = (_WORD *)(v48 + 2 * v45);
          *__int16 v50 = v39;
          uint64_t v42 = v50 + 1;
          while (v41 != v43)
          {
            __int16 v51 = *--v41;
            *--__int16 v50 = v51;
          }
          *a3 = v50;
          a3[1] = v42;
          a3[2] = v48 + 2 * v49;
          if (v43) {
            operator delete(v43);
          }
        }
        else
        {
          *size_t v41 = v39;
          uint64_t v42 = v41 + 1;
        }
        a3[1] = v42;
        BOOL v17 = v38;
        __int16 v34 = (__int16)v10;
      }
      int32x2_t v33 = v10 + 1;
    }
    while (v10 + 1 < v32);
    int v52 = *v32;
    uint64_t v54 = (_WORD *)a3[1];
    unint64_t v53 = a3[2];
    if (v15 > v52 != v17)
    {
      __int16 v55 = (_WORD)v32 - v34;
      if ((unint64_t)v54 >= v53)
      {
        float v57 = (_WORD *)*a3;
        uint64_t v58 = (uint64_t)v54 - *a3;
        if (v58 <= -3) {
          sub_1DC2FF97C();
        }
        uint64_t v59 = v58 >> 1;
        unint64_t v60 = v53 - (void)v57;
        if (v60 <= (v58 >> 1) + 1) {
          unint64_t v61 = v59 + 1;
        }
        else {
          unint64_t v61 = v60;
        }
        BOOL v26 = v60 >= 0x7FFFFFFFFFFFFFFELL;
        uint64_t v62 = 0x7FFFFFFFFFFFFFFFLL;
        if (!v26) {
          uint64_t v62 = v61;
        }
        if (v62)
        {
          uint64_t v62 = (uint64_t)sub_1DC3CC130(v62);
          float v57 = (_WORD *)*a3;
          uint64_t v54 = (_WORD *)a3[1];
        }
        else
        {
          uint64_t v63 = 0;
        }
        uint64_t v64 = (_WORD *)(v62 + 2 * v59);
        unint64_t v53 = v62 + 2 * v63;
        *uint64_t v64 = v55;
        int v56 = v64 + 1;
        while (v54 != v57)
        {
          __int16 v65 = *--v54;
          *--uint64_t v64 = v65;
        }
        *a3 = v64;
        a3[1] = v56;
        a3[2] = v53;
        if (v57)
        {
          operator delete(v57);
          unint64_t v53 = a3[2];
        }
      }
      else
      {
        _WORD *v54 = v55;
        int v56 = v54 + 1;
      }
      a3[1] = v56;
      __int16 v34 = (__int16)v32;
      uint64_t v54 = v56;
    }
    __int16 v66 = (_WORD)v32 - v34 + 1;
    if ((unint64_t)v54 >= v53)
    {
      uint64_t v68 = (_WORD *)*a3;
      uint64_t v69 = (uint64_t)v54 - *a3;
      if (v69 <= -3) {
        sub_1DC2FF97C();
      }
      uint64_t v70 = v69 >> 1;
      unint64_t v71 = v53 - (void)v68;
      if (v71 <= (v69 >> 1) + 1) {
        unint64_t v72 = v70 + 1;
      }
      else {
        unint64_t v72 = v71;
      }
      BOOL v26 = v71 >= 0x7FFFFFFFFFFFFFFELL;
      uint64_t v73 = 0x7FFFFFFFFFFFFFFFLL;
      if (!v26) {
        uint64_t v73 = v72;
      }
      if (v73)
      {
        uint64_t v73 = (uint64_t)sub_1DC3CC130(v73);
        uint64_t v68 = (_WORD *)*a3;
        uint64_t v54 = (_WORD *)a3[1];
      }
      else
      {
        uint64_t v74 = 0;
      }
      float v75 = (_WORD *)(v73 + 2 * v70);
      uint64_t v76 = v73 + 2 * v74;
      *float v75 = v66;
      int v67 = v75 + 1;
      while (v54 != v68)
      {
        __int16 v77 = *--v54;
        *--float v75 = v77;
      }
      *a3 = v75;
      a3[1] = v67;
      a3[2] = v76;
      if (v68) {
        operator delete(v68);
      }
    }
    else
    {
      _WORD *v54 = v66;
      int v67 = v54 + 1;
    }
    a3[1] = v67;
    if (v15 > v52)
    {
      unint64_t v78 = a3[2];
      if ((unint64_t)v67 >= v78)
      {
        float v80 = (_WORD *)*a3;
        uint64_t v81 = (uint64_t)v67 - *a3;
        if (v81 <= -3) {
          sub_1DC2FF97C();
        }
        uint64_t v82 = v81 >> 1;
        unint64_t v83 = v78 - (void)v80;
        if (v83 <= (v81 >> 1) + 1) {
          unint64_t v84 = v82 + 1;
        }
        else {
          unint64_t v84 = v83;
        }
        BOOL v26 = v83 >= 0x7FFFFFFFFFFFFFFELL;
        uint64_t v85 = 0x7FFFFFFFFFFFFFFFLL;
        if (!v26) {
          uint64_t v85 = v84;
        }
        if (v85)
        {
          uint64_t v85 = (uint64_t)sub_1DC3CC130(v85);
          float v80 = (_WORD *)*a3;
          int v67 = (_WORD *)a3[1];
        }
        else
        {
          uint64_t v86 = 0;
        }
        float v87 = (_WORD *)(v85 + 2 * v82);
        uint64_t v88 = v85 + 2 * v86;
        *float v87 = 0;
        float v79 = v87 + 1;
        while (v67 != v80)
        {
          __int16 v89 = *--v67;
          *--float v87 = v89;
        }
        *a3 = v87;
        a3[1] = v79;
        a3[2] = v88;
        if (v80) {
          operator delete(v80);
        }
      }
      else
      {
        *int v67 = 0;
        float v79 = v67 + 1;
      }
      a3[1] = v79;
    }
  }
  if (v92)
  {
    uint64_t v93 = v92;
    operator delete(v92);
  }
  return v7;
}

void sub_1DC3E02E4(_Unwind_Exception *exception_object)
{
  long long v3 = *(void **)(v1 - 112);
  if (v3)
  {
    *(void *)(v1 - 104) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3E0318(char *a1)
{
  int v1 = *(_DWORD *)a1;
  uint64_t v2 = 4;
  long long v3 = a1;
  do
  {
    int v4 = *(_DWORD *)&a1[v2];
    BOOL v5 = v1 < v4;
    if (v1 <= v4) {
      int v1 = *(_DWORD *)&a1[v2];
    }
    if (v5) {
      long long v3 = &a1[v2];
    }
    v2 += 4;
  }
  while (v2 != 128);
  uint64_t v6 = 0;
  int v7 = 0;
  int v8 = 0;
  unint64_t v9 = (unint64_t)(v3 - a1) >> 2;
  int v10 = *(_DWORD *)v3;
  do
  {
    if (((int)v6 - (int)v9) * ((int)v6 - (int)v9) * *(_DWORD *)&a1[4 * v6] > v7)
    {
      int v8 = v6;
      int v7 = (v6 - v9) * (v6 - v9) * *(_DWORD *)&a1[4 * v6];
    }
    ++v6;
  }
  while (v6 != 32);
  if (v8 >= (int)v9) {
    int v11 = v9;
  }
  else {
    int v11 = v8;
  }
  if (v8 <= (int)v9) {
    int v8 = v9;
  }
  if (v8 - v11 < 3) {
    return 0xFFFFFFFFLL;
  }
  int v13 = v8 - 1;
  if (v13 > v11)
  {
    uint64_t v14 = v13;
    uint64_t v15 = v11;
    int v16 = -v11;
    int v17 = -1;
    int v18 = 1;
    do
    {
      if ((v16 + (int)v14) * (v16 + (int)v14) * v18 * (v10 - *(_DWORD *)&a1[4 * v14]) > v17)
      {
        int v13 = v14;
        int v17 = (v16 + v14) * (v16 + v14) * v18 * (v10 - *(_DWORD *)&a1[4 * v14]);
      }
      --v14;
      ++v18;
    }
    while (v14 > v15);
  }
  return (8 * v13);
}

BOOL sub_1DC3E0404(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), a4, a2);
  if (*(_DWORD *)(a4 + 8) - *(_DWORD *)a4 < 3) {
    return 0;
  }
  return sub_1DC3E0494((unsigned __int8 **)a4, a3);
}

BOOL sub_1DC3E0494(unsigned __int8 **a1, uint64_t a2)
{
  int64_t v4 = a1[1] - *a1;
  BOOL v5 = *(unsigned char **)a2;
  int64_t v6 = *(void *)(a2 + 8) - *(void *)a2;
  if (v6 == v4)
  {
    if (v6 >= 1) {
      bzero(v5, v6);
    }
  }
  else
  {
    char v26 = 0;
    sub_1DC314894(&v18, (int)v4, &v26);
    int v7 = *(unsigned char **)a2;
    if (*(void *)a2)
    {
      *(void *)(a2 + 8) = v7;
      operator delete(v7);
    }
    *(_OWORD *)a2 = v18;
    *(void *)(a2 + 16) = v19;
  }
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  int v8 = *a1;
  if ((int)v4 >= 1)
  {
    uint64_t v9 = v4;
    int v10 = v8;
    do
    {
      unsigned int v11 = *v10++;
      ++*(_DWORD *)((char *)&v18 + (((unint64_t)v11 >> 1) & 0x7C));
      --v9;
    }
    while (v9);
  }
  int v12 = sub_1DC3E0318((char *)&v18);
  if (v12 > 0)
  {
    if (v12 > *v8)
    {
      if (*(void *)(a2 + 8) == *(void *)a2) {
        goto LABEL_24;
      }
      **(unsigned char **)a2 = 1;
    }
    if (v4 << 32 >= 0x200000001)
    {
      uint64_t v13 = 0;
      do
      {
        unint64_t v14 = v13 + 1;
        int v15 = 4 * v8[v13 + 1] - (v8[v13 + 2] + v8[v13]);
        if (v12 > (v15 + ((unsigned __int16)(v15 & 0x8000) >> 15)) >> 1)
        {
          if (*(void *)(a2 + 8) - *(void *)a2 <= v14) {
            goto LABEL_24;
          }
          *(unsigned char *)(*(void *)a2 + v13 + 1) = 1;
        }
        ++v13;
      }
      while (&v8[v14 + 1] < &v8[(int)v4 - 1]);
    }
    unint64_t v16 = ((v4 << 32) - 0x100000000) >> 32;
    if (v12 > v8[v16])
    {
      if (*(void *)(a2 + 8) - *(void *)a2 > v16)
      {
        *(unsigned char *)(*(void *)a2 + v16) = 1;
        return v12 > 0;
      }
LABEL_24:
      sub_1DC351420();
    }
  }
  return v12 > 0;
}

BOOL sub_1DC3E065C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, int a5)
{
  int v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  if (v10 < 3) {
    return 0;
  }
  LODWORD(v12) = v10;
  char v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  long long v23 = 0;
  long long v24 = 0;
  uint64_t v25 = 0;
  (*(void (**)(void, uint64_t, void **))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), a2, &v26);
  uint64_t v13 = (unsigned __int8 *)v26;
  if (a5)
  {
    if ((int)a2 < 1)
    {
      int v15 = 0;
      unsigned int v14 = 1;
    }
    else
    {
      (*(void (**)(void, void, void **))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), (a2 - 1), &v23);
      unsigned int v14 = 2;
      int v15 = (unsigned __int8 *)v23;
    }
    if ((int)a2 + 1 < (*(int (**)(void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8)))
    {
      (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
      ++v14;
    }
  }
  else
  {
    int v15 = 0;
    unsigned int v14 = 1;
  }
  uint64_t v12 = v12;
  unint64_t v16 = (unsigned char *)*a4;
  unint64_t v17 = a4[1] - *a4;
  if (v12 <= v17)
  {
    if (v12 < v17) {
      a4[1] = (unint64_t)&v16[v12];
    }
  }
  else
  {
    sub_1DC3D9108(a4, v12 - v17);
    unint64_t v16 = (unsigned char *)*a4;
  }
  long long v18 = v15;
  uint64_t v19 = 0;
  do
  {
    unsigned int v21 = *v13++;
    unsigned int v20 = v21;
    if (v15) {
      v20 += *v18;
    }
    *v16++ = v20 / v14;
    ++v19;
    ++v18;
    --v12;
  }
  while (v12);
  BOOL v11 = sub_1DC3E0494((unsigned __int8 **)a4, a3);
  if (v23)
  {
    long long v24 = v23;
    operator delete(v23);
  }
  if (v26)
  {
    uint64_t v27 = v26;
    operator delete(v26);
  }
  return v11;
}

void sub_1DC3E08B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1DC3E08F4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, int a5)
{
  int v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8));
  if (v10 < 3) {
    return 0;
  }
  LODWORD(v12) = v10;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  long long v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v13 = (unsigned __int8 *)(*(uint64_t (**)(void, uint64_t, void **, void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), a2, &v27, 0);
  if (a5)
  {
    if ((int)a2 < 1)
    {
      uint64_t v14 = 0;
      unsigned int v15 = 1;
    }
    else
    {
      uint64_t v14 = (*(uint64_t (**)(void, void, void **, void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), (a2 - 1), &v24, 0);
      unsigned int v15 = 2;
    }
    if ((int)a2 + 1 >= (*(int (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8)))
    {
      uint64_t v16 = 0;
    }
    else
    {
      uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8));
      ++v15;
    }
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v16 = 0;
    unsigned int v15 = 1;
  }
  uint64_t v12 = v12;
  unint64_t v17 = (unsigned char *)*a4;
  unint64_t v18 = a4[1] - *a4;
  if (v12 <= v18)
  {
    if (v12 < v18) {
      a4[1] = (unint64_t)&v17[v12];
    }
  }
  else
  {
    sub_1DC3D9108(a4, v12 - v18);
    unint64_t v17 = (unsigned char *)*a4;
  }
  uint64_t v19 = (unsigned __int8 *)v14;
  unsigned int v20 = (unsigned __int8 *)v16;
  do
  {
    unsigned int v22 = *v13++;
    unsigned int v21 = v22;
    if (v14) {
      v21 += *v19;
    }
    if (v16) {
      v21 += *v20;
    }
    *v17++ = v21 / v15;
    ++v20;
    ++v19;
    --v12;
  }
  while (v12);
  BOOL v11 = sub_1DC3E0494((unsigned __int8 **)a4, a3);
  if (v24)
  {
    uint64_t v25 = v24;
    operator delete(v24);
  }
  if (v27)
  {
    uint64_t v28 = v27;
    operator delete(v27);
  }
  return v11;
}

void sub_1DC3E0B54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DC3E0B98(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

uint64_t sub_1DC3E0BC0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16))();
}

void sub_1DC3E0BE8(void *a1)
{
  *a1 = &unk_1F3660E70;
  int v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_1DC32EEF4(v1);
  }
  JUMPOUT(0x1E019CE90);
}

void *sub_1DC3E0C54(void *a1)
{
  *a1 = &unk_1F3660E70;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_1DC32EEF4(v2);
  }
  return a1;
}

uint64_t sub_1DC3E0CA0(int a1, int a2)
{
  switch(a1)
  {
    case 0:
      unint64_t v2 = 0x252B2F24202E2DuLL >> (8 * (a2 - 36));
      if ((a2 - 36) >= 7) {
        LOBYTE(v2) = 0;
      }
      if (a2 <= 0x23) {
        LOBYTE(v2) = a2 + 55;
      }
      if (a2 <= 9) {
        LOBYTE(v2) = a2 + 48;
      }
      break;
    case 1:
      LOBYTE(v2) = a2 - 9;
      break;
    case 2:
      unsigned int v3 = 0x604000u >> (8 * (a2 - 30));
      if ((a2 - 30) >= 3) {
        LOBYTE(v3) = 127;
      }
      if ((a2 - 25) <= 4) {
        char v4 = a2 + 98;
      }
      else {
        char v4 = v3;
      }
      if ((a2 - 20) <= 4) {
        char v5 = a2 + 71;
      }
      else {
        char v5 = v4;
      }
      if ((a2 - 15) <= 4) {
        char v6 = a2 + 44;
      }
      else {
        char v6 = v5;
      }
      if ((a2 - 10) <= 4) {
        LOBYTE(v2) = a2 + 17;
      }
      else {
        LOBYTE(v2) = v6;
      }
      break;
    case 3:
      LOBYTE(v2) = a2 + 23;
      break;
    case 4:
      LOBYTE(v2) = a2 + 87;
      break;
    default:
      LOBYTE(v2) = 0;
      break;
  }
  return (char)v2;
}

BOOL sub_1DC3E0DA8(uint64_t a1, int a2, int a3, int *a4, char *__s1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  BOOL result = 1;
  if (__s1 && *a4 != a3)
  {
    if (!strcmp(__s1, "UTF-8")) {
      return 1;
    }
    uint64_t v11 = MEMORY[0x1E019D3A0]("UTF-8", __s1);
    if (v11 == -1)
    {
      if (qword_1EAA94CD0 != -1) {
        dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
      }
      unsigned int v22 = qword_1EAA94CC8;
      BOOL result = os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v23 = *__error();
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "UTF-8";
        __int16 v32 = 2082;
        int32x2_t v33 = __s1;
        __int16 v34 = 1026;
        int v35 = v23;
        _os_log_error_impl(&dword_1DC2FE000, v22, OS_LOG_TYPE_ERROR, "[Code93i] iconv_open(\"%{public}s\", \"%{public}s\") failed: %{public, errno}d", buf, 0x1Cu);
        return 0;
      }
    }
    else
    {
      uint64_t v12 = v11;
      uint64_t v13 = *a4;
      *(void *)long long buf = v13 - a3;
      int v14 = 8 * *(_DWORD *)buf + 8;
      size_t v28 = 8 * *(void *)buf + 8;
      unsigned int v15 = (char *)malloc_type_malloc(v28, 0x85B62F8AuLL);
      uint64_t v26 = a1 + a3;
      uint64_t v27 = v15;
      if (MEMORY[0x1E019D380](v12, &v26, buf, &v27, &v28) == -1)
      {
        size_t v16 = 8 * v13 - 8 * a3 + 136;
        while (*__error() == 7)
        {
          v28 += 128;
          uint64_t v17 = v27 - v15;
          unsigned int v15 = (char *)malloc_type_realloc(v15, v16, 0xF7CEEB7BuLL);
          uint64_t v27 = &v15[v17];
          v16 += 128;
          if (MEMORY[0x1E019D380](v12, &v26, buf, &v27, &v28) != -1)
          {
            int v14 = v16 - 128;
            goto LABEL_10;
          }
        }
        if (qword_1EAA94CD0 != -1) {
          dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
        }
        long long v24 = qword_1EAA94CC8;
        if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR))
        {
          int v25 = *__error();
          *(_DWORD *)uint64_t v29 = 67240192;
          int v30 = v25;
          _os_log_error_impl(&dword_1DC2FE000, v24, OS_LOG_TYPE_ERROR, "[Code93i] iconv failed: %{public, errno}d", v29, 8u);
        }
        free(v15);
        MEMORY[0x1E019D390](v12);
        return 0;
      }
LABEL_10:
      MEMORY[0x1E019D390](v12);
      LODWORD(v18) = v14 - v28;
      *a4 = a3;
      if ((int)v18 >= 1)
      {
        uint64_t v18 = v18;
        uint64_t v19 = v15;
        do
        {
          uint64_t v20 = *a4;
          if ((int)v20 < a2)
          {
            char v21 = *v19;
            *a4 = v20 + 1;
            *(unsigned char *)(a1 + v20) = v21;
          }
          ++v19;
          --v18;
        }
        while (v18);
      }
      free(v15);
      return *a4 <= a2;
    }
  }
  return result;
}

uint64_t sub_1DC3E10D0(uint64_t a1, int a2, int *a3, int *a4, void *a5)
{
  uint64_t v5 = *a3;
  if ((int)v5 > a2 - 2 || *(unsigned char *)(a1 + v5) != 47) {
    return 0;
  }
  int v6 = *(char *)(v5 + a1 + 1);
  if (v6 < 44)
  {
    int v7 = 1;
    goto LABEL_14;
  }
  if ((int)v5 > a2 - 3) {
    return 0;
  }
  int v8 = *(char *)(v5 + a1 + 2);
  if (v6 == 44)
  {
    int v6 = v8 + 44;
    int v7 = 2;
    goto LABEL_14;
  }
  if ((int)v5 > a2 - 4) {
    return 0;
  }
  int v9 = *(char *)(v5 + a1 + 3);
  if (v6 == 45)
  {
    int v6 = v9 + 52 * v8 + 96;
    int v7 = 3;
    goto LABEL_14;
  }
  if ((int)v5 > a2 - 5) {
    return 0;
  }
  int v6 = *(char *)(v5 + a1 + 4) + 52 * (v9 + 52 * (v8 + 52 * v6 - 2392)) + 2800;
  int v7 = 4;
LABEL_14:
  uint64_t v11 = 0;
  *a4 = v6;
  *a3 += v7;
  uint64_t v12 = dword_1E6C3AF88;
  while (1)
  {
    int v13 = *v12;
    v12 += 4;
    if (v13 == *a4) {
      break;
    }
    if (++v11 == 32)
    {
      uint64_t v14 = 0;
      goto LABEL_19;
    }
  }
  uint64_t v14 = *(void *)&dword_1E6C3AF88[4 * v11 + 2];
LABEL_19:
  *a5 = v14;
  return 1;
}

void sub_1DC3E11EC()
{
}

uint64_t sub_1DC3E1214(uint64_t a1, float *a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  if (a3 < 16) {
    return 16;
  }
  if ((-1431655765 * a3 + 1431655765) > 0x55555554) {
    return 2;
  }
  int v9 = a3 - 1;
  size_t v10 = (a3 - 1) / 3uLL;
  uint64_t v11 = malloc_type_malloc(4 * v10, 0x100004052888210uLL);
  float v63 = 0.0;
  uint64_t v12 = (v10 - 1);
  sub_1DC3DF300((uint64_t)a2, a4, 3 * v12, v67);
  sub_1DC3DDD2C(55, 7u, 0xFu, v66, v65, v67, flt_1DC41AF8C, &v11[v12], &v63);
  int v13 = v11[v12];
  if ((v13 - 53) > 1)
  {
    size_t v16 = 0;
LABEL_30:
    *(_DWORD *)(a5 + 24) = 0;
    *(void *)(a5 + 8) = 0;
    uint64_t v6 = 6;
    goto LABEL_31;
  }
  int v57 = a3;
  uint64_t v58 = &v11[v12];
  unsigned int v56 = v9;
  uint64_t v59 = a5;
  size_t count = v10;
  int v14 = 0;
  unint64_t v15 = 0;
  size_t v16 = 0;
  float v17 = v63 + 0.0;
  float v18 = fminf(v63, INFINITY);
  BOOL v19 = v13 == 53;
  unint64_t v61 = v11;
  do
  {
    sub_1DC3DF300((uint64_t)a2, a4, v14, v67);
    sub_1DC3DDD2C(55, 7u, 0xFu, v66, v65, v67, flt_1DC41AF8C, v11, &v63);
    if (v15)
    {
      if (v15 >= 4 && v19 && v15 <= (v10 - 5))
      {
        v16[v15] = v63;
LABEL_13:
        BOOL v19 = 1;
        goto LABEL_15;
      }
      goto LABEL_15;
    }
    if ((*v61 - 53) > 1)
    {
      uint64_t v11 = v61;
      goto LABEL_30;
    }
    if (*v61 == 54 && v19)
    {
      size_t v16 = (float *)malloc_type_calloc(v10, 4uLL, 0x100004052888210uLL);
      goto LABEL_13;
    }
    BOOL v19 = 0;
LABEL_15:
    float v17 = v17 + v63;
    if (v63 < v18) {
      float v18 = v63;
    }
    ++v15;
    ++v11;
    v14 += 3;
  }
  while (v12 != v15);
  size_t v20 = v10;
  *(float *)(a5 + 24) = (float)((float)(v17 / (float)(int)v10) * 0.3) + (float)(v18 * 0.7);
  uint64_t v11 = v61;
  if ((*v61 - 53) > 1 || (*v58 - 53) > 1)
  {
    uint64_t v6 = 6;
LABEL_28:
    *(float *)(v59 + 24) = *(float *)(v59 + 24) / 100.0;
    goto LABEL_31;
  }
  pthread_once(&stru_1EAA94B60, (void (*)(void))sub_1DC3E11EC);
  if (*v61 == 53)
  {
    if (*v58 == 54)
    {
      if ((v10 - 11) > 0x2B)
      {
        uint64_t v6 = 7;
      }
      else
      {
        size_t v24 = (v10 - 8);
        int v25 = (char *)malloc_type_malloc(2 * v24, 0x1000040BDFB0063uLL);
        if (v16) {
          uint64_t v26 = (unsigned int *)malloc_type_calloc((v10 - 8), 4uLL, 0x100004052888210uLL);
        }
        else {
          uint64_t v26 = 0;
        }
        int v64 = 0;
        BOOL v38 = malloc_type_calloc(v24, 2uLL, 0x1000040BDFB0063uLL);
        int v69 = 0;
        uint64_t v68 = 0;
        int v39 = count - 9;
        unint64_t v40 = v61 + 4;
        int v41 = count - 9;
        uint64_t v42 = (count - 8);
        do
        {
          int v43 = *v40++;
          *(_WORD *)&v25[2 * v41--] = v43;
          --v42;
        }
        while (v42);
        uint64_t v44 = v61;
        uint64_t v45 = (count - 4);
        uint64_t v46 = 10;
        unint64_t v47 = v61;
        do
        {
          int v48 = v47[1];
          ++v47;
          uint64_t v49 = &v70[v46];
          *(_WORD *)uint64_t v49 = v48;
          *((_WORD *)v49 - 3) = v44[v45];
          v46 -= 2;
          uint64_t v44 = v47;
        }
        while (v46 != 4);
        if (sub_1DC3C6864(qword_1EAA94E80, v25, v24, v70, 6u, v26, 0, &v64, v38, &v68)) {
          BOOL v50 = 1;
        }
        else {
          BOOL v50 = (2 * v64) > 4;
        }
        if (v50)
        {
          int v51 = 0;
          uint64_t v6 = 7;
          uint64_t v11 = v61;
        }
        else
        {
          int v52 = v61 + 4;
          do
          {
            *v52++ = SLOBYTE(v38[v39--]);
            --v24;
          }
          while (v24);
          uint64_t v53 = 0;
          uint64_t v54 = &v61[v45];
          uint64_t v11 = v61;
          __int16 v55 = (char *)&v69 + 2;
          do
          {
            v61[v53 + 1] = *v55;
            v54[v53++] = *(v55 - 6);
            v55 -= 2;
          }
          while (v53 != 3);
          if (v61[v12 >> 1] == 52 && v61[(v12 >> 1) + 1] == count - 10)
          {
            uint64_t v6 = 0;
            int v51 = 1;
          }
          else
          {
            int v51 = 0;
            uint64_t v6 = 7;
          }
        }
        free(v25);
        free(v38);
        if (v26) {
          free(v26);
        }
        size_t v20 = count;
        if (v51) {
          goto LABEL_45;
        }
      }
      goto LABEL_51;
    }
    BOOL v21 = *v58 == 53;
LABEL_40:
    int v22 = 53;
    goto LABEL_41;
  }
  if (*v61 != 54)
  {
    BOOL v21 = 0;
    goto LABEL_40;
  }
  BOOL v21 = 0;
  if (*v58 == 54) {
    int v22 = 47;
  }
  else {
    int v22 = 53;
  }
LABEL_41:
  unint64_t v27 = (v10 - 4);
  int32x2_t v28 = 0;
  int32x2_t v29 = (int32x2_t)0x100000000;
  do
  {
    int8x8_t v30 = (int8x8_t)vadd_s32(v29, (int32x2_t)0x100000001);
    int32x2_t v31 = vcgt_s32(v29, (int32x2_t)0xE00000013);
    __int16 v32 = (const float *)&v61[v27];
    int32x2_t v29 = vsub_s32((int32x2_t)vbic_s8(v30, (int8x8_t)v31), v31);
    int32x2_t v33 = (int32x2_t)vld1_dup_f32(v32);
    int32x2_t v28 = vmla_s32(v28, v33, v29);
    BOOL v50 = v27-- > 1;
  }
  while (v50);
  if (v28.i32[0] % v22 != v61[(v10 - 3)]
    || (v28.i32[1] + v21 + v28.i32[0] % v22) % v22 != v61[(v10 - 2)])
  {
    uint64_t v6 = 5;
LABEL_51:
    *(void *)(v59 + 8) = 0;
    goto LABEL_28;
  }
LABEL_45:
  *(void *)(v59 + 8) = v20;
  __int16 v34 = *(void **)(v59 + 16);
  if (v34) {
    free(v34);
  }
  *(void *)(v59 + 16) = 0;
  int v35 = malloc_type_malloc(v20, 0x100004077774924uLL);
  uint64_t v36 = 0;
  *(void *)(v59 + 16) = v35;
  do
  {
    *(unsigned char *)(*(void *)(v59 + 16) + v36) = v11[v36];
    ++v36;
  }
  while (v20 != v36);
  uint64_t v6 = 0;
  *(_DWORD *)(v59 + 80) = 1;
  *(_DWORD *)(v59 + 84) = v20;
  *(float *)(v59 + 72) = (float)(a2[6] - *a2) / 18.0;
  *(float *)(v59 + 76) = (float)(a2[v56] - a2[v57 - 7]) / 18.0;
  uint64_t v37 = *(void *)(v59 + 64);
  *(void *)(v37 + 40) = 0;
  *(float *)(v37 + 48) = *a2;
  *(_DWORD *)(v37 + 52) = *(_DWORD *)(a4 + 4 * v56);
  *(_DWORD *)(v37 + 20) = v57;
LABEL_31:
  free(v11);
  if (v16) {
    free(v16);
  }
  return v6;
}

void sub_1DC3E18D0(uint64_t a1, unsigned char *a2, int a3, unint64_t *a4, char *a5)
{
  uint64_t v5 = a2;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v6 = *(unsigned __int8 **)(a1 + 16);
  if (v6) {
    BOOL v8 = (int)v7 <= 4;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    if (a2) {
      *a2 = 0;
    }
  }
  else
  {
    int v9 = *v6;
    if ((v9 - 53) <= 1)
    {
      int v10 = v6[(v7 - 1)];
      if ((v10 - 53) <= 1)
      {
        unint64_t v12 = (v7 - 4);
        BOOL v13 = v10 == 54;
        if (v9 == 54)
        {
          BOOL v174 = v10 != 54;
          int v14 = 1;
          signed int v15 = v7 - 4;
        }
        else
        {
          if (v10 != 54) {
            return;
          }
          BOOL v13 = 0;
          signed int v15 = v7 - 5;
          BOOL v174 = 1;
          int v14 = 4;
        }
        int v16 = 2 * v7;
        float v17 = (unsigned __int8 *)malloc_type_malloc((2 * v7), 0xF58C8A8AuLL);
        int v18 = v15 - v14;
        if (v15 < v14) {
          ++v18;
        }
        int v185 = -1;
        unsigned int v19 = v14;
        int v20 = v14 + (v18 >> 1);
        uint64_t v184 = a5;
        v186[0] = v19;
        uint64_t v182 = (uint64_t)v17;
        int v176 = 2 * v7;
        if (v15 < v19)
        {
          int v21 = v19;
          LODWORD(v22) = 0;
          int v181 = 0;
          int v178 = 0;
          int v179 = 0;
          int v183 = 0;
          int v23 = 0;
LABEL_305:
          int v137 = v20 + 2;
          if (v21 == v20 + 3) {
            int v138 = v21 - 4;
          }
          else {
            int v138 = v21 - 2;
          }
          BOOL v139 = v21 == v137;
          if (v21 == v137) {
            int v140 = v20;
          }
          else {
            int v140 = v21;
          }
          if (v139) {
            int v138 = v20 - 2;
          }
          if (v9 == 54)
          {
            int v140 = v21;
            int v138 = v21 - 2;
          }
          int v141 = (char)v6[v140 - 1];
          int v142 = (char)v6[v138];
          if (v23 == 1 && (int)v22 >= 1)
          {
            float v143 = a4;
            if (v22 == 1)
            {
              if (v141 > 9) {
                goto LABEL_392;
              }
              LOBYTE(v144) = v141 + 48;
            }
            else
            {
              LODWORD(v144) = v141 + 48 * v142;
              if (v144 > 0x3E7) {
                goto LABEL_392;
              }
              uint64_t v145 = SHIDWORD(v186[0]);
              ++HIDWORD(v186[0]);
              v17[v145] = ((unsigned __int16)v144 / 0x64u) | 0x30;
              uint64_t v146 = SHIDWORD(v186[0]);
              ++HIDWORD(v186[0]);
              v17[v146] = (((unsigned __int16)v144 / 0xAu) % 0xAu) | 0x30;
              LOBYTE(v144) = ((unsigned __int16)v144 % 0xAu) | 0x30;
            }
LABEL_358:
            uint64_t v150 = SHIDWORD(v186[0]);
            ++HIDWORD(v186[0]);
            v17[v150] = v144;
            goto LABEL_359;
          }
          float v143 = a4;
          if (v23 == 3 && v181 >= 1)
          {
            if (v181 == 1)
            {
              if (v183) {
                goto LABEL_392;
              }
              unint64_t v144 = 0x252B2F24202E2DuLL >> (8 * (v141 - 36));
              if ((v141 - 36) > 6) {
                LOBYTE(v144) = 0;
              }
              if (v141 <= 0x23) {
                LOBYTE(v144) = v141 + 55;
              }
              if (v141 <= 9) {
                LOBYTE(v144) = v141 + 48;
              }
              LOBYTE(v144) = v144 ^ 0x80;
            }
            else
            {
              if (v183) {
                goto LABEL_392;
              }
              unint64_t v148 = 0x252B2F24202E2DuLL >> (8 * (v142 - 36));
              if ((v142 - 36) > 6) {
                LOBYTE(v148) = 0;
              }
              if (v142 <= 0x23) {
                LOBYTE(v148) = v142 + 55;
              }
              if (v142 <= 9) {
                LOBYTE(v148) = v142 + 48;
              }
              uint64_t v149 = SHIDWORD(v186[0]);
              ++HIDWORD(v186[0]);
              v17[v149] = v148;
              unint64_t v144 = 0x252B2F24202E2DuLL >> (8 * (v141 - 36));
              if ((v141 - 36) > 6) {
                LOBYTE(v144) = 0;
              }
              if (v141 <= 0x23) {
                LOBYTE(v144) = v141 + 55;
              }
              if (v141 <= 9) {
                LOBYTE(v144) = v141 + 48;
              }
            }
            goto LABEL_358;
          }
          if (v23 != 2)
          {
LABEL_359:
            int v151 = 1;
LABEL_373:
            if (v9 == 54 && v151)
            {
              int32x2_t v156 = (int32x2_t)1;
              int32x2_t v157 = 0;
              do
              {
                int8x8_t v158 = (int8x8_t)vadd_s32(v156, (int32x2_t)0x100000001);
                int32x2_t v159 = vcgt_s32(v156, (int32x2_t)0x130000000ELL);
                int32x2_t v156 = vsub_s32((int32x2_t)vbic_s8(v158, (int8x8_t)v159), v159);
                int32x2_t v157 = vmla_s32(v157, v156, vdup_n_s32((char)v6[v12]));
                BOOL v8 = v12-- > 1;
              }
              while (v8);
              if (v174) {
                int v160 = 53;
              }
              else {
                int v160 = 47;
              }
              if (v157.i32[1] % v160 != (char)v6[(v7 - 3)]
                || (v157.i32[1] % v160 + v157.i32[0]) % v160 != (char)v6[(v7 - 2)])
              {
LABEL_392:
                *uint64_t v5 = 0;
                free(v17);
                return;
              }
            }
            else if (!v151)
            {
              goto LABEL_392;
            }
            int v161 = HIDWORD(v186[0]);
            if (SHIDWORD(v186[0]) >= a3 - 1) {
              int v161 = a3 - 1;
            }
            *float v143 = v161;
            if (v161)
            {
              unint64_t v162 = 0;
              do
              {
                v5[v162] = v17[v162];
                ++v162;
                unint64_t v163 = *v143;
              }
              while (*v143 > v162);
            }
            else
            {
              unint64_t v163 = 0;
            }
            v5 += v163;
            goto LABEL_392;
          }
          if (v179 < 1) {
            goto LABEL_371;
          }
          if (v179 == 1)
          {
            if (!v183)
            {
              unint64_t v147 = 0x252B2F24202E2DuLL >> (8 * (v141 - 36));
              if ((v141 - 36) > 6) {
                LOBYTE(v147) = 0;
              }
              if (v141 <= 0x23) {
                LOBYTE(v147) = v141 + 55;
              }
              if (v141 <= 9) {
                LOBYTE(v147) = v141 + 48;
              }
              LOBYTE(v147) = v147 ^ 0x80;
LABEL_370:
              uint64_t v155 = SHIDWORD(v186[0]);
              ++HIDWORD(v186[0]);
              v17[v155] = v147;
LABEL_371:
              int v152 = 1;
              goto LABEL_372;
            }
          }
          else if (!v183)
          {
            int v152 = 0;
            if (v142 > 9 || v141 > 42) {
              goto LABEL_372;
            }
            unsigned __int8 v153 = v142 + 48;
            uint64_t v154 = SHIDWORD(v186[0]);
            ++HIDWORD(v186[0]);
            v17[v154] = v153;
            unint64_t v147 = 0x252B2F24202E2DuLL >> (8 * (v141 - 36));
            if ((v141 - 36) > 6) {
              LOBYTE(v147) = 0;
            }
            if (v141 <= 0x23) {
              LOBYTE(v147) = v141 + 55;
            }
            if (v141 <= 9) {
              LOBYTE(v147) = v141 + 48;
            }
            goto LABEL_370;
          }
          int v152 = 0;
LABEL_372:
          int v151 = sub_1DC3E0DA8(v182, v176, v178, (int *)v186 + 1, v184) & v152;
          float v17 = (unsigned __int8 *)v182;
          goto LABEL_373;
        }
        signed int v24 = v15;
        unsigned int v172 = v15 - v19;
        BOOL v175 = v13;
        int v170 = 0;
        int v23 = 0;
        int v178 = 0;
        int v179 = 0;
        int v181 = 0;
        uint64_t v22 = 0;
        int v25 = 0;
        int v26 = 0;
        int v183 = 0;
        uint64_t v27 = (v20 + 1);
        int v28 = v20 + 2;
        int v29 = v20 + 3;
        uint64_t v166 = v19 | 2;
        int v30 = v20 - 2;
        uint64_t v169 = v19 + 1;
        int v167 = v16 - 2;
        int v168 = v16 - 1;
        uint64_t v165 = v19 + 3;
        int v171 = v19;
        int v21 = v19;
        signed int v180 = v15;
        while (1)
        {
          if (v25 <= 0) {
            int v31 = 0;
          }
          else {
            int v31 = v26;
          }
          if (v25 <= 0) {
            int v32 = 0;
          }
          else {
            int v32 = v26;
          }
          int v33 = v21 != v20 && v21 != v27 && v25 > 0;
          if (v21 != v20 && v21 != v27) {
            int v34 = v32;
          }
          else {
            int v34 = v26;
          }
          if (v21 == v29) {
            int v35 = -4;
          }
          else {
            int v35 = -2;
          }
          int v36 = v35 + v21;
          if (v21 == v28) {
            int v37 = v20;
          }
          else {
            int v37 = v21;
          }
          if (v21 == v28) {
            int v36 = v30;
          }
          if (v9 == 54)
          {
            int v33 = v25 > 0;
            int v26 = v31;
          }
          else
          {
            int v26 = v34;
          }
          if (v9 == 54) {
            int v38 = v21;
          }
          else {
            int v38 = v37;
          }
          if (v9 == 54) {
            int v39 = v21 - 2;
          }
          else {
            int v39 = v36;
          }
          if (v39 < 1) {
            int v40 = 0;
          }
          else {
            int v40 = (char)v6[v39];
          }
          v25 -= v33;
          int v41 = (char)v6[v21];
          int v42 = (char)v6[v38 - 1];
          switch(v23)
          {
            case 0:
              if (v41 <= 9)
              {
                int v43 = v183;
                if (!v183)
                {
                  int v23 = 0;
                  int v183 = 0;
                  uint64_t v74 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v74] = v41 + 48;
                  goto LABEL_304;
                }
                if (v175) {
                  goto LABEL_392;
                }
                int v23 = 0;
                int v25 = v41 + 3;
                goto LABEL_53;
              }
              if ((v41 - 10) <= 0x19)
              {
                if (v183 == v26) {
                  int v58 = 0;
                }
                else {
                  int v58 = v183;
                }
                if (v183) {
                  int v59 = v58;
                }
                else {
                  int v59 = v26;
                }
                int v60 = (char)v6[v21];
                uint64_t v61 = v22;
                char v62 = sub_1DC3E0CA0(v59, v60);
                int v30 = v20 - 2;
                int v29 = v20 + 3;
                int v28 = v20 + 2;
                uint64_t v27 = (v20 + 1);
                uint64_t v22 = v61;
                signed int v24 = v180;
                int v23 = 0;
                int v183 = 0;
                uint64_t v63 = SHIDWORD(v186[0]);
                ++HIDWORD(v186[0]);
                *(unsigned char *)(v182 + v63) = v62;
                float v17 = (unsigned __int8 *)v182;
                goto LABEL_304;
              }
              if ((v41 - 36) <= 0xA)
              {
                int v43 = v183;
                if (!v183)
                {
                  switch(v6[v21])
                  {
                    case '$':
                      int v23 = 0;
                      int v183 = 0;
                      uint64_t v69 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      char v70 = 45;
                      goto LABEL_201;
                    case '%':
                      int v23 = 0;
                      int v183 = 0;
                      uint64_t v69 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      char v70 = 46;
                      goto LABEL_201;
                    case '&':
                      int v23 = 0;
                      int v183 = 0;
                      uint64_t v69 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      char v70 = 32;
                      goto LABEL_201;
                    case '\'':
                      int v23 = 0;
                      int v183 = 0;
                      uint64_t v69 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      char v70 = 36;
                      goto LABEL_201;
                    case '(':
                      int v23 = 0;
                      int v183 = 0;
                      uint64_t v69 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      char v70 = 47;
                      goto LABEL_201;
                    case ')':
                      int v23 = 0;
                      int v183 = 0;
                      uint64_t v69 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      char v70 = 43;
                      goto LABEL_201;
                    case '*':
                      int v23 = 0;
                      int v183 = 0;
                      uint64_t v69 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      char v70 = 37;
                      goto LABEL_201;
                    default:
                      int v23 = 0;
                      int v183 = v41 - 42;
                      break;
                  }
                  goto LABEL_304;
                }
                int v23 = 0;
                int v25 = v41 - 23;
LABEL_53:
                int v26 = v43;
                int v183 = 0;
                goto LABEL_304;
              }
              if (v175) {
                goto LABEL_392;
              }
              int v23 = 3;
              switch(v6[v21])
              {
                case '/':
                  if (v26) {
                    goto LABEL_392;
                  }
                  uint64_t v53 = v22;
                  if ((sub_1DC3E10D0((uint64_t)v6, v7, (int *)v186, &v185, &v184) & 1) == 0) {
                    goto LABEL_394;
                  }
                  int v23 = 0;
                  int v26 = 0;
                  float v17 = (unsigned __int8 *)v182;
                  goto LABEL_124;
                case '0':
                  int v50 = v25 + 2;
                  BOOL v51 = v25 <= 0;
                  goto LABEL_58;
                case '1':
                  int v23 = 2;
                  int v178 = HIDWORD(v186[0]);
                  break;
                case '2':
                  break;
                case '3':
                  int v109 = v170 + v171;
                  if (v21 < v170 + v171 + 3)
                  {
                    if (v21 == v109) {
                      goto LABEL_167;
                    }
                    if (v21 == v109 + 1)
                    {
                      if (SHIDWORD(v186[0]) >= 1)
                      {
                        int v64 = 0;
                        int v121 = *v17;
                        if ((v121 - 65) < 0x1A || (v121 - 48) < 0xA) {
                          goto LABEL_281;
                        }
                      }
LABEL_280:
                      int v64 = 7;
                    }
                    else
                    {
                      if (HIDWORD(v186[0]) == 1)
                      {
                        int v64 = 0;
                        int v125 = *v17;
                        if ((v125 - 65) >= 0x1A && (v125 - 48) >= 0xA)
                        {
                          if ((v125 - 97) >= 0x1A) {
                            int v64 = 7;
                          }
                          else {
                            int v64 = 0;
                          }
                        }
                        goto LABEL_281;
                      }
                      if (SHIDWORD(v186[0]) < 2 || *v17 - 48 > 9 || v17[1] - 48 >= 0xA) {
                        goto LABEL_280;
                      }
LABEL_167:
                      int v64 = 0;
                    }
LABEL_281:
                    int v23 = 0;
                    HIDWORD(v186[0]) = 0;
                    goto LABEL_303;
                  }
                  if (v21 >= v24) {
                    goto LABEL_206;
                  }
                  int v23 = 0;
                  uint64_t v69 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  char v70 = 29;
LABEL_201:
                  v17[v69] = v70;
                  break;
                case '4':
                  if (v9 != 54 && v21 == v20)
                  {
                    int v110 = (char)v6[v27] + 1;
                    LODWORD(v186[0]) = v27;
                    if (v110 != v172) {
                      goto LABEL_392;
                    }
LABEL_206:
                    int v23 = 0;
                    break;
                  }
                  if (v21 != v171) {
                    goto LABEL_392;
                  }
                  if (v24 >= v166 && v6[v169] == 51 && v6[v166] == 50) {
                    goto LABEL_206;
                  }
                  if (v171 > (int)v7 - 3 || v41 != 52) {
                    goto LABEL_392;
                  }
                  int v118 = (char)v6[v169];
                  int v119 = (char)v6[v166];
                  if (v118 > 44)
                  {
                    if ((char)v6[v165] > 50) {
                      goto LABEL_392;
                    }
                    int v122 = v119 + 52 * v118 - 2340;
                    if (v122 > 360) {
                      goto LABEL_392;
                    }
                    uint64_t v123 = 0x28u;
                    while (v122 > *(_DWORD *)((char *)&unk_1DC41AF18 + v123))
                    {
                      v123 += 4;
                      if (v123 == 116) {
                        goto LABEL_392;
                      }
                    }
                    int v170 = 4;
                    int v120 = v165;
                  }
                  else
                  {
                    if (v119 > 50) {
                      goto LABEL_392;
                    }
                    int v170 = 3;
                    int v120 = v166;
                  }
                  int v23 = 0;
                  LODWORD(v186[0]) = v120;
                  break;
                default:
                  goto LABEL_392;
              }
LABEL_304:
              signed int v136 = v186[0];
              int v21 = ++LODWORD(v186[0]);
              if (v136 >= v24) {
                goto LABEL_305;
              }
              break;
            case 1:
              if (v41 > 0x2F)
              {
                int v64 = 0;
                if ((int)v22 >= 1 && v41 >= 48 && v41 <= 50)
                {
                  if (v22 == 1)
                  {
                    if (v42 > 9) {
                      goto LABEL_138;
                    }
                    int v64 = 0;
                    uint64_t v22 = 0;
                    unsigned __int8 v87 = v42 + 48;
                    uint64_t v88 = SHIDWORD(v186[0]);
                    ++HIDWORD(v186[0]);
                    v17[v88] = v87;
                  }
                  else
                  {
                    unsigned int v65 = v42 + 48 * v40;
                    if (v65 <= 0x3E7)
                    {
                      int v64 = 0;
                      uint64_t v22 = 0;
                      uint64_t v66 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v66] = ((unsigned __int16)v65 / 0x64u) | 0x30;
                      uint64_t v67 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v67] = (((unsigned __int16)v65 / 0xAu) % 0xAu) | 0x30;
                      uint64_t v68 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v68] = ((unsigned __int16)v65 % 0xAu) | 0x30;
                      v25 -= v25 > 0;
                      goto LABEL_139;
                    }
LABEL_138:
                    uint64_t v22 = 0;
                    int v64 = 7;
                  }
                }
LABEL_139:
                int v23 = 0;
                switch(v41)
                {
                  case '0':
                    goto LABEL_303;
                  case '1':
                    goto LABEL_272;
                  case '2':
                    goto LABEL_294;
                  case '3':
                    if (v21 < v24)
                    {
                      uint64_t v89 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v89] = 29;
                    }
                    goto LABEL_145;
                  case '4':
                    if (v9 == 54) {
                      goto LABEL_392;
                    }
                    if (v21 != v20) {
                      goto LABEL_392;
                    }
                    int v90 = (char)v6[v27] + 1;
                    LODWORD(v186[0]) = v27;
                    if (v90 != v172) {
                      goto LABEL_392;
                    }
LABEL_145:
                    int v23 = 1;
                    break;
                  default:
                    goto LABEL_392;
                }
                goto LABEL_303;
              }
              if ((int)v22 < 2)
              {
                uint64_t v22 = (v22 + 1);
              }
              else
              {
                unsigned int v44 = v41 + 48 * (v42 + 48 * v40);
                if (v44 >> 5 > 0xC34)
                {
                  unsigned int v82 = v44 - 100000;
                  if (v82 >> 4 > 0x270) {
                    goto LABEL_392;
                  }
                  uint64_t v22 = 0;
                  uint64_t v83 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v83] = ((unsigned __int16)v82 / 0x3E8u) | 0x30;
                  uint64_t v84 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v84] = (((unsigned __int16)v82 / 0x64u) % 0xAu) | 0x30;
                  uint64_t v85 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v85] = ((unsigned __int16)v82 / 0xAu - 10 * ((6554 * ((unsigned __int16)v82 / 0xAu)) >> 16)) | 0x30;
                  uint64_t v86 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v86] = ((unsigned __int16)v82 % 0xAu) | 0x30;
                  v25 -= v25 > 0;
                }
                else
                {
                  uint64_t v22 = 0;
                  uint64_t v45 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v45] = (v44 / 0x2710) | 0x30;
                  uint64_t v46 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v46] = ((v44 / 0x3E8) % 0xAu) | 0x30;
                  uint64_t v47 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v47] = ((unsigned __int16)(v44 / 0x64) % 0xAu) | 0x30;
                  uint64_t v48 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v48] = ((unsigned __int16)(v44 / 0xA) % 0xAu) | 0x30;
                  uint64_t v49 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v49] = (v44 % 0xA) | 0x30;
                  int v50 = v25 - 2;
                  BOOL v51 = v25 <= 1;
LABEL_58:
                  if (!v51) {
                    int v25 = v50;
                  }
                }
              }
              int v23 = 1;
              goto LABEL_304;
            case 2:
              if (v26) {
                goto LABEL_392;
              }
              int v52 = v41 - 42;
              if (v41 > 0x2A)
              {
                if ((v41 - 43) <= 3u)
                {
                  int v26 = 0;
                  int v23 = 2;
                  goto LABEL_91;
                }
                if ((v41 - 48) > 2)
                {
                  int v64 = 0;
                }
                else
                {
                  unsigned int v164 = v22;
                  if (v179 < 1)
                  {
                    int v91 = 0;
                  }
                  else if (v179 == 1)
                  {
                    if (v183) {
                      goto LABEL_155;
                    }
                    if (v42 > 9)
                    {
                      if (v42 > 0x23)
                      {
                        if ((v42 - 36) > 6) {
                          LOBYTE(v117) = 0;
                        }
                        else {
                          unint64_t v117 = 0x252B2F24202E2DuLL >> (8 * (v42 - 36));
                        }
                      }
                      else
                      {
                        LOBYTE(v117) = v42 + 55;
                      }
                    }
                    else
                    {
                      LOBYTE(v117) = v42 + 48;
                    }
                    LOBYTE(v117) = v117 ^ 0x80;
LABEL_284:
                    int v91 = 0;
                    int v179 = 0;
                    uint64_t v132 = SHIDWORD(v186[0]);
                    ++HIDWORD(v186[0]);
                    v17[v132] = v117;
                  }
                  else
                  {
                    if (!v183)
                    {
                      if (v40 > 9)
                      {
                        if (v40 > 0x23)
                        {
                          if ((v40 - 36) > 6) {
                            LOBYTE(v71) = 0;
                          }
                          else {
                            unint64_t v71 = 0x252B2F24202E2DuLL >> (8 * (v40 - 36));
                          }
                        }
                        else
                        {
                          LOBYTE(v71) = v40 + 55;
                        }
                      }
                      else
                      {
                        LOBYTE(v71) = v40 + 48;
                      }
                      uint64_t v126 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v126] = v71;
                      if (v42 > 9)
                      {
                        if (v42 > 0x23)
                        {
                          if ((v42 - 36) > 6) {
                            LOBYTE(v117) = 0;
                          }
                          else {
                            unint64_t v117 = 0x252B2F24202E2DuLL >> (8 * (v42 - 36));
                          }
                        }
                        else
                        {
                          LOBYTE(v117) = v42 + 55;
                        }
                      }
                      else
                      {
                        LOBYTE(v117) = v42 + 48;
                      }
                      goto LABEL_284;
                    }
LABEL_155:
                    int v179 = 0;
                    int v91 = 7;
                  }
                  BOOL v133 = sub_1DC3E0DA8((uint64_t)v17, v176, v178, (int *)v186 + 1, v184);
                  int v178 = HIDWORD(v186[0]);
                  if (v133) {
                    int v64 = v91;
                  }
                  else {
                    int v64 = 7;
                  }
                  signed int v24 = v180;
                  uint64_t v22 = v164;
                  uint64_t v27 = (v20 + 1);
                  int v29 = v20 + 3;
                  int v28 = v20 + 2;
                  int v30 = v20 - 2;
                }
                int v26 = 0;
                int v23 = 1;
                float v17 = (unsigned __int8 *)v182;
                switch(v41)
                {
                  case '/':
                    int v128 = v64;
                    uint64_t v129 = v22;
                    if ((sub_1DC3E10D0((uint64_t)v6, v7, (int *)v186, &v185, &v184) & 1) == 0) {
                      goto LABEL_394;
                    }
                    int v26 = 0;
                    int v23 = 2;
                    goto LABEL_292;
                  case '0':
                    break;
                  case '1':
                    goto LABEL_295;
                  case '2':
                    goto LABEL_293;
                  case '3':
                    if (v21 >= v24) {
                      goto LABEL_301;
                    }
                    int v26 = 0;
                    uint64_t v134 = SHIDWORD(v186[0]);
                    ++HIDWORD(v186[0]);
                    *(unsigned char *)(v182 + v134) = 29;
                    goto LABEL_302;
                  case '4':
                    if (v9 == 54) {
                      goto LABEL_392;
                    }
                    if (v21 != v20) {
                      goto LABEL_392;
                    }
                    int v135 = (char)v6[v27] + 1;
                    LODWORD(v186[0]) = v27;
                    if (v135 != v172) {
                      goto LABEL_392;
                    }
LABEL_301:
                    int v26 = 0;
LABEL_302:
                    int v23 = 2;
                    break;
                  default:
                    goto LABEL_394;
                }
LABEL_303:
                if (v64) {
                  goto LABEL_392;
                }
                goto LABEL_304;
              }
              if (!v183)
              {
                if (v179 < 2)
                {
                  int v26 = 0;
                  int v183 = 0;
                  ++v179;
                  goto LABEL_186;
                }
                int v75 = v41 + 43 * (v42 + 43 * v40);
                if (v75 < 0x10000)
                {
                  int v179 = 0;
                  int v26 = 0;
                  int v183 = 0;
                  uint64_t v76 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  __int16 v77 = v75 + 255;
                  if (v75 >= 0) {
                    HIBYTE(v77) = BYTE1(v75);
                  }
                  v17[v76] = HIBYTE(v77);
                  uint64_t v78 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
LABEL_185:
                  v17[v78] = v75;
LABEL_186:
                  int v23 = 2;
                  goto LABEL_304;
                }
                if (v75 < 0x12710)
                {
                  int v179 = 0;
                  int v26 = 0;
                  int v183 = 0;
                  uint64_t v92 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v92] = ((unsigned __int16)v75 / 0x3E8u) | 0x30;
                  uint64_t v93 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v93] = (((unsigned __int16)v75 / 0x64u) % 0xAu) | 0x30;
                  unsigned int v94 = (unsigned __int16)v75 / 0xAu;
                  uint64_t v95 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v95] = (v94 - 10 * ((6554 * v94) >> 16)) | 0x30;
                  goto LABEL_183;
                }
                if (v75 >= 0x12AF8)
                {
                  if (v75 >= 0x12B5C) {
                    return;
                  }
                  int v179 = 0;
                  int v26 = 0;
                  int v183 = 0;
                  LOBYTE(v75) = v75 + 8;
                  LOBYTE(v94) = v75 / 0xAu;
                  uint64_t v114 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v114] = (v75 / 0xAu) | 0x30;
LABEL_183:
                  char v104 = v75 - 10 * v94;
                }
                else
                {
                  int v179 = 0;
                  int v26 = 0;
                  int v183 = 0;
                  unsigned __int16 v101 = v75 - 10000;
                  uint64_t v102 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v102] = (v101 / 0x64u) | 0x30;
                  uint64_t v103 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v103] = ((v101 / 0xAu) % 0xAu) | 0x30;
                  char v104 = v101 % 0xAu;
                }
                uint64_t v78 = SHIDWORD(v186[0]);
                ++HIDWORD(v186[0]);
                LOBYTE(v75) = v104 | 0x30;
                goto LABEL_185;
              }
              uint64_t v53 = v22;
              if ((v41 - 10) <= 0x19) {
                goto LABEL_72;
              }
              if (v183 != 1 || v41 > 9) {
                goto LABEL_392;
              }
              int v26 = 0;
              uint64_t v54 = SHIDWORD(v186[0]);
              ++HIDWORD(v186[0]);
              v17[v54] = v41 + 48;
              int v183 = 1;
              int v23 = 2;
              goto LABEL_124;
            case 3:
              if (v26) {
                goto LABEL_392;
              }
              int v52 = v41 - 42;
              if (v41 > 0x2A)
              {
                if ((v41 - 43) > 3u)
                {
                  int v64 = 0;
                  int v72 = v181;
                  if (v181 >= 1 && v41 >= 48 && v41 <= 50)
                  {
                    if (v181 == 1)
                    {
                      if (v183) {
                        goto LABEL_153;
                      }
                      if (v42 > 9)
                      {
                        if (v42 > 0x23)
                        {
                          if ((v42 - 36) > 6) {
                            LOBYTE(v111) = 0;
                          }
                          else {
                            unint64_t v111 = 0x252B2F24202E2DuLL >> (8 * (v42 - 36));
                          }
                        }
                        else
                        {
                          LOBYTE(v111) = v42 + 55;
                        }
                      }
                      else
                      {
                        LOBYTE(v111) = v42 + 48;
                      }
                      LOBYTE(v111) = v111 ^ 0x80;
LABEL_265:
                      int v64 = 0;
                      int v72 = 0;
                      uint64_t v127 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v127] = v111;
                    }
                    else
                    {
                      if (!v183)
                      {
                        if (v40 > 9)
                        {
                          if (v40 > 0x23)
                          {
                            if ((v40 - 36) > 6) {
                              LOBYTE(v73) = 0;
                            }
                            else {
                              unint64_t v73 = 0x252B2F24202E2DuLL >> (8 * (v40 - 36));
                            }
                          }
                          else
                          {
                            LOBYTE(v73) = v40 + 55;
                          }
                        }
                        else
                        {
                          LOBYTE(v73) = v40 + 48;
                        }
                        uint64_t v124 = SHIDWORD(v186[0]);
                        ++HIDWORD(v186[0]);
                        v17[v124] = v73;
                        if (v42 > 9)
                        {
                          if (v42 > 0x23)
                          {
                            if ((v42 - 36) > 6) {
                              LOBYTE(v111) = 0;
                            }
                            else {
                              unint64_t v111 = 0x252B2F24202E2DuLL >> (8 * (v42 - 36));
                            }
                          }
                          else
                          {
                            LOBYTE(v111) = v42 + 55;
                          }
                        }
                        else
                        {
                          LOBYTE(v111) = v42 + 48;
                        }
                        goto LABEL_265;
                      }
LABEL_153:
                      int v72 = 0;
                      int v64 = 7;
                    }
                  }
                  int v181 = v72;
                  int v26 = 0;
                  int v23 = 1;
                  switch(v41)
                  {
                    case '/':
                      int v128 = v64;
                      uint64_t v129 = v22;
                      if ((sub_1DC3E10D0((uint64_t)v6, v7, (int *)v186, &v185, &v184) & 1) == 0)
                      {
LABEL_394:
                        float v17 = (unsigned __int8 *)v182;
                        goto LABEL_392;
                      }
                      int v26 = 0;
                      int v23 = 3;
LABEL_292:
                      float v17 = (unsigned __int8 *)v182;
                      signed int v24 = v180;
                      uint64_t v22 = v129;
                      uint64_t v27 = (v20 + 1);
                      int v29 = v20 + 3;
                      int v28 = v20 + 2;
                      int v30 = v20 - 2;
                      int v64 = v128;
                      break;
                    case '0':
                      goto LABEL_303;
                    case '1':
                      int v26 = 0;
LABEL_272:
                      int v23 = 2;
                      int v178 = HIDWORD(v186[0]);
                      goto LABEL_303;
                    case '2':
LABEL_295:
                      int v26 = 0;
                      int v23 = 0;
                      goto LABEL_303;
                    case '3':
                      if (v21 >= v24) {
                        goto LABEL_293;
                      }
                      int v26 = 0;
                      uint64_t v130 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v130] = 29;
                      goto LABEL_294;
                    case '4':
                      if (v9 == 54) {
                        goto LABEL_392;
                      }
                      if (v21 != v20) {
                        goto LABEL_392;
                      }
                      int v131 = (char)v6[v27] + 1;
                      LODWORD(v186[0]) = v27;
                      if (v131 != v172) {
                        goto LABEL_392;
                      }
LABEL_293:
                      int v26 = 0;
LABEL_294:
                      int v23 = 3;
                      goto LABEL_303;
                    default:
                      goto LABEL_392;
                  }
                  goto LABEL_303;
                }
                int v26 = 0;
                int v23 = 3;
LABEL_91:
                int v183 = v52;
              }
              else
              {
                if (!v183)
                {
                  if (v181 < 2)
                  {
                    int v26 = 0;
                    int v183 = 0;
                    ++v181;
                  }
                  else
                  {
                    unsigned int v79 = v41 + 43 * (v42 + 43 * v40);
                    if ((int)v79 < 0x10000)
                    {
                      if ((int)v79 > 127)
                      {
                        if (v79 > 0x7FF)
                        {
                          if (v79 >> 11 == 27) {
                            goto LABEL_392;
                          }
                          uint64_t v112 = SHIDWORD(v186[0]);
                          if (SHIDWORD(v186[0]) >= v167) {
                            goto LABEL_392;
                          }
                          ++HIDWORD(v186[0]);
                          v17[v112] = (v79 >> 12) - 32;
                          uint64_t v113 = SHIDWORD(v186[0]);
                          ++HIDWORD(v186[0]);
                          v17[v113] = (v79 >> 6) & 0x3F | 0x80;
                        }
                        else
                        {
                          uint64_t v100 = SHIDWORD(v186[0]);
                          if (SHIDWORD(v186[0]) >= v168) {
                            goto LABEL_392;
                          }
                          ++HIDWORD(v186[0]);
                          v17[v100] = (v79 >> 6) - 64;
                        }
                        int v80 = HIDWORD(v186[0]);
                        LOBYTE(v79) = v79 & 0x3F | 0x80;
                      }
                      else
                      {
                        int v80 = HIDWORD(v186[0]);
                        if (SHIDWORD(v186[0]) >= v176) {
                          goto LABEL_392;
                        }
                      }
                      int v181 = 0;
                      int v26 = 0;
                      int v183 = 0;
                      HIDWORD(v186[0]) = v80 + 1;
                      v17[v80] = v79;
                      goto LABEL_191;
                    }
                    if (v79 < 0x12710)
                    {
                      int v181 = 0;
                      int v26 = 0;
                      int v183 = 0;
                      uint64_t v96 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v96] = ((unsigned __int16)v79 / 0x3E8u) | 0x30;
                      uint64_t v97 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v97] = (((unsigned __int16)v79 / 0x64u) % 0xAu) | 0x30;
                      unsigned int v98 = (unsigned __int16)v79 / 0xAu;
                      uint64_t v99 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v99] = (v98 - 10 * ((6554 * v98) >> 16)) | 0x30;
                      goto LABEL_189;
                    }
                    if (v79 >= 0x12AF8)
                    {
                      if (v79 >= 0x12B5C) {
                        return;
                      }
                      int v181 = 0;
                      int v26 = 0;
                      int v183 = 0;
                      LOBYTE(v79) = v79 + 8;
                      LOBYTE(v98) = v79 / 0xAu;
                      uint64_t v115 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v115] = (v79 / 0xAu) | 0x30;
LABEL_189:
                      char v108 = v79 - 10 * v98;
                    }
                    else
                    {
                      int v181 = 0;
                      int v26 = 0;
                      int v183 = 0;
                      unsigned __int16 v105 = v79 - 10000;
                      uint64_t v106 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v106] = (v105 / 0x64u) | 0x30;
                      uint64_t v107 = SHIDWORD(v186[0]);
                      ++HIDWORD(v186[0]);
                      v17[v107] = ((v105 / 0xAu) % 0xAu) | 0x30;
                      char v108 = v105 % 0xAu;
                    }
                    uint64_t v116 = SHIDWORD(v186[0]);
                    ++HIDWORD(v186[0]);
                    v17[v116] = v108 | 0x30;
                  }
LABEL_191:
                  int v23 = 3;
                  goto LABEL_304;
                }
                uint64_t v53 = v22;
                if ((v41 - 10) > 0x19)
                {
                  if (v183 != 1 || v41 > 9) {
                    goto LABEL_392;
                  }
                  int v26 = 0;
                  uint64_t v81 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  v17[v81] = v41 + 48;
                  int v183 = 1;
                  int v23 = 3;
                }
                else
                {
LABEL_72:
                  char v55 = sub_1DC3E0CA0(v183, v41);
                  int v23 = 0;
                  int v26 = 0;
                  int v183 = 0;
                  char v56 = v55 ^ 0x80;
                  float v17 = (unsigned __int8 *)v182;
                  uint64_t v57 = SHIDWORD(v186[0]);
                  ++HIDWORD(v186[0]);
                  *(unsigned char *)(v182 + v57) = v56;
                }
LABEL_124:
                signed int v24 = v180;
                uint64_t v22 = v53;
                uint64_t v27 = (v20 + 1);
                int v29 = v20 + 3;
                int v28 = v20 + 2;
                int v30 = v20 - 2;
              }
              goto LABEL_304;
            default:
              goto LABEL_304;
          }
        }
      }
    }
  }
}

BOOL sub_1DC3E3294(int a1)
{
  return a1 > 15 && a1 % 3 == 1;
}

void *sub_1DC3E32C4(void *__dst)
{
  if (__dst)
  {
    int v1 = __dst;
    unint64_t v2 = (void *)__dst[88];
    if (v2) {
      free(v2);
    }
    unsigned int v3 = (void *)v1[87];
    if (v3) {
      free(v3);
    }
    return memcpy(v1, &unk_1DC41BF30, 0x2C8uLL);
  }
  return __dst;
}

float sub_1DC3E3324(uint64_t a1, uint64_t a2, int a3, int *a4, _DWORD *a5, float *a6, float *a7, float result, float a9, float a10)
{
  int v10 = *(_DWORD *)a1;
  BOOL v11 = *(int *)a1 >= 5 && v10 == *(_DWORD *)a2;
  if (v11 && v10 - 4 > a3)
  {
    uint64_t v12 = *(void *)(a1 + 8);
    float v13 = vabds_f32(*(float *)(v12 + 4 * a3), result);
    float v14 = INFINITY;
    if (v13 <= INFINITY)
    {
      uint64_t v15 = a3;
      int v16 = v10 - a3 - 5;
      while (1)
      {
        float v14 = v13;
        if (!v16) {
          break;
        }
        int v17 = v15 + 1;
        float v13 = vabds_f32(*(float *)(v12 + 4 + 4 * v15), result);
        --v16;
        ++v15;
        if (v13 > v14)
        {
          a3 = v17 - 1;
          goto LABEL_13;
        }
      }
      a3 = *(_DWORD *)a1 - 5;
    }
LABEL_13:
    if (v14 <= a10)
    {
      uint64_t v18 = a3 + 4;
      BOOL result = *(float *)(v12 + 4 * v18);
      if (vabds_f32(result, a9) <= a10)
      {
        uint64_t v19 = *(void *)(a2 + 8);
        float v20 = *(float *)(v12 + 4 * a3);
        BOOL result = result - v20;
        uint64_t v21 = 4 * a3 + 4;
        *a7 = (float)(1.0 / result) * (float)(*(float *)(v12 + v21) - v20);
        a7[1] = (float)(1.0 / result) * (float)(*(float *)(v19 + v21) - *(float *)(v19 + 4 * a3));
        uint64_t v22 = 4 * a3 + 8;
        a7[2] = (float)(1.0 / result) * (float)(*(float *)(v12 + v22) - *(float *)(v12 + v21));
        a7[3] = (float)(1.0 / result) * (float)(*(float *)(v19 + v22) - *(float *)(v19 + v21));
        uint64_t v23 = 4 * a3 + 12;
        a7[4] = (float)(1.0 / result) * (float)(*(float *)(v12 + v23) - *(float *)(v12 + v22));
        a7[5] = (float)(1.0 / result) * (float)(*(float *)(v19 + v23) - *(float *)(v19 + v22));
        *a6 = result;
        *a4 = a3;
        *a5 = v18;
      }
    }
  }
  return result;
}

uint64_t sub_1DC3E3478(uint64_t result, uint64_t a2, unsigned int a3, float *a4, int a5)
{
  if ((a3 & 0x80000000) == 0 && *(_DWORD *)result == *(_DWORD *)a2)
  {
    uint64_t v5 = a3 + 4;
    if ((int)v5 < *(_DWORD *)result)
    {
      uint64_t v6 = *(void *)(result + 8);
      uint64_t v7 = *(void *)(a2 + 8);
      float v8 = *(float *)(v6 + 4 * a3);
      float v9 = *(float *)(v6 + 4 * v5) - v8;
      float v10 = 1.0;
      if (v9 > 0.0) {
        float v10 = 1.0 / v9;
      }
      *a4 = (float)(*(float *)(v6 + 4 * (a3 + 1)) - v8) * v10;
      a4[1] = v10 * (float)(*(float *)(v7 + 4 * (a3 + 1)) - *(float *)(v7 + 4 * a3));
      a4[2] = v10 * (float)(*(float *)(v6 + 4 * (a3 + 2)) - *(float *)(v6 + 4 * (a3 + 1)));
      a4[3] = v10 * (float)(*(float *)(v7 + 4 * (a3 + 2)) - *(float *)(v7 + 4 * (a3 + 1)));
      uint64_t v11 = a3 + 3;
      a4[4] = v10 * (float)(*(float *)(v6 + 4 * v11) - *(float *)(v6 + 4 * (a3 + 2)));
      a4[5] = v10 * (float)(*(float *)(v7 + 4 * v11) - *(float *)(v7 + 4 * (a3 + 2)));
      if (a5) {
        a4[6] = v10 * (float)(*(float *)(v6 + 4 * v5) - *(float *)(v6 + 4 * v11));
      }
    }
  }
  return result;
}

float sub_1DC3E355C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  float v3 = 0.0;
  do
  {
    float v4 = *(float *)(a1 + v2);
    if (v4 < 0.088235 || v4 >= 0.14706)
    {
      if (v4 < 0.14706 || v4 >= 0.20588)
      {
        if (v4 < 0.20588 || v4 >= 0.26471)
        {
          if (v4 < 0.26471 || v4 >= 0.32353)
          {
            if (v4 < 0.32353 || v4 >= 0.38235)
            {
              if (v4 < 0.38235 || v4 >= 0.44118)
              {
                if (v4 >= 0.44118 && v4 < 0.5)
                {
                  float v5 = v4 + -0.47059;
                  int v6 = 8;
                }
                else
                {
                  BOOL v8 = v4 >= 0.5;
                  BOOL v9 = v4 < 0.55882;
                  float v5 = v4 + -0.52941;
                  BOOL v10 = !v8 || !v9;
                  if (v8 && v9) {
                    int v6 = 9;
                  }
                  else {
                    int v6 = -1;
                  }
                  if (v10) {
                    float v5 = 1000000.0;
                  }
                }
              }
              else
              {
                float v5 = v4 + -0.41176;
                int v6 = 7;
              }
            }
            else
            {
              float v5 = v4 + -0.35294;
              int v6 = 6;
            }
          }
          else
          {
            float v5 = v4 + -0.29412;
            int v6 = 5;
          }
        }
        else
        {
          float v5 = v4 + -0.23529;
          int v6 = 4;
        }
      }
      else
      {
        float v5 = v4 + -0.17647;
        int v6 = 3;
      }
    }
    else
    {
      float v5 = v4 + -0.11765;
      int v6 = 2;
    }
    *(_DWORD *)(a2 + v2) = v6;
    float v3 = v3 + (float)(v5 * v5);
    v2 += 4;
  }
  while (v2 != 24);
  return expf(v3 * -20.0);
}

uint64_t sub_1DC3E36F8(int a1, int32x4_t *a2, float *a3)
{
  int v3 = 0;
  unsigned int v4 = vaddvq_s32(vmulq_s32(*a2, (int32x4_t)xmmword_1DC3FDDD0)) + 10 * a2[1].i32[0] + a2[1].i32[1];
  uint64_t v5 = (uint64_t)*(&off_1E6C3AF38 + a1 / 3);
  uint64_t v6 = (uint64_t)*(&off_1E6C3AF50 + a1 / 3);
  int v7 = 928;
  int v8 = 464;
  while (1)
  {
    uint64_t v9 = v8;
    unsigned int v10 = *(_DWORD *)(v5 + 4 * v8);
    BOOL v11 = v10 >= v4;
    if (v10 == v4) {
      break;
    }
    if (v10 <= v4) {
      int v12 = v7;
    }
    else {
      int v12 = v9;
    }
    if (v11) {
      int v7 = v12;
    }
    if (!v11) {
      int v3 = v9 + 1;
    }
    int v13 = v7 + v3;
    if (v7 + v3 < 0 != __OFADD__(v7, v3)) {
      ++v13;
    }
    int v8 = v13 >> 1;
    if (v7 <= v3)
    {
      if (*(_DWORD *)(v5 + 4 * v8) == v4)
      {
        uint64_t v9 = v8;
      }
      else
      {
        int v14 = *(_DWORD *)(v5 + 4 * v3) - v4;
        if (v14 < 0) {
          int v14 = v4 - *(_DWORD *)(v5 + 4 * v3);
        }
        int v15 = *(_DWORD *)(v5 + 4 * v7) - v4;
        if (v15 < 0) {
          int v15 = -v15;
        }
        *a3 = *a3 * 0.5;
        if (v14 >= v15) {
          int v3 = v7;
        }
        uint64_t v9 = v3;
      }
      return *(unsigned int *)(v6 + 4 * v9);
    }
  }
  return *(unsigned int *)(v6 + 4 * v9);
}

uint64_t sub_1DC3E37DC(unsigned int a1, int a2, int a3, int a4, signed int a5, uint64_t a6)
{
  signed int v7 = 3 * (a1 / 0x1E) + a2 / 3;
  uint64_t result = (v7 + 1);
  if ((int)result < a4 || v7 >= a5) {
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)a6)
  {
    unsigned int v10 = a1 - 30 * (v7 / 3);
    if (a3)
    {
      if (a2 != 6)
      {
        if (a2 != 3)
        {
          if (a2 || v10 > 0x1D) {
            goto LABEL_64;
          }
          uint64_t v11 = 0;
          int v12 = 0;
          ++*(_WORD *)(a6 + 104 + 2 * v10);
          unsigned __int16 v13 = *(_WORD *)(a6 + 104);
          do
          {
            unsigned int v14 = *(unsigned __int16 *)(a6 + 106 + 2 * v11++);
            if (v14 > v13)
            {
              int v12 = v11;
              unsigned __int16 v13 = v14;
            }
          }
          while (v11 != 29);
LABEL_43:
          *(_WORD *)(a6 + 228) = v13;
          *(_DWORD *)(a6 + 16) = v12;
          goto LABEL_64;
        }
        if (v10 + 2 >= 0x1D)
        {
          int v21 = *(_DWORD *)(a6 + 12);
        }
        else
        {
          uint64_t v20 = 0;
          int v21 = 0;
          uint64_t v22 = ((((86 * (char)v10) & 0x8000) != 0) + ((unsigned __int16)(86 * (char)v10) >> 8));
          ++*(_WORD *)(a6 + 86 + 2 * v22);
          unsigned __int16 v23 = *(_WORD *)(a6 + 86);
          do
          {
            unsigned int v24 = *(unsigned __int16 *)(a6 + 88 + 2 * v20++);
            if (v24 > v23)
            {
              int v21 = v20;
              unsigned __int16 v23 = v24;
            }
          }
          while (v20 != 8);
          *(_WORD *)(a6 + 224) = v23;
          *(_DWORD *)(a6 + 12) = v21;
        }
        unsigned int v35 = -3 * v21 + v10;
        if (v35 > 2) {
          goto LABEL_64;
        }
        uint64_t v36 = 0;
        int v37 = 0;
        ++*(_WORD *)(a6 + 164 + 2 * v35);
        unsigned __int16 v38 = *(_WORD *)(a6 + 164);
        do
        {
          unsigned int v39 = *(unsigned __int16 *)(a6 + 166 + 2 * v36++);
          if (v39 > v38)
          {
            int v37 = v36;
            unsigned __int16 v38 = v39;
          }
        }
        while (v36 != 2);
LABEL_63:
        *(_WORD *)(a6 + 230) = v38;
        *(_DWORD *)(a6 + 20) = v37;
LABEL_64:
        int v43 = *(_DWORD *)(a6 + 16);
        if ((v43 & 0x80000000) == 0)
        {
          int v44 = *(_DWORD *)(a6 + 20);
          if ((v44 & 0x80000000) == 0) {
            *(_DWORD *)(a6 + 4) = 3 * v43 + v44 + 1;
          }
        }
        if (*(unsigned __int16 *)(a6 + 226) < 3u
          || *(unsigned __int16 *)(a6 + 224) < 3u
          || *(unsigned __int16 *)(a6 + 228) < 3u
          || *(unsigned __int16 *)(a6 + 230) < 3u
          || (int v45 = *(_DWORD *)(a6 + 4), (v45 - 3) > 0x57))
        {
          int v47 = 0;
        }
        else
        {
          uint64_t v46 = *(int *)(a6 + 12);
          int v47 = 1;
          if (1 << (v46 + 1) >= *(_DWORD *)(a6 + 8) * v45)
          {
            int v47 = 0;
            *(_WORD *)(a6 + 2 * v46 + 86) = 0;
            *(_WORD *)(a6 + 224) = 0;
          }
        }
        *(_DWORD *)a6 = v47;
        return result;
      }
      if (v10 > 0x1D) {
        goto LABEL_64;
      }
      uint64_t v25 = 0;
      int v16 = 0;
      unsigned int v26 = v10 + 1;
      unsigned __int16 v18 = *(_WORD *)(a6 + 24);
      ++*(_WORD *)(a6 + 24 + 2 * v26);
      do
      {
        unsigned int v27 = *(unsigned __int16 *)(a6 + 26 + 2 * v25++);
        if (v27 > v18)
        {
          int v16 = v25;
          unsigned __int16 v18 = v27;
        }
      }
      while (v25 != 30);
    }
    else
    {
      if (a2 == 6)
      {
        if (v10 + 2 >= 0x1D)
        {
          int v31 = *(_DWORD *)(a6 + 12);
        }
        else
        {
          uint64_t v30 = 0;
          int v31 = 0;
          uint64_t v32 = ((((86 * (char)v10) & 0x8000) != 0) + ((unsigned __int16)(86 * (char)v10) >> 8));
          ++*(_WORD *)(a6 + 86 + 2 * v32);
          unsigned __int16 v33 = *(_WORD *)(a6 + 86);
          do
          {
            unsigned int v34 = *(unsigned __int16 *)(a6 + 88 + 2 * v30++);
            if (v34 > v33)
            {
              int v31 = v30;
              unsigned __int16 v33 = v34;
            }
          }
          while (v30 != 8);
          *(_WORD *)(a6 + 224) = v33;
          *(_DWORD *)(a6 + 12) = v31;
        }
        unsigned int v40 = -3 * v31 + v10;
        if (v40 > 2) {
          goto LABEL_64;
        }
        uint64_t v41 = 0;
        int v37 = 0;
        ++*(_WORD *)(a6 + 164 + 2 * v40);
        unsigned __int16 v38 = *(_WORD *)(a6 + 164);
        do
        {
          unsigned int v42 = *(unsigned __int16 *)(a6 + 166 + 2 * v41++);
          if (v42 > v38)
          {
            int v37 = v41;
            unsigned __int16 v38 = v42;
          }
        }
        while (v41 != 2);
        goto LABEL_63;
      }
      if (a2 == 3)
      {
        if (v10 > 0x1D) {
          goto LABEL_64;
        }
        uint64_t v28 = 0;
        int v12 = 0;
        ++*(_WORD *)(a6 + 104 + 2 * v10);
        unsigned __int16 v13 = *(_WORD *)(a6 + 104);
        do
        {
          unsigned int v29 = *(unsigned __int16 *)(a6 + 106 + 2 * v28++);
          if (v29 > v13)
          {
            int v12 = v28;
            unsigned __int16 v13 = v29;
          }
        }
        while (v28 != 29);
        goto LABEL_43;
      }
      if (a2 || v10 > 0x1D) {
        goto LABEL_64;
      }
      uint64_t v15 = 0;
      int v16 = 0;
      unsigned int v17 = v10 + 1;
      unsigned __int16 v18 = *(_WORD *)(a6 + 24);
      ++*(_WORD *)(a6 + 24 + 2 * v17);
      do
      {
        unsigned int v19 = *(unsigned __int16 *)(a6 + 26 + 2 * v15++);
        if (v19 > v18)
        {
          int v16 = v15;
          unsigned __int16 v18 = v19;
        }
      }
      while (v15 != 30);
    }
    *(_WORD *)(a6 + 226) = v18;
    *(_DWORD *)(a6 + 8) = v16;
    goto LABEL_64;
  }
  return result;
}

uint64_t sub_1DC3E3BF8(float *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  BOOL v51 = a1;
  int v52 = a2;
  *(void *)&long long v50 = a3;
  *((void *)&v50 + 1) = a4;
  sub_1DC3ED678(&v51, &v50, a6, a7);
  int v9 = v50;
  int v10 = v50 - 12;
  if ((int)v50 < 12) {
    return 16;
  }
  unsigned int v12 = v50 - 1;
  uint64_t v13 = *(void *)(a5 + 64);
  if (*(unsigned char *)(v13 + 30)) {
    int v14 = 4;
  }
  else {
    int v14 = v50;
  }
  __asm { FMOV            V0.2S, #-1.0 }
  *(void *)(a5 + 72) = _D0;
  *(void *)(v13 + 40) = 0;
  uint64_t v20 = (uint64_t)v52;
  *(_DWORD *)(v13 + 48) = *v52;
  uint64_t v21 = *((void *)&v50 + 1);
  *(_DWORD *)(v13 + 52) = *(_DWORD *)(*((void *)&v50 + 1) + 4 * v12);
  *(void *)(v13 + 32) = _D0;
  if (v14 - 1 >= v10) {
    unsigned int v22 = v10;
  }
  else {
    unsigned int v22 = v14 - 1;
  }
  float v23 = -1.0;
  unsigned int v24 = 0;
  if (v22)
  {
    while (1)
    {
      sub_1DC3E3478((uint64_t)&v51, (uint64_t)&v50, v24, v54, 0);
      float v26 = v25;
      float v27 = 0.0;
      if (v25 > 0.0)
      {
        float v28 = fmaxf(fabsf(9.0 - (float)(v54[0] * 17.0)) / 17.0, 0.0);
        float v29 = fabsf(2.0 - (float)(v54[1] * 17.0)) / 17.0;
        if (v29 > v28) {
          float v28 = v29;
        }
        float v30 = fabsf(2.0 - (float)(v54[2] * 17.0)) / 17.0;
        if (v30 > v28) {
          float v28 = v30;
        }
        float v31 = fabsf(2.0 - (float)(v54[3] * 17.0)) / 17.0;
        if (v31 > v28) {
          float v28 = v31;
        }
        float v32 = fabsf(2.0 - (float)(v54[4] * 17.0)) / 17.0;
        if (v32 > v28) {
          float v28 = v32;
        }
        float v33 = fabsf(2.0 - (float)(v54[5] * 17.0)) / 17.0;
        if (v33 > v28) {
          float v28 = v33;
        }
        float v27 = fmaxf(1.0 - v28, 0.0);
        if (v27 > 0.93) {
          break;
        }
      }
      if (v22 == ++v24)
      {
        unsigned int v24 = v22;
        float v23 = -1.0;
        if (!a6) {
          goto LABEL_28;
        }
        goto LABEL_29;
      }
    }
    float v23 = v26 / 17.0;
    *(float *)(a5 + 72) = v26 / 17.0;
    *(float *)(v13 + 32) = v26;
    *(_DWORD *)(v13 + 40) = v24;
    *(_DWORD *)(v13 + 48) = *(_DWORD *)(v20 + 4 * v24);
    if (a6) {
      goto LABEL_29;
    }
  }
  else
  {
    float v26 = 0.0;
    float v27 = 0.0;
    if (a6) {
      goto LABEL_29;
    }
  }
LABEL_28:
  if (v23 <= 0.0) {
    return 6;
  }
LABEL_29:
  int v34 = v24 + 12;
  if (v23 <= 0.0) {
    int v34 = 4;
  }
  if (v9 - v14 <= v34) {
    int v35 = v34;
  }
  else {
    int v35 = v9 - v14;
  }
  float v36 = -1.0;
  if (v9 <= v35)
  {
    float v38 = 0.0;
    float v39 = 0.0;
    if (a6) {
      goto LABEL_59;
    }
  }
  else
  {
    float v48 = v23;
    while (1)
    {
      int v37 = v9 - 1;
      sub_1DC3E3478((uint64_t)&v51, (uint64_t)&v50, v9 - 5, v53, 1);
      float v39 = 0.0;
      if (v38 > 0.0)
      {
        float v40 = fmaxf(fabsf(8.0 - (float)(v53[0] * 17.0)) / 17.0, 0.0);
        float v41 = fabsf(2.0 - (float)(v53[1] * 17.0)) / 17.0;
        if (v41 > v40) {
          float v40 = v41;
        }
        float v42 = fabsf(4.0 - (float)(v53[2] * 17.0)) / 17.0;
        if (v42 > v40) {
          float v40 = v42;
        }
        float v43 = fabsf(4.0 - (float)(v53[3] * 17.0)) / 17.0;
        if (v43 > v40) {
          float v40 = v43;
        }
        float v44 = fabsf(2.0 - (float)(v53[4] * 17.0)) / 17.0;
        if (v44 > v40) {
          float v40 = v44;
        }
        float v45 = fabsf(2.0 - (float)(v53[5] * 17.0)) / 17.0;
        if (v45 > v40) {
          float v40 = v45;
        }
        float v46 = fabsf(3.0 - (float)(v53[6] * 17.0)) / 17.0;
        if (v46 > v40) {
          float v40 = v46;
        }
        float v39 = fmaxf(1.0 - v40, 0.0);
        if (v39 > 0.93) {
          break;
        }
      }
      --v9;
      if (v37 <= v35)
      {
        unsigned int v12 = v37 - 1;
        float v23 = v48;
        float v36 = -1.0;
        if (!a6) {
          goto LABEL_56;
        }
        goto LABEL_59;
      }
    }
    float v36 = v38 / 17.0;
    *(float *)(a5 + 76) = v38 / 17.0;
    *(float *)(v13 + 36) = v38;
    *(_DWORD *)(v13 + 44) = v12 - v37;
    *(_DWORD *)(v13 + 52) = *(_DWORD *)(v21 + 4 * v37);
    unsigned int v12 = v9 - 1;
    float v23 = v48;
    if (a6) {
      goto LABEL_59;
    }
  }
LABEL_56:
  if (v36 <= 0.0) {
    return 6;
  }
LABEL_59:
  if ((float)(v27 * v39) > 0.93)
  {
    *(float *)(a5 + 24) = v27 * v39;
LABEL_75:
    *(_DWORD *)(v13 + 20) = 12;
    return 1;
  }
  if (v27 <= 0.93 || v23 <= 0.0)
  {
    if (v39 <= 0.93 || v36 <= 0.0)
    {
      *(_DWORD *)(a5 + 24) = 0;
      return 6;
    }
    float v49 = 0.0;
    if ((int)sub_1DC3E40A4((uint64_t)v51, v20, v50, v21, v12 - 8, &v49, v38) >= 1)
    {
      float v47 = v49;
      if (v39 < v49) {
        float v47 = v39;
      }
      goto LABEL_72;
    }
  }
  else
  {
    float v49 = 0.0;
    if ((int)sub_1DC3E40A4((uint64_t)v51, v20, v50, v21, v24 + 4, &v49, v26) >= 1)
    {
      float v47 = v49;
      if (v27 < v49) {
        float v47 = v27;
      }
LABEL_72:
      *(float *)(a5 + 24) = v47;
      uint64_t result = 1;
      goto LABEL_74;
    }
  }
  uint64_t result = 14;
LABEL_74:
  if (result == 1) {
    goto LABEL_75;
  }
  return result;
}

uint64_t sub_1DC3E40A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, float *a6, float a7)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  v17[0] = a1;
  v17[1] = a2;
  v16[0] = a3;
  v16[1] = a4;
  sub_1DC3E3478((uint64_t)v17, (uint64_t)v16, a5, v21, 0);
  if ((float)(vabds_f32(a7, v9) / a7) >= 0.2) {
    return 0xFFFFFFFFLL;
  }
  float v15 = sub_1DC3E355C((uint64_t)v21, (uint64_t)&v18);
  if (v15 <= 0.9) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v10 = (v18.i32[0] + v19 - (v18.i32[1] + v20) + 9) % 9;
  if (v10 > 6 || ((1 << v10) & 0x49) == 0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v12 = sub_1DC3E36F8(v10, &v18, &v15);
  if (v12 > 0x3A0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v13 = 3 * ((unsigned __int16)v12 / 0x1Eu) + v10 / 3u;
  if (v13 - 90 <= 0xFFFFFFA5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = v13 + 1;
  *a6 = v15;
  return result;
}

uint64_t sub_1DC3E4210(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, int *a8, float a9, float a10, float a11, float a12, void *a13, float *a14)
{
  int v14 = a8;
  float v15 = a7;
  uint64_t v18 = a4;
  uint64_t v184 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a4 + 29) && *(int *)(a4 + 4) >= 1 && *(int *)(a4 + 12) >= 1)
  {
    float v25 = *(float *)(a4 + 16);
    if (v25 > 0.0)
    {
      ++*a13;
      *a8 = -1;
      *a7 = -1;
      if (dword_1EBFFC218 < 1)
      {
        int v28 = 0;
      }
      else
      {
        uint64_t v27 = 0;
        int v28 = 0;
        float v29 = dword_1EBFFBA10;
        do
        {
          int v30 = *v29;
          v29 += 16;
          if (v30 == 13) {
            int v31 = 1 << v27;
          }
          else {
            int v31 = 0;
          }
          v28 |= v31;
          ++v27;
        }
        while (dword_1EBFFC218 != v27);
      }
      uint64_t v89 = *(void *)(a5 + 80);
      uint64_t v91 = sub_1DC3EDB08(a1, a2, v28, *(_DWORD *)(a4 + 4), *(_DWORD *)(a4 + 12), (void *)a5, v89 + 56, v89 + 72, a9, a10, a11, a12, 1.0, v25, a14);
      if (v91)
      {
        uint64_t v21 = v91;
        int v92 = -1;
        int v93 = -1;
LABEL_223:
        *float v15 = v93 - 1;
        int v88 = v92 - 1;
        goto LABEL_224;
      }
      uint64_t v167 = v89;
      unint64_t v147 = v15;
      if (a2)
      {
        int v95 = *(_DWORD *)(a4 + 40);
        int v94 = *(_DWORD *)(a4 + 44);
        uint64_t v96 = (int *)(a4 + 48);
        uint64_t v97 = (int *)(a4 + 52);
      }
      else
      {
        int v95 = 0;
        int v94 = 0;
        uint64_t v96 = *(int **)(v89 + 64);
        uint64_t v97 = (int *)(*(void *)(v89 + 80) + 4 * *(int *)(v89 + 72) - 4);
      }
      unsigned int v98 = (_DWORD *)(v89 + 72);
      if (a3)
      {
        uint64_t v183 = 0;
        long long v181 = 0u;
        long long v182 = 0u;
        memset(v180, 0, sizeof(v180));
        long long v179 = 0u;
        uint64_t v99 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
        *(void *)&long long v181 = v99;
        *((void *)v99 + 8) = 0;
        *((_DWORD *)v99 + 18) = 0;
        *((void *)v99 + 10) = 0;
        *(_OWORD *)uint64_t v99 = 0u;
        *((_OWORD *)v99 + 1) = 0u;
        *((_OWORD *)v99 + 2) = 0u;
        *(_OWORD *)(v99 + 44) = 0u;
        uint64_t v100 = sub_1DC3E3BF8(*(float **)(v89 + 56), *(_DWORD **)(v89 + 64), *(void *)(v89 + 72), *(void *)(v89 + 80), (uint64_t)&v179, 0, 0);
        if (v100 != 1)
        {
          uint64_t v21 = v100;
          sub_1DC3D5860((uint64_t)&v179);
          int v92 = -1;
          int v93 = -1;
          float v15 = v147;
          goto LABEL_223;
        }
        unsigned __int16 v101 = (int *)(v89 + 56);
        int v95 = *(_DWORD *)(v181 + 40);
        int v94 = *(_DWORD *)(v181 + 44);
        int v103 = *(_DWORD *)(v181 + 48);
        int v102 = *(_DWORD *)(v181 + 52);
        sub_1DC3D5860((uint64_t)&v179);
      }
      else
      {
        int v102 = *v97;
        int v103 = *v96;
        unsigned __int16 v101 = (int *)(v89 + 56);
      }
      char v104 = *(_DWORD **)(a5 + 80);
      v104[12] = v103;
      v104[13] = v102;
      v104[10] = v95;
      v104[11] = v94;
      long long v179 = xmmword_1DC41C1F8;
      v180[0] = 0x3F8000003F800000;
      v175.i64[1] = -1;
      *(void *)&long long v176 = -1;
      v175.i64[0] = -1;
      int v105 = *v101;
      uint64_t v106 = a6;
      if (*v101 - (v95 + v94) < 17 || *v98 != v105)
      {
        int v93 = -1;
        unsigned int v109 = -1;
        goto LABEL_157;
      }
      sub_1DC3E3478((uint64_t)v101, v89 + 72, v95 + 4, (float *)&v179, 0);
      if (!a14 && (float)(vabds_f32(*(float *)(a4 + 32), v107) / *(float *)(a4 + 32)) >= 0.3)
      {
        sub_1DC3E3478((uint64_t)v101, v89 + 72, v105 - v94 - 9, (float *)&v179, 0);
        unsigned int v109 = -1;
        int v93 = -1;
        goto LABEL_211;
      }
      v171.i32[0] = sub_1DC3E355C((uint64_t)&v179, (uint64_t)&v175);
      if (*(float *)v171.i32 <= 0.9)
      {
        int v93 = -1;
      }
      else
      {
        unsigned int v109 = (v175.i32[0] + (int)v176 - (v175.i32[1] + DWORD1(v176)) + 9) % 9;
        int v93 = -1;
        if (v109 <= 6 && ((1 << v109) & 0x49) != 0)
        {
          unsigned int v138 = sub_1DC3E36F8(v109, &v175, (float *)v171.i32);
          if (v138 <= 0x3A0)
          {
            int v93 = sub_1DC3E37DC(v138, v109, 1, 1, 90, a6);
            int v105 = *v101;
          }
LABEL_210:
          sub_1DC3E3478((uint64_t)v101, (uint64_t)v98, v105 - v94 - 9, (float *)&v179, 0);
          if (a14)
          {
LABEL_212:
            v171.i32[0] = sub_1DC3E355C((uint64_t)&v179, (uint64_t)&v175);
            if (*(float *)v171.i32 > 0.9)
            {
              unsigned int v114 = (v175.i32[0] + (int)v176 - (v175.i32[1] + DWORD1(v176)) + 9) % 9;
              int v110 = -1;
              if (v114 <= 6 && ((1 << v114) & 0x49) != 0)
              {
                unsigned int v139 = sub_1DC3E36F8(v114, &v175, (float *)v171.i32);
                if (v139 < 0x3A1)
                {
                  int v113 = sub_1DC3E37DC(v139, v114, 0, 1, 90, a6);
                  int v165 = *(_DWORD *)(a6 + 8);
                  BOOL v112 = v93 > 0;
                  BOOL v111 = v113 > 0;
                  if (v113 >= 1 && v93 >= 1)
                  {
                    char v115 = 0;
                    int v92 = v93;
                    if (v93 == v113) {
                      goto LABEL_170;
                    }
                  }
                  goto LABEL_159;
                }
                int v110 = v114;
              }
LABEL_158:
              BOOL v111 = 0;
              int v165 = *(_DWORD *)(a6 + 8);
              BOOL v112 = v93 > 0;
              int v113 = -1;
              unsigned int v114 = v110;
LABEL_159:
              if (!a14)
              {
                int v92 = v113;
                goto LABEL_222;
              }
              if (v113 != -1) {
                BOOL v112 = 0;
              }
              if (v112)
              {
                char v115 = 0;
                int v92 = -1;
              }
              else
              {
                char v116 = !v111;
                if (v93 == -1) {
                  char v115 = v116;
                }
                else {
                  char v115 = 1;
                }
                int v92 = v113;
              }
LABEL_170:
              if ((v115 & 1) == 0 && *(_DWORD *)a6)
              {
                int v117 = v93 <= v92 ? v92 : v93;
                uint64_t v118 = (v117 - 1);
                if (v117 >= 1 && v117 <= *(_DWORD *)(a6 + 4))
                {
                  float v119 = *(float *)(*(void *)(v167 + 64) + 4 * v95);
                  float v120 = *(float *)(*(void *)(v167 + 80) + 4 * (*(_DWORD *)(v167 + 72) - v94 - 5));
                  LODWORD(v170) = 0;
                  int v121 = v165;
                  if (v165 > 0)
                  {
                    unsigned int v168 = v109;
                    uint64_t v145 = v14;
                    float v122 = (float)(v120 - v119) / (float)((float)((float)((float)(v165 + 2) * 17.0) + 17.0) + 7.0);
                    float v123 = v122 * 17.0;
                    unsigned int v124 = v95 + 8;
                    uint64_t v159 = (v117 - 1);
                    unint64_t v163 = (unsigned char *)(a6 + v118 + 240);
                    uint64_t v125 = 30 * (int)v118;
                    uint64_t v126 = v165;
                    float v127 = 0.0;
                    int v128 = 2;
                    while (1)
                    {
                      sub_1DC3E3478((uint64_t)v101, (uint64_t)v98, v124, (float *)&v179, 0);
                      if ((float)(vabds_f32(v123, v129) / v123) < 0.03) {
                        break;
                      }
                      sub_1DC3E3324((uint64_t)v101, (uint64_t)v98, v95, (int *)&v170 + 1, &v170, v174, (float *)&v179, v119 + (float)((float)v128 * v123), v123 + (float)(v119 + (float)((float)v128 * v123)), v122);
                      if (!v130)
                      {
                        unsigned int v124 = v170;
                        int v95 = v170;
                        goto LABEL_183;
                      }
LABEL_201:
                      ++v128;
                      ++v125;
                      if (!--v126)
                      {
                        int v14 = v145;
                        uint64_t v118 = v159;
                        uint64_t v106 = a6;
                        int v121 = v165;
                        goto LABEL_221;
                      }
                    }
                    v124 += 4;
LABEL_183:
                    v171.i32[0] = sub_1DC3E355C((uint64_t)&v179, (uint64_t)&v175);
                    unsigned int v131 = (v175.i32[0] + (int)v176 - (v175.i32[1] + DWORD1(v176)) + 9) % 9;
                    if (v131 <= 6 && ((1 << v131) & 0x49) != 0 && (v131 == v168 || v131 == v114))
                    {
                      unsigned int v134 = sub_1DC3E36F8(v131, &v175, (float *)v171.i32);
                      if (v134 <= 0x3A0)
                      {
                        if (!*v163)
                        {
                          *unint64_t v163 = 1;
                          ++*(_DWORD *)(a6 + 232);
                        }
                        uint64_t v135 = *(void *)(a6 + 696);
                        float v136 = *(float *)(v135 + 4 * v125);
                        float v137 = *(float *)v171.i32;
                        if (v136 <= 0.9 && *(float *)v171.i32 > 0.9) {
                          ++*(_DWORD *)(a6 + 236);
                        }
                        if (v137 > v136)
                        {
                          *(_WORD *)(*(void *)(a6 + 704) + 2 * v125) = v134;
                          *(float *)(v135 + 4 * v125) = v137;
                          float v136 = v137;
                        }
                        float v127 = v127 + v136;
                      }
                    }
                    goto LABEL_201;
                  }
                  float v127 = 0.0;
LABEL_221:
                  *(float *)(v106 + 4 * v118 + 332) = v127 / (float)v121;
                }
              }
LABEL_222:
              float v15 = v147;
              uint64_t v21 = 0;
              goto LABEL_223;
            }
LABEL_157:
            int v110 = -1;
            goto LABEL_158;
          }
LABEL_211:
          if ((float)(vabds_f32(*(float *)(a4 + 36), v108) / *(float *)(a4 + 36)) >= 0.3) {
            goto LABEL_157;
          }
          goto LABEL_212;
        }
      }
      unsigned int v109 = -1;
      goto LABEL_210;
    }
  }
  ++*a13;
  *a8 = -1;
  *a7 = -1;
  uint64_t v20 = *(void *)(a5 + 80);
  uint64_t v21 = sub_1DC3ED600(a1, a14, (void *)a5, a9, a10, a11, a12);
  if (v21) {
    return v21;
  }
  int v22 = *(_DWORD *)a6;
  int v155 = a2;
  if (!a14)
  {
    if (v22)
    {
      unsigned int v23 = *(_DWORD *)(a6 + 8);
LABEL_19:
      int v24 = 1000;
      goto LABEL_20;
    }
LABEL_18:
    unsigned int v23 = llroundf((float)((float)(vabds_f32(*(float *)(v18 + 52), *(float *)(v18 + 48)) / *(float *)(v18 + 24)) + -69.0)/ 17.0);
    goto LABEL_19;
  }
  if (!v22) {
    goto LABEL_18;
  }
  unsigned int v23 = *(_DWORD *)(a6 + 8);
  int v24 = (int)(float)((float)(int)(8 * v23 + 34) * 1.5);
LABEL_20:
  float v32 = 7.0;
  long long v177 = 0u;
  long long v178 = 0u;
  int32x4_t v175 = 0u;
  long long v176 = 0u;
  int v33 = sub_1DC3A0718((uint64_t)&v175, *(float **)a5, *(_DWORD *)(a5 + 8), (float)(7.0 / (float)(int)(34 * v23 + 138)) + 0.5);
  if (v33) {
    BOOL v34 = v33 <= v24;
  }
  else {
    BOOL v34 = 0;
  }
  if (!v34)
  {
    sub_1DC3A0B9C((uint64_t)&v175);
    return 2;
  }
  int v35 = v33;
  int v153 = v24;
  int8x8_t v158 = (void *)a5;
  uint64_t v161 = a6;
  float v36 = (_DWORD *)(v20 + 56);
  uint64_t v154 = v20;
  int v37 = (_DWORD *)(v20 + 72);
  uint64_t v170 = 0;
  uint64_t v149 = (__int32 *)(v18 + 52);
  uint64_t v150 = (__int32 *)(v18 + 48);
  int v38 = -1;
  uint64_t v21 = 14;
  unsigned int v39 = 1;
  int v156 = -1;
  int v162 = -1;
  int v40 = -1;
  uint64_t v146 = v15;
  while (1)
  {
    if (v35 < 24) {
      goto LABEL_89;
    }
    int v166 = v38;
    float v41 = (float *)(*v158 + 4 * (int)(float)(*(float *)v176 + -0.5));
    LODWORD(v41) = *v41 <= v41[1];
    sub_1DC3DAAE8((int *)(v176 + 4 * v41), (v35 - v41) & 0xFFFFFFFE, (uint64_t)v36, (uint64_t)v37);
    if (v155)
    {
      int v43 = *(_DWORD *)(v18 + 40);
      __int32 v42 = *(_DWORD *)(v18 + 44);
      float v45 = v149;
      float v44 = v150;
    }
    else
    {
      int v43 = 0;
      __int32 v42 = 0;
      float v44 = *(__int32 **)(v154 + 64);
      float v45 = (__int32 *)(*(void *)(v154 + 80) + 4 * *(int *)(v154 + 72) - 4);
    }
    if (a3)
    {
      uint64_t v183 = 0;
      long long v181 = 0u;
      long long v182 = 0u;
      memset(v180, 0, sizeof(v180));
      long long v179 = 0u;
      float v46 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
      *(void *)&long long v181 = v46;
      *(_OWORD *)((char *)&v180[1] + 4) = 0u;
      *(_OWORD *)((char *)&v180[3] + 4) = 0u;
      *((void *)v46 + 8) = 0;
      *((_DWORD *)v46 + 18) = 0;
      *((void *)v46 + 10) = 0;
      *(_OWORD *)float v46 = 0u;
      *((_OWORD *)v46 + 1) = 0u;
      *((_OWORD *)v46 + 2) = 0u;
      *(_OWORD *)(v46 + 44) = 0u;
      if (sub_1DC3E3BF8(*(float **)(v154 + 56), *(_DWORD **)(v154 + 64), *(void *)(v154 + 72), *(void *)(v154 + 80), (uint64_t)&v179, 0, 0) != 1)
      {
        sub_1DC3D5860((uint64_t)&v179);
LABEL_88:
        uint64_t v18 = a4;
        int v38 = v166;
        goto LABEL_89;
      }
      int v43 = *(_DWORD *)(v181 + 40);
      __int32 v42 = *(_DWORD *)(v181 + 44);
      float32x2_t v151 = *(float32x2_t *)(v181 + 48);
      sub_1DC3D5860((uint64_t)&v179);
      float32x2_t v47 = v151;
    }
    else
    {
      v47.i32[0] = *v44;
      v47.i32[1] = *v45;
    }
    float v48 = (float32x2_t *)v158[10];
    v48[6] = vcvt_f32_s32(vcvt_s32_f32(v47));
    v48[5].i32[0] = v43;
    v48[5].i32[1] = v42;
    int v49 = v162;
    if (*v36 - (v43 + v42) < 12 || *v37 != *v36) {
      goto LABEL_55;
    }
    long long v50 = v14;
    unsigned int v51 = v156;
    if (v40 <= 0)
    {
      sub_1DC3E3478((uint64_t)v36, (uint64_t)v37, v43 + 4, v174, 0);
      if (!a14 && (float)(vabds_f32(*(float *)(a4 + 32), v52) / *(float *)(a4 + 32)) >= 0.3) {
        goto LABEL_50;
      }
      LODWORD(v170) = sub_1DC3E355C((uint64_t)v174, (uint64_t)&v171);
      if (*(float *)&v170 > 0.9)
      {
        unsigned int v51 = (v171.i32[0] + v172 - (v171.i32[1] + v173) + 9) % 9;
        if (v51 <= 6 && ((1 << v51) & 0x49) != 0)
        {
          unsigned int v54 = sub_1DC3E36F8(v51, &v171, (float *)&v170);
          if (v54 > 0x3A0) {
            goto LABEL_53;
          }
          int v156 = v51;
          int v55 = sub_1DC3E37DC(v54, v51, 1, 1, 90, v161);
          int v40 = v55;
          if (*(_DWORD *)v161)
          {
            if (v55 > *(_DWORD *)(v161 + 4)) {
              int v40 = -1;
            }
            else {
              int v40 = v55;
            }
          }
          int v49 = v162;
LABEL_50:
          unsigned int v51 = v156;
          goto LABEL_53;
        }
      }
      unsigned int v51 = -1;
    }
LABEL_53:
    int v156 = v51;
    if (v49 <= 0)
    {
      sub_1DC3E3478((uint64_t)v36, (uint64_t)v37, *v36 - v42 - 9, v174, 0);
      int v14 = v50;
      if (!a14 && (float)(vabds_f32(*(float *)(a4 + 36), v83) / *(float *)(a4 + 36)) >= 0.3)
      {
        BOOL v58 = 0;
        float v15 = v146;
        goto LABEL_75;
      }
      LODWORD(v170) = sub_1DC3E355C((uint64_t)v174, (uint64_t)&v171);
      float v15 = v146;
      if (*(float *)&v170 <= 0.9)
      {
        int v166 = -1;
      }
      else
      {
        unint64_t v144 = v14;
        unsigned int v84 = (v171.i32[0] + v172 - (v171.i32[1] + v173) + 9) % 9;
        if (v84 > 6 || ((1 << v84) & 0x49) == 0)
        {
          int v166 = -1;
        }
        else
        {
          unsigned int v86 = sub_1DC3E36F8(v84, &v171, (float *)&v170);
          int v166 = v84;
          if (v86 <= 0x3A0)
          {
            int v87 = sub_1DC3E37DC(v86, v84, 0, 1, 90, v161);
            if (*(_DWORD *)v161)
            {
              if (v87 > *(_DWORD *)(v161 + 4)) {
                int v49 = -1;
              }
              else {
                int v49 = v87;
              }
            }
            else
            {
              int v49 = v87;
            }
          }
        }
        int v14 = v144;
      }
    }
    else
    {
      int v14 = v50;
      float v15 = v146;
    }
LABEL_55:
    BOOL v58 = v40 > 0 && v40 == v49 && v49 > 0;
    if (a14 && !v58) {
      BOOL v58 = v40 >= 1 && v49 == -1 || v40 == -1 && v49 > 0;
    }
LABEL_75:
    int v162 = v49;
    if (a3) {
      break;
    }
    if (!*(_DWORD *)v161 && v58) {
      break;
    }
    uint64_t v21 = 0;
    if (!*(_DWORD *)v161 || !v58) {
      goto LABEL_88;
    }
    if (v40 <= v162) {
      int v61 = v162;
    }
    else {
      int v61 = v40;
    }
    uint64_t v62 = (v61 - 1);
    if (v61 < 1 || v61 > *(_DWORD *)(v161 + 4))
    {
      uint64_t v21 = 0;
      goto LABEL_88;
    }
    float v63 = *(float *)(*(void *)(v154 + 64) + 4 * v43);
    float v64 = *(float *)(*(void *)(v154 + 80) + 4 * (*(_DWORD *)(v154 + 72) - v42 - 5));
    uint64_t v65 = *(int *)(v161 + 8);
    unsigned int v169 = 0;
    if ((int)v65 > 0)
    {
      uint64_t v142 = (v61 - 1);
      float v143 = v14;
      int v152 = 0;
      float v66 = (float)(v64 - v63) / (float)((float)((float)((float)(v65 + 2) * 17.0) + 17.0) + v32);
      float v67 = v66 * 17.0;
      unsigned int v68 = v43 + 8;
      unint64_t v148 = (unsigned char *)(v161 + v62 + 240);
      uint64_t v69 = 30 * (int)v62;
      float v70 = 0.0;
      int v71 = 2;
      int v141 = v65;
      uint64_t v72 = v65;
      while (1)
      {
        sub_1DC3E3478((uint64_t)v36, (uint64_t)v37, v68, v174, 0);
        *((float *)&v170 + 1) = v73;
        if ((float)(vabds_f32(v67, v73) / v67) < 0.03) {
          break;
        }
        sub_1DC3E3324((uint64_t)v36, (uint64_t)v37, v43, (int *)&v179, &v169, (float *)&v170 + 1, v174, v63 + (float)((float)v71 * v67), v67 + (float)(v63 + (float)((float)v71 * v67)), v66);
        if (!v74)
        {
          unsigned int v68 = v169;
          int v43 = v169;
          goto LABEL_99;
        }
LABEL_117:
        ++v69;
        ++v71;
        if (!--v72)
        {
          int v14 = v143;
          float v15 = v146;
          float v32 = 7.0;
          LODWORD(v65) = v141;
          uint64_t v62 = v142;
          int v82 = v152;
          goto LABEL_133;
        }
      }
      v68 += 4;
LABEL_99:
      LODWORD(v170) = sub_1DC3E355C((uint64_t)v174, (uint64_t)&v171);
      unsigned int v75 = (v171.i32[0] + v172 - (v171.i32[1] + v173) + 9) % 9;
      if (v75 <= 6 && ((1 << v75) & 0x49) != 0 && (v75 == v156 || v75 == v166))
      {
        unsigned int v78 = sub_1DC3E36F8(v75, &v171, (float *)&v170);
        if (v78 <= 0x3A0)
        {
          if (!*v148)
          {
            *unint64_t v148 = 1;
            ++*(_DWORD *)(v161 + 232);
          }
          uint64_t v79 = *(void *)(v161 + 696);
          float v80 = *(float *)(v79 + 4 * v69);
          float v81 = *(float *)&v170;
          if (v80 <= 0.9 && *(float *)&v170 > 0.9) {
            ++*(_DWORD *)(v161 + 236);
          }
          if (v81 > v80)
          {
            *(_WORD *)(*(void *)(v161 + 704) + 2 * v69) = v78;
            *(float *)(v79 + 4 * v69) = v81;
            float v80 = v81;
          }
          ++v152;
          float v70 = v70 + v80;
        }
      }
      goto LABEL_117;
    }
    int v82 = 0;
    float v70 = 0.0;
LABEL_133:
    uint64_t v21 = 0;
    *(float *)(v161 + 4 * v62 + 332) = v70 / (float)(int)v65;
    uint64_t v18 = a4;
    int v38 = v166;
    if (v82 == v65) {
      goto LABEL_140;
    }
LABEL_89:
    if (v39 > 2 || (int v35 = sub_1DC3A0948((uint64_t)&v175, *(float *)(v18 + 24)), v35 <= v153))
    {
      if (++v39 != 4) {
        continue;
      }
    }
    goto LABEL_140;
  }
  uint64_t v21 = 0;
LABEL_140:
  sub_1DC3A0B9C((uint64_t)&v175);
  *float v15 = v40 - 1;
  int v88 = v162 - 1;
LABEL_224:
  *int v14 = v88;
  return v21;
}

void sub_1DC3E52DC(uint64_t a1, float *a2, float *a3, float *a4, float *a5, uint64_t a6, int a7)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v53 = 0;
  int v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v49 = 0u;
  int v14 = sub_1DC3F0878(*(void *)(a1 + 32), *(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), (float **)&v53, (float *)&v49, (float)(int)roundf(*a2), (float)(int)roundf(a2[1]), (float)(int)roundf(*a3), (float)(int)roundf(a3[1]), 5.0);
  if (v14 < 9)
  {
    *(void *)a5 = *(void *)a2;
    *(void *)a6 = *(void *)a3;
    int v16 = (float *)v53;
    if (!v53) {
      return;
    }
    goto LABEL_23;
  }
  unsigned int v15 = v14;
  float v48 = a5;
  int v16 = (float *)v53;
  sub_1DC3F0A40((float *)v53, v14);
  float v17 = *((float *)&v50 + 1)
      + (float)((float)(*((float *)&v49 + 1) * (float)(*a4 - *((float *)&v50 + 3)))
              - (float)(*((float *)&v49 + 2) * (float)(*(float *)&v51 - a4[1])));
  uint64_t v18 = (float *)malloc_type_malloc(4 * v15, 0x100004052888210uLL);
  int v19 = v18;
  float v20 = *v16;
  *uint64_t v18 = *v16;
  for (uint64_t i = 1; i != v15; ++i)
  {
    float v20 = v20 + v16[i];
    v18[i] = v20;
  }
  int v22 = v15 >> 2;
  if ((int)(v15 >> 2) >= a7) {
    int v22 = a7;
  }
  if (a7 >= 2) {
    int v23 = v22;
  }
  else {
    int v23 = 2;
  }
  float v24 = 1.0 / (float)v23;
  if (v23 + 1 > (int)v17) {
    int v25 = v23 + 1;
  }
  else {
    int v25 = (int)v17;
  }
  if ((int)(v15 - 1 - v23) >= v25) {
    int v26 = v25;
  }
  else {
    int v26 = v15 - 1 - v23;
  }
  uint64_t v27 = (char *)malloc_type_malloc(4 * v15, 0x100004052888210uLL);
  bzero(v27, 4 * v15);
  uint64_t v28 = v26;
  int v29 = v26 + 2;
  uint64_t v30 = v26;
  while (v30 > v23)
  {
    float v31 = v19[v30 - 1 - v23];
    float v32 = v19[v23 + v30];
    uint64_t v33 = v30;
    int v34 = v30-- + 1;
    float v35 = v24 * (float)((float)(v19[v30] - v31) - (float)(v32 - v19[v33]));
    *(float *)&v27[v33 * 4] = v35;
    float v36 = *(float *)&v27[4 * v34];
    --v29;
    if (v36 > 0.4 && v36 > v35)
    {
      float v38 = (float)v29;
      goto LABEL_27;
    }
  }
  float v38 = 0.0;
LABEL_27:
  v56[0] = v38;
  bzero(v27, 4 * v15);
  if (v26 >= (int)(v15 - v23))
  {
LABEL_35:
    int v44 = v15 - 1;
  }
  else
  {
    unsigned int v39 = &v19[v26];
    int v40 = (float *)&v27[4 * v26];
    while (1)
    {
      float v41 = v24 * (float)((float)(v19[v23 + v28] - *v39) - (float)(*(v39 - 1) - v19[v28 - 1 - v23]));
      *int v40 = v41;
      float v42 = *(v40 - 1);
      if (v42 > 0.4 && v42 > v41) {
        break;
      }
      ++v28;
      ++v39;
      ++v40;
      if (v28 >= (int)(v15 - v23)) {
        goto LABEL_35;
      }
    }
    int v44 = v28 - 1;
  }
  v56[1] = (float)v44;
  sub_1DC3F02E0(*(void *)a1, *(void *)(a1 + 8), (float *)&v49, 2u, v56, v55, v54);
  float v45 = v55[1];
  float v46 = v54[0];
  float v47 = v54[1];
  *float v48 = v55[0];
  v48[1] = v46;
  *(float *)a6 = v45;
  *(float *)(a6 + 4) = v47;
  free(v27);
  free(v19);
  if (v16)
  {
LABEL_23:
    free(v16);
  }
}

uint64_t sub_1DC3E5690(float32x2_t *a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v353 = *MEMORY[0x1E4F143B8];
  pthread_once(&stru_1EAA94B70, (void (*)(void))sub_1DC3E802C);
  uint64_t v8 = *(void *)(a2 + 64);
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  v9.i32[0] = *(_DWORD *)(a3 + 40);
  if (v9.f32[0] >= 0.0) {
    float v10 = *(float *)(a3 + 40);
  }
  else {
    float v10 = v9.f32[0] + 6.2832;
  }
  if (*(unsigned char *)(v8 + 28)) {
    float v10 = fmodf(v10 + 3.1416, 6.2832);
  }
  if (*(unsigned char *)(v8 + 30))
  {
    int32x2_t v11 = *(int32x2_t *)(a3 + 32);
    v9.i32[0] = *(_DWORD *)(a3 + 44);
  }
  else
  {
    float32x2_t v9 = a1[7];
    int32x2_t v11 = vcvt_s32_f32(v9);
    v9.f32[0] = (float)(a1[2].i32[0] - a1[1].i32[1]);
  }
  int32x2_t v290 = (int32x2_t)v9;
  if (!*(unsigned char *)(v8 + 29) && *(int *)(v8 + 4) >= 1 && *(int *)(v8 + 12) >= 1 && *(float *)(v8 + 16) > 0.0)
  {
    int32x2_t v11 = *(int32x2_t *)(a3 + 32);
    v9.i32[0] = *(_DWORD *)(a3 + 44);
    int32x2_t v290 = (int32x2_t)v9;
  }
  int32x2_t v295 = v11;
  float v306 = 0;
  memset(v305, 0, sizeof(v305));
  long long v304 = 0u;
  uint64_t v289 = v8;
  sub_1DC3D5788((int *)v8, (uint64_t)&v304);
  BYTE12(v305[0]) = 0;
  int v303 = -1;
  int v302 = -1;
  unint64_t v301 = 1;
  memcpy(__dst, &unk_1DC41BF30, sizeof(__dst));
  v342 = malloc_type_calloc(0xA8CuLL, 2uLL, 0x1000040BDFB0063uLL);
  int v341 = malloc_type_malloc(0x2A30uLL, 0x100004052888210uLL);
  bzero(v341, 0x2A30uLL);
  uint64_t v299 = 0;
  uint64_t v300 = 0;
  unint64_t v297 = 0;
  unint64_t v298 = 0;
  float v12 = (float)v295.i32[1];
  int v14 = *(_DWORD *)(a2 + 28);
  int v13 = *(_DWORD *)(a2 + 32);
  int v15 = *(_DWORD *)(a2 + 44);
  int v16 = *(_DWORD *)(a2 + 48);
  long long v329 = 0u;
  long long v330 = 0u;
  long long v327 = 0u;
  long long v328 = 0u;
  long long v326 = 0u;
  float v17 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
  v331[0] = v17;
  *((void *)v17 + 8) = 0;
  *((_DWORD *)v17 + 18) = 0;
  *((void *)v17 + 10) = 0;
  *(_OWORD *)float v17 = 0u;
  *((_OWORD *)v17 + 1) = 0u;
  *((_OWORD *)v17 + 2) = 0u;
  *(_OWORD *)(v17 + 44) = 0u;
  float v320 = NAN;
  int v319 = -1;
  __float2 v18 = __sincosf_stret(v10);
  float v19 = v10;
  float v20 = v18.__cosval * (float)(*(float *)v290.i32 * 0.5);
  float v21 = v18.__sinval * (float)(*(float *)v290.i32 * 0.5);
  float v276 = (float)v295.i32[0];
  v296 = a4;
  float v281 = v12;
  if (sub_1DC3E4210((uint64_t)a4, 1, 1, (uint64_t)&v304, (uint64_t)&v326, (uint64_t)__dst, &v320, &v319, v276 - v20, v12 - v21, v20 + v276, v21 + v12, &v301, 0) >= 2)
  {
    sub_1DC3D5988((uint64_t)&v326);
    uint64_t v36 = 21;
    float v37 = v19;
  }
  else
  {
    int v277 = v14;
    int v272 = v13;
    int v282 = v15;
    int v22 = v325;
    int v23 = (float *)&v322 + 3;
    uint64_t v24 = *(void *)(v331[0] + 64);
    int v25 = (float *)(v24 + 4 * *(int *)(v331[0] + 40));
    float v286 = (float)(vabds_f32(v25[4], *v25)
                 + vabds_f32(*(float *)(*(void *)(v331[0] + 80)+ 4 * (*(_DWORD *)(v331[0] + 72) + ~*(_DWORD *)(v331[0] + 44))), *(float *)(v24 + 4 * (*(_DWORD *)(v331[0] + 72) - *(_DWORD *)(v331[0] + 44) - 5))))/ 35.0;
    memset(v324, 0, sizeof(v324));
    long long v322 = 0u;
    long long v323 = 0u;
    __vImage_Buffer src = 0u;
    int v26 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
    v325[0] = v26;
    *((void *)v26 + 8) = 0;
    *((_DWORD *)v26 + 18) = 0;
    *((void *)v26 + 10) = 0;
    *(_OWORD *)int v26 = 0u;
    *((_OWORD *)v26 + 1) = 0u;
    *((_OWORD *)v26 + 2) = 0u;
    *(_OWORD *)(v26 + 44) = 0u;
    if ((float)((float)(v286 * 3.0) * 3.0) <= 2.0) {
      float v27 = 1.0;
    }
    else {
      float v27 = (float)((float)(v286 * 3.0) * 3.0) * 0.5;
    }
    int v28 = vcvtps_s32_f32(log2f(v27) + 0.5);
    if (v28 <= 1) {
      int v29 = 1;
    }
    else {
      int v29 = v28;
    }
    float v270 = v19;
    float v30 = v19 + -1.57079633;
    __float2 v31 = __sincosf_stret(v30);
    float v32 = v19 + 1.57079633;
    __float2 v33 = __sincosf_stret(v32);
    while (1)
    {
      if (sub_1DC3E4210((uint64_t)a4, 1, 1, (uint64_t)&v304, (uint64_t)&__src, (uint64_t)__dst, &v320, &v319, (float)((float)(v31.__cosval * v27) + v276) - v20, (float)((float)(v31.__sinval * v27) + v12) - v21, v20 + (float)((float)(v31.__cosval * v27) + v276), v21 + (float)((float)(v31.__sinval * v27) + v12), &v301, 0) < 2)
      {
        int v260 = v16;
        uint64_t v267 = a2;
        float v38 = (float *)&v327 + 3;
        unsigned int v39 = v331;
        goto LABEL_29;
      }
      sub_1DC3D5988((uint64_t)&__src);
      memset(v324, 0, sizeof(v324));
      long long v322 = 0u;
      long long v323 = 0u;
      __vImage_Buffer src = 0u;
      int v34 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
      v325[0] = v34;
      *((void *)v34 + 8) = 0;
      *((_DWORD *)v34 + 18) = 0;
      *((void *)v34 + 10) = 0;
      *(_OWORD *)int v34 = 0u;
      *((_OWORD *)v34 + 1) = 0u;
      *((_OWORD *)v34 + 2) = 0u;
      *(_OWORD *)(v34 + 44) = 0u;
      if (sub_1DC3E4210((uint64_t)a4, 1, 1, (uint64_t)&v304, (uint64_t)&__src, (uint64_t)__dst, &v320, &v319, (float)((float)(v33.__cosval * v27) + v276) - v20, (float)((float)(v33.__sinval * v27) + v12) - v21, v20 + (float)((float)(v33.__cosval * v27) + v276), v21 + (float)((float)(v33.__sinval * v27) + v12), &v301, 0) < 2)break; {
      sub_1DC3D5988((uint64_t)&__src);
      }
      memset(v324, 0, sizeof(v324));
      long long v322 = 0u;
      long long v323 = 0u;
      __vImage_Buffer src = 0u;
      float v35 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
      v325[0] = v35;
      *((void *)v35 + 8) = 0;
      *((_DWORD *)v35 + 18) = 0;
      *((void *)v35 + 10) = 0;
      *(_OWORD *)float v35 = 0u;
      *((_OWORD *)v35 + 1) = 0u;
      *((_OWORD *)v35 + 2) = 0u;
      float v27 = v27 * 0.5;
      *(_OWORD *)(v35 + 44) = 0u;
      if (!--v29)
      {
        unint64_t v259 = 0;
        uint64_t v36 = 21;
        float v291 = 0.0;
        float v273 = 0.0;
        float v283 = 0.0;
        float v264 = 0.0;
        float v278 = 0.0;
        float v262 = 0.0;
        float v287 = 0.0;
        float v266 = 0.0;
        unint64_t v258 = 0;
        uint64_t v257 = 0;
        uint64_t v261 = 0;
        uint64_t v8 = v289;
        float v37 = v19;
        goto LABEL_52;
      }
    }
    int v260 = v16;
    uint64_t v267 = a2;
    float v38 = (float *)&v322 + 3;
    unsigned int v39 = v325;
    int v23 = (float *)&v327 + 3;
    int v22 = v331;
LABEL_29:
    uint64_t v40 = *v22;
    int v41 = *(_DWORD *)(*v22 + 44);
    uint64_t v42 = *(int *)(*v22 + 40);
    uint64_t v43 = *(void *)(*v22 + 64);
    uint64_t v44 = *(void *)(*v22 + 80);
    int v45 = *(_DWORD *)(v44 + 4 * v42);
    LODWORD(v350) = *(_DWORD *)(v43 + 4 * v42);
    HIDWORD(v350) = v45;
    LODWORD(v40) = *(_DWORD *)(v40 + 56) - v41 - 5;
    int v46 = *(_DWORD *)(v44 + 4 * (int)v40);
    int v351 = *(_DWORD *)(v43 + 4 * (int)v40);
    int v352 = v46;
    unint64_t v47 = *a4;
    unint64_t v48 = a4[1];
    sub_1DC3F02E0(*a4, v48, v23, 4u, (float *)&v350, (float *)&v336, (float *)&v332);
    float v49 = (float)(*(float *)&v336 + *((float *)&v336 + 1)) * 0.5;
    float v50 = (float)(*(float *)&v332 + *((float *)&v332 + 1)) * 0.5;
    float v263 = (float)(*((float *)&v336 + 2) + *((float *)&v336 + 3)) * 0.5;
    uint64_t v51 = *v39;
    int v52 = *(_DWORD *)(*v39 + 44);
    uint64_t v53 = *(int *)(*v39 + 40);
    uint64_t v54 = *(void *)(*v39 + 64);
    uint64_t v55 = *(void *)(v51 + 80);
    float v56 = *(float *)(v55 + 4 * v53);
    float v57 = (float)(*((float *)&v332 + 2) + *((float *)&v332 + 3)) * 0.5;
    float v249 = *(float *)(v54 + 4 * v53);
    unint64_t v347 = __PAIR64__(LODWORD(v56), LODWORD(v249));
    LODWORD(v53) = *(_DWORD *)(v51 + 56) - v52 - 5;
    int v58 = *(_DWORD *)(v55 + 4 * (int)v53);
    int v348 = *(_DWORD *)(v54 + 4 * (int)v53);
    int v349 = v58;
    sub_1DC3F02E0(v47, v48, v38, 4u, (float *)&v347, (float *)&v336, (float *)&v332);
    int v59 = *(_DWORD *)(*v22 + 72) + ~v41;
    int v60 = *(_DWORD *)(v51 + 72);
    a4 = v296;
    uint64_t v61 = *(void *)(*v22 + 80);
    float v62 = *(float *)(v61 + 4 * v59);
    int v63 = v60 + ~v52;
    uint64_t v64 = *(void *)(*v22 + 64);
    float v65 = *(float *)(v64 + 4 * v42);
    float v66 = *(float *)(v55 + 4 * v63);
    float v67 = *(float *)(v61 + 4 * v42);
    float v68 = *(float *)(v64 + 4 * v59 - 16);
    float v69 = *(float *)(v54 + 4 * v63 - 16);
    uint64_t v318 = 0;
    uint64_t v317 = 0;
    uint64_t v316 = 0;
    uint64_t v315 = 0;
    float v70 = (float)(*v296 - 2);
    float v71 = (float)(v296[1] - 2);
    float v72 = 1.0;
    float v255 = v62;
    float v256 = v56;
    float v253 = v66;
    float v254 = v65;
    float v251 = v68;
    float v252 = v67;
    float v250 = v69;
    float v265 = (float)(*((float *)&v336 + 2) + *((float *)&v336 + 3)) * 0.5;
    float v292 = (float)(*((float *)&v332 + 2) + *((float *)&v332 + 3)) * 0.5;
    if (BYTE14(v305[0]))
    {
      int v73 = v277;
      uint64_t v8 = v289;
      if (v277 >= v282)
      {
        float v75 = 1.0;
        a2 = v267;
      }
      else
      {
        a2 = v267;
        if (v272 >= v260)
        {
          float v75 = 1.0;
        }
        else
        {
          if (v277 <= 1) {
            int v73 = 1;
          }
          float v72 = (float)v73;
          if (v272 <= 1) {
            int v74 = 1;
          }
          else {
            int v74 = v272;
          }
          float v75 = (float)v74;
          if (v70 >= (float)v282) {
            float v70 = (float)v282;
          }
          if (v71 >= (float)v260) {
            float v71 = (float)v260;
          }
        }
      }
    }
    else
    {
      float v75 = 1.0;
      a2 = v267;
      uint64_t v8 = v289;
    }
    float v279 = (float)(*(float *)&v336 + *((float *)&v336 + 1)) * 0.5;
    float v284 = (float)(*(float *)&v332 + *((float *)&v332 + 1)) * 0.5;
    float v76 = v71;
    sub_1DC3F0024((float *)&v318 + 1, (float *)&v318, (float *)&v317 + 1, (float *)&v317, v49, v50, v279, v284, v72, v70, v75, v71);
    sub_1DC3F0024((float *)&v316 + 1, (float *)&v316, (float *)&v315 + 1, (float *)&v315, v263, v57, v265, v292, v72, v70, v75, v76);
    float v345 = *((float *)&v318 + 1);
    float v346 = *(float *)&v318;
    float v343 = *((float *)&v317 + 1);
    float v344 = *(float *)&v317;
    *(float *)double v314 = (float)(v49 + v279) * 0.5;
    *(float *)&v314[1] = (float)(v50 + v284) * 0.5;
    int v77 = vcvtps_s32_f32(v286 + v286);
    sub_1DC3E52DC((uint64_t)v296, &v345, &v343, (float *)v314, (float *)&v300, (uint64_t)&v299, v77);
    v313[0] = HIDWORD(v316);
    v313[1] = v316;
    v312[0] = *((float *)&v315 + 1);
    LODWORD(v312[1]) = v315;
    v311[0] = (float)(v263 + v265) * 0.5;
    v311[1] = (float)(v57 + v292) * 0.5;
    sub_1DC3E52DC((uint64_t)v296, (float *)v313, v312, v311, (float *)&v297, (uint64_t)&v298, v77);
    uint64_t v261 = v300;
    uint64_t v257 = v299;
    unint64_t v258 = v298;
    unint64_t v259 = v297;
    LODWORD(v283) = v297;
    float v278 = *((float *)&v300 + 1);
    float v287 = *(float *)&v300;
    float v293 = *((float *)&v297 + 1);
    LODWORD(v264) = v298;
    float v262 = *((float *)&v299 + 1);
    float v266 = *(float *)&v299;
    float v274 = *((float *)&v298 + 1);
    if (sub_1DC3EFD04(&v310, &v309, &v308, &v307, *(float *)&v300, *((float *)&v300 + 1), *(float *)&v297, *((float *)&v297 + 1), *(float *)&v299, *((float *)&v299 + 1), *(float *)&v298, *((float *)&v298 + 1)) == 2)
    {
      uint64_t v36 = 22;
      float v12 = v281;
      float v78 = v293;
      float v79 = v274;
      float v37 = v270;
    }
    else
    {
      float v80 = v283 - v287;
      float v78 = v293;
      float v81 = v293 - v278;
      float v82 = v264 - v266;
      float v79 = v274;
      float v83 = v274 - v262;
      float v84 = sqrtf((float)(v81 * v81) + (float)(v80 * v80));
      float v12 = v281;
      float v37 = v270;
      if ((float)(vabds_f32(v84, sqrtf((float)(v83 * v83) + (float)(v82 * v82))) / v84) < 0.5
        && (float v85 = sqrtf((float)((float)(v262 - v278) * (float)(v262 - v278))+ (float)((float)(v266 - v287) * (float)(v266 - v287))), (float)(vabds_f32(v85, sqrtf((float)((float)(v274 - v293) * (float)(v274 - v293))+ (float)((float)(v264 - v283) * (float)(v264 - v283))))/ v85) < 0.5))
      {
        uint64_t v36 = 0;
        float v86 = (float)((float)((float)(v255 - v251) / (float)(v255 - v254))
                    + (float)((float)(v253 - v250) / (float)(v253 - v249)))
            * 0.55;
        float v87 = (float)((float)((float)(v252 - v254) / (float)(v255 - v254))
                    + (float)((float)(v256 - v249) / (float)(v253 - v249)))
            * -0.55;
        float v88 = v287 + (float)(v87 * v80);
        *(float *)&uint64_t v89 = v88;
        float v278 = *((float *)&v261 + 1) + (float)(v87 * v81);
        *((float *)&v89 + 1) = v278;
        float v90 = *((float *)&v257 + 1) + (float)(v87 * v83);
        *(float *)&uint64_t v91 = v266 + (float)(v87 * v82);
        uint64_t v261 = v89;
        float v262 = v90;
        *((float *)&v91 + 1) = v90;
        float v78 = *((float *)&v259 + 1) + (float)(v86 * v81);
        float v283 = v283 + (float)(v86 * v80);
        float v287 = v88;
        float v79 = *((float *)&v258 + 1) + (float)(v86 * v83);
        float v264 = v264 + (float)(v86 * v82);
        float v266 = *(float *)&v91;
        uint64_t v299 = v91;
        uint64_t v300 = v89;
        uint64_t v257 = v91;
        unint64_t v258 = __PAIR64__(LODWORD(v79), LODWORD(v264));
        unint64_t v297 = __PAIR64__(LODWORD(v78), LODWORD(v283));
        unint64_t v298 = __PAIR64__(LODWORD(v79), LODWORD(v264));
        unint64_t v259 = __PAIR64__(LODWORD(v78), LODWORD(v283));
      }
      else
      {
        uint64_t v36 = 22;
      }
    }
    float v273 = v79;
    float v291 = v78;
LABEL_52:
    sub_1DC3D5988((uint64_t)&__src);
    sub_1DC3D5988((uint64_t)&v326);
    if (!v36)
    {
      v92.i64[0] = v261;
      v92.i64[1] = v257;
      *(int32x4_t *)(a2 + 28) = vcvtq_s32_f32(vrndaq_f32(v92));
      v92.i64[0] = v258;
      v92.i64[1] = v259;
      *(int32x4_t *)(a2 + 44) = vcvtq_s32_f32(vrndaq_f32(v92));
      float v93 = v266 - v287;
      float v94 = v262 - v278;
      float v95 = v264 - v283;
      float v96 = v273 - v291;
      int v97 = __dst[0];
      if (!LODWORD(__dst[0]))
      {
        if (v301 > 0x13)
        {
          int v97 = 0;
        }
        else
        {
          do
          {
            float v98 = (float)rand() * 4.6566e-10;
            float v99 = v287 + (float)(v98 * v93);
            float v100 = v278 + (float)(v98 * v94);
            float v101 = v283 + (float)(v98 * v95);
            long long v329 = 0u;
            long long v330 = 0u;
            long long v327 = 0u;
            long long v328 = 0u;
            float v102 = v291 + (float)(v98 * v96);
            long long v326 = 0u;
            int v103 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
            v331[0] = v103;
            *((void *)v103 + 8) = 0;
            *((_DWORD *)v103 + 18) = 0;
            *((void *)v103 + 10) = 0;
            *(_OWORD *)int v103 = 0u;
            *((_OWORD *)v103 + 1) = 0u;
            *((_OWORD *)v103 + 2) = 0u;
            *(_OWORD *)(v103 + 44) = 0u;
            sub_1DC3E4210((uint64_t)a4, 0, 0, (uint64_t)&v304, (uint64_t)&v326, (uint64_t)__dst, &v303, &v302, v99, v100, v101, v102, &v301, 0);
            sub_1DC3D5988((uint64_t)&v326);
            int v97 = __dst[0];
          }
          while (!LODWORD(__dst[0]) && v301 < 0x14);
        }
      }
      float v12 = v281;
      if (v97
        && SHIDWORD(__dst[0]) >= 3
        && SHIDWORD(__dst[0]) <= 90
        && SLODWORD(__dst[1]) >= 1
        && SLODWORD(__dst[1]) <= 30)
      {
        float v104 = (float)((float)(v291 - v278) * (float)(v291 - v278))
             + (float)((float)(v283 - v287) * (float)(v283 - v287));
        float v105 = (float)(v94 * v94) + (float)(v93 * v93);
        if (v104 <= (float)((float)((float)(v273 - v262) * (float)(v273 - v262))
                           + (float)((float)(v264 - v266) * (float)(v264 - v266))))
          float v104 = (float)((float)(v273 - v262) * (float)(v273 - v262))
               + (float)((float)(v264 - v266) * (float)(v264 - v266));
        float v106 = sqrtf(v104);
        if (v105 <= (float)((float)(v96 * v96) + (float)(v95 * v95))) {
          float v105 = (float)(v96 * v96) + (float)(v95 * v95);
        }
        float v107 = v106 / (float)((float)((float)((float)(LODWORD(__dst[1]) + 2) * 17.0) + 17.0) + 18.0);
        float v108 = 1.0;
        if (v107 > 0.0)
        {
          float v109 = 3.0 / v107;
          float v110 = 4.0;
          if (v109 <= 4.0) {
            float v110 = v109;
          }
          if (v109 >= 0.5) {
            float v108 = v110;
          }
          else {
            float v108 = 0.5;
          }
        }
        int v111 = 2 * HIDWORD(__dst[0]);
        float v112 = sqrtf(v105);
        *((float *)v305 + 2) = v108 * *((float *)v305 + 2);
        if (SDWORD1(v304) >= 1 && SHIDWORD(v304) >= 1 && *(float *)v305 > 0.0) {
          HIDWORD(v304) = vcvtps_s32_f32(v108 * (float)SHIDWORD(v304));
        }
        unsigned int v113 = (int)(float)(ceilf(v106 * v108) + 1.0);
        unsigned int v114 = (int)(float)(ceilf(v112 * v108) + 1.0);
        long long v323 = 0u;
        memset(v324, 0, 28);
        __vImage_Buffer src = 0u;
        long long v322 = 0u;
        sub_1DC3EE07C(v113, v114, (uint64_t)&__src, *(float *)&v261, *((float *)&v261 + 1), *(float *)&v257, *((float *)&v257 + 1), *(float *)&v258, *((float *)&v258 + 1), *(float *)&v259, *((float *)&v259 + 1));
        int v115 = 0;
        int v116 = 0;
        uint64_t v117 = 0;
        do
        {
          long long v329 = 0u;
          long long v330 = 0u;
          long long v327 = 0u;
          long long v328 = 0u;
          float v118 = (float)((float)v115 / (float)(v111 - 1)) * (float)(int)(v114 - 1);
          long long v326 = 0u;
          float v119 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
          v331[0] = v119;
          *((void *)v119 + 8) = 0;
          *((_DWORD *)v119 + 18) = 0;
          *((void *)v119 + 10) = 0;
          *(_OWORD *)float v119 = 0u;
          *((_OWORD *)v119 + 1) = 0u;
          *((_OWORD *)v119 + 2) = 0u;
          *(_OWORD *)(v119 + 44) = 0u;
          sub_1DC3E4210((uint64_t)a4, 0, 0, (uint64_t)&v304, (uint64_t)&v326, (uint64_t)__dst, &v303, &v302, 0.0, v118, (float)(int)(v113 - 1), v118, &v301, (float *)&__src);
          if (v303 >= 0) {
            unsigned int v120 = -1;
          }
          else {
            unsigned int v120 = v302;
          }
          if (v302 < 0 || v303 == v302) {
            uint64_t v122 = v303;
          }
          else {
            uint64_t v122 = v120;
          }
          if ((v122 & 0x80000000) != 0 || SHIDWORD(__dst[0]) <= (int)v122)
          {
            uint64_t v122 = v117;
          }
          else if ((int)v122 >= (int)v117)
          {
            v116 -= (int)v122 > (int)v117;
          }
          else
          {
            ++v116;
          }
          sub_1DC3D5988((uint64_t)&v326);
          ++v115;
          uint64_t v117 = v122;
          a4 = v296;
        }
        while (v111 != v115);
        if (v116 > 0)
        {
          *(int8x16_t *)(a2 + 28) = vextq_s8(*(int8x16_t *)(a2 + 28), *(int8x16_t *)(a2 + 28), 8uLL);
          *(int8x16_t *)(a2 + 44) = vextq_s8(*(int8x16_t *)(a2 + 44), *(int8x16_t *)(a2 + 44), 8uLL);
        }
      }
      uint64_t v36 = sub_1DC3E718C((uint64_t)__dst, a2);
      uint64_t v8 = v289;
      float v37 = v270;
      if (!v36)
      {
        if (v342[1] == 920) {
          *(_DWORD *)(a2 + 4) = 3;
        }
        sub_1DC3D5788((int *)&v304, v289);
        uint64_t v36 = 0;
      }
    }
  }
  sub_1DC3E32C4(__dst);
  sub_1DC3D5738((uint64_t)&v304);
  if (!v36) {
    return v36;
  }
  if (!*(unsigned char *)(v8 + 29)) {
    return 21;
  }
  memcpy(__dst, &unk_1DC41BF30, sizeof(__dst));
  v342 = malloc_type_calloc(0xA8CuLL, 2uLL, 0x1000040BDFB0063uLL);
  int v341 = malloc_type_malloc(0x2A30uLL, 0x100004052888210uLL);
  bzero(v341, 0x2A30uLL);
  memset(v305, 0, sizeof(v305));
  long long v304 = 0u;
  float v123 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
  float v306 = v123;
  *((void *)v123 + 8) = 0;
  *((_DWORD *)v123 + 18) = 0;
  *((void *)v123 + 10) = 0;
  *(_OWORD *)float v123 = 0u;
  *((_OWORD *)v123 + 1) = 0u;
  *((_OWORD *)v123 + 2) = 0u;
  *(_OWORD *)(v123 + 44) = 0u;
  *(int32x2_t *)(v8 + 40) = vadd_s32(*(int32x2_t *)(v8 + 40), (int32x2_t)0x800000004);
  if (*(unsigned char *)(v8 + 28)) {
    *(float32x2_t *)(v8 + 48) = vsub_f32((float32x2_t)vdup_lane_s32(v290, 0), *(float32x2_t *)(v8 + 48));
  }
  float v124 = *(float *)(v8 + 32);
  if (v124 <= 0.0) {
    float v125 = NAN;
  }
  else {
    float v125 = v124 + *(float *)(v8 + 48);
  }
  *(float *)(v8 + 48) = v125;
  float v126 = *(float *)(v8 + 36);
  if (v126 <= 0.0) {
    float v127 = NAN;
  }
  else {
    float v127 = *(float *)(v8 + 52) + (float)(v126 * -2.0);
  }
  *(float *)(v8 + 52) = v127;
  v314[0] = -1;
  uint64_t v36 = sub_1DC3E7450((uint64_t)a4, 1, 90, v8, (uint64_t)&v304, __dst, v314, 0, v276, v12, v37, *(float *)v290.i32);
  sub_1DC3D5988((uint64_t)&v304);
  if (v36 || v314[0] < 1) {
    goto LABEL_281;
  }
  float v268 = (_DWORD *)a2;
  char v285 = 0;
  uint64_t v128 = 0;
  unsigned int v129 = 0;
  uint64_t v288 = 0;
  int v130 = 0;
  float v131 = *(float *)(v8 + 24);
  float v132 = v18.__sinval * v131;
  float v133 = -(float)(v131 * v18.__cosval);
  int v339 = 0;
  long long v337 = 0u;
  long long v338 = 0u;
  long long v336 = 0u;
  int v335 = 0;
  long long v333 = 0u;
  long long v334 = 0u;
  long long v332 = 0u;
  int v275 = 1;
  float v134 = 2147500000.0;
  float v271 = -2147500000.0;
  int v294 = 4;
  char v135 = 1;
  float v269 = v127;
  while (1)
  {
    int v136 = v314[0];
    v313[0] = v314[0];
    *(float *)(v8 + 48) = v125;
    *(float *)(v8 + 52) = v127;
    if (v129 != 2)
    {
      if (v129 == 3)
      {
        float v137 = v296;
        if (SLODWORD(__dst[1]) >= 1) {
          memcpy(&v326, &__src, 4 * LODWORD(__dst[1]));
        }
      }
      else
      {
        float v137 = v296;
      }
      goto LABEL_180;
    }
    if (!LODWORD(__dst[0])) {
      break;
    }
    uint64_t v138 = v128;
    int v139 = __dst[1];
    uint64_t v140 = (LODWORD(__dst[1]) + 3);
    if (SLODWORD(__dst[1]) >= -2)
    {
      if ((int)v140 <= 1) {
        unsigned int v141 = 1;
      }
      else {
        unsigned int v141 = LODWORD(__dst[1]) + 3;
      }
      memset_pattern16(&__src, &unk_1DC3FDE80, 4 * v141);
    }
    memset(v305, 0, sizeof(v305));
    long long v304 = 0u;
    uint64_t v142 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
    float v306 = v142;
    *((void *)v142 + 8) = 0;
    *((_DWORD *)v142 + 18) = 0;
    *((void *)v142 + 10) = 0;
    *(_OWORD *)uint64_t v142 = 0u;
    *((_OWORD *)v142 + 1) = 0u;
    *((_OWORD *)v142 + 2) = 0u;
    int v143 = v136 - 1;
    int v144 = v136 + 1;
    *(_OWORD *)(v142 + 44) = 0u;
    float v137 = v296;
    int v145 = sub_1DC3E7450((uint64_t)v296, v143, v144, v8, (uint64_t)&v304, __dst, v313, &__src, v276, v281, v37, *(float *)v290.i32);
    sub_1DC3D5988((uint64_t)&v304);
    if (v145) {
      goto LABEL_229;
    }
    if (*(float *)&__src <= 0.0)
    {
      uint64_t v146 = 0;
      while (v140 != v146)
      {
        uint64_t v147 = v146++;
        if (*((float *)&__src + v147 + 1) > 0.0)
        {
          if (!v146) {
            goto LABEL_138;
          }
          float v148 = *((float *)&__src + (int)v146);
          uint64_t v149 = (int)v146;
          float v150 = *(float *)((char *)&__src + (((v147 << 32) + 0x200000000) >> 30)) - v148;
          goto LABEL_136;
        }
      }
      if (v140)
      {
        float v148 = *((float *)&__src + (int)v140);
        uint64_t v149 = (int)v140;
        float v150 = *((float *)&__src + v139 + 4) - v148;
        LODWORD(v146) = v140;
LABEL_136:
        uint64_t v151 = v149 - 1;
        do
        {
          float v148 = v148 - v150;
          *((float *)&__src + v151) = v148;
        }
        while (v151--);
        goto LABEL_138;
      }
      LODWORD(v146) = 0;
      int v154 = 0;
      int v157 = 0;
      if (v320 > 0.0) {
        goto LABEL_154;
      }
    }
    else
    {
      LODWORD(v146) = 0;
LABEL_138:
      if (*((float *)&__src + v139 + 2) > 0.0) {
        goto LABEL_150;
      }
      if (v140)
      {
        int v153 = &v320 + (int)v140;
        int v154 = v140;
        do
          float v155 = *v153--;
        while (v155 <= 0.0 && v154-- != 1);
      }
      else
      {
        int v154 = 0;
      }
    }
    if (v154 != v140)
    {
      int8x8_t v158 = (float *)&__src + v154;
      float v159 = *v158;
      float v160 = *v158 - *(v158 - 1);
      uint64_t v161 = (float *)&__src + v154 + 1;
      int v162 = v140;
      do
      {
        float v159 = v160 + v159;
        *v161++ = v159;
        --v162;
      }
      while (v154 != v162);
      int v157 = v146;
      goto LABEL_154;
    }
LABEL_150:
    int v157 = v146;
    int v154 = v140;
LABEL_154:
    if (v157 + 1 < v154)
    {
LABEL_155:
      uint64_t v163 = v157;
      int v164 = -v157;
      while (v154 != v163)
      {
        uint64_t v165 = v163;
        int v166 = v164;
        ++v163;
        --v164;
        if (*((float *)&__src + v165 + 1) <= 0.0)
        {
          if (v154 != v163)
          {
            uint64_t v167 = (int)v163;
            while (v154 != v167)
            {
              int v168 = v167 + 1;
              float v169 = *((float *)&__src + ++v167);
              if (v169 > 0.0)
              {
                uint64_t v170 = v168;
                int v157 = v168;
                goto LABEL_164;
              }
            }
            uint64_t v170 = v154;
            int v157 = v154;
LABEL_164:
            int v171 = v163 - 1;
            int v172 = v157 - (v163 - 1);
            if (v157 != v171)
            {
              float v173 = *((float *)&__src + v171);
              float v174 = (float)(*((float *)&__src + v170) - v173) / (float)v172;
              int v175 = v157 + v166;
              long long v176 = (float *)&__src + (int)v165 + 1;
              do
              {
                float v173 = v174 + v173;
                *v176++ = v173;
                --v175;
              }
              while (v175);
            }
            if (v157 != v154) {
              goto LABEL_155;
            }
          }
          break;
        }
      }
    }
    if (v139 >= -2)
    {
      if ((int)v140 <= 1) {
        unsigned int v177 = 1;
      }
      else {
        unsigned int v177 = v140;
      }
      memcpy(&v326, &__src, 4 * v177);
    }
    float v178 = *(float *)(v8 + 24);
    if (v178 <= 5.0) {
      int v179 = 2;
    }
    else {
      int v179 = 4;
    }
    int v275 = v179;
    float v132 = v132 / (float)v179;
    float v133 = v133 / (float)v179;
    if (v178 <= 5.0) {
      char v180 = 1;
    }
    else {
      char v180 = 2;
    }
    v294 <<= v180;
    uint64_t v288 = &v326;
    uint64_t v128 = v138;
LABEL_180:
    int v280 = v130;
    if ((v294 & 0x80000000) == 0)
    {
      int v181 = 0;
      int v182 = 1;
      float v183 = v281;
      float v184 = v276;
      while (1)
      {
        if (v129 <= 1 && LODWORD(__dst[0])) {
          goto LABEL_226;
        }
        float v184 = v132 + v184;
        if (v184 < 1.0) {
          goto LABEL_226;
        }
        float v183 = v133 + v183;
        BOOL v185 = v184 > (float)(*v137 - 2) || v183 < 1.0;
        if (v185 || v183 > (float)(v137[1] - 2)) {
          goto LABEL_226;
        }
        int v186 = v137;
        int v187 = v313[0];
        memset(&v305[2], 0, 32);
        int v188 = ((v135 ^ v285) & 1) != 0 ? v313[0] - v182 : v313[0];
        int v189 = ((v135 ^ v285) & 1) != 0 ? v313[0] : v313[0] + v182;
        memset(v305, 0, 32);
        int v190 = (v128 & 1) != 0 ? v188 : v313[0] - v182;
        int v191 = (v128 & 1) != 0 ? v189 : v313[0] + v182;
        long long v304 = 0uLL;
        uint64_t v192 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
        float v306 = v192;
        *((void *)v192 + 8) = 0;
        *((_DWORD *)v192 + 18) = 0;
        *((void *)v192 + 10) = 0;
        *(_OWORD *)uint64_t v192 = 0u;
        *((_OWORD *)v192 + 1) = 0u;
        *((_OWORD *)v192 + 2) = 0u;
        *(_OWORD *)(v192 + 44) = 0u;
        uint64_t v193 = (uint64_t)v186;
        uint64_t v8 = v289;
        if (!sub_1DC3E7450(v193, v190, v191, v289, (uint64_t)&v304, __dst, v313, v288, v184, v183, v37, *(float *)v290.i32))break; {
        if (++v181 / v275 < 2)
        }
          int v182 = v181 / v275 + 1;
        else {
          int v182 = 3;
        }
        float v137 = v296;
LABEL_216:
        sub_1DC3D5988((uint64_t)&v304);
        if (v181 > v294) {
          goto LABEL_226;
        }
      }
      if (v128)
      {
        uint64_t v128 = 1;
        goto LABEL_211;
      }
      if (v313[0] == v187)
      {
        uint64_t v128 = 0;
LABEL_211:
        float v137 = v296;
      }
      else
      {
        if ((v135 ^ (v313[0] >= v187))) {
          int v194 = v280 - 1;
        }
        else {
          int v194 = v280 + 1;
        }
        float v137 = v296;
        int v280 = v194;
        if (v194 == -2)
        {
          char v285 = 0;
          uint64_t v128 = 1;
        }
        else if (v194 == 2)
        {
          uint64_t v128 = 1;
          int v280 = 2;
          char v285 = 1;
        }
        else
        {
          uint64_t v128 = 0;
        }
      }
      if (v134 >= (float)v313[0])
      {
        int v181 = 0;
        uint64_t v350 = *(void *)(v289 + 48);
        long long v336 = *(_OWORD *)((char *)v305 + 12);
        long long v337 = *(_OWORD *)((char *)&v305[1] + 12);
        long long v338 = *(_OWORD *)((char *)&v305[2] + 12);
        int v339 = HIDWORD(v305[3]);
        float v134 = (float)v313[0];
      }
      else
      {
        int v181 = 0;
        if (v271 <= (float)v313[0])
        {
          unint64_t v347 = *(void *)(v289 + 48);
          long long v332 = *(_OWORD *)((char *)v305 + 12);
          long long v333 = *(_OWORD *)((char *)&v305[1] + 12);
          long long v334 = *(_OWORD *)((char *)&v305[2] + 12);
          int v335 = HIDWORD(v305[3]);
          float v271 = (float)v313[0];
        }
      }
      goto LABEL_216;
    }
LABEL_226:
    ++v129;
    float v132 = -v132;
    float v133 = -v133;
    v135 ^= 1u;
    float v127 = v269;
    int v130 = v280;
    if (v129 == 4) {
      goto LABEL_229;
    }
  }
  float v137 = v296;
LABEL_229:
  uint64_t v36 = sub_1DC3E718C((uint64_t)__dst, (uint64_t)v268);
  if (!v36)
  {
    if (v342[1] == 920) {
      v268[1] = 3;
    }
    float v195 = *(float *)(v8 + 32);
    float v196 = *(float *)(v8 + 36);
    int v197 = __dst[1];
    if (v195 <= 0.0)
    {
      float v198 = v196 * (float)~LODWORD(__dst[1]);
      *(float *)&uint64_t v350 = *((float *)&v350 + 1) + v198;
      *(float *)&unint64_t v347 = v198 + *((float *)&v347 + 1);
    }
    if (v196 <= 0.0)
    {
      float v199 = v195 * (float)(LODWORD(__dst[1]) + 1);
      *((float *)&v350 + 1) = *(float *)&v350 + v199;
      *((float *)&v347 + 1) = *(float *)&v347 + v199;
    }
    unint64_t v201 = *v137;
    unint64_t v200 = v137[1];
    sub_1DC3F02E0(v201, v200, (float *)&v336, 2u, (float *)&v350, &v345, &v343);
    float v203 = v345;
    float v202 = v346;
    float v204 = v343;
    float v205 = v344;
    sub_1DC3F02E0(v201, v200, (float *)&v332, 2u, (float *)&v347, &v345, &v343);
    float v206 = (float)(17 * v197 + 17);
    float v207 = 35.0 / v206;
    float v208 = -17.0 / v206;
    float v209 = v203 + (float)(v208 * (float)(v202 - v203));
    float v210 = v204 + (float)(v208 * (float)(v205 - v204));
    float v211 = v202 + (float)(v207 * (float)(v202 - v203));
    float v212 = v205 + (float)(v207 * (float)(v205 - v204));
    float v213 = v345 + (float)(v208 * (float)(v346 - v345));
    float v214 = v343 + (float)(v208 * (float)(v344 - v343));
    float v215 = v346 + (float)(v207 * (float)(v346 - v345));
    float v216 = v344 + (float)(v207 * (float)(v344 - v343));
    float v217 = (float)(int)(float)((float)(v271 - v134) + 1.0);
    float v218 = (float)(int)(float)((float)SHIDWORD(__dst[0]) - v271) / v217;
    float v219 = (float)-(float)(int)(float)(v134 + -1.0) / v217;
    float v220 = v209 + (float)(v219 * (float)(v213 - v209));
    float v221 = v210 + (float)(v219 * (float)(v214 - v210));
    float v222 = v213 + (float)(v218 * (float)(v213 - v209));
    float v223 = v214 + (float)(v218 * (float)(v214 - v210));
    float v224 = v211 + (float)(v219 * (float)(v215 - v211));
    float v225 = v212 + (float)(v219 * (float)(v216 - v212));
    float v226 = v215 + (float)(v218 * (float)(v215 - v211));
    float v227 = v216 + (float)(v218 * (float)(v216 - v212));
    if (sub_1DC3EFD04(v312, v311, (float *)&v301, (float *)&v300, v220, v221, v224, v225, v222, v223, v226, v227) == 2)
    {
      uint64_t v36 = 22;
    }
    else
    {
      uint64_t v36 = 0;
      int v228 = llroundf(v220);
      int v229 = llroundf(v221);
      int v230 = llroundf(v222);
      int v231 = llroundf(v223);
      int v232 = llroundf(v226);
      int v233 = llroundf(v227);
      int v234 = llroundf(v224);
      int v235 = v201 - 1;
      int v236 = v200 - 1;
      if (v228 >= (int)v201 - 1) {
        int v237 = v201 - 1;
      }
      else {
        int v237 = v228;
      }
      if (v228 >= 0) {
        int v238 = v237;
      }
      else {
        int v238 = 0;
      }
      if (v229 >= v236) {
        int v239 = v200 - 1;
      }
      else {
        int v239 = v229;
      }
      BOOL v185 = v229 < 0;
      int v240 = llroundf(v225);
      if (v185) {
        int v239 = 0;
      }
      v268[7] = v238;
      v268[8] = v239;
      if (v230 >= v235) {
        int v241 = v201 - 1;
      }
      else {
        int v241 = v230;
      }
      if (v230 < 0) {
        int v241 = 0;
      }
      if (v231 >= v236) {
        int v242 = v200 - 1;
      }
      else {
        int v242 = v231;
      }
      if (v231 < 0) {
        int v242 = 0;
      }
      v268[9] = v241;
      v268[10] = v242;
      if (v232 >= v235) {
        int v243 = v201 - 1;
      }
      else {
        int v243 = v232;
      }
      if (v232 < 0) {
        int v243 = 0;
      }
      if (v233 >= v236) {
        int v244 = v200 - 1;
      }
      else {
        int v244 = v233;
      }
      if (v233 < 0) {
        int v244 = 0;
      }
      v268[11] = v243;
      v268[12] = v244;
      if (v234 >= v235) {
        int v245 = v201 - 1;
      }
      else {
        int v245 = v234;
      }
      if (v234 < 0) {
        int v245 = 0;
      }
      if (v240 >= v236) {
        int v246 = v200 - 1;
      }
      else {
        int v246 = v240;
      }
      if (v240 >= 0) {
        int v247 = v246;
      }
      else {
        int v247 = 0;
      }
      v268[13] = v245;
      v268[14] = v247;
    }
  }
LABEL_281:
  sub_1DC3E32C4(__dst);
  return v36;
}

uint64_t sub_1DC3E718C(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)a1) {
    BOOL v4 = v3 < 3;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_16;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  BOOL v7 = v3 > 90 || v6 < 1;
  BOOL v8 = !v7 && v6 <= 30;
  if (!v8
    || (unsigned int v9 = *(_DWORD *)(a1 + 12), v9 > 8)
    || (v10 = v6 * v3, v11 = *(_DWORD *)(a1 + 236), v12 = __OFSUB__(v10, v11), int v13 = v10 - v11, (v13 < 0) ^ v12))
  {
LABEL_16:
    *(_DWORD *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    return 6;
  }
  *(_DWORD *)(a2 + 24) = 0;
  unsigned int v16 = 2 << v9;
  unsigned int v17 = v10 - (2 << v9);
  int v18 = (2 << v9) - 2;
  if (v13 > v18 || (int)v17 < 1) {
    return 6;
  }
  *(void *)(a2 + 8) = 2 * v10;
  float v20 = *(void **)(a2 + 16);
  if (v20)
  {
    free(v20);
    *(void *)(a2 + 16) = 0;
  }
  size_t v21 = v10;
  int v22 = (char *)malloc_type_calloc(v10, 2uLL, 0x1000040BDFB0063uLL);
  int v23 = malloc_type_calloc(v21, 2uLL, 0x1000040BDFB0063uLL);
  uint64_t v24 = (unsigned int *)malloc_type_calloc(v21, 4uLL, 0x100004052888210uLL);
  int v25 = v24;
  if (!v22 || !v23 || !v24)
  {
    if (v23) {
      free(v23);
    }
    *(_DWORD *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    uint64_t v14 = 15;
    if (!v22) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  int v26 = *(_DWORD *)(a1 + 4);
  if (v26 < 1)
  {
    signed int v29 = 0;
  }
  else
  {
    unsigned int v27 = 0;
    int v28 = 0;
    signed int v29 = 0;
    int v30 = *(_DWORD *)(a1 + 8);
    __float2 v31 = v22;
    do
    {
      if (v30 >= 1)
      {
        int v32 = 0;
        __float2 v33 = (float *)(*(void *)(a1 + 696) + 4 * v27);
        int v34 = (__int16 *)(*(void *)(a1 + 704) + 2 * v27);
        do
        {
          __int16 v35 = *v34++;
          *(_WORD *)__float2 v31 = v35;
          v31 += 2;
          if (*v33 < 0.9)
          {
            v24[v29++] = v32 + v28 * v30;
            int v30 = *(_DWORD *)(a1 + 8);
          }
          ++v32;
          ++v33;
        }
        while (v32 < v30);
        int v26 = *(_DWORD *)(a1 + 4);
      }
      ++v28;
      v27 += 30;
    }
    while (v28 < v26);
  }
  int v37 = 0;
  if (sub_1DC3C6864(qword_1EAA94E88, v22, v17, &v22[2 * v17], v16, v24, v29, &v37, v23, &v23[v17])) {
    goto LABEL_44;
  }
  int v36 = v37 - v29;
  if (v37 - v29 > 3 || *(int *)(a1 + 12) < 1)
  {
    if (v29 + 2 * v36 <= v18)
    {
LABEL_53:
      uint64_t v14 = 0;
      *(_DWORD *)(a2 + 24) = 1065353216;
      *(void *)(a2 + 16) = v23;
      *(void *)(a2 + 80) = *(void *)(a1 + 4);
      goto LABEL_45;
    }
  }
  else if (v29 + 2 * v36 <= (int)(v16 - 3))
  {
    goto LABEL_53;
  }
LABEL_44:
  free(v23);
  *(void *)(a2 + 8) = 0;
  uint64_t v14 = 5;
LABEL_45:
  free(v22);
LABEL_46:
  if (v25) {
    free(v25);
  }
  return v14;
}

uint64_t sub_1DC3E7450(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, _DWORD *a6, int *a7, _DWORD *a8, float a9, float a10, float a11, float a12)
{
  uint64_t v151 = *MEMORY[0x1E4F143B8];
  float v22 = a12 * 0.5;
  __float2 v23 = __sincosf_stret(a11);
  uint64_t v24 = *(void *)(a5 + 80);
  uint64_t result = sub_1DC3ED600(a1, 0, (void *)a5, a9 - (float)(v23.__cosval * v22), a10 - (float)(v23.__sinval * v22), (float)(v23.__cosval * v22) + a9, (float)(v23.__sinval * v22) + a10);
  if (result) {
    return result;
  }
  char v135 = a8;
  if (*a6)
  {
    float v26 = (float)((float)*(int *)(a4 + 40) + (float)((float)(8 * a6[2] + 34) * 1.5)) + (float)*(int *)(a4 + 44);
  }
  else if (*(unsigned char *)(a4 + 30))
  {
    float v26 = 288.0;
  }
  else
  {
    float v26 = 1000.0;
  }
  long long v145 = 0u;
  long long v146 = 0u;
  long long v143 = 0u;
  long long v144 = 0u;
  int v27 = sub_1DC3A0718((uint64_t)&v143, *(float **)a5, *(_DWORD *)(a5 + 8), 0.5);
  if (!v27 || (int v28 = v27, v27 > (int)v26))
  {
    sub_1DC3A0B9C((uint64_t)&v143);
    return 2;
  }
  uint64_t v140 = v24 + 72;
  float v29 = *(float *)(a4 + 32);
  uint64_t v133 = *(unsigned int *)(a4 + 40);
  if (a2 >= 90) {
    int v30 = 90;
  }
  else {
    int v30 = a2;
  }
  if (v30 <= 1) {
    int v30 = 1;
  }
  if (a3 >= 90) {
    int v31 = 90;
  }
  else {
    int v31 = a3;
  }
  if (v31 <= 1) {
    int v32 = 1;
  }
  else {
    int v32 = v31;
  }
  float v125 = a7;
  if (*a6 && v32 >= a6[1]) {
    int v32 = a6[1];
  }
  __float2 v33 = a8;
  char v34 = 0;
  uint64_t v138 = v24;
  int v136 = (int *)(v24 + 56);
  float v35 = *(float *)(a4 + 36);
  float v36 = *(float *)(a4 + 48);
  float v37 = *(float *)(a4 + 52);
  int v132 = *(_DWORD *)(a4 + 44);
  signed int v114 = v32;
  int v115 = v30;
  if (v32 - v30 <= 1) {
    int v38 = 1;
  }
  else {
    int v38 = 2;
  }
  float v39 = *(float *)(a4 + 24) * (float)v38;
  uint64_t v40 = a8 + 1;
  int v130 = a8 + 1;
  if (!a8) {
    uint64_t v40 = 0;
  }
  int v139 = v40;
  if (v29 <= 0.0) {
    int v41 = -4;
  }
  else {
    int v41 = 4;
  }
  int v112 = v41;
  float v134 = -1.0;
  int v129 = -1;
  char v42 = 1;
  int v128 = -1;
  float v43 = -1.0;
  int v44 = -1;
  int v137 = -1;
  uint64_t v45 = 0xFFFFFFFFLL;
  float v126 = a6;
  uint64_t v120 = a5;
  uint64_t v124 = a4;
  float v118 = *(float *)(a4 + 48);
  float v119 = *(float *)(a4 + 36);
  float v116 = v39;
  float v117 = *(float *)(a4 + 52);
  while (1)
  {
    char v46 = v34;
    if (v28 < 16) {
      goto LABEL_100;
    }
    unint64_t v47 = (float *)(*(void *)a5 + 4 * (int)(float)(*(float *)v144 + -0.5));
    LODWORD(v47) = *v47 <= v47[1];
    sub_1DC3DAAE8((int *)(v144 + 4 * v47), (v28 - v47) & 0xFFFFFFFE, (uint64_t)v136, v140);
    int v48 = *v136;
    BOOL v49 = v29 > 0.0 && (int)v45 <= 0;
    int v141 = *v136;
    if (!v49) {
      goto LABEL_60;
    }
    uint64_t v50 = v45;
    signed int v51 = v133;
    if ((v133 & 0x80000000) != 0 || (int)v133 >= v48)
    {
      int v52 = *(float **)(v138 + 64);
    }
    else
    {
      int v52 = *(float **)(v138 + 64);
      if (vabds_f32(v52[v133], v36) <= v39) {
        goto LABEL_44;
      }
    }
    signed int v51 = sub_1DC3E7F6C(*(void *)v136, v52, v36);
LABEL_44:
    sub_1DC3E3478((uint64_t)v136, v140, v51, v150, 0);
    float v43 = v53;
    if ((float)(vabds_f32(*(float *)(a4 + 32), v53) / *(float *)(a4 + 32)) >= 0.2) {
      goto LABEL_58;
    }
    float v142 = sub_1DC3E355C((uint64_t)v150, (uint64_t)&v147);
    if (v142 <= 0.9
      || ((unsigned int v54 = (v147.i32[0] + v148 - (v147.i32[1] + v149) + 9) % 9, v54 <= 6)
        ? (BOOL v55 = ((1 << v54) & 0x49) == 0)
        : (BOOL v55 = 1),
          v55))
    {
      int v128 = -1;
LABEL_58:
      uint64_t v45 = v50;
LABEL_59:
      int v48 = v141;
      goto LABEL_60;
    }
    int v128 = (v147.i32[0] + v148 - (v147.i32[1] + v149) + 9) % 9;
    unsigned int v56 = sub_1DC3E36F8(v54, &v147, &v142);
    if (v56 > 0x3A0 || v142 <= 0.9) {
      goto LABEL_58;
    }
    uint64_t v57 = sub_1DC3E37DC(v56, v128, 1, v115, v114, (uint64_t)a6);
    if ((int)v57 < 1)
    {
      uint64_t v45 = v57;
      goto LABEL_59;
    }
    *(_DWORD *)(a4 + 40) = v51;
    uint64_t v58 = *(void *)(v138 + 64);
    *(_DWORD *)(a4 + 48) = *(_DWORD *)(v58 + 4 * v51);
    int v48 = v141;
    if (v33 && *a6)
    {
      int v59 = (_DWORD *)(v58 + 4 * v51);
      *__float2 v33 = *v59;
      v33[1] = v59[4];
    }
    uint64_t v45 = v57;
LABEL_60:
    if (v35 <= 0.0 || v137 > 0) {
      goto LABEL_81;
    }
    uint64_t v60 = v45;
    int v61 = v48 - 1;
    signed int v62 = v48 - 1 - v132;
    if (v62 < 0 || v62 >= v48)
    {
      int v63 = *(float **)(v138 + 64);
    }
    else
    {
      int v63 = *(float **)(v138 + 64);
      if (vabds_f32(v63[v62], v37) <= v39) {
        goto LABEL_68;
      }
    }
    signed int v62 = sub_1DC3E7F6C(*(void *)v136, v63, v37);
LABEL_68:
    sub_1DC3E3478((uint64_t)v136, v140, v62, v150, 0);
    float v134 = v64;
    if ((float)(vabds_f32(*(float *)(a4 + 36), v64) / *(float *)(a4 + 36)) >= 0.2) {
      goto LABEL_90;
    }
    float v142 = sub_1DC3E355C((uint64_t)v150, (uint64_t)&v147);
    if (v142 <= 0.9
      || ((unsigned int v65 = (v147.i32[0] + v148 - (v147.i32[1] + v149) + 9) % 9, v65 <= 6)
        ? (BOOL v66 = ((1 << v65) & 0x49) == 0)
        : (BOOL v66 = 1),
          v66))
    {
      int v129 = -1;
LABEL_90:
      int v48 = v141;
      uint64_t v45 = v60;
      __float2 v33 = v135;
      if ((int)v60 <= 0) {
        goto LABEL_99;
      }
LABEL_91:
      int v44 = v45 - 1;
      goto LABEL_92;
    }
    int v129 = (v147.i32[0] + v148 - (v147.i32[1] + v149) + 9) % 9;
    unsigned int v67 = sub_1DC3E36F8(v65, &v147, &v142);
    if (v67 > 0x3A0) {
      goto LABEL_90;
    }
    if (v142 <= 0.9) {
      goto LABEL_90;
    }
    int v137 = sub_1DC3E37DC(v67, v129, 0, v115, v114, (uint64_t)a6);
    if (v137 < 1) {
      goto LABEL_90;
    }
    *(_DWORD *)(a4 + 44) = v61 - v62;
    uint64_t v68 = *(void *)(v138 + 64);
    *(_DWORD *)(a4 + 52) = *(_DWORD *)(v68 + 4 * v62);
    __float2 v33 = v135;
    int v48 = v141;
    if (v135 && *a6)
    {
      float v69 = (_DWORD *)(v68 + 4 * v62);
      int v70 = a6[2];
      v135[v70 + 1] = *v69;
      v135[v70 + 2] = v69[4];
    }
    uint64_t v45 = v60;
LABEL_81:
    int v44 = v45 - 1;
    if ((int)v45 < 1 || v137 < 1)
    {
      if ((int)v45 >= 1) {
        goto LABEL_91;
      }
      int v44 = v137 <= 0 ? -1 : v137 - 1;
    }
    else if (v45 == v137)
    {
      int v137 = v45;
    }
    else
    {
      int v72 = *v125;
      if (*v125 < 1)
      {
        uint64_t v45 = 0xFFFFFFFFLL;
        int v137 = -1;
        goto LABEL_99;
      }
      unsigned int v73 = v45 - v72;
      if ((int)v45 - v72 < 0) {
        unsigned int v73 = v72 - v45;
      }
      int v74 = v137 - v72;
      if (v74 < 0) {
        int v74 = -v74;
      }
      int v75 = v73 >= v74 ? v137 : v45;
      int v44 = v75 - 1;
    }
LABEL_92:
    if (!*a6) {
      break;
    }
    if (v44 < 0 || v44 >= a6[1]) {
      goto LABEL_99;
    }
    unsigned int v131 = v45;
    if (v29 <= 0.0)
    {
      uint64_t v71 = (v48 + ~*(_DWORD *)(a4 + 44) - 4);
      if ((v71 & 0x80000000) != 0) {
        goto LABEL_189;
      }
    }
    else
    {
      uint64_t v71 = (*(_DWORD *)(a4 + 40) + 4);
      if ((v71 & 0x80000000) != 0) {
        goto LABEL_189;
      }
    }
    if ((int)v71 + 4 >= v48)
    {
LABEL_189:
      uint64_t v45 = v131;
      goto LABEL_100;
    }
    int v76 = v129;
    if (v44 + 1 == v131) {
      int v76 = v128;
    }
    int v77 = v76 - 3;
    if (!v76) {
      int v77 = 6;
    }
    int v121 = v77;
    if (v76 == 6) {
      int v78 = 0;
    }
    else {
      int v78 = v76 + 3;
    }
    int v113 = v78;
    if (v29 <= 0.0) {
      float v79 = v134;
    }
    else {
      float v79 = v43;
    }
    int v122 = a6[2];
    char v123 = v46;
    int v80 = v122 - 1;
    if (v122 >= 1)
    {
      int v81 = 0;
      int v82 = 0;
      int v127 = 0;
      float v83 = *(float *)(v124 + 24) * 1.5;
      while (1)
      {
        int v84 = v82;
        if (v29 <= 0.0) {
          int v85 = v80;
        }
        else {
          int v85 = v81;
        }
        int v82 = 14;
        if (!v84 && (v71 & 0x80000000) == 0 && (int)v71 + 4 < v48)
        {
          uint64_t v86 = *(void *)(v138 + 64);
          float v87 = *(float *)(v86 + 4 * v71);
          float v88 = *(float *)(v86 + 4 * (v71 + 4));
          if (v33)
          {
            float v89 = *(float *)&v130[v85];
            BOOL v49 = v89 <= 0.0;
            float v90 = vabds_f32(v87, v89);
            BOOL v91 = v49 || v90 <= v83;
            if (!v91
              || ((v92 = *(float *)&v130[v85 + 1], BOOL v49 = v92 <= 0.0, v93 = vabds_f32(v88, v92), !v49)
                ? (BOOL v94 = v93 <= v83)
                : (BOOL v94 = 1),
                  !v94))
            {
              int v82 = 7;
              goto LABEL_148;
            }
          }
          if ((float)(vabds_f32(v79, v88 - v87) / v79) < 0.2) {
            int v82 = 1;
          }
          else {
            int v82 = 14;
          }
        }
        if (!v33) {
          goto LABEL_159;
        }
LABEL_148:
        if (v82 == 1)
        {
LABEL_159:
          uint64_t v99 = v71;
          if (v82 == 1)
          {
LABEL_160:
            sub_1DC3E3478((uint64_t)v136, v140, v99, v150, 0);
            float v142 = sub_1DC3E355C((uint64_t)v150, (uint64_t)&v147);
            if (v142 <= 0.9)
            {
              int v82 = 1;
              goto LABEL_174;
            }
            unsigned int v101 = (v147.i32[0] + v148 - (v147.i32[1] + v149) + 9) % 9;
            if (v101 > 6 || ((1 << v101) & 0x49) == 0)
            {
              int v82 = 1;
            }
            else
            {
              unsigned int v103 = sub_1DC3E36F8(v101, &v147, &v142);
              int v82 = 1;
              if (v103 <= 0x3A0)
              {
                float v104 = v142;
                if (v142 > 0.9)
                {
                  unsigned int v105 = v85 + 30 * v44;
                  if (v101 == v121)
                  {
                    __float2 v33 = v135;
                    uint64_t v106 = v138;
                    float v107 = v130;
                    if (v44)
                    {
                      v105 -= 30;
LABEL_181:
                      if ((v105 & 0x80000000) == 0)
                      {
                        uint64_t v108 = *((void *)v126 + 87);
                        float v109 = *(float *)(v108 + 4 * v105);
                        if (v109 <= 0.9) {
                          ++v126[59];
                        }
                        if (v104 > v109)
                        {
                          *(_WORD *)(*((void *)v126 + 88) + 2 * v105) = v103;
                          *(float *)(v108 + 4 * v105) = v104;
                        }
                        if (v33)
                        {
                          float v110 = (_DWORD *)(*(void *)(v106 + 64) + 4 * (int)v99);
                          int v111 = &v107[v85];
                          _DWORD *v111 = *v110;
                          v111[1] = v110[4];
                        }
                        int v82 = 0;
                        ++v127;
                        uint64_t v99 = (v99 + v112);
                      }
                    }
                  }
                  else
                  {
                    BOOL v55 = v101 == v113;
                    __float2 v33 = v135;
                    uint64_t v106 = v138;
                    float v107 = v130;
                    if (!v55) {
                      goto LABEL_181;
                    }
                    if (v44 <= 0x58)
                    {
                      v105 += 30;
                      goto LABEL_181;
                    }
                  }
LABEL_174:
                  int v48 = v141;
                  goto LABEL_175;
                }
              }
            }
LABEL_173:
            __float2 v33 = v135;
            goto LABEL_174;
          }
          goto LABEL_156;
        }
        float v95 = *(float *)&v139[v85];
        if (v95 > 0.0)
        {
          float v96 = *(float *)&v139[v85 + 1];
          if (v96 > 0.0)
          {
            int v97 = *(float **)(v138 + 64);
            uint64_t v98 = sub_1DC3E7F6C(*(void *)(v138 + 56), v97, *(float *)&v139[v85]);
            if (v98 == v71)
            {
              uint64_t v99 = v71;
              goto LABEL_173;
            }
            uint64_t v99 = v98;
            int v48 = v141;
            if ((v98 & 0x80000000) != 0 || (int)v98 + 4 >= v141 || vabds_f32(v97[v98], v95) >= v83)
            {
              uint64_t v99 = v71;
              __float2 v33 = v135;
              goto LABEL_175;
            }
            float v100 = vabds_f32(v97[(v98 + 4)], v96);
            __float2 v33 = v135;
            if (v100 < v83) {
              goto LABEL_160;
            }
          }
        }
LABEL_156:
        uint64_t v99 = v71;
LABEL_175:
        ++v81;
        --v80;
        uint64_t v71 = v99;
        if (v80 == -1) {
          goto LABEL_192;
        }
      }
    }
    int v127 = 0;
LABEL_192:
    char v46 = v123;
    a6 = v126;
    a5 = v120;
    a4 = v124;
    float v36 = v118;
    float v35 = v119;
    float v39 = v116;
    float v37 = v117;
    uint64_t v45 = v131;
    if (v127 == v122)
    {
LABEL_196:
      sub_1DC3A0B9C((uint64_t)&v143);
      if ((v44 & 0x80000000) == 0) {
        goto LABEL_197;
      }
      return 13;
    }
LABEL_100:
    if ((v42 & 1) == 0 || (int v28 = sub_1DC3A0948((uint64_t)&v143, *(float *)(a4 + 24)), v28 <= (int)v26))
    {
      char v42 = 0;
      char v34 = 1;
      if ((v46 & 1) == 0) {
        continue;
      }
    }
    goto LABEL_196;
  }
  if (v44 < 0)
  {
LABEL_99:
    int v44 = -1;
    goto LABEL_100;
  }
  sub_1DC3A0B9C((uint64_t)&v143);
LABEL_197:
  uint64_t result = 0;
  *float v125 = v44 + 1;
  return result;
}

uint64_t sub_1DC3E7F6C(int a1, float *a2, float a3)
{
  uint64_t result = (a1 - 1);
  if ((float)((float)(*a2 + a2[(int)result]) * 0.5) <= a3)
  {
    if (a1 < 1) {
      return 0;
    }
    uint64_t v5 = result;
    while (1)
    {
      float v7 = a2[v5];
      if (v7 < a3) {
        break;
      }
      if (v5-- <= 0) {
        return 0;
      }
    }
    uint64_t result = (v5 + 1);
    if ((int)result >= a1) {
      return v5;
    }
    float v9 = a2[result] - a3;
    float v10 = a3 - v7;
  }
  else
  {
    if (a1 < 1) {
      return result;
    }
    uint64_t v5 = 0;
    while (1)
    {
      float v6 = a2[v5];
      if (v6 > a3) {
        break;
      }
      if (a1 == ++v5) {
        return result;
      }
    }
    if (!v5) {
      return v5;
    }
    uint64_t result = (v5 - 1);
    float v9 = a3 - a2[result];
    float v10 = v6 - a3;
  }
  if (v9 >= v10) {
    return v5;
  }
  return result;
}

void sub_1DC3E802C()
{
}

uint64_t sub_1DC3E8054(uint64_t result, char *a2, std::string::size_type a3, size_t *a4, const char *a5)
{
  unint64_t v5 = *(void *)(result + 8);
  if (v5 >= 4)
  {
    float v9 = *(unsigned __int16 **)(result + 16);
    unint64_t v10 = v5 >> 1;
    if (v10 >= *v9) {
      unint64_t v11 = *v9;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = sub_1DC3EE6F0((uint64_t)v9, 1uLL, v11, a2, a3, a4, a5);
    if (result)
    {
      size_t v12 = a3 - 1;
      if (a3 - 1 >= *a4) {
        size_t v12 = *a4;
      }
      a2[v12] = 0;
    }
    else
    {
      *a2 = 0;
      *a4 = 0;
    }
  }
  return result;
}

BOOL sub_1DC3E80E0(int a1, uint64_t a2, int a3)
{
  return a1 > 8 && a3 > 9;
}

BOOL sub_1DC3E80F0(uint64_t *a1, uint64_t *a2)
{
  if (*a1)
  {
    int v74 = sub_1DC34D67C();
    sub_1DC314778((uint64_t)v72, *a1 + 24);
    uint64_t v5 = *(void *)(v73 + 16);
    uint64_t v4 = *(void *)(v73 + 24);
    unint64_t v6 = v4 - v5 - 1;
    BOOL v7 = v6 < 0xB8C;
    if (v6 >= 0xB8C)
    {
LABEL_92:
      sub_1DC311968(v72);
      sub_1DC3073A4((atomic_ullong *)&v74);
      return v7;
    }
    CFMutableStringRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4 - v5);
    float v9 = Mutable;
    if (Mutable)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      CFDataSetLength(v9, v4 - v5);
      if (v4 != v5)
      {
        uint64_t v11 = 0;
        do
        {
          MutableBytePtr[v11] = *(unsigned char *)(*(void *)(v73 + 16) + v11);
          ++v11;
        }
        while (v4 - v5 != v11);
      }
      int v75 = (void **)v9;
      size_t v12 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire)+ 24), atomic_exchange((atomic_ullong *volatile)&v75, 0));
      if (v12) {
        CFRelease(v12);
      }
      sub_1DC34D854((atomic_ullong *)&v75);
    }
    uint64_t v13 = *a1;
    uint64_t v70 = 0;
    uint64_t v71 = 0;
    uint64_t v69 = 0;
    sub_1DC2FFB5C((atomic_uint *)&v69, *(void *)(v13 + 48), *(void *)(v13 + 56), (uint64_t)(*(void *)(v13 + 56) - *(void *)(v13 + 48)) >> 3);
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire);
    int v15 = (void **)(explicit + 40);
    if (*(unsigned char *)(explicit + 64))
    {
      unsigned int v16 = *v15;
      if (*v15)
      {
        *(void *)(explicit + 48) = v16;
        operator delete(v16);
      }
    }
    *int v15 = 0;
    *(void *)(explicit + 48) = 0;
    *(void *)(explicit + 56) = 0;
    *(unsigned char *)(explicit + 64) = 1;
    if ((int)((unint64_t)(v70 - v69) >> 3) >= 1)
    {
      uint64_t v17 = 0;
      do
      {
        int v18 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire);
        double v19 = (*(float (**)(void))(**(void **)(v69 + 8 * v17) + 16))(*(void *)(v69 + 8 * v17));
        double v20 = (*(float (**)(void))(**(void **)(v69 + 8 * v17) + 24))(*(void *)(v69 + 8 * v17));
        float v22 = (double *)v18[6];
        unint64_t v21 = v18[7];
        if ((unint64_t)v22 >= v21)
        {
          uint64_t v24 = (double *)v18[5];
          uint64_t v25 = ((char *)v22 - (char *)v24) >> 4;
          unint64_t v26 = v25 + 1;
          if ((unint64_t)(v25 + 1) >> 60) {
            sub_1DC2FF97C();
          }
          uint64_t v27 = v21 - (void)v24;
          if (v27 >> 3 > v26) {
            unint64_t v26 = v27 >> 3;
          }
          if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v28 = v26;
          }
          if (v28)
          {
            unint64_t v28 = (unint64_t)sub_1DC300068(v28);
            uint64_t v24 = (double *)v18[5];
            float v22 = (double *)v18[6];
          }
          else
          {
            uint64_t v29 = 0;
          }
          int v30 = (double *)(v28 + 16 * v25);
          double *v30 = v19;
          v30[1] = v20;
          int v31 = v30;
          if (v22 != v24)
          {
            do
            {
              *((_OWORD *)v31 - 1) = *((_OWORD *)v22 - 1);
              v31 -= 2;
              v22 -= 2;
            }
            while (v22 != v24);
            uint64_t v24 = (double *)v18[5];
          }
          __float2 v23 = v30 + 2;
          v18[5] = v31;
          v18[6] = v30 + 2;
          v18[7] = v28 + 16 * v29;
          if (v24) {
            operator delete(v24);
          }
        }
        else
        {
          *float v22 = v19;
          v22[1] = v20;
          __float2 v23 = v22 + 2;
        }
        v18[6] = v23;
        ++v17;
        unint64_t v32 = (unint64_t)(v70 - v69) >> 3;
        if ((int)v32 >= 4) {
          LODWORD(v32) = 4;
        }
      }
      while (v17 < (int)v32);
    }
    unint64_t v33 = atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire);
    char v34 = (void **)(v33 + 72);
    if (*(unsigned char *)(v33 + 96))
    {
      float v35 = *v34;
      if (*v34)
      {
        *(void *)(v33 + 80) = v35;
        operator delete(v35);
      }
    }
    *char v34 = 0;
    *(void *)(v33 + 80) = 0;
    *(void *)(v33 + 88) = 0;
    *(unsigned char *)(v33 + 96) = 1;
    unint64_t v36 = (unint64_t)(v70 - v69) >> 3;
    if ((int)v36 >= 7) {
      LODWORD(v36) = 7;
    }
    if ((int)v36 >= 5)
    {
      uint64_t v37 = 4;
      do
      {
        int v38 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire);
        double v39 = (*(float (**)(void))(**(void **)(v69 + 8 * v37) + 16))(*(void *)(v69 + 8 * v37));
        double v40 = (*(float (**)(void))(**(void **)(v69 + 8 * v37) + 24))(*(void *)(v69 + 8 * v37));
        char v42 = (double *)v38[10];
        unint64_t v41 = v38[11];
        if ((unint64_t)v42 >= v41)
        {
          int v44 = (double *)v38[9];
          uint64_t v45 = ((char *)v42 - (char *)v44) >> 4;
          unint64_t v46 = v45 + 1;
          if ((unint64_t)(v45 + 1) >> 60) {
            sub_1DC2FF97C();
          }
          uint64_t v47 = v41 - (void)v44;
          if (v47 >> 3 > v46) {
            unint64_t v46 = v47 >> 3;
          }
          if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v48 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v48 = v46;
          }
          if (v48)
          {
            unint64_t v48 = (unint64_t)sub_1DC300068(v48);
            int v44 = (double *)v38[9];
            char v42 = (double *)v38[10];
          }
          else
          {
            uint64_t v49 = 0;
          }
          uint64_t v50 = (double *)(v48 + 16 * v45);
          *uint64_t v50 = v39;
          v50[1] = v40;
          signed int v51 = v50;
          if (v42 != v44)
          {
            do
            {
              *((_OWORD *)v51 - 1) = *((_OWORD *)v42 - 1);
              v51 -= 2;
              v42 -= 2;
            }
            while (v42 != v44);
            int v44 = (double *)v38[9];
          }
          float v43 = v50 + 2;
          v38[9] = v51;
          void v38[10] = v50 + 2;
          v38[11] = v48 + 16 * v49;
          if (v44) {
            operator delete(v44);
          }
        }
        else
        {
          *char v42 = v39;
          v42[1] = v40;
          float v43 = v42 + 2;
        }
        void v38[10] = v43;
        ++v37;
        unint64_t v52 = (unint64_t)(v70 - v69) >> 3;
        if ((int)v52 >= 7) {
          LODWORD(v52) = 7;
        }
      }
      while (v37 < (int)v52);
    }
    sub_1DC3D503C(atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire) + 112, (void *)(*a1 + 80));
    __int16 v53 = *(_DWORD *)sub_1DC3D527C(*(uint64_t **)(*a1 + 88)) != 0;
    *(_WORD *)(atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire) + 104) = v53 | 0x100;
    int v54 = *(_DWORD *)(*a1 + 72);
    if (v54 <= 9)
    {
      if (v54 == 1)
      {
        int v75 = (void **)CFRetain(@"QR");
        BOOL v55 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire)+ 16), atomic_exchange((atomic_ullong *volatile)&v75, 0));
        if (v55) {
          CFRelease(v55);
        }
        sub_1DC31FA90((atomic_ullong *)&v75);
        if ((**(unsigned char **)(v73 + 16) & 0xF0) != 0x50) {
          goto LABEL_79;
        }
      }
      else
      {
        int v75 = (void **)CFRetain(@"DataMatrix");
        uint64_t v57 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire)+ 16), atomic_exchange((atomic_ullong *volatile)&v75, 0));
        if (v57) {
          CFRelease(v57);
        }
        sub_1DC31FA90((atomic_ullong *)&v75);
        if (**(unsigned __int8 **)(v73 + 16) != 232) {
          goto LABEL_79;
        }
      }
      unint64_t v58 = atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire);
      if (*(unsigned char *)(v58 + 208)) {
        sub_1DC34D854((atomic_ullong *)(v58 + 200));
      }
      *(void *)(v58 + 200) = 0;
      *(_OWORD *)(v58 + 168) = 0u;
      *(_OWORD *)(v58 + 184) = 0u;
      *(unsigned char *)(v58 + 208) = 1;
      *(unsigned char *)(atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire) + 168) = 1;
LABEL_79:
      unint64_t v59 = atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire);
      *(_DWORD *)(v59 + 32) = 1065353216;
      *(unsigned char *)(v59 + 36) = 1;
      unint64_t v60 = a2[2];
      int v61 = (void *)a2[1];
      if ((unint64_t)v61 >= v60)
      {
        uint64_t v63 = ((uint64_t)v61 - *a2) >> 3;
        if ((unint64_t)(v63 + 1) >> 61) {
          sub_1DC2FF97C();
        }
        uint64_t v64 = v60 - *a2;
        uint64_t v65 = v64 >> 2;
        if (v64 >> 2 <= (unint64_t)(v63 + 1)) {
          uint64_t v65 = v63 + 1;
        }
        if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v66 = v65;
        }
        float v79 = a2 + 2;
        if (v66) {
          unint64_t v66 = (unint64_t)sub_1DC2FFD7C(v66);
        }
        else {
          uint64_t v67 = 0;
        }
        int v75 = (void **)v66;
        int v76 = (void *)(v66 + 8 * v63);
        int v77 = v76;
        unint64_t v78 = v66 + 8 * v67;
        *int v76 = atomic_exchange((atomic_ullong *volatile)&v74, 0);
        ++v77;
        sub_1DC34D7DC(a2, &v75);
        signed int v62 = (void *)a2[1];
        sub_1DC308428((uint64_t)&v75);
      }
      else
      {
        void *v61 = atomic_exchange((atomic_ullong *volatile)&v74, 0);
        signed int v62 = v61 + 1;
        a2[1] = (uint64_t)v62;
      }
      a2[1] = (uint64_t)v62;
      int v75 = (void **)&v69;
      sub_1DC2FFC48(&v75);
      goto LABEL_92;
    }
    if (v54 == 10)
    {
      int v75 = (void **)CFRetain(@"Aztec");
      unsigned int v56 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire)+ 16), atomic_exchange((atomic_ullong *volatile)&v75, 0));
      if (v56) {
        goto LABEL_77;
      }
    }
    else
    {
      int v75 = (void **)CFRetain(@"MicroQR");
      unsigned int v56 = (const void *)atomic_exchange((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire)+ 16), atomic_exchange((atomic_ullong *volatile)&v75, 0));
      if (v56) {
LABEL_77:
      }
        CFRelease(v56);
    }
    sub_1DC31FA90((atomic_ullong *)&v75);
    goto LABEL_79;
  }
  return 0;
}

void sub_1DC3E8818(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, atomic_ullong a16, atomic_ullong a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void **a22)
{
  a22 = (void **)&a10;
  sub_1DC2FFC48(&a22);
  sub_1DC311968(&a13);
  sub_1DC3073A4(&a16);
  _Unwind_Resume(a1);
}

void *sub_1DC3E88C0()
{
  return &unk_1F3664F68;
}

uint64_t sub_1DC3E88CC(uint64_t a1, uint64_t a2)
{
  if (sub_1DC307420(*(void *)(a2 + 8), (uint64_t)"ZNK3mrc7Decoder24decodeUsingZXing_V4_IIE_ERKNS0_4PassEE3$_0")) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

void sub_1DC3E8908(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)a2 + 8)) {
    BOOL v4 = *(unsigned char *)(a3 + 96) == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    sub_1DC3070F0(*(atomic_ullong **)(a1[1] + 40), a3);
    if (qword_1EBFFC3E0 != -1) {
      dispatch_once(&qword_1EBFFC3E0, &unk_1F3662428);
    }
    uint64_t v5 = qword_1EBFFC3E8;
    if (os_log_type_enabled((os_log_t)qword_1EBFFC3E8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1[1] + 40);
      if (*(unsigned char *)(v6 + 96))
      {
        sub_1DC390B4C((uint64_t)buf, v6);
      }
      else
      {
        long long v96 = 0u;
        *(void *)long long buf = -1;
        memset(&buf[8], 0, 24);
        long long v97 = 0u;
        long long v98 = 0u;
        long long v99 = 0u;
      }
      sub_1DC390F7C((CFErrorRef *)&v120, (uint64_t)buf);
      unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v120, memory_order_acquire);
      LODWORD(v100[0]) = 138543362;
      *(CFTypeRef *)((char *)v100 + 4) = explicit;
      char v34 = "Cannot retrieve or instantiate IIE model: %{public}@";
LABEL_77:
      _os_log_error_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_ERROR, v34, (uint8_t *)v100, 0xCu);
      sub_1DC306854((atomic_ullong *)&v120);
      sub_1DC390B00((atomic_ullong *)buf);
      return;
    }
    return;
  }
  uint64_t v7 = *a2;
  uint64_t v8 = a1[1];
  float v9 = *(void **)(v8 + 8);
  unint64_t v10 = (_OWORD *)a1[3];
  long long v11 = v10[1];
  *(_OWORD *)&v90.uintptr_t data = *v10;
  long long v91 = v11;
  uint64_t v12 = *(void *)(v8 + 40);
  if (qword_1EBFFC3E0 != -1) {
    dispatch_once(&qword_1EBFFC3E0, &unk_1F3662428);
  }
  uint64_t v5 = qword_1EBFFC3E8;
  v90.isa = (void *)os_signpost_id_generate((os_log_t)qword_1EBFFC3E8);
  LOBYTE(v90.info) = 1;
  if (*(unsigned char *)(v7 + 200)
    && *(unsigned char *)(v7 + 392)
    && *(unsigned char *)(v7 + 344)
    && atomic_load_explicit((atomic_ullong *volatile)(v7 + 400), memory_order_acquire))
  {
    v109[0] = &unk_1F365F398;
    float v110 = v109;
    v108[0] = &unk_1F365F3F0;
    v108[3] = v108;
    int v111 = &v90;
    sub_1DC31AD78((uint64_t)v112, (uint64_t)v108);
    if (LOBYTE(v111->info) && v110) {
      sub_1DC31AE10((uint64_t)v110, (uint64_t)v111->isa);
    }
    sub_1DC31AE60(v108);
    uint64_t v13 = sub_1DC31AE60(v109);
    if (*(unsigned char *)(v7 + 200)
      && *(unsigned char *)(v7 + 392)
      && *(unsigned char *)(v7 + 344)
      && (uint64_t v14 = (atomic_ullong *)*v9, atomic_load_explicit((atomic_ullong *volatile)(v7 + 400), memory_order_acquire))
      && sub_1DC3934C8((uint64_t)v13, v14))
    {
      int v15 = 0;
      unint64_t v16 = *v9 & 0xFFFFFFFFFFFFFF00;
      uint64_t v17 = *v9;
    }
    else
    {
      uint64_t v17 = 0;
      unint64_t v16 = 0;
      int v15 = 1;
    }
    if (qword_1EAA94CB0 != -1) {
      dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
    }
    uint64_t v27 = qword_1EAA94CA8;
    if (v15)
    {
      if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v9 - 2;
        _os_log_error_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_ERROR, "Unable to find any supported pixel buffer from MRCSample: %{public}@", buf, 0xCu);
      }
      *(void *)long long buf = -6007;
      v100[0] = @"Unable to find any supported pixel buffer from MRCSample.";
      sub_1DC306334((atomic_ullong *)v12, (uint64_t *)buf, v100);
LABEL_53:
      int v19 = 0;
      buf[0] = 0;
      BYTE8(v98) = 0;
      goto LABEL_159;
    }
    if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v69 = atomic_load_explicit((atomic_ullong *volatile)(v16 | v17), memory_order_acquire);
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v69;
      _os_log_debug_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_DEBUG, "Found best pixel buffer: %{public}@", buf, 0xCu);
    }
    long long v28 = v91;
    *(_OWORD *)(v7 + 352) = *(_OWORD *)&v90.data;
    *(_OWORD *)(v7 + 368) = v28;
    *(unsigned char *)(v7 + 384) = 1;
    if ((sub_1DC391D4C(v7 + 280, (atomic_ullong *)(v16 | v17), v12, &v90) & 1) == 0)
    {
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_INFO, "Failed to run image preprocessor.", buf, 2u);
      }
      goto LABEL_53;
    }
    uint64_t v29 = *(void *)(*(void *)(v7 + 208) + 8);
    int v30 = (const vImage_Buffer *)(v7 + 312);
    if (!*(unsigned char *)(v7 + 344)) {
      int v30 = 0;
    }
    vImage_Buffer src = v30;
    v100[0] = &unk_1F365E418;
    unsigned int v101 = v100;
    uint64_t v120 = (uint64_t *)&unk_1F365E470;
    v121[2] = &v120;
    *(void *)long long buf = &v90;
    sub_1DC31AD78((uint64_t)&buf[8], (uint64_t)&v120);
    uint64_t v87 = v7 + 280;
    if (*(unsigned char *)(*(void *)buf + 8) && v101) {
      sub_1DC31AE10((uint64_t)v101, **(void **)buf);
    }
    sub_1DC31AE60(&v120);
    sub_1DC31AE60(v100);
    sub_1DC3712B8((CVPixelBufferRef *)&v94, (atomic_ullong *)(v7 + 400), v12);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire))
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      unint64_t v36 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v119.data) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v36, OS_LOG_TYPE_ERROR, "Failed to create input pixel buffer from pixel buffer pool", (uint8_t *)&v119, 2u);
      }
      goto LABEL_101;
    }
    if (CVPixelBufferIsPlanar((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire)))
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      int v31 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v119.data) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v31, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", (uint8_t *)&v119, 2u);
      }
LABEL_100:
      v119.uintptr_t data = (void *)-2001;
      int v115 = @"Invalid input pixel buffer.";
      sub_1DC306334((atomic_ullong *)v12, (uint64_t *)&v119, (CFTypeRef *)&v115);
LABEL_101:
      unint64_t v92 = 0;
      goto LABEL_102;
    }
    vImagePixelCount Width = CVPixelBufferGetWidth((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire));
    vImagePixelCount Height = CVPixelBufferGetHeight((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire));
    OSType PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire));
    if (Width != *(void *)(v29 + 80)
      || Height != *(void *)(v29 + 72)
      || (OSType v39 = PixelFormatType, PixelFormatType != 1278226534) && PixelFormatType != 1278226536)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      int v44 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v119.data) = 0;
        _os_log_error_impl(&dword_1DC2FE000, v44, OS_LOG_TYPE_ERROR, "Invalid input pixel buffer", (uint8_t *)&v119, 2u);
      }
      goto LABEL_100;
    }
    double v40 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire);
    if (v40) {
      double v40 = (__CFString *)CFRetain(v40);
    }
    int v115 = v40;
    uint64_t v116 = v12;
    char v117 = sub_1DC36FB80((atomic_ullong *)&v115, 0, v12);
    if ((v117 & 1) == 0)
    {
      if (qword_1EBFFC3D0 != -1) {
        dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
      }
      int v72 = qword_1EBFFC3D8;
      if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
      {
        int v77 = *(_DWORD *)(v12 + 24);
        LODWORD(v119.data) = 67240192;
        HIDWORD(v119.data) = v77;
        _os_log_error_impl(&dword_1DC2FE000, v72, OS_LOG_TYPE_ERROR, "CVPixelBufferLockBaseAddress failed: %{public}d", (uint8_t *)&v119, 8u);
      }
      unint64_t v92 = 0;
      goto LABEL_213;
    }
    BaseAddress = CVPixelBufferGetBaseAddress((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire));
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire));
    v119.uintptr_t data = BaseAddress;
    v119.double height = Height;
    v119.double width = Width;
    v119.rowBytes = BytesPerRow;
    if (v39 == 1278226536)
    {
      vImage_Error v42 = vImageConvert_Planar8toPlanar16F(src, &v119, 0);
      if (v42)
      {
        if (qword_1EBFFC3D0 != -1) {
          dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
        }
        float v43 = qword_1EBFFC3D8;
        if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)signed int v114 = 134349056;
          *(void *)&v114[4] = v42;
          _os_log_error_impl(&dword_1DC2FE000, v43, OS_LOG_TYPE_ERROR, "vImageConvert_Planar8toPlanar16F failed: %{public}zd", v114, 0xCu);
        }
        *(void *)signed int v114 = -2005;
        float v93 = @"vImageConvert_Planar8toPlanar16F failed.";
        sub_1DC306334((atomic_ullong *)v12, (uint64_t *)v114, (CFTypeRef *)&v93);
LABEL_184:
        unint64_t v74 = 0;
        *(void *)(v12 + 32) = v42;
        *(unsigned char *)(v12 + 40) = 1;
LABEL_212:
        unint64_t v92 = v74;
LABEL_213:
        if (v117) {
          char v117 = sub_1DC36FD3C((atomic_ullong *)&v115, 0, v116) ^ 1;
        }
        sub_1DC307370((atomic_ullong *)&v115);
LABEL_102:
        sub_1DC307370((atomic_ullong *)&v94);
        if (*(unsigned char *)(*(void *)buf + 8) && (void)v96) {
          sub_1DC31AE10(v96, **(void **)buf);
        }
        sub_1DC31AE60(&buf[8]);
        if (atomic_load_explicit((atomic_ullong *volatile)&v92, memory_order_acquire))
        {
          uint64_t v45 = *(void *)(v7 + 208);
          IOSurfaceRef IOSurface = CVPixelBufferGetIOSurface((CVPixelBufferRef)atomic_load_explicit((atomic_ullong *volatile)&v92, memory_order_acquire));
          if (IOSurface) {
            IOSurfaceRef IOSurface = CFRetain(IOSurface);
          }
          *(void *)long long buf = IOSurface;
          char v47 = sub_1DC3166FC(v45, (atomic_ullong *)buf, v12);
          sub_1DC315BA8((atomic_ullong *)buf);
          if (v47)
          {
            if (sub_1DC31A58C(v7 + 72, (qos_class_t *)(v7 + 24), v12, (uint64_t)&v90))
            {
              uint64_t v48 = *(void *)(v7 + 248);
              *(_OWORD *)srca = *(_OWORD *)(v7 + 216);
              *(_OWORD *)uint64_t v86 = *(_OWORD *)(v7 + 232);
              v119.uintptr_t data = &unk_1F365E680;
              v119.rowBytes = (size_t)&v119;
              int v115 = (__CFString *)&unk_1F365F868;
              float v118 = &v115;
              uint64_t v120 = (uint64_t *)&v90;
              sub_1DC31AD78((uint64_t)v121, (uint64_t)&v115);
              if (*((unsigned char *)v120 + 8) && v119.rowBytes) {
                sub_1DC31AE10(v119.rowBytes, *v120);
              }
              sub_1DC31AE60(&v115);
              sub_1DC31AE60(&v119);
              vImagePixelCount v49 = srca[1]->height;
              if (*(void *)(v49 + 64) == 4)
              {
                if (*(void *)(v49 + 48) == 4
                  && *(void *)(v49 + 56) == 1
                  && *(void *)(v49 + 120) / *(void *)(v49 + 32) == 1)
                {
                  uint64_t v50 = *(void *)(v86[0] + 8);
                  if (*(void *)(v50 + 48) == 4 && *(void *)(v50 + 56) == 1 && *(void *)(v50 + 64) == 4)
                  {
                    uint64_t v51 = *(void *)(v49 + 72);
                    if (*(void *)(v50 + 72) == v51)
                    {
                      uint64_t v52 = *(void *)(v49 + 80);
                      if (*(void *)(v50 + 80) == v52 && *(void *)(v50 + 120) / *(void *)(v50 + 32) == 1)
                      {
                        __int16 v53 = (void *)(v49 + 16);
                        int v54 = (void *)(v50 + 16);
                        int v55 = *(_DWORD *)(v50 + 16);
                        if (v55 == *(_DWORD *)(v49 + 16))
                        {
                          int v56 = *(_DWORD *)(v50 + 20);
                          if (v56 == *(_DWORD *)(v49 + 20))
                          {
                            uint64_t v57 = *(void *)(v86[1] + 8);
                            if (*(void *)(v57 + 48) == 4
                              && *(void *)(v57 + 56) == 1
                              && *(void *)(v57 + 64) == 4
                              && *(void *)(v57 + 72) == v51
                              && *(void *)(v57 + 80) == v52
                              && *(void *)(v57 + 120) / *(void *)(v57 + 32) == 1
                              && *(_DWORD *)(v57 + 16) == v55
                              && *(_DWORD *)(v57 + 20) == v56)
                            {
                              uint64_t v58 = *(void *)(v48 + 8);
                              if (*(void *)(v58 + 48) == 4
                                && *(void *)(v58 + 56) == 1
                                && *(void *)(v58 + 64) == 8
                                && *(void *)(v58 + 72) == 1
                                && *(void *)(v58 + 80) == 1
                                && *(void *)(v58 + 120) / *(void *)(v58 + 32) == 1
                                && *(_DWORD *)(v58 + 16) == v55
                                && *(_DWORD *)(v58 + 20) == v56)
                              {
                                vImagePixelCount v59 = srca[0]->height;
                                if (*(void *)(v59 + 48) == 4
                                  && *(void *)(v59 + 56) == 1
                                  && *(void *)(v59 + 120) / *(void *)(v59 + 32) == 1
                                  && *(_DWORD *)(v59 + 16) == v55
                                  && *(_DWORD *)(v59 + 20) == v56)
                                {
                                  buf[0] = 0;
                                  BYTE8(v98) = 0;
                                  if (v55 == 4)
                                  {
                                    unint64_t v60 = (void *)(v59 + 16);
                                    int v61 = (void *)(v57 + 16);
                                    p_rowBytes = (atomic_ullong *)&srca[0]->rowBytes;
                                    uint64_t v63 = (atomic_ullong *)&srca[1]->rowBytes;
                                    uint64_t v64 = (atomic_ullong *)(v86[0] + 24);
                                    uint64_t v65 = (atomic_ullong *)(v86[1] + 24);
                                    unint64_t v66 = (atomic_ullong *)(v48 + 24);
                                    if (v56 == 6)
                                    {
                                      BOOL v67 = sub_1DC394878((uint64_t)buf, v87, p_rowBytes, v63, v64, v65, v66, v60, v53, v54, v61, v58 + 16, v12);
                                      goto LABEL_242;
                                    }
                                    if (v56 == 3)
                                    {
                                      BOOL v67 = sub_1DC3935E8((uint64_t)buf, v87, p_rowBytes, v63, v64, v65, v66, v60, v53, v54, v61, v58 + 16, v12);
LABEL_242:
                                      if (v67)
                                      {
                                        *(_OWORD *)&v100[1] = *(_OWORD *)&buf[8];
                                        v100[0] = *(CFTypeRef *)buf;
                                        unsigned int v101 = *(CFTypeRef **)&buf[24];
                                        long long v102 = v96;
                                        uint64_t v103 = v97;
                                        *(void *)long long buf = 0;
                                        long long v96 = 0uLL;
                                        *(void *)&long long v97 = 0;
                                        char v104 = BYTE8(v97);
                                        char v106 = v98;
                                        char v82 = 1;
                                        int v105 = HIDWORD(v97);
LABEL_239:
                                        char v107 = v82;
                                        if (BYTE8(v98)) {
                                          sub_1DC3935A8((uint64_t)buf);
                                        }
LABEL_191:
                                        if (*((unsigned char *)v120 + 8) && v122) {
                                          sub_1DC31AE10(v122, *v120);
                                        }
                                        sub_1DC31AE60(v121);
                                        if (v107)
                                        {
                                          if (sub_1DC31B2C0(*(void *)(v7 + 104), v12))
                                          {
                                            if (sub_1DC316B30(*(void *)(v7 + 208), v12))
                                            {
                                              buf[0] = 0;
                                              BYTE8(v98) = 0;
                                              if (v107)
                                              {
                                                *(CFTypeRef *)long long buf = v100[0];
                                                *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)&v100[1];
                                                *(void *)&buf[24] = v101;
                                                long long v96 = v102;
                                                *(void *)&long long v97 = v103;
                                                v100[0] = 0;
                                                long long v102 = 0uLL;
                                                uint64_t v103 = 0;
                                                BYTE8(v97) = v104;
                                                HIDWORD(v97) = v105;
                                                LOBYTE(v98) = v106;
                                                int v19 = 1;
                                                BYTE8(v98) = 1;
                                                goto LABEL_207;
                                              }
                                              int v19 = 0;
LABEL_158:
                                              sub_1DC307370((atomic_ullong *)&v92);
LABEL_159:
                                              if (LOBYTE(v111->info) && v113) {
                                                sub_1DC31AE10(v113, (uint64_t)v111->isa);
                                              }
                                              sub_1DC31AE60(v112);
                                              goto LABEL_30;
                                            }
                                            if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
                                            {
                                              *(_WORD *)long long buf = 0;
                                              int v76 = "Failed to unbind input surface.";
                                              goto LABEL_205;
                                            }
LABEL_206:
                                            int v19 = 0;
                                            buf[0] = 0;
                                            BYTE8(v98) = 0;
LABEL_207:
                                            if (v107) {
                                              sub_1DC3935A8((uint64_t)v100);
                                            }
                                            goto LABEL_158;
                                          }
                                          if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO)) {
                                            goto LABEL_206;
                                          }
                                          *(_WORD *)long long buf = 0;
                                          int v76 = "Failed to reset network.";
                                        }
                                        else
                                        {
                                          if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO)) {
                                            goto LABEL_206;
                                          }
                                          *(_WORD *)long long buf = 0;
                                          int v76 = "Failed to run postprocessor.";
                                        }
LABEL_205:
                                        _os_log_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_INFO, v76, buf, 2u);
                                        goto LABEL_206;
                                      }
                                      if (qword_1EAA94CB0 != -1) {
                                        dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
                                      }
                                      float v83 = qword_1EAA94CA8;
                                      if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_INFO))
                                      {
                                        *(_WORD *)signed int v114 = 0;
                                        _os_log_impl(&dword_1DC2FE000, v83, OS_LOG_TYPE_INFO, "Failed to postprocess.", v114, 2u);
                                      }
LABEL_238:
                                      char v82 = 0;
                                      LOBYTE(v100[0]) = 0;
                                      goto LABEL_239;
                                    }
                                  }
                                  if (qword_1EAA94CB0 != -1) {
                                    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
                                  }
                                  int v81 = qword_1EAA94CA8;
                                  if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
                                  {
                                    *(_WORD *)signed int v114 = 0;
                                    _os_log_error_impl(&dword_1DC2FE000, v81, OS_LOG_TYPE_ERROR, "Unsupported output tensor data type", v114, 2u);
                                  }
                                  *(void *)signed int v114 = -2001;
                                  BOOL v94 = @"Unsupported output tensor data type.";
                                  sub_1DC306334((atomic_ullong *)v12, (uint64_t *)v114, (CFTypeRef *)&v94);
                                  goto LABEL_238;
                                }
                                if (qword_1EAA94CB0 != -1) {
                                  dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
                                }
                                int v80 = qword_1EAA94CA8;
                                if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
                                {
                                  *(_WORD *)long long buf = 0;
                                  _os_log_error_impl(&dword_1DC2FE000, v80, OS_LOG_TYPE_ERROR, "Unexpected output thresmap.", buf, 2u);
                                }
                                *(void *)long long buf = -6009;
                                *(void *)signed int v114 = @"Unexpected output thresmap.";
                                sub_1DC306334((atomic_ullong *)v12, (uint64_t *)buf, (CFTypeRef *)v114);
                              }
                              else
                              {
                                if (qword_1EAA94CB0 != -1) {
                                  dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
                                }
                                float v79 = qword_1EAA94CA8;
                                if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
                                {
                                  *(_WORD *)long long buf = 0;
                                  _os_log_error_impl(&dword_1DC2FE000, v79, OS_LOG_TYPE_ERROR, "Unexpected output attributes.", buf, 2u);
                                }
                                *(void *)long long buf = -6009;
                                *(void *)signed int v114 = @"Unexpected output attributes.";
                                sub_1DC306334((atomic_ullong *)v12, (uint64_t *)buf, (CFTypeRef *)v114);
                              }
                            }
                            else
                            {
                              if (qword_1EAA94CB0 != -1) {
                                dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
                              }
                              unint64_t v78 = qword_1EAA94CA8;
                              if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
                              {
                                *(_WORD *)long long buf = 0;
                                _os_log_error_impl(&dword_1DC2FE000, v78, OS_LOG_TYPE_ERROR, "Unexpected output offset_y.", buf, 2u);
                              }
                              *(void *)long long buf = -6009;
                              *(void *)signed int v114 = @"Unexpected output offset_y.";
                              sub_1DC306334((atomic_ullong *)v12, (uint64_t *)buf, (CFTypeRef *)v114);
                            }
                            LOBYTE(v100[0]) = 0;
                            char v107 = 0;
                            goto LABEL_191;
                          }
                        }
                      }
                    }
                  }
                  if (qword_1EAA94CB0 != -1) {
                    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
                  }
                  int v75 = qword_1EAA94CA8;
                  if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_error_impl(&dword_1DC2FE000, v75, OS_LOG_TYPE_ERROR, "Unexpected output offset_x.", buf, 2u);
                  }
                  *(void *)long long buf = -6009;
                  *(void *)signed int v114 = @"Unexpected output offset_x.";
                  sub_1DC306334((atomic_ullong *)v12, (uint64_t *)buf, (CFTypeRef *)v114);
                }
                else
                {
                  if (qword_1EAA94CB0 != -1) {
                    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
                  }
                  uint64_t v71 = qword_1EAA94CA8;
                  if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_error_impl(&dword_1DC2FE000, v71, OS_LOG_TYPE_ERROR, "Unexpected output heatmap.", buf, 2u);
                  }
                  *(void *)long long buf = -6009;
                  *(void *)signed int v114 = @"Unexpected output heatmap.";
                  sub_1DC306334((atomic_ullong *)v12, (uint64_t *)buf, (CFTypeRef *)v114);
                }
              }
              else
              {
                if (qword_1EAA94CB0 != -1) {
                  dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
                }
                uint64_t v70 = qword_1EAA94CA8;
                if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_error_impl(&dword_1DC2FE000, v70, OS_LOG_TYPE_ERROR, "Output heatmap buffer num of channels should be 4 for 4 corners.", buf, 2u);
                }
                *(void *)long long buf = -6009;
                *(void *)signed int v114 = @"Output heatmap buffer not equals to 4.";
                sub_1DC306334((atomic_ullong *)v12, (uint64_t *)buf, (CFTypeRef *)v114);
              }
              LOBYTE(v100[0]) = 0;
              char v107 = 0;
              goto LABEL_191;
            }
            if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)long long buf = 0;
              uint64_t v68 = "Failed to execute.";
              goto LABEL_156;
            }
LABEL_157:
            int v19 = 0;
            buf[0] = 0;
            BYTE8(v98) = 0;
            goto LABEL_158;
          }
          if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO)) {
            goto LABEL_157;
          }
          *(_WORD *)long long buf = 0;
          uint64_t v68 = "Failed to bind input surface.";
        }
        else
        {
          if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO)) {
            goto LABEL_157;
          }
          *(_WORD *)long long buf = 0;
          uint64_t v68 = "Failed to create input pixel buffer.";
        }
LABEL_156:
        _os_log_impl(&dword_1DC2FE000, v27, OS_LOG_TYPE_INFO, v68, buf, 2u);
        goto LABEL_157;
      }
      sub_1DC38F220((uint64_t *)&v119);
    }
    else
    {
      vImage_Error v42 = vImageConvert_Planar8toPlanarF(src, &v119, 255.0, 0.0, 0);
      if (v42)
      {
        if (qword_1EBFFC3D0 != -1) {
          dispatch_once(&qword_1EBFFC3D0, &unk_1F36624E8);
        }
        uint64_t v73 = qword_1EBFFC3D8;
        if (os_log_type_enabled((os_log_t)qword_1EBFFC3D8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)signed int v114 = 134349056;
          *(void *)&v114[4] = v42;
          _os_log_error_impl(&dword_1DC2FE000, v73, OS_LOG_TYPE_ERROR, "vImageConvert_Planar8toPlanarF failed: %{public}zd", v114, 0xCu);
        }
        *(void *)signed int v114 = -2005;
        float v93 = @"vImageConvert_Planar8toPlanarF failed.";
        sub_1DC306334((atomic_ullong *)v12, (uint64_t *)v114, (CFTypeRef *)&v93);
        goto LABEL_184;
      }
    }
    unint64_t v74 = atomic_exchange((atomic_ullong *volatile)&v94, 0);
    goto LABEL_212;
  }
  if (qword_1EAA94CB0 != -1) {
    dispatch_once(&qword_1EAA94CB0, &unk_1F3662528);
  }
  int v18 = qword_1EAA94CA8;
  if (os_log_type_enabled((os_log_t)qword_1EAA94CA8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_1DC2FE000, v18, OS_LOG_TYPE_ERROR, "IIEModel is not ready.", buf, 2u);
  }
  *(void *)long long buf = -6005;
  v100[0] = @"IIEModel is not ready.";
  sub_1DC306334((atomic_ullong *)v12, (uint64_t *)buf, v100);
  int v19 = 0;
  buf[0] = 0;
  BYTE8(v98) = 0;
LABEL_30:
  uint64_t v20 = a1[2];
  if (*(unsigned __int8 *)(v20 + 72) == v19)
  {
    if (*(unsigned char *)(v20 + 72))
    {
      uint64_t v21 = sub_1DC3935A8(v20);
      uint64_t v22 = *(void *)buf;
      *(void *)long long buf = 0;
      *(void *)uint64_t v21 = v22;
      *(_OWORD *)(v21 + 8) = *(_OWORD *)&buf[8];
      *(void *)(v21 + 24) = *(void *)&buf[24];
      *(_OWORD *)(v21 + 32) = v96;
      *(void *)(v21 + 48) = v97;
      long long v96 = 0uLL;
      *(void *)&long long v97 = 0;
      *(unsigned char *)(v21 + 56) = BYTE8(v97);
      *(_DWORD *)(v21 + 60) = HIDWORD(v97);
      *(unsigned char *)(v21 + 64) = v98;
      if (!v19) {
        goto LABEL_38;
      }
      goto LABEL_37;
    }
  }
  else
  {
    if (!*(unsigned char *)(v20 + 72))
    {
      uint64_t v26 = *(void *)buf;
      *(void *)long long buf = 0;
      *(void *)uint64_t v20 = v26;
      *(_OWORD *)(v20 + 8) = *(_OWORD *)&buf[8];
      *(void *)(v20 + 24) = *(void *)&buf[24];
      *(_OWORD *)(v20 + 32) = v96;
      *(void *)(v20 + 48) = v97;
      long long v96 = 0uLL;
      *(void *)&long long v97 = 0;
      *(unsigned char *)(v20 + 56) = BYTE8(v97);
      *(_DWORD *)(v20 + 60) = HIDWORD(v97);
      *(unsigned char *)(v20 + 64) = v98;
      *(unsigned char *)(v20 + 72) = 1;
      if (!v19) {
        goto LABEL_38;
      }
      goto LABEL_37;
    }
    *(unsigned char *)(sub_1DC3935A8(v20) + 72) = 0;
  }
  if (v19) {
LABEL_37:
  }
    sub_1DC3935A8((uint64_t)buf);
LABEL_38:
  uint64_t v23 = a1[2];
  if (*(unsigned char *)(v23 + 72) && !*(unsigned char *)(*(void *)(a1[1] + 40) + 96))
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      uint64_t v24 = (uint64_t)(*(void *)(v23 + 40) - *(void *)(v23 + 32)) >> 3;
      double v25 = *(float *)(v23 + 60);
      *(_DWORD *)long long buf = 134349312;
      *(void *)&uint8_t buf[4] = v24;
      *(_WORD *)&unsigned char buf[12] = 2050;
      *(double *)&buf[14] = v25;
      _os_log_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_INFO, "IIE inference yields %{public}zu key point(s), module size is %{public}f.", buf, 0x16u);
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    uint64_t v32 = *(void *)(a1[1] + 40);
    if (*(unsigned char *)(v32 + 96))
    {
      sub_1DC390B4C((uint64_t)buf, v32);
    }
    else
    {
      long long v96 = 0u;
      *(void *)long long buf = -1;
      memset(&buf[8], 0, 24);
      long long v97 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
    }
    sub_1DC390F7C((CFErrorRef *)&v120, (uint64_t)buf);
    float v35 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v120, memory_order_acquire);
    LODWORD(v100[0]) = 138543362;
    *(CFTypeRef *)((char *)v100 + 4) = v35;
    char v34 = "Cannot run IIE inference: %{public}@";
    goto LABEL_77;
  }
}

void sub_1DC3EA010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,atomic_ullong a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a42) {
    sub_1DC3935A8((uint64_t)&a33);
  }
  sub_1DC31AEE4((uint64_t **)(v64 - 144));
  sub_1DC307370(&a30);
  sub_1DC31AEE4(&a64);
  _Unwind_Resume(a1);
}

__n128 sub_1DC3EA1C8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3664F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_1DC3EA1F8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F3664F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_1DC3EA24C()
{
}

void sub_1DC3EA264(uint64_t a1, uint64_t a2)
{
  uint64_t v323 = *MEMORY[0x1E4F143B8];
  if (sub_1DC379140(*(atomic_ullong **)(a1 + 8))) {
    BOOL v4 = *(unsigned char *)(a2 + 32) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_15;
  }
  if (qword_1EBFFC3E0 != -1) {
    dispatch_once(&qword_1EBFFC3E0, &unk_1F3662428);
  }
  uint64_t v5 = qword_1EBFFC3E8;
  if (os_log_type_enabled((os_log_t)qword_1EBFFC3E8, OS_LOG_TYPE_INFO))
  {
    buf.i16[0] = 0;
    _os_log_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_INFO, "All prerequisites are met, will run IIE inference.", (uint8_t *)&buf, 2u);
  }
  uint64_t v6 = *(void *)(a2 + 8);
  if (CGRectIsEmpty(*(CGRect *)(v6 + 16))
    || CGRectIsInfinite(*(CGRect *)(v6 + 16))
    || CGRectIsNull(*(CGRect *)(v6 + 16)))
  {
    **(_WORD **)(a2 + 64) = 256;
    goto LABEL_13;
  }
  float v9 = *(_OWORD **)(a2 + 24);
  v326.origin.CGFloat x = sub_1DC326F34((uint64_t)v9, 0.1);
  long long v10 = v9[5];
  *(_OWORD *)&v247.a = v9[4];
  long long v11 = v9[6];
  *(_OWORD *)&v247.c = v10;
  *(_OWORD *)&v247.tCGFloat x = v11;
  CGRect v332 = CGRectApplyAffineTransform(v326, &v247);
  CGRect v327 = CGRectIntersection(*(CGRect *)(v6 + 16), v332);
  CGFloat x = v327.origin.x;
  CGFloat y = v327.origin.y;
  CGFloat width = v327.size.width;
  CGFloat height = v327.size.height;
  uint64_t v16 = **(void **)(a2 + 8);
  int v230 = sub_1DC383CD0((atomic_ullong *)v16);
  double v227 = CGRectGetWidth(*(CGRect *)(v16 + 8));
  double v17 = CGRectGetHeight(*(CGRect *)(v16 + 8));
  uint64_t v18 = *(void *)(v16 + 40);
  v328.origin.CGFloat x = x;
  v328.origin.CGFloat y = y;
  v328.size.CGFloat width = width;
  v328.size.CGFloat height = height;
  double MinX = CGRectGetMinX(v328);
  v329.origin.CGFloat x = x;
  v329.origin.CGFloat y = y;
  v329.size.CGFloat width = width;
  v329.size.CGFloat height = height;
  double MinY = CGRectGetMinY(v329);
  v330.origin.CGFloat x = x;
  v330.origin.CGFloat y = y;
  v330.size.CGFloat width = width;
  v330.size.CGFloat height = height;
  double MaxX = CGRectGetMaxX(v330);
  v331.origin.CGFloat x = x;
  v331.origin.CGFloat y = y;
  v331.size.CGFloat width = width;
  v331.size.CGFloat height = height;
  double MaxY = CGRectGetMaxY(v331);
  unint64_t v23 = (unint64_t)v227;
  unint64_t v24 = vcvtmd_s64_f64(MinX);
  uint64_t v25 = vcvtmd_s64_f64(MinY);
  int64_t v26 = vcvtpd_s64_f64(MaxX);
  int64_t v27 = vcvtpd_s64_f64(MaxY);
  if ((uint64_t)(unint64_t)v227 >= v26) {
    unint64_t v28 = v26;
  }
  else {
    unint64_t v28 = (unint64_t)v227;
  }
  if ((uint64_t)(unint64_t)v17 >= v27) {
    unint64_t v29 = v27;
  }
  else {
    unint64_t v29 = (unint64_t)v17;
  }
  uint64_t v30 = ((_BYTE)v24 + (_BYTE)v230) & 0xF;
  uint64_t v228 = v18;
  if ((v18 & 0xF) != 0) {
    uint64_t v30 = 0;
  }
  uint64_t v31 = (v24 - v30) & ~((uint64_t)(v24 - v30) >> 63);
  uint64_t v32 = v25 & ~(v25 >> 63);
  v246[0] = v31;
  v246[1] = v28;
  unint64_t v224 = v28;
  v246[2] = v32;
  v246[3] = v29;
  LOBYTE(v236) = 0;
  char v245 = 0;
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (explicit)
  {
    CFTypeID v34 = CFGetTypeID(explicit);
    if (qword_1EBFFB7E0 != -1) {
      dispatch_once_f(&qword_1EBFFB7E0, 0, (dispatch_function_t)sub_1DC30DEE4);
    }
    if (v34 != qword_1EBFFB818) {
      _os_assumes_log();
    }
  }
  long long v322 = 0;
  float v35 = operator new(0x20uLL);
  *float v35 = &unk_1F3664F08;
  v35[1] = a2;
  v35[2] = &v236;
  v35[3] = v246;
  long long v322 = v35;
  sub_1DC397E30((uint64_t)explicit + 16, v321);
  sub_1DC39860C(v321);
  uint64_t v37 = *(void *)(a2 + 40);
  if (*(unsigned char *)(v37 + 96) && *(void *)v37 != -6001)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      buf.i16[0] = 0;
      _os_log_error_impl(&dword_1DC2FE000, v5, OS_LOG_TYPE_ERROR, "Underlying errors occurred during inference, bail out immediately.", (uint8_t *)&buf, 2u);
    }
    goto LABEL_71;
  }
  if (!v245)
  {
    sub_1DC3EDF80(a1, a2);
    goto LABEL_268;
  }
  int v38 = v242;
  if (!v242) {
    goto LABEL_71;
  }
  int v39 = v242 & 0xFE;
  if (v39 == 4)
  {
    buf.i32[0] = 1;
    buf.i8[4] = 1;
    double v40 = *(atomic_ullong **)(a1 + 8);
    unint64_t v41 = @"Aztec";
  }
  else if (v39 == 2)
  {
    buf.i32[0] = 1;
    buf.i8[4] = 1;
    double v40 = *(atomic_ullong **)(a1 + 8);
    unint64_t v41 = @"DataMatrix";
  }
  else
  {
    if (v242 != 1) {
      goto LABEL_49;
    }
    buf.i32[0] = 1;
    buf.i8[4] = 1;
    double v40 = *(atomic_ullong **)(a1 + 8);
    unint64_t v41 = @"MicroQR";
  }
  if ((sub_1DC3778A8(v40, v41, (uint64_t)&buf) & 1) == 0)
  {
LABEL_71:
    **(_WORD **)(a2 + 64) = 256;
    goto LABEL_268;
  }
LABEL_49:
  v36.columns[0].i64[0] = COERCE_UNSIGNED_INT(1.0);
  v36.columns[1].i32[0] = 0;
  v36.columns[1].i32[1] = 1.0;
  double v42 = (double)(uint64_t)(v29 - v32);
  v36.columns[0].f32[2] = (float)v31;
  v36.columns[1].f32[2] = (float)v32;
  if ((double)(uint64_t)(v224 - v31) >= v42) {
    double v42 = (double)(uint64_t)(v224 - v31);
  }
  uint64_t v43 = v237;
  float v44 = v42;
  float v45 = (float)(int)v237 / v44;
  unint64_t v46 = v240;
  char v47 = v241;
  float v225 = v44;
  if (v240 != v241)
  {
    do
    {
      *unint64_t v46 = vmul_n_f32(*v46, v44);
      ++v46;
    }
    while (v46 != v47);
    uint64_t v43 = v237;
  }
  float v48 = v243;
  LODWORD(v49) = 0;
  *((float *)&v49 + 1) = v45;
  v36.columns[2] = (simd_float3)xmmword_1DC3FDDE0;
  buf.i8[0] = v244;
  buf.i64[1] = v23;
  unint64_t v299 = (unint64_t)v17;
  uint64_t v300 = v230;
  unint64_t v301 = v23;
  unint64_t v302 = (unint64_t)v17;
  uint64_t v303 = v228;
  uint64_t v304 = v236;
  uint64_t v305 = v238;
  uint64_t v306 = v43;
  uint64_t v307 = v239;
  simd_float3 v308 = v36.columns[0];
  simd_float3 v309 = v36.columns[1];
  long long v310 = xmmword_1DC3FDDE0;
  long long v311 = LODWORD(v45);
  long long v312 = v49;
  long long v313 = xmmword_1DC3FDDE0;
  float v320 = 0;
  int32x4_t v318 = 0u;
  int32x4_t v319 = 0u;
  long long v316 = 0u;
  int32x4_t v317 = 0u;
  long long v314 = 0u;
  long long v315 = 0u;
  simd_float3x3 v325 = __invert_f3(v36);
  uint64_t v50 = 0;
  v317.i32[2] = v325.columns[0].i32[2];
  v317.i64[0] = v325.columns[0].i64[0];
  v318.i32[2] = v325.columns[1].i32[2];
  v318.i64[0] = v325.columns[1].i64[0];
  v319.i32[2] = v325.columns[2].i32[2];
  v319.i64[0] = v325.columns[2].i64[0];
  float32x4_t v51 = (float32x4_t)v317;
  float32x4_t v52 = (float32x4_t)v318;
  float32x4_t v53 = (float32x4_t)v319;
  *(_OWORD *)std::string __p = v311;
  long long v251 = v312;
  long long v252 = v313;
  do
  {
    *(float32x4_t *)((char *)&p_buf + v50 * 8) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v51, COERCE_FLOAT(*(_OWORD *)&__p[v50])), v52, (float32x2_t)__p[v50], 1), v53, *(float32x4_t *)&__p[v50], 2);
    v50 += 2;
  }
  while (v50 != 6);
  float v54 = v48 * v225;
  DWORD2(v314) = v262;
  DWORD2(v315) = v264;
  *(void *)&long long v314 = p_buf;
  *(int32x2_t *)&long long v315 = v263;
  DWORD2(v316) = v266;
  *(void *)&long long v316 = v265;
  if (v39 != 4)
  {
    float32x2_t v82 = v240[1];
    float32x2_t v83 = vsub_f32(*v240, v82);
    float32x2_t v84 = v240[2];
    float32x2_t v85 = v240[3];
    float32x2_t v86 = vsub_f32(v84, v85);
    v83.f32[0] = sqrtf(vaddv_f32(vmul_f32(v83, v83))) + sqrtf(vaddv_f32(vmul_f32(v86, v86)));
    v86.f32[0] = v54 + v54;
    float v87 = v83.f32[0] / (float)(v54 + v54);
    float32x2_t v88 = vsub_f32(*v240, v85);
    float32x2_t v89 = vsub_f32(v82, v84);
    float v90 = (float)(sqrtf(vaddv_f32(vmul_f32(v89, v89))) + sqrtf(vaddv_f32(vmul_f32(v88, v88)))) / v86.f32[0];
    switch(v38)
    {
      case 1:
        long long v97 = &dword_1DC421C4C;
        uint64_t v98 = 4;
        break;
      case 2:
        long long v97 = &dword_1DC421C5C;
        uint64_t v98 = 24;
        break;
      case 3:
        long long v91 = 0;
        if (v90 < 54.4 && v87 < 22.4 && v87 > 5.4 && v90 > 15.4)
        {
          uint64_t v92 = 0;
          uint64_t v93 = 0;
          float v94 = 1.0;
          do
          {
            float v95 = (float)(vabds_f32((float)*(int *)&asc_1DC421C1C[4 * v92], v87)
                        + vabds_f32((float)dword_1DC421C34[v92], v90))
                / (float)(dword_1DC421C34[v92] + *(_DWORD *)&asc_1DC421C1C[4 * v92]);
            if (v95 < v94)
            {
              uint64_t v93 = v92;
              float v94 = v95;
            }
            ++v92;
          }
          while (v92 != 6);
          if (v94 <= 0.1)
          {
            long long v96 = sub_1DC2FFD7C(1uLL);
            *long long v96 = *(_DWORD *)&asc_1DC421C1C[4 * v93];
            v96[1] = dword_1DC421C34[v93];
            goto LABEL_295;
          }
          goto LABEL_100;
        }
LABEL_101:
        **(_WORD **)(a2 + 64) = 256;
        if (v91) {
          operator delete(v91);
        }
        goto LABEL_267;
      default:
LABEL_100:
        long long v91 = 0;
        goto LABEL_101;
    }
    int v99 = *v97;
    if (v90 >= v87) {
      float v100 = v87;
    }
    else {
      float v100 = v90;
    }
    if (v100 <= (float)((float)v99 - (float)((float)*v97 * 0.4))) {
      goto LABEL_100;
    }
    float v101 = (float)v97[v98 - 1];
    float v102 = v101 * 0.4;
    float v103 = v87 >= v90 ? v87 : v90;
    if (v103 >= (float)(v102 + v101)) {
      goto LABEL_100;
    }
    float v104 = (float)(v87 + v90) * 0.5;
    unint64_t v105 = (unint64_t)&v97[v98];
    uint64_t v106 = 4 * v98;
    uint64_t v107 = 4;
    uint64_t v108 = (unsigned int *)v97;
    do
    {
      if (vabds_f32((float)v97[(unint64_t)v107 / 4], v104) < vabds_f32((float)v99, v104))
      {
        int v99 = v97[(unint64_t)v107 / 4];
        uint64_t v108 = (unsigned int *)&v97[(unint64_t)v107 / 4];
      }
      v107 += 4;
    }
    while (v106 != v107);
    unsigned int v109 = *v108;
    if (vabds_f32((float)(int)*v108, v104) > v102) {
      goto LABEL_100;
    }
    int v139 = (int32x2_t *)sub_1DC2FFD7C(1uLL);
    int v141 = v139;
    float v142 = &v139[v140];
    *int v139 = vdup_n_s32(v109);
    long long v143 = v139 + 1;
    if (v97 < (int *)v108)
    {
      unsigned int v144 = *(v108 - 1);
      if (v140 < 2)
      {
        uint64_t v206 = 2;
        if ((unint64_t)((8 * v140) >> 2) > 2) {
          uint64_t v206 = (8 * v140) >> 2;
        }
        if ((unint64_t)(8 * v140) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v207 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v207 = v206;
        }
        float v208 = (int32x2_t *)sub_1DC2FFD7C(v207);
        uint64_t v209 = 0;
        float v142 = &v208[v210];
        v208[1] = vdup_n_s32(v144);
        long long v143 = v208 + 2;
        do
        {
          v208[v209] = v141[v209];
          --v209;
        }
        while (v209 != -1);
        long long v91 = v208;
        operator delete(v141);
LABEL_278:
        if ((unint64_t)(v108 + 1) < v105)
        {
          unsigned int v211 = v108[1];
          if (v143 >= v142)
          {
            uint64_t v212 = v143 - v91;
            unint64_t v213 = v212 + 1;
            if ((unint64_t)(v212 + 1) >> 61) {
              sub_1DC2FF97C();
            }
            float v214 = v143;
            if (((char *)v142 - (char *)v91) >> 2 > v213) {
              unint64_t v213 = ((char *)v142 - (char *)v91) >> 2;
            }
            if ((unint64_t)((char *)v142 - (char *)v91) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v215 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v215 = v213;
            }
            float v216 = (int32x2_t *)((char *)sub_1DC2FFD7C(v215) + 8 * v212);
            *float v216 = vdup_n_s32(v211);
            float v217 = v216 + 1;
            while (v214 != v91)
            {
              int32x2_t v218 = v214[-1];
              --v214;
              v216[-1] = v218;
              --v216;
            }
            operator delete(v91);
            long long v91 = v216;
            long long v143 = v217;
          }
          else
          {
            v143->i32[0] = v211;
            v143->i32[1] = v211;
            ++v143;
          }
        }
        if ((char *)v143 - (char *)v91 == 24)
        {
          int v219 = v91[2].i32[0];
          int v220 = v91[1].i32[0];
          if (vabds_f32((float)v219, v104) < vabds_f32((float)v220, v104))
          {
            __int32 v221 = v91[1].i32[1];
            __int32 v222 = v91[2].i32[1];
            v91[1].i32[0] = v219;
            v91[1].i32[1] = v222;
            v91[2].i32[0] = v220;
            v91[2].i32[1] = v221;
          }
        }
        if (v91 != v143) {
LABEL_295:
        }
          sub_1DC353CE0();
        goto LABEL_101;
      }
      v139[1].i32[0] = v144;
      v139[1].i32[1] = v144;
      long long v143 = v139 + 2;
    }
    long long v91 = v139;
    goto LABEL_278;
  }
  float v294 = v48 * v225;
  BOOL v293 = v38 == 5;
  int v235 = 0;
  int32x4_t v226 = (int32x4_t)v309;
  int32x4_t v229 = (int32x4_t)v310;
  int32x4_t v231 = (int32x4_t)v308;
  float v291 = 0;
  int32x2_t v290 = 0;
  uint64_t v292 = 0;
  sub_1DC3017D0(&v290, v240, (uint64_t)v241, v241 - v240);
  int v55 = v290;
  uint64_t v56 = (uint64_t)v291;
  if (v290 != v291)
  {
    float32x4_t v57 = (float32x4_t)vzip1q_s32(v231, v226);
    v57.i32[2] = v229.i32[0];
    float32x4_t v58 = (float32x4_t)vzip2q_s32(vzip1q_s32(v231, v229), vdupq_lane_s32(*(int32x2_t *)v226.i8, 1));
    float32x4_t v59 = (float32x4_t)vzip2q_s32(v231, v226);
    v59.i32[2] = v229.i32[2];
    unint64_t v60 = v290;
    do
    {
      int32x4_t v61 = (int32x4_t)vaddq_f32(v59, vmlaq_lane_f32(vmulq_n_f32(v57, COERCE_FLOAT(*v60)), v58, *v60, 1));
      *v60++ = vdiv_f32(*(float32x2_t *)v61.i8, (float32x2_t)vdup_laneq_s32(v61, 2));
    }
    while (v60 != (float32x2_t *)v56);
  }
  if (v38 == 5) {
    int v62 = 7;
  }
  else {
    int v62 = 11;
  }
  if (!sub_1DC3015FC(v55, v56, v62)) {
    goto LABEL_261;
  }
  *(float32x2_t *)v63.i8 = *v55;
  *(float32x2_t *)v64.i8 = v55[1];
  int32x4_t v67 = v63;
  v67.i32[2] = 1.0;
  *(float32x2_t *)v65.i8 = v55[2];
  *(float32x2_t *)v66.i8 = v55[3];
  int32x4_t v68 = v65;
  v68.i32[2] = 1.0;
  int32x4_t v69 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v68, v68), (int8x16_t)v68, 0xCuLL), vnegq_f32((float32x4_t)v67)), (float32x4_t)v68, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v67, v67), (int8x16_t)v67, 0xCuLL));
  int32x4_t v70 = v64;
  v70.i32[2] = 1.0;
  int32x4_t v71 = v66;
  v71.i32[2] = 1.0;
  int32x4_t v72 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v69, v69), (int8x16_t)v69, 0xCuLL);
  int32x4_t v73 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v71, v71), (int8x16_t)v71, 0xCuLL), vnegq_f32((float32x4_t)v70)), (float32x4_t)v71, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v70, v70), (int8x16_t)v70, 0xCuLL));
  int32x4_t v74 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v73, v73), (int8x16_t)v73, 0xCuLL);
  int8x16_t v75 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v74, v74), (int8x16_t)v74, 0xCuLL), vnegq_f32((float32x4_t)v72)), (float32x4_t)v74, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v72, v72), (int8x16_t)v72, 0xCuLL));
  v74.i32[0] = vextq_s8(v75, v75, 8uLL).u32[0];
  v74.i32[1] = v75.i32[0];
  float32x2_t v76 = vdiv_f32(*(float32x2_t *)v74.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v75.i8, 1));
  *(int32x2_t *)v77.f32 = vrev64_s32((int32x2_t)vmul_f32(vsub_f32(v76, *v55), vsub_f32(v76, *(float32x2_t *)v65.i8)));
  *(float32x2_t *)&v77.u32[2] = vmul_f32(vsub_f32(v76, *(float32x2_t *)v64.i8), vsub_f32(v76, *(float32x2_t *)v66.i8));
  if (vmaxv_u16((uint16x4_t)vmovn_s32(vcgezq_f32(v77))))
  {
LABEL_262:
    float v291 = v55;
    operator delete(v55);
    goto LABEL_263;
  }
  if (v293) {
    int v78 = 7;
  }
  else {
    int v78 = 11;
  }
  int v289 = v78;
  float v79 = v294;
  int32x2_t v80 = vcvt_s32_f32(v76);
  p_int32x4_t buf = &buf;
  float v262 = (unsigned int *)v80;
  uint64_t v264 = 1;
  int32x2_t v263 = 0;
  if (sub_1DC2FFEA4(&p_buf, *(double *)&v80))
  {
    if (!sub_1DC2FFF08((int32x2_t *)&p_buf, v79)) {
      goto LABEL_221;
    }
  }
  else
  {
    int v223 = v78;
    float v110 = 0;
    int v111 = 0;
    unint64_t v112 = 0;
    uint64_t v113 = 0;
    int v114 = (int)v79;
    do
    {
      if (v114 >= 1)
      {
        __int32 v115 = 0;
        int32x2_t v116 = qword_1DC40C2E0[v113];
        *(int32x2_t *)v81.i8 = v80;
        int32x4_t v232 = v81;
        while (1)
        {
          v117.i64[1] = v232.i64[1];
          *(int32x2_t *)v117.i8 = vadd_s32(*(int32x2_t *)v232.i8, v116);
          int32x4_t v232 = v117;
          if (sub_1DC3A8728(&buf, *(double *)v117.i64)) {
            break;
          }
          if (v114 == ++v115) {
            goto LABEL_126;
          }
        }
        int32x4_t v81 = v232;
        v81.i32[2] = v115;
        if ((unint64_t)v111 >= v112)
        {
          int32x4_t v233 = v81;
          uint64_t v118 = v111 - v110;
          unint64_t v119 = v118 + 1;
          if ((unint64_t)(v118 + 1) >> 60) {
            sub_1DC2FF97C();
          }
          if ((uint64_t)(v112 - (void)v110) >> 3 > v119) {
            unint64_t v119 = (uint64_t)(v112 - (void)v110) >> 3;
          }
          if (v112 - (unint64_t)v110 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v120 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v120 = v119;
          }
          if (v120) {
            unint64_t v120 = (unint64_t)sub_1DC300068(v120);
          }
          else {
            uint64_t v121 = 0;
          }
          uint64_t v122 = (int32x4_t *)(v120 + 16 * v118);
          v81.i64[1] = v233.i64[1];
          *uint64_t v122 = v233;
          uint64_t v123 = v122 + 1;
          while (v111 != v110)
          {
            int32x4_t v124 = v111[-1];
            --v111;
            v81.i64[1] = v124.i64[1];
            v122[-1] = v124;
            --v122;
          }
          unint64_t v112 = v120 + 16 * v121;
          if (v110) {
            operator delete(v110);
          }
          float v110 = v122;
          int v111 = v123;
        }
        else
        {
          *v111++ = v81;
        }
      }
LABEL_126:
      ++v113;
    }
    while (v113 != 8);
    unint64_t v125 = 126 - 2 * __clz(v111 - v110);
    if (v111 == v110) {
      uint64_t v126 = 0;
    }
    else {
      uint64_t v126 = v125;
    }
    sub_1DC3000A0((uint64_t)v110, v111, v126, 1);
    if (v111 == v110)
    {
      int v127 = 0;
      int v132 = 0;
    }
    else
    {
      int v127 = 0;
      int v128 = 0;
      unint64_t v129 = 0;
      int v130 = v110;
      do
      {
        uint64_t v131 = v130->i64[0];
        if ((unint64_t)v128 >= v129)
        {
          uint64_t v133 = (v128 - v127) >> 3;
          unint64_t v134 = v133 + 1;
          if ((unint64_t)(v133 + 1) >> 61) {
            sub_1DC2FF97C();
          }
          if ((uint64_t)(v129 - (void)v127) >> 2 > v134) {
            unint64_t v134 = (uint64_t)(v129 - (void)v127) >> 2;
          }
          if (v129 - (unint64_t)v127 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v135 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v135 = v134;
          }
          if (v135) {
            unint64_t v135 = (unint64_t)sub_1DC2FFD7C(v135);
          }
          else {
            uint64_t v136 = 0;
          }
          int v137 = (char *)(v135 + 8 * v133);
          *(void *)int v137 = v131;
          int v132 = v137 + 8;
          while (v128 != v127)
          {
            uint64_t v138 = *((void *)v128 - 1);
            v128 -= 8;
            *((void *)v137 - 1) = v138;
            v137 -= 8;
          }
          unint64_t v129 = v135 + 8 * v136;
          if (v127) {
            operator delete(v127);
          }
          int v127 = v137;
        }
        else
        {
          *(void *)int v128 = v131;
          int v132 = v128 + 8;
        }
        ++v130;
        int v128 = v132;
      }
      while (v130 != v111);
    }
    if (v110) {
      operator delete(v110);
    }
    if (v127 == v132)
    {
      BOOL v146 = 0;
    }
    else
    {
      long long v145 = v127 + 8;
      do
      {
        float v262 = (unsigned int *)*((void *)v145 - 1);
        BOOL v146 = sub_1DC2FFF08((int32x2_t *)&p_buf, v79);
        if (v146) {
          break;
        }
        BOOL v4 = v145 == v132;
        v145 += 8;
      }
      while (!v4);
    }
    if (v127) {
      operator delete(v127);
    }
    int v78 = v223;
    if (!v146)
    {
LABEL_221:
      int v154 = 0;
      v296 = 0;
      int32x2_t v295 = 0;
      uint64_t v297 = 0;
      goto LABEL_226;
    }
  }
  float v147 = v79 * (float)v78;
  int32x2_t v148 = (int32x2_t)v262;
  int32x2_t v263 = (int32x2_t)0x100000000;
  int v149 = (int)v147;
  if (sub_1DC300B80((int32x2_t *)&p_buf, (v78 + 1) >> 1, (int)v147, (int)(float)(v79 / 5.0), (int)(float)(v79 * 0.5)) == -1)goto LABEL_221; {
  int32x2_t v151 = (int32x2_t)v262;
  }
  v150.i32[0] = -v263.i32[1];
  int32x2_t v263 = vzip1_s32(v150, v263);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v251 = 0;
  sub_1DC300D68(__p, vcvts_n_u32_f32(v147, 2uLL));
  int v152 = 0;
  float v153 = v147 * 8.0;
  int v154 = (float32x2_t *)__p[1];
  unint64_t v155 = v251;
  int32x2_t v156 = v151;
  do
  {
    float32x2_t v157 = vadd_f32(vcvt_f32_s32(v156), (float32x2_t)0x3F0000003F000000);
    if ((unint64_t)v154 >= v155)
    {
      int8x8_t v158 = (float32x2_t *)__p[0];
      uint64_t v159 = ((char *)v154 - (char *)__p[0]) >> 3;
      unint64_t v160 = v159 + 1;
      if ((unint64_t)(v159 + 1) >> 61) {
        sub_1DC2FF97C();
      }
      if ((uint64_t)(v155 - (unint64_t)__p[0]) >> 2 > v160) {
        unint64_t v160 = (uint64_t)(v155 - (unint64_t)__p[0]) >> 2;
      }
      if (v155 - (unint64_t)__p[0] >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v161 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v161 = v160;
      }
      if (v161) {
        unint64_t v161 = (unint64_t)sub_1DC2FFD7C(v161);
      }
      else {
        uint64_t v162 = 0;
      }
      uint64_t v163 = (float32x2_t *)(v161 + 8 * v159);
      *uint64_t v163 = v157;
      int v164 = v163 + 1;
      if (v154 != v158)
      {
        do
        {
          float32x2_t v165 = v154[-1];
          --v154;
          v163[-1] = v165;
          --v163;
        }
        while (v154 != v158);
        int v154 = (float32x2_t *)__p[0];
      }
      unint64_t v155 = v161 + 8 * v162;
      __p[0] = v163;
      __p[1] = v164;
      *(void *)&long long v251 = v155;
      if (v154) {
        operator delete(v154);
      }
      int v154 = v164;
    }
    else
    {
      *v154++ = v157;
    }
    __p[1] = v154;
    int32x2_t v166 = (int32x2_t)v262;
    int32x2_t v167 = vsub_s32((int32x2_t)v262, v148);
    __int32 v168 = v167.i32[1];
    __int32 v169 = v167.i32[0];
    if (v167.i32[0] >= 0) {
      unsigned int v170 = v167.i32[0];
    }
    else {
      unsigned int v170 = -v167.i32[0];
    }
    if (v167.i32[1] >= 0) {
      unsigned int v171 = v167.u32[1];
    }
    else {
      unsigned int v171 = -v167.i32[1];
    }
    if (v170 <= v171) {
      signed int v172 = v171;
    }
    else {
      signed int v172 = v170;
    }
    v167.i32[0] = -v263.i32[1];
    int32x2_t v234 = v263;
    int32x2_t v173 = vzip1_s32(v167, v263);
    int32x2_t v174 = vneg_s32(v173);
    if (sub_1DC301990((uint64_t)&p_buf, v174) == -1)
    {
      int32x2_t v263 = v174;
    }
    else if (sub_1DC301990((uint64_t)&p_buf, v234) == -1)
    {
      int32x2_t v174 = v234;
    }
    else
    {
      int32x2_t v263 = v173;
      if (sub_1DC301990((uint64_t)&p_buf, v173) == -1)
      {
        int32x2_t v174 = v173;
      }
      else
      {
        v175.i32[1] = v234.i32[1];
        v175.i32[0] = -v234.i32[0];
        int32x2_t v174 = vzip1_s32(v175, v173);
        int32x2_t v263 = v174;
        if (sub_1DC301990((uint64_t)&p_buf, v174) != -1) {
          goto LABEL_222;
        }
      }
    }
    int32x2_t v156 = vadd_s32(v174, v166);
    float v262 = (unsigned int *)v156;
    if (v156.i32[0] < 0
      || *((void *)p_buf + 1) <= (unint64_t)v156.u32[0]
      || v156.i32[1] < 0
      || *((void *)p_buf + 2) <= (unint64_t)v156.u32[1])
    {
      goto LABEL_222;
    }
    int32x2_t v176 = vsub_s32(v156, v148);
    int v177 = v176.i32[1];
    unsigned int v178 = v176.i32[0];
    if (v176.i32[0] < 0) {
      unsigned int v178 = -v176.i32[0];
    }
    if (v176.i32[1] < 0) {
      int v177 = -v176.i32[1];
    }
    if (v178 > v177) {
      int v177 = v178;
    }
    if (v177 > v149
      || (uint32x2_t v179 = (uint32x2_t)vceq_s32(v156, v148), (vpmin_u32(v179, v179).u32[0] & 0x80000000) != 0)
      || (char v180 = __p[0], v153 < (float)(unint64_t)(((char *)v154 - (char *)__p[0]) >> 3)))
    {
LABEL_222:
      char v180 = __p[0];
      goto LABEL_223;
    }
    v152 |= 1 << (v169 / v172 + 3 * (v168 / v172) + 4);
    uint32x2_t v181 = (uint32x2_t)vceq_s32(v156, v151);
  }
  while ((vpmin_u32(v181, v181).u32[0] & 0x80000000) == 0);
  if (v152 != 495)
  {
LABEL_223:
    v296 = 0;
    int32x2_t v295 = 0;
    uint64_t v297 = 0;
    if (v180) {
      operator delete(v180);
    }
    int v154 = 0;
    goto LABEL_226;
  }
  int32x2_t v295 = __p[0];
  v296 = v154;
  uint64_t v297 = v251;
  if (__p[0] != v154) {
    sub_1DC300E10(&p_buf, (char **)&v295, vadd_f32(vcvt_f32_s32(v148), (float32x2_t)0x3F0000003F000000));
  }
LABEL_226:
  float v287 = 0;
  __vImage_Buffer src = 0;
  uint64_t v288 = 0;
  if (v154)
  {
    v296 = v154;
    operator delete(v154);
  }
  BOOL v285 = __src != v287;
  if (__src == v287 || (int v182 = (char *)__src + 8, (char *)__src + 8 == v287))
  {
    BOOL v185 = (char *)__src;
  }
  else
  {
    float32x2_t v183 = *v290;
    float32x2_t v184 = *(float32x2_t *)__src;
    BOOL v185 = (char *)__src;
    int v186 = (char *)__src + 8;
    do
    {
      float32x2_t v187 = *(float32x2_t *)v186;
      v186 += 8;
      int8x8_t v188 = (int8x8_t)v187;
      float32x2_t v189 = vsub_f32(v183, v187);
      int32x2_t v190 = (int32x2_t)vmul_f32(v189, v189);
      float32x2_t v191 = vsub_f32(v183, v184);
      int32x2_t v192 = (int32x2_t)vmul_f32(v191, v191);
      float32x2_t v193 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v190, v192), (float32x2_t)vzip2_s32(v190, v192)));
      unsigned __int8 v194 = vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v193, 1), v193).u8[0];
      if (v194) {
        unsigned int v195 = -1;
      }
      else {
        unsigned int v195 = 0;
      }
      float32x2_t v184 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v195), v188, (int8x8_t)v184);
      if (v194) {
        BOOL v185 = v182;
      }
      int v182 = v186;
    }
    while (v186 != v287);
  }
  sub_1DC301684((char *)__src, v185, v287);
  char v284 = 0;
  int v283 = 0;
  uint64_t v282 = 0;
  unsigned int v281 = 0;
  int v280 = &buf;
  char v279 = 0;
  v296 = 0;
  int32x2_t v295 = 0;
  uint64_t v297 = 0;
  sub_1DC3017D0(&v295, __src, (uint64_t)v287, (v287 - (unsigned char *)__src) >> 3);
  if (v285)
  {
    float v198 = (float32x2_t *)v295;
    float v199 = v296;
    if (v295 != v296)
    {
      float32x4_t v200 = (float32x4_t)vzip1q_s32(v317, v318);
      v200.i32[2] = v319.i32[0];
      float32x4_t v201 = (float32x4_t)vzip2q_s32(vzip1q_s32(v317, v319), vdupq_lane_s32(*(int32x2_t *)v318.i8, 1));
      float32x4_t v202 = (float32x4_t)vzip2q_s32(v317, v318);
      v202.i32[2] = v319.i32[2];
      do
      {
        int32x4_t v203 = (int32x4_t)vaddq_f32(v202, vmlaq_lane_f32(vmulq_n_f32(v200, COERCE_FLOAT(*v198)), v201, *v198, 1));
        *v198++ = vdiv_f32(*(float32x2_t *)v203.i8, (float32x2_t)vdup_laneq_s32(v203, 2));
      }
      while (v198 != v199);
    }
    sub_1DC3A82FC();
  }
  int v277 = 0;
  float v276 = 0;
  uint64_t v278 = 0;
  p_int32x4_t buf = &v279;
  float v262 = &v281;
  int32x2_t v263 = (int32x2_t)&buf;
  uint64_t v264 = (uint64_t)&v240;
  float v265 = &v280;
  float v266 = &v293;
  uint64_t v267 = &v284;
  float v268 = &v283;
  float v269 = (char *)&v282 + 4;
  float v270 = &v282;
  float v271 = &v294;
  int v272 = &v285;
  p_vImage_Buffer src = &__src;
  float v274 = &v289;
  int v275 = &v276;
  if (v279)
  {
    int v204 = 1;
  }
  else
  {
    int v204 = sub_1DC37BE48((uint64_t)&p_buf, v196, v197);
    char v279 = v204;
  }
  __p[0] = &v279;
  __p[1] = &v281;
  *(void *)&long long v251 = &v276;
  *((void *)&v251 + 1) = &v285;
  *(void *)&long long v252 = &v240;
  *((void *)&v252 + 1) = &v289;
  float v253 = &v295;
  float v254 = &buf;
  float v255 = &v280;
  float v256 = &v293;
  uint64_t v257 = &v284;
  unint64_t v258 = &v283;
  unint64_t v259 = (char *)&v282 + 4;
  int v260 = &v282;
  if (v204 || (int v205 = sub_1DC37C2AC((uint64_t)__p), v279 = v205, v205))
  {
    v249[1] = 0;
    if (v283) {
      operator new();
    }
    if (v284) {
      operator new();
    }
    uint64_t v248 = 0;
    sub_1DC37C96C((uint64_t)v249, (uint64_t)&buf, v293, v281, v282, HIDWORD(v282), 0);
  }
  if (v276)
  {
    int v277 = v276;
    operator delete(v276);
  }
  if (v295)
  {
    v296 = (float32x2_t *)v295;
    operator delete(v295);
  }
  if (__src)
  {
    float v287 = (char *)__src;
    operator delete(__src);
  }
  int v55 = v290;
LABEL_261:
  if (v55) {
    goto LABEL_262;
  }
LABEL_263:
  if (v235)
  {
    atomic_fetch_add_explicit(v235 + 2, 1u, memory_order_relaxed);
    p_int32x4_t buf = v235;
    **(_WORD **)(a2 + 64) = sub_1DC3E80F0((uint64_t *)&p_buf, *(uint64_t **)a2) | 0x100;
    sub_1DC311C00((atomic_uint **)&p_buf);
  }
  else
  {
    **(_WORD **)(a2 + 64) = 256;
  }
  sub_1DC311C00(&v235);
LABEL_267:
  sub_1DC30184C(&v320);
LABEL_268:
  if (v245) {
    sub_1DC3935A8((uint64_t)&v236);
  }
LABEL_13:
  uint64_t v7 = *(unsigned char **)(a2 + 64);
  if (!v7[1] || !*v7)
  {
LABEL_15:
    uint64_t v8 = *(atomic_ullong **)(a1 + 8);
    if (!sub_1DC379140(v8)
      || (buf.i8[0] = 0, buf.i8[4] = 0, (sub_1DC3778A8(v8, @"QR", (uint64_t)&buf) & 1) != 0)
      || !*(unsigned char *)(a2 + 32))
    {
      sub_1DC3EDF80(a1, a2);
    }
  }
}

void sub_1DC3EC0B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,atomic_uint *a28,__int16 a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  if (v38) {
    operator delete(v38);
  }
  if (STACK[0x2B8]) {
    operator delete((void *)STACK[0x2B8]);
  }
  sub_1DC311C00(&a28);
  sub_1DC30184C((atomic_uint **)&STACK[0x410]);
  if (a38) {
    sub_1DC3935A8((uint64_t)&a29);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DC3EC394(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = 0; i != 4; ++i)
  {
    uint64_t v3 = 0;
    while (i == v3 || *(float *)(a1 + 4 * v3) <= *(float *)(a1 + 4 * i))
    {
      if (++v3 == 5) {
        goto LABEL_8;
      }
    }
  }
LABEL_8:
  for (uint64_t j = 0; j != 4; ++j)
  {
    if (j != i)
    {
      uint64_t v5 = 0;
      while (i == v5 || j == v5 || *(float *)(a1 + 4 * v5) <= *(float *)(a1 + 4 * j))
      {
        if (++v5 == 5) {
          goto LABEL_17;
        }
      }
    }
  }
LABEL_17:
  uint64_t v6 = 0;
  float v7 = *(float *)(a1 + 4 * (int)i);
  if (v7 >= *(float *)(a1 + 4 * (int)j)) {
    float v7 = *(float *)(a1 + 4 * (int)j);
  }
  *(float *)a2 = v7;
  float v8 = *(float *)(a1 + 4 * (int)i);
  if (v8 <= *(float *)(a1 + 4 * (int)j)) {
    float v8 = *(float *)(a1 + 4 * (int)j);
  }
  *(float *)(a2 + 4) = v8;
  *(float *)(a2 + 8) = *(float *)(a1 + 4 * (int)i) + *(float *)(a1 + 4 * (int)j);
  *(_DWORD *)(a2 + 12) = 2;
  float v9 = v8 + 1.0;
  *(float *)(a2 + 16) = v9;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 3;
  float v10 = 0.0;
  float v11 = 0.0;
  do
  {
    if (4 * i != v6 && 4 * j != v6)
    {
      if (v9 >= *(float *)(a1 + v6)) {
        float v9 = *(float *)(a1 + v6);
      }
      *(float *)(a2 + 16) = v9;
      if (v11 <= *(float *)(a1 + v6)) {
        float v11 = *(float *)(a1 + v6);
      }
      *(float *)(a2 + 20) = v11;
      float v10 = *(float *)(a1 + v6) + v10;
      *(float *)(a2 + 24) = v10;
    }
    v6 += 4;
  }
  while (v6 != 20);
  if ((int)i >= (int)j) {
    int v12 = j;
  }
  else {
    int v12 = i;
  }
  char v13 = 7;
  switch(v12)
  {
    case 0:
      if ((int)i <= (int)j) {
        LODWORD(i) = j;
      }
      BOOL v14 = i >= 5;
      char v15 = 8 * i;
      unint64_t v16 = 0x1080503FFLL;
      goto LABEL_41;
    case 1:
      if ((int)i <= (int)j) {
        LODWORD(i) = j;
      }
      BOOL v14 = i >= 5;
      char v15 = 8 * i;
      unint64_t v16 = 0x20906FFFFLL;
LABEL_41:
      unint64_t v17 = v16 >> v15;
      if (v14) {
        char v13 = -1;
      }
      else {
        char v13 = v17;
      }
      break;
    case 2:
      if ((int)i <= (int)j) {
        LODWORD(i) = j;
      }
      if (i == 4) {
        char v18 = 4;
      }
      else {
        char v18 = -1;
      }
      if (i == 3) {
        char v13 = 0;
      }
      else {
        char v13 = v18;
      }
      break;
    case 3:
      return v13;
    default:
      char v13 = -1;
      break;
  }
  return v13;
}

float sub_1DC3EC590(uint64_t a1)
{
  float v1 = *(float *)(a1 + 8) / (float)*(int *)(a1 + 12);
  float v2 = (float)(*(float *)(a1 + 4) - *(float *)a1) / v1;
  float v3 = (float)(*(float *)(a1 + 20) - *(float *)(a1 + 16)) / v1;
  float v4 = 1.0;
  float v5 = 1.0;
  if (v2 >= 0.2)
  {
    float v5 = 0.0;
    if (v2 < 0.4) {
      float v5 = (float)(0.4 - v2) / 0.2;
    }
  }
  if (v3 >= 0.3)
  {
    float v4 = 0.0;
    if (v3 < 0.4) {
      float v4 = (float)(0.4 - v3) / 0.1;
    }
  }
  float v6 = v1 / (float)(*(float *)(a1 + 24) / (float)*(int *)(a1 + 28));
  BOOL v7 = v6 >= 1.5;
  if (v6 > 3.5) {
    BOOL v7 = 0;
  }
  float result = (float)v7;
  if (v4 < (float)v7) {
    float result = v4;
  }
  if (v5 < result) {
    return v5;
  }
  return result;
}

uint64_t sub_1DC3EC65C(int a1, float *a2, int a3, float *a4, uint64_t a5, unsigned int a6, uint64_t a7, int a8)
{
  uint64_t v195 = *MEMORY[0x1E4F143B8];
  int v8 = a3 % 5;
  uint64_t v9 = 6;
  if (a1 >= 3 && a3 >= 2)
  {
    float v11 = a2[2];
    float v12 = (float)(v11 - *a2) * 0.25;
    float v13 = v12 * 0.4;
    if (v12 < 5.0) {
      float v13 = (float)(v12 * 0.4) + 0.5;
    }
    if (vabds_f32(*a4 - *a2, v12) <= v13)
    {
      float v14 = a2[1];
      if (vabds_f32(v14 - *a4, v12) <= v13)
      {
        float v15 = a4[1];
        if (vabds_f32(v15 - v14, v12) <= v13 && vabds_f32(v11 - v15, v12) <= v13)
        {
          unint64_t v16 = a3 - (unint64_t)(v8 == 1);
          int v17 = ((int)v16 - 4) / 5;
          uint64_t v18 = 5 * v17 + 2;
          float v19 = a4[v18];
          uint64_t v20 = 20 * v17 + 12;
          float v21 = *(float *)((char *)a2 + v20);
          float v22 = v21 - v19;
          float v23 = *(float *)((char *)a4 + v20) - v21;
          float v24 = (float)(v22 + v23) * 0.5;
          float v25 = (float)(v23 - v22) * 0.5;
          if (v25 <= (float)(v24 * 0.4))
          {
            float v27 = (float)(v19 - a2[v18]) - v25;
            float v28 = v27 / v24;
            if ((float)(v27 / v24) >= 1.6 && v28 <= 3.4)
            {
              float v29 = 0.0;
              if (v24 < 5.0) {
                float v29 = 0.5;
              }
              float v30 = v29 + (float)(v24 * 0.4);
              if (fabsf(v27 - (float)(v24 * v28)) <= v30
                && vabds_f32(v22 + v25, v24) <= v30
                && vabds_f32(v23 - v25, v24) <= v30)
              {
                float v157 = (float)(v22 + v23) * 0.5;
                BOOL v156 = v8 == 1;
                int v161 = ((int)v16 - 4) / 5;
                size_t v33 = 2 * v17;
                int32x2_t v176 = (char *)malloc_type_calloc(v33, 1uLL, 0x100004077774924uLL);
                int32x2_t v167 = (float *)malloc_type_calloc(v33, 4uLL, 0x100004052888210uLL);
                int32x2_t v166 = (float *)malloc_type_calloc(v33, 4uLL, 0x100004052888210uLL);
                __int16 v186 = 0;
                long long v184 = 0u;
                long long v185 = 0u;
                long long v182 = 0u;
                long long v183 = 0u;
                float v34 = 1.0;
                float v35 = 1.0;
                float v36 = 0.0;
                float v37 = 0.0;
                float v38 = 0.0;
                if ((int)v16 >= 9)
                {
                  uint64_t v39 = 0;
                  if (v8 == 1) {
                    uint64_t v40 = 3;
                  }
                  else {
                    uint64_t v40 = 2;
                  }
                  uint64_t v164 = (v161 - 1);
                  if (v161 <= 1) {
                    uint64_t v41 = 1;
                  }
                  else {
                    uint64_t v41 = v161;
                  }
                  uint64_t v163 = v41;
                  __asm { FMOV            V20.2D, #0.5 }
                  unint64_t v46 = &a2[v40];
                  uint64_t v165 = v40;
                  char v47 = &a4[v40];
                  float64x2_t v162 = _Q20;
                  do
                  {
                    float v172 = v36;
                    float v173 = v37;
                    float v174 = v38;
                    uint64_t v48 = 0;
                    uint64_t v49 = v165 + 5 * v39;
                    do
                    {
                      *(float *)&v192[v48 * 4] = v47[v48] - v46[v48];
                      ++v48;
                    }
                    while (v48 != 5);
                    int v177 = v46;
                    unsigned int v178 = v47;
                    uint64_t v175 = 2 * v39;
                    v176[2 * v39] = sub_1DC3EC394((uint64_t)v192, (uint64_t)&v184);
                    float v50 = *((float *)&v185 + 2);
                    float v51 = sub_1DC3EC590((uint64_t)&v184);
                    uint64_t v52 = 0;
                    v167[v39] = *((float *)&v184 + 2);
                    uint64_t v179 = v39;
                    uint64_t v53 = v39 + v161;
                    v167[v53] = v50;
                    do
                    {
                      *(float *)&v191[v52 * 4] = v177[v52 + 1] - v178[v52];
                      ++v52;
                    }
                    while (v52 != 5);
                    char v54 = sub_1DC3EC394((uint64_t)v191, (uint64_t)&v182);
                    if (v179) {
                      float v55 = -0.0;
                    }
                    else {
                      float v55 = v50;
                    }
                    float v56 = *((float *)&v183 + 2);
                    float v57 = *((float *)&v182 + 2);
                    if (v179) {
                      float v58 = -0.0;
                    }
                    else {
                      float v58 = *((float *)&v183 + 2);
                    }
                    float v170 = v58;
                    float v171 = v55;
                    uint64_t v168 = v175 | 1;
                    v176[v175 | 1] = v54;
                    if (v179 == v164) {
                      float v59 = v50;
                    }
                    else {
                      float v59 = -0.0;
                    }
                    float v169 = v59;
                    v166[v179] = v57;
                    v166[v53] = v56;
                    if (v179 == v164) {
                      float v60 = v56;
                    }
                    else {
                      float v60 = -0.0;
                    }
                    float v61 = sub_1DC3EC590((uint64_t)&v182);
                    float v62 = v61;
                    if (v51 < v61) {
                      float v61 = v51;
                    }
                    if (v61 < 0.1)
                    {
                      if (v62 <= 0.3)
                      {
                        if (v51 <= 0.3)
                        {
                          sub_1DC3ED30C((uint64_t)v192, (uint64_t)v190, (unsigned char *)&v186 + 1);
                          sub_1DC3ED30C((uint64_t)v191, (uint64_t)v189, &v186);
                        }
                        else
                        {
                          sub_1DC3ED30C((uint64_t)v191, (uint64_t)v189, &v186);
                          v190[0] = v176[v175];
                          HIBYTE(v186) = 1;
                        }
                      }
                      else
                      {
                        sub_1DC3ED30C((uint64_t)v192, (uint64_t)v190, (unsigned char *)&v186 + 1);
                        v189[0] = v176[v168];
                        LOBYTE(v186) = 1;
                      }
                      int32x4_t v63 = &a2[v49];
                      signed int v64 = (int)(*v63 + 0.5);
                      int v65 = (int)(v63[5] + 0.5);
                      int v180 = SHIBYTE(v186);
                      int v181 = (char)v186;
                      float v188 = 0.0;
                      uint64_t v187 = 0;
                      if (sub_1DC3B4340(a7, v64, v65, &v188, (float *)&v187 + 1, (float *)&v187))
                      {
                        if (v180 >= 1)
                        {
                          uint64_t v66 = 0;
                          float v67 = (double)(v65 - v64) * 0.0625;
                          float v68 = *((float *)&v187 + 1);
                          float v69 = *(float *)&v187;
                          float v70 = 1.0 / (float)(v188 + v188);
                          float v71 = (float)(v65 - v64);
                          char v72 = 127;
                          float v73 = -100.0;
                          char v74 = 127;
                          while (1)
                          {
                            if (v181 < 1) {
                              goto LABEL_134;
                            }
                            uint64_t v75 = 0;
                            char v76 = v190[v66];
                            float32x4_t v77 = &flt_1DC421E60[5 * v76];
                            do
                            {
                              uint64_t v78 = 0;
                              int v79 = (char)v189[v75];
                              char v80 = v189[v75];
                              v194[0] = 0;
                              float v81 = 0.0;
                              do
                              {
                                float v82 = v77[v78];
                                float32x2_t v83 = &v194[2 * v78];
                                float v84 = flt_1DC421E60[5 * v79 + v78++];
                                v85.f32[0] = v81 + v82;
                                float v81 = v85.f32[0] + v84;
                                v85.f32[1] = v85.f32[0] + v84;
                                *(int32x2_t *)(v83 + 1) = vmovn_s64(vcvtq_s64_f64(vaddq_f64(vcvtq_f64_f32(vmul_n_f32(v85, v67)), v162)));
                              }
                              while (v78 != 5);
                              if (a7)
                              {
                                uint64_t v86 = 0;
                                float v87 = 0.0;
                                int v88 = v194[0];
                                do
                                {
                                  uint64_t v89 = v86 + 1;
                                  int v90 = v194[v86 + 1];
                                  if (v88 < v90)
                                  {
                                    uint64_t v91 = v88 + v64;
                                    do
                                    {
                                      float v92 = *(float *)(a7 + 4 * v91);
                                      if (v86)
                                      {
                                        float v93 = v92 - v68;
                                        if (v93 > 0.0) {
                                          float v93 = 0.0;
                                        }
                                      }
                                      else
                                      {
                                        float v93 = fmaxf(v92 - v69, 0.0);
                                      }
                                      float v87 = v87 + (float)(v70 * (float)(v93 * v93));
                                      ++v91;
                                    }
                                    while (v91 < v90 + v64);
                                  }
                                  int v88 = v194[++v86];
                                }
                                while (v89 != 10);
                                float v94 = (float)-v87 / v71;
                              }
                              else
                              {
                                float v94 = -100.0;
                              }
                              if (v94 > -0.12 && v94 > v73)
                              {
                                float v73 = v94;
                                char v74 = v80;
                                char v72 = v76;
                              }
                              if (v67 <= 1.5) {
                                goto LABEL_133;
                              }
                              uint64_t v95 = 0;
                              float v96 = v94 * v71;
                              int v97 = v194[10];
                              uint64_t v98 = &flt_1DC421E60[5 * v79];
                              do
                              {
                                int v99 = (int *)((char *)&unk_1DC421F28 + 8 * v95);
                                int v100 = *v99;
                                uint64_t v101 = (*v99 + v64);
                                if (*v99 + v64 < 0) {
                                  goto LABEL_132;
                                }
                                int v102 = v99[1] + v65;
                                if (v102 >= a8) {
                                  goto LABEL_132;
                                }
                                uint64_t v103 = 0;
                                int v104 = v102 - v101;
                                float v106 = 0.0;
                                do
                                {
                                  v107.f32[0] = v106 + v77[v103];
                                  float v106 = v107.f32[0] + v98[v103];
                                  v107.f32[1] = v106;
                                  float v105 = (double)v104 * 0.0625;
                                  *(int32x2_t *)&v192[8 * v103++ + 24] = vmovn_s64(vcvtq_s64_f64(vaddq_f64(vcvtq_f64_f32(vmul_n_f32(v107, v105)), v162)));
                                }
                                while (v103 != 5);
                                if (!a7)
                                {
                                  float v138 = -100.0;
                                  goto LABEL_127;
                                }
                                float v108 = v96;
                                if (v100)
                                {
                                  int v109 = v100 <= 0 ? v101 : v64;
                                  int v110 = v100 <= 0 ? v64 : v101;
                                  float v108 = v96;
                                  if (v109 < v110)
                                  {
                                    uint64_t v111 = v110 - (uint64_t)v109;
                                    float v108 = v96;
                                    unint64_t v112 = (float *)(a7 + 4 * v109);
                                    do
                                    {
                                      float v113 = *v112++;
                                      float v114 = fmaxf(v113 - v69, 0.0);
                                      float v115 = v70 * (float)(v114 * v114);
                                      float v116 = -v115;
                                      if (v100 <= 0) {
                                        float v116 = v115;
                                      }
                                      float v108 = v108 + v116;
                                      --v111;
                                    }
                                    while (v111);
                                  }
                                }
                                int v117 = v97 - v100;
                                if (v117 != v193)
                                {
                                  int v118 = v117 >= v193 ? v193 : v117;
                                  int v119 = v117 < v193 ? v193 : v117;
                                  if (v118 < v119)
                                  {
                                    uint64_t v120 = v118 + (int)v101;
                                    uint64_t v121 = v119 + (int)v101;
                                    do
                                    {
                                      float v122 = *(float *)(a7 + 4 * v120) - v68;
                                      if (v122 > 0.0) {
                                        float v122 = 0.0;
                                      }
                                      float v123 = v70 * (float)(v122 * v122);
                                      float v124 = -v123;
                                      if (v117 < v193) {
                                        float v124 = v123;
                                      }
                                      float v108 = v108 + v124;
                                      ++v120;
                                    }
                                    while (v120 < v121);
                                  }
                                }
                                for (uint64_t i = 1; i != 10; ++i)
                                {
                                  uint64_t v126 = *(int *)&v192[4 * i + 20];
                                  int v127 = v126 + v101;
                                  int v128 = v194[i] + v64;
                                  if (v126 + v101 != v128)
                                  {
                                    int v129 = v128 >= v127 ? v126 + v101 : v194[i] + v64;
                                    int v130 = v127 <= v128 ? v194[i] + v64 : v126 + v101;
                                    _VF = __OFSUB__(v130, v129);
                                    int v131 = v130 - v129;
                                    if (!((v131 < 0) ^ _VF | (v131 == 0)))
                                    {
                                      uint64_t v132 = v101 + v126;
                                      if (v101 + v126 >= v128) {
                                        uint64_t v132 = v128;
                                      }
                                      uint64_t v133 = (float *)(a7 + 4 * v132);
                                      do
                                      {
                                        float v134 = *v133 - v68;
                                        if (v134 > 0.0) {
                                          float v134 = 0.0;
                                        }
                                        float v135 = fmaxf(*v133 - v69, 0.0);
                                        float v136 = v70 * (float)(v134 * v134);
                                        float v137 = v70 * (float)(v135 * v135);
                                        if (i)
                                        {
                                          if (v128 < v127)
                                          {
LABEL_122:
                                            float v108 = (float)(v108 + v136) - v137;
                                            goto LABEL_123;
                                          }
                                        }
                                        else if (v127 < v128)
                                        {
                                          goto LABEL_122;
                                        }
                                        float v108 = v137 + (float)(v108 - v136);
LABEL_123:
                                        ++v133;
                                        --v131;
                                      }
                                      while (v131);
                                    }
                                  }
                                }
                                float v138 = v108 / (float)v104;
LABEL_127:
                                if (v138 > -0.12 && v138 > v73)
                                {
                                  float v73 = v138;
                                  char v74 = v80;
                                  char v72 = v76;
                                }
LABEL_132:
                                ++v95;
                              }
                              while (v95 != 8);
LABEL_133:
                              ++v75;
                            }
                            while (v75 != v181);
LABEL_134:
                            if (++v66 == v180) {
                              goto LABEL_137;
                            }
                          }
                        }
                        char v74 = 127;
                        float v73 = -100.0;
                        char v72 = 127;
LABEL_137:
                        if (v73 > -0.12)
                        {
                          v190[0] = v72;
                          v189[0] = v74;
                          v176[v175] = v72;
                          v176[v168] = v74;
                          float v51 = 0.3;
                          float v62 = 0.3;
                        }
                      }
                    }
                    float v37 = (float)(v173 + v171) + v170;
                    float v38 = (float)(v174 + v169) + v60;
                    if (v51 < v35) {
                      float v140 = v51;
                    }
                    else {
                      float v140 = v35;
                    }
                    if (v51 >= v34) {
                      float v141 = v34;
                    }
                    else {
                      float v141 = v51;
                    }
                    if (v51 < v34) {
                      float v140 = v34;
                    }
                    float v36 = (float)(v172 + v51) + v62;
                    if (v62 < v140) {
                      float v142 = v62;
                    }
                    else {
                      float v142 = v140;
                    }
                    if (v62 >= v141) {
                      float v34 = v141;
                    }
                    else {
                      float v34 = v62;
                    }
                    if (v62 >= v141) {
                      float v35 = v142;
                    }
                    else {
                      float v35 = v141;
                    }
                    uint64_t v39 = v179 + 1;
                    unint64_t v46 = v177 + 5;
                    char v47 = v178 + 5;
                  }
                  while (v179 + 1 != v163);
                }
                float v143 = (float)((float)(v35 * 0.3) + (float)(v34 * 0.2)) + (float)((float)(v36 / (float)(int)v33) * 0.5);
                if (v34 < 0.1) {
                  float v143 = 0.0;
                }
                *(float *)(a5 + 24) = v143;
                *(void *)(a5 + 8) = v33;
                *(_DWORD *)(a5 + 80) = 1;
                *(_DWORD *)(a5 + 84) = v161;
                unsigned int v144 = *(void **)(a5 + 16);
                if (v144)
                {
                  float v145 = v38;
                  float v146 = v37;
                  free(v144);
                  float v37 = v146;
                  float v38 = v145;
                }
                *(void *)(a5 + 16) = v176;
                unsigned int v147 = a6;
                if (a6)
                {
                  if ((int)v16 < 9)
                  {
                    unsigned int v147 = 0;
LABEL_178:
                    if (*(float *)(a5 + 24) < 0.1 && v147 == 0) {
                      uint64_t v9 = 7;
                    }
                    else {
                      uint64_t v9 = v147;
                    }
                    if (!v9)
                    {
                      if (vabds_f32(v12, v37 / 6.0) <= (float)((float)(v37 / 6.0) * 0.3)
                        && vabds_f32(v157, v38 / 6.0) <= (float)((float)(v38 / 6.0) * 0.3))
                      {
                        uint64_t v9 = 0;
                        *(float *)(a5 + 72) = (float)((float)(v37 + a2[v156 + 2]) - a2[v156]) * 0.1;
                        *(float *)(a5 + 76) = (float)((float)(v38 + a4[v16 - 1]) - a4[(int)v16 - 2]) * 0.125;
                        unint64_t v155 = *(_DWORD **)(a5 + 64);
                        v155[10] = 0;
                        v155[11] = v156;
                        v155[12] = *(_DWORD *)a2;
                        v155[13] = LODWORD(a4[v16 - 1]);
                        v155[5] = v16;
                      }
                      else
                      {
                        uint64_t v9 = 6;
                      }
                    }
                    free(v167);
                    free(v166);
                    return v9;
                  }
                  int v148 = 0;
                  if (v161 <= 1) {
                    uint64_t v149 = 1;
                  }
                  else {
                    uint64_t v149 = v161;
                  }
                  int32x2_t v150 = v176 + 1;
                  do
                  {
                    v148 += *v150 + 3 * *(v150 - 1);
                    v150 += 2;
                    --v149;
                  }
                  while (v149);
                  HIDWORD(v151) = -858993459 * v148 + 429496728;
                  LODWORD(v151) = HIDWORD(v151);
                  if ((v151 >> 1) < 0x19999999)
                  {
                    unsigned int v147 = 0;
                  }
                  else
                  {
                    *(_DWORD *)(a5 + 24) = 0;
                    unsigned int v147 = 5;
                  }
                }
                if ((v16 - 14) <= 4)
                {
                  double v152 = fmaxf(v167[2], v167[3]) * 1.2;
                  if (v152 >= *v167
                    || v152 >= v167[1]
                    || (double v153 = fmaxf(v166[2], v166[3]) * 1.2, v153 >= *v166)
                    || v153 >= v166[1])
                  {
                    unsigned int v147 = 2;
                  }
                }
                goto LABEL_178;
              }
            }
          }
        }
      }
    }
  }
  return v9;
}

uint64_t sub_1DC3ED30C(uint64_t result, uint64_t a2, unsigned char *a3)
{
  int v3 = 0;
  int v4 = 0;
  for (uint64_t i = 1; i != 5; ++i)
  {
    float v6 = *(float *)(result + 4 * i);
    if (v6 > *(float *)(result + 4 * v4)) {
      int v4 = i;
    }
    if (v6 < *(float *)(result + 4 * v3)) {
      int v3 = i;
    }
  }
  uint64_t v7 = 0;
  int v8 = 0;
  uint64_t v9 = (float *)((char *)&unk_1DC421E60 + 4 * v4);
  float v10 = (float *)((char *)&unk_1DC421E60 + 4 * v3);
  do
  {
    if (*v10 < 1.1 && *v9 > 2.0) {
      *(unsigned char *)(a2 + v8++) = v7;
    }
    ++v7;
    v9 += 5;
    v10 += 5;
  }
  while (v7 != 10);
  *a3 = v8;
  return result;
}

uint64_t sub_1DC3ED3A4(int a1, float *a2, int a3, float *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a3 < 9) {
    return 16;
  }
  if ((-858993459 * a3 - 858993460) > 0x33333332) {
    return 2;
  }
  return sub_1DC3EC65C(a1, a2, a3, a4, a5, 0, a6, a7);
}

uint64_t sub_1DC3ED3EC(int a1, float *a2, int a3, float *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a3 < 9) {
    return 16;
  }
  if ((-858993459 * a3 - 858993460) > 0x33333332) {
    return 2;
  }
  return sub_1DC3EC65C(a1, a2, a3, a4, a5, 1u, a6, a7);
}

uint64_t sub_1DC3ED434(int a1, float *a2, int a3, float *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a3 >= 39) {
    return sub_1DC3EC65C(a1, a2, a3, a4, a5, 0, a6, a7);
  }
  else {
    return 16;
  }
}

uint64_t sub_1DC3ED454(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 >= a3 - 1) {
    LODWORD(v3) = a3 - 1;
  }
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      *(unsigned char *)(a2 + v4) = *(unsigned char *)(*(void *)(result + 16) + v4) + 48;
      ++v4;
    }
    while (v3 != v4);
  }
  *(unsigned char *)(a2 + (int)v3) = 0;
  return result;
}

BOOL sub_1DC3ED498(int a1)
{
  return a1 > 8 && a1 % 5 == 4;
}

BOOL sub_1DC3ED4C8(int a1)
{
  return a1 == 39 || a1 == 41;
}

uint64_t sub_1DC3ED4DC(uint64_t a1, int a2, uint64_t a3, float a4, float a5, float a6, float a7)
{
  memset(v23, 0, sizeof(v23));
  float v14 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
  float v24 = v14;
  *((void *)v14 + 8) = 0;
  *((_DWORD *)v14 + 18) = 0;
  *((void *)v14 + 10) = 0;
  *(_OWORD *)float v14 = 0u;
  *((_OWORD *)v14 + 1) = 0u;
  *((_OWORD *)v14 + 2) = 0u;
  *(_OWORD *)(v14 + 44) = 0u;
  if (a2) {
    float v15 = a7;
  }
  else {
    float v15 = a5;
  }
  if (a2) {
    float v16 = a4;
  }
  else {
    float v16 = a6;
  }
  if (a2) {
    float v17 = a5;
  }
  else {
    float v17 = a7;
  }
  if (a2) {
    float v18 = a6;
  }
  else {
    float v18 = a4;
  }
  int v19 = sub_1DC3F0878(*(void *)(a1 + 32), *(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), (float **)v23, (float *)&v23[1] + 3, v18, v15, v16, v17, 3.0);
  if (v19 >= 22)
  {
    *((void *)&v23[0] + 1) = v19;
    LODWORD(v23[1]) = v19 - 1;
    int v21 = 1 << *(_DWORD *)a3;
    **(_DWORD **)(a3 + 64) = v21;
    uint64_t v20 = sub_1DC3DABE8((uint64_t)v23, a3, v21);
  }
  else
  {
    uint64_t v20 = 16;
  }
  sub_1DC3D5988((uint64_t)v23);
  return v20;
}

uint64_t sub_1DC3ED600(uint64_t a1, float *a2, void *a3, float a4, float a5, float a6, float a7)
{
  if (a2) {
    int v8 = sub_1DC3EE488((uint64_t *)a1, a2, a3, a4, a5, a6, a7, 1.0);
  }
  else {
    int v8 = sub_1DC3F0878(*(void *)(a1 + 32), *(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), (float **)a3, (float *)a3 + 7, a4, a5, a6, a7, 1.0);
  }
  if (v8 < 41) {
    return 16;
  }
  uint64_t v9 = 0;
  *((_DWORD *)a3 + 2) = v8;
  *((_DWORD *)a3 + 3) = 0;
  *((_DWORD *)a3 + 4) = v8 - 1;
  return v9;
}

float **sub_1DC3ED678(float **result, long long *a2, uint64_t a3, int a4)
{
  if (a3)
  {
    if (*(int *)result >= 1)
    {
      int v4 = *(_DWORD *)a2;
      if (*(int *)a2 >= 1)
      {
        float v5 = *result[1];
        int v6 = (int)(float)(fabsf(v5) + -0.5);
        if (v6 + 1 >= a4) {
          int v7 = v6;
        }
        else {
          int v7 = v6 + 1;
        }
        if (v5 > 0.0 == *(float *)(a3 + 4 * (v6 - (v6 + 1 >= a4))) <= *(float *)(a3 + 4 * v7))
        {
          long long v8 = *(_OWORD *)result;
          *(_OWORD *)float result = *a2;
          *a2 = v8;
          float v5 = *result[1];
          int v4 = *(_DWORD *)a2;
        }
        uint64_t v9 = (float *)*((void *)a2 + 1);
        if (v5 > *v9)
        {
          *((void *)a2 + 1) = v9 + 1;
          *(_DWORD *)a2 = --v4;
        }
        if (*(_DWORD *)result != v4)
        {
          if (*(_DWORD *)result <= v4) {
            float v10 = (float **)a2;
          }
          else {
            float v10 = result;
          }
          --*(_DWORD *)v10;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1DC3ED744(double *a1, double a2, double a3, double a4, double a5, float a6, double a7, double a8, double a9, double a10, double a11)
{
  float v21 = a6 * 3.14159265 / 180.0;
  float v22 = a10 - a7;
  __float2 v23 = __sincosf_stret(v21);
  float v24 = a11 - a8;
  if ((float)((float)(v23.__sinval * v24) + (float)(v22 * v23.__cosval)) >= 0.0)
  {
    float v26 = v21;
  }
  else
  {
    float v25 = v21 + 3.14159265;
    float v26 = v25;
  }
  if (a4 <= a5) {
    double v27 = a5;
  }
  else {
    double v27 = a4;
  }
  float v28 = v27 + v27;
  __float2 v29 = __sincosf_stret(v26);
  double v30 = (float)(v29.__sinval * v28);
  float v31 = a7 + v30;
  float v32 = a7 - v30;
  float v60 = v32;
  float v61 = v31;
  double v33 = (float)(v29.__cosval * v28);
  float v34 = a8 - v33;
  float v35 = a8 + v33;
  float v58 = v35;
  float v59 = v34;
  float v36 = a10 - v30;
  float v50 = v36;
  float v37 = a10 + v30;
  float v56 = v37;
  float v57 = v36;
  float v38 = a11 + v33;
  float v39 = a11 - v33;
  float v54 = v39;
  float v55 = v38;
  float v40 = a2;
  float v41 = a3;
  float v42 = a2 + a4;
  float v43 = a3 + a5;
  uint64_t result = sub_1DC3EFD88(&v61, &v59, &v60, &v58, v31, v34, v32, v35, v40, v42, v41, v43);
  if (result
    && (uint64_t result = sub_1DC3EFD88(&v57, &v55, &v56, &v54, v50, v38, v37, v39, v40, v42, v41, v43), result))
  {
    double v45 = v59;
    *a1 = v61;
    a1[1] = v45;
    double v46 = v58;
    a1[2] = v60;
    a1[3] = v46;
    double v47 = v55;
    a1[4] = v57;
    a1[5] = v47;
    a1[6] = v56;
    double v48 = v54;
    uint64_t v49 = 3;
  }
  else
  {
    a1[6] = v42;
    a1[7] = v41;
    *a1 = v40;
    a1[1] = v41;
    a1[2] = v40;
    double v48 = v43;
    uint64_t v49 = 1;
    a1[4] = v42;
    a1[5] = v43;
  }
  a1[2 * v49 + 1] = v48;
  return result;
}

uint64_t sub_1DC3ED978(uint64_t a1, int a2, int a3, int a4, unsigned int *a5, float a6, float a7, float a8, float a9, float a10)
{
  uint64_t v32 = 0;
  double v33 = 0;
  uint64_t v30 = 0;
  float v31 = 0;
  memset(v28, 0, sizeof(v28));
  uint64_t v20 = (char *)malloc_type_malloc(0x58uLL, 0x1080040FF0494E1uLL);
  __float2 v29 = (int *)v20;
  *((void *)v20 + 8) = 0;
  *((_DWORD *)v20 + 18) = 0;
  *((void *)v20 + 10) = 0;
  *(_OWORD *)uint64_t v20 = 0u;
  *((_OWORD *)v20 + 1) = 0u;
  *((_OWORD *)v20 + 2) = 0u;
  *(_OWORD *)(v20 + 44) = 0u;
  if (a2) {
    float v21 = a8;
  }
  else {
    float v21 = a6;
  }
  if (a2) {
    float v22 = a9;
  }
  else {
    float v22 = a7;
  }
  if (a2) {
    float v23 = a6;
  }
  else {
    float v23 = a8;
  }
  if (a2) {
    float v24 = a7;
  }
  else {
    float v24 = a9;
  }
  uint64_t v25 = sub_1DC3EDB08(a1, 1, 1 << *a5, a3, a4, v28, (uint64_t)&v32, (uint64_t)&v30, v21, v22, v23, v24, 3.0, a10, 0);
  if (!v25)
  {
    sub_1DC3D5788(v29, *((void *)a5 + 8));
    uint64_t v26 = *a5;
    if ((**((_DWORD **)a5 + 8) >> v26)) {
      uint64_t v25 = (*(uint64_t (**)(uint64_t, void *, uint64_t, void *, unsigned int *, void, void))&dword_1EBFFBA10[16 * v26 + 10])(v32, v33, v30, v31, a5, *(void *)&v28[0], DWORD2(v28[0]));
    }
    else {
      uint64_t v25 = 2;
    }
  }
  if (v33) {
    free(v33);
  }
  if (v31) {
    free(v31);
  }
  sub_1DC3D5988((uint64_t)v28);
  return v25;
}

uint64_t sub_1DC3EDB08(uint64_t a1, int a2, int a3, int a4, int a5, void *a6, uint64_t a7, uint64_t a8, float a9, float a10, float a11, float a12, float a13, float a14, float *a15)
{
  if (a15) {
    int v23 = sub_1DC3EE488((uint64_t *)a1, a15, a6, a9, a10, a11, a12, a13);
  }
  else {
    int v23 = sub_1DC3F0878(*(void *)(a1 + 32), *(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), (float **)a6, (float *)a6 + 7, a9, a10, a11, a12, a13);
  }
  *((_DWORD *)a6 + 2) = v23;
  if (v23 <= 21)
  {
    if (*a6) {
      free((void *)*a6);
    }
    *a6 = 0;
    *((_DWORD *)a6 + 2) = 0;
    return 16;
  }
  sub_1DC3F0FCC((float *)*a6, v23, &v71, &v70);
  if (v24 == 0.0) {
    return 18;
  }
  *(_DWORD *)(a6[10] + 4) = a4;
  uint64_t v25 = (float *)*a6;
  signed int v26 = *((_DWORD *)a6 + 2);
  if (a2)
  {
    LODWORD(v64) = 0;
    float v68 = 0;
    uint64_t v66 = 0;
    sub_1DC3F0BD0(v25, v26, a4, (int *)&v64, &v68, &v66);
    double v27 = v66;
    if ((int)v64 < 1)
    {
      uint64_t v33 = 0;
    }
    else
    {
      uint64_t v28 = 0;
      int v29 = 0;
      int v30 = -v26;
      do
      {
        int v31 = *((_DWORD *)v66 + v28) - *((_DWORD *)v68 + v28);
        BOOL v32 = v30 < v31;
        if (v30 <= v31) {
          int v30 = *((_DWORD *)v66 + v28) - *((_DWORD *)v68 + v28);
        }
        if (v32) {
          int v29 = v28;
        }
        ++v28;
      }
      while (v64 != v28);
      uint64_t v33 = v29;
    }
    int v35 = *((_DWORD *)v68 + v33);
    int v36 = *((_DWORD *)v66 + v33);
    free(v68);
    free(v27);
    if (v35 < 0 || v35 >= v26 || v36 < 0 || (v36 < v26 ? (BOOL v37 = v35 < v36) : (BOOL v37 = 0), !v37))
    {
      int v35 = 0;
      *((_DWORD *)a6 + 3) = 0;
      int v36 = v26 - 1;
    }
    else
    {
      *((_DWORD *)a6 + 3) = v35;
    }
  }
  else
  {
    int v35 = 0;
    int v36 = v26 - 1;
    *((_DWORD *)a6 + 3) = 0;
  }
  *((_DWORD *)a6 + 4) = v36;
  sub_1DC3F106C(v25, v26, v35, v36);
  int v39 = *((_DWORD *)a6 + 3);
  int v38 = *((_DWORD *)a6 + 4);
  size_t v40 = (v38 - v39 + 1);
  *(_DWORD *)(a6[10] + 8) = v40;
  if (v39 >= v38) {
    return 15;
  }
  if ((int)v40 < 41) {
    return 16;
  }
  float v68 = 0;
  uint64_t v66 = 0;
  uint64_t v64 = 0;
  uint64_t v62 = 0;
  float v41 = malloc_type_calloc(4uLL, (v38 - v39 + 1), 0x9ACECC79uLL);
  float v69 = v41;
  float v42 = malloc_type_calloc(4uLL, v40, 0x1BE3430AuLL);
  float v67 = v42;
  int v65 = malloc_type_calloc(4uLL, v40, 0x9737F225uLL);
  int32x4_t v63 = malloc_type_calloc(4uLL, v40, 0x90D5D658uLL);
  uint64_t v43 = sub_1DC37F038((uint64_t)a6, (uint64_t)&v64, (uint64_t)&v62);
  if (!v43)
  {
    uint64_t v43 = sub_1DC37F104(a6, (unsigned int *)&v64, (int *)&v62, v40, 0.8, 0.0);
    if (!v43)
    {
      uint64_t v45 = (int)v62;
      LODWORD(v66) = v62;
      if ((int)v62 >= 1)
      {
        double v46 = (int *)v63;
        do
        {
          int v47 = *v46++;
          *v42++ = v47;
          --v45;
        }
        while (v45);
      }
      uint64_t v48 = (int)v64;
      LODWORD(v68) = v64;
      if ((int)v64 >= 1)
      {
        uint64_t v49 = (int *)v65;
        do
        {
          int v50 = *v49++;
          *v41++ = v50;
          --v48;
        }
        while (v48);
      }
      uint64_t v51 = sub_1DC37F104(a6, (unsigned int *)&v68, (int *)&v66, a5, a14, 0.02);
      if (v51)
      {
        uint64_t v34 = v51;
        float v41 = v69;
        goto LABEL_37;
      }
      int v52 = (int)v68;
      float v41 = v69;
      uint64_t v53 = v67;
      sub_1DC3D6370((uint64_t)v68, (uint64_t)v69, (uint64_t)v66, (uint64_t)v67, (_DWORD *)a6[10], a3);
      if (!*(_DWORD *)a6[10])
      {
        uint64_t v34 = 2;
        goto LABEL_37;
      }
      if (a7)
      {
        float v54 = *(void **)(a7 + 8);
        if (v54) {
          free(v54);
        }
        *(void *)(a7 + 8) = 0;
        *(_DWORD *)a7 = 0;
      }
      if (a8)
      {
        float v55 = *(void **)(a8 + 8);
        if (v55) {
          free(v55);
        }
        *(void *)(a8 + 8) = 0;
        *(_DWORD *)a8 = 0;
      }
      *(void *)(a7 + 8) = malloc_type_calloc(4uLL, *((int *)a6 + 2), 0x1A493BD8uLL);
      *(void *)(a8 + 8) = malloc_type_calloc(4uLL, *((int *)a6 + 2), 0xAFDFE941uLL);
      uint64_t v43 = sub_1DC37F87C(*a6, v52, (uint64_t)v41, (uint64_t)v53, a7, a8);
      if (!v43)
      {
        unsigned int v56 = *(_DWORD *)a8 - 1;
        if (*(int *)a8 < 1 || (unsigned int v57 = *(_DWORD *)a7 - 1, *(int *)a7 < 1))
        {
          uint64_t v34 = 10;
        }
        else
        {
          uint64_t v34 = 0;
          float v58 = *(float **)(a7 + 8);
          float v59 = *v58;
          float v60 = *(float **)(a8 + 8);
          if (*v58 >= *v60) {
            float v59 = *v60;
          }
          *((float *)a6 + 5) = v59;
          float v61 = v58[v57];
          if (v61 <= v60[v56]) {
            float v61 = v60[v56];
          }
          *((float *)a6 + 6) = v61;
        }
        goto LABEL_37;
      }
    }
  }
  uint64_t v34 = v43;
LABEL_37:
  if (v41) {
    free(v41);
  }
  if (v67) {
    free(v67);
  }
  if (v65) {
    free(v65);
  }
  if (v63) {
    free(v63);
  }
  return v34;
}

uint64_t sub_1DC3EDF80(uint64_t a1, uint64_t a2)
{
  int v11 = 1;
  char v12 = 1;
  unint64_t v3 = *(atomic_ullong **)(a1 + 8);
  if ((sub_1DC3778A8(v3, @"QR", (uint64_t)&v11) & 1) != 0
    || (int v9 = 1, v10 = 1, (sub_1DC3778A8(v3, @"MicroQR", (uint64_t)&v9) & 1) != 0)
    || (int v7 = 1, v8 = 1, (sub_1DC3778A8(v3, @"Aztec", (uint64_t)&v7) & 1) != 0)
    || (v5 = 1, v6 = 1, uint64_t result = sub_1DC3778A8(v3, @"DataMatrix", (uint64_t)&v5), (result & 1) != 0))
  {
    sub_1DC3D1F54();
  }
  **(_WORD **)(a2 + 64) = 256;
  return result;
}

uint64_t sub_1DC3EE07C(unsigned int a1, unsigned int a2, uint64_t a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11)
{
  v91[4] = *MEMORY[0x1E4F143B8];
  *(float *)v12.i32 = (float)((float)((float)(a4 + a6) + a8) + a10) * 0.25;
  *(float *)v11.i32 = (float)((float)((float)(a5 + a7) + a9) + a11) * 0.25;
  float32x2_t v25 = vcvt_f32_s32(vadd_s32((int32x2_t)__PAIR64__(a2, a1), (int32x2_t)-1));
  float32x2_t v26 = vmul_f32(v25, (float32x2_t)0x3F0000003F000000);
  *(float *)&unsigned int v27 = 0.0 - v26.f32[1];
  float32x2_t v74 = v26;
  *(float32x2_t *)v28.i8 = vsub_f32(v25, v26);
  v25.i32[0] = 0;
  *(float32x2_t *)v29.i8 = vsub_f32(v25, v74);
  float32x2_t v30 = vmul_f32(*(float32x2_t *)v29.i8, *(float32x2_t *)v29.i8);
  v31.i64[0] = __PAIR64__(v29.u32[1], v27);
  v31.i64[1] = __PAIR64__(v27, v29.u32[1]);
  v29.i64[1] = v29.i64[0];
  v28.i64[1] = v28.i64[0];
  float v68 = *(float *)v12.i32;
  float v69 = *(float *)v11.i32;
  float v32 = vmlas_n_f32(*(float *)&v27 * *(float *)&v27, *(float *)v28.i32, *(float *)v28.i32)
      + (float)(vmlas_n_f32(v30.f32[1], *(float *)v28.i32, *(float *)v28.i32)
              + (float)(vmlas_n_f32(*(float *)&v27 * *(float *)&v27, *(float *)v29.i32, *(float *)v29.i32)
                      + vmlas_n_f32(v30.f32[1], *(float *)v29.i32, *(float *)v29.i32)));
  *(float32x2_t *)v33.f32 = vsub_f32((float32x2_t)__PAIR64__(LODWORD(a6), LODWORD(a4)), (float32x2_t)vdup_lane_s32(v12, 0));
  *(float32x2_t *)v34.f32 = vsub_f32((float32x2_t)__PAIR64__(LODWORD(a7), LODWORD(a5)), (float32x2_t)vdup_lane_s32(v11, 0));
  float32x2_t v35 = vmla_f32(vmul_f32(*(float32x2_t *)v34.f32, *(float32x2_t *)v34.f32), *(float32x2_t *)v33.f32, *(float32x2_t *)v33.f32);
  *(float *)&unsigned int v36 = a9 - *(float *)v11.i32;
  *(float *)&unsigned int v37 = a11 - *(float *)v11.i32;
  *(float *)v13.i32 = sqrt(v32 * 0.125);
  v35.f32[0] = sqrt((float)((float)((float)(*(float *)&v37 * *(float *)&v37)+ (float)((float)(a10 - *(float *)v12.i32) * (float)(a10 - *(float *)v12.i32)))+ (float)((float)((float)(*(float *)&v36 * *(float *)&v36)+ (float)((float)(a8 - *(float *)v12.i32) * (float)(a8 - *(float *)v12.i32)))+ vaddv_f32(v35)))* 0.125);
  float v66 = *(float *)v13.i32;
  float v67 = v35.f32[0];
  float32x4_t v38 = (float32x4_t)vdupq_lane_s32(v13, 0);
  float32x4_t v39 = (float32x4_t)vdupq_lane_s32((int32x2_t)v35, 0);
  v33.f32[2] = a8 - *(float *)v12.i32;
  v33.f32[3] = a10 - *(float *)v12.i32;
  v34.i64[1] = __PAIR64__(v37, v36);
  v92.val[1] = vdivq_f32((float32x4_t)vuzp1q_s32(v29, v28), v38);
  v95.val[1] = vdivq_f32(v31, v38);
  float32x4_t v40 = vdivq_f32(v33, v39);
  v93.val[0] = vdivq_f32(v34, v39);
  v93.val[1] = vnegq_f32(v40);
  float32x4_t v41 = vnegq_f32(v92.val[1]);
  v95.val[0] = 0uLL;
  v94.val[0] = vmulq_f32(v92.val[1], v93.val[0]);
  v92.val[0] = 0u;
  float v42 = (float *)&v84;
  vst2q_f32(v42, v92);
  v42 += 8;
  vst2q_f32(v42, v95);
  uint64_t v43 = (float *)&v87;
  vst2q_f32(v43, v95);
  float v44 = (float *)v88;
  v92.val[0] = vnegq_f32(v95.val[1]);
  v92.val[1] = 0u;
  vst2q_f32(v44, v92);
  uint64_t v45 = (float *)&v89;
  v94.val[1] = vmulq_f32(v40, v41);
  vst2q_f32(v45, v94);
  double v46 = (float *)&v90;
  v94.val[0] = vmulq_f32(v95.val[1], v93.val[0]);
  v94.val[1] = vmulq_f32(v40, v92.val[0]);
  vst2q_f32(v46, v94);
  int v47 = (float *)v91;
  vst2q_f32(v47, v93);
  long long v85 = xmmword_1DC3FDE20;
  long long v86 = xmmword_1DC3FDE20;
  v88[2] = xmmword_1DC3FDE30;
  v88[3] = xmmword_1DC3FDE30;
  uint64_t result = sgesvd_NEWLAPACK();
  float v49 = -(float)(1.0 / v66);
  float v50 = v49 * v74.f32[0];
  float v51 = vmuls_lane_f32(v49, v74, 1);
  float v52 = (float)(v68 * v81) + (float)(v67 * v75);
  float v53 = (float)(1.0 / v66) * v52;
  float v54 = (float)(v68 * v82) + (float)(v67 * v76);
  float v55 = (float)(1.0 / v66) * v54;
  float v56 = (float)((float)((float)(v68 * v83) + (float)(v67 * v77)) + (float)(v52 * v50)) + (float)(v54 * v51);
  float v57 = (float)(v69 * v81) + (float)(v67 * v78);
  float v58 = (float)(1.0 / v66) * v57;
  float v59 = (float)(v69 * v82) + (float)(v67 * v79);
  float v60 = (float)(1.0 / v66) * v59;
  float v61 = (float)((float)((float)(v69 * v83) + (float)(v67 * v80)) + (float)(v57 * v50)) + (float)(v59 * v51);
  float v62 = (float)(1.0 / v66) * v81;
  float v63 = (float)(1.0 / v66) * v82;
  float v64 = (float)(v83 + (float)(v81 * v50)) + (float)(v82 * v51);
  float v65 = 1.0
      / sqrtf((float)((float)((float)((float)((float)((float)((float)((float)(v55 * v55) + (float)(v53 * v53))+ (float)(v56 * v56))+ (float)(v58 * v58))+ (float)(v60 * v60))+ (float)(v61 * v61))+ (float)(v62 * v62))+ (float)(v63 * v63))+ (float)(v64 * v64));
  *(float *)(a3 + 40) = v53 * v65;
  *(float *)(a3 + 44) = v55 * v65;
  *(float *)(a3 + 48) = v56 * v65;
  *(float *)(a3 + 52) = v58 * v65;
  *(float *)(a3 + 56) = v60 * v65;
  *(float *)(a3 + 60) = v61 * v65;
  *(float *)(a3 + 64) = v62 * v65;
  *(float *)(a3 + 68) = v63 * v65;
  *(float *)(a3 + 72) = v64 * v65;
  *(float *)(a3 + 8) = a6;
  *(float *)(a3 + 12) = a7;
  *(float *)(a3 + 16) = a8;
  *(float *)(a3 + 20) = a9;
  *(float *)a3 = a4;
  *(float *)(a3 + 4) = a5;
  *(float *)(a3 + 24) = a10;
  *(float *)(a3 + 28) = a11;
  *(_DWORD *)(a3 + 32) = a1;
  *(_DWORD *)(a3 + 36) = a2;
  return result;
}

uint64_t sub_1DC3EE488(uint64_t *a1, float *a2, void *a3, float a4, float a5, float a6, float a7, float a8)
{
  int v13 = vcvtps_s32_f32(fmaxf(a8, 1.0));
  if (v13 >= 0) {
    int v14 = v13;
  }
  else {
    int v14 = v13 + 1;
  }
  float v15 = a6 - a4;
  float v16 = a7 - a5;
  float v17 = atan2f(a7 - a5, a6 - a4);
  float v18 = cosf(v17 + -1.5708);
  int v19 = vcvtps_s32_f32(sqrtf((float)(v16 * v16) + (float)(v15 * v15)));
  uint64_t v20 = (v19 + 1);
  float v21 = malloc_type_malloc(4 * (int)v20, 0x100004052888210uLL);
  if (!v21) {
    return 0;
  }
  if ((v19 & 0x80000000) == 0)
  {
    uint64_t v23 = 0;
    int v24 = v14 >> 1;
    if (v14 >> 1 < 0) {
      int v24 = -v24;
    }
    int v25 = v24 + 1;
    do
    {
      v21[v23] = 0;
      if (v13 >= -1)
      {
        int v26 = 0;
        float v27 = (float)(int)v23 / (float)v19;
        float v28 = a4 + (float)(v27 * v15);
        float v29 = a5 + (float)(v27 * v16);
        float v30 = 0.0;
        int v31 = -(v14 >> 1);
        do
        {
          float v32 = v28 + (float)((float)v31 * v18);
          float v33 = v29 + (float)((float)v31 * v18);
          float v34 = a2[18] + (float)((float)(v33 * a2[17]) + (float)(a2[16] * v32));
          float v35 = (float)(a2[12] + (float)((float)(v33 * a2[11]) + (float)(a2[10] * v32))) / v34;
          LODWORD(v22) = vcvtmd_s64_f64(v35);
          if ((v22 & 0x80000000) == 0)
          {
            uint64_t v36 = *a1;
            unint64_t v37 = *a1 - 1;
            if (v37 >= v22)
            {
              LODWORD(v36) = vcvtpd_s64_f64(v35);
              if ((v36 & 0x80000000) == 0 && v37 >= v36)
              {
                float v38 = a2[13];
                float v39 = a2[14];
                float v40 = (float)(a2[15] + (float)((float)(v33 * v39) + (float)(v38 * v32))) / v34;
                LODWORD(v37) = vcvtmd_s64_f64(v40);
                if ((v37 & 0x80000000) == 0)
                {
                  unint64_t v41 = a1[1];
                  unint64_t v42 = v41 - 1;
                  if (v41 - 1 >= v37)
                  {
                    LODWORD(v41) = vcvtpd_s64_f64(v40);
                    if ((v41 & 0x80000000) == 0 && v42 >= v41)
                    {
                      *(float *)&unsigned int v43 = (float)(int)v22;
                      *(float *)&unsigned int v44 = (float)(int)v37;
                      uint64_t v45 = a1[4];
                      uint64_t v46 = a1[2];
                      uint64_t v47 = v45 + v46 * v37;
                      LOBYTE(v43) = *(unsigned char *)(v47 + v22);
                      float v48 = v40 - *(float *)&v44;
                      LOBYTE(v44) = *(unsigned char *)(v47 + v36);
                      uint64_t v49 = v45 + v46 * v41;
                      LOBYTE(v38) = *(unsigned char *)(v49 + v22);
                      LOBYTE(v39) = *(unsigned char *)(v49 + v36);
                      float v30 = v30
                          + (float)((float)(v48
                                          * (float)((float)((float)(v35 - (float)(int)v22) * (float)LODWORD(v39))
                                                  + (float)((float)(1.0 - (float)(v35 - (float)(int)v22))
                                                          * (float)LODWORD(v38))))
                                  + (float)((float)(1.0 - v48)
                                          * (float)((float)((float)(v35 - (float)(int)v22) * (float)v44)
                                                  + (float)((float)(1.0 - (float)(v35 - (float)(int)v22)) * (float)v43))));
                      *(float *)&v21[v23] = v30;
                      ++v26;
                    }
                  }
                }
              }
            }
          }
          ++v31;
        }
        while (v25 != v31);
        if (v26 > 1) {
          *(float *)&v21[v23] = v30 / (float)v26;
        }
      }
      ++v23;
    }
    while (v23 != v20);
  }
  *a3 = v21;
  return v20;
}

uint64_t sub_1DC3EE6F0(uint64_t a1, unint64_t a2, unint64_t a3, char *a4, std::string::size_type a5, size_t *a6, const char *a7)
{
  uint64_t v7 = 0;
  uint64_t v202 = *MEMORY[0x1E4F143B8];
  if (a3 > 0xA8C) {
    return v7;
  }
  unint64_t v9 = a2;
  if (a2 >= a3) {
    return v7;
  }
  unint64_t v13 = a2;
  do
  {
    if (*(unsigned __int16 *)(a1 + 2 * v13) > 0x3A0u) {
      return 0;
    }
    ++v13;
  }
  while (a3 != v13);
  pthread_once(&stru_1EAA94B80, (void (*)(void))sub_1DC3EFBE0);
  if (a7) {
    int v14 = a7;
  }
  else {
    int v14 = "ISO-8859-1";
  }
  uint64_t v15 = MEMORY[0x1E019D3A0]("UTF-8", v14);
  if (v15 == -1)
  {
    if (qword_1EAA94CD0 != -1) {
      dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
    }
    float v16 = qword_1EAA94CC8;
    if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR))
    {
      int v166 = *__error();
      *(_DWORD *)int32x4_t buf = 136446722;
      *(void *)&uint8_t buf[4] = "UTF-8";
      __int16 v192 = 2082;
      int v193 = v14;
      __int16 v194 = 1026;
      int v195 = v166;
      _os_log_error_impl(&dword_1DC2FE000, v16, OS_LOG_TYPE_ERROR, "[PDF417] iconv_open(\"%{public}s\", \"%{public}s\") failed: %{public, errno}d", buf, 0x1Cu);
    }
    uint64_t v15 = -1;
  }
  float v174 = a6;
  uint64_t v176 = 0;
  uint64_t v17 = 0;
  char v179 = 0;
  int v18 = 0;
  __uint64_t n = 0;
  size_t v19 = 0;
  __src[87] = 0;
  std::string::size_type v20 = a5 - 1;
  uint64_t i = 3;
  uint64_t v22 = 3;
  while (2)
  {
    if (a3 <= v9 || (uint64_t v23 = v20 - v19, v20 <= v19))
    {
      if ((v18 & 1) == 0)
      {
        int8x8_t v158 = a4;
        goto LABEL_345;
      }
      unint64_t v159 = v19 >> 1;
      int8x8_t v158 = a4;
      unint64_t v160 = v174;
      if (v19 >= 2)
      {
        if (v159 <= 1) {
          uint64_t v161 = 1;
        }
        else {
          uint64_t v161 = v19 >> 1;
        }
        float64x2_t v162 = a4;
        do
        {
          *(_WORD *)float64x2_t v162 = bswap32(*(unsigned __int16 *)v162) >> 16;
          v162 += 2;
          --v161;
        }
        while (v161);
      }
      uint64_t v163 = v15;
      if (v19) {
        *(_WORD *)&a4[2 * v159] = a4[v19 - 1] << 8;
      }
      size_t v19 = sub_1DC36F420((uint64_t)a4, 8 * v19, a4, a5);
      uint64_t v15 = v163;
LABEL_346:
      size_t v164 = a5 - 1;
      if (v19 < a5 - 1) {
        size_t v164 = v19;
      }
      if (v160) {
        *unint64_t v160 = v164;
      }
      v158[v164] = 0;
      uint64_t v7 = 1;
      goto LABEL_351;
    }
    int v24 = *(__int16 *)(a1 + 2 * v9);
    switch(*(_WORD *)(a1 + 2 * v9))
    {
      case 0x384:
        uint64_t v176 = 0;
        uint64_t v17 = 0;
        goto LABEL_19;
      case 0x385:
        int v59 = 1;
        goto LABEL_160;
      case 0x386:
        int v59 = 3;
        goto LABEL_160;
      case 0x387:
      case 0x388:
      case 0x389:
      case 0x38A:
      case 0x38B:
      case 0x38C:
      case 0x38D:
      case 0x38E:
      case 0x38F:
      case 0x390:
      case 0x392:
      case 0x393:
      case 0x394:
      case 0x395:
      case 0x396:
      case 0x397:
      case 0x39B:
        goto LABEL_19;
      case 0x391:
        if (HIDWORD(v176)) {
          goto LABEL_333;
        }
        HIDWORD(v176) = 0;
        uint64_t v17 = 4;
        goto LABEL_19;
      case 0x398:
        int v18 = 1;
        goto LABEL_19;
      case 0x399:
        if (v9 != 1) {
          goto LABEL_333;
        }
        goto LABEL_19;
      case 0x39A:
        char v179 = 0;
        goto LABEL_19;
      case 0x39C:
        goto LABEL_159;
      case 0x39D:
        if (++v9 >= a3) {
          goto LABEL_333;
        }
        unsigned int v60 = *(unsigned __int16 *)(a1 + 2 * v9);
        if (v60 > 0x383) {
          goto LABEL_333;
        }
        uint64_t v22 = v60 + 810900;
        goto LABEL_19;
      case 0x39E:
        if (v9 + 2 >= a3) {
          goto LABEL_333;
        }
        unsigned int v61 = *(unsigned __int16 *)(a1 + 2 * v9 + 2);
        if (v61 > 0x383) {
          goto LABEL_333;
        }
        unsigned int v62 = *(unsigned __int16 *)(a1 + 2 * (v9 + 2));
        if (v62 >= 0x384) {
          goto LABEL_333;
        }
        uint64_t v22 = v62 + 900 * v61 + 900;
        v9 += 2;
        goto LABEL_19;
      case 0x39F:
        if (++v9 >= a3) {
          goto LABEL_333;
        }
        uint64_t v22 = *(unsigned __int16 *)(a1 + 2 * v9);
        if (v22 > 0x383) {
          goto LABEL_333;
        }
        goto LABEL_19;
      case 0x3A0:
        v9 += 2;
        char v179 = 1;
        goto LABEL_19;
      default:
        if (!HIDWORD(v176))
        {
          if (v17 != 4)
          {
            uint64_t v91 = 0;
            *(_DWORD *)int32x4_t buf = ((__int16)((34953 * v24) >> 16) >> 4)
                           + (((v24 + ((-30583 * v24) >> 16)) & 0x8000) >> 15);
            *(_DWORD *)&uint8_t buf[4] = (__int16)(v24 - 30 * *(_WORD *)buf);
            char v92 = 1;
            do
            {
              char v93 = v92;
              uint64_t v94 = *(int *)&buf[4 * v91];
              switch((int)v17)
              {
                case 0:
                  if ((int)v94 <= 26)
                  {
                    float32x4x2_t v95 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
                    goto LABEL_198;
                  }
                  int v97 = v176;
                  if (v94 == 27) {
                    int v98 = 1;
                  }
                  else {
                    int v98 = v176;
                  }
                  unsigned int v99 = v94 == 27;
                  if (v94 == 28)
                  {
                    int v98 = 2;
                    unsigned int v99 = 2;
                  }
                  if (v94 != 29) {
                    int v97 = v98;
                  }
                  LODWORD(v176) = v97;
                  if (v94 == 29) {
                    uint64_t v17 = 3;
                  }
                  else {
                    uint64_t v17 = v99;
                  }
                  break;
                case 1:
                  if ((int)v94 <= 26)
                  {
                    float32x4x2_t v95 = "abcdefghijklmnopqrstuvwxyz ";
                    goto LABEL_198;
                  }
                  unsigned int v100 = v94 != 27;
                  int v101 = v176;
                  if (v94 == 28) {
                    int v102 = 2;
                  }
                  else {
                    int v102 = v176;
                  }
                  if (v94 == 28) {
                    unsigned int v100 = 2;
                  }
                  if (v94 != 29) {
                    int v101 = v102;
                  }
                  LODWORD(v176) = v101;
                  if (v94 == 29) {
                    uint64_t v17 = 3;
                  }
                  else {
                    uint64_t v17 = v100;
                  }
                  break;
                case 2:
                  if ((int)v94 <= 26 && v94 != 25)
                  {
                    float32x4x2_t v95 = "0123456789&\r\t,:#-.$/+%*=^";
                    goto LABEL_198;
                  }
                  uint64_t v17 = 2;
                  switch((int)v94)
                  {
                    case 25:
                      LODWORD(v176) = 3;
                      goto LABEL_174;
                    case 27:
                      LODWORD(v176) = 1;
                      uint64_t v17 = 1;
                      goto LABEL_199;
                    case 28:
                      goto LABEL_176;
                    case 29:
LABEL_174:
                      uint64_t v17 = 3;
                      break;
                    default:
                      goto LABEL_199;
                  }
                  break;
                case 3:
                  if (v94 == 29)
                  {
LABEL_176:
                    LODWORD(v176) = 0;
                    uint64_t v17 = 0;
                  }
                  else
                  {
LABEL_198:
                    __src[__n] = v95[v94];
                    uint64_t v17 = v176;
                    ++__n;
                  }
                  break;
                default:
                  break;
              }
LABEL_199:
              char v92 = 0;
              uint64_t v91 = 1;
            }
            while ((v93 & 1) != 0);
            HIDWORD(v176) = 0;
            goto LABEL_19;
          }
          if (v24 <= 255)
          {
            HIDWORD(v176) = 0;
            __src[__n] = v24;
            uint64_t v17 = v176;
            ++__n;
            goto LABEL_19;
          }
          goto LABEL_333;
        }
        unsigned int v173 = v17;
        if ((HIDWORD(v176) - 1) > 1)
        {
          if (HIDWORD(v176) != 3)
          {
LABEL_159:
            int v59 = 2;
LABEL_160:
            HIDWORD(v176) = v59;
            goto LABEL_19;
          }
          uint64_t v185 = 0x800000000;
          std::locale __dst = buf;
          *(void *)float v199 = 0x800000000;
          float32x4_t v200 = v196;
          uint64_t v183 = 0x800000000;
          long long v184 = &v197;
          uint64_t v181 = 0x800000000;
          long long v182 = &v198;
          if (v24)
          {
            int v24 = (unsigned __int16)v24;
            LODWORD(v185) = 1;
          }
          *(_DWORD *)int32x4_t buf = v24;
          unint64_t v65 = v9 + 1;
          int v170 = v18;
          unsigned int v168 = i;
          uint64_t v171 = v15;
          size_t v172 = v19;
          if (v9 + 1 >= a3)
          {
            uint64_t v104 = v15;
            size_t v105 = v19;
            float v106 = v196;
            unint64_t v66 = 1;
            goto LABEL_219;
          }
          unint64_t v66 = 1;
          while (1)
          {
            if (v66 > 0xE || *(unsigned __int16 *)(a1 + 2 * v65) > 0x383u) {
              goto LABEL_218;
            }
            if (!v185) {
              goto LABEL_156;
            }
            int v67 = (int)v185 >= 0 ? v185 : -(int)v185;
            float v68 = __dst;
            int v69 = v67;
            while (!*v68)
            {
              ++v68;
              if (!--v69) {
                goto LABEL_156;
              }
            }
            size_t v70 = 4 * (v67 + 1);
            int v177 = v67;
            float v71 = (unsigned int *)off_1EAA94E20(qword_1EAA94E28, 0, v70);
            if (!v71) {
              goto LABEL_156;
            }
            char v72 = v71;
            bzero(v71, v70);
            float v73 = (unsigned int *)__dst;
            if ((int)v185 >= 0) {
              int v74 = v185;
            }
            else {
              int v74 = -(int)v185;
            }
            if (v185)
            {
              unsigned int v75 = 0;
              float v76 = v72;
              float v77 = (unsigned int *)__dst;
              do
              {
                unsigned int v78 = *v77++;
                unint64_t v79 = 900 * v78;
                unint64_t v80 = HIDWORD(v79);
                BOOL v81 = __CFADD__(*v76, v79);
                unsigned int v82 = *v76 + v79;
                int v83 = v81;
                if (v82 < *v76) {
                  int v84 = 1;
                }
                else {
                  int v84 = v83;
                }
                int v85 = v84 + v80;
                BOOL v81 = __CFADD__(v82, v75);
                unsigned int v86 = v82 + v75;
                int v87 = v81;
                if (v86 < v75) {
                  int v88 = 1;
                }
                else {
                  int v88 = v87;
                }
                unsigned int v75 = v85 + v88;
                *v76++ = v86;
                --v74;
              }
              while (v74);
              v72[v177] = v75;
              if (v75)
              {
                if ((v185 & 0x80000000) != 0) {
                  int v89 = v185 - 1;
                }
                else {
                  int v89 = v185 + 1;
                }
                goto LABEL_150;
              }
            }
            else
            {
              v72[v177] = 0;
            }
            int v89 = v185;
LABEL_150:
            if (v72 != v73)
            {
              if (v89 >= 0) {
                unsigned int v90 = v89;
              }
              else {
                unsigned int v90 = -v89;
              }
              memcpy(v73, v72, 4 * v90);
              LODWORD(v185) = v89;
            }
            off_1EAA94E18(qword_1EAA94E28);
LABEL_156:
            sub_1DC3BEAF0(*(unsigned __int16 *)(a1 + 2 * v65), (uint64_t)&v185);
            unint64_t v65 = ++v66 + v9;
            uint64_t v15 = v171;
            size_t v19 = v172;
            if (v66 == a3 - v9)
            {
              unint64_t v66 = a3 - v9;
LABEL_218:
              uint64_t v104 = v15;
              size_t v105 = v19;
              float v106 = v200;
LABEL_219:
              std::string::size_type v20 = a5 - 1;
              unint64_t v9 = v9 + v66 - 1;
              *float v106 = 10;
              *(_DWORD *)float v199 = 1;
              sub_1DC3BF930((uint64_t)v199, (uint64_t)&v183);
              int v115 = 0;
              size_t v116 = __n;
              size_t v19 = v105;
              uint64_t v15 = v104;
              while (2)
              {
                int v18 = v170;
                if (!v185) {
                  goto LABEL_333;
                }
                uint64_t v117 = 0;
                if ((int)v185 >= 0) {
                  unsigned int v118 = v185;
                }
                else {
                  unsigned int v118 = -(int)v185;
                }
                uint64_t i = (uint64_t)__dst;
                if ((((int)v185 & 0x4000000000000000) != 0) ^ __OFSUB__((int)v185, -(uint64_t)(int)v185) | ((int)v185 == -(uint64_t)(int)v185)) {
                  uint64_t v119 = -(uint64_t)(int)v185;
                }
                else {
                  LODWORD(v119) = v185;
                }
                while (!*((_DWORD *)__dst + v117))
                {
                  if (v119 == ++v117)
                  {
                    if (v185 != 1 || *(_DWORD *)__dst != 1) {
                      goto LABEL_333;
                    }
LABEL_324:
                    if (v116 <= __n)
                    {
                      HIDWORD(v176) = 3;
                      __uint64_t n = v116;
                      uint64_t v17 = v173;
                      uint64_t i = v168;
                    }
                    else
                    {
                      size_t v156 = v116 - 1;
                      uint64_t v17 = v173;
                      for (uint64_t i = v168; v156 > __n; ++__n)
                      {
                        char v157 = __src[v156];
                        __src[v156] = __src[__n];
                        __src[__n] = v157;
                        --v156;
                      }
                      HIDWORD(v176) = 3;
                      __uint64_t n = v116;
                    }
                    goto LABEL_19;
                  }
                }
                if (v185 == 1 && *(_DWORD *)__dst == 1) {
                  goto LABEL_324;
                }
                size_t v169 = v116;
                if (__dst != v182)
                {
                  memcpy(v182, __dst, 4 * v118);
                  int v115 = v185;
                  LODWORD(v181) = v185;
                }
                int v120 = v115;
                uint64_t v121 = sub_1DC3BE9C8(v183, v184);
                int v122 = *(_DWORD *)v199;
                if (*(int *)v199 < 0) {
                  int v122 = -*(_DWORD *)v199;
                }
                int v123 = v120;
                if (v120 >= 0) {
                  int v124 = v120;
                }
                else {
                  int v124 = -v120;
                }
                unsigned int v125 = v124 + 4 * v122;
                size_t v189 = 0;
                int32x2_t v190 = 0;
                if (!v125)
                {
                  uint64_t v126 = 0;
                  goto LABEL_244;
                }
                int32x2_t v190 = (void *)off_1EAA94E20(qword_1EAA94E28, 0, 4 * (v124 + 4 * v122));
                if (v190)
                {
                  HIDWORD(v189) = v125;
                  uint64_t v126 = off_1EAA94E20(qword_1EAA94E28, 0, 4 * v125);
                  if (!v126)
                  {
                    uint64_t v127 = 0;
                    goto LABEL_258;
                  }
LABEL_244:
                  uint64_t v167 = v126;
                  LODWORD(v181) = v124;
                  do
                  {
                    if (v182 != v190)
                    {
                      int v128 = v181;
                      if ((int)v181 >= 0) {
                        unsigned int v129 = v181;
                      }
                      else {
                        unsigned int v129 = -(int)v181;
                      }
                      memcpy(v190, v182, 4 * v129);
                      LODWORD(v189) = v128;
                    }
                    if (v121 == 1)
                    {
                      uint64_t v130 = 1;
                      sub_1DC3BF170(1u, (uint64_t)&v189);
                    }
                    else
                    {
                      sub_1DC3BF2D8((v121 - 2), (uint64_t)&v189);
                      uint64_t v130 = v121;
                    }
                    sub_1DC3BF3C8((int *)&v183, (int *)&v189);
                    sub_1DC3BF2D8(v130, (uint64_t)&v189);
                    sub_1DC3BF3C8((int *)v199, (int *)&v189);
                    sub_1DC3BF01C((int *)&v189, (uint64_t)&v181);
                    int v131 = *(_DWORD *)v199;
                    uint64_t v132 = v200;
                    if ((sub_1DC3BEA30((uint64_t)&v181, *(int *)v199, v200) & 0x80000000) == 0)
                    {
                      sub_1DC3BF01C((int *)v199, (uint64_t)&v181);
                      int v131 = *(_DWORD *)v199;
                      uint64_t v132 = v200;
                    }
                  }
                  while ((sub_1DC3BEA30((uint64_t)&v181, v131, v132) & 0x80000000) == 0);
                  if (v123 < 0)
                  {
                    uint64_t v127 = v167;
                    if (v181)
                    {
                      if ((int)v181 >= 0) {
                        int v148 = v181;
                      }
                      else {
                        int v148 = -(int)v181;
                      }
                      uint64_t v149 = v182;
                      while (!*v149)
                      {
                        ++v149;
                        if (!--v148) {
                          goto LABEL_258;
                        }
                      }
                      LODWORD(v181) = -(int)v181;
                      sub_1DC3BEB98((unsigned int *)v199, (uint64_t)&v181);
                    }
                  }
                  else
                  {
                    uint64_t v127 = v167;
                  }
LABEL_258:
                  if (v190) {
                    off_1EAA94E18(qword_1EAA94E28);
                  }
                  size_t v189 = 0;
                  int32x2_t v190 = 0;
                  if (v127) {
                    off_1EAA94E18(qword_1EAA94E28);
                  }
                }
                int v133 = sub_1DC3BE9C8(v183, v184);
                if (v185)
                {
                  if ((int)v185 >= 0) {
                    int v134 = v185;
                  }
                  else {
                    int v134 = -(int)v185;
                  }
                  float v135 = __dst;
                  int v136 = v134;
                  while (!*v135)
                  {
                    ++v135;
                    if (!--v136) {
                      goto LABEL_271;
                    }
                  }
                  if ((int)v185 < 1) {
                    int v137 = -1;
                  }
                  else {
                    int v137 = 1;
                  }
                }
                else
                {
                  int v134 = 0;
LABEL_271:
                  int v137 = 0;
                }
                int v138 = *(_DWORD *)v199;
                if (*(int *)v199 < 0) {
                  int v138 = -*(_DWORD *)v199;
                }
                unsigned int v139 = v134 + 4 * v138;
                uint64_t v187 = 0;
                float v188 = 0;
                size_t v189 = 0;
                int32x2_t v190 = 0;
                int32x2_t v190 = (void *)off_1EAA94E20(qword_1EAA94E28, 0, 4 * v139);
                if (v190)
                {
                  HIDWORD(v189) = v139;
                  float v140 = (_DWORD *)off_1EAA94E20(qword_1EAA94E28, 0, 4 * v139);
                  float v188 = v140;
                  if (v140)
                  {
                    uint64_t v141 = (2 * v133 - 2);
                    HIDWORD(v187) = v139;
                    int v142 = v185;
                    if ((int)v185 < 0) {
                      int v142 = -(int)v185;
                    }
                    LODWORD(v185) = v142;
                    _DWORD *v140 = 0;
                    do
                    {
                      sub_1DC3BF594((uint64_t)&v185, (uint64_t)&v183, (uint64_t)&v189);
                      sub_1DC3BF2D8(v141, (uint64_t)&v189);
                      sub_1DC3BEB98((unsigned int *)&v189, (uint64_t)&v187);
                      sub_1DC3BF3C8((int *)v199, (int *)&v189);
                      sub_1DC3BF01C((int *)&v189, (uint64_t)&v185);
                      int v143 = *(_DWORD *)v199;
                      unsigned int v144 = v200;
                      if ((sub_1DC3BEA30((uint64_t)&v185, *(int *)v199, v200) & 0x80000000) == 0)
                      {
                        sub_1DC3BF01C((int *)v199, (uint64_t)&v185);
                        sub_1DC3BEAF0(1, (uint64_t)&v187);
                        int v143 = *(_DWORD *)v199;
                        unsigned int v144 = v200;
                      }
                    }
                    while ((sub_1DC3BEA30((uint64_t)&v185, v143, v144) & 0x80000000) == 0);
                    float v145 = v188;
                    if (v188 == __dst)
                    {
                      int v146 = v185;
                    }
                    else
                    {
                      int v146 = (int)v187;
                      if ((int)v187 >= 0) {
                        unsigned int v147 = v187;
                      }
                      else {
                        unsigned int v147 = -(int)v187;
                      }
                      memcpy(__dst, v188, 4 * v147);
                    }
                    LODWORD(v185) = v146 * v137;
                  }
                  else
                  {
                    float v145 = 0;
                  }
                  uint64_t i = (uint64_t)v190;
                  if (v190) {
                    off_1EAA94E18(qword_1EAA94E28);
                  }
                  size_t v189 = 0;
                  int32x2_t v190 = 0;
                  if (v145) {
                    off_1EAA94E18(qword_1EAA94E28);
                  }
                }
                int v115 = v181;
                if (v181)
                {
                  uint64_t v150 = 0;
                  LODWORD(v151) = v181;
                  double v152 = (unsigned int *)v182;
                  if ((((int)v181 & 0x4000000000000000) != 0) ^ __OFSUB__((int)v181, -(uint64_t)(int)v181) | ((int)v181 == -(uint64_t)(int)v181)) {
                    uint64_t v151 = -(uint64_t)(int)v181;
                  }
                  uint64_t v15 = v171;
                  size_t v19 = v172;
                  size_t v153 = v169;
                  while (!*((_DWORD *)v182 + v150))
                  {
                    if (v151 == ++v150) {
                      goto LABEL_316;
                    }
                  }
                  if ((v181 & 0x80000000) != 0)
                  {
LABEL_316:
                    unsigned int v154 = 0;
                  }
                  else
                  {
                    int v155 = v181;
                    if (sub_1DC3BE9C8(v181, v182) <= 0x20) {
                      unsigned int v154 = *v152;
                    }
                    else {
                      unsigned int v154 = 0;
                    }
                    uint64_t v15 = v171;
                    size_t v19 = v172;
                    int v115 = v155;
LABEL_319:
                    size_t v153 = v169;
                  }
                  __src[v153] = (v154 % 0xA) | 0x30;
                  size_t v116 = v153 + 1;
                  std::string::size_type v20 = a5 - 1;
                  continue;
                }
                break;
              }
              unsigned int v154 = 0;
              uint64_t v15 = v171;
              size_t v19 = v172;
              goto LABEL_319;
            }
          }
        }
        unint64_t v49 = 0;
        *(_WORD *)&uint8_t buf[8] = 0;
        *(void *)int32x4_t buf = 0;
        do
        {
          unsigned int v50 = *(unsigned __int16 *)(a1 + 2 * v9 + 2 * v49);
          if (v50 > 0x383)
          {
            BOOL v52 = 1;
            unint64_t v51 = v49;
            int v54 = HIDWORD(v176);
LABEL_104:
            unint64_t v63 = v51 % 5;
            if (v54 != 2 || !v63)
            {
              if (v54 != 1) {
                BOOL v52 = 0;
              }
              if (!v63 && !v52)
              {
                uint64_t v64 = v51;
                goto LABEL_210;
              }
              if (v51) {
                goto LABEL_211;
              }
              goto LABEL_214;
            }
            goto LABEL_333;
          }
          *(_WORD *)&buf[2 * v49] = v50;
          unint64_t v51 = v49 + 1;
          BOOL v52 = v49 < 4;
          if (v49 > 3) {
            break;
          }
          unint64_t v53 = v9 + 1 + v49++;
        }
        while (v53 < a3);
        int v54 = HIDWORD(v176);
        if (HIDWORD(v176) != 1 || v51 != 5) {
          goto LABEL_104;
        }
        unint64_t v55 = v9 + 5;
        if (v9 + 5 >= a3)
        {
          int v58 = 0;
        }
        else
        {
          uint64_t v56 = 5;
          while (1)
          {
            int v57 = *(__int16 *)(a1 + 2 * v55);
            if (v57 < 900)
            {
LABEL_206:
              int v58 = 0;
              goto LABEL_207;
            }
            if ((v57 - 903) >= 0xA
              && (unsigned __int16)v57 - 914 >= 4
              && (unsigned __int16)v57 != 919)
            {
              break;
            }
LABEL_71:
            ++v56;
LABEL_72:
            unint64_t v55 = v56 + v9;
            if (v56 + v9 >= a3) {
              goto LABEL_206;
            }
          }
          if ((unsigned __int16)v57 != 913)
          {
            int v58 = 1;
            switch(v57)
            {
              case 900:
              case 901:
              case 902:
              case 922:
              case 923:
              case 924:
              case 928:
                goto LABEL_207;
              case 918:
              case 920:
                goto LABEL_71;
              case 921:
                goto LABEL_333;
              case 925:
              case 927:
                v56 += 2;
                goto LABEL_72;
              case 926:
                v56 += 3;
                goto LABEL_72;
              default:
                goto LABEL_72;
            }
          }
          int v58 = 1;
LABEL_207:
          unint64_t v55 = v56 + v9;
        }
        unint64_t v51 = 5;
        if (v55 < a3)
        {
          uint64_t v64 = 5;
          if (!v58)
          {
LABEL_210:
            unint64_t v107 = 656100000000 * *(__int16 *)buf
                 + 729000000 * *(__int16 *)&buf[2]
                 + 810000 * *(__int16 *)&buf[4]
                 + 900 * *(__int16 *)&buf[6]
                 + *(__int16 *)&buf[8];
            float v108 = &__src[__n];
            uint64x2_t v109 = (uint64x2_t)vdupq_n_s64(v107);
            int32x2_t v110 = vmovn_s64((int64x2_t)vshlq_u64(v109, (uint64x2_t)xmmword_1DC3FDE50));
            int16x8_t v111 = (int16x8_t)vshlq_u64(v109, (uint64x2_t)xmmword_1DC3FDE40);
            *(int32x2_t *)v111.i8 = vmovn_s64((int64x2_t)v111);
            v111.i16[1] = v111.i16[2];
            v111.i16[2] = v110.i16[0];
            v111.i16[3] = v110.i16[2];
            *(_DWORD *)float v108 = vmovn_s16(v111).u32[0];
            void v108[4] = BYTE1(v107);
            __n += 6;
            v108[5] = v107;
            unint64_t v51 = v64;
            goto LABEL_214;
          }
        }
LABEL_211:
        for (uint64_t j = 0; j != v51; ++j)
          __src[__n + j] = *(_WORD *)&buf[2 * j];
        __n += j;
LABEL_214:
        uint64_t v17 = v173;
        BOOL v81 = v51 != 0;
        unint64_t v113 = v51 - 1;
        if (!v81) {
          unint64_t v113 = 0;
        }
        v9 += v113;
LABEL_19:
        if (v22 != i)
        {
          if (v15 != -1)
          {
            size_t v25 = v19;
            uint64_t v26 = v17;
            MEMORY[0x1E019D390](v15);
            uint64_t v17 = v26;
            size_t v19 = v25;
          }
          uint64_t v27 = 0;
          float v28 = dword_1E6C3AF88;
          while (1)
          {
            int v29 = *v28;
            v28 += 4;
            if (v29 == v22) {
              break;
            }
            if (++v27 == 32) {
              goto LABEL_27;
            }
          }
          if ((unint64_t)(v27 - 27) < 5)
          {
LABEL_27:
            __uint64_t n = 0;
            uint64_t v15 = -1;
            uint64_t i = v22;
            goto LABEL_36;
          }
          uint64_t v30 = v17;
          size_t v31 = v19;
          float v32 = *(const char **)&dword_1E6C3AF88[4 * v27 + 2];
          uint64_t v33 = MEMORY[0x1E019D3A0]("UTF-8", v32);
          if (v33 == -1)
          {
            if (qword_1EAA94CD0 != -1) {
              dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
            }
            float v34 = qword_1EAA94CC8;
            if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR))
            {
              int v103 = *__error();
              *(_DWORD *)int32x4_t buf = 136446722;
              *(void *)&uint8_t buf[4] = "UTF-8";
              __int16 v192 = 2082;
              int v193 = v32;
              __int16 v194 = 1026;
              int v195 = v103;
              _os_log_error_impl(&dword_1DC2FE000, v34, OS_LOG_TYPE_ERROR, "[PDF417] iconv_open(\"%{public}s\", \"%{public}s\") failed: %{public, errno}d", buf, 0x1Cu);
            }
            __uint64_t n = 0;
            uint64_t v15 = -1;
          }
          else
          {
            uint64_t v15 = v33;
            __uint64_t n = 0;
          }
          uint64_t i = v22;
          std::string::size_type v20 = a5 - 1;
          size_t v19 = v31;
          uint64_t v17 = v30;
        }
LABEL_36:
        if (v179)
        {
LABEL_37:
          __uint64_t n = 0;
          int v35 = 0;
          goto LABEL_98;
        }
        if (v18)
        {
          if (__n)
          {
            size_t v43 = v19;
            uint64_t v44 = i;
            uint64_t v45 = v17;
            uint64_t v46 = v15;
            memcpy(&a4[v19], __src, __n);
            uint64_t i = v44;
            uint64_t v15 = v46;
            uint64_t v17 = v45;
            int v35 = 0;
            size_t v19 = __n + v43;
            int v18 = 1;
            __uint64_t n = 0;
          }
          else
          {
            __uint64_t n = 0;
            int v35 = 0;
            int v18 = 1;
          }
          goto LABEL_98;
        }
        if (v15 == -1)
        {
          int v18 = 0;
          goto LABEL_37;
        }
        uint64_t v36 = i;
        uint64_t v37 = v17;
        *(void *)int32x4_t buf = __src;
        size_t v189 = __n;
        float v38 = &a4[v19];
        uint64_t v187 = &a4[v19];
        uint64_t v185 = v23;
        size_t v39 = v19;
        uint64_t v40 = v15;
        uint64_t v41 = MEMORY[0x1E019D380](v15, buf, &v189, &v187, &v185);
        size_t v42 = v187 - v38 + v39;
        if (v41 == -1)
        {
          int v47 = *__error();
          if (v47 == 7)
          {
            int v35 = 31;
          }
          else
          {
            if (v47 == 22) {
              goto LABEL_43;
            }
            if (qword_1EAA94CD0 != -1) {
              dispatch_once(&qword_1EAA94CD0, &unk_1F365F980);
            }
            float v48 = qword_1EAA94CC8;
            if (os_log_type_enabled((os_log_t)qword_1EAA94CC8, OS_LOG_TYPE_ERROR))
            {
              int v114 = *__error();
              *(_DWORD *)float v199 = 67240192;
              *(_DWORD *)&v199[4] = v114;
              int v35 = 8;
              _os_log_error_impl(&dword_1DC2FE000, v48, OS_LOG_TYPE_ERROR, "[PDF417] iconv failed: %{public, errno}d", v199, 8u);
            }
            else
            {
              int v35 = 8;
            }
          }
          std::string::size_type v20 = a5 - 1;
          size_t v19 = v42;
          uint64_t v17 = v37;
          int v18 = 0;
          uint64_t v15 = v40;
          uint64_t i = v36;
          goto LABEL_98;
        }
LABEL_43:
        if (v189)
        {
          __memmove_chk();
          __uint64_t n = v189;
        }
        else
        {
          __uint64_t n = 0;
        }
        std::string::size_type v20 = a5 - 1;
        size_t v19 = v42;
        uint64_t v17 = v37;
        uint64_t v15 = v40;
        uint64_t i = v36;
        int v18 = 0;
        int v35 = 0;
LABEL_98:
        ++v9;
        if (!v35) {
          continue;
        }
        int8x8_t v158 = a4;
        if (v35 != 8)
        {
LABEL_345:
          unint64_t v160 = v174;
          goto LABEL_346;
        }
LABEL_333:
        uint64_t v7 = 0;
LABEL_351:
        if (v15 != -1) {
          MEMORY[0x1E019D390](v15, i);
        }
        return v7;
    }
  }
}

double sub_1DC3EFBE0()
{
  zone = malloc_create_zone(0, 0);
  qword_1EAA94EA0 = (uint64_t)zone;
  if (!zone)
  {
    perror("malloc_create_zone");
    zone = (malloc_zone_t *)qword_1EAA94EA0;
  }
  double result = *(double *)&xmmword_1F36625E8;
  unk_1EAA94E10 = xmmword_1F36625E8;
  off_1EAA94E20 = (uint64_t (*)(void, void, void))off_1F36625F8;
  qword_1EAA94E28 = (uint64_t)zone;
  return result;
}

void *sub_1DC3EFC50(malloc_zone_t *a1, void *a2, size_t a3)
{
  return malloc_type_zone_realloc(a1, a2, a3, 0x3C15DCA2uLL);
}

void *sub_1DC3EFC60(malloc_zone_t *a1, size_t a2)
{
  return malloc_type_zone_malloc(a1, a2, 0xE5344F27uLL);
}

FFTSetup sub_1DC3EFC6C(uint64_t a1, vDSP_Length __Log2n)
{
  unsigned int v2 = __Log2n;
  *(_DWORD *)a1 = 1 << __Log2n;
  *(_DWORD *)(a1 + 4) = __Log2n;
  int v4 = *(OpaqueFFTSetup **)(a1 + 8);
  if (v4) {
    vDSP_destroy_fftsetup(v4);
  }
  FFTSetup result = vDSP_create_fftsetup(v2, 0);
  *(void *)(a1 + 8) = result;
  return result;
}

FFTSetup sub_1DC3EFCB8()
{
  uint64_t v0 = malloc_type_malloc(0x10uLL, 0x10200405730B0C9uLL);
  qword_1EAA94EA8 = (uint64_t)v0;
  v0[1] = 0;
  return sub_1DC3EFC6C((uint64_t)v0, 0xDuLL);
}

uint64_t sub_1DC3EFD04(float *a1, float *a2, float *a3, float *a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  float v12 = a7 - a5;
  float v13 = a8 - a6;
  float v14 = a11 - a9;
  float v15 = a12 - a10;
  float v16 = (float)(v12 * (float)(a12 - a10)) - (float)(v14 * v13);
  if (v16 == 0.0) {
    return 0;
  }
  float v18 = a5 - a9;
  float v19 = a6 - a10;
  float v20 = (float)((float)(v12 * v19) - (float)(v13 * v18)) / v16;
  float v21 = (float)((float)(v14 * v19) - (float)(v15 * v18)) / v16;
  BOOL v24 = v21 < 0.0 || v20 > 1.0 || v20 < 0.0 || v21 > 1.0;
  *a1 = a5 + (float)(v21 * v12);
  *a2 = a6 + (float)(v21 * v13);
  if (v24) {
    uint64_t result = 1;
  }
  else {
    uint64_t result = 2;
  }
  *a3 = v21;
  *a4 = v20;
  return result;
}

uint64_t sub_1DC3EFD88(float *a1, float *a2, float *a3, float *a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  *a1 = a5;
  *a2 = a6;
  *a3 = a7;
  *a4 = a8;
  if (a5 >= a9 && a5 <= a10 && a8 >= a11 && a8 <= a12 && a7 >= a9 && a7 <= a10 && a6 >= a11 && a6 <= a12) {
    return 1;
  }
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  int v31 = sub_1DC3EFD04((float *)&v48 + 1, (float *)&v48, &v44, &v43, a9, a11, a9, a12, a5, a6, a7, a8);
  int v32 = sub_1DC3EFD04((float *)&v47 + 1, (float *)&v47, &v42, &v41, a10, a11, a10, a12, a5, a6, a7, a8);
  int v33 = sub_1DC3EFD04((float *)&v46 + 1, (float *)&v46, &v40, &v39, a9, a11, a10, a11, a5, a6, a7, a8);
  int v34 = sub_1DC3EFD04((float *)&v45 + 1, (float *)&v45, &v38, &v37, a9, a12, a10, a12, a5, a6, a7, a8);
  uint64_t v35 = 0;
  if (v31 == 2)
  {
    if (a7 < a9 || a5 >= a9)
    {
      *a3 = *((float *)&v48 + 1);
      *(_DWORD *)a4 = v48;
    }
    else
    {
      *a1 = *((float *)&v48 + 1);
      *(_DWORD *)a2 = v48;
    }
    uint64_t v35 = 1;
  }
  if (v32 == 2)
  {
    if (a7 > a10 || a5 <= a10)
    {
      *a3 = *((float *)&v47 + 1);
      *(_DWORD *)a4 = v47;
    }
    else
    {
      *a1 = *((float *)&v47 + 1);
      *(_DWORD *)a2 = v47;
    }
    uint64_t v35 = 1;
  }
  if (v33 == 2)
  {
    if (a8 < a11 || a6 >= a11)
    {
      *a3 = *((float *)&v46 + 1);
      *(_DWORD *)a4 = v46;
    }
    else
    {
      *a1 = *((float *)&v46 + 1);
      *(_DWORD *)a2 = v46;
    }
    uint64_t v35 = 1;
  }
  if (v34 == 2)
  {
    if (a8 > a12 || a6 <= a12)
    {
      *a3 = *((float *)&v45 + 1);
      *(_DWORD *)a4 = v45;
    }
    else
    {
      *a1 = *((float *)&v45 + 1);
      *(_DWORD *)a2 = v45;
    }
    return 1;
  }
  return v35;
}

float sub_1DC3F0024(float *a1, float *a2, float *a3, float *a4, float result, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  float v12 = a8 - a6;
  float v13 = a7 - result;
  if ((float)(a7 - result) != 0.0 || v12 != 0.0)
  {
    if (a6 < a11 || (v12 == 0.0 ? (BOOL v14 = a6 > a12) : (BOOL v14 = 1), v14))
    {
      if (result < a9 || (v13 == 0.0 ? (BOOL v17 = result > a10) : (BOOL v17 = 1), v17))
      {
        uint64_t v19 = 0;
        int v20 = 0;
        *(float *)float v42 = a9;
        *(float *)&v42[1] = a10;
        uint64_t v43 = 0;
        uint64_t v39 = 0;
        float v40 = a11;
        float v41 = a12;
        uint64_t v37 = -1;
        unint64_t v38 = -1;
        char v21 = 1;
        int v22 = -1;
        int v23 = -1;
        do
        {
          char v24 = v21;
          if (*((_DWORD *)&v37 + v19) == -1)
          {
            float v25 = (float)(a6 - (float)((float)(v12 / v13) * result)) + (float)((float)(v12 / v13) * *(float *)&v42[v19]);
            *((float *)&v39 + v19) = v25;
            int v26 = v25 >= a11;
            if (v25 == a11) {
              int v23 = 0;
            }
            if (v25 > a12) {
              int v26 = 0;
            }
            *((_DWORD *)&v37 + v19) = v26;
            if (v25 == a12) {
              int v22 = 0;
            }
            v20 += v26;
          }
          char v21 = 0;
          uint64_t v19 = 1;
        }
        while ((v24 & 1) != 0);
        char v27 = 0;
        unint64_t v38 = __PAIR64__(v22, v23);
        uint64_t result = result - (float)((float)(v13 / v12) * a6);
        uint64_t v28 = 2;
        do
        {
          char v29 = v27;
          if (*((_DWORD *)&v37 + v28) == -1)
          {
            float v30 = result + (float)((float)(v13 / v12) * *((float *)&v39 + v28));
            *(float *)&v42[v28] = v30;
            int v31 = v30 >= a9;
            if (v30 > a10) {
              int v31 = 0;
            }
            *((_DWORD *)&v37 + v28) = v31;
            v20 += v31;
          }
          char v27 = 1;
          uint64_t v28 = 3;
        }
        while ((v29 & 1) == 0);
        if (v20 == 2)
        {
          uint64_t v32 = 0;
          while (!*((_DWORD *)&v37 + v32))
          {
            if (++v32 == 4) {
              goto LABEL_49;
            }
          }
          *a1 = *(float *)&v42[v32];
          *a2 = *((float *)&v39 + v32);
LABEL_49:
          uint64_t v33 = v32;
          if (v32 <= 3) {
            uint64_t v32 = 3;
          }
          else {
            uint64_t v32 = v32;
          }
          while (v32 != v33)
          {
            uint64_t v34 = v33 + 1;
            if (*((_DWORD *)&v37 + ++v33))
            {
              *a3 = *(float *)&v42[v34];
              *a4 = *((float *)&v39 + v34);
              break;
            }
          }
          uint64_t result = *a3;
          float v36 = *a1;
          if ((__PAIR64__(v13 > 0.0, LODWORD(v13)) - COERCE_UNSIGNED_INT(0.0)) >> 32 != (__PAIR64__((float)(*a3 - *a1) > 0.0, *a3 - *a1)- COERCE_UNSIGNED_INT(0.0)) >> 32|| (__PAIR64__(v12 > 0.0, LODWORD(v12)) - COERCE_UNSIGNED_INT(0.0)) >> 32 != (__PAIR64__((float)(*a4 - *a2) > 0.0, *a4 - *a2)- COERCE_UNSIGNED_INT(0.0)) >> 32)
          {
            *a1 = result;
            *a3 = v36;
            uint64_t result = *a2;
            *a2 = *a4;
            *a4 = result;
          }
        }
      }
      else
      {
        *a1 = result;
        *a3 = a7;
        if (a6 >= a8) {
          uint64_t result = a12;
        }
        else {
          uint64_t result = a11;
        }
        if (a6 >= a8) {
          float v18 = a11;
        }
        else {
          float v18 = a12;
        }
        *a2 = result;
        *a4 = v18;
      }
    }
    else
    {
      *a2 = a6;
      *a4 = a8;
      BOOL v15 = result < a7;
      if (result >= a7) {
        uint64_t result = a10;
      }
      else {
        uint64_t result = a9;
      }
      if (v15) {
        float v16 = a10;
      }
      else {
        float v16 = a9;
      }
      *a1 = result;
      *a3 = v16;
    }
  }
  return result;
}

unint64_t sub_1DC3F02E0(unint64_t result, unint64_t a2, float *a3, unsigned int a4, float *a5, float *a6, float *a7)
{
  float v7 = (float)result;
  LODWORD(result) = 1;
  uint64_t v8 = a4;
  do
  {
    int v9 = result;
    float v10 = *a5 - a3[5];
    float v11 = (float)((float)(a3[2] * 0.0) + (float)(a3[1] * v10)) + a3[7];
    float v12 = a3[8] - (float)((float)(a3[4] * 0.0) + (float)(a3[3] * v10));
    *a6 = v11;
    *a7 = v12;
    uint64_t result = 0;
    if (v9 && v11 >= 0.0)
    {
      BOOL v13 = v11 < v7;
      if (v12 < 0.0) {
        BOOL v13 = 0;
      }
      uint64_t result = v12 < (float)a2 && v13;
    }
    ++a7;
    ++a6;
    ++a5;
    --v8;
  }
  while (v8);
  return result;
}

uint64_t sub_1DC3F0370(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float **a5, float *a6, float a7, float a8, float a9, float a10, float a11)
{
  float v11 = a9 - a7;
  float v12 = a10 - a8;
  int v13 = (int)(float)(a9 - a7);
  int v14 = (int)(float)(a10 - a8);
  if (!(v13 | v14)) {
    return 0;
  }
  float v26 = atan2f(a10 - a8, v11);
  unsigned int v27 = vcvtms_s32_f32(sqrtf((float)(v12 * v12) + (float)(v11 * v11)));
  if ((v27 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v96 = a3;
  unsigned int v99 = a5;
  float v100 = a9;
  float v28 = (float)(a7 + a9) * 0.5;
  float v97 = a10;
  float v98 = v26;
  float v101 = a8;
  float v29 = (float)(a8 + a10) * 0.5;
  size_t v30 = v27 + 1;
  __float2 v31 = __sincosf_stret(v26);
  float v32 = -v31.__sinval;
  float v33 = fmaxf(a11, 1.0);
  float v34 = ceilf(v33);
  int v35 = vcvtps_s32_f32(v33);
  float v36 = (float *)malloc_type_calloc(v30, 4uLL, 0x100004052888210uLL);
  uint64_t v37 = (int *)malloc_type_calloc(v30, 4uLL, 0x100004052888210uLL);
  uint64_t v45 = v37;
  float v46 = (float)((float)(int)v30 + -1.0) * 0.5;
  float v47 = (float)((float)(int)v34 + -1.0) * 0.5;
  if (v13)
  {
    if (v14)
    {
      float v48 = v97;
      if (v35 >= 1)
      {
        int v49 = 0;
        unint64_t v50 = a2 - 1;
        unint64_t v51 = v96 - 1;
        do
        {
          uint64_t v52 = 0;
          float v53 = v47 - (float)v49;
          float v54 = v31.__sinval * v53;
          float v55 = v31.__cosval * v53;
          do
          {
            float v56 = (float)(int)v52 - v46;
            float v57 = v28 + (float)(v54 + (float)(v31.__cosval * v56));
            LODWORD(v38) = vcvtmd_s64_f64(v57);
            if ((v38 & 0x80000000) == 0 && v50 >= v38)
            {
              LODWORD(v39) = vcvtpd_s64_f64(v57);
              if ((v39 & 0x80000000) == 0 && v50 >= v39)
              {
                float v58 = v29 - (float)(v55 + (float)(v32 * v56));
                LODWORD(v40) = vcvtmd_s64_f64(v58);
                if ((v40 & 0x80000000) == 0 && v51 >= v40)
                {
                  LODWORD(v41) = vcvtpd_s64_f64(v58);
                  if ((v41 & 0x80000000) == 0 && v51 >= v41)
                  {
                    float v59 = v57 - (float)(int)v38;
                    *(float *)&unsigned int v60 = (float)(int)v40;
                    float v61 = v58 - (float)(int)v40;
                    uint64_t v62 = a1 + v40 * a4;
                    LOBYTE(v60) = *(unsigned char *)(v62 + v38);
                    LOBYTE(v42) = *(unsigned char *)(v62 + v39);
                    uint64_t v40 = a1 + v41 * a4;
                    LOBYTE(v43) = *(unsigned char *)(v40 + v38);
                    float v43 = (float)LODWORD(v43);
                    LOBYTE(v44) = *(unsigned char *)(v40 + v39);
                    float v44 = (float)LODWORD(v44);
                    float v63 = (float)(v59 * (float)LODWORD(v42)) + (float)((float)(1.0 - v59) * (float)v60);
                    float v42 = 1.0 - v61;
                    v36[v52] = v36[v52]
                             + (float)((float)(v61 * (float)((float)(v59 * v44) + (float)((float)(1.0 - v59) * v43)))
                                     + (float)((float)(1.0 - v61) * v63));
                    uint64_t v38 = (v37[v52] + 1);
                    v37[v52] = v38;
                  }
                }
              }
            }
            ++v52;
          }
          while (v30 != v52);
          ++v49;
        }
        while (v49 != v35);
      }
    }
    else
    {
      int v76 = (int)v101;
      if (v35 >= 0) {
        int v77 = v35;
      }
      else {
        int v77 = v35 + 1;
      }
      unint64_t v78 = (v76 - (v77 >> 1)) & ~((v76 - (v77 >> 1)) >> 31);
      unint64_t v79 = v76 + (v77 >> 1);
      if (v96 - 1 >= v79) {
        unint64_t v80 = v79;
      }
      else {
        unint64_t v80 = v96 - 1;
      }
      float v48 = v97;
      if (v80 >= v78)
      {
        float v81 = a7;
        unsigned int v82 = (unsigned char *)(a1 + a4 * v78 + (int)a7);
        do
        {
          int v83 = v82;
          int v84 = v36;
          int v85 = v37;
          size_t v86 = v30;
          do
          {
            LOBYTE(v81) = *v83;
            float v81 = *v84 + (float)LODWORD(v81);
            *v84++ = v81;
            ++*v85++;
            v83 += (v11 > 0.0) - (unint64_t)(v11 < 0.0);
            --v86;
          }
          while (v86);
          v82 += a4;
          BOOL v75 = v78++ == v80;
        }
        while (!v75);
      }
    }
  }
  else
  {
    int v65 = (int)a7;
    if (v35 >= 0) {
      int v66 = v35;
    }
    else {
      int v66 = v35 + 1;
    }
    unint64_t v67 = (v65 - (v66 >> 1)) & ~((v65 - (v66 >> 1)) >> 31);
    unint64_t v68 = v65 + (v66 >> 1);
    if (a2 - 1 >= v68) {
      unint64_t v69 = v68;
    }
    else {
      unint64_t v69 = a2 - 1;
    }
    float v48 = v97;
    if (v69 >= v67)
    {
      float v70 = v101;
      do
      {
        uint64_t v71 = a1 + a4 * (int)v101;
        char v72 = v36;
        float v73 = v37;
        size_t v74 = v30;
        do
        {
          LOBYTE(v70) = *(unsigned char *)(v71 + v67);
          float v70 = *v72 + (float)LODWORD(v70);
          *v72++ = v70;
          ++*v73++;
          v71 += a4 * ((v12 > 0.0) - (unint64_t)(v12 < 0.0));
          --v74;
        }
        while (v74);
        BOOL v75 = v67++ == v69;
      }
      while (!v75);
    }
  }
  uint64_t v87 = 0;
  int v88 = 0;
  do
  {
    int v89 = v37[v87];
    if (v89 < 1) {
      ++v88;
    }
    else {
      v36[v87] = v36[v87] / (float)v89;
    }
    ++v87;
  }
  while (v30 != v87);
  uint64_t v64 = (v30 - v88);
  float v90 = v47;
  if (v88 < 1 || (int)v64 <= 0)
  {
    char v92 = v36;
  }
  else
  {
    uint64_t v91 = (float *)malloc_type_malloc(4 * (v30 - v88), 0x100004052888210uLL);
    char v92 = v91;
    uint64_t v93 = 0;
    int v94 = 0;
    do
    {
      if (v45[v93] >= 1) {
        v91[v94++] = v36[v93];
      }
      ++v93;
    }
    while (v30 != v93);
    free(v36);
  }
  free(v45);
  if (!v64)
  {
    free(v92);
    char v92 = 0;
  }
  *unsigned int v99 = v92;
  *a6 = v98;
  a6[1] = v31.__cosval;
  a6[2] = v31.__sinval;
  a6[3] = v32;
  a6[4] = v31.__cosval;
  a6[5] = v46;
  a6[6] = v90;
  a6[7] = v28;
  a6[8] = v29;
  a6[9] = a7;
  a6[10] = v101;
  a6[11] = v100;
  a6[12] = v48;
  return v64;
}

uint64_t sub_1DC3F0878(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, float **a5, float *a6, float a7, float a8, float a9, float a10, float a11)
{
  uint64_t result = 0;
  if (a2 >= 3 && a3 >= 3)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t result = sub_1DC3EFD88((float *)&v20 + 1, (float *)&v20, (float *)&v19 + 1, (float *)&v19, a7, a8, a9, a10, 1.0, (float)(a2 - 2), 1.0, (float)(a3 - 2));
    if (result) {
      return sub_1DC3F0370(a1, a2, a3, a4, a5, a6, *((float *)&v20 + 1), *(float *)&v20, *((float *)&v19 + 1), *(float *)&v19, a11);
    }
  }
  return result;
}

uint64_t sub_1DC3F0940(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, float **a5, float *a6, float a7, float a8, float a9, float a10, float a11)
{
  uint64_t result = 0;
  if (a2 >= 3 && a3 >= 3)
  {
    float v21 = a9 * 0.5;
    __float2 v22 = __sincosf_stret(a10);
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t result = sub_1DC3EFD88((float *)&v24 + 1, (float *)&v24, (float *)&v23 + 1, (float *)&v23, a7 - (float)(v21 * v22.__cosval), a8 - (float)(v21 * v22.__sinval), (float)(v21 * v22.__cosval) + a7, (float)(v21 * v22.__sinval) + a8, 1.0, (float)(a2 - 2), 1.0, (float)(a3 - 2));
    if (result) {
      return sub_1DC3F0370(a1, a2, a3, a4, a5, a6, *((float *)&v24 + 1), *(float *)&v24, *((float *)&v23 + 1), *(float *)&v23, a11);
    }
  }
  return result;
}

float *sub_1DC3F0A40(float *result, int a2)
{
  if (a2 >= 1)
  {
    uint64_t v2 = a2;
    float v3 = INFINITY;
    float v4 = -INFINITY;
    int v5 = result;
    uint64_t v6 = a2;
    do
    {
      float v7 = *v5++;
      float v8 = v7;
      if (v7 < v3) {
        float v3 = v8;
      }
      if (v8 > v4) {
        float v4 = v8;
      }
      --v6;
    }
    while (v6);
    float v9 = v4 - v3;
    if (v9 == 0.0)
    {
      do
      {
        *result++ = 0.5;
        --v2;
      }
      while (v2);
    }
    else
    {
      do
      {
        *uint64_t result = (float)((float)(*result - v3) / v9) + 0.0;
        ++result;
        --v2;
      }
      while (v2);
    }
  }
  return result;
}

float sub_1DC3F0AD4(uint64_t a1, float *a2, unsigned int a3)
{
  double v3 = *a2;
  double v4 = 0.0;
  if (a3 >= 2)
  {
    for (uint64_t i = 1; i != a3; v4 = v4 + (float)(v6 * (float)i++))
    {
      float v6 = a2[i];
      double v3 = v3 + v6;
    }
  }
  float v7 = 1.0 / (float)a3;
  if (a3)
  {
    uint64_t v8 = 0;
    float v9 = (float)(a3 - 1) * 0.5;
    float v10 = (float)((float)(v7 * 0.16667) * (float)((a3 - 1) * a3 * (2 * a3 - 1))) - (float)(v9 * v9);
    double v11 = v3 * v7;
    double v12 = v9;
    double v13 = (v7 * v4 - v11 * v12) / v10;
    double v14 = v11 - v13 * v12;
    float v15 = 0.0;
    float v16 = 0.0;
    do
    {
      float v17 = v14 + v13 * (double)v8;
      float v18 = a2[v8] - v17;
      *(float *)(a1 + 4 * v8) = v18;
      float v16 = v16 + v18;
      float v15 = v15 + (float)(v18 * v18);
      ++v8;
    }
    while (a3 != v8);
  }
  else
  {
    float v16 = 0.0;
    float v15 = 0.0;
  }
  return (float)(v7 * v15) - (float)(v16 * v16);
}

_DWORD *sub_1DC3F0BD0(float *a1, signed int a2, int a3, int *a4, void **a5, void *a6)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  size_t v12 = 4 * a2;
  double v13 = malloc_type_malloc(v12, 0x100004052888210uLL);
  double v14 = (float *)malloc_type_malloc(v12, 0x100004052888210uLL);
  double v15 = *a1;
  double v16 = v15 * v15;
  *double v13 = *(_DWORD *)a1;
  float v17 = v15 * v15;
  *double v14 = v17;
  if (a2 >= 2)
  {
    unsigned int v18 = 2;
    unint64_t v19 = 1;
    do
    {
      double v20 = a1[v19];
      double v15 = v15 + v20;
      double v16 = v16 + v20 * v20;
      *(float *)&double v20 = v15;
      v13[v19] = LODWORD(v20);
      *(float *)&double v20 = v16;
      v14[v19] = *(float *)&v20;
      unint64_t v19 = v18++;
    }
    while (v19 < a2);
  }
  uint64_t v57 = 0;
  memset(v56, 0, sizeof(v56));
  uint64_t v55 = 0;
  memset(v54, 0, sizeof(v54));
  int v21 = a2 - 2 * a3;
  int v22 = -1;
  if (((2 * a3) | 1) >= v21)
  {
    LOBYTE(v24) = 0;
  }
  else
  {
    uint64_t v23 = 0;
    int v24 = 0;
    int v25 = 0;
    int v26 = 0;
    int v27 = v21 - 1;
    float v28 = *(float *)&v13[2 * a3];
    float v29 = v14[2 * a3];
    float v30 = 1.0 / (float)((float)(2 * a3) + 1.0);
    int v31 = ~(4 * a3) + a2;
    uint64_t v32 = ~(uint64_t)(2 * a3) + v27;
    uint64_t v33 = 8 * a3 + 4;
    float v34 = (char *)v14 + v33;
    uint64_t v35 = (16 * a3) | 4;
    float v36 = (char *)v14 + v35;
    uint64_t v37 = (char *)v13 + v35;
    int v38 = 2 * a3 + 1;
    uint64_t v39 = (char *)v13 + v33;
    do
    {
      float v40 = *(float *)&v37[4 * v23] - v28;
      float v28 = *(float *)&v39[4 * v23];
      float v41 = v30 * (float)(v28 - *(float *)&v13[(int)v23]);
      float v42 = v30 * v40;
      float v43 = *(float *)&v36[4 * v23] - v29;
      float v29 = *(float *)&v34[4 * v23];
      float v44 = (float)(v30 * v43) - (float)(v42 * v42);
      double v45 = (float)((float)(v30 * (float)(v29 - v14[(int)v23])) - (float)(v41 * v41));
      double v46 = v44;
      if (v46 * 50.0 >= v45 || v41 * 1.2 >= v42) {
        v24 &= v25 ^ 1;
      }
      int v47 = v38 + v23;
      if (v45 * 50.0 >= v46 || v42 * 1.2 >= v41)
      {
        BOOL v48 = v26;
        int v26 = 0;
      }
      else
      {
        if ((v26 & 1) == 0)
        {
          v22 += (v24 & 1) == 0;
          if (v22 <= 9) {
            *((_DWORD *)v56 + v22) = v47;
          }
        }
        BOOL v48 = v32 == v23;
        int v26 = 1;
      }
      v24 |= v48;
      int v25 = (v22 < 0) & v25;
      if (v46 * 50.0 < v45 && (v22 & 0x80000000) == 0)
      {
        if (v41 * 1.2 >= v42)
        {
          int v25 = 0;
        }
        else
        {
          if v22 <= 9 && (v24) {
            *((_DWORD *)v54 + v22) = v47;
          }
          int v24 = (v32 != v23) & v24;
          int v25 = 1;
        }
      }
      ++v23;
    }
    while (v31 != v23);
  }
  int v49 = v22 + ((v24 & 1) == 0);
  free(v14);
  free(v13);
  if (v49 >= 10) {
    size_t v50 = 10;
  }
  else {
    size_t v50 = v49;
  }
  *a4 = v50;
  if (v49 <= 0)
  {
    *a4 = 1;
    *a5 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
    uint64_t result = malloc_type_calloc(*a4, 4uLL, 0x100004052888210uLL);
    *a6 = result;
    *(_DWORD *)*a5 = 0;
    *uint64_t result = a2 - 1;
  }
  else
  {
    *a5 = malloc_type_calloc(v50, 4uLL, 0x100004052888210uLL);
    uint64_t result = malloc_type_calloc(*a4, 4uLL, 0x100004052888210uLL);
    *a6 = result;
    if (*a4 >= 1)
    {
      uint64_t v52 = 0;
      float v53 = *a5;
      do
      {
        v53[v52] = *((_DWORD *)v56 + v52);
        result[v52] = *((_DWORD *)v54 + v52);
        ++v52;
      }
      while (v52 < *a4);
    }
  }
  return result;
}

float *sub_1DC3F0FCC(float *a1, int a2, float *a3, float *a4)
{
  *a3 = sub_1DC3F0AD4((uint64_t)a1, a1, a2);
  uint64_t result = sub_1DC3F0A40(a1, a2);
  int v8 = 0;
  if (a2 <= 3) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = a2;
  }
  float v11 = *a1;
  float v10 = a1 + 1;
  float v12 = v11;
  uint64_t v13 = v9 - 1;
  do
  {
    float v14 = *v10++;
    float v15 = v14;
    if (vabds_f32(v14, v12) > 0.2) {
      ++v8;
    }
    float v12 = v15;
    --v13;
  }
  while (v13);
  *a4 = (float)v8 / (float)(v9 - 1);
  return result;
}

float *sub_1DC3F106C(float *result, int a2, int a3, int a4)
{
  if (a4 <= a2 && (a3 & 0x80000000) == 0)
  {
    int v5 = a4 - a3;
    if (a4 > a3)
    {
      float v6 = &result[a3];
      int v7 = v5 + 1;
      sub_1DC3F0AD4((uint64_t)v6, v6, v5 + 1);
      return sub_1DC3F0A40(v6, v7);
    }
  }
  return result;
}

uint64_t AppC3DConfigCreate()
{
  return MEMORY[0x1F4108838]();
}

uint64_t AppC3DConfigRelease()
{
  return MEMORY[0x1F4108840]();
}

uint64_t AppC3DConfigSetANEFallbackDevice()
{
  return MEMORY[0x1F4108848]();
}

uint64_t AppC3DConfigSetTrackingConfig()
{
  return MEMORY[0x1F4108858]();
}

uint64_t AppC3DConfigSetTrackingMode()
{
  return MEMORY[0x1F4108860]();
}

uint64_t AppC3DCreate()
{
  return MEMORY[0x1F4108868]();
}

uint64_t AppC3DFlush()
{
  return MEMORY[0x1F4108870]();
}

uint64_t AppC3DProcessCameraFrameData()
{
  return MEMORY[0x1F4108880]();
}

uint64_t AppC3DRelease()
{
  return MEMORY[0x1F4108888]();
}

uint64_t AppC3DSetUpdateCallback()
{
  return MEMORY[0x1F4108898]();
}

uint64_t AppC3DTrackingResultCreateCorners()
{
  return MEMORY[0x1F41088A8]();
}

uint64_t AppC3DTrackingResultCreateData()
{
  return MEMORY[0x1F41088B0]();
}

uint64_t AppC3DTrackingResultGetConfidence()
{
  return MEMORY[0x1F41088B8]();
}

uint64_t AppC3DTrackingResultGetDataVersion()
{
  return MEMORY[0x1F41088C0]();
}

uint64_t AppC3DTrackingResultGetMetadata()
{
  return MEMORY[0x1F41088D0]();
}

uint64_t AppC3DTrackingResultGetNumberOfTrackingData()
{
  return MEMORY[0x1F41088D8]();
}

uint64_t AppC3DWait()
{
  return MEMORY[0x1F41088F0]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  return (CFAllocatorRef)MEMORY[0x1F40D70F8](allocator, context);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7178](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D71C8](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1F40D7450](bundle);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x1F40D7528](allocator, bundleURL);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1F40D77A8](cf);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1F40D77F8](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7808](allocator, capacity);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1F40D7818](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1F40D7858](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7A90](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1F40D7A98](allocator, domain, code, userInfo);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1F40D7AB8](err);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B68](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1F40D7BA0](cf);
}

CFTypeRef CFMakeCollectable(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D7CA0](cf);
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1F40D7D78](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E30](number);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE0](key, applicationID, keyExistsAndHasValidFormat);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40D7F18](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

Boolean CFPropertyListIsValid(CFPropertyListRef plist, CFPropertyListFormat format)
{
  return MEMORY[0x1F40D7F68](plist, format);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1F40D81F8](theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return (CFSetRef)MEMORY[0x1F40D8200](allocator, values, numValues, callBacks);
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  return (CFSetRef)MEMORY[0x1F40D8208](allocator, theSet);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

CFTypeID CFSetGetTypeID(void)
{
  return MEMORY[0x1F40D8230]();
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1F40D83D0](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1F40D83E0](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x1F40D83F8](alloc, theString, *(void *)&encoding, lossByte);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8400](alloc, data, *(void *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8440](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8458](alloc, cStr, *(void *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  return (CFStringRef)MEMORY[0x1F40D8478](alloc, buffer);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8558](string, buffer, maxBufLen);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  return MEMORY[0x1F40D85A0](string);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

void CFStringReplaceAll(CFMutableStringRef theString, CFStringRef replacement)
{
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1F40D8740](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1F40D8758](anURL, pathStyle);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return (CGAffineTransform *)MEMORY[0x1F40D9790](retstr, t1, t2);
}

BOOL CGAffineTransformEqualToTransform(CGAffineTransform *t1, CGAffineTransform *t2)
{
  return MEMORY[0x1F40D97A0](t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97A8](retstr, t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97C8](retstr, angle);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97D0](retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97D8](retstr, tx, ty);
}

CGAffineTransform *__cdecl CGAffineTransformScale(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97F0](retstr, t, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97F8](retstr, t, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x1F40D9808](data, width, height, bitsPerComponent, bytesPerRow, space, *(void *)&bitmapInfo);
}

size_t CGBitmapContextGetBytesPerRow(CGContextRef context)
{
  return MEMORY[0x1F40D9858](context);
}

void *__cdecl CGBitmapContextGetData(CGContextRef context)
{
  return (void *)MEMORY[0x1F40D9868](context);
}

size_t CGBitmapContextGetHeight(CGContextRef context)
{
  return MEMORY[0x1F40D9870](context);
}

size_t CGBitmapContextGetWidth(CGContextRef context)
{
  return MEMORY[0x1F40D9878](context);
}

CGColorSpaceRef CGColorSpaceCreateDeviceGray(void)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D9AF0]();
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D9AF8]();
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
}

void CGContextRelease(CGContextRef c)
{
}

CGDataProviderRef CGDataProviderCreateWithCFData(CFDataRef data)
{
  return (CGDataProviderRef)MEMORY[0x1F40DA300](data);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return (CGDataProviderRef)MEMORY[0x1F40DA310](info, data, size, releaseData);
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return (CGImageRef)MEMORY[0x1F40DA868](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, *(void *)&bitmapInfo, provider);
}

CGImageRef CGImageCreateWithImageInRect(CGImageRef image, CGRect rect)
{
  return (CGImageRef)MEMORY[0x1F40DA890](image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
}

CGImageDestinationRef CGImageDestinationCreateWithData(CFMutableDataRef data, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x1F40E9738](data, type, count, options);
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x1F40E9758](url, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return MEMORY[0x1F40E9760](idst);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x1F40DA948](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x1F40DA9B8](image);
}

void CGImageRelease(CGImageRef image)
{
}

CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point)
{
  return (CFDictionaryRef)MEMORY[0x1F40DB200]((__n128)point, *(__n128 *)&point.y);
}

BOOL CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point)
{
  return MEMORY[0x1F40DB210](dict, point);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  MEMORY[0x1F40DB220](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v5;
  result.size.CGFloat width = v4;
  result.origin.CGFloat y = v3;
  result.origin.CGFloat x = v2;
  return result;
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x1F40DB238]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  MEMORY[0x1F40DB250]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  MEMORY[0x1F40DB268]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  MEMORY[0x1F40DB270]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  MEMORY[0x1F40DB298]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  MEMORY[0x1F40DB2A0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  MEMORY[0x1F40DB2A8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  MEMORY[0x1F40DB2B8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.CGFloat height = v6;
  result.size.CGFloat width = v5;
  result.origin.CGFloat y = v4;
  result.origin.CGFloat x = v3;
  return result;
}

CGRect CGRectIntegral(CGRect rect)
{
  MEMORY[0x1F40DB2C0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v4;
  result.size.CGFloat width = v3;
  result.origin.CGFloat y = v2;
  result.origin.CGFloat x = v1;
  return result;
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  MEMORY[0x1F40DB2C8]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.CGFloat height = v5;
  result.size.CGFloat width = v4;
  result.origin.CGFloat y = v3;
  result.origin.CGFloat x = v2;
  return result;
}

BOOL CGRectIntersectsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1F40DB2D0]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x1F40DB2D8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsInfinite(CGRect rect)
{
  return MEMORY[0x1F40DB2E0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsNull(CGRect rect)
{
  return MEMORY[0x1F40DB2E8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return MEMORY[0x1F40DB2F0](dict, rect);
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  MEMORY[0x1F40DB310]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.CGFloat height = v5;
  result.size.CGFloat width = v4;
  result.origin.CGFloat y = v3;
  result.origin.CGFloat x = v2;
  return result;
}

CFTypeRef CMGetAttachment(CMAttachmentBearerRef target, CFStringRef key, CMAttachmentMode *attachmentModeOut)
{
  return (CFTypeRef)MEMORY[0x1F40DBBF0](target, key, attachmentModeOut);
}

CFDictionaryRef CMTimeCopyAsDictionary(CMTime *time, CFAllocatorRef allocator)
{
  return (CFDictionaryRef)MEMORY[0x1F40DC0E0](time, allocator);
}

CFStringRef CMTimeCopyDescription(CFAllocatorRef allocator, CMTime *time)
{
  return (CFStringRef)MEMORY[0x1F40DC0E8](allocator, time);
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  MEMORY[0x1F40DC100](time);
  return result;
}

CMTime *__cdecl CMTimeMakeFromDictionary(CMTime *__return_ptr retstr, CFDictionaryRef dictionaryRepresentation)
{
  return (CMTime *)MEMORY[0x1F40DC110](retstr, dictionaryRepresentation);
}

CFTypeRef CVBufferCopyAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x1F40DFB48](buffer, key, attachmentMode);
}

CFDictionaryRef CVPixelBufferCopyCreationAttributes(CVPixelBufferRef pixelBuffer)
{
  return (CFDictionaryRef)MEMORY[0x1F40DFCD8](pixelBuffer);
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFCE0](allocator, width, height, *(void *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

CVReturn CVPixelBufferCreateWithBytes(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, void *baseAddress, size_t bytesPerRow, CVPixelBufferReleaseBytesCallback releaseCallback, void *releaseRefCon, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFD00](allocator, width, height, *(void *)&pixelFormatType, baseAddress, bytesPerRow, releaseCallback, releaseRefCon);
}

CVReturn CVPixelBufferCreateWithIOSurface(CFAllocatorRef allocator, IOSurfaceRef surface, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFD08](allocator, surface, pixelBufferAttributes, pixelBufferOut);
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x1F40DFD28](pixelBuffer);
}

void *__cdecl CVPixelBufferGetBaseAddressOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return (void *)MEMORY[0x1F40DFD30](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD40](pixelBuffer);
}

size_t CVPixelBufferGetBytesPerRowOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1F40DFD48](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD68](pixelBuffer);
}

size_t CVPixelBufferGetHeightOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1F40DFD70](pixelBuffer, planeIndex);
}

IOSurfaceRef CVPixelBufferGetIOSurface(CVPixelBufferRef pixelBuffer)
{
  return (IOSurfaceRef)MEMORY[0x1F40DFD78](pixelBuffer);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD80](pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD88](pixelBuffer);
}

CFTypeID CVPixelBufferGetTypeID(void)
{
  return MEMORY[0x1F40DFD90]();
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFD98](pixelBuffer);
}

size_t CVPixelBufferGetWidthOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1F40DFDA0](pixelBuffer, planeIndex);
}

Boolean CVPixelBufferIsPlanar(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1F40DFDB0](pixelBuffer);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x1F40DFDB8](pixelBuffer, lockFlags);
}

CVReturn CVPixelBufferPoolCreate(CFAllocatorRef allocator, CFDictionaryRef poolAttributes, CFDictionaryRef pixelBufferAttributes, CVPixelBufferPoolRef *poolOut)
{
  return MEMORY[0x1F40DFDC0](allocator, poolAttributes, pixelBufferAttributes, poolOut);
}

CVReturn CVPixelBufferPoolCreatePixelBuffer(CFAllocatorRef allocator, CVPixelBufferPoolRef pixelBufferPool, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFDC8](allocator, pixelBufferPool, pixelBufferOut);
}

CVReturn CVPixelBufferPoolCreatePixelBufferWithAuxAttributes(CFAllocatorRef allocator, CVPixelBufferPoolRef pixelBufferPool, CFDictionaryRef auxAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1F40DFDD0](allocator, pixelBufferPool, auxAttributes, pixelBufferOut);
}

void CVPixelBufferRelease(CVPixelBufferRef texture)
{
}

CVPixelBufferRef CVPixelBufferRetain(CVPixelBufferRef texture)
{
  return (CVPixelBufferRef)MEMORY[0x1F40DFE40](texture);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x1F40DFE48](pixelBuffer, unlockFlags);
}

CFDictionaryRef CVPixelFormatDescriptionCreateWithPixelFormatType(CFAllocatorRef allocator, OSType pixelFormat)
{
  return (CFDictionaryRef)MEMORY[0x1F40DFE50](allocator, *(void *)&pixelFormat);
}

uint64_t FigCreateIOSurfacePropertiesDictionary()
{
  return MEMORY[0x1F4103090]();
}

uint64_t IOSurfaceCreateChildSurface()
{
  return MEMORY[0x1F40E9310]();
}

size_t IOSurfaceGetAllocSize(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9350](buffer);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x1F40E9358](buffer);
}

void *__cdecl IOSurfaceGetBaseAddressOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return (void *)MEMORY[0x1F40E9380](buffer, planeIndex);
}

size_t IOSurfaceGetBytesPerElementOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1F40E93A0](buffer, planeIndex);
}

size_t IOSurfaceGetBytesPerRowOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1F40E93B8](buffer, planeIndex);
}

size_t IOSurfaceGetHeightOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1F40E9450](buffer, planeIndex);
}

IOSurfaceID IOSurfaceGetID(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9460](buffer);
}

size_t IOSurfaceGetPlaneCount(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9488](buffer);
}

size_t IOSurfaceGetWidthOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1F40E9508](buffer, planeIndex);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1F40E9540](buffer, *(void *)&options, seed);
}

uint64_t IOSurfaceLockPlane()
{
  return MEMORY[0x1F40E9548]();
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1F40E9630](buffer, *(void *)&options, seed);
}

uint64_t IOSurfaceUnlockPlane()
{
  return MEMORY[0x1F40E9638]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1F417CE00]();
}

uint64_t MGIsQuestionValid()
{
  return MEMORY[0x1F417CE50]();
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x1F40EDE00]();
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1F40E7280](aClass);
}

OSStatus VTCreateCGImageFromCVPixelBuffer(CVPixelBufferRef pixelBuffer, CFDictionaryRef options, CGImageRef *imageOut)
{
  return MEMORY[0x1F4103190](pixelBuffer, options, imageOut);
}

OSStatus VTPixelRotationSessionCreate(CFAllocatorRef allocator, VTPixelRotationSessionRef *pixelRotationSessionOut)
{
  return MEMORY[0x1F4103490](allocator, pixelRotationSessionOut);
}

void VTPixelRotationSessionInvalidate(VTPixelRotationSessionRef session)
{
}

OSStatus VTPixelRotationSessionRotateImage(VTPixelRotationSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x1F41034A8](session, sourceBuffer, destinationBuffer);
}

uint64_t VTPixelRotationSessionRotateSubImage()
{
  return MEMORY[0x1F41034B0]();
}

OSStatus VTPixelTransferSessionCreate(CFAllocatorRef allocator, VTPixelTransferSessionRef *pixelTransferSessionOut)
{
  return MEMORY[0x1F41034D0](allocator, pixelTransferSessionOut);
}

void VTPixelTransferSessionInvalidate(VTPixelTransferSessionRef session)
{
}

OSStatus VTPixelTransferSessionTransferImage(VTPixelTransferSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x1F41034F0](session, sourceBuffer, destinationBuffer);
}

OSStatus VTSessionCopyProperty(VTSessionRef session, CFStringRef propertyKey, CFAllocatorRef allocator, void *propertyValueOut)
{
  return MEMORY[0x1F4103520](session, propertyKey, allocator, propertyValueOut);
}

OSStatus VTSessionSetProperty(VTSessionRef session, CFStringRef propertyKey, CFTypeRef propertyValue)
{
  return MEMORY[0x1F4103538](session, propertyKey, propertyValue);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFIsDeallocating()
{
  return MEMORY[0x1F40D8E18]();
}

uint64_t _CFNonObjCEqual()
{
  return MEMORY[0x1F40D8EA8]();
}

uint64_t _CFNonObjCRelease()
{
  return MEMORY[0x1F40D8EB8]();
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

uint64_t _CFTryRetain()
{
  return MEMORY[0x1F40D91E0]();
}

uint64_t _CFURLIsFileURL()
{
  return MEMORY[0x1F40D9348]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::string *__cdecl std::error_code::message(std::string *__return_ptr retstr, const std::error_code *this)
{
  return (std::string *)MEMORY[0x1F417E360](retstr, this);
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__filename(const std::__fs::filesystem::path *this)
{
  double v1 = (const std::string_view::value_type *)MEMORY[0x1F417E3C0](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__root_directory(const std::__fs::filesystem::path *this)
{
  double v1 = (const std::string_view::value_type *)MEMORY[0x1F417E3D8](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4B8](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

std::wstring *__cdecl std::to_wstring(std::wstring *__return_ptr retstr, int __val)
{
  return (std::wstring *)MEMORY[0x1F417E540](retstr, *(void *)&__val);
}

void std::__call_once(std::once_flag::_State_type *a1, void *a2, void (__cdecl *a3)(void *))
{
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

std::string *__cdecl std::string::append(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  return (std::string *)MEMORY[0x1F417E5D0](this, __n, __c);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1F417E660](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

std::wstring *__cdecl std::wstring::append(std::wstring *this, std::wstring::size_type __n, std::wstring::value_type __c)
{
  return (std::wstring *)MEMORY[0x1F417E688](this, __n, *(void *)&__c);
}

std::wstring *__cdecl std::wstring::insert(std::wstring *this, std::wstring::size_type __pos, const std::wstring::value_type *__s, std::wstring::size_type __n)
{
  return (std::wstring *)MEMORY[0x1F417E698](this, __pos, __s, __n);
}

void std::wstring::resize(std::wstring *this, std::wstring::size_type __n, std::wstring::value_type __c)
{
}

void std::wstring::push_back(std::wstring *this, std::wstring::value_type __c)
{
}

std::wstring *__cdecl std::wstring::operator=(std::wstring *this, const std::wstring *__str)
{
  return (std::wstring *)MEMORY[0x1F417E6C0](this, __str);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1F417E728]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1F417E740]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1F417E748]();
}

uint64_t std::wistream::get()
{
  return MEMORY[0x1F417E818]();
}

uint64_t std::wistream::~wistream()
{
  return MEMORY[0x1F417E820]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x1F417E830]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x1F417E838]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1F417E860]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E898]();
}

{
  return MEMORY[0x1F417E8A8]();
}

{
  return MEMORY[0x1F417E8B0]();
}

{
  return MEMORY[0x1F417E8C8]();
}

{
  return MEMORY[0x1F417E8D0]();
}

uint64_t std::wostream::put()
{
  return MEMORY[0x1F417E8D8]();
}

uint64_t std::wostream::~wostream()
{
  return MEMORY[0x1F417E8E0]();
}

uint64_t std::wostream::operator<<()
{
  return MEMORY[0x1F417E900]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1F417E940]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

uint64_t std::wstreambuf::basic_streambuf()
{
  return MEMORY[0x1F417E988]();
}

uint64_t std::wstreambuf::~wstreambuf()
{
  return MEMORY[0x1F417E990]();
}

const std::error_category *std::system_category(void)
{
  return (const std::error_category *)MEMORY[0x1F417E9E0]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

BOOL std::__fs::filesystem::__create_directory(const std::__fs::filesystem::path *a1, std::error_code *a2)
{
  return MEMORY[0x1F417EB58](a1, a2);
}

std::__fs::filesystem::path *__cdecl std::__fs::filesystem::__temp_directory_path(std::__fs::filesystem::path *__return_ptr retstr, std::error_code *__ec)
{
  return (std::__fs::filesystem::path *)MEMORY[0x1F417EB88](retstr, __ec);
}

std::__fs::filesystem::file_status std::__fs::filesystem::__status(const std::__fs::filesystem::path *a1, std::error_code *__ec)
{
  return (std::__fs::filesystem::file_status)MEMORY[0x1F417EBC8](a1, __ec);
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1F417ECA0]();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

uint64_t std::wios::~wios()
{
  return MEMORY[0x1F417EE48]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1F417EE70](retstr, *(void *)&__val);
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[](void *__p, std::align_val_t a2)
{
  while (1)
    ;
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new[](size_t __sz, std::align_val_t a2)
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void *__cxa_get_exception_ptr(void *a1)
{
  return (void *)MEMORY[0x1F417EF70](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_pure_virtual(void)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x1F417EFA8](lpsrc, lpstype, lpdtype, s2d);
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

simd_float3x3 __invert_f3(simd_float3x3 a1)
{
  MEMORY[0x1F40C9BF8]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2]);
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

uint64_t __memmove_chk()
{
  return MEMORY[0x1F40C9C30]();
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x1F40C9C88](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

uint64_t _os_assert_log()
{
  return MEMORY[0x1F40C9F90]();
}

uint64_t _os_assumes_log()
{
  return MEMORY[0x1F40C9F98]();
}

uint64_t _os_crash()
{
  return MEMORY[0x1F40C9FA0]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

void abort(void)
{
}

uint64_t abort_report_np()
{
  return MEMORY[0x1F40CA1E8]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1F40CA210](a1, *(void *)&a2);
}

float atan2f(float a1, float a2)
{
  MEMORY[0x1F40CA468](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

const char *__cdecl class_getName(Class cls)
{
  return (const char *)MEMORY[0x1F4181548](cls);
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x1F40CB3D0](*(void *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

float cosf(float a1)
{
  MEMORY[0x1F40CB8B0](a1);
  return result;
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_barrier_async_and_wait_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_barrier_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_barrier_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1F40CB9C8](flags, *(void *)&qos_class, *(void *)&relative_priority, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA8](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBB8](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBD0](label, attr, target);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

uintptr_t dispatch_source_get_data(dispatch_source_t source)
{
  return MEMORY[0x1F40CBCA0](source);
}

void dispatch_source_set_cancel_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

uint64_t e5rt_compute_gpu_device_retain_from_mtl_device()
{
  return MEMORY[0x1F41180A8]();
}

void exit(int a1)
{
}

float expf(float a1)
{
  MEMORY[0x1F40CBFF8](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1F40CC058](*(void *)&a1, *(void *)&a2);
}

float fmodf(float a1, float a2)
{
  MEMORY[0x1F40CC1A8](a1, a2);
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

size_t iconv(iconv_t a1, char **a2, size_t *a3, char **a4, size_t *a5)
{
  return MEMORY[0x1F417F6B8](a1, a2, a3, a4, a5);
}

int iconv_close(iconv_t a1)
{
  return MEMORY[0x1F417F6D0](a1);
}

iconv_t iconv_open(const char *a1, const char *a2)
{
  return (iconv_t)MEMORY[0x1F417F6D8](a1, a2);
}

float log2f(float a1)
{
  MEMORY[0x1F40CC8B0](a1);
  return result;
}

float logf(float a1)
{
  MEMORY[0x1F40CC8C0](a1);
  return result;
}

mach_port_t mach_thread_self(void)
{
  return MEMORY[0x1F40CCA58]();
}

malloc_zone_t *__cdecl malloc_create_zone(vm_size_t start_size, unsigned int flags)
{
  return (malloc_zone_t *)MEMORY[0x1F40CCB20](start_size, *(void *)&flags);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

void *__cdecl malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBC0](zone, size, type_id);
}

void *__cdecl malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBD8](zone, ptr, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_destroyWeak(id *location)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_initWeakOrNil(id *location, id val)
{
  return (id)MEMORY[0x1F4181760](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

void objc_storeStrong(id *location, id obj)
{
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1F40CD550](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1F40CD558](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1F40CD560](log, ptr);
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1F40CD5E8]();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_has_factory_content()
{
  return MEMORY[0x1F40CD640]();
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x1F40CD648]();
}

void perror(const char *a1)
{
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1F40CD888](*(void *)&pid, buffer, *(void *)&buffersize);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1F40CDAC8](a1, a2);
}

int pthread_threadid_np(pthread_t a1, __uint64_t *a2)
{
  return MEMORY[0x1F40CDB90](a1, a2);
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x1F40CDBD8]();
}

int rand(void)
{
  return MEMORY[0x1F40CDC08]();
}

uint64_t sgesvd_NEWLAPACK()
{
  return MEMORY[0x1F40D17F8]();
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

long double tan(long double __x)
{
  MEMORY[0x1F40CE420](__x);
  return result;
}

float tanf(float a1)
{
  MEMORY[0x1F40CE428](a1);
  return result;
}

void vDSP_conv(const float *__A, vDSP_Stride __IA, const float *__F, vDSP_Stride __IF, float *__C, vDSP_Stride __IC, vDSP_Length __N, vDSP_Length __P)
{
}

FFTSetup vDSP_create_fftsetup(vDSP_Length __Log2n, FFTRadix __Radix)
{
  return (FFTSetup)MEMORY[0x1F40D19F0](__Log2n, *(void *)&__Radix);
}

void vDSP_ctoz(const DSPComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__Z, vDSP_Stride __IZ, vDSP_Length __N)
{
}

void vDSP_destroy_fftsetup(FFTSetup __setup)
{
}

void vDSP_fft_zrip(FFTSetup __Setup, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __Log2N, FFTDirection __Direction)
{
}

void vDSP_vfixu8(const float *__A, vDSP_Stride __IA, unsigned __int8 *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvcmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

vImage_Error vImageBufferFill_CbCr8(const vImage_Buffer *dest, const Pixel_88 color, vImage_Flags flags)
{
  return MEMORY[0x1F40D2288](dest, color, *(void *)&flags);
}

vImage_Error vImageBuffer_Init(vImage_Buffer *buf, vImagePixelCount height, vImagePixelCount width, uint32_t pixelBits, vImage_Flags flags)
{
  return MEMORY[0x1F40D22A0](buf, height, width, *(void *)&pixelBits, *(void *)&flags);
}

vImage_Error vImageConvert_420Yp8_CbCr8ToARGB8888(const vImage_Buffer *srcYp, const vImage_Buffer *srcCbCr, const vImage_Buffer *dest, const vImage_YpCbCrToARGB *info, const uint8_t permuteMap[4], const uint8_t alpha, vImage_Flags flags)
{
  return MEMORY[0x1F40D23E8](srcYp, srcCbCr, dest, info, permuteMap, alpha, *(void *)&flags);
}

vImage_Error vImageConvert_ARGB16UtoPlanar16U(const vImage_Buffer *argbSrc, const vImage_Buffer *aDest, const vImage_Buffer *rDest, const vImage_Buffer *gDest, const vImage_Buffer *bDest, vImage_Flags flags)
{
  return MEMORY[0x1F40D2498](argbSrc, aDest, rDest, gDest, bDest, *(void *)&flags);
}

vImage_Error vImageConvert_ARGB8888To420Yp8_CbCr8(const vImage_Buffer *src, const vImage_Buffer *destYp, const vImage_Buffer *destCbCr, const vImage_ARGBToYpCbCr *info, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1F40D24C0](src, destYp, destCbCr, info, permuteMap, *(void *)&flags);
}

vImage_Error vImageConvert_ARGBToYpCbCr_GenerateConversion(const vImage_ARGBToYpCbCrMatrix *matrix, const vImage_YpCbCrPixelRange *pixelRange, vImage_ARGBToYpCbCr *outInfo, vImageARGBType inARGBType, vImageYpCbCrType outYpCbCrType, vImage_Flags flags)
{
  return MEMORY[0x1F40D2570](matrix, pixelRange, outInfo, *(void *)&inARGBType, *(void *)&outYpCbCrType, *(void *)&flags);
}

vImage_Error vImageConvert_BGRX8888ToPlanar8(const vImage_Buffer *src, const vImage_Buffer *blue, const vImage_Buffer *green, const vImage_Buffer *red, vImage_Flags flags)
{
  return MEMORY[0x1F40D2580](src, blue, green, red, *(void *)&flags);
}

vImage_Error vImageConvert_BGRXFFFFToPlanarF(const vImage_Buffer *src, const vImage_Buffer *blue, const vImage_Buffer *green, const vImage_Buffer *red, vImage_Flags flags)
{
  return MEMORY[0x1F40D2588](src, blue, green, red, *(void *)&flags);
}

vImage_Error vImageConvert_Planar16FtoPlanar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D25A8](src, dest, *(void *)&flags);
}

vImage_Error vImageConvert_Planar8toPlanar16F(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D2610](src, dest, *(void *)&flags);
}

vImage_Error vImageConvert_Planar8toPlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, Pixel_F maxFloat, Pixel_F minFloat, vImage_Flags flags)
{
  return MEMORY[0x1F40D2618](src, dest, *(void *)&flags, maxFloat, minFloat);
}

vImage_Error vImageConvert_YpCbCrToARGB_GenerateConversion(const vImage_YpCbCrToARGBMatrix *matrix, const vImage_YpCbCrPixelRange *pixelRange, vImage_YpCbCrToARGB *outInfo, vImageYpCbCrType inYpCbCrType, vImageARGBType outARGBType, vImage_Flags flags)
{
  return MEMORY[0x1F40D2780](matrix, pixelRange, outInfo, *(void *)&inYpCbCrType, *(void *)&outARGBType, *(void *)&flags);
}

vImage_Error vImageCopyBuffer(const vImage_Buffer *src, const vImage_Buffer *dest, size_t pixelSize, vImage_Flags flags)
{
  return MEMORY[0x1F40D2858](src, dest, pixelSize, *(void *)&flags);
}

vImage_Error vImageRotate90_Planar16U(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_16U backColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2C70](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_8 backColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2C78](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageScale_CbCr8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1F40D2CE8](src, dest, tempBuffer, *(void *)&flags);
}

vImage_Error vImageScale_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1F40D2D08](src, dest, tempBuffer, *(void *)&flags);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x1F40CE8B0](__s, *(void *)&__c, __n);
}

int wmemcmp(const __int32 *a1, const __int32 *a2, size_t a3)
{
  return MEMORY[0x1F40CE8B8](a1, a2, a3);
}