uint64_t OTSVGTableRelease(uint64_t result)
{
  std::__shared_weak_count *v1;
  uint64_t vars8;

  if (result)
  {
    v1 = *(std::__shared_weak_count **)(result + 8);
    if (v1) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v1);
    }
    JUMPOUT(0x1C18A3E80);
  }
  return result;
}

unint64_t SVG::ViewBox::parseViewBox@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = 0;
  do
  {
    unint64_t v5 = v4;
    unint64_t v4 = SVG::consumeWsp((uint64_t *)a1, v4);
  }
  while (v6);
  *(void *)&long long v7 = -1;
  *((void *)&v7 + 1) = -1;
  long long v14 = v7;
  long long v15 = v7;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t result = (unint64_t)SVG::consumeWspCommaList<double,4ul>((uint64_t *)a1, v5, (void *(*)(uint64_t *__return_ptr, uint64_t *, unint64_t))SVG::consumeNumber, (uint64_t)&v14);
  if (!(_BYTE)v17) {
    goto LABEL_10;
  }
  unint64_t result = v16;
  do
  {
    unint64_t v9 = result;
    unint64_t result = SVG::consumeWsp((uint64_t *)a1, result);
  }
  while (v10);
  uint64_t v11 = *(unsigned __int8 *)(a1 + 23);
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *(void *)(a1 + 8);
  }
  if (v9 == v11)
  {
    long long v12 = v15;
    *(_OWORD *)a2 = v14;
    *(_OWORD *)(a2 + 16) = v12;
    char v13 = 1;
  }
  else
  {
LABEL_10:
    char v13 = 0;
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + 32) = v13;
  return result;
}

unint64_t SVG::PreserveAspectRatio::parsePreserveAspectRatio(uint64_t a1)
{
  unint64_t v2 = 0;
  do
  {
    uint64_t v3 = v2;
    unint64_t v2 = SVG::consumeWsp((uint64_t *)a1, v2);
  }
  while (v4);
  memset(v12, 170, sizeof(v12));
  SVG::consumePreserveAspectRatio((uint64_t *)a1, v3, (uint64_t)v12);
  if (!LOBYTE(v12[2])) {
    goto LABEL_10;
  }
  unint64_t v5 = v12[1];
  do
  {
    unint64_t v6 = v5;
    unint64_t v5 = SVG::consumeWsp((uint64_t *)a1, v5);
  }
  while (v7);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 23);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a1 + 8);
  }
  if (v6 == v8)
  {
    unint64_t v9 = v12[0] & 0xFFFFFFFFFFFFFF00;
    uint64_t v10 = LOBYTE(v12[0]);
  }
  else
  {
LABEL_10:
    unint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  return v10 | v9;
}

unint64_t SVG::consumePreserveAspectRatio@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = a2;
  unint64_t v6 = SVG::consumeString<6ul>((uint64_t)"defer", (uint64_t)a1, a2);
  if (v7)
  {
    unint64_t result = SVG::consumeWsp(a1, v6);
    if (!v9) {
      goto LABEL_29;
    }
    do
    {
      uint64_t v3 = result;
      unint64_t result = SVG::consumeWsp(a1, result);
    }
    while (v10);
  }
  unint64_t v11 = SVG::consumeString<5ul>((uint64_t)"none", (uint64_t)a1, v3);
  if (!v12)
  {
    unint64_t v15 = SVG::consumeString<9ul>((uint64_t)"xMinYMin", (uint64_t)a1, v3);
    if (v16)
    {
      unint64_t v13 = v15;
      uint64_t v14 = 1;
      goto LABEL_24;
    }
    unint64_t v17 = SVG::consumeString<9ul>((uint64_t)"xMidYMin", (uint64_t)a1, v3);
    if (v18)
    {
      unint64_t v13 = v17;
      uint64_t v14 = 2;
      goto LABEL_24;
    }
    unint64_t v19 = SVG::consumeString<9ul>((uint64_t)"xMaxYMin", (uint64_t)a1, v3);
    if (v20)
    {
      unint64_t v13 = v19;
      uint64_t v14 = 3;
      goto LABEL_24;
    }
    unint64_t v21 = SVG::consumeString<9ul>((uint64_t)"xMinYMid", (uint64_t)a1, v3);
    if (v22)
    {
      unint64_t v13 = v21;
      uint64_t v14 = 4;
      goto LABEL_24;
    }
    unint64_t v23 = SVG::consumeString<9ul>((uint64_t)"xMidYMid", (uint64_t)a1, v3);
    if (v24)
    {
      unint64_t v13 = v23;
      uint64_t v14 = 5;
      goto LABEL_24;
    }
    unint64_t v25 = SVG::consumeString<9ul>((uint64_t)"xMaxYMid", (uint64_t)a1, v3);
    if (v26)
    {
      unint64_t v13 = v25;
      uint64_t v14 = 6;
      goto LABEL_24;
    }
    unint64_t v27 = SVG::consumeString<9ul>((uint64_t)"xMinYMax", (uint64_t)a1, v3);
    if (v28)
    {
      unint64_t v13 = v27;
      uint64_t v14 = 7;
      goto LABEL_24;
    }
    unint64_t v29 = SVG::consumeString<9ul>((uint64_t)"xMidYMax", (uint64_t)a1, v3);
    if (v30)
    {
      unint64_t v13 = v29;
      uint64_t v14 = 8;
      goto LABEL_24;
    }
    unint64_t result = SVG::consumeString<9ul>((uint64_t)"xMaxYMax", (uint64_t)a1, v3);
    if (v31)
    {
      unint64_t v13 = result;
      uint64_t v14 = 9;
      goto LABEL_24;
    }
LABEL_29:
    char v37 = 0;
    *(unsigned char *)a3 = 0;
    goto LABEL_34;
  }
  unint64_t v13 = v11;
  uint64_t v14 = 0;
LABEL_24:
  unint64_t result = SVG::consumeWsp(a1, v13);
  if (v32)
  {
    do
    {
      uint64_t v33 = result;
      unint64_t result = SVG::consumeWsp(a1, result);
    }
    while (v34);
    unint64_t result = SVG::consumeString<5ul>((uint64_t)"meet", (uint64_t)a1, v33);
    if (v35)
    {
      unint64_t v36 = 0;
      unint64_t v13 = result;
    }
    else
    {
      unint64_t result = SVG::consumeString<6ul>((uint64_t)"slice", (uint64_t)a1, v33);
      if (v38) {
        unint64_t v13 = result;
      }
      unint64_t v36 = (unint64_t)(v38 != 0) << 32;
    }
  }
  else
  {
    unint64_t v36 = 0;
  }
  *(void *)a3 = v36 | v14;
  *(void *)(a3 + 8) = v13;
  char v37 = 1;
LABEL_34:
  *(unsigned char *)(a3 + 16) = v37;
  return result;
}

CGAffineTransform *SVG::computeViewBoxTransform@<X0>(CGAffineTransform *result@<X0>, uint64_t a2@<X8>, CGFloat a3@<D0>, CGFloat a4@<D1>, CGFloat a5@<D2>, CGFloat a6@<D3>, double a7@<D4>, double a8@<D5>, double a9@<D6>, double a10@<D7>)
{
  if (a5 == 0.0 || a6 == 0.0)
  {
LABEL_53:
    char v26 = 0;
    *(unsigned char *)a2 = 0;
  }
  else
  {
    double v11 = a9 / a5;
    double v12 = a10 / a6;
    switch((int)result)
    {
      case 0:
        double v13 = 0.0;
        goto LABEL_37;
      case 1:
        double v13 = 0.0;
        if (HIDWORD(result) == 1)
        {
          BOOL v15 = v11 < v12;
        }
        else
        {
          if (HIDWORD(result))
          {
            double v11 = NAN;
            double v12 = NAN;
            goto LABEL_37;
          }
          BOOL v15 = v12 < v11;
        }
        if (v15) {
          double v11 = a10 / a6;
        }
        double v12 = v11;
LABEL_37:
        double v14 = 0.0;
        goto LABEL_50;
      case 2:
        double v14 = 0.5;
        goto LABEL_11;
      case 3:
        double v14 = 1.0;
LABEL_11:
        double v13 = 0.0;
        goto LABEL_21;
      case 4:
        double v14 = 0.0;
        goto LABEL_17;
      case 5:
        double v13 = 0.5;
        if (HIDWORD(result) == 1)
        {
          BOOL v16 = v11 < v12;
        }
        else
        {
          if (HIDWORD(result))
          {
            double v11 = NAN;
            double v12 = NAN;
            goto LABEL_43;
          }
          BOOL v16 = v12 < v11;
        }
        if (v16) {
          double v11 = a10 / a6;
        }
        double v12 = v11;
LABEL_43:
        double v14 = 0.5;
        goto LABEL_50;
      case 6:
        double v14 = 1.0;
LABEL_17:
        double v13 = 0.5;
        goto LABEL_21;
      case 7:
        double v14 = 0.0;
        goto LABEL_20;
      case 8:
        double v14 = 0.5;
LABEL_20:
        double v13 = 1.0;
LABEL_21:
        if (HIDWORD(result) == 1)
        {
          BOOL v17 = v11 < v12;
        }
        else
        {
          if (HIDWORD(result))
          {
            double v11 = NAN;
            double v12 = NAN;
            goto LABEL_50;
          }
          BOOL v17 = v12 < v11;
        }
        if (v17) {
          double v11 = a10 / a6;
        }
        double v12 = v11;
        goto LABEL_50;
      case 9:
        double v13 = 1.0;
        if (HIDWORD(result) == 1)
        {
          BOOL v18 = v11 < v12;
        }
        else
        {
          if (HIDWORD(result))
          {
            double v11 = NAN;
            double v12 = NAN;
            goto LABEL_49;
          }
          BOOL v18 = v12 < v11;
        }
        if (v18) {
          double v11 = a10 / a6;
        }
        double v12 = v11;
LABEL_49:
        double v14 = 1.0;
LABEL_50:
        if (v11 == 0.0 || v12 == 0.0) {
          goto LABEL_53;
        }
        *(void *)&long long v20 = -1;
        *((void *)&v20 + 1) = -1;
        *(_OWORD *)&v33.c = v20;
        *(_OWORD *)&v33.tx = v20;
        *(_OWORD *)&v33.a = v20;
        double v29 = v11;
        double v30 = v12;
        CGAffineTransformMakeScale(&v33, v11, v12);
        CGAffineTransform v32 = v33;
        v34.origin.x = a3;
        v34.origin.y = a4;
        v34.size.width = a5;
        v34.size.height = a6;
        CGRect v35 = CGRectApplyAffineTransform(v34, &v32);
        CGAffineTransform v31 = v33;
        unint64_t result = CGAffineTransformTranslate((CGAffineTransform *)a2, &v31, (a7 + v14 * a9 - (v35.origin.x + v14 * v35.size.width)) / v29, (a8 + v13 * a10 - (v35.origin.y + v13 * v35.size.height)) / v30);
        char v26 = 1;
        break;
      default:
        double v13 = NAN;
        double v14 = NAN;
        goto LABEL_50;
    }
  }
  *(unsigned char *)(a2 + 48) = v26;
  return result;
}

void *SVG::consumeWspCommaList<double,4ul>@<X0>(uint64_t *a1@<X0>, unint64_t a2@<X1>, void *(*a3)(uint64_t *__return_ptr, uint64_t *, unint64_t)@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = 0;
  *(void *)&long long v9 = -1;
  *((void *)&v9 + 1) = -1;
  long long v17 = v9;
  long long v18 = v9;
  while (1)
  {
    if (v8)
    {
      unint64_t v10 = SVG::consumeCommaWsp(a1, a2);
      if (v11) {
        a2 = v10;
      }
    }
    uint64_t v14 = -1;
    unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t result = a3(&v14, a1, a2);
    if (!(_BYTE)v16) {
      break;
    }
    *(void *)((char *)&v17 + v8) = v14;
    a2 = v15;
    v8 += 8;
    if (v8 == 32)
    {
      long long v13 = v18;
      *(_OWORD *)a4 = v17;
      *(_OWORD *)(a4 + 16) = v13;
      *(void *)(a4 + 32) = a2;
      *(unsigned char *)(a4 + 40) = 1;
      return result;
    }
  }
  *(unsigned char *)a4 = 0;
  *(unsigned char *)(a4 + 40) = 0;
  return result;
}

unint64_t SVG::consumeString<6ul>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  uint64_t v4 = a3 + 5;
  if (v3 >= a3 + 5)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      int v12 = *(char *)(v11 + a3 + v10);
      if (__tolower(*(char *)(a1 + v10)) != v12)
      {
        uint64_t v13 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
        int v14 = *(char *)(v13 + a3 + v10);
        if (__toupper(*(char *)(a1 + v10)) != v14) {
          break;
        }
      }
      if (++v10 == 5)
      {
        unint64_t v6 = v4 & 0xFFFFFFFFFFFFFF00;
        uint64_t v5 = v4;
        return v6 | v5;
      }
    }
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  return v6 | v5;
}

unint64_t SVG::consumeString<5ul>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  uint64_t v4 = a3 + 4;
  if (v3 >= a3 + 4)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      int v12 = *(char *)(v11 + a3 + v10);
      if (__tolower(*(char *)(a1 + v10)) != v12)
      {
        uint64_t v13 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
        int v14 = *(char *)(v13 + a3 + v10);
        if (__toupper(*(char *)(a1 + v10)) != v14) {
          break;
        }
      }
      if (++v10 == 4)
      {
        unint64_t v6 = v4 & 0xFFFFFFFFFFFFFF00;
        uint64_t v5 = v4;
        return v6 | v5;
      }
    }
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  return v6 | v5;
}

unint64_t SVG::consumeString<9ul>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  uint64_t v4 = a3 + 8;
  if (v3 >= a3 + 8)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      int v12 = *(char *)(v11 + a3 + v10);
      if (__tolower(*(char *)(a1 + v10)) != v12)
      {
        uint64_t v13 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
        int v14 = *(char *)(v13 + a3 + v10);
        if (__toupper(*(char *)(a1 + v10)) != v14) {
          break;
        }
      }
      if (++v10 == 8)
      {
        unint64_t v6 = v4 & 0xFFFFFFFFFFFFFF00;
        uint64_t v5 = v4;
        return v6 | v5;
      }
    }
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  return v6 | v5;
}

uint64_t SVG::Presentation::defaultPresentation@<X0>(uint64_t a1@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  memcpy((void *)a1, &unk_1BF1D9678, 0x238uLL);
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 308) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 480) = 0;
  *(_DWORD *)(a1 + 512) = 0;
  *(_DWORD *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 528) = 0;
  *(_DWORD *)(a1 + 544) = 0;
  *(_DWORD *)(a1 + 560) = 0;
  *(void *)(a1 + 568) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = 0;
  *(_DWORD *)(a1 + 504) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_DWORD *)(a1 + 48) = 2;
  v9[0] = 0;
  v10[0] = 0;
  unsigned int v11 = 2;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>(a1 + 64, (uint64_t)v9);
  if (v11 != -1) {
    ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A74F30 + v11))(v6, v9);
  }
  *(void *)(a1 + 88) = 0x200000000;
  *(void *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 112) = 2;
  *(_OWORD *)(a1 + 116) = xmmword_1BF1D9660;
  *(void *)(a1 + 132) = 0x200000000;
  v7[0] = 2852126720;
  unsigned int v8 = 2;
  v10[0] = 0;
  int v14 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>((uint64_t)v10, (uint64_t)v7);
  unsigned int v15 = 2;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>(a1 + 152, (uint64_t)v9);
  if (v15 != -1) {
    ((void (*)(char *, unsigned char *))*(&off_1F1A74F60 + v15))(&v5, v9);
  }
  unsigned int v15 = -1;
  if (v8 != -1) {
    ((void (*)(char *, void *))*(&off_1F1A74F90 + v8))(&v5, v7);
  }
  *(void *)(a1 + 208) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 216) = 2;
  int64x2_t v4 = vdupq_n_s64(0x200000000uLL);
  *(int64x2_t *)(a1 + 224) = v4;
  v9[0] = 0;
  v10[0] = 0;
  unsigned int v11 = 2;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>(a1 + 248, (uint64_t)v9);
  if (v11 != -1) {
    ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A74F30 + v11))(v6, v9);
  }
  *(void *)(a1 + 272) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 280) = 2;
  *(int64x2_t *)(a1 + 288) = v4;
  *(void *)(a1 + 308) = 2852126720;
  *(unsigned char *)(a1 + 316) = 1;
  *(_DWORD *)(a1 + 320) = 2;
  *(void *)(a1 + 328) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 336) = 2;
  LODWORD(v7[0]) = 0;
  unsigned int v8 = 0;
  v10[0] = 0;
  int v14 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>((uint64_t)v10, (uint64_t)v7);
  unsigned int v15 = 2;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>(a1 + 352, (uint64_t)v9);
  if (v15 != -1) {
    ((void (*)(char *, unsigned char *))*(&off_1F1A74F60 + v15))(&v5, v9);
  }
  unsigned int v15 = -1;
  if (v8 != -1) {
    ((void (*)(char *, void *))*(&off_1F1A74F90 + v8))(&v5, v7);
  }
  v9[0] = 0;
  char v12 = 0;
  unsigned int v13 = 2;
  uint64_t result = std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1>>(a1 + 416, (uint64_t)v9);
  if (v13 != -1) {
    uint64_t result = ((uint64_t (*)(unsigned char *, unsigned char *))*(&off_1F1A75008 + v13))(v6, v9);
  }
  *(void *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 472) = 0;
  *(_DWORD *)(a1 + 480) = 2;
  *(void *)(a1 + 488) = 0x200000000;
  *(void *)(a1 + 496) = 0x200000000;
  *(void *)(a1 + 504) = 0x4010000000000000;
  *(_DWORD *)(a1 + 512) = 2;
  *(void *)(a1 + 520) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 528) = 2;
  *(void *)(a1 + 544) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 552) = 0;
  *(_DWORD *)(a1 + 560) = 2;
  *(void *)(a1 + 568) = 0x200000000;
  return result;
}

void SVG::Presentation::inherit(SVG::Presentation *this@<X0>, const SVG::Presentation *a2@<X1>, const SVG::Presentation *a3@<X2>, _OWORD *a4@<X8>)
{
  memcpy(a4, &unk_1BF1D9678, 0x240uLL);
  long long v9 = *((_OWORD *)this + 1);
  *a4 = *(_OWORD *)this;
  a4[1] = v9;
  a4[2] = *((_OWORD *)this + 2);
  *((void *)a4 + 6) = *((void *)this + 6);
  *((unsigned char *)a4 + 64) = 0;
  *((_DWORD *)a4 + 20) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a4 + 4), (uint64_t)this + 64);
  *(_OWORD *)((char *)a4 + 88) = *(_OWORD *)((char *)this + 88);
  *(_OWORD *)((char *)a4 + 104) = *(_OWORD *)((char *)this + 104);
  *(_OWORD *)((char *)a4 + 120) = *(_OWORD *)((char *)this + 120);
  *((_DWORD *)a4 + 34) = *((_DWORD *)this + 34);
  *((unsigned char *)a4 + 152) = 0;
  *((_DWORD *)a4 + 50) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)a4 + 152, (uint64_t)this + 152);
  *((unsigned char *)a4 + 248) = 0;
  long long v10 = *((_OWORD *)this + 14);
  a4[13] = *((_OWORD *)this + 13);
  a4[14] = v10;
  *((_DWORD *)a4 + 66) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)a4 + 248, (uint64_t)this + 248);
  long long v11 = *((_OWORD *)this + 17);
  a4[18] = *((_OWORD *)this + 18);
  long long v12 = *((_OWORD *)this + 20);
  a4[19] = *((_OWORD *)this + 19);
  a4[20] = v12;
  *((void *)a4 + 42) = *((void *)this + 42);
  a4[17] = v11;
  *((unsigned char *)a4 + 352) = 0;
  *((_DWORD *)a4 + 100) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a4 + 22), (uint64_t)this + 352);
  *((unsigned char *)a4 + 416) = 0;
  *((_DWORD *)a4 + 112) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a4 + 26), (uint64_t)this + 416);
  long long v13 = *(_OWORD *)((char *)this + 536);
  *(_OWORD *)((char *)a4 + 520) = *(_OWORD *)((char *)this + 520);
  *(_OWORD *)((char *)a4 + 536) = v13;
  *(_OWORD *)((char *)a4 + 552) = *(_OWORD *)((char *)this + 552);
  *((void *)a4 + 71) = *((void *)this + 71);
  long long v14 = *(_OWORD *)((char *)this + 472);
  *(_OWORD *)((char *)a4 + 456) = *(_OWORD *)((char *)this + 456);
  *(_OWORD *)((char *)a4 + 472) = v14;
  long long v15 = *(_OWORD *)((char *)this + 504);
  *(_OWORD *)((char *)a4 + 488) = *(_OWORD *)((char *)this + 488);
  *(_OWORD *)((char *)a4 + 504) = v15;
  if (*((_DWORD *)this + 23) <= 1u) {
    *((void *)a4 + 11) = *((void *)a2 + 11);
  }
  if (*((_DWORD *)this + 28) <= 1u)
  {
    a4[6] = *((_OWORD *)a2 + 6);
    *((_DWORD *)a4 + 28) = *((_DWORD *)a2 + 28);
  }
  if (*((_DWORD *)this + 30) <= 1u) {
    *(void *)((char *)a4 + 116) = *(void *)((char *)a2 + 116);
  }
  if (*((_DWORD *)this + 32) <= 1u) {
    *(void *)((char *)a4 + 124) = *(void *)((char *)a2 + 124);
  }
  if (*((_DWORD *)this + 50) <= 1u) {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)a4 + 152, (uint64_t)a2 + 152);
  }
  if (*((_DWORD *)this + 54) <= 1u) {
    a4[13] = *((_OWORD *)a2 + 13);
  }
  if (*((_DWORD *)this + 57) <= 1u) {
    *((void *)a4 + 28) = *((void *)a2 + 28);
  }
  if (*((_DWORD *)this + 59) <= 1u) {
    *((void *)a4 + 29) = *((void *)a2 + 29);
  }
  if (*((_DWORD *)this + 75) <= 1u) {
    *((void *)a4 + 37) = *((void *)a2 + 37);
  }
  if (*((_DWORD *)this + 100) <= 1u) {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a4 + 22), (uint64_t)a2 + 352);
  }
  if (*((_DWORD *)this + 112) <= 1u) {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a4 + 26), (uint64_t)a2 + 416);
  }
  if (*((_DWORD *)this + 120) <= 1u)
  {
    long long v16 = *(_OWORD *)((char *)a2 + 472);
    *(_OWORD *)((char *)a4 + 456) = *(_OWORD *)((char *)a2 + 456);
    *(_OWORD *)((char *)a4 + 472) = v16;
  }
  if (*((_DWORD *)this + 123) <= 1u) {
    *((void *)a4 + 61) = *((void *)a2 + 61);
  }
  if (*((_DWORD *)this + 125) <= 1u) {
    *((void *)a4 + 62) = *((void *)a2 + 62);
  }
  if (*((_DWORD *)this + 128) <= 1u) {
    *(_OWORD *)((char *)a4 + 504) = *(_OWORD *)((char *)a2 + 504);
  }
  if (*((_DWORD *)this + 132) <= 1u) {
    *(_OWORD *)((char *)a4 + 520) = *(_OWORD *)((char *)a2 + 520);
  }
  if (*((_DWORD *)this + 140) <= 1u)
  {
    long long v17 = *(_OWORD *)((char *)a2 + 552);
    *(_OWORD *)((char *)a4 + 536) = *(_OWORD *)((char *)a2 + 536);
    *(_OWORD *)((char *)a4 + 552) = v17;
  }
  if (*((_DWORD *)this + 143) <= 1u) {
    *((void *)a4 + 71) = *((void *)a2 + 71);
  }
  int v18 = *((_DWORD *)this + 12);
  unint64_t v19 = a3;
  if (v18)
  {
    if (v18 != 1) {
      goto LABEL_41;
    }
    unint64_t v19 = a2;
  }
  long long v20 = *((_OWORD *)v19 + 1);
  *a4 = *(_OWORD *)v19;
  a4[1] = v20;
  a4[2] = *((_OWORD *)v19 + 2);
  *((void *)a4 + 6) = *((void *)v19 + 6);
LABEL_41:
  int v21 = *((_DWORD *)this + 20);
  char v22 = a3;
  if (v21)
  {
    if (v21 != 1) {
      goto LABEL_45;
    }
    char v22 = a2;
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a4 + 4), (uint64_t)v22 + 64);
LABEL_45:
  int v23 = *((_DWORD *)this + 34);
  char v24 = a3;
  if (v23)
  {
    if (v23 != 1) {
      goto LABEL_49;
    }
    char v24 = a2;
  }
  *(void *)((char *)a4 + 132) = *(void *)((char *)v24 + 132);
LABEL_49:
  int v25 = *((_DWORD *)this + 66);
  char v26 = a3;
  if (v25)
  {
    if (v25 != 1) {
      goto LABEL_53;
    }
    char v26 = a2;
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)a4 + 248, (uint64_t)v26 + 248);
LABEL_53:
  int v27 = *((_DWORD *)this + 70);
  char v28 = a3;
  if (v27)
  {
    if (v27 != 1) {
      goto LABEL_57;
    }
    char v28 = a2;
  }
  a4[17] = *((_OWORD *)v28 + 17);
LABEL_57:
  int v29 = *((_DWORD *)this + 73);
  double v30 = a3;
  if (v29)
  {
    if (v29 != 1) {
      goto LABEL_61;
    }
    double v30 = a2;
  }
  *((void *)a4 + 36) = *((void *)v30 + 36);
LABEL_61:
  int v31 = *((_DWORD *)this + 80);
  CGAffineTransform v32 = a3;
  if (v31)
  {
    if (v31 != 1) {
      goto LABEL_65;
    }
    CGAffineTransform v32 = a2;
  }
  a4[19] = *((_OWORD *)v32 + 19);
  *((_DWORD *)a4 + 80) = *((_DWORD *)v32 + 80);
LABEL_65:
  int v33 = *((_DWORD *)this + 84);
  if (v33)
  {
    if (v33 != 1) {
      goto LABEL_69;
    }
    a3 = a2;
  }
  *(_OWORD *)((char *)a4 + 328) = *(_OWORD *)((char *)a3 + 328);
LABEL_69:
  if (*((_DWORD *)a4 + 28) != 2) {
    goto LABEL_76;
  }
  SVG::resolveCurrentColor((uint64_t)(a4 + 9), *(const void **)((char *)a4 + 100), *((unsigned char *)a4 + 108));
  if (*((_DWORD *)a4 + 28) != 2) {
    goto LABEL_76;
  }
  SVG::resolveCurrentColor((uint64_t)a4 + 344, *(const void **)((char *)a4 + 100), *((unsigned char *)a4 + 108));
  if (*((_DWORD *)a4 + 80) != 2) {
    goto LABEL_76;
  }
  if (*((unsigned char *)a4 + 316)) {
    return;
  }
  if (*((_DWORD *)a4 + 28) != 2) {
LABEL_76:
  }
    std::__throw_bad_variant_access[abi:nn180100]();
  *(void *)((char *)&v34 + 4) = *(void *)((char *)a4 + 100);
  HIDWORD(v34) = *((_DWORD *)a4 + 27);
  a4[19] = v34;
  *((_DWORD *)a4 + 80) = 2;
}

void SVG::resolveCurrentColor(uint64_t a1, const void *a2, char a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 56) != 2) {
    std::__throw_bad_variant_access[abi:nn180100]();
  }
  uint64_t v4 = a1 + 8;
  int v5 = *(_DWORD *)(a1 + 48);
  if (v5 == 3)
  {
    if (*(unsigned char *)(a1 + 40)) {
      BOOL v6 = *(_DWORD *)(a1 + 36) == 1;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      char v7 = *(const void **)(a1 + 16);
      if (v7)
      {
        CFRetain(*(CFTypeRef *)(a1 + 16));
        char v8 = *(unsigned char *)(a1 + 41);
        char v9 = *(unsigned char *)(a1 + 42);
        char v10 = *(unsigned char *)(a1 + 43);
        long long v12 = v7;
        CFRetain(v7);
      }
      else
      {
        char v8 = *(unsigned char *)(a1 + 41);
        char v9 = *(unsigned char *)(a1 + 42);
        char v10 = *(unsigned char *)(a1 + 43);
        long long v12 = 0;
      }
      int v13 = 0;
      uint64_t v14 = 0;
      int v15 = 3;
      char v16 = 1;
      char v17 = v8;
      char v18 = v9;
      char v19 = v10;
      unsigned int v20 = 3;
      v22[0] = 0;
      int v23 = -1;
      std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>((uint64_t)v22, (uint64_t)&v12);
      unsigned int v24 = 2;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>(v4, (uint64_t)&v21);
      if (v24 != -1) {
        ((void (*)(char *, uint64_t *))*(&off_1F1A74F60 + v24))(&v11, &v21);
      }
      unsigned int v24 = -1;
      if (v20 != -1) {
        ((void (*)(char *, const void **))*(&off_1F1A74F90 + v20))(&v11, &v12);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
  }
  else if (v5 == 1)
  {
    if (a3)
    {
      long long v12 = a2;
      unsigned int v20 = 2;
    }
    else
    {
      LODWORD(v12) = 0;
      unsigned int v20 = 4;
    }
    v22[0] = 0;
    int v23 = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>((uint64_t)v22, (uint64_t)&v12);
    unsigned int v24 = 2;
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>(v4, (uint64_t)&v21);
    if (v24 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A74F60 + v24))(&v11, &v21);
    }
    unsigned int v24 = -1;
    if (v20 != -1) {
      ((void (*)(char *, const void **))*(&off_1F1A74F90 + v20))(&v11, &v12);
    }
  }
}

uint64_t SVG::Presentation::specifiedInherit@<X0>(SVG::Presentation *this@<X0>, const SVG::Presentation *a2@<X1>, _OWORD *a3@<X8>)
{
  memcpy(a3, &unk_1BF1D9678, 0x240uLL);
  long long v7 = *((_OWORD *)this + 1);
  *a3 = *(_OWORD *)this;
  a3[1] = v7;
  a3[2] = *((_OWORD *)this + 2);
  *((void *)a3 + 6) = *((void *)this + 6);
  *((unsigned char *)a3 + 64) = 0;
  *((_DWORD *)a3 + 20) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a3 + 4), (uint64_t)this + 64);
  *(_OWORD *)((char *)a3 + 88) = *(_OWORD *)((char *)this + 88);
  *(_OWORD *)((char *)a3 + 104) = *(_OWORD *)((char *)this + 104);
  *(_OWORD *)((char *)a3 + 120) = *(_OWORD *)((char *)this + 120);
  *((_DWORD *)a3 + 34) = *((_DWORD *)this + 34);
  *((unsigned char *)a3 + 152) = 0;
  *((_DWORD *)a3 + 50) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)a3 + 152, (uint64_t)this + 152);
  *((unsigned char *)a3 + 248) = 0;
  long long v8 = *((_OWORD *)this + 14);
  a3[13] = *((_OWORD *)this + 13);
  a3[14] = v8;
  *((_DWORD *)a3 + 66) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)a3 + 248, (uint64_t)this + 248);
  long long v9 = *((_OWORD *)this + 17);
  a3[18] = *((_OWORD *)this + 18);
  long long v10 = *((_OWORD *)this + 20);
  a3[19] = *((_OWORD *)this + 19);
  a3[20] = v10;
  *((void *)a3 + 42) = *((void *)this + 42);
  a3[17] = v9;
  *((unsigned char *)a3 + 352) = 0;
  *((_DWORD *)a3 + 100) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a3 + 22), (uint64_t)this + 352);
  *((unsigned char *)a3 + 416) = 0;
  *((_DWORD *)a3 + 112) = -1;
  uint64_t result = std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a3 + 26), (uint64_t)this + 416);
  long long v12 = *(_OWORD *)((char *)this + 536);
  *(_OWORD *)((char *)a3 + 520) = *(_OWORD *)((char *)this + 520);
  *(_OWORD *)((char *)a3 + 536) = v12;
  *(_OWORD *)((char *)a3 + 552) = *(_OWORD *)((char *)this + 552);
  *((void *)a3 + 71) = *((void *)this + 71);
  long long v13 = *(_OWORD *)((char *)this + 472);
  *(_OWORD *)((char *)a3 + 456) = *(_OWORD *)((char *)this + 456);
  *(_OWORD *)((char *)a3 + 472) = v13;
  long long v14 = *(_OWORD *)((char *)this + 504);
  *(_OWORD *)((char *)a3 + 488) = *(_OWORD *)((char *)this + 488);
  *(_OWORD *)((char *)a3 + 504) = v14;
  if (!*((_DWORD *)this + 12) && *((_DWORD *)a2 + 12))
  {
    long long v15 = *((_OWORD *)a2 + 1);
    *a3 = *(_OWORD *)a2;
    a3[1] = v15;
    a3[2] = *((_OWORD *)a2 + 2);
    *((void *)a3 + 6) = *((void *)a2 + 6);
  }
  if (!*((_DWORD *)this + 20) && *((_DWORD *)a2 + 20)) {
    uint64_t result = std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a3 + 4), (uint64_t)a2 + 64);
  }
  if (!*((_DWORD *)this + 23) && *((_DWORD *)a2 + 23)) {
    *((void *)a3 + 11) = *((void *)a2 + 11);
  }
  if (!*((_DWORD *)this + 28) && *((_DWORD *)a2 + 28))
  {
    a3[6] = *((_OWORD *)a2 + 6);
    *((_DWORD *)a3 + 28) = *((_DWORD *)a2 + 28);
  }
  if (!*((_DWORD *)this + 30) && *((_DWORD *)a2 + 30)) {
    *(void *)((char *)a3 + 116) = *(void *)((char *)a2 + 116);
  }
  if (!*((_DWORD *)this + 32) && *((_DWORD *)a2 + 32)) {
    *(void *)((char *)a3 + 124) = *(void *)((char *)a2 + 124);
  }
  if (!*((_DWORD *)this + 34) && *((_DWORD *)a2 + 34)) {
    *(void *)((char *)a3 + 132) = *(void *)((char *)a2 + 132);
  }
  if (!*((_DWORD *)this + 50) && *((_DWORD *)a2 + 50)) {
    uint64_t result = std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)a3 + 152, (uint64_t)a2 + 152);
  }
  if (!*((_DWORD *)this + 54) && *((_DWORD *)a2 + 54)) {
    a3[13] = *((_OWORD *)a2 + 13);
  }
  if (!*((_DWORD *)this + 57) && *((_DWORD *)a2 + 57)) {
    *((void *)a3 + 28) = *((void *)a2 + 28);
  }
  if (!*((_DWORD *)this + 59) && *((_DWORD *)a2 + 59)) {
    *((void *)a3 + 29) = *((void *)a2 + 29);
  }
  if (!*((_DWORD *)this + 66) && *((_DWORD *)a2 + 66)) {
    uint64_t result = std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)a3 + 248, (uint64_t)a2 + 248);
  }
  if (!*((_DWORD *)this + 70) && *((_DWORD *)a2 + 70)) {
    a3[17] = *((_OWORD *)a2 + 17);
  }
  if (!*((_DWORD *)this + 73) && *((_DWORD *)a2 + 73)) {
    *((void *)a3 + 36) = *((void *)a2 + 36);
  }
  if (!*((_DWORD *)this + 75) && *((_DWORD *)a2 + 75)) {
    *((void *)a3 + 37) = *((void *)a2 + 37);
  }
  if (!*((_DWORD *)this + 80) && *((_DWORD *)a2 + 80))
  {
    a3[19] = *((_OWORD *)a2 + 19);
    *((_DWORD *)a3 + 80) = *((_DWORD *)a2 + 80);
  }
  if (!*((_DWORD *)this + 84) && *((_DWORD *)a2 + 84)) {
    *(_OWORD *)((char *)a3 + 328) = *(_OWORD *)((char *)a2 + 328);
  }
  if (!*((_DWORD *)this + 100) && *((_DWORD *)a2 + 100)) {
    uint64_t result = std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a3 + 22), (uint64_t)a2 + 352);
  }
  if (!*((_DWORD *)this + 112) && *((_DWORD *)a2 + 112)) {
    uint64_t result = std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(a3 + 26), (uint64_t)a2 + 416);
  }
  if (!*((_DWORD *)this + 120) && *((_DWORD *)a2 + 120))
  {
    long long v16 = *(_OWORD *)((char *)a2 + 472);
    *(_OWORD *)((char *)a3 + 456) = *(_OWORD *)((char *)a2 + 456);
    *(_OWORD *)((char *)a3 + 472) = v16;
  }
  if (!*((_DWORD *)this + 123) && *((_DWORD *)a2 + 123)) {
    *((void *)a3 + 61) = *((void *)a2 + 61);
  }
  if (!*((_DWORD *)this + 125) && *((_DWORD *)a2 + 125)) {
    *((void *)a3 + 62) = *((void *)a2 + 62);
  }
  if (!*((_DWORD *)this + 128) && *((_DWORD *)a2 + 128)) {
    *(_OWORD *)((char *)a3 + 504) = *(_OWORD *)((char *)a2 + 504);
  }
  if (!*((_DWORD *)this + 132) && *((_DWORD *)a2 + 132)) {
    *(_OWORD *)((char *)a3 + 520) = *(_OWORD *)((char *)a2 + 520);
  }
  if (!*((_DWORD *)this + 140) && *((_DWORD *)a2 + 140))
  {
    long long v17 = *(_OWORD *)((char *)a2 + 552);
    *(_OWORD *)((char *)a3 + 536) = *(_OWORD *)((char *)a2 + 536);
    *(_OWORD *)((char *)a3 + 552) = v17;
  }
  if (!*((_DWORD *)this + 143))
  {
    if (*((_DWORD *)a2 + 143)) {
      *((void *)a3 + 71) = *((void *)a2 + 71);
    }
  }
  return result;
}

void SVG::Presentation::Presentation(uint64_t a1, void *a2)
{
  uint64_t v211 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  uint64_t v4 = a1 + 64;
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  uint64_t v5 = a1 + 152;
  *(_DWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 248) = 0;
  uint64_t v6 = a1 + 248;
  *(_DWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 308) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 480) = 0;
  *(_DWORD *)(a1 + 512) = 0;
  *(_DWORD *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 528) = 0;
  *(_DWORD *)(a1 + 544) = 0;
  *(_DWORD *)(a1 + 560) = 0;
  *(void *)(a1 + 112) = 0;
  uint64_t v7 = a1 + 112;
  *(void *)(a1 + 224) = 0;
  long long v8 = (uint64_t *)(a1 + 224);
  *(void *)(a1 + 568) = 0;
  *(void *)(a1 + 288) = 0;
  long long v9 = (uint64_t *)(a1 + 288);
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 504) = 0;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = 0;
  std::string::basic_string[abi:nn180100]<0>(__p, "clip");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  long long v10 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v10)
  {
    if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", (uint64_t)(v10 + 64)))
    {
      int v12 = 0;
      int v13 = 1;
    }
    else if (SVG::consumeStringAlone<5ul>((uint64_t)"auto", (uint64_t)(v10 + 64)))
    {
      uint64_t v11 = 0;
      int v12 = 0;
      memset(__p, 0, 28);
      int v13 = 2;
    }
    else
    {
      unint64_t v14 = 0;
      do
      {
        uint64_t v15 = v14;
        unint64_t v14 = SVG::consumeWsp((uint64_t *)v10 + 8, v14);
      }
      while (v16);
      *(void *)&long long v17 = -1;
      *((void *)&v17 + 1) = -1;
      *(_OWORD *)__p = v17;
      *(_OWORD *)&__p[16] = v17;
      memset(&__p[32], 170, 24);
      SVG::consumeClipRect((uint64_t *)v10 + 8, v15, (uint64_t)__p);
      if (!__p[48]) {
        goto LABEL_19;
      }
      unint64_t v18 = *(void *)&__p[40];
      do
      {
        unint64_t v19 = v18;
        unint64_t v18 = SVG::consumeWsp((uint64_t *)v10 + 8, v18);
      }
      while (v20);
      uint64_t v21 = v10[87];
      uint64_t v11 = (char)v21;
      if ((int)v11 < 0) {
        uint64_t v21 = *((void *)v10 + 9);
      }
      if (v19 == v21)
      {
        int v12 = *(_DWORD *)__p;
        *(_OWORD *)&__str[12] = *(_OWORD *)&__p[16];
        uint64_t v11 = *(void *)&__p[32];
        *(_OWORD *)__p = *(_OWORD *)&__p[4];
        *(_OWORD *)__str = *(_OWORD *)__p;
        *(_OWORD *)&__p[12] = *(_OWORD *)&__str[12];
        int v13 = 2;
      }
      else
      {
LABEL_19:
        int v13 = 0;
        int v12 = 0;
      }
    }
    *(_DWORD *)(a1 + 8) = v12;
    *(_OWORD *)(a1 + 12) = *(_OWORD *)__p;
    *(_OWORD *)(a1 + 24) = *(_OWORD *)&__p[12];
    *(void *)(a1 + 40) = v11;
    *(_DWORD *)(a1 + 48) = v13;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "clip-path");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  char v22 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v22)
  {
    SVG::consumeIRIOrNone((uint64_t)__p, (uint64_t)(v22 + 64));
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>(v4, (uint64_t)&__p[8]);
    if (*(_DWORD *)&__p[24] != -1) {
      ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A74F30 + *(unsigned int *)&__p[24]))(__str, &__p[8]);
    }
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "clip-rule");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  int v23 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v23) {
    *(void *)(a1 + 88) = SVG::consumeFillRule((uint64_t)(v23 + 64));
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "color");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  unsigned int v24 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if (!v24) {
      goto LABEL_84;
    }
  }
  else if (!v24)
  {
    goto LABEL_84;
  }
  uint64_t v25 = (uint64_t *)(v24 + 64);
  uint64_t v26 = SVG::consumeColorAlone((uint64_t)v25);
  if (!HIDWORD(v27))
  {
    memset(__str, 170, 24);
    SVG::CSS::preprocess(v25, __str);
    unint64_t v28 = 0;
    do
    {
      uint64_t v29 = v28;
      unint64_t v28 = SVG::CSS::consumeWhitespace((uint64_t *)__str, v28);
    }
    while (v30);
    unint64_t v31 = SVG::consumeString<5ul>((uint64_t)"var(", (uint64_t)__str, v29);
    if (v32)
    {
      do
      {
        unint64_t v33 = v31;
        unint64_t v31 = SVG::CSS::consumeWhitespace((uint64_t *)__str, v31);
      }
      while (v34);
      *(void *)&long long v35 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)__p = v35;
      *(_OWORD *)&__p[16] = v35;
      SVG::CSS::consumeAName((uint64_t *)__str, v33, (std::string *)__p);
      *(_OWORD *)v203 = *(_OWORD *)__p;
      unint64_t v36 = *(void *)&__p[24];
      uint64_t v204 = *(void *)&__p[16];
      memset(__p, 0, 24);
      if (__str[23] >= 0) {
        unint64_t v37 = __str[23];
      }
      else {
        unint64_t v37 = *(void *)&__str[8];
      }
      do
        SVG::CSS::consumeWhitespace((uint64_t *)__str, --v37);
      while (v38);
      SVG::consumeString<2ul>(")", (uint64_t *)__str, v37);
      if (v39)
      {
        unint64_t v40 = SVG::consumeString<8ul>((uint64_t)"--color", (uint64_t)v203, 0);
        if (v41
          && (memset(&v202, 170, sizeof(v202)),
              SVG::consumeInteger((uint64_t)v203, v40, (uint64_t)&v202),
              v202.__r_.__value_.__s.__data_[16]))
        {
          uint64_t v42 = v202.__r_.__value_.__r.__words[0];
          if ((uint64_t)v202.__r_.__value_.__l.__data_ >= 0xFFFF) {
            uint64_t v42 = 0xFFFFLL;
          }
          *(void *)&v209[4] = v42 & ~(v42 >> 63) | 0x1AAAA0000;
          *(_DWORD *)&v209[12] = 2;
        }
        else
        {
          uint64_t v43 = v7;
          uint64_t v44 = v5;
          v45 = v8;
          uint64_t v46 = v6;
          v47 = v9;
          do
          {
            uint64_t v48 = v36;
            unint64_t v36 = SVG::CSS::consumeWhitespace((uint64_t *)__str, v36);
          }
          while (v49);
          unint64_t v50 = SVG::consumeString<2ul>(",", (uint64_t *)__str, v48);
          if (v51)
          {
            std::string::size_type v52 = v50;
            long long v9 = v47;
            do
              SVG::CSS::consumeWhitespace((uint64_t *)__str, v37--);
            while (v53);
            memset(&v202, 170, sizeof(v202));
            std::string::basic_string(&v202, (const std::string *)__str, v52, v37 - v52 + 1, (std::allocator<char> *)v209);
            *(void *)v209 = SVG::consumeColorAlone((uint64_t)&v202);
            *(void *)&v209[8] = v54;
            uint64_t v6 = v46;
            if (SHIBYTE(v202.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v202.__r_.__value_.__l.__data_);
            }
          }
          else
          {
            *(_DWORD *)&v209[4] = 0;
            *(_DWORD *)&v209[12] = 0;
            long long v9 = v47;
            uint64_t v6 = v46;
          }
          long long v8 = v45;
          uint64_t v5 = v44;
          uint64_t v7 = v43;
        }
      }
      else
      {
        *(_DWORD *)&v209[4] = 0;
        *(_DWORD *)&v209[12] = 0;
      }
      if (SHIBYTE(v204) < 0) {
        operator delete(v203[0]);
      }
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }
    else
    {
      *(_DWORD *)&v209[4] = 0;
      *(_DWORD *)&v209[12] = 0;
    }
    if ((__str[23] & 0x80000000) != 0) {
      operator delete(*(void **)__str);
    }
    unint64_t v27 = *(void *)&v209[8];
    uint64_t v26 = *(void *)v209;
  }
  *(void *)__p = v26;
  *(void *)&__p[8] = v27;
  if (HIDWORD(v27) == 2)
  {
    uint64_t v55 = *(void *)&__p[4];
    if (*(_DWORD *)v7 != 2) {
      *(_DWORD *)uint64_t v7 = 2;
    }
    *(void *)(a1 + 100) = v55;
    *(unsigned char *)(a1 + 108) = 1;
  }
  else
  {
    if (HIDWORD(v27) == 1)
    {
      if (*(_DWORD *)v7 != 1) {
        *(_DWORD *)uint64_t v7 = 1;
      }
    }
    else
    {
      if (HIDWORD(v27))
      {
        uint64_t v199 = std::__throw_bad_variant_access[abi:nn180100]();
        SVG::consumeIRIOrNone(v199, v200);
        return;
      }
      if (*(_DWORD *)v7) {
        *(_DWORD *)uint64_t v7 = 0;
      }
    }
    *(_DWORD *)(a1 + 100) = 0;
  }
LABEL_84:
  std::string::basic_string[abi:nn180100]<0>(__p, "color-interpolation");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v56 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v56)
  {
    if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", (uint64_t)(v56 + 64)))
    {
      uint64_t v57 = 0;
      uint64_t v58 = 0x100000000;
    }
    else if (SVG::consumeStringAlone<5ul>((uint64_t)"auto", (uint64_t)(v56 + 64)))
    {
      uint64_t v57 = 0;
      uint64_t v58 = 0x200000000;
    }
    else if (SVG::consumeStringAlone<5ul>((uint64_t)"sRGB", (uint64_t)(v56 + 64)))
    {
      uint64_t v58 = 0x200000000;
      uint64_t v57 = 1;
    }
    else
    {
      uint64_t v59 = v7;
      uint64_t v60 = v5;
      v61 = v8;
      uint64_t v62 = v6;
      v63 = v9;
      unint64_t v64 = 0;
      do
      {
        uint64_t v65 = v64;
        unint64_t v64 = SVG::consumeWsp((uint64_t *)v56 + 8, v64);
      }
      while (v66);
      unint64_t v67 = SVG::consumeString<10ul>((uint64_t)"linearRGB", (uint64_t)(v56 + 64), v65);
      if (v68)
      {
        do
        {
          unint64_t v69 = v67;
          unint64_t v67 = SVG::consumeWsp((uint64_t *)v56 + 8, v67);
        }
        while (v70);
        uint64_t v71 = v56[87];
        if ((v71 & 0x80u) != 0) {
          uint64_t v71 = *((void *)v56 + 9);
        }
        uint64_t v72 = v69 == v71;
        uint64_t v57 = 2 * v72;
        uint64_t v58 = v72 << 33;
      }
      else
      {
        uint64_t v57 = 0;
        uint64_t v58 = 0;
      }
      long long v9 = v63;
      uint64_t v6 = v62;
      long long v8 = v61;
      uint64_t v5 = v60;
      uint64_t v7 = v59;
    }
    *(void *)(a1 + 116) = v58 | v57;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "color-rendering");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v73 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v73) {
    *(void *)(a1 + 124) = SVG::consumeRenderingQuality((uint64_t)(v73 + 64));
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "display");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v74 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v74)
  {
    uint64_t v75 = (uint64_t)(v74 + 64);
    if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", v75))
    {
      uint64_t v76 = 0;
      uint64_t v77 = 0x100000000;
    }
    else if (SVG::consumeStringAlone<7ul>((uint64_t)"inline", v75))
    {
      uint64_t v76 = 0;
      uint64_t v77 = 0x200000000;
    }
    else
    {
      uint64_t v77 = 0x200000000;
      if (SVG::consumeStringAlone<6ul>((uint64_t)"block", v75))
      {
        uint64_t v76 = 1;
      }
      else
      {
        BOOL v78 = SVG::consumeStringAlone<5ul>((uint64_t)"none", v75);
        if (!v78) {
          uint64_t v77 = 0;
        }
        uint64_t v76 = 2;
        if (!v78) {
          uint64_t v76 = 0;
        }
      }
    }
    *(void *)(a1 + 132) = v77 | v76;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "fill");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v79 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v79)
  {
    SVG::parseAloneOrVar<SVG::Presentation::Paint>((uint64_t)__p, (uint64_t *)v79 + 8);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>(v5, (uint64_t)&__p[8]);
    if (v208 != -1) {
      ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A74F60 + v208))(__str, &__p[8]);
    }
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "fill-opacity");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v80 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v80)
  {
    *(void *)(a1 + 208) = SVG::consumeOpacity((uint64_t)(v80 + 64));
    *(void *)(a1 + 216) = v81;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "fill-rule");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v82 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v82) {
    *long long v8 = SVG::consumeFillRule((uint64_t)(v82 + 64));
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "image-rendering");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v83 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v83) {
    *(void *)(a1 + 232) = SVG::consumeRenderingQuality((uint64_t)(v83 + 64));
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "mask");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v84 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v84)
  {
    SVG::consumeIRIOrNone((uint64_t)__p, (uint64_t)(v84 + 64));
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>(v6, (uint64_t)&__p[8]);
    if (*(_DWORD *)&__p[24] != -1) {
      ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A74F30 + *(unsigned int *)&__p[24]))(__str, &__p[8]);
    }
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "opacity");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v85 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v85)
  {
    *(void *)(a1 + 272) = SVG::consumeOpacity((uint64_t)(v85 + 64));
    *(void *)(a1 + 280) = v86;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "overflow");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v87 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v87)
  {
    uint64_t v88 = (uint64_t)(v87 + 64);
    if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", v88))
    {
      uint64_t v89 = 0;
      uint64_t v90 = 0x100000000;
    }
    else if (SVG::consumeStringAlone<8ul>((uint64_t)"visible", v88))
    {
      uint64_t v89 = 0;
      uint64_t v90 = 0x200000000;
    }
    else
    {
      uint64_t v90 = 0x200000000;
      if (SVG::consumeStringAlone<7ul>((uint64_t)"hidden", v88))
      {
        uint64_t v89 = 1;
      }
      else
      {
        BOOL v91 = SVG::consumeStringAlone<5ul>((uint64_t)"auto", v88);
        if (!v91) {
          uint64_t v90 = 0;
        }
        uint64_t v89 = 2;
        if (!v91) {
          uint64_t v89 = 0;
        }
      }
    }
    *long long v9 = v90 | v89;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "shape-rendering");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v92 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v92)
  {
    if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", (uint64_t)(v92 + 64)))
    {
      uint64_t v93 = 0;
      uint64_t v94 = 0x100000000;
    }
    else if (SVG::consumeStringAlone<14ul>((uint64_t)(v92 + 64)))
    {
      uint64_t v94 = 0x200000000;
      uint64_t v93 = 1;
    }
    else
    {
      uint64_t v201 = v7;
      unint64_t v95 = 0;
      do
      {
        unint64_t v96 = v95;
        unint64_t v95 = SVG::consumeWsp((uint64_t *)v92 + 8, v95);
      }
      while (v97);
      unint64_t v98 = v92[87];
      if ((v98 & 0x80u) != 0) {
        unint64_t v98 = *((void *)v92 + 9);
      }
      unint64_t v99 = v96 + 10;
      if (v98 >= v96 + 10)
      {
        uint64_t v100 = 0;
        while (1)
        {
          uint64_t v101 = (v92[87] & 0x80u) == 0 ? (uint64_t)(v92 + 64) : *((void *)v92 + 8);
          int v102 = *(char *)(v101 + v96 + v100);
          __darwin_ct_rune_t v103 = aCrispedges[v100];
          if (__tolower(v103) != v102)
          {
            uint64_t v104 = (v92[87] & 0x80u) == 0 ? (uint64_t)(v92 + 64) : *((void *)v92 + 8);
            int v105 = *(char *)(v104 + v96 + v100);
            if (__toupper(v103) != v105) {
              break;
            }
          }
          if (++v100 == 10)
          {
            do
            {
              unint64_t v106 = v99;
              unint64_t v99 = SVG::consumeWsp((uint64_t *)v92 + 8, v99);
            }
            while (v107);
            uint64_t v108 = v92[87];
            if ((v108 & 0x80u) != 0) {
              uint64_t v108 = *((void *)v92 + 9);
            }
            if (v106 == v108)
            {
              uint64_t v94 = 0x200000000;
              uint64_t v93 = 2;
              goto LABEL_232;
            }
            break;
          }
        }
      }
      unint64_t v109 = 0;
      do
      {
        unint64_t v110 = v109;
        unint64_t v109 = SVG::consumeWsp((uint64_t *)v92 + 8, v109);
      }
      while (v111);
      unint64_t v112 = v92[87];
      if ((v112 & 0x80u) != 0) {
        unint64_t v112 = *((void *)v92 + 9);
      }
      unint64_t v113 = v110 + 18;
      if (v112 >= v110 + 18)
      {
        uint64_t v114 = 0;
        while (1)
        {
          uint64_t v115 = (v92[87] & 0x80u) == 0 ? (uint64_t)(v92 + 64) : *((void *)v92 + 8);
          int v116 = *(char *)(v115 + v110 + v114);
          __darwin_ct_rune_t v117 = aGeometricpreci[v114];
          if (__tolower(v117) != v116)
          {
            uint64_t v118 = (v92[87] & 0x80u) == 0 ? (uint64_t)(v92 + 64) : *((void *)v92 + 8);
            int v119 = *(char *)(v118 + v110 + v114);
            if (__toupper(v117) != v119) {
              break;
            }
          }
          if (++v114 == 18)
          {
            do
            {
              unint64_t v120 = v113;
              unint64_t v113 = SVG::consumeWsp((uint64_t *)v92 + 8, v113);
            }
            while (v121);
            uint64_t v122 = v92[87];
            if ((v122 & 0x80u) != 0) {
              uint64_t v122 = *((void *)v92 + 9);
            }
            if (v120 == v122)
            {
              uint64_t v94 = 0x200000000;
              uint64_t v93 = 3;
              goto LABEL_232;
            }
            break;
          }
        }
      }
      BOOL v123 = SVG::consumeStringAlone<5ul>((uint64_t)"auto", (uint64_t)(v92 + 64));
      uint64_t v93 = 0;
      uint64_t v94 = 0x200000000;
      if (!v123) {
        uint64_t v94 = 0;
      }
LABEL_232:
      uint64_t v7 = v201;
    }
    *(void *)(a1 + 296) = v94 | v93;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "stop-color");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v124 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v124)
  {
    v125 = (uint64_t *)(v124 + 64);
    memset(v209, 170, sizeof(v209));
    SVG::consumeStopColor((uint64_t)v209, (uint64_t)v125);
    if (*(_DWORD *)&v209[16])
    {
      long long v205 = *(_OWORD *)v209;
      int v206 = *(_DWORD *)&v209[16];
LABEL_269:
      *(_OWORD *)(v7 + 192) = v205;
      *(_DWORD *)(v7 + 208) = v206;
      goto LABEL_270;
    }
    memset(__str, 170, 24);
    SVG::CSS::preprocess(v125, __str);
    unint64_t v126 = 0;
    do
    {
      uint64_t v127 = v126;
      unint64_t v126 = SVG::CSS::consumeWhitespace((uint64_t *)__str, v126);
    }
    while (v128);
    unint64_t v129 = SVG::consumeString<5ul>((uint64_t)"var(", (uint64_t)__str, v127);
    if (!v130)
    {
      DWORD1(v205) = 0;
      int v206 = 0;
LABEL_267:
      if ((__str[23] & 0x80000000) != 0) {
        operator delete(*(void **)__str);
      }
      goto LABEL_269;
    }
    do
    {
      unint64_t v131 = v129;
      unint64_t v129 = SVG::CSS::consumeWhitespace((uint64_t *)__str, v129);
    }
    while (v132);
    *(void *)&long long v133 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v133 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)__p = v133;
    *(_OWORD *)&__p[16] = v133;
    SVG::CSS::consumeAName((uint64_t *)__str, v131, (std::string *)__p);
    *(_OWORD *)v203 = *(_OWORD *)__p;
    unint64_t v134 = *(void *)&__p[24];
    uint64_t v204 = *(void *)&__p[16];
    memset(__p, 0, 24);
    if (__str[23] >= 0) {
      unint64_t v135 = __str[23];
    }
    else {
      unint64_t v135 = *(void *)&__str[8];
    }
    do
      SVG::CSS::consumeWhitespace((uint64_t *)__str, --v135);
    while (v136);
    SVG::consumeString<2ul>(")", (uint64_t *)__str, v135);
    if (v137)
    {
      unint64_t v138 = SVG::consumeString<8ul>((uint64_t)"--color", (uint64_t)v203, 0);
      if (v139)
      {
        memset(&v202, 170, sizeof(v202));
        SVG::consumeInteger((uint64_t)v203, v138, (uint64_t)&v202);
        if (v202.__r_.__value_.__s.__data_[16])
        {
          uint64_t v140 = v202.__r_.__value_.__r.__words[0];
          if ((uint64_t)v202.__r_.__value_.__l.__data_ >= 0xFFFF) {
            uint64_t v140 = 0xFFFFLL;
          }
          *(void *)((char *)&v205 + 4) = v140 & ~(v140 >> 63) | 0x1AAAA0000;
          BYTE12(v205) = 1;
          int v206 = 2;
          goto LABEL_263;
        }
      }
      do
      {
        uint64_t v141 = v134;
        unint64_t v134 = SVG::CSS::consumeWhitespace((uint64_t *)__str, v134);
      }
      while (v142);
      unint64_t v143 = SVG::consumeString<2ul>(",", (uint64_t *)__str, v141);
      if (v144)
      {
        std::string::size_type v145 = v143;
        do
          SVG::CSS::consumeWhitespace((uint64_t *)__str, v135--);
        while (v146);
        memset(&v202, 170, sizeof(v202));
        std::string::basic_string(&v202, (const std::string *)__str, v145, v135 - v145 + 1, (std::allocator<char> *)&v205);
        SVG::consumeStopColor((uint64_t)&v205, (uint64_t)&v202);
        if (SHIBYTE(v202.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v202.__r_.__value_.__l.__data_);
        }
        goto LABEL_263;
      }
    }
    DWORD1(v205) = 0;
    int v206 = 0;
LABEL_263:
    if (SHIBYTE(v204) < 0) {
      operator delete(v203[0]);
    }
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    goto LABEL_267;
  }
LABEL_270:
  std::string::basic_string[abi:nn180100]<0>(__p, "stop-opacity");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v147 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v147)
  {
    *(void *)(a1 + 328) = SVG::consumeOpacity((uint64_t)(v147 + 64));
    *(void *)(a1 + 336) = v148;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "stroke");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v149 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v149)
  {
    SVG::parseAloneOrVar<SVG::Presentation::Paint>((uint64_t)__p, (uint64_t *)v149 + 8);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>(a1 + 352, (uint64_t)&__p[8]);
    if (v208 != -1) {
      ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A74F60 + v208))(__str, &__p[8]);
    }
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "stroke-dasharray");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v150 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (!v150) {
    goto LABEL_312;
  }
  if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", (uint64_t)(v150 + 64)))
  {
    int v151 = 1;
    *(_DWORD *)&__p[8] = 0;
LABEL_309:
    *(_DWORD *)&__p[40] = v151;
    goto LABEL_310;
  }
  if (SVG::consumeStringAlone<5ul>((uint64_t)"none", (uint64_t)(v150 + 64)))
  {
    __p[8] = 0;
    __p[32] = 0;
LABEL_308:
    int v151 = 2;
    goto LABEL_309;
  }
  unint64_t v152 = 0;
  *(void *)&long long v153 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v153 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&__str[16] = v153;
  *(_OWORD *)__str = v153;
  do
  {
    unint64_t v154 = v152;
    unint64_t v152 = SVG::consumeWsp((uint64_t *)v150 + 8, v152);
  }
  while (v155);
  *(void *)&__p[32] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v156 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v156 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__p = v156;
  *(_OWORD *)&__p[16] = v156;
  SVG::consumeDashArrayValue((uint64_t *)v150 + 8, v154, (uint64_t)__p);
  if (__p[32])
  {
    unint64_t v157 = *(void *)&__p[24];
    do
    {
      unint64_t v158 = v157;
      unint64_t v157 = SVG::consumeWsp((uint64_t *)v150 + 8, v157);
    }
    while (v159);
    uint64_t v160 = v150[87];
    if ((v160 & 0x80u) != 0) {
      uint64_t v160 = *((void *)v150 + 9);
    }
    if (v158 == v160)
    {
      memset(__str, 0, 24);
      v161 = *(void **)__p;
      int64_t v162 = *(void *)&__p[8] - *(void *)__p;
      if (*(void *)&__p[8] != *(void *)__p)
      {
        std::vector<SVG::Length>::__vallocate[abi:nn180100](__str, v162 >> 4);
        uint64_t v163 = *(void *)&__str[8];
        memmove(*(void **)&__str[8], v161, v162);
        *(void *)&__str[8] = v163 + v162;
      }
      int v164 = 1;
    }
    else
    {
      int v164 = 0;
      __str[0] = 0;
      v161 = *(void **)__p;
    }
    __str[24] = v164;
    if (v161)
    {
      operator delete(v161);
      int v164 = __str[24];
    }
    if (v164)
    {
      *(_OWORD *)&__p[8] = *(_OWORD *)__str;
      *(void *)&__p[24] = *(void *)&__str[16];
      __p[32] = 1;
      goto LABEL_308;
    }
  }
  *(_DWORD *)&__p[8] = 0;
  *(_DWORD *)&__p[40] = 0;
LABEL_310:
  std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1>>(a1 + 416, (uint64_t)&__p[8]);
  if (*(_DWORD *)&__p[40] != -1) {
    ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A75008 + *(unsigned int *)&__p[40]))(__str, &__p[8]);
  }
LABEL_312:
  std::string::basic_string[abi:nn180100]<0>(__p, "stroke-dashoffset");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v165 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v165)
  {
    *(void *)__p = -1;
    *(void *)&__p[8] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__p[16] = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeAlone<SVG::Length>((uint64_t)(v165 + 64), (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeLength, (uint64_t)__p);
    if (__p[16])
    {
      *(_OWORD *)&__str[8] = *(_OWORD *)__p;
      *(_OWORD *)(v7 + 344) = *(_OWORD *)__str;
      *(void *)(v7 + 360) = *(void *)&__str[16];
      *(_DWORD *)(a1 + 480) = 2;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "stroke-linecap");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v166 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v166)
  {
    uint64_t v167 = (uint64_t)(v166 + 64);
    if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", v167))
    {
      uint64_t v168 = 0;
      uint64_t v169 = 0x100000000;
    }
    else if (SVG::consumeStringAlone<5ul>((uint64_t)"butt", v167))
    {
      uint64_t v168 = 0;
      uint64_t v169 = 0x200000000;
    }
    else
    {
      uint64_t v169 = 0x200000000;
      if (SVG::consumeStringAlone<6ul>((uint64_t)"round", v167))
      {
        uint64_t v168 = 1;
      }
      else
      {
        BOOL v170 = SVG::consumeStringAlone<7ul>((uint64_t)"square", v167);
        if (!v170) {
          uint64_t v169 = 0;
        }
        uint64_t v168 = 2;
        if (!v170) {
          uint64_t v168 = 0;
        }
      }
    }
    *(void *)(v7 + 376) = v169 | v168;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "stroke-linejoin");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v171 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v171)
  {
    uint64_t v172 = (uint64_t)(v171 + 64);
    if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", v172))
    {
      uint64_t v173 = 0;
      uint64_t v174 = 0x100000000;
    }
    else if (SVG::consumeStringAlone<6ul>((uint64_t)"miter", v172))
    {
      uint64_t v173 = 0;
      uint64_t v174 = 0x200000000;
    }
    else
    {
      uint64_t v174 = 0x200000000;
      if (SVG::consumeStringAlone<6ul>((uint64_t)"round", v172))
      {
        uint64_t v173 = 1;
      }
      else
      {
        BOOL v175 = SVG::consumeStringAlone<6ul>((uint64_t)"bevel", v172);
        if (!v175) {
          uint64_t v174 = 0;
        }
        uint64_t v173 = 2;
        if (!v175) {
          uint64_t v173 = 0;
        }
      }
    }
    *(void *)(a1 + 496) = v174 | v173;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "stroke-miterlimit");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v176 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v176)
  {
    uint64_t v177 = (uint64_t)(v176 + 64);
    if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", v177))
    {
      unint64_t v178 = 0;
      uint64_t v179 = 1;
    }
    else
    {
      double v180 = COERCE_DOUBLE(SVG::consumeAlone<double>(v177, (void (*)(uint64_t *__return_ptr, uint64_t, unint64_t))SVG::consumeNumber));
      BOOL v182 = v181 == 0;
      if (v180 < 1.0) {
        BOOL v182 = 1;
      }
      unint64_t v178 = *(void *)&v180 & 0xFFFFFFFF00000000;
      BOOL v183 = !v182;
      uint64_t v179 = 2;
      if (v183) {
        unint64_t v178 = *(void *)&v180;
      }
      else {
        uint64_t v179 = 0;
      }
    }
    *(void *)(a1 + 504) = v178;
    *(void *)(a1 + 512) = v179;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "stroke-opacity");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v184 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v184)
  {
    *(void *)(a1 + 520) = SVG::consumeOpacity((uint64_t)(v184 + 64));
    *(void *)(a1 + 528) = v185;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "stroke-width");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v186 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v186)
  {
    *(void *)__p = -1;
    *(void *)&__p[8] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__p[16] = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeAlone<SVG::Length>((uint64_t)(v186 + 64), (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeLength, (uint64_t)__p);
    if (__p[16])
    {
      *(_OWORD *)&__str[8] = *(_OWORD *)__p;
      *(_OWORD *)(v7 + 424) = *(_OWORD *)__str;
      *(void *)(v7 + 440) = *(void *)&__str[16];
      *(_DWORD *)(a1 + 560) = 2;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "visibility");
  std::string::basic_string[abi:nn180100]<0>(__str, "http://www.w3.org/2000/svg");
  v187 = SVG::Element::findInAttributeMap(a2, (uint64_t)__p, (uint64_t)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (v187)
  {
    if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", (uint64_t)(v187 + 64)))
    {
      uint64_t v188 = 0;
      uint64_t v189 = 0x100000000;
    }
    else if (SVG::consumeStringAlone<8ul>((uint64_t)"visible", (uint64_t)(v187 + 64)))
    {
      uint64_t v188 = 0;
      uint64_t v189 = 0x200000000;
    }
    else if (SVG::consumeStringAlone<7ul>((uint64_t)"hidden", (uint64_t)(v187 + 64)))
    {
      uint64_t v189 = 0x200000000;
      uint64_t v188 = 1;
    }
    else
    {
      unint64_t v190 = 0;
      do
      {
        uint64_t v191 = v190;
        unint64_t v190 = SVG::consumeWsp((uint64_t *)v187 + 8, v190);
      }
      while (v192);
      unint64_t v193 = SVG::consumeString<9ul>((uint64_t)"collapse", (uint64_t)(v187 + 64), v191);
      if (v194)
      {
        do
        {
          unint64_t v195 = v193;
          unint64_t v193 = SVG::consumeWsp((uint64_t *)v187 + 8, v193);
        }
        while (v196);
        uint64_t v197 = v187[87];
        if ((v197 & 0x80u) != 0) {
          uint64_t v197 = *((void *)v187 + 9);
        }
        uint64_t v198 = v195 == v197;
        uint64_t v188 = 2 * v198;
        uint64_t v189 = v198 << 33;
      }
      else
      {
        uint64_t v188 = 0;
        uint64_t v189 = 0;
      }
    }
    *(void *)(a1 + 568) = v189 | v188;
  }
}

void SVG::consumeIRIOrNone(uint64_t a1, uint64_t a2)
{
  if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", a2))
  {
    *(_DWORD *)(a1 + 8) = 0;
    int v4 = 1;
LABEL_6:
    *(_DWORD *)(a1 + 24) = v4;
    return;
  }
  if (SVG::consumeStringAlone<5ul>((uint64_t)"none", a2))
  {
    *(unsigned char *)(a1 + 8) = 0;
    *(unsigned char *)(a1 + 16) = 0;
LABEL_5:
    int v4 = 2;
    goto LABEL_6;
  }
  unint64_t v5 = 0;
  do
  {
    uint64_t v6 = v5;
    unint64_t v5 = SVG::consumeWsp((uint64_t *)a2, v5);
  }
  while (v7);
  memset(cf, 170, sizeof(cf));
  SVG::consumeFuncIRI(a2, v6, (uint64_t)cf);
  if (!LOBYTE(cf[2]))
  {
LABEL_22:
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    return;
  }
  CFTypeRef v8 = cf[1];
  do
  {
    CFTypeRef v9 = v8;
    CFTypeRef v8 = (CFTypeRef)SVG::consumeWsp((uint64_t *)a2, (unint64_t)v8);
  }
  while (v10);
  CFTypeRef v11 = (CFTypeRef)*(unsigned __int8 *)(a2 + 23);
  if ((char)v11 < 0) {
    CFTypeRef v11 = *(CFTypeRef *)(a2 + 8);
  }
  CFTypeRef v12 = cf[0];
  if (v9 != v11)
  {
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    goto LABEL_22;
  }
  if (!cf[0])
  {
    *(void *)(a1 + 8) = 0;
    *(unsigned char *)(a1 + 16) = 1;
    goto LABEL_5;
  }
  CFRetain(cf[0]);
  CFRelease(v12);
  CFRetain(v12);
  *(void *)(a1 + 8) = v12;
  *(unsigned char *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 24) = 2;
  CFRelease(v12);
}

uint64_t SVG::consumeFillRule(uint64_t a1)
{
  if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", a1))
  {
    BOOL v2 = 0;
    uint64_t v3 = 0x100000000;
  }
  else
  {
    uint64_t v3 = 0x200000000;
    if (SVG::consumeStringAlone<8ul>((uint64_t)"nonzero", a1))
    {
      BOOL v2 = 0;
    }
    else
    {
      BOOL v4 = SVG::consumeStringAlone<8ul>((uint64_t)"evenodd", a1);
      if (!v4) {
        uint64_t v3 = 0;
      }
      BOOL v2 = v4;
    }
  }
  return v3 | v2;
}

uint64_t SVG::consumeColorAlone(uint64_t a1)
{
  if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", a1))
  {
    HIDWORD(v8) = 0;
  }
  else
  {
    int v2 = SVG::consumeAlone<SVG::Presentation::Color>(a1, (void (*)(void *__return_ptr, uint64_t, unint64_t))SVG::consumeHexColor);
    if (v3
      || (int v2 = SVG::consumeAlone<SVG::Presentation::Color>(a1, (void (*)(void *__return_ptr, uint64_t, unint64_t))SVG::consumeRGBColor), v4)|| (int v2 = SVG::consumeAlone<SVG::Presentation::Color>(a1, (void (*)(void *__return_ptr, uint64_t, unint64_t))SVG::consumePercentRGBColor), v5)|| (int v2 = SVG::consumeAlone<SVG::Presentation::Color>(a1, (void (*)(void *__return_ptr, uint64_t, unint64_t))SVG::consumeColorKeyword), v6))
    {
      HIDWORD(v8) = v2;
    }
    else
    {
      HIDWORD(v8) = 0;
    }
  }
  return v8;
}

uint64_t SVG::consumeRenderingQuality(uint64_t a1)
{
  if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", a1))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0x100000000;
  }
  else if (SVG::consumeStringAlone<5ul>((uint64_t)"auto", a1))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0x200000000;
  }
  else if (SVG::consumeStringAlone<14ul>(a1))
  {
    uint64_t v3 = 0x200000000;
    uint64_t v2 = 1;
  }
  else
  {
    unint64_t v4 = 0;
    do
    {
      unint64_t v5 = v4;
      unint64_t v4 = SVG::consumeWsp((uint64_t *)a1, v4);
    }
    while (v6);
    unint64_t v7 = *(unsigned __int8 *)(a1 + 23);
    if ((v7 & 0x80u) != 0) {
      unint64_t v7 = *(void *)(a1 + 8);
    }
    unint64_t v8 = v5 + 15;
    if (v7 >= v5 + 15)
    {
      uint64_t v9 = 0;
      while (1)
      {
        uint64_t v10 = *(char *)(a1 + 23) >= 0 ? a1 : *(void *)a1;
        int v11 = *(char *)(v10 + v5 + v9);
        __darwin_ct_rune_t v12 = aOptimizequalit[v9];
        if (__tolower(v12) != v11)
        {
          uint64_t v13 = *(char *)(a1 + 23) >= 0 ? a1 : *(void *)a1;
          int v14 = *(char *)(v13 + v5 + v9);
          if (__toupper(v12) != v14) {
            break;
          }
        }
        if (++v9 == 15)
        {
          do
          {
            unint64_t v15 = v8;
            unint64_t v8 = SVG::consumeWsp((uint64_t *)a1, v8);
          }
          while (v16);
          uint64_t v17 = *(unsigned __int8 *)(a1 + 23);
          if ((v17 & 0x80u) != 0) {
            uint64_t v17 = *(void *)(a1 + 8);
          }
          uint64_t v18 = v15 == v17;
          uint64_t v2 = 2 * v18;
          uint64_t v3 = v18 << 33;
          return v3 | v2;
        }
      }
    }
    uint64_t v2 = 0;
    uint64_t v3 = 0;
  }
  return v3 | v2;
}

void SVG::parseAloneOrVar<SVG::Presentation::Paint>(uint64_t a1, uint64_t *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v37[2] = v4;
  long long v38 = v4;
  v37[0] = v4;
  v37[1] = v4;
  SVG::consumePaint((uint64_t)v37, (uint64_t)a2);
  uint64_t v5 = DWORD2(v38);
  if (DWORD2(v38))
  {
    *(unsigned char *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 56) = -1;
    if (v5 != -1)
    {
      ((void (*)(std::string *))*(&off_1F1A75118 + v5))(&v35);
      *(_DWORD *)(a1 + 56) = v5;
    }
    goto LABEL_33;
  }
  memset(&__str, 170, sizeof(__str));
  SVG::CSS::preprocess(a2, &__str);
  unint64_t v6 = 0;
  do
  {
    uint64_t v7 = v6;
    unint64_t v6 = SVG::CSS::consumeWhitespace((uint64_t *)&__str, v6);
  }
  while (v8);
  unint64_t v9 = SVG::consumeString<5ul>((uint64_t)"var(", (uint64_t)&__str, v7);
  if (v10)
  {
    do
    {
      unint64_t v11 = v9;
      unint64_t v9 = SVG::CSS::consumeWhitespace((uint64_t *)&__str, v9);
    }
    while (v12);
    *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)unint64_t v31 = v13;
    long long v32 = v13;
    SVG::CSS::consumeAName((uint64_t *)&__str, v11, (std::string *)v31);
    *(_OWORD *)__p = *(_OWORD *)v31;
    unint64_t v14 = *((void *)&v32 + 1);
    uint64_t v30 = v32;
    v31[0] = 0;
    v31[1] = 0;
    *(void *)&long long v32 = 0;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    do
      SVG::CSS::consumeWhitespace((uint64_t *)&__str, --size);
    while (v16);
    SVG::consumeString<2ul>(")", (uint64_t *)&__str, size);
    if (v17)
    {
      unint64_t v18 = SVG::consumeString<8ul>((uint64_t)"--color", (uint64_t)__p, 0);
      if (v19)
      {
        memset(v28, 170, sizeof(v28));
        SVG::consumeInteger((uint64_t)__p, v18, (uint64_t)v28);
        if (LOBYTE(v28[2]))
        {
          uint64_t v20 = v28[0];
          if (v28[0] >= 0xFFFFLL) {
            uint64_t v20 = 0xFFFFLL;
          }
          v35.__r_.__value_.__l.__size_ = v20 & ~(v20 >> 63) | 0x1AAAA0000;
          unsigned int v36 = 2;
          *(unsigned char *)(a1 + 16) = 0;
          uint64_t v21 = a1 + 16;
          *(_DWORD *)(v21 + 32) = -1;
          std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>(v21, (uint64_t)&v35.__r_.__value_.__l.__size_);
          *(_DWORD *)(v21 + 40) = 2;
          if (v36 != -1) {
            ((void (*)(char *, std::string::size_type *))*(&off_1F1A74F90 + v36))(&v34, &v35.__r_.__value_.__r.__words[1]);
          }
          goto LABEL_27;
        }
      }
      do
      {
        uint64_t v22 = v14;
        unint64_t v14 = SVG::CSS::consumeWhitespace((uint64_t *)&__str, v14);
      }
      while (v23);
      unint64_t v24 = SVG::consumeString<2ul>(",", (uint64_t *)&__str, v22);
      if (v25)
      {
        std::string::size_type v26 = v24;
        do
          SVG::CSS::consumeWhitespace((uint64_t *)&__str, size--);
        while (v27);
        memset(&v35, 170, sizeof(v35));
        std::string::basic_string(&v35, &__str, v26, size - v26 + 1, (std::allocator<char> *)v28);
        SVG::consumePaint(a1, (uint64_t)&v35);
        if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v35.__r_.__value_.__l.__data_);
        }
        goto LABEL_27;
      }
    }
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 56) = 0;
LABEL_27:
    if (SHIBYTE(v30) < 0) {
      operator delete(__p[0]);
    }
    if (SBYTE7(v32) < 0) {
      operator delete(v31[0]);
    }
    goto LABEL_31;
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 56) = 0;
LABEL_31:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
LABEL_33:
  if (DWORD2(v38) != -1) {
    ((void (*)(std::string *, char *))*(&off_1F1A74F60 + DWORD2(v38)))(&v35, (char *)v37 + 8);
  }
}

void SVG::consumePaint(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", a2))
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 56) = 1;
    return;
  }
  if (SVG::consumeStringAlone<5ul>((uint64_t)"none", a2))
  {
    *(_DWORD *)&cf[8] = 0;
    DWORD2(v22) = 0;
LABEL_7:
    *(unsigned char *)(a1 + 16) = 0;
    uint64_t v4 = a1 + 16;
    *(_DWORD *)(v4 + 32) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>(v4, (uint64_t)&cf[8]);
    *(_DWORD *)(v4 + 40) = 2;
    goto LABEL_8;
  }
  if (SVG::consumeStringAlone<13ul>(a2))
  {
    *(_DWORD *)&cf[8] = 0;
    DWORD2(v22) = 1;
    goto LABEL_7;
  }
  unint64_t v5 = SVG::consumeAlone<SVG::Presentation::Color>(a2, (void (*)(void *__return_ptr, uint64_t, unint64_t))SVG::consumeColorWithICCColor);
  if (v6)
  {
    *(void *)&cf[8] = v5;
    DWORD2(v22) = 2;
    *(unsigned char *)(a1 + 16) = 0;
    uint64_t v7 = a1 + 16;
    *(_DWORD *)(v7 + 32) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>(v7, (uint64_t)&cf[8]);
    *(_DWORD *)(v7 + 40) = 2;
LABEL_8:
    if (DWORD2(v22) != -1) {
      ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A74F90 + DWORD2(v22)))(v19, &cf[8]);
    }
    return;
  }
  unint64_t v8 = 0;
  memset(v19, 170, sizeof(v19));
  do
  {
    uint64_t v9 = v8;
    unint64_t v8 = SVG::consumeWsp((uint64_t *)a2, v8);
  }
  while (v10);
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&cf[16] = v11;
  long long v22 = v11;
  *(_OWORD *)cf = v11;
  SVG::consumePaintIRI((std::string *)a2, v9, (uint64_t)cf);
  if (!BYTE8(v22)) {
    goto LABEL_31;
  }
  unint64_t v12 = v22;
  do
  {
    unint64_t v13 = v12;
    unint64_t v12 = SVG::consumeWsp((uint64_t *)a2, v12);
  }
  while (v14);
  uint64_t v15 = *(char *)(a2 + 23) >= 0 ? *(unsigned __int8 *)(a2 + 23) : *(void *)(a2 + 8);
  char v16 = *(const void **)cf;
  if (v13 == v15)
  {
    if (*(void *)cf) {
      CFRetain(*(CFTypeRef *)cf);
    }
    *(_OWORD *)char v19 = *(_OWORD *)&cf[8];
    *(_DWORD *)&v19[16] = *(_DWORD *)&cf[24];
    unint64_t v17 = (unint64_t)v16;
  }
  else
  {
    unint64_t v17 = 0xAAAAAAAAAAAAAA00;
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v13 == v15)
  {
    *(void *)&cf[8] = v17;
    *(_OWORD *)&cf[16] = *(_OWORD *)v19;
    LODWORD(v22) = *(_DWORD *)&v19[16];
    DWORD2(v22) = 3;
    *(unsigned char *)(a1 + 16) = 0;
    uint64_t v18 = a1 + 16;
    *(_DWORD *)(v18 + 32) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>(v18, (uint64_t)&cf[8]);
    *(_DWORD *)(v18 + 40) = 2;
    if (DWORD2(v22) != -1) {
      ((void (*)(char *, unsigned char *))*(&off_1F1A74F90 + DWORD2(v22)))(&v20, &cf[8]);
    }
  }
  else
  {
LABEL_31:
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 56) = 0;
  }
}

uint64_t SVG::consumeOpacity(uint64_t a1)
{
  if (SVG::consumeStringAlone<8ul>((uint64_t)"inherit", a1)) {
    return 0;
  }
  double v3 = COERCE_DOUBLE(SVG::consumeAlone<double>(a1, (void (*)(uint64_t *__return_ptr, uint64_t, unint64_t))SVG::consumeNumber));
  if (!v4) {
    return 0;
  }
  double v5 = 1.0;
  if (v3 <= 1.0) {
    double v5 = v3;
  }
  double v6 = 0.0;
  if (v3 >= 0.0) {
    double v6 = v5;
  }
  return *(void *)&v6;
}

unint64_t SVG::consumeStopColor(uint64_t a1, uint64_t a2)
{
  unint64_t result = SVG::consumeStringAlone<8ul>((uint64_t)"inherit", a2);
  if (result)
  {
    *(_DWORD *)(a1 + 4) = 0;
    int v5 = 1;
LABEL_7:
    *(_DWORD *)(a1 + 16) = v5;
    return result;
  }
  unint64_t result = SVG::consumeStringAlone<13ul>(a2);
  if (result)
  {
    *(void *)(a1 + 4) = 0;
    *(void *)(a1 + 12) = 0x200000000;
    return result;
  }
  unint64_t result = SVG::consumeAlone<SVG::Presentation::Color>(a2, (void (*)(void *__return_ptr, uint64_t, unint64_t))SVG::consumeColorWithICCColor);
  if (v6)
  {
    *(void *)(a1 + 4) = result;
    *(unsigned char *)(a1 + 12) = 1;
    int v5 = 2;
    goto LABEL_7;
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

void *SVG::consumeAlone<SVG::Length>@<X0>(uint64_t a1@<X0>, void *(*a2)(long long *__return_ptr, uint64_t, unint64_t)@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = 0;
  do
  {
    unint64_t v7 = v6;
    unint64_t v6 = SVG::consumeWsp((uint64_t *)a1, v6);
  }
  while (v8);
  *(void *)&long long v13 = -1;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t result = a2(&v13, a1, v7);
  if (!(_BYTE)v15) {
    goto LABEL_10;
  }
  unint64_t result = (void *)v14;
  do
  {
    char v10 = result;
    unint64_t result = (void *)SVG::consumeWsp((uint64_t *)a1, (unint64_t)result);
  }
  while (v11);
  unint64_t v12 = (void *)*(unsigned __int8 *)(a1 + 23);
  if ((char)v12 < 0) {
    unint64_t v12 = *(void **)(a1 + 8);
  }
  if (v10 == v12)
  {
    *(_OWORD *)a3 = v13;
    *(unsigned char *)(a3 + 16) = 1;
  }
  else
  {
LABEL_10:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
  }
  return result;
}

CFTypeRef SVG::createColorObject@<X0>(CFArrayRef theArray@<X1>, uint64_t a2@<X0>, void *a3@<X8>, CGFloat a4@<D0>)
{
  unsigned __int16 v4 = a2;
  if (HIDWORD(a2))
  {
    if (HIDWORD(a2) == 1)
    {
      CFTypeRef result = (CFTypeRef)CFArrayGetCount(theArray);
      if ((uint64_t)result <= v4)
      {
        *a3 = 0;
      }
      else
      {
        CFTypeRef result = CFArrayGetValueAtIndex(theArray, v4);
        *a3 = result;
        if (result)
        {
          return CFRetain(result);
        }
      }
    }
    else
    {
      uint64_t v8 = std::__throw_bad_variant_access[abi:nn180100]();
      return (CFTypeRef)std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>(v8, v9);
    }
  }
  else
  {
    CFTypeRef result = CGColorCreateSRGB((double)a2 / 255.0, (double)BYTE1(a2) / 255.0, (double)BYTE2(a2) / 255.0, a4);
    *a3 = result;
  }
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 16);
  uint64_t v4 = *(unsigned int *)(a2 + 16);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    CFTypeRef result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A74F30 + v3))(&v6, result, a2);
    *(_DWORD *)(v2 + 16) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))*(&off_1F1A74F48 + v4))(&v5, result, a2);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSK_1EJSA_SB_SI_EEEEEEDcSM_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 8))
  {
    if (*(void *)a2) {
      CFRelease(*(CFTypeRef *)a2);
    }
  }
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSP_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEEOSX_EEEDcSP_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 16);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    CFTypeRef result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F30 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[4] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSP_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEEOSX_EEEDcSP_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 16);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    CFTypeRef result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F30 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[4] = 1;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSP_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEEOSX_EEEDcSP_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__assign_alt[abi:nn180100]<2ul,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_DWORD *)(a1 + 16) == 2) {
    std::__optional_storage_base<SVG::CF<__CFURL const*>,false>::__assign_from[abi:nn180100]<std::__optional_move_assign_base<SVG::CF<__CFURL const*>,false>>(a2, a3);
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__emplace[abi:nn180100]<2ul,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>(a1, a3);
  }
}

void std::__optional_storage_base<SVG::CF<__CFURL const*>,false>::__assign_from[abi:nn180100]<std::__optional_move_assign_base<SVG::CF<__CFURL const*>,false>>(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned __int8 *)(a1 + 8) == *((unsigned __int8 *)a2 + 8))
  {
    if (*(unsigned char *)(a1 + 8))
    {
      uint64_t v4 = *(const void **)a1;
      if (*(void *)a1) {
        CFRelease(v4);
      }
      uint64_t v5 = *a2;
      *a2 = 0;
      *(void *)a1 = v5;
    }
  }
  else if (*(unsigned char *)(a1 + 8))
  {
    char v6 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v6);
    }
    *(unsigned char *)(a1 + 8) = 0;
  }
  else
  {
    uint64_t v7 = *a2;
    *a2 = 0;
    *(void *)a1 = v7;
    *(unsigned char *)(a1 + 8) = 1;
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__emplace[abi:nn180100]<2ul,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F1A74F30 + v4))(&v7, a1);
  }
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 8) = 0;
  if (*((unsigned char *)a2 + 8))
  {
    uint64_t v5 = *a2;
    *a2 = 0;
    *(void *)a1 = v5;
    *(unsigned char *)(a1 + 8) = 1;
  }
  *(_DWORD *)(a1 + 16) = 2;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 48);
  uint64_t v4 = *(unsigned int *)(a2 + 48);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    CFTypeRef result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A74F60 + v3))(&v6, result, a2);
    *(_DWORD *)(v2 + 48) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))*(&off_1F1A74F78 + v4))(&v5, result, a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSE_1EJSA_SB_SC_EEEEEEDcSG_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 40);
  if (v3 != -1) {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A74F90 + v3))(&v5, a2 + 8);
  }
  *(_DWORD *)(a2 + 40) = -1;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 48);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    uint64_t result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F60 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[12] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 48);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    uint64_t result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F60 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[12] = 1;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__assign_alt[abi:nn180100]<2ul,SVG::Presentation::Paint,SVG::Presentation::Paint>(*a1, a2, a3);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__assign_alt[abi:nn180100]<2ul,SVG::Presentation::Paint,SVG::Presentation::Paint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 48) == 2) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>(a2 + 8, a3 + 8);
  }
  else {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__emplace[abi:nn180100]<2ul,SVG::Presentation::Paint>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 32);
  uint64_t v4 = *(unsigned int *)(a2 + 32);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A74F90 + v3))(&v6, result, a2);
    *(_DWORD *)(v2 + 32) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))*(&off_1F1A74FB8 + v4))(&v5, result, a2);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSG_1EJSA_SB_SC_SD_SE_EEEEEEDcSI_DpT0_(uint64_t a1, CFTypeRef *a2)
{
  if (*a2) {
    CFRelease(*a2);
  }
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOST_EEEDcSL_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    uint64_t result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F90 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOST_EEEDcSL_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    uint64_t result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F90 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 1;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOST_EEEDcSL_DpT0_(uint64_t result, void *a2, void *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (v5 == 2)
    {
      *a2 = *a3;
      return result;
    }
    uint64_t result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A74F90 + v5))(&v6, v4);
  }
  *(_DWORD *)(v4 + 32) = -1;
  *(void *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 32) = 2;
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOST_EEEDcSL_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  *(void *)&double result = std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__assign_alt[abi:nn180100]<3ul,SVG::Presentation::IRIWithFallback,SVG::Presentation::IRIWithFallback>(*a1, a2, a3).n128_u64[0];
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOST_EEEDcSL_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (v5 == 4)
    {
      *a2 = *a3;
      return result;
    }
    double result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F90 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 4;
  return result;
}

__n128 std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__assign_alt[abi:nn180100]<3ul,SVG::Presentation::IRIWithFallback,SVG::Presentation::IRIWithFallback>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 3)
  {
    ((void (*)(char *, uint64_t))*(&off_1F1A74F90 + v5))(&v10, a1);
LABEL_7:
    *(_DWORD *)(a1 + 32) = -1;
    uint64_t v9 = *a3;
    *a3 = 0;
    *(void *)a1 = v9;
    __n128 result = *(__n128 *)(a3 + 1);
    *(_DWORD *)(a1 + 24) = *((_DWORD *)a3 + 6);
    *(__n128 *)(a1 + 8) = result;
    *(_DWORD *)(a1 + 32) = 3;
    return result;
  }
  if (*(void *)a2) {
    CFRelease(*(CFTypeRef *)a2);
  }
  uint64_t v7 = *a3;
  *a3 = 0;
  *(void *)a2 = v7;
  __n128 result = *(__n128 *)(a3 + 1);
  *(unsigned char *)(a2 + 24) = *((unsigned char *)a3 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__emplace[abi:nn180100]<2ul,SVG::Presentation::Paint>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 48);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F1A74F60 + v4))(&v6, a1);
  }
  *(_DWORD *)(a1 + 48) = -1;
  *(unsigned char *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 40) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>(a1 + 8, a2 + 8);
  *(_DWORD *)(a1 + 48) = 2;
  return a1;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 32);
  if (v4 != -1) {
    __n128 result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A74F90 + v4))(&v7, result);
  }
  *(_DWORD *)(v3 + 32) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5 != -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A74FE0 + v5))(&v6, v3, a2);
    *(_DWORD *)(v3 + 32) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSM_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOSU_EEEDcSM_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSM_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOSU_EEEDcSM_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSM_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOSU_EEEDcSM_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSM_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOSU_EEEDcSM_DpT0_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  *a3 = 0;
  *(void *)a2 = v3;
  __n128 result = *(__n128 *)(a3 + 1);
  *(_DWORD *)(a2 + 24) = *((_DWORD *)a3 + 6);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSM_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEEOSU_EEEDcSM_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 32);
  uint64_t v4 = *(unsigned int *)(a2 + 32);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A75008 + v3))(&v6, result, a2);
    *(_DWORD *)(v2 + 32) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))*(&off_1F1A75020 + v4))(&v5, result, a2);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSK_1EJSA_SB_SI_EEEEEEDcSM_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v2 = *(void **)a2;
    if (*(void *)a2)
    {
      *(void *)(a2 + 8) = v2;
      operator delete(v2);
    }
  }
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSP_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEEOSX_EEEDcSP_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A75008 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSP_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEEOSX_EEEDcSP_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A75008 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 1;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSP_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEEOSX_EEEDcSP_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__assign_alt[abi:nn180100]<2ul,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>(uint64_t a1, uint64_t a2, __n128 *a3)
{
  if (*(_DWORD *)(a1 + 32) == 2) {
    std::__optional_storage_base<std::vector<SVG::Length>,false>::__assign_from[abi:nn180100]<std::__optional_move_assign_base<std::vector<SVG::Length>,false>>(a2, a3);
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__emplace[abi:nn180100]<2ul,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>(a1, (uint64_t)a3);
  }
}

__n128 std::__optional_storage_base<std::vector<SVG::Length>,false>::__assign_from[abi:nn180100]<std::__optional_move_assign_base<std::vector<SVG::Length>,false>>(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      result.n128_u64[0] = std::vector<SVG::Length>::__move_assign(a1, a2).n128_u64[0];
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v4;
      operator delete(v4);
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

__n128 std::vector<SVG::Length>::__move_assign(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__emplace[abi:nn180100]<2ul,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 32);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F1A75008 + v4))(&v6, a1);
  }
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  *(_DWORD *)(a1 + 32) = 2;
  return a1;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 16);
  if (v4 != -1) {
    __n128 result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A74F30 + v4))(&v7, result);
  }
  *(_DWORD *)(v3 + 16) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 16);
  if (v5 != -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A75038 + v5))(&v6, v3, a2);
    *(_DWORD *)(v3 + 16) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISJ_LNS0_6_TraitE1EEEEEvRSK_OT_EUlRSS_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKS10_EEEDcSS_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISJ_LNS0_6_TraitE1EEEEEvRSK_OT_EUlRSS_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKS10_EEEDcSS_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISJ_LNS0_6_TraitE1EEEEEvRSK_OT_EUlRSS_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKS10_EEEDcSS_DpT0_(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  *a2 = 0;
  a2[8] = 0;
  if (*(unsigned char *)(a3 + 8))
  {
    uint64_t v4 = *(const void **)a3;
    *(void *)a2 = *(void *)a3;
    if (v4) {
      CFRetain(v4);
    }
    a2[8] = 1;
  }
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 48);
  if (v4 != -1) {
    __n128 result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A74F60 + v4))(&v7, result);
  }
  *(_DWORD *)(v3 + 48) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 48);
  if (v5 != -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A75050 + v5))(&v6, v3, a2);
    *(_DWORD *)(v3 + 48) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSM_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEERKSU_EEEDcSM_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSM_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEERKSU_EEEDcSM_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSM_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEERKSU_EEEDcSM_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 40) = -1;
  return std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1> const&>(a2 + 8, a3 + 8);
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 32);
  if (v4 != -1) {
    __n128 result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A74F90 + v4))(&v7, result);
  }
  *(_DWORD *)(v3 + 32) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5 != -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A75068 + v5))(&v6, v3, a2);
    *(_DWORD *)(v3 + 32) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSO_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSW_EEEDcSO_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSO_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSW_EEEDcSO_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSO_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSW_EEEDcSO_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSO_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSW_EEEDcSO_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(const void **)a3;
  *(void *)a2 = *(void *)a3;
  if (v5) {
    CFRetain(v5);
  }
  __n128 result = *(__n128 *)(a3 + 8);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a3 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISF_LNS0_6_TraitE1EEEEEvRSG_OT_EUlRSO_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSW_EEEDcSO_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 32);
  if (v4 != -1) {
    __n128 result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A75008 + v4))(&v7, result);
  }
  *(_DWORD *)(v3 + 32) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5 != -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A75090 + v5))(&v6, v3, a2);
    *(_DWORD *)(v3 + 32) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISJ_LNS0_6_TraitE1EEEEEvRSK_OT_EUlRSS_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKS10_EEEDcSS_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISJ_LNS0_6_TraitE1EEEEEvRSK_OT_EUlRSS_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKS10_EEEDcSS_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISJ_LNS0_6_TraitE1EEEEEvRSK_OT_EUlRSS_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKS10_EEEDcSS_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a2 = 0;
  *(unsigned char *)(a2 + 24) = 0;
  if (*(unsigned char *)(a3 + 24)) {
    *((unsigned char *)std::vector<SVG::Length>::vector((void *)a2, a3) + 24) = 1;
  }
}

void *std::vector<SVG::Length>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<SVG::Length>::__vallocate[abi:nn180100](a1, v5 >> 4);
    char v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<SVG::Length>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Length>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Length>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a2);
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 48);
  uint64_t v4 = *(unsigned int *)(a2 + 48);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A74F60 + v3))(&v6, result, a2);
    *(_DWORD *)(v2 + 48) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))*(&off_1F1A750A8 + v4))(&v5, result, a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEERKST_EEEDcSL_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 48);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F60 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[12] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEERKST_EEEDcSL_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 48);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F60 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[12] = 1;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSL_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEERKST_EEEDcSL_DpT0_(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 48);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 2)
  {
    ((void (*)(char *, uint64_t))*(&off_1F1A74F60 + v5))(&v13, v4);
LABEL_7:
    *(unsigned char *)(v4 + 8) = 0;
    uint64_t v10 = v4 + 8;
    *(_DWORD *)(v10 + 40) = -1;
    *(_DWORD *)(v10 + 32) = -1;
    __n128 result = std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1> const&>(v10, a3 + 8);
    *(_DWORD *)(v10 + 40) = 2;
    return result;
  }
  uint64_t v7 = a2 + 8;
  uint64_t v8 = *(unsigned int *)(a2 + 40);
  uint64_t v9 = *(unsigned int *)(a3 + 40);
  if (v8 == -1)
  {
    if (v9 == -1) {
      return result;
    }
  }
  else if (v9 == -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A74F90 + v8))(&v12, v7);
    *(_DWORD *)(a2 + 40) = -1;
    return result;
  }
  uint64_t v11 = v7;
  return ((uint64_t (*)(uint64_t *))*(&off_1F1A750C0 + v9))(&v11);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSN_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSV_EEEDcSN_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F90 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSN_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSV_EEEDcSN_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F90 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 1;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSN_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSV_EEEDcSN_DpT0_(uint64_t result, void *a2, void *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (v5 == 2)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A74F90 + v5))(&v6, v4);
  }
  *(_DWORD *)(v4 + 32) = -1;
  *(void *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 32) = 2;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSN_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSV_EEEDcSN_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 32);
  if (v5 != -1)
  {
    if (v5 == 3)
    {
      SVG::CF<__CFURL const*>::operator=((const void **)a2, (const void **)a3);
      __n128 result = *(__n128 *)(a3 + 8);
      *(unsigned char *)(a2 + 24) = *(unsigned char *)(a3 + 24);
      *(__n128 *)(a2 + 8) = result;
      return result;
    }
    ((void (*)(char *, uint64_t))*(&off_1F1A74F90 + v5))(&v9, v4);
  }
  *(_DWORD *)(v4 + 32) = -1;
  uint64_t v8 = *(const void **)a3;
  *(void *)uint64_t v4 = *(void *)a3;
  if (v8) {
    CFRetain(v8);
  }
  __n128 result = *(__n128 *)(a3 + 8);
  *(_DWORD *)(v4 + 24) = *(_DWORD *)(a3 + 24);
  *(__n128 *)(v4 + 8) = result;
  *(_DWORD *)(v4 + 32) = 3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation4NoneENS9_12CurrentColorENS9_5ColorENS9_15IRIWithFallbackENS9_11FromContextEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISF_LNS0_6_TraitE1EEEEEvOT_EUlRSN_OT0_E_JRNS0_6__baseILSJ_1EJSA_SB_SC_SD_SE_EEERKSV_EEEDcSN_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (v5 == 4)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F90 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 4;
  return result;
}

const void **SVG::CF<__CFURL const*>::operator=(const void **a1, const void **a2)
{
  uint64_t v4 = *a1;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *a2;
  *a1 = *a2;
  if (v5) {
    CFRetain(v5);
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 32);
  uint64_t v4 = *(unsigned int *)(a2 + 32);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A75008 + v3))(&v6, result, a2);
    *(_DWORD *)(v2 + 32) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))*(&off_1F1A750E8 + v4))(&v5, result, a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKSZ_EEEDcSR_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A75008 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKSZ_EEEDcSR_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 32);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A75008 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[8] = 1;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS_6vectorINS8_6LengthENS_9allocatorISE_EEEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKSZ_EEEDcSR_DpT0_(uint64_t *a1, char **a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  if (*(_DWORD *)(*a1 + 32) == 2)
  {
    if (*((unsigned __int8 *)a2 + 24) == *(unsigned __int8 *)(a3 + 24))
    {
      if (a2 != (char **)a3 && *((unsigned char *)a2 + 24))
      {
        uint64_t v5 = *(char **)a3;
        char v6 = *(char **)(a3 + 8);
        int64_t v7 = (int64_t)&v6[-*(void *)a3];
        unint64_t v8 = v7 >> 4;
        uint64_t v9 = (uint64_t)a2[2];
        uint64_t v10 = *a2;
        if (v7 >> 4 <= (unint64_t)((v9 - (uint64_t)*a2) >> 4))
        {
          char v13 = (void **)(a2 + 1);
          char v16 = a2[1];
          unint64_t v17 = (v16 - v10) >> 4;
          if (v17 < v8)
          {
            uint64_t v18 = &v5[16 * v17];
            if (v16 != v10)
            {
              memmove(v10, v5, v16 - v10);
              uint64_t v10 = (char *)*v13;
            }
            int64_t v7 = v6 - v18;
            if (v6 == v18) {
              goto LABEL_33;
            }
            char v19 = v10;
            char v20 = v18;
            goto LABEL_32;
          }
        }
        else
        {
          if (v10)
          {
            a2[1] = v10;
            operator delete(v10);
            uint64_t v9 = 0;
            *a2 = 0;
            a2[1] = 0;
            a2[2] = 0;
          }
          if (v7 < 0) {
            abort();
          }
          uint64_t v11 = v9 >> 3;
          if (v9 >> 3 <= v8) {
            uint64_t v11 = v7 >> 4;
          }
          if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v12 = v11;
          }
          std::vector<SVG::Length>::__vallocate[abi:nn180100](a2, v12);
          unint64_t v14 = a2[1];
          char v13 = (void **)(a2 + 1);
          uint64_t v10 = v14;
        }
        if (v6 == v5)
        {
LABEL_33:
          *char v13 = &v10[v7];
          return;
        }
        char v19 = v10;
        char v20 = v5;
LABEL_32:
        memmove(v19, v20, v7);
        goto LABEL_33;
      }
    }
    else if (*((unsigned char *)a2 + 24))
    {
      unint64_t v15 = *a2;
      if (*a2)
      {
        a2[1] = v15;
        operator delete(v15);
      }
      *((unsigned char *)a2 + 24) = 0;
    }
    else
    {
      std::vector<SVG::Length>::vector(a2, a3);
      *((unsigned char *)a2 + 24) = 1;
    }
  }
  else
  {
    LOBYTE(__p[0]) = 0;
    char v22 = 0;
    if (*(unsigned char *)(a3 + 24))
    {
      std::vector<SVG::Length>::vector(__p, a3);
      char v22 = 1;
    }
    std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__emplace[abi:nn180100]<2ul,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>(v3, (uint64_t)__p);
    if (v22 && __p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 16);
  uint64_t v4 = *(unsigned int *)(a2 + 16);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A74F30 + v3))(&v6, result, a2);
    *(_DWORD *)(v2 + 16) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))*(&off_1F1A75100 + v4))(&v5, result, a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKSZ_EEEDcSR_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 16);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F30 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[4] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKSZ_EEEDcSR_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 16);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A74F30 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[4] = 1;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_14ValueOrKeywordINS8_2CFIPK7__CFURLEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISJ_LNS0_6_TraitE1EEEEEvOT_EUlRSR_OT0_E_JRNS0_6__baseILSN_1EJSA_SB_SI_EEERKSZ_EEEDcSR_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 16);
  if (v5 != -1)
  {
    if (v5 == 2)
    {
      if (*(unsigned __int8 *)(a2 + 8) == *(unsigned __int8 *)(a3 + 8))
      {
        if (*(unsigned char *)(a2 + 8))
        {
          SVG::CF<__CFURL const*>::operator=((const void **)a2, (const void **)a3);
        }
      }
      else if (*(unsigned char *)(a2 + 8))
      {
        if (*(void *)a2) {
          CFRelease(*(CFTypeRef *)a2);
        }
        *(unsigned char *)(a2 + 8) = 0;
      }
      else
      {
        unint64_t v8 = *(const void **)a3;
        *(void *)a2 = *(void *)a3;
        if (v8) {
          CFRetain(v8);
        }
        *(unsigned char *)(a2 + 8) = 1;
      }
      return;
    }
    ((void (*)(char *, uint64_t))*(&off_1F1A74F30 + v5))(&v9, v4);
  }
  *(_DWORD *)(v4 + 16) = -1;
  *(unsigned char *)uint64_t v4 = 0;
  *(unsigned char *)(v4 + 8) = 0;
  if (*(unsigned char *)(a3 + 8))
  {
    int64_t v7 = *(const void **)a3;
    *(void *)uint64_t v4 = *(void *)a3;
    if (v7) {
      CFRetain(v7);
    }
    *(unsigned char *)(v4 + 8) = 1;
  }
  *(_DWORD *)(v4 + 16) = 2;
}

uint64_t std::__throw_bad_variant_access[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_variant_access was thrown in -fno-exceptions mode");
  return std::string::basic_string[abi:nn180100]<0>(v0, v1);
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    char v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    char v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

BOOL SVG::consumeStringAlone<8ul>(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  do
  {
    uint64_t v5 = v4;
    unint64_t v4 = SVG::consumeWsp((uint64_t *)a2, v4);
  }
  while (v6);
  unint64_t v7 = SVG::consumeString<8ul>(a1, a2, v5);
  if (!v8) {
    return 0;
  }
  do
  {
    unint64_t v9 = v7;
    unint64_t v7 = SVG::consumeWsp((uint64_t *)a2, v7);
  }
  while (v10);
  uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *(void *)(a2 + 8);
  }
  return v9 == v11;
}

BOOL SVG::consumeStringAlone<5ul>(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  do
  {
    uint64_t v5 = v4;
    unint64_t v4 = SVG::consumeWsp((uint64_t *)a2, v4);
  }
  while (v6);
  unint64_t v7 = SVG::consumeString<5ul>(a1, a2, v5);
  if (!v8) {
    return 0;
  }
  do
  {
    unint64_t v9 = v7;
    unint64_t v7 = SVG::consumeWsp((uint64_t *)a2, v7);
  }
  while (v10);
  uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *(void *)(a2 + 8);
  }
  return v9 == v11;
}

unint64_t SVG::consumeClipRect@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t result = SVG::consumeString<5ul>((uint64_t)"rect", (uint64_t)a1, a2);
  if (!v6) {
    goto LABEL_10;
  }
  do
  {
    uint64_t v7 = result;
    unint64_t result = SVG::consumeWsp(a1, result);
  }
  while (v8);
  unint64_t result = SVG::consumeString<2ul>("(", a1, v7);
  if (!v9) {
    goto LABEL_10;
  }
  do
  {
    unint64_t v10 = result;
    unint64_t result = SVG::consumeWsp(a1, result);
  }
  while (v11);
  *(void *)&long long v12 = -1;
  *((void *)&v12 + 1) = -1;
  long long v19 = v12;
  long long v20 = v12;
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t result = (unint64_t)SVG::consumeWspCommaList<double,4ul>(a1, v10, (void *(*)(uint64_t *__return_ptr, uint64_t *, unint64_t))SVG::consumeAutoOrCSSLength, (uint64_t)&v19);
  if (!(_BYTE)v22) {
    goto LABEL_10;
  }
  unint64_t v13 = v21;
  do
  {
    uint64_t v14 = v13;
    unint64_t v13 = SVG::consumeWsp(a1, v13);
  }
  while (v15);
  unint64_t result = SVG::consumeString<2ul>(")", a1, v14);
  if (v16)
  {
    long long v17 = v20;
    *(_OWORD *)a3 = v19;
    *(_OWORD *)(a3 + 16) = v17;
    char v18 = 1;
    *(unsigned char *)(a3 + 32) = 1;
    *(void *)(a3 + 40) = result;
  }
  else
  {
LABEL_10:
    char v18 = 0;
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 48) = v18;
  return result;
}

unint64_t SVG::consumeString<8ul>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  uint64_t v4 = a3 + 7;
  if (v3 >= a3 + 7)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      int v12 = *(char *)(v11 + a3 + v10);
      if (__tolower(*(char *)(a1 + v10)) != v12)
      {
        uint64_t v13 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
        int v14 = *(char *)(v13 + a3 + v10);
        if (__toupper(*(char *)(a1 + v10)) != v14) {
          break;
        }
      }
      if (++v10 == 7)
      {
        unint64_t v6 = v4 & 0xFFFFFFFFFFFFFF00;
        uint64_t v5 = v4;
        return v6 | v5;
      }
    }
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  return v6 | v5;
}

unint64_t SVG::consumeString<2ul>(char *a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v3 = *((unsigned __int8 *)a2 + 23);
  int v4 = (char)v3;
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = a2[1];
  }
  uint64_t v5 = a3 + 1;
  if (v3 >= a3 + 1
    && (v4 >= 0 ? (char v9 = a2) : (char v9 = (uint64_t *)*a2),
        (int v10 = *((char *)v9 + a3), __tolower(*a1) == v10)
     || (*((char *)a2 + 23) >= 0 ? (uint64_t v11 = a2) : (uint64_t v11 = (uint64_t *)*a2), v12 = *((char *)v11 + a3), __toupper(*a1) == v12)))
  {
    unint64_t v13 = v5 & 0xFFFFFFFFFFFFFF00;
    uint64_t v14 = v5;
  }
  else
  {
    uint64_t v14 = 0;
    unint64_t v13 = 0;
  }
  return v13 | v14;
}

void SVG::consumeAutoOrCSSLength(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = SVG::consumeString<5ul>((uint64_t)"auto", a1, a2);
  if (v7)
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = v6;
    *(unsigned char *)(a3 + 16) = 1;
  }
  else
  {
    SVG::consumeCSSLength(a1, a2, a3);
  }
}

void SVG::consumeFuncIRI(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5 = SVG::consumeString<4ul>((uint64_t)"url", a1, a2);
  if (!v6) {
    goto LABEL_24;
  }
  do
  {
    uint64_t v7 = v5;
    unint64_t v5 = SVG::consumeWsp((uint64_t *)a1, v5);
  }
  while (v8);
  unint64_t v9 = SVG::consumeString<2ul>("(", (uint64_t *)a1, v7);
  if (!v10) {
    goto LABEL_24;
  }
  do
  {
    unint64_t v11 = v9;
    unint64_t v9 = SVG::consumeWsp((uint64_t *)a1, v9);
  }
  while (v12);
  unint64_t v13 = *(unsigned __int8 *)(a1 + 23);
  int v14 = (char)v13;
  if ((v13 & 0x80u) != 0) {
    unint64_t v13 = *(void *)(a1 + 8);
  }
  if (v13 <= v11)
  {
    unint64_t v16 = v11;
  }
  else
  {
    uint64_t v15 = v14 >= 0 ? a1 : *(void *)a1;
    unint64_t v16 = v11;
    while (*(unsigned char *)(v15 + v16) != 41)
    {
      if (v13 == ++v16)
      {
        unint64_t v16 = v13;
        break;
      }
    }
  }
  uint64_t v17 = v14 >= 0 ? a1 : *(void *)a1;
  CFURLRef v18 = CFURLCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)(v17 + v11), v16 - v11, 0x8000100u, 0);
  if (v18)
  {
    CFURLRef v19 = v18;
    CFRetain(v18);
    CFRelease(v19);
    do
    {
      uint64_t v20 = v16;
      unint64_t v16 = SVG::consumeWsp((uint64_t *)a1, v16);
    }
    while (v21);
    unint64_t v22 = SVG::consumeString<2ul>(")", (uint64_t *)a1, v20);
    if (v23)
    {
      unint64_t v24 = v22;
      CFRetain(v19);
      *(void *)a3 = v19;
      *(void *)(a3 + 8) = v24;
      *(unsigned char *)(a3 + 16) = 1;
    }
    else
    {
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 16) = 0;
    }
    CFRelease(v19);
  }
  else
  {
LABEL_24:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
  }
}

unint64_t SVG::consumeString<4ul>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  uint64_t v4 = a3 + 3;
  if (v3 >= a3 + 3)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      int v12 = *(char *)(v11 + a3 + v10);
      if (__tolower(*(char *)(a1 + v10)) != v12)
      {
        uint64_t v13 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
        int v14 = *(char *)(v13 + a3 + v10);
        if (__toupper(*(char *)(a1 + v10)) != v14) {
          break;
        }
      }
      if (++v10 == 3)
      {
        unint64_t v6 = v4 & 0xFFFFFFFFFFFFFF00;
        uint64_t v5 = v4;
        return v6 | v5;
      }
    }
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  return v6 | v5;
}

unint64_t SVG::consumeAlone<SVG::Presentation::Color>(uint64_t a1, void (*a2)(void *__return_ptr, uint64_t, unint64_t))
{
  unint64_t v4 = 0;
  do
  {
    unint64_t v5 = v4;
    unint64_t v4 = SVG::consumeWsp((uint64_t *)a1, v4);
  }
  while (v6);
  memset(v14, 170, sizeof(v14));
  a2(v14, a1, v5);
  if (!LOBYTE(v14[2])) {
    goto LABEL_10;
  }
  unint64_t v7 = v14[1];
  do
  {
    unint64_t v8 = v7;
    unint64_t v7 = SVG::consumeWsp((uint64_t *)a1, v7);
  }
  while (v9);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 23);
  if ((v10 & 0x80u) != 0) {
    uint64_t v10 = *(void *)(a1 + 8);
  }
  if (v8 == v10)
  {
    unint64_t v11 = v14[0] & 0xFFFFFFFFFFFFFF00;
    uint64_t v12 = LOBYTE(v14[0]);
  }
  else
  {
LABEL_10:
    unint64_t v11 = 0;
    uint64_t v12 = 0;
  }
  return v12 | v11;
}

unint64_t SVG::consumeHexColor@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t result = SVG::consumeString<2ul>("#", a1, a2);
  if (v6
    && (memset(v14, 170, sizeof(v14)), unint64_t result = SVG::consumeHexDigit((uint64_t)v14, a1, result), LOBYTE(v14[2]))
    && (memset(v13, 170, sizeof(v13)), unint64_t result = SVG::consumeHexDigit((uint64_t)v13, a1, v14[1]), LOBYTE(v13[2]))
    && (memset(v12, 170, sizeof(v12)), unint64_t result = SVG::consumeHexDigit((uint64_t)v12, a1, v13[1]), LOBYTE(v12[2])))
  {
    memset(v11, 170, sizeof(v11));
    unint64_t v7 = v12[1];
    unint64_t result = SVG::consumeHexDigit((uint64_t)v11, a1, v12[1]);
    if (LOBYTE(v11[2])
      && (memset(v10, 170, sizeof(v10)), unint64_t result = SVG::consumeHexDigit((uint64_t)v10, a1, v11[1]), LOBYTE(v10[2]))
      && (memset(v9, 170, sizeof(v9)), unint64_t result = SVG::consumeHexDigit((uint64_t)v9, a1, v10[1]), LOBYTE(v9[2])))
    {
      uint64_t v8 = v9[1];
      *(void *)a3 = (LOBYTE(v13[0]) | (16 * LOBYTE(v14[0]))) | (unint64_t)(unsigned __int16)((LOBYTE(v11[0]) | (16 * LOBYTE(v12[0]))) << 8) | ((unint64_t)(LOBYTE(v9[0]) | (16 * LOBYTE(v10[0]))) << 16) | 0xAA000000;
      *(void *)(a3 + 8) = v8;
    }
    else
    {
      *(void *)a3 = (LOBYTE(v14[0]) | (16 * LOBYTE(v14[0]))) | (unint64_t)(unsigned __int16)((LOBYTE(v13[0]) | (16 * LOBYTE(v13[0]))) << 8) | ((unint64_t)(LOBYTE(v12[0]) | (16 * LOBYTE(v12[0]))) << 16) | 0xAA000000;
      *(void *)(a3 + 8) = v7;
    }
    *(unsigned char *)(a3 + 16) = 1;
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
  }
  return result;
}

void *SVG::consumeRGBColor@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return SVG::consumeFunction<SVG::Presentation::Color,4ul>(a3, a1, a2, (void *(*)(void *__return_ptr, uint64_t *, void *))SVG::consumeRGBColorValue);
}

void *SVG::consumePercentRGBColor@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return SVG::consumeFunction<SVG::Presentation::Color,4ul>(a3, a1, a2, (void *(*)(void *__return_ptr, uint64_t *, void *))SVG::consumePercentRGBColorValue);
}

uint64_t SVG::consumeHexDigit(uint64_t result, uint64_t *a2, unint64_t a3)
{
  unint64_t v3 = *((unsigned __int8 *)a2 + 23);
  int v4 = (char)v3;
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = a2[1];
  }
  if (v3 <= a3) {
    goto LABEL_15;
  }
  if (v4 >= 0) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = (uint64_t *)*a2;
  }
  int v6 = *((unsigned __int8 *)v5 + a3);
  if ((v6 - 48) > 9)
  {
    if ((v6 - 65) <= 5)
    {
      char v7 = v6 - 55;
LABEL_13:
      *(unsigned char *)unint64_t result = v7;
      *(void *)(result + 8) = a3 + 1;
      goto LABEL_14;
    }
    if ((v6 - 97) <= 5)
    {
      char v7 = v6 - 87;
      goto LABEL_13;
    }
LABEL_15:
    char v8 = 0;
    *(unsigned char *)unint64_t result = 0;
    goto LABEL_16;
  }
  *(unsigned char *)unint64_t result = v6 - 48;
  *(void *)(result + 8) = a3 + 1;
LABEL_14:
  char v8 = 1;
LABEL_16:
  *(unsigned char *)(result + 16) = v8;
  return result;
}

void *SVG::consumeFunction<SVG::Presentation::Color,4ul>(uint64_t a1, uint64_t *a2, uint64_t a3, void *(*a4)(void *__return_ptr, uint64_t *, void *))
{
  unint64_t result = (void *)SVG::consumeString<4ul>((uint64_t)"rgb", (uint64_t)a2, a3);
  if (!v8) {
    goto LABEL_10;
  }
  do
  {
    uint64_t v9 = (uint64_t)result;
    unint64_t result = (void *)SVG::consumeWsp(a2, (unint64_t)result);
  }
  while (v10);
  unint64_t result = (void *)SVG::consumeString<2ul>("(", a2, v9);
  if (!v11)
  {
LABEL_10:
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 16) = 0;
    return result;
  }
  do
  {
    uint64_t v12 = result;
    unint64_t result = (void *)SVG::consumeWsp(a2, (unint64_t)result);
  }
  while (v13);
  memset(v19, 170, sizeof(v19));
  unint64_t result = a4(v19, a2, v12);
  char v14 = v19[2];
  if (!LOBYTE(v19[2])) {
    goto LABEL_12;
  }
  unint64_t v15 = v19[1];
  do
  {
    uint64_t v16 = v15;
    unint64_t v15 = SVG::consumeWsp(a2, v15);
  }
  while (v17);
  unint64_t result = (void *)SVG::consumeString<2ul>(")", a2, v16);
  if (!v18)
  {
    char v14 = 0;
LABEL_12:
    *(unsigned char *)a1 = 0;
    goto LABEL_13;
  }
  *(void *)a1 = v19[0];
  *(void *)(a1 + 8) = result;
  char v14 = 1;
LABEL_13:
  *(unsigned char *)(a1 + 16) = v14;
  return result;
}

void SVG::consumeRGBColorValue(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  memset(v16, 170, sizeof(v16));
  SVG::consumeInteger((uint64_t)a1, a2, (uint64_t)v16);
  if (LOBYTE(v16[2])
    && (unint64_t v5 = SVG::consumeCommaSpace(a1, v16[1]), v6)
    && (memset(v15, 170, sizeof(v15)), SVG::consumeInteger((uint64_t)a1, v5, (uint64_t)v15), LOBYTE(v15[2]))
    && (unint64_t v7 = SVG::consumeCommaSpace(a1, v15[1]), v8))
  {
    memset(v14, 170, sizeof(v14));
    SVG::consumeInteger((uint64_t)a1, v7, (uint64_t)v14);
    char v9 = v14[2];
    if (LOBYTE(v14[2]))
    {
      uint64_t v10 = v16[0];
      uint64_t v11 = 255;
      if (v16[0] >= 255) {
        uint64_t v10 = 255;
      }
      uint64_t v12 = v15[0];
      if (v15[0] >= 255) {
        uint64_t v12 = 255;
      }
      uint64_t v13 = v14[1];
      if (v14[0] < 255) {
        uint64_t v11 = v14[0];
      }
      *(void *)a3 = v10 & ~(v10 >> 63) | ((v12 & ~(v12 >> 63)) << 8) | ((v11 & ~(v11 >> 63)) << 16) | 0xAA000000;
      *(void *)(a3 + 8) = v13;
      char v9 = 1;
    }
    else
    {
      *(unsigned char *)a3 = 0;
    }
    *(unsigned char *)(a3 + 16) = v9;
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
  }
}

unint64_t SVG::consumeCommaSpace(uint64_t *a1, unint64_t a2)
{
  do
  {
    uint64_t v4 = a2;
    a2 = SVG::consumeWsp(a1, a2);
  }
  while (v5);
  unint64_t v6 = SVG::consumeString<2ul>(",", a1, v4);
  if (!v7) {
    return 0;
  }
  do
  {
    unint64_t v8 = v6;
    unint64_t v6 = SVG::consumeWsp(a1, v6);
  }
  while (v9);
  return v8;
}

void SVG::consumePercentRGBColorValue(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v28 = NAN;
  uint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumePathNumber((uint64_t)a1, a2, (uint64_t)&v28);
  if ((_BYTE)v30)
  {
    unint64_t v5 = SVG::consumeString<2ul>("%", a1, v29);
    if (v6)
    {
      unint64_t v7 = SVG::consumeCommaSpace(a1, v5);
      if (v8)
      {
        double v25 = NAN;
        uint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
        SVG::consumePathNumber((uint64_t)a1, v7, (uint64_t)&v25);
        if ((_BYTE)v27)
        {
          unint64_t v9 = SVG::consumeString<2ul>("%", a1, v26);
          if (v10)
          {
            unint64_t v11 = SVG::consumeCommaSpace(a1, v9);
            if (v12)
            {
              double v22 = NAN;
              uint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
              unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
              SVG::consumePathNumber((uint64_t)a1, v11, (uint64_t)&v22);
              char v13 = v24;
              if ((_BYTE)v24)
              {
                unint64_t v14 = SVG::consumeString<2ul>("%", a1, v23);
                if (v15)
                {
                  double v16 = 255.0;
                  double v17 = v28 * 255.0 / 100.0;
                  if (v28 > 100.0) {
                    double v17 = 255.0;
                  }
                  double v18 = 0.0;
                  if (v28 < 0.0) {
                    double v17 = 0.0;
                  }
                  uint64_t v19 = (int)v17;
                  double v20 = v25 * 255.0 / 100.0;
                  if (v25 > 100.0) {
                    double v20 = 255.0;
                  }
                  if (v25 >= 0.0) {
                    double v21 = v20;
                  }
                  else {
                    double v21 = 0.0;
                  }
                  if (v22 <= 100.0) {
                    double v16 = v22 * 255.0 / 100.0;
                  }
                  if (v22 >= 0.0) {
                    double v18 = v16;
                  }
                  *(void *)a3 = v19 | ((unint64_t)(int)v21 << 8) | ((unint64_t)(int)v18 << 16) | 0xAA000000;
                  *(void *)(a3 + 8) = v14;
                  char v13 = 1;
                  goto LABEL_27;
                }
                char v13 = 0;
              }
              *(unsigned char *)a3 = 0;
LABEL_27:
              *(unsigned char *)(a3 + 16) = v13;
              return;
            }
          }
        }
      }
    }
  }
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 16) = 0;
}

unint64_t SVG::consumeString<10ul>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  uint64_t v4 = a3 + 9;
  if (v3 >= a3 + 9)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      int v12 = *(char *)(v11 + a3 + v10);
      if (__tolower(*(char *)(a1 + v10)) != v12)
      {
        uint64_t v13 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
        int v14 = *(char *)(v13 + a3 + v10);
        if (__toupper(*(char *)(a1 + v10)) != v14) {
          break;
        }
      }
      if (++v10 == 9)
      {
        unint64_t v6 = v4 & 0xFFFFFFFFFFFFFF00;
        uint64_t v5 = v4;
        return v6 | v5;
      }
    }
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  return v6 | v5;
}

BOOL SVG::consumeStringAlone<14ul>(uint64_t a1)
{
  unint64_t v2 = 0;
  do
  {
    unint64_t v3 = v2;
    unint64_t v2 = SVG::consumeWsp((uint64_t *)a1, v2);
  }
  while (v4);
  unint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  if ((v5 & 0x80u) != 0) {
    unint64_t v5 = *(void *)(a1 + 8);
  }
  unint64_t v6 = v3 + 13;
  if (v5 >= v3 + 13)
  {
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t v9 = *(char *)(a1 + 23) >= 0 ? a1 : *(void *)a1;
      int v10 = *(char *)(v9 + v3 + v8);
      __darwin_ct_rune_t v11 = aOptimizespeed[v8];
      if (__tolower(v11) != v10)
      {
        uint64_t v12 = *(char *)(a1 + 23) >= 0 ? a1 : *(void *)a1;
        int v13 = *(char *)(v12 + v3 + v8);
        if (__toupper(v11) != v13) {
          break;
        }
      }
      if (++v8 == 13)
      {
        do
        {
          unint64_t v14 = v6;
          unint64_t v6 = SVG::consumeWsp((uint64_t *)a1, v6);
        }
        while (v15);
        uint64_t v16 = *(unsigned __int8 *)(a1 + 23);
        if ((v16 & 0x80u) != 0) {
          uint64_t v16 = *(void *)(a1 + 8);
        }
        return v14 == v16;
      }
    }
  }
  return 0;
}

BOOL SVG::consumeStringAlone<7ul>(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  do
  {
    uint64_t v5 = v4;
    unint64_t v4 = SVG::consumeWsp((uint64_t *)a2, v4);
  }
  while (v6);
  unint64_t v7 = SVG::consumeString<7ul>(a1, a2, v5);
  if (!v8) {
    return 0;
  }
  do
  {
    unint64_t v9 = v7;
    unint64_t v7 = SVG::consumeWsp((uint64_t *)a2, v7);
  }
  while (v10);
  uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *(void *)(a2 + 8);
  }
  return v9 == v11;
}

BOOL SVG::consumeStringAlone<6ul>(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0;
  do
  {
    uint64_t v5 = v4;
    unint64_t v4 = SVG::consumeWsp((uint64_t *)a2, v4);
  }
  while (v6);
  unint64_t v7 = SVG::consumeString<6ul>(a1, a2, v5);
  if (!v8) {
    return 0;
  }
  do
  {
    unint64_t v9 = v7;
    unint64_t v7 = SVG::consumeWsp((uint64_t *)a2, v7);
  }
  while (v10);
  uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *(void *)(a2 + 8);
  }
  return v9 == v11;
}

unint64_t SVG::consumeString<7ul>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  uint64_t v4 = a3 + 6;
  if (v3 >= a3 + 6)
  {
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      int v12 = *(char *)(v11 + a3 + v10);
      if (__tolower(*(char *)(a1 + v10)) != v12)
      {
        uint64_t v13 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
        int v14 = *(char *)(v13 + a3 + v10);
        if (__toupper(*(char *)(a1 + v10)) != v14) {
          break;
        }
      }
      if (++v10 == 6)
      {
        unint64_t v6 = v4 & 0xFFFFFFFFFFFFFF00;
        uint64_t v5 = v4;
        return v6 | v5;
      }
    }
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  return v6 | v5;
}

BOOL SVG::consumeStringAlone<13ul>(uint64_t a1)
{
  unint64_t v2 = 0;
  do
  {
    uint64_t v3 = v2;
    unint64_t v2 = SVG::consumeWsp((uint64_t *)a1, v2);
  }
  while (v4);
  unint64_t v5 = SVG::consumeString<13ul>(a1, v3);
  if (!v6) {
    return 0;
  }
  do
  {
    unint64_t v7 = v5;
    unint64_t v5 = SVG::consumeWsp((uint64_t *)a1, v5);
  }
  while (v8);
  uint64_t v9 = *(unsigned __int8 *)(a1 + 23);
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = *(void *)(a1 + 8);
  }
  return v7 == v9;
}

size_t SVG::consumeColorWithICCColor@<X0>(std::string *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v68[2] = *MEMORY[0x1E4F143B8];
  memset(v49, 170, sizeof(v49));
  SVG::consumeHexColor((uint64_t *)a1, a2, (uint64_t)v49);
  if (LOBYTE(v49[2])
    || (memset(v49, 170, sizeof(v49)),
        SVG::consumeFunction<SVG::Presentation::Color,4ul>((uint64_t)v49, (uint64_t *)a1, a2, (void *(*)(void *__return_ptr, uint64_t *, void *))SVG::consumeRGBColorValue), LOBYTE(v49[2]))|| (memset(v49, 170, sizeof(v49)), SVG::consumeFunction<SVG::Presentation::Color,4ul>((uint64_t)v49, (uint64_t *)a1, a2, (void *(*)(void *__return_ptr, uint64_t *, void *))SVG::consumePercentRGBColorValue), LOBYTE(v49[2]))|| (memset(v49, 170, sizeof(v49)), size_t result = SVG::consumeColorKeyword((uint64_t *)a1, a2, (uint64_t)v49), LOBYTE(v49[2])))
  {
    unint64_t v7 = v49[1];
    unint64_t v8 = v49[1];
    do
    {
      uint64_t v9 = v8;
      unint64_t v8 = SVG::consumeWsp((uint64_t *)a1, v8);
    }
    while (v10);
    *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v47[16] = v11;
    long long v48 = v11;
    long long v46 = v11;
    *(_OWORD *)v47 = v11;
    unint64_t v12 = SVG::consumeString<10ul>((uint64_t)"icc-color", (uint64_t)a1, v9);
    if (!v13) {
      goto LABEL_25;
    }
    do
    {
      uint64_t v14 = v12;
      unint64_t v12 = SVG::consumeWsp((uint64_t *)a1, v12);
    }
    while (v15);
    unint64_t v16 = SVG::consumeString<2ul>("(", (uint64_t *)a1, v14);
    if (v17)
    {
      uint64_t v44 = a3;
      unint64_t v45 = v7;
      do
      {
        std::string::size_type v18 = v16;
        unint64_t v16 = SVG::consumeWsp((uint64_t *)a1, v16);
      }
      while (v19);
      *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v54[2] = v20;
      long long v55 = v20;
      v54[0] = v20;
      v54[1] = v20;
      memset(v68, 170, 15);
      unint64_t v21 = v18;
      while (1)
      {
        unint64_t v22 = SVG::consumeWsp((uint64_t *)a1, v21);
        char v24 = v23;
        unint64_t v25 = SVG::consumeString<2ul>(",", (uint64_t *)a1, v21);
        char v27 = v26;
        unint64_t v28 = SVG::consumeString<2ul>("(", (uint64_t *)a1, v21);
        char v30 = v29;
        unint64_t v31 = SVG::consumeString<2ul>(")", (uint64_t *)a1, v21);
        if (v24 || v27 || v30 || v32) {
          break;
        }
        if (v22 <= v25) {
          unint64_t v33 = v25;
        }
        else {
          unint64_t v33 = v22;
        }
        if (v33 <= v28) {
          unint64_t v33 = v28;
        }
        if (v33 <= v31) {
          unint64_t v21 = v31;
        }
        else {
          unint64_t v21 = v33;
        }
      }
      unint64_t v7 = v45;
      if (v21 == v18)
      {
        LOBYTE(v54[0]) = 0;
        BYTE8(v55) = 0;
      }
      else
      {
        std::string::basic_string((std::string *)&v65, a1, v18, v21 - v18, (std::allocator<char> *)&v61);
        if (SBYTE7(v66) < 0)
        {
          std::string::__init_copy_ctor_external(&v61, (const std::string::value_type *)v65, *((std::string::size_type *)&v65 + 1));
          BOOL v34 = SBYTE7(v66) < 0;
        }
        else
        {
          BOOL v34 = 0;
          *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v65;
          v61.__r_.__value_.__r.__words[2] = v66;
        }
        v68[0] = v61.__r_.__value_.__l.__size_;
        std::string v35 = (void *)v61.__r_.__value_.__r.__words[0];
        *(void *)((char *)v68 + 7) = *(std::string::size_type *)((char *)&v61.__r_.__value_.__r.__words[1] + 7);
        int v36 = SHIBYTE(v61.__r_.__value_.__r.__words[2]);
        *(void *)&long long v62 = v21;
        memset(&v61, 0, sizeof(v61));
        if (v34) {
          operator delete((void *)v65);
        }
        unint64_t v67 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v37 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v37 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v65 = v37;
        long long v66 = v37;
        SVG::consumeOneOrMoreGeneric<double>((uint64_t)a1, (void (*)(long long *__return_ptr))SVG::consumeNumber, (uint64_t (*)(uint64_t, void))SVG::consumeCommaWsp, (uint64_t)&v65);
        if ((_BYTE)v67)
        {
          v56 = v35;
          *(void *)uint64_t v57 = v68[0];
          *(void *)&v57[7] = *(void *)((char *)v68 + 7);
          char v58 = v36;
          long long __p = v65;
          uint64_t v60 = v66;
          long long v65 = 0uLL;
          *(void *)&long long v66 = 0;
          SVG::ValueWithOffset<SVG::ICCColor>::ValueWithOffset(&v61, (long long *)&v56, *((std::string::size_type *)&v66 + 1));
          v54[0] = *(_OWORD *)&v61.__r_.__value_.__l.__data_;
          memset(&v61, 0, sizeof(v61));
          *(_OWORD *)((char *)&v54[1] + 8) = v62;
          unint64_t v38 = v64;
          *(void *)&v54[1] = *((void *)&v61.__r_.__value_.__l + 2);
          *((void *)&v54[2] + 1) = v63;
          *(void *)&long long v55 = v64;
          long long v62 = 0uLL;
          uint64_t v63 = 0;
          BYTE8(v55) = 1;
          if ((void)__p)
          {
            *((void *)&__p + 1) = __p;
            operator delete((void *)__p);
          }
          if (v58 < 0) {
            operator delete(v56);
          }
          if ((_BYTE)v67 && (void)v65)
          {
            *((void *)&v65 + 1) = v65;
            operator delete((void *)v65);
          }
          do
          {
            uint64_t v39 = v38;
            unint64_t v38 = SVG::consumeWsp((uint64_t *)a1, v38);
          }
          while (v40);
          std::string::size_type v41 = SVG::consumeString<2ul>(")", (uint64_t *)a1, v39);
          if (v42)
          {
            *(_OWORD *)unint64_t v50 = v54[0];
            uint64_t v51 = *(void *)&v54[1];
            memset(v54, 0, sizeof(v54));
            *(_OWORD *)std::string::size_type v52 = *(_OWORD *)((char *)&v54[1] + 8);
            uint64_t v53 = *((void *)&v54[2] + 1);
            SVG::ValueWithOffset<SVG::ICCColor>::ValueWithOffset(&v61, (long long *)v50, v41);
            uint64_t v43 = v63;
            unint64_t v7 = v64;
            *(void *)v47 = *((void *)&v61.__r_.__value_.__l + 2);
            long long v46 = *(_OWORD *)&v61.__r_.__value_.__l.__data_;
            memset(&v61, 0, sizeof(v61));
            *(_OWORD *)&v47[8] = v62;
            long long v62 = 0uLL;
            uint64_t v63 = 0;
            *(void *)&v47[24] = v43;
            *(void *)&long long v48 = v64;
            BYTE8(v48) = 1;
            if (v52[0])
            {
              v52[1] = v52[0];
              operator delete(v52[0]);
            }
            a3 = v44;
            if (SHIBYTE(v51) < 0) {
              operator delete(v50[0]);
            }
            std::__optional_destruct_base<SVG::ValueWithOffset<SVG::ICCColor>,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v54);
            goto LABEL_29;
          }
        }
        else
        {
          LOBYTE(v54[0]) = 0;
          BYTE8(v55) = 0;
          if (v36 < 0) {
            operator delete(v35);
          }
        }
      }
      LOBYTE(v46) = 0;
      BYTE8(v48) = 0;
      std::__optional_destruct_base<SVG::ValueWithOffset<SVG::ICCColor>,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v54);
      a3 = v44;
    }
    else
    {
LABEL_25:
      LOBYTE(v46) = 0;
      BYTE8(v48) = 0;
    }
LABEL_29:
    *(void *)a3 = v49[0];
    *(void *)(a3 + 8) = v7;
    *(unsigned char *)(a3 + 16) = 1;
    return std::__optional_destruct_base<SVG::ValueWithOffset<SVG::ICCColor>,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v46);
  }
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 16) = 0;
  return result;
}

void SVG::consumePaintIRI(std::string *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  memset(cf, 170, sizeof(cf));
  SVG::consumeFuncIRI((uint64_t)a1, a2, (uint64_t)cf);
  if (!LOBYTE(cf[2]))
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 40) = 0;
    return;
  }
  CFTypeRef v5 = cf[1];
  CFTypeRef v6 = cf[1];
  do
  {
    unint64_t v7 = (unint64_t)v6;
    CFTypeRef v6 = (CFTypeRef)SVG::consumeWsp((uint64_t *)a1, (unint64_t)v6);
  }
  while (v8);
  unint64_t v9 = SVG::consumeString<5ul>((uint64_t)"none", (uint64_t)a1, v7);
  if (!v10)
  {
    unint64_t v13 = SVG::consumeString<13ul>((uint64_t)a1, v7);
    if (!v14)
    {
      memset(v18, 170, sizeof(v18));
      SVG::consumeColorWithICCColor(a1, v7, (uint64_t)v18);
      if (LOBYTE(v18[2]))
      {
        CFTypeRef v15 = cf[0];
        uint64_t v17 = v18[0];
        uint64_t v16 = v18[1];
        if (cf[0])
        {
          CFRetain(cf[0]);
          CFRelease(v15);
        }
        *(void *)a3 = v15;
        *(void *)(a3 + 12) = v17;
        *(_DWORD *)(a3 + 20) = 2;
        *(unsigned char *)(a3 + 24) = 1;
        *(void *)(a3 + 32) = v16;
      }
      else
      {
        CFTypeRef v12 = cf[0];
        if (cf[0])
        {
          CFRetain(cf[0]);
          *(void *)a3 = v12;
          *(unsigned char *)(a3 + 8) = 0;
          *(unsigned char *)(a3 + 24) = 0;
          *(void *)(a3 + 32) = v5;
          goto LABEL_12;
        }
        *(void *)a3 = 0;
        *(unsigned char *)(a3 + 8) = 0;
        *(unsigned char *)(a3 + 24) = 0;
        *(void *)(a3 + 32) = v5;
      }
LABEL_22:
      *(unsigned char *)(a3 + 40) = 1;
      return;
    }
    unint64_t v11 = v13;
    CFTypeRef v12 = cf[0];
    if (cf[0])
    {
      CFRetain(cf[0]);
      *(void *)a3 = v12;
      *(_DWORD *)(a3 + 12) = 0;
      *(_DWORD *)(a3 + 20) = 1;
      goto LABEL_11;
    }
    *(void *)a3 = 0;
    *(_DWORD *)(a3 + 12) = 0;
    *(_DWORD *)(a3 + 20) = 1;
LABEL_21:
    *(unsigned char *)(a3 + 24) = 1;
    *(void *)(a3 + 32) = v11;
    goto LABEL_22;
  }
  unint64_t v11 = v9;
  CFTypeRef v12 = cf[0];
  if (!cf[0])
  {
    *(void *)a3 = 0;
    *(_DWORD *)(a3 + 12) = 0;
    *(_DWORD *)(a3 + 20) = 0;
    goto LABEL_21;
  }
  CFRetain(cf[0]);
  *(void *)a3 = v12;
  *(_DWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 20) = 0;
LABEL_11:
  *(unsigned char *)(a3 + 24) = 1;
  *(void *)(a3 + 32) = v11;
LABEL_12:
  *(unsigned char *)(a3 + 40) = 1;
  CFRelease(v12);
}

unint64_t SVG::consumeString<13ul>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned __int8 *)(a1 + 23);
  if ((v2 & 0x80u) != 0) {
    unint64_t v2 = *(void *)(a1 + 8);
  }
  uint64_t v3 = a2 + 12;
  if (v2 >= a2 + 12)
  {
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t v9 = *(char *)(a1 + 23) >= 0 ? a1 : *(void *)a1;
      int v10 = *(char *)(v9 + a2 + v8);
      __darwin_ct_rune_t v11 = aCurrentcolor[v8];
      if (__tolower(v11) != v10)
      {
        uint64_t v12 = *(char *)(a1 + 23) >= 0 ? a1 : *(void *)a1;
        int v13 = *(char *)(v12 + a2 + v8);
        if (__toupper(v11) != v13) {
          break;
        }
      }
      if (++v8 == 12)
      {
        unint64_t v5 = v3 & 0xFFFFFFFFFFFFFF00;
        uint64_t v4 = v3;
        return v5 | v4;
      }
    }
  }
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  return v5 | v4;
}

std::string *SVG::ValueWithOffset<SVG::ICCColor>::ValueWithOffset(std::string *this, long long *a2, std::string::size_type a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v6;
  }
  std::vector<double>::vector(this[1].__r_.__value_.__r.__words, (uint64_t)a2 + 24);
  this[2].__r_.__value_.__r.__words[0] = a3;
  return this;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  unint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    unint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void *std::vector<double>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<double>::__vallocate[abi:nn180100](a1, v5 >> 3);
    std::string::size_type v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<double>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  size_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<double>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a2);
}

void SVG::consumeOneOrMoreGeneric<double>(uint64_t a1@<X0>, void (*a2)(long long *__return_ptr)@<X2>, uint64_t (*a3)(uint64_t, void)@<X3>, uint64_t a4@<X8>)
{
  *(void *)&long long v32 = -1;
  *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  a2(&v32);
  if ((_BYTE)v33)
  {
    uint64_t v8 = (char *)operator new(8uLL);
    long long __p = v8;
    *(void *)uint64_t v8 = v32;
    uint64_t v9 = v8 + 8;
    int v36 = v8 + 8;
    while (1)
    {
      std::string v35 = v9;
      uint64_t v10 = *((void *)&v32 + 1);
      uint64_t v11 = a3(a1, *((void *)&v32 + 1));
      if (v12) {
        uint64_t v10 = v11;
      }
      ((void (*)(void **__return_ptr, uint64_t, uint64_t))a2)(__dst, a1, v10);
      LOBYTE(v33) = v30;
      long long v32 = *(_OWORD *)__dst;
      if (!(_BYTE)v30) {
        break;
      }
      int v13 = v35;
      if (v35 >= v36)
      {
        char v14 = (char *)__p;
        uint64_t v15 = (v35 - (unsigned char *)__p) >> 3;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 61) {
          abort();
        }
        uint64_t v17 = v36 - (unsigned char *)__p;
        if ((v36 - (unsigned char *)__p) >> 2 > v16) {
          unint64_t v16 = v17 >> 2;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v16;
        }
        if (v18)
        {
          char v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)&v36, v18);
          char v14 = (char *)__p;
          int v13 = v35;
        }
        else
        {
          char v19 = 0;
        }
        long long v20 = &v19[8 * v15];
        *(void *)long long v20 = v32;
        uint64_t v9 = v20 + 8;
        while (v13 != v14)
        {
          uint64_t v21 = *((void *)v13 - 1);
          v13 -= 8;
          *((void *)v20 - 1) = v21;
          v20 -= 8;
        }
        long long __p = v20;
        std::string v35 = v9;
        int v36 = &v19[8 * v18];
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *(void *)std::string v35 = v32;
        uint64_t v9 = v13 + 8;
      }
    }
    char v23 = (char *)__p;
    unint64_t v22 = v35;
    long long __p = 0;
    std::string v35 = 0;
    int v36 = 0;
    __dst[1] = 0;
    uint64_t v30 = 0;
    __dst[0] = 0;
    int64_t v24 = v22 - v23;
    if (v22 == v23)
    {
      uint64_t v28 = 0;
      char v26 = 0;
      char v27 = 0;
    }
    else
    {
      std::vector<double>::__vallocate[abi:nn180100](__dst, v24 >> 3);
      unint64_t v25 = (char *)__dst[1];
      memmove(__dst[1], v23, v24);
      char v26 = &v25[v24];
      char v27 = __dst[0];
      uint64_t v28 = v30;
    }
    *(void *)a4 = v27;
    *(void *)(a4 + 8) = v26;
    uint64_t v30 = 0;
    uint64_t v31 = v10;
    __dst[0] = 0;
    __dst[1] = 0;
    *(void *)(a4 + 16) = v28;
    *(void *)(a4 + 24) = v10;
    *(unsigned char *)(a4 + 32) = 1;
    if (v23) {
      operator delete(v23);
    }
    if (__p)
    {
      std::string v35 = (char *)__p;
      operator delete(__p);
    }
  }
  else
  {
    *(unsigned char *)a4 = 0;
    *(unsigned char *)(a4 + 32) = 0;
  }
}

uint64_t std::__optional_destruct_base<SVG::ValueWithOffset<SVG::ICCColor>,false>::~__optional_destruct_base[abi:nn180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    unint64_t v2 = *(void **)(a1 + 24);
    if (v2)
    {
      *(void *)(a1 + 32) = v2;
      operator delete(v2);
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t SVG::consumeAlone<double>(uint64_t a1, void (*a2)(uint64_t *__return_ptr, uint64_t, unint64_t))
{
  unint64_t v4 = 0;
  do
  {
    unint64_t v5 = v4;
    unint64_t v4 = SVG::consumeWsp((uint64_t *)a1, v4);
  }
  while (v6);
  uint64_t v12 = -1;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  a2(&v12, a1, v5);
  if (!(_BYTE)v14) {
    return 0;
  }
  unint64_t v7 = v13;
  do
  {
    unint64_t v8 = v7;
    unint64_t v7 = SVG::consumeWsp((uint64_t *)a1, v7);
  }
  while (v9);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 23);
  if ((v10 & 0x80u) != 0) {
    uint64_t v10 = *(void *)(a1 + 8);
  }
  if (v8 == v10) {
    return v12;
  }
  else {
    return 0;
  }
}

void SVG::consumeDashArrayValue(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 32) = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)a3 = v6;
  *(_OWORD *)(a3 + 16) = v6;
  *(void *)&v30[0] = -1;
  memset((char *)v30 + 8, 170, 24);
  SVG::consumeLength(a1, a2, (uint64_t)v30);
  if (BYTE8(v30[1]))
  {
    unint64_t v7 = (char *)operator new(0x10uLL);
    unint64_t v8 = v7 + 16;
    *(_OWORD *)unint64_t v7 = v30[0];
    long long __p = v7;
    unint64_t v33 = v7 + 16;
    while (1)
    {
      long long v32 = v8;
      unint64_t v9 = *(void *)&v30[1];
      unint64_t v10 = SVG::consumeCommaWsp(a1, *(unint64_t *)&v30[1]);
      if (v11) {
        unint64_t v9 = v10;
      }
      SVG::consumeLength(a1, v9, (uint64_t)__dst);
      *(_OWORD *)((char *)v30 + 9) = *(_OWORD *)((char *)__dst + 9);
      v30[0] = __dst[0];
      if (!BYTE8(__dst[1])) {
        break;
      }
      uint64_t v12 = v32;
      if (v32 >= v33)
      {
        uint64_t v13 = (v32 - (unsigned char *)__p) >> 4;
        unint64_t v14 = v13 + 1;
        if ((unint64_t)(v13 + 1) >> 60) {
          abort();
        }
        uint64_t v15 = v33 - (unsigned char *)__p;
        if ((v33 - (unsigned char *)__p) >> 3 > v14) {
          unint64_t v14 = v15 >> 3;
        }
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v14;
        }
        if (v16) {
          uint64_t v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Length>>((uint64_t)&v33, v16);
        }
        else {
          uint64_t v17 = 0;
        }
        unint64_t v18 = &v17[16 * v13];
        *(_OWORD *)unint64_t v18 = v30[0];
        long long v20 = (char *)__p;
        char v19 = v32;
        uint64_t v21 = v18;
        if (v32 != __p)
        {
          do
          {
            *((_OWORD *)v21 - 1) = *((_OWORD *)v19 - 1);
            v21 -= 16;
            v19 -= 16;
          }
          while (v19 != v20);
          char v19 = (char *)__p;
        }
        unint64_t v8 = v18 + 16;
        long long __p = v21;
        long long v32 = v18 + 16;
        unint64_t v33 = &v17[16 * v16];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        *(_OWORD *)long long v32 = v30[0];
        unint64_t v8 = v12 + 16;
      }
    }
    char v23 = (char *)__p;
    unint64_t v22 = v32;
    long long __p = 0;
    long long v32 = 0;
    unint64_t v33 = 0;
    memset(__dst, 0, 24);
    int64_t v24 = v22 - v23;
    if (v22 == v23)
    {
      uint64_t v28 = 0;
      uint64_t v26 = 0;
      uint64_t v27 = 0;
    }
    else
    {
      std::vector<SVG::Length>::__vallocate[abi:nn180100](__dst, v24 >> 4);
      uint64_t v25 = *((void *)&__dst[0] + 1);
      memmove(*((void **)&__dst[0] + 1), v23, v24);
      uint64_t v26 = v25 + v24;
      uint64_t v27 = *(void *)&__dst[0];
      uint64_t v28 = *(void *)&__dst[1];
    }
    *(void *)a3 = v27;
    *(void *)(a3 + 8) = v26;
    *((void *)&__dst[1] + 1) = v9;
    memset(__dst, 0, 24);
    *(void *)(a3 + 16) = v28;
    *(void *)(a3 + 24) = v9;
    *(unsigned char *)(a3 + 32) = 1;
    if (v23) {
      operator delete(v23);
    }
    if (__p)
    {
      long long v32 = (char *)__p;
      operator delete(__p);
    }
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = a2;
    *(unsigned char *)(a3 + 32) = 1;
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSK_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEEOSS_EEEDcSK_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSK_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEEOSS_EEEDcSK_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG12Presentation12NotSpecifiedENS9_7InheritENS9_5PaintEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISD_LNS0_6_TraitE1EEEEEvRSE_OT_EUlRSK_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEEOSS_EEEDcSK_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 40) = -1;
  return std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext>,(std::__variant_detail::_Trait)1>>(a2 + 8, a3 + 8);
}

uint64_t SVG::ShapeElement::ShapeElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)a1 = &unk_1F1A74668;
  uint64_t v6 = MEMORY[0x1E4F1DAB8];
  long long v7 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)(a1 + 640) = *MEMORY[0x1E4F1DAB8];
  *(_OWORD *)(a1 + 656) = v7;
  *(_OWORD *)(a1 + 672) = *(_OWORD *)(v6 + 32);
  std::string::basic_string[abi:nn180100]<0>(__p, "transform");
  std::string::basic_string[abi:nn180100]<0>(v16, "http://www.w3.org/2000/svg");
  unint64_t v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)__p, (uint64_t)v16);
  if (v17 < 0) {
    operator delete(v16[0]);
  }
  if (SBYTE7(v13) < 0)
  {
    operator delete(__p[0]);
    if (!v8) {
      return a1;
    }
  }
  else if (!v8)
  {
    return a1;
  }
  *(void *)&long long v9 = -1;
  *((void *)&v9 + 1) = -1;
  long long v13 = v9;
  long long v14 = v9;
  *(_OWORD *)long long __p = v9;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  SVG::parseTransform((uint64_t)(v8 + 64), (uint64_t)__p);
  if ((_BYTE)v15)
  {
    long long v10 = v13;
    *(_OWORD *)(a1 + 640) = *(_OWORD *)__p;
    *(_OWORD *)(a1 + 656) = v10;
    *(_OWORD *)(a1 + 672) = v14;
  }
  return a1;
}

uint64_t SVG::ShapeElement::appendChild()
{
  return 0;
}

uint64_t SVG::Element::isStructural(SVG::Element *this)
{
  return 0;
}

uint64_t *OTSVGGlyphRecordingCreate(std::mutex **a1, unsigned int a2)
{
  unint64_t v4 = *a1;
  std::mutex::lock(*a1);
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)&(*a1)[5].__m_.__opaque[16];
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    long long v9 = *(uint64_t ****)(*(void *)&(*a1)[5].__m_.__opaque[8] + 8 * v8);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t **)*i)
      {
        unint64_t v11 = (unint64_t)i[1];
        if (v11 == a2)
        {
          if (*((unsigned __int16 *)i + 8) == a2)
          {
            if (i[3]) {
              operator new();
            }
            unint64_t v15 = 0;
            std::mutex::unlock(v4);
            return v15;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  std::mutex::unlock(v4);
  unint64_t v60 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v59[7] = v12;
  v59[8] = v12;
  v59[5] = v12;
  v59[6] = v12;
  v59[3] = v12;
  v59[4] = v12;
  v59[1] = v12;
  v59[2] = v12;
  v59[0] = v12;
  long long v57 = v12;
  long long v58 = v12;
  v55[3] = v12;
  *(_OWORD *)v56 = v12;
  v55[1] = v12;
  v55[2] = v12;
  v55[0] = v12;
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v55);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v55, (uint64_t)"glyph", 5);
  std::ostream::operator<<();
  long long v13 = &(*a1)[1].__m_.__opaque[24];
  std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v55 + 8, __p);
  long long v14 = std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>(v13, (uint64_t)__p);
  unint64_t v15 = (uint64_t *)v14;
  if ((v54 & 0x80000000) == 0)
  {
    if (!v14) {
      goto LABEL_105;
    }
LABEL_21:
    unint64_t v15 = (uint64_t *)SVG::GlyphRecordingCreateWithElement((uint64_t)*a1, v15[5]);
    unint64_t v16 = *a1;
    std::mutex::lock(*a1);
    char v17 = *a1;
    if (v15)
    {
      uint64_t v19 = *v15;
      unint64_t v18 = (std::__shared_weak_count *)v15[1];
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      uint64_t v19 = 0;
      unint64_t v18 = 0;
    }
    unint64_t v20 = *(void *)&v17[5].__m_.__opaque[16];
    std::string::size_type v52 = v16;
    if (v20)
    {
      uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v20);
      v21.i16[0] = vaddlv_u8(v21);
      if (v21.u32[0] > 1uLL)
      {
        unint64_t v22 = a2;
        if (v20 <= a2) {
          unint64_t v22 = a2 % v20;
        }
      }
      else
      {
        unint64_t v22 = (v20 - 1) & a2;
      }
      char v23 = *(uint64_t ****)(*(void *)&v17[5].__m_.__opaque[8] + 8 * v22);
      if (v23)
      {
        for (j = *v23; j; j = (uint64_t **)*j)
        {
          unint64_t v25 = (unint64_t)j[1];
          if (v25 == a2)
          {
            if (*((unsigned __int16 *)j + 8) == a2) {
              goto LABEL_102;
            }
          }
          else
          {
            if (v21.u32[0] > 1uLL)
            {
              if (v25 >= v20) {
                v25 %= v20;
              }
            }
            else
            {
              v25 &= v20 - 1;
            }
            if (v25 != v22) {
              break;
            }
          }
        }
      }
    }
    else
    {
      unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
    }
    uint64_t v51 = &v17[5].__m_.__opaque[24];
    uint64_t v26 = operator new(0x28uLL);
    *uint64_t v26 = 0;
    v26[1] = a2;
    *((_WORD *)v26 + 8) = a2;
    v26[3] = v19;
    v26[4] = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    float v27 = (float)(unint64_t)(*(void *)&v17[5].__m_.__opaque[32] + 1);
    float v28 = *(float *)&v17[5].__m_.__opaque[40];
    if (v20 && (float)(v28 * (float)v20) >= v27)
    {
LABEL_92:
      uint64_t v45 = *(void *)&v17[5].__m_.__opaque[8];
      long long v46 = *(void **)(v45 + 8 * v22);
      if (v46)
      {
        *uint64_t v26 = *v46;
      }
      else
      {
        v47 = *(void **)v51;
        *uint64_t v26 = *(void *)v51;
        *(void *)uint64_t v51 = v26;
        *(void *)(v45 + 8 * v22) = v51;
        if (!v47) {
          goto LABEL_101;
        }
        unint64_t v48 = v47[1];
        if ((v20 & (v20 - 1)) != 0)
        {
          if (v48 >= v20) {
            v48 %= v20;
          }
        }
        else
        {
          v48 &= v20 - 1;
        }
        long long v46 = (void *)(*(void *)&v17[5].__m_.__opaque[8] + 8 * v48);
      }
      *long long v46 = v26;
LABEL_101:
      ++*(void *)&v17[5].__m_.__opaque[32];
      unint64_t v16 = v52;
LABEL_102:
      if (v18) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v18);
      }
      std::mutex::unlock(v16);
      goto LABEL_105;
    }
    BOOL v29 = 1;
    if (v20 >= 3) {
      BOOL v29 = (v20 & (v20 - 1)) != 0;
    }
    unint64_t v30 = v29 | (2 * v20);
    unint64_t v31 = vcvtps_u32_f32(v27 / v28);
    if (v30 <= v31) {
      int8x8_t prime = (int8x8_t)v31;
    }
    else {
      int8x8_t prime = (int8x8_t)v30;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v20 = *(void *)&v17[5].__m_.__opaque[16];
    if (*(void *)&prime > v20) {
      goto LABEL_56;
    }
    if (*(void *)&prime < v20)
    {
      unint64_t v39 = vcvtps_u32_f32((float)*(unint64_t *)&v17[5].__m_.__opaque[32] / *(float *)&v17[5].__m_.__opaque[40]);
      if (v20 < 3 || (uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v20), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
      {
        unint64_t v39 = std::__next_prime(v39);
      }
      else
      {
        uint64_t v41 = 1 << -(char)__clz(v39 - 1);
        if (v39 >= 2) {
          unint64_t v39 = v41;
        }
      }
      if (*(void *)&prime <= v39) {
        int8x8_t prime = (int8x8_t)v39;
      }
      if (*(void *)&prime >= v20)
      {
        unint64_t v20 = *(void *)&v17[5].__m_.__opaque[16];
      }
      else
      {
        if (prime)
        {
LABEL_56:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v33 = operator new(8 * *(void *)&prime);
          BOOL v34 = *(void **)&v17[5].__m_.__opaque[8];
          *(void *)&v17[5].__m_.__opaque[8] = v33;
          if (v34) {
            operator delete(v34);
          }
          uint64_t v35 = 0;
          *(int8x8_t *)&v17[5].__m_.__opaque[16] = prime;
          do
            *(void *)(*(void *)&v17[5].__m_.__opaque[8] + 8 * v35++) = 0;
          while (*(void *)&prime != v35);
          int v36 = *(void **)v51;
          if (*(void *)v51)
          {
            unint64_t v37 = v36[1];
            uint8x8_t v38 = (uint8x8_t)vcnt_s8(prime);
            v38.i16[0] = vaddlv_u8(v38);
            if (v38.u32[0] > 1uLL)
            {
              if (v37 >= *(void *)&prime) {
                v37 %= *(void *)&prime;
              }
            }
            else
            {
              v37 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)&v17[5].__m_.__opaque[8] + 8 * v37) = v51;
            char v42 = (void *)*v36;
            if (*v36)
            {
              do
              {
                unint64_t v43 = v42[1];
                if (v38.u32[0] > 1uLL)
                {
                  if (v43 >= *(void *)&prime) {
                    v43 %= *(void *)&prime;
                  }
                }
                else
                {
                  v43 &= *(void *)&prime - 1;
                }
                if (v43 != v37)
                {
                  uint64_t v44 = *(void *)&v17[5].__m_.__opaque[8];
                  if (!*(void *)(v44 + 8 * v43))
                  {
                    *(void *)(v44 + 8 * v43) = v36;
                    goto LABEL_83;
                  }
                  *int v36 = *v42;
                  *char v42 = **(void **)(*(void *)&v17[5].__m_.__opaque[8] + 8 * v43);
                  **(void **)(*(void *)&v17[5].__m_.__opaque[8] + 8 * v43) = v42;
                  char v42 = v36;
                }
                unint64_t v43 = v37;
LABEL_83:
                int v36 = v42;
                char v42 = (void *)*v42;
                unint64_t v37 = v43;
              }
              while (v42);
            }
          }
          unint64_t v20 = (unint64_t)prime;
          goto LABEL_87;
        }
        unint64_t v50 = *(void **)&v17[5].__m_.__opaque[8];
        *(void *)&v17[5].__m_.__opaque[8] = 0;
        if (v50) {
          operator delete(v50);
        }
        unint64_t v20 = 0;
        *(void *)&v17[5].__m_.__opaque[16] = 0;
      }
    }
LABEL_87:
    if ((v20 & (v20 - 1)) != 0)
    {
      if (v20 <= v5) {
        unint64_t v22 = v5 % v20;
      }
      else {
        unint64_t v22 = v5;
      }
    }
    else
    {
      unint64_t v22 = (v20 - 1) & v5;
    }
    goto LABEL_92;
  }
  operator delete(__p[0]);
  if (v15) {
    goto LABEL_21;
  }
LABEL_105:
  *(void *)&v55[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v55 + *(void *)(*(void *)&v55[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v55[0] + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v57) < 0) {
    operator delete(v56[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C18A3E60](v59);
  return v15;
}

uint64_t std::ostringstream::basic_ostringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 24;
  uint64_t v3 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v5;
  *(void *)(a1 + *(void *)(v5 - 24)) = v4;
  unint64_t v6 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(void *)a1 = v2;
  *(void *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

uint64_t SVG::GlyphRecordingCreateWithElement(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  memcpy(__dst, &unk_1BF1D9B48, sizeof(__dst));
  SVG::Presentation::defaultPresentation((uint64_t)__dst);
  memcpy(v27, &unk_1BF1D9948, sizeof(v27));
  SVG::Recorder::getInitialState(__dst, (uint64_t)v29);
  SVG::Recorder::Recorder((uint64_t)v27, v29, *(void *)(a1 + 88), *(_DWORD *)(a1 + 72), 72.0);
  if (LODWORD(v29[2].c) != -1) {
    ((void (*)(_OWORD *, CGFloat *))*(&off_1F1A75130 + LODWORD(v29[2].c)))(v20, &v29[0].b);
  }
  *(void *)&long long v4 = -1;
  *((void *)&v4 + 1) = -1;
  *(_OWORD *)&v25.c = v4;
  *(_OWORD *)&v25.tx = v4;
  *(_OWORD *)&v25.a = v4;
  unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = *(void *)(a1 + 64);
  SVG::computeViewBoxTransform(*(CGAffineTransform **)(v5 + 704), (uint64_t)&v25, *(CGFloat *)(v5 + 672), *(CGFloat *)(v5 + 680), *(CGFloat *)(v5 + 688), *(CGFloat *)(v5 + 696), 0.0, 0.0, *(double *)(v5 + 656), *(double *)(v5 + 664));
  if (!(_BYTE)v26) {
LABEL_18:
  }
    operator new();
  *(void *)&long long v6 = -1;
  *((void *)&v6 + 1) = -1;
  *(_OWORD *)&v24.c = v6;
  *(_OWORD *)&v24.tx = v6;
  CGAffineTransform t1 = v25;
  *(_OWORD *)&v24.a = v6;
  CGAffineTransformMakeScale(&t2, 1.0, -1.0);
  CGAffineTransformConcat(&v24, &t1, &t2);
  memset(&v20[2], 255, 32);
  v20[4] = xmmword_1BF1D9B30;
  v20[0] = xmmword_1BF1D9AF0;
  v20[1] = unk_1BF1D9B00;
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  CGAffineTransform v19 = v24;
  SVG::AffineTransformApplier::AffineTransformApplier((uint64_t)v20, (uint64_t)v27, &v19);
  memcpy(v29, &unk_1BF1D9B48, sizeof(v29));
  SVG::Presentation::inherit((SVG::Presentation *)(*(void *)(a1 + 64) + 64), (const SVG::Presentation *)__dst, (const SVG::Presentation *)__dst, v29);
  if (LODWORD(v29[2].ty) == 2)
  {
    if (HIDWORD(v29[2].tx) != 2)
    {
      *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v16[0] = v7;
      v16[1] = v7;
      uint64_t v17 = -1;
      unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v8 = *(double **)(a1 + 64);
      double v9 = v8[84];
      double v10 = v8[85];
      double v11 = v8[86];
      double v12 = v8[87];
      long long v13 = operator new(0x28uLL);
      *long long v13 = &unk_1F1A74D60;
      v13[1] = v27;
      v13[2] = a1;
      unint64_t v13[3] = __dst;
      v13[4] = a2;
      void v28[3] = v13;
      SVG::ApplyPresentation::ApplyPresentation((uint64_t)v16, v27, (uint64_t)v29, v8, (void *)(a1 + 136), (void *)(a1 + 256), (void *)(a1 + 296), (uint64_t)v28, v9, v10, v11, v12);
      std::__function::__value_func<void ()(SVG::ApplyPresentationState const&)>::~__value_func[abi:nn180100](v28);
      SVG::ApplyPresentation::~ApplyPresentation((SVG::ApplyPresentation *)v16);
    }
    if (LODWORD(v29[9].c) != -1) {
      ((void (*)(_OWORD *, CGFloat *))*(&off_1F1A751B8 + LODWORD(v29[9].c)))(v16, &v29[8].tx);
    }
    LODWORD(v29[9].c) = -1;
    if (LODWORD(v29[8].c) != -1) {
      ((void (*)(_OWORD *, CGFloat *))*(&off_1F1A751D0 + LODWORD(v29[8].c)))(v16, &v29[7].c);
    }
    LODWORD(v29[8].c) = -1;
    if (LODWORD(v29[5].d) != -1) {
      ((void (*)(_OWORD *, CGFloat *))*(&off_1F1A751E8 + LODWORD(v29[5].d)))(v16, &v29[5].b);
    }
    LODWORD(v29[5].d) = -1;
    if (LODWORD(v29[4].b) != -1) {
      ((void (*)(_OWORD *, CGFloat *))*(&off_1F1A751D0 + LODWORD(v29[4].b)))(v16, &v29[3].b);
    }
    LODWORD(v29[4].b) = -1;
    if (LODWORD(v29[1].tx) != -1) {
      ((void (*)(_OWORD *, CGFloat *))*(&off_1F1A751E8 + LODWORD(v29[1].tx)))(v16, &v29[1].c);
    }
    SVG::AffineTransformApplier::~AffineTransformApplier((SVG::AffineTransformApplier *)v20);
    goto LABEL_18;
  }
  uint64_t v14 = std::__throw_bad_variant_access[abi:nn180100]();
  return OTSVGGlyphRecordingCreateFromDocument(v14);
}

uint64_t OTSVGGlyphRecordingCreateFromDocument(uint64_t *a1)
{
  return SVG::GlyphRecordingCreateWithElement(*a1, *(void *)(*a1 + 64));
}

uint64_t OTSVGGlyphRecordingCreateFromID(uint64_t *a1, CFStringRef theString)
{
  CFIndex maxBufLen = 0;
  v16.length = CFStringGetLength(theString);
  v16.location = 0;
  CFStringGetBytes(theString, v16, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
  CFIndex v4 = maxBufLen;
  if (maxBufLen)
  {
    if (maxBufLen < 0) {
      goto LABEL_21;
    }
    uint64_t v5 = (char *)operator new(maxBufLen);
    long long v6 = &v5[v4];
    bzero(v5, v4);
  }
  else
  {
    long long v6 = 0;
    uint64_t v5 = 0;
  }
  v17.length = CFStringGetLength(theString);
  v17.location = 0;
  CFStringGetBytes(theString, v17, 0x8000100u, 0, 0, (UInt8 *)v5, maxBufLen, 0);
  size_t v7 = v6 - v5;
  memset(__dst, 170, sizeof(__dst));
  if ((unint64_t)(v6 - v5) >= 0x7FFFFFFFFFFFFFF8) {
LABEL_21:
  }
    abort();
  if (v7 >= 0x17)
  {
    uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v9 = v7 | 7;
    }
    uint64_t v10 = v9 + 1;
    unint64_t v8 = (void **)operator new(v9 + 1);
    __dst[1] = (void *)v7;
    _OWORD __dst[2] = (void *)(v10 | 0x8000000000000000);
    __dst[0] = v8;
    goto LABEL_12;
  }
  HIBYTE(__dst[2]) = (_BYTE)v6 - (_BYTE)v5;
  unint64_t v8 = __dst;
  if (v6 != v5) {
LABEL_12:
  }
    memcpy(v8, v5, v7);
  *((unsigned char *)v8 + v7) = 0;
  double v11 = std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>((void *)(*a1 + 96), (uint64_t)__dst);
  if (v11) {
    uint64_t v12 = SVG::GlyphRecordingCreateWithElement(*a1, *((void *)v11 + 5));
  }
  else {
    uint64_t v12 = 0;
  }
  if (SHIBYTE(__dst[2]) < 0) {
    operator delete(__dst[0]);
  }
  if (v5) {
    operator delete(v5);
  }
  return v12;
}

uint64_t OTSVGGlyphRecordingRelease(uint64_t result)
{
  if (result)
  {
    v1 = *(std::__shared_weak_count **)(result + 8);
    if (v1) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v1);
    }
    JUMPOUT(0x1C18A3E80);
  }
  return result;
}

void OTSVGGlyphRecordingPlayback(uint64_t **a1, uint64_t a2)
{
}

void OTSVGGlyphRecordingPlaybackRecordingsAtPositions(uint64_t ***a1, uint64_t a2, uint64_t a3, CGContextRef c)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v4 = a3;
      if (a3)
      {
        long long v6 = a1;
        size_t v7 = (CGFloat *)(a2 + 8);
        do
        {
          if (*v6)
          {
            CGContextSaveGState(c);
            unint64_t v8 = **v6;
            LODWORD(v9) = *((_DWORD *)v8 + 14);
            CGFloat v10 = *((double *)v8 + 8) / (double)v9;
            CGAffineTransformMakeTranslation(&v11, *(v7 - 1), *v7);
            CGAffineTransformScale(&transform, &v11, v10, v10);
            CGContextConcatCTM(c, &transform);
            SVG::playback((uint64_t)c, **v6);
            CGContextRestoreGState(c);
          }
          v7 += 2;
          ++v6;
          --v4;
        }
        while (v4);
      }
    }
  }
}

double OTSVGGlyphRecordingGetBoundingRect(void *a1)
{
  if (a1) {
    uint64_t v1 = *a1 + 24;
  }
  else {
    uint64_t v1 = MEMORY[0x1E4F1DB28];
  }
  return *(double *)v1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSH_1EJSC_SE_SF_EEEEEEDcSJ_DpT0_(uint64_t a1, CFTypeRef *a2)
{
  if (*a2) {
    CFRelease(*a2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSH_1EJSC_SE_SF_EEEEEEDcSJ_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a2 + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

void std::__shared_weak_count::__release_shared[abi:nn180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t SVG::AffineTransformApplier::AffineTransformApplier(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a2;
  long long v6 = (SVG::StateSaverRestorer *)(a1 + 8);
  *(unsigned char *)(a1 + 16) = 0;
  long long v7 = a3[1];
  *(_OWORD *)&v20.a = *a3;
  *(_OWORD *)&v20.c = v7;
  *(_OWORD *)&v20.tx = a3[2];
  SVG::invert(&v20, a1 + 24);
  long long v8 = a3[1];
  *(_OWORD *)&v19.a = *a3;
  *(_OWORD *)&v19.c = v8;
  *(_OWORD *)&v19.tx = a3[2];
  BOOL IsIdentity = CGAffineTransformIsIdentity(&v19);
  *(unsigned char *)(a1 + 80) = IsIdentity;
  if (!IsIdentity)
  {
    if (!*(unsigned char *)(a1 + 72) && !*(unsigned char *)(a1 + 16)) {
      SVG::StateSaverRestorer::save(v6);
    }
    long long v11 = *a3;
    long long v12 = a3[1];
    long long v13 = a3[2];
    uint64_t v14 = &unk_1F1A74C88;
    long long v15 = v11;
    long long v16 = v12;
    long long v17 = v13;
    unsigned int v18 = 2;
    SVG::Recorder::append(a2, (uint64_t)&v14);
    if (v18 != -1) {
      ((void (*)(char *, void **))*(&off_1F1A75148 + v18))(&v21, &v14);
    }
  }
  return a1;
}

uint64_t SVG::StateSaverRestorer::save(SVG::StateSaverRestorer *this)
{
  uint64_t v2 = *(void *)this;
  v4[0] = &unk_1F1A74D18;
  unsigned int v5 = 0;
  uint64_t result = SVG::Recorder::append(v2, (uint64_t)v4);
  if (v5 != -1) {
    uint64_t result = ((uint64_t (*)(char *, void *))*(&off_1F1A75148 + v5))(&v6, v4);
  }
  *((unsigned char *)this + 8) = 1;
  return result;
}

void SVG::SaveState::~SaveState(SVG::SaveState *this)
{
}

void SVG::SaveState::execute(int a1, CGContextRef c)
{
}

double SVG::SaveState::boundingRect(SVG::SaveState *this, SVG::BoundingRectState *a2)
{
  unint64_t v2 = *((void *)a2 + 5) + *((void *)a2 + 4) - 1;
  std::deque<SVG::BoundingRectState::State>::push_back(a2, *(void *)(*((void *)a2 + 1) + 8 * (v2 / 0x2E)) + 88 * (v2 % 0x2E));
  return *MEMORY[0x1E4F1DB28];
}

double SVG::SaveState::timeCost()
{
  return 0.531666877;
}

double SVG::Command::memoryCost()
{
  return 0.0;
}

uint64_t SVG::SaveState::dump(SVG::SaveState *this)
{
  uint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"SaveState", 9);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  unint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

__n128 std::deque<SVG::BoundingRectState::State>::push_back(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 46 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<SVG::BoundingRectState::State>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x2E)) + 88 * (v7 % 0x2E);
  long long v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v11 = *(_OWORD *)(a2 + 48);
  long long v12 = *(_OWORD *)(a2 + 64);
  *(void *)(v8 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)(v8 + 48) = v11;
  *(_OWORD *)(v8 + 64) = v12;
  *(__n128 *)(v8 + 32) = result;
  ++a1[5];
  return result;
}

void std::deque<SVG::BoundingRectState::State>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x2E;
  unint64_t v4 = v2 - 46;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_29:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v29 = 1;
      }
      else {
        unint64_t v29 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v30 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>(v5, v29);
      uint64_t v31 = &v30[8 * (v29 >> 2)];
      unint64_t v33 = &v30[8 * v32];
      BOOL v34 = (uint64_t *)a1[1];
      unint64_t v8 = v31;
      uint64_t v35 = a1[2] - (void)v34;
      if (v35)
      {
        unint64_t v8 = &v31[v35 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v36 = 8 * (v35 >> 3);
        unint64_t v37 = &v30[8 * (v29 >> 2)];
        do
        {
          uint64_t v38 = *v34++;
          *(void *)unint64_t v37 = v38;
          v37 += 8;
          v36 -= 8;
        }
        while (v36);
      }
      goto LABEL_26;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    CGAffineTransform v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_29;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFD0uLL);
      std::__split_buffer<SVG::BoundingRectState::State *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFD0uLL);
    std::__split_buffer<SVG::BoundingRectState::State *>::push_front((uint64_t)a1, &v54);
    uint8x8_t v40 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v41 = *v40;
    long long v9 = (char *)(v40 + 1);
    uint64_t v10 = v41;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_29;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v30 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)(a1 + 3), v46);
      uint64_t v31 = &v30[8 * (v46 >> 2)];
      unint64_t v33 = &v30[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v31;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v31[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v30[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_26:
      unint64_t v39 = (char *)*a1;
      *a1 = v30;
      a1[1] = v31;
      a1[2] = v8;
      a1[3] = v33;
      if (v39)
      {
        operator delete(v39);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_29;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0xFD0uLL);
  std::__split_buffer<SVG::BoundingRectState::State *>::push_back(&v54, &v53);
  float v27 = (char *)a1[2];
  if (v27 == (char *)a1[1])
  {
    float v28 = (char *)a1[2];
  }
  else
  {
    do
    {
      v27 -= 8;
      std::__split_buffer<SVG::BoundingRectState::State *>::push_front((uint64_t)&v54, v27);
    }
    while (v27 != (char *)a1[1]);
    float v28 = (char *)a1[2];
  }
  char v42 = (char *)*a1;
  long long v43 = v54;
  long long v44 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  uint64_t v45 = a1[3];
  *(_OWORD *)a1 = v43;
  *((_OWORD *)a1 + 1) = v44;
  *(void *)&long long v55 = v28;
  *((void *)&v55 + 1) = v45;
  if (v28 != v27) {
    *(void *)&long long v55 = &v28[(v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (v42) {
    operator delete(v42);
  }
}

void std::__split_buffer<SVG::BoundingRectState::State *>::push_back(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    unint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v18 = 1;
      }
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      CGAffineTransform v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      uint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        uint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      float v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        uint64_t v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        uint64_t v6 = (char *)a1[1];
      }
      uint64_t v17 = &v6[8 * v13];
      uint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)uint64_t v6 = *a2;
  a1[2] += 8;
}

{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        int64_t v16 = 1;
      }
      else {
        int64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>(a1[4], v16);
      CGAffineTransform v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      unint64_t v7 = v6 >> 3;
      uint64_t v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        BOOL v10 = v9;
      }
      else {
        BOOL v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      uint64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }
      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<SVG::BoundingRectState::State *>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    unint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

{
  char *v4;
  char *v5;
  unsigned char *v6;
  unsigned char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    unint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = (v7 - v4) >> 2;
      }
      unint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      int64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        int64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void SVG::ConcatCTM::~ConcatCTM(SVG::ConcatCTM *this)
{
}

void SVG::ConcatCTM::execute(uint64_t a1, CGContextRef c)
{
  long long v2 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&v3.a = *(_OWORD *)(a1 + 8);
  *(_OWORD *)&v3.c = v2;
  *(_OWORD *)&v3.tx = *(_OWORD *)(a1 + 40);
  CGContextConcatCTM(c, &v3);
}

double SVG::ConcatCTM::boundingRect(SVG::ConcatCTM *this, SVG::BoundingRectState *a2)
{
  long long v2 = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)&v4.a = *(_OWORD *)((char *)this + 8);
  *(_OWORD *)&v4.c = v2;
  *(_OWORD *)&v4.tx = *(_OWORD *)((char *)this + 40);
  SVG::BoundingRectState::concatCTM(a2, &v4);
  return *MEMORY[0x1E4F1DB28];
}

double SVG::ConcatCTM::timeCost()
{
  return 2.83167397;
}

uint64_t SVG::ConcatCTM::dump(SVG::ConcatCTM *this)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"ConcatCTM ", 10);
  uint64_t v1 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v1, (uint64_t)" ", 1);
  long long v2 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v2, (uint64_t)" ", 1);
  CGAffineTransform v3 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v3, (uint64_t)" ", 1);
  CGAffineTransform v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v4, (uint64_t)" ", 1);
  uint64_t v5 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)" ", 1);
  uint64_t v6 = (void *)std::ostream::operator<<();
  unint64_t v7 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)" ", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(void *)(*v7 - 24)));
  uint64_t v8 = std::locale::use_facet(&v10, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v10);
  std::ostream::put();
  return std::ostream::flush();
}

__n128 SVG::BoundingRectState::concatCTM(SVG::BoundingRectState *this, CGAffineTransform *a2)
{
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  *(_OWORD *)&v12.c = v2;
  *(_OWORD *)&v12.tx = v2;
  *(_OWORD *)&v12.a = v2;
  long long v3 = *(_OWORD *)&a2->c;
  *(_OWORD *)&t1.a = *(_OWORD *)&a2->a;
  *(_OWORD *)&t1.c = v3;
  *(_OWORD *)&t1.tx = *(_OWORD *)&a2->tx;
  unint64_t v4 = *((void *)this + 5) + *((void *)this + 4) - 1;
  uint64_t v5 = (__n128 *)(*(void *)(*((void *)this + 1) + 8 * (v4 / 0x2E)) + 88 * (v4 % 0x2E));
  __n128 v6 = *v5;
  __n128 v7 = v5[2];
  *(__n128 *)&v10.c = v5[1];
  *(__n128 *)&v10.tx = v7;
  *(__n128 *)&v10.a = v6;
  CGAffineTransformConcat(&v12, &t1, &v10);
  __n128 result = *(__n128 *)&v12.a;
  __n128 v9 = *(__n128 *)&v12.tx;
  v5[1] = *(__n128 *)&v12.c;
  v5[2] = v9;
  *uint64_t v5 = result;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSO_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEEEEDcSQ_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74CD0;
  long long v2 = (const void *)a2[1];
  if (v2) {
    CFRelease(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSO_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEEEEDcSQ_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74BC8;
  long long v2 = (const void *)a2[1];
  if (v2) {
    CFRelease(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSO_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEEEEDcSQ_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74890;
  long long v2 = (const void *)a2[1];
  if (v2) {
    CFRelease(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSO_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEEEEDcSQ_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A748D8;
  long long v2 = (const void *)a2[1];
  if (v2) {
    CFRelease(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSO_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEEEEDcSQ_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74458;
  long long v2 = (std::__shared_weak_count *)a2[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSO_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEEEEDcSQ_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74280;
  long long v2 = (std::__shared_weak_count *)a2[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSO_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEEEEDcSQ_DpT0_(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F1A74B80;
  uint64_t v3 = *(unsigned int *)(a2 + 112);
  if (v3 != -1) {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A75130 + v3))(&v5, a2 + 8);
  }
  *(_DWORD *)(a2 + 112) = -1;
  return result;
}

void SVG::DrawImage::~DrawImage(SVG::DrawImage *this)
{
  *(void *)this = &unk_1F1A74CD0;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1A74CD0;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1C18A3E80);
}

void SVG::DrawImage::execute(uint64_t a1, CGContext *a2)
{
  *(void *)&long long v4 = -1;
  *((void *)&v4 + 1) = -1;
  *(_OWORD *)&v14.c = v4;
  *(_OWORD *)&v14.tx = v4;
  *(_OWORD *)&v14.a = v4;
  CGFloat v6 = *(double *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  *(CGFloat *)&long long v4 = v6;
  CGFloat MaxY = CGRectGetMaxY(*(CGRect *)&v4);
  CGAffineTransformMakeTranslation(&v13, v6, MaxY);
  CGAffineTransformScale(&v14, &v13, 1.0, -1.0);
  CGAffineTransform transform = v14;
  CGContextConcatCTM(a2, &transform);
  v15.size.width = *(CGFloat *)(a1 + 32);
  v15.size.height = *(CGFloat *)(a1 + 40);
  v15.origin.x = 0.0;
  v15.origin.y = 0.0;
  CGContextDrawImage(a2, v15, *(CGImageRef *)(a1 + 8));
  CGAffineTransform v10 = v14;
  CGAffineTransformInvert(&v11, &v10);
  CGContextConcatCTM(a2, &v11);
}

double SVG::DrawImage::boundingRect(SVG::DrawImage *this, SVG::BoundingRectState *a2)
{
  return SVG::BoundingRectState::deviceRect(a2, *(CGRect *)((char *)this + 16));
}

CGFloat SVG::DrawImage::timeCost(SVG::DrawImage *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  CGFloat v4 = CGRectGetWidth(*a2) * 0.0106;
  return v4 * CGRectGetHeight(*a2);
}

uint64_t SVG::DrawImage::dump(SVG::DrawImage *this)
{
  uint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"DrawImage", 9);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  long long v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

double SVG::BoundingRectState::deviceRect(SVG::BoundingRectState *this, CGRect a2)
{
  unint64_t v2 = *((void *)this + 5) + *((void *)this + 4) - 1;
  unint64_t v3 = *(void *)(*((void *)this + 1) + 8 * (v2 / 0x2E)) + 88 * (v2 % 0x2E);
  long long v5 = *(_OWORD *)(v3 + 16);
  long long v4 = *(_OWORD *)(v3 + 32);
  *(_OWORD *)&v8.a = *(_OWORD *)v3;
  *(_OWORD *)&v8.c = v5;
  *(_OWORD *)&v8.tx = v4;
  CGRect v9 = CGRectApplyAffineTransform(a2, &v8);
  CGFloat v6 = (CGRect *)(v3 + 48);
  if (!*(unsigned char *)(v3 + 80)) {
    CGFloat v6 = (CGRect *)MEMORY[0x1E4F1DB10];
  }
  *(void *)&double result = (unint64_t)CGRectIntersection(v9, *v6);
  return result;
}

void SVG::FillPath::~FillPath(SVG::FillPath *this)
{
  *(void *)this = &unk_1F1A74BC8;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1A74BC8;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1C18A3E80);
}

void SVG::FillPath::execute(uint64_t a1, CGContextRef c)
{
  CGContextAddPath(c, *(CGPathRef *)(a1 + 8));
  if (*(unsigned char *)(a1 + 16))
  {
    CGContextEOFillPath(c);
  }
  else
  {
    CGContextFillPath(c);
  }
}

double SVG::FillPath::boundingRect(SVG::FillPath *this, SVG::BoundingRectState *a2)
{
  CGRect BoundingBox = CGPathGetBoundingBox((CGPathRef)*((void *)this + 1));
  return SVG::BoundingRectState::deviceRect(a2, BoundingBox);
}

CGFloat SVG::FillPath::timeCost(CGPathRef *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  unint64_t info = 0;
  CGPathApply(this[1], &info, (CGPathApplierFunction)SVG::FillPath::countContours);
  double v4 = (double)info;
  CGFloat v5 = CGRectGetWidth(*a2) * 0.000411595;
  return v5 * CGRectGetHeight(*a2) + v4 * 0.125484 + 12.6893;
}

void SVG::FillPath::dump(SVG::FillPath *this)
{
  __b[128] = *(std::locale *)MEMORY[0x1E4F143B8];
  unint64_t v2 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"FillPath", 8);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  unint64_t v3 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(__b);
  std::ostream::put();
  std::ostream::flush();
  double v4 = (const void *)*((void *)this + 1);
  if (v4)
  {
    CFStringRef v5 = CFCopyDescription(v4);
    memset(__b, 170, 0x400uLL);
    CFStringGetCString(v5, (char *)__b, 1024, 0x8000100u);
    CGFloat v6 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"    ", 4);
    size_t v7 = strlen((const char *)__b);
    CGAffineTransform v8 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)__b, v7);
    std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
    CGRect v9 = std::locale::use_facet(&v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
    std::locale::~locale(&v10);
    std::ostream::put();
    std::ostream::flush();
    if (v5) {
      CFRelease(v5);
    }
  }
}

void *SVG::FillPath::countContours(void *this, void *a2, const CGPathElement *a3)
{
  return this;
}

void SVG::DrawLinearGradient::~DrawLinearGradient(SVG::DrawLinearGradient *this)
{
  *(void *)this = &unk_1F1A74890;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1A74890;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1C18A3E80);
}

void SVG::DrawLinearGradient::execute(uint64_t a1, CGContextRef c)
{
}

double SVG::DrawLinearGradient::boundingRect(SVG::DrawLinearGradient *this, SVG::BoundingRectState *a2)
{
  return SVG::BoundingRectState::clipRect(a2);
}

CGFloat SVG::DrawLinearGradient::timeCost(SVG::DrawLinearGradient *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  CGFloat v4 = CGRectGetWidth(*a2) * 0.0046;
  return v4 * CGRectGetHeight(*a2) + 34.306;
}

uint64_t SVG::DrawLinearGradient::dump(SVG::DrawLinearGradient *this)
{
  uint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"DrawLinearGradient", 18);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  unint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

double SVG::BoundingRectState::clipRect(SVG::BoundingRectState *this)
{
  unint64_t v1 = *((void *)this + 5) + *((void *)this + 4) - 1;
  unint64_t v2 = *(void *)(*((void *)this + 1) + 8 * (v1 / 0x2E)) + 88 * (v1 % 0x2E);
  if (*(unsigned char *)(v2 + 80)) {
    return *(double *)(v2 + 48);
  }
  else {
    return 0.0;
  }
}

void SVG::DrawRadialGradient::~DrawRadialGradient(SVG::DrawRadialGradient *this)
{
  *(void *)this = &unk_1F1A748D8;
  unint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1A748D8;
  unint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1C18A3E80);
}

void SVG::DrawRadialGradient::execute(uint64_t a1, CGContextRef c)
{
}

double SVG::DrawRadialGradient::boundingRect(SVG::DrawRadialGradient *this, SVG::BoundingRectState *a2)
{
  return SVG::BoundingRectState::clipRect(a2);
}

CGFloat SVG::DrawRadialGradient::timeCost(SVG::DrawRadialGradient *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  CGFloat v4 = CGRectGetWidth(*a2) * 0.0076;
  return v4 * CGRectGetHeight(*a2) + 166.67;
}

uint64_t SVG::DrawRadialGradient::dump(SVG::DrawRadialGradient *this)
{
  unint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"DrawRadialGradient", 18);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  unint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

void SVG::ClipToMask::~ClipToMask(SVG::ClipToMask *this)
{
  *(void *)this = &unk_1F1A74280;
  unint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

{
  std::__shared_weak_count *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1A74280;
  unint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  JUMPOUT(0x1C18A3E80);
}

void SVG::ClipToMask::execute(uint64_t a1, SVG *this)
{
  size_t v7 = (CGContext *)0xAAAAAAAAAAAAAAAALL;
  SVG::createParallelBitmapContext(this, *(CGRect *)(a1 + 72), &v7);
  if (v7)
  {
    long long v4 = *(_OWORD *)(a1 + 40);
    *(_OWORD *)&transform.a = *(_OWORD *)(a1 + 24);
    *(_OWORD *)&transform.c = v4;
    *(_OWORD *)&transform.tx = *(_OWORD *)(a1 + 56);
    CGContextConcatCTM(v7, &transform);
    SVG::playback((uint64_t)v7, *(uint64_t **)(a1 + 8));
    CGContextFlush(v7);
    CGImageRef mask = (CGImageRef)0xAAAAAAAAAAAAAAAALL;
    SVG::convertToMask(v7, &mask);
    if (mask)
    {
      CGContextClipToMask(this, *(CGRect *)(a1 + 72), mask);
    }
    else
    {
      CGContextAddRect(this, *MEMORY[0x1E4F1DB28]);
      CGContextClip(this);
    }
    if (mask) {
      CFRelease(mask);
    }
  }
  else
  {
    CGContextAddRect(this, *MEMORY[0x1E4F1DB28]);
    CGContextClip(this);
  }
  if (v7) {
    CFRelease(v7);
  }
}

double SVG::ClipToMask::boundingRect(SVG::ClipToMask *this, SVG::BoundingRectState *a2)
{
  v4.origin.x = SVG::BoundingRectState::deviceRect(a2, *(CGRect *)((char *)this + 72));
  SVG::BoundingRectState::clip(a2, v4);
  return *MEMORY[0x1E4F1DB28];
}

CGFloat SVG::ClipToMask::timeCost(SVG::ClipToMask *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  v8.origin.x = SVG::BoundingRectState::clipRectInPixels(a3);
  v8.origin.y = v3;
  v8.size.width = v4;
  v8.size.height = v5;
  return SVG::ClipToMask::staticTimeCost(&v8, v6);
}

uint64_t SVG::ClipToMask::dump(SVG::ClipToMask *this)
{
  unint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"ClipToMask", 10);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  unint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

void SVG::BoundingRectState::clip(SVG::BoundingRectState *this, CGRect a2)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  unint64_t v7 = *((void *)this + 5) + *((void *)this + 4) - 1;
  unint64_t v8 = *(void *)(*((void *)this + 1) + 8 * (v7 / 0x2E)) + 88 * (v7 % 0x2E);
  if (*(unsigned char *)(v8 + 80)) {
    CGRect v9 = (CGRect *)(v8 + 48);
  }
  else {
    CGRect v9 = (CGRect *)MEMORY[0x1E4F1DB10];
  }
  CGRect v14 = CGRectIntersection(*v9, *(CGRect *)&x);
  unint64_t v10 = *((void *)this + 5) + *((void *)this + 4) - 1;
  unint64_t v11 = *(void *)(*((void *)this + 1) + 8 * (v10 / 0x2E)) + 88 * (v10 % 0x2E);
  *(CGFloat *)(v11 + 48) = v14.origin.x;
  unint64_t v12 = v11 + 48;
  int v13 = *(unsigned __int8 *)(v12 + 32);
  *(CGFloat *)(v12 + 8) = v14.origin.y;
  *(CGFloat *)(v12 + 16) = v14.size.width;
  *(CGFloat *)(v12 + 24) = v14.size.height;
  if (!v13) {
    *(unsigned char *)(v12 + 32) = 1;
  }
}

double SVG::BoundingRectState::clipRectInPixels(SVG::BoundingRectState *this)
{
  v5.origin.CGFloat x = SVG::BoundingRectState::clipRect(this);
  long long v2 = *((_OWORD *)this + 4);
  *(_OWORD *)&v4.a = *((_OWORD *)this + 3);
  *(_OWORD *)&v4.c = v2;
  *(_OWORD *)&v4.tCGFloat x = *((_OWORD *)this + 5);
  *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(v5, &v4);
  return result;
}

CGFloat SVG::ClipToMask::staticTimeCost(CGRect *this, const CGRect *a2)
{
  CGFloat v3 = CGRectGetWidth(*this) * 0.0125;
  return v3 * CGRectGetHeight(*this) + 367.22;
}

void std::__function::__func<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0,std::allocator<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::~__func()
{
}

__n128 std::__function::__func<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0,std::allocator<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::__clone(uint64_t a1)
{
  long long v2 = (char *)operator new(0x28uLL);
  *(void *)long long v2 = &unk_1F1A74D60;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0,std::allocator<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F1A74D60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0,std::allocator<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::operator()(void *a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  memset(v24, 170, 48);
  *(_OWORD *)&v24[48] = unk_1BF1D9E58;
  uint64_t v1 = a1[1];
  uint64_t v2 = a1[2];
  CGFloat v3 = (const SVG::Presentation *)a1[3];
  uint64_t v4 = *(void *)(v2 + 64);
  *(void *)&v24[8] = v2 + 136;
  *(void *)&v24[16] = v3;
  memset(&v24[24], 0, 32);
  *(_DWORD *)&v24[56] = 1065353216;
  memset(v26, 0, sizeof(v26));
  long long v5 = *(_OWORD *)(v4 + 688);
  long long v31 = *(_OWORD *)(v4 + 672);
  *(void *)uint64_t v24 = &unk_1F1A74AE8;
  uint64_t v25 = v1;
  uint64_t v27 = v2 + 176;
  uint64_t v28 = v2 + 216;
  uint64_t v29 = v2 + 256;
  uint64_t v30 = v2 + 296;
  long long v32 = v5;
  unint64_t v6 = a1[4];
  if (v6 == v4)
  {
    long long __p = 0;
    unint64_t v22 = 0;
    uint64_t v23 = 0;
    unint64_t v7 = *(uint64_t **)(v4 + 32);
    unint64_t v8 = *(uint64_t **)(v4 + 40);
    if (v7 != v8)
    {
      unint64_t v10 = 0;
      do
      {
        uint64_t v11 = *v7;
        if (v10 >= v23)
        {
          uint64_t v12 = (v10 - (unsigned char *)__p) >> 3;
          if ((unint64_t)(v12 + 1) >> 61) {
            abort();
          }
          unint64_t v13 = (v23 - (unsigned char *)__p) >> 2;
          if (v13 <= v12 + 1) {
            unint64_t v13 = v12 + 1;
          }
          if ((unint64_t)(v23 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v13;
          }
          if (v14) {
            CGRect v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)&v23, v14);
          }
          else {
            CGRect v15 = 0;
          }
          int64_t v16 = &v15[8 * v12];
          *(void *)int64_t v16 = v11;
          unint64_t v10 = v16 + 8;
          uint64_t v18 = (char *)__p;
          uint64_t v17 = v22;
          if (v22 != __p)
          {
            do
            {
              uint64_t v19 = *((void *)v17 - 1);
              v17 -= 8;
              *((void *)v16 - 1) = v19;
              v16 -= 8;
            }
            while (v17 != v18);
            uint64_t v17 = (char *)__p;
          }
          long long __p = v16;
          unint64_t v22 = v10;
          uint64_t v23 = &v15[8 * v14];
          if (v17) {
            operator delete(v17);
          }
        }
        else
        {
          *(void *)unint64_t v10 = v11;
          v10 += 8;
        }
        unint64_t v22 = v10;
        ++v7;
      }
      while (v7 != v8);
      CGFloat v3 = (const SVG::Presentation *)a1[3];
      uint64_t v4 = *(void *)(a1[2] + 64);
    }
    SVG::Presentation::inherit((SVG::Presentation *)(v4 + 64), v3, v3, v34);
    SVG::RecordBase::operator()((float *)v24, (unint64_t **)&__p, (const SVG::Presentation *)v34);
    if (v44 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A751B8 + v44))(&v33, &v43);
    }
    unsigned int v44 = -1;
    if (v42 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A751D0 + v42))(&v33, &v41);
    }
    unsigned int v42 = -1;
    if (v40 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A751E8 + v40))(&v33, &v39);
    }
    unsigned int v40 = -1;
    if (v38 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A751D0 + v38))(&v33, &v37);
    }
    unsigned int v38 = -1;
    if (v36 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A751E8 + v36))(&v33, &v35);
    }
    if (__p)
    {
      unint64_t v22 = (char *)__p;
      operator delete(__p);
    }
  }
  else
  {
    SVG::RecordBase::operator()((float *)v24, v6, v3);
  }
  *(void *)uint64_t v24 = &unk_1F1A74AE8;
  std::deque<SVG::ApplyPresentationState>::~deque[abi:nn180100](v26);
  *(void *)uint64_t v24 = &unk_1F1A74330;
  return std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)&v24[24]);
}

uint64_t std::__function::__func<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0,std::allocator<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0,std::allocator<SVG::GlyphRecordingCreateWithElement(SVG::Document const&,SVG::Element const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::target_type()
{
}

uint64_t std::deque<SVG::ApplyPresentationState>::~deque[abi:nn180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  CGFloat v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      CGFloat v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 128;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 256;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    unint64_t v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<SVG::ApplyPresentationState *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<SVG::ApplyPresentationState *>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

BOOL std::type_info::operator==[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void *std::__function::__value_func<void ()(SVG::ApplyPresentationState const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void SVG::AffineTransformApplier::~AffineTransformApplier(SVG::AffineTransformApplier *this)
{
  if (!*((unsigned char *)this + 80))
  {
    if (*((unsigned char *)this + 72))
    {
      uint64_t v2 = *(void *)this;
      long long v3 = *(_OWORD *)((char *)this + 24);
      long long v4 = *(_OWORD *)((char *)this + 40);
      long long v5 = *(_OWORD *)((char *)this + 56);
      uint64_t v6 = &unk_1F1A74C88;
      long long v7 = v3;
      long long v8 = v4;
      long long v9 = v5;
      unsigned int v10 = 2;
      SVG::Recorder::append(v2, (uint64_t)&v6);
      if (v10 != -1) {
        ((void (*)(char *, void **))*(&off_1F1A75148 + v10))(&v11, &v6);
      }
    }
  }
  SVG::StateSaverRestorer::~StateSaverRestorer((SVG::AffineTransformApplier *)((char *)this + 8));
}

void SVG::StateSaverRestorer::~StateSaverRestorer(SVG::StateSaverRestorer *this)
{
  if (*((unsigned char *)this + 8))
  {
    uint64_t v1 = *(void *)this;
    v2[0] = &unk_1F1A74620;
    unsigned int v3 = 1;
    SVG::Recorder::append(v1, (uint64_t)v2);
    if (v3 != -1) {
      ((void (*)(char *, void *))*(&off_1F1A75148 + v3))(&v4, v2);
    }
  }
}

void SVG::RestoreState::~RestoreState(SVG::RestoreState *this)
{
}

void SVG::RestoreState::execute(int a1, CGContextRef c)
{
}

double SVG::RestoreState::boundingRect(SVG::RestoreState *this, SVG::BoundingRectState *a2)
{
  return *MEMORY[0x1E4F1DB28];
}

double SVG::RestoreState::timeCost(SVG::RestoreState *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  return 0.531666877;
}

uint64_t SVG::RestoreState::dump(SVG::RestoreState *this)
{
  uint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"RestoreState", 12);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  uint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

uint64_t std::deque<SVG::BoundingRectState::State>::__maybe_remove_back_spare[abi:nn180100](void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 46 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x2E) {
    a2 = 1;
  }
  if (v5 < 0x5C) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void std::__shared_ptr_pointer<SVG::GlyphRecording *,std::shared_ptr<SVG::GlyphRecording>::__shared_ptr_default_delete<SVG::GlyphRecording,SVG::GlyphRecording>,std::allocator<SVG::GlyphRecording>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C18A3E80);
}

uint64_t std::__shared_ptr_pointer<SVG::GlyphRecording *,std::shared_ptr<SVG::GlyphRecording>::__shared_ptr_default_delete<SVG::GlyphRecording,SVG::GlyphRecording>,std::allocator<SVG::GlyphRecording>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    uint64_t v2 = *(void ***)(result + 24);
    std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__destroy_vector::operator()[abi:nn180100](&v2);
    return MEMORY[0x1C18A3E80](v1, 0x1020C402710001DLL);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<SVG::GlyphRecording *,std::shared_ptr<SVG::GlyphRecording>::__shared_ptr_default_delete<SVG::GlyphRecording,SVG::GlyphRecording>,std::allocator<SVG::GlyphRecording>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__clear[abi:nn180100](void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  if (v3 != *result)
  {
    do
    {
      uint64_t v4 = v3 - 128;
      uint64_t v5 = *(unsigned int *)(v3 - 8);
      if (v5 != -1) {
        __n128 result = (void *)((uint64_t (*)(char *, uint64_t))*(&off_1F1A75148 + v5))(&v6, v3 - 128);
      }
      *(_DWORD *)(v3 - 8) = -1;
      v3 -= 128;
    }
    while (v4 != v2);
  }
  v1[1] = v2;
  return result;
}

void std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__clear[abi:nn180100](v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

uint64_t std::deque<SVG::BoundingRectState::State>::~deque[abi:nn180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 23;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 46;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    int v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<SVG::ApplyPresentationState *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::deque<SVG::Recorder::State>::~deque[abi:nn180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    unint64_t v4 = a1 + 5;
    uint64_t v3 = (void **)a1[1];
  }
  else
  {
    unint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 5];
    int v7 = *v6;
    long long v8 = (char *)*v6 + 128 * (v5 & 0x1F);
    uint64_t v9 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 2) & 0x3FFFFFFFFFFFFFF8)) + 128 * ((a1[5] + v5) & 0x1F);
    if (v8 != (char *)v9)
    {
      do
      {
        uint64_t v10 = *((unsigned int *)v8 + 28);
        if (v10 != -1)
        {
          ((void (*)(char *, char *))*(&off_1F1A75130 + v10))(&v17, v8 + 8);
          int v7 = *v6;
        }
        *((_DWORD *)v8 + 28) = -1;
        v8 += 128;
        if (v8 - v7 == 4096)
        {
          char v11 = (char *)v6[1];
          ++v6;
          int v7 = v11;
          long long v8 = v11;
        }
      }
      while (v8 != (char *)v9);
      uint64_t v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
  }
  *unint64_t v4 = 0;
  unint64_t v12 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v12 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v13 = v12 >> 3;
  if (v13 == 1)
  {
    uint64_t v14 = 16;
  }
  else
  {
    if (v13 != 2) {
      goto LABEL_18;
    }
    uint64_t v14 = 32;
  }
  a1[4] = v14;
LABEL_18:
  while (v2 != v3)
  {
    CGRect v15 = *v2++;
    operator delete(v15);
  }
  return std::__split_buffer<SVG::ApplyPresentationState *>::~__split_buffer((uint64_t)a1);
}

void *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  v13[0] = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = 0xAAAAAAAAAAAAAAAALL;
  MEMORY[0x1C18A3D50](v13, a1);
  if (LOBYTE(v13[0]))
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    uint64_t v8 = a2 + a3;
    if ((*(_DWORD *)(v6 + 8) & 0xB0) == 0x20) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = a2;
    }
    int v10 = *(_DWORD *)(v6 + 144);
    if (v10 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      char v11 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
      int v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v10;
    }
    if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v7, a2, v9, v8, v6, (char)v10)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1C18A3D60](v13);
  return a1;
}

uint64_t std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      memset(__p, 170, sizeof(__p));
      std::string::basic_string[abi:nn180100](__p, v12, __c);
      unint64_t v13 = SHIBYTE(__p[2]) >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void *std::string::basic_string[abi:nn180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

uint64_t std::stringbuf::str[abi:nn180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = std::stringbuf::view[abi:nn180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  unint64_t v5 = (const void *)result;
  size_t v6 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((unsigned char *)a2 + 23) = v4;
    if (!v4) {
      goto LABEL_9;
    }
  }
  uint64_t result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((unsigned char *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:nn180100](uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    unint64_t v3 = *(void *)(a1 + 48);
    if (*(void *)(a1 + 88) < v3) {
      *(void *)(a1 + 88) = v3;
    }
    return *(void *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(void *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>(void *a1, uint64_t a2)
{
  uint64_t v2 = (unsigned __int8 *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v5 = v4;
  }
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v17, (uint64_t *)a2, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (!*(void *)&v7) {
    return 0;
  }
  unint64_t v8 = v6;
  uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
  v9.i16[0] = vaddlv_u8(v9);
  unint64_t v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    unint64_t v11 = v6;
    if (v6 >= *(void *)&v7) {
      unint64_t v11 = v6 % *(void *)&v7;
    }
  }
  else
  {
    unint64_t v11 = (*(void *)&v7 - 1) & v6;
  }
  int64_t v12 = *(unsigned __int8 ***)(*a1 + 8 * v11);
  if (!v12) {
    return 0;
  }
  unint64_t v13 = *v12;
  if (*v12)
  {
    uint64_t v14 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v15 = *((void *)v13 + 1);
      if (v15 == v8)
      {
        if (std::equal_to<std::string>::operator()[abi:nn180100](v14, v13 + 16, v2)) {
          return v13;
        }
      }
      else
      {
        if (v10 > 1)
        {
          if (v15 >= *(void *)&v7) {
            v15 %= *(void *)&v7;
          }
        }
        else
        {
          v15 &= *(void *)&v7 - 1;
        }
        if (v15 != v11) {
          return 0;
        }
      }
      unint64_t v13 = *(unsigned __int8 **)v13;
    }
    while (v13);
  }
  return v13;
}

{
  unsigned __int8 *v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int8x8_t v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 **v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unint64_t v15;
  char v17;

  uint64_t v2 = (unsigned __int8 *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v5 = v4;
  }
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v17, (uint64_t *)a2, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (!*(void *)&v7) {
    return 0;
  }
  unint64_t v8 = v6;
  uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
  v9.i16[0] = vaddlv_u8(v9);
  unint64_t v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    unint64_t v11 = v6;
    if (v6 >= *(void *)&v7) {
      unint64_t v11 = v6 % *(void *)&v7;
    }
  }
  else
  {
    unint64_t v11 = (*(void *)&v7 - 1) & v6;
  }
  int64_t v12 = *(unsigned __int8 ***)(*a1 + 8 * v11);
  if (!v12) {
    return 0;
  }
  unint64_t v13 = *v12;
  if (*v12)
  {
    uint64_t v14 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v15 = *((void *)v13 + 1);
      if (v8 == v15)
      {
        if (std::equal_to<std::string>::operator()[abi:nn180100](v14, v13 + 16, v2)) {
          return v13;
        }
      }
      else
      {
        if (v10 > 1)
        {
          if (v15 >= *(void *)&v7) {
            v15 %= *(void *)&v7;
          }
        }
        else
        {
          v15 &= *(void *)&v7 - 1;
        }
        if (v15 != v11) {
          return 0;
        }
      }
      unint64_t v13 = *(unsigned __int8 **)v13;
    }
    while (v13);
  }
  return v13;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      uint64_t v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      uint64_t v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      uint64_t v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      uint64_t v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      uint64_t v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      uint64_t v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      unint64_t v11 = v7 + v9;
      unint64_t v12 = 0x9DDFEA08EB382D69
          * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))));
      unint64_t v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      unint64_t v14 = v4 + v7 + v8 + a3;
      uint64_t v15 = v14 + v5;
      unint64_t v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v8 + a3 + v5 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 21);
      uint64_t v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      uint64_t v18 = v6 + v9 + v17;
      uint64_t v19 = __ROR8__(v18, 44);
      uint64_t v20 = v18 + v10;
      uint64_t v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      uint64_t v23 = *a2;
      unint64_t v22 = a2 + 4;
      unint64_t v24 = v23 - 0x4B6D499041670D8DLL * v5;
      uint64_t v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        uint64_t v26 = *(v22 - 3);
        uint64_t v27 = v24 + v15 + v11 + v26;
        uint64_t v28 = v22[2];
        uint64_t v29 = v22[3];
        uint64_t v30 = v22[1];
        unint64_t v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        uint64_t v31 = v13 + v20;
        uint64_t v32 = *(v22 - 2);
        uint64_t v33 = *(v22 - 1);
        uint64_t v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        uint64_t v35 = v34 + v20 + v33;
        uint64_t v36 = v34 + v26 + v32;
        uint64_t v15 = v36 + v33;
        uint64_t v37 = __ROR8__(v36, 44) + v34;
        unint64_t v38 = (0xB492B66FBE98F273 * __ROR8__(v27, 37)) ^ v21;
        unint64_t v24 = 0xB492B66FBE98F273 * __ROR8__(v31, 33);
        unint64_t v16 = v37 + __ROR8__(v35 + v38, 21);
        unint64_t v39 = v24 + v21 + *v22;
        uint64_t v20 = v30 + v28 + v39 + v29;
        uint64_t v21 = __ROR8__(v30 + v28 + v39, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        unint64_t v13 = v38;
        v25 += 64;
      }
      while (v25);
      unint64_t v40 = v24
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) >> 47));
      unint64_t v41 = 0x9DDFEA08EB382D69
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69 * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }
    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100](a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](a2, a3);
  }
  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100](a2, a3);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100](_DWORD *a1, unint64_t a2)
{
  if (a2 < 9)
  {
    if (a2 < 4)
    {
      unint64_t result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        unint64_t v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      uint64_t v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    uint64_t v3 = *(void *)((char *)a1 + a2 - 8);
    uint64_t v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  unint64_t v3 = 0xB492B66FBE98F273 * *a1;
  uint64_t v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  unint64_t v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8);
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((v4 - 0x3C5A37A36834CED9 * *(void *)((char *)a1 + a2 - 16)) ^ v5);
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100](void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)((char *)a1 + a2 - 16);
  uint64_t v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  uint64_t v5 = a1[2];
  uint64_t v4 = a1[3];
  uint64_t v6 = __ROR8__(v3 + v4, 52);
  uint64_t v7 = v3 + a1[1];
  uint64_t v8 = __ROR8__(v7, 7);
  uint64_t v9 = v7 + v5;
  uint64_t v10 = *(void *)((char *)a1 + a2 - 32) + v5;
  uint64_t v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  uint64_t v12 = *(void *)((char *)a1 + a2 - 24) + v10 + v2;
  unint64_t v13 = 0xC3A5C85C97CB3127 * (v12 + *(void *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(void *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(void *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

uint64_t std::equal_to<std::string>::operator()[abi:nn180100](uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = a2[23];
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = a2[23];
  }
  else {
    uint64_t v5 = *((void *)a2 + 1);
  }
  uint64_t v6 = a3[23];
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *((void *)a3 + 1);
  }
  if (v5 != v6) {
    return 0;
  }
  if (v7 < 0) {
    uint64_t v3 = *(unsigned __int8 **)a3;
  }
  if ((v4 & 0x80) != 0) {
    return memcmp(*(const void **)a2, v3, *((void *)a2 + 1)) == 0;
  }
  if (!a2[23]) {
    return 1;
  }
  uint64_t v8 = v4 - 1;
  do
  {
    int v10 = *a2++;
    int v9 = v10;
    int v12 = *v3++;
    int v11 = v12;
    BOOL v14 = v8-- != 0;
    uint64_t result = v9 == v11;
  }
  while (v9 == v11 && v14);
  return result;
}

void SVG::unzipData(SVG *this@<X0>, void *a2@<X8>)
{
  BytePtr = CFDataGetBytePtr(this);
  CFIndex Length = CFDataGetLength(this);
  if (Length < 10 || *BytePtr != 31 || BytePtr[1] != 139 || BytePtr[2] != 8) {
    goto LABEL_25;
  }
  if ((BytePtr[3] & 4) != 0)
  {
    if ((unint64_t)Length > 0xB)
    {
      uint64_t v7 = *((unsigned __int16 *)BytePtr + 5) + 12;
      if ((BytePtr[3] & 8) == 0) {
        goto LABEL_14;
      }
      goto LABEL_10;
    }
LABEL_25:
    *a2 = 0;
    return;
  }
  uint64_t v7 = 10;
  if ((BytePtr[3] & 8) == 0) {
    goto LABEL_14;
  }
LABEL_10:
  if (Length > (unint64_t)v7)
  {
    while (BytePtr[v7++])
    {
      if (Length == v7)
      {
LABEL_18:
        uint64_t v7 = Length;
        goto LABEL_19;
      }
    }
  }
LABEL_14:
  if ((BytePtr[3] & 0x10) != 0 && Length > v7)
  {
    while (BytePtr[v7++])
    {
      if (Length == v7) {
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  if ((BytePtr[3] & 2) != 0) {
    uint64_t v10 = v7 + 2;
  }
  else {
    uint64_t v10 = v7;
  }
  int64_t v11 = Length - v10;
  if (Length <= v10) {
    goto LABEL_25;
  }
  size_t v12 = (unint64_t)((double)v11 * 1.5);
  unint64_t v13 = (uint8_t *)malloc_type_malloc(v12, 0xFDA97EBFuLL);
  v19.state = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v19.dst_ptr = v14;
  *(_OWORD *)&v19.src_ptr = v14;
  if (compression_stream_init(&v19, COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB))
  {
    uint64_t v15 = 0;
  }
  else
  {
    CFIndex v16 = 0;
    v19.dst_ptr = v13;
    v19.dst_std::string::size_type size = (unint64_t)((double)v11 * 1.5);
    v19.src_ptr = &BytePtr[v10];
    v19.src_std::string::size_type size = v11;
    uint64_t v17 = v13;
    while (1)
    {
      compression_status v18 = compression_stream_process(&v19, 1);
      v16 += v19.dst_ptr - v13;
      if (v18) {
        break;
      }
      size_t v12 = (unint64_t)((double)v12 * 1.5 + 1.0);
      uint64_t v15 = (char *)reallocf(v17, v12);
      if (!v15) {
        goto LABEL_33;
      }
      uint64_t v17 = v15;
      unint64_t v13 = (uint8_t *)&v15[v16];
      v19.dst_ptr = (uint8_t *)&v15[v16];
      v19.dst_std::string::size_type size = v12 - v16;
    }
    if (v18 == COMPRESSION_STATUS_END)
    {
      if (compression_stream_destroy(&v19) == COMPRESSION_STATUS_OK)
      {
        uint64_t v15 = (char *)CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v17, v16, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
LABEL_33:
        unint64_t v13 = 0;
        goto LABEL_36;
      }
    }
    else
    {
      compression_stream_destroy(&v19);
    }
    uint64_t v15 = 0;
    unint64_t v13 = (uint8_t *)v17;
  }
LABEL_36:
  *a2 = v15;
  free(v13);
}

double SVG::Length::computeValue(SVG::Length *this, double a2)
{
  double v7 = a2;
  uint64_t v6 = &v7;
  uint64_t v2 = *((unsigned int *)this + 2);
  if (v2 == -1)
  {
    uint64_t v4 = std::__throw_bad_variant_access[abi:nn180100]();
    return std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Length::computeValue(double)::$_0,SVG::Length::computeValue(double)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SVG::Length::Value,SVG::Length::Percentage> const&>(v4, v5);
  }
  else
  {
    uint64_t v8 = &v6;
    ((void (*)(double ***, SVG::Length *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100INS1_9__variant15__value_visitorIN3SVG7VisitorIZNKS6_6Length12computeValueEdE3__0JZNKS8_12computeValueEdE3__1EEEEEJRKNS0_6__implIJNS8_5ValueENS8_10PercentageEEEEEEEDcOT_DpOT0____fmatrix[v2])(&v8, this);
  }
  return result;
}

double std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Length::computeValue(double)::$_0,SVG::Length::computeValue(double)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SVG::Length::Value,SVG::Length::Percentage> const&>(uint64_t a1, uint64_t a2)
{
  return *(double *)a2;
}

double std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Length::computeValue(double)::$_0,SVG::Length::computeValue(double)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SVG::Length::Value,SVG::Length::Percentage> const&>(double ***a1, double *a2)
{
  return *a2 * ***a1 / 100.0;
}

uint64_t SVG::PatternElement::PatternElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)a1 = &unk_1F1A74728;
  *(unsigned char *)(a1 + 640) = 0;
  *(unsigned char *)(a1 + 672) = 0;
  *(unsigned char *)(a1 + 680) = 0;
  *(unsigned char *)(a1 + 688) = 0;
  *(unsigned char *)(a1 + 696) = 0;
  *(unsigned char *)(a1 + 712) = 0;
  *(unsigned char *)(a1 + 720) = 0;
  *(unsigned char *)(a1 + 736) = 0;
  *(unsigned char *)(a1 + 744) = 0;
  *(unsigned char *)(a1 + 760) = 0;
  *(unsigned char *)(a1 + 768) = 0;
  *(unsigned char *)(a1 + 784) = 0;
  *(unsigned char *)(a1 + 792) = 0;
  *(unsigned char *)(a1 + 796) = 0;
  *(unsigned char *)(a1 + 800) = 0;
  *(unsigned char *)(a1 + 804) = 0;
  *(unsigned char *)(a1 + 808) = 0;
  *(unsigned char *)(a1 + 856) = 0;
  *(void *)(a1 + 864) = 0;
  std::string::basic_string[abi:nn180100]<0>(v38, "viewBox");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v6)
  {
    *(void *)&long long v7 = -1;
    *((void *)&v7 + 1) = -1;
    *(_OWORD *)unint64_t v38 = v7;
    long long v39 = v7;
    *(void *)&long long v40 = 0xAAAAAAAAAAAAAAAALL;
    SVG::ViewBox::parseViewBox((uint64_t)(v6 + 64), (uint64_t)v38);
    if ((_BYTE)v40)
    {
      int v8 = *(unsigned __int8 *)(a1 + 672);
      long long v9 = v39;
      *(_OWORD *)(a1 + 640) = *(_OWORD *)v38;
      *(_OWORD *)(a1 + 656) = v9;
      if (!v8) {
        *(unsigned char *)(a1 + 672) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v38, "preserveAspectRatio");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v10 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v10)
  {
    unint64_t v11 = SVG::PreserveAspectRatio::parsePreserveAspectRatio((uint64_t)(v10 + 64));
    if (v12)
    {
      if (!*(unsigned char *)(a1 + 688)) {
        *(unsigned char *)(a1 + 688) = 1;
      }
      *(void *)(a1 + 680) = v11;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v38, "x");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  unint64_t v13 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v13)
  {
    v38[0] = (void *)-1;
    v38[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v13 + 64), (uint64_t)v38);
    if ((_BYTE)v39)
    {
      int v14 = *(unsigned __int8 *)(a1 + 712);
      *(_OWORD *)(a1 + 696) = *(_OWORD *)v38;
      if (!v14) {
        *(unsigned char *)(a1 + 712) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v38, "y");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v15 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v15)
  {
    v38[0] = (void *)-1;
    v38[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v15 + 64), (uint64_t)v38);
    if ((_BYTE)v39)
    {
      int v16 = *(unsigned __int8 *)(a1 + 736);
      *(_OWORD *)(a1 + 720) = *(_OWORD *)v38;
      if (!v16) {
        *(unsigned char *)(a1 + 736) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v38, "width");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v17 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v17)
  {
    v38[0] = (void *)-1;
    v38[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v17 + 64), (uint64_t)v38);
    if ((_BYTE)v39)
    {
      int v18 = *(unsigned __int8 *)(a1 + 760);
      *(_OWORD *)(a1 + 744) = *(_OWORD *)v38;
      if (!v18) {
        *(unsigned char *)(a1 + 760) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v38, "height");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  compression_stream v19 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v19)
  {
    v38[0] = (void *)-1;
    v38[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v19 + 64), (uint64_t)v38);
    if ((_BYTE)v39)
    {
      int v20 = *(unsigned __int8 *)(a1 + 784);
      *(_OWORD *)(a1 + 768) = *(_OWORD *)v38;
      if (!v20) {
        *(unsigned char *)(a1 + 784) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v38, "patternUnits");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v21 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v21)
  {
    uint64_t v22 = SVG::parseUnits((uint64_t)(v21 + 64));
    if ((v22 & 0xFF00000000) != 0)
    {
      *(_DWORD *)(a1 + 792) = v22;
      *(unsigned char *)(a1 + 796) = 1;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v38, "patternContentUnits");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v23 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v23)
  {
    uint64_t v24 = SVG::parseUnits((uint64_t)(v23 + 64));
    if ((v24 & 0xFF00000000) != 0)
    {
      *(_DWORD *)(a1 + 800) = v24;
      *(unsigned char *)(a1 + 804) = 1;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v38, "patternTransform");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v25 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v25)
  {
    *(void *)&long long v26 = -1;
    *((void *)&v26 + 1) = -1;
    long long v39 = v26;
    long long v40 = v26;
    *(_OWORD *)unint64_t v38 = v26;
    unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
    SVG::parseTransform((uint64_t)(v25 + 64), (uint64_t)v38);
    if ((_BYTE)v41)
    {
      int v27 = *(unsigned __int8 *)(a1 + 856);
      long long v28 = v39;
      *(_OWORD *)(a1 + 808) = *(_OWORD *)v38;
      *(_OWORD *)(a1 + 824) = v28;
      *(_OWORD *)(a1 + 840) = v40;
      if (!v27) {
        *(unsigned char *)(a1 + 856) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v38, "href");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/1999/xlink");
  uint64_t v29 = SVG::Element::findInAttributeMap(a3, (uint64_t)v38, (uint64_t)__p);
  if (v43 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v39) < 0) {
    operator delete(v38[0]);
  }
  if (v29)
  {
    CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if ((char)v29[87] < 0)
    {
      uint64_t v31 = (const UInt8 *)*((void *)v29 + 8);
      CFIndex v32 = *((void *)v29 + 9);
    }
    else
    {
      uint64_t v31 = v29 + 64;
      CFIndex v32 = v29[87];
    }
    CFStringRef v33 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v31, v32, 0x8000100u, 1u);
    if (v33)
    {
      CFStringRef v34 = v33;
      CFURLRef v35 = CFURLCreateWithString(v30, v33, 0);
      uint64_t v36 = *(const void **)(a1 + 864);
      if (v36) {
        CFRelease(v36);
      }
      *(void *)(a1 + 864) = v35;
      CFRelease(v34);
    }
  }
  return a1;
}

uint64_t SVG::PatternElement::appendChild(int64x2_t *a1, const void **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)*a2;
  {
    uint64_t v6 = *a2;
    if (!*a2
    {
      return 0;
    }
  }
  return SVG::Element::appendChild(a1, (uint64_t *)a2);
}

void SVG::PatternElement::computePlaybackRect(unint64_t a1, void *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  SVG::PatternElement::specifiedState(a1, a2, (uint64_t)v10);
  int v16 = v15;
  long long v17 = v11;
  long long v18 = v12;
  long long v19 = v13;
  long long v20 = v14;
  v21.origin.CGFloat x = a3;
  v21.origin.CGFloat y = a4;
  v21.size.CGFloat width = a5;
  v21.size.CGFloat height = a6;
  SVG::LengthRect::computeRect((SVG::LengthRect *)&v16, v21);
}

__n128 SVG::PatternElement::specifiedState@<Q0>(unint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 160) = xmmword_1BF1DA1E0;
  *(_OWORD *)(a3 + 176) = unk_1BF1DA1F0;
  *(_OWORD *)(a3 + 192) = xmmword_1BF1DA200;
  *(_OWORD *)(a3 + 208) = unk_1BF1DA210;
  *(_OWORD *)(a3 + 96) = xmmword_1BF1DA1A0;
  *(_OWORD *)(a3 + 112) = unk_1BF1DA1B0;
  *(_OWORD *)(a3 + 128) = xmmword_1BF1DA1C0;
  *(_OWORD *)(a3 + 144) = unk_1BF1DA1D0;
  *(_OWORD *)(a3 + 32) = xmmword_1BF1DA160;
  *(_OWORD *)(a3 + 48) = unk_1BF1DA170;
  *(_OWORD *)(a3 + 64) = xmmword_1BF1DA180;
  *(_OWORD *)(a3 + 80) = unk_1BF1DA190;
  *(_OWORD *)a3 = __const__ZNK3SVG14PatternElement17contentsTransformE6CGRectS1_RKNSt3__113unordered_mapIPK7__CFURLNS2_17reference_wrapperIKNS_7ElementEEENS2_4hashIS6_EENS2_8equal_toIS6_EENS2_9allocatorINS2_4pairIKS6_SA_EEEEEE_specifiedState;
  *(_OWORD *)(a3 + 16) = unk_1BF1DA150;
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + 40) = 0;
  uint64_t v4 = a3 + 40;
  *(unsigned char *)(a3 + 56) = 0;
  uint64_t v5 = a3 + 56;
  *(unsigned char *)(a3 + 48) = 0;
  *(unsigned char *)(a3 + 72) = 0;
  *(unsigned char *)(a3 + 80) = 0;
  *(unsigned char *)(a3 + 104) = 0;
  uint64_t v6 = a3 + 104;
  *(unsigned char *)(a3 + 96) = 0;
  *(unsigned char *)(a3 + 120) = 0;
  *(unsigned char *)(a3 + 128) = 0;
  *(unsigned char *)(a3 + 152) = 0;
  uint64_t v7 = a3 + 152;
  *(unsigned char *)(a3 + 144) = 0;
  *(unsigned char *)(a3 + 156) = 0;
  *(unsigned char *)(a3 + 160) = 0;
  *(unsigned char *)(a3 + 168) = 0;
  uint64_t v8 = a3 + 168;
  *(unsigned char *)(a3 + 164) = 0;
  *(unsigned char *)(a3 + 216) = 0;
  memset(v25, 170, sizeof(v25));
  SVG::hrefChain<SVG::PatternElement>(a1, a2, v25);
  uint64_t v10 = (char *)v25[0];
  long long v11 = (char *)v25[1];
  if (v25[1] == v25[0]) {
    goto LABEL_31;
  }
  do
  {
    long long v13 = (__n128 *)*((void *)v11 - 1);
    v11 -= 8;
    long long v12 = v13;
    *(__n128 *)uint64_t v24 = v13[50];
    *(__n128 *)&v24[16] = v13[51];
    *(__n128 *)&v24[32] = v13[52];
    *(__n128 *)&v24[48] = v13[53];
    *(__n128 *)CGRect v21 = v13[46];
    *(__n128 *)&v21[16] = v13[47];
    __n128 v22 = v13[48];
    __n128 v23 = v13[49];
    __n128 v18 = v13[42];
    *(__n128 *)long long v19 = v13[43];
    *(__n128 *)&v19[16] = v13[44];
    __n128 v20 = v13[45];
    __n128 v16 = v13[40];
    __n128 v17 = v13[41];
    if (!v13[42].n128_u8[0] && *(unsigned char *)(a3 + 32))
    {
      __n128 v16 = *(__n128 *)a3;
      __n128 v17 = *(__n128 *)(a3 + 16);
      v18.n128_u8[0] = *(unsigned char *)(a3 + 32);
    }
    if (!v12[43].n128_u8[0] && *(unsigned char *)(a3 + 48))
    {
      v18.n128_u64[1] = *(void *)v4;
      v19[0] = *(unsigned char *)(v4 + 8);
    }
    if (!v12[44].n128_u8[8] && *(unsigned char *)(a3 + 72))
    {
      *(_OWORD *)&v19[8] = *(_OWORD *)v5;
      v19[24] = *(unsigned char *)(v5 + 16);
    }
    if (!v12[46].n128_u8[0] && *(unsigned char *)(a3 + 96))
    {
      __n128 v20 = *(__n128 *)(a3 + 80);
      v21[0] = *(unsigned char *)(a3 + 96);
    }
    if (!v12[47].n128_u8[8] && *(unsigned char *)(a3 + 120))
    {
      *(_OWORD *)&v21[8] = *(_OWORD *)v6;
      v21[24] = *(unsigned char *)(v6 + 16);
    }
    if (!v12[49].n128_u8[0] && *(unsigned char *)(a3 + 144))
    {
      __n128 v22 = *(__n128 *)(a3 + 128);
      v23.n128_u8[0] = *(unsigned char *)(a3 + 144);
    }
    if (!v12[49].n128_u8[12] && *(unsigned char *)(a3 + 156))
    {
      v23.n128_u32[2] = *(_DWORD *)v7;
      v23.n128_u8[12] = *(unsigned char *)(v7 + 4);
    }
    if (!v12[50].n128_u8[4] && *(unsigned char *)(a3 + 164))
    {
      *(_DWORD *)uint64_t v24 = *(_DWORD *)(a3 + 160);
      v24[4] = *(unsigned char *)(a3 + 164);
    }
    if (!v12[53].n128_u8[8] && *(unsigned char *)(a3 + 216))
    {
      *(_OWORD *)&v24[8] = *(_OWORD *)v8;
      *(_OWORD *)&v24[24] = *(_OWORD *)(v8 + 16);
      *(_OWORD *)&v24[40] = *(_OWORD *)(v8 + 32);
      v24[56] = *(unsigned char *)(v8 + 48);
    }
    *(_OWORD *)(a3 + 160) = *(_OWORD *)v24;
    *(_OWORD *)(a3 + 176) = *(_OWORD *)&v24[16];
    *(_OWORD *)(a3 + 192) = *(_OWORD *)&v24[32];
    *(_OWORD *)(a3 + 208) = *(_OWORD *)&v24[48];
    *(_OWORD *)(a3 + 96) = *(_OWORD *)v21;
    *(_OWORD *)(a3 + 112) = *(_OWORD *)&v21[16];
    *(__n128 *)(a3 + 128) = v22;
    *(__n128 *)(a3 + 144) = v23;
    *(__n128 *)(a3 + 32) = v18;
    *(_OWORD *)(a3 + 48) = *(_OWORD *)v19;
    *(_OWORD *)(a3 + 64) = *(_OWORD *)&v19[16];
    *(__n128 *)(a3 + 80) = v20;
    __n128 result = v16;
    *(__n128 *)a3 = v16;
    *(__n128 *)(a3 + 16) = v17;
  }
  while (v11 != v10);
  if (!*(unsigned char *)(a3 + 48))
  {
LABEL_31:
    *(unsigned char *)(a3 + 48) = 1;
    *(void *)(a3 + 40) = 5;
  }
  if (!*(unsigned char *)(a3 + 72))
  {
    *(void *)(a3 + 56) = 0;
    *(_DWORD *)(a3 + 64) = 0;
    *(unsigned char *)(a3 + 72) = 1;
  }
  if (!*(unsigned char *)(a3 + 96))
  {
    *(void *)(a3 + 80) = 0;
    *(_DWORD *)(a3 + 88) = 0;
    *(unsigned char *)(a3 + 96) = 1;
  }
  if (!*(unsigned char *)(a3 + 120))
  {
    *(void *)(a3 + 104) = 0;
    *(_DWORD *)(a3 + 112) = 0;
    *(unsigned char *)(a3 + 120) = 1;
  }
  if (!*(unsigned char *)(a3 + 144))
  {
    *(void *)(a3 + 128) = 0;
    *(_DWORD *)(a3 + 136) = 0;
    *(unsigned char *)(a3 + 144) = 1;
  }
  if (!*(unsigned char *)(a3 + 156))
  {
    *(_DWORD *)(a3 + 152) = 1;
    *(unsigned char *)(a3 + 156) = 1;
  }
  if (!*(unsigned char *)(a3 + 164))
  {
    *(_DWORD *)(a3 + 160) = 0;
    *(unsigned char *)(a3 + 164) = 1;
  }
  if (*(unsigned char *)(a3 + 216))
  {
    if (!v10) {
      return result;
    }
  }
  else
  {
    long long v14 = (__n128 *)MEMORY[0x1E4F1DAB8];
    long long v15 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *(_OWORD *)uint64_t v8 = *MEMORY[0x1E4F1DAB8];
    *(_OWORD *)(v8 + 16) = v15;
    __n128 result = v14[2];
    *(__n128 *)(v8 + 32) = result;
    *(unsigned char *)(a3 + 216) = 1;
    if (!v10) {
      return result;
    }
  }
  v25[1] = v10;
  operator delete(v10);
  return result;
}

void SVG::PatternElement::computeRecordingRect(unint64_t a1, void *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  SVG::PatternElement::specifiedState(a1, a2, (uint64_t)v10);
  int v16 = v15;
  long long v17 = v11;
  long long v18 = v12;
  long long v19 = v13;
  long long v20 = v14;
  v21.origin.CGFloat x = a3;
  v21.origin.CGFloat y = a4;
  v21.size.CGFloat width = a5;
  v21.size.CGFloat height = a6;
  SVG::LengthRect::computePatternRecordingRect((SVG::LengthRect *)&v16, v21);
}

CGAffineTransform *SVG::PatternElement::contentsTransform@<X0>(unint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>, CGFloat a4@<D0>, CGFloat a5@<D1>, CGFloat a6@<D2>, CGFloat a7@<D3>, double a8@<D4>, double a9@<D5>, double a10@<D6>, double a11@<D7>)
{
  long long v34 = xmmword_1BF1DA1E0;
  long long v35 = unk_1BF1DA1F0;
  long long v36 = xmmword_1BF1DA200;
  long long v37 = unk_1BF1DA210;
  long long v30 = xmmword_1BF1DA1A0;
  long long v31 = unk_1BF1DA1B0;
  long long v32 = xmmword_1BF1DA1C0;
  long long v33 = unk_1BF1DA1D0;
  long long v26 = xmmword_1BF1DA160;
  long long v27 = unk_1BF1DA170;
  long long v28 = xmmword_1BF1DA180;
  long long v29 = unk_1BF1DA190;
  long long v24 = __const__ZNK3SVG14PatternElement17contentsTransformE6CGRectS1_RKNSt3__113unordered_mapIPK7__CFURLNS2_17reference_wrapperIKNS_7ElementEEENS2_4hashIS6_EENS2_8equal_toIS6_EENS2_9allocatorINS2_4pairIKS6_SA_EEEEEE_specifiedState;
  long long v25 = unk_1BF1DA150;
  SVG::PatternElement::specifiedState(a1, a2, (uint64_t)&v24);
  if ((_BYTE)v26)
  {
    long long v20 = v24;
    long long v21 = v25;
    __n128 v22 = (CGAffineTransform *)*((void *)&v26 + 1);
    return SVG::computeViewBoxTransform(v22, a3, *(CGFloat *)&v20, *((CGFloat *)&v20 + 1), *(CGFloat *)&v21, *((CGFloat *)&v21 + 1), a8, a9, a10, a11);
  }
  else
  {
    __n128 result = SVG::unitTransform((CGAffineTransform *)v34, a3, a4, a5, a6, a7);
    *(unsigned char *)(a3 + 48) = 1;
  }
  return result;
}

uint64_t SVG::hrefChain<SVG::PatternElement>@<X0>(unint64_t a1@<X0>, void *a2@<X1>, void **a3@<X8>)
{
  uint64_t v6 = (char *)operator new(8uLL);
  a3[2] = v6 + 8;
  *(void *)uint64_t v6 = a1;
  *a3 = v6;
  a3[1] = v6 + 8;
  memset(v25, 0, sizeof(v25));
  unint64_t v26 = 0xAAAAAAAA3F800000;
  unint64_t i = a1;
  std::__hash_table<SVG::PatternElement const*,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,std::allocator<SVG::PatternElement const*>>::__emplace_unique_key_args<SVG::PatternElement const*,SVG::PatternElement const*>((uint64_t)v25, &i, &i);
  for (unint64_t i = *(void *)(*(void *)v6 + 864); i; unint64_t i = *(void *)(*(v12 - 1) + 864))
  {
    uint64_t v7 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(a2, &i);
    if (!v7) {
      break;
    }
    uint64_t v8 = (const void *)v7[3];
    __n128 v23 = (void *)0xAAAAAAAAAAAAAAAALL;
    if (!v23
      || std::__hash_table<SVG::PatternElement const*,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,std::allocator<SVG::PatternElement const*>>::find<SVG::PatternElement const*>(v25, &v23))
    {
      break;
    }
    std::__hash_table<SVG::PatternElement const*,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,std::allocator<SVG::PatternElement const*>>::__emplace_unique_key_args<SVG::PatternElement const*,SVG::PatternElement const*>((uint64_t)v25, &v23, &v23);
    long long v9 = v23;
    long long v11 = a3[1];
    unint64_t v10 = (unint64_t)a3[2];
    if ((unint64_t)v11 >= v10)
    {
      uint64_t v13 = ((char *)v11 - (unsigned char *)*a3) >> 3;
      if ((unint64_t)(v13 + 1) >> 61) {
        abort();
      }
      uint64_t v14 = v10 - (void)*a3;
      uint64_t v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
        uint64_t v15 = v13 + 1;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v15;
      }
      if (v16) {
        long long v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)(a3 + 2), v16);
      }
      else {
        long long v17 = 0;
      }
      long long v18 = &v17[8 * v13];
      *(void *)long long v18 = v9;
      long long v12 = v18 + 8;
      long long v20 = (char *)*a3;
      long long v19 = (char *)a3[1];
      if (v19 != *a3)
      {
        do
        {
          uint64_t v21 = *((void *)v19 - 1);
          v19 -= 8;
          *((void *)v18 - 1) = v21;
          v18 -= 8;
        }
        while (v19 != v20);
        long long v19 = (char *)*a3;
      }
      *a3 = v18;
      a3[1] = v12;
      a3[2] = &v17[8 * v16];
      if (v19) {
        operator delete(v19);
      }
    }
    else
    {
      *long long v11 = v23;
      long long v12 = v11 + 1;
    }
    a3[1] = v12;
    unint64_t i = 0xAAAAAAAAAAAAAAAALL;
  }
  return std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)v25);
}

void SVG::PatternElement::~PatternElement(SVG::PatternElement *this)
{
  *(void *)this = &unk_1F1A74728;
  uint64_t v2 = (const void *)*((void *)this + 108);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75200 + v3))(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75218 + v4))(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75230 + v5))(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75218 + v6))(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75230 + v7))(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;

  *(void *)this = &unk_1F1A74728;
  uint64_t v2 = (const void *)*((void *)this + 108);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75200 + v3))(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75218 + v4))(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75230 + v5))(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75218 + v6))(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75230 + v7))(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

void *std::__hash_table<SVG::PatternElement const*,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,std::allocator<SVG::PatternElement const*>>::__emplace_unique_key_args<SVG::PatternElement const*,SVG::PatternElement const*>(uint64_t a1, void *a2, void *a3)
{
  unint64_t v5 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v6 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v5 >> 47) ^ v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
      if (v7 >= v8) {
        unint64_t v10 = v7 % v8;
      }
    }
    else
    {
      unint64_t v10 = v7 & (v8 - 1);
    }
    char v11 = *(void ***)(*(void *)a1 + 8 * v10);
    if (v11)
    {
      for (unint64_t i = *v11; i; unint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v7)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v13 >= v8) {
              v13 %= v8;
            }
          }
          else
          {
            v13 &= v8 - 1;
          }
          if (v13 != v10) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t i = operator new(0x18uLL);
  *unint64_t i = 0;
  i[1] = v7;
  i[2] = *a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<SVG::PatternElement const*,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,std::allocator<SVG::PatternElement const*>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v10 = v7 % v8;
      }
      else {
        unint64_t v10 = v7;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  uint64_t v21 = *(void **)(*(void *)a1 + 8 * v10);
  if (v21)
  {
    *unint64_t i = *v21;
LABEL_38:
    *uint64_t v21 = i;
    goto LABEL_39;
  }
  *unint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v10) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void std::__hash_table<SVG::PatternElement const*,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,std::allocator<SVG::PatternElement const*>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<SVG::PatternElement const*,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,std::allocator<SVG::PatternElement const*>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<SVG::PatternElement const*,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,std::allocator<SVG::PatternElement const*>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      char v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *char v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            char v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          char v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void *std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  unint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  __n128 result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v5 == v10)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      __n128 result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<SVG::PatternElement const*,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,std::allocator<SVG::PatternElement const*>>::find<SVG::PatternElement const*>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  unint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  __n128 result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      __n128 result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t SVG::Recorder::updateCost(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(result + 392))
  {
    uint64_t v3 = result;
    if (*(unsigned char *)(result + 408))
    {
      uint64_t v13 = a3;
      uint64_t v14 = result;
      uint64_t v6 = *(unsigned int *)(a2 + 120);
      if (v6 != -1)
      {
        float v15 = &v13;
        ((void (*)(uint64_t **, uint64_t))*(&off_1F1A75248 + v6))(&v15, a2);
        if (!*(unsigned char *)(v3 + 392)) {
          goto LABEL_13;
        }
        double v8 = v7 + *(double *)(v3 + 384);
        *(double *)(v3 + 384) = v8;
        if (v8 > 200000.0) {
          *(unsigned char *)(v3 + 392) = 0;
        }
        uint64_t v13 = a3;
        uint64_t v14 = v3;
        uint64_t v9 = *(unsigned int *)(a2 + 120);
        if (v9 != -1)
        {
          float v15 = &v13;
          __n128 result = ((uint64_t (*)(uint64_t **, uint64_t))*(&off_1F1A752B8 + v9))(&v15, a2);
          if (*(unsigned char *)(v3 + 408))
          {
            double v11 = v10 + *(double *)(v3 + 400);
            *(double *)(v3 + 400) = v11;
            if (v11 > 134217728.0) {
              *(unsigned char *)(v3 + 408) = 0;
            }
            return result;
          }
LABEL_13:
          unint64_t v12 = (SVG::Recorder *)std::__throw_bad_optional_access[abi:nn180100]();
          return SVG::Recorder::recordGetCTM(v12);
        }
      }
      std::__throw_bad_variant_access[abi:nn180100]();
      goto LABEL_13;
    }
  }
  return result;
}

uint64_t SVG::Recorder::recordGetCTM(SVG::Recorder *this)
{
  unint64_t v5 = &unk_1F1A74AA0;
  v3[0] = &unk_1F1A74AA0;
  int v4 = 13;
  SVG::Recorder::updateCost((uint64_t)this, (uint64_t)v3, MEMORY[0x1E4F1DB28]);
  if (v4 != -1) {
    ((void (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v4])(&v6, v3);
  }
  v3[0] = &unk_1F1A74AA0;
  int v4 = 13;
  std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>((uint64_t *)this + 22, (uint64_t)v3);
  if (v4 != -1) {
    ((void (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v4])(&v6, v3);
  }
  uint64_t result = *((void *)this + 52);
  *((void *)this + 52) = result + 1;
  return result;
}

unint64_t SVG::Recorder::setInitialState(SVG::Recorder *this)
{
  std::deque<SVG::Recorder::State>::push_back(this, (unsigned char *)this + 48);
  v3[0] = 0;
  int v4 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1> const&>((uint64_t)v3, (uint64_t)this + 56);
  unint64_t v5 = &unk_1F1A74B80;
  v6[0] = 0;
  int v7 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1>>((uint64_t)v6, (uint64_t)v3);
  int v8 = 9;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>((uint64_t *)this + 22, (uint64_t)&v5);
  if (v8 != -1) {
    unint64_t result = ((uint64_t (*)(char *, void **))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v8])(&v9, &v5);
  }
  int v8 = -1;
  if (v4 != -1) {
    return ((uint64_t (*)(char *, unsigned char *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v4])(&v9, v3);
  }
  return result;
}

uint64_t SVG::Recorder::Recorder(uint64_t a1, unsigned char *a2, uint64_t a3, unsigned int a4, double a5)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(unsigned char *)(a1 + 48) = *a2;
  *(unsigned char *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 160) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1> const&>(a1 + 56, (uint64_t)(a2 + 8));
  *(unsigned char *)(a1 + 168) = a2[120];
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = a3;
  CGAffineTransformMakeScale((CGAffineTransform *)(a1 + 208), a5 / (double)a4, a5 / (double)a4);
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  long long v10 = *(_OWORD *)(a1 + 208);
  long long v11 = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = v10;
  long long v12 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(a1 + 320) = v11;
  *(_OWORD *)(a1 + 336) = v12;
  long long v17 = __const_BoundingRectState_initialState;
  long long v18 = unk_1BF1DA4D8;
  long long v19 = xmmword_1BF1DA4E8;
  long long v20 = unk_1BF1DA4F8;
  long long v21 = xmmword_1BF1DA508;
  unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  long long v13 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
  long long v14 = *MEMORY[0x1E4F1DAB8];
  long long v18 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  long long v19 = v13;
  long long v17 = v14;
  LOBYTE(v20) = 0;
  LOBYTE(v22) = 0;
  std::deque<SVG::BoundingRectState::State>::emplace_back<SVG::BoundingRectState::State>((void *)(a1 + 256), (uint64_t)&v17);
  long long v15 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)(a1 + 352) = *MEMORY[0x1E4F1DB28];
  *(_OWORD *)(a1 + 368) = v15;
  *(void *)(a1 + 384) = 0;
  *(unsigned char *)(a1 + 392) = 1;
  *(void *)(a1 + 400) = 0;
  *(unsigned char *)(a1 + 408) = 1;
  *(void *)(a1 + 416) = 0;
  SVG::Recorder::setInitialState((SVG::Recorder *)a1);
  return a1;
}

uint64_t SVG::Recorder::append(uint64_t a1, uint64_t a2)
{
  long long v27 = (CGAffineTransform *)a1;
  uint64_t v2 = *(unsigned int *)(a2 + 120);
  if (v2 == -1) {
    goto LABEL_7;
  }
  *(void *)&v19.a = &v27;
  CGFloat v5 = ((double (*)(CGAffineTransform *))*(&off_1F1A75328 + v2))(&v19);
  CGFloat v7 = v6;
  CGFloat v9 = v8;
  CGFloat v11 = v10;
  v29.origin.CGFloat x = v5;
  v29.origin.CGFloat y = v6;
  v29.size.CGFloat width = v8;
  v29.size.CGFloat height = v10;
  *(CGRect *)(a1 + 352) = CGRectUnion(*(CGRect *)(a1 + 352), v29);
  long long v12 = *(_OWORD *)(a1 + 224);
  *(_OWORD *)&v19.a = *(_OWORD *)(a1 + 208);
  *(_OWORD *)&v19.c = v12;
  *(_OWORD *)&v19.tCGFloat x = *(_OWORD *)(a1 + 240);
  CGFloat v13 = v5;
  *(CGFloat *)&long long v12 = v7;
  CGFloat v14 = v9;
  CGFloat v15 = v11;
  CGRect v28 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v12 - 8), &v19);
  v19.a = v28.origin.x;
  v19.b = v28.origin.y;
  v19.c = v28.size.width;
  v19.d = v28.size.height;
  uint64_t result = SVG::Recorder::updateCost(a1, a2, (uint64_t)&v19);
  if (*(unsigned char *)(a1 + 392) && *(unsigned char *)(a1 + 408))
  {
    *(void *)&v19.a = a1;
    *(void *)&v19.b = a1;
    *(void *)&v19.c = a1;
    *(void *)&v19.d = a1;
    *(void *)&v19.tCGFloat x = a1;
    *(void *)&v19.tCGFloat y = a1;
    uint64_t v20 = a1;
    uint64_t v21 = a1;
    uint64_t v22 = a1;
    uint64_t v23 = a1;
    uint64_t v24 = a1;
    uint64_t v25 = a1;
    uint64_t v26 = a1;
    uint64_t v17 = *(unsigned int *)(a2 + 120);
    if (v17 != -1)
    {
      long long v27 = &v19;
      return ((uint64_t (*)(CGAffineTransform **, uint64_t))*(&off_1F1A75398 + v17))(&v27, a2);
    }
LABEL_7:
    long long v18 = (SVG::Recorder *)std::__throw_bad_variant_access[abi:nn180100]();
    return SVG::Recorder::takeRecording(v18);
  }
  return result;
}

void SVG::Recorder::takeRecording(SVG::Recorder *this@<X0>, void *a2@<X8>)
{
  SVG::Recorder::setInitialState(this);
  uint64_t v4 = *((void *)this + 22);
  uint64_t v5 = *((void *)this + 23);
  uint64_t v8 = v4;
  uint64_t v9 = v5;
  uint64_t v6 = *((void *)this + 24);
  uint64_t v10 = v6;
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  if (*((unsigned char *)this + 392) && *((unsigned char *)this + 408))
  {
    *a2 = v4;
    a2[1] = v5;
    a2[2] = v6;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v8 = 0;
  }
  else
  {
    memcpy(__dst, &__const__ZN3SVG8Recorder13takeRecordingEv_r, sizeof(__dst));
    SVG::Recorder::Recorder((uint64_t)__dst, (unsigned char *)this + 48, *((void *)this + 25), 1u, 1.0);
    SVG::Recorder::takeRecording((SVG::Recorder *)__dst);
    std::deque<SVG::BoundingRectState::State>::~deque[abi:nn180100](&__dst[32]);
    CGFloat v11 = &__dst[22];
    std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v11);
    if (LODWORD(__dst[20]) != -1) {
      ((void (*)(void ****, void ***))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[LODWORD(__dst[20])])(&v11, &__dst[7]);
    }
    LODWORD(__dst[20]) = -1;
    std::deque<SVG::Recorder::State>::~deque[abi:nn180100](__dst);
  }
  __dst[0] = (void **)&v8;
  std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__destroy_vector::operator()[abi:nn180100](__dst);
}

_DWORD *SVG::Recorder::getInitialState@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = xmmword_1BF1DA428;
  *(_OWORD *)(a2 + 80) = unk_1BF1DA438;
  *(_OWORD *)(a2 + 96) = xmmword_1BF1DA448;
  *(_OWORD *)(a2 + 112) = unk_1BF1DA458;
  *(_OWORD *)a2 = __const__ZN3SVG8Recorder15getInitialStateERKNS_12PresentationE_state;
  *(_OWORD *)(a2 + 16) = unk_1BF1DA3F8;
  *(_OWORD *)(a2 + 32) = xmmword_1BF1DA408;
  *(_OWORD *)(a2 + 48) = unk_1BF1DA418;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 112) = 0;
  if (result[23] == 2 && (*(unsigned char *)a2 = result[22] == 1, result[57] == 2))
  {
    *(unsigned char *)(a2 + 120) = result[56] == 1;
  }
  else
  {
    uint64_t v2 = (void **)std::__throw_bad_variant_access[abi:nn180100]();
    return (_DWORD *)std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(v2, v3);
  }
  return result;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<7ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<8ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<9ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<10ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<11ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<12ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<13ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 32))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__throw_bad_optional_access[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_optional_access was thrown in -fno-exceptions mode");
  return std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(v0, v1);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<7ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<8ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<9ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<10ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<11ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<12ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<13ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::updateCost(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&,CGRect const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 40))(a2, **a1, (*a1)[1] + 256);
}

void SVG::GetCTM::~GetCTM(SVG::GetCTM *this)
{
}

void SVG::GetCTM::execute(int a1, CGContextRef c, void *a3)
{
  CGContextGetCTM(&t1, c);
  CGContextGetBaseCTM();
  CGAffineTransformInvert(&t2, &v23);
  CGAffineTransformConcat(&v26, &t1, &t2);
  unint64_t v4 = a3[3];
  uint64_t v5 = (_OWORD *)a3[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v9 = a3[1];
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - v9) >> 4);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0x555555555555555) {
      abort();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v9) >> 4);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v13 = 0x555555555555555;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      CGFloat v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGAffineTransform>>((uint64_t)(a3 + 3), v13);
    }
    else {
      CGFloat v14 = 0;
    }
    CGFloat v15 = &v14[48 * v10];
    BOOL v16 = &v14[48 * v13];
    long long v17 = *(_OWORD *)&v26.a;
    long long v18 = *(_OWORD *)&v26.tx;
    *((_OWORD *)v15 + 1) = *(_OWORD *)&v26.c;
    *((_OWORD *)v15 + 2) = v18;
    *(_OWORD *)CGFloat v15 = v17;
    uint64_t v8 = v15 + 48;
    uint64_t v20 = (char *)a3[1];
    CGAffineTransform v19 = (char *)a3[2];
    if (v19 != v20)
    {
      do
      {
        long long v21 = *((_OWORD *)v19 - 3);
        long long v22 = *((_OWORD *)v19 - 1);
        *((_OWORD *)v15 - 2) = *((_OWORD *)v19 - 2);
        *((_OWORD *)v15 - 1) = v22;
        *((_OWORD *)v15 - 3) = v21;
        v15 -= 48;
        v19 -= 48;
      }
      while (v19 != v20);
      CGAffineTransform v19 = (char *)a3[1];
    }
    a3[1] = v15;
    a3[2] = v8;
    a3[3] = v16;
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    long long v6 = *(_OWORD *)&v26.a;
    long long v7 = *(_OWORD *)&v26.tx;
    v5[1] = *(_OWORD *)&v26.c;
    v5[2] = v7;
    *uint64_t v5 = v6;
    uint64_t v8 = v5 + 3;
  }
  a3[2] = v8;
}

double SVG::GetCTM::boundingRect(SVG::GetCTM *this, SVG::BoundingRectState *a2)
{
  return *MEMORY[0x1E4F1DB28];
}

double SVG::GetCTM::timeCost(SVG::GetCTM *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  return 0.0144500001;
}

uint64_t SVG::GetCTM::dump(SVG::GetCTM *this)
{
  uint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"GetCTM", 6);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  uint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CGAffineTransform>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(48 * a2);
}

unint64_t std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  std::locale v4 = a1 + 2;
  unint64_t v5 = v6;
  unint64_t v7 = *(v4 - 1);
  if (v7 >= v6)
  {
    uint64_t v9 = (uint64_t)(v7 - *a1) >> 7;
    if ((unint64_t)(v9 + 1) >> 57) {
      abort();
    }
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 6;
    if (v10 >> 6 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFF80) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v16[4] = v4;
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>>((uint64_t)v4, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    CGFloat v14 = &v13[128 * v9];
    v16[0] = v13;
    v16[1] = v14;
    void v16[3] = &v13[128 * v12];
    *CGFloat v14 = 0;
    *((_DWORD *)v14 + 30) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>,(std::__variant_detail::_Trait)1>>((uint64_t)v14, a2);
    _OWORD v16[2] = v14 + 128;
    std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__swap_out_circular_buffer(a1, v16);
    unint64_t v8 = a1[1];
    std::__split_buffer<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::~__split_buffer(v16);
  }
  else
  {
    *(unsigned char *)unint64_t v7 = 0;
    *(_DWORD *)(v7 + 120) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>,(std::__variant_detail::_Trait)1>>(v7, a2);
    unint64_t v8 = v7 + 128;
  }
  a1[1] = v8;
  return v8 - 128;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 120);
  if (v4 != -1) {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 120) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 120);
  if (v5 != -1)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base14__visit_alt_atB8nn180100IZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISL_LNS0_6_TraitE1EEEEEvRSM_OT_EUlRSS_OT0_E_JSR_SQ_EEEDcmST_DpOT0____fdiagonal[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 120) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74D18;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74620;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F1A74C88;
  __n128 result = *(__n128 *)(a3 + 8);
  long long v4 = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a3 + 40);
  *(_OWORD *)(a2 + 24) = v4;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = 0;
  *(void *)a2 = &unk_1F1A74CD0;
  *(void *)(a2 + 8) = v3;
  __n128 result = *(__n128 *)(a3 + 16);
  long long v5 = *(_OWORD *)(a3 + 32);
  *(__n128 *)(a2 + 16) = result;
  *(_OWORD *)(a2 + 32) = v5;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = 0;
  *(void *)a2 = &unk_1F1A74BC8;
  *(void *)(a2 + 8) = v3;
  *(unsigned char *)(a2 + 16) = *(unsigned char *)(a3 + 16);
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = 0;
  *(void *)a2 = &unk_1F1A74890;
  *(void *)(a2 + 8) = v3;
  __n128 result = *(__n128 *)(a3 + 16);
  long long v5 = *(_OWORD *)(a3 + 32);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
  *(__n128 *)(a2 + 16) = result;
  *(_OWORD *)(a2 + 32) = v5;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = 0;
  *(void *)a2 = &unk_1F1A748D8;
  *(void *)(a2 + 8) = v3;
  __n128 result = *(__n128 *)(a3 + 16);
  long long v5 = *(_OWORD *)(a3 + 32);
  long long v6 = *(_OWORD *)(a3 + 48);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a3 + 64);
  *(_OWORD *)(a2 + 32) = v5;
  *(_OWORD *)(a2 + 48) = v6;
  *(__n128 *)(a2 + 16) = result;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F1A74458;
  __n128 result = *(__n128 *)(a3 + 8);
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F1A74280;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a3 + 8);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  long long v3 = *(_OWORD *)(a3 + 56);
  long long v4 = *(_OWORD *)(a3 + 72);
  long long v5 = *(_OWORD *)(a3 + 88);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a3 + 40);
  *(_OWORD *)(a2 + 88) = v5;
  *(_OWORD *)(a2 + 72) = v4;
  *(_OWORD *)(a2 + 56) = v3;
  __n128 result = *(__n128 *)(a3 + 24);
  *(__n128 *)(a2 + 24) = result;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F1A74B80;
  *(_DWORD *)(a2 + 112) = -1;
  *(unsigned char *)(a2 + 8) = 0;
  return std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1>>(a2 + 8, a3 + 8);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A749E8;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74920;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F1A74C40;
  double result = *(double *)(a3 + 8);
  *(double *)(a2 + 8) = result;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm13ELm13EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG9SaveStateENS8_12RestoreStateENS8_9ConcatCTMENS8_9DrawImageENS8_8FillPathENS8_18DrawLinearGradientENS8_18DrawRadialGradientENS8_11ClipToPathsENS8_10ClipToMaskENS8_7SetFillENS8_22BeginTransparencyLayerENS8_20EndTransparencyLayerENS8_8SetAlphaENS8_6GetCTMEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISN_LNS0_6_TraitE1EEEEEvRSO_OT_EUlRSU_OT0_E_JRNS0_6__baseILSR_1EJS9_SA_SB_SC_SD_SE_SF_SG_SH_SI_SJ_SK_SL_SM_EEEOS12_EEEDcSU_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74AA0;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 104);
  if (v4 != -1) {
    double result = ((uint64_t (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 104) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 104);
  if (v5 != -1)
  {
    double result = ((uint64_t (*)(char *, uint64_t, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base14__visit_alt_atB8nn180100IZNS0_6__ctorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSL_OT0_E_JSK_SJ_EEEDcmSM_DpOT0____fdiagonal[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 104) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSN_OT0_E_JRNS0_6__baseILSK_1EJSC_SE_SF_EEEOSV_EEEDcSN_DpT0_(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  *a3 = 0;
  *a2 = v3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSN_OT0_E_JRNS0_6__baseILSK_1EJSC_SE_SF_EEEOSV_EEEDcSN_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSN_OT0_E_JRNS0_6__baseILSK_1EJSC_SE_SF_EEEOSV_EEEDcSN_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  long long v4 = *(_OWORD *)(a3 + 64);
  long long v3 = *(_OWORD *)(a3 + 80);
  long long v5 = *(_OWORD *)(a3 + 48);
  *(void *)(a2 + 96) = *(void *)(a3 + 96);
  *(_OWORD *)(a2 + 64) = v4;
  *(_OWORD *)(a2 + 80) = v3;
  *(_OWORD *)(a2 + 48) = v5;
  __n128 result = *(__n128 *)(a3 + 16);
  long long v7 = *(_OWORD *)(a3 + 32);
  *(__n128 *)(a2 + 16) = result;
  *(_OWORD *)(a2 + 32) = v7;
  return result;
}

void SVG::BeginTransparencyLayer::~BeginTransparencyLayer(SVG::BeginTransparencyLayer *this)
{
}

void SVG::BeginTransparencyLayer::execute(int a1, CGContextRef c)
{
}

double SVG::BeginTransparencyLayer::boundingRect(SVG::BeginTransparencyLayer *this, SVG::BoundingRectState *a2)
{
  return *MEMORY[0x1E4F1DB28];
}

CGFloat SVG::BeginTransparencyLayer::timeCost(SVG::BeginTransparencyLayer *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  v9.origin.CGFloat x = SVG::BoundingRectState::clipRectInPixels(a3);
  CGFloat x = v9.origin.x;
  CGFloat y = v9.origin.y;
  CGFloat width = v9.size.width;
  CGFloat height = v9.size.height;
  CGFloat v7 = CGRectGetWidth(v9) * 0.0025;
  v10.origin.CGFloat x = x;
  v10.origin.CGFloat y = y;
  v10.size.CGFloat width = width;
  v10.size.CGFloat height = height;
  return v7 * CGRectGetHeight(v10);
}

CGFloat SVG::BeginTransparencyLayer::memoryCost(SVG::BeginTransparencyLayer *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  v9.origin.CGFloat x = SVG::BoundingRectState::clipRectInPixels(a3);
  CGFloat x = v9.origin.x;
  CGFloat y = v9.origin.y;
  CGFloat width = v9.size.width;
  CGFloat height = v9.size.height;
  CGFloat v7 = CGRectGetWidth(v9) * 4.0;
  v10.origin.CGFloat x = x;
  v10.origin.CGFloat y = y;
  v10.size.CGFloat width = width;
  v10.size.CGFloat height = height;
  return v7 * CGRectGetHeight(v10);
}

uint64_t SVG::BeginTransparencyLayer::dump(SVG::BeginTransparencyLayer *this)
{
  uint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"BeginTransparencyLayer", 22);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  uint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

void SVG::EndTransparencyLayer::~EndTransparencyLayer(SVG::EndTransparencyLayer *this)
{
}

void SVG::EndTransparencyLayer::execute(int a1, CGContextRef c)
{
}

double SVG::EndTransparencyLayer::boundingRect(SVG::EndTransparencyLayer *this, SVG::BoundingRectState *a2)
{
  return *MEMORY[0x1E4F1DB28];
}

double SVG::EndTransparencyLayer::timeCost(SVG::EndTransparencyLayer *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  return 0.0;
}

uint64_t SVG::EndTransparencyLayer::dump(SVG::EndTransparencyLayer *this)
{
  uint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"EndTransparencyLayer", 20);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  uint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

void SVG::SetAlpha::~SetAlpha(SVG::SetAlpha *this)
{
}

void SVG::SetAlpha::execute(uint64_t a1, CGContextRef c)
{
}

double SVG::SetAlpha::boundingRect(SVG::SetAlpha *this, SVG::BoundingRectState *a2)
{
  return *MEMORY[0x1E4F1DB28];
}

double SVG::SetAlpha::timeCost(SVG::SetAlpha *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  return 1.41666738;
}

uint64_t SVG::SetAlpha::dump(SVG::SetAlpha *this)
{
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"SetAlpha ", 9);
  uint64_t v1 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  uint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

uint64_t *std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  long long v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = v6 - 128;
    do
    {
      v4 -= 128;
      *(unsigned char *)uint64_t v7 = 0;
      *(_DWORD *)(v7 + 12CGContextBeginTransparencyLayer(c, 0) = -1;
      __n128 result = (uint64_t *)std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>,(std::__variant_detail::_Trait)1>>(v7, v4);
      v7 -= 128;
    }
    while (v4 != v5);
    uint64_t v6 = v7 + 128;
  }
  a2[1] = v6;
  uint64_t v8 = *v3;
  *long long v3 = v6;
  a2[1] = v8;
  uint64_t v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 57) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(a2 << 7);
}

void **std::__split_buffer<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

uint64_t std::__split_buffer<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::clear[abi:nn180100](uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  if (v2 != v1)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = v2 - 128;
      *(void *)(v3 + 16) = v2 - 128;
      uint64_t v5 = *(unsigned int *)(v2 - 8);
      if (v5 != -1)
      {
        __n128 result = ((uint64_t (*)(char *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v5])(&v6);
        uint64_t v4 = *(void *)(v3 + 16);
      }
      *(_DWORD *)(v2 - 8) = -1;
      uint64_t v2 = v4;
    }
    while (v4 != v1);
  }
  return result;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 104);
  if (v4 != -1) {
    __n128 result = ((uint64_t (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 104) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 104);
  if (v5 != -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base14__visit_alt_atB8nn180100IZNS0_6__ctorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JSM_SL_EEEDcmSO_DpOT0____fdiagonal[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 104) = v5;
  }
  return result;
}

CFTypeRef _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSP_OT0_E_JRNS0_6__baseILSK_1EJSC_SE_SF_EEERKSX_EEEDcSP_DpT0_(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3)
{
  CFTypeRef result = *a3;
  *a2 = *a3;
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSP_OT0_E_JRNS0_6__baseILSK_1EJSC_SE_SF_EEERKSX_EEEDcSP_DpT0_(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSP_OT0_E_JRNS0_6__baseILSK_1EJSC_SE_SF_EEERKSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  *(void *)a2 = *(void *)a3;
  *(void *)(a2 + 8) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  long long v4 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 32) = v4;
  __n128 result = *(__n128 *)(a3 + 48);
  long long v6 = *(_OWORD *)(a3 + 64);
  long long v7 = *(_OWORD *)(a3 + 80);
  *(void *)(a2 + 96) = *(void *)(a3 + 96);
  *(_OWORD *)(a2 + 64) = v6;
  *(_OWORD *)(a2 + 8CGContextBeginTransparencyLayer(c, 0) = v7;
  *(__n128 *)(a2 + 48) = result;
  return result;
}

uint64_t std::deque<SVG::BoundingRectState::State>::emplace_back<SVG::BoundingRectState::State>(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 46 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<SVG::BoundingRectState::State>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x2E)) + 88 * (v7 % 0x2E);
  long long v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  long long v10 = *(_OWORD *)(a2 + 32);
  long long v11 = *(_OWORD *)(a2 + 48);
  long long v12 = *(_OWORD *)(a2 + 64);
  *(void *)(v8 + 8CGContextBeginTransparencyLayer(c, 0) = *(void *)(a2 + 80);
  *(_OWORD *)(v8 + 48) = v11;
  *(_OWORD *)(v8 + 64) = v12;
  *(_OWORD *)(v8 + 32) = v10;
  uint64_t v13 = a1[4];
  uint64_t v14 = a1[5] + 1;
  a1[5] = v14;
  unint64_t v15 = v13 + v14;
  uint64_t v16 = a1[1];
  long long v17 = (void *)(v16 + 8 * (v15 / 0x2E));
  uint64_t v18 = *v17 + 88 * (v15 % 0x2E);
  if (a1[2] == v16) {
    uint64_t v18 = 0;
  }
  if (v18 == *v17) {
    uint64_t v18 = *(v17 - 1) + 4048;
  }
  return v18 - 88;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<7ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<8ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<9ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<10ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<11ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<12ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<13ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void **a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 24))(a2, **a1 + 256);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1)
{
  uint64_t v1 = **a1;
  v4[0] = &unk_1F1A74D18;
  int v5 = 0;
  std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v1 + 22, (uint64_t)v4);
  if (v5 != -1) {
    ((void (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v5])(&v6, v4);
  }
  unint64_t v2 = v1[5] + v1[4] - 1;
  return std::deque<SVG::Recorder::State>::push_back(v1, (unsigned char *)(*(void *)(v1[1] + ((v2 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v2 & 0x1F) << 7)));
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1)
{
  uint64_t v1 = *(void **)(*(void *)a1 + 8);
  v11[0] = &unk_1F1A74620;
  int v12 = 1;
  std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v1 + 22, (uint64_t)v11);
  if (v12 != -1) {
    ((void (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v12])(&v13, v11);
  }
  uint64_t v2 = v1[5] - 1;
  unint64_t v3 = v2 + v1[4];
  uint64_t v4 = v1[1];
  unint64_t v5 = *(void *)(v4 + ((v3 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v3 & 0x1F) << 7);
  unsigned int v8 = *(_DWORD *)(v5 + 112);
  unint64_t v7 = (_DWORD *)(v5 + 112);
  uint64_t v6 = v8;
  if (v8 != -1)
  {
    ((void (*)(void *, unint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v6])(v11, *(void *)(v4 + ((v3 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v3 & 0x1F) << 7) + 8);
    uint64_t v2 = v1[5] - 1;
    uint64_t v4 = v1[1];
    unint64_t v3 = v1[4] + v2;
  }
  uint64_t v9 = v1[2];
  *unint64_t v7 = -1;
  v1[5] = v2;
  if (v9 == v4) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 4 * (v9 - v4) - 1;
  }
  if (v10 - v3 >= 0x40)
  {
    operator delete(*(void **)(v9 - 8));
    v1[2] -= 8;
  }
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(*(void *)(*(void *)a1 + 16) + 176);
  unint64_t v5 = &unk_1F1A74C88;
  long long v3 = *(_OWORD *)(a2 + 24);
  long long v6 = *(_OWORD *)(a2 + 8);
  long long v7 = v3;
  long long v8 = *(_OWORD *)(a2 + 40);
  int v9 = 2;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v2, (uint64_t)&v5);
  if (v9 != -1) {
    return ((uint64_t (*)(char *, void **))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v9])(&v10, &v5);
  }
  return result;
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1, uint64_t a2)
{
  long long v3 = (uint64_t *)(*(void *)(*(void *)a1 + 24) + 176);
  uint64_t v4 = *(const void **)(a2 + 8);
  v7[0] = &unk_1F1A74CD0;
  v7[1] = v4;
  if (v4) {
    CFRetain(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v8 = *(_OWORD *)(a2 + 16);
  long long v9 = v5;
  int v10 = 3;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v3, (uint64_t)v7);
  if (v10 != -1) {
    return ((uint64_t (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v10])(&v11, v7);
  }
  return result;
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1, uint64_t a2)
{
  long long v3 = (uint64_t *)(*(void *)(*(void *)a1 + 32) + 176);
  uint64_t v4 = *(const void **)(a2 + 8);
  v6[0] = &unk_1F1A74BC8;
  v6[1] = v4;
  if (v4) {
    CFRetain(v4);
  }
  char v7 = *(unsigned char *)(a2 + 16);
  int v8 = 4;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v3, (uint64_t)v6);
  if (v8 != -1) {
    return ((uint64_t (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v8])(&v9, v6);
  }
  return result;
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1, uint64_t a2)
{
  long long v3 = (uint64_t *)(*(void *)(*(void *)a1 + 40) + 176);
  uint64_t v4 = *(const void **)(a2 + 8);
  v7[0] = &unk_1F1A74890;
  v7[1] = v4;
  if (v4) {
    CFRetain(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v8 = *(_OWORD *)(a2 + 16);
  long long v9 = v5;
  int v10 = *(_DWORD *)(a2 + 48);
  int v11 = 5;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v3, (uint64_t)v7);
  if (v11 != -1) {
    return ((uint64_t (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v11])(&v12, v7);
  }
  return result;
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1, uint64_t a2)
{
  long long v3 = (uint64_t *)(*(void *)(*(void *)a1 + 48) + 176);
  uint64_t v4 = *(const void **)(a2 + 8);
  v7[0] = &unk_1F1A748D8;
  v7[1] = v4;
  if (v4) {
    CFRetain(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v8 = *(_OWORD *)(a2 + 16);
  long long v9 = v5;
  long long v10 = *(_OWORD *)(a2 + 48);
  int v11 = *(_DWORD *)(a2 + 64);
  int v12 = 6;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v3, (uint64_t)v7);
  if (v12 != -1) {
    return ((uint64_t (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v12])(&v13, v7);
  }
  return result;
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<7ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(*(void *)(*(void *)a1 + 56) + 176);
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  v6[0] = &unk_1F1A74458;
  v6[1] = v4;
  void v6[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  int v7 = 7;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v2, (uint64_t)v6);
  if (v7 != -1) {
    return ((uint64_t (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v7])(&v8, v6);
  }
  return result;
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<8ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(*(void *)(*(void *)a1 + 64) + 176);
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  v8[0] = &unk_1F1A74280;
  v8[1] = v4;
  v8[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  long long v5 = *(_OWORD *)(a2 + 56);
  long long v10 = *(_OWORD *)(a2 + 40);
  long long v11 = v5;
  long long v6 = *(_OWORD *)(a2 + 88);
  long long v12 = *(_OWORD *)(a2 + 72);
  long long v13 = v6;
  long long v9 = *(_OWORD *)(a2 + 24);
  int v14 = 8;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v2, (uint64_t)v8);
  if (v14 != -1) {
    return ((uint64_t (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v14])(&v15, v8);
  }
  return result;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<9ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(*(void *)a1 + 72);
  unint64_t v3 = v2[5] + v2[4] - 1;
  unint64_t v4 = *(void *)(v2[1] + ((v3 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v3 & 0x1F) << 7);
  uint64_t v5 = a2 + 8;
  LOBYTE(v17) = 0;
  unsigned int v19 = -1;
  uint64_t result = std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1> const&>((uint64_t)&v17, a2 + 8);
  uint64_t v7 = *(unsigned int *)(v4 + 112);
  unsigned int v8 = v19;
  BOOL v9 = v19 != -1 && v19 == v7;
  if (v7 == -1) {
    BOOL v10 = v19 == -1;
  }
  else {
    BOOL v10 = v9;
  }
  if (v7 == -1 || !v9)
  {
    int v12 = !v10;
  }
  else
  {
    CGAffineTransform v23 = &v22;
    uint64_t result = ((uint64_t (*)(char **, unint64_t, void **))*(&off_1F1A75408 + v7))(&v23, v4 + 8, &v17);
    int v12 = result;
    unsigned int v8 = v19;
  }
  if (v8 != -1) {
    uint64_t result = ((uint64_t (*)(char **, void **))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v8])(&v23, &v17);
  }
  if (v12)
  {
    long long v17 = &unk_1F1A74B80;
    v18[0] = 0;
    int v20 = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1> const&>((uint64_t)v18, v5);
    int v21 = 9;
    std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v2 + 22, (uint64_t)&v17);
    if (v21 != -1) {
      ((void (*)(char **, void **))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v21])(&v23, &v17);
    }
    LOBYTE(v17) = 0;
    unsigned int v19 = -1;
    uint64_t result = std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1> const&>((uint64_t)&v17, v5);
    unint64_t v13 = v2[5] + v2[4] - 1;
    unint64_t v14 = *(void *)(v2[1] + ((v13 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v13 & 0x1F) << 7);
    unint64_t v15 = v14 + 8;
    uint64_t v16 = *(unsigned int *)(v14 + 112);
    if (v16 == -1)
    {
      if (v19 == -1) {
        return result;
      }
    }
    else if (v19 == -1)
    {
      uint64_t result = ((uint64_t (*)(char **, unint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v16])(&v23, v15);
      *(_DWORD *)(v15 + 104) = -1;
      goto LABEL_23;
    }
    CGAffineTransform v23 = (char *)(v14 + 8);
    uint64_t result = ((uint64_t (*)(char **, unint64_t, void **))*(&off_1F1A75420 + v19))(&v23, v15, &v17);
LABEL_23:
    if (v19 != -1) {
      return ((uint64_t (*)(char **, void **))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v19])(&v23, &v17);
    }
  }
  return result;
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<10ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(*(void *)(*(void *)a1 + 80) + 176);
  v3[0] = &unk_1F1A749E8;
  int v4 = 10;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v1, (uint64_t)v3);
  if (v4 != -1) {
    return ((uint64_t (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v4])(&v5, v3);
  }
  return result;
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<11ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(*(void *)(*(void *)a1 + 88) + 176);
  v3[0] = &unk_1F1A74920;
  int v4 = 11;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v1, (uint64_t)v3);
  if (v4 != -1) {
    return ((uint64_t (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v4])(&v5, v3);
  }
  return result;
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<12ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_1,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_2,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_3,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_4,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_5,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_6,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_7,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_8,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_9,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_10,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_11,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_12,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_13,SVG::Recorder::append(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::$_14>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(*(void *)(*(void *)a1 + 96) + 176);
  v4[0] = &unk_1F1A74C40;
  v4[1] = *(void *)(a2 + 8);
  int v5 = 12;
  unint64_t result = std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::emplace_back<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>(v2, (uint64_t)v4);
  if (v5 != -1) {
    return ((uint64_t (*)(char *, void *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSN_EEEDcOSO_DpOT0____fmatrix[v5])(&v6, v4);
  }
  return result;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul,0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::not_equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,std::__variant_detail::_Trait::SetFill::CurrentColor,SVG::CF<CGColor *>::PatternData> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,std::__variant_detail::_Trait::SetFill::CurrentColor,SVG::CF<CGColor *>::PatternData> const>(uint64_t a1, const void **a2, const void **a3)
{
  unint64_t v3 = *a2;
  int v4 = *a3;
  if (v3) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    int v6 = (v3 != 0) ^ (v4 == 0);
  }
  else {
    int v6 = CFEqual(v3, v4) != 0;
  }
  return v6 ^ 1u;
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<1ul,1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::not_equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,std::__variant_detail::_Trait::SetFill::CurrentColor,SVG::CF<CGColor *>::PatternData> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,std::__variant_detail::_Trait::SetFill::CurrentColor,SVG::CF<CGColor *>::PatternData> const>(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return *a2 != *a3;
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<2ul,2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::not_equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,std::__variant_detail::_Trait::SetFill::CurrentColor,SVG::CF<CGColor *>::PatternData> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,std::__variant_detail::_Trait::SetFill::CurrentColor,SVG::CF<CGColor *>::PatternData> const>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a2 != *(void *)a3
    || !CGRectEqualToRect(*(CGRect *)(a2 + 16), *(CGRect *)(a3 + 16))
    || *(void *)(a2 + 48) != *(void *)(a3 + 48))
  {
    return 1;
  }
  long long v5 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)&t1.a = *(_OWORD *)(a2 + 56);
  *(_OWORD *)&t1.c = v5;
  *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)(a2 + 88);
  long long v6 = *(_OWORD *)(a3 + 72);
  *(_OWORD *)&v8.a = *(_OWORD *)(a3 + 56);
  *(_OWORD *)&v8.c = v6;
  *(_OWORD *)&v8.tCGFloat x = *(_OWORD *)(a3 + 88);
  return !CGAffineTransformEqualToTransform(&t1, &v8);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISG_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSK_1EJSC_SE_SF_EEEOSU_EEEDcSM_DpT0_(uint64_t *a1, CFTypeRef *a2, const void **a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 104);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5)
  {
    ((void (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v5])(&v9, v4);
LABEL_7:
    CGAffineTransform v8 = *a3;
    *a3 = 0;
    *(void *)uint64_t v4 = v8;
    *(_DWORD *)(v4 + 104) = 0;
    return;
  }
  if (*a2) {
    CFRelease(*a2);
  }
  uint64_t v7 = *a3;
  *a3 = 0;
  *a2 = v7;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISG_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSK_1EJSC_SE_SF_EEEOSU_EEEDcSM_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 104);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    unint64_t result = ((uint64_t (*)(char *, _DWORD *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v5])(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[26] = 1;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG2CFIP7CGColorEENS8_7SetFill12CurrentColorENSD_11PatternDataEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISG_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSK_1EJSC_SE_SF_EEEOSU_EEEDcSM_DpT0_(uint64_t *a1, uint64_t a2, long long *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 104);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 2)
  {
    ((void (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN3SVG2CFIP7CGColorEENS6_7SetFill12CurrentColorENSB_11PatternDataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSG_EEEDcOSH_DpOT0____fmatrix[v5])(&v16, v4);
LABEL_7:
    *(_DWORD *)(v4 + 104) = -1;
    *(_OWORD *)uint64_t v4 = *a3;
    *(void *)a3 = 0;
    *((void *)a3 + 1) = 0;
    long long v13 = a3[2];
    *(_OWORD *)(v4 + 16) = a3[1];
    *(_OWORD *)(v4 + 32) = v13;
    __n128 result = (__n128)a3[3];
    long long v14 = a3[4];
    long long v15 = a3[5];
    *(void *)(v4 + 96) = *((void *)a3 + 12);
    *(_OWORD *)(v4 + 64) = v14;
    *(_OWORD *)(v4 + 8CGContextBeginTransparencyLayer(c, 0) = v15;
    *(__n128 *)(v4 + 48) = result;
    *(_DWORD *)(v4 + 104) = 2;
    return result;
  }
  long long v7 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  CGAffineTransform v8 = *(std::__shared_weak_count **)(a2 + 8);
  *(_OWORD *)a2 = v7;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  long long v9 = a3[2];
  *(_OWORD *)(a2 + 16) = a3[1];
  *(_OWORD *)(a2 + 32) = v9;
  __n128 result = (__n128)a3[3];
  long long v11 = a3[4];
  long long v12 = a3[5];
  *(void *)(a2 + 96) = *((void *)a3 + 12);
  *(_OWORD *)(a2 + 64) = v11;
  *(_OWORD *)(a2 + 8CGContextBeginTransparencyLayer(c, 0) = v12;
  *(__n128 *)(a2 + 48) = result;
  return result;
}

uint64_t std::deque<SVG::Recorder::State>::push_back(void *a1, unsigned char *a2)
{
  uint64_t v4 = (char *)a1[1];
  uint64_t v5 = (char *)a1[2];
  uint64_t v6 = v5 - v4;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 4 * (v5 - v4) - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 >= 0x20)
    {
      a1[4] = v8 - 32;
      uint64_t v12 = *(void *)v4;
      BOOL v10 = v4 + 8;
      uint64_t v11 = v12;
      a1[1] = v10;
      if (v5 == (char *)a1[3])
      {
        uint64_t v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v5 == (char *)*a1) {
            unint64_t v40 = 1;
          }
          else {
            unint64_t v40 = (uint64_t)&v5[-*a1] >> 2;
          }
          unint64_t v41 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v40);
          char v43 = &v41[8 * (v40 >> 2)];
          unsigned int v44 = (uint64_t *)a1[1];
          uint64_t v5 = v43;
          uint64_t v45 = a1[2] - (void)v44;
          if (v45)
          {
            uint64_t v5 = &v43[v45 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v46 = 8 * (v45 >> 3);
            uint64_t v47 = &v41[8 * (v40 >> 2)];
            do
            {
              uint64_t v48 = *v44++;
              *(void *)uint64_t v47 = v48;
              v47 += 8;
              v46 -= 8;
            }
            while (v46);
          }
          uint64_t v49 = (char *)*a1;
          *a1 = v41;
          a1[1] = v43;
          a1[2] = v5;
          a1[3] = &v41[8 * v42];
          if (v49)
          {
            operator delete(v49);
            uint64_t v5 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v14 = v13 >> 3;
          BOOL v15 = v13 >> 3 < -1;
          uint64_t v16 = (v13 >> 3) + 2;
          if (v15) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14 + 1;
          }
          uint64_t v18 = -(v17 >> 1);
          uint64_t v19 = v17 >> 1;
          int v20 = &v10[-8 * v19];
          int64_t v21 = v5 - v10;
          if (v5 != v10)
          {
            memmove(&v10[-8 * v19], v10, v5 - v10);
            uint64_t v5 = (char *)a1[1];
          }
          char v22 = &v5[8 * v18];
          uint64_t v5 = &v20[v21];
          a1[1] = v22;
          a1[2] = &v20[v21];
        }
      }
      *(void *)uint64_t v5 = v11;
LABEL_35:
      a1[2] += 8;
LABEL_36:
      uint64_t v4 = (char *)a1[1];
      unint64_t v9 = a1[5] + a1[4];
      goto LABEL_37;
    }
    uint64_t v23 = v6 >> 3;
    uint64_t v24 = (char *)a1[3];
    uint64_t v25 = (char *)*a1;
    uint64_t v26 = (uint64_t)&v24[-*a1];
    if (v6 >> 3 < (unint64_t)(v26 >> 3))
    {
      long long v27 = operator new(0x1000uLL);
      CGRect v28 = v27;
      if (v24 == v5)
      {
        if (v4 == v25)
        {
          if (v5 == v4) {
            unint64_t v52 = 1;
          }
          else {
            unint64_t v52 = (v24 - v4) >> 2;
          }
          uint64_t v53 = 2 * v52;
          long long v54 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v52);
          uint64_t v4 = &v54[(v53 + 6) & 0xFFFFFFFFFFFFFFF8];
          v56 = (uint64_t *)a1[1];
          long long v57 = v4;
          uint64_t v58 = a1[2] - (void)v56;
          if (v58)
          {
            long long v57 = &v4[v58 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v59 = 8 * (v58 >> 3);
            unint64_t v60 = v4;
            do
            {
              uint64_t v61 = *v56++;
              *(void *)unint64_t v60 = v61;
              v60 += 8;
              v59 -= 8;
            }
            while (v59);
          }
          long long v62 = (char *)*a1;
          *a1 = v54;
          a1[1] = v4;
          a1[2] = v57;
          a1[3] = &v54[8 * v55];
          if (v62)
          {
            operator delete(v62);
            uint64_t v4 = (char *)a1[1];
          }
        }
        *((void *)v4 - 1) = v28;
        uint64_t v63 = (char *)a1[1];
        unint64_t v64 = (char *)a1[2];
        a1[1] = v63 - 8;
        uint64_t v65 = *((void *)v63 - 1);
        a1[1] = v63;
        if (v64 == (char *)a1[3])
        {
          uint64_t v66 = (uint64_t)&v63[-*a1];
          if ((unint64_t)v63 <= *a1)
          {
            if (v64 == (char *)*a1) {
              unint64_t v97 = 1;
            }
            else {
              unint64_t v97 = (uint64_t)&v64[-*a1] >> 2;
            }
            unint64_t v98 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v97);
            uint64_t v100 = &v98[8 * (v97 >> 2)];
            uint64_t v101 = (uint64_t *)a1[1];
            unint64_t v64 = v100;
            uint64_t v102 = a1[2] - (void)v101;
            if (v102)
            {
              unint64_t v64 = &v100[v102 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v103 = 8 * (v102 >> 3);
              uint64_t v104 = &v98[8 * (v97 >> 2)];
              do
              {
                uint64_t v105 = *v101++;
                *(void *)uint64_t v104 = v105;
                v104 += 8;
                v103 -= 8;
              }
              while (v103);
            }
            unint64_t v106 = (char *)*a1;
            *a1 = v98;
            a1[1] = v100;
            a1[2] = v64;
            a1[3] = &v98[8 * v99];
            if (v106)
            {
              operator delete(v106);
              unint64_t v64 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v67 = v66 >> 3;
            BOOL v15 = v66 >> 3 < -1;
            uint64_t v68 = (v66 >> 3) + 2;
            if (v15) {
              uint64_t v69 = v68;
            }
            else {
              uint64_t v69 = v67 + 1;
            }
            uint64_t v70 = -(v69 >> 1);
            uint64_t v71 = v69 >> 1;
            uint64_t v72 = &v63[-8 * v71];
            int64_t v73 = v64 - v63;
            if (v64 != v63)
            {
              memmove(&v63[-8 * v71], v63, v64 - v63);
              uint64_t v63 = (char *)a1[1];
            }
            unint64_t v64 = &v72[v73];
            a1[1] = &v63[8 * v70];
            a1[2] = &v72[v73];
          }
        }
        *(void *)unint64_t v64 = v65;
      }
      else
      {
        *(void *)uint64_t v5 = v27;
      }
      goto LABEL_35;
    }
    uint64_t v29 = v26 >> 2;
    if (v24 == v25) {
      unint64_t v30 = 1;
    }
    else {
      unint64_t v30 = v29;
    }
    long long v31 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v30);
    uint64_t v33 = v32;
    long long v34 = &v31[8 * v23];
    long long v35 = &v31[8 * v32];
    long long v36 = operator new(0x1000uLL);
    if (v23 == v33)
    {
      uint64_t v37 = 8 * v23;
      if (v6 < 1)
      {
        v74 = v36;
        uint64_t v75 = v37 >> 2;
        if (v5 == v4) {
          unint64_t v76 = 1;
        }
        else {
          unint64_t v76 = v75;
        }
        uint64_t v77 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v76);
        long long v34 = &v77[8 * (v76 >> 2)];
        long long v35 = &v77[8 * v78];
        if (v31) {
          operator delete(v31);
        }
        long long v31 = v77;
        long long v36 = v74;
      }
      else
      {
        uint64_t v38 = v37 >> 3;
        if (v38 >= -1) {
          unint64_t v39 = v38 + 1;
        }
        else {
          unint64_t v39 = v38 + 2;
        }
        v34 -= 8 * (v39 >> 1);
      }
    }
    *(void *)long long v34 = v36;
    v79 = v34 + 8;
    uint64_t v80 = a1[2];
    if (v80 == a1[1])
    {
      unint64_t v95 = v34;
      uint64_t v81 = v34 + 8;
LABEL_82:
      unint64_t v96 = (char *)*a1;
      *a1 = v31;
      a1[1] = v95;
      a1[2] = v81;
      a1[3] = v35;
      if (v96) {
        operator delete(v96);
      }
      goto LABEL_36;
    }
    while (1)
    {
      if (v34 == v31)
      {
        if (v79 < v35)
        {
          uint64_t v83 = (v35 - v79) >> 3;
          if (v83 >= -1) {
            unint64_t v84 = v83 + 1;
          }
          else {
            unint64_t v84 = v83 + 2;
          }
          uint64_t v81 = &v79[8 * (v84 >> 1)];
          v82 = &v34[8 * (v84 >> 1)];
          if (v79 == v34) {
            long long v34 = v79;
          }
          else {
            memmove(&v34[8 * (v84 >> 1)], v34, v79 - v34);
          }
          goto LABEL_78;
        }
        if (v35 == v34) {
          unint64_t v85 = 1;
        }
        else {
          unint64_t v85 = (v35 - v34) >> 2;
        }
        uint64_t v86 = 2 * v85;
        v87 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v85);
        long long v31 = v87;
        v82 = &v87[(v86 + 6) & 0xFFFFFFFFFFFFFFF8];
        uint64_t v81 = v82;
        uint64_t v89 = v79 - v34;
        if (v79 != v34)
        {
          uint64_t v81 = &v82[v89 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v90 = 8 * (v89 >> 3);
          BOOL v91 = v82;
          v92 = v34;
          do
          {
            uint64_t v93 = *(void *)v92;
            v92 += 8;
            *(void *)BOOL v91 = v93;
            v91 += 8;
            v90 -= 8;
          }
          while (v90);
        }
        long long v35 = &v87[8 * v88];
        operator delete(v34);
      }
      else
      {
        uint64_t v81 = v79;
        v82 = v34;
      }
      long long v34 = v31;
LABEL_78:
      long long v31 = v34;
      uint64_t v94 = *(void *)(v80 - 8);
      v80 -= 8;
      *((void *)v82 - 1) = v94;
      unint64_t v95 = v82 - 8;
      v79 = v81;
      long long v34 = v95;
      if (v80 == a1[1]) {
        goto LABEL_82;
      }
    }
  }
LABEL_37:
  unint64_t v50 = *(void *)&v4[(v9 >> 2) & 0x3FFFFFFFFFFFFFF8] + ((v9 & 0x1F) << 7);
  *(unsigned char *)unint64_t v50 = *a2;
  *(unsigned char *)(v50 + 8) = 0;
  *(_DWORD *)(v50 + 112) = -1;
  uint64_t result = std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1> const&>(v50 + 8, (uint64_t)(a2 + 8));
  *(unsigned char *)(v50 + 12CGContextBeginTransparencyLayer(c, 0) = a2[120];
  ++a1[5];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a1);
}

void SVG::createParallelBitmapContext(SVG *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, CGContext **a3@<X8>)
{
  if (a2.size.width == 0.0 || (double height = a2.size.height, a2.size.height == 0.0))
  {
    *a3 = 0;
  }
  else
  {
    double width = a2.size.width;
    double y = a2.origin.y;
    double x = a2.origin.x;
    *(void *)&long long v9 = -1;
    *((void *)&v9 + 1) = -1;
    *(_OWORD *)&v32.c = v9;
    *(_OWORD *)&v32.tdouble x = v9;
    *(_OWORD *)&v32.a = v9;
    CGContextGetCTM(&v32, this);
    CGFloat v30 = v32.ty + y * v32.d + v32.b * x;
    CGFloat v31 = v32.tx + y * v32.c + v32.a * x;
    v33.origin.double x = x;
    v33.origin.double y = y;
    v33.size.double width = width;
    v33.size.double height = height;
    CGFloat MaxX = CGRectGetMaxX(v33);
    CGFloat v29 = v32.tx + y * v32.c + v32.a * MaxX;
    CGFloat v11 = v32.ty + y * v32.d + v32.b * MaxX;
    v34.origin.double x = x;
    v34.origin.double y = y;
    v34.size.double width = width;
    v34.size.double height = height;
    CGFloat MaxY = CGRectGetMaxY(v34);
    CGFloat v13 = v32.tx + MaxY * v32.c + v32.a * x;
    CGFloat v14 = v32.ty + MaxY * v32.d + v32.b * x;
    v35.origin.double x = x;
    v35.origin.double y = y;
    v35.size.double width = width;
    v35.size.double height = height;
    double v15 = CGRectGetMaxX(v35);
    v36.origin.double x = x;
    v36.origin.double y = y;
    v36.size.double width = width;
    v36.size.double height = height;
    CGFloat v16 = CGRectGetMaxY(v36);
    CGFloat v17 = v32.tx + v16 * v32.c + v32.a * v15;
    CGFloat v18 = v32.ty + v16 * v32.d + v32.b * v15;
    double v19 = sqrt((v11 - v30) * (v11 - v30) + (v29 - v31) * (v29 - v31));
    double v20 = sqrt((v18 - v14) * (v18 - v14) + (v17 - v13) * (v17 - v13));
    double v21 = sqrt((v14 - v30) * (v14 - v30) + (v13 - v31) * (v13 - v31));
    double v22 = sqrt((v18 - v11) * (v18 - v11) + (v17 - v29) * (v17 - v29));
    if (v19 >= v20) {
      double v23 = v19;
    }
    else {
      double v23 = v20;
    }
    size_t v24 = vcvtpd_u64_f64(v23);
    if (v21 >= v22) {
      double v22 = v21;
    }
    size_t v25 = vcvtpd_u64_f64(v22);
    uint64_t v26 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    if (4 * v24 * v25 <= 0x200000)
    {
      CGRect v28 = CGBitmapContextCreate(0, v24, v25, 8uLL, 4 * v24, v26, 2u);
      long long v27 = v28;
      if (v28)
      {
        CGContextScaleCTM(v28, (double)v24 / width, (double)v25 / height);
        CGContextTranslateCTM(v27, -x, -y);
      }
    }
    else
    {
      long long v27 = 0;
    }
    *a3 = v27;
    if (v26) {
      CFRelease(v26);
    }
  }
}

void SVG::parseTransform(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = 0;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long v57 = v5;
  long long v58 = v5;
  do
  {
    unint64_t v6 = v4;
    unint64_t v4 = SVG::consumeWsp((uint64_t *)a1, v4);
  }
  while (v7);
  *(void *)&long long v8 = -1;
  *((void *)&v8 + 1) = -1;
  long long v63 = v8;
  *(_OWORD *)unint64_t v64 = v8;
  long long v62 = v8;
  *(void *)&v64[16] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v64[24] = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeTransform((uint64_t *)a1, v6, (uint64_t)&v62);
  int v9 = v64[24];
  if (v64[24])
  {
    BOOL v10 = (char *)operator new(0x30uLL);
    CGFloat v11 = v10 + 48;
    long long v12 = v63;
    *(_OWORD *)BOOL v10 = v62;
    *((_OWORD *)v10 + 1) = v12;
    *((_OWORD *)v10 + 2) = *(_OWORD *)v64;
    uint64_t v65 = v10;
    uint64_t v67 = v10 + 48;
    while (1)
    {
      uint64_t v66 = v11;
      unint64_t v6 = *(void *)&v64[16];
      unint64_t v13 = SVG::consumeCommaWspPlus((uint64_t *)a1, *(unint64_t *)&v64[16]);
      if (v14) {
        unint64_t v6 = v13;
      }
      SVG::consumeTransform((uint64_t *)a1, v6, (uint64_t)__dst);
      *(_OWORD *)&v64[9] = *(_OWORD *)((char *)v61 + 9);
      long long v62 = *(_OWORD *)__dst;
      long long v63 = v60;
      *(_OWORD *)unint64_t v64 = v61[0];
      if (!BYTE8(v61[1])) {
        break;
      }
      double v15 = v66;
      if (v66 >= v67)
      {
        CGFloat v18 = v65;
        unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v66 - v65) >> 4);
        unint64_t v20 = v19 + 1;
        if (v19 + 1 > 0x555555555555555) {
          abort();
        }
        if (0x5555555555555556 * ((v67 - v65) >> 4) > v20) {
          unint64_t v20 = 0x5555555555555556 * ((v67 - v65) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v67 - v65) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v21 = 0x555555555555555;
        }
        else {
          unint64_t v21 = v20;
        }
        if (v21)
        {
          double v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGAffineTransform>>((uint64_t)&v67, v21);
          CGFloat v18 = v65;
          double v15 = v66;
        }
        else
        {
          double v22 = 0;
        }
        double v23 = &v22[48 * v19];
        long long v24 = v62;
        long long v25 = *(_OWORD *)v64;
        *((_OWORD *)v23 + 1) = v63;
        *((_OWORD *)v23 + 2) = v25;
        *(_OWORD *)double v23 = v24;
        if (v15 == v18)
        {
          CGFloat v29 = &v22[48 * v19];
        }
        else
        {
          uint64_t v26 = &v22[48 * v19];
          do
          {
            long long v27 = *((_OWORD *)v15 - 3);
            long long v28 = *((_OWORD *)v15 - 1);
            CGFloat v29 = v26 - 48;
            *((_OWORD *)v26 - 2) = *((_OWORD *)v15 - 2);
            *((_OWORD *)v26 - 1) = v28;
            *((_OWORD *)v26 - 3) = v27;
            v15 -= 48;
            v26 -= 48;
          }
          while (v15 != v18);
        }
        CGFloat v11 = v23 + 48;
        uint64_t v65 = v29;
        uint64_t v66 = v23 + 48;
        uint64_t v67 = &v22[48 * v21];
        if (v18) {
          operator delete(v18);
        }
      }
      else
      {
        long long v16 = v62;
        long long v17 = *(_OWORD *)v64;
        *((_OWORD *)v66 + 1) = v63;
        *((_OWORD *)v15 + 2) = v17;
        *(_OWORD *)double v15 = v16;
        CGFloat v11 = v15 + 48;
      }
    }
    CGFloat v31 = v65;
    CGFloat v30 = v66;
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    __dst[1] = 0;
    *(void *)&long long v60 = 0;
    __dst[0] = 0;
    int64_t v32 = v30 - v31;
    if (v30 == v31)
    {
      unint64_t v34 = 0;
    }
    else
    {
      std::vector<CGAffineTransform>::__vallocate[abi:nn180100](__dst, 0xAAAAAAAAAAAAAAABLL * (v32 >> 4));
      CGRect v33 = __dst[1];
      memmove(__dst[1], v31, v32);
      unint64_t v34 = (unint64_t)v33 + v32;
      int64_t v32 = (int64_t)__dst[0];
    }
    *(void *)&long long v60 = 0;
    *((void *)&v60 + 1) = v6;
    __dst[0] = 0;
    __dst[1] = 0;
    if (v31) {
      operator delete(v31);
    }
    if (v65)
    {
      uint64_t v66 = v65;
      operator delete(v65);
    }
  }
  else
  {
    unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
    int64_t v32 = 0xAAAAAAAAAAAAAA00;
  }
  do
  {
    unint64_t v35 = v6;
    unint64_t v6 = SVG::consumeWsp((uint64_t *)a1, v6);
  }
  while (v36);
  uint64_t v37 = *(unsigned __int8 *)(a1 + 23);
  if ((v37 & 0x80u) != 0) {
    uint64_t v37 = *(void *)(a1 + 8);
  }
  if (v35 == v37)
  {
    v57[0] = 0;
    v57[1] = 0;
    *(void *)&long long v58 = 0;
    if (!v9)
    {
      uint64_t v42 = 0;
      unint64_t v41 = 0;
      BYTE8(v58) = 1;
      goto LABEL_49;
    }
    uint64_t v38 = v34 - v32;
    if (v34 != v32)
    {
      std::vector<CGAffineTransform>::__vallocate[abi:nn180100](v57, 0xAAAAAAAAAAAAAAABLL * (v38 >> 4));
      unint64_t v39 = (char *)v57[1];
      memmove(v57[1], (const void *)v32, v34 - v32);
      v57[1] = &v39[v38];
    }
    int v40 = 1;
    BYTE8(v58) = 1;
  }
  else
  {
    int v40 = 0;
    LOBYTE(v57[0]) = 0;
    BYTE8(v58) = 0;
    if (!v9)
    {
LABEL_47:
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 48) = 0;
      return;
    }
  }
  if (v32)
  {
    operator delete((void *)v32);
    int v40 = BYTE8(v58);
  }
  if (!v40) {
    goto LABEL_47;
  }
  uint64_t v42 = (long long *)v57[0];
  unint64_t v41 = v57[1];
LABEL_49:
  CGFloat v43 = *MEMORY[0x1E4F1DAB8];
  CGFloat v44 = *(double *)(MEMORY[0x1E4F1DAB8] + 8);
  CGFloat v45 = *(double *)(MEMORY[0x1E4F1DAB8] + 16);
  CGFloat v46 = *(double *)(MEMORY[0x1E4F1DAB8] + 24);
  CGFloat v48 = *(double *)(MEMORY[0x1E4F1DAB8] + 32);
  CGFloat v47 = *(double *)(MEMORY[0x1E4F1DAB8] + 40);
  int64_t v49 = v41 - (unsigned char *)v42;
  if (v49)
  {
    unint64_t v50 = v49 / 48;
    if (v50 <= 1) {
      uint64_t v51 = 1;
    }
    else {
      uint64_t v51 = v50;
    }
    unint64_t v52 = v42;
    do
    {
      long long v53 = *v52;
      long long v54 = v52[2];
      *(_OWORD *)&t1.c = v52[1];
      *(_OWORD *)&t1.tdouble x = v54;
      *(_OWORD *)&t1.a = v53;
      v55.a = v43;
      v55.b = v44;
      v55.c = v45;
      v55.d = v46;
      v55.tdouble x = v48;
      v55.tdouble y = v47;
      CGAffineTransformConcat((CGAffineTransform *)&v62, &t1, &v55);
      CGFloat v44 = *((double *)&v62 + 1);
      CGFloat v43 = *(double *)&v62;
      CGFloat v46 = *((double *)&v63 + 1);
      CGFloat v45 = *(double *)&v63;
      v52 += 3;
      CGFloat v48 = *(double *)v64;
      CGFloat v47 = *(double *)&v64[8];
      --v51;
    }
    while (v51);
  }
  *(CGFloat *)a2 = v43;
  *(CGFloat *)(a2 + 8) = v44;
  *(CGFloat *)(a2 + 16) = v45;
  *(CGFloat *)(a2 + 24) = v46;
  *(CGFloat *)(a2 + 32) = v48;
  *(CGFloat *)(a2 + 4CGContextBeginTransparencyLayer(c, 0) = v47;
  *(unsigned char *)(a2 + 48) = 1;
  if (v42)
  {
    v57[1] = v42;
    operator delete(v42);
  }
}

CGAffineTransform *SVG::invert@<X0>(CGAffineTransform *this@<X0>, uint64_t a2@<X8>)
{
  if (fabs(this->a * this->d - this->b * this->c) <= 2.22044605e-16)
  {
    char v5 = 0;
    *(unsigned char *)a2 = 0;
  }
  else
  {
    long long v4 = *(_OWORD *)&this->c;
    *(_OWORD *)&v6.a = *(_OWORD *)&this->a;
    *(_OWORD *)&v6.c = v4;
    *(_OWORD *)&v6.tdouble x = *(_OWORD *)&this->tx;
    this = CGAffineTransformInvert((CGAffineTransform *)a2, &v6);
    char v5 = 1;
  }
  *(unsigned char *)(a2 + 48) = v5;
  return this;
}

void SVG::consumeTransform(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)&long long v6 = -1;
  *((void *)&v6 + 1) = -1;
  *(_OWORD *)(a3 + 32) = v6;
  char v7 = (void *)(a3 + 32);
  *(void *)(a3 + 48) = 0xAAAAAAAAAAAAAAAALL;
  long long v8 = (void *)(a3 + 48);
  *(_OWORD *)a3 = v6;
  *(_OWORD *)(a3 + 16) = v6;
  *(void *)(a3 + 56) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v9 = SVG::consumeString<7ul>((uint64_t)"matrix", (uint64_t)a1, a2);
  if (v10)
  {
    do
    {
      uint64_t v11 = v9;
      unint64_t v9 = SVG::consumeWsp(a1, v9);
    }
    while (v12);
    *(double *)&unint64_t v13 = COERCE_DOUBLE(SVG::consumeString<2ul>("(", a1, v11));
    if (v14)
    {
      do
      {
        CGFloat b = *(double *)&v13;
        *(double *)&unint64_t v13 = COERCE_DOUBLE(SVG::consumeWsp(a1, v13));
      }
      while (v16);
      uint64_t v17 = 0;
      *(void *)&long long v18 = -1;
      *((void *)&v18 + 1) = -1;
      *(_OWORD *)&v128.CGFloat c = v18;
      *(_OWORD *)&v128.tdouble x = v18;
      *(_OWORD *)&v128.CGFloat a = v18;
      while (1)
      {
        if (v17)
        {
          *(double *)&unint64_t v19 = COERCE_DOUBLE(SVG::consumeCommaWsp(a1, *(unint64_t *)&b));
          if (v20) {
            CGFloat b = *(double *)&v19;
          }
        }
        v127.CGFloat a = NAN;
        v127.CGFloat b = -3.72066208e-103;
        v127.CGFloat c = -3.72066208e-103;
        SVG::consumePathNumber((uint64_t)a1, *(unint64_t *)&b, (uint64_t)&v127);
        if (!LOBYTE(v127.c)) {
          break;
        }
        *(CGFloat *)((char *)&v128.a + v17) = v127.a;
        CGFloat b = v127.b;
        v17 += 8;
        if (v17 == 48)
        {
          CGFloat a = v128.a;
          CGFloat v22 = v128.b;
          CGFloat c = v128.c;
          CGFloat d = v128.d;
          tdouble x = v128.tx;
          tdouble y = v128.ty;
          do
          {
            uint64_t v27 = *(void *)&b;
            CGFloat b = COERCE_DOUBLE(SVG::consumeWsp(a1, *(unint64_t *)&b));
          }
          while (v28);
          unint64_t v29 = SVG::consumeString<2ul>(")", a1, v27);
          *(CGFloat *)a3 = a;
          *(CGFloat *)(a3 + 8) = v22;
          *(CGFloat *)(a3 + 16) = c;
          *(CGFloat *)(a3 + 24) = d;
          *(CGFloat *)(a3 + 32) = tx;
          *(CGFloat *)(a3 + 4CGContextBeginTransparencyLayer(c, 0) = ty;
          *(void *)(a3 + 48) = v29;
          goto LABEL_72;
        }
      }
    }
  }
  *(void *)&long long v30 = -1;
  *((void *)&v30 + 1) = -1;
  *(_OWORD *)(a3 + 16) = v30;
  *(_OWORD *)(a3 + 32) = v30;
  *(_OWORD *)a3 = v30;
  *long long v8 = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v31 = SVG::consumeString<10ul>((uint64_t)"translate", (uint64_t)a1, a2);
  if (v32)
  {
    do
    {
      uint64_t v33 = v31;
      unint64_t v31 = SVG::consumeWsp(a1, v31);
    }
    while (v34);
    unint64_t v35 = SVG::consumeString<2ul>("(", a1, v33);
    if (v36)
    {
      do
      {
        unint64_t v37 = v35;
        unint64_t v35 = SVG::consumeWsp(a1, v35);
      }
      while (v38);
      v128.CGFloat a = NAN;
      v128.CGFloat b = -3.72066208e-103;
      v128.CGFloat c = -3.72066208e-103;
      SVG::consumePathNumber((uint64_t)a1, v37, (uint64_t)&v128);
      if (LOBYTE(v128.c))
      {
        CGFloat v39 = v128.a;
        CGFloat v40 = v128.b;
        unint64_t v41 = SVG::consumeCommaWsp(a1, *(unint64_t *)&v128.b);
        if (v42)
        {
          v127.CGFloat a = NAN;
          v127.CGFloat b = -3.72066208e-103;
          v127.CGFloat c = -3.72066208e-103;
          SVG::consumePathNumber((uint64_t)a1, v41, (uint64_t)&v127);
          if (LOBYTE(v127.c))
          {
            CGFloat v40 = v127.b;
            double v43 = v127.a;
          }
          else
          {
            double v43 = 0.0;
          }
        }
        else
        {
          double v43 = 0.0;
        }
        do
        {
          uint64_t v44 = *(void *)&v40;
          CGFloat v40 = COERCE_DOUBLE(SVG::consumeWsp(a1, *(unint64_t *)&v40));
        }
        while (v45);
        unint64_t v46 = SVG::consumeString<2ul>(")", a1, v44);
        if (v47)
        {
          unint64_t v48 = v46;
          CGAffineTransformMakeTranslation((CGAffineTransform *)a3, v39, v43);
LABEL_71:
          *(void *)(a3 + 48) = v48;
LABEL_72:
          *(unsigned char *)(a3 + 56) = 1;
          return;
        }
      }
    }
  }
  *(void *)&long long v49 = -1;
  *((void *)&v49 + 1) = -1;
  *(_OWORD *)(a3 + 16) = v49;
  *(_OWORD *)(a3 + 32) = v49;
  *(_OWORD *)a3 = v49;
  *long long v8 = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v50 = SVG::consumeString<6ul>((uint64_t)"scale", (uint64_t)a1, a2);
  if (v51)
  {
    do
    {
      uint64_t v52 = v50;
      unint64_t v50 = SVG::consumeWsp(a1, v50);
    }
    while (v53);
    unint64_t v54 = SVG::consumeString<2ul>("(", a1, v52);
    if (v55)
    {
      do
      {
        unint64_t v56 = v54;
        unint64_t v54 = SVG::consumeWsp(a1, v54);
      }
      while (v57);
      v128.CGFloat a = NAN;
      v128.CGFloat b = -3.72066208e-103;
      v128.CGFloat c = -3.72066208e-103;
      SVG::consumePathNumber((uint64_t)a1, v56, (uint64_t)&v128);
      if (LOBYTE(v128.c))
      {
        double v58 = v128.a;
        CGFloat v59 = v128.b;
        unint64_t v60 = SVG::consumeCommaWsp(a1, *(unint64_t *)&v128.b);
        if (v61)
        {
          v127.CGFloat a = NAN;
          v127.CGFloat b = -3.72066208e-103;
          v127.CGFloat c = -3.72066208e-103;
          SVG::consumePathNumber((uint64_t)a1, v60, (uint64_t)&v127);
          if (LOBYTE(v127.c))
          {
            CGFloat v59 = v127.b;
            double v62 = v127.a;
          }
          else
          {
            double v62 = v58;
          }
        }
        else
        {
          double v62 = v58;
        }
        do
        {
          uint64_t v63 = *(void *)&v59;
          CGFloat v59 = COERCE_DOUBLE(SVG::consumeWsp(a1, *(unint64_t *)&v59));
        }
        while (v64);
        unint64_t v65 = SVG::consumeString<2ul>(")", a1, v63);
        if (v66)
        {
          unint64_t v48 = v65;
          CGAffineTransformMakeScale((CGAffineTransform *)a3, v58, v62);
          goto LABEL_71;
        }
      }
    }
  }
  *(void *)&long long v67 = -1;
  *((void *)&v67 + 1) = -1;
  *(_OWORD *)(a3 + 16) = v67;
  *(_OWORD *)(a3 + 32) = v67;
  *(_OWORD *)a3 = v67;
  *long long v8 = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v68 = SVG::consumeString<7ul>((uint64_t)"rotate", (uint64_t)a1, a2);
  if (v69)
  {
    do
    {
      uint64_t v70 = v68;
      unint64_t v68 = SVG::consumeWsp(a1, v68);
    }
    while (v71);
    unint64_t v72 = SVG::consumeString<2ul>("(", a1, v70);
    if (v73)
    {
      do
      {
        unint64_t v74 = v72;
        unint64_t v72 = SVG::consumeWsp(a1, v72);
      }
      while (v75);
      *(double *)&uint64_t v123 = NAN;
      double v124 = -3.72066208e-103;
      unint64_t v125 = 0xAAAAAAAAAAAAAAAALL;
      SVG::consumePathNumber((uint64_t)a1, v74, (uint64_t)&v123);
      if ((_BYTE)v125)
      {
        double v76 = *(double *)&v123;
        CGFloat v77 = v124;
        unint64_t v78 = SVG::consumeCommaWsp(a1, *(unint64_t *)&v124);
        if (v79)
        {
          v128.CGFloat a = NAN;
          v128.CGFloat b = -3.72066208e-103;
          v128.CGFloat c = -3.72066208e-103;
          SVG::consumePathNumber((uint64_t)a1, v78, (uint64_t)&v128);
          double v80 = 0.0;
          if (LOBYTE(v128.c))
          {
            unint64_t v81 = SVG::consumeCommaWsp(a1, *(unint64_t *)&v128.b);
            double v82 = 0.0;
            if (v83)
            {
              v127.CGFloat a = NAN;
              v127.CGFloat b = -3.72066208e-103;
              v127.CGFloat c = -3.72066208e-103;
              SVG::consumePathNumber((uint64_t)a1, v81, (uint64_t)&v127);
              double v80 = LOBYTE(v127.c) ? v128.a : 0.0;
              double v82 = LOBYTE(v127.c) ? v127.a : 0.0;
              if (LOBYTE(v127.c)) {
                CGFloat v77 = v127.b;
              }
            }
            do
            {
LABEL_59:
              uint64_t v84 = *(void *)&v77;
              CGFloat v77 = COERCE_DOUBLE(SVG::consumeWsp(a1, *(unint64_t *)&v77));
            }
            while (v85);
            unint64_t v86 = SVG::consumeString<2ul>(")", a1, v84);
            if (v87)
            {
              unint64_t v48 = v86;
              *(void *)&long long v88 = -1;
              *((void *)&v88 + 1) = -1;
              *(_OWORD *)&v122.CGFloat a = v88;
              *(_OWORD *)&v122.CGFloat c = v88;
              *(_OWORD *)&v122.tdouble x = v88;
              CGAffineTransformMakeTranslation(&v122, v80, v82);
              CGAffineTransform v127 = v122;
              CGAffineTransformRotate(&v128, &v127, v76 / 180.0 * 3.14159265);
              CGAffineTransform v122 = v128;
              CGAffineTransform v126 = v128;
              CGAffineTransformTranslate(&v128, &v126, -v80, -v82);
              long long v90 = *(_OWORD *)&v128.c;
              long long v89 = *(_OWORD *)&v128.tx;
              CGAffineTransform v122 = v128;
              *(_OWORD *)a3 = *(_OWORD *)&v128.a;
              *(_OWORD *)(a3 + 16) = v90;
              *(_OWORD *)(a3 + 32) = v89;
              goto LABEL_71;
            }
            goto LABEL_62;
          }
        }
        else
        {
          double v80 = 0.0;
        }
        double v82 = 0.0;
        goto LABEL_59;
      }
    }
  }
LABEL_62:
  *(void *)&long long v91 = -1;
  *((void *)&v91 + 1) = -1;
  *(_OWORD *)(a3 + 16) = v91;
  *(_OWORD *)(a3 + 32) = v91;
  *(_OWORD *)a3 = v91;
  *long long v8 = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v92 = SVG::consumeString<6ul>((uint64_t)"skewX", (uint64_t)a1, a2);
  if (v93)
  {
    do
    {
      uint64_t v94 = v92;
      unint64_t v92 = SVG::consumeWsp(a1, v92);
    }
    while (v95);
    unint64_t v96 = SVG::consumeString<2ul>("(", a1, v94);
    if (v97)
    {
      do
      {
        unint64_t v98 = v96;
        unint64_t v96 = SVG::consumeWsp(a1, v96);
      }
      while (v99);
      v128.CGFloat a = NAN;
      v128.CGFloat b = -3.72066208e-103;
      v128.CGFloat c = -3.72066208e-103;
      SVG::consumePathNumber((uint64_t)a1, v98, (uint64_t)&v128);
      if (LOBYTE(v128.c))
      {
        CGFloat v100 = v128.b;
        do
        {
          uint64_t v101 = *(void *)&v100;
          CGFloat v100 = COERCE_DOUBLE(SVG::consumeWsp(a1, *(unint64_t *)&v100));
        }
        while (v102);
        unint64_t v103 = SVG::consumeString<2ul>(")", a1, v101);
        if (v104)
        {
          unint64_t v48 = v103;
          long double v105 = tan(v128.a / 180.0 * 3.14159265);
          *char v7 = 0;
          v7[1] = 0;
          *(_OWORD *)a3 = xmmword_1BF1DA530;
          *(long double *)(a3 + 16) = v105;
          *(void *)(a3 + 24) = 0x3FF0000000000000;
          goto LABEL_71;
        }
      }
    }
  }
  *(void *)&long long v106 = -1;
  *((void *)&v106 + 1) = -1;
  *(_OWORD *)(a3 + 16) = v106;
  *(_OWORD *)(a3 + 32) = v106;
  *(_OWORD *)a3 = v106;
  *long long v8 = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v107 = SVG::consumeString<6ul>((uint64_t)"skewY", (uint64_t)a1, a2);
  if (v108)
  {
    do
    {
      uint64_t v109 = v107;
      unint64_t v107 = SVG::consumeWsp(a1, v107);
    }
    while (v110);
    unint64_t v111 = SVG::consumeString<2ul>("(", a1, v109);
    if (v112)
    {
      do
      {
        unint64_t v113 = v111;
        unint64_t v111 = SVG::consumeWsp(a1, v111);
      }
      while (v114);
      v128.CGFloat a = NAN;
      v128.CGFloat b = -3.72066208e-103;
      v128.CGFloat c = -3.72066208e-103;
      SVG::consumePathNumber((uint64_t)a1, v113, (uint64_t)&v128);
      if (LOBYTE(v128.c))
      {
        CGFloat v115 = v128.b;
        do
        {
          uint64_t v116 = *(void *)&v115;
          CGFloat v115 = COERCE_DOUBLE(SVG::consumeWsp(a1, *(unint64_t *)&v115));
        }
        while (v117);
        unint64_t v118 = SVG::consumeString<2ul>(")", a1, v116);
        if (v119)
        {
          unint64_t v120 = v118;
          long double v121 = tan(v128.a / 180.0 * 3.14159265);
          *char v7 = 0;
          v7[1] = 0;
          *(void *)a3 = 0x3FF0000000000000;
          *(long double *)(a3 + 8) = v121;
          *(_OWORD *)(a3 + 16) = xmmword_1BF1DA540;
          *(void *)(a3 + 48) = v120;
          goto LABEL_72;
        }
      }
    }
  }
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 56) = 0;
}

unint64_t SVG::consumeCommaWspPlus(uint64_t *a1, unint64_t a2)
{
  unint64_t v3 = SVG::consumeCommaWsp(a1, a2);
  if (!v4) {
    return 0;
  }
  do
  {
    unint64_t v5 = v3;
    unint64_t v3 = SVG::consumeCommaWsp(a1, v3);
  }
  while (v6);
  return v5;
}

char *std::vector<CGAffineTransform>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGAffineTransform>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

uint64_t SVG::GElement::GElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)a1 = &unk_1F1A74C10;
  uint64_t v6 = MEMORY[0x1E4F1DAB8];
  long long v7 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = *MEMORY[0x1E4F1DAB8];
  *(_OWORD *)(a1 + 656) = v7;
  *(_OWORD *)(a1 + 672) = *(_OWORD *)(v6 + 32);
  std::string::basic_string[abi:nn180100]<0>(__p, "transform");
  std::string::basic_string[abi:nn180100]<0>(v16, "http://www.w3.org/2000/svg");
  long long v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)__p, (uint64_t)v16);
  if (v17 < 0) {
    operator delete(v16[0]);
  }
  if (SBYTE7(v13) < 0)
  {
    operator delete(__p[0]);
    if (!v8) {
      return a1;
    }
  }
  else if (!v8)
  {
    return a1;
  }
  *(void *)&long long v9 = -1;
  *((void *)&v9 + 1) = -1;
  long long v13 = v9;
  long long v14 = v9;
  *(_OWORD *)long long __p = v9;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  SVG::parseTransform((uint64_t)(v8 + 64), (uint64_t)__p);
  if ((_BYTE)v15)
  {
    long long v10 = v13;
    *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)__p;
    *(_OWORD *)(a1 + 656) = v10;
    *(_OWORD *)(a1 + 672) = v14;
  }
  return a1;
}

uint64_t SVG::GElement::appendChild(int64x2_t *a1, const void **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)*a2;
  {
    uint64_t v6 = *a2;
    if (!*a2
    {
      return 0;
    }
  }
  return SVG::Element::appendChild(a1, (uint64_t *)a2);
}

void SVG::GElement::~GElement(SVG::GElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75438 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75450 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75468 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75450 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75468 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75438 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75450 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75468 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75450 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75468 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

uint64_t SVG::GElement::isStructural(SVG::GElement *this)
{
  return 1;
}

void SVG::GradientElement::parseAttributes(void *a1, void *a2)
{
  std::string::basic_string[abi:nn180100]<0>(v31, "gradientUnits");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v4 = SVG::Element::findInAttributeMap(a2, (uint64_t)v31, (uint64_t)__p);
  if (v35 < 0) {
    operator delete(__p[0]);
  }
  if ((v31[23] & 0x80000000) != 0) {
    operator delete(*(void **)v31);
  }
  if (v4)
  {
    uint64_t v5 = SVG::parseUnits((uint64_t)(v4 + 64));
    if ((v5 & 0xFF00000000) != 0)
    {
      int v6 = v5;
      uint64_t v7 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
      *(_DWORD *)uint64_t v7 = v6;
      *(unsigned char *)(v7 + 4) = 1;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v31, "gradientTransform");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v8 = SVG::Element::findInAttributeMap(a2, (uint64_t)v31, (uint64_t)__p);
  if (v35 < 0) {
    operator delete(__p[0]);
  }
  if ((v31[23] & 0x80000000) != 0) {
    operator delete(*(void **)v31);
  }
  if (v8)
  {
    *(void *)&long long v9 = -1;
    *((void *)&v9 + 1) = -1;
    *(_OWORD *)&v31[16] = v9;
    long long v32 = v9;
    *(_OWORD *)unint64_t v31 = v9;
    unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
    SVG::parseTransform((uint64_t)(v8 + 64), (uint64_t)v31);
    if ((_BYTE)v33)
    {
      uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
      int v11 = *(unsigned __int8 *)(v10 + 56);
      long long v12 = *(_OWORD *)&v31[16];
      *(_OWORD *)(v10 + 8) = *(_OWORD *)v31;
      *(_OWORD *)(v10 + 24) = v12;
      *(_OWORD *)(v10 + 4CGContextBeginTransparencyLayer(c, 0) = v32;
      if (!v11) {
        *(unsigned char *)(v10 + 56) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v31, "spreadMethod");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  long long v13 = SVG::Element::findInAttributeMap(a2, (uint64_t)v31, (uint64_t)__p);
  if (v35 < 0) {
    operator delete(__p[0]);
  }
  if ((v31[23] & 0x80000000) != 0) {
    operator delete(*(void **)v31);
  }
  if (v13)
  {
    unint64_t v14 = 0;
    do
    {
      uint64_t v15 = v14;
      unint64_t v14 = SVG::consumeWsp((uint64_t *)v13 + 8, v14);
    }
    while (v16);
    memset(v31, 170, 24);
    SVG::consumeSpreadMethod((uint64_t)(v13 + 64), v15, (uint64_t)v31);
    if (v31[16])
    {
      unint64_t v17 = *(void *)&v31[8];
      do
      {
        unint64_t v18 = v17;
        unint64_t v17 = SVG::consumeWsp((uint64_t *)v13 + 8, v17);
      }
      while (v19);
      uint64_t v20 = v13[87];
      if ((v20 & 0x80u) != 0) {
        uint64_t v20 = *((void *)v13 + 9);
      }
      if (v18 == v20)
      {
        int v21 = *(_DWORD *)v31;
        uint64_t v22 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
        *(_DWORD *)(v22 + 64) = v21;
        *(unsigned char *)(v22 + 68) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v31, "href");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/1999/xlink");
  double v23 = SVG::Element::findInAttributeMap(a2, (uint64_t)v31, (uint64_t)__p);
  if (v35 < 0) {
    operator delete(__p[0]);
  }
  if ((v31[23] & 0x80000000) != 0) {
    operator delete(*(void **)v31);
  }
  if (v23)
  {
    CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if ((char)v23[87] < 0)
    {
      long long v25 = (const UInt8 *)*((void *)v23 + 8);
      CFIndex v26 = *((void *)v23 + 9);
    }
    else
    {
      long long v25 = v23 + 64;
      CFIndex v26 = v23[87];
    }
    CFStringRef v27 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v25, v26, 0x8000100u, 1u);
    if (v27)
    {
      CFStringRef v28 = v27;
      CFURLRef v29 = CFURLCreateWithString(v24, v27, 0);
      long long v30 = (const void *)a1[80];
      if (v30) {
        CFRelease(v30);
      }
      a1[80] = v29;
      CFRelease(v28);
    }
  }
}

uint64_t SVG::GradientElement::appendChild(int64x2_t *a1, const void **a2)
{
  if (!*a2
  {
    return 0;
  }
  return SVG::Element::appendChild(a1, (uint64_t *)a2);
}

void SVG::GradientElement::getGradient(unint64_t a1@<X0>, void *a2@<X1>, void *a3@<X2>, const __CFArray *a4@<X3>, CGGradientRef *a5@<X8>)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  cf = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  __dst[0] = (void *)a1;
  unint64_t v92 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(a3, __dst);
  char v8 = (char *)operator new(8uLL);
  *(void *)char v8 = a1;
  long long v9 = v8 + 8;
  memset(__dst, 0, 32);
  __dst[4] = (void *)0xAAAAAAAA3F800000;
  unint64_t v10 = 0x9DDFEA08EB382D69 * (((((a1 >> 3) & 0x3FFFFFF) << 6) | 8) ^ HIDWORD(a1));
  unint64_t v11 = 0x9DDFEA08EB382D69 * (HIDWORD(a1) ^ (v10 >> 47) ^ v10);
  unint64_t v12 = 0x9DDFEA08EB382D69 * (v11 ^ (v11 >> 47));
  long long v13 = operator new(0x18uLL);
  v13[1] = v12;
  void v13[2] = a1;
  std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>((uint64_t)__dst, 1uLL);
  unint64_t v14 = (unint64_t)__dst[1];
  uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)__dst[1]);
  v15.i16[0] = vaddlv_u8(v15);
  if (v15.u32[0] > 1uLL)
  {
    if ((void *)v12 >= __dst[1]) {
      v12 %= (unint64_t)__dst[1];
    }
  }
  else
  {
    v12 &= (unint64_t)__dst[1] - 1;
  }
  char v16 = __dst[0];
  unint64_t v17 = (void *)*((void *)__dst[0] + v12);
  if (v17)
  {
    *long long v13 = *v17;
  }
  else
  {
    *long long v13 = __dst[2];
    _OWORD __dst[2] = v13;
    v16[v12] = &__dst[2];
    if (!*v13) {
      goto LABEL_14;
    }
    unint64_t v18 = *(void *)(*v13 + 8);
    if (v15.u32[0] > 1uLL)
    {
      if (v18 >= v14) {
        v18 %= v14;
      }
    }
    else
    {
      v18 &= v14 - 1;
    }
    unint64_t v17 = (char *)__dst[0] + 8 * v18;
  }
  *unint64_t v17 = v13;
LABEL_14:
  ++__dst[3];
  *(void *)&v130[0] = *(void *)(*(void *)v8 + 640);
  if (*(void *)&v130[0])
  {
    char v19 = v8 + 8;
    while (1)
    {
      uint64_t v20 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(a2, v130);
      if (!v20) {
        break;
      }
      if (!v21) {
        goto LABEL_93;
      }
      unint64_t v22 = v21;
      unint64_t v23 = (unint64_t)__dst[1];
      unint64_t v24 = 0x9DDFEA08EB382D69 * (((8 * v21) + 8) ^ HIDWORD(v21));
      unint64_t v25 = 0x9DDFEA08EB382D69 * (HIDWORD(v21) ^ (v24 >> 47) ^ v24);
      unint64_t v26 = 0x9DDFEA08EB382D69 * (v25 ^ (v25 >> 47));
      if (__dst[1])
      {
        uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)__dst[1]);
        v27.i16[0] = vaddlv_u8(v27);
        if (v27.u32[0] > 1uLL)
        {
          unint64_t v28 = 0x9DDFEA08EB382D69 * (v25 ^ (v25 >> 47));
          if ((void *)v26 >= __dst[1]) {
            unint64_t v28 = v26 % (unint64_t)__dst[1];
          }
        }
        else
        {
          unint64_t v28 = ((unint64_t)__dst[1] - 1) & v26;
        }
        long long v30 = (void *)*((void *)__dst[0] + v28);
        if (v30)
        {
          for (unint64_t i = (void *)*v30; i; unint64_t i = (void *)*i)
          {
            unint64_t v32 = i[1];
            if (v32 == v26)
            {
              if (i[2] == v21) {
                goto LABEL_93;
              }
            }
            else
            {
              if (v27.u32[0] > 1uLL)
              {
                if ((void *)v32 >= __dst[1]) {
                  v32 %= (unint64_t)__dst[1];
                }
              }
              else
              {
                v32 &= (unint64_t)__dst[1] - 1;
              }
              if (v32 != v28) {
                break;
              }
            }
          }
        }
        if (v27.u32[0] > 1uLL)
        {
          unint64_t v29 = 0x9DDFEA08EB382D69 * (v25 ^ (v25 >> 47));
          if ((void *)v26 >= __dst[1]) {
            unint64_t v29 = v26 % (unint64_t)__dst[1];
          }
        }
        else
        {
          unint64_t v29 = ((unint64_t)__dst[1] - 1) & v26;
        }
        unint64_t v33 = (void *)*((void *)__dst[0] + v29);
        if (v33)
        {
          for (j = (void *)*v33; j; j = (void *)*j)
          {
            unint64_t v35 = j[1];
            if (v35 == v26)
            {
              if (j[2] == v21) {
                goto LABEL_72;
              }
            }
            else
            {
              if (v27.u32[0] > 1uLL)
              {
                if ((void *)v35 >= __dst[1]) {
                  v35 %= (unint64_t)__dst[1];
                }
              }
              else
              {
                v35 &= (unint64_t)__dst[1] - 1;
              }
              if (v35 != v29) {
                break;
              }
            }
          }
        }
      }
      else
      {
        unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
      }
      char v36 = operator new(0x18uLL);
      *char v36 = 0;
      v36[1] = v26;
      v36[2] = v22;
      float v37 = (float)((unint64_t)__dst[3] + 1);
      if (!v23 || (float)(*(float *)&__dst[4] * (float)v23) < v37)
      {
        BOOL v38 = (v23 & (v23 - 1)) != 0;
        if (v23 < 3) {
          BOOL v38 = 1;
        }
        unint64_t v39 = v38 | (2 * v23);
        unint64_t v40 = vcvtps_u32_f32(v37 / *(float *)&__dst[4]);
        if (v39 <= v40) {
          size_t v41 = v40;
        }
        else {
          size_t v41 = v39;
        }
        std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>((uint64_t)__dst, v41);
        unint64_t v23 = (unint64_t)__dst[1];
        if (((unint64_t)__dst[1] & ((unint64_t)__dst[1] - 1)) != 0)
        {
          if ((void *)v26 >= __dst[1]) {
            unint64_t v29 = v26 % (unint64_t)__dst[1];
          }
          else {
            unint64_t v29 = v26;
          }
        }
        else
        {
          unint64_t v29 = ((unint64_t)__dst[1] - 1) & v26;
        }
      }
      char v42 = __dst[0];
      double v43 = (void *)*((void *)__dst[0] + v29);
      if (v43)
      {
        *char v36 = *v43;
      }
      else
      {
        *char v36 = __dst[2];
        _OWORD __dst[2] = v36;
        v42[v29] = &__dst[2];
        if (!*v36) {
          goto LABEL_71;
        }
        unint64_t v44 = *(void *)(*v36 + 8);
        if ((v23 & (v23 - 1)) != 0)
        {
          if (v44 >= v23) {
            v44 %= v23;
          }
        }
        else
        {
          v44 &= v23 - 1;
        }
        double v43 = (char *)__dst[0] + 8 * v44;
      }
      *double v43 = v36;
LABEL_71:
      ++__dst[3];
LABEL_72:
      if (v9 >= v19)
      {
        uint64_t v46 = (v9 - v8) >> 3;
        unint64_t v47 = v46 + 1;
        if ((unint64_t)(v46 + 1) >> 61) {
          goto LABEL_239;
        }
        if ((v19 - v8) >> 2 > v47) {
          unint64_t v47 = (v19 - v8) >> 2;
        }
        if ((unint64_t)(v19 - v8) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v48 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v48 = v47;
        }
        if (v48)
        {
          if (v48 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          long long v49 = (char *)operator new(8 * v48);
        }
        else
        {
          long long v49 = 0;
        }
        unint64_t v50 = &v49[8 * v46];
        char v19 = &v49[8 * v48];
        *(void *)unint64_t v50 = v22;
        char v45 = v50 + 8;
        if (v9 == v8) {
          goto LABEL_87;
        }
        do
        {
          uint64_t v51 = *((void *)v9 - 1);
          v9 -= 8;
          *((void *)v50 - 1) = v51;
          v50 -= 8;
        }
        while (v9 != v8);
        if (v8) {
LABEL_87:
        }
          operator delete(v8);
        char v8 = v50;
      }
      else
      {
        *(void *)long long v9 = v22;
        char v45 = v9 + 8;
      }
      *(void *)&v130[0] = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&v130[0] = *(void *)(*((void *)v45 - 1) + 640);
      long long v9 = v45;
      if (!*(void *)&v130[0]) {
        goto LABEL_92;
      }
    }
  }
  char v45 = v9;
LABEL_92:
  long long v9 = v45;
LABEL_93:
  uint64_t v52 = __dst[2];
  if (__dst[2])
  {
    do
    {
      char v53 = (void *)*v52;
      operator delete(v52);
      uint64_t v52 = v53;
    }
    while (v53);
  }
  unint64_t v54 = __dst[0];
  __dst[0] = 0;
  if (v54) {
    operator delete(v54);
  }
  memcpy(__dst, &unk_1BF1DA560, sizeof(__dst));
  LODWORD(__dst[1]) = 0;
  LODWORD(__dst[6]) = 0;
  LODWORD(__dst[8]) = 0;
  LODWORD(__dst[10]) = 0;
  __dst[11] = 0;
  HIDWORD(__dst[12]) = 0;
  LODWORD(__dst[25]) = 0;
  LODWORD(__dst[26]) = 0;
  LODWORD(__dst[27]) = 0;
  LODWORD(__dst[31]) = 0;
  LODWORD(__dst[33]) = 0;
  LODWORD(__dst[34]) = 0;
  LODWORD(__dst[35]) = 0;
  HIDWORD(__dst[38]) = 0;
  LODWORD(__dst[40]) = 0;
  LODWORD(__dst[41]) = 0;
  LODWORD(__dst[42]) = 0;
  LODWORD(__dst[44]) = 0;
  LODWORD(__dst[50]) = 0;
  LODWORD(__dst[52]) = 0;
  LODWORD(__dst[56]) = 0;
  LODWORD(__dst[58]) = 0;
  LODWORD(__dst[60]) = 0;
  LODWORD(__dst[64]) = 0;
  LODWORD(__dst[65]) = 0;
  LODWORD(__dst[66]) = 0;
  LODWORD(__dst[68]) = 0;
  LODWORD(__dst[70]) = 0;
  uint64_t v162 = 0;
  memset(&__dst[14], 0, 28);
  LODWORD(__dst[19]) = 0;
  __dst[29] = 0;
  __dst[28] = 0;
  __dst[36] = 0;
  __dst[37] = 0;
  memset(&__dst[61], 0, 20);
  if (v9 != v8)
  {
    char v55 = v9;
    do
    {
      uint64_t v56 = *((void *)v55 - 1);
      v55 -= 8;
      SVG::Presentation::specifiedInherit((SVG::Presentation *)(v56 + 64), (const SVG::Presentation *)__dst, v130);
      *(_OWORD *)__dst = v130[0];
      *(_OWORD *)&_OWORD __dst[2] = v130[1];
      *(_OWORD *)&__dst[4] = v130[2];
      __dst[6] = v131;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>((uint64_t)&__dst[8], (uint64_t)v132);
      *(_OWORD *)&__dst[11] = v134;
      *(_OWORD *)&__dst[13] = v135;
      *(_OWORD *)&__dst[15] = v136;
      LODWORD(__dst[17]) = v137;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>((uint64_t)&__dst[19], (uint64_t)v138);
      *(_OWORD *)&__dst[26] = v140;
      *(_OWORD *)&__dst[28] = v141;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>((uint64_t)&__dst[31], (uint64_t)v142);
      *(_OWORD *)&__dst[38] = v146;
      *(_OWORD *)&__dst[40] = v147;
      __dst[42] = v148;
      *(_OWORD *)&__dst[34] = v144;
      *(_OWORD *)&__dst[36] = v145;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>((uint64_t)&__dst[44], (uint64_t)v149);
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1>>((uint64_t)&__dst[52], (uint64_t)v151);
      *(_OWORD *)&__dst[65] = v157;
      *(_OWORD *)&__dst[67] = v158;
      *(_OWORD *)&__dst[69] = v159;
      uint64_t v162 = v160;
      *(_OWORD *)&__dst[57] = v153;
      *(_OWORD *)&__dst[59] = v154;
      *(_OWORD *)&__dst[61] = v155;
      *(_OWORD *)&__dst[63] = v156;
      if (v152 != -1) {
        ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A754B0 + v152))(v111, v151);
      }
      unsigned int v152 = -1;
      if (v150 != -1) {
        ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A75498 + v150))(v111, v149);
      }
      unsigned int v150 = -1;
      if (v143 != -1) {
        ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A75480 + v143))(v111, v142);
      }
      unsigned int v143 = -1;
      if (v139 != -1) {
        ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A75498 + v139))(v111, v138);
      }
      unsigned int v139 = -1;
      if (v133 != -1) {
        ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A75480 + v133))(v111, v132);
      }
    }
    while (v55 != v8);
  }
  SVG::Presentation::defaultPresentation((uint64_t)v111);
  SVG::Presentation::inherit((SVG::Presentation *)__dst, (const SVG::Presentation *)(v92 + 3), (const SVG::Presentation *)v111, v130);
  if (v129 != -1) {
    ((void (*)(void *, unsigned char *))*(&off_1F1A754B0 + v129))(v100, v128);
  }
  unsigned int v129 = -1;
  if (v127 != -1) {
    ((void (*)(void *, unsigned char *))*(&off_1F1A75498 + v127))(v100, v126);
  }
  unsigned int v127 = -1;
  if (v120 != -1) {
    ((void (*)(void *, unsigned char *))*(&off_1F1A75480 + v120))(v100, v119);
  }
  unsigned int v120 = -1;
  if (v118 != -1) {
    ((void (*)(void *, unsigned char *))*(&off_1F1A75498 + v118))(v100, v117);
  }
  unsigned int v118 = -1;
  if (v113 != -1) {
    ((void (*)(void *, unsigned char *))*(&off_1F1A75480 + v113))(v100, v112);
  }
  unint64_t v96 = 0;
  char v97 = 0;
  unint64_t v98 = 0;
  if (v9 == v8)
  {
LABEL_124:
    unint64_t v60 = 0;
LABEL_125:
    *a5 = 0;
    if (!v60) {
      goto LABEL_127;
    }
    goto LABEL_126;
  }
  char v57 = v8;
  while (1)
  {
    double v58 = *(const void ***)(*(void *)v57 + 32);
    CGFloat v59 = *(const void ***)(*(void *)v57 + 40);
    if (v58 != v59) {
      break;
    }
    v57 += 8;
    if (v57 == v9) {
      goto LABEL_124;
    }
  }
  unint64_t v60 = 0;
  do
  {
    char v61 = *v58;
    if (v60 >= v98)
    {
      uint64_t v62 = ((char *)v60 - v96) >> 3;
      if ((unint64_t)(v62 + 1) >> 61) {
        goto LABEL_239;
      }
      unint64_t v63 = ((char *)v98 - v96) >> 2;
      if (v63 <= v62 + 1) {
        unint64_t v63 = v62 + 1;
      }
      if ((unint64_t)((char *)v98 - v96) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v64 = v63;
      }
      if (v64) {
        unint64_t v65 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)&v98, v64);
      }
      else {
        unint64_t v65 = 0;
      }
      char v66 = &v65[8 * v62];
      *(void *)char v66 = v61;
      unint64_t v60 = (const void **)(v66 + 8);
      unint64_t v68 = v96;
      long long v67 = v97;
      if (v97 != (const void **)v96)
      {
        do
        {
          uint64_t v69 = (uint64_t)*--v67;
          *((void *)v66 - 1) = v69;
          v66 -= 8;
        }
        while (v67 != (const void **)v68);
        long long v67 = (const void **)v96;
      }
      unint64_t v96 = v66;
      char v97 = v60;
      unint64_t v98 = (const void **)&v65[8 * v64];
      if (v67) {
        operator delete(v67);
      }
    }
    else
    {
      *v60++ = v61;
    }
    char v97 = v60;
    ++v58;
  }
  while (v58 != v59);
  uint64_t v70 = (const void **)v96;
  if (v96 == (char *)v60) {
    goto LABEL_125;
  }
  locations = 0;
  uint64_t v94 = 0;
  char v95 = 0;
  double v71 = 0.0;
  do
  {
    SVG::Presentation::defaultPresentation((uint64_t)v100);
    SVG::Presentation::inherit((SVG::Presentation *)(v72 + 64), (const SVG::Presentation *)v130, (const SVG::Presentation *)v100, v111);
    if (v110 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A754B0 + v110))(&v99, &v109);
    }
    unsigned int v110 = -1;
    if (v108 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A75498 + v108))(&v99, &v107);
    }
    unsigned int v108 = -1;
    if (v106 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A75480 + v106))(&v99, &v105);
    }
    unsigned int v106 = -1;
    if (v104 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A75498 + v104))(&v99, &v103);
    }
    unsigned int v104 = -1;
    if (v102 != -1) {
      ((void (*)(char *, uint64_t *))*(&off_1F1A75480 + v102))(&v99, &v101);
    }
    if (v123 != 2) {
      goto LABEL_238;
    }
    if (v122)
    {
      if (v125 != 2) {
        goto LABEL_238;
      }
      uint64_t v73 = v121;
LABEL_190:
      SVG::createColorObject(a4, v73, v100, v124);
      unint64_t v74 = (const void *)v100[0];
      goto LABEL_191;
    }
    if (v116 != 2) {
      goto LABEL_238;
    }
    if (v115)
    {
      if (v125 != 2) {
        goto LABEL_238;
      }
      uint64_t v73 = v114;
      goto LABEL_190;
    }
    unint64_t v74 = 0;
LABEL_191:
    double v75 = SVG::Length::computeValue((SVG::Length *)(v72 + 640), 1.0);
    if (v75 < v71) {
      double v75 = v71;
    }
    if (v75 <= 1.0) {
      double v76 = v75;
    }
    else {
      double v76 = 1.0;
    }
    if (v75 >= 0.0) {
      double v71 = v76;
    }
    else {
      double v71 = 0.0;
    }
    if (v74)
    {
      CFArrayAppendValue(cf, v74);
      CGFloat v77 = v94;
      if (v94 >= v95)
      {
        char v79 = locations;
        uint64_t v80 = v94 - locations;
        unint64_t v81 = v80 + 1;
        if ((unint64_t)(v80 + 1) >> 61) {
          goto LABEL_239;
        }
        uint64_t v82 = (char *)v95 - (char *)locations;
        if (((char *)v95 - (char *)locations) >> 2 > v81) {
          unint64_t v81 = v82 >> 2;
        }
        if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v83 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v83 = v81;
        }
        if (v83)
        {
          uint64_t v84 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)&v95, v83);
          char v79 = locations;
          CGFloat v77 = v94;
        }
        else
        {
          uint64_t v84 = 0;
        }
        char v85 = (double *)&v84[8 * v80];
        double *v85 = v71;
        unint64_t v78 = v85 + 1;
        while (v77 != v79)
        {
          uint64_t v86 = *((void *)v77-- - 1);
          *((void *)v85-- - 1) = v86;
        }
        locations = v85;
        char v95 = (double *)&v84[8 * v83];
        if (v79) {
          operator delete(v79);
        }
      }
      else
      {
        *uint64_t v94 = v71;
        unint64_t v78 = v94 + 1;
      }
      uint64_t v94 = v78;
      CFRelease(v74);
    }
    if (v129 != -1) {
      ((void (*)(void *, unsigned char *))*(&off_1F1A754B0 + v129))(v100, v128);
    }
    unsigned int v129 = -1;
    if (v127 != -1) {
      ((void (*)(void *, unsigned char *))*(&off_1F1A75498 + v127))(v100, v126);
    }
    unsigned int v127 = -1;
    if (v120 != -1) {
      ((void (*)(void *, unsigned char *))*(&off_1F1A75480 + v120))(v100, v119);
    }
    unsigned int v120 = -1;
    if (v118 != -1) {
      ((void (*)(void *, unsigned char *))*(&off_1F1A75498 + v118))(v100, v117);
    }
    unsigned int v118 = -1;
    if (v113 != -1) {
      ((void (*)(void *, unsigned char *))*(&off_1F1A75480 + v113))(v100, v112);
    }
    ++v70;
  }
  while (v70 != v60);
  if (v136 != 2)
  {
LABEL_238:
    std::__throw_bad_variant_access[abi:nn180100]();
LABEL_239:
    abort();
  }
  char v87 = (CFStringRef *)MEMORY[0x1E4F1DC88];
  if (HIDWORD(v135) != 2) {
    char v87 = (CFStringRef *)MEMORY[0x1E4F1DC98];
  }
  long long v88 = CGColorSpaceCreateWithName(*v87);
  *a5 = CGGradientCreateWithColors(v88, cf, locations);
  if (v88) {
    CFRelease(v88);
  }
  if (locations) {
    operator delete(locations);
  }
  unint64_t v60 = (const void **)v96;
  if (v96)
  {
LABEL_126:
    char v97 = v60;
    operator delete(v60);
  }
LABEL_127:
  if (v152 != -1) {
    ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A754B0 + v152))(v111, v151);
  }
  unsigned int v152 = -1;
  if (v150 != -1) {
    ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A75498 + v150))(v111, v149);
  }
  unsigned int v150 = -1;
  if (v143 != -1) {
    ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A75480 + v143))(v111, v142);
  }
  unsigned int v143 = -1;
  if (v139 != -1) {
    ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A75498 + v139))(v111, v138);
  }
  unsigned int v139 = -1;
  if (v133 != -1) {
    ((void (*)(_OWORD *, unsigned char *))*(&off_1F1A75480 + v133))(v111, v132);
  }
  if (LODWORD(__dst[56]) != -1) {
    ((void (*)(_OWORD *, void **))*(&off_1F1A754B0 + LODWORD(__dst[56])))(v130, &__dst[52]);
  }
  LODWORD(__dst[56]) = -1;
  if (LODWORD(__dst[50]) != -1) {
    ((void (*)(_OWORD *, void **))*(&off_1F1A75498 + LODWORD(__dst[50])))(v130, &__dst[44]);
  }
  LODWORD(__dst[50]) = -1;
  if (LODWORD(__dst[33]) != -1) {
    ((void (*)(_OWORD *, void **))*(&off_1F1A75480 + LODWORD(__dst[33])))(v130, &__dst[31]);
  }
  LODWORD(__dst[33]) = -1;
  if (LODWORD(__dst[25]) != -1) {
    ((void (*)(_OWORD *, void **))*(&off_1F1A75498 + LODWORD(__dst[25])))(v130, &__dst[19]);
  }
  LODWORD(__dst[25]) = -1;
  if (LODWORD(__dst[10]) != -1) {
    ((void (*)(_OWORD *, void **))*(&off_1F1A75480 + LODWORD(__dst[10])))(v130, &__dst[8]);
  }
  if (v8) {
    operator delete(v8);
  }
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t SVG::GradientElement::State::specifiedInherit@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v3 = *(_OWORD *)(result + 16);
  long long v4 = *(_OWORD *)(result + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(result + 32);
  *(_OWORD *)(a3 + 48) = v4;
  *(void *)(a3 + 64) = *(void *)(result + 64);
  *(_OWORD *)a3 = *(_OWORD *)result;
  *(_OWORD *)(a3 + 16) = v3;
  if (!*(unsigned char *)(result + 4) && *(unsigned char *)(a2 + 4))
  {
    *(_DWORD *)a3 = *(_DWORD *)a2;
    *(unsigned char *)(a3 + 4) = *(unsigned char *)(a2 + 4);
  }
  if (!*(unsigned char *)(result + 56) && *(unsigned char *)(a2 + 56))
  {
    *(_OWORD *)(a3 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a3 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a3 + 4CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)(a2 + 40);
    *(unsigned char *)(a3 + 56) = *(unsigned char *)(a2 + 56);
  }
  if (!*(unsigned char *)(result + 68))
  {
    if (*(unsigned char *)(a2 + 68))
    {
      *(_DWORD *)(a3 + 64) = *(_DWORD *)(a2 + 64);
      *(unsigned char *)(a3 + 68) = *(unsigned char *)(a2 + 68);
    }
  }
  return result;
}

unint64_t SVG::consumeSpreadMethod@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t result = SVG::consumeString<4ul>((uint64_t)"pad", a1, a2);
  if (v7)
  {
    *(_DWORD *)a3 = 0;
  }
  else
  {
    unint64_t result = SVG::consumeString<8ul>((uint64_t)"reflect", a1, a2);
    if (v9)
    {
      char v8 = 1;
      *(_DWORD *)a3 = 1;
      *(void *)(a3 + 8) = result;
      goto LABEL_6;
    }
    unint64_t result = SVG::consumeString<7ul>((uint64_t)"repeat", a1, a2);
    if (!v10)
    {
      char v8 = 0;
      *(unsigned char *)a3 = 0;
      goto LABEL_6;
    }
    *(_DWORD *)a3 = 2;
  }
  *(void *)(a3 + 8) = result;
  char v8 = 1;
LABEL_6:
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

void std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      char v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v5 = operator new(8 * prime);
  int v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  char v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    unint64_t v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *char v8 = *v14;
          *unint64_t v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          unint64_t v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        char v8 = v14;
        unint64_t v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

uint64_t SVG::MaskElement::MaskElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = (_OWORD *)(a1 + 648);
  uint64_t v6 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v6 + 64, a3);
  *(void *)a1 = &unk_1F1A74510;
  *(_DWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = 1;
  *uint64_t v5 = xmmword_1BF1DA7C0;
  v5[1] = xmmword_1BF1DA7C0;
  v5[2] = xmmword_1BF1DA7D0;
  v5[3] = xmmword_1BF1DA7D0;
  *(_DWORD *)(a1 + 712) = 0;
  std::string::basic_string[abi:nn180100]<0>(v18, "x");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v7 = SVG::Element::findInAttributeMap(a3, (uint64_t)v18, (uint64_t)__p);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0)
  {
    operator delete(v18[0]);
    if (!v7) {
      goto LABEL_9;
    }
  }
  else if (!v7)
  {
    goto LABEL_9;
  }
  v18[0] = (void *)-1;
  v18[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v7 + 64), (uint64_t)v18);
  if ((_BYTE)v19) {
    *uint64_t v5 = *(_OWORD *)v18;
  }
LABEL_9:
  std::string::basic_string[abi:nn180100]<0>(v18, "y");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)v18, (uint64_t)__p);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0)
  {
    operator delete(v18[0]);
    if (!v8) {
      goto LABEL_17;
    }
  }
  else if (!v8)
  {
    goto LABEL_17;
  }
  v18[0] = (void *)-1;
  v18[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v8 + 64), (uint64_t)v18);
  if ((_BYTE)v19) {
    v5[1] = *(_OWORD *)v18;
  }
LABEL_17:
  std::string::basic_string[abi:nn180100]<0>(v18, "width");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  size_t v9 = SVG::Element::findInAttributeMap(a3, (uint64_t)v18, (uint64_t)__p);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0)
  {
    operator delete(v18[0]);
    if (!v9) {
      goto LABEL_25;
    }
  }
  else if (!v9)
  {
    goto LABEL_25;
  }
  v18[0] = (void *)-1;
  v18[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v9 + 64), (uint64_t)v18);
  if ((_BYTE)v19) {
    v5[2] = *(_OWORD *)v18;
  }
LABEL_25:
  std::string::basic_string[abi:nn180100]<0>(v18, "height");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint8x8_t v10 = SVG::Element::findInAttributeMap(a3, (uint64_t)v18, (uint64_t)__p);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0)
  {
    operator delete(v18[0]);
    if (!v10) {
      goto LABEL_33;
    }
  }
  else if (!v10)
  {
    goto LABEL_33;
  }
  v18[0] = (void *)-1;
  v18[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v10 + 64), (uint64_t)v18);
  if ((_BYTE)v19) {
    v5[3] = *(_OWORD *)v18;
  }
LABEL_33:
  std::string::basic_string[abi:nn180100]<0>(v18, "maskUnits");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  unint64_t v11 = SVG::Element::findInAttributeMap(a3, (uint64_t)v18, (uint64_t)__p);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0)
  {
    operator delete(v18[0]);
    if (!v11) {
      goto LABEL_41;
    }
  }
  else if (!v11)
  {
    goto LABEL_41;
  }
  uint64_t v12 = SVG::parseUnits((uint64_t)(v11 + 64));
  if ((v12 & 0xFF00000000) != 0) {
    *(_DWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = v12;
  }
LABEL_41:
  std::string::basic_string[abi:nn180100]<0>(v18, "maskContentUnits");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v13 = SVG::Element::findInAttributeMap(a3, (uint64_t)v18, (uint64_t)__p);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0)
  {
    operator delete(v18[0]);
    if (!v13) {
      return a1;
    }
  }
  else if (!v13)
  {
    return a1;
  }
  uint64_t v14 = SVG::parseUnits((uint64_t)(v13 + 64));
  if ((v14 & 0xFF00000000) != 0) {
    *(_DWORD *)(a1 + 712) = v14;
  }
  return a1;
}

uint64_t SVG::MaskElement::appendChild(int64x2_t *a1, const void **a2)
{
  int8x8_t v4 = *a2;
  uint64_t v5 = *(void *)*a2;
  {
    uint64_t v6 = *a2;
    if (!*a2
    {
      return 0;
    }
  }
  return SVG::Element::appendChild(a1, (uint64_t *)a2);
}

void SVG::MaskElement::~MaskElement(SVG::MaskElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754C8 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754E0 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754F8 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754E0 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754F8 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754C8 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754E0 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754F8 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754E0 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A754F8 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

void SVG::analyzeDependencies(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  char v66 = 0;
  long long v67 = 0;
  uint64_t v68 = 0;
  SVG::findDependentElements((unint64_t *)&v66, a4);
  long long v9 = 0uLL;
  *(_OWORD *)long long __p = 0u;
  *(_OWORD *)unint64_t v64 = 0u;
  unint64_t v65 = 0xAAAAAAAA3F800000;
  char v10 = v66;
  char v11 = v67;
  unint64_t v12 = (unint64_t)v66;
  if (v66 != v67)
  {
    unint64_t v52 = (unint64_t)v66;
    while (1)
    {
      unint64_t v62 = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v13 = *((unsigned int *)v10 + 2);
      if (v13 == -1)
      {
LABEL_110:
        std::__throw_bad_variant_access[abi:nn180100]();
LABEL_111:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      *(void *)&long long v56 = v53;
      unint64_t v14 = ((uint64_t (*)(long long *, uint64_t *))*(&off_1F1A75520 + v13))(&v56, v10);
      unint64_t v15 = v14;
      unint64_t v16 = (unint64_t)__p[1];
      if (__p[1])
      {
        uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
        v17.i16[0] = vaddlv_u8(v17);
        if (v17.u32[0] > 1uLL)
        {
          unint64_t v18 = v14;
          if ((void *)v14 >= __p[1]) {
            unint64_t v18 = v14 % (unint64_t)__p[1];
          }
        }
        else
        {
          unint64_t v18 = ((unint64_t)__p[1] - 1) & v14;
        }
        unint64_t v19 = (void **)*((void *)__p[0] + v18);
        if (v19)
        {
          uint64_t v20 = *v19;
          if (*v19)
          {
            unsigned int v21 = *((_DWORD *)v10 + 2);
            do
            {
              unint64_t v22 = v20[1];
              if (v22 == v14)
              {
                uint64_t v23 = *((unsigned int *)v20 + 6);
                if (v23 == 1)
                {
                  if (v21 == 1) {
                    goto LABEL_28;
                  }
                }
                else
                {
                  if (*((_DWORD *)v20 + 6)) {
                    BOOL v24 = 0;
                  }
                  else {
                    BOOL v24 = v21 == 0;
                  }
                  if (v24)
                  {
LABEL_28:
                    if (v20[2] == *v10) {
                      goto LABEL_86;
                    }
                  }
                }
              }
              else
              {
                if (v17.u32[0] > 1uLL)
                {
                  if ((void *)v22 >= __p[1]) {
                    v22 %= (unint64_t)__p[1];
                  }
                }
                else
                {
                  v22 &= (unint64_t)__p[1] - 1;
                }
                if (v22 != v18) {
                  break;
                }
              }
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
        }
      }
      else
      {
        unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
      }
      uint64_t v20 = operator new(0x38uLL);
      *uint64_t v20 = 0;
      v20[1] = v15;
      *((_OWORD *)v20 + 1) = *(_OWORD *)v10;
      _OWORD v20[5] = 0;
      v20[6] = 0;
      v20[4] = 0;
      float v25 = (float)((unint64_t)v64[1] + 1);
      if (!v16 || (float)(*(float *)&v65 * (float)v16) < v25) {
        break;
      }
LABEL_76:
      size_t v41 = __p[0];
      char v42 = (void *)*((void *)__p[0] + v18);
      if (v42)
      {
        *uint64_t v20 = *v42;
      }
      else
      {
        *uint64_t v20 = v64[0];
        v64[0] = v20;
        v41[v18] = v64;
        if (!*v20) {
          goto LABEL_85;
        }
        unint64_t v43 = *(void *)(*v20 + 8);
        if ((v16 & (v16 - 1)) != 0)
        {
          if (v43 >= v16) {
            v43 %= v16;
          }
        }
        else
        {
          v43 &= v16 - 1;
        }
        char v42 = (char *)__p[0] + 8 * v43;
      }
      *char v42 = v20;
LABEL_85:
      ++v64[1];
      uint64_t v23 = *((unsigned int *)v10 + 2);
LABEL_86:
      unint64_t v62 = (unint64_t)v20;
      *(void *)&long long v56 = a2;
      *((void *)&v56 + 1) = &v62;
      *(void *)&long long v57 = a1;
      *((void *)&v57 + 1) = a3;
      unint64_t v58 = a2;
      CGFloat v59 = &v62;
      uint64_t v60 = a1;
      uint64_t v61 = a3;
      if (v23 == 0xFFFFFFFFLL) {
        goto LABEL_110;
      }
      *(void *)&v53[0] = &v56;
      ((void (*)(_OWORD *, uint64_t *))*(&off_1F1A75510 + v23))(v53, v10);
      v10 += 2;
      if (v10 == v11)
      {
        unint64_t v12 = (unint64_t)v11;
        char v10 = (uint64_t *)v52;
        long long v9 = 0uLL;
        goto LABEL_98;
      }
    }
    BOOL v26 = (v16 & (v16 - 1)) != 0;
    if (v16 < 3) {
      BOOL v26 = 1;
    }
    unint64_t v27 = v26 | (2 * v16);
    unint64_t v28 = vcvtps_u32_f32(v25 / *(float *)&v65);
    if (v27 <= v28) {
      int8x8_t prime = (int8x8_t)v28;
    }
    else {
      int8x8_t prime = (int8x8_t)v27;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v16 = (unint64_t)__p[1];
    }
    if (*(void *)&prime > v16) {
      goto LABEL_42;
    }
    if (*(void *)&prime < v16)
    {
      unint64_t v36 = vcvtps_u32_f32((float)(unint64_t)v64[1] / *(float *)&v65);
      if (v16 < 3 || (uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v16), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }
      if (*(void *)&prime <= v36) {
        int8x8_t prime = (int8x8_t)v36;
      }
      if (*(void *)&prime >= v16)
      {
        unint64_t v16 = (unint64_t)__p[1];
      }
      else
      {
        if (prime)
        {
LABEL_42:
          if (*(void *)&prime >> 61) {
            goto LABEL_111;
          }
          long long v30 = operator new(8 * *(void *)&prime);
          unint64_t v31 = __p[0];
          __p[0] = v30;
          if (v31) {
            operator delete(v31);
          }
          uint64_t v32 = 0;
          __p[1] = (void *)prime;
          do
            *((void *)__p[0] + v32++) = 0;
          while (*(void *)&prime != v32);
          unint64_t v33 = (void **)v64[0];
          if (v64[0])
          {
            unint64_t v34 = *((void *)v64[0] + 1);
            uint8x8_t v35 = (uint8x8_t)vcnt_s8(prime);
            v35.i16[0] = vaddlv_u8(v35);
            if (v35.u32[0] > 1uLL)
            {
              if (v34 >= *(void *)&prime) {
                v34 %= *(void *)&prime;
              }
            }
            else
            {
              v34 &= *(void *)&prime - 1;
            }
            *((void *)__p[0] + v34) = v64;
            for (i = *v33; i; unint64_t v34 = v40)
            {
              unint64_t v40 = i[1];
              if (v35.u32[0] > 1uLL)
              {
                if (v40 >= *(void *)&prime) {
                  v40 %= *(void *)&prime;
                }
              }
              else
              {
                v40 &= *(void *)&prime - 1;
              }
              if (v40 != v34)
              {
                if (!*((void *)__p[0] + v40))
                {
                  *((void *)__p[0] + v4CGContextBeginTransparencyLayer(c, 0) = v33;
                  goto LABEL_67;
                }
                *unint64_t v33 = (void *)*i;
                *unint64_t i = **((void **)__p[0] + v40);
                **((void **)__p[0] + v4CGContextBeginTransparencyLayer(c, 0) = i;
                unint64_t i = v33;
              }
              unint64_t v40 = v34;
LABEL_67:
              unint64_t v33 = (void **)i;
              unint64_t i = (void *)*i;
            }
          }
          unint64_t v16 = (unint64_t)prime;
          goto LABEL_71;
        }
        unint64_t v44 = __p[0];
        __p[0] = 0;
        if (v44) {
          operator delete(v44);
        }
        unint64_t v16 = 0;
        __p[1] = 0;
      }
    }
LABEL_71:
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v15 >= v16) {
        unint64_t v18 = v15 % v16;
      }
      else {
        unint64_t v18 = v15;
      }
    }
    else
    {
      unint64_t v18 = (v16 - 1) & v15;
    }
    goto LABEL_76;
  }
LABEL_98:
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(void *)(a5 + 16) = 0;
  long long v56 = v9;
  long long v57 = v9;
  unint64_t v58 = 0xAAAAAAAA3F800000;
  v53[0] = v9;
  v53[1] = v9;
  int v54 = 1065353216;
  int v55 = -1431655766;
  if (v10 != (uint64_t *)v12)
  {
    char v45 = v10;
    do
    {
      uint64_t v46 = *v45;
      uint64_t v47 = v45[1];
      v45 += 2;
      SVG::enqueue((void **)a5, (float *)&v56, (float *)v53, __p, v46, v47);
    }
    while (v45 != (uint64_t *)v12);
  }
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)v53);
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)&v56);
  unint64_t v48 = v64[0];
  if (v64[0])
  {
    do
    {
      long long v49 = (void *)*v48;
      unint64_t v50 = (void *)v48[4];
      if (v50)
      {
        v48[5] = v50;
        operator delete(v50);
      }
      operator delete(v48);
      unint64_t v48 = v49;
    }
    while (v49);
  }
  uint64_t v51 = __p[0];
  __p[0] = 0;
  if (v51) {
    operator delete(v51);
  }
  if (v10) {
    operator delete(v10);
  }
}

void SVG::findDependentElements(unint64_t *a1, void *a2)
{
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (_DWORD *)a1[1];
    unint64_t v7 = a1[2];
    if ((unint64_t)v6 < v7)
    {
      *(void *)uint64_t v6 = v5;
      void v6[2] = 0;
LABEL_7:
      char v11 = v6 + 4;
LABEL_32:
      a1[1] = (unint64_t)v11;
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)((uint64_t)v6 - *a1) >> 4;
    if (!((unint64_t)(v12 + 1) >> 60))
    {
      uint64_t v13 = v7 - *a1;
      uint64_t v14 = v13 >> 3;
      if (v13 >> 3 <= (unint64_t)(v12 + 1)) {
        uint64_t v14 = v12 + 1;
      }
      BOOL v15 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0;
      unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
      if (!v15) {
        unint64_t v16 = v14;
      }
      if (v16)
      {
        unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v16);
        uint64_t v6 = (_DWORD *)a1[1];
      }
      else
      {
        uint64_t v17 = 0;
      }
      unint64_t v23 = v16 + 16 * v12;
      unint64_t v24 = v16 + 16 * v17;
      *(void *)unint64_t v23 = v5;
      *(_DWORD *)(v23 + 8) = 0;
      char v11 = (_DWORD *)(v23 + 16);
      float v25 = (_DWORD *)*a1;
      if (v6 == (_DWORD *)*a1) {
        goto LABEL_30;
      }
      do
      {
        *(_OWORD *)(v23 - 16) = *((_OWORD *)v6 - 1);
        v23 -= 16;
        v6 -= 4;
      }
      while (v6 != v25);
LABEL_29:
      uint64_t v6 = (_DWORD *)*a1;
LABEL_30:
      *a1 = v23;
      a1[1] = (unint64_t)v11;
      a1[2] = v24;
      if (v6) {
        operator delete(v6);
      }
      goto LABEL_32;
    }
    goto LABEL_37;
  }
  if (v8)
  {
    long long v9 = v8;
    uint64_t v6 = (_DWORD *)a1[1];
    unint64_t v10 = a1[2];
    if ((unint64_t)v6 < v10)
    {
      *(void *)uint64_t v6 = v9;
      void v6[2] = 1;
      goto LABEL_7;
    }
    uint64_t v18 = (uint64_t)((uint64_t)v6 - *a1) >> 4;
    if (!((unint64_t)(v18 + 1) >> 60))
    {
      uint64_t v19 = v10 - *a1;
      uint64_t v20 = v19 >> 3;
      if (v19 >> 3 <= (unint64_t)(v18 + 1)) {
        uint64_t v20 = v18 + 1;
      }
      BOOL v15 = (unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0;
      unint64_t v21 = 0xFFFFFFFFFFFFFFFLL;
      if (!v15) {
        unint64_t v21 = v20;
      }
      if (v21)
      {
        unint64_t v21 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v21);
        uint64_t v6 = (_DWORD *)a1[1];
      }
      else
      {
        uint64_t v22 = 0;
      }
      unint64_t v23 = v21 + 16 * v18;
      unint64_t v24 = v21 + 16 * v22;
      *(void *)unint64_t v23 = v9;
      *(_DWORD *)(v23 + 8) = 1;
      char v11 = (_DWORD *)(v23 + 16);
      BOOL v26 = (_DWORD *)*a1;
      if (v6 == (_DWORD *)*a1) {
        goto LABEL_30;
      }
      do
      {
        *(_OWORD *)(v23 - 16) = *((_OWORD *)v6 - 1);
        v23 -= 16;
        v6 -= 4;
      }
      while (v6 != v26);
      goto LABEL_29;
    }
LABEL_37:
    abort();
  }
LABEL_33:
  unint64_t v28 = (uint64_t *)a2[4];
  unint64_t v27 = (uint64_t *)a2[5];
  while (v28 != v27)
  {
    uint64_t v29 = *v28++;
    SVG::findDependentElements(a1, v29);
  }
}

uint64_t SVG::enqueue(void **a1, float *a2, float *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)&long long v45 = a5;
  *((void *)&v45 + 1) = a6;
  unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v46 = a5;
  *((void *)&v46 + 1) = a6;
  long long v43 = v46;
  unint64_t v10 = std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::find<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>(a3, (uint64_t)&v46);
  LOBYTE(v44) = v10 != 0;
  if (v10) {
    return 1;
  }
  std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::__emplace_unique_key_args<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>&>(a3, (uint64_t)&v46, &v46);
  if (std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::find<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>(a2, (uint64_t)&v45))
  {
    goto LABEL_51;
  }
  if (DWORD2(v45) == -1)
  {
    std::__throw_bad_variant_access[abi:nn180100]();
    goto LABEL_56;
  }
  *(void *)&long long v46 = &v47;
  unint64_t v12 = ((uint64_t (*)(long long *, long long *))*(&off_1F1A75520 + DWORD2(v45)))(&v46, &v45);
  int8x8_t v13 = (int8x8_t)a4[1];
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v13);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v15 = v12;
    if (v12 >= *(void *)&v13) {
      unint64_t v15 = v12 % *(void *)&v13;
    }
  }
  else
  {
    unint64_t v15 = (*(void *)&v13 - 1) & v12;
  }
  unint64_t v16 = *(uint64_t **)(*a4 + 8 * v15);
  do
  {
    do
    {
      while (1)
      {
        do
          unint64_t v16 = (uint64_t *)*v16;
        while (v12 != v16[1]);
        int v17 = *((_DWORD *)v16 + 6);
        if (v17 != 1) {
          break;
        }
        if (DWORD2(v45) == 1) {
          goto LABEL_19;
        }
      }
      if (v17) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = DWORD2(v45) == 0;
      }
    }
    while (!v18);
LABEL_19:
    ;
  }
  while (v16[2] != (void)v45);
  uint64_t v19 = a1[1];
  uint64_t v20 = (void *)v16[4];
  unint64_t v21 = (void *)v16[5];
  if (v20 == v21) {
    goto LABEL_25;
  }
  unint64_t v22 = ((char *)v19 - (unsigned char *)*a1) >> 4;
  do
  {
    if (SVG::enqueue(a1, a2, a3, a4, *v20, v20[1]))
    {
      unint64_t v31 = (char *)*a1;
      long long v30 = a1[1];
      uint64_t v32 = v30 - (unsigned char *)*a1;
      if (v22 < v32 >> 4)
      {
        uint64_t v33 = 16 * v22;
        unint64_t v34 = v22;
        do
        {
          std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::__erase_unique<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>(a2, (uint64_t)&v31[v33]);
          ++v34;
          unint64_t v31 = (char *)*a1;
          long long v30 = a1[1];
          uint64_t v32 = v30 - (unsigned char *)*a1;
          v33 += 16;
        }
        while (v34 < v32 >> 4);
      }
      if (v32 >> 4 > v22)
      {
        uint64_t v35 = v30 - v31 - 16;
        do
        {
          v30 -= 16;
          BOOL v36 = v22 >= v35 >> 4;
          v35 -= 16;
        }
        while (!v36);
        a1[1] = v30;
      }
      uint64_t v11 = 1;
      goto LABEL_52;
    }
    v20 += 2;
  }
  while (v20 != v21);
  uint64_t v19 = a1[1];
LABEL_25:
  unint64_t v23 = (unint64_t)a1[2];
  if ((unint64_t)v19 < v23)
  {
    *uint64_t v19 = v45;
    unint64_t v24 = v19 + 1;
    goto LABEL_50;
  }
  uint64_t v25 = ((char *)v19 - (unsigned char *)*a1) >> 4;
  unint64_t v26 = v25 + 1;
  if ((unint64_t)(v25 + 1) >> 60) {
LABEL_56:
  }
    abort();
  uint64_t v27 = v23 - (void)*a1;
  if (v27 >> 3 > v26) {
    unint64_t v26 = v27 >> 3;
  }
  if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v28 = v26;
  }
  if (v28) {
    unint64_t v28 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v28);
  }
  else {
    uint64_t v29 = 0;
  }
  uint8x8_t v37 = (_OWORD *)(v28 + 16 * v25);
  unint64_t v38 = v28 + 16 * v29;
  *uint8x8_t v37 = v45;
  unint64_t v24 = v37 + 1;
  unint64_t v40 = (char *)*a1;
  unint64_t v39 = (char *)a1[1];
  if (v39 != *a1)
  {
    do
    {
      *--uint8x8_t v37 = *((_OWORD *)v39 - 1);
      v39 -= 16;
    }
    while (v39 != v40);
    unint64_t v39 = (char *)*a1;
  }
  *a1 = v37;
  a1[1] = v24;
  a1[2] = (void *)v38;
  if (v39) {
    operator delete(v39);
  }
LABEL_50:
  a1[1] = v24;
  std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::__emplace_unique_key_args<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>&>(a2, (uint64_t)&v45, &v45);
LABEL_51:
  uint64_t v11 = 0;
LABEL_52:
  if (!(_BYTE)v44) {
    std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::__erase_unique<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>(a3, (uint64_t)&v43);
  }
  return v11;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(unint64_t a1)
{
  if (a1 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a1);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::analyzeDependencies(std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,SVG::Presentation const&,SVG::Element const&)::$_0,SVG::analyzeDependencies(std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,SVG::Presentation const&,SVG::Element const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> &>(void ***a1, unint64_t *a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = *a2;
  uint64_t v4 = **a1;
  char v8 = *(void **)(*a2 + 56);
  uint64_t v5 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(v4, &v8);
  uint64_t v6 = *v2[1] + 32;
  long long v9 = *((_OWORD *)v2 + 1);
  memset(v10, 0, sizeof(v10));
  int v11 = 1065353216;
  char v8 = &unk_1F1A742C8;
  uint64_t v12 = v6;
  char v13 = 1;
  SVG::RecordBase::operator()((float *)&v8, v3, (const SVG::Presentation *)(v5 + 3));
  char v8 = &unk_1F1A74330;
  return std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)v10);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::analyzeDependencies(std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,SVG::Presentation const&,SVG::Element const&)::$_0,SVG::analyzeDependencies(std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,SVG::Presentation const&,SVG::Element const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> &>(uint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = *a2;
  uint64_t v4 = *(void **)(*a1 + 32);
  char v8 = *(void **)(*a2 + 56);
  uint64_t v5 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(v4, &v8);
  uint64_t v6 = **(void **)(v2 + 40) + 32;
  long long v9 = *(_OWORD *)(v2 + 48);
  memset(v10, 0, sizeof(v10));
  int v11 = 1065353216;
  char v8 = &unk_1F1A742C8;
  uint64_t v12 = v6;
  char v13 = 1;
  SVG::RecordBase::operator()((float *)&v8, v3, (const SVG::Presentation *)(v5 + 3));
  char v8 = &unk_1F1A74330;
  return std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)v10);
}

void SVG::Discoverer::~Discoverer(SVG::Discoverer *this)
{
  *(void *)this = &unk_1F1A74330;
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)this + 24);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F1A74330;
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)this + 24);
  JUMPOUT(0x1C18A3E80);
}

void SVG::Discoverer::processPatternElement(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 72))
  {
    *(unsigned char *)(a1 + 72) = 0;
  }
  else
  {
    unint64_t v3 = *(unint64_t **)(a1 + 64);
    uint64_t v4 = (_DWORD *)v3[1];
    unint64_t v5 = v3[2];
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v7 = (uint64_t)((uint64_t)v4 - *v3) >> 4;
      if ((unint64_t)(v7 + 1) >> 60) {
        abort();
      }
      uint64_t v8 = v5 - *v3;
      uint64_t v9 = v8 >> 3;
      if (v8 >> 3 <= (unint64_t)(v7 + 1)) {
        uint64_t v9 = v7 + 1;
      }
      BOOL v10 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0;
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
      if (!v10) {
        unint64_t v11 = v9;
      }
      if (v11)
      {
        unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v11);
        uint64_t v4 = (_DWORD *)v3[1];
      }
      else
      {
        uint64_t v12 = 0;
      }
      unint64_t v13 = v11 + 16 * v7;
      unint64_t v14 = v11 + 16 * v12;
      *(void *)unint64_t v13 = a2;
      *(_DWORD *)(v13 + 8) = 0;
      uint64_t v6 = (_DWORD *)(v13 + 16);
      unint64_t v15 = (_DWORD *)*v3;
      if (v4 != (_DWORD *)*v3)
      {
        do
        {
          *(_OWORD *)(v13 - 16) = *((_OWORD *)v4 - 1);
          v13 -= 16;
          v4 -= 4;
        }
        while (v4 != v15);
        uint64_t v4 = (_DWORD *)*v3;
      }
      *unint64_t v3 = v13;
      v3[1] = (unint64_t)v6;
      v3[2] = v14;
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      *(void *)uint64_t v4 = a2;
      v4[2] = 0;
      uint64_t v6 = v4 + 4;
    }
    v3[1] = (unint64_t)v6;
  }
}

void SVG::Discoverer::processMaskElement(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 72))
  {
    *(unsigned char *)(a1 + 72) = 0;
  }
  else
  {
    unint64_t v3 = *(unint64_t **)(a1 + 64);
    uint64_t v4 = (_DWORD *)v3[1];
    unint64_t v5 = v3[2];
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v7 = (uint64_t)((uint64_t)v4 - *v3) >> 4;
      if ((unint64_t)(v7 + 1) >> 60) {
        abort();
      }
      uint64_t v8 = v5 - *v3;
      uint64_t v9 = v8 >> 3;
      if (v8 >> 3 <= (unint64_t)(v7 + 1)) {
        uint64_t v9 = v7 + 1;
      }
      BOOL v10 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0;
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
      if (!v10) {
        unint64_t v11 = v9;
      }
      if (v11)
      {
        unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v11);
        uint64_t v4 = (_DWORD *)v3[1];
      }
      else
      {
        uint64_t v12 = 0;
      }
      unint64_t v13 = v11 + 16 * v7;
      unint64_t v14 = v11 + 16 * v12;
      *(void *)unint64_t v13 = a2;
      *(_DWORD *)(v13 + 8) = 1;
      uint64_t v6 = (_DWORD *)(v13 + 16);
      unint64_t v15 = (_DWORD *)*v3;
      if (v4 != (_DWORD *)*v3)
      {
        do
        {
          *(_OWORD *)(v13 - 16) = *((_OWORD *)v4 - 1);
          v13 -= 16;
          v4 -= 4;
        }
        while (v4 != v15);
        uint64_t v4 = (_DWORD *)*v3;
      }
      *unint64_t v3 = v13;
      v3[1] = (unint64_t)v6;
      v3[2] = v14;
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      *(void *)uint64_t v4 = a2;
      v4[2] = 1;
      uint64_t v6 = v4 + 4;
    }
    v3[1] = (unint64_t)v6;
  }
}

unint64_t std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::find<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>(void *a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 8);
  if (v2 == -1)
  {
    uint64_t v15 = std::__throw_bad_variant_access[abi:nn180100]();
    return std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::DependentElementHash::operator()(std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&)::{lambda(SVG::PatternElement const&)#1},SVG::DependentElementHash::operator()(std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&)::{lambda(SVG::MaskElement const&)#1}>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&>(v15, v16);
  }
  else
  {
    BOOL v18 = &v17;
    unint64_t v5 = ((uint64_t (*)(char **))*(&off_1F1A75520 + v2))(&v18);
    int8x8_t v6 = (int8x8_t)a1[1];
    if (!*(void *)&v6) {
      return 0;
    }
    uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = v5;
      if (v5 >= *(void *)&v6) {
        unint64_t v8 = v5 % *(void *)&v6;
      }
    }
    else
    {
      unint64_t v8 = (*(void *)&v6 - 1) & v5;
    }
    uint64_t v9 = *(uint64_t **)(*a1 + 8 * v8);
    if (v9)
    {
      uint64_t v9 = (uint64_t *)*v9;
      if (v9)
      {
        int v10 = *(_DWORD *)(a2 + 8);
        do
        {
          unint64_t v11 = v9[1];
          if (v11 == v5)
          {
            int v12 = *((_DWORD *)v9 + 6);
            if (v12 == 1)
            {
              if (v10 == 1) {
                goto LABEL_25;
              }
            }
            else
            {
              if (v12) {
                BOOL v13 = 0;
              }
              else {
                BOOL v13 = v10 == 0;
              }
              if (v13)
              {
LABEL_25:
                if (v9[2] == *(void *)a2) {
                  return (unint64_t)v9;
                }
              }
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= *(void *)&v6) {
                v11 %= *(void *)&v6;
              }
            }
            else
            {
              v11 &= *(void *)&v6 - 1;
            }
            if (v11 != v8) {
              return 0;
            }
          }
          uint64_t v9 = (uint64_t *)*v9;
        }
        while (v9);
      }
    }
    return (unint64_t)v9;
  }
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::DependentElementHash::operator()(std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&)::{lambda(SVG::PatternElement const&)#1},SVG::DependentElementHash::operator()(std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&)::{lambda(SVG::MaskElement const&)#1}>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&>(uint64_t a1, void *a2)
{
  unint64_t v2 = 0x9DDFEA08EB382D69 * (((((*a2 >> 3) & 0x3FFFFFFLL) << 6) | 8) ^ HIDWORD(*a2));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v2 >> 47) ^ v2)) ^ ((0x9DDFEA08EB382D69
                                                                      * (HIDWORD(*a2) ^ (v2 >> 47) ^ v2)) >> 47));
}

unint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::DependentElementHash::operator()(std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&)::{lambda(SVG::PatternElement const&)#1},SVG::DependentElementHash::operator()(std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&)::{lambda(SVG::MaskElement const&)#1}>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&>(uint64_t a1, void *a2)
{
  unint64_t v2 = 0x9DDFEA08EB382D69 * (((((*a2 >> 3) & 0x3FFFFFFLL) << 6) | 8) ^ HIDWORD(*a2));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v2 >> 47) ^ v2)) ^ ((0x9DDFEA08EB382D69
                                                                      * (HIDWORD(*a2) ^ (v2 >> 47) ^ v2)) >> 47));
}

void std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::__erase_unique<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>(void *a1, uint64_t a2)
{
  unint64_t v3 = (uint64_t *)std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::find<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>(a1, a2);
  if (!v3) {
    return;
  }
  int8x8_t v4 = (int8x8_t)a1[1];
  uint64_t v5 = *v3;
  unint64_t v6 = v3[1];
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v4);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    if (v6 >= *(void *)&v4) {
      v6 %= *(void *)&v4;
    }
  }
  else
  {
    v6 &= *(void *)&v4 - 1;
  }
  unint64_t v8 = *(uint64_t **)(*a1 + 8 * v6);
  do
  {
    uint64_t v9 = v8;
    unint64_t v8 = (uint64_t *)*v8;
  }
  while (v8 != v3);
  if (v9 == a1 + 2) {
    goto LABEL_20;
  }
  unint64_t v10 = v9[1];
  if (v7.u32[0] > 1uLL)
  {
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
  }
  else
  {
    v10 &= *(void *)&v4 - 1;
  }
  if (v10 != v6)
  {
LABEL_20:
    if (v5)
    {
      unint64_t v11 = *(void *)(v5 + 8);
      if (v7.u32[0] > 1uLL)
      {
        unint64_t v12 = *(void *)(v5 + 8);
        if (v11 >= *(void *)&v4) {
          unint64_t v12 = v11 % *(void *)&v4;
        }
      }
      else
      {
        unint64_t v12 = v11 & (*(void *)&v4 - 1);
      }
      if (v12 == v6) {
        goto LABEL_24;
      }
    }
    *(void *)(*a1 + 8 * v6) = 0;
    uint64_t v5 = *v3;
  }
  if (v5)
  {
    unint64_t v11 = *(void *)(v5 + 8);
LABEL_24:
    if (v7.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v4) {
        v11 %= *(void *)&v4;
      }
    }
    else
    {
      v11 &= *(void *)&v4 - 1;
    }
    if (v11 != v6)
    {
      *(void *)(*a1 + 8 * v11) = v9;
      uint64_t v5 = *v3;
    }
  }
  *uint64_t v9 = v5;
  *unint64_t v3 = 0;
  --a1[3];
  operator delete(v3);
}

void std::__hash_table<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,SVG::DependentElementHash,SVG::DependentElementPredicate,std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>::__emplace_unique_key_args<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>,std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>&>(float *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v3 = *(unsigned int *)(a2 + 8);
  if (v3 == -1)
  {
    std::__throw_bad_variant_access[abi:nn180100]();
    goto LABEL_95;
  }
  size_t v41 = &v40;
  unint64_t v7 = ((uint64_t (*)(char **))*(&off_1F1A75520 + v3))(&v41);
  unint64_t v8 = v7;
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = v7;
      if (v7 >= v9) {
        unint64_t v11 = v7 % v9;
      }
    }
    else
    {
      unint64_t v11 = (v9 - 1) & v7;
    }
    unint64_t v12 = *(uint64_t ***)(*(void *)a1 + 8 * v11);
    if (v12)
    {
      BOOL v13 = *v12;
      if (v13)
      {
        int v14 = *(_DWORD *)(a2 + 8);
        do
        {
          unint64_t v15 = v13[1];
          if (v15 == v7)
          {
            int v16 = *((_DWORD *)v13 + 6);
            if (v16 == 1)
            {
              if (v14 == 1) {
                goto LABEL_26;
              }
            }
            else
            {
              if (v16) {
                BOOL v17 = 0;
              }
              else {
                BOOL v17 = v14 == 0;
              }
              if (v17)
              {
LABEL_26:
                if (v13[2] == *(void *)a2) {
                  return;
                }
              }
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v15 >= v9) {
                v15 %= v9;
              }
            }
            else
            {
              v15 &= v9 - 1;
            }
            if (v15 != v11) {
              break;
            }
          }
          BOOL v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
    }
  }
  else
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  }
  BOOL v18 = operator new(0x20uLL);
  *BOOL v18 = 0;
  v18[1] = v8;
  *((_OWORD *)v18 + 1) = *a3;
  float v19 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v20 = a1[8];
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    BOOL v21 = 1;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      int8x8_t prime = (int8x8_t)v23;
    }
    else {
      int8x8_t prime = (int8x8_t)v22;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v9 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v9)
    {
LABEL_40:
      if (!(*(void *)&prime >> 61))
      {
        uint64_t v25 = operator new(8 * *(void *)&prime);
        unint64_t v26 = *(void **)a1;
        *(void *)a1 = v25;
        if (v26) {
          operator delete(v26);
        }
        uint64_t v27 = 0;
        *((int8x8_t *)a1 + 1) = prime;
        do
          *(void *)(*(void *)a1 + 8 * v27++) = 0;
        while (*(void *)&prime != v27);
        unint64_t v28 = (void *)*((void *)a1 + 2);
        if (v28)
        {
          unint64_t v29 = v28[1];
          uint8x8_t v30 = (uint8x8_t)vcnt_s8(prime);
          v30.i16[0] = vaddlv_u8(v30);
          if (v30.u32[0] > 1uLL)
          {
            if (v29 >= *(void *)&prime) {
              v29 %= *(void *)&prime;
            }
          }
          else
          {
            v29 &= *(void *)&prime - 1;
          }
          *(void *)(*(void *)a1 + 8 * v29) = a1 + 4;
          unint64_t v34 = (void *)*v28;
          if (*v28)
          {
            do
            {
              unint64_t v35 = v34[1];
              if (v30.u32[0] > 1uLL)
              {
                if (v35 >= *(void *)&prime) {
                  v35 %= *(void *)&prime;
                }
              }
              else
              {
                v35 &= *(void *)&prime - 1;
              }
              if (v35 != v29)
              {
                if (!*(void *)(*(void *)a1 + 8 * v35))
                {
                  *(void *)(*(void *)a1 + 8 * v35) = v28;
                  goto LABEL_65;
                }
                *unint64_t v28 = *v34;
                *unint64_t v34 = **(void **)(*(void *)a1 + 8 * v35);
                **(void **)(*(void *)a1 + 8 * v35) = v34;
                unint64_t v34 = v28;
              }
              unint64_t v35 = v29;
LABEL_65:
              unint64_t v28 = v34;
              unint64_t v34 = (void *)*v34;
              unint64_t v29 = v35;
            }
            while (v34);
          }
        }
        unint64_t v9 = (unint64_t)prime;
        goto LABEL_69;
      }
LABEL_95:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v31 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (*(void *)&prime <= v31) {
        int8x8_t prime = (int8x8_t)v31;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *((void *)a1 + 1);
      }
      else
      {
        if (prime) {
          goto LABEL_40;
        }
        unint64_t v39 = *(void **)a1;
        *(void *)a1 = 0;
        if (v39) {
          operator delete(v39);
        }
        unint64_t v9 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_69:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v11 = v8 % v9;
      }
      else {
        unint64_t v11 = v8;
      }
    }
    else
    {
      unint64_t v11 = (v9 - 1) & v8;
    }
  }
  BOOL v36 = *(void **)a1;
  uint8x8_t v37 = *(void **)(*(void *)a1 + 8 * v11);
  if (v37)
  {
    *BOOL v18 = *v37;
LABEL_82:
    *uint8x8_t v37 = v18;
    goto LABEL_83;
  }
  *BOOL v18 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v18;
  v36[v11] = a1 + 4;
  if (*v18)
  {
    unint64_t v38 = *(void *)(*v18 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v38 >= v9) {
        v38 %= v9;
      }
    }
    else
    {
      v38 &= v9 - 1;
    }
    uint8x8_t v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_82;
  }
LABEL_83:
  ++*((void *)a1 + 3);
}

uint64_t OTSVGTableCreateFromData(const __CFData *a1, int a2, double a3)
{
  if (a1)
  {
    if (a2)
    {
      CFIndex Length = CFDataGetLength(a1);
      if (Length >= 10)
      {
        unint64_t v7 = Length;
        *(_WORD *)buffer = -21846;
        v38.CFIndex location = 0;
        v38.length = 2;
        CFDataGetBytes(a1, v38, buffer);
        unsigned int v8 = __rev16(*(unsigned __int16 *)buffer);
        *(_DWORD *)buffer = -1431655766;
        v39.CFIndex location = 2;
        v39.length = 4;
        CFDataGetBytes(a1, v39, buffer);
        if (!v8)
        {
          unint64_t v10 = (unint64_t)buffer[0] << 24;
          uint64_t v11 = buffer[1];
          uint64_t v12 = buffer[2];
          uint64_t v13 = buffer[3];
          v14.CFIndex location = v10 | ((unint64_t)buffer[1] << 16) | ((unint64_t)buffer[2] << 8) | buffer[3];
          CFIndex v15 = v14.location + 2;
          if (v14.location + 2 <= v7)
          {
            *(_WORD *)buffer = -21846;
            CFIndex location = v14.location;
            v14.length = 2;
            CFDataGetBytes(a1, v14, buffer);
            unsigned int v16 = buffer[0];
            unsigned int v17 = buffer[1];
            if (v15 + 12 * (unint64_t)(buffer[1] | (buffer[0] << 8)) <= v7)
            {
              unint64_t v18 = buffer[1] | ((unint64_t)buffer[0] << 8);
              BytePtr = CFDataGetBytePtr(a1);
              if (v18)
              {
                uint64_t v20 = 12 * v17 + 3072 * v16 - 12;
                BOOL v21 = &BytePtr[0x10000 * v11 + 16 + 256 * v12 + v10 + v13];
                while (v20)
                {
                  unsigned int v22 = *((unsigned __int16 *)v21 - 1);
                  unsigned int v23 = *(unsigned __int16 *)v21;
                  unsigned int v24 = *((unsigned __int16 *)v21 - 7);
                  unsigned int v25 = *((unsigned __int16 *)v21 - 6);
                  unsigned int v26 = __rev16(v23);
                  unsigned int v27 = bswap32(v24);
                  unsigned int v28 = __rev16(v22);
                  unsigned int v29 = bswap32(v25);
                  if (v23 == v25 && v22 == v24) {
                    unsigned __int8 v31 = 0;
                  }
                  else {
                    unsigned __int8 v31 = -127;
                  }
                  if (v28 > HIWORD(v29)) {
                    unsigned __int8 v31 = 1;
                  }
                  if (v26 < HIWORD(v27)) {
                    unsigned __int8 v31 = -1;
                  }
                  v20 -= 12;
                  v21 += 12;
                  if (v31 != 129 && (v31 & 0x80) != 0) {
                    return 0;
                  }
                }
              }
              uint8x8_t v32 = &BytePtr[v15];
              memset(buffer, 170, sizeof(buffer));
              unint64_t v33 = v18;
              _ZNSt3__111make_sharedB8nn180100IN3SVG5TableEJEvEENS_10shared_ptrIT_EEDpOT0_(buffer);
              uint64_t v34 = *(void *)buffer;
              *(void *)(*(void *)buffer + 64) = v32;
              *(void *)(v34 + 72) = v33;
              CFRetain(a1);
              unint64_t v35 = *(const void **)(v34 + 80);
              if (v35) {
                CFRelease(v35);
              }
              *(void *)(v34 + 8CGContextBeginTransparencyLayer(c, 0) = a1;
              *(void *)(v34 + 88) = location;
              *(_DWORD *)(v34 + 96) = a2;
              *(double *)(v34 + 104) = a3;
              operator new();
            }
          }
        }
      }
    }
  }
  return 0;
}

char *_ZNSt3__111make_sharedB8nn180100IN3SVG5TableEJEvEENS_10shared_ptrIT_EEDpOT0_(void *a1)
{
  unint64_t v2 = (char *)operator new(0xB0uLL);
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *(void *)unint64_t v2 = &unk_1F1A74E28;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 1CGContextBeginTransparencyLayer(c, 0) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_DWORD *)v2 + 42) = 1065353216;
  a1[1] = v2;
  *((void *)v2 + 3) = 850045863;
  unint64_t result = v2 + 24;
  *a1 = result;
  return result;
}

void OTSVGTableEnumerateGlyphs(std::mutex **a1, uint64_t a2)
{
  if (a1 && a2)
  {
    int8x8_t v4 = *a1;
    std::mutex::lock(*a1);
    uint64_t v5 = *(void *)(*a1)[1].__m_.__opaque;
    if (v5)
    {
      sig = (unsigned __int16 *)(*a1)[1].__m_.__sig;
      unint64_t v7 = &sig[6 * v5];
      do
      {
        if (bswap32(*sig) >> 16 <= bswap32(sig[1]) >> 16) {
          (*(void (**)(uint64_t))(a2 + 16))(a2);
        }
        sig += 6;
      }
      while (sig != v7);
    }
    std::mutex::unlock(v4);
  }
}

uint64_t OTSVGTableGetDocumentIndexForGlyph(std::mutex **a1, unsigned int a2)
{
  if (!a1) {
    return -1;
  }
  int8x8_t v4 = *a1;
  std::mutex::lock(*a1);
  uint64_t v5 = *a1;
  unint64_t v6 = *(void *)(*a1)[1].__m_.__opaque;
  unint64_t v7 = -1;
  if (v6)
  {
    sig = (unsigned __int16 *)v5[1].__m_.__sig;
    unint64_t v9 = &sig[6 * v6];
    unint64_t v10 = sig;
    do
    {
      unint64_t v11 = v6 >> 1;
      uint64_t v12 = &v10[6 * (v6 >> 1)];
      unsigned int v13 = bswap32(v12[1]) >> 16;
      CFRange v14 = v12 + 6;
      v6 += ~(v6 >> 1);
      if (v13 < a2) {
        unint64_t v10 = v14;
      }
      else {
        unint64_t v6 = v11;
      }
    }
    while (v6);
    if (v10 == v9 || a2 < bswap32(*v10) >> 16 || a2 > bswap32(v10[1]) >> 16) {
      unint64_t v7 = -1;
    }
    else {
      unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((char *)v10 - (char *)sig) >> 2);
    }
  }
  std::mutex::unlock(v4);
  return v7;
}

void std::__shared_ptr_emplace<SVG::Table>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1A74E28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SVG::Table>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1A74E28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C18A3E80);
}

void std::__shared_ptr_emplace<SVG::Table>::__on_zero_shared(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 152);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      int8x8_t v4 = (std::__shared_weak_count *)v2[4];
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v4);
      }
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v5 = *(void **)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v5) {
    operator delete(v5);
  }
  unint64_t v6 = *(const void **)(a1 + 104);
  if (v6) {
    CFRelease(v6);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 24));
}

void SVG::playback(uint64_t a1, uint64_t *a2)
{
  uint64_t v13 = a1;
  FillColorAsColor = (const void *)CGContextGetFillColorAsColor();
  CFTypeRef cf = FillColorAsColor;
  if (FillColorAsColor) {
    CFRetain(FillColorAsColor);
  }
  long long __p = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (v4 != v5)
  {
    do
    {
      v14[0] = &v13;
      v14[1] = &cf;
      uint64_t v6 = *(unsigned int *)(v4 + 120);
      if (v6 == -1)
      {
        unint64_t v7 = (void ***)std::__throw_bad_variant_access[abi:nn180100]();
        std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(v7, v8);
        return;
      }
      CFIndex v15 = v14;
      ((void (*)(void **, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100INS1_9__variant15__value_visitorIZZN3SVG8playbackEP9CGContextRKNS6_9RecordingEENK3__0clERKNS_7variantIJNS6_9SaveStateENS6_12RestoreStateENS6_9ConcatCTMENS6_9DrawImageENS6_8FillPathENS6_18DrawLinearGradientENS6_18DrawRadialGradientENS6_11ClipToPathsENS6_10ClipToMaskENS6_7SetFillENS6_22BeginTransparencyLayerENS6_20EndTransparencyLayerENS6_8SetAlphaENS6_6GetCTMEEEEEUlRKNS6_7CommandEE_EEJRKNS0_6__implIJSE_SF_SG_SH_SI_SJ_SK_SL_SM_SN_SO_SP_SQ_SR_EEEEEEDcOT_DpOT0____fmatrix[v6])(&v15, v4);
      v4 += 128;
    }
    while (v4 != v5);
    if (__p)
    {
      unint64_t v11 = __p;
      operator delete(__p);
    }
  }
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<7ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<8ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<9ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<10ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<11ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<12ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<13ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::playback(CGContext *,SVG::Recording const&)::$_0::operator() const(std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&)::{lambda(SVG::Command const&)#1}> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)a2 + 16))(a2, ***a1, (*a1)[1]);
}

uint64_t SVG::SetFill::execute(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a2;
  v6[0] = &v7;
  v6[1] = &v7;
  void v6[2] = a3;
  v6[3] = a3;
  v6[4] = &v7;
  uint64_t v3 = *(unsigned int *)(a1 + 112);
  if (v3 == -1)
  {
    uint64_t v5 = (SVG::SetFill *)std::__throw_bad_variant_access[abi:nn180100]();
    return SVG::SetFill::dump(v5);
  }
  else
  {
    uint64_t v8 = v6;
    return ((uint64_t (*)(void **, uint64_t))*(&off_1F1A75530 + v3))(&v8, a1 + 8);
  }
}

void SVG::SetFill::dump(SVG::SetFill *this)
{
  unint64_t v2 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"SetFill", 7);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  uint64_t v3 = std::locale::use_facet(&v7, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(&v7);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v4 = *((unsigned int *)this + 28);
  if (v4 == -1)
  {
    uint64_t v5 = (SVG::SetFill *)std::__throw_bad_variant_access[abi:nn180100]();
    SVG::SetFill::~SetFill(v5);
  }
  else
  {
    v7.__locale_ = (std::locale::__imp *)&v6;
    ((void (*)(std::locale *, char *))off_1F1A75560[v4])(&v7, (char *)this + 8);
  }
}

void SVG::SetFill::~SetFill(SVG::SetFill *this)
{
  *(void *)this = &unk_1F1A74B80;
  uint64_t v2 = *((unsigned int *)this + 28);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A75578[v2])(&v3, (char *)this + 8);
  }
  *((_DWORD *)this + 28) = -1;
}

{
  uint64_t v2;
  char v3;

  *(void *)this = &unk_1F1A74B80;
  uint64_t v2 = *((unsigned int *)this + 28);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A75578[v2])(&v3, (char *)this + 8);
  }
  *((_DWORD *)this + 28) = -1;
  MEMORY[0x1C18A3E80](this, 0x10A3C40C258EA78);
}

double SVG::SetFill::boundingRect(SVG::SetFill *this, SVG::BoundingRectState *a2)
{
  return *MEMORY[0x1E4F1DB28];
}

double SVG::SetFill::timeCost(SVG::SetFill *this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  return 0.893334119;
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::SetFill::execute(CGContext *,SVG::PlaybackState &)::$_0,SVG::SetFill::execute(CGContext *,SVG::PlaybackState &)::$_1,SVG::SetFill::execute(CGContext *,SVG::PlaybackState &)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData> const&>(CGContextRef ***a1, CGColorRef *a2)
{
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::SetFill::execute(CGContext *,SVG::PlaybackState &)::$_0,SVG::SetFill::execute(CGContext *,SVG::PlaybackState &)::$_1,SVG::SetFill::execute(CGContext *,SVG::PlaybackState &)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData> const&>(uint64_t a1)
{
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::SetFill::execute(CGContext *,SVG::PlaybackState &)::$_0,SVG::SetFill::execute(CGContext *,SVG::PlaybackState &)::$_1,SVG::SetFill::execute(CGContext *,SVG::PlaybackState &)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData> const&>()
{
}

void SVG::drawPattern(SVG *this, CGContextRef c, CGContext *a3)
{
  CGContextClipToRect(c, *(CGRect *)((char *)this + 16));
  uint64_t v5 = *(uint64_t **)this;
  SVG::playback((uint64_t)c, v5);
}

uint64_t SVG::releaseInfo(uint64_t this, void *a2)
{
  if (this)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(this + 8);
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v2);
    }
    JUMPOUT(0x1C18A3E80);
  }
  return this;
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::SetFill::dump(void)::$_0,SVG::SetFill::dump(void)::$_1,SVG::SetFill::dump(void)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData> const&>(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (*a2)
  {
    CFStringRef v2 = CFCopyDescription(*a2);
    memset(__b, 170, sizeof(__b));
    CFStringGetCString(v2, __b, 1024, 0x8000100u);
    char v3 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"    ", 4);
    size_t v4 = strlen(__b);
    uint64_t v5 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v3, (uint64_t)__b, v4);
    std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24)));
    char v6 = std::locale::use_facet(&v7, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
    std::locale::~locale(&v7);
    std::ostream::put();
    std::ostream::flush();
    if (v2) {
      CFRelease(v2);
    }
  }
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::SetFill::dump(void)::$_0,SVG::SetFill::dump(void)::$_1,SVG::SetFill::dump(void)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData> const&>()
{
  int v0 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"    CurrentColor", 16);
  std::ios_base::getloc((const std::ios_base *)((char *)v0 + *(void *)(*v0 - 24)));
  uint64_t v1 = std::locale::use_facet(&v3, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v1->__vftable[2].~facet_0)(v1, 10);
  std::locale::~locale(&v3);
  std::ostream::put();
  return std::ostream::flush();
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::SetFill::dump(void)::$_0,SVG::SetFill::dump(void)::$_1,SVG::SetFill::dump(void)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData> const&>()
{
  int v0 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"    Pattern", 11);
  std::ios_base::getloc((const std::ios_base *)((char *)v0 + *(void *)(*v0 - 24)));
  uint64_t v1 = std::locale::use_facet(&v3, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v1->__vftable[2].~facet_0)(v1, 10);
  std::locale::~locale(&v3);
  std::ostream::put();
  return std::ostream::flush();
}

uint64_t SVG::RecordBase::shouldContinue(SVG::RecordBase *this)
{
  return 1;
}

void SVG::RecordBase::operator()(float *a1, unint64_t a2, const SVG::Presentation *a3)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(float *))(*(void *)a1 + 80))(a1)) {
    return;
  }
  char v6 = (void **)(a1 + 6);
  if (std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::find<SVG::Element const*>((void *)a1 + 3, a2))
  {
    return;
  }
  unint64_t v7 = 0x9DDFEA08EB382D69 * (((((a2 >> 3) & 0x3FFFFFF) << 6) | 8) ^ HIDWORD(a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *((void *)a1 + 4);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v12 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v12 = v9 % v10;
      }
    }
    else
    {
      unint64_t v12 = (v10 - 1) & v9;
    }
    uint64_t v13 = (void *)*((void *)*v6 + v12);
    if (v13)
    {
      for (unint64_t i = (void *)*v13; i; unint64_t i = (void *)*i)
      {
        unint64_t v15 = i[1];
        if (v15 == v9)
        {
          if (i[2] == a2) {
            goto LABEL_76;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v12) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  }
  unsigned int v16 = operator new(0x18uLL);
  *unsigned int v16 = 0;
  v16[1] = v9;
  _OWORD v16[2] = a2;
  float v17 = (float)(unint64_t)(*((void *)a1 + 6) + 1);
  float v18 = a1[14];
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      int8x8_t prime = (int8x8_t)v21;
    }
    else {
      int8x8_t prime = (int8x8_t)v20;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v10 = *((void *)a1 + 4);
    }
    if (*(void *)&prime > v10) {
      goto LABEL_32;
    }
    if (*(void *)&prime < v10)
    {
      unint64_t v29 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 6) / a1[14]);
      if (v10 < 3 || (uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v30.i16[0] = vaddlv_u8(v30), v30.u32[0] > 1uLL))
      {
        unint64_t v29 = std::__next_prime(v29);
      }
      else
      {
        uint64_t v31 = 1 << -(char)__clz(v29 - 1);
        if (v29 >= 2) {
          unint64_t v29 = v31;
        }
      }
      if (*(void *)&prime <= v29) {
        int8x8_t prime = (int8x8_t)v29;
      }
      if (*(void *)&prime >= v10)
      {
        unint64_t v10 = *((void *)a1 + 4);
      }
      else
      {
        if (prime)
        {
LABEL_32:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unsigned int v23 = operator new(8 * *(void *)&prime);
          unsigned int v24 = *v6;
          *char v6 = v23;
          if (v24) {
            operator delete(v24);
          }
          uint64_t v25 = 0;
          *((int8x8_t *)a1 + 4) = prime;
          do
            *((void *)*v6 + v25++) = 0;
          while (*(void *)&prime != v25);
          unsigned int v26 = (void *)*((void *)a1 + 5);
          if (v26)
          {
            unint64_t v27 = v26[1];
            uint8x8_t v28 = (uint8x8_t)vcnt_s8(prime);
            v28.i16[0] = vaddlv_u8(v28);
            if (v28.u32[0] > 1uLL)
            {
              if (v27 >= *(void *)&prime) {
                v27 %= *(void *)&prime;
              }
            }
            else
            {
              v27 &= *(void *)&prime - 1;
            }
            *((void *)*v6 + v27) = a1 + 10;
            uint8x8_t v32 = (void *)*v26;
            if (*v26)
            {
              do
              {
                unint64_t v33 = v32[1];
                if (v28.u32[0] > 1uLL)
                {
                  if (v33 >= *(void *)&prime) {
                    v33 %= *(void *)&prime;
                  }
                }
                else
                {
                  v33 &= *(void *)&prime - 1;
                }
                if (v33 != v27)
                {
                  if (!*((void *)*v6 + v33))
                  {
                    *((void *)*v6 + v33) = v26;
                    goto LABEL_57;
                  }
                  *unsigned int v26 = *v32;
                  *uint8x8_t v32 = **((void **)*v6 + v33);
                  **((void **)*v6 + v33) = v32;
                  uint8x8_t v32 = v26;
                }
                unint64_t v33 = v27;
LABEL_57:
                unsigned int v26 = v32;
                uint8x8_t v32 = (void *)*v32;
                unint64_t v27 = v33;
              }
              while (v32);
            }
          }
          unint64_t v10 = (unint64_t)prime;
          goto LABEL_61;
        }
        char v53 = *v6;
        *char v6 = 0;
        if (v53) {
          operator delete(v53);
        }
        unint64_t v10 = 0;
        *((void *)a1 + 4) = 0;
      }
    }
LABEL_61:
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v12 = v9 % v10;
      }
      else {
        unint64_t v12 = v9;
      }
    }
    else
    {
      unint64_t v12 = (v10 - 1) & v9;
    }
  }
  uint64_t v34 = *v6;
  unint64_t v35 = (void *)*((void *)*v6 + v12);
  if (v35)
  {
    *unsigned int v16 = *v35;
LABEL_74:
    *unint64_t v35 = v16;
    goto LABEL_75;
  }
  uint64_t v36 = *((void *)a1 + 5);
  *unsigned int v16 = v36;
  *((void *)a1 + 5) = v16;
  v34[v12] = a1 + 10;
  if (v36)
  {
    unint64_t v37 = *(void *)(v36 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v37 >= v10) {
        v37 %= v10;
      }
    }
    else
    {
      v37 &= v10 - 1;
    }
    unint64_t v35 = (char *)*v6 + 8 * v37;
    goto LABEL_74;
  }
LABEL_75:
  ++*((void *)a1 + 6);
LABEL_76:
  if (v38)
  {
    CFRange v39 = v38;
    memcpy(__dst, &unk_1BF1DA868, sizeof(__dst));
    SVG::Presentation::inherit(v39, a3, *((const SVG::Presentation **)a1 + 2), __dst);
    (*(void (**)(float *, unint64_t, _OWORD *))(*(void *)a1 + 16))(a1, a2, __dst);
    if (LODWORD(__dst[28]) != -1) {
      ((void (*)(char *, _OWORD *))off_1F1A75590[LODWORD(__dst[28])])(&v54, &__dst[26]);
    }
    LODWORD(__dst[28]) = -1;
    if (LODWORD(__dst[25]) != -1) {
      ((void (*)(char *, _OWORD *))off_1F1A755A8[LODWORD(__dst[25])])(&v54, &__dst[22]);
    }
    LODWORD(__dst[25]) = -1;
    if (DWORD2(__dst[16]) != -1) {
      ((void (*)(char *, char *))off_1F1A755C0[DWORD2(__dst[16])])(&v54, (char *)&__dst[15] + 8);
    }
    DWORD2(__dst[16]) = -1;
    if (DWORD2(__dst[12]) != -1) {
      ((void (*)(char *, char *))off_1F1A755A8[DWORD2(__dst[12])])(&v54, (char *)&__dst[9] + 8);
    }
    DWORD2(__dst[12]) = -1;
    if (LODWORD(__dst[5]) != -1) {
      ((void (*)(char *, _OWORD *))off_1F1A755C0[LODWORD(__dst[5])])(&v54, &__dst[4]);
    }
  }
  else
  {
    long long v45 = *(uint64_t **)(a2 + 32);
    long long v46 = *(uint64_t **)(a2 + 40);
    while (v45 != v46)
    {
      uint64_t v47 = *v45++;
      SVG::RecordBase::operator()(a1, v47, a3);
    }
  }
  char v40 = (float *)std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::find<SVG::Element const*>((void *)a1 + 3, a2);
  if (v40)
  {
    int8x8_t v41 = *(int8x8_t *)(a1 + 8);
    uint64_t v42 = *(void *)v40;
    unint64_t v43 = *((void *)v40 + 1);
    uint8x8_t v44 = (uint8x8_t)vcnt_s8(v41);
    v44.i16[0] = vaddlv_u8(v44);
    if (v44.u32[0] > 1uLL)
    {
      if (v43 >= *(void *)&v41) {
        v43 %= *(void *)&v41;
      }
    }
    else
    {
      v43 &= *(void *)&v41 - 1;
    }
    unint64_t v48 = (float *)*((void *)*v6 + v43);
    do
    {
      long long v49 = v48;
      unint64_t v48 = *(float **)v48;
    }
    while (v48 != v40);
    if (v49 == a1 + 10) {
      goto LABEL_108;
    }
    unint64_t v50 = *((void *)v49 + 1);
    if (v44.u32[0] > 1uLL)
    {
      if (v50 >= *(void *)&v41) {
        v50 %= *(void *)&v41;
      }
    }
    else
    {
      v50 &= *(void *)&v41 - 1;
    }
    if (v50 != v43)
    {
LABEL_108:
      if (v42)
      {
        unint64_t v51 = *(void *)(v42 + 8);
        if (v44.u32[0] > 1uLL)
        {
          unint64_t v52 = *(void *)(v42 + 8);
          if (v51 >= *(void *)&v41) {
            unint64_t v52 = v51 % *(void *)&v41;
          }
        }
        else
        {
          unint64_t v52 = v51 & (*(void *)&v41 - 1);
        }
        if (v52 == v43) {
          goto LABEL_112;
        }
      }
      *((void *)*v6 + v43) = 0;
      uint64_t v42 = *(void *)v40;
    }
    if (!v42)
    {
LABEL_118:
      *(void *)long long v49 = v42;
      *(void *)char v40 = 0;
      --*((void *)a1 + 6);
      operator delete(v40);
      return;
    }
    unint64_t v51 = *(void *)(v42 + 8);
LABEL_112:
    if (v44.u32[0] > 1uLL)
    {
      if (v51 >= *(void *)&v41) {
        v51 %= *(void *)&v41;
      }
    }
    else
    {
      v51 &= *(void *)&v41 - 1;
    }
    if (v51 != v43)
    {
      *((void *)*v6 + v51) = v49;
      uint64_t v42 = *(void *)v40;
    }
    goto LABEL_118;
  }
}

void SVG::RecordBase::operator()(float *a1, unint64_t **a2, const SVG::Presentation *a3)
{
  if ((*(unsigned int (**)(float *))(*(void *)a1 + 80))(a1))
  {
    unint64_t v7 = *a2;
    char v6 = a2[1];
    while (v7 != v6)
    {
      unint64_t v8 = *v7++;
      SVG::RecordBase::operator()(a1, v8, a3);
    }
  }
}

void SVG::RecordBase::processSpecificElement(SVG::RecordBase *this, unint64_t **lpsrc, const SVG::Presentation *a3)
{
  if (v6)
  {
    (*(void (**)(SVG::RecordBase *, void *, const SVG::Presentation *))(*(void *)this + 24))(this, v6, a3);
    goto LABEL_5;
  }
  if (v7)
  {
    (*(void (**)(SVG::RecordBase *, void *, const SVG::Presentation *))(*(void *)this + 32))(this, v7, a3);
LABEL_5:
    if ((*(unsigned int (**)(SVG::RecordBase *))(*(void *)this + 80))(this))
    {
      unint64_t v9 = lpsrc[4];
      unint64_t v8 = lpsrc[5];
      while (v9 != v8)
      {
        unint64_t v10 = *v9++;
        SVG::RecordBase::operator()((float *)this, v10, a3);
      }
    }
    return;
  }
  if (!v11)
  {
    if (v16)
    {
      float v17 = v16;
      float v18 = *(void (**)(SVG::RecordBase *, void *, const SVG::Presentation *))(*(void *)this + 48);
      BOOL v19 = this;
      unint64_t v20 = a3;
    }
    else
    {
      if (v21)
      {
        float v17 = v21;
        float v18 = *(void (**)(SVG::RecordBase *, void *, const SVG::Presentation *))(*(void *)this + 56);
        BOOL v19 = this;
        unint64_t v20 = a3;
      }
      else
      {
        if (v22)
        {
          float v17 = v22;
          float v18 = *(void (**)(SVG::RecordBase *, void *, const SVG::Presentation *))(*(void *)this + 64);
          BOOL v19 = this;
          unint64_t v20 = a3;
        }
        else
        {
          if (!v23) {
            return;
          }
          float v17 = v23;
          float v18 = *(void (**)(SVG::RecordBase *, void *, const SVG::Presentation *))(*(void *)this + 72);
          BOOL v19 = this;
          unint64_t v20 = a3;
        }
      }
    }
    v18(v19, v17, v20);
    return;
  }
  unint64_t v12 = v11;
  uint64_t v13 = (void *)*((void *)this + 1);
  uint64_t v24 = v12[94];
  CFRange v14 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(v13, &v24);
  if (v14)
  {
    unint64_t v15 = v14;
    (*(void (**)(SVG::RecordBase *, void *, const SVG::Presentation *))(*(void *)this + 40))(this, v12, a3);
    SVG::RecordBase::operator()((float *)this, v15[3], a3);
  }
}

BOOL SVG::Record::shouldContinue(SVG::Record *this)
{
  uint64_t v1 = *((void *)this + 8);
  return *(unsigned char *)(v1 + 392) && *(unsigned char *)(v1 + 408) != 0;
}

void SVG::Record::processPresentation(SVG::Record *this, const SVG::Element *a2, const SVG::Presentation *a3)
{
  v20[4] = *MEMORY[0x1E4F143B8];
  v19[0] = *((void *)this + 8);
  v19[1] = 0xAAAAAAAAAAAAAA00;
  SVG::StateSaverRestorer::save((SVG::StateSaverRestorer *)v19);
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[0] = v6;
  v16[1] = v6;
  uint64_t v17 = -1;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v7 = (void *)*((void *)this + 8);
  unint64_t v8 = (void *)*((void *)this + 1);
  unint64_t v9 = (void *)*((void *)this + 17);
  unint64_t v10 = (void *)*((void *)this + 18);
  double v11 = *((double *)this + 19);
  double v12 = *((double *)this + 20);
  double v13 = *((double *)this + 21);
  double v14 = *((double *)this + 22);
  unint64_t v15 = operator new(0x20uLL);
  *unint64_t v15 = &unk_1F1A73B50;
  v15[1] = this;
  v15[2] = a2;
  void v15[3] = a3;
  v20[3] = v15;
  SVG::ApplyPresentation::ApplyPresentation((uint64_t)v16, v7, (uint64_t)a3, a2, v8, v9, v10, (uint64_t)v20, v11, v12, v13, v14);
  std::__function::__value_func<void ()(SVG::ApplyPresentationState const&)>::~__value_func[abi:nn180100](v20);
  SVG::ApplyPresentation::~ApplyPresentation((SVG::ApplyPresentation *)v16);
  SVG::StateSaverRestorer::~StateSaverRestorer((SVG::StateSaverRestorer *)v19);
}

uint64_t SVG::Record::processGElement(SVG::Record *this, const SVG::GElement *a2, const SVG::Presentation *a3)
{
  uint64_t v3 = *((void *)this + 8);
  long long v5 = *((_OWORD *)a2 + 40);
  long long v6 = *((_OWORD *)a2 + 41);
  long long v7 = *((_OWORD *)a2 + 42);
  unint64_t v8 = &unk_1F1A74C88;
  long long v9 = v5;
  long long v10 = v6;
  long long v11 = v7;
  int v12 = 2;
  uint64_t result = SVG::Recorder::append(v3, (uint64_t)&v8);
  if (v12 != -1) {
    return ((uint64_t (*)(char *, void **))off_1F1A755D8[v12])(&v13, &v8);
  }
  return result;
}

uint64_t SVG::Record::processUseElement(SVG::Record *this, const SVG::UseElement *a2, const SVG::Presentation *a3)
{
  long long v11 = *((_OWORD *)a2 + 41);
  long long v12 = *((_OWORD *)a2 + 40);
  CGFloat v5 = *((double *)a2 + 84);
  CGFloat v6 = *((double *)a2 + 85);
  *(_OWORD *)unsigned int v16 = *((_OWORD *)a2 + 43);
  double v7 = SVG::Length::computeValue((SVG::Length *)v16, *((double *)this + 21));
  *(_OWORD *)unsigned int v16 = *((_OWORD *)a2 + 44);
  double v8 = SVG::Length::computeValue((SVG::Length *)v16, *((double *)this + 22));
  *(_OWORD *)&v18.CGFloat a = v12;
  *(_OWORD *)&v18.CGFloat c = v11;
  v18.tdouble x = v5;
  v18.tdouble y = v6;
  CGAffineTransformTranslate((CGAffineTransform *)v16, &v18, v7, v8);
  uint64_t v9 = *((void *)this + 8);
  long long v13 = *(_OWORD *)v16;
  long long v14 = *(_OWORD *)&v16[16];
  long long v15 = *(_OWORD *)&v16[32];
  *(void *)unsigned int v16 = &unk_1F1A74C88;
  *(_OWORD *)&v16[8] = v13;
  *(_OWORD *)&v16[24] = v14;
  *(_OWORD *)&v16[40] = v15;
  int v17 = 2;
  uint64_t result = SVG::Recorder::append(v9, (uint64_t)v16);
  if (v17 != -1) {
    return ((uint64_t (*)(char *, unsigned char *))off_1F1A755D8[v17])(&v19, v16);
  }
  return result;
}

void SVG::Record::processImageElement(SVG::Record *this, CGImageRef *a2, const SVG::Presentation *a3)
{
  if (*((_DWORD *)a3 + 143) == 2)
  {
    if (!*((_DWORD *)a3 + 142))
    {
      if (a2[96])
      {
        *(void *)&long long v5 = -1;
        *((void *)&v5 + 1) = -1;
        long long v27 = v5;
        long long v28 = v5;
        long long v26 = v5;
        unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v5 = *((void *)this + 19);
        uint64_t v6 = *((void *)this + 20);
        uint64_t v7 = *((void *)this + 21);
        uint64_t v8 = *((void *)this + 22);
        SVG::ImageElement::totalTransform((SVG::ImageElement *)a2, *(CGRect *)&v5, (uint64_t)&v26);
        if ((_BYTE)v29)
        {
          unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
          memset(&v24[2], 255, 32);
          v24[4] = xmmword_1BF1DABF8;
          v24[0] = xmmword_1BF1DABB8;
          v24[1] = unk_1BF1DABC8;
          uint64_t v9 = *((void *)this + 8);
          v23[1] = v27;
          v23[2] = v28;
          v23[0] = v26;
          SVG::AffineTransformApplier::AffineTransformApplier((uint64_t)v24, v9, v23);
          uint64_t v10 = *((void *)this + 8);
          long long v11 = a2[96];
          double Width = (double)CGImageGetWidth(v11);
          double Height = (double)CGImageGetHeight(a2[96]);
          if (v11)
          {
            CFRetain(v11);
            long long v14 = v11;
          }
          else
          {
            long long v14 = 0;
          }
          *(double *)&long long v18 = Width;
          *((double *)&v18 + 1) = Height;
          v19[0] = &unk_1F1A74CD0;
          v19[1] = v14;
          long long v20 = 0uLL;
          long long v21 = v18;
          int v22 = 3;
          SVG::Recorder::append(v10, (uint64_t)v19);
          if (v22 != -1) {
            ((void (*)(char *, void *))off_1F1A755D8[v22])(&v30, v19);
          }
          int v22 = -1;
          SVG::AffineTransformApplier::~AffineTransformApplier((SVG::AffineTransformApplier *)v24);
        }
      }
    }
  }
  else
  {
    long long v15 = (SVG::Record *)std::__throw_bad_variant_access[abi:nn180100]();
    SVG::Record::processShapeElement(v15, v16, v17);
  }
}

void SVG::Record::processShapeElement(SVG::Record *this, const SVG::ShapeElement *a2, const SVG::Presentation *a3)
{
  if (*((_DWORD *)a3 + 143) != 2) {
    goto LABEL_79;
  }
  if (*((_DWORD *)a3 + 142)) {
    return;
  }
  CFTypeRef v75 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(CFTypeRef *__return_ptr, const SVG::ShapeElement *, double, double, double, double))(*(void *)a2 + 32))(&v75, a2, *((double *)this + 19), *((double *)this + 20), *((double *)this + 21), *((double *)this + 22));
  if (!v75) {
    return;
  }
  double v9 = (*(double (**)(const SVG::ShapeElement *, double, double, double, double))(*(void *)a2 + 40))(a2, *((double *)this + 19), *((double *)this + 20), *((double *)this + 21), *((double *)this + 22));
  double v10 = v6;
  double v11 = v7;
  double v12 = v8;
  long long v73 = unk_1BF1DAB58;
  memset(v74, 170, 40);
  memset(v70, 170, sizeof(v70));
  long long v71 = unk_1BF1DAB38;
  long long v72 = xmmword_1BF1DAB48;
  long long v65 = xmmword_1BF1DAAC8;
  long long v66 = unk_1BF1DAAD8;
  long long v67 = xmmword_1BF1DAAE8;
  long long v68 = unk_1BF1DAAF8;
  long long v69 = xmmword_1BF1DAB08;
  *(_OWORD *)long long __p = xmmword_1BF1DAAA8;
  long long v64 = unk_1BF1DAAB8;
  if (*((_DWORD *)a3 + 50) != 2) {
    goto LABEL_79;
  }
  if (*((_DWORD *)a3 + 54) != 2) {
    goto LABEL_79;
  }
  memset(v54, 170, sizeof(v54));
  long long v55 = unk_1BF1DAB58;
  long long v56 = xmmword_1BF1DAB08;
  long long v57 = xmmword_1BF1DAB48;
  if (*((_DWORD *)a3 + 57) != 2) {
    goto LABEL_79;
  }
  unint64_t v13 = *((void *)this + 14) + *((void *)this + 13) - 1;
  *(_OWORD *)&v51[8] = *((_OWORD *)this + 10);
  *(void *)unint64_t v51 = *((void *)this + 19);
  SVG::ApplyPresentationFill::ApplyPresentationFill((uint64_t)__p, *((void **)this + 8), *((void *)this + 1), *((void *)this + 15), *((void *)this + 16), (uint64_t)a3 + 152, *((_DWORD *)a3 + 56) == 1, (uint64_t)v75, *((double *)a3 + 26), v9, v6, v7, v8, *(long long *)v51, *((void *)this + 21), *((void *)this + 22), *(void *)(*((void *)this + 10) + ((v13 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v13);
  CGFloat phase = *((CGFloat *)this + 8);
  *(void *)&long long cf = v75;
  if (v75) {
    CFRetain(v75);
  }
  if (LODWORD(v74[2]) == -1) {
    goto LABEL_79;
  }
  p_CGFloat phase = &phase;
  ((void (*)(CGFloat **, long long *))off_1F1A75648[LODWORD(v74[2])])(&p_phase, &v71);
  if ((void)cf) {
    CFRelease((CFTypeRef)cf);
  }
  SVG::ApplyPresentationFill::~ApplyPresentationFill((SVG::ApplyPresentationFill *)__p);
  CGPathRef v14 = (CGPathRef)v75;
  if (v75) {
    CFRetain(v75);
  }
  CGFloat phase = NAN;
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long cf = v15;
  long long v62 = v15;
  if (*((_DWORD *)a3 + 120) != 2 || *((_DWORD *)a3 + 112) != 2) {
    goto LABEL_79;
  }
  double v16 = *((double *)this + 21);
  double v17 = SVG::Length::computeValue((const SVG::Presentation *)((char *)a3 + 464), sqrt(*((double *)this + 22) * *((double *)this + 22) + v16 * v16) / 1.41421356);
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long __p = v18;
  long long v64 = v18;
  LOBYTE(__p[0]) = 0;
  BYTE8(v64) = 0;
  int v19 = *((unsigned __int8 *)a3 + 440);
  if (!*((unsigned char *)a3 + 440)) {
    goto LABEL_41;
  }
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v64 = 0;
  BYTE8(v64) = 1;
  long long v20 = (SVG::Length *)*((void *)a3 + 52);
  long long v21 = (SVG::Length *)*((void *)a3 + 53);
  if (v20 == v21)
  {
LABEL_40:
    int v19 = 0;
LABEL_41:
    CGFloat phase = v17;
    LOBYTE(cf) = 0;
    goto LABEL_43;
  }
  double v53 = v12;
  double v22 = v11;
  double v23 = v10;
  double v24 = v9;
  double v25 = 0.0;
  do
  {
    double v26 = SVG::Length::computeValue(v20, v16);
    if (v26 < 0.0)
    {
      int v19 = 0;
      CGFloat phase = v17;
      LOBYTE(cf) = 0;
      double v9 = v24;
      double v10 = v23;
      double v11 = v22;
      double v12 = v53;
      goto LABEL_43;
    }
    double v27 = v26;
    long long v28 = (char *)__p[1];
    if (__p[1] >= (void *)v64)
    {
      char v30 = (char *)__p[0];
      int64_t v31 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      unint64_t v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61) {
        goto LABEL_80;
      }
      uint64_t v33 = v64 - (unint64_t)__p[0];
      if ((uint64_t)(v64 - (unint64_t)__p[0]) >> 2 > v32) {
        unint64_t v32 = v33 >> 2;
      }
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v34 = v32;
      }
      if (v34)
      {
        unint64_t v35 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)&v64, v34);
        char v30 = (char *)__p[0];
        long long v28 = (char *)__p[1];
      }
      else
      {
        unint64_t v35 = 0;
      }
      uint64_t v36 = (double *)&v35[8 * v31];
      *uint64_t v36 = v27;
      unint64_t v29 = v36 + 1;
      while (v28 != v30)
      {
        uint64_t v37 = *((void *)v28 - 1);
        v28 -= 8;
        *((void *)v36-- - 1) = v37;
      }
      __p[0] = v36;
      __p[1] = v29;
      *(void *)&long long v64 = &v35[8 * v34];
      if (v30) {
        operator delete(v30);
      }
    }
    else
    {
      *(double *)__p[1] = v26;
      unint64_t v29 = v28 + 8;
    }
    double v25 = v25 + v27;
    __p[1] = v29;
    long long v20 = (SVG::Length *)((char *)v20 + 16);
  }
  while (v20 != v21);
  BOOL v38 = v25 == 0.0;
  double v9 = v24;
  double v10 = v23;
  double v11 = v22;
  double v12 = v53;
  if (v38) {
    goto LABEL_40;
  }
  CGFloat phase = v17;
  LOBYTE(cf) = 0;
  BYTE8(v62) = 0;
  if (!BYTE8(v64)) {
    goto LABEL_50;
  }
  long long cf = 0uLL;
  *(void *)&long long v62 = 0;
  unint64_t v48 = __p[0];
  int64_t v49 = (unsigned char *)v29 - (char *)__p[0];
  if (v29 != __p[0])
  {
    std::vector<double>::__vallocate[abi:nn180100](&cf, v49 >> 3);
    uint64_t v50 = *((void *)&cf + 1);
    memmove(*((void **)&cf + 1), v48, v49);
    *((void *)&cf + 1) = v50 + v49;
  }
  int v19 = 1;
LABEL_43:
  BYTE8(v62) = v19;
  if (BYTE8(v64) && __p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
    int v19 = BYTE8(v62);
  }
  if (v19)
  {
    CGPathRef CopyByDashingPath = CGPathCreateCopyByDashingPath((CGPathRef)v75, 0, phase, (const CGFloat *)cf, (uint64_t)(*((void *)&cf + 1) - cf) >> 3);
    if (v14) {
      CFRelease(v14);
    }
    CGPathRef v14 = CopyByDashingPath;
  }
LABEL_50:
  if (v14)
  {
    if (*((_DWORD *)a3 + 123) != 2) {
      goto LABEL_79;
    }
    CGLineCap v40 = *((_DWORD *)a3 + 122) >= 2u ? kCGLineCapSquare : *((_DWORD *)a3 + 122);
    if (*((_DWORD *)a3 + 125) != 2) {
      goto LABEL_79;
    }
    int v41 = *((_DWORD *)a3 + 124);
    CGLineJoin v42 = v41 == 2 ? kCGLineJoinBevel : v41 == 1;
    if (*((_DWORD *)a3 + 128) != 2 || *((_DWORD *)a3 + 140) != 2) {
      goto LABEL_79;
    }
    CGFloat v43 = *((double *)a3 + 63);
    double v44 = SVG::Length::computeValue((const SVG::Presentation *)((char *)a3 + 544), sqrt(*((double *)this + 22) * *((double *)this + 22) + *((double *)this + 21) * *((double *)this + 21))/ 1.41421356);
    CGPathRef CopyByStrokingPath = CGPathCreateCopyByStrokingPath(v14, 0, v44, v40, v42, v43);
    if (CopyByStrokingPath)
    {
      *(void *)&v74[2] = 0xAAAAAAAAAAAAAAAALL;
      long long v73 = v55;
      v74[0] = v54[3];
      v74[1] = v54[2];
      v70[0] = v54[1];
      v70[1] = v54[0];
      long long v71 = unk_1BF1DAB38;
      long long v72 = v57;
      long long v65 = xmmword_1BF1DAAC8;
      long long v66 = unk_1BF1DAAD8;
      long long v67 = xmmword_1BF1DAAE8;
      long long v68 = unk_1BF1DAAF8;
      long long v69 = v56;
      *(_OWORD *)long long __p = xmmword_1BF1DAAA8;
      long long v64 = unk_1BF1DAAB8;
      if (*((_DWORD *)a3 + 100) == 2 && *((_DWORD *)a3 + 132) == 2)
      {
        CGPathRef v46 = CopyByStrokingPath;
        unint64_t v47 = *((void *)this + 14) + *((void *)this + 13) - 1;
        *(_OWORD *)&v52[8] = *((_OWORD *)this + 10);
        *(void *)unint64_t v52 = *((void *)this + 19);
        SVG::ApplyPresentationFill::ApplyPresentationFill((uint64_t)__p, *((void **)this + 8), *((void *)this + 1), *((void *)this + 15), *((void *)this + 16), (uint64_t)a3 + 352, 0, (uint64_t)CopyByStrokingPath, *((double *)a3 + 65), v9, v10, v11, v12, *(long long *)v52, *((void *)this + 21), *((void *)this + 22), *(void *)(*((void *)this + 10) + ((v47 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v47);
        p_CGFloat phase = (CGFloat *)*((void *)this + 8);
        CFTypeRef v59 = v46;
        CFRetain(v46);
        if (LODWORD(v74[2]) != -1)
        {
          p_p_CGFloat phase = &p_phase;
          ((void (*)(CGFloat ***, long long *))off_1F1A75648[LODWORD(v74[2])])(&p_p_phase, &v71);
          if (v59) {
            CFRelease(v59);
          }
          SVG::ApplyPresentationFill::~ApplyPresentationFill((SVG::ApplyPresentationFill *)__p);
          CFRelease(v46);
          goto LABEL_68;
        }
      }
LABEL_79:
      std::__throw_bad_variant_access[abi:nn180100]();
LABEL_80:
      abort();
    }
  }
LABEL_68:
  if (BYTE8(v62) && (void)cf)
  {
    *((void *)&cf + 1) = cf;
    operator delete((void *)cf);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v75) {
    CFRelease(v75);
  }
}

void SVG::RecordBase::~RecordBase(SVG::RecordBase *this)
{
  *(void *)this = &unk_1F1A74330;
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)this + 24);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F1A74330;
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)this + 24);
  JUMPOUT(0x1C18A3E80);
}

void SVG::Record::~Record(SVG::Record *this)
{
  *(void *)this = &unk_1F1A74AE8;
  std::deque<SVG::ApplyPresentationState>::~deque[abi:nn180100]((void *)this + 9);
  *(void *)this = &unk_1F1A74330;
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)this + 24);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F1A74AE8;
  std::deque<SVG::ApplyPresentationState>::~deque[abi:nn180100]((void *)this + 9);
  *(void *)this = &unk_1F1A74330;
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)this + 24);
  JUMPOUT(0x1C18A3E80);
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::DrawShapeOfType> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::ApplyPresentationFill::None,std::__variant_detail::_Trait::FillPath,std::__variant_detail::_Trait::Gradient> const&>(void ***a1)
{
  CFStringRef v2 = **a1;
  uint64_t v1 = (*a1)[1];
  unint64_t v3 = v2[5] + v2[4] - 1;
  char v4 = *(unsigned char *)(*(void *)(v2[1] + ((v3 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v3 & 0x1F) << 7) + 120);
  CFTypeRef cf = v1;
  if (v1)
  {
    CFRetain(v1);
    CFTypeRef v5 = cf;
  }
  else
  {
    CFTypeRef v5 = 0;
  }
  v7[0] = &unk_1F1A74BC8;
  v7[1] = v5;
  char v8 = v4;
  int v9 = 4;
  SVG::Recorder::append((uint64_t)v2, (uint64_t)v7);
  if (v9 != -1) {
    ((void (*)(char *, void *))off_1F1A755D8[v9])(&v10, v7);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::DrawShapeOfType> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::ApplyPresentationFill::None,std::__variant_detail::_Trait::FillPath,std::__variant_detail::_Trait::Gradient> const&>(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v2[1] = 0xAAAAAAAAAAAAAA00;
  v2[0] = *(void *)v1;
  SVG::StateSaverRestorer::save((SVG::StateSaverRestorer *)v2);
  if (*(void *)(v1 + 8)) {
    CFRetain(*(CFTypeRef *)(v1 + 8));
  }
  operator new();
}

void SVG::ClipToPaths::LeafClipNode::~LeafClipNode(SVG::ClipToPaths::LeafClipNode *this)
{
  *(void *)this = &unk_1F1A74418;
  CFStringRef v2 = (const void *)*((void *)this + 9);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)this = &unk_1F1A743F8;
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

{
  const void *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F1A74418;
  CFStringRef v2 = (const void *)*((void *)this + 9);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)this = &unk_1F1A743F8;
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  JUMPOUT(0x1C18A3E80);
}

void SVG::ClipToPaths::BaseClipNode::~BaseClipNode(SVG::ClipToPaths::BaseClipNode *this)
{
  *(void *)this = &unk_1F1A743F8;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

{
  std::__shared_weak_count *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1A743F8;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  JUMPOUT(0x1C18A3E80);
}

void std::__shared_ptr_pointer<SVG::ClipToPaths::LeafClipNode  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C18A3E80);
}

uint64_t std::__shared_ptr_pointer<SVG::ClipToPaths::LeafClipNode  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<SVG::ClipToPaths::LeafClipNode  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t ***std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::DrawShapeOfType::operator()(SVG::ApplyPresentationFill::Gradient const&)::{lambda(std::vector<SVG::DrawLinearGradient> const&)#1},SVG::DrawShapeOfType::operator()(SVG::ApplyPresentationFill::Gradient const&)::{lambda(std::vector<SVG::DrawRadialGradient> const&)#1}>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>> const&>(uint64_t ***result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    char v4 = **result;
    do
    {
      uint64_t v5 = *v4;
      v9[0] = &unk_1F1A74890;
      double v6 = *(const void **)(v2 + 8);
      v9[1] = v6;
      if (v6) {
        CFRetain(v6);
      }
      long long v7 = *(_OWORD *)(v2 + 16);
      long long v8 = *(_OWORD *)(v2 + 32);
      int v12 = *(_DWORD *)(v2 + 48);
      long long v10 = v7;
      long long v11 = v8;
      int v13 = 5;
      uint64_t result = (uint64_t ***)SVG::Recorder::append(v5, (uint64_t)v9);
      if (v13 != -1) {
        uint64_t result = (uint64_t ***)((uint64_t (*)(char *, void *))off_1F1A755D8[v13])(&v14, v9);
      }
      v2 += 56;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::DrawShapeOfType::operator()(SVG::ApplyPresentationFill::Gradient const&)::{lambda(std::vector<SVG::DrawLinearGradient> const&)#1},SVG::DrawShapeOfType::operator()(SVG::ApplyPresentationFill::Gradient const&)::{lambda(std::vector<SVG::DrawRadialGradient> const&)#1}>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>> const&>(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    char v4 = *(uint64_t **)(*(void *)result + 8);
    do
    {
      uint64_t v5 = *v4;
      v10[0] = &unk_1F1A748D8;
      double v6 = *(const void **)(v2 + 8);
      v10[1] = v6;
      if (v6) {
        CFRetain(v6);
      }
      long long v7 = *(_OWORD *)(v2 + 16);
      long long v8 = *(_OWORD *)(v2 + 32);
      long long v9 = *(_OWORD *)(v2 + 48);
      int v14 = *(_DWORD *)(v2 + 64);
      long long v12 = v8;
      long long v13 = v9;
      long long v11 = v7;
      int v15 = 6;
      uint64_t result = SVG::Recorder::append(v5, (uint64_t)v10);
      if (v15 != -1) {
        uint64_t result = ((uint64_t (*)(char *, void *))off_1F1A755D8[v15])(&v16, v10);
      }
      v2 += 72;
    }
    while (v2 != v3);
  }
  return result;
}

void *std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::find<SVG::Element const*>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v2 - 1) & v5;
  }
  long long v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void std::__function::__func<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0,std::allocator<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::~__func()
{
}

__n128 std::__function::__func<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0,std::allocator<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::__clone(uint64_t a1)
{
  int8x8_t v2 = (char *)operator new(0x20uLL);
  *(void *)int8x8_t v2 = &unk_1F1A73B50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0,std::allocator<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F1A73B50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0,std::allocator<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::operator()(uint64_t a1, _OWORD *a2)
{
  int8x8_t v2 = a2;
  unint64_t v4 = *(SVG::RecordBase **)(a1 + 8);
  unint64_t v5 = (char *)*((void *)v4 + 11);
  uint8x8_t v6 = (char *)*((void *)v4 + 10);
  uint64_t v7 = v5 - v6;
  if (v5 == v6) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = 32 * (v5 - v6) - 1;
  }
  unint64_t v9 = *((void *)v4 + 13);
  unint64_t v10 = *((void *)v4 + 14) + v9;
  if (v8 != v10) {
    goto LABEL_37;
  }
  if (v9 < 0x100)
  {
    uint64_t v25 = v7 >> 3;
    double v26 = (char *)*((void *)v4 + 12);
    double v27 = (char *)*((void *)v4 + 9);
    if (v7 >> 3 < (unint64_t)((v26 - v27) >> 3))
    {
      long long v28 = operator new(0x1000uLL);
      unint64_t v29 = v28;
      if (v26 == v5)
      {
        if (v6 == v27)
        {
          if (v5 == v6) {
            unint64_t v58 = 1;
          }
          else {
            unint64_t v58 = (v26 - v6) >> 2;
          }
          uint64_t v59 = 2 * v58;
          uint64_t v60 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v58);
          uint8x8_t v6 = &v60[(v59 + 6) & 0xFFFFFFFFFFFFFFF8];
          long long v62 = (uint64_t *)*((void *)v4 + 10);
          unint64_t v63 = v6;
          uint64_t v64 = *((void *)v4 + 11) - (void)v62;
          if (v64)
          {
            unint64_t v63 = &v6[v64 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v65 = 8 * (v64 >> 3);
            long long v66 = &v60[(v59 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v67 = *v62++;
              *(void *)long long v66 = v67;
              v66 += 8;
              v65 -= 8;
            }
            while (v65);
          }
          long long v68 = (void *)*((void *)v4 + 9);
          *((void *)v4 + 9) = v60;
          *((void *)v4 + 1CGContextBeginTransparencyLayer(c, 0) = v6;
          *((void *)v4 + 11) = v63;
          *((void *)v4 + 12) = &v60[8 * v61];
          if (v68)
          {
            operator delete(v68);
            uint8x8_t v6 = (char *)*((void *)v4 + 10);
          }
        }
        *((void *)v6 - 1) = v29;
        long long v69 = (char *)*((void *)v4 + 10);
        uint64_t v70 = (char *)*((void *)v4 + 11);
        *((void *)v4 + 1CGContextBeginTransparencyLayer(c, 0) = v69 - 8;
        uint64_t v71 = *((void *)v69 - 1);
        *((void *)v4 + 1CGContextBeginTransparencyLayer(c, 0) = v69;
        if (v70 == *((char **)v4 + 12))
        {
          unint64_t v72 = *((void *)v4 + 9);
          uint64_t v73 = (uint64_t)&v69[-v72];
          if ((unint64_t)v69 <= v72)
          {
            uint64_t v104 = (uint64_t)&v70[-v72];
            BOOL v40 = v104 == 0;
            uint64_t v105 = v104 >> 2;
            if (v40) {
              unint64_t v106 = 1;
            }
            else {
              unint64_t v106 = v105;
            }
            uint64_t v107 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v106);
            uint64_t v109 = &v107[8 * (v106 >> 2)];
            unsigned int v110 = (uint64_t *)*((void *)v4 + 10);
            uint64_t v70 = v109;
            uint64_t v111 = *((void *)v4 + 11) - (void)v110;
            if (v111)
            {
              uint64_t v70 = &v109[v111 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v112 = 8 * (v111 >> 3);
              unsigned int v113 = &v107[8 * (v106 >> 2)];
              do
              {
                uint64_t v114 = *v110++;
                *(void *)unsigned int v113 = v114;
                v113 += 8;
                v112 -= 8;
              }
              while (v112);
            }
            char v115 = (void *)*((void *)v4 + 9);
            *((void *)v4 + 9) = v107;
            *((void *)v4 + 1CGContextBeginTransparencyLayer(c, 0) = v109;
            *((void *)v4 + 11) = v70;
            *((void *)v4 + 12) = &v107[8 * v108];
            if (v115)
            {
              operator delete(v115);
              uint64_t v70 = (char *)*((void *)v4 + 11);
            }
          }
          else
          {
            uint64_t v74 = v73 >> 3;
            BOOL v17 = v73 >> 3 < -1;
            uint64_t v75 = (v73 >> 3) + 2;
            if (v17) {
              uint64_t v76 = v75;
            }
            else {
              uint64_t v76 = v74 + 1;
            }
            uint64_t v77 = -(v76 >> 1);
            uint64_t v78 = v76 >> 1;
            char v79 = &v69[-8 * v78];
            int64_t v80 = v70 - v69;
            if (v70 != v69)
            {
              memmove(&v69[-8 * v78], v69, v70 - v69);
              long long v69 = (char *)*((void *)v4 + 10);
            }
            uint64_t v70 = &v79[v80];
            *((void *)v4 + 1CGContextBeginTransparencyLayer(c, 0) = &v69[8 * v77];
            *((void *)v4 + 11) = &v79[v80];
          }
        }
        *(void *)uint64_t v70 = v71;
      }
      else
      {
        *(void *)unint64_t v5 = v28;
      }
      goto LABEL_35;
    }
    if (v26 == v27) {
      unint64_t v30 = 1;
    }
    else {
      unint64_t v30 = (v26 - v27) >> 2;
    }
    int64_t v31 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v30);
    uint64_t v33 = v32;
    unint64_t v34 = &v31[8 * v25];
    unint64_t v35 = &v31[8 * v32];
    uint64_t v36 = operator new(0x1000uLL);
    if (v25 == v33)
    {
      uint64_t v37 = 8 * v25;
      if (v7 < 1)
      {
        unint64_t v81 = v36;
        uint64_t v82 = v37 >> 2;
        if (v5 == v6) {
          unint64_t v83 = 1;
        }
        else {
          unint64_t v83 = v82;
        }
        uint64_t v84 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v83);
        unint64_t v34 = &v84[8 * (v83 >> 2)];
        unint64_t v35 = &v84[8 * v85];
        if (v31) {
          operator delete(v31);
        }
        int64_t v31 = v84;
        uint64_t v36 = v81;
      }
      else
      {
        uint64_t v38 = v37 >> 3;
        if (v38 >= -1) {
          unint64_t v39 = v38 + 1;
        }
        else {
          unint64_t v39 = v38 + 2;
        }
        v34 -= 8 * (v39 >> 1);
      }
    }
    *(void *)unint64_t v34 = v36;
    uint64_t v86 = v34 + 8;
    uint64_t v87 = *((void *)v4 + 11);
    if (v87 == *((void *)v4 + 10))
    {
      unsigned int v102 = v34;
      long long v88 = v34 + 8;
LABEL_87:
      uint64_t v103 = (void *)*((void *)v4 + 9);
      *((void *)v4 + 9) = v31;
      *((void *)v4 + 1CGContextBeginTransparencyLayer(c, 0) = v102;
      *((void *)v4 + 11) = v88;
      *((void *)v4 + 12) = v35;
      int8x8_t v2 = a2;
      if (v103) {
        operator delete(v103);
      }
      goto LABEL_36;
    }
    while (1)
    {
      if (v34 == v31)
      {
        if (v86 < v35)
        {
          uint64_t v90 = (v35 - v86) >> 3;
          if (v90 >= -1) {
            unint64_t v91 = v90 + 1;
          }
          else {
            unint64_t v91 = v90 + 2;
          }
          long long v88 = &v86[8 * (v91 >> 1)];
          long long v89 = &v34[8 * (v91 >> 1)];
          if (v86 == v34) {
            unint64_t v34 = v86;
          }
          else {
            memmove(&v34[8 * (v91 >> 1)], v34, v86 - v34);
          }
          goto LABEL_83;
        }
        if (v35 == v34) {
          unint64_t v92 = 1;
        }
        else {
          unint64_t v92 = (v35 - v34) >> 2;
        }
        uint64_t v93 = 2 * v92;
        uint64_t v94 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v92);
        int64_t v31 = v94;
        long long v89 = &v94[(v93 + 6) & 0xFFFFFFFFFFFFFFF8];
        long long v88 = v89;
        uint64_t v96 = v86 - v34;
        if (v86 != v34)
        {
          long long v88 = &v89[v96 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v97 = 8 * (v96 >> 3);
          unint64_t v98 = &v94[(v93 + 6) & 0xFFFFFFFFFFFFFFF8];
          char v99 = v34;
          do
          {
            uint64_t v100 = *(void *)v99;
            v99 += 8;
            *(void *)unint64_t v98 = v100;
            v98 += 8;
            v97 -= 8;
          }
          while (v97);
        }
        unint64_t v35 = &v94[8 * v95];
        operator delete(v34);
      }
      else
      {
        long long v88 = v86;
        long long v89 = v34;
      }
      unint64_t v34 = v31;
LABEL_83:
      int64_t v31 = v34;
      uint64_t v101 = *(void *)(v87 - 8);
      v87 -= 8;
      *((void *)v89 - 1) = v101;
      unsigned int v102 = v89 - 8;
      uint64_t v86 = v88;
      unint64_t v34 = v102;
      if (v87 == *((void *)v4 + 10)) {
        goto LABEL_87;
      }
    }
  }
  *((void *)v4 + 13) = v9 - 256;
  uint64_t v13 = *(void *)v6;
  long long v11 = v6 + 8;
  uint64_t v12 = v13;
  *((void *)v4 + 1CGContextBeginTransparencyLayer(c, 0) = v11;
  if (v5 == *((char **)v4 + 12))
  {
    unint64_t v14 = *((void *)v4 + 9);
    uint64_t v15 = (uint64_t)&v11[-v14];
    if ((unint64_t)v11 <= v14)
    {
      uint64_t v41 = (uint64_t)&v5[-v14];
      BOOL v40 = v41 == 0;
      uint64_t v42 = v41 >> 2;
      if (v40) {
        unint64_t v43 = 1;
      }
      else {
        unint64_t v43 = v42;
      }
      double v44 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v43);
      CGPathRef v46 = &v44[8 * (v43 >> 2)];
      unint64_t v47 = (uint64_t *)*((void *)v4 + 10);
      unint64_t v5 = v46;
      uint64_t v48 = *((void *)v4 + 11) - (void)v47;
      if (v48)
      {
        unint64_t v5 = &v46[v48 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v49 = 8 * (v48 >> 3);
        uint64_t v50 = &v44[8 * (v43 >> 2)];
        do
        {
          uint64_t v51 = *v47++;
          *(void *)uint64_t v50 = v51;
          v50 += 8;
          v49 -= 8;
        }
        while (v49);
      }
      unint64_t v52 = (void *)*((void *)v4 + 9);
      *((void *)v4 + 9) = v44;
      *((void *)v4 + 1CGContextBeginTransparencyLayer(c, 0) = v46;
      *((void *)v4 + 11) = v5;
      *((void *)v4 + 12) = &v44[8 * v45];
      if (v52)
      {
        operator delete(v52);
        unint64_t v5 = (char *)*((void *)v4 + 11);
      }
    }
    else
    {
      uint64_t v16 = v15 >> 3;
      BOOL v17 = v15 >> 3 < -1;
      uint64_t v18 = (v15 >> 3) + 2;
      if (v17) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v16 + 1;
      }
      uint64_t v20 = -(v19 >> 1);
      uint64_t v21 = v19 >> 1;
      double v22 = &v11[-8 * v21];
      int64_t v23 = v5 - v11;
      if (v5 != v11)
      {
        memmove(&v11[-8 * v21], v11, v5 - v11);
        unint64_t v5 = (char *)*((void *)v4 + 10);
      }
      double v24 = &v5[8 * v20];
      unint64_t v5 = &v22[v23];
      *((void *)v4 + 1CGContextBeginTransparencyLayer(c, 0) = v24;
      *((void *)v4 + 11) = &v22[v23];
    }
  }
  *(void *)unint64_t v5 = v12;
LABEL_35:
  *((void *)v4 + 11) += 8;
LABEL_36:
  uint8x8_t v6 = (char *)*((void *)v4 + 10);
  unint64_t v10 = *((void *)v4 + 14) + *((void *)v4 + 13);
LABEL_37:
  *(_OWORD *)(*(void *)&v6[(v10 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v1CGContextBeginTransparencyLayer(c, 0) = *v2;
  ++*((void *)v4 + 14);
  SVG::RecordBase::processSpecificElement(v4, *(unint64_t ***)(a1 + 16), *(const SVG::Presentation **)(a1 + 24));
  uint64_t v54 = *((void *)v4 + 10);
  uint64_t v53 = *((void *)v4 + 11);
  if (v53 == v54) {
    uint64_t v55 = 0;
  }
  else {
    uint64_t v55 = 32 * (v53 - v54) - 1;
  }
  uint64_t v56 = *((void *)v4 + 13);
  uint64_t v57 = *((void *)v4 + 14) - 1;
  *((void *)v4 + 14) = v57;
  if ((unint64_t)(v55 - (v57 + v56)) >= 0x200)
  {
    operator delete(*(void **)(v53 - 8));
    *((void *)v4 + 11) -= 8;
  }
}

uint64_t std::__function::__func<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0,std::allocator<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0,std::allocator<SVG::Record::processPresentation(SVG::Element const&,SVG::Presentation const&)::$_0>,void ()(SVG::ApplyPresentationState const&)>::target_type()
{
}

double SVG::PathElement::PathElement(uint64_t a1, uint64_t x1_0, void *a3)
{
  uint64_t v5 = SVG::ShapeElement::ShapeElement(a1, x1_0, a3);
  *(void *)uint64_t v5 = &unk_1F1A74540;
  *(_OWORD *)(v5 + 688) = 0u;
  std::string::basic_string[abi:nn180100]<0>(__p, "d");
  std::string::basic_string[abi:nn180100]<0>(&v93, "http://www.w3.org/2000/svg");
  uint8x8_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)__p, (uint64_t)&v93);
  if (SHIBYTE(v94) < 0) {
    operator delete((void *)v93);
  }
  if (SBYTE7(v37) < 0)
  {
    operator delete(__p[0]);
    if (!v6)
    {
LABEL_40:
      std::string::basic_string[abi:nn180100]<0>(__p, "pathLength");
      std::string::basic_string[abi:nn180100]<0>(&v93, "http://www.w3.org/2000/svg");
      int64_t v31 = SVG::Element::findInAttributeMap(a3, (uint64_t)__p, (uint64_t)&v93);
      if (SHIBYTE(v94) < 0) {
        operator delete((void *)v93);
      }
      if (SBYTE7(v37) < 0) {
        operator delete(__p[0]);
      }
      if (v31)
      {
        uint64_t v33 = SVG::consumeNumberAlone((uint64_t)(v31 + 64));
        if (v34) {
          *(void *)(a1 + 696) = v33;
        }
      }
      return result;
    }
  }
  else if (!v6)
  {
    goto LABEL_40;
  }
  unint64_t v7 = 0;
  uint64_t v8 = (CFTypeRef *)(a1 + 688);
  unint64_t v9 = (uint64_t *)(v6 + 64);
  long long v90 = 0uLL;
  unint64_t v91 = 0;
  do
  {
    unint64_t v10 = v7;
    unint64_t v7 = SVG::consumeWsp(v9, v7);
  }
  while (v11);
  unint64_t v89 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v87 = v12;
  long long v88 = v12;
  uint64_t v38 = (unsigned char *)0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long __p = v12;
  long long v37 = v12;
  SVG::consumeMovetoDrawtoCommandGroup((uint64_t)__p, v9, v10);
  if ((_BYTE)v38)
  {
    memset(v97, 0, sizeof(v97));
    unint64_t v10 = *((void *)&v37 + 1);
    uint64_t v13 = (char *)__p[0];
    unint64_t v14 = (char *)__p[1];
    while (v13 != v14)
    {
      std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::emplace_back<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>((uint64_t *)v97, (uint64_t)v13);
      v13 += 48;
    }
    while (1)
    {
      unint64_t v17 = v10;
      do
      {
        unint64_t v18 = v17;
        unint64_t v17 = SVG::consumeWsp(v9, v17);
      }
      while (v19);
      SVG::consumeMovetoDrawtoCommandGroup((uint64_t)&v93, v9, v18);
      if (v38 == v96)
      {
        if (!(_BYTE)v38) {
          break;
        }
        std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__vdeallocate(__p);
        *(_OWORD *)long long __p = v93;
        unint64_t v20 = v94;
        unint64_t v94 = 0;
        long long v93 = 0uLL;
        *(void *)&long long v37 = v20;
        *((void *)&v37 + 1) = v95;
      }
      else if ((_BYTE)v38)
      {
        unint64_t v98 = __p;
        std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v98);
        LOBYTE(v38) = 0;
      }
      else
      {
        *(_OWORD *)long long __p = v93;
        unint64_t v21 = v94;
        unint64_t v94 = 0;
        long long v93 = 0uLL;
        *(void *)&long long v37 = v21;
        *((void *)&v37 + 1) = v95;
        LOBYTE(v38) = 1;
      }
      if (v96)
      {
        unint64_t v98 = (void **)&v93;
        std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v98);
      }
      if (!(_BYTE)v38) {
        break;
      }
      unint64_t v10 = *((void *)&v37 + 1);
      uint64_t v15 = (char *)__p[0];
      uint64_t v16 = (char *)__p[1];
      while (v15 != v16)
      {
        std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::emplace_back<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>((uint64_t *)v97, (uint64_t)v15);
        v15 += 48;
      }
    }
    uint64_t v23 = *(void *)&v97[8];
    uint64_t v22 = *(void *)v97;
    *(void *)unint64_t v92 = *(void *)v97;
    *(_OWORD *)&v92[8] = *(_OWORD *)&v97[8];
    memset(v97, 0, sizeof(v97));
    unint64_t v94 = 0;
    long long v93 = 0uLL;
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__init_with_size[abi:nn180100]<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*,std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*>(&v93, v22, v23, 0xAAAAAAAAAAAAAAABLL * ((v23 - v22) >> 4));
    long long v24 = v93;
    long long v87 = v93;
    unint64_t v25 = v94;
    unint64_t v94 = 0;
    unint64_t v95 = v10;
    long long v93 = 0uLL;
    *(void *)&long long v88 = v25;
    *((void *)&v88 + 1) = v10;
    LOBYTE(v89) = 1;
    unint64_t v98 = (void **)&v93;
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v98);
    unint64_t v98 = (void **)v92;
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v98);
    *(void *)&long long v93 = v97;
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v93);
    if ((_BYTE)v38)
    {
      *(void *)&long long v93 = __p;
      std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v93);
    }
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__vdeallocate((void **)&v90);
    long long v90 = v24;
    unint64_t v91 = v25;
    *(void *)&long long v88 = 0;
    long long v87 = 0uLL;
    __p[0] = &v87;
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
  }
  do
    unint64_t v10 = SVG::consumeWsp(v9, v10);
  while (v26);
  CFTypeRef cf = CGPathCreateMutable();
  *(_OWORD *)uint64_t v97 = *MEMORY[0x1E4F1DAD8];
  *(_OWORD *)unint64_t v92 = *(_OWORD *)v97;
  *(void *)&long long v93 = -256;
  *((void *)&v93 + 1) = -1;
  unint64_t v94 = 0xAAAAAAAAAAAAAA00;
  *(void *)&long long v87 = -256;
  *((void *)&v87 + 1) = -1;
  *(void *)&long long v88 = 0xAAAAAAAAAAAAAA00;
  uint64_t v85 = v97;
  __p[0] = &v93;
  __p[1] = &v87;
  *(void *)&long long v37 = &cf;
  *((void *)&v37 + 1) = v97;
  uint64_t v38 = v92;
  unint64_t v39 = &v93;
  BOOL v40 = &v87;
  uint64_t v41 = v97;
  uint64_t v42 = &v85;
  p_CFTypeRef cf = &cf;
  double v44 = v92;
  uint64_t v45 = &v93;
  CGPathRef v46 = &v87;
  unint64_t v47 = v97;
  uint64_t v48 = &v85;
  uint64_t v49 = &cf;
  uint64_t v50 = &v93;
  uint64_t v51 = &v87;
  unint64_t v52 = v97;
  uint64_t v53 = &v85;
  uint64_t v54 = &cf;
  uint64_t v55 = &v93;
  uint64_t v56 = &v87;
  uint64_t v57 = v97;
  unint64_t v58 = &v85;
  uint64_t v59 = &cf;
  uint64_t v60 = &v87;
  uint64_t v61 = v97;
  long long v62 = &v85;
  unint64_t v63 = &v93;
  uint64_t v64 = &cf;
  uint64_t v65 = &v87;
  long long v66 = v97;
  uint64_t v67 = &v93;
  long long v68 = &v85;
  long long v69 = &cf;
  uint64_t v70 = &v93;
  uint64_t v71 = v97;
  unint64_t v72 = &v85;
  uint64_t v73 = &v87;
  uint64_t v74 = &cf;
  uint64_t v75 = &v93;
  uint64_t v76 = v97;
  uint64_t v77 = &v87;
  uint64_t v78 = &v85;
  char v79 = &cf;
  int64_t v80 = &v93;
  unint64_t v81 = &v87;
  uint64_t v82 = v97;
  unint64_t v83 = &v85;
  uint64_t v84 = &cf;
  uint64_t v28 = *((void *)&v90 + 1);
  uint64_t v27 = v90;
  if ((void)v90 == *((void *)&v90 + 1))
  {
LABEL_34:
    CFTypeRef v30 = cf;
    if (cf)
    {
      CFRetain(cf);
      if (cf) {
        CFRelease(cf);
      }
    }
    __p[0] = &v90;
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
    if (*v8) {
      CFRelease(*v8);
    }
    *uint64_t v8 = v30;
    goto LABEL_40;
  }
  while (1)
  {
    uint64_t v29 = *(unsigned int *)(v27 + 40);
    if (v29 == -1) {
      break;
    }
    unint64_t v98 = __p;
    ((void (*)(void ***, uint64_t))off_1F1A75800[v29])(&v98, v27);
    v27 += 48;
    if (v27 == v28) {
      goto LABEL_34;
    }
  }
  unint64_t v35 = (SVG::PathElement *)std::__throw_bad_variant_access[abi:nn180100]();
  return SVG::PathElement::boundingBox(v35, v99);
}

double SVG::PathElement::boundingBox(SVG::PathElement *this, CGRect a2)
{
  int8x8_t v2 = (const CGPath *)*((void *)this + 86);
  if (v2)
  {
    CFRetain(*((CFTypeRef *)this + 86));
    PathCGRect BoundingBox = (unint64_t)CGPathGetPathBoundingBox(v2);
    CFRelease(v2);
  }
  else
  {
    PathCGRect BoundingBox = (unint64_t)CGPathGetPathBoundingBox(0);
  }
  return *(double *)&PathBoundingBox;
}

CFTypeRef SVG::PathElement::path@<X0>(SVG::PathElement *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, void *a3@<X8>)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 86);
  *a3 = result;
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void SVG::PathElement::~PathElement(SVG::PathElement *this)
{
  *(void *)this = &unk_1F1A74540;
  int8x8_t v2 = (const void *)*((void *)this + 86);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A75850[v3])(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A75868[v4])(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A75880[v5])(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A75868[v6])(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))off_1F1A75880[v7])(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;

  *(void *)this = &unk_1F1A74540;
  int8x8_t v2 = (const void *)*((void *)this + 86);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A75850[v3])(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A75868[v4])(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A75880[v5])(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A75868[v6])(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))off_1F1A75880[v7])(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

void SVG::consumeMovetoDrawtoCommandGroup(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v48 = v5;
  long long v49 = v5;
  long long v47 = v5;
  SVG::consumeSingleDrawtoCommand<std::vector<CGPoint>>(&v47, (uint64_t)a2, a3, 0x4Du, 0x6Du, (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeMovetoArgumentSequence);
  if (!BYTE8(v49))
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 32) = 0;
    return;
  }
  unint64_t v7 = *((void *)&v48 + 1);
  uint64_t v6 = v48;
  char v8 = v49;
  long long v26 = v47;
  *(void *)&long long v49 = (char *)&v35 + 8;
  char v9 = operator new(0x30uLL);
  *(_OWORD *)char v9 = v26;
  char v10 = (char *)(v9 + 6);
  void v9[2] = v6;
  void v9[3] = v7;
  *((unsigned char *)v9 + 32) = v8;
  *((_DWORD *)v9 + 1CGContextBeginTransparencyLayer(c, 0) = 1;
  uint64_t v34 = (uint64_t)v9;
  *((void *)&v35 + 1) = v9 + 6;
  long long v47 = 0u;
  long long v48 = 0u;
  std::__split_buffer<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::~__split_buffer((uint64_t)&v47);
  *(void *)&long long v35 = v10;
  do
  {
    unint64_t v11 = v7;
    unint64_t v7 = SVG::consumeWsp(a2, v7);
  }
  while (v12);
  unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v32 = v13;
  *(_OWORD *)&v32[16] = v13;
  unint64_t v50 = 0xAAAAAAAAAAAAAAAALL;
  long long v48 = v13;
  long long v49 = v13;
  long long v47 = v13;
  SVG::consumeDrawtoCommand((uint64_t)&v47, (uint64_t)a2, v11);
  if (!(_BYTE)v50)
  {
    uint64_t v23 = v34;
    uint64_t v28 = v34;
    uint64_t v24 = v35;
    long long v29 = v35;
    uint64_t v34 = 0;
    long long v35 = 0uLL;
    *(void *)&long long v48 = 0;
    long long v47 = 0uLL;
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__init_with_size[abi:nn180100]<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*,std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*>(&v47, v23, v24, 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 4));
    *(_OWORD *)a1 = v47;
    uint64_t v25 = v48;
    long long v47 = 0uLL;
    *(void *)&long long v48 = 0;
    *((void *)&v48 + 1) = v11;
    *(void *)(a1 + 16) = v25;
    *(void *)(a1 + 24) = v11;
    *(unsigned char *)(a1 + 32) = 1;
    uint64_t v42 = (void **)&v47;
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v42);
    uint64_t v42 = (void **)&v28;
    uint64_t v22 = &v42;
    goto LABEL_33;
  }
  uint64_t v39 = 0;
  long long v40 = 0uLL;
  char v38 = -86;
  if (DWORD2(v49) == -1) {
LABEL_34:
  }
    std::__throw_bad_variant_access[abi:nn180100]();
  while (1)
  {
    uint64_t v42 = (void **)&v38;
    unint64_t v14 = ((uint64_t (*)(void ***, long long *))off_1F1A75710[DWORD2(v49)])(&v42, &v47);
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::emplace_back<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>(&v39, (uint64_t)&v47);
    SVG::consumeDrawtoCommand((uint64_t)&v42, (uint64_t)a2, v14);
    if (v50 == v46)
    {
      if (!(_BYTE)v50) {
        break;
      }
      if (DWORD2(v49) == -1)
      {
        if (v45 == -1) {
          goto LABEL_18;
        }
      }
      else if (v45 == -1)
      {
        ((void (*)(void ***, long long *))off_1F1A75670[DWORD2(v49)])(&v41, &v47);
        DWORD2(v49) = -1;
LABEL_18:
        int v15 = v50;
        goto LABEL_19;
      }
      uint64_t v41 = (void **)&v47;
      ((void (*)(void ***, long long *, void ***))off_1F1A75760[v45])(&v41, &v47, &v42);
      goto LABEL_18;
    }
    if ((_BYTE)v50)
    {
      if (DWORD2(v49) != -1) {
        ((void (*)(void ***, long long *))off_1F1A75670[DWORD2(v49)])(&v41, &v47);
      }
      int v15 = 0;
      DWORD2(v49) = -1;
      LOBYTE(v5CGContextBeginTransparencyLayer(c, 0) = 0;
    }
    else
    {
      LOBYTE(v47) = 0;
      DWORD2(v49) = -1;
      std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>((uint64_t)&v47, (uint64_t)&v42);
      int v15 = 1;
      LOBYTE(v5CGContextBeginTransparencyLayer(c, 0) = 1;
    }
LABEL_19:
    if (v46 && v45 != -1) {
      ((void (*)(void ***, void ***))off_1F1A75670[v45])(&v41, &v42);
    }
    if (!v15) {
      break;
    }
    if (DWORD2(v49) == -1) {
      goto LABEL_34;
    }
  }
  uint64_t v16 = v39;
  uint64_t v36 = v39;
  uint64_t v17 = v40;
  long long v37 = v40;
  uint64_t v39 = 0;
  long long v40 = 0uLL;
  long long v43 = 0uLL;
  uint64_t v42 = 0;
  std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__init_with_size[abi:nn180100]<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*,std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*>(&v42, v16, v17, 0xAAAAAAAAAAAAAAABLL * ((v17 - v16) >> 4));
  unint64_t v18 = v42;
  *(void *)uint64_t v32 = v42;
  uint64_t v27 = (void **)v43;
  *(_OWORD *)&v32[8] = v43;
  uint64_t v42 = 0;
  long long v43 = 0uLL;
  unint64_t v44 = v14;
  *(void *)&v32[24] = v14;
  LOBYTE(v33) = 1;
  uint64_t v41 = (void **)&v42;
  std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v41);
  uint64_t v41 = (void **)&v36;
  std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v41);
  uint64_t v42 = (void **)&v39;
  std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v42);
  if ((_BYTE)v50 && DWORD2(v49) != -1) {
    ((void (*)(void ***, long long *))off_1F1A75670[DWORD2(v49)])(&v42, &v47);
  }
  while (v18 != v27)
  {
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::emplace_back<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>(&v34, (uint64_t)v18);
    v18 += 6;
  }
  uint64_t v19 = v34;
  uint64_t v30 = v34;
  uint64_t v20 = v35;
  long long v31 = v35;
  uint64_t v34 = 0;
  long long v35 = 0uLL;
  *(void *)&long long v48 = 0;
  long long v47 = 0uLL;
  std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__init_with_size[abi:nn180100]<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*,std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*>(&v47, v19, v20, 0xAAAAAAAAAAAAAAABLL * ((v20 - v19) >> 4));
  *(_OWORD *)a1 = v47;
  uint64_t v21 = v48;
  long long v47 = 0uLL;
  *(void *)&long long v48 = 0;
  *((void *)&v48 + 1) = v14;
  *(void *)(a1 + 16) = v21;
  *(void *)(a1 + 24) = v14;
  *(unsigned char *)(a1 + 32) = 1;
  uint64_t v42 = (void **)&v47;
  std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v42);
  uint64_t v42 = (void **)&v30;
  std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](&v42);
  *(void *)&long long v47 = v32;
  uint64_t v22 = (void ***)&v47;
LABEL_33:
  std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](v22);
  *(void *)&long long v47 = &v34;
  std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v47);
}

uint64_t std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::emplace_back<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1 + 2;
  unint64_t v5 = a1[2];
  unint64_t v6 = a1[1];
  if (v6 >= v5)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *a1) >> 4);
    if (v9 + 1 > 0x555555555555555) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x555555555555555;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v25 = v4;
    if (v12) {
      unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = v12 + 48 * v9;
    unint64_t v15 = v12 + 48 * v13;
    unint64_t v24 = v15;
    *(unsigned char *)uint64_t v14 = 0;
    *(_DWORD *)(v14 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>(v14, a2);
    uint64_t v8 = v14 + 48;
    v23.i64[1] = v14 + 48;
    uint64_t v17 = *a1;
    unint64_t v16 = a1[1];
    if (v16 == *a1)
    {
      int64x2_t v20 = vdupq_n_s64(v16);
    }
    else
    {
      uint64_t v18 = 0;
      do
      {
        *(unsigned char *)(v14 + v18 - 48) = 0;
        uint64_t v19 = v14 + v18 - 48;
        *(_DWORD *)(v19 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
        v18 -= 48;
        std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>(v19, v16 + v18);
      }
      while (v16 + v18 != v17);
      int64x2_t v20 = *(int64x2_t *)a1;
      v14 += v18;
      uint64_t v8 = v23.i64[1];
      unint64_t v15 = v24;
    }
    *a1 = v14;
    a1[1] = v8;
    int64x2_t v23 = v20;
    uint64_t v21 = a1[2];
    a1[2] = v15;
    unint64_t v24 = v21;
    uint64_t v22 = v20.i64[0];
    uint64_t result = std::__split_buffer<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    *(unsigned char *)unint64_t v6 = 0;
    *(_DWORD *)(v6 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
    uint64_t result = std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>(v6, a2);
    uint64_t v8 = v6 + 48;
  }
  a1[1] = v8;
  return result;
}

unsigned char *SVG::consumeSingleDrawtoCommand<std::vector<CGPoint>>(unsigned char *result, uint64_t a2, unint64_t a3, unsigned __int8 a4, unsigned __int8 a5, void *(*a6)(long long *__return_ptr, uint64_t, unint64_t))
{
  unint64_t v6 = result;
  unint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    unint64_t v7 = *(void *)(a2 + 8);
  }
  if (v7 > a3
    && (v8 >= 0 ? (uint64_t v10 = a2) : (uint64_t v10 = *(void *)a2),
        (int v11 = *(char *)(v10 + a3), v12 = a5, v11 != a4) ? (v13 = v11 == a5) : (v13 = 1),
        v13))
  {
    unint64_t v15 = a3 + 1;
    do
    {
      unint64_t v16 = v15;
      unint64_t v15 = SVG::consumeWsp((uint64_t *)a2, v15);
    }
    while (v17);
    unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v21 = v18;
    long long v22 = v18;
    uint64_t result = a6(&v21, a2, v16);
    char v19 = v23;
    if ((_BYTE)v23)
    {
      long long v20 = v22;
      *(_OWORD *)unint64_t v6 = v21;
      *((_OWORD *)v6 + 1) = v20;
      v6[32] = v11 != v12;
      char v19 = 1;
    }
    else
    {
      *unint64_t v6 = 0;
    }
    v6[40] = v19;
  }
  else
  {
    *uint64_t result = 0;
    result[40] = 0;
  }
  return result;
}

void SVG::consumeMovetoArgumentSequence(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void SVG::consumeOneOrMoreGeneric<CGPoint>(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  *(void *)uint64_t v28 = -1;
  *(void *)&v28[8] = -1;
  *(void *)&v28[16] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v28[24] = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeCoordinatePair(a2, a3, (uint64_t)v28);
  if (v28[24])
  {
    unint64_t v5 = (char *)operator new(0x10uLL);
    unint64_t v6 = v5 + 16;
    *(_OWORD *)unint64_t v5 = *(_OWORD *)v28;
    long long __p = v5;
    long long v31 = v5 + 16;
    while (1)
    {
      uint64_t v30 = v6;
      unint64_t v7 = *(void *)&v28[16];
      unint64_t v8 = SVG::consumeCommaWsp(a2, *(unint64_t *)&v28[16]);
      if (v9) {
        unint64_t v7 = v8;
      }
      SVG::consumeCoordinatePair(a2, v7, (uint64_t)__dst);
      *(_OWORD *)&v28[9] = *(_OWORD *)((char *)__dst + 9);
      *(_OWORD *)uint64_t v28 = __dst[0];
      if (!BYTE8(__dst[1])) {
        break;
      }
      uint64_t v10 = v30;
      if (v30 >= v31)
      {
        uint64_t v11 = (v30 - (unsigned char *)__p) >> 4;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 60) {
          abort();
        }
        uint64_t v13 = v31 - (unsigned char *)__p;
        if ((v31 - (unsigned char *)__p) >> 3 > v12) {
          unint64_t v12 = v13 >> 3;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14) {
          unint64_t v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Length>>((uint64_t)&v31, v14);
        }
        else {
          unint64_t v15 = 0;
        }
        unint64_t v16 = &v15[16 * v11];
        *(_OWORD *)unint64_t v16 = *(_OWORD *)v28;
        long long v18 = (char *)__p;
        char v17 = v30;
        char v19 = v16;
        if (v30 != __p)
        {
          do
          {
            *((_OWORD *)v19 - 1) = *((_OWORD *)v17 - 1);
            v19 -= 16;
            v17 -= 16;
          }
          while (v17 != v18);
          char v17 = (char *)__p;
        }
        unint64_t v6 = v16 + 16;
        long long __p = v19;
        uint64_t v30 = v16 + 16;
        long long v31 = &v15[16 * v14];
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *(_OWORD *)uint64_t v30 = *(_OWORD *)v28;
        unint64_t v6 = v10 + 16;
      }
    }
    long long v21 = (char *)__p;
    long long v20 = v30;
    long long __p = 0;
    uint64_t v30 = 0;
    long long v31 = 0;
    memset(__dst, 0, 24);
    int64_t v22 = v20 - v21;
    if (v20 == v21)
    {
      uint64_t v26 = 0;
      uint64_t v24 = 0;
      uint64_t v25 = 0;
    }
    else
    {
      std::vector<SVG::Length>::__vallocate[abi:nn180100](__dst, v22 >> 4);
      uint64_t v23 = *((void *)&__dst[0] + 1);
      memmove(*((void **)&__dst[0] + 1), v21, v22);
      uint64_t v24 = v23 + v22;
      uint64_t v25 = *(void *)&__dst[0];
      uint64_t v26 = *(void *)&__dst[1];
    }
    *(void *)a1 = v25;
    *(void *)(a1 + 8) = v24;
    *((void *)&__dst[1] + 1) = v7;
    memset(__dst, 0, 24);
    *(void *)(a1 + 16) = v26;
    *(void *)(a1 + 24) = v7;
    *(unsigned char *)(a1 + 32) = 1;
    if (v21) {
      operator delete(v21);
    }
    if (__p)
    {
      uint64_t v30 = (char *)__p;
      operator delete(__p);
    }
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 32) = 0;
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(unint64_t a1)
{
  if (a1 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(48 * a1);
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 40);
  if (v4 != -1) {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))off_1F1A75670[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 40);
  if (v5 != -1)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_1F1A756C0[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 4CGContextBeginTransparencyLayer(c, 0) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEEEEDcSL_DpT0_(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, __n128 *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v4 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v4;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, __n128 *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v4 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v4;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, __n128 *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v4 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v4;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, __n128 *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v4 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v4;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, __n128 *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v4 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v4;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, __n128 *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v4 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v4;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, __n128 *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v4 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v4;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, __n128 *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v4 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v4;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSP_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSX_EEEDcSP_DpT0_(uint64_t a1, uint64_t a2, __n128 *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v4 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v4;
  return result;
}

uint64_t std::__split_buffer<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 != v2)
  {
    do
    {
      uint64_t v4 = v3 - 48;
      *(void *)(a1 + 16) = v3 - 48;
      uint64_t v5 = *(unsigned int *)(v3 - 8);
      if (v5 != -1)
      {
        ((void (*)(char *))off_1F1A75670[v5])(&v7);
        uint64_t v4 = *(void *)(a1 + 16);
      }
      *(_DWORD *)(v3 - 8) = -1;
      uint64_t v3 = v4;
    }
    while (v4 != v2);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void SVG::consumeDrawtoCommand(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    unint64_t v6 = *(void *)(a2 + 8);
  }
  if (v6 > a3)
  {
    uint64_t v8 = v7 >= 0 ? a2 : *(void *)a2;
    if ((*(char *)(v8 + a3) | 0x20) == 0x7A)
    {
      __dst[0] = (void *)(a3 + 1);
      DWORD2(v51) = 0;
      *(unsigned char *)a1 = 0;
      *(_DWORD *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
      std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>(a1, (uint64_t)__dst);
      *(unsigned char *)(a1 + 48) = 1;
      if (DWORD2(v51) != -1) {
        ((void (*)(long long *, void **))off_1F1A75670[DWORD2(v51)])(&v45, __dst);
      }
      return;
    }
  }
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v50 = v9;
  long long v51 = v9;
  *(_OWORD *)__dst = v9;
  SVG::consumeSingleDrawtoCommand<std::vector<CGPoint>>(__dst, a2, a3, 0x4Cu, 0x6Cu, (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeLinetoArgumentSequence);
  if (BYTE8(v51))
  {
    uint64_t v11 = __dst[0];
    uint64_t v10 = __dst[1];
    *(void *)&long long v45 = *((void *)&v50 + 1);
    BYTE8(v45) = v51;
    __dst[0] = 0;
    __dst[1] = 0;
    *(void *)&long long v50 = 0;
    int64_t v12 = v10 - v11;
    if (v10 != v11)
    {
      std::vector<SVG::Length>::__vallocate[abi:nn180100](__dst, v12 >> 4);
      uint64_t v13 = (char *)__dst[1];
      memmove(__dst[1], v11, v12);
      __dst[1] = &v13[v12];
    }
    *((void *)&v50 + 1) = v45;
    LOBYTE(v51) = BYTE8(v45);
    int v14 = 2;
LABEL_22:
    DWORD2(v51) = v14;
    *(unsigned char *)a1 = 0;
    *(_DWORD *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>(a1, (uint64_t)__dst);
    *(unsigned char *)(a1 + 48) = 1;
    if (DWORD2(v51) != -1) {
      ((void (*)(char *, void **))off_1F1A75670[DWORD2(v51)])(&v44, __dst);
    }
LABEL_24:
    if (!v11) {
      return;
    }
    uint64_t v23 = v11;
    goto LABEL_26;
  }
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v50 = v15;
  long long v51 = v15;
  *(_OWORD *)__dst = v15;
  SVG::consumeSingleDrawtoCommand<std::vector<CGPoint>>(__dst, a2, a3, 0x48u, 0x68u, (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeHorizontalLinetoArgumentSequence);
  if (BYTE8(v51))
  {
    uint64_t v11 = __dst[0];
    unint64_t v16 = __dst[1];
    *(void *)&long long v45 = *((void *)&v50 + 1);
    BYTE8(v45) = v51;
    __dst[0] = 0;
    __dst[1] = 0;
    *(void *)&long long v50 = 0;
    int64_t v17 = v16 - v11;
    if (v16 != v11)
    {
      std::vector<double>::__vallocate[abi:nn180100](__dst, v17 >> 3);
      long long v18 = (char *)__dst[1];
      memmove(__dst[1], v11, v17);
      __dst[1] = &v18[v17];
    }
    *((void *)&v50 + 1) = v45;
    LOBYTE(v51) = BYTE8(v45);
    int v14 = 3;
    goto LABEL_22;
  }
  *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v50 = v19;
  long long v51 = v19;
  *(_OWORD *)__dst = v19;
  SVG::consumeSingleDrawtoCommand<std::vector<CGPoint>>(__dst, a2, a3, 0x56u, 0x76u, (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeVerticalLinetoArgumentSequence);
  if (BYTE8(v51))
  {
    uint64_t v11 = __dst[0];
    long long v20 = __dst[1];
    *(void *)&long long v45 = *((void *)&v50 + 1);
    BYTE8(v45) = v51;
    __dst[0] = 0;
    __dst[1] = 0;
    *(void *)&long long v50 = 0;
    int64_t v21 = v20 - v11;
    if (v20 != v11)
    {
      std::vector<double>::__vallocate[abi:nn180100](__dst, v21 >> 3);
      int64_t v22 = (char *)__dst[1];
      memmove(__dst[1], v11, v21);
      __dst[1] = &v22[v21];
    }
    *((void *)&v50 + 1) = v45;
    LOBYTE(v51) = BYTE8(v45);
    int v14 = 4;
    goto LABEL_22;
  }
  unint64_t v24 = *(unsigned __int8 *)(a2 + 23);
  int v25 = (char)v24;
  if ((v24 & 0x80u) != 0) {
    unint64_t v24 = *(void *)(a2 + 8);
  }
  if (v24 > a3)
  {
    uint64_t v26 = v25 >= 0 ? a2 : *(void *)a2;
    int v27 = *(unsigned __int8 *)(v26 + a3);
    if ((v27 | 0x20) == 0x63)
    {
      unint64_t v28 = a3 + 1;
      do
      {
        unint64_t v29 = v28;
        unint64_t v28 = SVG::consumeWsp((uint64_t *)a2, v28);
      }
      while (v30);
      *(void *)&long long v51 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v31 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)__dst = v31;
      long long v50 = v31;
      SVG::consumeOneOrMoreGeneric<std::array<CGPoint,3ul>>((uint64_t)__dst, (uint64_t *)a2, v29);
      if ((_BYTE)v51)
      {
        BOOL v32 = v27 != 99;
        uint64_t v11 = __dst[0];
        unint64_t v33 = __dst[1];
        uint64_t v34 = *((void *)&v50 + 1);
        __dst[0] = 0;
        __dst[1] = 0;
        *(void *)&long long v50 = 0;
        int64_t v35 = v33 - v11;
        if (v33 != v11)
        {
          if (0xAAAAAAAAAAAAAAABLL * (v35 >> 4) >= 0x555555555555556) {
            abort();
          }
          uint64_t v36 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(0xAAAAAAAAAAAAAAABLL * (v35 >> 4));
          __dst[0] = v36;
          *(void *)&long long v50 = &v36[48 * v37];
          memmove(v36, v11, v35);
          __dst[1] = &v36[16 * (v35 >> 4)];
        }
        *((void *)&v50 + 1) = v34;
        LOBYTE(v51) = v32;
        DWORD2(v51) = 5;
        *(unsigned char *)a1 = 0;
        *(_DWORD *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
        std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>(a1, (uint64_t)__dst);
        *(unsigned char *)(a1 + 48) = 1;
        if (DWORD2(v51) != -1) {
          ((void (*)(long long *, void **))off_1F1A75670[DWORD2(v51)])(&v45, __dst);
        }
        goto LABEL_24;
      }
    }
  }
  unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v38 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v50 = v38;
  long long v51 = v38;
  *(_OWORD *)__dst = v38;
  SVG::consumeSingleDrawtoCommand<std::vector<CGPoint>>(__dst, a2, a3, 0x53u, 0x73u, (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeSmoothCurvetoArgumentSequence);
  if (BYTE8(v51))
  {
    LOBYTE(v47) = v51;
    long long v43 = __dst[0];
    long long v45 = *(_OWORD *)__dst;
    long long v46 = v50;
    LOBYTE(v48) = 1;
    std::vector<std::array<CGPoint,2ul>>::vector(__dst, (uint64_t)&v45);
    *((void *)&v50 + 1) = *((void *)&v46 + 1);
    LOBYTE(v51) = v47;
    DWORD2(v51) = 6;
    *(unsigned char *)a1 = 0;
    *(_DWORD *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>(a1, (uint64_t)__dst);
    *(unsigned char *)(a1 + 48) = 1;
    if (DWORD2(v51) != -1) {
      ((void (*)(char *, void **))off_1F1A75670[DWORD2(v51)])(&v44, __dst);
    }
    uint64_t v23 = v43;
    if (!v43) {
      return;
    }
LABEL_26:
    operator delete(v23);
    return;
  }
  *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v50 = v39;
  long long v51 = v39;
  *(_OWORD *)__dst = v39;
  SVG::consumeQuadraticBezierCurveto((uint64_t)__dst, a2, a3);
  if (BYTE8(v51))
  {
    std::vector<std::array<CGPoint,2ul>>::vector(&v45, (uint64_t)__dst);
    *((void *)&v46 + 1) = *((void *)&v50 + 1);
    LOBYTE(v47) = v51;
    int v40 = 7;
  }
  else
  {
    *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v50 = v41;
    long long v51 = v41;
    *(_OWORD *)__dst = v41;
    SVG::consumeSmoothQuadraticBezierCurveto((uint64_t)__dst, a2, a3);
    if (BYTE8(v51))
    {
      std::vector<SVG::Length>::vector(&v45, (uint64_t)__dst);
      *((void *)&v46 + 1) = *((void *)&v50 + 1);
      LOBYTE(v47) = v51;
      int v40 = 8;
    }
    else
    {
      *(void *)&long long v42 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v50 = v42;
      long long v51 = v42;
      *(_OWORD *)__dst = v42;
      SVG::consumeEllipticalArc((uint64_t)__dst, a2, a3);
      if (!BYTE8(v51))
      {
        *(unsigned char *)a1 = 0;
        *(unsigned char *)(a1 + 48) = 0;
        return;
      }
      std::vector<SVG::EllipticalArcArgument>::vector(&v45, (uint64_t)__dst);
      *((void *)&v46 + 1) = *((void *)&v50 + 1);
      LOBYTE(v47) = v51;
      int v40 = 9;
    }
  }
  LODWORD(v48) = v40;
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>,(std::__variant_detail::_Trait)1>>(a1, (uint64_t)&v45);
  *(unsigned char *)(a1 + 48) = 1;
  if (v48 != -1) {
    ((void (*)(char *, long long *))off_1F1A75670[v48])(&v44, &v45);
  }
  uint64_t v23 = __dst[0];
  if (__dst[0]) {
    goto LABEL_26;
  }
}

unsigned char *SVG::consumeQuadraticBezierCurveto(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v10 = v4;
  long long v11 = v4;
  long long v9 = v4;
  __n128 result = SVG::consumeSingleDrawtoCommand<std::vector<CGPoint>>(&v9, a2, a3, 0x51u, 0x71u, (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeQuadraticBezierCurvetoArgumentSequence);
  char v6 = BYTE8(v11);
  if (BYTE8(v11))
  {
    unint64_t v8 = *((void *)&v10 + 1);
    unint64_t v7 = v10;
    *(unsigned char *)(a1 + 32) = v11;
    *(_OWORD *)a1 = v9;
    *(_OWORD *)(a1 + 16) = __PAIR128__(v8, v7);
    char v6 = 1;
  }
  else
  {
    *(unsigned char *)a1 = 0;
  }
  *(unsigned char *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = v6;
  return result;
}

unsigned char *SVG::consumeSmoothQuadraticBezierCurveto(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v10 = v4;
  long long v11 = v4;
  long long v9 = v4;
  __n128 result = SVG::consumeSingleDrawtoCommand<std::vector<CGPoint>>(&v9, a2, a3, 0x54u, 0x74u, (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeSmoothQuadraticBezierCurvetoArgumentSequence);
  char v6 = BYTE8(v11);
  if (BYTE8(v11))
  {
    unint64_t v8 = *((void *)&v10 + 1);
    unint64_t v7 = v10;
    *(unsigned char *)(a1 + 32) = v11;
    *(_OWORD *)a1 = v9;
    *(_OWORD *)(a1 + 16) = __PAIR128__(v8, v7);
    char v6 = 1;
  }
  else
  {
    *(unsigned char *)a1 = 0;
  }
  *(unsigned char *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = v6;
  return result;
}

void SVG::consumeEllipticalArc(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    unint64_t v4 = *(void *)(a2 + 8);
  }
  if (v4 > a3)
  {
    uint64_t v7 = v5 >= 0 ? a2 : *(void *)a2;
    int v8 = *(unsigned __int8 *)(v7 + a3);
    if ((v8 | 0x20) == 0x61)
    {
      unint64_t v9 = a3 + 1;
      do
      {
        unint64_t v10 = v9;
        unint64_t v9 = SVG::consumeWsp((uint64_t *)a2, v9);
      }
      while (v11);
      long long v40 = xmmword_1BF1DAE18;
      long long v41 = unk_1BF1DAE28;
      *(_OWORD *)long long v42 = xmmword_1BF1DAE38;
      *(_OWORD *)&v42[16] = unk_1BF1DAE48;
      SVG::consumeEllipticalArcArgument(a2, v10, (uint64_t)&v40);
      if (v42[24])
      {
        int64_t v12 = (long long *)operator new(0x30uLL);
        uint64_t v13 = (char *)(v12 + 3);
        long long v14 = v41;
        *int64_t v12 = v40;
        v12[1] = v14;
        v12[2] = *(_OWORD *)v42;
        long long v15 = (char *)(v12 + 3);
LABEL_12:
        unint64_t v16 = (char *)v12;
        for (int64_t i = v15 - (char *)v12; ; i += 48)
        {
          unint64_t v18 = *(void *)&v42[16];
          unint64_t v19 = SVG::consumeCommaWsp((uint64_t *)a2, *(unint64_t *)&v42[16]);
          if (v20) {
            unint64_t v18 = v19;
          }
          SVG::consumeEllipticalArcArgument(a2, v18, (uint64_t)v38);
          *(_OWORD *)&v42[9] = *(_OWORD *)&v39[9];
          long long v40 = v38[0];
          long long v41 = v38[1];
          *(_OWORD *)long long v42 = *(_OWORD *)v39;
          if (!v39[24]) {
            break;
          }
          if (v15 >= v13)
          {
            unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (i >> 4);
            unint64_t v24 = v23 + 1;
            if (v23 + 1 > 0x555555555555555) {
              goto LABEL_43;
            }
            if (0x5555555555555556 * ((v13 - v16) >> 4) > v24) {
              unint64_t v24 = 0x5555555555555556 * ((v13 - v16) >> 4);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v13 - v16) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v25 = 0x555555555555555;
            }
            else {
              unint64_t v25 = v24;
            }
            if (v25) {
              unint64_t v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(v25);
            }
            else {
              uint64_t v26 = 0;
            }
            int v27 = (long long *)(v25 + 48 * v23);
            long long v28 = v41;
            *int v27 = v40;
            v27[1] = v28;
            v27[2] = *(_OWORD *)v42;
            if (v15 == v16)
            {
              int64_t v12 = (long long *)(v25 + 48 * v23);
            }
            else
            {
              unint64_t v29 = 0;
              do
              {
                char v30 = &v27[v29 / 0x10];
                long long v31 = *(_OWORD *)&v15[v29 - 48];
                long long v32 = *(_OWORD *)&v15[v29 - 16];
                *(v30 - 2) = *(_OWORD *)&v15[v29 - 32];
                *(v30 - 1) = v32;
                *(v30 - 3) = v31;
                v29 -= 48;
              }
              while (&v15[v29] != v16);
              int64_t v12 = &v27[v29 / 0x10];
            }
            uint64_t v13 = (char *)(v25 + 48 * v26);
            long long v15 = (char *)(v27 + 3);
            if (v16) {
              operator delete(v16);
            }
            goto LABEL_12;
          }
          long long v21 = v40;
          long long v22 = *(_OWORD *)v42;
          *((_OWORD *)v15 + 1) = v41;
          *((_OWORD *)v15 + 2) = v22;
          *(_OWORD *)long long v15 = v21;
          v15 += 48;
        }
        if (v15 == v16)
        {
          uint64_t v36 = 0;
          uint64_t v37 = 0;
          uint64_t v34 = 0;
          if (!v16) {
            goto LABEL_39;
          }
        }
        else
        {
          if (0xAAAAAAAAAAAAAAABLL * (i >> 4) > 0x555555555555555) {
LABEL_43:
          }
            abort();
          uint64_t v34 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(0xAAAAAAAAAAAAAAABLL * (i >> 4));
          uint64_t v36 = &v34[48 * v35];
          memmove(v34, v16, i);
          uint64_t v37 = &v34[16 * (i >> 4)];
          if (!v16) {
            goto LABEL_39;
          }
        }
        operator delete(v16);
LABEL_39:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v37;
        *(void *)(a1 + 16) = v36;
        *(void *)(a1 + 24) = v18;
        *(unsigned char *)(a1 + 32) = v8 != 97;
        char v33 = 1;
        goto LABEL_40;
      }
    }
  }
  char v33 = 0;
  *(unsigned char *)a1 = 0;
LABEL_40:
  *(unsigned char *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = v33;
}

void SVG::consumeLinetoArgumentSequence(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void SVG::consumeHorizontalLinetoArgumentSequence(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  SVG::consumeOneOrMoreGeneric<double>(a1, (void (*)(long long *__return_ptr))SVG::consumeCoordinate, (uint64_t (*)(uint64_t, void))SVG::consumeCommaWsp, a2);
}

void SVG::consumeVerticalLinetoArgumentSequence(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  SVG::consumeOneOrMoreGeneric<double>(a1, (void (*)(long long *__return_ptr))SVG::consumeCoordinate, (uint64_t (*)(uint64_t, void))SVG::consumeCommaWsp, a2);
}

void SVG::consumeCurvetoArgument(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = 0;
  *(void *)&long long v7 = -1;
  *((void *)&v7 + 1) = -1;
  long long v15 = v7;
  long long v16 = v7;
  long long v14 = v7;
  while (1)
  {
    if (v6)
    {
      unint64_t v8 = SVG::consumeCommaWsp(a1, a2);
      if (v9) {
        a2 = v8;
      }
    }
    *(void *)&long long v11 = -1;
    *((void *)&v11 + 1) = -1;
    unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeCoordinatePair(a1, a2, (uint64_t)&v11);
    if (!(_BYTE)v13) {
      break;
    }
    *(long long *)((char *)&v14 + v6) = v11;
    a2 = v12;
    v6 += 16;
    if (v6 == 48)
    {
      long long v10 = v15;
      *(_OWORD *)a3 = v14;
      *(_OWORD *)(a3 + 16) = v10;
      *(_OWORD *)(a3 + 32) = v16;
      *(void *)(a3 + 48) = a2;
      *(unsigned char *)(a3 + 56) = 1;
      return;
    }
  }
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 56) = 0;
}

void SVG::consumeOneOrMoreGeneric<std::array<CGPoint,3ul>>(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  long long v34 = v5;
  *(_OWORD *)uint64_t v35 = v5;
  long long v33 = v5;
  *(void *)&v35[16] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v35[24] = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeCurvetoArgument(a2, a3, (uint64_t)&v33);
  if (v35[24])
  {
    uint64_t v6 = (char *)operator new(0x30uLL);
    long long v7 = v6 + 48;
    long long v8 = v34;
    *(_OWORD *)uint64_t v6 = v33;
    *((_OWORD *)v6 + 1) = v8;
    *((_OWORD *)v6 + 2) = *(_OWORD *)v35;
    char v9 = v6 + 48;
LABEL_3:
    long long v10 = v6;
    for (int64_t i = v9 - v6; ; i += 48)
    {
      unint64_t v12 = *(void *)&v35[16];
      unint64_t v13 = SVG::consumeCommaWsp(a2, *(unint64_t *)&v35[16]);
      if (v14) {
        unint64_t v12 = v13;
      }
      SVG::consumeCurvetoArgument(a2, v12, (uint64_t)v31);
      *(_OWORD *)&v35[9] = *(_OWORD *)&v32[9];
      long long v33 = v31[0];
      long long v34 = v31[1];
      *(_OWORD *)uint64_t v35 = *(_OWORD *)v32;
      if (!v32[24]) {
        break;
      }
      if (v9 >= v7)
      {
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (i >> 4);
        unint64_t v18 = v17 + 1;
        if (v17 + 1 > 0x555555555555555) {
          goto LABEL_33;
        }
        if (0x5555555555555556 * ((v7 - v10) >> 4) > v18) {
          unint64_t v18 = 0x5555555555555556 * ((v7 - v10) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v7 - v10) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v19 = 0x555555555555555;
        }
        else {
          unint64_t v19 = v18;
        }
        if (v19) {
          unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(v19);
        }
        else {
          uint64_t v20 = 0;
        }
        long long v21 = (_OWORD *)(v19 + 48 * v17);
        long long v22 = v34;
        *long long v21 = v33;
        v21[1] = v22;
        v21[2] = *(_OWORD *)v35;
        if (v9 == v10)
        {
          uint64_t v6 = (char *)(v19 + 48 * v17);
        }
        else
        {
          unint64_t v23 = 0;
          do
          {
            unint64_t v24 = &v21[v23 / 0x10];
            long long v25 = *(_OWORD *)&v9[v23 - 48];
            long long v26 = *(_OWORD *)&v9[v23 - 16];
            *(v24 - 2) = *(_OWORD *)&v9[v23 - 32];
            *(v24 - 1) = v26;
            *(v24 - 3) = v25;
            v23 -= 48;
          }
          while (&v9[v23] != v10);
          uint64_t v6 = (char *)&v21[v23 / 0x10];
        }
        long long v7 = (char *)(v19 + 48 * v20);
        char v9 = (char *)(v21 + 3);
        if (v10) {
          operator delete(v10);
        }
        goto LABEL_3;
      }
      long long v15 = v33;
      long long v16 = *(_OWORD *)v35;
      *((_OWORD *)v9 + 1) = v34;
      *((_OWORD *)v9 + 2) = v16;
      *(_OWORD *)char v9 = v15;
      v9 += 48;
    }
    if (v9 == v10)
    {
      unint64_t v29 = 0;
      char v30 = 0;
      int v27 = 0;
    }
    else
    {
      if (0xAAAAAAAAAAAAAAABLL * (i >> 4) > 0x555555555555555) {
LABEL_33:
      }
        abort();
      int v27 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(0xAAAAAAAAAAAAAAABLL * (i >> 4));
      unint64_t v29 = &v27[48 * v28];
      memmove(v27, v10, i);
      char v30 = &v27[16 * (i >> 4)];
    }
    *(void *)a1 = v27;
    *(void *)(a1 + 8) = v30;
    *(void *)(a1 + 16) = v29;
    *(void *)(a1 + 24) = v12;
    *(unsigned char *)(a1 + 32) = 1;
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 32) = 0;
  }
}

void SVG::consumeSmoothCurvetoArgumentSequence(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  SVG::consumeOneOrMoreGeneric<std::array<CGPoint,2ul>>(a3, a1, a2, (void (*)(long long *__return_ptr, uint64_t *, uint64_t))SVG::consumeSmoothCurvetoArgument);
}

void SVG::consumeSmoothCurvetoArgument(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void SVG::consumeOneOrMoreGeneric<std::array<CGPoint,2ul>>(uint64_t a1, uint64_t *a2, uint64_t a3, void (*a4)(long long *__return_ptr, uint64_t *, uint64_t))
{
  *(void *)&long long v7 = -1;
  *((void *)&v7 + 1) = -1;
  long long v33 = v7;
  *(_OWORD *)long long v34 = v7;
  *(void *)&v34[16] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v34[24] = 0xAAAAAAAAAAAAAAAALL;
  a4(&v33, a2, a3);
  if (v34[24])
  {
    long long v8 = (char *)operator new(0x20uLL);
    char v9 = v8 + 32;
    long long v10 = *(_OWORD *)v34;
    *(_OWORD *)long long v8 = v33;
    *((_OWORD *)v8 + 1) = v10;
    long long v11 = v8 + 32;
LABEL_3:
    unint64_t v12 = v8;
    for (int64_t i = v11 - v8; ; i += 32)
    {
      unint64_t v14 = *(void *)&v34[16];
      unint64_t v15 = SVG::consumeCommaWsp(a2, *(unint64_t *)&v34[16]);
      if (v16) {
        unint64_t v14 = v15;
      }
      a4(&v31, a2, v14);
      *(_OWORD *)&v34[9] = *(_OWORD *)&v32[9];
      long long v33 = v31;
      *(_OWORD *)long long v34 = *(_OWORD *)v32;
      if (!v32[24]) {
        break;
      }
      if (v11 >= v9)
      {
        uint64_t v18 = i >> 5;
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 59) {
          goto LABEL_33;
        }
        if ((v9 - v12) >> 4 > v19) {
          unint64_t v19 = (v9 - v12) >> 4;
        }
        if ((unint64_t)(v9 - v12) >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v20 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v19;
        }
        if (v20) {
          unint64_t v20 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::array<CGPoint,2ul>>>(v20);
        }
        else {
          uint64_t v21 = 0;
        }
        long long v22 = *(_OWORD *)v34;
        unint64_t v23 = (_OWORD *)(v20 + 32 * v18);
        *unint64_t v23 = v33;
        v23[1] = v22;
        if (v11 == v12)
        {
          long long v8 = (char *)(v20 + 32 * v18);
        }
        else
        {
          uint64_t v24 = 0;
          do
          {
            long long v25 = &v23[v24];
            long long v26 = *(_OWORD *)&v11[v24 * 16 - 16];
            *(v25 - 2) = *(_OWORD *)&v11[v24 * 16 - 32];
            *(v25 - 1) = v26;
            v24 -= 2;
          }
          while (&v11[v24 * 16] != v12);
          long long v8 = (char *)&v23[v24];
        }
        char v9 = (char *)(v20 + 32 * v21);
        long long v11 = (char *)(v23 + 2);
        if (v12) {
          operator delete(v12);
        }
        goto LABEL_3;
      }
      long long v17 = *(_OWORD *)v34;
      *(_OWORD *)long long v11 = v33;
      *((_OWORD *)v11 + 1) = v17;
      v11 += 32;
    }
    if (v11 == v12)
    {
      unint64_t v29 = 0;
      char v30 = 0;
      int v27 = 0;
    }
    else
    {
      if (i < 0) {
LABEL_33:
      }
        abort();
      int v27 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::array<CGPoint,2ul>>>((unint64_t)i >> 5);
      unint64_t v29 = &v27[32 * v28];
      memmove(v27, v12, i);
      char v30 = &v27[i];
    }
    *(void *)a1 = v27;
    *(void *)(a1 + 8) = v30;
    *(void *)(a1 + 16) = v29;
    *(void *)(a1 + 24) = v14;
    *(unsigned char *)(a1 + 32) = 1;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 32) = 0;
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::array<CGPoint,2ul>>>(unint64_t a1)
{
  if (a1 >> 59) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(32 * a1);
}

void *std::vector<std::array<CGPoint,2ul>>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<std::array<CGPoint,2ul>>::__vallocate[abi:nn180100](a1, v5 >> 5);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<std::array<CGPoint,2ul>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::array<CGPoint,2ul>>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void SVG::consumeWspCommaList<CGPoint,2ul>(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  char v6 = 0;
  uint64_t v7 = 0;
  *(void *)&long long v8 = -1;
  *((void *)&v8 + 1) = -1;
  long long v17 = v8;
  long long v18 = v8;
  char v9 = 1;
  while (1)
  {
    char v10 = v9;
    if (v6)
    {
      unint64_t v11 = SVG::consumeCommaWsp(a2, a3);
      if (v12) {
        a3 = v11;
      }
    }
    *(void *)&long long v14 = -1;
    *((void *)&v14 + 1) = -1;
    unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeCoordinatePair(a2, a3, (uint64_t)&v14);
    if (!(_BYTE)v16) {
      break;
    }
    char v9 = 0;
    *(&v17 + v7) = v14;
    a3 = v15;
    char v6 = 1;
    uint64_t v7 = 1;
    if ((v10 & 1) == 0)
    {
      long long v13 = v18;
      *(_OWORD *)a1 = v17;
      *(_OWORD *)(a1 + 16) = v13;
      *(void *)(a1 + 32) = a3;
      *(unsigned char *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = 1;
      return;
    }
  }
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = 0;
}

void SVG::consumeQuadraticBezierCurvetoArgumentSequence(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  SVG::consumeOneOrMoreGeneric<std::array<CGPoint,2ul>>(a3, a1, a2, (void (*)(long long *__return_ptr, uint64_t *, uint64_t))SVG::consumeQuadraticBezierCurvetoArgument);
}

void SVG::consumeQuadraticBezierCurvetoArgument(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void SVG::consumeSmoothQuadraticBezierCurvetoArgumentSequence(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void SVG::consumeEllipticalArcArgument(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v47 = -1;
  unint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v49 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeNonnegativeNumber((uint64_t)&v47, (uint64_t *)a1, a2);
  if (!(_BYTE)v49) {
    goto LABEL_33;
  }
  unint64_t v5 = v48;
  unint64_t v6 = SVG::consumeCommaWsp((uint64_t *)a1, v48);
  unint64_t v8 = v7 ? v6 : v5;
  uint64_t v44 = -1;
  unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeNonnegativeNumber((uint64_t)&v44, (uint64_t *)a1, v8);
  if (!(_BYTE)v46) {
    goto LABEL_33;
  }
  unint64_t v9 = v45;
  unint64_t v10 = SVG::consumeCommaWsp((uint64_t *)a1, v45);
  unint64_t v12 = v11 ? v10 : v9;
  double v41 = NAN;
  unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumePathNumber(a1, v12, (uint64_t)&v41);
  if (!(_BYTE)v43) {
    goto LABEL_33;
  }
  unint64_t v13 = SVG::consumeCommaWsp((uint64_t *)a1, v42);
  if (!v14) {
    goto LABEL_33;
  }
  unint64_t v15 = v13;
  unint64_t v16 = *(unsigned __int8 *)(a1 + 23);
  int v17 = (char)v16;
  if ((v16 & 0x80u) != 0) {
    unint64_t v16 = *(void *)(a1 + 8);
  }
  if (v16 <= v13) {
    goto LABEL_33;
  }
  if (v17 >= 0) {
    uint64_t v18 = a1;
  }
  else {
    uint64_t v18 = *(void *)a1;
  }
  int v19 = *(char *)(v18 + v13);
  if (v19 == 48)
  {
    char v20 = 0;
  }
  else
  {
    if (v19 != 49) {
      goto LABEL_33;
    }
    char v20 = 1;
  }
  unint64_t v21 = SVG::consumeCommaWsp((uint64_t *)a1, v13 + 1);
  if (v22) {
    unint64_t v23 = v21;
  }
  else {
    unint64_t v23 = v15 + 1;
  }
  unint64_t v24 = *(unsigned __int8 *)(a1 + 23);
  int v25 = (char)v24;
  if ((v24 & 0x80u) != 0) {
    unint64_t v24 = *(void *)(a1 + 8);
  }
  if (v24 <= v23) {
    goto LABEL_33;
  }
  if (v25 >= 0) {
    uint64_t v26 = a1;
  }
  else {
    uint64_t v26 = *(void *)a1;
  }
  int v27 = *(char *)(v26 + v23);
  if (v27 == 48)
  {
    char v28 = 0;
    goto LABEL_36;
  }
  if (v27 != 49)
  {
LABEL_33:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 56) = 0;
    return;
  }
  char v28 = 1;
LABEL_36:
  unint64_t v29 = SVG::consumeCommaWsp((uint64_t *)a1, v23 + 1);
  if (v30) {
    unint64_t v31 = v29;
  }
  else {
    unint64_t v31 = v23 + 1;
  }
  *(void *)&long long v38 = -1;
  *((void *)&v38 + 1) = -1;
  unint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeCoordinatePair((uint64_t *)a1, v31, (uint64_t)&v38);
  char v32 = v40;
  if ((_BYTE)v40)
  {
    unint64_t v33 = v39;
    uint64_t v34 = v47;
    uint64_t v35 = v44;
    double v36 = v41 / 180.0;
    *(_OWORD *)&v50[6] = v38;
    *(_OWORD *)(a3 + 26) = *(_OWORD *)v50;
    uint64_t v37 = *(void *)&v50[14];
    *(void *)a3 = v34;
    *(void *)(a3 + 8) = v35;
    *(double *)(a3 + 16) = v36 * 3.14159265;
    *(unsigned char *)(a3 + 24) = v20;
    *(unsigned char *)(a3 + 25) = v28;
    *(void *)(a3 + 4CGContextBeginTransparencyLayer(c, 0) = v37;
    *(void *)(a3 + 48) = v33;
    char v32 = 1;
  }
  else
  {
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 56) = v32;
}

void *std::vector<SVG::EllipticalArcArgument>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v5 >> 4) >= 0x555555555555556) {
      abort();
    }
    unint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(0xAAAAAAAAAAAAAAABLL * (v5 >> 4));
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[48 * v7];
    memmove(v6, v4, v5);
    a1[1] = &v6[16 * (v5 >> 4)];
  }
  return a1;
}

void SVG::consumeNonnegativeNumber(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v9 = -1;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeFloatingPointConstant(a2, a3, (uint64_t)&v9);
  if ((_BYTE)v11)
  {
    double v6 = *(double *)&v9;
    unint64_t v7 = v10;
  }
  else
  {
    memset(v8, 170, sizeof(v8));
    SVG::consumeIntegerConstant(a2, a3, (uint64_t)v8);
    if (!LOBYTE(v8[2]))
    {
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 16) = 0;
      return;
    }
    double v6 = (double)v8[0];
    unint64_t v7 = v8[1];
  }
  *(double *)a1 = v6;
  *(void *)(a1 + 8) = v7;
  *(unsigned char *)(a1 + 16) = 1;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)a2;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<7ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<8ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<9ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_0,SVG::consumeDrawtoCommands(std::string const&,unsigned long)::$_1> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t result, void *a2, void *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 40);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_1F1A75670[v5])(&v6, v4);
  }
  *(void *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 0;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 40);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      result.n128_u64[0] = std::vector<SVG::Length>::__move_assign(a2, a3).n128_u64[0];
      unint64_t v8 = a3[1].n128_u64[1];
      *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
      *(void *)(a2 + 24) = v8;
      return result;
    }
    ((void (*)(char *, uint64_t))off_1F1A75670[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = 0;
  __n128 result = *a3;
  *(__n128 *)uint64_t v4 = *a3;
  *(void *)(v4 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v9 = a3[1].n128_u64[1];
  *(unsigned char *)(v4 + 32) = a3[2].n128_u8[0];
  *(void *)(v4 + 24) = v9;
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 1;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 40);
  if (v5 != -1)
  {
    if (v5 == 2)
    {
      result.n128_u64[0] = std::vector<SVG::Length>::__move_assign(a2, a3).n128_u64[0];
      unint64_t v8 = a3[1].n128_u64[1];
      *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
      *(void *)(a2 + 24) = v8;
      return result;
    }
    ((void (*)(char *, uint64_t))off_1F1A75670[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = 0;
  __n128 result = *a3;
  *(__n128 *)uint64_t v4 = *a3;
  *(void *)(v4 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v9 = a3[1].n128_u64[1];
  *(unsigned char *)(v4 + 32) = a3[2].n128_u8[0];
  *(void *)(v4 + 24) = v9;
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 2;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 40);
  if (v5 != -1)
  {
    if (v5 == 3)
    {
      result.n128_u64[0] = std::vector<SVG::Length>::__move_assign(a2, a3).n128_u64[0];
      unint64_t v8 = a3[1].n128_u64[1];
      *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
      *(void *)(a2 + 24) = v8;
      return result;
    }
    ((void (*)(char *, uint64_t))off_1F1A75670[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = 0;
  __n128 result = *a3;
  *(__n128 *)uint64_t v4 = *a3;
  *(void *)(v4 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v9 = a3[1].n128_u64[1];
  *(unsigned char *)(v4 + 32) = a3[2].n128_u8[0];
  *(void *)(v4 + 24) = v9;
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 40);
  if (v5 != -1)
  {
    if (v5 == 4)
    {
      result.n128_u64[0] = std::vector<SVG::Length>::__move_assign(a2, a3).n128_u64[0];
      unint64_t v8 = a3[1].n128_u64[1];
      *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
      *(void *)(a2 + 24) = v8;
      return result;
    }
    ((void (*)(char *, uint64_t))off_1F1A75670[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = 0;
  __n128 result = *a3;
  *(__n128 *)uint64_t v4 = *a3;
  *(void *)(v4 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v9 = a3[1].n128_u64[1];
  *(unsigned char *)(v4 + 32) = a3[2].n128_u8[0];
  *(void *)(v4 + 24) = v9;
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 4;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 40);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 5)
  {
    ((void (*)(char *, uint64_t))off_1F1A75670[v5])(&v11, v4);
LABEL_7:
    *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
    *(void *)(v4 + 8) = 0;
    *(void *)(v4 + 16) = 0;
    *(void *)uint64_t v4 = 0;
    __n128 result = *a3;
    *(__n128 *)uint64_t v4 = *a3;
    *(void *)(v4 + 16) = a3[1].n128_u64[0];
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    unint64_t v10 = a3[1].n128_u64[1];
    *(unsigned char *)(v4 + 32) = a3[2].n128_u8[0];
    *(void *)(v4 + 24) = v10;
    *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 5;
    return result;
  }
  unint64_t v7 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v7;
    operator delete(v7);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v9 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v9;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 40);
  if (v5 != -1)
  {
    if (v5 == 6)
    {
      result.n128_u64[0] = std::vector<SVG::Length>::__move_assign(a2, a3).n128_u64[0];
      unint64_t v8 = a3[1].n128_u64[1];
      *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
      *(void *)(a2 + 24) = v8;
      return result;
    }
    ((void (*)(char *, uint64_t))off_1F1A75670[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = 0;
  __n128 result = *a3;
  *(__n128 *)uint64_t v4 = *a3;
  *(void *)(v4 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v9 = a3[1].n128_u64[1];
  *(unsigned char *)(v4 + 32) = a3[2].n128_u8[0];
  *(void *)(v4 + 24) = v9;
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 6;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 40);
  if (v5 != -1)
  {
    if (v5 == 7)
    {
      result.n128_u64[0] = std::vector<SVG::Length>::__move_assign(a2, a3).n128_u64[0];
      unint64_t v8 = a3[1].n128_u64[1];
      *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
      *(void *)(a2 + 24) = v8;
      return result;
    }
    ((void (*)(char *, uint64_t))off_1F1A75670[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = 0;
  __n128 result = *a3;
  *(__n128 *)uint64_t v4 = *a3;
  *(void *)(v4 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v9 = a3[1].n128_u64[1];
  *(unsigned char *)(v4 + 32) = a3[2].n128_u8[0];
  *(void *)(v4 + 24) = v9;
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 7;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 40);
  if (v5 != -1)
  {
    if (v5 == 8)
    {
      result.n128_u64[0] = std::vector<SVG::Length>::__move_assign(a2, a3).n128_u64[0];
      unint64_t v8 = a3[1].n128_u64[1];
      *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
      *(void *)(a2 + 24) = v8;
      return result;
    }
    ((void (*)(char *, uint64_t))off_1F1A75670[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = 0;
  __n128 result = *a3;
  *(__n128 *)uint64_t v4 = *a3;
  *(void *)(v4 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v9 = a3[1].n128_u64[1];
  *(unsigned char *)(v4 + 32) = a3[2].n128_u8[0];
  *(void *)(v4 + 24) = v9;
  *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 8;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISI_LNS0_6_TraitE1EEEEEvOT_EUlRSO_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEEOSW_EEEDcSO_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 40);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 9)
  {
    ((void (*)(char *, uint64_t))off_1F1A75670[v5])(&v11, v4);
LABEL_7:
    *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = -1;
    *(void *)(v4 + 8) = 0;
    *(void *)(v4 + 16) = 0;
    *(void *)uint64_t v4 = 0;
    __n128 result = *a3;
    *(__n128 *)uint64_t v4 = *a3;
    *(void *)(v4 + 16) = a3[1].n128_u64[0];
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    unint64_t v10 = a3[1].n128_u64[1];
    *(unsigned char *)(v4 + 32) = a3[2].n128_u8[0];
    *(void *)(v4 + 24) = v10;
    *(_DWORD *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = 9;
    return result;
  }
  unint64_t v7 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v7;
    operator delete(v7);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  unint64_t v9 = a3[1].n128_u64[1];
  *(unsigned char *)(a2 + 32) = a3[2].n128_u8[0];
  *(void *)(a2 + 24) = v9;
  return result;
}

void *std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__init_with_size[abi:nn180100]<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*,std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x555555555555556) {
      abort();
    }
    char v6 = result;
    __n128 result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(a4);
    unint64_t v7 = result;
    *char v6 = result;
    v6[1] = result;
    void v6[2] = &result[6 * v8];
    if (a2 != a3)
    {
      unint64_t v9 = result;
      do
      {
        *(unsigned char *)unint64_t v9 = 0;
        *((_DWORD *)v9 + 1CGContextBeginTransparencyLayer(c, 0) = -1;
        uint64_t v10 = *(unsigned int *)(a2 + 40);
        if (v10 != -1)
        {
          __n128 result = (void *)((uint64_t (*)(char *, void *, uint64_t))off_1F1A757B0[v10])(&v11, v9, a2);
          *((_DWORD *)v9 + 1CGContextBeginTransparencyLayer(c, 0) = v10;
        }
        a2 += 48;
        v9 += 6;
        v7 += 6;
      }
      while (a2 != a3);
    }
    v6[1] = v7;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, void *a2, uint64_t a3)
{
  __n128 result = std::vector<SVG::Length>::vector(a2, a3);
  uint64_t v5 = *(void *)(a3 + 24);
  *((unsigned char *)result + 32) = *(unsigned char *)(a3 + 32);
  result[3] = v5;
  return result;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, void *a2, uint64_t a3)
{
  __n128 result = std::vector<SVG::Length>::vector(a2, a3);
  uint64_t v5 = *(void *)(a3 + 24);
  *((unsigned char *)result + 32) = *(unsigned char *)(a3 + 32);
  result[3] = v5;
  return result;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, void *a2, uint64_t a3)
{
  __n128 result = std::vector<double>::vector(a2, a3);
  uint64_t v5 = *(void *)(a3 + 24);
  *((unsigned char *)result + 32) = *(unsigned char *)(a3 + 32);
  result[3] = v5;
  return result;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, void *a2, uint64_t a3)
{
  __n128 result = std::vector<double>::vector(a2, a3);
  uint64_t v5 = *(void *)(a3 + 24);
  *((unsigned char *)result + 32) = *(unsigned char *)(a3 + 32);
  result[3] = v5;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  char v6 = *(const void **)a3;
  uint64_t v5 = *(void *)(a3 + 8);
  int64_t v7 = v5 - *(void *)a3;
  if (v5 != *(void *)a3)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v7 >> 4) >= 0x555555555555556) {
      abort();
    }
    uint64_t v8 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>>(0xAAAAAAAAAAAAAAABLL * (v7 >> 4));
    *(void *)a2 = v8;
    *(void *)(a2 + 8) = v8;
    *(void *)(a2 + 16) = &v8[48 * v9];
    memmove(v8, v6, v7);
    *(void *)(a2 + 8) = &v8[16 * (v7 >> 4)];
  }
  uint64_t v10 = *(void *)(a3 + 24);
  *(unsigned char *)(a2 + 32) = *(unsigned char *)(a3 + 32);
  *(void *)(a2 + 24) = v10;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, void *a2, uint64_t a3)
{
  __n128 result = std::vector<std::array<CGPoint,2ul>>::vector(a2, a3);
  uint64_t v5 = *(void *)(a3 + 24);
  *((unsigned char *)result + 32) = *(unsigned char *)(a3 + 32);
  result[3] = v5;
  return result;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, void *a2, uint64_t a3)
{
  __n128 result = std::vector<std::array<CGPoint,2ul>>::vector(a2, a3);
  uint64_t v5 = *(void *)(a3 + 24);
  *((unsigned char *)result + 32) = *(unsigned char *)(a3 + 32);
  result[3] = v5;
  return result;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, void *a2, uint64_t a3)
{
  __n128 result = std::vector<SVG::Length>::vector(a2, a3);
  uint64_t v5 = *(void *)(a3 + 24);
  *((unsigned char *)result + 32) = *(unsigned char *)(a3 + 32);
  result[3] = v5;
  return result;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJmN3SVG6MovetoENS8_6LinetoENS8_16HorizontalLinetoENS8_14VerticalLinetoENS8_7CurvetoENS8_13SmoothCurvetoENS8_22QuadraticBezierCurvetoENS8_28SmoothQuadraticBezierCurvetoENS8_13EllipticalArcEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISI_LNS0_6_TraitE1EEEEEvRSJ_OT_EUlRSR_OT0_E_JRNS0_6__baseILSM_1EJmS9_SA_SB_SC_SD_SE_SF_SG_SH_EEERKSZ_EEEDcSR_DpT0_(uint64_t a1, void *a2, uint64_t a3)
{
  __n128 result = std::vector<SVG::EllipticalArcArgument>::vector(a2, a3);
  uint64_t v5 = *(void *)(a3 + 24);
  *((unsigned char *)result + 32) = *(unsigned char *)(a3 + 32);
  result[3] = v5;
  return result;
}

void std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__vdeallocate(void **a1)
{
  if (*a1)
  {
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__clear[abi:nn180100](a1);
    operator delete(*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void *std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__clear[abi:nn180100](void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  if (v3 != *result)
  {
    do
    {
      uint64_t v4 = v3 - 48;
      uint64_t v5 = *(unsigned int *)(v3 - 8);
      if (v5 != -1) {
        __n128 result = (void *)((uint64_t (*)(char *, uint64_t))off_1F1A75670[v5])(&v6, v3 - 48);
      }
      *(_DWORD *)(v3 - 8) = -1;
      v3 -= 48;
    }
    while (v4 != v2);
  }
  v1[1] = v2;
  return result;
}

__n128 std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (*(unsigned char *)(v2 + 16)) {
    *(unsigned char *)(v2 + 16) = 0;
  }
  uint64_t v3 = v1[1];
  if (*(unsigned char *)(v3 + 16)) {
    *(unsigned char *)(v3 + 16) = 0;
  }
  CGPathCloseSubpath(*(CGMutablePathRef *)v1[2]);
  uint64_t v4 = (__n128 *)v1[4];
  __n128 result = *v4;
  *(__n128 *)v1[3] = *v4;
  return result;
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 40);
  if (*(unsigned char *)(v4 + 16)) {
    *(unsigned char *)(v4 + 16) = 0;
  }
  uint64_t v5 = *(void *)(v3 + 48);
  if (*(unsigned char *)(v5 + 16)) {
    *(unsigned char *)(v5 + 16) = 0;
  }
  uint64_t v6 = *a2;
  if (a2[1] != *a2)
  {
    unint64_t v7 = 0;
    do
    {
      float64x2_t v8 = *(float64x2_t *)(v6 + 16 * v7);
      if (!*((unsigned char *)a2 + 32)) {
        float64x2_t v8 = vaddq_f64(v8, *(float64x2_t *)**(void **)(v3 + 64));
      }
      uint64_t v9 = **(CGPath ***)(v3 + 72);
      float64_t v10 = v8.f64[1];
      float64x2_t v13 = v8;
      if (v7)
      {
        CGPathAddLineToPoint(v9, 0, v8.f64[0], v8.f64[1]);
        float64x2_t v11 = v13;
      }
      else
      {
        CGPathMoveToPoint(v9, 0, v8.f64[0], v8.f64[1]);
        float64x2_t v11 = v13;
        unint64_t v12 = *(float64_t **)(v3 + 80);
        *unint64_t v12 = v13.f64[0];
        v12[1] = v10;
      }
      *(float64x2_t *)*(void *)(v3 + 56) = v11;
      ++v7;
      uint64_t v6 = *a2;
    }
    while (v7 < (a2[1] - *a2) >> 4);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 88);
  if (*(unsigned char *)(v4 + 16)) {
    *(unsigned char *)(v4 + 16) = 0;
  }
  uint64_t v5 = *(void *)(v3 + 96);
  if (*(unsigned char *)(v5 + 16)) {
    *(unsigned char *)(v5 + 16) = 0;
  }
  uint64_t v6 = *(double **)a2;
  unint64_t v7 = *(double **)(a2 + 8);
  while (v6 != v7)
  {
    double v8 = *v6;
    double v9 = v6[1];
    if (!*(unsigned char *)(a2 + 32))
    {
      float64_t v10 = **(double ***)(v3 + 112);
      double v8 = v8 + *v10;
      double v9 = v9 + v10[1];
    }
    CGPathAddLineToPoint(**(CGMutablePathRef **)(v3 + 120), 0, v8, v9);
    float64x2_t v11 = *(double **)(v3 + 104);
    *float64x2_t v11 = v8;
    v11[1] = v9;
    v6 += 2;
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 128);
  if (*(unsigned char *)(v4 + 16)) {
    *(unsigned char *)(v4 + 16) = 0;
  }
  uint64_t v5 = *(void *)(v3 + 136);
  if (*(unsigned char *)(v5 + 16)) {
    *(unsigned char *)(v5 + 16) = 0;
  }
  uint64_t v6 = *(double **)a2;
  unint64_t v7 = *(double **)(a2 + 8);
  if (*(double **)a2 != v7)
  {
    do
    {
      double v8 = *v6;
      if (*(unsigned char *)(a2 + 32))
      {
        double v9 = *(double *)(*(void *)(v3 + 144) + 8);
      }
      else
      {
        float64_t v10 = **(double ***)(v3 + 152);
        double v8 = v8 + *v10;
        double v9 = v10[1] + 0.0;
      }
      CGPathAddLineToPoint(**(CGMutablePathRef **)(v3 + 160), 0, v8, v9);
      float64x2_t v11 = *(double **)(v3 + 144);
      *float64x2_t v11 = v8;
      v11[1] = v9;
      ++v6;
    }
    while (v6 != v7);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 168);
  if (*(unsigned char *)(v4 + 16)) {
    *(unsigned char *)(v4 + 16) = 0;
  }
  uint64_t v5 = *(void *)(v3 + 176);
  if (*(unsigned char *)(v5 + 16)) {
    *(unsigned char *)(v5 + 16) = 0;
  }
  uint64_t v6 = *(double **)a2;
  unint64_t v7 = *(double **)(a2 + 8);
  if (*(double **)a2 != v7)
  {
    do
    {
      double v8 = *v6;
      if (*(unsigned char *)(a2 + 32))
      {
        double v9 = **(double **)(v3 + 184);
      }
      else
      {
        float64_t v10 = **(double ***)(v3 + 192);
        double v9 = *v10 + 0.0;
        double v8 = v8 + v10[1];
      }
      CGPathAddLineToPoint(**(CGMutablePathRef **)(v3 + 200), 0, v9, v8);
      float64x2_t v11 = *(double **)(v3 + 184);
      *float64x2_t v11 = v9;
      v11[1] = v8;
      ++v6;
    }
    while (v6 != v7);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<5ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 208);
  if (*(unsigned char *)(v4 + 16)) {
    *(unsigned char *)(v4 + 16) = 0;
  }
  uint64_t v5 = *(double **)(a2 + 8);
  if (*(double **)a2 != v5)
  {
    uint64_t v6 = (double *)(*(void *)a2 + 24);
    do
    {
      double v8 = *(v6 - 3);
      double v9 = *(v6 - 2);
      unint64_t v7 = v6 - 3;
      if (*(unsigned char *)(a2 + 32))
      {
        double v10 = *(v6 - 1);
        double v11 = *v6;
      }
      else
      {
        unint64_t v12 = **(double ***)(v3 + 224);
        double v13 = v12[1];
        double v8 = v8 + *v12;
        double v9 = v9 + v13;
        double v10 = *v12 + *(v6 - 1);
        double v11 = v13 + *v6;
      }
      uint64_t v14 = *(void *)(v3 + 232);
      int v15 = *(unsigned __int8 *)(v14 + 16);
      *(double *)uint64_t v14 = v10;
      *(double *)(v14 + 8) = v11;
      if (!v15) {
        *(unsigned char *)(v14 + 16) = 1;
      }
      double v16 = v6[1];
      double v17 = v6[2];
      if (!*(unsigned char *)(a2 + 32))
      {
        uint64_t v18 = **(double ***)(v3 + 224);
        double v16 = v16 + *v18;
        double v17 = v17 + v18[1];
      }
      CGPathAddCurveToPoint(**(CGMutablePathRef **)(v3 + 240), 0, v8, v9, v10, v11, v16, v17);
      int v19 = *(double **)(v3 + 216);
      *int v19 = v16;
      v19[1] = v17;
      v6 += 6;
    }
    while (v7 + 6 != v5);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<6ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 248);
  if (*(unsigned char *)(v4 + 16)) {
    *(unsigned char *)(v4 + 16) = 0;
  }
  uint64_t v5 = *(float64x2_t **)a2;
  uint64_t v6 = *(float64x2_t **)(a2 + 8);
  if (*(float64x2_t **)a2 != v6)
  {
    do
    {
      double v8 = *(float64x2_t **)(v3 + 256);
      uint64_t v7 = *(void *)(v3 + 264);
      int v9 = *(unsigned __int8 *)(v7 + 16);
      if (*(unsigned char *)(v7 + 16)) {
        float64x2_t v10 = vaddq_f64(*v8, vsubq_f64(*v8, *(float64x2_t *)v7));
      }
      else {
        float64x2_t v10 = *v8;
      }
      float64x2_t v11 = *v5;
      if (!*(unsigned char *)(a2 + 32)) {
        float64x2_t v11 = vaddq_f64(v11, *(float64x2_t *)**(void **)(v3 + 272));
      }
      *(float64x2_t *)uint64_t v7 = v11;
      if (!v9) {
        *(unsigned char *)(v7 + 16) = 1;
      }
      double v12 = v5[1].f64[0];
      double v13 = v5[1].f64[1];
      if (!*(unsigned char *)(a2 + 32))
      {
        uint64_t v14 = **(double ***)(v3 + 272);
        double v12 = v12 + *v14;
        double v13 = v13 + v14[1];
      }
      CGPathAddCurveToPoint(**(CGMutablePathRef **)(v3 + 280), 0, v10.f64[0], v10.f64[1], v11.f64[0], v11.f64[1], v12, v13);
      int v15 = *(double **)(v3 + 256);
      *int v15 = v12;
      v15[1] = v13;
      v5 += 2;
    }
    while (v5 != v6);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<7ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 288);
  if (*(unsigned char *)(v4 + 16)) {
    *(unsigned char *)(v4 + 16) = 0;
  }
  uint64_t v5 = *(float64x2_t **)a2;
  uint64_t v6 = *(float64x2_t **)(a2 + 8);
  if (*(float64x2_t **)a2 != v6)
  {
    do
    {
      float64x2_t v7 = *v5;
      if (!*(unsigned char *)(a2 + 32)) {
        float64x2_t v7 = vaddq_f64(v7, *(float64x2_t *)**(void **)(v3 + 304));
      }
      uint64_t v8 = *(void *)(v3 + 312);
      int v9 = *(unsigned __int8 *)(v8 + 16);
      *(float64x2_t *)uint64_t v8 = v7;
      if (!v9) {
        *(unsigned char *)(v8 + 16) = 1;
      }
      double v10 = v5[1].f64[0];
      double v11 = v5[1].f64[1];
      if (!*(unsigned char *)(a2 + 32))
      {
        double v12 = **(double ***)(v3 + 304);
        double v10 = v10 + *v12;
        double v11 = v11 + v12[1];
      }
      CGPathAddQuadCurveToPoint(**(CGMutablePathRef **)(v3 + 320), 0, v7.f64[0], v7.f64[1], v10, v11);
      double v13 = *(double **)(v3 + 296);
      *double v13 = v10;
      v13[1] = v11;
      v5 += 2;
    }
    while (v5 != v6);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<8ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 328);
  if (*(unsigned char *)(v4 + 16)) {
    *(unsigned char *)(v4 + 16) = 0;
  }
  uint64_t v5 = *(double **)a2;
  uint64_t v6 = *(double **)(a2 + 8);
  if (*(double **)a2 != v6)
  {
    do
    {
      uint64_t v8 = *(float64x2_t **)(v3 + 336);
      uint64_t v7 = *(void *)(v3 + 344);
      if (*(unsigned char *)(v7 + 16))
      {
        float64x2_t v9 = vaddq_f64(*v8, vsubq_f64(*v8, *(float64x2_t *)v7));
      }
      else
      {
        float64x2_t v9 = *v8;
        *(unsigned char *)(v7 + 16) = 1;
      }
      *(float64x2_t *)uint64_t v7 = v9;
      double v10 = *v5;
      double v11 = v5[1];
      if (!*(unsigned char *)(a2 + 32))
      {
        double v12 = **(double ***)(v3 + 352);
        double v10 = v10 + *v12;
        double v11 = v11 + v12[1];
      }
      CGPathAddQuadCurveToPoint(**(CGMutablePathRef **)(v3 + 360), 0, v9.f64[0], v9.f64[1], v10, v11);
      double v13 = *(double **)(v3 + 336);
      *double v13 = v10;
      v13[1] = v11;
      v5 += 2;
    }
    while (v5 != v6);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<9ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::parsePath(std::string const&)::$_0,SVG::parsePath(std::string const&)::$_1,SVG::parsePath(std::string const&)::$_2,SVG::parsePath(std::string const&)::$_3,SVG::parsePath(std::string const&)::$_4,SVG::parsePath(std::string const&)::$_5,SVG::parsePath(std::string const&)::$_6,SVG::parsePath(std::string const&)::$_7,SVG::parsePath(std::string const&)::$_8,SVG::parsePath(std::string const&)::$_9> &> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc> &>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 368);
  if (*(unsigned char *)(v4 + 16)) {
    *(unsigned char *)(v4 + 16) = 0;
  }
  uint64_t v5 = *(void *)(v3 + 376);
  if (*(unsigned char *)(v5 + 16)) {
    *(unsigned char *)(v5 + 16) = 0;
  }
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 != v7)
  {
    float64x2_t v8 = *(float64x2_t *)*(void *)(v3 + 384);
    double v9 = 0.5;
    do
    {
      float64x2_t v10 = *(float64x2_t *)(v6 + 32);
      if (!*((unsigned char *)a2 + 32)) {
        float64x2_t v10 = vaddq_f64(v10, *(float64x2_t *)**(void **)(v3 + 392));
      }
      double v11 = *(double *)v6;
      float64x2_t v57 = v10;
      if (*(double *)v6 == 0.0 || (double v12 = *(double *)(v6 + 8), v12 == 0.0))
      {
        CGPathAddLineToPoint(**(CGMutablePathRef **)(v3 + 400), 0, v10.f64[0], v10.f64[1]);
      }
      else
      {
        double v13 = fabs(v11);
        double v14 = fabs(v12);
        float64x2_t v56 = v8;
        double v15 = v9 * vsubq_f64(v8, v10).f64[0];
        double v54 = v8.f64[1];
        float64_t v16 = (v8.f64[1] - v10.f64[1]) * v9;
        double angle = fmod(*(long double *)(v6 + 16), 6.28318531);
        __double2 v17 = __sincos_stret(angle);
        double v51 = v16 * v17.__sinval;
        double v18 = v16 * v17.__sinval + v15 * v17.__cosval;
        double v49 = v15;
        double v50 = v16 * v17.__cosval;
        double v19 = v16 * v17.__cosval - v15 * v17.__sinval;
        double v20 = v18 * v18 / (v11 * v11) + v19 * v19 / (v12 * v12);
        double v21 = sqrt(v20);
        if (v20 <= 1.0) {
          double v22 = 1.0;
        }
        else {
          double v22 = v21;
        }
        double v23 = v14 * v22;
        double v24 = v13 * v22;
        double v25 = sqrt(fmax((v23 * (v24 * v24) * v23 - v19 * (v24 * v24) * v19 - v18 * (v23 * v23) * v18)/ (v18 * (v18 * (v23 * v23)) + v19 * (v24 * v24) * v19), 0.0));
        int v26 = *(unsigned __int8 *)(v6 + 25);
        if (*(unsigned __int8 *)(v6 + 24) == v26) {
          double v25 = -v25;
        }
        double v27 = v19 * (v24 * v25) / v23;
        double v28 = v18 * -(v23 * v25) / v24;
        double v29 = (v18 - v27) / v24;
        double v30 = (v19 - v28) / v23;
        double v31 = sqrt(v30 * v30 + v29 * v29);
        double v32 = (v29 + v30 * 0.0) / v31;
        double v33 = 1.0;
        if (v32 <= 1.0) {
          double v33 = (v29 + v30 * 0.0) / v31;
        }
        if (v32 >= -1.0) {
          double v34 = v33;
        }
        else {
          double v34 = -1.0;
        }
        double v35 = acos(v34);
        if (v30 - v29 * 0.0 < 0.0) {
          double v35 = -v35;
        }
        CGFloat startAngle = v35;
        double v36 = -(v51 + v49 * v17.__cosval);
        double v52 = v27;
        double v37 = (v36 - v27) / v24;
        double v38 = (-(v50 + v49 * -v17.__sinval) - v28) / v23;
        double v39 = (v30 * v38 + v29 * v37) / (v31 * sqrt(v38 * v38 + v37 * v37));
        double v40 = 1.0;
        if (v39 <= 1.0) {
          double v40 = v39;
        }
        if (v39 >= -1.0) {
          double v41 = v40;
        }
        else {
          double v41 = -1.0;
        }
        double v42 = acos(v41);
        if (v29 * v38 - v30 * v37 < 0.0) {
          double v42 = -v42;
        }
        if (v26 || v42 <= 0.0)
        {
          if (v42 >= 0.0 || v26 == 0) {
            double v43 = v42;
          }
          else {
            double v43 = v42 + 6.28318531;
          }
        }
        else
        {
          double v43 = v42 + -6.28318531;
        }
        double v9 = 0.5;
        double v45 = 0.5 * vaddq_f64(v56, v57).f64[0] + v52 * v17.__cosval - v17.__sinval * v28;
        *(void *)&long long v46 = -1;
        *((void *)&v46 + 1) = -1;
        *(_OWORD *)&v63.CGFloat c = v46;
        *(_OWORD *)&v63.tdouble x = v46;
        double v47 = (v54 + v57.f64[1]) * 0.5 + v17.__cosval * v28 + v52 * v17.__sinval;
        *(_OWORD *)&v63.CGFloat a = v46;
        CGAffineTransformMakeRotation(&v62, angle);
        CGAffineTransformScale(&v63, &v62, v24, v23);
        CGAffineTransform v60 = v63;
        CGAffineTransformInvert(&v61, &v60);
        *(void *)&long long v48 = -1;
        *((void *)&v48 + 1) = -1;
        *(_OWORD *)&m.CGFloat c = v48;
        *(_OWORD *)&m.tdouble x = v48;
        CGAffineTransform v58 = v63;
        *(_OWORD *)&m.CGFloat a = v48;
        CGAffineTransformTranslate(&m, &v58, v61.tx + v47 * v61.c + v61.a * v45, v61.ty + v47 * v61.d + v61.b * v45);
        CGPathAddArc(**(CGMutablePathRef **)(v3 + 400), &m, 0.0, 0.0, 1.0, startAngle, startAngle + v43, v43 < 0.0);
      }
      *(float64x2_t *)*(void *)(v3 + 384) = v57;
      v6 += 48;
      float64x2_t v8 = v57;
    }
    while (v6 != v7);
  }
}

void std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::variant<unsigned long,SVG::Moveto,SVG::Lineto,SVG::HorizontalLineto,SVG::VerticalLineto,SVG::Curveto,SVG::SmoothCurveto,SVG::QuadraticBezierCurveto,SVG::SmoothQuadraticBezierCurveto,SVG::EllipticalArc>>::__clear[abi:nn180100](v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

uint64_t SVG::PolyLineElement::PolyLineElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = (void *)SVG::ShapeElement::ShapeElement(a1, a2, a3);
  *uint64_t v5 = &unk_1F1A74850;
  v5[86] = 0;
  v5[88] = 0;
  v5[87] = 0;
  std::string::basic_string[abi:nn180100]<0>(v24, "points");
  std::string::basic_string[abi:nn180100]<0>(&__p, "http://www.w3.org/2000/svg");
  uint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v24, (uint64_t)&__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p);
  }
  if (SBYTE7(v25) < 0)
  {
    operator delete(v24[0]);
    if (!v6) {
      return a1;
    }
  }
  else if (!v6)
  {
    return a1;
  }
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)double v24 = v7;
  long long v25 = v7;
  SVG::consumeListOfCoordinates((uint64_t)(v6 + 64), (uint64_t)v24);
  if (BYTE8(v25))
  {
    float64x2_t v8 = 0;
    double v9 = 0;
    long long __p = 0;
    double v27 = 0;
    double v28 = 0;
    float64x2_t v10 = (char *)v24[0];
    if ((void *)((char *)v24[1] - (char *)v24[0]) >= (void *)0x10)
    {
      double v9 = 0;
      unint64_t v11 = 0;
      do
      {
        double v12 = &v10[16 * v11];
        uint64_t v14 = *(void *)v12;
        uint64_t v13 = *((void *)v12 + 1);
        if (v9 >= v28)
        {
          double v15 = (char *)__p;
          uint64_t v16 = (v9 - (unsigned char *)__p) >> 4;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 60) {
            abort();
          }
          uint64_t v18 = v28 - (unsigned char *)__p;
          if ((v28 - (unsigned char *)__p) >> 3 > v17) {
            unint64_t v17 = v18 >> 3;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19)
          {
            double v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Length>>((uint64_t)&v28, v19);
            double v15 = (char *)__p;
            double v9 = v27;
          }
          else
          {
            double v20 = 0;
          }
          double v21 = &v20[16 * v16];
          *(void *)double v21 = v14;
          *((void *)v21 + 1) = v13;
          double v22 = v21;
          if (v9 != v15)
          {
            do
            {
              *((_OWORD *)v22 - 1) = *((_OWORD *)v9 - 1);
              v22 -= 16;
              v9 -= 16;
            }
            while (v9 != v15);
            double v15 = (char *)__p;
          }
          double v9 = v21 + 16;
          long long __p = v22;
          double v27 = v21 + 16;
          double v28 = &v20[16 * v19];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)double v9 = v14;
          *((void *)v9 + 1) = v13;
          v9 += 16;
        }
        double v27 = v9;
        ++v11;
        float64x2_t v10 = (char *)v24[0];
      }
      while (v11 < (unint64_t)(((char *)v24[1] - (char *)v24[0]) >> 3) >> 1);
      float64x2_t v8 = (char *)__p;
    }
    if ((void **)(a1 + 688) != &__p)
    {
      std::vector<CGPoint>::__assign_with_size[abi:nn180100]<CGPoint*,CGPoint*>((char *)(a1 + 688), v8, (uint64_t)v9, (v9 - v8) >> 4);
      float64x2_t v8 = (char *)__p;
    }
    if (v8)
    {
      double v27 = v8;
      operator delete(v8);
    }
    if (BYTE8(v25) && v24[0])
    {
      v24[1] = v24[0];
      operator delete(v24[0]);
    }
  }
  return a1;
}

void SVG::PolyLineElement::path(const CGPoint **this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, CGPath **a3@<X8>)
{
  Mutable = CGPathCreateMutable();
  CGPathAddLines(Mutable, 0, this[86], this[87] - this[86]);
  *a3 = Mutable;
  if (Mutable)
  {
    CFRetain(Mutable);
    CFRelease(Mutable);
  }
}

float64_t SVG::PolyLineElement::boundingBox(SVG::PolyLineElement *this, CGRect a2)
{
  uint64_t v2 = (float64x2_t *)*((void *)this + 87);
  uint64_t v3 = (float64x2_t *)*((void *)this + 86);
  if (v2 == v3)
  {
    v5.f64[0] = *(float64_t *)MEMORY[0x1E4F1DB28];
  }
  else
  {
    float64x2_t v4 = *v3;
    float64x2_t v5 = *v3;
    do
    {
      float64x2_t v6 = *v3++;
      float64x2_t v5 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v5, v6), (int8x16_t)v6, (int8x16_t)v5);
      float64x2_t v4 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v6, v4), (int8x16_t)v6, (int8x16_t)v4);
    }
    while (v3 != v2);
  }
  return v5.f64[0];
}

void SVG::PolyLineElement::~PolyLineElement(SVG::PolyLineElement *this)
{
  *(void *)this = &unk_1F1A74850;
  uint64_t v2 = (void *)*((void *)this + 86);
  if (v2)
  {
    *((void *)this + 87) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A75898[v3])(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A758B0[v4])(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A758C8[v5])(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A758B0[v6])(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))off_1F1A758C8[v7])(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;

  *(void *)this = &unk_1F1A74850;
  uint64_t v2 = (void *)*((void *)this + 86);
  if (v2)
  {
    *((void *)this + 87) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A75898[v3])(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A758B0[v4])(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A758C8[v5])(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A758B0[v6])(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))off_1F1A758C8[v7])(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

char *std::vector<CGPoint>::__assign_with_size[abi:nn180100]<CGPoint*,CGPoint*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  char v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<SVG::Length>::__vallocate[abi:nn180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    char v12 = (void **)(v7 + 1);
    char v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  char v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    char v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    unint64_t v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *char v12 = &v9[v17];
  return result;
}

unint64_t SVG::consumeWsp(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = *((unsigned __int8 *)a1 + 23);
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    unint64_t v2 = a1[1];
  }
  if (v2 <= a2
    || (v3 >= 0 ? (uint64_t v4 = a1) : (uint64_t v4 = (uint64_t *)*a1),
        (unsigned int v5 = *((char *)v4 + a2), v6 = v5 > 0x20, v7 = (1 << v5) & 0x100002600, !v6) ? (v8 = v7 == 0) : (v8 = 1),
        v8))
  {
    uint64_t v10 = 0;
    unint64_t v9 = 0;
  }
  else
  {
    unint64_t v9 = (a2 + 1) & 0xFFFFFFFFFFFFFF00;
    uint64_t v10 = (a2 + 1);
  }
  return v9 | v10;
}

void SVG::consumeFloatingPointConstant(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)double v42 = v6;
  *(_OWORD *)&v42[16] = v6;
  SVG::consumeDigitSequence(a1, a2, (uint64_t)v42);
  if (!(_BYTE)v43)
  {
    unint64_t v16 = SVG::consumeString<2ul>(".", a1, a2);
    if (v17)
    {
      unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)long long __p = v18;
      *(_OWORD *)&__p[16] = v18;
      SVG::consumeDigitSequence(a1, v16, (uint64_t)__p);
      if ((_BYTE)v41)
      {
        unint64_t v19 = (unsigned __int8 *)operator new(1uLL);
        *unint64_t v19 = 0;
        *(double *)&uint64_t v21 = COERCE_DOUBLE(SVG::digitsToFloat(v19, v19 + 1, (uint64_t *)__p, v20));
        char v23 = v22;
        operator delete(v19);
        if (v23)
        {
          double v24 = *(double *)&v21;
          unint64_t v9 = *(void *)&__p[24];
          if (*(void *)__p) {
            operator delete(*(void **)__p);
          }
          goto LABEL_25;
        }
        if (*(void *)__p) {
          operator delete(*(void **)__p);
        }
      }
    }
LABEL_18:
    unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)double v42 = v30;
    *(_OWORD *)&v42[16] = v30;
    SVG::consumeDigitSequence(a1, a2, (uint64_t)v42);
    if ((_BYTE)v43)
    {
      double v31 = *(void **)v42;
      unint64_t v32 = *(void *)&v42[8] - *(void *)v42;
      if (*(void *)&v42[8] != *(void *)v42)
      {
        uint64_t v33 = 0;
        unint64_t v34 = 0;
        if (v32 <= 1) {
          unint64_t v32 = 1;
        }
        while (1)
        {
          unint64_t v35 = *(unsigned __int8 *)(*(void *)v42 + v33) + 10 * v34;
          if (v35 < v34) {
            goto LABEL_33;
          }
          ++v33;
          unint64_t v34 = v35;
          if (v32 == v33)
          {
            double v36 = (double)v35;
            goto LABEL_29;
          }
        }
      }
      double v36 = 0.0;
LABEL_29:
      memset(__p, 170, 24);
      SVG::consumeExponent((uint64_t)__p, (uint64_t)a1, *(unint64_t *)&v42[24]);
      if (__p[16])
      {
        double v37 = __exp10((double)*(uint64_t *)__p);
        uint64_t v38 = *(void *)&__p[8];
        *(double *)a3 = v36 * v37;
        *(void *)(a3 + 8) = v38;
        *(unsigned char *)(a3 + 16) = 1;
        if (v31) {
          operator delete(v31);
        }
        return;
      }
      if (v31) {
LABEL_33:
      }
        operator delete(v31);
    }
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
    return;
  }
  unint64_t v7 = SVG::consumeString<2ul>(".", a1, *(uint64_t *)&v42[24]);
  if (!v8)
  {
    char v25 = 1;
    unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
    double v24 = NAN;
    char v12 = *(void **)v42;
    if (!*(void *)v42) {
      goto LABEL_17;
    }
LABEL_16:
    operator delete(v12);
    goto LABEL_17;
  }
  unint64_t v9 = v7;
  unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long __p = v10;
  *(_OWORD *)&__p[16] = v10;
  SVG::consumeDigitSequence(a1, v7, (uint64_t)__p);
  if ((_BYTE)v41)
  {
    char v12 = *(void **)v42;
    uint64_t v13 = SVG::digitsToFloat(*(unsigned __int8 **)v42, *(unsigned __int8 **)&v42[8], (uint64_t *)__p, v11);
    if (v14)
    {
      uint64_t v15 = v13;
      unint64_t v9 = *(void *)&__p[24];
      if (*(void *)__p) {
        operator delete(*(void **)__p);
      }
LABEL_15:
      char v25 = 0;
      double v24 = *(double *)&v15;
      if (!v12) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
    if (*(void *)__p) {
      operator delete(*(void **)__p);
    }
  }
  else
  {
    int v26 = operator new(1uLL);
    *int v26 = 0;
    v39[1] = (uint64_t)(v26 + 1);
    v39[2] = (uint64_t)(v26 + 1);
    v39[0] = (uint64_t)v26;
    char v12 = *(void **)v42;
    *(double *)&uint64_t v15 = COERCE_DOUBLE(SVG::digitsToFloat(*(unsigned __int8 **)v42, *(unsigned __int8 **)&v42[8], v39, v27));
    char v29 = v28;
    operator delete(v26);
    if (v29) {
      goto LABEL_15;
    }
  }
  char v25 = 1;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  double v24 = NAN;
  if (v12) {
    goto LABEL_16;
  }
LABEL_17:
  if (v25) {
    goto LABEL_18;
  }
LABEL_25:
  memset(v42, 170, 24);
  SVG::consumeExponent((uint64_t)v42, (uint64_t)a1, v9);
  if (v42[16])
  {
    double v24 = v24 * __exp10((double)*(uint64_t *)v42);
    unint64_t v9 = *(void *)&v42[8];
  }
  *(double *)a3 = v24;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = 1;
}

void SVG::consumeExponent(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    unint64_t v4 = *(void *)(a2 + 8);
  }
  if (v4 <= a3) {
    goto LABEL_19;
  }
  uint64_t v6 = *(void *)a2;
  if (v5 >= 0) {
    uint64_t v6 = a2;
  }
  if ((*(char *)(v6 + a3) | 0x20) != 0x65) {
    goto LABEL_19;
  }
  unint64_t v7 = a3 + 1;
  if (v4 <= a3 + 1)
  {
    char v9 = 1;
  }
  else
  {
    int v8 = *(char *)(v6 + v7);
    char v9 = 1;
    if (v8 != 43)
    {
      if (v8 != 45) {
        goto LABEL_13;
      }
      char v9 = 0;
    }
    unint64_t v7 = a3 + 2;
  }
LABEL_13:
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long __p = v10;
  long long v16 = v10;
  SVG::consumeDigitSequence((uint64_t *)a2, v7, (uint64_t)__p);
  if (!(_BYTE)v17)
  {
LABEL_19:
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 16) = 0;
    return;
  }
  unint64_t v11 = SVG::digitsToInt(v9, (unsigned __int8 **)__p);
  if (!v12)
  {
    if (__p[0]) {
      operator delete(__p[0]);
    }
    goto LABEL_19;
  }
  uint64_t v13 = *((void *)&v16 + 1);
  char v14 = __p[0];
  *(void *)a1 = v11;
  *(void *)(a1 + 8) = v13;
  *(unsigned char *)(a1 + 16) = 1;
  if (v14) {
    operator delete(v14);
  }
}

void SVG::consumeDigitSequence(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *((char *)a1 + 23);
  if (v4 >= 0) {
    unint64_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    unint64_t v5 = a1[1];
  }
  if (v5 <= a2) {
    goto LABEL_46;
  }
  int v8 = (uint64_t *)*a1;
  if (v4 >= 0) {
    int v8 = a1;
  }
  unsigned int v9 = *((unsigned __int8 *)v8 + a2) - 48;
  if (v9 >= 0xA)
  {
LABEL_46:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 32) = 0;
  }
  else
  {
    long long v10 = operator new(1uLL);
    unint64_t v11 = (unint64_t)v10;
    *long long v10 = v9;
    char v12 = v10 + 1;
    unint64_t v13 = a2 + 1;
    if (v5 <= a2 + 1) {
      goto LABEL_40;
    }
    char v14 = (uint64_t *)*a1;
    if (v4 >= 0) {
      char v14 = a1;
    }
    unsigned int v15 = *((unsigned __int8 *)v14 + v13) - 48;
    if (v15 <= 9)
    {
      long long v16 = v10 + 1;
      while (v12 < v16)
      {
        *v12++ = v15;
LABEL_32:
        ++v13;
        unint64_t v26 = *((unsigned __int8 *)a1 + 23);
        int v27 = (char)v26;
        if ((v26 & 0x80u) != 0) {
          unint64_t v26 = a1[1];
        }
        if (v26 > v13)
        {
          uint64_t v28 = v27 >= 0 ? (uint64_t)a1 : *a1;
          unsigned int v15 = *(unsigned __int8 *)(v28 + v13) - 48;
          if (v15 < 0xA) {
            continue;
          }
        }
        goto LABEL_39;
      }
      unint64_t v17 = &v12[-v11];
      uint64_t v18 = (uint64_t)&v12[-v11 + 1];
      if (v18 < 0) {
        goto LABEL_49;
      }
      if (2 * (uint64_t)&v16[-v11] > (unint64_t)v18) {
        uint64_t v18 = 2 * (void)&v16[-v11];
      }
      if ((unint64_t)&v16[-v11] >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v19 = v18;
      }
      if (v19) {
        unint64_t v20 = (unint64_t)operator new(v19);
      }
      else {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v17[v20];
      long long v16 = (unsigned char *)(v20 + v19);
      char v22 = &v17[v20];
      *char v22 = v15;
      char v23 = v22 + 1;
      if (v12 == (unsigned char *)v11)
      {
        unint64_t v20 = (unint64_t)v21;
        unint64_t v11 = (unint64_t)v12;
      }
      else
      {
        double v24 = &v12[~v11];
        do
        {
          char v25 = *--v12;
          (v24--)[v20] = v25;
        }
        while (v12 != (unsigned char *)v11);
        if (!v11) {
          goto LABEL_31;
        }
      }
      operator delete((void *)v11);
LABEL_31:
      unint64_t v11 = v20;
      char v12 = v23;
      goto LABEL_32;
    }
LABEL_39:
    if (v12 == (unsigned char *)v11)
    {
      char v29 = 0;
      long long v30 = 0;
    }
    else
    {
LABEL_40:
      if ((uint64_t)&v12[-v11] < 0) {
LABEL_49:
      }
        abort();
      char v29 = (char *)operator new((size_t)&v12[-v11]);
      long long v30 = &v12[(void)v29 - v11];
      memmove(v29, (const void *)v11, (size_t)&v12[-v11]);
    }
    *(void *)a3 = v29;
    *(void *)(a3 + 8) = v30;
    *(void *)(a3 + 16) = v30;
    *(void *)(a3 + 24) = v13;
    *(unsigned char *)(a3 + 32) = 1;
    if (v11)
    {
      operator delete((void *)v11);
    }
  }
}

void SVG::consumeIntegerConstant(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v12 = v4;
  long long v13 = v4;
  SVG::consumeDigitSequence(a1, a2, (uint64_t)&v12);
  if (!(_BYTE)v14)
  {
LABEL_11:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
    return;
  }
  long long v5 = v12;
  unint64_t v6 = *((void *)&v12 + 1) - v12;
  if (*((void *)&v12 + 1) != (void)v12)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    while (1)
    {
      unint64_t v9 = v8;
      unint64_t v8 = *(unsigned __int8 *)(v12 + v7) + 10 * v8;
      if (v8 < v9) {
        break;
      }
      if (v6 == ++v7)
      {
        uint64_t v10 = *((void *)&v13 + 1);
        *(void *)a3 = v8;
        *(void *)(a3 + 8) = v10;
        *(unsigned char *)(a3 + 16) = 1;
        goto LABEL_9;
      }
    }
    operator delete((void *)v12);
    goto LABEL_11;
  }
  uint64_t v11 = *((void *)&v13 + 1);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = v11;
  *(unsigned char *)(a3 + 16) = 1;
  if (*((void *)&v5 + 1)) {
LABEL_9:
  }
    operator delete((void *)v5);
}

unint64_t SVG::consumeCommaWsp(uint64_t *a1, unint64_t a2)
{
  unint64_t v4 = SVG::consumeWsp(a1, a2);
  if (v5)
  {
    do
    {
      uint64_t v6 = v4;
      unint64_t v4 = SVG::consumeWsp(a1, v4);
    }
    while (v7);
    unint64_t v8 = SVG::consumeString<2ul>(",", a1, v6);
    if (!v9) {
      unint64_t v8 = v6;
    }
    do
    {
      unint64_t v10 = v8;
      unint64_t v8 = SVG::consumeWsp(a1, v8);
    }
    while (v11);
  }
  else
  {
    unint64_t v12 = SVG::consumeString<2ul>(",", a1, a2);
    if (!v13)
    {
      unint64_t v15 = 0;
      LOBYTE(v1CGContextBeginTransparencyLayer(c, 0) = 0;
      return v10 | v15;
    }
    do
    {
      unint64_t v10 = v12;
      unint64_t v12 = SVG::consumeWsp(a1, v12);
    }
    while (v14);
  }
  unint64_t v15 = v10 & 0xFFFFFFFFFFFFFF00;
  return v10 | v15;
}

void SVG::consumePathNumber(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = a2;
  unint64_t v6 = *(unsigned __int8 *)(a1 + 23);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    unint64_t v6 = *(void *)(a1 + 8);
  }
  double v8 = 1.0;
  if (v6 > a2)
  {
    if (v7 >= 0) {
      uint64_t v9 = a1;
    }
    else {
      uint64_t v9 = *(void *)a1;
    }
    int v10 = *(char *)(v9 + a2);
    if (v10 == 45)
    {
      unint64_t v3 = a2 + 1;
      double v8 = -1.0;
    }
    else if (v10 == 43)
    {
      unint64_t v3 = a2 + 1;
    }
  }
  double v14 = NAN;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeFloatingPointConstant((uint64_t *)a1, v3, (uint64_t)&v14);
  if ((_BYTE)v16)
  {
    double v11 = v8 * v14;
    unint64_t v12 = v15;
LABEL_15:
    *(double *)a3 = v11;
    *(void *)(a3 + 8) = v12;
    *(unsigned char *)(a3 + 16) = 1;
    return;
  }
  memset(v13, 170, sizeof(v13));
  SVG::consumeIntegerConstant((uint64_t *)a1, v3, (uint64_t)v13);
  if (LOBYTE(v13[2]))
  {
    double v11 = v8 * (double)v13[0];
    unint64_t v12 = v13[1];
    goto LABEL_15;
  }
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 16) = 0;
}

void SVG::consumeCoordinatePair(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v14 = -1;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumePathNumber((uint64_t)a1, a2, (uint64_t)&v14);
  if ((_BYTE)v16
    && ((unint64_t v5 = v15, v6 = SVG::consumeCommaWsp(a1, v15), v7) ? (v8 = v6) : (v8 = v5),
        uint64_t v11 = -1,
        unint64_t v12 = 0xAAAAAAAAAAAAAAAALL,
        unint64_t v13 = 0xAAAAAAAAAAAAAAAALL,
        SVG::consumePathNumber((uint64_t)a1, v8, (uint64_t)&v11),
        (_BYTE)v13))
  {
    uint64_t v9 = v11;
    unint64_t v10 = v12;
    *(void *)a3 = v14;
    *(void *)(a3 + 8) = v9;
    *(void *)(a3 + 16) = v10;
    *(unsigned char *)(a3 + 24) = 1;
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
  }
}

void SVG::consumeListOfCoordinates(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = 0;
  do
    unint64_t v4 = SVG::consumeWsp((uint64_t *)a1, v4);
  while (v5);
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long __p = v6;
  long long v17 = v6;
  SVG::consumeOneOrMoreGeneric<double>(a1, (void (*)(long long *__return_ptr))SVG::consumeCoordinate, (uint64_t (*)(uint64_t, void))SVG::consumeCommaWsp, (uint64_t)__p);
  if (!(_BYTE)v18)
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
    return;
  }
  unint64_t v7 = *((void *)&v17 + 1);
  do
  {
    unint64_t v8 = v7;
    unint64_t v7 = SVG::consumeWsp((uint64_t *)a1, v7);
  }
  while (v9);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 23);
  if ((v10 & 0x80u) != 0) {
    uint64_t v10 = *(void *)(a1 + 8);
  }
  if (v8 == v10)
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v11 = __p[0];
    char v12 = 1;
    int64_t v13 = (char *)__p[1] - (char *)__p[0];
    if (__p[1] != __p[0])
    {
      std::vector<double>::__vallocate[abi:nn180100]((void *)a2, v13 >> 3);
      uint64_t v14 = *(char **)(a2 + 8);
      memmove(v14, v11, v13);
      *(void *)(a2 + 8) = &v14[v13];
      int v15 = v18;
      *(unsigned char *)(a2 + 24) = 1;
      if (!v15) {
        return;
      }
      goto LABEL_15;
    }
  }
  else
  {
    char v12 = 0;
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + 24) = v12;
LABEL_15:
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void SVG::consumeInteger(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = *(unsigned __int8 *)(a1 + 23);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    unint64_t v4 = *(void *)(a1 + 8);
  }
  if (v4 <= a2)
  {
    char v8 = 1;
  }
  else
  {
    if (v5 >= 0) {
      uint64_t v6 = a1;
    }
    else {
      uint64_t v6 = *(void *)a1;
    }
    int v7 = *(char *)(v6 + a2);
    char v8 = 1;
    if (v7 != 43)
    {
      if (v7 != 45) {
        goto LABEL_12;
      }
      char v8 = 0;
    }
    ++a2;
  }
LABEL_12:
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long __p = v9;
  long long v15 = v9;
  SVG::consumeDigitSequence((uint64_t *)a1, a2, (uint64_t)__p);
  if (!(_BYTE)v16)
  {
LABEL_18:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
    return;
  }
  unint64_t v10 = SVG::digitsToInt(v8, (unsigned __int8 **)__p);
  if (!v11)
  {
    if (__p[0]) {
      operator delete(__p[0]);
    }
    goto LABEL_18;
  }
  uint64_t v12 = *((void *)&v15 + 1);
  int64_t v13 = __p[0];
  *(void *)a3 = v10;
  *(void *)(a3 + 8) = v12;
  *(unsigned char *)(a3 + 16) = 1;
  if (v13) {
    operator delete(v13);
  }
}

unint64_t SVG::digitsToInt(char a1, unsigned __int8 **a2)
{
  unint64_t v3 = *a2;
  unint64_t v2 = a2[1];
  unint64_t v4 = v2 - *a2;
  if (v2 == *a2)
  {
    unint64_t v5 = 0;
    if ((a1 & 1) == 0)
    {
LABEL_12:
      unint64_t v5 = -(uint64_t)v5;
      unint64_t v8 = v5 & 0xFFFFFFFFFFFFFF00;
      return v5 | v8;
    }
LABEL_10:
    unint64_t v8 = v5 & 0x7FFFFFFFFFFFFF00;
  }
  else
  {
    unint64_t v5 = 0;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      unint64_t v6 = v5;
      unsigned int v7 = *v3++;
      unint64_t v5 = v7 + 10 * v5;
      if (v5 < v6) {
        goto LABEL_8;
      }
      --v4;
    }
    while (v4);
    if (a1)
    {
      if ((v5 & 0x8000000000000000) == 0) {
        goto LABEL_10;
      }
LABEL_8:
      unint64_t v8 = 0;
      LOBYTE(v5) = 0;
      return v5 | v8;
    }
    if ((v5 & 0x8000000000000000) == 0) {
      goto LABEL_12;
    }
    BOOL v10 = v5 == 0x8000000000000000;
    LOBYTE(v5) = 0;
    uint64_t v11 = v10;
    unint64_t v8 = v11 << 63;
  }
  return v5 | v8;
}

void SVG::consumeNumber(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *(char *)(a1 + 23);
  unint64_t v6 = *(void *)(a1 + 8);
  if (v5 >= 0) {
    unint64_t v6 = *(unsigned __int8 *)(a1 + 23);
  }
  double v7 = 1.0;
  if (v6 <= a2)
  {
    unint64_t v10 = a2;
  }
  else
  {
    uint64_t v8 = *(void *)a1;
    if (v5 >= 0) {
      uint64_t v8 = a1;
    }
    int v9 = *(char *)(v8 + a2);
    if (v9 == 45)
    {
      unint64_t v10 = a2 + 1;
      double v7 = -1.0;
    }
    else if (v9 == 43)
    {
      unint64_t v10 = a2 + 1;
    }
    else
    {
      unint64_t v10 = a2;
    }
  }
  if (v6 <= v10)
  {
    unint64_t v11 = 0;
    long long v17 = 0;
  }
  else
  {
    unint64_t v11 = 0;
    uint64_t v12 = 0;
    int64_t v13 = 0;
    unsigned int v14 = v5 >> 31;
    while (1)
    {
      uint64_t v15 = (v14 & 1) != 0 ? *(void *)a1 : a1;
      unsigned int v16 = *(unsigned __int8 *)(v15 + v10) - 48;
      if (v16 > 9) {
        break;
      }
      if (v12 >= v13)
      {
        uint64_t v18 = (uint64_t)&v12[-v11 + 1];
        if (v18 < 0) {
          abort();
        }
        if (2 * (uint64_t)&v13[-v11] > (unint64_t)v18) {
          uint64_t v18 = 2 * (void)&v13[-v11];
        }
        if ((unint64_t)&v13[-v11] >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v19 = v18;
        }
        if (v19) {
          unint64_t v20 = (unsigned __int8 *)operator new(v19);
        }
        else {
          unint64_t v20 = 0;
        }
        uint64_t v21 = &v12[(void)v20 - v11];
        *uint64_t v21 = v16;
        long long v17 = v21 + 1;
        if (v12 != (unsigned __int8 *)v11)
        {
          char v22 = &v12[~v11];
          do
          {
            unsigned __int8 v23 = *--v12;
            (v22--)[(void)v20] = v23;
          }
          while (v12 != (unsigned __int8 *)v11);
          uint64_t v21 = v20;
        }
        int64_t v13 = &v20[v19];
        if (v11) {
          operator delete((void *)v11);
        }
        unint64_t v11 = (unint64_t)v21;
      }
      else
      {
        *uint64_t v12 = v16;
        long long v17 = v12 + 1;
      }
      ++v10;
      LOBYTE(v14) = *(char *)(a1 + 23) < 0;
      unint64_t v24 = *(unsigned __int8 *)(a1 + 23);
      if ((v24 & 0x80u) != 0) {
        unint64_t v24 = *(void *)(a1 + 8);
      }
      uint64_t v12 = v17;
      if (v24 <= v10) {
        goto LABEL_42;
      }
    }
    long long v17 = v12;
  }
LABEL_42:
  unint64_t v25 = SVG::consumeString<2ul>(".", (uint64_t *)a1, v10);
  if (!v26) {
    goto LABEL_52;
  }
  unint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v27 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long __p = v27;
  *(_OWORD *)&__p[16] = v27;
  SVG::consumeDigitSequence((uint64_t *)a1, v25, (uint64_t)__p);
  if (!(_BYTE)v39) {
    goto LABEL_52;
  }
  *(double *)&uint64_t v29 = COERCE_DOUBLE(SVG::digitsToFloat((unsigned __int8 *)v11, v17, (uint64_t *)__p, v28));
  if (!v30)
  {
    if (*(void *)__p) {
      operator delete(*(void **)__p);
    }
LABEL_52:
    memset(__p, 170, 24);
    SVG::consumeInteger(a1, a2, (uint64_t)__p);
    if (!__p[16])
    {
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 16) = 0;
      if (!v11) {
        return;
      }
      goto LABEL_57;
    }
    memset(v37, 170, sizeof(v37));
    uint64_t v34 = *(void *)&__p[8];
    SVG::consumeExponent((uint64_t)v37, a1, *(unint64_t *)&__p[8]);
    double v35 = (double)*(uint64_t *)__p;
    if (LOBYTE(v37[2]))
    {
      double v35 = __exp10((double)v37[0]) * v35;
      uint64_t v34 = v37[1];
    }
    *(double *)a3 = v35;
    *(void *)(a3 + 8) = v34;
    *(unsigned char *)(a3 + 16) = 1;
    goto LABEL_56;
  }
  double v31 = *(double *)&v29;
  memset(v37, 170, sizeof(v37));
  uint64_t v32 = *(void *)&__p[24];
  SVG::consumeExponent((uint64_t)v37, a1, *(unint64_t *)&__p[24]);
  double v33 = v7 * v31;
  if (LOBYTE(v37[2]))
  {
    double v33 = v33 * __exp10((double)v37[0]);
    uint64_t v32 = v37[1];
  }
  *(double *)a3 = v33;
  *(void *)(a3 + 8) = v32;
  *(unsigned char *)(a3 + 16) = 1;
  if (!*(void *)__p)
  {
LABEL_56:
    if (!v11) {
      return;
    }
    goto LABEL_57;
  }
  operator delete(*(void **)__p);
  if (!v11) {
    return;
  }
LABEL_57:
  operator delete((void *)v11);
}

uint64_t SVG::digitsToFloat(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t *a3, double a4)
{
  double v5 = 0.0;
  double v6 = 0.0;
  unint64_t v7 = a2 - a1;
  if (a2 == a1)
  {
LABEL_7:
    uint64_t v11 = *a3;
    if (a3[1] != *a3)
    {
      unint64_t v12 = 0;
      double v5 = 0.0;
      do
      {
        LOBYTE(a4) = *(unsigned char *)(v11 + v12);
        double v13 = (double)*(unint64_t *)&a4;
        a4 = __exp10(-1.0 - (double)v12);
        double v5 = v5 + v13 * a4;
        ++v12;
        uint64_t v11 = *a3;
      }
      while (v12 < a3[1] - *a3);
    }
    *(double *)&uint64_t result = v6 + v5;
  }
  else
  {
    unint64_t v8 = 0;
    if (v7 <= 1) {
      unint64_t v7 = 1;
    }
    while (1)
    {
      unsigned int v9 = *a1++;
      unint64_t v10 = v9 + 10 * v8;
      if (v10 < v8) {
        break;
      }
      unint64_t v8 = v10;
      if (!--v7)
      {
        double v6 = (double)v10;
        goto LABEL_7;
      }
    }
    *(double *)&uint64_t result = 0.0;
  }
  return result;
}

uint64_t SVG::consumeNumberAlone(uint64_t a1)
{
  return SVG::consumeAlone<double>(a1, (void (*)(uint64_t *__return_ptr, uint64_t, unint64_t))SVG::consumeNumber);
}

void SVG::consumeLength(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v12 = NAN;
  uint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeNumber((uint64_t)a1, a2, (uint64_t)&v12);
  if ((_BYTE)v14)
  {
    uint64_t v5 = v13;
    unint64_t v6 = SVG::consumeString<2ul>("%", a1, v13);
    if (v7)
    {
      *(double *)a3 = v12;
      *(void *)(a3 + 8) = 1;
      *(void *)(a3 + 16) = v6;
      *(unsigned char *)(a3 + 24) = 1;
    }
    else
    {
      double v9 = NAN;
      unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
      SVG::consumeUnitSuffix((uint64_t)a1, v5, (uint64_t)&v9);
      if ((_BYTE)v11)
      {
        unint64_t v8 = v10;
        *(double *)a3 = v12 * v9;
        *(void *)(a3 + 8) = 0;
        *(void *)(a3 + 16) = v8;
      }
      else
      {
        *(double *)a3 = v12;
        *(void *)(a3 + 8) = 0;
        *(void *)(a3 + 16) = v5;
      }
      *(unsigned char *)(a3 + 24) = 1;
    }
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
  }
}

unint64_t SVG::consumeUnitSuffix@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t result = SVG::consumeString<3ul>((uint64_t)"px", a1, a2);
  if (v7)
  {
    uint64_t v8 = 0x3FF0000000000000;
  }
  else
  {
    unint64_t result = SVG::consumeString<3ul>((uint64_t)"in", a1, a2);
    if (v9)
    {
      uint64_t v8 = 0x4058000000000000;
    }
    else
    {
      unint64_t result = SVG::consumeString<3ul>((uint64_t)"cm", a1, a2);
      if (v10)
      {
        uint64_t v8 = 0x4042E5CB972E5CB9;
      }
      else
      {
        unint64_t result = SVG::consumeString<3ul>((uint64_t)"mm", a1, a2);
        if (v11)
        {
          uint64_t v8 = 0x400E3C78F1E3C78ELL;
        }
        else
        {
          unint64_t result = SVG::consumeString<3ul>((uint64_t)"pt", a1, a2);
          if (v12)
          {
            uint64_t v8 = 0x3FF5555555555555;
          }
          else
          {
            unint64_t result = SVG::consumeString<3ul>((uint64_t)"pc", a1, a2);
            if (!v13)
            {
              char v14 = 0;
              *(unsigned char *)a3 = 0;
              goto LABEL_14;
            }
            uint64_t v8 = 0x4030000000000000;
          }
        }
      }
    }
  }
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = result;
  char v14 = 1;
LABEL_14:
  *(unsigned char *)(a3 + 16) = v14;
  return result;
}

void SVG::consumeCSSLength(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v10 = NAN;
  uint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeNumber(a1, a2, (uint64_t)&v10);
  if ((_BYTE)v12)
  {
    double v7 = NAN;
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v5 = v11;
    SVG::consumeUnitSuffix(a1, v11, (uint64_t)&v7);
    if ((_BYTE)v9)
    {
      unint64_t v6 = v8;
      *(double *)a3 = v10 * v7;
      *(void *)(a3 + 8) = v6;
    }
    else
    {
      *(double *)a3 = v10;
      *(void *)(a3 + 8) = v5;
    }
    *(unsigned char *)(a3 + 16) = 1;
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
  }
}

void *SVG::consumeLengthAlone@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return SVG::consumeAlone<SVG::Length>(a1, (void *(*)(long long *__return_ptr, uint64_t, unint64_t))SVG::consumeLength, a2);
}

unint64_t SVG::consumeString<3ul>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    unint64_t v3 = *(void *)(a2 + 8);
  }
  uint64_t v4 = a3 + 2;
  if (v3 >= a3 + 2)
  {
    uint64_t v10 = 0;
    for (char i = 1; ; char i = 0)
    {
      char v12 = i;
      uint64_t v13 = v10 + a3;
      uint64_t v14 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      int v15 = *(char *)(v14 + v13);
      if (__tolower(*(char *)(a1 + v10)) != v15)
      {
        uint64_t v16 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
        int v17 = *(char *)(v16 + v13);
        if (__toupper(*(char *)(a1 + v10)) != v17) {
          break;
        }
      }
      uint64_t v10 = 1;
      if ((v12 & 1) == 0)
      {
        unint64_t v6 = v4 & 0xFFFFFFFFFFFFFF00;
        uint64_t v5 = v4;
        return v6 | v5;
      }
    }
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  return v6 | v5;
}

unint64_t SVG::QualifiedNameHash::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v4 = v3;
  }
  unint64_t v5 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v13, (uint64_t *)a2, v4);
  unint64_t v8 = *(uint64_t **)(v2 + 24);
  uint64_t v7 = v2 + 24;
  unint64_t v6 = v8;
  int v9 = *(char *)(v7 + 23);
  if (v9 >= 0) {
    uint64_t v10 = (uint64_t *)v7;
  }
  else {
    uint64_t v10 = v6;
  }
  if (v9 >= 0) {
    unint64_t v11 = *(unsigned __int8 *)(v7 + 23);
  }
  else {
    unint64_t v11 = *(void *)(v7 + 8);
  }
  return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v14, v10, v11) ^ v5;
}

uint64_t SVG::QualifiedNamePredicate::operator()(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v4 = a2[23];
  size_t v5 = *((void *)a2 + 1);
  if ((v4 & 0x80u) == 0) {
    uint64_t v6 = a2[23];
  }
  else {
    uint64_t v6 = *((void *)a2 + 1);
  }
  uint64_t v7 = a3[23];
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *((void *)a3 + 1);
  }
  if (v6 != v7) {
    return 0;
  }
  if (v8 >= 0) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = *(unsigned __int8 **)a3;
  }
  if ((v4 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a2, v10, v5)) {
      return 0;
    }
  }
  else if (v4)
  {
    unint64_t v11 = a2;
    while (*v11 == *v10)
    {
      ++v11;
      ++v10;
      if (!--v4) {
        goto LABEL_17;
      }
    }
    return 0;
  }
LABEL_17:
  uint64_t v12 = a2[47];
  if ((v12 & 0x80u) == 0) {
    uint64_t v13 = a2[47];
  }
  else {
    uint64_t v13 = *((void *)a2 + 4);
  }
  uint64_t v14 = a3[47];
  int v15 = (char)v14;
  if ((v14 & 0x80u) != 0) {
    uint64_t v14 = *((void *)a3 + 4);
  }
  if (v13 != v14) {
    return 0;
  }
  uint64_t v16 = (const void **)(a2 + 24);
  size_t v19 = (unsigned __int8 *)*((void *)a3 + 3);
  uint64_t v18 = a3 + 24;
  int v17 = v19;
  if (v15 >= 0) {
    unint64_t v20 = v18;
  }
  else {
    unint64_t v20 = v17;
  }
  if ((v12 & 0x80) != 0) {
    return memcmp(*v16, v20, *((void *)a2 + 4)) == 0;
  }
  if (!a2[47]) {
    return 1;
  }
  uint64_t v21 = v12 - 1;
  do
  {
    int v23 = *(unsigned __int8 *)v16;
    uint64_t v16 = (const void **)((char *)v16 + 1);
    int v22 = v23;
    int v25 = *v20++;
    int v24 = v25;
    BOOL v27 = v21-- != 0;
    uint64_t result = v22 == v24;
  }
  while (v22 == v24 && v27);
  return result;
}

uint64_t SVG::Element::Element(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)a1 = &unk_1F1A74B50;
  *(_OWORD *)(a1 + 8) = 0u;
  size_t v5 = (std::string *)(a1 + 8);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = 0u;
  *(void *)(a1 + 56) = a2;
  std::string::basic_string[abi:nn180100]<0>(v10, "id");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v10, (uint64_t)__p);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0)
  {
    operator delete(v10[0]);
    if (!v6) {
      return a1;
    }
    goto LABEL_5;
  }
  if (v6) {
LABEL_5:
  }
    std::string::operator=(v5, (const std::string *)(v6 + 64));
  return a1;
}

unsigned __int8 *SVG::Element::findInAttributeMap(void *a1, uint64_t a2, uint64_t a3)
{
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long __p = v5;
  *(_OWORD *)&__p[16] = v5;
  *(_OWORD *)int v8 = v5;
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)v8, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)int v8 = *(_OWORD *)a3;
    *(void *)long long __p = *(void *)(a3 + 16);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)&__p[8], *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&__p[8] = *(_OWORD *)a2;
    *(void *)&__p[24] = *(void *)(a2 + 16);
  }
  uint64_t v6 = std::__hash_table<std::__hash_value_type<SVG::QualifiedName,std::string>,std::__unordered_map_hasher<SVG::QualifiedName,std::__hash_value_type<SVG::QualifiedName,std::string>,SVG::QualifiedNameHash,SVG::QualifiedNamePredicate,true>,std::__unordered_map_equal<SVG::QualifiedName,std::__hash_value_type<SVG::QualifiedName,std::string>,SVG::QualifiedNamePredicate,SVG::QualifiedNameHash,true>,std::allocator<std::__hash_value_type<SVG::QualifiedName,std::string>>>::find<SVG::QualifiedName>(a1, (unsigned __int8 *)v8);
  if ((__p[31] & 0x80000000) != 0) {
    operator delete(*(void **)&__p[8]);
  }
  if ((__p[7] & 0x80000000) != 0) {
    operator delete(v8[0]);
  }
  return v6;
}

void SVG::Element::~Element(void **this)
{
  *this = &unk_1F1A74B50;
  uint64_t v2 = this + 4;
  std::vector<std::unique_ptr<SVG::Element>>::__destroy_vector::operator()[abi:nn180100](&v2);
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  SVG::Element::~Element(this);
  JUMPOUT(0x1C18A3E80);
}

uint64_t SVG::Element::appendChild(int64x2_t *a1, uint64_t *a2)
{
  unint64_t v6 = a1[3].u64[0];
  uint64_t i64 = (uint64_t)a1[3].i64;
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(i64 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = a1[2].i64[0];
    uint64_t v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61) {
      abort();
    }
    uint64_t v12 = v5 - v10;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
      uint64_t v13 = v11 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    uint64_t v28 = i64;
    if (v14) {
      int v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>(i64, v14);
    }
    else {
      int v15 = 0;
    }
    uint64_t v16 = &v15[8 * v11];
    int v17 = &v15[8 * v14];
    BOOL v27 = v17;
    uint64_t v18 = *a2;
    *a2 = 0;
    *(void *)uint64_t v16 = v18;
    char v9 = v16 + 8;
    v26.i64[1] = (uint64_t)(v16 + 8);
    unint64_t v20 = (void *)a1[2].i64[0];
    size_t v19 = (void *)a1[2].i64[1];
    if (v19 == v20)
    {
      int64x2_t v22 = vdupq_n_s64((unint64_t)v19);
    }
    else
    {
      do
      {
        uint64_t v21 = *--v19;
        *size_t v19 = 0;
        *((void *)v16 - 1) = v21;
        v16 -= 8;
      }
      while (v19 != v20);
      int64x2_t v22 = a1[2];
      char v9 = (void *)v26.i64[1];
      int v17 = v27;
    }
    a1[2].i64[0] = (uint64_t)v16;
    a1[2].i64[1] = (uint64_t)v9;
    int64x2_t v26 = v22;
    uint64_t v23 = a1[3].i64[0];
    a1[3].i64[0] = (uint64_t)v17;
    BOOL v27 = (char *)v23;
    uint64_t v25 = v22.i64[0];
    std::__split_buffer<std::unique_ptr<SVG::Element>>::~__split_buffer((void **)&v25);
  }
  else
  {
    uint64_t v8 = *a2;
    *a2 = 0;
    *uint64_t v7 = v8;
    char v9 = v7 + 1;
  }
  a1[2].i64[1] = (uint64_t)v9;
  return 1;
}

void std::vector<std::unique_ptr<SVG::Element>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<SVG::Element>>::__clear[abi:nn180100](v2);
    unint64_t v3 = **a1;
    operator delete(v3);
  }
}

void *std::vector<std::unique_ptr<SVG::Element>>::__clear[abi:nn180100](void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = (void *)*result;
  unint64_t v3 = (void *)result[1];
  while (v3 != v2)
  {
    uint64_t v4 = (void *)*--v3;
    uint64_t result = v4;
    *unint64_t v3 = 0;
    if (v4) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  v1[1] = v2;
  return result;
}

void **std::__split_buffer<std::unique_ptr<SVG::Element>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<std::unique_ptr<SVG::Element>>::__destruct_at_end[abi:nn180100](void *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      v4[2] = v2 - 8;
      uint64_t result = *(void **)(v2 - 8);
      *(void *)(v2 - 8) = 0;
      if (result) {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
      uint64_t v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<SVG::QualifiedName,std::string>,std::__unordered_map_hasher<SVG::QualifiedName,std::__hash_value_type<SVG::QualifiedName,std::string>,SVG::QualifiedNameHash,SVG::QualifiedNamePredicate,true>,std::__unordered_map_equal<SVG::QualifiedName,std::__hash_value_type<SVG::QualifiedName,std::string>,SVG::QualifiedNamePredicate,SVG::QualifiedNameHash,true>,std::allocator<std::__hash_value_type<SVG::QualifiedName,std::string>>>::find<SVG::QualifiedName>(void *a1, unsigned __int8 *a2)
{
  unint64_t v4 = SVG::QualifiedNameHash::operator()((uint64_t)a1, (uint64_t)a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  uint64_t v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (char i = *v10; i; char i = *(unsigned __int8 **)i)
  {
    unint64_t v12 = *((void *)i + 1);
    if (v6 == v12)
    {
      unint64_t v4 = SVG::QualifiedNamePredicate::operator()(v4, i + 16, a2);
      if (v4) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

_OWORD *SVG::CircleElement::CircleElement(_OWORD *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::ShapeElement::ShapeElement((uint64_t)a1, a2, a3);
  *(void *)uint64_t v5 = &unk_1F1A746A8;
  *(void *)(v5 + 688) = 0;
  *(_DWORD *)(v5 + 696) = 0;
  *(void *)(v5 + 704) = 0;
  *(_DWORD *)(v5 + 712) = 0;
  *(void *)(v5 + 72CGContextBeginTransparencyLayer(c, 0) = 0;
  *(_DWORD *)(v5 + 728) = 0;
  std::string::basic_string[abi:nn180100]<0>(v12, "cx");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  unint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v12, (uint64_t)__p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v13) < 0)
  {
    operator delete(v12[0]);
    if (!v6) {
      goto LABEL_9;
    }
  }
  else if (!v6)
  {
    goto LABEL_9;
  }
  v12[0] = (void *)-1;
  v12[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v6 + 64), (uint64_t)v12);
  if ((_BYTE)v13) {
    a1[43] = *(_OWORD *)v12;
  }
LABEL_9:
  std::string::basic_string[abi:nn180100]<0>(v12, "cy");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint8x8_t v7 = SVG::Element::findInAttributeMap(a3, (uint64_t)v12, (uint64_t)__p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v13) < 0)
  {
    operator delete(v12[0]);
    if (!v7) {
      goto LABEL_17;
    }
  }
  else if (!v7)
  {
    goto LABEL_17;
  }
  v12[0] = (void *)-1;
  v12[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v7 + 64), (uint64_t)v12);
  if ((_BYTE)v13) {
    a1[44] = *(_OWORD *)v12;
  }
LABEL_17:
  std::string::basic_string[abi:nn180100]<0>(v12, "r");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  unint64_t v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)v12, (uint64_t)__p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v13) < 0)
  {
    operator delete(v12[0]);
    if (!v8) {
      return a1;
    }
  }
  else if (!v8)
  {
    return a1;
  }
  v12[0] = (void *)-1;
  v12[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v8 + 64), (uint64_t)v12);
  if ((_BYTE)v13) {
    a1[45] = *(_OWORD *)v12;
  }
  return a1;
}

void SVG::CircleElement::path(SVG::CircleElement *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, CGPath **a3@<X8>)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double v7 = SVG::Length::computeValue((SVG::CircleElement *)((char *)this + 688), a2.size.width);
  double v8 = SVG::Length::computeValue((SVG::CircleElement *)((char *)this + 704), height);
  double v9 = SVG::Length::computeValue((SVG::CircleElement *)((char *)this + 720), sqrt(height * height + width * width) / 1.41421356);
  if (v9 <= 0.0)
  {
    *a3 = 0;
  }
  else
  {
    double v10 = v9;
    Mutable = CGPathCreateMutable();
    v13.origin.double x = v7 - v10;
    v13.origin.double y = v8 - v10;
    v13.size.double width = v10 + v10;
    v13.size.double height = v10 + v10;
    CGPathAddEllipseInRect(Mutable, 0, v13);
    *a3 = Mutable;
    if (Mutable)
    {
      CFRetain(Mutable);
      CFRelease(Mutable);
    }
  }
}

double SVG::CircleElement::boundingBox(SVG::CircleElement *this, CGRect a2)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double v5 = SVG::Length::computeValue((SVG::CircleElement *)((char *)this + 688), a2.size.width);
  SVG::Length::computeValue((SVG::CircleElement *)((char *)this + 704), height);
  return v5
       - SVG::Length::computeValue((SVG::CircleElement *)((char *)this + 720), sqrt(height * height + width * width) / 1.41421356);
}

void SVG::CircleElement::~CircleElement(SVG::CircleElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A758E0[v2])(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A758F8[v3])(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A75910[v4])(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A758F8[v5])(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A75910[v6])(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A758E0[v2])(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A758F8[v3])(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A75910[v4])(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A758F8[v5])(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A75910[v6])(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

void SVG::LengthRect::computeRect(SVG::LengthRect *this, CGRect a2)
{
  double height = a2.size.height;
  double width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  *(void *)&long long v7 = -1;
  *((void *)&v7 + 1) = -1;
  long long v18 = v7;
  long long v19 = v7;
  long long v17 = v7;
  SVG::unitTransform((CGAffineTransform *)*(unsigned int *)this, (uint64_t)&v17, x, a2.origin.y, a2.size.width, a2.size.height);
  if (*(_DWORD *)this == 1)
  {
    double width = 1.0;
    CGFloat x = 0.0;
    CGFloat y = 0.0;
    double height = 1.0;
  }
  long long v14 = v18;
  long long v15 = v17;
  long long v8 = v19;
  v20.origin.CGFloat x = x;
  v20.origin.CGFloat y = y;
  v20.size.double width = width;
  v20.size.double height = height;
  SVG::LengthRect::computeOrigin(this, v20);
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  double v13 = SVG::Length::computeValue((SVG::LengthRect *)((char *)this + 40), width);
  v21.size.double height = SVG::Length::computeValue((SVG::LengthRect *)((char *)this + 56), height);
  *(_OWORD *)&v16.CGFloat a = v15;
  *(_OWORD *)&v16.CGFloat c = v14;
  *(_OWORD *)&v16.tCGFloat x = v8;
  v21.origin.CGFloat x = v10;
  v21.origin.CGFloat y = v12;
  v21.size.double width = v13;
  CGRectApplyAffineTransform(v21, &v16);
}

void SVG::LengthRect::computePatternRecordingRect(SVG::LengthRect *this, CGRect a2)
{
  double height = a2.size.height;
  double width = a2.size.width;
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  long long v19 = v5;
  long long v20 = v5;
  long long v18 = v5;
  uint64_t v6 = (SVG::LengthRect *)((char *)this + 40);
  SVG::unitTransform((CGAffineTransform *)*(unsigned int *)this, (uint64_t)&v18, a2.origin.x, a2.origin.y, width, a2.size.height);
  int v8 = *(_DWORD *)this;
  long long v7 = (SVG::LengthRect *)((char *)this + 56);
  BOOL v9 = v8 == 1;
  if (v8 == 1) {
    double v10 = 1.0;
  }
  else {
    double v10 = width;
  }
  if (v9) {
    double height = 1.0;
  }
  long long v15 = v19;
  long long v16 = v18;
  long long v11 = v20;
  CGFloat v12 = *MEMORY[0x1E4F1DAD8];
  CGFloat v13 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
  double v14 = SVG::Length::computeValue(v6, v10);
  v21.size.double height = SVG::Length::computeValue(v7, height);
  *(_OWORD *)&v17.CGFloat a = v16;
  *(_OWORD *)&v17.CGFloat c = v15;
  *(_OWORD *)&v17.tCGFloat x = v11;
  v21.origin.CGFloat x = v12;
  v21.origin.CGFloat y = v13;
  v21.size.double width = v14;
  CGRectApplyAffineTransform(v21, &v17);
}

uint64_t SVG::calculateLinearQuanta(SVG *this, CGPoint a2, CGSize a3, CGRect a4)
{
  CGFloat height = a4.size.height;
  CGFloat width = a4.size.width;
  CGFloat y = a4.origin.y;
  CGFloat x = a4.origin.x;
  double v8 = a3.width;
  double v23 = a3.height;
  double v24 = a2.y;
  CGFloat v19 = a4.origin.x - a2.x;
  double v21 = a2.x;
  CGFloat v9 = a3.height * (a4.origin.y - a2.y);
  CGFloat v10 = a3.height * a3.height + v8 * v8;
  double v22 = (v9 + (a4.origin.x - a2.x) * a3.width) / v10;
  double v11 = (v9 + (CGRectGetMaxX(a4) - a2.x) * a3.width) / v10;
  v25.origin.CGFloat x = x;
  v25.origin.CGFloat y = y;
  v25.size.CGFloat width = width;
  v25.size.CGFloat height = height;
  double v12 = (v23 * (CGRectGetMaxY(v25) - v24) + v19 * v8) / v10;
  v26.origin.CGFloat x = x;
  v26.origin.CGFloat y = y;
  v26.size.CGFloat width = width;
  v26.size.CGFloat height = height;
  double MaxX = CGRectGetMaxX(v26);
  v27.origin.CGFloat x = x;
  v27.origin.CGFloat y = y;
  v27.size.CGFloat width = width;
  v27.size.CGFloat height = height;
  double v15 = (v23 * (CGRectGetMaxY(v27) - v24) + (MaxX - v21) * v8) / v10;
  double v16 = v22;
  if (v11 >= v22) {
    double v17 = v22;
  }
  else {
    double v17 = v11;
  }
  if (v12 < v17) {
    double v17 = v12;
  }
  if (v15 < v17) {
    double v17 = v15;
  }
  if (v22 < v11) {
    double v16 = v11;
  }
  if (v16 < v12) {
    double v16 = v12;
  }
  if (v16 >= v15) {
    double v15 = v16;
  }
  LODWORD(v13) = vcvtmd_s64_f64(v17);
  LODWORD(v14) = vcvtpd_s64_f64(v15);
  return v13 | (v14 << 32);
}

uint64_t SVG::calculateRadialQuanta(SVG *this, CGPoint a2, double a3, CGRect a4)
{
  CGFloat height = a4.size.height;
  CGFloat width = a4.size.width;
  CGFloat y = a4.origin.y;
  CGFloat x = a4.origin.x;
  double v9 = a2.x;
  CGFloat v23 = a2.x - a4.origin.x;
  CGFloat v10 = (a2.y - a4.origin.y) * (a2.y - a4.origin.y);
  double v11 = sqrt(v10 + v23 * v23) / a3;
  CGFloat MaxX = CGRectGetMaxX(a4);
  double v13 = sqrt(v10 + (v9 - MaxX) * (v9 - MaxX)) / a3;
  v26.origin.CGFloat x = x;
  v26.origin.CGFloat y = y;
  v26.size.CGFloat width = width;
  v26.size.CGFloat height = height;
  CGFloat MaxY = CGRectGetMaxY(v26);
  double v15 = sqrt((a2.y - MaxY) * (a2.y - MaxY) + v23 * v23) / a3;
  v27.origin.CGFloat x = x;
  v27.origin.CGFloat y = y;
  v27.size.CGFloat width = width;
  v27.size.CGFloat height = height;
  double v24 = CGRectGetMaxX(v27);
  v28.origin.CGFloat x = x;
  v28.origin.CGFloat y = y;
  v28.size.CGFloat width = width;
  v28.size.CGFloat height = height;
  CGFloat v18 = CGRectGetMaxY(v28);
  double v19 = sqrt((a2.y - v18) * (a2.y - v18) + (a2.x - v24) * (a2.x - v24)) / a3;
  if (v13 >= v11) {
    double v20 = v11;
  }
  else {
    double v20 = v13;
  }
  if (v15 < v20) {
    double v20 = v15;
  }
  if (v19 < v20) {
    double v20 = v19;
  }
  if (v11 >= v13) {
    double v21 = v11;
  }
  else {
    double v21 = v13;
  }
  if (v21 < v15) {
    double v21 = v15;
  }
  if (v21 >= v19) {
    double v19 = v21;
  }
  LODWORD(v16) = vcvtmd_s64_f64(v20);
  LODWORD(v17) = vcvtpd_s64_f64(v19);
  return v16 | (v17 << 32);
}

_OWORD *SVG::EllipseElement::EllipseElement(_OWORD *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::ShapeElement::ShapeElement((uint64_t)a1, a2, a3);
  *(void *)uint64_t v5 = &unk_1F1A746E8;
  *(void *)(v5 + 688) = 0;
  *(_DWORD *)(v5 + 696) = 0;
  *(void *)(v5 + 704) = 0;
  *(_DWORD *)(v5 + 712) = 0;
  *(void *)(v5 + 72CGContextBeginTransparencyLayer(c, 0) = 0;
  *(_DWORD *)(v5 + 728) = 0;
  *(void *)(v5 + 736) = 0;
  *(_DWORD *)(v5 + 744) = 0;
  std::string::basic_string[abi:nn180100]<0>(v13, "cx");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0)
  {
    operator delete(v13[0]);
    if (!v6) {
      goto LABEL_9;
    }
  }
  else if (!v6)
  {
    goto LABEL_9;
  }
  v13[0] = (void *)-1;
  v13[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v6 + 64), (uint64_t)v13);
  if ((_BYTE)v14) {
    a1[43] = *(_OWORD *)v13;
  }
LABEL_9:
  std::string::basic_string[abi:nn180100]<0>(v13, "cy");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  long long v7 = SVG::Element::findInAttributeMap(a3, (uint64_t)v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0)
  {
    operator delete(v13[0]);
    if (!v7) {
      goto LABEL_17;
    }
  }
  else if (!v7)
  {
    goto LABEL_17;
  }
  v13[0] = (void *)-1;
  v13[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v7 + 64), (uint64_t)v13);
  if ((_BYTE)v14) {
    a1[44] = *(_OWORD *)v13;
  }
LABEL_17:
  std::string::basic_string[abi:nn180100]<0>(v13, "rx");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  double v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0)
  {
    operator delete(v13[0]);
    if (!v8) {
      goto LABEL_25;
    }
  }
  else if (!v8)
  {
    goto LABEL_25;
  }
  v13[0] = (void *)-1;
  v13[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v8 + 64), (uint64_t)v13);
  if ((_BYTE)v14) {
    a1[45] = *(_OWORD *)v13;
  }
LABEL_25:
  std::string::basic_string[abi:nn180100]<0>(v13, "ry");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  double v9 = SVG::Element::findInAttributeMap(a3, (uint64_t)v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0)
  {
    operator delete(v13[0]);
    if (!v9) {
      return a1;
    }
  }
  else if (!v9)
  {
    return a1;
  }
  v13[0] = (void *)-1;
  v13[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v9 + 64), (uint64_t)v13);
  if ((_BYTE)v14) {
    a1[46] = *(_OWORD *)v13;
  }
  return a1;
}

void SVG::EllipseElement::path(SVG::EllipseElement *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, CGPath **a3@<X8>)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double v7 = SVG::Length::computeValue((SVG::EllipseElement *)((char *)this + 688), a2.size.width);
  double v8 = SVG::Length::computeValue((SVG::EllipseElement *)((char *)this + 704), height);
  double v9 = SVG::Length::computeValue((SVG::EllipseElement *)((char *)this + 720), width);
  double v10 = SVG::Length::computeValue((SVG::EllipseElement *)((char *)this + 736), height);
  if (v9 <= 0.0 || (double v11 = v10, v10 <= 0.0))
  {
    *a3 = 0;
  }
  else
  {
    Mutable = CGPathCreateMutable();
    v14.origin.CGFloat x = v7 - v9;
    v14.origin.CGFloat y = v8 - v11;
    v14.size.double width = v9 + v9;
    v14.size.double height = v11 + v11;
    CGPathAddEllipseInRect(Mutable, 0, v14);
    *a3 = Mutable;
    if (Mutable)
    {
      CFRetain(Mutable);
      CFRelease(Mutable);
    }
  }
}

double SVG::EllipseElement::boundingBox(SVG::EllipseElement *this, CGRect a2)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double v5 = SVG::Length::computeValue((SVG::EllipseElement *)((char *)this + 688), a2.size.width);
  SVG::Length::computeValue((SVG::EllipseElement *)((char *)this + 704), height);
  double v6 = SVG::Length::computeValue((SVG::EllipseElement *)((char *)this + 720), width);
  SVG::Length::computeValue((SVG::EllipseElement *)((char *)this + 736), height);
  return v5 - v6;
}

void SVG::EllipseElement::~EllipseElement(SVG::EllipseElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A75928[v2])(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A75940[v3])(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A75958[v4])(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A75940[v5])(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A75958[v6])(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A75928[v2])(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A75940[v3])(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A75958[v4])(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A75940[v5])(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A75958[v6])(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

uint64_t SVG::LinearGradientElement::LinearGradientElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = 0;
  *(void *)a1 = &unk_1F1A74968;
  *(unsigned char *)(a1 + 648) = 0;
  *(unsigned char *)(a1 + 652) = 0;
  *(unsigned char *)(a1 + 656) = 0;
  *(unsigned char *)(a1 + 704) = 0;
  *(unsigned char *)(a1 + 712) = 0;
  *(unsigned char *)(a1 + 716) = 0;
  *(unsigned char *)(a1 + 72CGContextBeginTransparencyLayer(c, 0) = 0;
  *(unsigned char *)(a1 + 736) = 0;
  *(unsigned char *)(a1 + 744) = 0;
  *(unsigned char *)(a1 + 76CGContextBeginTransparencyLayer(c, 0) = 0;
  *(unsigned char *)(a1 + 768) = 0;
  *(unsigned char *)(a1 + 784) = 0;
  *(unsigned char *)(a1 + 792) = 0;
  *(unsigned char *)(a1 + 808) = 0;
  SVG::GradientElement::parseAttributes((void *)a1, a3);
  std::string::basic_string[abi:nn180100]<0>(v17, "x1");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
  if (v6)
  {
    v17[0] = (void *)-1;
    v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v6 + 64), (uint64_t)v17);
    if ((_BYTE)v18)
    {
      int v7 = *(unsigned __int8 *)(a1 + 736);
      *(_OWORD *)(a1 + 72CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)v17;
      if (!v7) {
        *(unsigned char *)(a1 + 736) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v17, "y1");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
  if (v8)
  {
    v17[0] = (void *)-1;
    v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v8 + 64), (uint64_t)v17);
    if ((_BYTE)v18)
    {
      int v9 = *(unsigned __int8 *)(a1 + 760);
      *(_OWORD *)(a1 + 744) = *(_OWORD *)v17;
      if (!v9) {
        *(unsigned char *)(a1 + 76CGContextBeginTransparencyLayer(c, 0) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v17, "x2");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v10 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
  if (v10)
  {
    v17[0] = (void *)-1;
    v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v10 + 64), (uint64_t)v17);
    if ((_BYTE)v18)
    {
      int v11 = *(unsigned __int8 *)(a1 + 784);
      *(_OWORD *)(a1 + 768) = *(_OWORD *)v17;
      if (!v11) {
        *(unsigned char *)(a1 + 784) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v17, "y2");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v12 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
  if (v12)
  {
    v17[0] = (void *)-1;
    v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v12 + 64), (uint64_t)v17);
    if ((_BYTE)v18)
    {
      int v13 = *(unsigned __int8 *)(a1 + 808);
      *(_OWORD *)(a1 + 792) = *(_OWORD *)v17;
      if (!v13) {
        *(unsigned char *)(a1 + 808) = 1;
      }
    }
  }
  return a1;
}

void SVG::LinearGradientElement::specifiedLinearState(unint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 16CGContextBeginTransparencyLayer(c, 0) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)(a3 + 96) = xmmword_1BF1DAF58;
  *(_OWORD *)(a3 + 112) = unk_1BF1DAF68;
  *(_OWORD *)(a3 + 128) = xmmword_1BF1DAF78;
  *(_OWORD *)(a3 + 144) = unk_1BF1DAF88;
  *(_OWORD *)(a3 + 32) = xmmword_1BF1DAF18;
  *(_OWORD *)(a3 + 48) = unk_1BF1DAF28;
  *(_OWORD *)(a3 + 64) = xmmword_1BF1DAF38;
  *(_OWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = unk_1BF1DAF48;
  *(_OWORD *)a3 = xmmword_1BF1DAEF8;
  *(_OWORD *)(a3 + 16) = unk_1BF1DAF08;
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 4) = 0;
  *(unsigned char *)(a3 + 8) = 0;
  long long v68 = (_OWORD *)(a3 + 8);
  *(unsigned char *)(a3 + 56) = 0;
  *(unsigned char *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 68) = 0;
  *(unsigned char *)(a3 + 72) = 0;
  uint64_t v70 = a3 + 72;
  *(unsigned char *)(a3 + 88) = 0;
  *(unsigned char *)(a3 + 96) = 0;
  *(unsigned char *)(a3 + 112) = 0;
  *(unsigned char *)(a3 + 12CGContextBeginTransparencyLayer(c, 0) = 0;
  uint64_t v69 = a3 + 120;
  *(unsigned char *)(a3 + 136) = 0;
  *(unsigned char *)(a3 + 144) = 0;
  *(unsigned char *)(a3 + 16CGContextBeginTransparencyLayer(c, 0) = 0;
  uint64_t v6 = (char *)operator new(8uLL);
  *(void *)uint64_t v6 = a1;
  int v7 = v6 + 8;
  memset(v71, 0, 32);
  *(void *)&v71[32] = 0xAAAAAAAA3F800000;
  unint64_t v8 = 0x9DDFEA08EB382D69 * (((((a1 >> 3) & 0x3FFFFFF) << 6) | 8) ^ HIDWORD(a1));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (HIDWORD(a1) ^ (v8 >> 47) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
  int v11 = operator new(0x18uLL);
  v11[1] = v10;
  v11[2] = a1;
  std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>((uint64_t)v71, 1uLL);
  unint64_t v12 = *(void *)&v71[8];
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v71[8]);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    if (v10 >= *(void *)&v71[8]) {
      v10 %= *(void *)&v71[8];
    }
  }
  else
  {
    v10 &= *(void *)&v71[8] - 1;
  }
  uint64_t v14 = *(void *)v71;
  double v15 = *(void **)(*(void *)v71 + 8 * v10);
  if (v15)
  {
    *int v11 = *v15;
  }
  else
  {
    *int v11 = *(void *)&v71[16];
    *(void *)&v71[16] = v11;
    *(void *)(v14 + 8 * v1CGContextBeginTransparencyLayer(c, 0) = &v71[16];
    if (!*v11) {
      goto LABEL_14;
    }
    unint64_t v16 = *(void *)(*v11 + 8);
    if (v13.u32[0] > 1uLL)
    {
      if (v16 >= v12) {
        v16 %= v12;
      }
    }
    else
    {
      v16 &= v12 - 1;
    }
    double v15 = (void *)(*(void *)v71 + 8 * v16);
  }
  *double v15 = v11;
LABEL_14:
  ++*(void *)&v71[24];
  *(void *)uint64_t v77 = *(void *)(*(void *)v6 + 640);
  if (*(void *)v77)
  {
    uint64_t v17 = v6 + 8;
    while (1)
    {
      unint64_t v18 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(a2, v77);
      if (!v18)
      {
        unint64_t v43 = v17;
        goto LABEL_95;
      }
      if (!v19) {
        goto LABEL_96;
      }
      unint64_t v20 = v19;
      unint64_t v21 = *(void *)&v71[8];
      unint64_t v22 = 0x9DDFEA08EB382D69 * (((8 * v19) + 8) ^ HIDWORD(v19));
      unint64_t v23 = 0x9DDFEA08EB382D69 * (HIDWORD(v19) ^ (v22 >> 47) ^ v22);
      unint64_t v24 = 0x9DDFEA08EB382D69 * (v23 ^ (v23 >> 47));
      if (*(void *)&v71[8])
      {
        uint8x8_t v25 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v71[8]);
        v25.i16[0] = vaddlv_u8(v25);
        if (v25.u32[0] > 1uLL)
        {
          unint64_t v26 = 0x9DDFEA08EB382D69 * (v23 ^ (v23 >> 47));
          if (v24 >= *(void *)&v71[8]) {
            unint64_t v26 = v24 % *(void *)&v71[8];
          }
        }
        else
        {
          unint64_t v26 = (*(void *)&v71[8] - 1) & v24;
        }
        CGRect v28 = *(void **)(*(void *)v71 + 8 * v26);
        if (v28)
        {
          for (char i = (void *)*v28; i; char i = (void *)*i)
          {
            unint64_t v30 = i[1];
            if (v30 == v24)
            {
              if (i[2] == v19) {
                goto LABEL_96;
              }
            }
            else
            {
              if (v25.u32[0] > 1uLL)
              {
                if (v30 >= *(void *)&v71[8]) {
                  v30 %= *(void *)&v71[8];
                }
              }
              else
              {
                v30 &= *(void *)&v71[8] - 1;
              }
              if (v30 != v26) {
                break;
              }
            }
          }
        }
        if (v25.u32[0] > 1uLL)
        {
          unint64_t v27 = 0x9DDFEA08EB382D69 * (v23 ^ (v23 >> 47));
          if (v24 >= *(void *)&v71[8]) {
            unint64_t v27 = v24 % *(void *)&v71[8];
          }
        }
        else
        {
          unint64_t v27 = (*(void *)&v71[8] - 1) & v24;
        }
        double v31 = *(void **)(*(void *)v71 + 8 * v27);
        if (v31)
        {
          for (j = (void *)*v31; j; j = (void *)*j)
          {
            unint64_t v33 = j[1];
            if (v33 == v24)
            {
              if (j[2] == v19) {
                goto LABEL_72;
              }
            }
            else
            {
              if (v25.u32[0] > 1uLL)
              {
                if (v33 >= *(void *)&v71[8]) {
                  v33 %= *(void *)&v71[8];
                }
              }
              else
              {
                v33 &= *(void *)&v71[8] - 1;
              }
              if (v33 != v27) {
                break;
              }
            }
          }
        }
      }
      else
      {
        unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
      }
      uint64_t v34 = operator new(0x18uLL);
      *uint64_t v34 = 0;
      v34[1] = v24;
      v34[2] = v20;
      float v35 = (float)(unint64_t)(*(void *)&v71[24] + 1);
      if (!v21 || (float)(*(float *)&v71[32] * (float)v21) < v35)
      {
        BOOL v36 = (v21 & (v21 - 1)) != 0;
        if (v21 < 3) {
          BOOL v36 = 1;
        }
        unint64_t v37 = v36 | (2 * v21);
        unint64_t v38 = vcvtps_u32_f32(v35 / *(float *)&v71[32]);
        if (v37 <= v38) {
          size_t v39 = v38;
        }
        else {
          size_t v39 = v37;
        }
        std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>((uint64_t)v71, v39);
        unint64_t v21 = *(void *)&v71[8];
        if ((*(void *)&v71[8] & (*(void *)&v71[8] - 1)) != 0)
        {
          if (v24 >= *(void *)&v71[8]) {
            unint64_t v27 = v24 % *(void *)&v71[8];
          }
          else {
            unint64_t v27 = v24;
          }
        }
        else
        {
          unint64_t v27 = (*(void *)&v71[8] - 1) & v24;
        }
      }
      uint64_t v40 = *(void *)v71;
      unint64_t v41 = *(void **)(*(void *)v71 + 8 * v27);
      if (v41) {
        break;
      }
      *uint64_t v34 = *(void *)&v71[16];
      *(void *)&v71[16] = v34;
      *(void *)(v40 + 8 * v27) = &v71[16];
      if (*v34)
      {
        unint64_t v42 = *(void *)(*v34 + 8);
        if ((v21 & (v21 - 1)) != 0)
        {
          if (v42 >= v21) {
            v42 %= v21;
          }
        }
        else
        {
          v42 &= v21 - 1;
        }
        unint64_t v41 = (void *)(*(void *)v71 + 8 * v42);
        goto LABEL_70;
      }
LABEL_71:
      ++*(void *)&v71[24];
LABEL_72:
      if (v17 >= v7)
      {
        uint64_t v44 = (v17 - v6) >> 3;
        unint64_t v45 = v44 + 1;
        if ((unint64_t)(v44 + 1) >> 61) {
          abort();
        }
        if ((v7 - v6) >> 2 > v45) {
          unint64_t v45 = (v7 - v6) >> 2;
        }
        if ((unint64_t)(v7 - v6) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v46 = v45;
        }
        if (v46)
        {
          if (v46 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          double v47 = (char *)operator new(8 * v46);
        }
        else
        {
          double v47 = 0;
        }
        long long v48 = &v47[8 * v44];
        int v7 = &v47[8 * v46];
        *(void *)long long v48 = v20;
        unint64_t v43 = v48 + 8;
        if (v17 == v6)
        {
          uint64_t v6 = v17;
        }
        else
        {
          do
          {
            uint64_t v49 = *((void *)v17 - 1);
            v17 -= 8;
            *((void *)v48 - 1) = v49;
            v48 -= 8;
          }
          while (v17 != v6);
          if (!v6) {
            goto LABEL_90;
          }
        }
        operator delete(v6);
LABEL_90:
        uint64_t v6 = v48;
        goto LABEL_91;
      }
      *(void *)uint64_t v17 = v20;
      unint64_t v43 = v17 + 8;
LABEL_91:
      *(void *)uint64_t v77 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)uint64_t v77 = *(void *)(*((void *)v43 - 1) + 640);
      uint64_t v17 = v43;
      if (!*(void *)v77) {
        goto LABEL_95;
      }
    }
    *uint64_t v34 = *v41;
LABEL_70:
    *unint64_t v41 = v34;
    goto LABEL_71;
  }
  unint64_t v43 = v6 + 8;
LABEL_95:
  uint64_t v17 = v43;
LABEL_96:
  double v50 = *(void **)&v71[16];
  if (*(void *)&v71[16])
  {
    do
    {
      double v51 = (void *)*v50;
      operator delete(v50);
      double v50 = v51;
    }
    while (v51);
  }
  double v52 = *(void **)v71;
  *(void *)uint64_t v71 = 0;
  if (v52) {
    operator delete(v52);
  }
  if (v17 != v6)
  {
    do
    {
      uint64_t v53 = v6;
      uint64_t v55 = *((void *)v17 - 1);
      v17 -= 8;
      double v54 = (unsigned char *)v55;
      uint64_t v76 = *(void *)(v55 + 808);
      long long v56 = *(_OWORD *)(v55 + 792);
      *(_OWORD *)&v74[16] = *(_OWORD *)(v55 + 776);
      long long v75 = v56;
      long long v57 = *(_OWORD *)(v55 + 728);
      *(_OWORD *)unint64_t v72 = *(_OWORD *)(v55 + 712);
      *(_OWORD *)&v72[16] = v57;
      long long v58 = *(_OWORD *)(v55 + 760);
      long long v73 = *(_OWORD *)(v55 + 744);
      *(_OWORD *)uint64_t v74 = v58;
      long long v59 = *(_OWORD *)(v55 + 664);
      *(_OWORD *)uint64_t v71 = *(_OWORD *)(v55 + 648);
      *(_OWORD *)&v71[16] = v59;
      long long v60 = *(_OWORD *)(v55 + 696);
      *(_OWORD *)&v71[32] = *(_OWORD *)(v55 + 680);
      *(_OWORD *)&v71[48] = v60;
      *(_OWORD *)uint64_t v77 = xmmword_1BF1DAEB0;
      memset(&v77[16], 255, 32);
      *(_OWORD *)&v77[48] = unk_1BF1DAEE0;
      unint64_t v78 = 0xAAAAAAAAAAAAAAAALL;
      SVG::GradientElement::State::specifiedInherit(v55 + 648, a3, (uint64_t)v77);
      *(_DWORD *)uint64_t v71 = *(_DWORD *)v77;
      v71[4] = v77[4];
      *(_OWORD *)&v71[8] = *(_OWORD *)&v77[8];
      *(_OWORD *)&v71[24] = *(_OWORD *)&v77[24];
      *(_OWORD *)&v71[40] = *(_OWORD *)&v77[40];
      v71[56] = v77[56];
      *(_DWORD *)unint64_t v72 = v78;
      v72[4] = BYTE4(v78);
      if (!*(unsigned char *)(v55 + 736) && *(unsigned char *)(a3 + 88))
      {
        *(_OWORD *)&v72[8] = *(_OWORD *)v70;
        v72[24] = *(unsigned char *)(v70 + 16);
      }
      if (!v54[760] && *(unsigned char *)(a3 + 112))
      {
        long long v73 = *(_OWORD *)(a3 + 96);
        v74[0] = *(unsigned char *)(a3 + 112);
      }
      if (!v54[784] && *(unsigned char *)(a3 + 136))
      {
        *(_OWORD *)&v74[8] = *(_OWORD *)v69;
        v74[24] = *(unsigned char *)(v69 + 16);
      }
      if (!v54[808] && *(unsigned char *)(a3 + 160))
      {
        long long v75 = *(_OWORD *)(a3 + 144);
        LOBYTE(v76) = *(unsigned char *)(a3 + 160);
      }
      long long v61 = v75;
      *(_OWORD *)(a3 + 128) = *(_OWORD *)&v74[16];
      *(_OWORD *)(a3 + 144) = v61;
      *(void *)(a3 + 16CGContextBeginTransparencyLayer(c, 0) = v76;
      long long v62 = *(_OWORD *)&v72[16];
      *(_OWORD *)(a3 + 64) = *(_OWORD *)v72;
      *(_OWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = v62;
      long long v63 = *(_OWORD *)v74;
      *(_OWORD *)(a3 + 96) = v73;
      *(_OWORD *)(a3 + 112) = v63;
      long long v64 = *(_OWORD *)&v71[16];
      *(_OWORD *)a3 = *(_OWORD *)v71;
      *(_OWORD *)(a3 + 16) = v64;
      long long v65 = *(_OWORD *)&v71[48];
      *(_OWORD *)(a3 + 32) = *(_OWORD *)&v71[32];
      *(_OWORD *)(a3 + 48) = v65;
      uint64_t v6 = v53;
    }
    while (v17 != v53);
  }
  if (!*(unsigned char *)(a3 + 4))
  {
    *(_DWORD *)a3 = 1;
    *(unsigned char *)(a3 + 4) = 1;
  }
  if (!*(unsigned char *)(a3 + 56))
  {
    uint64_t v66 = MEMORY[0x1E4F1DAB8];
    long long v67 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *long long v68 = *MEMORY[0x1E4F1DAB8];
    v68[1] = v67;
    v68[2] = *(_OWORD *)(v66 + 32);
    *(unsigned char *)(a3 + 56) = 1;
  }
  if (!*(unsigned char *)(a3 + 68))
  {
    *(_DWORD *)(a3 + 64) = 0;
    *(unsigned char *)(a3 + 68) = 1;
  }
  if (!*(unsigned char *)(a3 + 88))
  {
    *(void *)(a3 + 72) = 0;
    *(_DWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = 1;
    *(unsigned char *)(a3 + 88) = 1;
  }
  if (!*(unsigned char *)(a3 + 112))
  {
    *(void *)(a3 + 96) = 0;
    *(_DWORD *)(a3 + 104) = 1;
    *(unsigned char *)(a3 + 112) = 1;
  }
  if (!*(unsigned char *)(a3 + 136))
  {
    *(void *)(a3 + 12CGContextBeginTransparencyLayer(c, 0) = 0x4059000000000000;
    *(_DWORD *)(a3 + 128) = 1;
    *(unsigned char *)(a3 + 136) = 1;
  }
  if (!*(unsigned char *)(a3 + 160))
  {
    *(void *)(a3 + 144) = 0;
    *(_DWORD *)(a3 + 152) = 1;
    *(unsigned char *)(a3 + 16CGContextBeginTransparencyLayer(c, 0) = 1;
  }
  if (v6) {
    operator delete(v6);
  }
}

void SVG::LinearGradientElement::~LinearGradientElement(SVG::LinearGradientElement *this)
{
  *(void *)this = &unk_1F1A74810;
  uint64_t v2 = (const void *)*((void *)this + 80);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A75970[v3])(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A75988[v4])(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A759A0[v5])(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A75988[v6])(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))off_1F1A759A0[v7])(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;

  *(void *)this = &unk_1F1A74810;
  uint64_t v2 = (const void *)*((void *)this + 80);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A75970[v3])(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A75988[v4])(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A759A0[v5])(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A75988[v6])(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))off_1F1A759A0[v7])(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

uint64_t SVG::LinearGradientElement::getState(SVG::LinearGradientElement *this)
{
  return (uint64_t)this + 648;
}

__n128 SVG::LinearGradientElement::specifiedState@<Q0>(unint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  SVG::LinearGradientElement::specifiedLinearState(a1, a2, (uint64_t)v6);
  long long v4 = v6[3];
  *(_OWORD *)(a3 + 32) = v6[2];
  *(_OWORD *)(a3 + 48) = v4;
  *(void *)(a3 + 64) = v7;
  __n128 result = (__n128)v6[1];
  *(_OWORD *)a3 = v6[0];
  *(__n128 *)(a3 + 16) = result;
  return result;
}

uint64_t SVG::ClipPathElement::ClipPathElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)a1 = &unk_1F1A747E0;
  uint64_t v6 = MEMORY[0x1E4F1DAB8];
  long long v7 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = *MEMORY[0x1E4F1DAB8];
  *(_OWORD *)(a1 + 656) = v7;
  *(_OWORD *)(a1 + 672) = *(_OWORD *)(v6 + 32);
  *(_DWORD *)(a1 + 688) = 0;
  std::string::basic_string[abi:nn180100]<0>(v14, "transform");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)v14, (uint64_t)__p);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v15) < 0)
  {
    operator delete(v14[0]);
    if (!v8) {
      goto LABEL_9;
    }
  }
  else if (!v8)
  {
    goto LABEL_9;
  }
  *(void *)&long long v9 = -1;
  *((void *)&v9 + 1) = -1;
  long long v15 = v9;
  long long v16 = v9;
  *(_OWORD *)uint64_t v14 = v9;
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  SVG::parseTransform((uint64_t)(v8 + 64), (uint64_t)v14);
  if ((_BYTE)v17)
  {
    long long v10 = v15;
    *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)v14;
    *(_OWORD *)(a1 + 656) = v10;
    *(_OWORD *)(a1 + 672) = v16;
  }
LABEL_9:
  std::string::basic_string[abi:nn180100]<0>(v14, "clipPathUnits");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v11 = SVG::Element::findInAttributeMap(a3, (uint64_t)v14, (uint64_t)__p);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v15) < 0)
  {
    operator delete(v14[0]);
    if (!v11) {
      return a1;
    }
  }
  else if (!v11)
  {
    return a1;
  }
  uint64_t v12 = SVG::parseUnits((uint64_t)(v11 + 64));
  if ((v12 & 0xFF00000000) != 0) {
    *(_DWORD *)(a1 + 688) = v12;
  }
  return a1;
}

uint64_t SVG::ClipPathElement::appendChild(int64x2_t *a1, uint64_t *a2)
{
  uint64_t v2 = (const void *)*a2;
  if (!*a2
  {
    return 0;
  }
  return SVG::Element::appendChild(a1, a2);
}

void SVG::clipPaths(CGFloat a1@<X0>, void *a2@<X1>, void *a3@<X2>, float *a4@<X3>, uint64_t a5@<X8>, CGFloat a6@<D0>, CGFloat a7@<D1>, CGFloat a8@<D2>, CGFloat a9@<D3>, double a10@<D4>, double a11@<D5>, double a12@<D6>, double a13@<D7>)
{
  CGFloat v187 = a6;
  CGFloat v188 = a7;
  CGFloat v189 = a8;
  CGFloat v190 = a9;
  *(double *)v184 = a10;
  *(double *)&v184[1] = a11;
  double v185 = a12;
  double v186 = a13;
  if (std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::find<SVG::Element const*>(a4, *(unint64_t *)&a1))
  {
    uint64_t v18 = MEMORY[0x1E4F1DAB8];
    long long v19 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *(_OWORD *)(a5 + 24) = *MEMORY[0x1E4F1DAB8];
    *(_OWORD *)(a5 + 4CGContextBeginTransparencyLayer(c, 0) = v19;
    *(_OWORD *)(a5 + 56) = *(_OWORD *)(v18 + 32);
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    *(void *)a5 = &unk_1F1A74438;
    *(void *)(a5 + 8CGContextBeginTransparencyLayer(c, 0) = 0;
    *(void *)(a5 + 88) = 0;
    *(void *)(a5 + 72) = 0;
    memset(&v192, 0, 24);
    *(void *)&v191.CGFloat a = &v192;
    std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v191);
    return;
  }
  unint64_t v20 = 0x9DDFEA08EB382D69 * (((((*(void *)&a1 >> 3) & 0x3FFFFFFLL) << 6) | 8) ^ HIDWORD(*(void *)&a1));
  unint64_t v21 = 0x9DDFEA08EB382D69 * (HIDWORD(*(void *)&a1) ^ (v20 >> 47) ^ v20);
  unint64_t v22 = 0x9DDFEA08EB382D69 * (v21 ^ (v21 >> 47));
  unint64_t v23 = *((void *)a4 + 1);
  if (v23)
  {
    uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v23);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      unint64_t v25 = 0x9DDFEA08EB382D69 * (v21 ^ (v21 >> 47));
      if (v22 >= v23) {
        unint64_t v25 = v22 % v23;
      }
    }
    else
    {
      unint64_t v25 = (v23 - 1) & v22;
    }
    unint64_t v26 = *(void **)(*(void *)a4 + 8 * v25);
    if (v26)
    {
      for (char i = (void *)*v26; i; char i = (void *)*i)
      {
        unint64_t v28 = i[1];
        if (v28 == v22)
        {
          if (i[2] == *(void *)&a1) {
            goto LABEL_76;
          }
        }
        else
        {
          if (v24.u32[0] > 1uLL)
          {
            if (v28 >= v23) {
              v28 %= v23;
            }
          }
          else
          {
            v28 &= v23 - 1;
          }
          if (v28 != v25) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  }
  uint64_t v29 = (CGFloat *)operator new(0x18uLL);
  *uint64_t v29 = 0.0;
  *((void *)v29 + 1) = v22;
  v29[2] = a1;
  float v30 = (float)(unint64_t)(*((void *)a4 + 3) + 1);
  float v31 = a4[8];
  if (!v23 || (float)(v31 * (float)v23) < v30)
  {
    BOOL v32 = 1;
    if (v23 >= 3) {
      BOOL v32 = (v23 & (v23 - 1)) != 0;
    }
    unint64_t v33 = v32 | (2 * v23);
    unint64_t v34 = vcvtps_u32_f32(v30 / v31);
    if (v33 <= v34) {
      int8x8_t prime = (int8x8_t)v34;
    }
    else {
      int8x8_t prime = (int8x8_t)v33;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v23 = *((void *)a4 + 1);
    }
    if (*(void *)&prime > v23) {
      goto LABEL_32;
    }
    if (*(void *)&prime < v23)
    {
      unint64_t v42 = vcvtps_u32_f32((float)*((unint64_t *)a4 + 3) / a4[8]);
      if (v23 < 3 || (uint8x8_t v43 = (uint8x8_t)vcnt_s8((int8x8_t)v23), v43.i16[0] = vaddlv_u8(v43), v43.u32[0] > 1uLL))
      {
        unint64_t v42 = std::__next_prime(v42);
      }
      else
      {
        uint64_t v44 = 1 << -(char)__clz(v42 - 1);
        if (v42 >= 2) {
          unint64_t v42 = v44;
        }
      }
      if (*(void *)&prime <= v42) {
        int8x8_t prime = (int8x8_t)v42;
      }
      if (*(void *)&prime >= v23)
      {
        unint64_t v23 = *((void *)a4 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_32:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          BOOL v36 = operator new(8 * *(void *)&prime);
          unint64_t v37 = *(void **)a4;
          *(void *)a4 = v36;
          if (v37) {
            operator delete(v37);
          }
          uint64_t v38 = 0;
          *((int8x8_t *)a4 + 1) = prime;
          do
            *(void *)(*(void *)a4 + 8 * v38++) = 0;
          while (*(void *)&prime != v38);
          size_t v39 = (void *)*((void *)a4 + 2);
          if (v39)
          {
            unint64_t v40 = v39[1];
            uint8x8_t v41 = (uint8x8_t)vcnt_s8(prime);
            v41.i16[0] = vaddlv_u8(v41);
            if (v41.u32[0] > 1uLL)
            {
              if (v40 >= *(void *)&prime) {
                v40 %= *(void *)&prime;
              }
            }
            else
            {
              v40 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a4 + 8 * v4CGContextBeginTransparencyLayer(c, 0) = a4 + 4;
            unint64_t v45 = (void *)*v39;
            if (*v39)
            {
              do
              {
                unint64_t v46 = v45[1];
                if (v41.u32[0] > 1uLL)
                {
                  if (v46 >= *(void *)&prime) {
                    v46 %= *(void *)&prime;
                  }
                }
                else
                {
                  v46 &= *(void *)&prime - 1;
                }
                if (v46 != v40)
                {
                  if (!*(void *)(*(void *)a4 + 8 * v46))
                  {
                    *(void *)(*(void *)a4 + 8 * v46) = v39;
                    goto LABEL_57;
                  }
                  *size_t v39 = *v45;
                  void *v45 = **(void **)(*(void *)a4 + 8 * v46);
                  **(void **)(*(void *)a4 + 8 * v46) = v45;
                  unint64_t v45 = v39;
                }
                unint64_t v46 = v40;
LABEL_57:
                size_t v39 = v45;
                unint64_t v45 = (void *)*v45;
                unint64_t v40 = v46;
              }
              while (v45);
            }
          }
          unint64_t v23 = (unint64_t)prime;
          goto LABEL_61;
        }
        uint64_t v160 = *(void **)a4;
        *(void *)a4 = 0;
        if (v160) {
          operator delete(v160);
        }
        unint64_t v23 = 0;
        *((void *)a4 + 1) = 0;
      }
    }
LABEL_61:
    if ((v23 & (v23 - 1)) != 0)
    {
      if (v22 >= v23) {
        unint64_t v25 = v22 % v23;
      }
      else {
        unint64_t v25 = v22;
      }
    }
    else
    {
      unint64_t v25 = (v23 - 1) & v22;
    }
  }
  double v47 = *(void **)a4;
  long long v48 = *(CGFloat ***)(*(void *)a4 + 8 * v25);
  if (v48)
  {
    *(void *)uint64_t v29 = *v48;
  }
  else
  {
    uint64_t v49 = *((void *)a4 + 2);
    *(void *)uint64_t v29 = v49;
    *((void *)a4 + 2) = v29;
    v47[v25] = a4 + 4;
    if (!v49) {
      goto LABEL_75;
    }
    unint64_t v50 = *(void *)(v49 + 8);
    if ((v23 & (v23 - 1)) != 0)
    {
      if (v50 >= v23) {
        v50 %= v23;
      }
    }
    else
    {
      v50 &= v23 - 1;
    }
    long long v48 = (CGFloat **)(*(void *)a4 + 8 * v50);
  }
  *long long v48 = v29;
LABEL_75:
  ++*((void *)a4 + 3);
LABEL_76:
  v192.CGFloat a = a1;
  double v51 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(a3, &v192);
  if (v51[149] != 2) {
    goto LABEL_221;
  }
  if (v51[148])
  {
LABEL_80:
    uint64_t v52 = MEMORY[0x1E4F1DAB8];
    long long v53 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *(_OWORD *)(a5 + 24) = *MEMORY[0x1E4F1DAB8];
    *(_OWORD *)(a5 + 4CGContextBeginTransparencyLayer(c, 0) = v53;
    *(_OWORD *)(a5 + 56) = *(_OWORD *)(v52 + 32);
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    *(void *)a5 = &unk_1F1A74438;
    *(void *)(a5 + 8CGContextBeginTransparencyLayer(c, 0) = 0;
    *(void *)(a5 + 88) = 0;
    *(void *)(a5 + 72) = 0;
    memset(&v192, 0, 24);
    *(void *)&v191.CGFloat a = &v192;
    double v54 = (void ***)&v191;
    goto LABEL_81;
  }
  if (v51[40] != 2) {
    goto LABEL_221;
  }
  if (v51[39] == 2) {
    goto LABEL_80;
  }
  v183[0] = a2;
  v183[1] = a3;
  v183[2] = &v187;
  v183[3] = v184;
  v183[4] = a4;
  long long v173 = unk_1BF1DB088;
  long long v174 = *(_OWORD *)&byte_1BF1DB058[32];
  CGAffineTransform v192 = *(CGAffineTransform *)byte_1BF1DB058;
  long long v193 = unk_1BF1DB088;
  long long v172 = xmmword_1BF1DB098;
  long long v194 = xmmword_1BF1DB098;
  memset(v195, 170, 24);
  memset(v171, 170, sizeof(v171));
  if (v51[26] != 2)
  {
LABEL_221:
    std::__throw_bad_variant_access[abi:nn180100]();
    goto LABEL_222;
  }
  SVG::clipPaths(SVG::ClipPathElement const&,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,CGRect,CGRect,std::unordered_set<SVG::ClipPathElement const*> &)::$_1::operator()((uint64_t)&v192, (uint64_t)v183, (uint64_t)(v51 + 22));
  BOOL v170 = a2;
  if (LOBYTE(v195[1]))
  {
    long long v65 = operator new(0x78uLL);
    v65[1] = 0;
    v65[2] = 0;
    *long long v65 = &unk_1F1A74DF0;
    BOOL v175 = v65 + 3;
    std::construct_at[abi:nn180100]<SVG::ClipToPaths::ParentClipNode,SVG::ClipToPaths::ParentClipNode&,SVG::ClipToPaths::ParentClipNode*>((uint64_t)(v65 + 3), (uint64_t)&v192);
  }
  else
  {
    BOOL v175 = 0;
    long long v65 = 0;
  }
  std::__optional_destruct_base<SVG::ClipToPaths::ParentClipNode,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v192);
  v182[0] = a3;
  v182[1] = v184;
  v182[2] = v183;
  uint64_t v177 = &v181;
  int64x2_t v180 = 0uLL;
  double v181 = 0.0;
  uint64_t v66 = *(const void ***)(*(void *)&a1 + 32);
  long long v67 = *(const void ***)(*(void *)&a1 + 40);
  if (v66 != v67)
  {
    v176 = a3;
    v165 = v65;
    do
    {
      long long v68 = *v66;
      if (v69)
      {
        v191.CGFloat a = -3.72066208e-103;
        v191.CGFloat b = -3.72066208e-103;
        SVG::clipPaths(SVG::ClipPathElement const&,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,CGRect,CGRect,std::unordered_set<SVG::ClipPathElement const*> &)::$_2::operator()(&v191, (uint64_t)v182, (uint64_t)v69);
        CGFloat a = v191.a;
        if (*(void *)&v191.a)
        {
          uint64_t v72 = v180.i64[1];
          if (v180.i64[1] >= *(void *)&v181)
          {
            uint64_t v85 = (v180.i64[1] - v180.i64[0]) >> 4;
            unint64_t v86 = v85 + 1;
            if ((unint64_t)(v85 + 1) >> 60) {
              goto LABEL_222;
            }
            uint64_t v87 = *(void *)&v181 - v180.i64[0];
            if ((*(void *)&v181 - v180.i64[0]) >> 3 > v86) {
              unint64_t v86 = v87 >> 3;
            }
            if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v88 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v88 = v86;
            }
            *(void *)&v192.tCGFloat x = v177;
            unint64_t v89 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v88);
            unint64_t v91 = (CGFloat *)&v89[16 * v85];
            *unint64_t v91 = a;
            CGFloat b = v191.b;
            v91[1] = v191.b;
            if (b != 0.0) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&b + 8), 1uLL, memory_order_relaxed);
            }
            unint64_t v92 = (void *)v180.i64[1];
            long long v93 = (void *)v180.i64[0];
            if (v180.i64[1] == v180.i64[0])
            {
              int64x2_t v96 = vdupq_n_s64(v180.u64[1]);
              unint64_t v94 = v91;
            }
            else
            {
              unint64_t v94 = v91;
              do
              {
                long long v95 = *((_OWORD *)v92 - 1);
                v92 -= 2;
                *((_OWORD *)v94 - 1) = v95;
                v94 -= 2;
                void *v92 = 0;
                v92[1] = 0;
              }
              while (v92 != v93);
              int64x2_t v96 = v180;
            }
            uint64_t v74 = v91 + 2;
            v180.i64[0] = (uint64_t)v94;
            v180.i64[1] = (uint64_t)(v91 + 2);
            *(int64x2_t *)&v192.CGFloat b = v96;
            CGFloat v97 = v181;
            *(void *)&double v181 = &v89[16 * v90];
            v192.CGFloat d = v97;
            *(void *)&v192.CGFloat a = v96.i64[0];
            std::__split_buffer<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::~__split_buffer((uint64_t)&v192);
          }
          else
          {
            *(CGFloat *)v180.i64[1] = v191.a;
            CGFloat b = v191.b;
            *(CGFloat *)(v72 + 8) = v191.b;
            if (b != 0.0) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&b + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v74 = (CGFloat *)(v72 + 16);
          }
          v180.i64[1] = (uint64_t)v74;
        }
        else
        {
          CGFloat b = v191.b;
        }
        if (b != 0.0) {
          std::__shared_weak_count::__release_shared[abi:nn180100](*(std::__shared_weak_count **)&b);
        }
      }
      else
      {
        if (v75)
        {
          uint64_t v76 = v75;
          *(void *)&v192.CGFloat a = v75;
          uint64_t v77 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(v176, &v192);
          if (v77[149] != 2) {
            goto LABEL_221;
          }
          unint64_t v78 = v77;
          if (!v77[148])
          {
            if (v77[40] != 2) {
              goto LABEL_221;
            }
            if (v77[39] != 2)
            {
              int64x2_t v196 = 0uLL;
              double v197 = 0.0;
              v192.CGFloat a = v76[94];
              char v79 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(v170, &v192);
              if (v79)
              {
                if (v80)
                {
                  v191.CGFloat a = -3.72066208e-103;
                  v191.CGFloat b = -3.72066208e-103;
                  SVG::clipPaths(SVG::ClipPathElement const&,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,CGRect,CGRect,std::unordered_set<SVG::ClipPathElement const*> &)::$_2::operator()(&v191, (uint64_t)v182, (uint64_t)v80);
                  CGFloat v81 = v191.a;
                  if (*(void *)&v191.a)
                  {
                    uint64_t v82 = v196.i64[1];
                    if (v196.i64[1] >= *(void *)&v197)
                    {
                      uint64_t v98 = (v196.i64[1] - v196.i64[0]) >> 4;
                      unint64_t v99 = v98 + 1;
                      if ((unint64_t)(v98 + 1) >> 60) {
                        goto LABEL_222;
                      }
                      uint64_t v100 = *(void *)&v197 - v196.i64[0];
                      if ((*(void *)&v197 - v196.i64[0]) >> 3 > v99) {
                        unint64_t v99 = v100 >> 3;
                      }
                      if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF0) {
                        unint64_t v101 = 0xFFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v101 = v99;
                      }
                      *(void *)&v192.tCGFloat x = &v197;
                      unsigned int v102 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v101);
                      uint64_t v104 = (CGFloat *)&v102[16 * v98];
                      *uint64_t v104 = v81;
                      CGFloat v83 = v191.b;
                      v104[1] = v191.b;
                      if (v83 != 0.0) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v83 + 8), 1uLL, memory_order_relaxed);
                      }
                      uint64_t v105 = (void *)v196.i64[1];
                      unint64_t v106 = (void *)v196.i64[0];
                      if (v196.i64[1] == v196.i64[0])
                      {
                        int64x2_t v109 = vdupq_n_s64(v196.u64[1]);
                        uint64_t v107 = v104;
                      }
                      else
                      {
                        uint64_t v107 = v104;
                        do
                        {
                          long long v108 = *((_OWORD *)v105 - 1);
                          v105 -= 2;
                          *((_OWORD *)v107 - 1) = v108;
                          v107 -= 2;
                          *uint64_t v105 = 0;
                          v105[1] = 0;
                        }
                        while (v105 != v106);
                        int64x2_t v109 = v196;
                      }
                      uint64_t v84 = v104 + 2;
                      v196.i64[0] = (uint64_t)v107;
                      v196.i64[1] = (uint64_t)(v104 + 2);
                      *(int64x2_t *)&v192.CGFloat b = v109;
                      CGFloat v110 = v197;
                      *(void *)&double v197 = &v102[16 * v103];
                      v192.CGFloat d = v110;
                      *(void *)&v192.CGFloat a = v109.i64[0];
                      std::__split_buffer<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::~__split_buffer((uint64_t)&v192);
                    }
                    else
                    {
                      *(CGFloat *)v196.i64[1] = v191.a;
                      CGFloat v83 = v191.b;
                      *(CGFloat *)(v82 + 8) = v191.b;
                      if (v83 != 0.0) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v83 + 8), 1uLL, memory_order_relaxed);
                      }
                      uint64_t v84 = (CGFloat *)(v82 + 16);
                    }
                    v196.i64[1] = (uint64_t)v84;
                  }
                  else
                  {
                    CGFloat v83 = v191.b;
                  }
                  if (v83 != 0.0) {
                    std::__shared_weak_count::__release_shared[abi:nn180100](*(std::__shared_weak_count **)&v83);
                  }
                }
              }
              *(void *)&v195[1] = 0xAAAAAAAAAAAAAAAALL;
              *(_OWORD *)&v192.tCGFloat x = v174;
              long long v193 = v173;
              long long v194 = v172;
              v195[0] = v171[1];
              *(_OWORD *)&v192.CGFloat a = v171[0];
              *(_OWORD *)&v192.CGFloat c = *(_OWORD *)&byte_1BF1DB058[16];
              if (v78[26] != 2) {
                goto LABEL_221;
              }
              SVG::clipPaths(SVG::ClipPathElement const&,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,CGRect,CGRect,std::unordered_set<SVG::ClipPathElement const*> &)::$_1::operator()((uint64_t)&v192, (uint64_t)v183, (uint64_t)(v78 + 22));
              if (LOBYTE(v195[1]))
              {
                uint64_t v111 = operator new(0x78uLL);
                v111[1] = 0;
                v111[2] = 0;
                *uint64_t v111 = &unk_1F1A74DF0;
                uint64_t v112 = v111 + 3;
                std::construct_at[abi:nn180100]<SVG::ClipToPaths::ParentClipNode,SVG::ClipToPaths::ParentClipNode&,SVG::ClipToPaths::ParentClipNode*>((uint64_t)(v111 + 3), (uint64_t)&v192);
              }
              else
              {
                uint64_t v111 = 0;
                uint64_t v112 = 0;
              }
              std::__optional_destruct_base<SVG::ClipToPaths::ParentClipNode,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v192);
              long long v166 = *((_OWORD *)v76 + 41);
              long long v168 = *((_OWORD *)v76 + 40);
              CGFloat v113 = v76[84];
              CGFloat v114 = v76[85];
              *(_OWORD *)&v192.CGFloat a = *((_OWORD *)v76 + 43);
              double v115 = SVG::Length::computeValue((SVG::Length *)&v192, v185);
              *(_OWORD *)&v192.CGFloat a = *((_OWORD *)v76 + 44);
              double v116 = SVG::Length::computeValue((SVG::Length *)&v192, v186);
              *(_OWORD *)&v191.CGFloat a = v168;
              *(_OWORD *)&v191.CGFloat c = v166;
              v191.tCGFloat x = v113;
              v191.tCGFloat y = v114;
              CGAffineTransformTranslate(&v192, &v191, v115, v116);
              int64x2_t v167 = *(int64x2_t *)&v192.c;
              int64x2_t v169 = *(int64x2_t *)&v192.a;
              tCGFloat x = v192.tx;
              tCGFloat y = v192.ty;
              char v119 = (int64x2_t *)operator new(0x78uLL);
              unsigned int v120 = (uint64_t *)v119;
              v119->i64[1] = 0;
              v119[1].i64[0] = 0;
              v119->i64[0] = (uint64_t)&unk_1F1A74DF0;
              uint64_t v121 = &v119[1].i8[8];
              v119[2].i64[0] = (uint64_t)v112;
              v119[2].i64[1] = (uint64_t)v111;
              v119[3] = v169;
              v119[4] = v167;
              *(CGFloat *)v119[5].uint64_t i64 = tx;
              *(CGFloat *)&v119[5].i64[1] = ty;
              v119[1].i64[1] = (uint64_t)&unk_1F1A74438;
              v119[6] = v196;
              *(double *)v119[7].uint64_t i64 = v197;
              int64x2_t v196 = 0uLL;
              double v197 = 0.0;
              uint64_t v122 = v180.i64[1];
              if (v180.i64[1] >= *(void *)&v181)
              {
                uint64_t v124 = (v180.i64[1] - v180.i64[0]) >> 4;
                unint64_t v125 = v124 + 1;
                if ((unint64_t)(v124 + 1) >> 60) {
                  goto LABEL_222;
                }
                uint64_t v126 = *(void *)&v181 - v180.i64[0];
                if ((*(void *)&v181 - v180.i64[0]) >> 3 > v125) {
                  unint64_t v125 = v126 >> 3;
                }
                if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v127 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v127 = v125;
                }
                *(void *)&v192.tCGFloat x = v177;
                CGAffineTransform v128 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v127);
                char v130 = &v128[16 * v124];
                *(void *)char v130 = v121;
                *((void *)v130 + 1) = v120;
                unint64_t v131 = (void *)v180.i64[1];
                char v132 = (void *)v180.i64[0];
                if (v180.i64[1] == v180.i64[0])
                {
                  int64x2_t v135 = vdupq_n_s64(v180.u64[1]);
                  unsigned int v133 = &v128[16 * v124];
                }
                else
                {
                  unsigned int v133 = &v128[16 * v124];
                  do
                  {
                    long long v134 = *((_OWORD *)v131 - 1);
                    v131 -= 2;
                    *((_OWORD *)v133 - 1) = v134;
                    v133 -= 16;
                    *unint64_t v131 = 0;
                    v131[1] = 0;
                  }
                  while (v131 != v132);
                  int64x2_t v135 = v180;
                }
                int v123 = v130 + 16;
                v180.i64[0] = (uint64_t)v133;
                v180.i64[1] = (uint64_t)(v130 + 16);
                *(int64x2_t *)&v192.CGFloat b = v135;
                CGFloat v136 = v181;
                *(void *)&double v181 = &v128[16 * v129];
                v192.CGFloat d = v136;
                *(void *)&v192.CGFloat a = v135.i64[0];
                std::__split_buffer<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::~__split_buffer((uint64_t)&v192);
              }
              else
              {
                *(void *)v180.i64[1] = v121;
                *(void *)(v122 + 8) = v119;
                int v123 = (void *)(v122 + 16);
              }
              v180.i64[1] = (uint64_t)v123;
              *(void *)&v192.CGFloat a = &v196;
              std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v192);
            }
          }
        }
      }
      ++v66;
    }
    while (v66 != v67);
    int v137 = (SVG **)v180.i64[0];
    long long v65 = v165;
    if (v180.i64[0] != v180.i64[1])
    {
      int v138 = 0;
      do
      {
        unsigned int v139 = *v137;
        v137 += 2;
        v138 += SVG::countChildren(v139, v70);
      }
      while (v137 != (SVG **)v180.i64[1]);
      if (v138) {
        goto LABEL_220;
      }
    }
  }
  CGPathRef v140 = CGPathCreateWithRect(*MEMORY[0x1E4F1DB28], 0);
  long long v141 = operator new(0x70uLL);
  char v142 = v141;
  v141[1] = 0;
  v141[2] = 0;
  *long long v141 = &unk_1F1A74DB8;
  unsigned int v143 = (char *)(v141 + 3);
  v141[4] = 0;
  v141[5] = 0;
  uint64_t v144 = MEMORY[0x1E4F1DAB8];
  long long v145 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *((_OWORD *)v141 + 3) = *MEMORY[0x1E4F1DAB8];
  *((_OWORD *)v141 + 4) = v145;
  *((_OWORD *)v141 + 5) = *(_OWORD *)(v144 + 32);
  v141[3] = &unk_1F1A74418;
  v141[12] = v140;
  *((unsigned char *)v141 + 104) = 1;
  uint64_t v146 = v180.i64[1];
  if (v180.i64[1] >= *(void *)&v181)
  {
    uint64_t v148 = (v180.i64[1] - v180.i64[0]) >> 4;
    unint64_t v149 = v148 + 1;
    if (!((unint64_t)(v148 + 1) >> 60))
    {
      uint64_t v150 = *(void *)&v181 - v180.i64[0];
      if ((*(void *)&v181 - v180.i64[0]) >> 3 > v149) {
        unint64_t v149 = v150 >> 3;
      }
      if ((unint64_t)v150 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v151 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v151 = v149;
      }
      *(void *)&v192.tCGFloat x = v177;
      unsigned int v152 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v151);
      long long v154 = &v152[16 * v148];
      *(void *)long long v154 = v143;
      *((void *)v154 + 1) = v142;
      long long v155 = (void *)v180.i64[1];
      long long v156 = (void *)v180.i64[0];
      if (v180.i64[1] == v180.i64[0])
      {
        int64x2_t v159 = vdupq_n_s64(v180.u64[1]);
        long long v157 = &v152[16 * v148];
      }
      else
      {
        long long v157 = &v152[16 * v148];
        do
        {
          long long v158 = *((_OWORD *)v155 - 1);
          v155 -= 2;
          *((_OWORD *)v157 - 1) = v158;
          v157 -= 16;
          *long long v155 = 0;
          v155[1] = 0;
        }
        while (v155 != v156);
        int64x2_t v159 = v180;
      }
      long long v147 = v154 + 16;
      v180.i64[0] = (uint64_t)v157;
      v180.i64[1] = (uint64_t)(v154 + 16);
      *(int64x2_t *)&v192.CGFloat b = v159;
      CGFloat v161 = v181;
      *(void *)&double v181 = &v152[16 * v153];
      v192.CGFloat d = v161;
      *(void *)&v192.CGFloat a = v159.i64[0];
      std::__split_buffer<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::~__split_buffer((uint64_t)&v192);
      goto LABEL_219;
    }
LABEL_222:
    abort();
  }
  *(void *)v180.i64[1] = v143;
  *(void *)(v146 + 8) = v141;
  long long v147 = (void *)(v146 + 16);
LABEL_219:
  v180.i64[1] = (uint64_t)v147;
LABEL_220:
  *(void *)&long long v162 = -1;
  *((void *)&v162 + 1) = -1;
  *(_OWORD *)&v192.CGFloat c = v162;
  *(_OWORD *)&v192.tCGFloat x = v162;
  *(_OWORD *)&v192.CGFloat a = v162;
  SVG::unitTransform((CGAffineTransform *)*(unsigned int *)(*(void *)&a1 + 688), (uint64_t)&t1, v187, v188, v189, v190);
  long long v163 = *(_OWORD *)(*(void *)&a1 + 656);
  *(_OWORD *)&t2.CGFloat a = *(_OWORD *)(*(void *)&a1 + 640);
  *(_OWORD *)&t2.CGFloat c = v163;
  *(_OWORD *)&t2.tCGFloat x = *(_OWORD *)(*(void *)&a1 + 672);
  CGAffineTransformConcat(&v192, &t1, &t2);
  long long v164 = *(_OWORD *)&v192.c;
  *(_OWORD *)(a5 + 24) = *(_OWORD *)&v192.a;
  *(void *)(a5 + 8) = v175;
  *(void *)(a5 + 16) = v65;
  *(_OWORD *)(a5 + 4CGContextBeginTransparencyLayer(c, 0) = v164;
  *(_OWORD *)(a5 + 56) = *(_OWORD *)&v192.tx;
  *(void *)a5 = &unk_1F1A74438;
  *(int64x2_t *)(a5 + 72) = v180;
  *(double *)(a5 + 88) = v181;
  int64x2_t v180 = 0uLL;
  double v181 = 0.0;
  *(void *)&v192.CGFloat a = &v180;
  double v54 = (void ***)&v192;
LABEL_81:
  std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__destroy_vector::operator()[abi:nn180100](v54);
  uint64_t v55 = std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::find<SVG::Element const*>(a4, *(unint64_t *)&a1);
  if (!v55) {
    return;
  }
  int8x8_t v56 = *(int8x8_t *)(a4 + 2);
  uint64_t v57 = *v55;
  unint64_t v58 = v55[1];
  uint8x8_t v59 = (uint8x8_t)vcnt_s8(v56);
  v59.i16[0] = vaddlv_u8(v59);
  if (v59.u32[0] > 1uLL)
  {
    if (v58 >= *(void *)&v56) {
      v58 %= *(void *)&v56;
    }
  }
  else
  {
    v58 &= *(void *)&v56 - 1;
  }
  long long v60 = *(uint64_t **)(*(void *)a4 + 8 * v58);
  do
  {
    long long v61 = v60;
    long long v60 = (uint64_t *)*v60;
  }
  while (v60 != v55);
  if (v61 == (uint64_t *)(a4 + 4)) {
    goto LABEL_102;
  }
  unint64_t v62 = v61[1];
  if (v59.u32[0] > 1uLL)
  {
    if (v62 >= *(void *)&v56) {
      v62 %= *(void *)&v56;
    }
  }
  else
  {
    v62 &= *(void *)&v56 - 1;
  }
  if (v62 != v58)
  {
LABEL_102:
    if (v57)
    {
      unint64_t v63 = *(void *)(v57 + 8);
      if (v59.u32[0] > 1uLL)
      {
        unint64_t v64 = *(void *)(v57 + 8);
        if (v63 >= *(void *)&v56) {
          unint64_t v64 = v63 % *(void *)&v56;
        }
      }
      else
      {
        unint64_t v64 = v63 & (*(void *)&v56 - 1);
      }
      if (v64 == v58) {
        goto LABEL_106;
      }
    }
    *(void *)(*(void *)a4 + 8 * v58) = 0;
    uint64_t v57 = *v55;
  }
  if (v57)
  {
    unint64_t v63 = *(void *)(v57 + 8);
LABEL_106:
    if (v59.u32[0] > 1uLL)
    {
      if (v63 >= *(void *)&v56) {
        v63 %= *(void *)&v56;
      }
    }
    else
    {
      v63 &= *(void *)&v56 - 1;
    }
    if (v63 != v58)
    {
      *(void *)(*(void *)a4 + 8 * v63) = v61;
      uint64_t v57 = *v55;
    }
  }
  uint64_t *v61 = v57;
  *uint64_t v55 = 0;
  --*((void *)a4 + 3);
  operator delete(v55);
}

void SVG::ClipPathElement::~ClipPathElement(SVG::ClipPathElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A759B8[v2])(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A759D0[v3])(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A759E8[v4])(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A759D0[v5])(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A759E8[v6])(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A759B8[v2])(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))off_1F1A759D0[v3])(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))off_1F1A759E8[v4])(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))off_1F1A759D0[v5])(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))off_1F1A759E8[v6])(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

void SVG::clipPaths(SVG::ClipPathElement const&,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,CGRect,CGRect,std::unordered_set<SVG::ClipPathElement const*> &)::$_1::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 8) {
    && (uint64_t v5 = *(void **)a2,
  }
        v11[0] = *(void *)a3,
  {
    char v8 = *(double **)(a2 + 16);
    SVG::clipPaths(v11, v7, *(void *)a2, *(void *)(a2 + 8), *(void *)(a2 + 32), *v8, v8[1], v8[2], v8[3], **(double **)(a2 + 24), *(double *)(*(void *)(a2 + 24) + 8), *(double *)(*(void *)(a2 + 24) + 16), *(double *)(*(void *)(a2 + 24) + 24));
    uint64_t v10 = v11[1];
    char v9 = v12;
    *(void *)a1 = &unk_1F1A743F8;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)(a1 + 24) = v13;
    *(_OWORD *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = v14;
    *(_OWORD *)(a1 + 56) = v15;
    *(void *)a1 = &unk_1F1A74438;
    *(_OWORD *)(a1 + 72) = v16;
    *(void *)(a1 + 88) = v17;
    long long v16 = 0uLL;
    uint64_t v17 = 0;
    *(unsigned char *)(a1 + 96) = 1;
    v11[0] = &unk_1F1A74438;
    uint64_t v18 = (void **)&v16;
    std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__destroy_vector::operator()[abi:nn180100](&v18);
    v11[0] = &unk_1F1A743F8;
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    }
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 96) = 0;
  }
}

BOOL SVG::countChildren(SVG *this, SVG::ClipToPaths::BaseClipNode *a2)
{
  if (!v3) {
  uint64_t v5 = (SVG **)*((void *)v3 + 9);
  }
  uint64_t v6 = (SVG **)*((void *)v3 + 10);
  if (v5 == v6) {
    return 0;
  }
  LODWORD(v7) = 0;
  do
  {
    char v8 = *v5;
    v5 += 2;
    uint64_t v7 = SVG::countChildren(v8, v4) + v7;
  }
  while (v5 != v6);
  return v7;
}

void SVG::ClipToPaths::ParentClipNode::~ParentClipNode(SVG::ClipToPaths::ParentClipNode *this)
{
  *(void *)this = &unk_1F1A74438;
  uint64_t v3 = (void **)((char *)this + 72);
  std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__destroy_vector::operator()[abi:nn180100](&v3);
  *(void *)this = &unk_1F1A743F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

{
  std::__shared_weak_count *v2;
  void **v3;

  *(void *)this = &unk_1F1A74438;
  uint64_t v3 = (void **)((char *)this + 72);
  std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__destroy_vector::operator()[abi:nn180100](&v3);
  *(void *)this = &unk_1F1A743F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  MEMORY[0x1C18A3E80](this, 0x10A1C4090873174);
}

void std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
  a1[1] = v2;
}

void std::__shared_ptr_emplace<SVG::ClipToPaths::ParentClipNode>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1A74DF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SVG::ClipToPaths::ParentClipNode>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1A74DF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C18A3E80);
}

uint64_t std::__shared_ptr_emplace<SVG::ClipToPaths::ParentClipNode>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::construct_at[abi:nn180100]<SVG::ClipToPaths::ParentClipNode,SVG::ClipToPaths::ParentClipNode&,SVG::ClipToPaths::ParentClipNode*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)a1 = &unk_1F1A743F8;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  long long v5 = *(_OWORD *)(a2 + 24);
  long long v6 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = v6;
  *(_OWORD *)(a1 + 24) = v5;
  *(void *)a1 = &unk_1F1A74438;
  *(void *)(a1 + 8CGContextBeginTransparencyLayer(c, 0) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  uint64_t v7 = *(char **)(a2 + 72);
  char v8 = *(char **)(a2 + 80);
  uint64_t v9 = v8 - v7;
  if (v8 != v7)
  {
    if (v9 < 0) {
      abort();
    }
    uint64_t v10 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::variant<std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>>>>(v9 >> 4);
    uint64_t v11 = 0;
    *(void *)(a1 + 72) = v10;
    *(void *)(a1 + 8CGContextBeginTransparencyLayer(c, 0) = v10;
    *(void *)(a1 + 88) = &v10[2 * v12];
    long long v13 = v10;
    do
    {
      uint64_t v14 = *((void *)v7 + 1);
      *long long v13 = *(void *)v7;
      v13[1] = v14;
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
      }
      v11 += 2;
      v7 += 16;
      v13 += 2;
    }
    while (v7 != v8);
    *(void *)(a1 + 8CGContextBeginTransparencyLayer(c, 0) = &v10[v11];
  }
  return a1;
}

uint64_t std::__optional_destruct_base<SVG::ClipToPaths::ParentClipNode,false>::~__optional_destruct_base[abi:nn180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96))
  {
    *(void *)a1 = &unk_1F1A74438;
    uint64_t v4 = (void **)(a1 + 72);
    std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__destroy_vector::operator()[abi:nn180100](&v4);
    *(void *)a1 = &unk_1F1A743F8;
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v2);
    }
  }
  return a1;
}

_DWORD *SVG::clipPaths(SVG::ClipPathElement const&,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,CGRect,CGRect,std::unordered_set<SVG::ClipPathElement const*> &)::$_2::operator()(void *a1, uint64_t a2, uint64_t a3)
{
  long long v6 = *(void **)a2;
  v18[0] = a3;
  __n128 result = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(v6, v18);
  if (result[149] != 2) {
    goto LABEL_16;
  }
  char v8 = result;
  if (result[148])
  {
LABEL_5:
    *a1 = 0;
    a1[1] = 0;
    return result;
  }
  if (result[40] != 2) {
    goto LABEL_16;
  }
  if (result[39] == 2) {
    goto LABEL_5;
  }
  CGPathRef v19 = (CGPathRef)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(CGPathRef *__return_ptr, uint64_t, double, double, double, double))(*(void *)a3 + 32))(&v19, a3, **(double **)(a2 + 8), *(double *)(*(void *)(a2 + 8) + 8), *(double *)(*(void *)(a2 + 8) + 16), *(double *)(*(void *)(a2 + 8) + 24));
  if (!v19)
  {
    CGPathRef v9 = CGPathCreateWithRect(*MEMORY[0x1E4F1DB28], 0);
    if (v19) {
      CFRelease(v19);
    }
    CGPathRef v19 = v9;
  }
  if (v8[29] == 2
    && (BOOL v10 = v8[28] == 1,
        memset(&v18[4], 255, 32),
        *(_OWORD *)&v18[8] = xmmword_1BF1DB098,
        memset(&v18[10], 170, 24),
        *(_OWORD *)uint64_t v18 = xmmword_1BF1DB058,
        *(_OWORD *)&v18[2] = unk_1BF1DB068,
        v8[26] == 2))
  {
    SVG::clipPaths(SVG::ClipPathElement const&,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,CGRect,CGRect,std::unordered_set<SVG::ClipPathElement const*> &)::$_1::operator()((uint64_t)v18, *(void *)(a2 + 16), (uint64_t)(v8 + 22));
    if (LOBYTE(v18[12]))
    {
      uint64_t v11 = operator new(0x78uLL);
      v11[1] = 0;
      void v11[2] = 0;
      *uint64_t v11 = &unk_1F1A74DF0;
      uint64_t v12 = v11 + 3;
      std::construct_at[abi:nn180100]<SVG::ClipToPaths::ParentClipNode,SVG::ClipToPaths::ParentClipNode&,SVG::ClipToPaths::ParentClipNode*>((uint64_t)(v11 + 3), (uint64_t)v18);
    }
    else
    {
      uint64_t v12 = 0;
      uint64_t v11 = 0;
    }
    std::__optional_destruct_base<SVG::ClipToPaths::ParentClipNode,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v18);
    long long v16 = *(_OWORD *)(a3 + 656);
    long long v17 = *(_OWORD *)(a3 + 640);
    uint64_t v13 = *(void *)(a3 + 672);
    uint64_t v14 = *(void *)(a3 + 680);
    __n128 result = operator new(0x70uLL);
    *((void *)result + 1) = 0;
    *((void *)result + 2) = 0;
    *(void *)__n128 result = &unk_1F1A74DB8;
    *((void *)result + 4) = v12;
    *((void *)result + 5) = v11;
    *((_OWORD *)result + 3) = v17;
    *((_OWORD *)result + 4) = v16;
    *((void *)result + 1CGContextBeginTransparencyLayer(c, 0) = v13;
    *((void *)result + 11) = v14;
    *((void *)result + 3) = &unk_1F1A74418;
    *((void *)result + 12) = v19;
    *((unsigned char *)result + 104) = v10;
    *a1 = result + 6;
    a1[1] = result;
  }
  else
  {
LABEL_16:
    uint64_t v15 = std::__throw_bad_variant_access[abi:nn180100]();
    return (_DWORD *)std::__shared_ptr_emplace<SVG::ClipToPaths::LeafClipNode>::~__shared_ptr_emplace(v15);
  }
  return result;
}

void std::__shared_ptr_emplace<SVG::ClipToPaths::LeafClipNode>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1A74DB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SVG::ClipToPaths::LeafClipNode>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1A74DB8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C18A3E80);
}

uint64_t std::__shared_ptr_emplace<SVG::ClipToPaths::LeafClipNode>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::__split_buffer<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v2 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 16;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void SVG::ApplyPresentationFill::ApplyPresentationFill(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, long long a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  *(double *)long long v60 = a10;
  *(double *)&v60[1] = a11;
  *(double *)&v60[2] = a12;
  *(double *)&v60[3] = a13;
  long long v57 = a14;
  uint64_t v58 = a15;
  uint64_t v59 = a16;
  uint64_t v56 = a8;
  *(void *)a1 = a2;
  unint64_t v25 = a2[5] + a2[4] - 1;
  uint64_t v26 = *(void *)(a2[1] + ((v25 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v25 & 0x1F) << 7) + 8;
  *(unsigned char *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 112) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1> const&>(a1 + 8, v26);
  *(_DWORD *)(a1 + 144) = 0;
  *(void *)(a1 + 12CGContextBeginTransparencyLayer(c, 0) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  unint64_t v27 = a2[5] + a2[4] - 1;
  *(unsigned char *)(a1 + 129) = *(unsigned char *)(*(void *)(a2[1] + ((v27 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v27 & 0x1F) << 7) + 120);
  *(void *)(a1 + 136) = a17;
  *(_DWORD *)(a1 + 224) = 0;
  float v28 = *(double *)a17;
  if (!*(unsigned char *)(a17 + 8)) {
    float v28 = 1.0;
  }
  float v55 = v28;
  int v29 = *(_DWORD *)(a6 + 40);
  if ((v29 - 1) > 1)
  {
    if (a9 < 1.0)
    {
      *(unsigned char *)(a1 + 128) = 1;
      v34[0] = &unk_1F1A74C40;
      *(double *)&v34[1] = a9;
      unint64_t v40 = &unk_1F1A74C40;
      double v41 = a9;
      int v54 = 12;
      SVG::Recorder::append((uint64_t)a2, (uint64_t)&v40);
      if (v54 != -1) {
        ((void (*)(void *, void **))off_1F1A75A18[v54])(v37, &v40);
      }
      v34[0] = &unk_1F1A749E8;
      unint64_t v40 = &unk_1F1A749E8;
      int v54 = 10;
      SVG::Recorder::append((uint64_t)a2, (uint64_t)&v40);
      if (v54 != -1) {
        ((void (*)(void *, void **))off_1F1A75A18[v54])(v37, &v40);
      }
      int v29 = *(_DWORD *)(a6 + 40);
    }
  }
  else
  {
    float v30 = v28 * a9;
    float v55 = v30;
  }
  char v39 = -86;
  char v38 = -86;
  v37[0] = a2;
  v37[1] = &v55;
  BOOL v36 = a2;
  uint64_t v42 = a3;
  uint8x8_t v43 = v60;
  uint64_t v44 = a4;
  unint64_t v45 = &v56;
  unint64_t v46 = &v57;
  uint64_t v47 = a5;
  long long v48 = a2;
  uint64_t v49 = &v39;
  unint64_t v50 = &v38;
  double v51 = v37;
  unint64_t v40 = a2;
  double v41 = COERCE_DOUBLE(&v55);
  uint64_t v52 = &v36;
  long long v53 = a2;
  if (v29 != -1)
  {
    v61[0] = &v40;
    ((void (*)(void *__return_ptr, void *, uint64_t))off_1F1A75A88[v29])(v34, v61, a6 + 8);
    uint64_t v31 = *(unsigned int *)(a1 + 224);
    if (v31 == -1)
    {
      if (v35 == -1)
      {
LABEL_19:
        unint64_t v32 = a2[5] + a2[4] - 1;
        *(unsigned char *)(*(void *)(a2[1] + ((v32 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v32 & 0x1F) << 7) + 12CGContextBeginTransparencyLayer(c, 0) = a7;
        return;
      }
    }
    else if (v35 == -1)
    {
      ((void (*)(void *, uint64_t))*(&off_1F1A75AF0 + v31))(v61, a1 + 144);
      *(_DWORD *)(a1 + 224) = -1;
      goto LABEL_17;
    }
    v61[0] = a1 + 144;
    ((void (*)(void *, uint64_t, void *))*(&off_1F1A75B08 + v35))(v61, a1 + 144, v34);
LABEL_17:
    if (v35 != -1) {
      ((void (*)(void *, void *))*(&off_1F1A75AF0 + v35))(v61, v34);
    }
    goto LABEL_19;
  }
  unint64_t v33 = (SVG::ApplyPresentationFill *)std::__throw_bad_variant_access[abi:nn180100]();
  SVG::ApplyPresentationFill::~ApplyPresentationFill(v33);
}

void SVG::ApplyPresentationFill::~ApplyPresentationFill(SVG::ApplyPresentationFill *this)
{
  uint64_t v2 = *(void *)this;
  unint64_t v3 = *(void *)(*(void *)this + 40) + *(void *)(*(void *)this + 32) - 1;
  *(unsigned char *)(*(void *)(*(void *)(*(void *)this + 8) + ((v3 >> 2) & 0x3FFFFFFFFFFFFFF8))
           + ((v3 & 0x1F) << 7)
           + 12CGContextBeginTransparencyLayer(c, 0) = *((unsigned char *)this + 129);
  uint64_t v4 = (char *)this + 8;
  LOBYTE(v10[0]) = 0;
  int v11 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1> const&>((uint64_t)v10, (uint64_t)this + 8);
  uint64_t v12 = &unk_1F1A74B80;
  LOBYTE(v13[0]) = 0;
  int v14 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1>>((uint64_t)v13, (uint64_t)v10);
  int v15 = 9;
  SVG::Recorder::append(v2, (uint64_t)&v12);
  if (v15 != -1) {
    ((void (*)(char *, void **))off_1F1A75A18[v15])(&v16, &v12);
  }
  int v15 = -1;
  if (v11 != -1) {
    ((void (*)(char *, void *))off_1F1A75A00[v11])(&v16, v10);
  }
  if (*((unsigned char *)this + 128))
  {
    uint64_t v5 = *(void *)this;
    uint64_t v12 = &unk_1F1A74920;
    int v15 = 11;
    SVG::Recorder::append(v5, (uint64_t)&v12);
    if (v15 != -1) {
      ((void (*)(char *, void **))off_1F1A75A18[v15])(&v16, &v12);
    }
    uint64_t v6 = *(void *)this;
    v10[0] = 0x3FF0000000000000;
    uint64_t v12 = &unk_1F1A74C40;
    v13[0] = 0x3FF0000000000000;
    int v15 = 12;
    SVG::Recorder::append(v6, (uint64_t)&v12);
    if (v15 != -1) {
      ((void (*)(char *, void **))off_1F1A75A18[v15])(&v16, &v12);
    }
  }
  uint64_t v7 = *((unsigned int *)this + 56);
  if (v7 != -1) {
    ((void (*)(void **, char *))*(&off_1F1A75AF0 + v7))(&v12, (char *)this + 144);
  }
  *((_DWORD *)this + 56) = -1;
  char v8 = (const void *)*((void *)this + 15);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = *((unsigned int *)this + 28);
  if (v9 != -1) {
    ((void (*)(void **, char *))off_1F1A75A00[v9])(&v12, v4);
  }
  *((_DWORD *)this + 28) = -1;
}

void SVG::ApplyPresentation::ApplyPresentation(uint64_t a1, void *a2, uint64_t a3, void *lpsrc, void *a5, void *a6, void *a7, uint64_t a8, double a9, double a10, double a11, double a12)
{
  *(void *)(a1 + 8) = a2;
  uint64_t v12 = (SVG::StateSaverRestorer *)(a1 + 8);
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 26) = 0;
  if (*(_DWORD *)(a3 + 136) != 2) {
    goto LABEL_91;
  }
  int v15 = *(_DWORD *)(a3 + 132);
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = 0;
  *(unsigned char *)(a1 + 27) = v15 == 2;
  if (v15 == 2) {
    return;
  }
  if (v26)
  {
    long long v27 = v26[41];
    *(_OWORD *)&v93[8] = v26[40];
    *(_OWORD *)&v93[24] = v27;
    *(_OWORD *)&v93[40] = v26[42];
    *(void *)long long v93 = &unk_1F1A74C88;
    *(void *)int64x2_t v96 = &unk_1F1A74C88;
    *(_OWORD *)&v96[8] = *(_OWORD *)&v93[8];
    *(_OWORD *)&v96[24] = v27;
    long long v97 = *(_OWORD *)&v93[40];
    int v101 = 2;
    SVG::Recorder::append((uint64_t)a2, (uint64_t)v96);
    if (v101 != -1) {
      ((void (*)(void *, unsigned char *))off_1F1A75A18[v101])(v94, v96);
    }
  }
  if (*(_DWORD *)(a3 + 48) != 2) {
    goto LABEL_91;
  }
  if (*(unsigned char *)(a3 + 40))
  {
    if (v28)
    {
      int v29 = v28;
      if (!*(unsigned char *)(a1 + 16))
      {
        SVG::StateSaverRestorer::save(v12);
        if (*(_DWORD *)(a3 + 48) != 2) {
          goto LABEL_91;
        }
      }
      double v30 = *(double *)(a3 + 32);
      v103.origin.CGFloat x = v29[84] + v30;
      double v31 = *(double *)(a3 + 8);
      v103.origin.CGFloat y = v29[85] + v31;
      v103.size.double width = v29[86] - v30 - *(double *)(a3 + 16);
      v103.size.double height = v29[87] - v31 - *(double *)(a3 + 24);
      CGPathRef v32 = CGPathCreateWithRect(v103, 0);
      unint64_t v33 = operator new(0x70uLL);
      v33[1] = 0;
      v33[2] = 0;
      *unint64_t v33 = &unk_1F1A74DB8;
      v33[4] = 0;
      v33[5] = 0;
      uint64_t v34 = MEMORY[0x1E4F1DAB8];
      long long v35 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      *((_OWORD *)v33 + 3) = *MEMORY[0x1E4F1DAB8];
      *((_OWORD *)v33 + 4) = v35;
      *((_OWORD *)v33 + 5) = *(_OWORD *)(v34 + 32);
      v33[3] = &unk_1F1A74418;
      v33[12] = v32;
      *((unsigned char *)v33 + 104) = 1;
      *(void *)long long v93 = &unk_1F1A74458;
      *(void *)&v93[8] = 0;
      *(void *)int64x2_t v96 = &unk_1F1A74458;
      *(void *)&v96[8] = v33 + 3;
      *(void *)&v96[16] = v33;
      *(void *)&v93[16] = 0;
      int v101 = 7;
      SVG::Recorder::append((uint64_t)a2, (uint64_t)v96);
      if (v101 != -1) {
        ((void (*)(void *, unsigned char *))off_1F1A75A18[v101])(v94, v96);
      }
      int v101 = -1;
      *(void *)long long v93 = &unk_1F1A74458;
    }
  }
  if (*(_DWORD *)(a3 + 80) != 2) {
    goto LABEL_91;
  }
  if (*(unsigned char *)(a3 + 72))
  {
    *(void *)int64x2_t v96 = *(void *)(a3 + 64);
    BOOL v36 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(a5, v96);
    if (v36)
    {
      if (v37 != 0.0)
      {
        CGFloat v38 = v37;
        if (v39)
        {
          (*(void (**)(void *, double, double, double, double))(*(void *)v39 + 40))(v39, a9, a10, a11, a12);
        }
        else
        {
          CGFloat v42 = 1.0;
          CGFloat v40 = 0.0;
          CGFloat v41 = 0.0;
          CGFloat v43 = 1.0;
        }
        memset(&v93[32], 255, 32);
        *(_OWORD *)&v93[64] = xmmword_1BF1DB158;
        *(_OWORD *)&v93[80] = unk_1BF1DB168;
        *(_OWORD *)long long v93 = xmmword_1BF1DB118;
        *(_OWORD *)&v93[16] = unk_1BF1DB128;
        memset(v96, 0, 32);
        *(void *)&v96[32] = 0xAAAAAAAA3F800000;
        SVG::clipPaths(v38, a5, a7, (float *)v96, (uint64_t)v93, v40, v41, v42, v43, a9, a10, a11, a12);
        std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)v96);
        uint64_t v44 = operator new(0x78uLL);
        v44[1] = 0;
        v44[2] = 0;
        *uint64_t v44 = &unk_1F1A74DF0;
        uint64_t v46 = *(void *)&v93[8];
        uint64_t v45 = *(void *)&v93[16];
        v44[3] = &unk_1F1A743F8;
        v44[4] = v46;
        v44[5] = v45;
        if (v45) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v45 + 8), 1uLL, memory_order_relaxed);
        }
        long long v47 = *(_OWORD *)&v93[40];
        *((_OWORD *)v44 + 3) = *(_OWORD *)&v93[24];
        *((_OWORD *)v44 + 4) = v47;
        long long v48 = *(_OWORD *)&v93[56];
        v44[3] = &unk_1F1A74438;
        long long v49 = *(_OWORD *)&v93[72];
        *((_OWORD *)v44 + 5) = v48;
        *((_OWORD *)v44 + 6) = v49;
        v44[14] = *(void *)&v93[88];
        memset(&v93[72], 0, 24);
        v94[0] = &unk_1F1A74458;
        v94[1] = 0;
        *(void *)int64x2_t v96 = &unk_1F1A74458;
        *(void *)&v96[8] = v44 + 3;
        *(void *)&v96[16] = v44;
        long long v95 = 0;
        int v101 = 7;
        SVG::Recorder::append((uint64_t)a2, (uint64_t)v96);
        if (v101 != -1) {
          ((void (*)(char *, unsigned char *))off_1F1A75A18[v101])(v102, v96);
        }
        int v101 = -1;
        v94[0] = &unk_1F1A74458;
        if (v95) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v95);
        }
        *(void *)long long v93 = &unk_1F1A74438;
        *(void *)int64x2_t v96 = &v93[72];
        std::vector<std::shared_ptr<SVG::ClipToPaths::BaseClipNode>>::__destroy_vector::operator()[abi:nn180100]((void ***)v96);
        *(void *)long long v93 = &unk_1F1A743F8;
        if (*(void *)&v93[16]) {
          std::__shared_weak_count::__release_shared[abi:nn180100](*(std::__shared_weak_count **)&v93[16]);
        }
      }
    }
  }
  if (*(_DWORD *)(a3 + 264) != 2) {
    goto LABEL_91;
  }
  if (*(unsigned char *)(a3 + 256))
  {
    *(void *)int64x2_t v96 = *(void *)(a3 + 248);
    unint64_t v50 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(a5, v96);
    if (v50)
    {
      if (v51)
      {
        int8x8_t v52 = (int8x8_t)a6[1];
        if (v52)
        {
          long long v53 = (unsigned int *)v51;
          unint64_t v54 = 0x9DDFEA08EB382D69 * (((8 * v51) + 8) ^ HIDWORD(v51));
          unint64_t v55 = 0x9DDFEA08EB382D69 * (HIDWORD(v51) ^ (v54 >> 47) ^ v54);
          unint64_t v56 = 0x9DDFEA08EB382D69 * (v55 ^ (v55 >> 47));
          uint8x8_t v57 = (uint8x8_t)vcnt_s8(v52);
          v57.i16[0] = vaddlv_u8(v57);
          if (v57.u32[0] > 1uLL)
          {
            unint64_t v58 = v56;
            if (v56 >= *(void *)&v52) {
              unint64_t v58 = v56 % *(void *)&v52;
            }
          }
          else
          {
            unint64_t v58 = (*(void *)&v52 - 1) & v56;
          }
          uint64_t v59 = *(void **)(*a6 + 8 * v58);
          if (v59)
          {
            long long v60 = (void *)*v59;
            if (*v59)
            {
              do
              {
                unint64_t v61 = v60[1];
                if (v56 == v61)
                {
                  if (v60[2] == v51)
                  {
                    if (v62)
                    {
                      double v63 = (*(double (**)(void *, double, double, double, double))(*(void *)v62 + 40))(v62, a9, a10, a11, a12);
                      CGFloat v65 = v64;
                      double v67 = v66;
                      double v69 = v68;
                    }
                    else
                    {
                      double v67 = 1.0;
                      double v63 = 0.0;
                      CGFloat v65 = 0.0;
                      double v69 = 1.0;
                    }
                    if (!*(unsigned char *)(a1 + 16)) {
                      SVG::StateSaverRestorer::save(v12);
                    }
                    SVG::unitTransform((CGAffineTransform *)v53[178], (uint64_t)&v90, v63, v65, v67, v69);
                    v104.origin.CGFloat x = v63;
                    v104.origin.CGFloat y = v65;
                    v104.size.double width = v67;
                    v104.size.double height = v69;
                    SVG::LengthRect::computeRect((SVG::LengthRect *)(v53 + 160), v104);
                    unint64_t v74 = v60[3];
                    uint64_t v75 = v60[4];
                    *(void *)long long v93 = &unk_1F1A74280;
                    *(void *)&v93[8] = v74;
                    *(void *)&v93[16] = v75;
                    if (v75)
                    {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v75 + 8), 1uLL, memory_order_relaxed);
                      long long v76 = *(_OWORD *)&v93[8];
                    }
                    else
                    {
                      long long v76 = v74;
                    }
                    *(_OWORD *)&v93[24] = v90;
                    *(_OWORD *)&v93[40] = v91;
                    *(_OWORD *)&v93[56] = v92;
                    *(void *)&v93[72] = v70;
                    *(void *)&v93[80] = v71;
                    *(void *)&v93[88] = v72;
                    *(void *)&v93[96] = v73;
                    *(void *)int64x2_t v96 = &unk_1F1A74280;
                    *(_OWORD *)&v96[8] = v76;
                    *(void *)&v93[8] = 0;
                    *(void *)&v93[16] = 0;
                    *(_OWORD *)&v96[24] = v90;
                    long long v100 = *(_OWORD *)&v93[88];
                    long long v99 = *(_OWORD *)&v93[72];
                    long long v98 = v92;
                    long long v97 = v91;
                    int v101 = 8;
                    SVG::Recorder::append((uint64_t)a2, (uint64_t)v96);
                    if (v101 != -1) {
                      ((void (*)(void *, unsigned char *))off_1F1A75A18[v101])(v94, v96);
                    }
                    int v101 = -1;
                    *(void *)long long v93 = &unk_1F1A74280;
                    if (*(void *)&v93[16]) {
                      std::__shared_weak_count::__release_shared[abi:nn180100](*(std::__shared_weak_count **)&v93[16]);
                    }
                    break;
                  }
                }
                else
                {
                  if (v57.u32[0] > 1uLL)
                  {
                    if (v61 >= *(void *)&v52) {
                      v61 %= *(void *)&v52;
                    }
                  }
                  else
                  {
                    v61 &= *(void *)&v52 - 1;
                  }
                  if (v61 != v58) {
                    break;
                  }
                }
                long long v60 = (void *)*v60;
              }
              while (v60);
            }
          }
        }
      }
    }
  }
  unint64_t v77 = a2[5] + a2[4] - 1;
  unint64_t v78 = (BOOL *)(*(void *)(a2[1] + ((v77 >> 2) & 0x3FFFFFFFFFFFFFF8)) + ((v77 & 0x1F) << 7));
  *(unsigned char *)(a1 + 25) = *v78;
  if (*(_DWORD *)(a3 + 92) != 2) {
    goto LABEL_91;
  }
  *unint64_t v78 = *(_DWORD *)(a3 + 88) == 1;
  BOOL v80 = v78[120];
  char v79 = v78 + 120;
  *(unsigned char *)(a1 + 26) = v80;
  if (*(_DWORD *)(a3 + 228) != 2) {
    goto LABEL_91;
  }
  BOOL *v79 = *(_DWORD *)(a3 + 224) == 1;
  if (*((void *)lpsrc + 4) == *((void *)lpsrc + 5)
  {
    if (*(_DWORD *)(a3 + 200) != 2 || *(_DWORD *)(a3 + 400) != 2) {
      goto LABEL_91;
    }
    int v81 = *(_DWORD *)(a3 + 192);
    unsigned int v82 = v81 - 1;
    int v83 = *(_DWORD *)(a3 + 392);
    BOOL v84 = v81 || (v83 - 1) >= 2;
    BOOL v85 = !v84;
    BOOL v86 = v83 || v82 >= 2;
    if (!v86 || v85)
    {
      if (*(_DWORD *)(a3 + 280) == 2)
      {
        *(void *)(a1 + 32) = *(void *)(a3 + 272);
        *(unsigned char *)(a1 + 4CGContextBeginTransparencyLayer(c, 0) = 1;
        goto LABEL_86;
      }
LABEL_91:
      std::__throw_bad_variant_access[abi:nn180100]();
      goto LABEL_92;
    }
  }
  if (*(_DWORD *)(a3 + 280) != 2) {
    goto LABEL_91;
  }
  double v87 = *(double *)(a3 + 272);
  if (v87 < 1.0)
  {
    *(unsigned char *)(a1 + 24) = 1;
    *(void *)long long v93 = &unk_1F1A74C40;
    *(double *)&v93[8] = v87;
    *(void *)int64x2_t v96 = &unk_1F1A74C40;
    *(double *)&v96[8] = v87;
    int v101 = 12;
    SVG::Recorder::append((uint64_t)a2, (uint64_t)v96);
    if (v101 != -1) {
      ((void (*)(void *, unsigned char *))off_1F1A75A18[v101])(v94, v96);
    }
    *(void *)long long v93 = &unk_1F1A749E8;
    *(void *)int64x2_t v96 = &unk_1F1A749E8;
    int v101 = 10;
    SVG::Recorder::append((uint64_t)a2, (uint64_t)v96);
    if (v101 != -1) {
      ((void (*)(void *, unsigned char *))off_1F1A75A18[v101])(v94, v96);
    }
  }
LABEL_86:
  *(_OWORD *)int64x2_t v96 = *(_OWORD *)(a1 + 32);
  uint64_t v88 = *(void *)(a8 + 24);
  if (!v88)
  {
LABEL_92:
    unint64_t v89 = (SVG::ApplyPresentation *)std::__throw_bad_function_call[abi:nn180100]();
    SVG::ApplyPresentation::~ApplyPresentation(v89);
    return;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v88 + 48))(v88, v96);
}

void SVG::ApplyPresentation::~ApplyPresentation(SVG::ApplyPresentation *this)
{
  if (!*((unsigned char *)this + 27))
  {
    if (*((unsigned char *)this + 24))
    {
      uint64_t v2 = *(void *)this;
      v6[0] = &unk_1F1A74920;
      int v7 = 11;
      SVG::Recorder::append(v2, (uint64_t)v6);
      if (v7 != -1) {
        ((void (*)(char *, void *))off_1F1A75A18[v7])(&v8, v6);
      }
      uint64_t v3 = *(void *)this;
      v6[0] = &unk_1F1A74C40;
      v6[1] = 0x3FF0000000000000;
      int v7 = 12;
      SVG::Recorder::append(v3, (uint64_t)v6);
      if (v7 != -1) {
        ((void (*)(char *, void *))off_1F1A75A18[v7])(&v8, v6);
      }
    }
    unint64_t v4 = *(void *)(*(void *)this + 40) + *(void *)(*(void *)this + 32) - 1;
    uint64_t v5 = (unsigned char *)(*(void *)(*(void *)(*(void *)this + 8) + ((v4 >> 2) & 0x3FFFFFFFFFFFFFF8))
                 + ((v4 & 0x1F) << 7));
    v5[120] = *((unsigned char *)this + 26);
    *uint64_t v5 = *((unsigned char *)this + 25);
  }
  SVG::StateSaverRestorer::~StateSaverRestorer((SVG::ApplyPresentation *)((char *)this + 8));
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_0,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_1,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_4,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_3>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext> const&>(_DWORD *a1@<X8>)
{
  *a1 = 0;
  a1[20] = 0;
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_0,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_1,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_4,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_3>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext> const&>(_DWORD *a1@<X8>)
{
  *a1 = 0;
  a1[20] = 0;
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_0,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_1,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_4,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_3>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext> const&>(float ***a1@<X0>, uint64_t *a2@<X1>, _DWORD *a3@<X8>)
{
}

void std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_0,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_1,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_4,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_3>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext> const&>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v241 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a1;
  uint64_t v6 = *(void **)(*a1 + 16);
  *(void *)CGAffineTransform t2 = *(void *)a2;
  int v7 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(v6, t2);
  if (!v7) {
    goto LABEL_108;
  }
  char v8 = (const void *)v7[3];
  if (!v9)
  {
    if (v19)
    {
      unint64_t v20 = *(void **)(v5 + 56);
      int8x8_t v21 = (int8x8_t)v20[1];
      if (v21)
      {
        unint64_t v22 = v19;
        unint64_t v23 = 0x9DDFEA08EB382D69 * (((8 * v19) + 8) ^ HIDWORD(v19));
        unint64_t v24 = 0x9DDFEA08EB382D69 * (HIDWORD(v19) ^ (v23 >> 47) ^ v23);
        unint64_t v25 = 0x9DDFEA08EB382D69 * (v24 ^ (v24 >> 47));
        uint8x8_t v26 = (uint8x8_t)vcnt_s8(v21);
        v26.i16[0] = vaddlv_u8(v26);
        if (v26.u32[0] > 1uLL)
        {
          unint64_t v27 = v25;
          if (v25 >= *(void *)&v21) {
            unint64_t v27 = v25 % *(void *)&v21;
          }
        }
        else
        {
          unint64_t v27 = (*(void *)&v21 - 1) & v25;
        }
        double v31 = *(double ***)(*v20 + 8 * v27);
        if (v31)
        {
          for (uint64_t i = *v31; i; uint64_t i = *(double **)i)
          {
            unint64_t v33 = *((void *)i + 1);
            if (v25 == v33)
            {
              if (*((void *)i + 2) == v19)
              {
                uint64_t v105 = *(SVG::Recorder **)(v5 + 64);
                uint64_t v107 = *(void **)(v5 + 16);
                unint64_t v106 = *(double **)(v5 + 24);
                CGFloat v108 = *v106;
                CGFloat v109 = v106[1];
                CGFloat v110 = v106[2];
                CGFloat v111 = v106[3];
                memset(&v230, 255, sizeof(v230));
                CGFloat v113 = i[3];
                uint64_t v112 = (std::__shared_weak_count *)*((void *)i + 4);
                if (v112) {
                  atomic_fetch_add_explicit(&v112->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                SVG::PatternElement::computeRecordingRect(v19, v107, v108, v109, v110, v111);
                double v115 = v114;
                double v117 = v116;
                double v119 = v118;
                double v121 = v120;
                SVG::PatternElement::computePlaybackRect(v22, v107, v108, v109, v110, v111);
                double v209 = v122;
                double v212 = v123;
                *(void *)&long long v124 = -1;
                *((void *)&v124 + 1) = -1;
                *(_OWORD *)&v228.CGFloat c = v124;
                *(_OWORD *)&v228.tCGFloat x = v124;
                *(_OWORD *)&v228.CGFloat a = v124;
                unint64_t v229 = 0xAAAAAAAAAAAAAAAALL;
                SVG::PatternElement::contentsTransform(v22, v107, (uint64_t)&v228, v108, v109, v110, v111, v115, v117, v119, v121);
                if ((_BYTE)v229)
                {
                  *(void *)&long long v125 = -1;
                  *((void *)&v125 + 1) = -1;
                  *(_OWORD *)&t1.CGFloat c = v125;
                  *(_OWORD *)&t1.tCGFloat x = v125;
                  unint64_t v227 = 0xAAAAAAAAAAAAAAAALL;
                  CGAffineTransform v225 = v228;
                  *(_OWORD *)&t1.CGFloat a = v125;
                  SVG::invert(&v225, (uint64_t)&t1);
                  if ((_BYTE)v227)
                  {
                    CGAffineTransform v224 = t1;
                    v247.origin.CGFloat x = v115;
                    v247.origin.CGFloat y = v117;
                    v247.size.CGFloat width = v119;
                    v247.size.CGFloat height = v121;
                    CGRect v248 = CGRectApplyAffineTransform(v247, &v224);
                    if (v248.size.width > 0.0)
                    {
                      CGFloat height = v248.size.height;
                      if (v248.size.height > 0.0)
                      {
                        CGFloat x = v248.origin.x;
                        CGFloat y = v248.origin.y;
                        CGFloat width = v248.size.width;
                        uint64_t CTM = SVG::Recorder::recordGetCTM(v105);
                        *(void *)&long long v131 = -1;
                        *((void *)&v131 + 1) = -1;
                        *(_OWORD *)&v223.CGFloat c = v131;
                        *(_OWORD *)&v223.tCGFloat x = v131;
                        *(_OWORD *)&v223.CGFloat a = v131;
                        CGAffineTransformMakeTranslation(&v223, v209 - v115, v212 - v117);
                        SVG::PatternElement::specifiedState(v22, v107, (uint64_t)t2);
                        CGAffineTransform v219 = v240;
                        CGAffineTransform v222 = v228;
                        CGAffineTransform v220 = v223;
                        CGAffineTransformConcat(&v221, &v220, &v219);
                        CGAffineTransformConcat(&v230, &v222, &v221);
                        *(void *)&v214.CGFloat a = &unk_1F1A74B80;
                        v214.CGFloat b = v113;
                        *(void *)&v214.CGFloat c = v112;
                        v214.CGFloat d = x;
                        v214.tCGFloat x = y;
                        v214.tCGFloat y = width;
                        CGFloat v215 = height;
                        uint64_t v216 = CTM;
                        CGAffineTransform v217 = v230;
                        int v218 = 2;
                        *(void *)CGAffineTransform t2 = &unk_1F1A74B80;
                        t2[8] = 0;
                        int v236 = -1;
                        std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1>>((uint64_t)&t2[8], (uint64_t)&v214.b);
                        LODWORD(v237) = 9;
                        SVG::Recorder::append((uint64_t)v105, (uint64_t)t2);
                        if (v237 != -1) {
                          ((void (*)(char *, unsigned char *))off_1F1A75A18[v237])(&v231, t2);
                        }
                        LODWORD(v237) = -1;
                        *(void *)&v214.CGFloat a = &unk_1F1A74B80;
                        if (v218 != -1) {
                          ((void (*)(char *, CGFloat *))off_1F1A75A00[v218])(&v231, &v214.b);
                        }
                        *(_DWORD *)a3 = 0;
                        *(_DWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = 1;
                        return;
                      }
                    }
                  }
                }
                if (v112) {
                  std::__shared_weak_count::__release_shared[abi:nn180100](v112);
                }
                break;
              }
            }
            else
            {
              if (v26.u32[0] > 1uLL)
              {
                if (v33 >= *(void *)&v21) {
                  v33 %= *(void *)&v21;
                }
              }
              else
              {
                v33 &= *(void *)&v21 - 1;
              }
              if (v33 != v27) {
                break;
              }
            }
          }
        }
      }
    }
LABEL_108:
    if (!*(unsigned char *)(a2 + 24))
    {
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = 0;
      return;
    }
    uint64_t v132 = **(void **)(v5 + 96);
    *(_OWORD *)CGAffineTransform t2 = *(_OWORD *)*(void *)(v5 + 88);
    *(void *)&t2[16] = v132;
    uint64_t v133 = *(unsigned int *)(a2 + 20);
    if (v133 != -1)
    {
      *(void *)&v214.CGFloat a = t2;
      ((void (*)(CGAffineTransform *, uint64_t))off_1F1A75AD0[v133])(&v214, a2 + 12);
      return;
    }
    std::__throw_bad_variant_access[abi:nn180100]();
LABEL_203:
    abort();
  }
  unint64_t v10 = (unint64_t)v9;
  (*(void (**)(unsigned char *__return_ptr))(*(void *)v9 + 40))(t2);
  if (*(_DWORD *)t2 == 1)
  {
    uint64_t v11 = *(void *)(v5 + 24);
    if (*(double *)(v11 + 16) <= 0.0 || *(double *)(v11 + 24) <= 0.0) {
      goto LABEL_108;
    }
  }
  uint64_t v12 = *(void **)(v5 + 32);
  int8x8_t v13 = (int8x8_t)v12[1];
  if (!*(void *)&v13) {
    goto LABEL_108;
  }
  unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v10) + 8) ^ HIDWORD(v10));
  unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v10) ^ (v14 >> 47) ^ v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v13);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v18 = v16;
    if (v16 >= *(void *)&v13) {
      unint64_t v18 = v16 % *(void *)&v13;
    }
  }
  else
  {
    unint64_t v18 = (*(void *)&v13 - 1) & v16;
  }
  float v28 = *(void **)(*v12 + 8 * v18);
  if (!v28) {
    goto LABEL_108;
  }
  int v29 = (void *)*v28;
  if (!v29) {
    goto LABEL_108;
  }
  while (1)
  {
    unint64_t v30 = v29[1];
    if (v16 == v30) {
      break;
    }
    if (v17.u32[0] > 1uLL)
    {
      if (v30 >= *(void *)&v13) {
        v30 %= *(void *)&v13;
      }
    }
    else
    {
      v30 &= *(void *)&v13 - 1;
    }
    if (v30 != v18) {
      goto LABEL_108;
    }
LABEL_25:
    int v29 = (void *)*v29;
    if (!v29) {
      goto LABEL_108;
    }
  }
  if (v29[2] != v10) {
    goto LABEL_25;
  }
  uint64_t v34 = (const void *)v29[3];
  uint64_t v35 = *(void *)(v5 + 48);
  BOOL v36 = **(const CGPath ***)(v5 + 40);
  double v37 = *(double *)(v35 + 16);
  double v38 = *(double *)(v35 + 24);
  CGFloat v40 = *(void **)(v5 + 16);
  char v39 = *(double **)(v5 + 24);
  CGFloat v41 = *v39;
  CGFloat v42 = v39[1];
  CGFloat v43 = v39[2];
  CGFloat v44 = v39[3];
  memset(&v214, 255, sizeof(v214));
  CGFloat v215 = 0.0;
  uint64_t v216 = 0;
  v217.CGFloat a = 0.0;
  v217.CGFloat b = -3.72066066e-103;
  *(void *)&long long v45 = -1;
  *((void *)&v45 + 1) = -1;
  *(_OWORD *)&v228.CGFloat c = v45;
  *(_OWORD *)&v228.tCGFloat x = v45;
  *(_OWORD *)&v228.CGFloat a = v45;
  (*(void (**)(unsigned char *__return_ptr, unint64_t, void *))(*(void *)v10 + 40))(t2, v10, v40);
  SVG::unitTransform((CGAffineTransform *)*(unsigned int *)t2, (uint64_t)&v228, v41, v42, v43, v44);
  (*(void (**)(unsigned char *__return_ptr, unint64_t, void *))(*(void *)v10 + 40))(t2, v10, v40);
  CGAffineTransform t1 = *(CGAffineTransform *)&t2[8];
  *(CGAffineTransform *)CGAffineTransform t2 = v228;
  CGAffineTransformConcat(&v214, &t1, (CGAffineTransform *)t2);
  *(void *)&long long v46 = -1;
  *((void *)&v46 + 1) = -1;
  *(_OWORD *)&v228.CGFloat c = v46;
  *(_OWORD *)&v228.tCGFloat x = v46;
  *(_OWORD *)&v228.CGFloat a = v46;
  unint64_t v229 = 0xAAAAAAAAAAAAAAAALL;
  CGAffineTransform t1 = v214;
  SVG::invert(&t1, (uint64_t)&v228);
  if (!(_BYTE)v229) {
    goto LABEL_119;
  }
  (*(void (**)(unsigned char *__return_ptr, unint64_t, void *))(*(void *)v10 + 40))(t2, v10, v40);
  if (*(_DWORD *)t2) {
    double v47 = 1.0;
  }
  else {
    double v47 = v37;
  }
  if (*(_DWORD *)t2) {
    double v48 = 1.0;
  }
  else {
    double v48 = v38;
  }
  CGRect BoundingBox = CGPathGetBoundingBox(v36);
  CGAffineTransform v230 = v228;
  CGRect v246 = CGRectApplyAffineTransform(BoundingBox, &v230);
  CGFloat v49 = v246.origin.x;
  CGFloat v50 = v246.origin.y;
  CGFloat v51 = v246.size.width;
  CGFloat v52 = v246.size.height;
  if (!v53)
  {
    if (v134)
    {
      unint64_t v135 = (unint64_t)v134;
      CGFloat v210 = v51;
      CGFloat v213 = v52;
      SVG::RadialGradientElement::specifiedRadialState((unint64_t)v134, v40, (uint64_t)t2);
      *(_OWORD *)&v225.CGFloat a = v234;
      double v136 = SVG::Length::computeValue((SVG::Length *)&v225, v47);
      SVG::RadialGradientElement::specifiedRadialState(v135, v40, (uint64_t)t2);
      *(_OWORD *)CGAffineTransform t2 = v235;
      double v137 = SVG::Length::computeValue((SVG::Length *)t2, v48);
      SVG::RadialGradientElement::specifiedRadialState(v135, v40, (uint64_t)t2);
      v225.CGFloat c = v239;
      *(_OWORD *)&v225.CGFloat a = v238;
      CGFloat v138 = v136;
      if (LOBYTE(v239)) {
        double v136 = SVG::Length::computeValue((SVG::Length *)&v225, v47);
      }
      SVG::RadialGradientElement::specifiedRadialState(v135, v40, (uint64_t)t2);
      v225.CGFloat c = v240.c;
      *(_OWORD *)&v225.CGFloat a = *(_OWORD *)&v240.a;
      double v139 = v137;
      if (LOBYTE(v240.c)) {
        double v139 = SVG::Length::computeValue((SVG::Length *)&v225, v48);
      }
      SVG::RadialGradientElement::specifiedRadialState(v135, v40, (uint64_t)t2);
      *(_OWORD *)CGAffineTransform t2 = v237;
      double v140 = SVG::Length::computeValue((SVG::Length *)t2, sqrt(v48 * v48 + v47 * v47) / 1.41421356);
      *(void *)&long long v141 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v141 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v224.CGFloat a = v141;
      *(_OWORD *)&v224.CGFloat c = v141;
      char v142 = (SVG *)(*(void *(**)(unsigned char *__return_ptr, unint64_t, void *))(*(void *)v10 + 40))(t2, v10, v40);
      if (v140 != 0.0)
      {
        int v146 = v233;
        if (!v233)
        {
          *(void *)CGAffineTransform t2 = &unk_1F1A748D8;
          *(void *)&t2[8] = v34;
          if (v34) {
            CFRetain(v34);
          }
          *(double *)&t2[16] = v136;
          *(double *)&t2[24] = v139;
          *(void *)&t2[32] = 0;
          *(CGFloat *)&t2[40] = v138;
          *(double *)&t2[48] = v137;
          *(double *)&t2[56] = v140;
          int v233 = 3;
          long long v205 = (char *)operator new(0x48uLL);
          uint64_t v206 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<SVG::DrawRadialGradient>,SVG::DrawRadialGradient const*,SVG::DrawRadialGradient const*,SVG::DrawRadialGradient*>((uint64_t)t2, (uint64_t)&v234, (uint64_t)v205);
          *(void *)&v224.CGFloat a = v205;
          *(void *)&v224.CGFloat b = v206;
          *(void *)&v224.CGFloat c = v205 + 72;
          memset(&v225, 0, 24);
          LOBYTE(v224.d) = 1;
          *(void *)&v223.CGFloat a = &v225;
          std::vector<SVG::DrawRadialGradient>::__destroy_vector::operator()[abi:nn180100]((void ***)&v223);
          *(void *)CGAffineTransform t2 = &unk_1F1A748D8;
          if (*(void *)&t2[8]) {
            CFRelease(*(CFTypeRef *)&t2[8]);
          }
          goto LABEL_200;
        }
        v243.CGFloat x = v138;
        v243.CGFloat y = v137;
        v249.origin.CGFloat x = v49;
        v249.origin.CGFloat y = v50;
        v249.size.CGFloat width = v210;
        v249.size.CGFloat height = v213;
        unint64_t v147 = SVG::calculateRadialQuanta(v142, v243, v140, v249);
        unint64_t v148 = HIDWORD(v147);
        if (HIDWORD(v147) - (int)v147 <= 25)
        {
          CGFloat v149 = 0.0;
          long long v150 = 0uLL;
          memset(&v223, 0, 24);
          if (SHIDWORD(v147) <= (int)v147) {
            goto LABEL_195;
          }
          double v151 = v136;
          double v152 = v139;
          CGFloat v153 = v138;
          while (1)
          {
            if (v140 * (double)(int)v147 >= 0.0) {
              double v154 = v140 * (double)(int)v147;
            }
            else {
              double v154 = 0.0;
            }
            int v155 = v147 + 1;
            if (v140 * (double)((int)v147 + 1) >= 0.0) {
              double v156 = v140 * (double)v155;
            }
            else {
              double v156 = 0.0;
            }
            if (v147)
            {
              if (v146 == 2 || (v147 & 1) == 0)
              {
                *(void *)CGAffineTransform t2 = &unk_1F1A748D8;
                *(void *)&t2[8] = v34;
                if (v34) {
                  CFRetain(v34);
                }
                *(CGFloat *)&t2[16] = v153;
                *(double *)&t2[24] = v137;
                *(double *)&t2[32] = v154;
                *(CGFloat *)&t2[40] = v153;
                *(double *)&t2[48] = v137;
                *(double *)&t2[56] = v156;
                int v233 = 0;
                CGFloat b = v223.b;
                if (*(void *)&v223.b >= *(void *)&v223.c)
                {
                  CGFloat a = v223.a;
                  unint64_t v174 = 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)&v223.b - *(void *)&v223.a) >> 3);
                  unint64_t v175 = v174 + 1;
                  if (v174 + 1 > 0x38E38E38E38E38ELL) {
                    goto LABEL_203;
                  }
                  if (0x1C71C71C71C71C72 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3) > v175) {
                    unint64_t v175 = 0x1C71C71C71C71C72 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3);
                  }
                  if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3) >= 0x1C71C71C71C71C7) {
                    unint64_t v176 = 0x38E38E38E38E38ELL;
                  }
                  else {
                    unint64_t v176 = v175;
                  }
                  *(void *)&v225.tCGFloat x = &v223.c;
                  if (v176)
                  {
                    unint64_t v176 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawRadialGradient>>(v176);
                    CGFloat a = v223.a;
                    CGFloat b = v223.b;
                  }
                  else
                  {
                    uint64_t v177 = 0;
                  }
                  *(void *)&CGFloat v178 = v176 + 72 * v174;
                  *(void *)&v225.CGFloat d = v176 + 72 * v177;
                  **(void **)&CGFloat v178 = &unk_1F1A748D8;
                  uint64_t v195 = *(void *)&t2[8];
                  *(void *)&t2[8] = 0;
                  *(void *)(*(void *)&v178 + 8) = v195;
                  long long v197 = *(_OWORD *)&t2[32];
                  long long v196 = *(_OWORD *)&t2[48];
                  LODWORD(v195) = v233;
                  *(_OWORD *)(*(void *)&v178 + 16) = *(_OWORD *)&t2[16];
                  *(_OWORD *)(*(void *)&v178 + 32) = v197;
                  *(_DWORD *)(*(void *)&v178 + 64) = v195;
                  *(_OWORD *)(*(void *)&v178 + 48) = v196;
                  *(void *)&CGFloat c = *(void *)&v178 + 72;
                  *(void *)&v225.CGFloat c = *(void *)&v178 + 72;
                  if (*(void *)&b != *(void *)&a)
                  {
                    uint64_t v198 = v176 + 72 * v174 - 72;
                    do
                    {
                      *(void *)(*(void *)&v178 - 72) = &unk_1F1A748D8;
                      *(void *)&v178 -= 72;
                      uint64_t v199 = *(void *)(*(void *)&b - 64);
                      *(void *)(*(void *)&b - 64) = 0;
                      *(void *)(*(void *)&v178 + 8) = v199;
                      long long v200 = *(_OWORD *)(*(void *)&b - 56);
                      long long v201 = *(_OWORD *)(*(void *)&b - 40);
                      long long v202 = *(_OWORD *)(*(void *)&b - 24);
                      *(_DWORD *)(*(void *)&v178 + 64) = *(_DWORD *)(*(void *)&b - 8);
                      *(_OWORD *)(*(void *)&v178 + 32) = v201;
                      *(_OWORD *)(*(void *)&v178 + 48) = v202;
                      *(_OWORD *)(*(void *)&v178 + 16) = v200;
                      v198 -= 72;
                      *(void *)&b -= 72;
                    }
                    while (*(void *)&b != *(void *)&a);
                    goto LABEL_189;
                  }
                  goto LABEL_190;
                }
              }
              else
              {
                *(void *)CGAffineTransform t2 = &unk_1F1A748D8;
                *(void *)&t2[8] = v34;
                if (v34) {
                  CFRetain(v34);
                }
                *(CGFloat *)&t2[16] = v153;
                *(double *)&t2[24] = v137;
                *(double *)&t2[32] = v156;
                *(CGFloat *)&t2[40] = v153;
                *(double *)&t2[48] = v137;
                *(double *)&t2[56] = v154;
                int v233 = 0;
                CGFloat b = v223.b;
                if (*(void *)&v223.b >= *(void *)&v223.c)
                {
                  CGFloat v158 = v223.a;
                  unint64_t v159 = 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)&v223.b - *(void *)&v223.a) >> 3);
                  unint64_t v160 = v159 + 1;
                  if (v159 + 1 > 0x38E38E38E38E38ELL) {
                    goto LABEL_203;
                  }
                  if (0x1C71C71C71C71C72 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3) > v160) {
                    unint64_t v160 = 0x1C71C71C71C71C72 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3);
                  }
                  if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3) >= 0x1C71C71C71C71C7) {
                    unint64_t v161 = 0x38E38E38E38E38ELL;
                  }
                  else {
                    unint64_t v161 = v160;
                  }
                  *(void *)&v225.tCGFloat x = &v223.c;
                  if (v161)
                  {
                    unint64_t v161 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawRadialGradient>>(v161);
                    CGFloat v158 = v223.a;
                    CGFloat b = v223.b;
                  }
                  else
                  {
                    uint64_t v162 = 0;
                  }
                  *(void *)&CGFloat v178 = v161 + 72 * v159;
                  *(void *)&v225.CGFloat d = v161 + 72 * v162;
                  **(void **)&CGFloat v178 = &unk_1F1A748D8;
                  uint64_t v187 = *(void *)&t2[8];
                  *(void *)&t2[8] = 0;
                  *(void *)(*(void *)&v178 + 8) = v187;
                  long long v189 = *(_OWORD *)&t2[32];
                  long long v188 = *(_OWORD *)&t2[48];
                  LODWORD(v187) = v233;
                  *(_OWORD *)(*(void *)&v178 + 16) = *(_OWORD *)&t2[16];
                  *(_OWORD *)(*(void *)&v178 + 32) = v189;
                  *(_DWORD *)(*(void *)&v178 + 64) = v187;
                  *(_OWORD *)(*(void *)&v178 + 48) = v188;
                  *(void *)&CGFloat c = *(void *)&v178 + 72;
                  *(void *)&v225.CGFloat c = *(void *)&v178 + 72;
                  if (*(void *)&b != *(void *)&v158)
                  {
                    uint64_t v190 = v161 + 72 * v159 - 72;
                    do
                    {
                      *(void *)(*(void *)&v178 - 72) = &unk_1F1A748D8;
                      *(void *)&v178 -= 72;
                      uint64_t v191 = *(void *)(*(void *)&b - 64);
                      *(void *)(*(void *)&b - 64) = 0;
                      *(void *)(*(void *)&v178 + 8) = v191;
                      long long v192 = *(_OWORD *)(*(void *)&b - 56);
                      long long v193 = *(_OWORD *)(*(void *)&b - 40);
                      long long v194 = *(_OWORD *)(*(void *)&b - 24);
                      *(_DWORD *)(*(void *)&v178 + 64) = *(_DWORD *)(*(void *)&b - 8);
                      *(_OWORD *)(*(void *)&v178 + 32) = v193;
                      *(_OWORD *)(*(void *)&v178 + 48) = v194;
                      *(_OWORD *)(*(void *)&v178 + 16) = v192;
                      v190 -= 72;
                      *(void *)&b -= 72;
                    }
                    while (*(void *)&b != *(void *)&v158);
                    goto LABEL_189;
                  }
                  goto LABEL_190;
                }
              }
            }
            else
            {
              *(void *)CGAffineTransform t2 = &unk_1F1A748D8;
              *(void *)&t2[8] = v34;
              if (v34) {
                CFRetain(v34);
              }
              *(double *)&t2[16] = v151;
              *(double *)&t2[24] = v152;
              *(void *)&t2[32] = 0;
              *(CGFloat *)&t2[40] = v153;
              *(double *)&t2[48] = v137;
              *(double *)&t2[56] = v140;
              int v233 = 0;
              CGFloat b = v223.b;
              if (*(void *)&v223.b >= *(void *)&v223.c)
              {
                CGFloat v163 = v223.a;
                unint64_t v164 = 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)&v223.b - *(void *)&v223.a) >> 3);
                unint64_t v165 = v164 + 1;
                if (v164 + 1 > 0x38E38E38E38E38ELL) {
                  goto LABEL_203;
                }
                if (0x1C71C71C71C71C72 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3) > v165) {
                  unint64_t v165 = 0x1C71C71C71C71C72 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3);
                }
                if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3) >= 0x1C71C71C71C71C7) {
                  unint64_t v166 = 0x38E38E38E38E38ELL;
                }
                else {
                  unint64_t v166 = v165;
                }
                *(void *)&v225.tCGFloat x = &v223.c;
                if (v166)
                {
                  unint64_t v166 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawRadialGradient>>(v166);
                  CGFloat v163 = v223.a;
                  CGFloat b = v223.b;
                }
                else
                {
                  uint64_t v167 = 0;
                }
                *(void *)&CGFloat v178 = v166 + 72 * v164;
                *(void *)&v225.CGFloat d = v166 + 72 * v167;
                **(void **)&CGFloat v178 = &unk_1F1A748D8;
                uint64_t v179 = *(void *)&t2[8];
                *(void *)&t2[8] = 0;
                *(void *)(*(void *)&v178 + 8) = v179;
                long long v181 = *(_OWORD *)&t2[32];
                long long v180 = *(_OWORD *)&t2[48];
                LODWORD(v179) = v233;
                *(_OWORD *)(*(void *)&v178 + 16) = *(_OWORD *)&t2[16];
                *(_OWORD *)(*(void *)&v178 + 32) = v181;
                *(_DWORD *)(*(void *)&v178 + 64) = v179;
                *(_OWORD *)(*(void *)&v178 + 48) = v180;
                *(void *)&CGFloat c = *(void *)&v178 + 72;
                *(void *)&v225.CGFloat c = *(void *)&v178 + 72;
                if (*(void *)&b != *(void *)&v163)
                {
                  uint64_t v182 = v166 + 72 * v164 - 72;
                  do
                  {
                    *(void *)(*(void *)&v178 - 72) = &unk_1F1A748D8;
                    *(void *)&v178 -= 72;
                    uint64_t v183 = *(void *)(*(void *)&b - 64);
                    *(void *)(*(void *)&b - 64) = 0;
                    *(void *)(*(void *)&v178 + 8) = v183;
                    long long v184 = *(_OWORD *)(*(void *)&b - 56);
                    long long v185 = *(_OWORD *)(*(void *)&b - 40);
                    long long v186 = *(_OWORD *)(*(void *)&b - 24);
                    *(_DWORD *)(*(void *)&v178 + 64) = *(_DWORD *)(*(void *)&b - 8);
                    *(_OWORD *)(*(void *)&v178 + 32) = v185;
                    *(_OWORD *)(*(void *)&v178 + 48) = v186;
                    *(_OWORD *)(*(void *)&v178 + 16) = v184;
                    v182 -= 72;
                    *(void *)&b -= 72;
                  }
                  while (*(void *)&b != *(void *)&v163);
LABEL_189:
                  CGFloat c = v225.c;
                }
LABEL_190:
                long long v203 = *(_OWORD *)&v223.a;
                v223.CGFloat a = v178;
                v223.CGFloat b = c;
                *(_OWORD *)&v225.CGFloat b = v203;
                CGFloat v204 = v223.c;
                v223.CGFloat c = v225.d;
                v225.CGFloat d = v204;
                *(void *)&v225.CGFloat a = v203;
                std::__split_buffer<SVG::DrawRadialGradient>::~__split_buffer((uint64_t)&v225);
                goto LABEL_191;
              }
            }
            **(void **)&CGFloat b = &unk_1F1A748D8;
            uint64_t v168 = *(void *)&t2[8];
            *(void *)&t2[8] = 0;
            *(void *)(*(void *)&b + 8) = v168;
            long long v169 = *(_OWORD *)&t2[16];
            long long v170 = *(_OWORD *)&t2[32];
            long long v171 = *(_OWORD *)&t2[48];
            *(_DWORD *)(*(void *)&b + 64) = v233;
            *(_OWORD *)(*(void *)&b + 32) = v170;
            *(_OWORD *)(*(void *)&b + 48) = v171;
            *(_OWORD *)(*(void *)&b + 16) = v169;
            *(void *)&CGFloat c = *(void *)&b + 72;
LABEL_191:
            v223.CGFloat b = c;
            *(void *)CGAffineTransform t2 = &unk_1F1A748D8;
            if (*(void *)&t2[8]) {
              CFRelease(*(CFTypeRef *)&t2[8]);
            }
            LODWORD(v147) = v155;
            if (v155 == v148)
            {
              long long v150 = *(_OWORD *)&v223.a;
              CGFloat v149 = v223.c;
LABEL_195:
              *(_OWORD *)&v224.CGFloat a = v150;
              v224.CGFloat c = v149;
              memset(&v223, 0, 24);
              LOBYTE(v224.d) = 1;
              *(void *)CGAffineTransform t2 = &v223;
              std::vector<SVG::DrawRadialGradient>::__destroy_vector::operator()[abi:nn180100]((void ***)t2);
LABEL_200:
              std::__variant_detail::__assignment<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__assign_alt[abi:nn180100]<1ul,std::vector<SVG::DrawRadialGradient>,std::vector<SVG::DrawRadialGradient>>((uint64_t)&v215, (void **)&v215, (__n128 *)&v224);
              long long v207 = *(_OWORD *)&v214.c;
              *(_OWORD *)a3 = *(_OWORD *)&v214.a;
              *(_OWORD *)(a3 + 16) = v207;
              *(_OWORD *)(a3 + 32) = *(_OWORD *)&v214.tx;
              *(unsigned char *)(a3 + 48) = 0;
              *(_DWORD *)(a3 + 72) = -1;
              std::__variant_detail::__ctor<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>,(std::__variant_detail::_Trait)1>>(a3 + 48, (uint64_t)&v215);
              *(_DWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = 2;
              if (LOBYTE(v224.d))
              {
                *(void *)CGAffineTransform t2 = &v224;
                std::vector<SVG::DrawRadialGradient>::__destroy_vector::operator()[abi:nn180100]((void ***)t2);
              }
              goto LABEL_120;
            }
          }
        }
      }
    }
LABEL_119:
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = 0;
    goto LABEL_120;
  }
  unint64_t v54 = (unint64_t)v53;
  CGFloat v208 = v49;
  CGFloat v211 = v50;
  SVG::LinearGradientElement::specifiedLinearState((unint64_t)v53, v40, (uint64_t)t2);
  *(_OWORD *)&v225.CGFloat a = v234;
  double v55 = SVG::Length::computeValue((SVG::Length *)&v225, v47);
  SVG::LinearGradientElement::specifiedLinearState(v54, v40, (uint64_t)t2);
  *(_OWORD *)CGAffineTransform t2 = v235;
  double v56 = SVG::Length::computeValue((SVG::Length *)t2, v48);
  SVG::LinearGradientElement::specifiedLinearState(v54, v40, (uint64_t)t2);
  *(_OWORD *)&v225.CGFloat a = v237;
  double v57 = SVG::Length::computeValue((SVG::Length *)&v225, v47);
  SVG::LinearGradientElement::specifiedLinearState(v54, v40, (uint64_t)t2);
  *(_OWORD *)CGAffineTransform t2 = v238;
  double v58 = SVG::Length::computeValue((SVG::Length *)t2, v48);
  *(void *)&long long v59 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v59 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v224.CGFloat a = v59;
  *(_OWORD *)&v224.CGFloat c = v59;
  long long v60 = (SVG *)(*(void *(**)(unsigned char *__return_ptr, unint64_t, void *))(*(void *)v10 + 40))(t2, v10, v40);
  int v61 = v233;
  double v62 = v57 - v55;
  double v63 = v58 - v56;
  if (v57 - v55 == *MEMORY[0x1E4F1DB30] && v63 == *(double *)(MEMORY[0x1E4F1DB30] + 8)) {
    goto LABEL_119;
  }
  if (!v233)
  {
    *(void *)CGAffineTransform t2 = &unk_1F1A74890;
    *(void *)&t2[8] = v34;
    if (v34) {
      CFRetain(v34);
    }
    *(double *)&t2[16] = v55;
    *(double *)&t2[24] = v56;
    *(double *)&t2[32] = v57;
    *(double *)&t2[40] = v58;
    *(_DWORD *)&t2[48] = 3;
    unsigned int v143 = (char *)operator new(0x38uLL);
    uint64_t v144 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<SVG::DrawLinearGradient>,SVG::DrawLinearGradient const*,SVG::DrawLinearGradient const*,SVG::DrawLinearGradient*>((uint64_t)t2, (uint64_t)&t2[56], (uint64_t)v143);
    *(void *)&v224.CGFloat a = v143;
    *(void *)&v224.CGFloat b = v144;
    *(void *)&v224.CGFloat c = v143 + 56;
    memset(&v225, 0, 24);
    LOBYTE(v224.d) = 1;
    *(void *)&v223.CGFloat a = &v225;
    std::vector<SVG::DrawLinearGradient>::__destroy_vector::operator()[abi:nn180100]((void ***)&v223);
    *(void *)CGAffineTransform t2 = &unk_1F1A74890;
    if (*(void *)&t2[8]) {
      CFRelease(*(CFTypeRef *)&t2[8]);
    }
    goto LABEL_126;
  }
  v242.CGFloat x = v55;
  v242.CGFloat y = v56;
  v244.CGFloat width = v57 - v55;
  v244.CGFloat height = v58 - v56;
  v250.origin.CGFloat x = v208;
  v250.origin.CGFloat y = v211;
  v250.size.CGFloat width = v51;
  v250.size.CGFloat height = v52;
  unint64_t v64 = SVG::calculateLinearQuanta(v60, v242, v244, v250);
  unint64_t v65 = HIDWORD(v64);
  if (HIDWORD(v64) - (int)v64 > 25) {
    goto LABEL_119;
  }
  CGFloat v66 = 0.0;
  long long v67 = 0uLL;
  memset(&v223, 0, 24);
  if (SHIDWORD(v64) <= (int)v64) {
    goto LABEL_94;
  }
  while (2)
  {
    double v68 = v55 + v62 * (double)(int)v64;
    double v69 = v56 + v63 * (double)(int)v64;
    int v70 = v64 + 1;
    if (v61 == 2 || (v64 & 1) == 0)
    {
      *(void *)CGAffineTransform t2 = &unk_1F1A74890;
      *(void *)&t2[8] = v34;
      if (v34) {
        CFRetain(v34);
      }
      *(double *)&t2[16] = v68;
      *(double *)&t2[24] = v69;
      *(double *)&t2[32] = v55 + v62 * (double)v70;
      *(double *)&t2[40] = v56 + v63 * (double)v70;
      *(_DWORD *)&t2[48] = 0;
      CGFloat v71 = v223.b;
      if (*(void *)&v223.b < *(void *)&v223.c) {
        goto LABEL_70;
      }
      CGFloat v81 = v223.a;
      uint64_t v82 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v223.b - *(void *)&v223.a) >> 3);
      unint64_t v83 = v82 + 1;
      if ((unint64_t)(v82 + 1) > 0x492492492492492) {
        goto LABEL_203;
      }
      if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3) > v83) {
        unint64_t v83 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3);
      }
      if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3)) >= 0x249249249249249) {
        CGFloat v84 = 1.2008702e-286;
      }
      else {
        CGFloat v84 = *(double *)&v83;
      }
      *(void *)&v225.tCGFloat x = &v223.c;
      if (v84 == 0.0)
      {
        uint64_t v85 = 0;
      }
      else
      {
        CGFloat v84 = COERCE_DOUBLE(std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawLinearGradient>>(*(unint64_t *)&v84));
        CGFloat v81 = v223.a;
        CGFloat v71 = v223.b;
      }
      *(void *)&CGFloat v95 = *(void *)&v84 + 56 * v82;
      v225.CGFloat a = v84;
      v225.CGFloat b = v95;
      *(void *)&v225.CGFloat d = *(void *)&v84 + 56 * v85;
      **(void **)&CGFloat v95 = &unk_1F1A74890;
      uint64_t v96 = *(void *)&t2[8];
      *(void *)&t2[8] = 0;
      *(void *)(*(void *)&v95 + 8) = v96;
      long long v97 = *(_OWORD *)&t2[16];
      long long v98 = *(_OWORD *)&t2[32];
      *(_DWORD *)(*(void *)&v95 + 48) = *(_DWORD *)&t2[48];
      *(_OWORD *)(*(void *)&v95 + 16) = v97;
      *(_OWORD *)(*(void *)&v95 + 32) = v98;
      *(void *)&CGFloat v80 = *(void *)&v95 + 56;
      *(void *)&v225.CGFloat c = *(void *)&v95 + 56;
      CGFloat v90 = v225.b;
      if (*(void *)&v71 != *(void *)&v81)
      {
        uint64_t v99 = *(void *)&v225.b - 56;
        do
        {
          *(void *)(*(void *)&v90 - 56) = &unk_1F1A74890;
          *(void *)&v90 -= 56;
          uint64_t v100 = *(void *)(*(void *)&v71 - 48);
          *(void *)(*(void *)&v71 - 48) = 0;
          *(void *)(*(void *)&v90 + 8) = v100;
          long long v101 = *(_OWORD *)(*(void *)&v71 - 40);
          long long v102 = *(_OWORD *)(*(void *)&v71 - 24);
          *(_DWORD *)(*(void *)&v90 + 48) = *(_DWORD *)(*(void *)&v71 - 8);
          *(_OWORD *)(*(void *)&v90 + 16) = v101;
          *(_OWORD *)(*(void *)&v90 + 32) = v102;
          v99 -= 56;
          *(void *)&v71 -= 56;
        }
        while (*(void *)&v71 != *(void *)&v81);
LABEL_88:
        CGFloat v80 = v225.c;
      }
LABEL_89:
      long long v103 = *(_OWORD *)&v223.a;
      v223.CGFloat a = v90;
      v223.CGFloat b = v80;
      *(_OWORD *)&v225.CGFloat b = v103;
      CGFloat v104 = v223.c;
      v223.CGFloat c = v225.d;
      v225.CGFloat d = v104;
      *(void *)&v225.CGFloat a = v103;
      std::__split_buffer<SVG::DrawLinearGradient>::~__split_buffer((uint64_t)&v225);
    }
    else
    {
      *(void *)CGAffineTransform t2 = &unk_1F1A74890;
      *(void *)&t2[8] = v34;
      if (v34) {
        CFRetain(v34);
      }
      *(double *)&t2[16] = v55 + v62 * (double)v70;
      *(double *)&t2[24] = v56 + v63 * (double)v70;
      *(double *)&t2[32] = v68;
      *(double *)&t2[40] = v69;
      *(_DWORD *)&t2[48] = 0;
      CGFloat v71 = v223.b;
      if (*(void *)&v223.b >= *(void *)&v223.c)
      {
        CGFloat v72 = v223.a;
        uint64_t v73 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v223.b - *(void *)&v223.a) >> 3);
        unint64_t v74 = v73 + 1;
        if ((unint64_t)(v73 + 1) > 0x492492492492492) {
          goto LABEL_203;
        }
        if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3) > v74) {
          unint64_t v74 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3);
        }
        if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v223.c - *(void *)&v223.a) >> 3)) >= 0x249249249249249) {
          CGFloat v75 = 1.2008702e-286;
        }
        else {
          CGFloat v75 = *(double *)&v74;
        }
        *(void *)&v225.tCGFloat x = &v223.c;
        if (v75 == 0.0)
        {
          uint64_t v76 = 0;
        }
        else
        {
          CGFloat v75 = COERCE_DOUBLE(std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawLinearGradient>>(*(unint64_t *)&v75));
          CGFloat v72 = v223.a;
          CGFloat v71 = v223.b;
        }
        *(void *)&CGFloat v86 = *(void *)&v75 + 56 * v73;
        v225.CGFloat a = v75;
        v225.CGFloat b = v86;
        *(void *)&v225.CGFloat d = *(void *)&v75 + 56 * v76;
        **(void **)&CGFloat v86 = &unk_1F1A74890;
        uint64_t v87 = *(void *)&t2[8];
        *(void *)&t2[8] = 0;
        *(void *)(*(void *)&v86 + 8) = v87;
        long long v88 = *(_OWORD *)&t2[16];
        long long v89 = *(_OWORD *)&t2[32];
        *(_DWORD *)(*(void *)&v86 + 48) = *(_DWORD *)&t2[48];
        *(_OWORD *)(*(void *)&v86 + 16) = v88;
        *(_OWORD *)(*(void *)&v86 + 32) = v89;
        *(void *)&CGFloat v80 = *(void *)&v86 + 56;
        *(void *)&v225.CGFloat c = *(void *)&v86 + 56;
        CGFloat v90 = v225.b;
        if (*(void *)&v71 != *(void *)&v72)
        {
          uint64_t v91 = *(void *)&v225.b - 56;
          do
          {
            *(void *)(*(void *)&v90 - 56) = &unk_1F1A74890;
            *(void *)&v90 -= 56;
            uint64_t v92 = *(void *)(*(void *)&v71 - 48);
            *(void *)(*(void *)&v71 - 48) = 0;
            *(void *)(*(void *)&v90 + 8) = v92;
            long long v93 = *(_OWORD *)(*(void *)&v71 - 40);
            long long v94 = *(_OWORD *)(*(void *)&v71 - 24);
            *(_DWORD *)(*(void *)&v90 + 48) = *(_DWORD *)(*(void *)&v71 - 8);
            *(_OWORD *)(*(void *)&v90 + 16) = v93;
            *(_OWORD *)(*(void *)&v90 + 32) = v94;
            v91 -= 56;
            *(void *)&v71 -= 56;
          }
          while (*(void *)&v71 != *(void *)&v72);
          goto LABEL_88;
        }
        goto LABEL_89;
      }
LABEL_70:
      **(void **)&CGFloat v71 = &unk_1F1A74890;
      uint64_t v77 = *(void *)&t2[8];
      *(void *)&t2[8] = 0;
      *(void *)(*(void *)&v71 + 8) = v77;
      long long v78 = *(_OWORD *)&t2[16];
      long long v79 = *(_OWORD *)&t2[32];
      *(_DWORD *)(*(void *)&v71 + 48) = *(_DWORD *)&t2[48];
      *(_OWORD *)(*(void *)&v71 + 16) = v78;
      *(_OWORD *)(*(void *)&v71 + 32) = v79;
      *(void *)&CGFloat v80 = *(void *)&v71 + 56;
    }
    v223.CGFloat b = v80;
    *(void *)CGAffineTransform t2 = &unk_1F1A74890;
    if (*(void *)&t2[8]) {
      CFRelease(*(CFTypeRef *)&t2[8]);
    }
    LODWORD(v64) = v70;
    if (v70 != v65) {
      continue;
    }
    break;
  }
  long long v67 = *(_OWORD *)&v223.a;
  CGFloat v66 = v223.c;
LABEL_94:
  *(_OWORD *)&v224.CGFloat a = v67;
  v224.CGFloat c = v66;
  memset(&v223, 0, 24);
  LOBYTE(v224.d) = 1;
  *(void *)CGAffineTransform t2 = &v223;
  std::vector<SVG::DrawLinearGradient>::__destroy_vector::operator()[abi:nn180100]((void ***)t2);
LABEL_126:
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__assign_alt[abi:nn180100]<0ul,std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawLinearGradient>>((uint64_t)&v215, (void **)&v215, (__n128 *)&v224);
  long long v145 = *(_OWORD *)&v214.c;
  *(_OWORD *)a3 = *(_OWORD *)&v214.a;
  *(_OWORD *)(a3 + 16) = v145;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)&v214.tx;
  *(unsigned char *)(a3 + 48) = 0;
  *(_DWORD *)(a3 + 72) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>,(std::__variant_detail::_Trait)1>>(a3 + 48, (uint64_t)&v215);
  *(_DWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = 2;
  if (LOBYTE(v224.d))
  {
    *(void *)CGAffineTransform t2 = &v224;
    std::vector<SVG::DrawLinearGradient>::__destroy_vector::operator()[abi:nn180100]((void ***)t2);
  }
LABEL_120:
  if (LODWORD(v217.b) != -1) {
    ((void (*)(unsigned char *, CGFloat *))off_1F1A75AB0[LODWORD(v217.b)])(t2, &v215);
  }
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<4ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_0,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_1,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_4,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_3>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::IRIWithFallback,SVG::Presentation::FromContext> const&>@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 104);
  v5[0] = 0;
  int v6 = 1;
  int v7 = &unk_1F1A74B80;
  v8[0] = 0;
  int v9 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1>>((uint64_t)v8, (uint64_t)v5);
  int v10 = 9;
  uint64_t result = SVG::Recorder::append(v3, (uint64_t)&v7);
  if (v10 != -1) {
    uint64_t result = ((uint64_t (*)(char *, void **))off_1F1A75A18[v10])(&v11, &v7);
  }
  int v10 = -1;
  if (v6 != -1) {
    uint64_t result = ((uint64_t (*)(char *, _DWORD *))off_1F1A75A00[v6])(&v11, v5);
  }
  *a2 = 0;
  a2[20] = 1;
  return result;
}

void SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2::operator()(_DWORD *a1, float **a2, uint64_t a3)
{
  CFTypeRef v13 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  SVG::createColorObject(*((CFArrayRef *)*a2 + 25), a3, &v13, *a2[1]);
  uint64_t v5 = (uint64_t)*a2;
  CFTypeRef v6 = v13;
  if (v13) {
    CFRetain(v13);
  }
  v7[0] = v6;
  int v8 = 0;
  int v9 = &unk_1F1A74B80;
  v10[0] = 0;
  int v11 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1>>((uint64_t)v10, (uint64_t)v7);
  int v12 = 9;
  SVG::Recorder::append(v5, (uint64_t)&v9);
  if (v12 != -1) {
    ((void (*)(char *, void **))off_1F1A75A18[v12])(&v14, &v9);
  }
  int v12 = -1;
  if (v8 != -1) {
    ((void (*)(char *, void *))off_1F1A75A00[v8])(&v14, v7);
  }
  *a1 = 0;
  a1[20] = 1;
  if (v6) {
    CFRelease(v6);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawLinearGradient>>(unint64_t a1)
{
  if (a1 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(56 * a1);
}

uint64_t std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<SVG::DrawLinearGradient>,SVG::DrawLinearGradient const*,SVG::DrawLinearGradient const*,SVG::DrawLinearGradient*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    uint64_t v6 = a3;
    do
    {
      int v7 = *(const void **)(v5 + 8);
      *(void *)uint64_t v3 = &unk_1F1A74890;
      *(void *)(v3 + 8) = v7;
      if (v7) {
        CFRetain(v7);
      }
      long long v8 = *(_OWORD *)(v5 + 16);
      long long v9 = *(_OWORD *)(v5 + 32);
      *(_DWORD *)(v3 + 48) = *(_DWORD *)(v5 + 48);
      *(_OWORD *)(v3 + 16) = v8;
      *(_OWORD *)(v3 + 32) = v9;
      v5 += 56;
      v3 += 56;
      v6 += 56;
    }
    while (v5 != a2);
  }
  return v3;
}

void std::vector<SVG::DrawLinearGradient>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 56;
      int v7 = v4 - 56;
      long long v8 = v4 - 56;
      do
      {
        long long v9 = *(void (***)(char *))v8;
        v8 -= 56;
        (*v9)(v7);
        v6 -= 56;
        BOOL v10 = v7 == v2;
        int v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__split_buffer<SVG::DrawLinearGradient>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = *(void (***)(void))(i - 56);
    *(void *)(a1 + 16) = i - 56;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

__n128 std::__variant_detail::__assignment<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__assign_alt[abi:nn180100]<0ul,std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawLinearGradient>>(uint64_t a1, void **a2, __n128 *a3)
{
  uint64_t v5 = *(unsigned int *)(a1 + 24);
  if (v5 == -1) {
    goto LABEL_12;
  }
  if (v5)
  {
    ((void (*)(char *, uint64_t))off_1F1A75AB0[v5])(&v16, a1);
LABEL_12:
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a3;
    *(__n128 *)a1 = *a3;
    *(void *)(a1 + 16) = a3[1].n128_u64[0];
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    *(_DWORD *)(a1 + 24) = 0;
    return result;
  }
  int v7 = (char *)*a2;
  if (*a2)
  {
    long long v8 = (char *)a2[1];
    long long v9 = *a2;
    if (v8 != v7)
    {
      BOOL v10 = v8 - 56;
      int v11 = v8 - 56;
      int v12 = v8 - 56;
      do
      {
        CFTypeRef v13 = *(void (***)(char *))v12;
        v12 -= 56;
        (*v13)(v11);
        v10 -= 56;
        BOOL v14 = v11 == v7;
        int v11 = v12;
      }
      while (!v14);
      long long v9 = *a2;
    }
    a2[1] = v7;
    operator delete(v9);
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  a2[2] = (void *)a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJNS_6vectorIN3SVG18DrawLinearGradientENS_9allocatorISA_EEEENS8_INS9_18DrawRadialGradientENSB_ISE_EEEEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSD_SG_EEEEEEDcSK_DpT0_(uint64_t a1, void **a2)
{
  uint64_t v2 = a2;
  std::vector<SVG::DrawLinearGradient>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJNS_6vectorIN3SVG18DrawLinearGradientENS_9allocatorISA_EEEENS8_INS9_18DrawRadialGradientENSB_ISE_EEEEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSD_SG_EEEEEEDcSK_DpT0_(uint64_t a1, void **a2)
{
  uint64_t v2 = a2;
  std::vector<SVG::DrawRadialGradient>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void std::vector<SVG::DrawRadialGradient>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 72;
      int v7 = v4 - 72;
      long long v8 = v4 - 72;
      do
      {
        long long v9 = *(void (***)(char *))v8;
        v8 -= 72;
        (*v9)(v7);
        v6 -= 72;
        BOOL v10 = v7 == v2;
        int v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 24);
  if (v4 != -1) {
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_1F1A75AB0[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 24) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 24);
  if (v5 != -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_1F1A75AC0[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 24) = v5;
  }
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJNS_6vectorIN3SVG18DrawLinearGradientENS_9allocatorISA_EEEENS8_INS9_18DrawRadialGradientENSB_ISE_EEEEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSO_OT0_E_JRNS0_6__baseILSL_1EJSD_SG_EEEOSW_EEEDcSO_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  __n128 result = *a3;
  *a2 = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJNS_6vectorIN3SVG18DrawLinearGradientENS_9allocatorISA_EEEENS8_INS9_18DrawRadialGradientENSB_ISE_EEEEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSO_OT0_E_JRNS0_6__baseILSL_1EJSD_SG_EEEOSW_EEEDcSO_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  __n128 result = *a3;
  *a2 = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawRadialGradient>>(unint64_t a1)
{
  if (a1 >= 0x38E38E38E38E38FLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(72 * a1);
}

uint64_t std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<SVG::DrawRadialGradient>,SVG::DrawRadialGradient const*,SVG::DrawRadialGradient const*,SVG::DrawRadialGradient*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    uint64_t v6 = a3;
    do
    {
      char v7 = *(const void **)(v5 + 8);
      *(void *)uint64_t v3 = &unk_1F1A748D8;
      *(void *)(v3 + 8) = v7;
      if (v7) {
        CFRetain(v7);
      }
      long long v8 = *(_OWORD *)(v5 + 16);
      long long v9 = *(_OWORD *)(v5 + 32);
      long long v10 = *(_OWORD *)(v5 + 48);
      *(_DWORD *)(v3 + 64) = *(_DWORD *)(v5 + 64);
      *(_OWORD *)(v3 + 32) = v9;
      *(_OWORD *)(v3 + 48) = v10;
      *(_OWORD *)(v3 + 16) = v8;
      v5 += 72;
      v3 += 72;
      v6 += 72;
    }
    while (v5 != a2);
  }
  return v3;
}

uint64_t std::__split_buffer<SVG::DrawRadialGradient>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 72);
    *(void *)(a1 + 16) = i - 72;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

__n128 std::__variant_detail::__assignment<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__assign_alt[abi:nn180100]<1ul,std::vector<SVG::DrawRadialGradient>,std::vector<SVG::DrawRadialGradient>>(uint64_t a1, void **a2, __n128 *a3)
{
  uint64_t v5 = *(unsigned int *)(a1 + 24);
  if (v5 == -1) {
    goto LABEL_12;
  }
  if (v5 != 1)
  {
    ((void (*)(char *, uint64_t))off_1F1A75AB0[v5])(&v16, a1);
LABEL_12:
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a3;
    *(__n128 *)a1 = *a3;
    *(void *)(a1 + 16) = a3[1].n128_u64[0];
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    *(_DWORD *)(a1 + 24) = 1;
    return result;
  }
  char v7 = (char *)*a2;
  if (*a2)
  {
    long long v8 = (char *)a2[1];
    long long v9 = *a2;
    if (v8 != v7)
    {
      long long v10 = v8 - 72;
      int v11 = v8 - 72;
      int v12 = v8 - 72;
      do
      {
        CFTypeRef v13 = *(void (***)(char *))v12;
        v12 -= 72;
        (*v13)(v11);
        v10 -= 72;
        BOOL v14 = v11 == v7;
        int v11 = v12;
      }
      while (!v14);
      long long v9 = *a2;
    }
    a2[1] = v7;
    operator delete(v9);
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  __n128 result = *a3;
  *(__n128 *)a2 = *a3;
  a2[2] = (void *)a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  return result;
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_0,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_1,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_3>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::FromContext> const&>(_DWORD *a1@<X8>)
{
  *a1 = 0;
  a1[20] = 0;
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_0,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_1,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_3>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::FromContext> const&>(_DWORD *a1@<X8>)
{
  *a1 = 0;
  a1[20] = 0;
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_0,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_1,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_3>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::FromContext> const&>(float ***a1@<X0>, uint64_t *a2@<X1>, _DWORD *a3@<X8>)
{
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::ApplyPresentationFill::ApplyPresentationFill(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_0,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_1,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_2,SVG::ApplyPresentationFill::(SVG::Recorder &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> const&,SVG::Presentation::Paint const&,double,BOOL,CGRect,CGRect,CGPath const*,SVG::ApplyPresentationState const&)::$_3>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,SVG::Presentation::None,SVG::Presentation::CurrentColor,SVG::Presentation::Color,SVG::Presentation::FromContext> const&>@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 16);
  v5[0] = 0;
  int v6 = 1;
  char v7 = &unk_1F1A74B80;
  v8[0] = 0;
  int v9 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::CF<CGColor *>,SVG::SetFill::CurrentColor,SVG::SetFill::PatternData>,(std::__variant_detail::_Trait)1>>((uint64_t)v8, (uint64_t)v5);
  int v10 = 9;
  uint64_t result = SVG::Recorder::append(v3, (uint64_t)&v7);
  if (v10 != -1) {
    uint64_t result = ((uint64_t (*)(char *, void **))off_1F1A75A18[v10])(&v11, &v7);
  }
  int v10 = -1;
  if (v6 != -1) {
    uint64_t result = ((uint64_t (*)(char *, _DWORD *))off_1F1A75A00[v6])(&v11, v5);
  }
  *a2 = 0;
  a2[20] = 1;
  return result;
}

void SVG::SetContextFill::~SetContextFill(SVG::SetContextFill *this)
{
  *(void *)this = &unk_1F1A74B80;
  uint64_t v2 = *((unsigned int *)this + 28);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A75A00[v2])(&v3, (char *)this + 8);
  }
  *((_DWORD *)this + 28) = -1;
}

{
  uint64_t v2;
  char v3;

  *(void *)this = &unk_1F1A74B80;
  uint64_t v2 = *((unsigned int *)this + 28);
  if (v2 != -1) {
    ((void (*)(char *, char *))off_1F1A75A00[v2])(&v3, (char *)this + 8);
  }
  *((_DWORD *)this + 28) = -1;
  MEMORY[0x1C18A3E80](this, 0x10A3C40C258EA78);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG21ApplyPresentationFill4NoneENS9_8FillPathENS9_8GradientEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSE_1EJSA_SB_SC_EEEEEEDcSG_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 72);
  if (v3 != -1) {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))off_1F1A75AB0[v3])(&v5, a2 + 48);
  }
  *(_DWORD *)(a2 + 72) = -1;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG21ApplyPresentationFill4NoneENS9_8FillPathENS9_8GradientEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 80);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    uint64_t result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A75AF0 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[20] = 0;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG21ApplyPresentationFill4NoneENS9_8FillPathENS9_8GradientEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 80);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *a2 = *a3;
      return result;
    }
    uint64_t result = ((uint64_t (*)(char *, _DWORD *))*(&off_1F1A75AF0 + v5))(&v6, v4);
  }
  *uint64_t v4 = *a3;
  v4[20] = 1;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG21ApplyPresentationFill4NoneENS9_8FillPathENS9_8GradientEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISD_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSH_1EJSA_SB_SC_EEEOSR_EEEDcSJ_DpT0_(uint64_t result, uint64_t a2, long long *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 80);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 2)
  {
    ((void (*)(char *, uint64_t))*(&off_1F1A75AF0 + v5))(&v16, v4);
LABEL_7:
    *(_DWORD *)(v4 + 8CGContextBeginTransparencyLayer(c, 0) = -1;
    long long v12 = *a3;
    long long v13 = a3[2];
    *(_OWORD *)(v4 + 16) = a3[1];
    *(_OWORD *)(v4 + 32) = v13;
    *(_OWORD *)uint64_t v4 = v12;
    *(unsigned char *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 72) = -1;
    uint64_t result = std::__variant_detail::__ctor<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>,(std::__variant_detail::_Trait)1>>(v4 + 48, (uint64_t)(a3 + 3));
    *(_DWORD *)(v4 + 8CGContextBeginTransparencyLayer(c, 0) = 2;
    return result;
  }
  long long v7 = *a3;
  long long v8 = a3[2];
  *(_OWORD *)(a2 + 16) = a3[1];
  *(_OWORD *)(a2 + 32) = v8;
  *(_OWORD *)a2 = v7;
  uint64_t v9 = a2 + 48;
  uint64_t v10 = *(unsigned int *)(a2 + 72);
  uint64_t v11 = *((unsigned int *)a3 + 18);
  if (v10 == -1)
  {
    if (v11 == -1) {
      return result;
    }
  }
  else if (v11 == -1)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))off_1F1A75AB0[v10])(&v15, v9);
    *(_DWORD *)(a2 + 72) = -1;
    return result;
  }
  uint64_t v14 = v9;
  return ((uint64_t (*)(uint64_t *))*(&off_1F1A75B20 + v11))(&v14);
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJNS_6vectorIN3SVG18DrawLinearGradientENS_9allocatorISA_EEEENS8_INS9_18DrawRadialGradientENSB_ISE_EEEEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISH_LNS0_6_TraitE1EEEEEvOT_EUlRSN_OT0_E_JRNS0_6__baseILSL_1EJSD_SG_EEEOSV_EEEDcSN_DpT0_(uint64_t *a1, void **a2, __n128 *a3)
{
  *(void *)&double result = std::__variant_detail::__assignment<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__assign_alt[abi:nn180100]<0ul,std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawLinearGradient>>(*a1, a2, a3).n128_u64[0];
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJNS_6vectorIN3SVG18DrawLinearGradientENS_9allocatorISA_EEEENS8_INS9_18DrawRadialGradientENSB_ISE_EEEEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISH_LNS0_6_TraitE1EEEEEvOT_EUlRSN_OT0_E_JRNS0_6__baseILSL_1EJSD_SG_EEEOSV_EEEDcSN_DpT0_(uint64_t *a1, void **a2, __n128 *a3)
{
  *(void *)&double result = std::__variant_detail::__assignment<std::__variant_detail::__traits<std::vector<SVG::DrawLinearGradient>,std::vector<SVG::DrawRadialGradient>>>::__assign_alt[abi:nn180100]<1ul,std::vector<SVG::DrawRadialGradient>,std::vector<SVG::DrawRadialGradient>>(*a1, a2, a3).n128_u64[0];
  return result;
}

uint64_t std::__throw_bad_function_call[abi:nn180100]()
{
  return SVG::ImageElement::ImageElement();
}

uint64_t SVG::ImageElement::ImageElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)a1 = &unk_1F1A745F0;
  *(void *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = 5;
  uint64_t v6 = MEMORY[0x1E4F1DAB8];
  long long v7 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)(a1 + 648) = *MEMORY[0x1E4F1DAB8];
  *(_OWORD *)(a1 + 664) = v7;
  *(_OWORD *)(a1 + 68CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)(v6 + 32);
  *(void *)(a1 + 696) = 0;
  *(_DWORD *)(a1 + 704) = 0;
  *(void *)(a1 + 712) = 0;
  *(_DWORD *)(a1 + 72CGContextBeginTransparencyLayer(c, 0) = 0;
  *(void *)(a1 + 728) = 0;
  *(_DWORD *)(a1 + 736) = 0;
  *(void *)(a1 + 744) = 0;
  *(_DWORD *)(a1 + 752) = 0;
  long long v8 = (CFTypeRef *)(a1 + 760);
  *(_OWORD *)(a1 + 76CGContextBeginTransparencyLayer(c, 0) = 0u;
  std::string::basic_string[abi:nn180100]<0>(data, "preserveAspectRatio");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v9 = SVG::Element::findInAttributeMap(a3, (uint64_t)data, (uint64_t)__p);
  if (v42 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v38) < 0) {
    operator delete(data[0]);
  }
  if (v9)
  {
    unint64_t v10 = SVG::PreserveAspectRatio::parsePreserveAspectRatio((uint64_t)(v9 + 64));
    if (v11) {
      *(void *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = v10;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(data, "transform");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  long long v12 = SVG::Element::findInAttributeMap(a3, (uint64_t)data, (uint64_t)__p);
  if (v42 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v38) < 0) {
    operator delete(data[0]);
  }
  if (v12)
  {
    *(void *)&long long v13 = -1;
    *((void *)&v13 + 1) = -1;
    long long v38 = v13;
    long long v39 = v13;
    *(_OWORD *)datCGFloat a = v13;
    unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
    SVG::parseTransform((uint64_t)(v12 + 64), (uint64_t)data);
    if ((_BYTE)v40)
    {
      long long v14 = v38;
      *(_OWORD *)(a1 + 648) = *(_OWORD *)data;
      *(_OWORD *)(a1 + 664) = v14;
      *(_OWORD *)(a1 + 68CGContextBeginTransparencyLayer(c, 0) = v39;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(data, "x");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v15 = SVG::Element::findInAttributeMap(a3, (uint64_t)data, (uint64_t)__p);
  if (v42 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v38) < 0) {
    operator delete(data[0]);
  }
  if (v15)
  {
    data[0] = (CFDataRef)-1;
    data[1] = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v38 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v15 + 64), (uint64_t)data);
    if ((_BYTE)v38) {
      *(_OWORD *)(a1 + 696) = *(_OWORD *)data;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(data, "y");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v16 = SVG::Element::findInAttributeMap(a3, (uint64_t)data, (uint64_t)__p);
  if (v42 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v38) < 0) {
    operator delete(data[0]);
  }
  if (v16)
  {
    data[0] = (CFDataRef)-1;
    data[1] = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v38 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v16 + 64), (uint64_t)data);
    if ((_BYTE)v38) {
      *(_OWORD *)(a1 + 712) = *(_OWORD *)data;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(data, "width");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint8x8_t v17 = SVG::Element::findInAttributeMap(a3, (uint64_t)data, (uint64_t)__p);
  if (v42 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v38) < 0) {
    operator delete(data[0]);
  }
  if (v17)
  {
    data[0] = (CFDataRef)-1;
    data[1] = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v38 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v17 + 64), (uint64_t)data);
    if ((_BYTE)v38) {
      *(_OWORD *)(a1 + 728) = *(_OWORD *)data;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(data, "height");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  unint64_t v18 = SVG::Element::findInAttributeMap(a3, (uint64_t)data, (uint64_t)__p);
  if (v42 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v38) < 0) {
    operator delete(data[0]);
  }
  if (v18)
  {
    data[0] = (CFDataRef)-1;
    data[1] = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v38 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v18 + 64), (uint64_t)data);
    if ((_BYTE)v38) {
      *(_OWORD *)(a1 + 744) = *(_OWORD *)data;
    }
  }
  std::string::basic_string[abi:nn180100]<0>(data, "href");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/1999/xlink");
  unint64_t v19 = SVG::Element::findInAttributeMap(a3, (uint64_t)data, (uint64_t)__p);
  if (v42 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v38) < 0) {
    operator delete(data[0]);
  }
  if (v19)
  {
    CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if ((char)v19[87] < 0)
    {
      int8x8_t v21 = (const UInt8 *)*((void *)v19 + 8);
      CFIndex v22 = *((void *)v19 + 9);
    }
    else
    {
      int8x8_t v21 = v19 + 64;
      CFIndex v22 = v19[87];
    }
    CFStringRef v23 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v21, v22, 0x8000100u, 1u);
    if (v23)
    {
      CFStringRef v24 = v23;
      CFURLRef v25 = CFURLCreateWithString(v20, v23, 0);
      if (*v8) {
        CFRelease(*v8);
      }
      *long long v8 = v25;
      CFRelease(v24);
    }
  }
  CFURLRef v26 = (const __CFURL *)*v8;
  if (*v8)
  {
    CFStringRef v27 = CFURLCopyScheme((CFURLRef)*v8);
    if (v27)
    {
      CFStringRef v28 = v27;
      ImageAtIndeCGFloat x = 0;
      if (CFEqual(v27, @"data"))
      {
        CFStringRef v30 = CFURLCopyResourceSpecifier(v26);
        CFRange v31 = CFStringFind(v30, @",", 0);
        if (v31.location == -1)
        {
          ImageAtIndeCGFloat x = 0;
          if (!v30) {
            goto LABEL_69;
          }
        }
        else
        {
          v43.length = CFStringGetLength(v30) - (v31.location + v31.length);
          v43.CFIndex location = v31.location + v31.length;
          CGPathRef v32 = (SVG *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v30, v43);
          data[0] = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
          SVG::decodeBase64(v32, data);
          unint64_t v33 = CGDataProviderCreateWithCFData(data[0]);
          uint64_t v34 = CGImageSourceCreateWithDataProvider(v33, 0);
          ImageAtIndeCGFloat x = CGImageSourceCreateImageAtIndex(v34, 0, 0);
          if (v34) {
            CFRelease(v34);
          }
          if (v33) {
            CFRelease(v33);
          }
          if (data[0]) {
            CFRelease(data[0]);
          }
          if (v32) {
            CFRelease(v32);
          }
          if (!v30) {
            goto LABEL_69;
          }
        }
        CFRelease(v30);
      }
LABEL_69:
      CFRelease(v28);
      goto LABEL_71;
    }
  }
  ImageAtIndeCGFloat x = 0;
LABEL_71:
  uint64_t v35 = *(const void **)(a1 + 768);
  if (v35) {
    CFRelease(v35);
  }
  *(void *)(a1 + 768) = ImageAtIndex;
  return a1;
}

CGAffineTransform *SVG::ImageElement::totalTransform@<X0>(SVG::ImageElement *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, uint64_t a3@<X8>)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double v7 = SVG::Length::computeValue((SVG::ImageElement *)((char *)this + 696), a2.size.width);
  double v8 = SVG::Length::computeValue((SVG::ImageElement *)((char *)this + 712), height);
  double v9 = SVG::Length::computeValue((SVG::ImageElement *)((char *)this + 728), width);
  double v10 = SVG::Length::computeValue((SVG::ImageElement *)((char *)this + 744), height);
  *(void *)&long long v11 = -1;
  *((void *)&v11 + 1) = -1;
  *(_OWORD *)&v19.CGFloat c = v11;
  *(_OWORD *)&v19.tCGFloat x = v11;
  *(_OWORD *)&v19.CGFloat a = v11;
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  CGFloat v12 = (double)CGImageGetWidth(*((CGImageRef *)this + 96));
  size_t v13 = CGImageGetHeight(*((CGImageRef *)this + 96));
  double result = SVG::computeViewBoxTransform(*((CGAffineTransform **)this + 80), (uint64_t)&v19, 0.0, 0.0, v12, (double)v13, v7, v8, v9, v10);
  char v15 = v20;
  if ((_BYTE)v20)
  {
    CGAffineTransform t1 = v19;
    long long v16 = *(_OWORD *)((char *)this + 664);
    *(_OWORD *)&v17.CGFloat a = *(_OWORD *)((char *)this + 648);
    *(_OWORD *)&v17.CGFloat c = v16;
    *(_OWORD *)&v17.tCGFloat x = *(_OWORD *)((char *)this + 680);
    double result = CGAffineTransformConcat((CGAffineTransform *)a3, &t1, &v17);
    char v15 = 1;
  }
  else
  {
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 48) = v15;
  return result;
}

uint64_t SVG::ImageElement::appendChild()
{
  return 0;
}

void SVG::ImageElement::~ImageElement(SVG::ImageElement *this)
{
  SVG::ImageElement::~ImageElement(this);
  JUMPOUT(0x1C18A3E80);
}

{
  const void *v2;
  const void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  char v10;
  char v11;
  char v12;
  char v13;

  *(void *)this = &unk_1F1A745F0;
  uint64_t v2 = (const void *)*((void *)this + 96);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 95);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *((unsigned int *)this + 128);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75B30 + v4))(&v9, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v5 = *((unsigned int *)this + 116);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75B48 + v5))(&v10, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v6 = *((unsigned int *)this + 82);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75B60 + v6))(&v11, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  double v7 = *((unsigned int *)this + 66);
  if (v7 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75B48 + v7))(&v12, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  double v8 = *((unsigned int *)this + 36);
  if (v8 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75B60 + v8))(&v13, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

char *SVG::convertString(SVG *this, id a2)
{
  double result = (char *)[a2 UTF8String];
  if (result)
  {
    return (char *)std::string::basic_string[abi:nn180100]<0>(this, result);
  }
  else
  {
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
  }
  return result;
}

void *__copy_helper_atomic_property_(void *result, uint64_t a2)
{
  *double result = 0;
  result[1] = 0;
  result[2] = 0;
  uint64_t v3 = *(const void **)a2;
  uint64_t v2 = *(void *)(a2 + 8);
  int64_t v4 = v2 - *(void *)a2;
  if (v2 != *(void *)a2)
  {
    uint64_t v5 = result;
    std::vector<std::reference_wrapper<SVG::Element>>::__vallocate[abi:nn180100](result, v4 >> 3);
    uint64_t v6 = (char *)v5[1];
    double result = memmove(v6, v3, v4);
    v5[1] = &v6[v4];
  }
  return result;
}

char *__assign_helper_atomic_property_(char *result, const void **a2)
{
  if (result != (char *)a2)
  {
    uint64_t v2 = result;
    uint64_t v3 = (char *)*a2;
    int64_t v4 = (char *)a2[1];
    int64_t v5 = v4 - (unsigned char *)*a2;
    unint64_t v6 = v5 >> 3;
    uint64_t v7 = *((void *)result + 2);
    double v8 = *(char **)result;
    if (v5 >> 3 <= (unint64_t)((v7 - *(void *)result) >> 3))
    {
      long long v11 = (void **)(result + 8);
      size_t v13 = (unsigned char *)*((void *)result + 1);
      unint64_t v14 = (v13 - v8) >> 3;
      if (v14 < v6)
      {
        char v15 = &v3[8 * v14];
        if (v13 != v8)
        {
          double result = (char *)memmove(*(void **)result, *a2, v13 - v8);
          double v8 = (char *)*v11;
        }
        int64_t v5 = v4 - v15;
        if (v4 == v15) {
          goto LABEL_20;
        }
        long long v16 = v8;
        CGAffineTransform v17 = v15;
        goto LABEL_19;
      }
    }
    else
    {
      if (v8)
      {
        *((void *)result + 1) = v8;
        operator delete(v8);
        uint64_t v7 = 0;
        *(void *)uint64_t v2 = 0;
        *((void *)v2 + 1) = 0;
        *((void *)v2 + 2) = 0;
      }
      if (v5 < 0) {
        abort();
      }
      uint64_t v9 = v7 >> 2;
      if (v7 >> 2 <= v6) {
        uint64_t v9 = v5 >> 3;
      }
      if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v10 = v9;
      }
      double result = std::vector<std::reference_wrapper<SVG::Element>>::__vallocate[abi:nn180100](v2, v10);
      CGFloat v12 = (char *)*((void *)v2 + 1);
      long long v11 = (void **)(v2 + 8);
      double v8 = v12;
    }
    if (v4 == v3)
    {
LABEL_20:
      *long long v11 = &v8[v5];
      return result;
    }
    long long v16 = v8;
    CGAffineTransform v17 = v3;
LABEL_19:
    double result = (char *)memmove(v16, v17, v5);
    goto LABEL_20;
  }
  return result;
}

void __copy_helper_atomic_property__52(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  uint64_t v4 = a1 + 32;
  std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>(a1, *(void *)(a2 + 8));
  int64_t v5 = *(uint64_t **)(a2 + 16);
  if (v5)
  {
    CFStringRef v28 = (void *)(a1 + 16);
    do
    {
      int v6 = *((char *)v5 + 39);
      if (v6 >= 0) {
        uint64_t v7 = v5 + 2;
      }
      else {
        uint64_t v7 = (uint64_t *)v5[2];
      }
      if (v6 >= 0) {
        unint64_t v8 = *((unsigned __int8 *)v5 + 39);
      }
      else {
        unint64_t v8 = v5[3];
      }
      unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)v29, v7, v8);
      unint64_t v10 = v9;
      unint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
        v12.i16[0] = vaddlv_u8(v12);
        unint64_t v13 = v12.u32[0];
        if (v12.u32[0] > 1uLL)
        {
          unint64_t v14 = v9;
          if (v9 >= v11) {
            unint64_t v14 = v9 % v11;
          }
        }
        else
        {
          unint64_t v14 = (v11 - 1) & v9;
        }
        char v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v14);
        if (v15)
        {
          for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
          {
            unint64_t v17 = *((void *)i + 1);
            if (v17 == v10)
            {
              if (std::equal_to<std::string>::operator()[abi:nn180100](v4, i + 16, (unsigned __int8 *)v5 + 16)) {
                goto LABEL_48;
              }
            }
            else
            {
              if (v13 > 1)
              {
                if (v17 >= v11) {
                  v17 %= v11;
                }
              }
              else
              {
                v17 &= v11 - 1;
              }
              if (v17 != v14) {
                break;
              }
            }
          }
        }
      }
      else
      {
        unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
      }
      v29[2] = 0xAAAAAAAAAAAAAA01;
      unint64_t v18 = (char *)operator new(0x58uLL);
      v29[1] = a1 + 16;
      *(void *)unint64_t v18 = 0;
      *((void *)v18 + 1) = v10;
      std::pair<std::string const,std::stack<std::string>>::pair[abi:nn180100]((std::string *)(v18 + 16), (long long *)v5 + 1);
      float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v20 = *(float *)(a1 + 32);
      if (!v11 || (float)(v20 * (float)v11) < v19)
      {
        BOOL v21 = (v11 & (v11 - 1)) != 0;
        if (v11 < 3) {
          BOOL v21 = 1;
        }
        unint64_t v22 = v21 | (2 * v11);
        unint64_t v23 = vcvtps_u32_f32(v19 / v20);
        if (v22 <= v23) {
          size_t v24 = v23;
        }
        else {
          size_t v24 = v22;
        }
        std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>(a1, v24);
        unint64_t v11 = *(void *)(a1 + 8);
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v10 >= v11) {
            unint64_t v14 = v10 % v11;
          }
          else {
            unint64_t v14 = v10;
          }
        }
        else
        {
          unint64_t v14 = (v11 - 1) & v10;
        }
      }
      uint64_t v25 = *(void *)a1;
      CFURLRef v26 = *(void **)(*(void *)a1 + 8 * v14);
      if (v26)
      {
        *(void *)unint64_t v18 = *v26;
      }
      else
      {
        *(void *)unint64_t v18 = *v28;
        *CFStringRef v28 = v18;
        *(void *)(v25 + 8 * v14) = v28;
        if (!*(void *)v18) {
          goto LABEL_47;
        }
        unint64_t v27 = *(void *)(*(void *)v18 + 8);
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v27 >= v11) {
            v27 %= v11;
          }
        }
        else
        {
          v27 &= v11 - 1;
        }
        CFURLRef v26 = (void *)(*(void *)a1 + 8 * v27);
      }
      *CFURLRef v26 = v18;
LABEL_47:
      v29[0] = 0;
      ++*(void *)(a1 + 24);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::stack<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::stack<std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)v29);
LABEL_48:
      int64_t v5 = (uint64_t *)*v5;
    }
    while (v5);
  }
}

void __assign_helper_atomic_property__53(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v58 = v2;
    uint64_t v59 = v3;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
    int64_t v5 = *(uint64_t **)(a2 + 16);
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
      uint64_t v8 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
      if (v8) {
        BOOL v9 = v5 == 0;
      }
      else {
        BOOL v9 = 1;
      }
      if (!v9)
      {
        while (1)
        {
          std::string::operator=((std::string *)(v8 + 16), (const std::string *)(v5 + 2));
          if ((uint64_t *)v8 != v5)
          {
            unint64_t v11 = v5[9];
            unint64_t v12 = v11 / 0xAA;
            uint64_t v13 = v5[6];
            if (v5[7] == v13)
            {
              unint64_t v14 = 0;
              unint64_t v17 = 0;
              long long v16 = (void *)(v13 + 8 * ((v5[10] + v11) / 0xAA));
            }
            else
            {
              unint64_t v14 = (std::string *)(*(void *)(v13 + 8 * (v11 / 0xAA)) + 24 * (v11 % 0xAA));
              unint64_t v15 = v5[10] + v11;
              long long v16 = (void *)(v13 + 8 * (v15 / 0xAA));
              unint64_t v17 = *v16 + 24 * (v15 % 0xAA);
            }
            unint64_t v18 = (std::string **)(v13 + 8 * v12);
            if ((std::string *)v17 == v14)
            {
              unint64_t v19 = 0;
              BOOL v21 = (uint64_t *)(v8 + 80);
LABEL_20:
              unint64_t v26 = *(void *)(v8 + 72);
              uint64_t v27 = *(void *)(v8 + 48);
              CFStringRef v28 = (std::string **)(v27 + 8 * (v26 / 0xAA));
              if (*(void *)(v8 + 56) == v27) {
                unint64_t v29 = 0;
              }
              else {
                unint64_t v29 = (unint64_t)&(*v28)[v26 % 0xAA];
              }
              unint64_t v54 = v18;
              double v55 = v14;
              std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>::operator+=[abi:nn180100](&v54, v19);
              CFStringRef v30 = v54;
              CFRange v31 = v55;
              unint64_t v54 = v28;
              double v55 = (std::string *)v29;
              std::__for_each_segment[abi:nn180100]<std::__deque_iterator<std::string,std::string const*,std::string const&,std::string const* const*,long,170l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<std::string,std::string const*,std::string const&,std::string const* const*,long,170l>,std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>>>(v18, v14, v30, v31, (uint64_t)&v54);
              unint64_t v32 = *(void *)(v8 + 72);
              uint64_t v33 = *(void *)(v8 + 80);
              uint64_t v34 = *(void *)(v8 + 48);
              uint64_t v35 = *(void *)(v8 + 56);
              BOOL v36 = (void *)(v34 + 8 * ((v32 + v33) / 0xAA));
              if (v35 == v34) {
                unint64_t v37 = 0;
              }
              else {
                unint64_t v37 = *v36 + 24 * ((v32 + v33) % 0xAA);
              }
              if (v55 != (std::string *)v37)
              {
                uint64_t v38 = ((char *)v55 - (char *)*v54) >> 3;
                uint64_t v39 = 170 * ((std::string **)v36 - v54)
                    - 0x5555555555555555 * ((uint64_t)(v37 - *v36) >> 3)
                    + 0x5555555555555555 * v38;
                if (v39 >= 1)
                {
                  unint64_t v40 = (std::string **)(v34 + 8 * (v32 / 0xAA));
                  if (v35 == v34) {
                    unint64_t v41 = 0;
                  }
                  else {
                    unint64_t v41 = (unint64_t)&(*v40)[v32 % 0xAA];
                  }
                  if (v55 == (std::string *)v41) {
                    uint64_t v44 = 0;
                  }
                  else {
                    uint64_t v44 = 170 * (v54 - v40)
                  }
                        - 0x5555555555555555 * v38
                        + 0x5555555555555555 * ((uint64_t)(v41 - (void)*v40) >> 3);
                  unint64_t v54 = v40;
                  double v55 = (std::string *)v41;
                  std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>::operator+=[abi:nn180100](&v54, v44);
                  long long v45 = v55;
                  if (v55 != (std::string *)v37)
                  {
                    long long v46 = v54;
                    do
                    {
                      if (SHIBYTE(v45->__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v45->__r_.__value_.__l.__data_);
                      }
                      if ((char *)++v45 - (char *)*v46 == 4080)
                      {
                        double v47 = v46[1];
                        ++v46;
                        long long v45 = v47;
                      }
                    }
                    while (v45 != (std::string *)v37);
                    uint64_t v33 = *v21;
                  }
                  *BOOL v21 = v33 - v39;
                  while (std::deque<std::string>::__maybe_remove_back_spare[abi:nn180100]((void *)(v8 + 40)))
                    ;
                }
              }
              goto LABEL_46;
            }
            unint64_t v19 = 170 * ((std::string **)v16 - v18)
                - 0x5555555555555555 * ((uint64_t)(v17 - *v16) >> 3)
                + 0x5555555555555555 * (((char *)v14 - (char *)*v18) >> 3);
            BOOL v21 = (uint64_t *)(v8 + 80);
            unint64_t v20 = *(void *)(v8 + 80);
            if (v20 >= v19) {
              goto LABEL_20;
            }
            unint64_t v54 = (std::string **)(v13 + 8 * v12);
            double v55 = v14;
            std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>::operator+=[abi:nn180100](&v54, v20);
            unint64_t v22 = *(void *)(v8 + 72);
            uint64_t v23 = *(void *)(v8 + 48);
            size_t v24 = (std::string **)(v23 + 8 * (v22 / 0xAA));
            if (*(void *)(v8 + 56) == v23) {
              unint64_t v25 = 0;
            }
            else {
              unint64_t v25 = (unint64_t)&(*v24)[v22 % 0xAA];
            }
            char v42 = v54;
            CFRange v43 = v55;
            unint64_t v54 = v24;
            double v55 = (std::string *)v25;
            std::__for_each_segment[abi:nn180100]<std::__deque_iterator<std::string,std::string const*,std::string const&,std::string const* const*,long,170l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<std::string,std::string const*,std::string const&,std::string const* const*,long,170l>,std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>>>(v18, v14, v42, v43, (uint64_t)&v54);
            std::deque<std::string>::__append_with_size[abi:nn180100]<std::__deque_iterator<std::string,std::string const*,std::string const&,std::string const* const*,long,170l>>((void *)(v8 + 40), v42, (long long *)v43, v19 - *v21);
          }
LABEL_46:
          unint64_t v10 = *(void **)v8;
          std::__hash_table<std::__hash_value_type<std::string,std::stack<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::stack<std::string>>>>::__node_insert_multi(a1, v8);
          int64_t v5 = (uint64_t *)*v5;
          if (v10) {
            BOOL v48 = v5 == 0;
          }
          else {
            BOOL v48 = 1;
          }
          uint64_t v8 = (uint64_t)v10;
          if (v48) {
            goto LABEL_51;
          }
        }
      }
      unint64_t v10 = (void *)v8;
LABEL_51:
      std::__hash_table<std::__hash_value_type<std::string,std::stack<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::stack<std::string>>>>::__deallocate_node(v10);
    }
    for (; v5; int64_t v5 = (uint64_t *)*v5)
    {
      unint64_t v56 = 0xAAAAAAAAAAAAAA01;
      CGFloat v49 = (char *)operator new(0x58uLL);
      double v55 = (std::string *)(a1 + 16);
      *(void *)CGFloat v49 = 0;
      *((void *)v49 + 1) = 0;
      CGFloat v50 = std::pair<std::string const,std::stack<std::string>>::pair[abi:nn180100]((std::string *)(v49 + 16), (long long *)v5 + 1);
      int v51 = v49[39];
      if (v51 >= 0) {
        CGFloat v52 = (uint64_t *)v50;
      }
      else {
        CGFloat v52 = (uint64_t *)*((void *)v49 + 2);
      }
      if (v51 >= 0) {
        unint64_t v53 = v49[39];
      }
      else {
        unint64_t v53 = *((void *)v49 + 3);
      }
      *((void *)v49 + 1) = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v57, v52, v53);
      std::__hash_table<std::__hash_value_type<std::string,std::stack<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::stack<std::string>>>>::__node_insert_multi(a1, (uint64_t)v49);
      unint64_t v54 = 0;
      std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::stack<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::stack<std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)&v54);
    }
  }
}

uint64_t *OTSVGDocumentCreate(std::mutex **a1, unint64_t a2, const __CFArray *a3)
{
  uint64_t v6 = *a1;
  std::mutex::lock(*a1);
  int8x8_t v7 = *(int8x8_t *)&(*a1)[1].__m_.__opaque[48];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v9 = a2;
      if (*(void *)&v7 <= a2) {
        unint64_t v9 = a2 % *(void *)&v7;
      }
    }
    else
    {
      unint64_t v9 = (*(void *)&v7 - 1) & a2;
    }
    unint64_t v10 = *(void **)(*(void *)&(*a1)[1].__m_.__opaque[40] + 8 * v9);
    if (v10)
    {
      unint64_t v11 = (void *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == a2)
          {
            if (v11[2] == a2)
            {
              if (v11[3]) {
                operator new();
              }
              unint64_t v19 = 0;
              std::mutex::unlock(v6);
              return v19;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v12 >= *(void *)&v7) {
                v12 %= *(void *)&v7;
              }
            }
            else
            {
              v12 &= *(void *)&v7 - 1;
            }
            if (v12 != v9) {
              break;
            }
          }
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  std::mutex::unlock(v6);
  if ((a2 & 0x8000000000000000) != 0) {
    return 0;
  }
  uint64_t v13 = *a1;
  if (*(void *)(*a1)[1].__m_.__opaque <= (int64_t)a2) {
    return 0;
  }
  uint64_t sig = v13[1].__m_.__sig;
  unsigned int Length = CFDataGetLength(*(CFDataRef *)&v13[1].__m_.__opaque[8]);
  unint64_t v16 = sig + 12 * a2;
  unsigned int v18 = *(_DWORD *)(v16 + 8);
  unint64_t v17 = (unsigned int *)(v16 + 8);
  if (*(void *)&(*a1)[1].__m_.__opaque[16] + bswap32(v18) + bswap32(*(v17 - 1)) > (uint64_t)Length) {
    return 0;
  }
  CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)&(*a1)[1].__m_.__opaque[8]);
  uint64_t v23 = CFDataCreate(v21, &BytePtr[*(void *)&(*a1)[1].__m_.__opaque[16] + bswap32(*(v17 - 1))], bswap32(*v17));
  unint64_t v19 = (uint64_t *)OTSVGDocumentCreateWithData(v23, *(unsigned int *)&(*a1)[1].__m_.__opaque[24], a3);
  size_t v24 = *a1;
  std::mutex::lock(*a1);
  unint64_t v25 = *a1;
  if (v19)
  {
    uint64_t v26 = *v19;
    uint64_t v27 = (std::__shared_weak_count *)v19[1];
    if (v27) {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v27 = 0;
  }
  unint64_t v28 = *(void *)&v25[1].__m_.__opaque[48];
  uint64_t v59 = v24;
  if (v28)
  {
    uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)v28);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      unint64_t v30 = a2;
      if (v28 <= a2) {
        unint64_t v30 = a2 % v28;
      }
    }
    else
    {
      unint64_t v30 = (v28 - 1) & a2;
    }
    CFRange v31 = *(void **)(*(void *)&v25[1].__m_.__opaque[40] + 8 * v30);
    if (v31)
    {
      for (uint64_t i = (void *)*v31; i; uint64_t i = (void *)*i)
      {
        unint64_t v33 = i[1];
        if (v33 == a2)
        {
          if (i[2] == a2) {
            goto LABEL_104;
          }
        }
        else
        {
          if (v29.u32[0] > 1uLL)
          {
            if (v33 >= v28) {
              v33 %= v28;
            }
          }
          else
          {
            v33 &= v28 - 1;
          }
          if (v33 != v30) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  }
  uint64_t v34 = v25 + 2;
  uint64_t v35 = operator new(0x28uLL);
  *uint64_t v35 = 0;
  v35[1] = a2;
  v35[2] = a2;
  v35[3] = v26;
  v35[4] = v27;
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  float v36 = (float)(unint64_t)(*(void *)v25[2].__m_.__opaque + 1);
  float v37 = *(float *)&v25[2].__m_.__opaque[8];
  if (!v28 || (float)(v37 * (float)v28) < v36)
  {
    BOOL v38 = 1;
    if (v28 >= 3) {
      BOOL v38 = (v28 & (v28 - 1)) != 0;
    }
    unint64_t v39 = v38 | (2 * v28);
    unint64_t v40 = vcvtps_u32_f32(v36 / v37);
    if (v39 <= v40) {
      int8x8_t prime = (int8x8_t)v40;
    }
    else {
      int8x8_t prime = (int8x8_t)v39;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v28 = *(void *)&v25[1].__m_.__opaque[48];
    if (*(void *)&prime > v28) {
      goto LABEL_59;
    }
    if (*(void *)&prime < v28)
    {
      unint64_t v48 = vcvtps_u32_f32((float)*(unint64_t *)v25[2].__m_.__opaque / *(float *)&v25[2].__m_.__opaque[8]);
      if (v28 < 3 || (uint8x8_t v49 = (uint8x8_t)vcnt_s8((int8x8_t)v28), v49.i16[0] = vaddlv_u8(v49), v49.u32[0] > 1uLL))
      {
        unint64_t v48 = std::__next_prime(v48);
      }
      else
      {
        uint64_t v50 = 1 << -(char)__clz(v48 - 1);
        if (v48 >= 2) {
          unint64_t v48 = v50;
        }
      }
      if (*(void *)&prime <= v48) {
        int8x8_t prime = (int8x8_t)v48;
      }
      if (*(void *)&prime >= v28)
      {
        unint64_t v28 = *(void *)&v25[1].__m_.__opaque[48];
      }
      else
      {
        if (prime)
        {
LABEL_59:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          char v42 = operator new(8 * *(void *)&prime);
          CFRange v43 = *(void **)&v25[1].__m_.__opaque[40];
          *(void *)&v25[1].__m_.__opaque[40] = v42;
          if (v43) {
            operator delete(v43);
          }
          uint64_t v44 = 0;
          *(int8x8_t *)&v25[1].__m_.__opaque[48] = prime;
          do
            *(void *)(*(void *)&v25[1].__m_.__opaque[40] + 8 * v44++) = 0;
          while (*(void *)&prime != v44);
          long long v45 = (void *)v34->__m_.__sig;
          if (v34->__m_.__sig)
          {
            unint64_t v46 = v45[1];
            uint8x8_t v47 = (uint8x8_t)vcnt_s8(prime);
            v47.i16[0] = vaddlv_u8(v47);
            if (v47.u32[0] > 1uLL)
            {
              if (v46 >= *(void *)&prime) {
                v46 %= *(void *)&prime;
              }
            }
            else
            {
              v46 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)&v25[1].__m_.__opaque[40] + 8 * v46) = v34;
            int v51 = (void *)*v45;
            if (*v45)
            {
              do
              {
                unint64_t v52 = v51[1];
                if (v47.u32[0] > 1uLL)
                {
                  if (v52 >= *(void *)&prime) {
                    v52 %= *(void *)&prime;
                  }
                }
                else
                {
                  v52 &= *(void *)&prime - 1;
                }
                if (v52 != v46)
                {
                  uint64_t v53 = *(void *)&v25[1].__m_.__opaque[40];
                  if (!*(void *)(v53 + 8 * v52))
                  {
                    *(void *)(v53 + 8 * v52) = v45;
                    goto LABEL_85;
                  }
                  void *v45 = *v51;
                  *int v51 = **(void **)(*(void *)&v25[1].__m_.__opaque[40] + 8 * v52);
                  **(void **)(*(void *)&v25[1].__m_.__opaque[40] + 8 * v52) = v51;
                  int v51 = v45;
                }
                unint64_t v52 = v46;
LABEL_85:
                long long v45 = v51;
                int v51 = (void *)*v51;
                unint64_t v46 = v52;
              }
              while (v51);
            }
          }
          unint64_t v28 = (unint64_t)prime;
          goto LABEL_89;
        }
        uint64_t v58 = *(void **)&v25[1].__m_.__opaque[40];
        *(void *)&v25[1].__m_.__opaque[40] = 0;
        if (v58) {
          operator delete(v58);
        }
        unint64_t v28 = 0;
        *(void *)&v25[1].__m_.__opaque[48] = 0;
      }
    }
LABEL_89:
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v28 <= a2) {
        unint64_t v30 = a2 % v28;
      }
      else {
        unint64_t v30 = a2;
      }
    }
    else
    {
      unint64_t v30 = (v28 - 1) & a2;
    }
  }
  uint64_t v54 = *(void *)&v25[1].__m_.__opaque[40];
  double v55 = *(void **)(v54 + 8 * v30);
  if (v55)
  {
    *uint64_t v35 = *v55;
    size_t v24 = v59;
  }
  else
  {
    uint64_t v56 = v34->__m_.__sig;
    *uint64_t v35 = v34->__m_.__sig;
    v34->__m_.__uint64_t sig = (uint64_t)v35;
    *(void *)(v54 + 8 * v3CGContextBeginTransparencyLayer(c, 0) = v34;
    size_t v24 = v59;
    if (!v56) {
      goto LABEL_103;
    }
    unint64_t v57 = *(void *)(v56 + 8);
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v57 >= v28) {
        v57 %= v28;
      }
    }
    else
    {
      v57 &= v28 - 1;
    }
    double v55 = (void *)(*(void *)&v25[1].__m_.__opaque[40] + 8 * v57);
  }
  *double v55 = v35;
LABEL_103:
  ++*(void *)v25[2].__m_.__opaque;
LABEL_104:
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  }
  std::mutex::unlock(v24);
  if (v23) {
    CFRelease(v23);
  }
  return v19;
}

uint64_t OTSVGDocumentCreateWithData(SVG *a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v35 = 0;
  int64_t v5 = [[_OTSVGParserDelegate alloc] initWithUnitsPerEm:a2];
  [(_OTSVGParserDelegate *)v5 setRoot:&v35];
  CFTypeRef cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  SVG::unzipData(a1, &cf);
  if (cf) {
    a1 = (SVG *)cf;
  }
  uint64_t v6 = (void *)[objc_alloc(MEMORY[0x1E4F29250]) initWithData:a1];
  [v6 setShouldProcessNamespaces:1];
  [v6 setShouldReportNamespacePrefixes:1];
  [v6 setDelegate:v5];
  [v6 parse];
  if (![(_OTSVGParserDelegate *)v5 errorOccurred])
  {
    int8x8_t v7 = v35;
    if (v35)
    {
      *(_OWORD *)CFRange v31 = 0u;
      *(_OWORD *)unint64_t v32 = 0u;
      unint64_t v33 = 0xAAAAAAAA3F800000;
      SVG::populateIdMapWithRealIds((uint64_t)v31, (uint64_t)v35);
      SVG::populateIdMapWithFakeIds((uint64_t)v31, (uint64_t)v7, 0);
      memset(v29, 0, sizeof(v29));
      unint64_t v30 = 0xAAAAAAAA3F800000;
      SVG::populateReferenceMap((uint64_t)v29, v31, v35);
      *(_OWORD *)uint64_t v26 = 0u;
      *(_OWORD *)uint64_t v27 = 0u;
      unint64_t v28 = 0xAAAAAAAA3F800000;
      SVG::Presentation::defaultPresentation((uint64_t)v53);
      SVG::Presentation::defaultPresentation((uint64_t)v39);
      SVG::populateDirectlyInheritedPresentationMap((uint64_t *)v26, (const SVG::Presentation *)v53, (const SVG::Presentation *)v39, (unint64_t)v35);
      if (v52 != -1) {
        ((void (*)(void **, uint64_t *))*(&off_1F1A75BA8 + v52))(v22, &v51);
      }
      unsigned int v52 = -1;
      if (v50 != -1) {
        ((void (*)(void **, uint64_t *))*(&off_1F1A75B90 + v50))(v22, &v49);
      }
      unsigned int v50 = -1;
      if (v48 != -1) {
        ((void (*)(void **, uint64_t *))*(&off_1F1A75B78 + v48))(v22, &v47);
      }
      unsigned int v48 = -1;
      if (v46 != -1) {
        ((void (*)(void **, uint64_t *))*(&off_1F1A75B90 + v46))(v22, &v45);
      }
      unsigned int v46 = -1;
      if (v41 != -1) {
        ((void (*)(void **, void *))*(&off_1F1A75B78 + v41))(v22, v40);
      }
      if (v63 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75BA8 + v63))(v39, v62);
      }
      unsigned int v63 = -1;
      if (v61 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75B90 + v61))(v39, v60);
      }
      unsigned int v61 = -1;
      if (v59 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75B78 + v59))(v39, v58);
      }
      unsigned int v59 = -1;
      if (v57 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75B90 + v57))(v39, v56);
      }
      unsigned int v57 = -1;
      if (v55 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75B78 + v55))(v39, v54);
      }
      *(_OWORD *)unint64_t v22 = 0u;
      *(_OWORD *)uint64_t v23 = 0u;
      int v24 = 1065353216;
      int v25 = -1431655766;
      SVG::populateGradientMap((uint64_t *)v22, v29, v26, a3, v35);
      *(_OWORD *)unsigned int v18 = 0u;
      *(_OWORD *)unint64_t v19 = 0u;
      int v20 = 1065353216;
      int v21 = -1431655766;
      *(_OWORD *)long long __p = 0u;
      *(_OWORD *)unint64_t v15 = 0u;
      int v16 = 1065353216;
      int v17 = -1431655766;
      SVG::Presentation::defaultPresentation((uint64_t)v53);
      uint8x8_t v8 = v35;
      CFArrayRef v37 = a3;
      memset(v36, 170, sizeof(v36));
      SVG::analyzeDependencies((uint64_t)v29, (unint64_t)v26, (uint64_t)v53, v35, (uint64_t)v36);
      unint64_t v10 = (unsigned int *)v36[0];
      unint64_t v9 = (unsigned int *)v36[1];
      if (v36[0] != v36[1])
      {
        do
        {
          v39[0] = &v37;
          v39[1] = v29;
          v39[2] = v22;
          uint64_t v39[3] = v18;
          v39[4] = __p;
          v39[5] = v26;
          v39[6] = v8;
          v39[7] = &v37;
          v40[0] = v29;
          v40[1] = v22;
          unint64_t v41 = v18;
          char v42 = __p;
          CFRange v43 = v26;
          uint64_t v44 = v8;
          uint64_t v11 = v10[2];
          if (v11 == -1) {
            std::__throw_bad_variant_access[abi:nn180100]();
          }
          BOOL v38 = v39;
          ((void (*)(void **, unsigned int *))*(&off_1F1A75BC0 + v11))(&v38, v10);
          v10 += 4;
        }
        while (v10 != v9);
        unint64_t v10 = (unsigned int *)v36[0];
      }
      if (v10)
      {
        v36[1] = v10;
        operator delete(v10);
      }
      if (v63 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75BA8 + v63))(v39, v62);
      }
      unsigned int v63 = -1;
      if (v61 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75B90 + v61))(v39, v60);
      }
      unsigned int v61 = -1;
      if (v59 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75B78 + v59))(v39, v58);
      }
      unsigned int v59 = -1;
      if (v57 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75B90 + v57))(v39, v56);
      }
      unsigned int v57 = -1;
      if (v55 != -1) {
        ((void (*)(void *, unsigned char *))*(&off_1F1A75B78 + v55))(v39, v54);
      }
      operator new();
    }
  }

  if (cf) {
    CFRelease(cf);
  }

  unint64_t v12 = v35;
  uint64_t v35 = 0;
  if (v12) {
    (*(void (**)(void *))(*v12 + 8))(v12);
  }
  return 0;
}

void SVG::populateReferenceMap(uint64_t a1, void *a2, void *a3)
{
  if (v6)
  {
    int8x8_t v7 = v6;
    if (*((_DWORD *)v6 + 20) == 2 && *((unsigned char *)v6 + 72) != 0)
    {
      CFURLRef v9 = v6[8];
      if (v9)
      {
        *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)long long __p = v10;
        long long v40 = v10;
        SVG::extractValidFragment((SVG *)__p, v9);
        if (BYTE8(v40))
        {
          uint64_t v11 = std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>(a2, (uint64_t)__p);
          if (v11) {
            std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::__emplace_unique_key_args<__CFURL const*,__CFURL const* const&,std::reference_wrapper<SVG::Element> const&>(a1, (unint64_t)v9, (uint64_t)v9, *((void *)v11 + 5));
          }
          if (BYTE8(v40) && SBYTE7(v40) < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }
    if (*((_DWORD *)v7 + 66) == 2 && *((unsigned char *)v7 + 256) != 0)
    {
      CFURLRef v13 = v7[31];
      if (v13)
      {
        *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)long long __p = v14;
        long long v40 = v14;
        SVG::extractValidFragment((SVG *)__p, v13);
        if (BYTE8(v40))
        {
          unint64_t v15 = std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>(a2, (uint64_t)__p);
          if (v15) {
            std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::__emplace_unique_key_args<__CFURL const*,__CFURL const* const&,std::reference_wrapper<SVG::Element> const&>(a1, (unint64_t)v13, (uint64_t)v13, *((void *)v15 + 5));
          }
          if (BYTE8(v40) && SBYTE7(v40) < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }
    if (*((_DWORD *)v7 + 50) == 2 && *((_DWORD *)v7 + 48) == 3)
    {
      CFURLRef v17 = v7[20];
      if (v17)
      {
        *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)long long __p = v18;
        long long v40 = v18;
        SVG::extractValidFragment((SVG *)__p, v17);
        if (BYTE8(v40))
        {
          unint64_t v19 = std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>(a2, (uint64_t)__p);
          if (v19) {
            std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::__emplace_unique_key_args<__CFURL const*,__CFURL const* const&,std::reference_wrapper<SVG::Element> const&>(a1, (unint64_t)v7[20], (uint64_t)v7[20], *((void *)v19 + 5));
          }
          if (BYTE8(v40) && SBYTE7(v40) < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }
    if (*((_DWORD *)v7 + 100) == 2 && *((_DWORD *)v7 + 98) == 3)
    {
      CFURLRef v21 = v7[45];
      if (v21)
      {
        *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)long long __p = v22;
        long long v40 = v22;
        SVG::extractValidFragment((SVG *)__p, v21);
        if (BYTE8(v40))
        {
          uint64_t v23 = std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>(a2, (uint64_t)__p);
          if (v23) {
            std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::__emplace_unique_key_args<__CFURL const*,__CFURL const* const&,std::reference_wrapper<SVG::Element> const&>(a1, (unint64_t)v7[45], (uint64_t)v7[45], *((void *)v23 + 5));
          }
          if (BYTE8(v40) && SBYTE7(v40) < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }
  }
  if (v24)
  {
    CFURLRef v25 = (const __CFURL *)*((void *)v24 + 94);
    if (v25)
    {
      *(void *)&long long v26 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)long long __p = v26;
      long long v40 = v26;
      SVG::extractValidFragment((SVG *)__p, v25);
      if (BYTE8(v40))
      {
        uint64_t v27 = std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>(a2, (uint64_t)__p);
        if (v27) {
          std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::__emplace_unique_key_args<__CFURL const*,__CFURL const* const&,std::reference_wrapper<SVG::Element> const&>(a1, (unint64_t)v25, (uint64_t)v25, *((void *)v27 + 5));
        }
        if (BYTE8(v40) && SBYTE7(v40) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  if (v28)
  {
    CFURLRef v29 = (const __CFURL *)*((void *)v28 + 80);
    if (v29)
    {
      *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)long long __p = v30;
      long long v40 = v30;
      SVG::extractValidFragment((SVG *)__p, v29);
      if (BYTE8(v40))
      {
        CFRange v31 = std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>(a2, (uint64_t)__p);
        if (v31) {
          std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::__emplace_unique_key_args<__CFURL const*,__CFURL const* const&,std::reference_wrapper<SVG::Element> const&>(a1, (unint64_t)v29, (uint64_t)v29, *((void *)v31 + 5));
        }
        if (BYTE8(v40) && SBYTE7(v40) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  if (v32)
  {
    CFURLRef v33 = (const __CFURL *)*((void *)v32 + 108);
    if (v33)
    {
      *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)long long __p = v34;
      long long v40 = v34;
      SVG::extractValidFragment((SVG *)__p, v33);
      if (BYTE8(v40))
      {
        uint64_t v35 = std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>(a2, (uint64_t)__p);
        if (v35) {
          std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::__emplace_unique_key_args<__CFURL const*,__CFURL const* const&,std::reference_wrapper<SVG::Element> const&>(a1, (unint64_t)v33, (uint64_t)v33, *((void *)v35 + 5));
        }
        if (BYTE8(v40) && SBYTE7(v40) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  CFArrayRef v37 = (uint64_t *)a3[4];
  float v36 = (uint64_t *)a3[5];
  while (v37 != v36)
  {
    uint64_t v38 = *v37++;
    SVG::populateReferenceMap(a1, a2, v38);
  }
}

void SVG::populateDirectlyInheritedPresentationMap(uint64_t *a1, const SVG::Presentation *a2, const SVG::Presentation *a3, unint64_t a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!v8)
  {
    CFURLRef v17 = *(uint64_t **)(a4 + 32);
    int v16 = *(uint64_t **)(a4 + 40);
    while (v17 != v16)
    {
      uint64_t v18 = *v17++;
      SVG::populateDirectlyInheritedPresentationMap(a1, a2, a3, v18);
    }
    return;
  }
  CFURLRef v9 = v8;
  memcpy(__dst, &unk_1BF1DB2D0, sizeof(__dst));
  SVG::Presentation::inherit(v9, a2, a3, __dst);
  unint64_t v10 = 0x9DDFEA08EB382D69 * (((((a4 >> 3) & 0x3FFFFFF) << 6) | 8) ^ HIDWORD(a4));
  unint64_t v11 = 0x9DDFEA08EB382D69 * (HIDWORD(a4) ^ (v10 >> 47) ^ v10);
  unint64_t v12 = 0x9DDFEA08EB382D69 * (v11 ^ (v11 >> 47));
  unint64_t v13 = a1[1];
  if (v13)
  {
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v15 = 0x9DDFEA08EB382D69 * (v11 ^ (v11 >> 47));
      if (v12 >= v13) {
        unint64_t v15 = v12 % v13;
      }
    }
    else
    {
      unint64_t v15 = (v13 - 1) & v12;
    }
    unint64_t v19 = *(void **)(*a1 + 8 * v15);
    if (v19)
    {
      for (uint64_t i = (void *)*v19; i; uint64_t i = (void *)*i)
      {
        unint64_t v21 = i[1];
        if (v21 == v12)
        {
          if (i[2] == a4) {
            goto LABEL_79;
          }
        }
        else
        {
          if (v14.u32[0] > 1uLL)
          {
            if (v21 >= v13) {
              v21 %= v13;
            }
          }
          else
          {
            v21 &= v13 - 1;
          }
          if (v21 != v15) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  }
  unsigned int v55 = a1 + 2;
  long long v22 = (char *)operator new(0x258uLL);
  long long v23 = __dst[1];
  *(_OWORD *)(v22 + 24) = __dst[0];
  *(void *)long long v22 = 0;
  *((void *)v22 + 1) = v12;
  *((void *)v22 + 2) = a4;
  *(_OWORD *)(v22 + 4CGContextBeginTransparencyLayer(c, 0) = v23;
  *(_OWORD *)(v22 + 56) = __dst[2];
  *((void *)v22 + 9) = *(void *)&__dst[3];
  v22[88] = 0;
  *((_DWORD *)v22 + 26) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(v22 + 88), (uint64_t)&__dst[4]);
  long long v24 = *(_OWORD *)((char *)&__dst[6] + 8);
  *((_OWORD *)v22 + 7) = *(_OWORD *)((char *)&__dst[5] + 8);
  *((_OWORD *)v22 + 8) = v24;
  *((_OWORD *)v22 + 9) = *(_OWORD *)((char *)&__dst[7] + 8);
  *((_DWORD *)v22 + 4CGContextBeginTransparencyLayer(c, 0) = DWORD2(__dst[8]);
  v22[176] = 0;
  *((_DWORD *)v22 + 56) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(v22 + 176), (uint64_t)&__dst[9] + 8);
  long long v25 = __dst[14];
  *(_OWORD *)(v22 + 232) = __dst[13];
  *(_OWORD *)(v22 + 248) = v25;
  v22[272] = 0;
  *((_DWORD *)v22 + 72) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(v22 + 272), (uint64_t)&__dst[15] + 8);
  long long v26 = __dst[20];
  *(_OWORD *)(v22 + 328) = __dst[19];
  *(_OWORD *)(v22 + 344) = v26;
  *((void *)v22 + 45) = *(void *)&__dst[21];
  long long v27 = __dst[18];
  *(_OWORD *)(v22 + 296) = __dst[17];
  *(_OWORD *)(v22 + 312) = v27;
  v22[376] = 0;
  *((_DWORD *)v22 + 106) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(v22 + 376), (uint64_t)&__dst[22]);
  v22[440] = 0;
  *((_DWORD *)v22 + 118) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1> const&>((uint64_t)(v22 + 440), (uint64_t)&__dst[26]);
  long long v28 = *(_OWORD *)((char *)&__dst[33] + 8);
  *((_OWORD *)v22 + 34) = *(_OWORD *)((char *)&__dst[32] + 8);
  *((_OWORD *)v22 + 35) = v28;
  *((_OWORD *)v22 + 36) = *(_OWORD *)((char *)&__dst[34] + 8);
  *((void *)v22 + 74) = *((void *)&__dst[35] + 1);
  long long v29 = *(_OWORD *)((char *)&__dst[29] + 8);
  *((_OWORD *)v22 + 3CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)((char *)&__dst[28] + 8);
  *((_OWORD *)v22 + 31) = v29;
  long long v30 = *(_OWORD *)((char *)&__dst[31] + 8);
  *((_OWORD *)v22 + 32) = *(_OWORD *)((char *)&__dst[30] + 8);
  *((_OWORD *)v22 + 33) = v30;
  float v31 = (float)(unint64_t)(a1[3] + 1);
  float v32 = *((float *)a1 + 8);
  if (!v13 || (float)(v32 * (float)v13) < v31)
  {
    BOOL v33 = v13 < 3 || (v13 & (v13 - 1)) != 0;
    unint64_t v34 = v33 | (2 * v13);
    unint64_t v35 = vcvtps_u32_f32(v31 / v32);
    if (v34 <= v35) {
      int8x8_t prime = (int8x8_t)v35;
    }
    else {
      int8x8_t prime = (int8x8_t)v34;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v13 = a1[1];
    if (*(void *)&prime > v13) {
      goto LABEL_35;
    }
    if (*(void *)&prime < v13)
    {
      unint64_t v43 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v13 < 3 || (uint8x8_t v44 = (uint8x8_t)vcnt_s8((int8x8_t)v13), v44.i16[0] = vaddlv_u8(v44), v44.u32[0] > 1uLL))
      {
        unint64_t v43 = std::__next_prime(v43);
      }
      else
      {
        uint64_t v45 = 1 << -(char)__clz(v43 - 1);
        if (v43 >= 2) {
          unint64_t v43 = v45;
        }
      }
      if (*(void *)&prime <= v43) {
        int8x8_t prime = (int8x8_t)v43;
      }
      if (*(void *)&prime >= v13)
      {
        unint64_t v13 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_35:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          CFArrayRef v37 = operator new(8 * *(void *)&prime);
          uint64_t v38 = (void *)*a1;
          *a1 = (uint64_t)v37;
          if (v38) {
            operator delete(v38);
          }
          uint64_t v39 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v39++) = 0;
          while (*(void *)&prime != v39);
          long long v40 = (void *)*v55;
          if (*v55)
          {
            unint64_t v41 = v40[1];
            uint8x8_t v42 = (uint8x8_t)vcnt_s8(prime);
            v42.i16[0] = vaddlv_u8(v42);
            if (v42.u32[0] > 1uLL)
            {
              if (v41 >= *(void *)&prime) {
                v41 %= *(void *)&prime;
              }
            }
            else
            {
              v41 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v41) = v55;
            unsigned int v46 = (void *)*v40;
            if (*v40)
            {
              do
              {
                unint64_t v47 = v46[1];
                if (v42.u32[0] > 1uLL)
                {
                  if (v47 >= *(void *)&prime) {
                    v47 %= *(void *)&prime;
                  }
                }
                else
                {
                  v47 &= *(void *)&prime - 1;
                }
                if (v47 != v41)
                {
                  if (!*(void *)(*a1 + 8 * v47))
                  {
                    *(void *)(*a1 + 8 * v47) = v40;
                    goto LABEL_60;
                  }
                  *long long v40 = *v46;
                  *unsigned int v46 = **(void **)(*a1 + 8 * v47);
                  **(void **)(*a1 + 8 * v47) = v46;
                  unsigned int v46 = v40;
                }
                unint64_t v47 = v41;
LABEL_60:
                long long v40 = v46;
                unsigned int v46 = (void *)*v46;
                unint64_t v41 = v47;
              }
              while (v46);
            }
          }
          unint64_t v13 = (unint64_t)prime;
          goto LABEL_64;
        }
        uint64_t v54 = (void *)*a1;
        *a1 = 0;
        if (v54) {
          operator delete(v54);
        }
        unint64_t v13 = 0;
        a1[1] = 0;
      }
    }
LABEL_64:
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v12 >= v13) {
        unint64_t v15 = v12 % v13;
      }
      else {
        unint64_t v15 = v12;
      }
    }
    else
    {
      unint64_t v15 = (v13 - 1) & v12;
    }
  }
  uint64_t v48 = *a1;
  uint64_t v49 = *(void **)(*a1 + 8 * v15);
  if (v49)
  {
    *(void *)long long v22 = *v49;
  }
  else
  {
    *(void *)long long v22 = *v55;
    *unsigned int v55 = v22;
    *(void *)(v48 + 8 * v15) = v55;
    if (!*(void *)v22) {
      goto LABEL_78;
    }
    unint64_t v50 = *(void *)(*(void *)v22 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v50 >= v13) {
        v50 %= v13;
      }
    }
    else
    {
      v50 &= v13 - 1;
    }
    uint64_t v49 = (void *)(*a1 + 8 * v50);
  }
  *uint64_t v49 = v22;
LABEL_78:
  ++a1[3];
LABEL_79:
  unsigned int v52 = *(uint64_t **)(a4 + 32);
  uint64_t v51 = *(uint64_t **)(a4 + 40);
  while (v52 != v51)
  {
    uint64_t v53 = *v52++;
    SVG::populateDirectlyInheritedPresentationMap(a1, __dst, a3, v53);
  }
  if (LODWORD(__dst[28]) != -1) {
    ((void (*)(char *, _OWORD *))*(&off_1F1A75BA8 + LODWORD(__dst[28])))(&v56, &__dst[26]);
  }
  LODWORD(__dst[28]) = -1;
  if (LODWORD(__dst[25]) != -1) {
    ((void (*)(char *, _OWORD *))*(&off_1F1A75B90 + LODWORD(__dst[25])))(&v56, &__dst[22]);
  }
  LODWORD(__dst[25]) = -1;
  if (DWORD2(__dst[16]) != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75B78 + DWORD2(__dst[16])))(&v56, (char *)&__dst[15] + 8);
  }
  DWORD2(__dst[16]) = -1;
  if (DWORD2(__dst[12]) != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75B90 + DWORD2(__dst[12])))(&v56, (char *)&__dst[9] + 8);
  }
  DWORD2(__dst[12]) = -1;
  if (LODWORD(__dst[5]) != -1) {
    ((void (*)(char *, _OWORD *))*(&off_1F1A75B78 + LODWORD(__dst[5])))(&v56, &__dst[4]);
  }
}

void SVG::populateGradientMap(uint64_t *a1, void *a2, void *a3, const __CFArray *a4, void *a5)
{
  if (!v10) {
    goto LABEL_78;
  }
  unint64_t v11 = (unint64_t)v10;
  CFTypeRef cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  SVG::GradientElement::getGradient((unint64_t)v10, a2, a3, a4, (CGGradientRef *)&cf);
  CFTypeRef v12 = cf;
  if (!cf) {
    goto LABEL_78;
  }
  unint64_t v13 = 0x9DDFEA08EB382D69 * (((8 * v11) + 8) ^ HIDWORD(v11));
  unint64_t v14 = 0x9DDFEA08EB382D69 * (HIDWORD(v11) ^ (v13 >> 47) ^ v13);
  unint64_t v15 = 0x9DDFEA08EB382D69 * (v14 ^ (v14 >> 47));
  unint64_t v16 = a1[1];
  if (v16)
  {
    uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
    v17.i16[0] = vaddlv_u8(v17);
    if (v17.u32[0] > 1uLL)
    {
      unint64_t v18 = 0x9DDFEA08EB382D69 * (v14 ^ (v14 >> 47));
      if (v15 >= v16) {
        unint64_t v18 = v15 % v16;
      }
    }
    else
    {
      unint64_t v18 = (v16 - 1) & v15;
    }
    unint64_t v19 = *(void **)(*a1 + 8 * v18);
    if (v19)
    {
      for (uint64_t i = (void *)*v19; i; uint64_t i = (void *)*i)
      {
        unint64_t v21 = i[1];
        if (v21 == v15)
        {
          if (i[2] == v11) {
            goto LABEL_76;
          }
        }
        else
        {
          if (v17.u32[0] > 1uLL)
          {
            if (v21 >= v16) {
              v21 %= v16;
            }
          }
          else
          {
            v21 &= v16 - 1;
          }
          if (v21 != v18) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  }
  uint64_t v54 = a1 + 2;
  long long v22 = operator new(0x20uLL);
  *long long v22 = 0;
  v22[1] = v15;
  CFTypeRef cf = 0;
  v22[2] = v11;
  v22[3] = v12;
  float v23 = (float)(unint64_t)(a1[3] + 1);
  float v24 = *((float *)a1 + 8);
  if (!v16 || (float)(v24 * (float)v16) < v23)
  {
    BOOL v25 = 1;
    if (v16 >= 3) {
      BOOL v25 = (v16 & (v16 - 1)) != 0;
    }
    unint64_t v26 = v25 | (2 * v16);
    unint64_t v27 = vcvtps_u32_f32(v23 / v24);
    if (v26 <= v27) {
      int8x8_t v28 = (int8x8_t)v27;
    }
    else {
      int8x8_t v28 = (int8x8_t)v26;
    }
    if (*(void *)&v28 == 1)
    {
      int8x8_t v28 = (int8x8_t)2;
    }
    else if ((*(void *)&v28 & (*(void *)&v28 - 1)) != 0)
    {
      size_t v29 = (size_t)v28;
      long long v30 = v22;
      size_t prime = std::__next_prime(v29);
      long long v22 = v30;
      int8x8_t v28 = (int8x8_t)prime;
      unint64_t v16 = a1[1];
    }
    if (*(void *)&v28 > v16) {
      goto LABEL_32;
    }
    if (*(void *)&v28 < v16)
    {
      unint64_t v39 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v16 < 3 || (uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v16), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
      {
        uint64_t v51 = v22;
        unint64_t v39 = std::__next_prime(v39);
        long long v22 = v51;
      }
      else
      {
        uint64_t v41 = 1 << -(char)__clz(v39 - 1);
        if (v39 >= 2) {
          unint64_t v39 = v41;
        }
      }
      if (*(void *)&v28 <= v39) {
        int8x8_t v28 = (int8x8_t)v39;
      }
      if (*(void *)&v28 >= v16)
      {
        unint64_t v16 = a1[1];
      }
      else
      {
        if (v28)
        {
LABEL_32:
          if (*(void *)&v28 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          float v32 = v22;
          BOOL v33 = operator new(8 * *(void *)&v28);
          unint64_t v34 = (void *)*a1;
          *a1 = (uint64_t)v33;
          if (v34) {
            operator delete(v34);
          }
          uint64_t v35 = 0;
          a1[1] = (uint64_t)v28;
          long long v22 = v32;
          do
            *(void *)(*a1 + 8 * v35++) = 0;
          while (*(void *)&v28 != v35);
          float v36 = (void *)*v54;
          if (*v54)
          {
            unint64_t v37 = v36[1];
            uint8x8_t v38 = (uint8x8_t)vcnt_s8(v28);
            v38.i16[0] = vaddlv_u8(v38);
            if (v38.u32[0] > 1uLL)
            {
              if (v37 >= *(void *)&v28) {
                v37 %= *(void *)&v28;
              }
            }
            else
            {
              v37 &= *(void *)&v28 - 1;
            }
            *(void *)(*a1 + 8 * v37) = v54;
            uint8x8_t v42 = (void *)*v36;
            if (*v36)
            {
              do
              {
                unint64_t v43 = v42[1];
                if (v38.u32[0] > 1uLL)
                {
                  if (v43 >= *(void *)&v28) {
                    v43 %= *(void *)&v28;
                  }
                }
                else
                {
                  v43 &= *(void *)&v28 - 1;
                }
                if (v43 != v37)
                {
                  if (!*(void *)(*a1 + 8 * v43))
                  {
                    *(void *)(*a1 + 8 * v43) = v36;
                    goto LABEL_57;
                  }
                  *float v36 = *v42;
                  *uint8x8_t v42 = **(void **)(*a1 + 8 * v43);
                  **(void **)(*a1 + 8 * v43) = v42;
                  uint8x8_t v42 = v36;
                }
                unint64_t v43 = v37;
LABEL_57:
                float v36 = v42;
                uint8x8_t v42 = (void *)*v42;
                unint64_t v37 = v43;
              }
              while (v42);
            }
          }
          unint64_t v16 = (unint64_t)v28;
          goto LABEL_61;
        }
        unsigned int v52 = (void *)*a1;
        *a1 = 0;
        if (v52)
        {
          uint64_t v53 = v22;
          operator delete(v52);
          long long v22 = v53;
        }
        unint64_t v16 = 0;
        a1[1] = 0;
      }
    }
LABEL_61:
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v15 >= v16) {
        unint64_t v18 = v15 % v16;
      }
      else {
        unint64_t v18 = v15;
      }
    }
    else
    {
      unint64_t v18 = (v16 - 1) & v15;
    }
  }
  uint64_t v44 = *a1;
  uint64_t v45 = *(void **)(*a1 + 8 * v18);
  if (v45)
  {
    *long long v22 = *v45;
  }
  else
  {
    unsigned int v46 = (void *)*v54;
    *long long v22 = *v54;
    *uint64_t v54 = v22;
    *(void *)(v44 + 8 * v18) = v54;
    if (!v46) {
      goto LABEL_75;
    }
    unint64_t v47 = v46[1];
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v47 >= v16) {
        v47 %= v16;
      }
    }
    else
    {
      v47 &= v16 - 1;
    }
    uint64_t v45 = (void *)(*a1 + 8 * v47);
  }
  void *v45 = v22;
LABEL_75:
  ++a1[3];
  CFTypeRef v12 = cf;
LABEL_76:
  if (v12) {
    CFRelease(v12);
  }
LABEL_78:
  uint64_t v49 = (uint64_t *)a5[4];
  uint64_t v48 = (uint64_t *)a5[5];
  while (v49 != v48)
  {
    uint64_t v50 = *v49++;
    SVG::populateGradientMap(a1, a2, a3, a4, v50);
  }
}

void OTSVGDocumentEnumerateIDs(uint64_t a1, void *a2)
{
  CFURLRef v9 = a2;
  if (a1)
  {
    uint64_t v3 = *(uint64_t **)(*(void *)a1 + 112);
    if (v3)
    {
      CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        int v5 = *((char *)v3 + 39);
        if (v5 >= 0) {
          uint64_t v6 = (const UInt8 *)(v3 + 2);
        }
        else {
          uint64_t v6 = (const UInt8 *)v3[2];
        }
        if (v5 >= 0) {
          CFIndex v7 = *((unsigned __int8 *)v3 + 39);
        }
        else {
          CFIndex v7 = v3[3];
        }
        CFStringRef v8 = CFStringCreateWithBytes(v4, v6, v7, 0x8000100u, 0);
        v9[2](v9, v8);
        if (v8) {
          CFRelease(v8);
        }
        uint64_t v3 = (uint64_t *)*v3;
      }
      while (v3);
    }
  }
}

uint64_t OTSVGDocumentRelease(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(std::__shared_weak_count **)(result + 8);
    if (v1) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v1);
    }
    JUMPOUT(0x1C18A3E80);
  }
  return result;
}

double OTSVGDocumentGetIntrinsicRect()
{
  return 0.0;
}

uint64_t std::deque<std::string>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    CFAllocatorRef v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    CFAllocatorRef v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 / 0xAA];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 24 * (v5 % 0xAA);
    unint64_t v9 = (unint64_t)v2[(*(void *)(a1 + 40) + v5) / 0xAA] + 24 * ((*(void *)(a1 + 40) + v5) % 0xAA);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 23) < 0)
        {
          operator delete(*(void **)v8);
          unint64_t v7 = (unint64_t)*v6;
        }
        v8 += 24;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }
      while (v8 != v9);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  *CFAllocatorRef v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 85;
    goto LABEL_16;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 170;
LABEL_16:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      unint64_t v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *std::vector<std::reference_wrapper<SVG::Element>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  double result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void SVG::populateIdMapWithRealIds(uint64_t a1, uint64_t a2)
{
  int v4 = *(char *)(a2 + 31);
  if (v4 >= 0) {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 31);
  }
  else {
    unint64_t v5 = *(void *)(a2 + 16);
  }
  if (v5)
  {
    uint64_t v6 = (_OWORD *)(a2 + 8);
    if (v4 >= 0) {
      unint64_t v7 = (uint64_t *)(a2 + 8);
    }
    else {
      unint64_t v7 = *(uint64_t **)(a2 + 8);
    }
    unint64_t v8 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v31, v7, v5);
    unint64_t v9 = v8;
    unint64_t v10 = *(void *)(a1 + 8);
    if (v10)
    {
      uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
      v11.i16[0] = vaddlv_u8(v11);
      unint64_t v12 = v11.u32[0];
      if (v11.u32[0] > 1uLL)
      {
        unint64_t v13 = v8;
        if (v8 >= v10) {
          unint64_t v13 = v8 % v10;
        }
      }
      else
      {
        unint64_t v13 = (v10 - 1) & v8;
      }
      unint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v13);
      if (v14)
      {
        for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
        {
          unint64_t v16 = *((void *)i + 1);
          if (v16 == v9)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100](a1 + 32, i + 16, (unsigned __int8 *)(a2 + 8))) {
              goto LABEL_50;
            }
          }
          else
          {
            if (v12 > 1)
            {
              if (v16 >= v10) {
                v16 %= v10;
              }
            }
            else
            {
              v16 &= v10 - 1;
            }
            if (v16 != v13) {
              break;
            }
          }
        }
      }
    }
    else
    {
      unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
    }
    uint8x8_t v17 = operator new(0x30uLL);
    *uint8x8_t v17 = 0;
    v17[1] = v9;
    unint64_t v18 = (std::string *)(v17 + 2);
    if (*(char *)(a2 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(v18, *(const std::string::value_type **)(a2 + 8), *(void *)(a2 + 16));
    }
    else
    {
      *(_OWORD *)&v18->__r_.__value_.__l.__data_ = *v6;
      v17[4] = *(void *)(a2 + 24);
    }
    v17[5] = a2;
    float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
    float v20 = *(float *)(a1 + 32);
    if (!v10 || (float)(v20 * (float)v10) < v19)
    {
      BOOL v21 = 1;
      if (v10 >= 3) {
        BOOL v21 = (v10 & (v10 - 1)) != 0;
      }
      unint64_t v22 = v21 | (2 * v10);
      unint64_t v23 = vcvtps_u32_f32(v19 / v20);
      if (v22 <= v23) {
        size_t v24 = v23;
      }
      else {
        size_t v24 = v22;
      }
      std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>(a1, v24);
      unint64_t v10 = *(void *)(a1 + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v9 >= v10) {
          unint64_t v13 = v9 % v10;
        }
        else {
          unint64_t v13 = v9;
        }
      }
      else
      {
        unint64_t v13 = (v10 - 1) & v9;
      }
    }
    uint64_t v25 = *(void *)a1;
    unint64_t v26 = *(void **)(*(void *)a1 + 8 * v13);
    if (v26)
    {
      *uint8x8_t v17 = *v26;
    }
    else
    {
      *uint8x8_t v17 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v17;
      *(void *)(v25 + 8 * v13) = a1 + 16;
      if (!*v17)
      {
LABEL_49:
        ++*(void *)(a1 + 24);
        goto LABEL_50;
      }
      unint64_t v27 = *(void *)(*v17 + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v27 >= v10) {
          v27 %= v10;
        }
      }
      else
      {
        v27 &= v10 - 1;
      }
      unint64_t v26 = (void *)(*(void *)a1 + 8 * v27);
    }
    *unint64_t v26 = v17;
    goto LABEL_49;
  }
LABEL_50:
  size_t v29 = *(uint64_t **)(a2 + 32);
  int8x8_t v28 = *(uint64_t **)(a2 + 40);
  while (v29 != v28)
  {
    uint64_t v30 = *v29++;
    SVG::populateIdMapWithRealIds(a1, v30);
  }
}

uint64_t SVG::populateIdMapWithFakeIds(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(unsigned __int8 *)(a2 + 31);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 16);
  }
  if (v5) {
    goto LABEL_61;
  }
  uint64_t v35 = a2;
  long long v44 = 0uLL;
  uint64_t v45 = 0;
  uint64_t v6 = *MEMORY[0x1E4FBA418];
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA418] + 24);
  do
  {
    unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v42[7] = v8;
    v42[8] = v8;
    v42[5] = v8;
    v42[6] = v8;
    v42[3] = v8;
    v42[4] = v8;
    v42[1] = v8;
    v42[2] = v8;
    v42[0] = v8;
    long long v40 = v8;
    long long v41 = v8;
    v38[3] = v8;
    *(_OWORD *)long long __p = v8;
    v38[1] = v8;
    _OWORD v38[2] = v8;
    v38[0] = v8;
    std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v38);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v38, (uint64_t)"element", 7);
    std::ostream::operator<<();
    std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v38 + 8, &v36);
    if (SHIBYTE(v45) < 0) {
      operator delete((void *)v44);
    }
    long long v44 = v36;
    uint64_t v45 = v37;
    *(void *)&v38[0] = v6;
    *(void *)((char *)v38 + *(void *)(v6 - 24)) = v7;
    *((void *)&v38[0] + 1) = MEMORY[0x1E4FBA470] + 16;
    if (SHIBYTE(v40) < 0) {
      operator delete(__p[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x1C18A3E60](v42);
    a3 = (a3 + 1);
  }
  while (std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::find<std::string>((void *)a1, (uint64_t)&v44));
  if (v45 >= 0) {
    unint64_t v9 = (uint64_t *)&v44;
  }
  else {
    unint64_t v9 = (uint64_t *)v44;
  }
  if (v45 >= 0) {
    unint64_t v10 = HIBYTE(v45);
  }
  else {
    unint64_t v10 = *((void *)&v44 + 1);
  }
  unint64_t v11 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)v38, v9, v10);
  unint64_t v12 = v11;
  unint64_t v13 = *(void *)(a1 + 8);
  if (v13)
  {
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    unint64_t v15 = v14.u32[0];
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v16 = v11;
      if (v11 >= v13) {
        unint64_t v16 = v11 % v13;
      }
    }
    else
    {
      unint64_t v16 = (v13 - 1) & v11;
    }
    uint8x8_t v17 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v16);
    if (v17)
    {
      for (uint64_t i = *v17; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v19 = *((void *)i + 1);
        if (v19 == v12)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](a1 + 32, i + 16, (unsigned __int8 *)&v44)) {
            goto LABEL_58;
          }
        }
        else
        {
          if (v15 > 1)
          {
            if (v19 >= v13) {
              v19 %= v13;
            }
          }
          else
          {
            v19 &= v13 - 1;
          }
          if (v19 != v16) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  }
  float v20 = operator new(0x30uLL);
  *float v20 = 0;
  v20[1] = v12;
  BOOL v21 = (std::string *)(v20 + 2);
  if (SHIBYTE(v45) < 0)
  {
    std::string::__init_copy_ctor_external(v21, (const std::string::value_type *)v44, *((std::string::size_type *)&v44 + 1));
  }
  else
  {
    *(_OWORD *)&v21->__r_.__value_.__l.__data_ = v44;
    v20[4] = v45;
  }
  void v20[5] = v35;
  float v22 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v23 = *(float *)(a1 + 32);
  if (!v13 || (float)(v23 * (float)v13) < v22)
  {
    BOOL v24 = 1;
    if (v13 >= 3) {
      BOOL v24 = (v13 & (v13 - 1)) != 0;
    }
    unint64_t v25 = v24 | (2 * v13);
    unint64_t v26 = vcvtps_u32_f32(v22 / v23);
    if (v25 <= v26) {
      size_t v27 = v26;
    }
    else {
      size_t v27 = v25;
    }
    std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>(a1, v27);
    unint64_t v13 = *(void *)(a1 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v12 >= v13) {
        unint64_t v16 = v12 % v13;
      }
      else {
        unint64_t v16 = v12;
      }
    }
    else
    {
      unint64_t v16 = (v13 - 1) & v12;
    }
  }
  uint64_t v28 = *(void *)a1;
  size_t v29 = *(void **)(*(void *)a1 + 8 * v16);
  if (v29)
  {
    *float v20 = *v29;
  }
  else
  {
    *float v20 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v20;
    *(void *)(v28 + 8 * v16) = a1 + 16;
    if (!*v20) {
      goto LABEL_57;
    }
    unint64_t v30 = *(void *)(*v20 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v30 >= v13) {
        v30 %= v13;
      }
    }
    else
    {
      v30 &= v13 - 1;
    }
    size_t v29 = (void *)(*(void *)a1 + 8 * v30);
  }
  *size_t v29 = v20;
LABEL_57:
  ++*(void *)(a1 + 24);
LABEL_58:
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)v44);
  }
  a2 = v35;
LABEL_61:
  char v31 = *(uint64_t **)(a2 + 32);
  float v32 = *(uint64_t **)(a2 + 40);
  while (v31 != v32)
  {
    uint64_t v33 = *v31++;
    a3 = SVG::populateIdMapWithFakeIds(a1, v33, a3);
  }
  return a3;
}

void SVG::extractValidFragment(SVG *this, CFURLRef anURL)
{
  if (!CFURLCanBeDecomposed(anURL)) {
    goto LABEL_19;
  }
  CFStringRef v4 = CFURLCopyScheme(anURL);
  CFStringRef v5 = CFURLCopyNetLocation(anURL);
  CFStringRef v6 = CFURLCopyPath(anURL);
  if ((unint64_t)v4 | (unint64_t)v5)
  {
    *(unsigned char *)this = 0;
    *((unsigned char *)this + 24) = 0;
    if (!v6)
    {
      if (!v5) {
        goto LABEL_6;
      }
      goto LABEL_5;
    }
LABEL_12:
    CFRelease(v6);
    if (!v5)
    {
LABEL_6:
      if (v4)
      {
        CFRelease(v4);
      }
      return;
    }
LABEL_5:
    CFRelease(v5);
    goto LABEL_6;
  }
  if (v6)
  {
    *(unsigned char *)this = 0;
    *((unsigned char *)this + 24) = 0;
    goto LABEL_12;
  }
  uint64_t v7 = (__CFString *)CFURLCopyFragment(anURL, &stru_1F1A76148);
  if (!v7)
  {
LABEL_19:
    *(unsigned char *)this = 0;
    *((unsigned char *)this + 24) = 0;
    return;
  }
  long long v8 = v7;
  memset(__p, 170, sizeof(__p));
  SVG::convertString((SVG *)__p, v7);
  unint64_t v9 = (void *)HIBYTE(__p[2]);
  int v10 = SHIBYTE(__p[2]);
  if (SHIBYTE(__p[2]) < 0) {
    unint64_t v9 = __p[1];
  }
  if (v9)
  {
    *(_OWORD *)this = *(_OWORD *)__p;
    *((void **)this + 2) = __p[2];
    *((unsigned char *)this + 24) = 1;
  }
  else
  {
    *(unsigned char *)this = 0;
    *((unsigned char *)this + 24) = 0;
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  CFRelease(v8);
}

void std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::__emplace_unique_key_args<__CFURL const*,__CFURL const* const&,std::reference_wrapper<SVG::Element> const&>(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v12 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v12 = v9 % v10;
      }
    }
    else
    {
      unint64_t v12 = (v10 - 1) & v9;
    }
    unint64_t v13 = *(void **)(*(void *)a1 + 8 * v12);
    if (v13)
    {
      for (uint64_t i = (void *)*v13; i; uint64_t i = (void *)*i)
      {
        unint64_t v15 = i[1];
        if (v15 == v9)
        {
          if (i[2] == a2) {
            return;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v12) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v16 = operator new(0x20uLL);
  *unint64_t v16 = 0;
  v16[1] = v9;
  _OWORD v16[2] = a3;
  void v16[3] = a4;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v12 = v9 % v10;
      }
      else {
        unint64_t v12 = v9;
      }
    }
    else
    {
      unint64_t v12 = (v10 - 1) & v9;
    }
  }
  uint64_t v23 = *(void *)a1;
  BOOL v24 = *(void **)(*(void *)a1 + 8 * v12);
  if (v24)
  {
    *unint64_t v16 = *v24;
LABEL_38:
    *BOOL v24 = v16;
    goto LABEL_39;
  }
  *unint64_t v16 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v16;
  *(void *)(v23 + 8 * v12) = a1 + 16;
  if (*v16)
  {
    unint64_t v25 = *(void *)(*v16 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10) {
        v25 %= v10;
      }
    }
    else
    {
      v25 &= v10 - 1;
    }
    BOOL v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::populatePatternAndMaskMaps(std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> &,std::unordered_map<SVG::MaskElement const*,SVG::Document::MaskData> &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,__CFArray const*,SVG::Presentation const&,SVG::SVGElement const&)::$_0,SVG::populatePatternAndMaskMaps(std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> &,std::unordered_map<SVG::MaskElement const*,SVG::Document::MaskData> &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,__CFArray const*,SVG::Presentation const&,SVG::SVGElement const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&>(uint64_t ***a1, unint64_t *a2)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  unint64_t v3 = *a2;
  memcpy(__dst, &unk_1BF1DB2D0, sizeof(__dst));
  SVG::Presentation::defaultPresentation((uint64_t)__dst);
  memcpy(v74, &unk_1BF1DB510, sizeof(v74));
  SVG::Recorder::getInitialState(__dst, (uint64_t)v109);
  SVG::Recorder::Recorder((uint64_t)v74, v109, **v2, 1u, 1.0);
  if (*(_DWORD *)&v109[112] != -1) {
    ((void (*)(long long *, unsigned char *))*(&off_1F1A75BD0 + *(unsigned int *)&v109[112]))(&v76, &v109[8]);
  }
  memset(v73, 170, sizeof(v73));
  SVG::hrefChain<SVG::PatternElement>(v3, v2[1], v73);
  long long __p = 0;
  CGFloat v71 = 0;
  CGFloat v72 = 0;
  CFStringRef v5 = (char *)v73[0];
  CFStringRef v4 = (char *)v73[1];
  unsigned int v61 = v2;
  unint64_t v62 = v3;
  if (v73[0] == v73[1])
  {
    CFStringRef v4 = (char *)v73[0];
  }
  else
  {
    CFStringRef v6 = (char *)v73[0];
    while (1)
    {
      unint64_t v7 = *(uint64_t **)(*(void *)v6 + 32);
      unint64_t v8 = *(uint64_t **)(*(void *)v6 + 40);
      if (v7 != v8) {
        break;
      }
      v6 += 8;
      if (v6 == v73[1]) {
        goto LABEL_28;
      }
    }
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = *v7;
      if (v9 >= v72)
      {
        uint64_t v11 = (v9 - (unsigned char *)__p) >> 3;
        if ((unint64_t)(v11 + 1) >> 61) {
          abort();
        }
        unint64_t v12 = (v72 - (unsigned char *)__p) >> 2;
        if (v12 <= v11 + 1) {
          unint64_t v12 = v11 + 1;
        }
        if ((unint64_t)(v72 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v13 = v12;
        }
        if (v13) {
          uint8x8_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)&v72, v13);
        }
        else {
          uint8x8_t v14 = 0;
        }
        unint64_t v15 = &v14[8 * v11];
        *(void *)unint64_t v15 = v10;
        unint64_t v9 = v15 + 8;
        float v17 = (char *)__p;
        unint64_t v16 = v71;
        if (v71 != __p)
        {
          do
          {
            uint64_t v18 = *((void *)v16 - 1);
            v16 -= 8;
            *((void *)v15 - 1) = v18;
            v15 -= 8;
          }
          while (v16 != v17);
          unint64_t v16 = (char *)__p;
        }
        long long __p = v15;
        CGFloat v71 = v9;
        CGFloat v72 = &v14[8 * v13];
        if (v16) {
          operator delete(v16);
        }
      }
      else
      {
        *(void *)unint64_t v9 = v10;
        v9 += 8;
      }
      CGFloat v71 = v9;
      ++v7;
    }
    while (v7 != v8);
    CFStringRef v5 = (char *)v73[0];
    CFStringRef v4 = (char *)v73[1];
  }
LABEL_28:
  memcpy(v109, &unk_1BF1DB2D0, sizeof(v109));
  *(_DWORD *)&v109[8] = 0;
  *(_DWORD *)&v109[48] = 0;
  *(_DWORD *)&v109[64] = 0;
  *(_DWORD *)&v109[80] = 0;
  *(void *)&v109[88] = 0;
  *(_DWORD *)&v109[100] = 0;
  *(_DWORD *)&v109[200] = 0;
  *(_DWORD *)&v109[208] = 0;
  *(_DWORD *)&v109[216] = 0;
  *(_DWORD *)&v109[248] = 0;
  *(_DWORD *)&v109[264] = 0;
  *(_DWORD *)&v109[272] = 0;
  *(_DWORD *)&v109[280] = 0;
  *(_DWORD *)&v109[308] = 0;
  *(_DWORD *)&v109[320] = 0;
  *(_DWORD *)&v109[328] = 0;
  *(_DWORD *)&v109[336] = 0;
  *(_DWORD *)&v109[352] = 0;
  *(_DWORD *)&v109[400] = 0;
  *(_DWORD *)&v109[416] = 0;
  *(_DWORD *)&v109[448] = 0;
  *(_DWORD *)&v109[464] = 0;
  *(_DWORD *)&v109[480] = 0;
  *(_DWORD *)&v109[512] = 0;
  *(_DWORD *)&v109[520] = 0;
  *(_DWORD *)&v109[528] = 0;
  *(_DWORD *)&v109[544] = 0;
  *(_DWORD *)&v109[560] = 0;
  uint64_t v110 = 0;
  memset(&v109[112], 0, 28);
  *(_DWORD *)&v109[152] = 0;
  *(void *)&v109[232] = 0;
  *(void *)&v109[224] = 0;
  *(void *)&v109[288] = 0;
  *(void *)&v109[296] = 0;
  memset(&v109[488], 0, 20);
  if (v4 != v5)
  {
    do
    {
      uint64_t v19 = *((void *)v4 - 1);
      v4 -= 8;
      SVG::Presentation::specifiedInherit((SVG::Presentation *)(v19 + 64), (const SVG::Presentation *)v109, &v76);
      *(_OWORD *)CGFloat v109 = v76;
      *(_OWORD *)&v109[16] = v77;
      *(_OWORD *)&v109[32] = v78;
      *(void *)&v109[48] = v79;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>((uint64_t)&v109[64], (uint64_t)v80);
      *(_OWORD *)&v109[88] = v82;
      *(_OWORD *)&v109[104] = v83;
      *(_OWORD *)&v109[120] = v84;
      *(_DWORD *)&v109[136] = v85;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>((uint64_t)&v109[152], (uint64_t)v86);
      *(_OWORD *)&v109[208] = v88;
      *(_OWORD *)&v109[224] = v89;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<SVG::CF<__CFURL const*>>>,(std::__variant_detail::_Trait)1>>((uint64_t)&v109[248], (uint64_t)v90);
      *(_OWORD *)&v109[304] = v94;
      *(_OWORD *)&v109[320] = v95;
      *(void *)&v109[336] = v96;
      *(_OWORD *)&v109[272] = v92;
      *(_OWORD *)&v109[288] = v93;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::Paint>,(std::__variant_detail::_Trait)1>>((uint64_t)&v109[352], (uint64_t)v97);
      std::__variant_detail::__assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<SVG::Presentation::NotSpecified,SVG::Presentation::Inherit,SVG::Presentation::ValueOrKeyword<std::vector<SVG::Length>>>,(std::__variant_detail::_Trait)1>>((uint64_t)&v109[416], (uint64_t)v99);
      *(_OWORD *)&v109[520] = v105;
      *(_OWORD *)&v109[536] = v106;
      *(_OWORD *)&v109[552] = v107;
      uint64_t v110 = v108;
      *(_OWORD *)&v109[456] = v101;
      *(_OWORD *)&v109[472] = v102;
      *(_OWORD *)&v109[488] = v103;
      *(_OWORD *)&v109[504] = v104;
      if (v100 != -1) {
        ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A75BA8 + v100))(v63, v99);
      }
      unsigned int v100 = -1;
      if (v98 != -1) {
        ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A75B90 + v98))(v63, v97);
      }
      unsigned int v98 = -1;
      if (v91 != -1) {
        ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A75B78 + v91))(v63, v90);
      }
      unsigned int v91 = -1;
      if (v87 != -1) {
        ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A75B90 + v87))(v63, v86);
      }
      unsigned int v87 = -1;
      if (v81 != -1) {
        ((void (*)(unsigned char *, unsigned char *))*(&off_1F1A75B78 + v81))(v63, v80);
      }
    }
    while (v4 != v73[0]);
  }
  *(_OWORD *)&v63[48] = unk_1BF1DB6E8;
  memset(v63, 170, 48);
  unint64_t v20 = v61[1];
  size_t v22 = v61[4];
  unint64_t v21 = v61[5];
  uint64_t v23 = v61[6];
  long long v24 = *((_OWORD *)v61 + 1);
  *(_DWORD *)&v63[56] = 1065353216;
  memset(&v63[24], 0, 32);
  *(void *)&v63[8] = v20;
  *(void *)&v63[16] = __dst;
  *(void *)unsigned int v63 = &unk_1F1A74AE8;
  uint64_t v64 = v74;
  memset(v65, 0, 48);
  v65[3] = v24;
  CGFloat v66 = v22;
  long long v67 = v21;
  long long v25 = *((_OWORD *)v23 + 43);
  long long v68 = *((_OWORD *)v23 + 42);
  long long v69 = v25;
  *(void *)&long long v76 = *(void *)(v62 + 56);
  unint64_t v26 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(v21, &v76);
  SVG::Presentation::inherit((SVG::Presentation *)v109, (const SVG::Presentation *)(v26 + 3), (const SVG::Presentation *)__dst, &v76);
  SVG::RecordBase::operator()((float *)v63, (unint64_t **)&__p, (const SVG::Presentation *)&v76);
  if (v100 != -1) {
    ((void (*)(void ***, unsigned char *))*(&off_1F1A75BA8 + v100))(&v75, v99);
  }
  unsigned int v100 = -1;
  if (v98 != -1) {
    ((void (*)(void ***, unsigned char *))*(&off_1F1A75B90 + v98))(&v75, v97);
  }
  unsigned int v98 = -1;
  if (v91 != -1) {
    ((void (*)(void ***, unsigned char *))*(&off_1F1A75B78 + v91))(&v75, v90);
  }
  unsigned int v91 = -1;
  if (v87 != -1) {
    ((void (*)(void ***, unsigned char *))*(&off_1F1A75B90 + v87))(&v75, v86);
  }
  unsigned int v87 = -1;
  if (v81 != -1) {
    ((void (*)(void ***, unsigned char *))*(&off_1F1A75B78 + v81))(&v75, v80);
  }
  SVG::Recorder::takeRecording((SVG::Recorder *)v74, &v76);
  size_t v27 = (char *)operator new(0x30uLL);
  *((void *)v27 + 1) = 0;
  *((void *)v27 + 2) = 0;
  *(void *)size_t v27 = &unk_1F1A74E60;
  *(_OWORD *)(v27 + 24) = v76;
  *((void *)v27 + 5) = v77;
  long long v76 = 0uLL;
  *(void *)&long long v77 = 0;
  CGFloat v75 = (void **)&v76;
  std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__destroy_vector::operator()[abi:nn180100](&v75);
  uint64_t v28 = v61[3];
  unint64_t v29 = 0x9DDFEA08EB382D69 * (((8 * v62) + 8) ^ HIDWORD(v62));
  unint64_t v30 = 0x9DDFEA08EB382D69 * (HIDWORD(v62) ^ (v29 >> 47) ^ v29);
  unint64_t v31 = 0x9DDFEA08EB382D69 * (v30 ^ (v30 >> 47));
  unint64_t v32 = v28[1];
  if (v32)
  {
    uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v32);
    v33.i16[0] = vaddlv_u8(v33);
    if (v33.u32[0] > 1uLL)
    {
      unint64_t v34 = 0x9DDFEA08EB382D69 * (v30 ^ (v30 >> 47));
      if (v31 >= v32) {
        unint64_t v34 = v31 % v32;
      }
    }
    else
    {
      unint64_t v34 = (v32 - 1) & v31;
    }
    uint64_t v35 = *(void **)(*v28 + 8 * v34);
    if (v35)
    {
      for (uint64_t i = (void *)*v35; i; uint64_t i = (void *)*i)
      {
        unint64_t v37 = i[1];
        if (v37 == v31)
        {
          if (i[2] == v62) {
            goto LABEL_123;
          }
        }
        else
        {
          if (v33.u32[0] > 1uLL)
          {
            if (v37 >= v32) {
              v37 %= v32;
            }
          }
          else
          {
            v37 &= v32 - 1;
          }
          if (v37 != v34) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  }
  uint8x8_t v38 = v28 + 2;
  unint64_t v39 = operator new(0x28uLL);
  *unint64_t v39 = 0;
  v39[1] = v31;
  v39[2] = v62;
  uint64_t v39[3] = v27 + 24;
  v39[4] = v27;
  float v40 = (float)(unint64_t)(v28[3] + 1);
  float v41 = *((float *)v28 + 8);
  if (!v32 || (float)(v41 * (float)v32) < v40)
  {
    BOOL v42 = 1;
    if (v32 >= 3) {
      BOOL v42 = (v32 & (v32 - 1)) != 0;
    }
    unint64_t v43 = v42 | (2 * v32);
    unint64_t v44 = vcvtps_u32_f32(v40 / v41);
    if (v43 <= v44) {
      int8x8_t prime = (int8x8_t)v44;
    }
    else {
      int8x8_t prime = (int8x8_t)v43;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v32 = v28[1];
    if (*(void *)&prime > v32) {
      goto LABEL_79;
    }
    if (*(void *)&prime < v32)
    {
      unint64_t v52 = vcvtps_u32_f32((float)(unint64_t)v28[3] / *((float *)v28 + 8));
      if (v32 < 3 || (uint8x8_t v53 = (uint8x8_t)vcnt_s8((int8x8_t)v32), v53.i16[0] = vaddlv_u8(v53), v53.u32[0] > 1uLL))
      {
        unint64_t v52 = std::__next_prime(v52);
      }
      else
      {
        uint64_t v54 = 1 << -(char)__clz(v52 - 1);
        if (v52 >= 2) {
          unint64_t v52 = v54;
        }
      }
      if (*(void *)&prime <= v52) {
        int8x8_t prime = (int8x8_t)v52;
      }
      if (*(void *)&prime >= v32)
      {
        unint64_t v32 = v28[1];
      }
      else
      {
        if (prime)
        {
LABEL_79:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unsigned int v46 = operator new(8 * *(void *)&prime);
          unint64_t v47 = (void *)*v28;
          *uint64_t v28 = (uint64_t)v46;
          if (v47) {
            operator delete(v47);
          }
          uint64_t v48 = 0;
          v28[1] = (uint64_t)prime;
          do
            *(void *)(*v28 + 8 * v48++) = 0;
          while (*(void *)&prime != v48);
          uint64_t v49 = (void *)*v38;
          if (*v38)
          {
            unint64_t v50 = v49[1];
            uint8x8_t v51 = (uint8x8_t)vcnt_s8(prime);
            v51.i16[0] = vaddlv_u8(v51);
            if (v51.u32[0] > 1uLL)
            {
              if (v50 >= *(void *)&prime) {
                v50 %= *(void *)&prime;
              }
            }
            else
            {
              v50 &= *(void *)&prime - 1;
            }
            *(void *)(*v28 + 8 * v5CGContextBeginTransparencyLayer(c, 0) = v38;
            unsigned int v55 = (void *)*v49;
            if (*v49)
            {
              do
              {
                unint64_t v56 = v55[1];
                if (v51.u32[0] > 1uLL)
                {
                  if (v56 >= *(void *)&prime) {
                    v56 %= *(void *)&prime;
                  }
                }
                else
                {
                  v56 &= *(void *)&prime - 1;
                }
                if (v56 != v50)
                {
                  if (!*(void *)(*v28 + 8 * v56))
                  {
                    *(void *)(*v28 + 8 * v56) = v49;
                    goto LABEL_104;
                  }
                  *uint64_t v49 = *v55;
                  *unsigned int v55 = **(void **)(*v28 + 8 * v56);
                  **(void **)(*v28 + 8 * v56) = v55;
                  unsigned int v55 = v49;
                }
                unint64_t v56 = v50;
LABEL_104:
                uint64_t v49 = v55;
                unsigned int v55 = (void *)*v55;
                unint64_t v50 = v56;
              }
              while (v55);
            }
          }
          unint64_t v32 = (unint64_t)prime;
          goto LABEL_108;
        }
        long long v60 = (void *)*v28;
        *uint64_t v28 = 0;
        if (v60) {
          operator delete(v60);
        }
        unint64_t v32 = 0;
        v28[1] = 0;
      }
    }
LABEL_108:
    if ((v32 & (v32 - 1)) != 0)
    {
      if (v31 >= v32) {
        unint64_t v34 = v31 % v32;
      }
      else {
        unint64_t v34 = v31;
      }
    }
    else
    {
      unint64_t v34 = (v32 - 1) & v31;
    }
  }
  uint64_t v57 = *v28;
  uint64_t v58 = *(void **)(*v28 + 8 * v34);
  if (v58)
  {
    *unint64_t v39 = *v58;
LABEL_121:
    *uint64_t v58 = v39;
    goto LABEL_122;
  }
  *unint64_t v39 = *v38;
  *uint8x8_t v38 = v39;
  *(void *)(v57 + 8 * v34) = v38;
  if (*v39)
  {
    unint64_t v59 = *(void *)(*v39 + 8);
    if ((v32 & (v32 - 1)) != 0)
    {
      if (v59 >= v32) {
        v59 %= v32;
      }
    }
    else
    {
      v59 &= v32 - 1;
    }
    uint64_t v58 = (void *)(*v28 + 8 * v59);
    goto LABEL_121;
  }
LABEL_122:
  size_t v27 = 0;
  ++v28[3];
LABEL_123:
  *(void *)unsigned int v63 = &unk_1F1A74AE8;
  std::deque<SVG::ApplyPresentationState>::~deque[abi:nn180100](v65);
  *(void *)unsigned int v63 = &unk_1F1A74330;
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)&v63[24]);
  if (*(_DWORD *)&v109[448] != -1) {
    ((void (*)(long long *, unsigned char *))*(&off_1F1A75BA8 + *(unsigned int *)&v109[448]))(&v76, &v109[416]);
  }
  *(_DWORD *)&v109[448] = -1;
  if (*(_DWORD *)&v109[400] != -1) {
    ((void (*)(long long *, unsigned char *))*(&off_1F1A75B90 + *(unsigned int *)&v109[400]))(&v76, &v109[352]);
  }
  *(_DWORD *)&v109[400] = -1;
  if (*(_DWORD *)&v109[264] != -1) {
    ((void (*)(long long *, unsigned char *))*(&off_1F1A75B78 + *(unsigned int *)&v109[264]))(&v76, &v109[248]);
  }
  *(_DWORD *)&v109[264] = -1;
  if (*(_DWORD *)&v109[200] != -1) {
    ((void (*)(long long *, unsigned char *))*(&off_1F1A75B90 + *(unsigned int *)&v109[200]))(&v76, &v109[152]);
  }
  *(_DWORD *)&v109[200] = -1;
  if (*(_DWORD *)&v109[80] != -1) {
    ((void (*)(long long *, unsigned char *))*(&off_1F1A75B78 + *(unsigned int *)&v109[80]))(&v76, &v109[64]);
  }
  if (__p)
  {
    CGFloat v71 = (char *)__p;
    operator delete(__p);
  }
  if (v73[0])
  {
    v73[1] = v73[0];
    operator delete(v73[0]);
  }
  std::deque<SVG::BoundingRectState::State>::~deque[abi:nn180100](&v74[32]);
  *(void *)CGFloat v109 = &v74[22];
  std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__destroy_vector::operator()[abi:nn180100]((void ***)v109);
  if (LODWORD(v74[20]) != -1) {
    ((void (*)(unsigned char *, void *))*(&off_1F1A75BD0 + LODWORD(v74[20])))(v109, &v74[7]);
  }
  LODWORD(v74[20]) = -1;
  std::deque<SVG::Recorder::State>::~deque[abi:nn180100](v74);
  if (__dst[112] != -1) {
    ((void (*)(unsigned char *, _DWORD *))*(&off_1F1A75BA8 + __dst[112]))(v109, &__dst[104]);
  }
  __dst[112] = -1;
  if (__dst[100] != -1) {
    ((void (*)(unsigned char *, _DWORD *))*(&off_1F1A75B90 + __dst[100]))(v109, &__dst[88]);
  }
  __dst[100] = -1;
  if (__dst[66] != -1) {
    ((void (*)(unsigned char *, _DWORD *))*(&off_1F1A75B78 + __dst[66]))(v109, &__dst[62]);
  }
  __dst[66] = -1;
  if (__dst[50] != -1) {
    ((void (*)(unsigned char *, _DWORD *))*(&off_1F1A75B90 + __dst[50]))(v109, &__dst[38]);
  }
  __dst[50] = -1;
  if (__dst[20] != -1) {
    ((void (*)(unsigned char *, _DWORD *))*(&off_1F1A75B78 + __dst[20]))(v109, &__dst[16]);
  }
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v27);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::Visitor<SVG::populatePatternAndMaskMaps(std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> &,std::unordered_map<SVG::MaskElement const*,SVG::Document::MaskData> &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,__CFArray const*,SVG::Presentation const&,SVG::SVGElement const&)::$_0,SVG::populatePatternAndMaskMaps(std::unordered_map<SVG::PatternElement const*,SVG::Document::PatternData> &,std::unordered_map<SVG::MaskElement const*,SVG::Document::MaskData> &,std::unordered_map<__CFURL const*,std::reference_wrapper<SVG::Element const>> const&,std::unordered_map<SVG::GradientElement const*,SVG::CF<CGGradient *>> const&,std::unordered_map<SVG::Element const*,SVG::Presentation> const&,__CFArray const*,SVG::Presentation const&,SVG::SVGElement const&)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::reference_wrapper<SVG::PatternElement const>,std::reference_wrapper<SVG::MaskElement const>> const&>(uint64_t *a1, unint64_t *a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  unint64_t v3 = *a2;
  memcpy(__dst, &unk_1BF1DB2D0, sizeof(__dst));
  SVG::Presentation::defaultPresentation((uint64_t)__dst);
  memcpy(v67, &unk_1BF1DB510, sizeof(v67));
  SVG::Recorder::getInitialState(__dst, (uint64_t)&v69);
  SVG::Recorder::Recorder((uint64_t)v67, &v69, **(void **)(v2 + 56), 1u, 1.0);
  if (v73 != -1) {
    ((void (*)(unsigned char *, char *))*(&off_1F1A75BD0 + v73))(v60, (char *)&v69 + 8);
  }
  memset(v60, 170, 48);
  *(_OWORD *)&unsigned char v60[48] = unk_1BF1DB6E8;
  uint64_t v5 = *(void *)(v2 + 88);
  CFStringRef v4 = *(void **)(v2 + 96);
  uint64_t v6 = *(void *)(v2 + 104);
  *(void *)&v60[8] = *(void *)(v2 + 64);
  *(void *)&v60[16] = __dst;
  memset(&v60[24], 0, 32);
  *(_DWORD *)&v60[56] = 1065353216;
  long long __p = 0;
  unint64_t v59 = 0;
  *(void *)long long v60 = &unk_1F1A74AE8;
  unsigned int v61 = v67;
  long long v7 = *(_OWORD *)(v2 + 72);
  memset(v62, 0, 48);
  v62[3] = v7;
  uint64_t v63 = v5;
  uint64_t v64 = v4;
  long long v8 = *(_OWORD *)(v6 + 688);
  long long v65 = *(_OWORD *)(v6 + 672);
  long long v66 = v8;
  uint64_t v58 = 0;
  unint64_t v9 = *(uint64_t **)(v3 + 32);
  uint64_t v10 = *(uint64_t **)(v3 + 40);
  if (v9 != v10)
  {
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = *v9;
      if (v11 >= v59)
      {
        uint64_t v13 = (v11 - (unsigned char *)__p) >> 3;
        if ((unint64_t)(v13 + 1) >> 61) {
          abort();
        }
        unint64_t v14 = (v59 - (unsigned char *)__p) >> 2;
        if (v14 <= v13 + 1) {
          unint64_t v14 = v13 + 1;
        }
        if ((unint64_t)(v59 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v14;
        }
        if (v15) {
          unint64_t v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<double>>((uint64_t)&v59, v15);
        }
        else {
          unint64_t v16 = 0;
        }
        float v17 = &v16[8 * v13];
        *(void *)float v17 = v12;
        uint64_t v11 = v17 + 8;
        uint64_t v19 = (char *)__p;
        uint64_t v18 = v58;
        if (v58 != __p)
        {
          do
          {
            uint64_t v20 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v17 - 1) = v20;
            v17 -= 8;
          }
          while (v18 != v19);
          uint64_t v18 = (char *)__p;
        }
        long long __p = v17;
        uint64_t v58 = v11;
        unint64_t v59 = &v16[8 * v15];
        if (v18) {
          operator delete(v18);
        }
      }
      else
      {
        *(void *)uint64_t v11 = v12;
        v11 += 8;
      }
      uint64_t v58 = v11;
      ++v9;
    }
    while (v9 != v10);
    CFStringRef v4 = *(void **)(v2 + 96);
  }
  *(void *)&long long v69 = *(void *)(v3 + 56);
  unint64_t v21 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(v4, &v69);
  SVG::Presentation::inherit((SVG::Presentation *)(v3 + 64), (const SVG::Presentation *)(v21 + 3), (const SVG::Presentation *)__dst, &v69);
  SVG::RecordBase::operator()((float *)v60, (unint64_t **)&__p, (const SVG::Presentation *)&v69);
  if (v81 != -1) {
    ((void (*)(void ***, uint64_t *))*(&off_1F1A75BA8 + v81))(&v68, &v80);
  }
  unsigned int v81 = -1;
  if (v79 != -1) {
    ((void (*)(void ***, uint64_t *))*(&off_1F1A75B90 + v79))(&v68, &v78);
  }
  unsigned int v79 = -1;
  if (v77 != -1) {
    ((void (*)(void ***, uint64_t *))*(&off_1F1A75B78 + v77))(&v68, &v76);
  }
  unsigned int v77 = -1;
  if (v75 != -1) {
    ((void (*)(void ***, uint64_t *))*(&off_1F1A75B90 + v75))(&v68, &v74);
  }
  unsigned int v75 = -1;
  if (v72 != -1) {
    ((void (*)(void ***, uint64_t *))*(&off_1F1A75B78 + v72))(&v68, &v71);
  }
  SVG::Recorder::takeRecording((SVG::Recorder *)v67, &v69);
  size_t v22 = (char *)operator new(0x30uLL);
  *((void *)v22 + 1) = 0;
  *((void *)v22 + 2) = 0;
  *(void *)size_t v22 = &unk_1F1A74E60;
  *(_OWORD *)(v22 + 24) = v69;
  *((void *)v22 + 5) = v70;
  long long v69 = 0uLL;
  uint64_t v70 = 0;
  long long v68 = (void **)&v69;
  std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__destroy_vector::operator()[abi:nn180100](&v68);
  uint64_t v23 = *(uint64_t **)(v2 + 88);
  unint64_t v24 = 0x9DDFEA08EB382D69 * (((8 * v3) + 8) ^ HIDWORD(v3));
  unint64_t v25 = 0x9DDFEA08EB382D69 * (HIDWORD(v3) ^ (v24 >> 47) ^ v24);
  unint64_t v26 = 0x9DDFEA08EB382D69 * (v25 ^ (v25 >> 47));
  unint64_t v27 = v23[1];
  if (v27)
  {
    uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v27);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      unint64_t v29 = 0x9DDFEA08EB382D69 * (v25 ^ (v25 >> 47));
      if (v26 >= v27) {
        unint64_t v29 = v26 % v27;
      }
    }
    else
    {
      unint64_t v29 = (v27 - 1) & v26;
    }
    unint64_t v30 = *(void **)(*v23 + 8 * v29);
    if (v30)
    {
      for (uint64_t i = (void *)*v30; i; uint64_t i = (void *)*i)
      {
        unint64_t v32 = i[1];
        if (v32 == v26)
        {
          if (i[2] == v3) {
            goto LABEL_106;
          }
        }
        else
        {
          if (v28.u32[0] > 1uLL)
          {
            if (v32 >= v27) {
              v32 %= v27;
            }
          }
          else
          {
            v32 &= v27 - 1;
          }
          if (v32 != v29) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
  }
  uint8x8_t v33 = v23 + 2;
  unint64_t v34 = operator new(0x28uLL);
  *unint64_t v34 = 0;
  v34[1] = v26;
  v34[2] = v3;
  v34[3] = v22 + 24;
  _OWORD v34[4] = v22;
  float v35 = (float)(unint64_t)(v23[3] + 1);
  float v36 = *((float *)v23 + 8);
  if (!v27 || (float)(v36 * (float)v27) < v35)
  {
    BOOL v37 = 1;
    if (v27 >= 3) {
      BOOL v37 = (v27 & (v27 - 1)) != 0;
    }
    unint64_t v38 = v37 | (2 * v27);
    unint64_t v39 = vcvtps_u32_f32(v35 / v36);
    if (v38 <= v39) {
      int8x8_t prime = (int8x8_t)v39;
    }
    else {
      int8x8_t prime = (int8x8_t)v38;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v27 = v23[1];
    }
    if (*(void *)&prime > v27) {
      goto LABEL_62;
    }
    if (*(void *)&prime < v27)
    {
      unint64_t v47 = vcvtps_u32_f32((float)(unint64_t)v23[3] / *((float *)v23 + 8));
      if (v27 < 3 || (uint8x8_t v48 = (uint8x8_t)vcnt_s8((int8x8_t)v27), v48.i16[0] = vaddlv_u8(v48), v48.u32[0] > 1uLL))
      {
        unint64_t v47 = std::__next_prime(v47);
      }
      else
      {
        uint64_t v49 = 1 << -(char)__clz(v47 - 1);
        if (v47 >= 2) {
          unint64_t v47 = v49;
        }
      }
      if (*(void *)&prime <= v47) {
        int8x8_t prime = (int8x8_t)v47;
      }
      if (*(void *)&prime >= v27)
      {
        unint64_t v27 = v23[1];
      }
      else
      {
        if (prime)
        {
LABEL_62:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          float v41 = operator new(8 * *(void *)&prime);
          BOOL v42 = (void *)*v23;
          *uint64_t v23 = (uint64_t)v41;
          if (v42) {
            operator delete(v42);
          }
          uint64_t v43 = 0;
          v23[1] = (uint64_t)prime;
          do
            *(void *)(*v23 + 8 * v43++) = 0;
          while (*(void *)&prime != v43);
          unint64_t v44 = (void *)*v33;
          if (*v33)
          {
            unint64_t v45 = v44[1];
            uint8x8_t v46 = (uint8x8_t)vcnt_s8(prime);
            v46.i16[0] = vaddlv_u8(v46);
            if (v46.u32[0] > 1uLL)
            {
              if (v45 >= *(void *)&prime) {
                v45 %= *(void *)&prime;
              }
            }
            else
            {
              v45 &= *(void *)&prime - 1;
            }
            *(void *)(*v23 + 8 * v45) = v33;
            unint64_t v50 = (void *)*v44;
            if (*v44)
            {
              do
              {
                unint64_t v51 = v50[1];
                if (v46.u32[0] > 1uLL)
                {
                  if (v51 >= *(void *)&prime) {
                    v51 %= *(void *)&prime;
                  }
                }
                else
                {
                  v51 &= *(void *)&prime - 1;
                }
                if (v51 != v45)
                {
                  if (!*(void *)(*v23 + 8 * v51))
                  {
                    *(void *)(*v23 + 8 * v51) = v44;
                    goto LABEL_87;
                  }
                  *unint64_t v44 = *v50;
                  *unint64_t v50 = **(void **)(*v23 + 8 * v51);
                  **(void **)(*v23 + 8 * v51) = v50;
                  unint64_t v50 = v44;
                }
                unint64_t v51 = v45;
LABEL_87:
                unint64_t v44 = v50;
                unint64_t v50 = (void *)*v50;
                unint64_t v45 = v51;
              }
              while (v50);
            }
          }
          unint64_t v27 = (unint64_t)prime;
          goto LABEL_91;
        }
        unint64_t v56 = (void *)*v23;
        *uint64_t v23 = 0;
        if (v56) {
          operator delete(v56);
        }
        unint64_t v27 = 0;
        v23[1] = 0;
      }
    }
LABEL_91:
    if ((v27 & (v27 - 1)) != 0)
    {
      if (v26 >= v27) {
        unint64_t v29 = v26 % v27;
      }
      else {
        unint64_t v29 = v26;
      }
    }
    else
    {
      unint64_t v29 = (v27 - 1) & v26;
    }
  }
  uint64_t v52 = *v23;
  uint8x8_t v53 = *(void **)(*v23 + 8 * v29);
  if (v53)
  {
    *unint64_t v34 = *v53;
LABEL_104:
    *uint8x8_t v53 = v34;
    goto LABEL_105;
  }
  uint64_t v54 = (void *)*v33;
  *unint64_t v34 = *v33;
  *uint8x8_t v33 = v34;
  *(void *)(v52 + 8 * v29) = v33;
  if (v54)
  {
    unint64_t v55 = v54[1];
    if ((v27 & (v27 - 1)) != 0)
    {
      if (v55 >= v27) {
        v55 %= v27;
      }
    }
    else
    {
      v55 &= v27 - 1;
    }
    uint8x8_t v53 = (void *)(*v23 + 8 * v55);
    goto LABEL_104;
  }
LABEL_105:
  size_t v22 = 0;
  ++v23[3];
LABEL_106:
  if (__p)
  {
    uint64_t v58 = (char *)__p;
    operator delete(__p);
  }
  *(void *)long long v60 = &unk_1F1A74AE8;
  std::deque<SVG::ApplyPresentationState>::~deque[abi:nn180100](v62);
  *(void *)long long v60 = &unk_1F1A74330;
  std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table((uint64_t)&v60[24]);
  std::deque<SVG::BoundingRectState::State>::~deque[abi:nn180100](&v67[32]);
  *(void *)&long long v69 = &v67[22];
  std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v69);
  if (LODWORD(v67[20]) != -1) {
    ((void (*)(long long *, void *))*(&off_1F1A75BD0 + LODWORD(v67[20])))(&v69, &v67[7]);
  }
  LODWORD(v67[20]) = -1;
  std::deque<SVG::Recorder::State>::~deque[abi:nn180100](v67);
  if (__dst[112] != -1) {
    ((void (*)(long long *, _DWORD *))*(&off_1F1A75BA8 + __dst[112]))(&v69, &__dst[104]);
  }
  __dst[112] = -1;
  if (__dst[100] != -1) {
    ((void (*)(long long *, _DWORD *))*(&off_1F1A75B90 + __dst[100]))(&v69, &__dst[88]);
  }
  __dst[100] = -1;
  if (__dst[66] != -1) {
    ((void (*)(long long *, _DWORD *))*(&off_1F1A75B78 + __dst[66]))(&v69, &__dst[62]);
  }
  __dst[66] = -1;
  if (__dst[50] != -1) {
    ((void (*)(long long *, _DWORD *))*(&off_1F1A75B90 + __dst[50]))(&v69, &__dst[38]);
  }
  __dst[50] = -1;
  if (__dst[20] != -1) {
    ((void (*)(long long *, _DWORD *))*(&off_1F1A75B78 + __dst[20]))(&v69, &__dst[16]);
  }
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v22);
  }
}

void std::__shared_ptr_emplace<SVG::Recording>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1A74E60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SVG::Recording>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1A74E60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C18A3E80);
}

void std::__shared_ptr_emplace<SVG::Recording>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  std::vector<std::variant<SVG::SaveState,SVG::RestoreState,SVG::ConcatCTM,SVG::DrawImage,SVG::FillPath,SVG::DrawLinearGradient,SVG::DrawRadialGradient,SVG::ClipToPaths,SVG::ClipToMask,SVG::SetFill,SVG::BeginTransparencyLayer,SVG::EndTransparencyLayer,SVG::SetAlpha,SVG::GetCTM>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

std::string *std::pair<std::string const,std::stack<std::string>>::pair[abi:nn180100](std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = 0u;
  *(_OWORD *)&this[1].__r_.__value_.__r.__words[2] = 0u;
  *(_OWORD *)&this[2].__r_.__value_.__r.__words[1] = 0u;
  unint64_t v5 = *((void *)a2 + 7);
  uint64_t v6 = *((void *)a2 + 4);
  long long v7 = (void *)(v6 + 8 * (v5 / 0xAA));
  if (*((void *)a2 + 5) == v6)
  {
    long long v8 = 0;
    unint64_t v11 = 0;
    uint64_t v10 = (void *)(v6 + 8 * ((*((void *)a2 + 8) + v5) / 0xAA));
  }
  else
  {
    long long v8 = (long long *)(*(void *)(v6 + 8 * (v5 / 0xAA)) + 24 * (v5 % 0xAA));
    unint64_t v9 = *((void *)a2 + 8) + v5;
    uint64_t v10 = (void *)(v6 + 8 * (v9 / 0xAA));
    unint64_t v11 = *v10 + 24 * (v9 % 0xAA);
  }
  if ((long long *)v11 == v8) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = 170 * (v10 - v7)
  }
        - 0x5555555555555555 * ((uint64_t)(v11 - *v10) >> 3)
        + 0x5555555555555555 * (((uint64_t)v8 - *v7) >> 3);
  std::deque<std::string>::__append_with_size[abi:nn180100]<std::__deque_iterator<std::string,std::string const*,std::string const&,std::string const* const*,long,170l>>(this[1].__r_.__value_.__r.__words, v7, v8, v12);
  return this;
}

void std::deque<std::string>::__append_with_size[abi:nn180100]<std::__deque_iterator<std::string,std::string const*,std::string const&,std::string const* const*,long,170l>>(void *a1, void *a2, long long *a3, unint64_t a4)
{
  uint64_t v4 = a4;
  unint64_t v9 = (char *)a1[1];
  long long v8 = (char *)a1[2];
  uint64_t v10 = (v8 - v9) >> 3;
  if (v8 == v9) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 170 * v10 - 1;
  }
  unint64_t v12 = a1[4];
  uint64_t v13 = a1[5];
  unint64_t v14 = v13 + v12;
  unint64_t v15 = v11 - (v13 + v12);
  BOOL v16 = a4 >= v15;
  unint64_t v17 = a4 - v15;
  if (v17 != 0 && v16)
  {
    if (v8 == v9) {
      unint64_t v18 = v17 + 1;
    }
    else {
      unint64_t v18 = v17;
    }
    if (v18 % 0xAA) {
      unint64_t v19 = v18 / 0xAA + 1;
    }
    else {
      unint64_t v19 = v18 / 0xAA;
    }
    if (v19 >= v12 / 0xAA) {
      unint64_t v20 = v12 / 0xAA;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v19 <= v12 / 0xAA)
    {
      for (a1[4] = v12 - 170 * v20; v20; --v20)
      {
        unint64_t v26 = (void *)a1[1];
        uint64_t v29 = *v26;
        unint64_t v27 = (char *)(v26 + 1);
        uint64_t v28 = v29;
        a1[1] = v27;
        if (v8 == (char *)a1[3])
        {
          uint64_t v30 = (uint64_t)&v27[-*a1];
          if ((unint64_t)v27 <= *a1)
          {
            if (v8 == (char *)*a1) {
              unint64_t v38 = 1;
            }
            else {
              unint64_t v38 = (uint64_t)&v8[-*a1] >> 2;
            }
            unint64_t v39 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v38);
            float v41 = &v39[8 * (v38 >> 2)];
            BOOL v42 = (uint64_t *)a1[1];
            long long v8 = v41;
            uint64_t v43 = a1[2] - (void)v42;
            if (v43)
            {
              long long v8 = &v41[v43 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v44 = 8 * (v43 >> 3);
              unint64_t v45 = &v39[8 * (v38 >> 2)];
              do
              {
                uint64_t v46 = *v42++;
                *(void *)unint64_t v45 = v46;
                v45 += 8;
                v44 -= 8;
              }
              while (v44);
            }
            unint64_t v47 = (char *)*a1;
            *a1 = v39;
            a1[1] = v41;
            a1[2] = v8;
            a1[3] = &v39[8 * v40];
            if (v47)
            {
              operator delete(v47);
              long long v8 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v31 = v30 >> 3;
            BOOL v32 = v30 >> 3 < -1;
            uint64_t v33 = (v30 >> 3) + 2;
            if (v32) {
              uint64_t v34 = v33;
            }
            else {
              uint64_t v34 = v31 + 1;
            }
            float v35 = &v27[-8 * (v34 >> 1)];
            int64_t v36 = v8 - v27;
            if (v8 != v27)
            {
              memmove(&v27[-8 * (v34 >> 1)], v27, v8 - v27);
              long long v8 = (char *)a1[1];
            }
            BOOL v37 = &v8[-8 * (v34 >> 1)];
            long long v8 = &v35[v36];
            a1[1] = v37;
            a1[2] = &v35[v36];
          }
        }
        *(void *)long long v8 = v28;
        long long v8 = (char *)(a1[2] + 8);
        a1[2] = v8;
      }
    }
    else
    {
      unint64_t v21 = v19 - v20;
      uint64_t v22 = a1[3] - *a1;
      if (v19 - v20 <= (v22 >> 3) - v10)
      {
        if (v21)
        {
          while (a1[3] != a1[2])
          {
            *(void *)&long long v104 = operator new(0xFF0uLL);
            std::__split_buffer<std::string *>::push_back(a1, &v104);
            --v19;
            if (!--v21)
            {
              long long v8 = (char *)a1[2];
              goto LABEL_78;
            }
          }
          for (uint64_t i = 0; i != v21; ++i)
          {
            *(void *)&long long v104 = operator new(0xFF0uLL);
            std::__split_buffer<std::string *>::push_front((uint64_t)a1, &v104);
            long long v8 = (char *)a1[2];
            if (&v8[-a1[1]] == (char *)8) {
              uint64_t v69 = 169;
            }
            else {
              uint64_t v69 = 170;
            }
            uint64_t v70 = v69 + a1[4];
            a1[4] = v70;
          }
          unint64_t v20 = v19;
        }
        else
        {
LABEL_78:
          uint64_t v70 = a1[4];
        }
        for (a1[4] = v70 - 170 * v20; v20; --v20)
        {
          uint64_t v71 = (void *)a1[1];
          uint64_t v74 = *v71;
          unsigned int v72 = (char *)(v71 + 1);
          uint64_t v73 = v74;
          a1[1] = v72;
          if (v8 == (char *)a1[3])
          {
            uint64_t v75 = (uint64_t)&v72[-*a1];
            if ((unint64_t)v72 <= *a1)
            {
              if (v8 == (char *)*a1) {
                unint64_t v82 = 1;
              }
              else {
                unint64_t v82 = (uint64_t)&v8[-*a1] >> 2;
              }
              uint64_t v83 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v82);
              int v85 = &v83[8 * (v82 >> 2)];
              CGFloat v86 = (uint64_t *)a1[1];
              long long v8 = v85;
              uint64_t v87 = a1[2] - (void)v86;
              if (v87)
              {
                long long v8 = &v85[v87 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v88 = 8 * (v87 >> 3);
                long long v89 = &v83[8 * (v82 >> 2)];
                do
                {
                  uint64_t v90 = *v86++;
                  *(void *)long long v89 = v90;
                  v89 += 8;
                  v88 -= 8;
                }
                while (v88);
              }
              unsigned int v91 = (char *)*a1;
              *a1 = v83;
              a1[1] = v85;
              a1[2] = v8;
              a1[3] = &v83[8 * v84];
              if (v91)
              {
                operator delete(v91);
                long long v8 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v76 = v75 >> 3;
              BOOL v32 = v75 >> 3 < -1;
              uint64_t v77 = (v75 >> 3) + 2;
              if (v32) {
                uint64_t v78 = v77;
              }
              else {
                uint64_t v78 = v76 + 1;
              }
              unsigned int v79 = &v72[-8 * (v78 >> 1)];
              int64_t v80 = v8 - v72;
              if (v8 != v72)
              {
                memmove(&v72[-8 * (v78 >> 1)], v72, v8 - v72);
                long long v8 = (char *)a1[1];
              }
              unsigned int v81 = &v8[-8 * (v78 >> 1)];
              long long v8 = &v79[v80];
              a1[1] = v81;
              a1[2] = &v79[v80];
            }
          }
          *(void *)long long v8 = v73;
          long long v8 = (char *)(a1[2] + 8);
          a1[2] = v8;
        }
      }
      else
      {
        if (v22 >> 2 <= v21 + v10) {
          unint64_t v23 = v21 + v10;
        }
        else {
          unint64_t v23 = v22 >> 2;
        }
        unint64_t v24 = v10 - v20;
        long long v106 = a1 + 3;
        if (v23) {
          unint64_t v23 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v23);
        }
        else {
          uint64_t v25 = 0;
        }
        uint64_t v101 = -170 * v20;
        uint64_t v102 = v4;
        *(void *)&long long v104 = v23;
        *((void *)&v104 + 1) = v23 + 8 * v24;
        *(void *)&long long v105 = *((void *)&v104 + 1);
        *((void *)&v105 + 1) = v23 + 8 * v25;
        do
        {
          long long v103 = operator new(0xFF0uLL);
          std::__split_buffer<std::string *>::push_back(&v104, &v103);
          --v21;
        }
        while (v21);
        uint8x8_t v48 = (void *)a1[1];
        if (v20)
        {
          uint64_t v49 = (char *)v105;
          do
          {
            if (v49 == *((char **)&v105 + 1))
            {
              unint64_t v50 = (char *)*((void *)&v104 + 1);
              unint64_t v51 = (void *)v104;
              if (*((void *)&v104 + 1) <= (unint64_t)v104)
              {
                if (v49 == (char *)v104) {
                  unint64_t v57 = 1;
                }
                else {
                  unint64_t v57 = (uint64_t)&v49[-v104] >> 2;
                }
                uint64_t v58 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v57);
                uint64_t v61 = v49 - v50;
                BOOL v60 = v49 == v50;
                uint64_t v49 = &v58[8 * (v57 >> 2)];
                if (!v60)
                {
                  uint64_t v49 = &v58[8 * (v57 >> 2) + (v61 & 0xFFFFFFFFFFFFFFF8)];
                  uint64_t v62 = 8 * (v61 >> 3);
                  uint64_t v63 = &v58[8 * (v57 >> 2)];
                  do
                  {
                    uint64_t v64 = *(void *)v50;
                    v50 += 8;
                    *(void *)uint64_t v63 = v64;
                    v63 += 8;
                    v62 -= 8;
                  }
                  while (v62);
                }
                *(void *)&long long v104 = v58;
                *((void *)&v104 + 1) = &v58[8 * (v57 >> 2)];
                *(void *)&long long v105 = v49;
                *((void *)&v105 + 1) = &v58[8 * v59];
                if (v51) {
                  operator delete(v51);
                }
              }
              else
              {
                uint64_t v52 = (uint64_t)(*((void *)&v104 + 1) - v104) >> 3;
                if (v52 >= -1) {
                  uint64_t v53 = v52 + 1;
                }
                else {
                  uint64_t v53 = v52 + 2;
                }
                uint64_t v54 = *((void *)&v104 + 1) - 8 * (v53 >> 1);
                unint64_t v55 = &v49[-*((void *)&v104 + 1)];
                if (v49 != *((char **)&v104 + 1))
                {
                  memmove((void *)(*((void *)&v104 + 1) - 8 * (v53 >> 1)), *((const void **)&v104 + 1), (size_t)&v49[-*((void *)&v104 + 1)]);
                  uint64_t v49 = v50;
                }
                unint64_t v56 = &v49[-8 * (v53 >> 1)];
                uint64_t v49 = &v55[v54];
                *((void *)&v104 + 1) = v56;
                *(void *)&long long v105 = &v55[v54];
              }
            }
            *(void *)uint64_t v49 = *v48;
            uint64_t v49 = (char *)(v105 + 8);
            *(void *)&long long v105 = v105 + 8;
            uint8x8_t v48 = (void *)(a1[1] + 8);
            a1[1] = v48;
            --v20;
          }
          while (v20);
        }
        long long v65 = (void *)a1[2];
        if (v65 != v48)
        {
          do
            std::__split_buffer<std::string *>::push_front((uint64_t)&v104, --v65);
          while (v65 != (void *)a1[1]);
        }
        long long v66 = (char *)*a1;
        long long v67 = v105;
        *(_OWORD *)a1 = v104;
        *((_OWORD *)a1 + 1) = v67;
        uint64_t v4 = v102;
        a1[4] += v101;
        if (v66)
        {
          operator delete(v66);
          long long v8 = (char *)a1[2];
        }
        else
        {
          long long v8 = (char *)v67;
        }
      }
    }
    uint64_t v13 = a1[5];
    unint64_t v9 = (char *)a1[1];
    unint64_t v14 = a1[4] + v13;
  }
  long long v92 = &v9[8 * (v14 / 0xAA)];
  if (v8 == v9) {
    unint64_t v93 = 0;
  }
  else {
    unint64_t v93 = *(void *)v92 + 24 * (v14 % 0xAA);
  }
  *(void *)&long long v104 = &v9[8 * (v14 / 0xAA)];
  *((void *)&v104 + 1) = v93;
  std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>::operator+=[abi:nn180100](&v104, v4);
  uint64_t v94 = *((void *)&v104 + 1);
  if (v93 != *((void *)&v104 + 1))
  {
    long long v95 = (char *)v104;
    do
    {
      if (v92 == v95) {
        uint64_t v96 = v94;
      }
      else {
        uint64_t v96 = *(void *)v92 + 4080;
      }
      if (v93 == v96)
      {
        uint64_t v96 = v93;
      }
      else
      {
        long long v97 = (std::string *)v93;
        do
        {
          if (*((char *)a3 + 23) < 0)
          {
            std::string::__init_copy_ctor_external(v97, *(const std::string::value_type **)a3, *((void *)a3 + 1));
          }
          else
          {
            long long v98 = *a3;
            v97->__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
            *(_OWORD *)&v97->__r_.__value_.__l.__data_ = v98;
          }
          a3 = (long long *)((char *)a3 + 24);
          if ((long long *)((char *)a3 - *a2) == (long long *)4080)
          {
            uint64_t v99 = (long long *)a2[1];
            ++a2;
            a3 = v99;
          }
          ++v97;
        }
        while (v97 != (std::string *)v96);
        uint64_t v13 = a1[5];
      }
      v13 -= 0x5555555555555555 * ((uint64_t)(v96 - v93) >> 3);
      a1[5] = v13;
      if (v92 == v95) {
        break;
      }
      unint64_t v100 = *((void *)v92 + 1);
      v92 += 8;
      unint64_t v93 = v100;
    }
    while (v100 != v94);
  }
}

void std::__split_buffer<std::string *>::push_back(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    unint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      unint64_t v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v16);
      unint64_t v19 = &v17[8 * (v16 >> 2)];
      unint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v22 = 8 * (v21 >> 3);
        unint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)unint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      uint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }
      unint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<std::string *>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Recorder::State *>>(v11);
      unint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      unint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        unint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)unint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        unint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      unint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    unint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void *std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>::operator+=[abi:nn180100](void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x5555555555555555 * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 169 - v3;
      uint64_t v6 = &v2[-(v5 / 0xAA)];
      *double result = v6;
      unint64_t v4 = *v6 + 24 * (170 * (v5 / 0xAA) - v5) + 4056;
    }
    else
    {
      *double result = &v2[v3 / 0xAA];
      unint64_t v4 = v2[v3 / 0xAA] + 24 * (v3 % 0xAA);
    }
    result[1] = v4;
  }
  return result;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::stack<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::stack<std::string>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::stack<std::string>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::stack<std::string>>,0>(uint64_t a1)
{
  std::deque<std::string>::~deque[abi:nn180100](a1 + 24);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::stack<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::stack<std::string>>>>::__node_insert_multi(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)a2;
  unint64_t v4 = (unsigned __int8 *)(a2 + 16);
  unint64_t v5 = *(unsigned __int8 *)(a2 + 39);
  unint64_t v6 = *(void *)(a2 + 24);
  if ((v5 & 0x80u) == 0) {
    uint64_t v7 = (uint64_t *)(a2 + 16);
  }
  else {
    uint64_t v7 = *(uint64_t **)(a2 + 16);
  }
  if ((v5 & 0x80u) == 0) {
    unint64_t v8 = v5;
  }
  else {
    unint64_t v8 = v6;
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v49, v7, v8);
  float v10 = *(float *)(a1 + 32);
  unint64_t v48 = v9;
  *((void *)v4 - 1) = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  if (!v11 || (float)(v10 * (float)v11) < v12)
  {
    BOOL v13 = 1;
    if (v11 >= 3) {
      BOOL v13 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v14 = v13 | (2 * v11);
    unint64_t v15 = vcvtps_u32_f32(v12 / v10);
    if (v14 <= v15) {
      int8x8_t prime = (int8x8_t)v15;
    }
    else {
      int8x8_t prime = (int8x8_t)v14;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    unint64_t v47 = v2;
    if (*(void *)&prime > v11)
    {
LABEL_19:
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v17 = operator new(8 * *(void *)&prime);
      uint64_t v18 = *(void **)a1;
      *(void *)a1 = v17;
      if (v18) {
        operator delete(v18);
      }
      uint64_t v19 = 0;
      *(int8x8_t *)(a1 + 8) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v19++) = 0;
      while (*(void *)&prime != v19);
      uint64_t v20 = *(unsigned __int8 ***)(a1 + 16);
      if (v20)
      {
        unint64_t v21 = (unint64_t)v20[1];
        uint8x8_t v22 = (uint8x8_t)vcnt_s8(prime);
        v22.i16[0] = vaddlv_u8(v22);
        unint64_t v23 = v22.u32[0];
        if (v22.u32[0] > 1uLL)
        {
          if (v21 >= *(void *)&prime) {
            v21 %= *(void *)&prime;
          }
        }
        else
        {
          v21 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)a1 + 8 * v21) = a1 + 16;
        unint64_t v27 = *v20;
        if (*v20)
        {
          unint64_t v46 = v22.u32[0];
          do
          {
            unint64_t v28 = *((void *)v27 + 1);
            if (v23 > 1)
            {
              if (v28 >= *(void *)&prime) {
                v28 %= *(void *)&prime;
              }
            }
            else
            {
              v28 &= *(void *)&prime - 1;
            }
            if (v28 == v21)
            {
              uint64_t v20 = (unsigned __int8 **)v27;
            }
            else if (*(void *)(*(void *)a1 + 8 * v28))
            {
              uint64_t v29 = *(unsigned __int8 **)v27;
              if (*(void *)v27)
              {
                uint64_t v30 = v27;
                while (1)
                {
                  int v31 = std::equal_to<std::string>::operator()[abi:nn180100](a1 + 32, v27 + 16, v29 + 16);
                  BOOL v32 = *(unsigned __int8 **)v30;
                  if (!v31) {
                    break;
                  }
                  uint64_t v29 = *(unsigned __int8 **)v32;
                  uint64_t v30 = *(unsigned __int8 **)v30;
                  if (!*(void *)v32) {
                    goto LABEL_52;
                  }
                }
                uint64_t v29 = *(unsigned __int8 **)v30;
                BOOL v32 = v30;
LABEL_52:
                unint64_t v23 = v46;
              }
              else
              {
                BOOL v32 = v27;
              }
              *uint64_t v20 = v29;
              *(void *)BOOL v32 = **(void **)(*(void *)a1 + 8 * v28);
              **(void **)(*(void *)a1 + 8 * v28) = v27;
            }
            else
            {
              *(void *)(*(void *)a1 + 8 * v28) = v20;
              uint64_t v20 = (unsigned __int8 **)v27;
              unint64_t v21 = v28;
            }
            unint64_t v27 = *v20;
          }
          while (*v20);
        }
      }
      goto LABEL_64;
    }
    if (*(void *)&prime < v11)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime < v11)
      {
        if (prime) {
          goto LABEL_19;
        }
        uint64_t v33 = *(void **)a1;
        *(void *)a1 = 0;
        if (v33) {
          operator delete(v33);
        }
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_64:
    unint64_t v11 = *(void *)(a1 + 8);
    uint64_t v2 = v47;
  }
  uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
  v34.i16[0] = vaddlv_u8(v34);
  unint64_t v35 = v34.u32[0];
  if (v34.u32[0] > 1uLL)
  {
    unint64_t v36 = v48;
    if (v11 <= v48) {
      unint64_t v36 = v48 % v11;
    }
  }
  else
  {
    unint64_t v36 = (v11 - 1) & v48;
  }
  BOOL v37 = *(unsigned __int8 **)(*(void *)a1 + 8 * v36);
  if (v37)
  {
    unint64_t v38 = *(unsigned __int8 **)v37;
    if (*(void *)v37)
    {
      int v39 = 0;
      do
      {
        unint64_t v40 = *((void *)v38 + 1);
        if (v35 > 1)
        {
          unint64_t v41 = *((void *)v38 + 1);
          if (v40 >= v11) {
            unint64_t v41 = v40 % v11;
          }
        }
        else
        {
          unint64_t v41 = v40 & (v11 - 1);
        }
        if (v41 != v36) {
          break;
        }
        int v42 = v40 == v48 ? std::equal_to<std::string>::operator()[abi:nn180100](a1 + 32, v38 + 16, v4) : 0;
        if (v39 & (v42 ^ 1)) {
          break;
        }
        v39 |= v42;
        BOOL v37 = *(unsigned __int8 **)v37;
        unint64_t v38 = *(unsigned __int8 **)v37;
      }
      while (*(void *)v37);
      unint64_t v11 = *(void *)(a1 + 8);
      uint8x8_t v43 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
      v43.i16[0] = vaddlv_u8(v43);
      unint64_t v35 = v43.u32[0];
    }
  }
  unint64_t v44 = v2[1];
  if (v35 > 1)
  {
    if (v44 >= v11) {
      v44 %= v11;
    }
  }
  else
  {
    v44 &= v11 - 1;
  }
  if (!v37)
  {
    *uint64_t v2 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v2;
    *(void *)(*(void *)a1 + 8 * v44) = a1 + 16;
    if (!*v2) {
      goto LABEL_101;
    }
    unint64_t v45 = *(void *)(*v2 + 8);
    if (v35 > 1)
    {
      if (v45 >= v11) {
        v45 %= v11;
      }
    }
    else
    {
      v45 &= v11 - 1;
    }
LABEL_100:
    *(void *)(*(void *)a1 + 8 * v45) = v2;
    goto LABEL_101;
  }
  *uint64_t v2 = *(void *)v37;
  *(void *)BOOL v37 = v2;
  if (*v2)
  {
    unint64_t v45 = *(void *)(*v2 + 8);
    if (v35 > 1)
    {
      if (v45 >= v11) {
        v45 %= v11;
      }
    }
    else
    {
      v45 &= v11 - 1;
    }
    if (v45 != v44) {
      goto LABEL_100;
    }
  }
LABEL_101:
  ++*(void *)(a1 + 24);
}

void std::__hash_table<std::__hash_value_type<std::string,std::stack<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::stack<std::string>>>>::__deallocate_node(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      uint64_t v2 = (void *)*v1;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::stack<std::string>>,0>((uint64_t)(v1 + 2));
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

double std::__for_each_segment[abi:nn180100]<std::__deque_iterator<std::string,std::string const*,std::string const&,std::string const* const*,long,170l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<std::string,std::string const*,std::string const&,std::string const* const*,long,170l>,std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>>>(std::string **a1, std::string *a2, std::string **a3, std::string *a4, uint64_t a5)
{
  std::string::size_type size = *(std::string ***)a5;
  unint64_t v8 = *(std::string **)(a5 + 8);
  if (a1 == a3)
  {
    memset(&v14, 170, sizeof(v14));
  }
  else
  {
    float v10 = a1 + 1;
    for (uint64_t i = *a1 + 170; ; uint64_t i = v12 + 170)
    {
      memset(&v14, 170, sizeof(v14));
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::string const*,std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>,0>(&v14, a2, i, size, v8);
      unint64_t v8 = (std::string *)v14.__r_.__value_.__r.__words[2];
      std::string::size_type size = (std::string **)v14.__r_.__value_.__l.__size_;
      *(void *)a5 = v14.__r_.__value_.__l.__size_;
      *(void *)(a5 + 8) = v8;
      if (v10 == a3) {
        break;
      }
      float v12 = *v10++;
      a2 = v12;
    }
    a2 = *a3;
    memset(&v14, 170, sizeof(v14));
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::string const*,std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>,0>(&v14, a2, a4, size, v8);
  double result = *(double *)&v14.__r_.__value_.__l.__size_;
  *(_OWORD *)a5 = *(_OWORD *)&v14.__r_.__value_.__r.__words[1];
  return result;
}

std::string *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::string const*,std::__deque_iterator<std::string,std::string*,std::string&,std::string**,long,170l>,0>(std::string *result, std::string *__str, std::string *a3, std::string **a4, std::string *this)
{
  unint64_t v6 = a4;
  uint64_t v7 = __str;
  words = result->__r_.__value_.__r.__words;
  if (__str == a3)
  {
    unint64_t v9 = __str;
  }
  else
  {
    unint64_t v9 = a3;
    float v10 = *a4;
    while (1)
    {
      int64_t v11 = 0xAAAAAAAAAAAAAAABLL * (((char *)v10 - (char *)this + 4080) >> 3);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (char *)v7) >> 3)) < v11) {
        int64_t v11 = 0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (char *)v7) >> 3);
      }
      if (v11)
      {
        float v12 = v7 + v11;
        uint64_t v13 = 24 * v11;
        do
        {
          double result = std::string::operator=(this++, v7++);
          v13 -= 24;
        }
        while (v13);
        uint64_t v7 = v12;
      }
      if (v7 == v9) {
        break;
      }
      std::string v14 = v6[1];
      ++v6;
      float v10 = v14;
      this = v14;
    }
    if (&(*v6)[170] == this)
    {
      unint64_t v15 = v6[1];
      ++v6;
      this = v15;
    }
  }
  void *words = v9;
  words[1] = v6;
  words[2] = this;
  return result;
}

BOOL std::deque<std::string>::__maybe_remove_back_spare[abi:nn180100](void *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v1 = a1[2];
  if (v1 == v2) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 170 * ((v1 - v2) >> 3) - 1;
  }
  unint64_t v4 = v3 - (a1[5] + a1[4]);
  if (v4 >= 0x154)
  {
    operator delete(*(void **)(v1 - 8));
    a1[2] -= 8;
  }
  return v4 > 0x153;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::stack<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::stack<std::string>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::stack<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::stack<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::stack<std::string>>>>::__deallocate_node(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::__deallocate_node(*(void ***)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::__deallocate_node(void **__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      uint64_t v2 = (void **)*v1;
      if (*((char *)v1 + 39) < 0) {
        operator delete(v1[2]);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::__unordered_map_hasher<SVG::Element const*,std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,true>,std::__unordered_map_equal<SVG::Element const*,std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::equal_to<SVG::Element const*>,std::hash<SVG::Element const*>,true>,std::allocator<std::__hash_value_type<SVG::Element const*,SVG::Presentation>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::__unordered_map_hasher<SVG::Element const*,std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,true>,std::__unordered_map_equal<SVG::Element const*,std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::equal_to<SVG::Element const*>,std::hash<SVG::Element const*>,true>,std::allocator<std::__hash_value_type<SVG::Element const*,SVG::Presentation>>>::__deallocate_node(*(unsigned int **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::__unordered_map_hasher<SVG::Element const*,std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,true>,std::__unordered_map_equal<SVG::Element const*,std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::equal_to<SVG::Element const*>,std::hash<SVG::Element const*>,true>,std::allocator<std::__hash_value_type<SVG::Element const*,SVG::Presentation>>>::__deallocate_node(unsigned int *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      uint64_t v2 = *(unsigned int **)v1;
      uint64_t v3 = v1[118];
      if (v3 != -1) {
        ((void (*)(char *, unsigned int *))*(&off_1F1A75BA8 + v3))(&v8, v1 + 110);
      }
      v1[118] = -1;
      uint64_t v4 = v1[106];
      if (v4 != -1) {
        ((void (*)(char *, unsigned int *))*(&off_1F1A75B90 + v4))(&v9, v1 + 94);
      }
      v1[106] = -1;
      uint64_t v5 = v1[72];
      if (v5 != -1) {
        ((void (*)(char *, unsigned int *))*(&off_1F1A75B78 + v5))(&v10, v1 + 68);
      }
      v1[72] = -1;
      uint64_t v6 = v1[56];
      if (v6 != -1) {
        ((void (*)(char *, unsigned int *))*(&off_1F1A75B90 + v6))(&v11, v1 + 44);
      }
      v1[56] = -1;
      uint64_t v7 = v1[26];
      if (v7 != -1) {
        ((void (*)(char *, unsigned int *))*(&off_1F1A75B78 + v7))(&v12, v1 + 22);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::__unordered_map_hasher<SVG::GradientElement const*,std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,true>,std::__unordered_map_equal<SVG::GradientElement const*,std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::equal_to<SVG::GradientElement const*>,std::hash<SVG::GradientElement const*>,true>,std::allocator<std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::__unordered_map_hasher<SVG::GradientElement const*,std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,true>,std::__unordered_map_equal<SVG::GradientElement const*,std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::equal_to<SVG::GradientElement const*>,std::hash<SVG::GradientElement const*>,true>,std::allocator<std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>>>::__deallocate_node(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::__unordered_map_hasher<SVG::GradientElement const*,std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,true>,std::__unordered_map_equal<SVG::GradientElement const*,std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::equal_to<SVG::GradientElement const*>,std::hash<SVG::GradientElement const*>,true>,std::allocator<std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>>>::__deallocate_node(void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      uint64_t v2 = (void *)*v1;
      uint64_t v3 = (const void *)v1[3];
      if (v3) {
        CFRelease(v3);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::__unordered_map_hasher<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,true>,std::__unordered_map_equal<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::equal_to<SVG::PatternElement const*>,std::hash<SVG::PatternElement const*>,true>,std::allocator<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::__unordered_map_hasher<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,true>,std::__unordered_map_equal<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::equal_to<SVG::PatternElement const*>,std::hash<SVG::PatternElement const*>,true>,std::allocator<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>>>::__deallocate_node(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::__unordered_map_hasher<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,true>,std::__unordered_map_equal<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::equal_to<SVG::PatternElement const*>,std::hash<SVG::PatternElement const*>,true>,std::allocator<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>>>::__deallocate_node(void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      uint64_t v2 = (void *)*v1;
      uint64_t v3 = (std::__shared_weak_count *)v1[4];
      if (v3) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v3);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void std::__shared_ptr_pointer<SVG::Document *,std::shared_ptr<SVG::Document>::__shared_ptr_default_delete<SVG::Document,SVG::Document>,std::allocator<SVG::Document>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1C18A3E80);
}

uint64_t std::__shared_ptr_pointer<SVG::Document *,std::shared_ptr<SVG::Document>::__shared_ptr_default_delete<SVG::Document,SVG::Document>,std::allocator<SVG::Document>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 352);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        uint64_t v4 = (std::__shared_weak_count *)v2[4];
        if (v4) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v4);
        }
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uint64_t v5 = *(void **)(v1 + 336);
    *(void *)(v1 + 336) = 0;
    if (v5) {
      operator delete(v5);
    }
    std::__hash_table<std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::__unordered_map_hasher<SVG::Element const*,std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,true>,std::__unordered_map_equal<SVG::Element const*,std::__hash_value_type<SVG::Element const*,SVG::Presentation>,std::equal_to<SVG::Element const*>,std::hash<SVG::Element const*>,true>,std::allocator<std::__hash_value_type<SVG::Element const*,SVG::Presentation>>>::~__hash_table(v1 + 296);
    std::__hash_table<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::__unordered_map_hasher<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,true>,std::__unordered_map_equal<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::equal_to<SVG::PatternElement const*>,std::hash<SVG::PatternElement const*>,true>,std::allocator<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>>>::~__hash_table(v1 + 256);
    std::__hash_table<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::__unordered_map_hasher<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::hash<SVG::PatternElement const*>,std::equal_to<SVG::PatternElement const*>,true>,std::__unordered_map_equal<SVG::PatternElement const*,std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>,std::equal_to<SVG::PatternElement const*>,std::hash<SVG::PatternElement const*>,true>,std::allocator<std::__hash_value_type<SVG::PatternElement const*,SVG::Document::PatternData>>>::~__hash_table(v1 + 216);
    std::__hash_table<std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::__unordered_map_hasher<SVG::GradientElement const*,std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,true>,std::__unordered_map_equal<SVG::GradientElement const*,std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>,std::equal_to<SVG::GradientElement const*>,std::hash<SVG::GradientElement const*>,true>,std::allocator<std::__hash_value_type<SVG::GradientElement const*,SVG::CF<CGGradient *>>>>::~__hash_table(v1 + 176);
    std::__hash_table<SVG::Element const*,std::hash<SVG::Element const*>,std::equal_to<SVG::Element const*>,std::allocator<SVG::Element const*>>::~__hash_table(v1 + 136);
    std::__hash_table<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::reference_wrapper<SVG::Element>>>>::~__hash_table(v1 + 96);
    uint64_t v6 = *(const void **)(v1 + 88);
    if (v6) {
      CFRelease(v6);
    }
    uint64_t v7 = *(void *)(v1 + 64);
    *(void *)(v1 + 64) = 0;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    std::mutex::~mutex((std::mutex *)v1);
    JUMPOUT(0x1C18A3E80);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<SVG::Document *,std::shared_ptr<SVG::Document>::__shared_ptr_default_delete<SVG::Document,SVG::Document>,std::allocator<SVG::Document>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

_OWORD *SVG::RectElement::RectElement(_OWORD *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::ShapeElement::ShapeElement((uint64_t)a1, a2, a3);
  *(void *)uint64_t v5 = &unk_1F1A74580;
  *(void *)(v5 + 688) = 0;
  *(_DWORD *)(v5 + 696) = 0;
  *(void *)(v5 + 704) = 0;
  *(_DWORD *)(v5 + 712) = 0;
  *(void *)(v5 + 72CGContextBeginTransparencyLayer(c, 0) = 0;
  *(_DWORD *)(v5 + 728) = 0;
  *(void *)(v5 + 736) = 0;
  *(_DWORD *)(v5 + 744) = 0;
  *(void *)(v5 + 752) = 0;
  *(_DWORD *)(v5 + 76CGContextBeginTransparencyLayer(c, 0) = 0;
  *(void *)(v5 + 768) = 0;
  *(_DWORD *)(v5 + 776) = 0;
  std::string::basic_string[abi:nn180100]<0>(v17, "x");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0)
  {
    operator delete(v17[0]);
    if (!v6) {
      goto LABEL_9;
    }
  }
  else if (!v6)
  {
    goto LABEL_9;
  }
  v17[0] = (void *)-1;
  v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v6 + 64), (uint64_t)v17);
  if ((_BYTE)v18) {
    a1[43] = *(_OWORD *)v17;
  }
LABEL_9:
  std::string::basic_string[abi:nn180100]<0>(v17, "y");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v7 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0)
  {
    operator delete(v17[0]);
    if (!v7) {
      goto LABEL_17;
    }
  }
  else if (!v7)
  {
    goto LABEL_17;
  }
  v17[0] = (void *)-1;
  v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v7 + 64), (uint64_t)v17);
  if ((_BYTE)v18) {
    a1[44] = *(_OWORD *)v17;
  }
LABEL_17:
  std::string::basic_string[abi:nn180100]<0>(v17, "width");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0)
  {
    operator delete(v17[0]);
    if (!v8) {
      goto LABEL_25;
    }
  }
  else if (!v8)
  {
    goto LABEL_25;
  }
  v17[0] = (void *)-1;
  v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v8 + 64), (uint64_t)v17);
  if ((_BYTE)v18) {
    a1[45] = *(_OWORD *)v17;
  }
LABEL_25:
  std::string::basic_string[abi:nn180100]<0>(v17, "height");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v9 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0)
  {
    operator delete(v17[0]);
    if (!v9) {
      goto LABEL_33;
    }
  }
  else if (!v9)
  {
    goto LABEL_33;
  }
  v17[0] = (void *)-1;
  v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v9 + 64), (uint64_t)v17);
  if ((_BYTE)v18) {
    a1[46] = *(_OWORD *)v17;
  }
LABEL_33:
  std::string::basic_string[abi:nn180100]<0>(v17, "rx");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v10 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(v17, "ry");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v11 = SVG::Element::findInAttributeMap(a3, (uint64_t)v17, (uint64_t)__p);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
  char v12 = a1 + 47;
  if (v10)
  {
    v17[0] = (void *)-1;
    v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v10 + 64), (uint64_t)v17);
    if ((_BYTE)v18) {
      *char v12 = *(_OWORD *)v17;
    }
  }
  uint64_t v13 = a1 + 48;
  if (v11)
  {
    v17[0] = (void *)-1;
    v17[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v11 + 64), (uint64_t)v17);
    if ((_BYTE)v18) {
      *uint64_t v13 = *(_OWORD *)v17;
    }
  }
  if (!v10)
  {
    *char v12 = *v13;
    if (v11) {
      return a1;
    }
LABEL_51:
    *uint64_t v13 = *v12;
    return a1;
  }
  if (!v11) {
    goto LABEL_51;
  }
  return a1;
}

double SVG::RectElement::boundingBox(SVG::RectElement *this, CGRect a2)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double v5 = SVG::Length::computeValue((SVG::RectElement *)((char *)this + 688), a2.size.width);
  SVG::Length::computeValue((SVG::RectElement *)((char *)this + 704), height);
  SVG::Length::computeValue((SVG::RectElement *)((char *)this + 720), width);
  SVG::Length::computeValue((SVG::RectElement *)((char *)this + 736), height);
  return v5;
}

void SVG::RectElement::path(SVG::RectElement *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, CGPathRef *a3@<X8>)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double v7 = SVG::RectElement::boundingBox(this, a2);
  CGFloat v9 = v8;
  double v11 = v10;
  double v13 = v12;
  double v14 = SVG::Length::computeValue((SVG::RectElement *)((char *)this + 752), width);
  double v15 = SVG::Length::computeValue((SVG::RectElement *)((char *)this + 768), height);
  if (v11 * 0.5 >= v14) {
    double v16 = v14;
  }
  else {
    double v16 = v11 * 0.5;
  }
  if (v13 * 0.5 >= v15) {
    double v17 = v15;
  }
  else {
    double v17 = v13 * 0.5;
  }
  if (v11 <= 0.0 || v13 <= 0.0)
  {
    *a3 = 0;
  }
  else if (v16 == 0.0 || v17 == 0.0)
  {
    v58.origin.CGFloat x = v7;
    v58.origin.CGFloat y = v9;
    v58.size.double width = v11;
    v58.size.double height = v13;
    *a3 = CGPathCreateWithRect(v58, 0);
  }
  else
  {
    Mutable = CGPathCreateMutable();
    CGPathMoveToPoint(Mutable, 0, v7 + v16, v9);
    v50.origin.CGFloat x = v7;
    v50.origin.CGFloat y = v9;
    v50.size.double width = v11;
    v50.size.double height = v13;
    CGFloat MaxX = CGRectGetMaxX(v50);
    CGPathAddLineToPoint(Mutable, 0, MaxX - v16, v9);
    *(void *)&long long v20 = -1;
    *((void *)&v20 + 1) = -1;
    *(_OWORD *)&v49.CGFloat c = v20;
    *(_OWORD *)&v49.tCGFloat x = v20;
    *(_OWORD *)&v49.CGFloat a = v20;
    CGAffineTransformMakeScale(&v49, v16, v17);
    v51.origin.CGFloat x = v7;
    v51.origin.CGFloat y = v9;
    v51.size.double width = v11;
    v51.size.double height = v13;
    CGFloat v21 = CGRectGetMaxX(v51) - v16;
    CGAffineTransform v47 = v49;
    CGAffineTransformInvert(&v48, &v47);
    *(void *)&long long v22 = -1;
    *((void *)&v22 + 1) = -1;
    *(_OWORD *)&m.CGFloat c = v22;
    *(_OWORD *)&m.tCGFloat x = v22;
    CGAffineTransform v45 = v49;
    *(_OWORD *)&m.CGFloat a = v22;
    CGAffineTransformTranslate(&m, &v45, v48.tx + (v9 + v17) * v48.c + v48.a * v21, v48.ty + (v9 + v17) * v48.d + v48.b * v21);
    CGPathAddArc(Mutable, &m, 0.0, 0.0, 1.0, 4.71238898, 6.28318531, 0);
    v52.origin.CGFloat x = v7;
    v52.origin.CGFloat y = v9;
    v52.size.double width = v11;
    v52.size.double height = v13;
    CGFloat v23 = CGRectGetMaxX(v52);
    v53.origin.CGFloat x = v7;
    v53.origin.CGFloat y = v9;
    v53.size.double width = v11;
    v53.size.double height = v13;
    CGFloat MaxY = CGRectGetMaxY(v53);
    CGPathAddLineToPoint(Mutable, 0, v23, MaxY - v17);
    *(void *)&long long v25 = -1;
    *((void *)&v25 + 1) = -1;
    *(_OWORD *)&v49.CGFloat c = v25;
    *(_OWORD *)&v49.tCGFloat x = v25;
    *(_OWORD *)&v49.CGFloat a = v25;
    CGAffineTransformMakeScale(&v49, v16, v17);
    v54.origin.CGFloat x = v7;
    v54.origin.CGFloat y = v9;
    v54.size.double width = v11;
    v54.size.double height = v13;
    CGFloat v26 = CGRectGetMaxX(v54) - v16;
    v55.origin.CGFloat x = v7;
    v55.origin.CGFloat y = v9;
    v55.size.double width = v11;
    v55.size.double height = v13;
    CGFloat v27 = CGRectGetMaxY(v55) - v17;
    CGAffineTransform v43 = v49;
    CGAffineTransformInvert(&v44, &v43);
    *(void *)&long long v28 = -1;
    *((void *)&v28 + 1) = -1;
    *(_OWORD *)&m.CGFloat c = v28;
    *(_OWORD *)&m.tCGFloat x = v28;
    *(_OWORD *)&m.CGFloat a = v28;
    CGAffineTransform v42 = v49;
    CGAffineTransformTranslate(&m, &v42, v44.tx + v27 * v44.c + v44.a * v26, v44.ty + v27 * v44.d + v44.b * v26);
    CGPathAddArc(Mutable, &m, 0.0, 0.0, 1.0, 0.0, 1.57079633, 0);
    v56.origin.CGFloat x = v7;
    v56.origin.CGFloat y = v9;
    v56.size.double width = v11;
    v56.size.double height = v13;
    CGFloat v29 = CGRectGetMaxY(v56);
    double v30 = v7 + v16;
    CGPathAddLineToPoint(Mutable, 0, v7 + v16, v29);
    *(void *)&long long v31 = -1;
    *((void *)&v31 + 1) = -1;
    *(_OWORD *)&v49.CGFloat c = v31;
    *(_OWORD *)&v49.tCGFloat x = v31;
    *(_OWORD *)&v49.CGFloat a = v31;
    CGAffineTransformMakeScale(&v49, v16, v17);
    v57.origin.CGFloat x = v7;
    v57.origin.CGFloat y = v9;
    v57.size.double width = v11;
    v57.size.double height = v13;
    CGFloat v32 = CGRectGetMaxY(v57) - v17;
    CGAffineTransform v40 = v49;
    CGAffineTransformInvert(&v41, &v40);
    *(void *)&long long v33 = -1;
    *((void *)&v33 + 1) = -1;
    *(_OWORD *)&m.CGFloat c = v33;
    *(_OWORD *)&m.tCGFloat x = v33;
    *(_OWORD *)&m.CGFloat a = v33;
    CGAffineTransform v39 = v49;
    CGAffineTransformTranslate(&m, &v39, v41.tx + v32 * v41.c + v41.a * v30, v41.ty + v32 * v41.d + v41.b * v30);
    CGPathAddArc(Mutable, &m, 0.0, 0.0, 1.0, 1.57079633, 3.14159265, 0);
    CGPathAddLineToPoint(Mutable, 0, v7, v9 + v17);
    *(void *)&long long v34 = -1;
    *((void *)&v34 + 1) = -1;
    *(_OWORD *)&v49.CGFloat c = v34;
    *(_OWORD *)&v49.tCGFloat x = v34;
    *(_OWORD *)&v49.CGFloat a = v34;
    CGAffineTransformMakeScale(&v49, v16, v17);
    CGAffineTransform v37 = v49;
    CGAffineTransformInvert(&v38, &v37);
    *(void *)&long long v35 = -1;
    *((void *)&v35 + 1) = -1;
    *(_OWORD *)&m.CGFloat c = v35;
    *(_OWORD *)&m.tCGFloat x = v35;
    *(_OWORD *)&m.CGFloat a = v35;
    CGAffineTransform v36 = v49;
    CGAffineTransformTranslate(&m, &v36, v38.tx + (v9 + v17) * v38.c + v38.a * v30, v38.ty + (v9 + v17) * v38.d + v38.b * v30);
    CGPathAddArc(Mutable, &m, 0.0, 0.0, 1.0, 3.14159265, 4.71238898, 0);
    CGPathCloseSubpath(Mutable);
    *a3 = Mutable;
    if (Mutable)
    {
      CFRetain(Mutable);
      CFRelease(Mutable);
    }
  }
}

void SVG::RectElement::~RectElement(SVG::RectElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75BE8 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C00 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C18 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C00 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C18 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75BE8 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C00 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C18 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C00 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C18 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

uint64_t SVG::PolygonElement::PolygonElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = (void *)SVG::ShapeElement::ShapeElement(a1, a2, a3);
  *uint64_t v5 = &unk_1F1A74758;
  v5[86] = 0;
  v5[88] = 0;
  v5[87] = 0;
  std::string::basic_string[abi:nn180100]<0>(v24, "points");
  std::string::basic_string[abi:nn180100]<0>(&__p, "http://www.w3.org/2000/svg");
  uint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v24, (uint64_t)&__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p);
  }
  if (SBYTE7(v25) < 0)
  {
    operator delete(v24[0]);
    if (!v6) {
      return a1;
    }
  }
  else if (!v6)
  {
    return a1;
  }
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unint64_t v24 = v7;
  long long v25 = v7;
  SVG::consumeListOfCoordinates((uint64_t)(v6 + 64), (uint64_t)v24);
  if (BYTE8(v25))
  {
    char v8 = 0;
    char v9 = 0;
    long long __p = 0;
    CGFloat v27 = 0;
    long long v28 = 0;
    char v10 = (char *)v24[0];
    if ((void *)((char *)v24[1] - (char *)v24[0]) >= (void *)0x10)
    {
      char v9 = 0;
      unint64_t v11 = 0;
      do
      {
        double v12 = &v10[16 * v11];
        uint64_t v14 = *(void *)v12;
        uint64_t v13 = *((void *)v12 + 1);
        if (v9 >= v28)
        {
          double v15 = (char *)__p;
          uint64_t v16 = (v9 - (unsigned char *)__p) >> 4;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 60) {
            abort();
          }
          uint64_t v18 = v28 - (unsigned char *)__p;
          if ((v28 - (unsigned char *)__p) >> 3 > v17) {
            unint64_t v17 = v18 >> 3;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v17;
          }
          if (v19)
          {
            long long v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::Length>>((uint64_t)&v28, v19);
            double v15 = (char *)__p;
            char v9 = v27;
          }
          else
          {
            long long v20 = 0;
          }
          CGFloat v21 = &v20[16 * v16];
          *(void *)CGFloat v21 = v14;
          *((void *)v21 + 1) = v13;
          long long v22 = v21;
          if (v9 != v15)
          {
            do
            {
              *((_OWORD *)v22 - 1) = *((_OWORD *)v9 - 1);
              v22 -= 16;
              v9 -= 16;
            }
            while (v9 != v15);
            double v15 = (char *)__p;
          }
          char v9 = v21 + 16;
          long long __p = v22;
          CGFloat v27 = v21 + 16;
          long long v28 = &v20[16 * v19];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)char v9 = v14;
          *((void *)v9 + 1) = v13;
          v9 += 16;
        }
        CGFloat v27 = v9;
        ++v11;
        char v10 = (char *)v24[0];
      }
      while (v11 < (unint64_t)(((char *)v24[1] - (char *)v24[0]) >> 3) >> 1);
      char v8 = (char *)__p;
    }
    if ((void **)(a1 + 688) != &__p)
    {
      std::vector<CGPoint>::__assign_with_size[abi:nn180100]<CGPoint*,CGPoint*>((char *)(a1 + 688), v8, (uint64_t)v9, (v9 - v8) >> 4);
      char v8 = (char *)__p;
    }
    if (v8)
    {
      CGFloat v27 = v8;
      operator delete(v8);
    }
    if (BYTE8(v25) && v24[0])
    {
      v24[1] = v24[0];
      operator delete(v24[0]);
    }
  }
  return a1;
}

void SVG::PolygonElement::path(const CGPoint **this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, CGPath **a3@<X8>)
{
  Mutable = CGPathCreateMutable();
  CGPathAddLines(Mutable, 0, this[86], this[87] - this[86]);
  if ((unint64_t)((char *)this[87] - (char *)this[86]) >= 0x11) {
    CGPathCloseSubpath(Mutable);
  }
  *a3 = Mutable;
  if (Mutable)
  {
    CFRetain(Mutable);
    CFRelease(Mutable);
  }
}

float64_t SVG::PolygonElement::boundingBox(SVG::PolygonElement *this, CGRect a2)
{
  uint64_t v2 = (float64x2_t *)*((void *)this + 87);
  uint64_t v3 = (float64x2_t *)*((void *)this + 86);
  if (v2 == v3)
  {
    v5.f64[0] = *(float64_t *)MEMORY[0x1E4F1DB28];
  }
  else
  {
    float64x2_t v4 = *v3;
    float64x2_t v5 = *v3;
    do
    {
      float64x2_t v6 = *v3++;
      float64x2_t v5 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v5, v6), (int8x16_t)v6, (int8x16_t)v5);
      float64x2_t v4 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v6, v4), (int8x16_t)v6, (int8x16_t)v4);
    }
    while (v3 != v2);
  }
  return v5.f64[0];
}

void SVG::PolygonElement::~PolygonElement(SVG::PolygonElement *this)
{
  *(void *)this = &unk_1F1A74758;
  uint64_t v2 = (void *)*((void *)this + 86);
  if (v2)
  {
    *((void *)this + 87) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C30 + v3))(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C48 + v4))(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C60 + v5))(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C48 + v6))(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C60 + v7))(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;

  *(void *)this = &unk_1F1A74758;
  uint64_t v2 = (void *)*((void *)this + 86);
  if (v2)
  {
    *((void *)this + 87) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C30 + v3))(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C48 + v4))(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C60 + v5))(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C48 + v6))(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C60 + v7))(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

unint64_t SVG::CSS::consumeWhitespace(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = *((unsigned __int8 *)a1 + 23);
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    unint64_t v2 = a1[1];
  }
  if (v2 <= a2
    || (v3 >= 0 ? (uint64_t v4 = a1) : (uint64_t v4 = (uint64_t *)*a1),
        (unsigned int v5 = *((char *)v4 + a2), v6 = v5 > 0x20, v7 = (1 << v5) & 0x100000600, !v6) ? (v8 = v7 == 0) : (v8 = 1),
        v8))
  {
    uint64_t v10 = 0;
    unint64_t v9 = 0;
  }
  else
  {
    unint64_t v9 = (a2 + 1) & 0xFFFFFFFFFFFFFF00;
    uint64_t v10 = (a2 + 1);
  }
  return v9 | v10;
}

uint64_t SVG::CSS::consumeAName@<X0>(uint64_t *a1@<X0>, unint64_t a2@<X1>, std::string *a3@<X8>)
{
  unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[7] = v5;
  v40[8] = v5;
  v40[5] = v5;
  v40[6] = v5;
  v40[3] = v5;
  v40[4] = v5;
  v40[1] = v5;
  void v40[2] = v5;
  long long v39 = v5;
  v40[0] = v5;
  *(_OWORD *)CGAffineTransform v37 = v5;
  long long v38 = v5;
  v36[2] = v5;
  void v36[3] = v5;
  v36[0] = v5;
  v36[1] = v5;
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v36);
  memset(v35, 170, sizeof(v35));
  SVG::CSS::consumeCodePoint(a1, a2, (uint64_t)v35);
  if (!LOBYTE(v35[2])) {
    goto LABEL_63;
  }
  do
  {
    if ((v35[0] & 0xFFFFFFDF) - 65 < 0x1A
      || SLODWORD(v35[0]) > 127
      || LODWORD(v35[0]) == 95
      || (LODWORD(v35[0]) != 45 ? (BOOL v6 = (LODWORD(v35[0]) - 48) > 9) : (BOOL v6 = 0), !v6))
    {
      SVG::CSS::appendToStringStream(v36, v35[0]);
      a2 = v35[1];
      goto LABEL_10;
    }
    if (LODWORD(v35[0]) != 92) {
      break;
    }
    unint64_t v7 = v35[1];
    memset(v43, 170, 24);
    SVG::CSS::consumeCodePoint(a1, v35[1], (uint64_t)v43);
    if (!LOBYTE(v43[2]) || LODWORD(v43[0]) == 10) {
      break;
    }
    memset(v42, 170, sizeof(v42));
    SVG::CSS::consumeHexDigit((uint64_t)v42, a1, v7);
    if (!LOBYTE(v42[2]))
    {
      SVG::CSS::consumeCodePoint(a1, v7, (uint64_t)v43);
      unsigned int v29 = v43[0];
      a2 = v43[1];
      goto LABEL_62;
    }
    int v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    unint64_t v12 = v42[1];
    do
    {
      memset(v43, 170, 24);
      SVG::CSS::consumeHexDigit((uint64_t)v43, a1, v12);
      if (!LOBYTE(v43[2])) {
        break;
      }
      if (v10 >= v9)
      {
        uint64_t v14 = (uint64_t)&v10[-v11 + 1];
        if (v14 < 0) {
          goto LABEL_70;
        }
        if (2 * (uint64_t)&v9[-v11] > (unint64_t)v14) {
          uint64_t v14 = 2 * (void)&v9[-v11];
        }
        if ((unint64_t)&v9[-v11] >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v15 = v14;
        }
        if (v15) {
          unint64_t v16 = (unint64_t)operator new(v15);
        }
        else {
          unint64_t v16 = 0;
        }
        uint64_t v13 = &v10[v16 - v11];
        *uint64_t v13 = v43[0];
        if (v10 == (char *)v11)
        {
          unint64_t v11 = (unint64_t)&v10[v16 - v11];
          if (v10) {
            goto LABEL_33;
          }
        }
        else
        {
          unint64_t v17 = &v10[~v11];
          do
          {
            char v18 = *--v10;
            (v17--)[v16] = v18;
          }
          while (v10 != (char *)v11);
          uint64_t v10 = (char *)v11;
          unint64_t v11 = v16;
          if (v10) {
LABEL_33:
          }
            operator delete(v10);
        }
        unint64_t v9 = (char *)(v16 + v15);
        unint64_t v12 = v43[1];
        goto LABEL_35;
      }
      *uint64_t v10 = v43[0];
      unint64_t v12 = v43[1];
      uint64_t v13 = v10;
LABEL_35:
      uint64_t v10 = v13 + 1;
      ++v8;
    }
    while (v8 != 5);
    size_t v19 = (size_t)&v10[-v11];
    if (v10 == (char *)v11)
    {
      CGFloat v21 = 0;
      long long v22 = 0;
      if (v11) {
        goto LABEL_42;
      }
    }
    else
    {
      if ((uint64_t)&v10[-v11] < 0) {
LABEL_70:
      }
        abort();
      long long v20 = operator new((size_t)&v10[-v11]);
      memmove(v20, (const void *)v11, (size_t)&v10[-v11]);
      CGFloat v21 = (unsigned __int8 *)operator new((size_t)&v10[-v11]);
      memcpy(v21, v20, v19);
      long long v22 = &v21[v19];
      operator delete(v20);
      if (v11) {
LABEL_42:
      }
        operator delete((void *)v11);
    }
    unint64_t v23 = SVG::CSS::consumeWhitespace(a1, v12);
    if (v24) {
      a2 = v23;
    }
    else {
      a2 = v12;
    }
    int v25 = LOBYTE(v42[0]);
    for (i = v21; i != v22; int v25 = v27 | (16 * v25))
      int v27 = *i++;
    if (!v25)
    {
      unsigned int v29 = 65533;
      if (!v21) {
        goto LABEL_62;
      }
LABEL_61:
      operator delete(v21);
      goto LABEL_62;
    }
    if (v25 >> 11 != 27 && v25 <= 1114111) {
      unsigned int v29 = v25;
    }
    else {
      unsigned int v29 = 65533;
    }
    if (v21) {
      goto LABEL_61;
    }
LABEL_62:
    SVG::CSS::appendToStringStream(v36, v29);
LABEL_10:
    memset(v35, 170, sizeof(v35));
    SVG::CSS::consumeCodePoint(a1, a2, (uint64_t)v35);
  }
  while (LOBYTE(v35[2]));
LABEL_63:
  std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v36 + 8, __p);
  if (SHIBYTE(v34) < 0)
  {
    std::string::__init_copy_ctor_external(a3, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
    int v30 = SHIBYTE(v34);
    a3[1].__r_.__value_.__r.__words[0] = a2;
    if (v30 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
    a3->__r_.__value_.__r.__words[2] = v34;
    a3[1].__r_.__value_.__r.__words[0] = a2;
  }
  *(void *)&v36[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v36 + *(void *)(*(void *)&v36[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v36[0] + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v38) < 0) {
    operator delete(v37[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1C18A3E60](v40);
}

uint64_t *SVG::CSS::consumeCodePoint@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *((unsigned __int8 *)result + 23);
  if (*((char *)result + 23) < 0)
  {
    unint64_t v6 = result[1];
    if (v6 > a2)
    {
      unint64_t v4 = a2 + 1;
      unsigned int v5 = *(unsigned __int8 *)(*result + a2);
      if (*(char *)(*result + a2) < 0)
      {
LABEL_7:
        if (v4 != v6)
        {
          if (v5 < 0xE0)
          {
            if (v5 < 0xC2) {
              goto LABEL_39;
            }
            int v14 = v5 & 0x1F;
            unint64_t v9 = (uint64_t *)*result;
          }
          else
          {
            if (v5 > 0xEF)
            {
              if (v5 > 0xF4) {
                goto LABEL_39;
              }
              unsigned int v18 = v5 - 240;
              unint64_t v9 = (uint64_t *)*result;
              uint64_t v19 = (v3 & 0x80u) == 0 ? (uint64_t)result : *result;
              unint64_t v20 = *(unsigned __int8 *)(v19 + v4);
              if (((byte_1BF1DB8A3[v20 >> 4] >> v18) & 1) == 0) {
                goto LABEL_39;
              }
              unint64_t v4 = a2 + 2;
              if ((v3 & 0x80) != 0)
              {
                CGFloat v21 = (uint64_t *)*result;
                if (v4 == result[1]) {
                  goto LABEL_39;
                }
              }
              else
              {
                CGFloat v21 = result;
                if (v4 == v3)
                {
                  unsigned int v5 = -1;
                  unint64_t v4 = *((unsigned __int8 *)result + 23);
                  goto LABEL_40;
                }
              }
              unsigned int v12 = *((unsigned __int8 *)v21 + v4) ^ 0x80;
              if (v12 > 0x3F) {
                goto LABEL_39;
              }
              int v7 = v20 & 0x3F | (v18 << 6);
            }
            else
            {
              int v7 = v5 & 0xF;
              unsigned int v8 = a00000000000000[v5 & 0xF];
              unint64_t v9 = (uint64_t *)*result;
              if ((v3 & 0x80u) == 0) {
                uint64_t v10 = result;
              }
              else {
                uint64_t v10 = (uint64_t *)*result;
              }
              unsigned int v11 = *((unsigned __int8 *)v10 + v4);
              if (((v8 >> (v11 >> 5)) & 1) == 0) {
                goto LABEL_39;
              }
              unsigned int v12 = v11 & 0x3F;
            }
            ++v4;
            if ((v3 & 0x80u) == 0) {
              uint64_t v13 = *((unsigned __int8 *)result + 23);
            }
            else {
              uint64_t v13 = result[1];
            }
            if (v4 == v13) {
              goto LABEL_39;
            }
            int v14 = v12 | (v7 << 6);
          }
          if ((v3 & 0x80u) == 0) {
            unint64_t v16 = result;
          }
          else {
            unint64_t v16 = v9;
          }
          unsigned int v17 = *((unsigned __int8 *)v16 + v4) ^ 0x80;
          if (v17 <= 0x3F)
          {
            unsigned int v5 = v17 | (v14 << 6);
            ++v4;
            goto LABEL_40;
          }
        }
LABEL_39:
        unsigned int v5 = -1;
      }
LABEL_40:
      *(_DWORD *)a3 = v5;
      *(void *)(a3 + 8) = v4;
      char v15 = 1;
      goto LABEL_41;
    }
  }
  else if (v3 > a2)
  {
    unint64_t v4 = a2 + 1;
    unsigned int v5 = *((unsigned __int8 *)result + a2);
    if (*((char *)result + a2) < 0)
    {
      unint64_t v6 = *((unsigned __int8 *)result + 23);
      goto LABEL_7;
    }
    goto LABEL_40;
  }
  char v15 = 0;
  *(unsigned char *)a3 = 0;
LABEL_41:
  *(unsigned char *)(a3 + 16) = v15;
  return result;
}

void *SVG::CSS::appendToStringStream(void *result, unsigned int a2)
{
  unint64_t v2 = result;
  int v6 = -1431655766;
  if (a2 > 0x7F)
  {
    if (a2 > 0x7FF)
    {
      if (a2 >> 11 < 0x1B || (a2 & 0xFFFFE000) == 0xE000)
      {
        LOBYTE(v6) = (a2 >> 12) | 0xE0;
        BYTE1(v6) = (a2 >> 6) & 0x3F | 0x80;
        BYTE2(v6) = a2 & 0x3F | 0x80;
        uint64_t v3 = 3;
      }
      else
      {
        if ((a2 - 0x10000) >> 20) {
          return result;
        }
        LOBYTE(v6) = (a2 >> 18) | 0xF0;
        BYTE1(v6) = (a2 >> 12) & 0x3F | 0x80;
        BYTE2(v6) = (a2 >> 6) & 0x3F | 0x80;
        HIBYTE(v6) = a2 & 0x3F | 0x80;
        uint64_t v3 = 4;
      }
    }
    else
    {
      LOBYTE(v6) = (a2 >> 6) | 0xC0;
      BYTE1(v6) = a2 & 0x3F | 0x80;
      uint64_t v3 = 2;
    }
  }
  else
  {
    LOBYTE(v6) = a2;
    uint64_t v3 = 1;
  }
  unint64_t v4 = &v6;
  do
  {
    char v5 = *(unsigned char *)v4;
    unint64_t v4 = (int *)((char *)v4 + 1);
    char v7 = v5;
    double result = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v2, (uint64_t)&v7, 1);
    --v3;
  }
  while (v3);
  return result;
}

uint64_t SVG::CSS::preprocess@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[7] = v4;
  v16[8] = v4;
  v16[5] = v4;
  v16[6] = v4;
  void v16[3] = v4;
  v16[4] = v4;
  v16[1] = v4;
  _OWORD v16[2] = v4;
  long long v15 = v4;
  v16[0] = v4;
  *(_OWORD *)long long __p = v4;
  long long v14 = v4;
  v12[2] = v4;
  unint64_t v12[3] = v4;
  v12[0] = v4;
  v12[1] = v4;
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v12);
  memset(v11, 170, sizeof(v11));
  char v5 = a1;
  for (unint64_t i = 0; ; unint64_t i = v8)
  {
    SVG::CSS::consumeCodePoint(v5, i, (uint64_t)v11);
    if (!LOBYTE(v11[2])) {
      break;
    }
    unsigned int v7 = v11[0];
    if (LODWORD(v11[0]))
    {
      if (LODWORD(v11[0]) == 13)
      {
        memset(v10, 170, sizeof(v10));
        unint64_t v8 = v11[1];
        SVG::CSS::consumeCodePoint(a1, v11[1], (uint64_t)v10);
        if (LOBYTE(v10[2]) && LODWORD(v10[0]) == 10)
        {
          SVG::CSS::appendToStringStream(v12, 0xAu);
          unint64_t v8 = v10[1];
          goto LABEL_13;
        }
        goto LABEL_11;
      }
      if (LODWORD(v11[0]) == 12)
      {
        unint64_t v8 = v11[1];
LABEL_11:
        SVG::CSS::appendToStringStream(v12, 0xAu);
        goto LABEL_13;
      }
    }
    else
    {
      unsigned int v7 = 65533;
    }
    SVG::CSS::appendToStringStream(v12, v7);
    unint64_t v8 = v11[1];
LABEL_13:
    memset(v11, 170, sizeof(v11));
    char v5 = a1;
  }
  std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v12 + 8, a2);
  *(void *)&v12[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v12 + *(void *)(*(void *)&v12[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v12[0] + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1C18A3E60](v16);
}

uint64_t *SVG::CSS::consumeHexDigit(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  memset(v7, 170, sizeof(v7));
  double result = SVG::CSS::consumeCodePoint(a2, a3, (uint64_t)v7);
  if (LOBYTE(v7[2]))
  {
    if ((LODWORD(v7[0]) - 58) >= 0xFFFFFFF6)
    {
      char v5 = LOBYTE(v7[0]) - 48;
      goto LABEL_8;
    }
    if ((LODWORD(v7[0]) - 65) <= 5)
    {
      char v5 = LOBYTE(v7[0]) - 55;
LABEL_8:
      uint64_t v6 = v7[1];
      *(unsigned char *)a1 = v5;
      *(void *)(a1 + 8) = v6;
      *(unsigned char *)(a1 + 16) = 1;
      return result;
    }
    if ((LODWORD(v7[0]) - 97) <= 5)
    {
      char v5 = LOBYTE(v7[0]) - 87;
      goto LABEL_8;
    }
  }
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 16) = 0;
  return result;
}

uint64_t SVG::parseUnits(uint64_t a1)
{
  unint64_t v2 = 0;
  do
  {
    uint64_t v3 = v2;
    unint64_t v2 = SVG::consumeWsp((uint64_t *)a1, v2);
  }
  while (v4);
  memset(v13, 170, sizeof(v13));
  SVG::consumeUnits(a1, v3, (uint64_t)v13);
  int v5 = LOBYTE(v13[2]);
  if (!LOBYTE(v13[2])) {
    goto LABEL_11;
  }
  unint64_t v6 = v13[1];
  do
  {
    unint64_t v7 = v6;
    unint64_t v6 = SVG::consumeWsp((uint64_t *)a1, v6);
  }
  while (v8);
  uint64_t v9 = *(unsigned __int8 *)(a1 + 23);
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = *(void *)(a1 + 8);
  }
  if (v7 != v9)
  {
    int v5 = 0;
LABEL_11:
    unsigned int v10 = 0;
    uint64_t v11 = 0;
    return v11 | v10 | v5;
  }
  unsigned int v10 = v13[0] & 0xFFFFFF00;
  int v5 = LOBYTE(v13[0]);
  uint64_t v11 = 0x100000000;
  return v11 | v10 | v5;
}

uint64_t SVG::consumeUnits@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = result;
  unint64_t v6 = *(unsigned __int8 *)(result + 23);
  char v7 = v6;
  unint64_t v8 = *(void *)(result + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(result + 23);
  }
  else {
    unint64_t v9 = *(void *)(result + 8);
  }
  uint64_t v10 = a2 + 14;
  if (v9 >= a2 + 14)
  {
    uint64_t v11 = 0;
    while (1)
    {
      uint64_t v12 = *(char *)(v4 + 23) >= 0 ? v4 : *(void *)v4;
      int v13 = *(char *)(v12 + a2 + v11);
      __darwin_ct_rune_t v14 = aUserspaceonuse[v11];
      double result = __tolower(v14);
      if (result != v13)
      {
        uint64_t v15 = *(char *)(v4 + 23) >= 0 ? v4 : *(void *)v4;
        int v16 = *(char *)(v15 + a2 + v11);
        double result = __toupper(v14);
        if (result != v16) {
          break;
        }
      }
      if (++v11 == 14)
      {
        *(_DWORD *)a3 = 0;
        *(void *)(a3 + 8) = v10;
        char v17 = 1;
        goto LABEL_32;
      }
    }
    unint64_t v6 = *(unsigned __int8 *)(v4 + 23);
    unint64_t v8 = *(void *)(v4 + 8);
    char v7 = *(unsigned char *)(v4 + 23);
  }
  if (v7 < 0) {
    unint64_t v6 = v8;
  }
  if (v6 >= a2 + 17)
  {
    uint64_t v18 = 0;
    while (1)
    {
      uint64_t v19 = *(char *)(v4 + 23) >= 0 ? v4 : *(void *)v4;
      int v20 = *(char *)(v19 + a2 + v18);
      __darwin_ct_rune_t v21 = aObjectbounding[v18];
      double result = __tolower(v21);
      if (result != v20)
      {
        uint64_t v22 = *(char *)(v4 + 23) >= 0 ? v4 : *(void *)v4;
        int v23 = *(char *)(v22 + a2 + v18);
        double result = __toupper(v21);
        if (result != v23) {
          break;
        }
      }
      if (++v18 == 17)
      {
        char v17 = 1;
        *(_DWORD *)a3 = 1;
        *(void *)(a3 + 8) = a2 + 17;
        goto LABEL_32;
      }
    }
  }
  char v17 = 0;
  *(unsigned char *)a3 = 0;
LABEL_32:
  *(unsigned char *)(a3 + 16) = v17;
  return result;
}

CGAffineTransform *SVG::unitTransform@<X0>(CGAffineTransform *result@<X0>, uint64_t a2@<X8>, CGFloat a3@<D0>, CGFloat a4@<D1>, CGFloat a5@<D2>, CGFloat a6@<D3>)
{
  if (result == 1)
  {
    CGAffineTransformMakeTranslation(&v11, a3, a4);
    return CGAffineTransformScale((CGAffineTransform *)a2, &v11, a5, a6);
  }
  else if (!result)
  {
    uint64_t v7 = MEMORY[0x1E4F1DAB8];
    long long v8 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *(_OWORD *)a2 = *MEMORY[0x1E4F1DAB8];
    *(_OWORD *)(a2 + 16) = v8;
    *(_OWORD *)(a2 + 32) = *(_OWORD *)(v7 + 32);
  }
  return result;
}

uint64_t SVG::DefsElement::DefsElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)a1 = &unk_1F1A744A0;
  uint64_t v6 = MEMORY[0x1E4F1DAB8];
  long long v7 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = *MEMORY[0x1E4F1DAB8];
  *(_OWORD *)(a1 + 656) = v7;
  *(_OWORD *)(a1 + 672) = *(_OWORD *)(v6 + 32);
  std::string::basic_string[abi:nn180100]<0>(__p, "transform");
  std::string::basic_string[abi:nn180100]<0>(v16, "http://www.w3.org/2000/svg");
  long long v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)__p, (uint64_t)v16);
  if (v17 < 0) {
    operator delete(v16[0]);
  }
  if (SBYTE7(v13) < 0)
  {
    operator delete(__p[0]);
    if (!v8) {
      return a1;
    }
  }
  else if (!v8)
  {
    return a1;
  }
  *(void *)&long long v9 = -1;
  *((void *)&v9 + 1) = -1;
  long long v13 = v9;
  long long v14 = v9;
  *(_OWORD *)long long __p = v9;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  SVG::parseTransform((uint64_t)(v8 + 64), (uint64_t)__p);
  if ((_BYTE)v15)
  {
    long long v10 = v13;
    *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)__p;
    *(_OWORD *)(a1 + 656) = v10;
    *(_OWORD *)(a1 + 672) = v14;
  }
  return a1;
}

uint64_t SVG::DefsElement::appendChild(int64x2_t *a1, const void **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)*a2;
  {
    uint64_t v6 = *a2;
    if (!*a2
    {
      return 0;
    }
  }
  return SVG::Element::appendChild(a1, (uint64_t *)a2);
}

void SVG::DefsElement::~DefsElement(SVG::DefsElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C78 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C90 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CA8 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C90 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CA8 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C78 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C90 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CA8 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75C90 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CA8 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

uint64_t SVG::DefsElement::isStructural(SVG::DefsElement *this)
{
  return 1;
}

uint64_t SVG::SVGElement::SVGElement(uint64_t a1, unsigned int a2, uint64_t a3, void *a4)
{
  uint64_t v7 = SVG::Element::Element(a1, a3, a4);
  SVG::Presentation::Presentation(v7 + 64, a4);
  *(void *)a1 = &unk_1F1A74398;
  double v8 = (double)a2;
  *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = 0u;
  *(double *)(a1 + 656) = (double)a2;
  *(double *)(a1 + 664) = (double)a2;
  long long v9 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)(a1 + 672) = *MEMORY[0x1E4F1DB28];
  *(_OWORD *)(a1 + 688) = v9;
  *(void *)(a1 + 704) = 5;
  std::string::basic_string[abi:nn180100]<0>(v22, "x");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v10 = SVG::Element::findInAttributeMap(a4, (uint64_t)v22, (uint64_t)__p);
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v23) < 0)
  {
    operator delete(v22[0]);
    if (!v10) {
      goto LABEL_9;
    }
  }
  else if (!v10)
  {
    goto LABEL_9;
  }
  v22[0] = (void *)-1;
  v22[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v10 + 64), (uint64_t)v22);
  if ((_BYTE)v23) {
    *(double *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = SVG::Length::computeValue((SVG::Length *)v22, v8);
  }
LABEL_9:
  std::string::basic_string[abi:nn180100]<0>(v22, "y");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v11 = SVG::Element::findInAttributeMap(a4, (uint64_t)v22, (uint64_t)__p);
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v23) < 0)
  {
    operator delete(v22[0]);
    if (!v11) {
      goto LABEL_17;
    }
  }
  else if (!v11)
  {
    goto LABEL_17;
  }
  v22[0] = (void *)-1;
  v22[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v11 + 64), (uint64_t)v22);
  if ((_BYTE)v23) {
    *(double *)(a1 + 648) = SVG::Length::computeValue((SVG::Length *)v22, v8);
  }
LABEL_17:
  std::string::basic_string[abi:nn180100]<0>(v22, "width");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v12 = SVG::Element::findInAttributeMap(a4, (uint64_t)v22, (uint64_t)__p);
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v23) < 0)
  {
    operator delete(v22[0]);
    if (!v12) {
      goto LABEL_25;
    }
  }
  else if (!v12)
  {
    goto LABEL_25;
  }
  v22[0] = (void *)-1;
  v22[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v12 + 64), (uint64_t)v22);
  if ((_BYTE)v23) {
    *(double *)(a1 + 656) = SVG::Length::computeValue((SVG::Length *)v22, v8);
  }
LABEL_25:
  std::string::basic_string[abi:nn180100]<0>(v22, "height");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  long long v13 = SVG::Element::findInAttributeMap(a4, (uint64_t)v22, (uint64_t)__p);
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v23) < 0)
  {
    operator delete(v22[0]);
    if (!v13) {
      goto LABEL_33;
    }
  }
  else if (!v13)
  {
    goto LABEL_33;
  }
  v22[0] = (void *)-1;
  v22[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v13 + 64), (uint64_t)v22);
  if ((_BYTE)v23) {
    *(double *)(a1 + 664) = SVG::Length::computeValue((SVG::Length *)v22, v8);
  }
LABEL_33:
  std::string::basic_string[abi:nn180100]<0>(v22, "viewBox");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  long long v14 = SVG::Element::findInAttributeMap(a4, (uint64_t)v22, (uint64_t)__p);
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v23) < 0) {
    operator delete(v22[0]);
  }
  unint64_t v15 = (_OWORD *)(a1 + 672);
  if (v14
    && (*(void *)&long long v16 = -1,
        *((void *)&v16 + 1) = -1,
        *(_OWORD *)uint64_t v22 = v16,
        long long v23 = v16,
        unint64_t v24 = 0xAAAAAAAAAAAAAAAALL,
        SVG::ViewBox::parseViewBox((uint64_t)(v14 + 64), (uint64_t)v22),
        (_BYTE)v24))
  {
    long long v17 = v23;
    *unint64_t v15 = *(_OWORD *)v22;
    *(_OWORD *)(a1 + 688) = v17;
  }
  else
  {
    *(void *)unint64_t v15 = 0;
    *(void *)(a1 + 68CGContextBeginTransparencyLayer(c, 0) = 0;
    *(_OWORD *)(a1 + 688) = *(_OWORD *)(a1 + 656);
  }
  std::string::basic_string[abi:nn180100]<0>(v22, "preserveAspectRatio");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v18 = SVG::Element::findInAttributeMap(a4, (uint64_t)v22, (uint64_t)__p);
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v23) < 0)
  {
    operator delete(v22[0]);
    if (!v18) {
      return a1;
    }
  }
  else if (!v18)
  {
    return a1;
  }
  unint64_t v19 = SVG::PreserveAspectRatio::parsePreserveAspectRatio((uint64_t)(v18 + 64));
  if (v20) {
    *(void *)(a1 + 704) = v19;
  }
  return a1;
}

uint64_t SVG::SVGElement::appendChild(int64x2_t *a1, const void **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)*a2;
  {
    uint64_t v6 = *a2;
    if (!*a2
    {
      return 0;
    }
  }
  return SVG::Element::appendChild(a1, (uint64_t *)a2);
}

void SVG::SVGElement::~SVGElement(SVG::SVGElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CC0 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CD8 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CF0 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CD8 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CF0 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CC0 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CD8 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CF0 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CD8 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75CF0 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

void SVG::convertToMask(SVG *this@<X0>, CGImageRef *a2@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint32_t BitmapInfo = CGBitmapContextGetBitmapInfo(this);
  ColorSpace = CGBitmapContextGetColorSpace(this);
  vImagePixelCount Width = CGBitmapContextGetWidth(this);
  vImagePixelCount Height = CGBitmapContextGetHeight(this);
  size_t v9 = CGBitmapContextGetBitsPerComponent(this);
  CGBitmapContextGetBitsPerPixel(this);
  size_t BytesPerRow = CGBitmapContextGetBytesPerRow(this);
  DatCGFloat a = CGBitmapContextGetData(this);
  size_t bitsPerComponent = v9;
  if (BytesPerRow * Height)
  {
    if (((BytesPerRow * Height) & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v12 = operator new(BytesPerRow * Height);
    bzero(v12, BytesPerRow * Height);
    dest.datCGFloat a = v12;
    dest.double height = Height;
    dest.double width = Width;
    dest.rowBytes = BytesPerRow;
    long long v13 = operator new(BytesPerRow * Height);
    bzero(v13, BytesPerRow * Height);
  }
  else
  {
    uint64_t v12 = 0;
    long long v13 = 0;
    dest.datCGFloat a = 0;
    dest.double height = Height;
    dest.double width = Width;
    dest.rowBytes = BytesPerRow;
  }
  srcBottom.datCGFloat a = v13;
  srcBottom.double height = Height;
  srcBottom.double width = Width;
  srcBottom.rowBytes = BytesPerRow;
  src.datCGFloat a = Data;
  src.double height = Height;
  src.double width = Width;
  src.rowBytes = BytesPerRow;
  matrix[0] = xmmword_1BF1DB8DC;
  matrix[1] = unk_1BF1DB8EC;
  if (vImageMatrixMultiply_ARGB8888(&src, &dest, (const int16_t *)matrix, 255, 0, 0, 0)
    || (*(_DWORD *)color = 255, vImageBufferFill_ARGB8888(&srcBottom, color, 0))
    || vImageAlphaBlend_ARGB8888(&dest, &srcBottom, &dest, 0)
    || (*(_OWORD *)char v20 = xmmword_1BF1DB8FC,
        long long v21 = *(_OWORD *)algn_1BF1DB90C,
        vImageMatrixMultiply_ARGB8888(&dest, &dest, v20, 1, 0, 0, 0)))
  {
    *a2 = 0;
  }
  else
  {
    long long v14 = CGBitmapContextCreate(v12, Width, Height, bitsPerComponent, BytesPerRow, ColorSpace, BitmapInfo);
    *a2 = CGBitmapContextCreateImage(v14);
    if (v14) {
      CFRelease(v14);
    }
  }
  if (v13) {
    operator delete(v13);
  }
  if (v12) {
    operator delete(v12);
  }
}

uint64_t SVG::UseElement::UseElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)a1 = &unk_1F1A743C8;
  uint64_t v6 = MEMORY[0x1E4F1DAB8];
  long long v7 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = *MEMORY[0x1E4F1DAB8];
  *(_OWORD *)(a1 + 656) = v7;
  *(_OWORD *)(a1 + 672) = *(_OWORD *)(v6 + 32);
  *(void *)(a1 + 688) = 0;
  *(_DWORD *)(a1 + 696) = 0;
  *(void *)(a1 + 704) = 0;
  *(_DWORD *)(a1 + 712) = 0;
  *(void *)(a1 + 72CGContextBeginTransparencyLayer(c, 0) = 0;
  *(_DWORD *)(a1 + 728) = 0;
  *(void *)(a1 + 736) = 0;
  *(_DWORD *)(a1 + 744) = 0;
  *(void *)(a1 + 752) = 0;
  std::string::basic_string[abi:nn180100]<0>(v24, "transform");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)v24, (uint64_t)__p);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v25) < 0)
  {
    operator delete(v24[0]);
    if (!v8) {
      goto LABEL_9;
    }
  }
  else if (!v8)
  {
    goto LABEL_9;
  }
  *(void *)&long long v9 = -1;
  *((void *)&v9 + 1) = -1;
  long long v25 = v9;
  long long v26 = v9;
  *(_OWORD *)unint64_t v24 = v9;
  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  SVG::parseTransform((uint64_t)(v8 + 64), (uint64_t)v24);
  if ((_BYTE)v27)
  {
    long long v10 = v25;
    *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)v24;
    *(_OWORD *)(a1 + 656) = v10;
    *(_OWORD *)(a1 + 672) = v26;
  }
LABEL_9:
  std::string::basic_string[abi:nn180100]<0>(v24, "x");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v11 = SVG::Element::findInAttributeMap(a3, (uint64_t)v24, (uint64_t)__p);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v25) < 0)
  {
    operator delete(v24[0]);
    if (!v11) {
      goto LABEL_17;
    }
  }
  else if (!v11)
  {
    goto LABEL_17;
  }
  v24[0] = (void *)-1;
  v24[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v11 + 64), (uint64_t)v24);
  if ((_BYTE)v25) {
    *(_OWORD *)(a1 + 688) = *(_OWORD *)v24;
  }
LABEL_17:
  std::string::basic_string[abi:nn180100]<0>(v24, "y");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v12 = SVG::Element::findInAttributeMap(a3, (uint64_t)v24, (uint64_t)__p);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v25) < 0)
  {
    operator delete(v24[0]);
    if (!v12) {
      goto LABEL_25;
    }
  }
  else if (!v12)
  {
    goto LABEL_25;
  }
  v24[0] = (void *)-1;
  v24[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v12 + 64), (uint64_t)v24);
  if ((_BYTE)v25) {
    *(_OWORD *)(a1 + 704) = *(_OWORD *)v24;
  }
LABEL_25:
  std::string::basic_string[abi:nn180100]<0>(v24, "width");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  long long v13 = SVG::Element::findInAttributeMap(a3, (uint64_t)v24, (uint64_t)__p);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v25) < 0)
  {
    operator delete(v24[0]);
    if (!v13) {
      goto LABEL_33;
    }
  }
  else if (!v13)
  {
    goto LABEL_33;
  }
  v24[0] = (void *)-1;
  v24[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v13 + 64), (uint64_t)v24);
  if ((_BYTE)v25) {
    *(_OWORD *)(a1 + 72CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)v24;
  }
LABEL_33:
  std::string::basic_string[abi:nn180100]<0>(v24, "height");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  long long v14 = SVG::Element::findInAttributeMap(a3, (uint64_t)v24, (uint64_t)__p);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v25) < 0)
  {
    operator delete(v24[0]);
    if (!v14) {
      goto LABEL_41;
    }
  }
  else if (!v14)
  {
    goto LABEL_41;
  }
  v24[0] = (void *)-1;
  v24[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v14 + 64), (uint64_t)v24);
  if ((_BYTE)v25) {
    *(_OWORD *)(a1 + 736) = *(_OWORD *)v24;
  }
LABEL_41:
  std::string::basic_string[abi:nn180100]<0>(v24, "href");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/1999/xlink");
  unint64_t v15 = SVG::Element::findInAttributeMap(a3, (uint64_t)v24, (uint64_t)__p);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE7(v25) < 0)
  {
    operator delete(v24[0]);
    if (!v15) {
      return a1;
    }
  }
  else if (!v15)
  {
    return a1;
  }
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if ((char)v15[87] < 0)
  {
    long long v17 = (const UInt8 *)*((void *)v15 + 8);
    CFIndex v18 = *((void *)v15 + 9);
  }
  else
  {
    long long v17 = v15 + 64;
    CFIndex v18 = v15[87];
  }
  CFStringRef v19 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v17, v18, 0x8000100u, 1u);
  if (v19)
  {
    CFStringRef v20 = v19;
    CFURLRef v21 = CFURLCreateWithString(v16, v19, 0);
    uint64_t v22 = *(const void **)(a1 + 752);
    if (v22) {
      CFRelease(v22);
    }
    *(void *)(a1 + 752) = v21;
    CFRelease(v20);
  }
  return a1;
}

uint64_t SVG::UseElement::appendChild()
{
  return 0;
}

void SVG::UseElement::~UseElement(SVG::UseElement *this)
{
  *(void *)this = &unk_1F1A743C8;
  uint64_t v2 = (const void *)*((void *)this + 94);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D08 + v3))(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D20 + v4))(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D38 + v5))(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D20 + v6))(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D38 + v7))(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;

  *(void *)this = &unk_1F1A743C8;
  uint64_t v2 = (const void *)*((void *)this + 94);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D08 + v3))(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D20 + v4))(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D38 + v5))(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D20 + v6))(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D38 + v7))(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

uint64_t SVG::UseElement::isStructural(SVG::UseElement *this)
{
  return 1;
}

_OWORD *SVG::LineElement::LineElement(_OWORD *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::ShapeElement::ShapeElement((uint64_t)a1, a2, a3);
  *(void *)uint64_t v5 = &unk_1F1A744D0;
  *(void *)(v5 + 688) = 0;
  *(_DWORD *)(v5 + 696) = 0;
  *(void *)(v5 + 704) = 0;
  *(_DWORD *)(v5 + 712) = 0;
  *(void *)(v5 + 72CGContextBeginTransparencyLayer(c, 0) = 0;
  *(_DWORD *)(v5 + 728) = 0;
  *(void *)(v5 + 736) = 0;
  *(_DWORD *)(v5 + 744) = 0;
  std::string::basic_string[abi:nn180100]<0>(v13, "x1");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0)
  {
    operator delete(v13[0]);
    if (!v6) {
      goto LABEL_9;
    }
  }
  else if (!v6)
  {
    goto LABEL_9;
  }
  v13[0] = (void *)-1;
  v13[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v6 + 64), (uint64_t)v13);
  if ((_BYTE)v14) {
    a1[43] = *(_OWORD *)v13;
  }
LABEL_9:
  std::string::basic_string[abi:nn180100]<0>(v13, "y1");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v7 = SVG::Element::findInAttributeMap(a3, (uint64_t)v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0)
  {
    operator delete(v13[0]);
    if (!v7) {
      goto LABEL_17;
    }
  }
  else if (!v7)
  {
    goto LABEL_17;
  }
  v13[0] = (void *)-1;
  v13[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v7 + 64), (uint64_t)v13);
  if ((_BYTE)v14) {
    a1[44] = *(_OWORD *)v13;
  }
LABEL_17:
  std::string::basic_string[abi:nn180100]<0>(v13, "x2");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0)
  {
    operator delete(v13[0]);
    if (!v8) {
      goto LABEL_25;
    }
  }
  else if (!v8)
  {
    goto LABEL_25;
  }
  v13[0] = (void *)-1;
  v13[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v8 + 64), (uint64_t)v13);
  if ((_BYTE)v14) {
    a1[45] = *(_OWORD *)v13;
  }
LABEL_25:
  std::string::basic_string[abi:nn180100]<0>(v13, "y2");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v9 = SVG::Element::findInAttributeMap(a3, (uint64_t)v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0)
  {
    operator delete(v13[0]);
    if (!v9) {
      return a1;
    }
  }
  else if (!v9)
  {
    return a1;
  }
  v13[0] = (void *)-1;
  v13[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v9 + 64), (uint64_t)v13);
  if ((_BYTE)v14) {
    a1[46] = *(_OWORD *)v13;
  }
  return a1;
}

void SVG::LineElement::path(SVG::LineElement *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, CGPath **a3@<X8>)
{
  double height = a2.size.height;
  double width = a2.size.width;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  double v7 = SVG::Length::computeValue((SVG::LineElement *)((char *)this + 688), a2.size.width);
  double v8 = SVG::Length::computeValue((SVG::LineElement *)((char *)this + 704), height);
  double v9 = SVG::Length::computeValue((SVG::LineElement *)((char *)this + 720), width);
  double v10 = SVG::Length::computeValue((SVG::LineElement *)((char *)this + 736), height);
  Mutable = CGPathCreateMutable();
  points.CGFloat x = v7;
  points.CGFloat y = v8;
  double v13 = v9;
  double v14 = v10;
  CGPathAddLines(Mutable, 0, &points, 2uLL);
  *a3 = Mutable;
  if (Mutable)
  {
    CFRetain(Mutable);
    CFRelease(Mutable);
  }
}

double SVG::LineElement::boundingBox(SVG::LineElement *this, CGRect a2)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double v5 = SVG::Length::computeValue((SVG::LineElement *)((char *)this + 688), a2.size.width);
  SVG::Length::computeValue((SVG::LineElement *)((char *)this + 704), height);
  double v6 = SVG::Length::computeValue((SVG::LineElement *)((char *)this + 720), width);
  SVG::Length::computeValue((SVG::LineElement *)((char *)this + 736), height);
  if (v6 >= v5) {
    return v5;
  }
  else {
    return v6;
  }
}

void SVG::LineElement::~LineElement(SVG::LineElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D50 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D68 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D80 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D68 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D80 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D50 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D68 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D80 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D68 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75D80 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

double SVG::Image::transformIntoVariant@<D0>(SVG::Image *this@<X0>, CGAffineTransform *a2@<X1>, uint64_t a3@<X8>)
{
  long long v5 = *(_OWORD *)&a2->c;
  *(_OWORD *)&v15.CGFloat a = *(_OWORD *)&a2->a;
  *(_OWORD *)&v15.CGFloat c = v5;
  *(_OWORD *)&v15.tCGFloat x = *(_OWORD *)&a2->tx;
  uint64_t v6 = *((void *)this + 1);
  *(void *)&long long v5 = *((void *)this + 2);
  uint64_t v7 = *((void *)this + 3);
  uint64_t v8 = *((void *)this + 4);
  CGRect v16 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v5 - 8), &v15);
  char v9 = (const void *)*((void *)this + 5);
  *(CGFloat *)&long long v12 = v16.origin.x;
  *((void *)&v12 + 1) = *(void *)&v16.origin.y;
  *(CGFloat *)&long long v13 = v16.size.width;
  *((void *)&v13 + 1) = *(void *)&v16.size.height;
  double v14 = v9;
  if (v9)
  {
    CFRetain(v9);
    char v10 = v14;
  }
  else
  {
    char v10 = 0;
  }
  *(void *)a3 = &unk_1F1A74A68;
  double result = *(double *)&v12;
  *(_OWORD *)(a3 + 8) = v12;
  *(_OWORD *)(a3 + 24) = v13;
  *(void *)(a3 + 4CGContextBeginTransparencyLayer(c, 0) = v10;
  *(_DWORD *)(a3 + 48) = 0;
  return result;
}

void SVG::Image::~Image(SVG::Image *this)
{
  *(void *)this = &unk_1F1A74A68;
  uint64_t v1 = (const void *)*((void *)this + 5);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1A74A68;
  uint64_t v1 = (const void *)*((void *)this + 5);
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1C18A3E80);
}

void SVG::Path::transformIntoVariant(SVG::Path *this@<X0>, CGAffineTransform *a2@<X1>, uint64_t a3@<X8>)
{
  long long v4 = *(_OWORD *)&a2->c;
  v5[0] = *(_OWORD *)&a2->a;
  v5[1] = v4;
  v5[2] = *(_OWORD *)&a2->tx;
  SVG::Path::transform((SVG::Path *)v6, (CGAffineTransform *)*((unsigned __int8 *)this + 8), *((void *)this + 2), (uint64_t)v5);
  *(void *)a3 = &unk_1F1A74A30;
  *(unsigned char *)(a3 + 8) = v6[8];
  *(void *)(a3 + 16) = v7;
  *(_DWORD *)(a3 + 48) = 1;
}

void SVG::Path::transform(SVG::Path *this, CGAffineTransform *a2, uint64_t a3, uint64_t a4)
{
  char v4 = (char)a2;
  uint64_t v6 = (const void *)MEMORY[0x1C18A3BF0](a3, a4);
  *(void *)this = &unk_1F1A74A30;
  *((unsigned char *)this + 8) = v4;
  *((void *)this + 2) = v6;
  if (v6)
  {
    uint64_t v7 = v6;
    CFRetain(v6);
    CFRelease(v7);
  }
}

void SVG::Path::~Path(SVG::Path *this)
{
  *(void *)this = &unk_1F1A74A30;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1A74A30;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
  JUMPOUT(0x1C18A3E80);
}

void SVG::ClipToPaths::execute(uint64_t a1, CGContext *a2)
{
  char v11 = a2;
  SVG::simplify((SVG *)&v9, *(const SVG::ClipToPaths::BaseClipNode ***)(a1 + 8), a2);
  uint64_t v2 = v9;
  uint64_t v3 = v10;
  if (v9 == v10)
  {
LABEL_4:
    long long v12 = (CGContext ***)&v9;
    std::vector<std::variant<SVG::Image,SVG::Path>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v12);
  }
  else
  {
    while (1)
    {
      uint64_t v8 = &v11;
      uint64_t v4 = *(unsigned int *)(v2 + 48);
      if (v4 == -1) {
        break;
      }
      long long v12 = &v8;
      ((void (*)(CGContext ****, uint64_t))*(&off_1F1A75E28 + v4))(&v12, v2);
      v2 += 56;
      if (v2 == v3) {
        goto LABEL_4;
      }
    }
    long long v5 = (SVG *)std::__throw_bad_variant_access[abi:nn180100]();
    SVG::simplify(v5, v6, v7);
  }
}

void SVG::simplify(SVG *this, const SVG::ClipToPaths::BaseClipNode **lpsrc, CGContext *a3)
{
  j = (const SVG::ClipToPaths::BaseClipNode *)lpsrc;
  uint64_t v165 = *MEMORY[0x1E4F143B8];
  long long v156 = 0uLL;
  unint64_t v157 = 0;
  long long v5 = lpsrc[1];
  if (v5)
  {
    memset(v158, 170, sizeof(v158));
    SVG::simplify((SVG *)v158, v5, a3);
    uint64_t v7 = v158[0];
    uint64_t v6 = v158[1];
    if ((uint64_t)(v158[1] - v158[0]) >= 1)
    {
      CGFloat v138 = this;
      uint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v158[1] - v158[0]) >> 3);
      unint64_t v9 = *((void *)&v156 + 1);
      uint64_t v10 = v156;
      uint64_t v11 = (*((void *)&v156 + 1) - (void)v156) / 56;
      uint64_t v12 = v156 + 56 * v11;
      if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v157 - *((void *)&v156 + 1)) >> 3) < v8)
      {
        *(_OWORD *)unint64_t v161 = 0uLL;
        unint64_t v13 = v11 + v8;
        if ((unint64_t)(v11 + v8) > 0x492492492492492) {
          goto LABEL_191;
        }
        if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v157 - v156) >> 3) > v13) {
          unint64_t v13 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v157 - v156) >> 3);
        }
        if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v157 - v156) >> 3)) >= 0x249249249249249) {
          unint64_t v14 = 0x492492492492492;
        }
        else {
          unint64_t v14 = v13;
        }
        *((void *)&v162 + 1) = &v157;
        CGAffineTransform v15 = j;
        if (v14)
        {
          long long v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawLinearGradient>>(v14);
        }
        else
        {
          long long v17 = 0;
          uint64_t v16 = 0;
        }
        uint64_t v22 = &v17[56 * v11];
        *(void *)&long long v162 = &v17[56 * v16];
        uint64_t v23 = (uint64_t)&v22[56 * v8];
        uint64_t v24 = (uint64_t)v22;
        do
        {
          *(unsigned char *)uint64_t v24 = 0;
          *(_DWORD *)(v24 + 48) = -1;
          std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1> const&>(v24, v7);
          v7 += 56;
          v24 += 56;
        }
        while (v24 != v23);
        *(void *)&v161[16] = v23;
        uint64_t v25 = v156;
        if ((void)v156 != v12)
        {
          uint64_t v26 = 56 * v11;
          do
          {
            v17[v26 - 56] = 0;
            uint64_t v27 = (uint64_t)&v17[v26 - 56];
            *(_DWORD *)(v27 + 48) = -1;
            std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1>>(v27, v10 + v26 - 56);
            v10 -= 56;
            v17 -= 56;
          }
          while (v10 + v26 != v25);
          uint64_t v23 = *(void *)&v161[16];
          uint64_t v22 = &v17[56 * v11];
        }
        uint64_t v28 = *((void *)&v156 + 1);
        if (*((void *)&v156 + 1) == v12)
        {
          this = v138;
        }
        else
        {
          this = v138;
          do
          {
            *(unsigned char *)uint64_t v23 = 0;
            *(_DWORD *)(v23 + 48) = -1;
            std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1>>(v23, v12);
            v12 += 56;
            v23 += 56;
          }
          while (v12 != v28);
          uint64_t v12 = *((void *)&v156 + 1);
        }
        uint64_t v29 = v156;
        unint64_t v30 = v157;
        *(void *)&long long v156 = v22;
        *((void *)&v156 + 1) = v23;
        unint64_t v157 = v162;
        *(void *)&v161[16] = v12;
        *(void *)&long long v162 = v30;
        *(void *)unint64_t v161 = v29;
        *(void *)&v161[8] = v29;
        std::__split_buffer<std::variant<SVG::Image,SVG::Path>>::~__split_buffer((uint64_t)v161);
        j = v15;
        goto LABEL_51;
      }
      long long __p = j;
      if (0x6DB6DB6DB6DB6DB7 * ((*((void *)&v156 + 1) - v12) >> 3) >= v8)
      {
        uint64_t v18 = v158[0] + 8 * ((uint64_t)(v158[1] - v158[0]) >> 3);
        uint64_t v19 = *((void *)&v156 + 1);
        this = v138;
      }
      else
      {
        uint64_t v144 = *((void *)&v156 + 1) - v12;
        uint64_t v18 = v158[0] + 8 * ((*((void *)&v156 + 1) - v12) >> 3);
        if (v18 == v158[1])
        {
          uint64_t v19 = *((void *)&v156 + 1);
        }
        else
        {
          uint64_t v19 = *((void *)&v156 + 1);
          uint64_t v20 = v158[0] + 8 * ((*((void *)&v156 + 1) - v12) >> 3);
          uint64_t v21 = *((void *)&v156 + 1);
          do
          {
            *(unsigned char *)uint64_t v21 = 0;
            *(_DWORD *)(v21 + 48) = -1;
            std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1> const&>(v21, v20);
            v20 += 56;
            v19 += 56;
            v21 += 56;
          }
          while (v20 != v6);
        }
        *((void *)&v156 + 1) = v19;
        j = __p;
        this = v138;
        if (v144 < 1) {
          goto LABEL_51;
        }
      }
      uint64_t v31 = v12 + 56 * v8;
      unint64_t v32 = v19 - 56 * v8;
      uint64_t v33 = v19;
      if (v32 < v9)
      {
        uint64_t v33 = v19;
        do
        {
          *(unsigned char *)uint64_t v33 = 0;
          *(_DWORD *)(v33 + 48) = -1;
          std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1>>(v33, v32);
          v32 += 56;
          v33 += 56;
        }
        while (v32 < v9);
      }
      *((void *)&v156 + 1) = v33;
      if (v19 != v31)
      {
        uint64_t v34 = v19 - 56;
        for (uint64_t i = 8 * ((v19 - v31) >> 3); i; i -= 56)
        {
          uint64_t v36 = *(unsigned int *)(v34 + 48);
          uint64_t v37 = *(unsigned int *)(v12 + i - 8);
          if (v36 == -1)
          {
            if (v37 != -1)
            {
LABEL_42:
              *(void *)unint64_t v161 = v34;
              ((void (*)(unsigned char *, uint64_t, uint64_t))*(&off_1F1A75DC8 + v37))(v161, v34, v12 + i - 56);
            }
          }
          else
          {
            if (v37 != -1) {
              goto LABEL_42;
            }
            ((void (*)(unsigned char *, uint64_t))*(&off_1F1A75D98 + v36))(v161, v34);
            *(_DWORD *)(v34 + 48) = -1;
          }
          v34 -= 56;
        }
      }
      for (j = __p; v7 != v18; v12 += 56)
      {
        uint64_t v38 = *(unsigned int *)(v12 + 48);
        uint64_t v39 = *(unsigned int *)(v7 + 48);
        if (v38 == -1)
        {
          if (v39 != -1)
          {
LABEL_49:
            *(void *)unint64_t v161 = v12;
            ((void (*)(unsigned char *, uint64_t, uint64_t))*(&off_1F1A75DD8 + v39))(v161, v12, v7);
          }
        }
        else
        {
          if (v39 != -1) {
            goto LABEL_49;
          }
          ((void (*)(unsigned char *, uint64_t))*(&off_1F1A75D98 + v38))(v161, v12);
          *(_DWORD *)(v12 + 48) = -1;
        }
        v7 += 56;
      }
    }
LABEL_51:
    *(void *)unint64_t v161 = v158;
    std::vector<std::variant<SVG::Image,SVG::Path>>::__destroy_vector::operator()[abi:nn180100]((void ***)v161);
  }
  int v155 = v40;
  if (!v40)
  {
    if (v46)
    {
      CGAffineTransform v47 = v46;
      unint64_t v48 = *((unsigned __int8 *)v46 + 80);
      CGAffineTransform v49 = (const void *)v46[9];
      CGContextRef c = (CGContextRef)&unk_1F1A74A30;
      unsigned __int8 v152 = v48;
      CFTypeRef v153 = v49;
      if (v49)
      {
        CFRetain(v49);
        unint64_t v48 = v152;
        CFTypeRef v50 = v153;
      }
      else
      {
        CFTypeRef v50 = 0;
      }
      long long v88 = *(_OWORD *)(v47 + 5);
      v150[0] = *(_OWORD *)(v47 + 3);
      v150[1] = v88;
      v150[2] = *(_OWORD *)(v47 + 7);
      SVG::Path::transform((SVG::Path *)v158, (CGAffineTransform *)v48, (uint64_t)v50, (uint64_t)v150);
      uint64_t v89 = *((void *)&v156 + 1);
      if (*((void *)&v156 + 1) >= v157)
      {
        uint64_t v92 = v156;
        uint64_t v93 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v156 + 1) - v156) >> 3);
        unint64_t v94 = v93 + 1;
        if ((unint64_t)(v93 + 1) > 0x492492492492492) {
          goto LABEL_191;
        }
        if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v157 - v156) >> 3) > v94) {
          unint64_t v94 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v157 - v156) >> 3);
        }
        if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v157 - v156) >> 3)) >= 0x249249249249249) {
          unint64_t v95 = 0x492492492492492;
        }
        else {
          unint64_t v95 = v94;
        }
        *((void *)&v162 + 1) = &v157;
        if (v95)
        {
          unint64_t v95 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawLinearGradient>>(v95);
          uint64_t v89 = *((void *)&v156 + 1);
          uint64_t v92 = v156;
        }
        else
        {
          uint64_t v96 = 0;
        }
        unint64_t v120 = v95 + 56 * v93;
        *(void *)unint64_t v161 = v95;
        *(void *)&v161[8] = v120;
        unint64_t v121 = v95 + 56 * v96;
        *(void *)&long long v162 = v121;
        *(void *)unint64_t v120 = &unk_1F1A74A30;
        *(unsigned char *)(v120 + 8) = v158[1];
        uint64_t v122 = v158[2];
        v158[2] = 0;
        *(void *)(v120 + 16) = v122;
        *(_DWORD *)(v120 + 48) = 1;
        unint64_t v91 = v120 + 56;
        *(void *)&v161[16] = v120 + 56;
        if (v89 != v92)
        {
          uint64_t v123 = 0;
          do
          {
            *(unsigned char *)(v120 + v123 - 56) = 0;
            uint64_t v124 = v120 + v123 - 56;
            *(_DWORD *)(v124 + 48) = -1;
            v123 -= 56;
            std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1>>(v124, v89 + v123);
          }
          while (v89 + v123 != v92);
          unint64_t v91 = *(void *)&v161[16];
          unint64_t v121 = v162;
          v120 += v123;
        }
        long long v125 = v156;
        *(void *)&long long v156 = v120;
        *((void *)&v156 + 1) = v91;
        *(_OWORD *)&v161[8] = v125;
        unint64_t v126 = v157;
        unint64_t v157 = v121;
        *(void *)&long long v162 = v126;
        *(void *)unint64_t v161 = v125;
        std::__split_buffer<std::variant<SVG::Image,SVG::Path>>::~__split_buffer((uint64_t)v161);
      }
      else
      {
        **((void **)&v156 + 1) = &unk_1F1A74A30;
        *(unsigned char *)(v89 + 8) = v158[1];
        uint64_t v90 = v158[2];
        v158[2] = 0;
        *(void *)(v89 + 16) = v90;
        *(_DWORD *)(v89 + 48) = 1;
        unint64_t v91 = v89 + 56;
      }
      *((void *)&v156 + 1) = v91;
      v158[0] = &unk_1F1A74A30;
      if (v158[2]) {
        CFRelease((CFTypeRef)v158[2]);
      }
      CGContextRef c = (CGContextRef)&unk_1F1A74A30;
      if (v153) {
        CFRelease(v153);
      }
    }
LABEL_188:
    *(_OWORD *)this = v156;
    *((void *)this + 2) = v157;
    long long v156 = 0uLL;
    unint64_t v157 = 0;
    goto LABEL_189;
  }
  unint64_t v41 = v40[9];
  double v140 = v40[10];
  uint64_t v42 = ((char *)v140 - (char *)v41) >> 4;
  if (!v42) {
    goto LABEL_188;
  }
  if (v42 == 1)
  {
    SVG::simplify((SVG *)v158, *v41, a3);
    uint64_t v43 = v158[0];
    for (uint64_t k = v158[1]; v43 != k; v43 += 56)
    {
      double v154 = (void **)&v155;
      uint64_t v45 = *(unsigned int *)(v43 + 48);
      if (v45 == -1) {
        goto LABEL_190;
      }
      CGContextRef c = (CGContextRef)&v154;
      ((void (*)(unsigned char *__return_ptr, CGContextRef *, uint64_t))*(&off_1F1A75DE8 + v45))(v161, &c, v43);
      std::vector<std::variant<SVG::Image,SVG::Path>>::emplace_back<std::variant<SVG::Image,SVG::Path>>((uint64_t *)&v156, (uint64_t)v161);
      if (v164 != -1) {
        ((void (*)(CGContextRef *, unsigned char *))*(&off_1F1A75D98 + v164))(&c, v161);
      }
    }
    *(void *)unint64_t v161 = v158;
    std::vector<std::variant<SVG::Image,SVG::Path>>::__destroy_vector::operator()[abi:nn180100]((void ***)v161);
    goto LABEL_188;
  }
  double v139 = this;
  CGFloat v52 = *MEMORY[0x1E4F1DB28];
  CGFloat v51 = *(double *)(MEMORY[0x1E4F1DB28] + 8);
  CGFloat v54 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
  CGFloat v53 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
  if (v41 != v140)
  {
    CGRect v55 = 0;
    CGRect v56 = 0;
    long long v145 = 0;
    __pCGFloat a = 0;
    CGRect v57 = 0;
    CGRect v58 = 0;
    while (1)
    {
      memset(v158, 170, sizeof(v158));
      SVG::simplify((SVG *)v158, *v41, a3);
      memset(v161, 0, sizeof(v161));
      char v142 = v41;
      unint64_t v143 = (unint64_t)v58;
      if (v56 >= v145)
      {
        unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * ((v56 - v55) >> 3) + 1;
        if (v59 > 0xAAAAAAAAAAAAAAALL) {
          goto LABEL_191;
        }
        if (0x5555555555555556 * ((v145 - v55) >> 3) > v59) {
          unint64_t v59 = 0x5555555555555556 * ((v145 - v55) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v145 - v55) >> 3) >= 0x555555555555555) {
          unint64_t v59 = 0xAAAAAAAAAAAAAAALL;
        }
        if (v59 > 0xAAAAAAAAAAAAAAALL) {
LABEL_192:
        }
          std::__throw_bad_array_new_length[abi:nn180100]();
        uint64_t v146 = 3 * v59;
        BOOL v60 = (char *)operator new(24 * v59);
        uint64_t v61 = &v60[8 * ((v56 - v55) >> 3)];
        *((void *)v61 + 1) = 0;
        *((void *)v61 + 2) = 0;
        *(void *)uint64_t v61 = 0;
        memset(v161, 0, sizeof(v161));
        if (v56 == v55)
        {
          uint64_t v63 = &v60[8 * ((v56 - v55) >> 3)];
        }
        else
        {
          uint64_t v62 = v56;
          uint64_t v63 = &v60[8 * ((v56 - v55) >> 3)];
          do
          {
            *((void *)v63 - 3) = 0;
            *((void *)v63 - 2) = 0;
            v63 -= 24;
            *((void *)v63 + 2) = 0;
            long long v64 = *(_OWORD *)(v62 - 24);
            v62 -= 24;
            *(_OWORD *)uint64_t v63 = v64;
            *((void *)v63 + 2) = *((void *)v62 + 2);
            *(void *)uint64_t v62 = 0;
            *((void *)v62 + 1) = 0;
            *((void *)v62 + 2) = 0;
          }
          while (v62 != v55);
          if (v56 != v55)
          {
            long long v65 = v60;
            do
            {
              v56 -= 24;
              CGContextRef c = (CGContextRef)v56;
              std::vector<std::variant<SVG::Image,SVG::Path>>::__destroy_vector::operator()[abi:nn180100]((void ***)&c);
            }
            while (v56 != v55);
            BOOL v60 = v65;
          }
        }
        long long v145 = &v60[8 * v146];
        CGRect v56 = v61 + 24;
        if (v55) {
          operator delete(v55);
        }
        CGRect v55 = v63;
      }
      else
      {
        *(void *)CGRect v56 = 0;
        *((void *)v56 + 1) = 0;
        *((void *)v56 + 2) = 0;
        *(_OWORD *)CGRect v56 = *(_OWORD *)v161;
        *((void *)v56 + 2) = *(void *)&v161[16];
        memset(v161, 0, sizeof(v161));
        v56 += 24;
      }
      CGContextRef c = (CGContextRef)v161;
      std::vector<std::variant<SVG::Image,SVG::Path>>::__destroy_vector::operator()[abi:nn180100]((void ***)&c);
      uint64_t v67 = v158[0];
      uint64_t v66 = v158[1];
      if (v158[0] != v158[1]) {
        break;
      }
LABEL_90:
      CGFloat x = *MEMORY[0x1E4F1DB10];
      CGFloat y = *(double *)(MEMORY[0x1E4F1DB10] + 8);
      CGFloat width = *(double *)(MEMORY[0x1E4F1DB10] + 16);
      CGFloat height = *(double *)(MEMORY[0x1E4F1DB10] + 24);
      uint64_t v73 = *((void *)v56 - 3);
      for (uint64_t m = *((void *)v56 - 2); v73 != m; v73 += 56)
      {
        uint64_t v75 = *(unsigned int *)(v73 + 48);
        if (v75 == -1) {
          goto LABEL_190;
        }
        *(void *)unint64_t v161 = &c;
        v171.origin.CGFloat x = ((double (*)(unsigned char *, uint64_t))*(&off_1F1A75E08 + v75))(v161, v73);
        v171.origin.CGFloat y = v76;
        v171.size.CGFloat width = v77;
        v171.size.CGFloat height = v78;
        v166.origin.CGFloat x = x;
        v166.origin.CGFloat y = y;
        v166.size.CGFloat width = width;
        v166.size.CGFloat height = height;
        CGRect v167 = CGRectIntersection(v166, v171);
        CGFloat x = v167.origin.x;
        CGFloat y = v167.origin.y;
        CGFloat width = v167.size.width;
        CGFloat height = v167.size.height;
      }
      v168.origin.CGFloat x = v52;
      v168.origin.CGFloat y = v51;
      v168.size.CGFloat width = v54;
      v168.size.CGFloat height = v53;
      v172.origin.CGFloat x = x;
      v172.origin.CGFloat y = y;
      v172.size.CGFloat width = width;
      v172.size.CGFloat height = height;
      CGRect v169 = CGRectUnion(v168, v172);
      CGFloat v52 = v169.origin.x;
      CGFloat v51 = v169.origin.y;
      CGFloat v54 = v169.size.width;
      CGFloat v53 = v169.size.height;
      CGRect v58 = (char *)v143;
      if ((unint64_t)v57 >= v143)
      {
        unsigned int v79 = (char *)__pa;
        uint64_t v80 = (v57 - (char *)__pa) >> 5;
        unint64_t v81 = v80 + 1;
        if ((unint64_t)(v80 + 1) >> 59) {
          goto LABEL_191;
        }
        if ((uint64_t)(v143 - (void)__pa) >> 4 > v81) {
          unint64_t v81 = (uint64_t)(v143 - (void)__pa) >> 4;
        }
        if (v143 - (unint64_t)__pa >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v82 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v82 = v81;
        }
        if (v82)
        {
          if (v82 >> 59) {
            goto LABEL_192;
          }
          uint64_t v83 = (char *)operator new(32 * v82);
          unsigned int v79 = (char *)__pa;
        }
        else
        {
          uint64_t v83 = 0;
        }
        uint64_t v84 = &v83[32 * v80];
        *(CGFloat *)uint64_t v84 = x;
        *((CGFloat *)v84 + 1) = y;
        *((CGFloat *)v84 + 2) = width;
        *((CGFloat *)v84 + 3) = height;
        if (v57 == v79)
        {
          uint64_t v87 = &v83[32 * v80];
        }
        else
        {
          int v85 = &v83[32 * v80];
          do
          {
            long long v86 = *((_OWORD *)v57 - 1);
            uint64_t v87 = v85 - 32;
            *((_OWORD *)v85 - 2) = *((_OWORD *)v57 - 2);
            *((_OWORD *)v85 - 1) = v86;
            v57 -= 32;
            v85 -= 32;
          }
          while (v57 != v79);
        }
        CGRect v58 = &v83[32 * v82];
        CGRect v57 = v84 + 32;
        if (v79) {
          operator delete(v79);
        }
        __pCGFloat a = (CGRect *)v87;
      }
      else
      {
        *(CGFloat *)CGRect v57 = x;
        *((CGFloat *)v57 + 1) = y;
        *((CGFloat *)v57 + 2) = width;
        *((CGFloat *)v57 + 3) = height;
        v57 += 32;
      }
      *(void *)unint64_t v161 = v158;
      std::vector<std::variant<SVG::Image,SVG::Path>>::__destroy_vector::operator()[abi:nn180100]((void ***)v161);
      unint64_t v41 = v142 + 2;
      if (v142 + 2 == v140) {
        goto LABEL_127;
      }
    }
    while (1)
    {
      double v154 = (void **)&v155;
      uint64_t v68 = *(unsigned int *)(v67 + 48);
      if (v68 == -1) {
        break;
      }
      CGContextRef c = (CGContextRef)&v154;
      ((void (*)(unsigned char *__return_ptr, CGContextRef *, uint64_t))*(&off_1F1A75DF8 + v68))(v161, &c, v67);
      std::vector<std::variant<SVG::Image,SVG::Path>>::emplace_back<std::variant<SVG::Image,SVG::Path>>((uint64_t *)v56 - 3, (uint64_t)v161);
      if (v164 != -1) {
        ((void (*)(CGContextRef *, unsigned char *))*(&off_1F1A75D98 + v164))(&c, v161);
      }
      v67 += 56;
      if (v67 == v66) {
        goto LABEL_90;
      }
    }
LABEL_190:
    std::__throw_bad_variant_access[abi:nn180100]();
LABEL_191:
    abort();
  }
  CGRect v55 = 0;
  CGRect v56 = 0;
  __pCGFloat a = 0;
LABEL_127:
  CGContextRef c = (CGContextRef)0xAAAAAAAAAAAAAAAALL;
  v170.origin.CGFloat x = v52;
  v170.origin.CGFloat y = v51;
  v170.size.CGFloat width = v54;
  v170.size.CGFloat height = v53;
  SVG::createParallelBitmapContext(a3, v170, &c);
  CGContextRef v97 = c;
  if (c)
  {
    long long v98 = c;
    CGContextRef v147 = c;
    if (v56 != v55)
    {
      uint64_t v99 = 0;
      if ((unint64_t)((v56 - v55) / 24) <= 1) {
        uint64_t v100 = 1;
      }
      else {
        uint64_t v100 = (v56 - v55) / 24;
      }
      do
      {
        CGContextSaveGState(c);
        uint64_t v101 = &v55[24 * v99];
        uint64_t v103 = *(void *)v101;
        uint64_t v102 = *((void *)v101 + 1);
        while (v103 != v102)
        {
          v158[0] = &c;
          uint64_t v104 = *(unsigned int *)(v103 + 48);
          if (v104 == -1) {
            goto LABEL_190;
          }
          *(void *)unint64_t v161 = v158;
          ((void (*)(unsigned char *, uint64_t))*(&off_1F1A75E18 + v104))(v161, v103);
          v103 += 56;
        }
        CGContextFillRect(c, __pa[v99]);
        CGContextRestoreGState(c);
        ++v99;
      }
      while (v99 != v100);
      long long v98 = c;
      CGContextRef v97 = v147;
    }
    CGContextFlush(v98);
    CGImageRef Image = CGBitmapContextCreateImage(c);
    CGImageRef v106 = Image;
    *(void *)unint64_t v161 = &unk_1F1A74A68;
    *(CGFloat *)&v161[8] = v52;
    *(CGFloat *)&v161[16] = v51;
    *(CGFloat *)&long long v162 = v54;
    *((CGFloat *)&v162 + 1) = v53;
    CFTypeRef v163 = Image;
    if (Image) {
      CFRetain(Image);
    }
    uint64_t v107 = *((void *)&v156 + 1);
    if (*((void *)&v156 + 1) >= v157)
    {
      uint64_t v115 = v156;
      uint64_t v116 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)&v156 + 1) - v156) >> 3);
      unint64_t v117 = v116 + 1;
      if ((unint64_t)(v116 + 1) > 0x492492492492492) {
        goto LABEL_191;
      }
      if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v157 - v156) >> 3) > v117) {
        unint64_t v117 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v157 - v156) >> 3);
      }
      if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v157 - v156) >> 3)) >= 0x249249249249249) {
        unint64_t v118 = 0x492492492492492;
      }
      else {
        unint64_t v118 = v117;
      }
      unint64_t v160 = &v157;
      if (v118)
      {
        unint64_t v118 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawLinearGradient>>(v118);
        uint64_t v107 = *((void *)&v156 + 1);
        uint64_t v115 = v156;
      }
      else
      {
        uint64_t v119 = 0;
      }
      unint64_t v130 = v118 + 56 * v116;
      v158[0] = v118;
      v158[1] = v130;
      unint64_t v131 = v118 + 56 * v119;
      unint64_t v159 = v131;
      *(void *)unint64_t v130 = &unk_1F1A74A68;
      long long v132 = *(_OWORD *)&v161[8];
      *(_OWORD *)(v130 + 24) = v162;
      *(_OWORD *)(v130 + 8) = v132;
      CFTypeRef v133 = v163;
      CFTypeRef v163 = 0;
      *(void *)(v130 + 4CGContextBeginTransparencyLayer(c, 0) = v133;
      *(_DWORD *)(v130 + 48) = 0;
      unint64_t v110 = v130 + 56;
      v158[2] = v130 + 56;
      if (v107 != v115)
      {
        uint64_t v134 = 0;
        do
        {
          *(unsigned char *)(v130 + v134 - 56) = 0;
          uint64_t v135 = v130 + v134 - 56;
          *(_DWORD *)(v135 + 48) = -1;
          v134 -= 56;
          std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1>>(v135, v107 + v134);
        }
        while (v107 + v134 != v115);
        unint64_t v110 = v158[2];
        unint64_t v131 = v159;
        v130 += v134;
        CGContextRef v97 = v147;
      }
      long long v136 = v156;
      *(void *)&long long v156 = v130;
      *((void *)&v156 + 1) = v110;
      *(_OWORD *)&v158[1] = v136;
      unint64_t v137 = v157;
      unint64_t v157 = v131;
      unint64_t v159 = v137;
      v158[0] = v136;
      std::__split_buffer<std::variant<SVG::Image,SVG::Path>>::~__split_buffer((uint64_t)v158);
      this = v139;
    }
    else
    {
      **((void **)&v156 + 1) = &unk_1F1A74A68;
      long long v108 = *(_OWORD *)&v161[8];
      *(_OWORD *)(v107 + 24) = v162;
      *(_OWORD *)(v107 + 8) = v108;
      CFTypeRef v109 = v163;
      CFTypeRef v163 = 0;
      *(void *)(v107 + 4CGContextBeginTransparencyLayer(c, 0) = v109;
      *(_DWORD *)(v107 + 48) = 0;
      unint64_t v110 = v107 + 56;
    }
    *((void *)&v156 + 1) = v110;
    *(void *)unint64_t v161 = &unk_1F1A74A68;
    if (v163) {
      CFRelease(v163);
    }
    if (v106)
    {
      CGImageRef v129 = v106;
LABEL_177:
      CFRelease(v129);
    }
  }
  else
  {
    v158[1] = 0xAAAAAAAAAAAAAA01;
    CGPathRef v111 = CGPathCreateWithRect(*MEMORY[0x1E4F1DB28], 0);
    v158[0] = &unk_1F1A74A30;
    v158[2] = v111;
    if (v111)
    {
      CGPathRef v112 = v111;
      CFRetain(v111);
      CFRelease(v112);
      char v113 = v158[1];
      uint64_t v114 = v158[2];
    }
    else
    {
      uint64_t v114 = 0;
      char v113 = 1;
    }
    *(void *)unint64_t v161 = &unk_1F1A74A30;
    v161[8] = v113;
    v158[2] = 0;
    *(void *)&v161[16] = v114;
    unsigned int v164 = 1;
    unint64_t v127 = operator new(0x38uLL);
    *(void *)this = v127;
    CGAffineTransform v128 = (char *)(v127 + 14);
    *((void *)this + 2) = v127 + 14;
    *(unsigned char *)unint64_t v127 = 0;
    v127[12] = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1> const&>((uint64_t)v127, (uint64_t)v161);
    *((void *)this + 1) = v128;
    if (v164 != -1) {
      ((void (*)(void ***, unsigned char *))*(&off_1F1A75D98 + v164))(&v154, v161);
    }
    v158[0] = &unk_1F1A74A30;
    CGImageRef v129 = (CGImageRef)v158[2];
    if (v158[2]) {
      goto LABEL_177;
    }
  }
  if (c) {
    CFRelease(c);
  }
  if (__pa) {
    operator delete(__pa);
  }
  if (v55)
  {
    while (v56 != v55)
    {
      v56 -= 24;
      *(void *)unint64_t v161 = v56;
      std::vector<std::variant<SVG::Image,SVG::Path>>::__destroy_vector::operator()[abi:nn180100]((void ***)v161);
    }
    operator delete(v55);
  }
  if (v97) {
    goto LABEL_188;
  }
LABEL_189:
  *(void *)unint64_t v161 = &v156;
  std::vector<std::variant<SVG::Image,SVG::Path>>::__destroy_vector::operator()[abi:nn180100]((void ***)v161);
}

double SVG::ClipToPaths::boundingRect(SVG **this, SVG::BoundingRectState *a2)
{
  v4.origin.CGFloat x = SVG::boundingRect(this[1], a2);
  v5.origin.CGFloat x = SVG::BoundingRectState::deviceRect(a2, v4);
  SVG::BoundingRectState::clip(a2, v5);
  return *MEMORY[0x1E4F1DB28];
}

double SVG::boundingRect(SVG *this, const SVG::ClipToPaths::BaseClipNode *a2)
{
  double x = *MEMORY[0x1E4F1DB10];
  CGFloat y = *(double *)(MEMORY[0x1E4F1DB10] + 8);
  CGFloat width = *(double *)(MEMORY[0x1E4F1DB10] + 16);
  CGFloat height = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  uint64_t v7 = (SVG *)*((void *)this + 1);
  if (v7)
  {
    SVG::boundingRect(v7, a2);
    v46.origin.double x = v8;
    v46.origin.CGFloat y = v9;
    v46.size.CGFloat width = v10;
    v46.size.CGFloat height = v11;
    v39.origin.double x = x;
    v39.origin.CGFloat y = y;
    v39.size.CGFloat width = width;
    v39.size.CGFloat height = height;
    CGRect v40 = CGRectIntersection(v39, v46);
    double x = v40.origin.x;
    CGFloat y = v40.origin.y;
    CGFloat width = v40.size.width;
    CGFloat height = v40.size.height;
  }
  if (v12)
  {
    CGFloat v15 = *MEMORY[0x1E4F1DB28];
    CGFloat v14 = *(double *)(MEMORY[0x1E4F1DB28] + 8);
    CGFloat v17 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
    CGFloat v16 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
    uint64_t v18 = (SVG **)*((void *)v12 + 9);
    uint64_t v19 = (SVG **)*((void *)v12 + 10);
    if (v18 != v19)
    {
      uint64_t v20 = (long long *)(v12 + 24);
      do
      {
        uint64_t v21 = *v18;
        v18 += 2;
        SVG::boundingRect(v21, v13);
        long long v22 = *v20;
        long long v23 = v20[2];
        *(_OWORD *)&v38.CGContextRef c = v20[1];
        *(_OWORD *)&v38.tdouble x = v23;
        *(_OWORD *)&v38.CGFloat a = v22;
        CGRect v47 = CGRectApplyAffineTransform(v41, &v38);
        v42.origin.double x = v15;
        v42.origin.CGFloat y = v14;
        v42.size.CGFloat width = v17;
        v42.size.CGFloat height = v16;
        CGRect v43 = CGRectUnion(v42, v47);
        CGFloat v15 = v43.origin.x;
        CGFloat v14 = v43.origin.y;
        CGFloat v17 = v43.size.width;
        CGFloat v16 = v43.size.height;
      }
      while (v18 != v19);
    }
    double v24 = x;
    CGFloat v25 = y;
    CGFloat v26 = width;
    CGFloat v27 = height;
    CGFloat v28 = v15;
    CGFloat v29 = v14;
    CGFloat v30 = v17;
    CGFloat v31 = v16;
    goto LABEL_10;
  }
  if (v32)
  {
    uint64_t v33 = v32;
    CGRect BoundingBox = CGPathGetBoundingBox((CGPathRef)v32[9]);
    long long v34 = *(_OWORD *)(v33 + 3);
    long long v35 = *(_OWORD *)(v33 + 7);
    *(_OWORD *)&v37.CGContextRef c = *(_OWORD *)(v33 + 5);
    *(_OWORD *)&v37.tdouble x = v35;
    *(_OWORD *)&v37.CGFloat a = v34;
    CGRect v45 = CGRectApplyAffineTransform(BoundingBox, &v37);
    CGFloat v28 = v45.origin.x;
    CGFloat v29 = v45.origin.y;
    CGFloat v30 = v45.size.width;
    CGFloat v31 = v45.size.height;
    double v24 = x;
    CGFloat v25 = y;
    CGFloat v26 = width;
    CGFloat v27 = height;
LABEL_10:
    *(void *)&double x = (unint64_t)CGRectIntersection(*(CGRect *)&v24, *(CGRect *)&v28);
  }
  return x;
}

double SVG::ClipToPaths::timeCost(SVG **this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  v9[0] = SVG::BoundingRectState::clipRectInPixels(a3);
  v9[1] = v4;
  void v9[2] = v5;
  void v9[3] = v6;
  return SVG::timeCost(this[1], (const SVG::ClipToPaths::BaseClipNode *)v9, v7);
}

double SVG::timeCost(SVG *this, const SVG::ClipToPaths::BaseClipNode *a2, const CGRect *a3)
{
  uint64_t v5 = (SVG *)*((void *)this + 1);
  if (v5)
  {
    SVG::timeCost(v5, a2, a3);
    double v7 = v6 + 0.0;
  }
  else
  {
    double v7 = 0.0;
  }
  if (v8)
  {
    CGFloat v11 = v8;
    uint64_t v12 = v8[9];
    unint64_t v13 = v8[10];
    if (v12 == v13)
    {
      CGFloat v16 = v8[9];
    }
    else
    {
      do
      {
        CGFloat v14 = *v12;
        v12 += 2;
        SVG::timeCost(v14, a2, v10);
        double v7 = v7 + v15;
      }
      while (v12 != v13);
      uint64_t v12 = v11[9];
      CGFloat v16 = v11[10];
    }
    if ((unint64_t)((char *)v16 - (char *)v12) > 0x10)
    {
      double v18 = SVG::ClipToMask::staticTimeCost((CGRect *)a2, v9);
      return v7 + v18;
    }
  }
  {
    CGFloat v17 = CGRectGetWidth(*(CGRect *)a2) * 0.0008;
    double v18 = v17 * CGRectGetHeight(*(CGRect *)a2) + 100.93;
    return v7 + v18;
  }
  return v7;
}

void SVG::ClipToPaths::memoryCost(SVG **this, const CGRect *a2, const SVG::BoundingRectState *a3)
{
  v8[0] = SVG::BoundingRectState::clipRectInPixels(a3);
  v8[1] = v4;
  v8[2] = v5;
  void v8[3] = v6;
  SVG::memoryCost(this[1], (const SVG::ClipToPaths::BaseClipNode *)v8, v7);
}

void SVG::memoryCost(SVG *this, const SVG::ClipToPaths::BaseClipNode *a2, const CGRect *a3)
{
  uint64_t v5 = (SVG *)*((void *)this + 1);
  if (v5)
  {
    SVG::memoryCost(v5, a2, a3);
    double v7 = v6 + 0.0;
  }
  else
  {
    double v7 = 0.0;
  }
  if (v8)
  {
    CGFloat v10 = v8;
    CGFloat v11 = v8[9];
    uint64_t v12 = v8[10];
    if (v11 == v12)
    {
      double v15 = v8[9];
    }
    else
    {
      do
      {
        unint64_t v13 = *v11;
        v11 += 2;
        SVG::memoryCost(v13, a2, v9);
        double v7 = v7 + v14;
      }
      while (v11 != v12);
      CGFloat v11 = v10[9];
      double v15 = v10[10];
    }
    if ((unint64_t)((char *)v15 - (char *)v11) > 0x10)
    {
      CGRectGetWidth(*(CGRect *)a2);
      CGRectGetHeight(*(CGRect *)a2);
    }
  }
}

void SVG::ClipToPaths::~ClipToPaths(SVG::ClipToPaths *this)
{
  *(void *)this = &unk_1F1A74458;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

{
  std::__shared_weak_count *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1A74458;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  JUMPOUT(0x1C18A3E80);
}

uint64_t SVG::ClipToPaths::dump(SVG::ClipToPaths *this)
{
  uint64_t v1 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"ClipToPaths", 11);
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(void *)(*v1 - 24)));
  uint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  return std::ostream::flush();
}

double SVG::Image::boundingBox(SVG::Image *this)
{
  return *((double *)this + 1);
}

void SVG::Image::clip(SVG::Image *this, CGContextRef c)
{
}

double SVG::Path::boundingBox(SVG::Path *this)
{
  *(void *)&double result = (unint64_t)CGPathGetBoundingBox((CGPathRef)*((void *)this + 2));
  return result;
}

void SVG::Path::clip(CGPathRef *this, CGContextRef c)
{
  CGContextAddPath(c, this[2]);
  if (*((unsigned char *)this + 8))
  {
    CGContextEOClip(c);
  }
  else
  {
    CGContextClip(c);
  }
}

uint64_t std::vector<std::variant<SVG::Image,SVG::Path>>::emplace_back<std::variant<SVG::Image,SVG::Path>>(uint64_t *a1, uint64_t a2)
{
  std::locale v4 = a1 + 2;
  unint64_t v5 = a1[2];
  unint64_t v6 = a1[1];
  if (v6 >= v5)
  {
    uint64_t v9 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v6 - *a1) >> 3);
    if ((unint64_t)(v9 + 1) > 0x492492492492492) {
      abort();
    }
    unint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v5 - *a1) >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x249249249249249) {
      unint64_t v12 = 0x492492492492492;
    }
    else {
      unint64_t v12 = v11;
    }
    CGFloat v25 = v4;
    if (v12) {
      unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<SVG::DrawLinearGradient>>(v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = v12 + 56 * v9;
    unint64_t v15 = v12 + 56 * v13;
    unint64_t v24 = v15;
    *(unsigned char *)uint64_t v14 = 0;
    *(_DWORD *)(v14 + 48) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1>>(v14, a2);
    uint64_t v8 = v14 + 56;
    v23.i64[1] = v14 + 56;
    uint64_t v17 = *a1;
    unint64_t v16 = a1[1];
    if (v16 == *a1)
    {
      int64x2_t v20 = vdupq_n_s64(v16);
    }
    else
    {
      uint64_t v18 = 0;
      do
      {
        *(unsigned char *)(v14 + v18 - 56) = 0;
        uint64_t v19 = v14 + v18 - 56;
        *(_DWORD *)(v19 + 48) = -1;
        v18 -= 56;
        std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1>>(v19, v16 + v18);
      }
      while (v16 + v18 != v17);
      int64x2_t v20 = *(int64x2_t *)a1;
      v14 += v18;
      uint64_t v8 = v23.i64[1];
      unint64_t v15 = v24;
    }
    *a1 = v14;
    a1[1] = v8;
    int64x2_t v23 = v20;
    uint64_t v21 = a1[2];
    a1[2] = v15;
    unint64_t v24 = v21;
    uint64_t v22 = v20.i64[0];
    uint64_t result = std::__split_buffer<std::variant<SVG::Image,SVG::Path>>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    *(unsigned char *)unint64_t v6 = 0;
    *(_DWORD *)(v6 + 48) = -1;
    uint64_t result = std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1>>(v6, a2);
    uint64_t v8 = v6 + 56;
  }
  a1[1] = v8;
  return result;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 48);
  if (v4 != -1) {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A75D98 + v4))(&v7, result);
  }
  *(_DWORD *)(v3 + 48) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 48);
  if (v5 != -1)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A75DA8 + v5))(&v6, v3, a2);
    *(_DWORD *)(v3 + 48) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_EEEEEEDcSE_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74A68;
  uint64_t v2 = (const void *)a2[5];
  if (v2) {
    CFRelease(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_EEEEEEDcSE_DpT0_(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1A74A30;
  uint64_t v2 = (const void *)a2[2];
  if (v2) {
    CFRelease(v2);
  }
}

CFTypeRef _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSK_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEERKSS_EEEDcSK_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F1A74A68;
  long long v3 = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(a2 + 8) = v3;
  CFTypeRef result = *(CFTypeRef *)(a3 + 40);
  *(void *)(a2 + 4CGContextBeginTransparencyLayer(c, 0) = result;
  if (result) {
    return CFRetain(result);
  }
  return result;
}

CFTypeRef _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSK_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEERKSS_EEEDcSK_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F1A74A30;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(a3 + 8);
  CFTypeRef result = *(CFTypeRef *)(a3 + 16);
  *(void *)(a2 + 16) = result;
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<SVG::Image,SVG::Path>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<SVG::Image,SVG::Path>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 48);
  if (v4 != -1) {
    CFTypeRef result = ((uint64_t (*)(char *, uint64_t))*(&off_1F1A75D98 + v4))(&v7, result);
  }
  *(_DWORD *)(v3 + 48) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 48);
  if (v5 != -1)
  {
    CFTypeRef result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F1A75DB8 + v5))(&v6, v3, a2);
    *(_DWORD *)(v3 + 48) = v5;
  }
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F1A74A68;
  __n128 result = *(__n128 *)(a3 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
  *(__n128 *)(a2 + 8) = result;
  uint64_t v4 = *(void *)(a3 + 40);
  *(void *)(a3 + 4CGContextBeginTransparencyLayer(c, 0) = 0;
  *(void *)(a2 + 4CGContextBeginTransparencyLayer(c, 0) = v4;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F1A74A30;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(a3 + 8);
  uint64_t v3 = *(void *)(a3 + 16);
  *(void *)(a3 + 16) = 0;
  *(void *)(a2 + 16) = v3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISB_LNS0_6_TraitE1EEEEEvOT_EUlRSH_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSP_EEEDcSH_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 48);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5)
  {
    ((void (*)(char *, uint64_t))*(&off_1F1A75D98 + v5))(&v11, v4);
LABEL_7:
    *(_DWORD *)(v4 + 48) = -1;
    *(void *)uint64_t v4 = &unk_1F1A74A68;
    __n128 result = *(__n128 *)(a3 + 8);
    *(_OWORD *)(v4 + 24) = *(_OWORD *)(a3 + 24);
    *(__n128 *)(v4 + 8) = result;
    uint64_t v10 = *(void *)(a3 + 40);
    *(void *)(a3 + 4CGContextBeginTransparencyLayer(c, 0) = 0;
    *(void *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = v10;
    *(_DWORD *)(v4 + 48) = 0;
    return result;
  }
  __n128 result = *(__n128 *)(a3 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
  *(__n128 *)(a2 + 8) = result;
  uint64_t v8 = *(const void **)(a2 + 40);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = *(void *)(a3 + 40);
  *(void *)(a3 + 4CGContextBeginTransparencyLayer(c, 0) = 0;
  *(void *)(a2 + 4CGContextBeginTransparencyLayer(c, 0) = v9;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISB_LNS0_6_TraitE1EEEEEvOT_EUlRSH_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSP_EEEDcSH_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 48);
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 1)
  {
    ((void (*)(char *, uint64_t))*(&off_1F1A75D98 + v5))(&v10, v4);
LABEL_7:
    *(void *)uint64_t v4 = &unk_1F1A74A30;
    *(unsigned char *)(v4 + 8) = *(unsigned char *)(a3 + 8);
    uint64_t v9 = *(void *)(a3 + 16);
    *(void *)(a3 + 16) = 0;
    *(void *)(v4 + 16) = v9;
    *(_DWORD *)(v4 + 48) = 1;
    return;
  }
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(a3 + 8);
  char v7 = *(const void **)(a2 + 16);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(void *)(a3 + 16);
  *(void *)(a3 + 16) = 0;
  *(void *)(a2 + 16) = v8;
}

CFTypeRef _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISB_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEERKSR_EEEDcSJ_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 48);
  if (v5 != -1)
  {
    if (!v5)
    {
      long long v7 = *(_OWORD *)(a3 + 8);
      *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
      *(_OWORD *)(a2 + 8) = v7;
      uint64_t v8 = *(const void **)(a2 + 40);
      if (v8) {
        CFRelease(v8);
      }
      CFTypeRef result = *(CFTypeRef *)(a3 + 40);
      *(void *)(a2 + 4CGContextBeginTransparencyLayer(c, 0) = result;
      if (result)
      {
        return CFRetain(result);
      }
      return result;
    }
    ((void (*)(char *, uint64_t))*(&off_1F1A75D98 + v5))(&v11, v4);
  }
  *(_DWORD *)(v4 + 48) = -1;
  *(void *)uint64_t v4 = &unk_1F1A74A68;
  long long v10 = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(v4 + 24) = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(v4 + 8) = v10;
  CFTypeRef result = *(CFTypeRef *)(a3 + 40);
  *(void *)(v4 + 4CGContextBeginTransparencyLayer(c, 0) = result;
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *(_DWORD *)(v4 + 48) = 0;
  return result;
}

CFTypeRef _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJN3SVG5ImageENS8_4PathEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISB_LNS0_6_TraitE1EEEEEvOT_EUlRSJ_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEERKSR_EEEDcSJ_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(unsigned int *)(*a1 + 48);
  if (v5 != -1)
  {
    if (v5 == 1)
    {
      *(unsigned char *)(a2 + 8) = *(unsigned char *)(a3 + 8);
      long long v7 = *(const void **)(a2 + 16);
      if (v7) {
        CFRelease(v7);
      }
      CFTypeRef result = *(CFTypeRef *)(a3 + 16);
      *(void *)(a2 + 16) = result;
      if (result)
      {
        return CFRetain(result);
      }
      return result;
    }
    ((void (*)(char *, uint64_t))*(&off_1F1A75D98 + v5))(&v9, v4);
  }
  *(_DWORD *)(v4 + 48) = -1;
  *(void *)uint64_t v4 = &unk_1F1A74A30;
  *(unsigned char *)(v4 + 8) = *(unsigned char *)(a3 + 8);
  CFTypeRef result = *(CFTypeRef *)(a3 + 16);
  *(void *)(v4 + 16) = result;
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *(_DWORD *)(v4 + 48) = 1;
  return result;
}

uint64_t std::__split_buffer<std::variant<SVG::Image,SVG::Path>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 != v2)
  {
    do
    {
      uint64_t v4 = v3 - 56;
      *(void *)(a1 + 16) = v3 - 56;
      uint64_t v5 = *(unsigned int *)(v3 - 8);
      if (v5 != -1)
      {
        ((void (*)(char *))*(&off_1F1A75D98 + v5))(&v7);
        uint64_t v4 = *(void *)(a1 + 16);
      }
      *(_DWORD *)(v3 - 8) = -1;
      uint64_t v3 = v4;
    }
    while (v4 != v2);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::simplify(SVG::ClipToPaths::BaseClipNode const&,CGContext *)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v2 = ***a1;
  long long v3 = *(_OWORD *)(v2 + 24);
  long long v4 = *(_OWORD *)(v2 + 56);
  v6[1] = *(_OWORD *)(v2 + 40);
  void v6[2] = v4;
  v6[0] = v3;
  return (*(uint64_t (**)(uint64_t, _OWORD *))(*(void *)a2 + 32))(a2, v6);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::simplify(SVG::ClipToPaths::BaseClipNode const&,CGContext *)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v2 = ***a1;
  long long v3 = *(_OWORD *)(v2 + 24);
  long long v4 = *(_OWORD *)(v2 + 56);
  v6[1] = *(_OWORD *)(v2 + 40);
  void v6[2] = v4;
  v6[0] = v3;
  return (*(uint64_t (**)(uint64_t, _OWORD *))(*(void *)a2 + 32))(a2, v6);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::simplify(SVG::ClipToPaths::BaseClipNode const&,CGContext *)::$_1> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v2 = ***a1;
  long long v3 = *(_OWORD *)(v2 + 24);
  long long v4 = *(_OWORD *)(v2 + 56);
  v6[1] = *(_OWORD *)(v2 + 40);
  void v6[2] = v4;
  v6[0] = v3;
  return (*(uint64_t (**)(uint64_t, _OWORD *))(*(void *)a2 + 32))(a2, v6);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::simplify(SVG::ClipToPaths::BaseClipNode const&,CGContext *)::$_1> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v2 = ***a1;
  long long v3 = *(_OWORD *)(v2 + 24);
  long long v4 = *(_OWORD *)(v2 + 56);
  v6[1] = *(_OWORD *)(v2 + 40);
  void v6[2] = v4;
  v6[0] = v3;
  return (*(uint64_t (**)(uint64_t, _OWORD *))(*(void *)a2 + 32))(a2, v6);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::simplify(SVG::ClipToPaths::BaseClipNode const&,CGContext *)::$_2> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::simplify(SVG::ClipToPaths::BaseClipNode const&,CGContext *)::$_2> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::simplify(SVG::ClipToPaths::BaseClipNode const&,CGContext *)::$_3> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 24))(a2, ***a1);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::simplify(SVG::ClipToPaths::BaseClipNode const&,CGContext *)::$_3> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 24))(a2, ***a1);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::ClipToPaths::execute(CGContext *,SVG::PlaybackState &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 24))(a2, ***a1);
}

uint64_t std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<SVG::ClipToPaths::execute(CGContext *,SVG::PlaybackState &)::$_0> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,SVG::Image,SVG::Path> const&>(void ***a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 24))(a2, ***a1);
}

void std::vector<std::variant<SVG::Image,SVG::Path>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    long long v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        char v6 = v4 - 56;
        uint64_t v7 = *((unsigned int *)v4 - 2);
        if (v7 != -1) {
          ((void (*)(char *, char *))*(&off_1F1A75D98 + v7))(&v8, v4 - 56);
        }
        *((_DWORD *)v4 - 2) = -1;
        v4 -= 56;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t SVG::RadialGradientElement::RadialGradientElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = 0;
  *(void *)a1 = &unk_1F1A749A8;
  *(unsigned char *)(a1 + 648) = 0;
  *(unsigned char *)(a1 + 652) = 0;
  *(unsigned char *)(a1 + 656) = 0;
  *(unsigned char *)(a1 + 704) = 0;
  *(unsigned char *)(a1 + 712) = 0;
  *(unsigned char *)(a1 + 716) = 0;
  *(unsigned char *)(a1 + 72CGContextBeginTransparencyLayer(c, 0) = 0;
  *(unsigned char *)(a1 + 736) = 0;
  *(unsigned char *)(a1 + 744) = 0;
  *(unsigned char *)(a1 + 76CGContextBeginTransparencyLayer(c, 0) = 0;
  *(unsigned char *)(a1 + 768) = 0;
  *(unsigned char *)(a1 + 784) = 0;
  *(unsigned char *)(a1 + 792) = 0;
  *(unsigned char *)(a1 + 808) = 0;
  *(unsigned char *)(a1 + 816) = 0;
  *(unsigned char *)(a1 + 832) = 0;
  SVG::GradientElement::parseAttributes((void *)a1, a3);
  std::string::basic_string[abi:nn180100]<0>(v19, "cx");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v19, (uint64_t)__p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
  if (v6)
  {
    v19[0] = (void *)-1;
    v19[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v6 + 64), (uint64_t)v19);
    if ((_BYTE)v20)
    {
      int v7 = *(unsigned __int8 *)(a1 + 736);
      *(_OWORD *)(a1 + 72CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)v19;
      if (!v7) {
        *(unsigned char *)(a1 + 736) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v19, "cy");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  char v8 = SVG::Element::findInAttributeMap(a3, (uint64_t)v19, (uint64_t)__p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
  if (v8)
  {
    v19[0] = (void *)-1;
    v19[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v8 + 64), (uint64_t)v19);
    if ((_BYTE)v20)
    {
      int v9 = *(unsigned __int8 *)(a1 + 760);
      *(_OWORD *)(a1 + 744) = *(_OWORD *)v19;
      if (!v9) {
        *(unsigned char *)(a1 + 76CGContextBeginTransparencyLayer(c, 0) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v19, "r");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  long long v10 = SVG::Element::findInAttributeMap(a3, (uint64_t)v19, (uint64_t)__p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
  if (v10)
  {
    v19[0] = (void *)-1;
    v19[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v10 + 64), (uint64_t)v19);
    if ((_BYTE)v20)
    {
      int v11 = *(unsigned __int8 *)(a1 + 784);
      *(_OWORD *)(a1 + 768) = *(_OWORD *)v19;
      if (!v11) {
        *(unsigned char *)(a1 + 784) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v19, "fx");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  unint64_t v12 = SVG::Element::findInAttributeMap(a3, (uint64_t)v19, (uint64_t)__p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
  if (v12)
  {
    v19[0] = (void *)-1;
    v19[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v12 + 64), (uint64_t)v19);
    if ((_BYTE)v20)
    {
      int v13 = *(unsigned __int8 *)(a1 + 808);
      *(_OWORD *)(a1 + 792) = *(_OWORD *)v19;
      if (!v13) {
        *(unsigned char *)(a1 + 808) = 1;
      }
    }
  }
  std::string::basic_string[abi:nn180100]<0>(v19, "fy");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v14 = SVG::Element::findInAttributeMap(a3, (uint64_t)v19, (uint64_t)__p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
  if (v14)
  {
    v19[0] = (void *)-1;
    v19[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
    SVG::consumeLengthAlone((uint64_t)(v14 + 64), (uint64_t)v19);
    if ((_BYTE)v20)
    {
      int v15 = *(unsigned __int8 *)(a1 + 832);
      *(_OWORD *)(a1 + 816) = *(_OWORD *)v19;
      if (!v15) {
        *(unsigned char *)(a1 + 832) = 1;
      }
    }
  }
  return a1;
}

void SVG::RadialGradientElement::specifiedRadialState(unint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 128) = xmmword_1BF1DBA60;
  *(_OWORD *)(a3 + 144) = unk_1BF1DBA70;
  *(_OWORD *)(a3 + 16CGContextBeginTransparencyLayer(c, 0) = xmmword_1BF1DBA80;
  *(_OWORD *)(a3 + 176) = unk_1BF1DBA90;
  *(_OWORD *)(a3 + 64) = xmmword_1BF1DBA20;
  *(_OWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = unk_1BF1DBA30;
  *(_OWORD *)(a3 + 96) = xmmword_1BF1DBA40;
  *(_OWORD *)(a3 + 112) = unk_1BF1DBA50;
  *(_OWORD *)a3 = xmmword_1BF1DB9E0;
  *(_OWORD *)(a3 + 16) = unk_1BF1DB9F0;
  *(_OWORD *)(a3 + 32) = xmmword_1BF1DBA00;
  *(_OWORD *)(a3 + 48) = unk_1BF1DBA10;
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 4) = 0;
  *(unsigned char *)(a3 + 8) = 0;
  uint64_t v69 = (_OWORD *)(a3 + 8);
  *(unsigned char *)(a3 + 56) = 0;
  *(unsigned char *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 68) = 0;
  *(unsigned char *)(a3 + 72) = 0;
  uint64_t v72 = a3 + 72;
  *(unsigned char *)(a3 + 88) = 0;
  *(unsigned char *)(a3 + 96) = 0;
  *(unsigned char *)(a3 + 112) = 0;
  *(unsigned char *)(a3 + 12CGContextBeginTransparencyLayer(c, 0) = 0;
  uint64_t v71 = a3 + 120;
  *(unsigned char *)(a3 + 136) = 0;
  *(unsigned char *)(a3 + 144) = 0;
  *(unsigned char *)(a3 + 16CGContextBeginTransparencyLayer(c, 0) = 0;
  *(unsigned char *)(a3 + 168) = 0;
  uint64_t v70 = a3 + 168;
  *(unsigned char *)(a3 + 184) = 0;
  uint64_t v5 = (char *)operator new(8uLL);
  *(void *)uint64_t v5 = a1;
  char v6 = v5 + 8;
  memset(v74, 0, 32);
  *(void *)&unsigned char v74[32] = 0xAAAAAAAA3F800000;
  unint64_t v7 = 0x9DDFEA08EB382D69 * (((((a1 >> 3) & 0x3FFFFFF) << 6) | 8) ^ HIDWORD(a1));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(a1) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  long long v10 = operator new(0x18uLL);
  v10[1] = v9;
  void v10[2] = a1;
  std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>((uint64_t)v74, 1uLL);
  unint64_t v11 = *(void *)&v74[8];
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v74[8]);
  v12.i16[0] = vaddlv_u8(v12);
  if (v12.u32[0] > 1uLL)
  {
    if (v9 >= *(void *)&v74[8]) {
      v9 %= *(void *)&v74[8];
    }
  }
  else
  {
    v9 &= *(void *)&v74[8] - 1;
  }
  uint64_t v13 = *(void *)v74;
  uint64_t v14 = *(void **)(*(void *)v74 + 8 * v9);
  if (v14)
  {
    *long long v10 = *v14;
  }
  else
  {
    *long long v10 = *(void *)&v74[16];
    *(void *)&v74[16] = v10;
    *(void *)(v13 + 8 * v9) = &v74[16];
    if (!*v10) {
      goto LABEL_14;
    }
    unint64_t v15 = *(void *)(*v10 + 8);
    if (v12.u32[0] > 1uLL)
    {
      if (v15 >= v11) {
        v15 %= v11;
      }
    }
    else
    {
      v15 &= v11 - 1;
    }
    uint64_t v14 = (void *)(*(void *)v74 + 8 * v15);
  }
  *uint64_t v14 = v10;
LABEL_14:
  ++*(void *)&v74[24];
  *(void *)uint64_t v80 = *(void *)(*(void *)v5 + 640);
  if (*(void *)v80)
  {
    unint64_t v16 = v5 + 8;
    while (1)
    {
      uint64_t v17 = std::__hash_table<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::__unordered_map_hasher<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::hash<__CFURL const*>,std::equal_to<__CFURL const*>,true>,std::__unordered_map_equal<__CFURL const*,std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>,std::equal_to<__CFURL const*>,std::hash<__CFURL const*>,true>,std::allocator<std::__hash_value_type<__CFURL const*,std::reference_wrapper<SVG::Element const>>>>::find<__CFURL const*>(a2, v80);
      if (!v17)
      {
        CGRect v43 = v16;
        goto LABEL_95;
      }
      if (!v18) {
        goto LABEL_96;
      }
      unint64_t v19 = v18;
      unint64_t v20 = *(void *)&v74[8];
      unint64_t v21 = 0x9DDFEA08EB382D69 * (((8 * v18) + 8) ^ HIDWORD(v18));
      unint64_t v22 = 0x9DDFEA08EB382D69 * (HIDWORD(v18) ^ (v21 >> 47) ^ v21);
      unint64_t v23 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
      unint64_t v24 = v6;
      if (*(void *)&v74[8])
      {
        uint8x8_t v25 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v74[8]);
        v25.i16[0] = vaddlv_u8(v25);
        if (v25.u32[0] > 1uLL)
        {
          unint64_t v26 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
          if (v23 >= *(void *)&v74[8]) {
            unint64_t v26 = v23 % *(void *)&v74[8];
          }
        }
        else
        {
          unint64_t v26 = (*(void *)&v74[8] - 1) & v23;
        }
        CGFloat v28 = *(void **)(*(void *)v74 + 8 * v26);
        if (v28)
        {
          for (uint64_t i = (void *)*v28; i; uint64_t i = (void *)*i)
          {
            unint64_t v30 = i[1];
            if (v30 == v23)
            {
              if (i[2] == v18) {
                goto LABEL_96;
              }
            }
            else
            {
              if (v25.u32[0] > 1uLL)
              {
                if (v30 >= *(void *)&v74[8]) {
                  v30 %= *(void *)&v74[8];
                }
              }
              else
              {
                v30 &= *(void *)&v74[8] - 1;
              }
              if (v30 != v26) {
                break;
              }
            }
          }
        }
        if (v25.u32[0] > 1uLL)
        {
          unint64_t v27 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
          if (v23 >= *(void *)&v74[8]) {
            unint64_t v27 = v23 % *(void *)&v74[8];
          }
        }
        else
        {
          unint64_t v27 = (*(void *)&v74[8] - 1) & v23;
        }
        CGFloat v31 = *(void **)(*(void *)v74 + 8 * v27);
        if (v31)
        {
          for (j = (void *)*v31; j; j = (void *)*j)
          {
            unint64_t v33 = j[1];
            if (v33 == v23)
            {
              if (j[2] == v18) {
                goto LABEL_72;
              }
            }
            else
            {
              if (v25.u32[0] > 1uLL)
              {
                if (v33 >= *(void *)&v74[8]) {
                  v33 %= *(void *)&v74[8];
                }
              }
              else
              {
                v33 &= *(void *)&v74[8] - 1;
              }
              if (v33 != v27) {
                break;
              }
            }
          }
        }
      }
      else
      {
        unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
      }
      long long v34 = operator new(0x18uLL);
      *long long v34 = 0;
      v34[1] = v23;
      v34[2] = v19;
      float v35 = (float)(unint64_t)(*(void *)&v74[24] + 1);
      if (!v20 || (float)(*(float *)&v74[32] * (float)v20) < v35)
      {
        BOOL v36 = (v20 & (v20 - 1)) != 0;
        if (v20 < 3) {
          BOOL v36 = 1;
        }
        unint64_t v37 = v36 | (2 * v20);
        unint64_t v38 = vcvtps_u32_f32(v35 / *(float *)&v74[32]);
        if (v37 <= v38) {
          size_t v39 = v38;
        }
        else {
          size_t v39 = v37;
        }
        std::__hash_table<SVG::GradientElement const*,std::hash<SVG::GradientElement const*>,std::equal_to<SVG::GradientElement const*>,std::allocator<SVG::GradientElement const*>>::__rehash<true>((uint64_t)v74, v39);
        unint64_t v20 = *(void *)&v74[8];
        if ((*(void *)&v74[8] & (*(void *)&v74[8] - 1)) != 0)
        {
          if (v23 >= *(void *)&v74[8]) {
            unint64_t v27 = v23 % *(void *)&v74[8];
          }
          else {
            unint64_t v27 = v23;
          }
        }
        else
        {
          unint64_t v27 = (*(void *)&v74[8] - 1) & v23;
        }
      }
      uint64_t v40 = *(void *)v74;
      CGRect v41 = *(void **)(*(void *)v74 + 8 * v27);
      if (v41) {
        break;
      }
      *long long v34 = *(void *)&v74[16];
      *(void *)&v74[16] = v34;
      *(void *)(v40 + 8 * v27) = &v74[16];
      if (*v34)
      {
        unint64_t v42 = *(void *)(*v34 + 8);
        if ((v20 & (v20 - 1)) != 0)
        {
          if (v42 >= v20) {
            v42 %= v20;
          }
        }
        else
        {
          v42 &= v20 - 1;
        }
        CGRect v41 = (void *)(*(void *)v74 + 8 * v42);
        goto LABEL_70;
      }
LABEL_71:
      ++*(void *)&v74[24];
      char v6 = v24;
LABEL_72:
      if (v16 >= v6)
      {
        uint64_t v44 = (v16 - v5) >> 3;
        unint64_t v45 = v44 + 1;
        if ((unint64_t)(v44 + 1) >> 61) {
          abort();
        }
        if ((v6 - v5) >> 2 > v45) {
          unint64_t v45 = (v6 - v5) >> 2;
        }
        if ((unint64_t)(v6 - v5) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v46 = v45;
        }
        if (v46)
        {
          if (v46 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          CGRect v47 = (char *)operator new(8 * v46);
        }
        else
        {
          CGRect v47 = 0;
        }
        unint64_t v48 = &v47[8 * v44];
        char v6 = &v47[8 * v46];
        *(void *)unint64_t v48 = v19;
        CGRect v43 = v48 + 8;
        if (v16 == v5)
        {
          uint64_t v5 = v16;
        }
        else
        {
          do
          {
            uint64_t v49 = *((void *)v16 - 1);
            v16 -= 8;
            *((void *)v48 - 1) = v49;
            v48 -= 8;
          }
          while (v16 != v5);
          if (!v5) {
            goto LABEL_90;
          }
        }
        operator delete(v5);
LABEL_90:
        uint64_t v5 = v48;
        goto LABEL_91;
      }
      *(void *)unint64_t v16 = v19;
      CGRect v43 = v16 + 8;
LABEL_91:
      *(void *)uint64_t v80 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)uint64_t v80 = *(void *)(*((void *)v43 - 1) + 640);
      unint64_t v16 = v43;
      if (!*(void *)v80) {
        goto LABEL_95;
      }
    }
    *long long v34 = *v41;
LABEL_70:
    *CGRect v41 = v34;
    goto LABEL_71;
  }
  CGRect v43 = v5 + 8;
LABEL_95:
  unint64_t v16 = v43;
LABEL_96:
  CFTypeRef v50 = *(void **)&v74[16];
  if (*(void *)&v74[16])
  {
    do
    {
      CGFloat v51 = (void *)*v50;
      operator delete(v50);
      CFTypeRef v50 = v51;
    }
    while (v51);
  }
  CGFloat v52 = *(void **)v74;
  *(void *)uint64_t v74 = 0;
  if (v52) {
    operator delete(v52);
  }
  for (; v16 != v5; *(_OWORD *)(a3 + 48) = v66)
  {
    uint64_t v54 = *((void *)v16 - 1);
    v16 -= 8;
    CGFloat v53 = (unsigned char *)v54;
    long long v55 = *(_OWORD *)(v54 + 792);
    *(_OWORD *)&v77[16] = *(_OWORD *)(v54 + 776);
    long long v78 = v55;
    long long v56 = *(_OWORD *)(v54 + 824);
    *(_OWORD *)unsigned int v79 = *(_OWORD *)(v54 + 808);
    *(_OWORD *)&v79[16] = v56;
    long long v57 = *(_OWORD *)(v54 + 728);
    *(_OWORD *)uint64_t v75 = *(_OWORD *)(v54 + 712);
    *(_OWORD *)&v75[16] = v57;
    long long v58 = *(_OWORD *)(v54 + 760);
    long long v76 = *(_OWORD *)(v54 + 744);
    *(_OWORD *)CGFloat v77 = v58;
    long long v59 = *(_OWORD *)(v54 + 664);
    *(_OWORD *)uint64_t v74 = *(_OWORD *)(v54 + 648);
    *(_OWORD *)&v74[16] = v59;
    long long v60 = *(_OWORD *)(v54 + 696);
    *(_OWORD *)&unsigned char v74[32] = *(_OWORD *)(v54 + 680);
    *(_OWORD *)&v74[48] = v60;
    *(_OWORD *)uint64_t v80 = xmmword_1BF1DB998;
    memset(&v80[16], 255, 32);
    *(_OWORD *)&v80[48] = unk_1BF1DB9C8;
    unint64_t v81 = 0xAAAAAAAAAAAAAAAALL;
    SVG::GradientElement::State::specifiedInherit(v54 + 648, a3, (uint64_t)v80);
    *(_DWORD *)uint64_t v74 = *(_DWORD *)v80;
    v74[4] = v80[4];
    *(_OWORD *)&v74[8] = *(_OWORD *)&v80[8];
    *(_OWORD *)&v74[24] = *(_OWORD *)&v80[24];
    *(_OWORD *)&v74[40] = *(_OWORD *)&v80[40];
    v74[56] = v80[56];
    *(_DWORD *)uint64_t v75 = v81;
    v75[4] = BYTE4(v81);
    if (!*(unsigned char *)(v54 + 736) && *(unsigned char *)(a3 + 88))
    {
      *(_OWORD *)&v75[8] = *(_OWORD *)v72;
      v75[24] = *(unsigned char *)(v72 + 16);
    }
    if (!v53[760] && *(unsigned char *)(a3 + 112))
    {
      long long v76 = *(_OWORD *)(a3 + 96);
      v77[0] = *(unsigned char *)(a3 + 112);
    }
    if (!v53[784] && *(unsigned char *)(a3 + 136))
    {
      *(_OWORD *)&v77[8] = *(_OWORD *)v71;
      v77[24] = *(unsigned char *)(v71 + 16);
    }
    if (!v53[808] && *(unsigned char *)(a3 + 160))
    {
      long long v78 = *(_OWORD *)(a3 + 144);
      v79[0] = *(unsigned char *)(a3 + 160);
    }
    if (!v53[832] && *(unsigned char *)(a3 + 184))
    {
      *(_OWORD *)&v79[8] = *(_OWORD *)v70;
      v79[24] = *(unsigned char *)(v70 + 16);
    }
    long long v61 = v78;
    *(_OWORD *)(a3 + 128) = *(_OWORD *)&v77[16];
    *(_OWORD *)(a3 + 144) = v61;
    long long v62 = *(_OWORD *)&v79[16];
    *(_OWORD *)(a3 + 16CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)v79;
    *(_OWORD *)(a3 + 176) = v62;
    long long v63 = *(_OWORD *)&v75[16];
    *(_OWORD *)(a3 + 64) = *(_OWORD *)v75;
    *(_OWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = v63;
    long long v64 = *(_OWORD *)v77;
    *(_OWORD *)(a3 + 96) = v76;
    *(_OWORD *)(a3 + 112) = v64;
    long long v65 = *(_OWORD *)&v74[16];
    *(_OWORD *)a3 = *(_OWORD *)v74;
    *(_OWORD *)(a3 + 16) = v65;
    long long v66 = *(_OWORD *)&v74[48];
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v74[32];
  }
  if (!*(unsigned char *)(a3 + 4))
  {
    *(_DWORD *)a3 = 1;
    *(unsigned char *)(a3 + 4) = 1;
  }
  if (!*(unsigned char *)(a3 + 56))
  {
    uint64_t v67 = MEMORY[0x1E4F1DAB8];
    long long v68 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *uint64_t v69 = *MEMORY[0x1E4F1DAB8];
    v69[1] = v68;
    v69[2] = *(_OWORD *)(v67 + 32);
    *(unsigned char *)(a3 + 56) = 1;
  }
  if (!*(unsigned char *)(a3 + 68))
  {
    *(_DWORD *)(a3 + 64) = 0;
    *(unsigned char *)(a3 + 68) = 1;
  }
  if (!*(unsigned char *)(a3 + 88))
  {
    *(void *)(a3 + 72) = 0x4049000000000000;
    *(_DWORD *)(a3 + 8CGContextBeginTransparencyLayer(c, 0) = 1;
    *(unsigned char *)(a3 + 88) = 1;
  }
  if (!*(unsigned char *)(a3 + 112))
  {
    *(void *)(a3 + 96) = 0x4049000000000000;
    *(_DWORD *)(a3 + 104) = 1;
    *(unsigned char *)(a3 + 112) = 1;
  }
  if (!*(unsigned char *)(a3 + 136))
  {
    *(void *)(a3 + 12CGContextBeginTransparencyLayer(c, 0) = 0x4049000000000000;
    *(_DWORD *)(a3 + 128) = 1;
    *(unsigned char *)(a3 + 136) = 1;
  }
  if (v5) {
    operator delete(v5);
  }
}

void SVG::RadialGradientElement::~RadialGradientElement(SVG::RadialGradientElement *this)
{
  *(void *)this = &unk_1F1A74810;
  uint64_t v2 = (const void *)*((void *)this + 80);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E38 + v3))(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E50 + v4))(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E68 + v5))(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E50 + v6))(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E68 + v7))(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;

  *(void *)this = &unk_1F1A74810;
  uint64_t v2 = (const void *)*((void *)this + 80);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((unsigned int *)this + 128);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E38 + v3))(&v8, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v4 = *((unsigned int *)this + 116);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E50 + v4))(&v9, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v5 = *((unsigned int *)this + 82);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E68 + v5))(&v10, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v6 = *((unsigned int *)this + 66);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E50 + v6))(&v11, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v7 = *((unsigned int *)this + 36);
  if (v7 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E68 + v7))(&v12, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

uint64_t SVG::RadialGradientElement::getState(SVG::RadialGradientElement *this)
{
  return (uint64_t)this + 648;
}

__n128 SVG::RadialGradientElement::specifiedState@<Q0>(unint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  SVG::RadialGradientElement::specifiedRadialState(a1, a2, (uint64_t)v6);
  long long v4 = v6[3];
  *(_OWORD *)(a3 + 32) = v6[2];
  *(_OWORD *)(a3 + 48) = v4;
  *(void *)(a3 + 64) = v7;
  __n128 result = (__n128)v6[1];
  *(_OWORD *)a3 = v6[0];
  *(__n128 *)(a3 + 16) = result;
  return result;
}

uint64_t SVG::StopElement::StopElement(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = SVG::Element::Element(a1, a2, a3);
  SVG::Presentation::Presentation(v5 + 64, a3);
  *(void *)a1 = &unk_1F1A745C0;
  *(void *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = 0;
  *(_DWORD *)(a1 + 648) = 0;
  std::string::basic_string[abi:nn180100]<0>(v10, "offset");
  std::string::basic_string[abi:nn180100]<0>(__p, "http://www.w3.org/2000/svg");
  uint64_t v6 = SVG::Element::findInAttributeMap(a3, (uint64_t)v10, (uint64_t)__p);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v11) < 0)
  {
    operator delete(v10[0]);
    if (!v6) {
      return a1;
    }
  }
  else if (!v6)
  {
    return a1;
  }
  v10[0] = (void *)-1;
  v10[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  SVG::consumeLengthAlone((uint64_t)(v6 + 64), (uint64_t)v10);
  if ((_BYTE)v11) {
    *(_OWORD *)(a1 + 64CGContextBeginTransparencyLayer(c, 0) = *(_OWORD *)v10;
  }
  return a1;
}

uint64_t SVG::StopElement::appendChild()
{
  return 0;
}

void SVG::StopElement::~StopElement(SVG::StopElement *this)
{
  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E80 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E98 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75EB0 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E98 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75EB0 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;

  uint64_t v2 = *((unsigned int *)this + 128);
  if (v2 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E80 + v2))(&v7, (char *)this + 480);
  }
  *((_DWORD *)this + 128) = -1;
  uint64_t v3 = *((unsigned int *)this + 116);
  if (v3 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E98 + v3))(&v8, (char *)this + 416);
  }
  *((_DWORD *)this + 116) = -1;
  uint64_t v4 = *((unsigned int *)this + 82);
  if (v4 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75EB0 + v4))(&v9, (char *)this + 312);
  }
  *((_DWORD *)this + 82) = -1;
  uint64_t v5 = *((unsigned int *)this + 66);
  if (v5 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75E98 + v5))(&v10, (char *)this + 216);
  }
  *((_DWORD *)this + 66) = -1;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6 != -1) {
    ((void (*)(char *, char *))*(&off_1F1A75EB0 + v6))(&v11, (char *)this + 128);
  }
  *((_DWORD *)this + 36) = -1;
  SVG::Element::~Element((void **)this);
  MEMORY[0x1C18A3E80]();
}

uint64_t SVG::decodeBase64@<X0>(SVG *this@<X0>, void *a2@<X8>)
{
  uint64_t result = [objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedString:this options:1];
  *a2 = result;
  return result;
}

size_t SVG::consumeColorKeyword@<X0>(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  size_t v5 = *((unsigned __int8 *)a1 + 23);
  char v7 = (uint64_t *)*a1;
  unint64_t v6 = a1[1];
  float v35 = (uint64_t *)*a1;
  size_t v36 = v6;
  if ((v5 & 0x80u) == 0)
  {
    unint64_t v6 = *((unsigned __int8 *)a1 + 23);
    char v7 = a1;
  }
  BOOL v8 = v6 >= a2;
  unint64_t v9 = v6 - a2;
  if (v8) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  char v11 = (char *)v7 + a2;
  char v12 = (__objc2_class **)&SVG::colorKeywords;
  unint64_t v13 = 147;
  do
  {
    unint64_t v14 = v13 >> 1;
    unint64_t v15 = (const char **)&v12[2 * (v13 >> 1)];
    unint64_t v16 = *v15;
    size_t result = strlen(*v15);
    if (result)
    {
      size_t v18 = result - 1;
      unint64_t v19 = v10;
      unint64_t v20 = v11;
      while (v19)
      {
        int v21 = *v16;
        int v22 = *v20;
        if (v21 < v22)
        {
          char v12 = (__objc2_class **)(v15 + 2);
          unint64_t v14 = v13 + ~v14;
          break;
        }
        ++v20;
        ++v16;
        BOOL v23 = v21 > v22 || v18-- == 0;
        --v19;
        if (v23) {
          break;
        }
      }
    }
    unint64_t v13 = v14;
  }
  while (v14);
  if (v12 == &off_1E63F3B18) {
    goto LABEL_25;
  }
  size_t result = strlen((const char *)*v12);
  size_t v24 = result + a2;
  if ((v5 & 0x80) != 0)
  {
    uint8x8_t v25 = v35;
    if (v36 < v24)
    {
LABEL_25:
      char v26 = 0;
      uint64_t v27 = a3;
      *(unsigned char *)a3 = 0;
      goto LABEL_26;
    }
  }
  else
  {
    uint8x8_t v25 = a1;
    if (v24 > v5) {
      goto LABEL_25;
    }
  }
  size_t result = memcmp((char *)v25 + a2, *v12, result);
  if (result) {
    goto LABEL_25;
  }
  CGFloat v28 = v12 + 2;
  do
  {
    CGFloat v29 = v28;
    if (v28 == &off_1E63F3B18) {
      break;
    }
    unint64_t v30 = *v28;
    size_t v31 = strlen((const char *)*v28);
    size_t v32 = v31 + a2;
    if ((v5 & 0x80) != 0)
    {
      unint64_t v33 = v35;
      if (v36 < v32) {
        break;
      }
    }
    else
    {
      unint64_t v33 = a1;
      if (v32 > v5) {
        break;
      }
    }
    int v34 = memcmp((char *)v33 + a2, v30, v31);
    CGFloat v28 = v29 + 2;
  }
  while (!v34);
  size_t result = strlen((const char *)*(v29 - 2));
  *(void *)a3 = *((unsigned __int16 *)v29 - 4) | ((unint64_t)*((unsigned __int8 *)v29 - 6) << 16);
  *(void *)(a3 + 8) = result + a2;
  uint64_t v27 = a3;
  char v26 = 1;
LABEL_26:
  *(unsigned char *)(v27 + 16) = v26;
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1F40D77A8](cf);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1F40D7818](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.length = v4;
  result.CFIndex location = v3;
  return result;
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1F40D8500](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

Boolean CFURLCanBeDecomposed(CFURLRef anURL)
{
  return MEMORY[0x1F40D8728](anURL);
}

CFStringRef CFURLCopyFragment(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1F40D8760](anURL, charactersToLeaveEscaped);
}

CFStringRef CFURLCopyNetLocation(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8778](anURL);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8790](anURL);
}

CFStringRef CFURLCopyResourceSpecifier(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87B8](anURL);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87C0](anURL);
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D8888](allocator, URLBytes, length, *(void *)&encoding, baseURL);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88C0](allocator, URLString, baseURL);
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return (CGAffineTransform *)MEMORY[0x1F40D9790](retstr, t1, t2);
}

BOOL CGAffineTransformEqualToTransform(CGAffineTransform *t1, CGAffineTransform *t2)
{
  return MEMORY[0x1F40D97A0](t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97A8](retstr, t);
}

BOOL CGAffineTransformIsIdentity(CGAffineTransform *t)
{
  return MEMORY[0x1F40D97B0](t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97C8](retstr, angle);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97D0](retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97D8](retstr, tx, ty);
}

CGAffineTransform *__cdecl CGAffineTransformRotate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97E8](retstr, t, angle);
}

CGAffineTransform *__cdecl CGAffineTransformScale(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97F0](retstr, t, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1F40D97F8](retstr, t, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x1F40D9808](data, width, height, bitsPerComponent, bytesPerRow, space, *(void *)&bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return (CGImageRef)MEMORY[0x1F40D9818](context);
}

CGBitmapInfo CGBitmapContextGetBitmapInfo(CGContextRef context)
{
  return MEMORY[0x1F40D9840](context);
}

size_t CGBitmapContextGetBitsPerComponent(CGContextRef context)
{
  return MEMORY[0x1F40D9848](context);
}

size_t CGBitmapContextGetBitsPerPixel(CGContextRef context)
{
  return MEMORY[0x1F40D9850](context);
}

size_t CGBitmapContextGetBytesPerRow(CGContextRef context)
{
  return MEMORY[0x1F40D9858](context);
}

CGColorSpaceRef CGBitmapContextGetColorSpace(CGContextRef context)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D9860](context);
}

void *__cdecl CGBitmapContextGetData(CGContextRef context)
{
  return (void *)MEMORY[0x1F40D9868](context);
}

size_t CGBitmapContextGetHeight(CGContextRef context)
{
  return MEMORY[0x1F40D9870](context);
}

size_t CGBitmapContextGetWidth(CGContextRef context)
{
  return MEMORY[0x1F40D9878](context);
}

CGColorRef CGColorCreateSRGB(CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  return (CGColorRef)MEMORY[0x1F40D99B0](red, green, blue, alpha);
}

CGColorSpaceRef CGColorSpaceCreatePattern(CGColorSpaceRef baseSpace)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D9B38](baseSpace);
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x1F40D9B60](name);
}

void CGContextAddPath(CGContextRef c, CGPathRef path)
{
}

void CGContextAddRect(CGContextRef c, CGRect rect)
{
}

void CGContextBeginTransparencyLayer(CGContextRef c, CFDictionaryRef auxiliaryInfo)
{
}

void CGContextClip(CGContextRef c)
{
}

void CGContextClipToMask(CGContextRef c, CGRect rect, CGImageRef mask)
{
}

void CGContextClipToRect(CGContextRef c, CGRect rect)
{
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
}

void CGContextDrawLinearGradient(CGContextRef c, CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options)
{
}

void CGContextDrawRadialGradient(CGContextRef c, CGGradientRef gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options)
{
}

void CGContextEOClip(CGContextRef c)
{
}

void CGContextEOFillPath(CGContextRef c)
{
}

void CGContextEndTransparencyLayer(CGContextRef c)
{
}

void CGContextFillPath(CGContextRef c)
{
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
}

void CGContextFlush(CGContextRef c)
{
}

uint64_t CGContextGetBaseCTM()
{
  return MEMORY[0x1F40D9F58]();
}

CGAffineTransform *__cdecl CGContextGetCTM(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return (CGAffineTransform *)MEMORY[0x1F40D9F68](retstr, c);
}

uint64_t CGContextGetFillColorAsColor()
{
  return MEMORY[0x1F40D9F98]();
}

void CGContextRestoreGState(CGContextRef c)
{
}

void CGContextSaveGState(CGContextRef c)
{
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
}

void CGContextSetAlpha(CGContextRef c, CGFloat alpha)
{
}

void CGContextSetFillColorSpace(CGContextRef c, CGColorSpaceRef space)
{
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
}

void CGContextSetFillPattern(CGContextRef c, CGPatternRef pattern, const CGFloat *components)
{
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
}

CGDataProviderRef CGDataProviderCreateWithCFData(CFDataRef data)
{
  return (CGDataProviderRef)MEMORY[0x1F40DA300](data);
}

CGGradientRef CGGradientCreateWithColors(CGColorSpaceRef space, CFArrayRef colors, const CGFloat *locations)
{
  return (CGGradientRef)MEMORY[0x1F40DA778](space, colors, locations);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x1F40DA948](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x1F40DA9B8](image);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x1F40E9968](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithDataProvider(CGDataProviderRef provider, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x1F40E99A8](provider, options);
}

void CGPathAddArc(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, BOOL clockwise)
{
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
}

void CGPathAddEllipseInRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
}

void CGPathAddLines(CGMutablePathRef path, const CGAffineTransform *m, const CGPoint *points, size_t count)
{
}

void CGPathAddQuadCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
}

void CGPathApply(CGPathRef path, void *info, CGPathApplierFunction function)
{
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
}

CGPathRef CGPathCreateCopyByDashingPath(CGPathRef path, const CGAffineTransform *transform, CGFloat phase, const CGFloat *lengths, size_t count)
{
  return (CGPathRef)MEMORY[0x1F40DB018](path, transform, lengths, count, phase);
}

CGPathRef CGPathCreateCopyByStrokingPath(CGPathRef path, const CGAffineTransform *transform, CGFloat lineWidth, CGLineCap lineCap, CGLineJoin lineJoin, CGFloat miterLimit)
{
  return (CGPathRef)MEMORY[0x1F40DB038](path, transform, *(void *)&lineCap, *(void *)&lineJoin, lineWidth, miterLimit);
}

CGPathRef CGPathCreateCopyByTransformingPath(CGPathRef path, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x1F40DB048](path, transform);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x1F40DB068]();
}

CGPathRef CGPathCreateWithRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x1F40DB0A8](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGRect CGPathGetBoundingBox(CGPathRef path)
{
  MEMORY[0x1F40DB0D0](path);
  result.size.CGFloat height = v4;
  result.size.CGFloat width = v3;
  result.origin.CGFloat y = v2;
  result.origin.double x = v1;
  return result;
}

CGRect CGPathGetPathBoundingBox(CGPathRef path)
{
  MEMORY[0x1F40DB0F0](path);
  result.size.CGFloat height = v4;
  result.size.CGFloat width = v3;
  result.origin.CGFloat y = v2;
  result.origin.double x = v1;
  return result;
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
}

CGPatternRef CGPatternCreate(void *info, CGRect bounds, CGAffineTransform *matrix, CGFloat xStep, CGFloat yStep, CGPatternTiling tiling, BOOL isColored, const CGPatternCallbacks *callbacks)
{
  return (CGPatternRef)MEMORY[0x1F40DB180](info, matrix, *(void *)&tiling, isColored, callbacks, (__n128)bounds.origin, *(__n128 *)&bounds.origin.y, (__n128)bounds.size, *(__n128 *)&bounds.size.height, xStep, yStep);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  MEMORY[0x1F40DB220](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v5;
  result.size.CGFloat width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1F40DB248]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  MEMORY[0x1F40DB250]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  MEMORY[0x1F40DB268]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  MEMORY[0x1F40DB270]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  MEMORY[0x1F40DB2A8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  MEMORY[0x1F40DB2C8]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.CGFloat height = v5;
  result.size.CGFloat width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  MEMORY[0x1F40DB310]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.CGFloat height = v5;
  result.size.CGFloat width = v4;
  result.origin.CGFloat y = v3;
  result.origin.double x = v2;
  return result;
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1F417E660](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

uint64_t std::ostream::put()
{
  return MEMORY[0x1F417E830]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x1F417E838]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1F417E860]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E880]();
}

{
  return MEMORY[0x1F417E8A0]();
}

{
  return MEMORY[0x1F417E8C0]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x1F417EFA8](lpsrc, lpstype, lpdtype, s2d);
}

double __exp10(double a1)
{
  MEMORY[0x1F40C9B90](a1);
  return result;
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x1F40C9C80](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9CF8](*(void *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9D00](*(void *)&a1);
}

void abort(void)
{
}

long double acos(long double __x)
{
  MEMORY[0x1F40CA330](__x);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

compression_status compression_stream_destroy(compression_stream *stream)
{
  return MEMORY[0x1F417F0C0](stream);
}

compression_status compression_stream_init(compression_stream *stream, compression_stream_operation operation, compression_algorithm algorithm)
{
  return MEMORY[0x1F417F0D0](stream, *(void *)&operation, *(void *)&algorithm);
}

compression_status compression_stream_process(compression_stream *stream, int flags)
{
  return MEMORY[0x1F417F0E0](stream, *(void *)&flags);
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x1F40CC1A0](__x, __y);
  return result;
}

void free(void *a1)
{
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_copyCppObjectAtomic(void *dest, const void *src, void (__cdecl *copyHelper)(void *, const void *))
{
}

void objc_enumerationMutation(id obj)
{
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

void objc_release(id a1)
{
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1F40CDC88](__ptr, __size);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

long double tan(long double __x)
{
  MEMORY[0x1F40CE420](__x);
  return result;
}

vImage_Error vImageAlphaBlend_ARGB8888(const vImage_Buffer *srcTop, const vImage_Buffer *srcBottom, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D2238](srcTop, srcBottom, dest, *(void *)&flags);
}

vImage_Error vImageBufferFill_ARGB8888(const vImage_Buffer *dest, const Pixel_8888 color, vImage_Flags flags)
{
  return MEMORY[0x1F40D2278](dest, color, *(void *)&flags);
}

vImage_Error vImageMatrixMultiply_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const int16_t matrix[16], int32_t divisor, const int16_t *pre_bias, const int32_t *post_bias, vImage_Flags flags)
{
  return MEMORY[0x1F40D2A58](src, dest, matrix, *(void *)&divisor, pre_bias, post_bias, *(void *)&flags);
}