void re::StackScratchAllocator::FreePersistentBlocks(re::StackScratchAllocator *this)
{
  re *v1;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  unint64_t v7;
  uint64_t vars8;

  std::mutex::lock(&re::StackScratchAllocator::s_mutex);
  if (atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount))
  {
    for (i = 0; i < v7; ++i)
    {
      v4 = re::StackScratchAllocator::s_rootsWithPersistentBlocks[i];
      v5 = *(void *)(v4 + 8);
      if (v5)
      {
        v6 = re::globalAllocators(v1);
        v1 = (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6[2] + 40))(v6[2], v5);
        v4 = re::StackScratchAllocator::s_rootsWithPersistentBlocks[i];
      }
      *(void *)(v4 + 8) = 0;
      v7 = atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
    }
  }
  atomic_store(0, &re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
  std::mutex::unlock(&re::StackScratchAllocator::s_mutex);
}

uint64_t re::Allocator::addDestructor(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t re::Allocator::destructorCalledByDefault(re::Allocator *this)
{
  return 1;
}

double re::HashTable<unsigned long,unsigned long,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 24 * v3;
      do
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0) {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
        }
        v4 += 24;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t *re::globalAllocators(re *this)
{
  {
    if (v2)
    {
      re::globalAllocators(void)::s_instance = (uint64_t)&unk_26DD34218;
      byte_2682A4650 = 0;
      *(_OWORD *)algn_2682A4660 = 0u;
      *(_OWORD *)&algn_2682A4660[16] = 0u;
      re::GlobalAllocators::init((_anonymous_namespace_ *)&re::globalAllocators(void)::s_instance);
    }
  }
  return &re::globalAllocators(void)::s_instance;
}

void anonymous namespace'::internalSystemAllocator(_anonymous_namespace_ *this)
{
  {
    byte_2682A46D0 = 0;
    *(void *)algn_2682A46C8 = "System allocator";
  }
}

_anonymous_namespace_ *re::initGlobalAllocators(re *this)
{
  double result = (_anonymous_namespace_ *)re::globalAllocators(this);
  if (!byte_2682A4650)
  {
    re::globalAllocators(result);
    return re::GlobalAllocators::init((_anonymous_namespace_ *)&re::globalAllocators(void)::s_instance);
  }
  return result;
}

_anonymous_namespace_ *re::GlobalAllocators::init(_anonymous_namespace_ *this)
{
  if (!*((unsigned char *)this + 8))
  {
    v1 = this;
    re::globalMemoryTracker(this);
    if (!re::globalMemoryTracker(void)::s_instance)
    {
      qword_2682A4690[0] = *((void *)v1 + 2);
      re::DynamicArray<re::Allocator const*>::setCapacity(qword_2682A4690, 0x400uLL);
      ++dword_2682A46A8;
      re::globalMemoryTracker(void)::s_instance = 1;
    }
    re::MemoryTracker::track((os_unfair_lock_s *)&re::globalMemoryTracker(void)::s_instance, *((const re::Allocator **)v1 + 2));
    uint64_t v2 = (re::AlignedAllocator *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1 + 2) + 32))(*((void *)v1 + 2), 104, 8);
    *((void *)v1 + 3) = re::AlignedAllocator::AlignedAllocator(v2, "SIMD-aligned allocator", 16, v3);
    uint64_t v4 = (re::AlignedAllocator *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1 + 2) + 32))(*((void *)v1 + 2), 104, 8);
    *((void *)v1 + 4) = re::AlignedAllocator::AlignedAllocator(v4, "Cache-aligned allocator", 64, v5);
    uint64_t v6 = (re::AlignedAllocator *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1 + 2) + 32))(*((void *)v1 + 2), 104, 8);
    *((void *)v1 + 5) = re::AlignedAllocator::AlignedAllocator(v6, "TLB-aligned allocator", 0x4000, v7);
    uint64_t v8 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1 + 2) + 32))(*((void *)v1 + 2), 5304, 8);
    *(unsigned char *)uint64_t v8 = 0;
    *(void *)(v8 + 88) = 0;
    *(void *)(v8 + 96) = 0;
    *(_DWORD *)(v8 + 104) = 0;
    *(_OWORD *)(v8 + 8) = 0u;
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 68) = 0u;
    *(void *)(v8 + 108) = 0x1FFFFFFFFLL;
    *(_DWORD *)(v8 + 120) = 0;
    *(void *)(v8 + 136) = 0;
    *(void *)(v8 + 144) = 0;
    *(void *)(v8 + 128) = 0;
    *(_DWORD *)(v8 + 152) = 0;
    bzero((void *)(v8 + 160), 0x1418uLL);
    *((void *)v1 + 6) = v8;
    this = re::PerFrameAllocatorManager::init((_anonymous_namespace_ *)v8);
    *((unsigned char *)v1 + 8) = 1;
  }
  return this;
}

void re::deinitGlobalAllocators(re *this)
{
  v1 = re::globalAllocators(this);
  if (byte_2682A4650)
  {
    re::globalAllocators((re *)v1);
    re::GlobalAllocators::deinit((re **)&re::globalAllocators(void)::s_instance);
  }
}

void re::GlobalAllocators::deinit(re **this)
{
  if (*((unsigned char *)this + 8))
  {
    re::StackScratchAllocator::FreePersistentBlocks((re::StackScratchAllocator *)this);
    re::globalMemoryTracker(v2);
    re::PerFrameAllocatorManager::deinit(this[6]);
    uint64_t v3 = this[2];
    uint64_t v4 = this[6];
    if (v4)
    {
      uint64_t v5 = 5120;
      do
      {
        *(void *)((char *)v4 + v5 + 128) = 0;
        v5 -= 40;
      }
      while (v5);
      uint64_t v6 = *((void *)v4 + 16);
      if (v6)
      {
        uint64_t v7 = *((void *)v4 + 20);
        if (v7)
        {
          uint64_t v8 = *((void *)v4 + 18);
          if (v8)
          {
            uint64_t v9 = 88 * v8;
            uint64_t v10 = v7 + 48;
            do
            {
              re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v10);
              re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v10 - 40);
              v10 += 88;
              v9 -= 88;
            }
            while (v9);
            uint64_t v6 = *((void *)v4 + 16);
            uint64_t v7 = *((void *)v4 + 20);
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 40))(v6, v7);
        }
        *((void *)v4 + 20) = 0;
        *((void *)v4 + 17) = 0;
        *((void *)v4 + 18) = 0;
        *((void *)v4 + 16) = 0;
        ++*((_DWORD *)v4 + 38);
      }
      re::DataArray<re::PerFrameAllocatorImpl>::deinit((uint64_t)v4 + 56);
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v4 + 56);
      uint64_t v11 = *((void *)v4 + 4);
      if (v11)
      {
        if (*((void *)v4 + 5))
        {
          (*(void (**)(uint64_t, void))(*(void *)v11 + 40))(v11, *((void *)v4 + 6));
          *((void *)v4 + 5) = 0;
          *((void *)v4 + 6) = 0;
        }
        *((void *)v4 + 4) = 0;
      }
      uint64_t v12 = *((void *)v4 + 1);
      if (v12)
      {
        if (*((void *)v4 + 2))
        {
          (*(void (**)(uint64_t, void))(*(void *)v12 + 40))(v12, *((void *)v4 + 3));
          *((void *)v4 + 2) = 0;
          *((void *)v4 + 3) = 0;
        }
        *((void *)v4 + 1) = 0;
      }
      (*(void (**)(const re::Allocator *, re *))(*(void *)v3 + 40))(v3, v4);
      uint64_t v3 = this[2];
    }
    this[6] = 0;
    v13 = this[5];
    if (v13)
    {
      (**(void (***)(re *))v13)(this[5]);
      (*(void (**)(const re::Allocator *, re *))(*(void *)v3 + 40))(v3, v13);
      uint64_t v3 = this[2];
    }
    this[5] = 0;
    v14 = this[4];
    if (v14)
    {
      (**(void (***)(re *))v14)(this[4]);
      (*(void (**)(const re::Allocator *, re *))(*(void *)v3 + 40))(v3, v14);
      uint64_t v3 = this[2];
    }
    this[4] = 0;
    v15 = this[3];
    if (v15)
    {
      (**(void (***)(re *))v15)(this[3]);
      (*(void (**)(const re::Allocator *, re *))(*(void *)v3 + 40))(v3, v15);
      uint64_t v3 = this[2];
    }
    this[3] = 0;
    re::MemoryTracker::untrack((os_unfair_lock_s *)&re::globalMemoryTracker(void)::s_instance, v3);
    if (re::globalMemoryTracker(void)::s_instance)
    {
      v16 = (_anonymous_namespace_ *)re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)qword_2682A4690);
      re::globalMemoryTracker(void)::s_instance = 0;
    }
    *((unsigned char *)this + 8) = 0;
  }
}

void re::GlobalAllocators::~GlobalAllocators(re **this)
{
  *this = (re *)&unk_26DD34218;
  re::GlobalAllocators::deinit(this);
}

{
  uint64_t vars8;

  *this = (re *)&unk_26DD34218;
  re::GlobalAllocators::deinit(this);
  JUMPOUT(0x22A6A9430);
}

char *re::globalMemoryTracker(re *this)
{
  {
    if (v2)
    {
      re::globalMemoryTracker(void)::s_instance = 0;
      qword_2682A46B0 = 0;
      *(_OWORD *)&algn_2682A4689[3] = 0u;
      unk_2682A469C = 0u;
      re::DynamicArray<re::Allocator const*>::setCapacity(qword_2682A4690, 0x400uLL);
      ++dword_2682A46A8;
      re::globalMemoryTracker(void)::s_instance = 1;
    }
  }
  return &re::globalMemoryTracker(void)::s_instance;
}

uint64_t re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    if (*(void *)(a1 + 32)) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::deinit(uint64_t result)
{
  if (*(_DWORD *)(result + 44))
  {
    v1 = (void *)result;
    double v2 = re::DataArray<re::PerFrameAllocatorImpl>::clear((void *)result);
    if (!v1[2])
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v3 = (void *)v1[4];
    (*(void (**)(void, void, double))(*(void *)*v1 + 40))(*v1, *v3, v2);
    (*(void (**)(void, void))(*(void *)*v1 + 40))(*v1, v3[1]);
    uint64_t result = re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v1);
    *((_DWORD *)v1 + 11) = 0;
  }
  return result;
}

double re::DataArray<re::PerFrameAllocatorImpl>::clear(void *a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator((uint64_t)v12, (uint64_t)a1, 0);
  if (*(void **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFFLL || (DWORD2(v12[0]) & 0xFFFF0000) != 4294901760)
  {
    do
    {
      unint64_t v4 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)v12);
      re::DataArray<re::PerFrameAllocatorImpl>::destroy((uint64_t)a1, v4);
      re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(v12);
    }
    while (*(void **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFF || WORD5(v12[0]) != 0xFFFF);
  }
  uint64_t v7 = a1[2];
  unint64_t v8 = v7 - 1;
  if (v7 != 1)
  {
    uint64_t v9 = 16 * v7;
    do
    {
      if (a1[2] <= v8)
      {
        memset(v12, 0, sizeof(v12));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v10 = a1[4] + v9;
      (*(void (**)(void, void))(*(void *)*a1 + 40))(*a1, *(void *)(v10 - 16));
      (*(void (**)(void, void))(*(void *)*a1 + 40))(*a1, *(void *)(v10 - 8));
      re::DynamicArray<re::DataArray<re::PerFrameAllocatorImpl>::ElementBlock>::removeAt((uint64_t)a1, v8);
      v9 -= 16;
      --v8;
    }
    while (v8);
  }
  double result = NAN;
  a1[6] = 0xFFFFFFFF00000000;
  return result;
}

uint64_t (***re::DataArray<re::PerFrameAllocatorImpl>::destroy(uint64_t a1, unint64_t a2))(void)
{
  int v2 = a2;
  unint64_t v4 = a2 >> 16;
  double result = (uint64_t (***)(void))re::DataArray<re::PerFrameAllocatorImpl>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (result)
  {
    uint64_t v6 = result;
    double result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *uint64_t v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
  return result;
}

unint64_t re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle(unsigned __int16 *a1)
{
  unint64_t v1 = a1[5];
  if (*(void *)(*(void *)a1 + 16) <= v1)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return (v1 << 16) | ((unint64_t)(*(_DWORD *)(*(void *)(*(void *)(*(void *)a1 + 32) + 16 * v1 + 8)
                                                    + 4 * a1[4]) & 0xFFFFFF) << 32) | a1[4];
}

uint64_t re::DynamicArray<re::DataArray<re::PerFrameAllocatorImpl>::ElementBlock>::removeAt(uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(void *)(result + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v3 = v2 - 1;
  if (v2 - 1 > a2)
  {
    *(_OWORD *)(*(void *)(result + 32) + 16 * a2) = *(_OWORD *)(*(void *)(result + 32) + 16 * v2 - 16);
    uint64_t v3 = *(void *)(result + 16) - 1;
  }
  *(void *)(result + 16) = v3;
  ++*(_DWORD *)(result + 24);
  return result;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::DataArrayIterator(uint64_t a1, uint64_t a2, char a3)
{
  *(void *)a1 = a2;
  if ((a3 & 1) != 0 || !*(_DWORD *)(a2 + 40))
  {
    *(_DWORD *)(a1 + 8) = -1;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    if (!*(void *)(a2 + 16))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (!**(_DWORD **)(*(void *)(a2 + 32) + 8)) {
      re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment((_WORD *)a1);
    }
  }
  return a1;
}

_WORD *re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(_WORD *result)
{
  uint64_t v1 = *(void *)result;
  unint64_t v2 = *(void *)(*(void *)result + 16);
  unsigned __int16 v3 = v2 - 1;
  unsigned __int16 v4 = result[4];
  unsigned __int16 v5 = result[5];
  while (1)
  {
    ++v4;
    if (v5 < v3 && *(_DWORD *)(v1 + 44) <= v4)
    {
      unsigned __int16 v4 = 0;
      result[5] = ++v5;
    }
    if (v5 == v3 && *(_DWORD *)(v1 + 48) <= v4) {
      break;
    }
    if (v2 <= v5)
    {
      result[4] = v4;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (*(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 16 * v5 + 8) + 4 * v4))
    {
      result[4] = v4;
      return result;
    }
  }
  *((_DWORD *)result + 2) = -1;
  return result;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (unsigned int v3 = *(_DWORD *)(a1 + 44)) : (unsigned int v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((uint64_t v4 = *(void *)(a1 + 32),
          (int v5 = *(_DWORD *)(*(void *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (BOOL v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (BOOL v6 = 0),
         v6)))
  {
    return *(void *)(v4 + 16 * WORD1(a2)) + 184 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

re::MallocZoneAllocator *re::MallocZoneAllocator::MallocZoneAllocator(re::MallocZoneAllocator *this, const char *a2, int a3)
{
  *(void *)re::Allocator::Allocator(this, a2, a3) = &unk_26DD34248;
  zone = malloc_create_zone(0, 0);
  *((void *)this + 3) = zone;
  malloc_set_zone_name(zone, a2);
  return this;
}

void re::MallocZoneAllocator::~MallocZoneAllocator(malloc_zone_t **this)
{
  *this = (malloc_zone_t *)&unk_26DD34248;
  malloc_destroy_zone(this[3]);
  this[3] = 0;
  re::Allocator::~Allocator((re::Allocator *)this);
}

{
  uint64_t vars8;

  *this = (malloc_zone_t *)&unk_26DD34248;
  malloc_destroy_zone(this[3]);
  this[3] = 0;
  re::Allocator::~Allocator((re::Allocator *)this);
  JUMPOUT(0x22A6A9430);
}

void *re::MallocZoneAllocator::alloc(malloc_zone_t **this, size_t size, unint64_t a3)
{
  uint64_t v3 = 16;
  if (a3 > 0x10) {
    uint64_t v3 = a3;
  }
  return malloc_type_zone_memalign(this[3], (v3 + 7) & 0xFFFFFFFFFFFFFFF8, size, 0x2419C6E8uLL);
}

void re::MallocZoneAllocator::free(malloc_zone_t **this, void *a2)
{
  if (a2) {
    malloc_zone_free(this[3], a2);
  }
}

uint64_t re::MallocZoneAllocator::parent(re::MallocZoneAllocator *this)
{
  return 0;
}

uint64_t re::MallocZoneAllocator::statistics(re::MallocZoneAllocator *this)
{
  return 0;
}

void re::MemoryTracker::track(os_unfair_lock_s *this, const re::Allocator *a2)
{
  uint64_t v4 = a2;
  uint64_t v3 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::DynamicArray<re::Allocator const*>::add(&this[2]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

void *re::DynamicArray<re::Allocator const*>::add(void *this, void *a2)
{
  uint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::Allocator const*>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  *(void *)(v3[4] + 8 * v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::MemoryTracker::untrack(os_unfair_lock_s *this, const re::Allocator *a2)
{
  unint64_t v4 = a2;
  uint64_t v3 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::DynamicArray<re::Allocator const*>::removeStable(&this[2]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

BOOL re::DynamicArray<re::Allocator const*>::removeStable(void *a1, void *a2)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = a1[2];
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    int v5 = (void *)a1[4];
    while (*v5 != *a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        int v5 = (void *)(v2 + 8 * v3);
        break;
      }
    }
  }
  else
  {
    int v5 = (void *)a1[4];
  }
  uint64_t v6 = (uint64_t)v5 - v2;
  uint64_t v7 = v6 >> 3;
  if (v6 >> 3 != v3) {
    re::DynamicArray<re::Allocator const*>::removeStableAt(a1, v6 >> 3);
  }
  return v7 != v3;
}

void *re::DynamicArray<re::Allocator const*>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    int v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 8 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        double result = (void *)re::DynamicArray<re::Allocator const*>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void *re::DynamicArray<re::Allocator const*>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::Allocator const*>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Allocator const*>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::Allocator const*>::removeStableAt(void *result, unint64_t a2)
{
  unint64_t v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v3 = result;
  uint64_t v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    uint64_t v5 = result[4];
    double result = (void *)(v5 + 8 * a2);
    BOOL v6 = (char *)(v5 + 8 * v2);
    if (v6 != (char *)(result + 1))
    {
      double result = memmove(result, result + 1, v6 - (char *)(result + 1));
      uint64_t v4 = v3[2] - 1;
    }
  }
  v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

id *re::ObjCObject::operator=(id *location, id *a2)
{
  if (location != a2) {
    objc_storeStrong(location, *a2);
  }
  return location;
}

void **re::ObjCObject::operator=(void **a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *a1;
  if (*a1 != v3)
  {
    *a1 = v3;

    id v3 = 0;
  }

  return a1;
}

re::PoolAllocator *re::PoolAllocator::PoolAllocator(re::PoolAllocator *this, const char *a2, unint64_t a3, uint64_t a4, re::Allocator *a5, unint64_t a6)
{
  uint64_t v11 = re::Allocator::Allocator(this, a2, 1);
  *(void *)uint64_t v11 = &unk_26DD342B8;
  *((void *)v11 + 3) = a5;
  *((_DWORD *)v11 + 8) = 0;
  *((_DWORD *)v11 + 10) = 0;
  *((_OWORD *)v11 + 3) = 0u;
  *((_OWORD *)v11 + 4) = 0u;
  *((_DWORD *)v11 + 20) = 0;
  *(void *)((char *)v11 + 84) = 0x7FFFFFFFLL;
  *((void *)v11 + 16) = 0;
  *((void *)v11 + 13) = 0;
  *((void *)v11 + 14) = 0;
  *((_DWORD *)v11 + 30) = 0;
  *((void *)v11 + 12) = a5;
  re::DynamicArray<re::Allocator const*>::setCapacity((void *)v11 + 12, 0);
  ++*((_DWORD *)this + 30);
  *((void *)this + 17) = a5;
  *((void *)this + 21) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((_DWORD *)this + 40) = 0;
  re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity((void *)this + 17, 0);
  ++*((_DWORD *)this + 40);
  *((void *)this + 26) = 0;
  *((void *)this + 28) = 0;
  *((_WORD *)this + 116) = 1;
  int8x8_t v13 = (int8x8_t)16;
  if (a6 > 0x10) {
    int8x8_t v13 = (int8x8_t)a6;
  }
  *((int8x8_t *)this + 22) = v13;
  uint64_t v14 = 32;
  if (a4) {
    uint64_t v14 = a4;
  }
  *((void *)this + 24) = a3;
  unint64_t v15 = 8;
  if (a3 > 8) {
    unint64_t v15 = a3;
  }
  if (v15 >= 0x18)
  {
    *((void *)this + 26) = 8;
    unint64_t v15 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    *((void *)this + 28) = v15 - 8;
    *((unsigned char *)this + 233) = 1;
  }
  unint64_t v16 = v15 + 7;
  *((void *)this + 27) = v16 & 0xFFFFFFFFFFFFFFF8;
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v13);
  v17.i16[0] = vaddlv_u8(v17);
  unint64_t v18 = (v16 | 7) + *(void *)&v13;
  unint64_t v19 = v18 / *(void *)&v13 * *(void *)&v13;
  unint64_t v20 = v18 & -*(void *)&v13;
  if (v17.u32[0] != 1) {
    unint64_t v20 = v19;
  }
  *((void *)this + 23) = v20;
  unint64_t v21 = v20 * v14;
  *((void *)this + 25) = v21;
  if (HIDWORD(v21))
  {
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) ", "m_blockSize <= std::numeric_limits<uint32_t>::max()", "PoolAllocator", 52);
    double result = (re::PoolAllocator *)_os_crash();
    __break(1u);
  }
  else
  {
    *((void *)this + 25) = v21 + *(void *)&v13;
    return this;
  }
  return result;
}

void re::PoolAllocator::~PoolAllocator(re::PoolAllocator *this)
{
  if (*((void *)this + 3))
  {
    uint64_t v2 = *((void *)this + 14);
    if (v2)
    {
      id v3 = (uint64_t *)*((void *)this + 16);
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *v3++;
        (*(void (**)(void, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), v5);
        v4 -= 8;
      }
      while (v4);
    }
    *((void *)this + 14) = 0;
    ++*((_DWORD *)this + 30);
    *((void *)this + 3) = 0;
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 136);
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 96);
  re::HashTable<unsigned long,unsigned long,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::deinit((uint64_t *)this + 6);
  re::Allocator::~Allocator(this);
}

{
  uint64_t vars8;

  re::PoolAllocator::~PoolAllocator(this);
  JUMPOUT(0x22A6A9430);
}

unint64_t re::PoolAllocator::alloc(re::PoolAllocator *this, unint64_t a2, unint64_t a3)
{
  if (!*((void *)this + 3) || *((void *)this + 22) < a3 || *((void *)this + 24) < a2) {
    return 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 8);
  if (!*((void *)this + 19))
  {
    uint64_t v11 = *((void *)this + 3);
    if (!v11) {
      goto LABEL_38;
    }
    uint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)v11 + 32))(v11, *((void *)this + 25), *((void *)this + 22));
    if (v12)
    {
      unint64_t v4 = (unint64_t)v12;
      *(_OWORD *)uint64_t v12 = xmmword_228CDE090;
      unint64_t v13 = *((void *)this + 14);
      if (HIDWORD(v13)) {
        goto LABEL_41;
      }
      *((_DWORD *)v12 + 2) = v13;
      uint64_t v14 = *((void *)this + 23);
      unint64_t v15 = (unint64_t)v12 + *((void *)this + 22);
      unint64_t v16 = (char *)v12 + *((void *)this + 25) - v14;
      if (v15 <= (unint64_t)v16)
      {
        int v19 = *((unsigned __int8 *)this + 233);
        unint64_t v20 = (char *)v12 + *((void *)this + 22);
        uint64_t v17 = *((void *)this + 26);
        uint64_t v21 = *((void *)this + 27);
        do
        {
          *(void *)&v20[v21] = v12;
          if (v19)
          {
            *(void *)unint64_t v20 = 0xFEEFED900143AD35;
            *(void *)&v20[*((void *)this + 28)] = 0xDFFDFE9001F00735;
          }
          *(void *)&v20[v17] = &v20[v14];
          v20 += v14;
        }
        while (v20 <= v16);
      }
      else
      {
        uint64_t v17 = *((void *)this + 26);
      }
      *(void *)&v16[v17] = 0;
      unint64_t v22 = *((void *)this + 13);
      if (v13 >= v22)
      {
        unint64_t v23 = v13 + 1;
        if (v22 < v13 + 1)
        {
          if (*((void *)this + 12))
          {
            unint64_t v24 = 2 * v22;
            if (!v22) {
              unint64_t v24 = 8;
            }
            if (v24 <= v23) {
              unint64_t v25 = v23;
            }
            else {
              unint64_t v25 = v24;
            }
            re::DynamicArray<re::Allocator const*>::setCapacity((void *)this + 12, v25);
          }
          else
          {
            re::DynamicArray<re::Allocator const*>::setCapacity((void *)this + 12, v23);
            ++*((_DWORD *)this + 30);
          }
        }
        unint64_t v13 = *((void *)this + 14);
      }
      *(void *)(*((void *)this + 16) + 8 * v13) = v4;
      *((void *)this + 14) = v13 + 1;
      ++*((_DWORD *)this + 30);
      uint64_t v26 = *((void *)this + 19);
      v27.n128_u64[0] = v4;
      v27.n128_u64[1] = v15;
      re::DynamicArray<re::PoolAllocator::PoolFreeList>::add((uint64_t)this + 136, &v27);
      *(_DWORD *)(v4 + 12) = v26;
    }
    if (!*((void *)this + 19))
    {
LABEL_38:
      unint64_t v4 = 0;
      goto LABEL_39;
    }
  }
  uint64_t v7 = *((void *)this + 21);
  unint64_t v4 = *(void *)(v7 + 8);
  if (*((unsigned char *)this + 233)
    && (*(void *)v4 != 0xFEEFED900143AD35 || *(void *)(v4 + *((void *)this + 28)) != 0xDFFDFE9001F00735))
  {
    goto LABEL_42;
  }
  uint64_t v8 = *(void *)(v4 + *((void *)this + 27));
  unsigned int v9 = *(_DWORD *)(v8 + 4) + *((_DWORD *)this + 46);
  *(_DWORD *)(v8 + 4) = v9;
  uint64_t v10 = *(void *)(v4 + *((void *)this + 26));
  if (v10)
  {
    *(void *)(v7 + 8) = v10;
LABEL_20:
    *(void *)(v4 + *((void *)this + 26)) = 0;
LABEL_39:
    os_unfair_lock_unlock((os_unfair_lock_t)this + 8);
    return v4;
  }
  if (*((void *)this + 22) + v9 == *((void *)this + 25))
  {
    unint64_t v18 = *(unsigned int *)(v8 + 12);
    re::DynamicArray<re::DataArray<re::PerFrameAllocatorImpl>::ElementBlock>::removeAt((uint64_t)this + 136, v18);
    if (*((void *)this + 19) > v18) {
      *(_DWORD *)(*(void *)(*((void *)this + 21) + 16 * v18) + 12) = v18;
    }
    goto LABEL_20;
  }
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "isBlockFull(block)", "alloc", 113);
  _os_crash();
  __break(1u);
LABEL_41:
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "m_blocks.size() <= std::numeric_limits<uint32_t>::max()", "addPoolBlock", 281);
  _os_crash();
  __break(1u);
LABEL_42:
  re::internal::assertLog((re::internal *)5, v6, "assertion failure: '%s' (%s:line %i) Free pool entry %p is corrupted", "!hasEntryMemoryBeenStomped(entry)", "alloc", 104, v4);
  unint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::PoolAllocator::free(os_unfair_lock_s *this, char *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if (!a2) {
    return;
  }
  if (*(void *)&this[6]._os_unfair_lock_opaque)
  {
    os_unfair_lock_lock(this + 8);
    uint64_t v5 = *(_DWORD **)&a2[*(void *)&this[54]._os_unfair_lock_opaque];
    if (!LOBYTE(this[58]._os_unfair_lock_opaque) || *v5 == -1159983635)
    {
      if (!BYTE1(this[58]._os_unfair_lock_opaque)
        || *(void *)a2 == 0xFEEFED900143AD35
        && *(void *)&a2[*(void *)&this[56]._os_unfair_lock_opaque] == 0xDFFDFE9001F00735)
      {
        uint64_t v6 = *(void *)&this[38]._os_unfair_lock_opaque;
        if (v6)
        {
          BOOL v7 = 0;
          uint64_t v8 = *(void *)&this[42]._os_unfair_lock_opaque;
          uint64_t v9 = v8 + 16 * v6;
          do
          {
            if (!v7)
            {
              for (i = *(char **)(v8 + 8); i; i = *(char **)&i[*(void *)&this[52]._os_unfair_lock_opaque])
              {
                BOOL v7 = i == a2;
                if (i == a2) {
                  break;
                }
              }
            }
            v8 += 16;
          }
          while (v8 != v9);
          if (v7) {
            goto LABEL_35;
          }
        }
      }
      uint64_t v11 = v5[1];
      uint64_t v12 = *(void *)&this[44]._os_unfair_lock_opaque;
      uint64_t v13 = *(void *)&this[50]._os_unfair_lock_opaque;
      int v14 = v11 - this[46]._os_unfair_lock_opaque;
      v5[1] = v14;
      if (!v14)
      {
        if (!*(void *)&this[6]._os_unfair_lock_opaque) {
          goto LABEL_35;
        }
        unint64_t v15 = v5[2];
        if (*(void *)&this[28]._os_unfair_lock_opaque > v15)
        {
          uint64_t v16 = *(void *)(*(void *)&this[32]._os_unfair_lock_opaque + 8 * v15);
          unint64_t v17 = *(unsigned int *)(v16 + 12);
          re::DynamicArray<re::DataArray<re::PerFrameAllocatorImpl>::ElementBlock>::removeAt((uint64_t)&this[34], v17);
          if (*(void *)&this[38]._os_unfair_lock_opaque > v17) {
            *(_DWORD *)(*(void *)(*(void *)&this[42]._os_unfair_lock_opaque + 16 * v17) + 12) = v17;
          }
          (*(void (**)(void, uint64_t))(**(void **)&this[6]._os_unfair_lock_opaque + 40))(*(void *)&this[6]._os_unfair_lock_opaque, v16);
          unint64_t v18 = *(void *)&this[28]._os_unfair_lock_opaque;
          if (v18 > v15)
          {
            unint64_t v19 = v18 - 1;
            if (v18 - 1 <= v15)
            {
              *(void *)&this[28]._uint32_t os_unfair_lock_opaque = v19;
              ++this[30]._os_unfair_lock_opaque;
            }
            else
            {
              *(void *)(*(void *)&this[32]._os_unfair_lock_opaque + 8 * v15) = *(void *)(*(void *)&this[32]._os_unfair_lock_opaque
                                                                                             + 8 * v18
                                                                                             - 8);
              *(void *)&this[28]._uint32_t os_unfair_lock_opaque = v19;
              ++this[30]._os_unfair_lock_opaque;
              *(_DWORD *)(*(void *)(*(void *)&this[32]._os_unfair_lock_opaque + 8 * v15) + 8) = v15;
            }
LABEL_35:
            os_unfair_lock_unlock(this + 8);
            return;
          }
LABEL_48:
          long long v29 = 0u;
          long long v30 = 0u;
          long long v27 = 0u;
          long long v28 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_47:
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      }
      if (v12 + v11 == v13)
      {
        uint32_t os_unfair_lock_opaque = this[38]._os_unfair_lock_opaque;
        *(void *)buf = v5;
        *(void *)&buf[8] = 0;
        re::DynamicArray<re::PoolAllocator::PoolFreeList>::add((uint64_t)&this[34], (__n128 *)buf);
        v5[3] = os_unfair_lock_opaque;
      }
      else
      {
        uint32_t os_unfair_lock_opaque = v5[3];
      }
      if (*(void *)&this[38]._os_unfair_lock_opaque > (unint64_t)os_unfair_lock_opaque)
      {
        uint64_t v23 = *(void *)(*(void *)&this[42]._os_unfair_lock_opaque + 16 * os_unfair_lock_opaque + 8);
        if (BYTE1(this[58]._os_unfair_lock_opaque))
        {
          *(void *)a2 = 0xFEEFED900143AD35;
          *(void *)&a2[*(void *)&this[56]._os_unfair_lock_opaque] = 0xDFFDFE9001F00735;
        }
        *(void *)&a2[*(void *)&this[52]._os_unfair_lock_opaque] = v23;
        *(void *)(*(void *)&this[42]._os_unfair_lock_opaque + 16 * os_unfair_lock_opaque + 8) = a2;
        goto LABEL_35;
      }
LABEL_46:
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_47;
    }
    re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Pool block is invalid. This could mean the memory address was not allocated from this pool, or other corruption. Enable RE_MEMORY_TRACKING to debug", "!m_enableAsserts || block->m_magic == blockGuard", "free", 149);
    _os_crash();
    __break(1u);
LABEL_42:
    if (*(void *)&this[2]._os_unfair_lock_opaque) {
      unint64_t v25 = *(const char **)&this[2]._os_unfair_lock_opaque;
    }
    else {
      unint64_t v25 = "<UNKNOWN>";
    }
    re::internal::assertLog((re::internal *)5, v21, "assertion failure: '%s' (%s:line %i) Called free() on pool %s which is not bound to a parent allocator (already destroyed?)", "!m_enableAsserts", "free", 133, v25);
    _os_crash();
    __break(1u);
    goto LABEL_46;
  }
  unint64_t v20 = *re::foundationMemoryLogObjects((re *)this);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    unint64_t v24 = *(const char **)&this[2]._os_unfair_lock_opaque;
    if (!v24) {
      unint64_t v24 = "<UNKNOWN>";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v24;
    _os_log_error_impl(&dword_228C70000, v20, OS_LOG_TYPE_ERROR, "Called free() on pool %s which is not bound to a parent allocator (already destroyed?)", buf, 0xCu);
  }
  if (LOBYTE(this[58]._os_unfair_lock_opaque)) {
    goto LABEL_42;
  }
}

uint64_t re::PoolAllocator::statistics(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 8;
  os_unfair_lock_lock(this + 8);
  uint64_t v3 = *(void *)&this[28]._os_unfair_lock_opaque;
  uint64_t v4 = 16 * *(void *)&this[38]._os_unfair_lock_opaque + 8 * v3;
  uint64_t v5 = 16 * *(void *)&this[36]._os_unfair_lock_opaque + 8 * *(void *)&this[26]._os_unfair_lock_opaque;
  if (v3)
  {
    uint64_t v6 = *(uint64_t **)&this[32]._os_unfair_lock_opaque;
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6++;
      v5 += *(void *)&this[50]._os_unfair_lock_opaque;
      v4 += *(unsigned int *)(v8 + 4);
      v7 -= 8;
    }
    while (v7);
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

__n128 re::DynamicArray<re::PoolAllocator::PoolFreeList>::add(uint64_t a1, __n128 *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(a1 + 32) + 16 * v5) = *a2;
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::PoolAllocator::parent(re::PoolAllocator *this)
{
  return *((void *)this + 3);
}

void *re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 16 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 16 * v5[2]);
            __n128 result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        __n128 result = (void *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const char *__s, re::Allocator *a3)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  size_t v6 = strlen(__s);
  if (v6)
  {
    size_t v7 = v6;
    *(void *)this = a3;
    re::DynamicString::setCapacity(this, v6 + 1);
    re::DynamicString::assign(this, __s, v7);
  }
  else
  {
    *(void *)this = a3;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

void *re::DynamicString::assign(re::DynamicString *this, const char *__src, size_t __len)
{
  uint64_t v6 = *((void *)this + 1);
  if (v6) {
    size_t v7 = *((void *)this + 3);
  }
  else {
    size_t v7 = 23;
  }
  if (v7 <= __len)
  {
    re::DynamicString::growCapacity(this, __len + 1);
    uint64_t v6 = *((void *)this + 1);
  }
  if (v6) {
    BOOL v8 = (char *)*((void *)this + 2);
  }
  else {
    BOOL v8 = (char *)this + 9;
  }
  __n128 result = memmove(v8, __src, __len);
  if (*((unsigned char *)this + 8)) {
    unint64_t v10 = (char *)*((void *)this + 2);
  }
  else {
    unint64_t v10 = (char *)this + 9;
  }
  v10[__len] = 0;
  uint64_t v11 = *((void *)this + 1);
  if (v11) {
    *((void *)this + 1) = (2 * __len) | 1;
  }
  else {
    *((unsigned char *)this + 8) = v11 & 1 | (2 * __len);
  }
  return result;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const re::DynamicString *a2)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  unint64_t v4 = *((void *)a2 + 1);
  if (v4) {
    unint64_t v5 = v4 >> 1;
  }
  else {
    unint64_t v5 = v4 >> 1;
  }
  if (v5)
  {
    *(void *)this = *(void *)a2;
    re::DynamicString::setCapacity(this, v5 + 1);
    re::DynamicString::copy(this, a2);
  }
  else
  {
    uint64_t v6 = *(uint64_t **)a2;
    if (!*(void *)a2)
    {
    }
    *(void *)this = v6;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

void *re::DynamicString::copy(void *this, const re::DynamicString *a2)
{
  uint64_t v2 = this;
  unint64_t v3 = *((void *)a2 + 1);
  unint64_t v4 = v3 >> 1;
  if ((v3 & 1) == 0) {
    unint64_t v4 = v3 >> 1;
  }
  uint64_t v5 = this[1];
  if (v4)
  {
    if (v5) {
      unint64_t v7 = this[3];
    }
    else {
      unint64_t v7 = 23;
    }
    if (v4 >= v7)
    {
      re::DynamicString::setCapacity(this, v4 + 1);
      uint64_t v5 = v2[1];
    }
    if (v5) {
      unint64_t v9 = (void *)v2[2];
    }
    else {
      unint64_t v9 = (char *)v2 + 9;
    }
    unint64_t v10 = *((void *)a2 + 1);
    if (v10) {
      uint64_t v11 = (char *)*((void *)a2 + 2);
    }
    else {
      uint64_t v11 = (char *)a2 + 9;
    }
    unint64_t v12 = v10 >> 1;
    unint64_t v13 = v10 >> 1;
    if (*((void *)a2 + 1)) {
      unint64_t v13 = v12;
    }
    this = memmove(v9, v11, v13 + 1);
    uint64_t v14 = v2[1];
    if (v14)
    {
      uint64_t v15 = *((void *)a2 + 1);
      uint64_t v16 = 254;
      if (v15) {
        uint64_t v16 = -2;
      }
      v2[1] = v16 & v15 | 1;
    }
    else
    {
      *((unsigned char *)v2 + 8) = *((unsigned char *)a2 + 8) & 0xFE | v14 & 1;
    }
  }
  else
  {
    if (v5)
    {
      this[1] = 1;
      BOOL v8 = (unsigned char *)this[2];
    }
    else
    {
      *((unsigned char *)this + 8) = v5 & 1;
      BOOL v8 = (char *)this + 9;
    }
    *BOOL v8 = 0;
  }
  return this;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *this, uint64_t a2)
{
  size_t v3 = *(void *)(a2 + 8);
  if (v3)
  {
    if (!*(void *)this)
    {
      re::DynamicString::setCapacity(this, v3 + 1);
    }
    re::DynamicString::assign(this, *(const char **)a2, v3);
  }
  else
  {
    uint64_t v5 = *((void *)this + 1);
    if (v5)
    {
      *((void *)this + 1) = 1;
      uint64_t v6 = (unsigned char *)*((void *)this + 2);
    }
    else
    {
      *((unsigned char *)this + 8) = v5 & 1;
      uint64_t v6 = (char *)this + 9;
    }
    *uint64_t v6 = 0;
  }
  return this;
}

void *re::DynamicString::setCapacity(void *this, size_t __n)
{
  size_t v3 = this;
  unint64_t v4 = this[1];
  if (__n <= 0x17)
  {
    if ((v4 & 1) == 0) {
      return this;
    }
    goto LABEL_6;
  }
  if (v4)
  {
LABEL_6:
    int v5 = 0;
    uint64_t v6 = this[3];
    goto LABEL_7;
  }
  int v5 = 1;
  uint64_t v6 = 23;
LABEL_7:
  if (v6 != __n)
  {
    size_t v7 = v5 ? v4 >> 1 : v4 >> 1;
    if (v7 < __n)
    {
      if (__n > 0x16)
      {
        this = (void *)(*(uint64_t (**)(void))(*(void *)*this + 32))();
        if (!this)
        {
          re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Out of memory.", "newBuffer", "setCapacity", 455);
          this = (void *)_os_crash();
          __break(1u);
          return this;
        }
        uint64_t v11 = this;
        *(unsigned char *)this = 0;
        unint64_t v12 = v3[1];
        unint64_t v13 = v12 >> 1;
        if ((v12 & 1) == 0) {
          unint64_t v13 = v12 >> 1;
        }
        if (v13)
        {
          if (v12) {
            uint64_t v14 = (const void *)v3[2];
          }
          else {
            uint64_t v14 = (char *)v3 + 9;
          }
          this = memcpy(this, v14, v13 + 1);
          unint64_t v12 = v3[1];
        }
        if (v12)
        {
          this = (void *)(*(uint64_t (**)(void, void))(*(void *)*v3 + 40))(*v3, v3[2]);
          uint64_t v15 = v3[1];
        }
        else
        {
          uint64_t v15 = v12 & 0xFE;
        }
        v3[2] = v11;
        v3[3] = __n;
        unint64_t v9 = v15 | 1;
      }
      else
      {
        BOOL v8 = (const void *)this[2];
        *((unsigned char *)this + 8) = v4;
        memcpy((char *)this + 9, v8, __n);
        this = (void *)(*(uint64_t (**)(void, const void *))(*(void *)*v3 + 40))(*v3, v8);
        unint64_t v9 = v3[1] & 0xFFFFFFFFFFFFFFFELL;
      }
      v3[1] = v9;
    }
  }
  return this;
}

double re::DynamicString::deinit(re::DynamicString *this)
{
  uint64_t v2 = *(void *)this;
  if (v2)
  {
    if (*((unsigned char *)this + 8)) {
      (*(void (**)(uint64_t, void))(*(void *)v2 + 40))(v2, *((void *)this + 2));
    }
    double result = 0.0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
  }
  return result;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *this, re::DynamicString *a2)
{
  if (this == a2) {
    return this;
  }
  uint64_t v4 = *(void *)a2;
  if (!*(void *)this)
  {
    if (!v4) {
      return this;
    }
    unint64_t v7 = *((void *)a2 + 1);
    if (v7) {
      unint64_t v8 = v7 >> 1;
    }
    else {
      unint64_t v8 = v7 >> 1;
    }
    *(void *)this = v4;
    re::DynamicString::setCapacity(this, v8 + 1);
LABEL_11:
    re::DynamicString::copy(this, a2);
    return this;
  }
  if (v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    *((void *)this + 1) = 1;
    uint64_t v6 = (unsigned char *)*((void *)this + 2);
  }
  else
  {
    *((unsigned char *)this + 8) = v5 & 1;
    uint64_t v6 = (char *)this + 9;
  }
  *uint64_t v6 = 0;
  return this;
}

{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned char *v11;

  if (this != a2)
  {
    size_t v3 = *(void *)this;
    uint64_t v4 = *(void *)a2;
    if (*(void *)this) {
      uint64_t v5 = v3 == v4;
    }
    else {
      uint64_t v5 = 1;
    }
    if (v5)
    {
      *(void *)this = v4;
      *(void *)a2 = v3;
      uint64_t v6 = *((void *)this + 3);
      *((void *)this + 3) = *((void *)a2 + 3);
      *((void *)a2 + 3) = v6;
      unint64_t v8 = *((void *)this + 1);
      unint64_t v7 = *((void *)this + 2);
      unint64_t v9 = *((void *)a2 + 2);
      *((void *)this + 1) = *((void *)a2 + 1);
      *((void *)this + 2) = v9;
      *((void *)a2 + 1) = v8;
      *((void *)a2 + 2) = v7;
    }
    else if (v4)
    {
      re::DynamicString::copy(this, a2);
    }
    else
    {
      uint64_t v10 = *((void *)this + 1);
      if (v10)
      {
        *((void *)this + 1) = 1;
        uint64_t v11 = (unsigned char *)*((void *)this + 2);
      }
      else
      {
        *((unsigned char *)this + 8) = v10 & 1;
        uint64_t v11 = (char *)this + 9;
      }
      *uint64_t v11 = 0;
    }
  }
  return this;
}

BOOL re::DynamicString::operator==(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    uint64_t v2 = *(const char **)(a1 + 16);
  }
  else {
    uint64_t v2 = (const char *)(a1 + 9);
  }
  if (*(void *)(a2 + 8)) {
    size_t v3 = *(const char **)(a2 + 16);
  }
  else {
    size_t v3 = (const char *)(a2 + 9);
  }
  return strcmp(v2, v3) == 0;
}

void *re::DynamicString::append(re::DynamicString *this, const char *__src, size_t __len)
{
  unint64_t v6 = *((void *)this + 1);
  unint64_t v7 = v6 >> 1;
  if ((v6 & 1) == 0) {
    unint64_t v7 = v6 >> 1;
  }
  unint64_t v8 = v7 + __len;
  if (v6) {
    unint64_t v9 = *((void *)this + 3);
  }
  else {
    unint64_t v9 = 23;
  }
  if (v8 >= v9)
  {
    re::DynamicString::growCapacity(this, v8 + 1);
    unint64_t v6 = *((void *)this + 1);
  }
  if (v6) {
    uint64_t v10 = (char *)*((void *)this + 2);
  }
  else {
    uint64_t v10 = (char *)this + 9;
  }
  if (v6) {
    unint64_t v11 = v6 >> 1;
  }
  else {
    unint64_t v11 = v6 >> 1;
  }
  double result = memmove(&v10[v11], __src, __len);
  uint64_t v13 = *((void *)this + 1);
  if (v13)
  {
    size_t v14 = v13 + 2 * __len;
    *((void *)this + 1) = v14;
    if (v14) {
      goto LABEL_16;
    }
  }
  else
  {
    *((unsigned char *)this + 8) = v13 + 2 * __len;
    size_t v14 = *((void *)this + 1);
    if (v14)
    {
LABEL_16:
      uint64_t v15 = (char *)*((void *)this + 2);
      goto LABEL_19;
    }
  }
  uint64_t v15 = (char *)this + 9;
LABEL_19:
  if (v14) {
    size_t v16 = v14 >> 1;
  }
  else {
    size_t v16 = v14 >> 1;
  }
  v15[v16] = 0;
  return result;
}

void *re::DynamicString::growCapacity(void *this, size_t a2)
{
  if (this[1])
  {
    size_t v3 = this[3];
    if (v3 >= a2) {
      return this;
    }
    unint64_t v2 = 2 * v3;
  }
  else
  {
    if (a2 <= 0x17) {
      return this;
    }
    unint64_t v2 = 64;
  }
  if (v2 > a2) {
    a2 = v2;
  }
  return re::DynamicString::setCapacity(this, a2);
}

uint64_t re::DynamicString::appendf(re::DynamicString *this, const char *a2, ...)
{
  va_start(va, a2);
  return re::DynamicString::vappendf(this, a2, va);
}

uint64_t re::DynamicString::vappendf(re::DynamicString *this, const char *__format, va_list a3)
{
  unint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    unint64_t v6 = v5 >> 1;
    uint64_t v8 = *((void *)this + 3);
    unint64_t v7 = (char *)(*((void *)this + 2) + (v5 >> 1));
  }
  else
  {
    unint64_t v6 = v5 >> 1;
    unint64_t v7 = (char *)this + v6 + 9;
    uint64_t v8 = 23;
  }
  uint64_t result = vsnprintf(v7, v8 - v6, __format, a3);
  unint64_t v10 = *((void *)this + 1);
  if ((result & 0x80000000) == 0)
  {
    unint64_t v11 = v10 >> 1;
    unint64_t v12 = v10 >> 1;
    if (v10) {
      unint64_t v12 = v10 >> 1;
    }
    unint64_t v13 = v12 + result;
    if (v10)
    {
      if (v13 >= *((void *)this + 3))
      {
        size_t v14 = (char *)*((void *)this + 2);
        if (!v14)
        {
LABEL_16:
          re::DynamicString::growCapacity(this, result + v11 + 1);
          unint64_t v17 = *((void *)this + 1);
          if (v17)
          {
            unint64_t v18 = v17 >> 1;
            uint64_t v20 = *((void *)this + 3);
            unint64_t v19 = (char *)(*((void *)this + 2) + (v17 >> 1));
          }
          else
          {
            unint64_t v18 = v17 >> 1;
            unint64_t v19 = (char *)this + v18 + 9;
            uint64_t v20 = 23;
          }
          uint64_t result = vsnprintf(v19, v20 - v18, __format, a3);
          goto LABEL_25;
        }
LABEL_14:
        v14[v12] = 0;
        unint64_t v16 = *((void *)this + 1);
        unint64_t v11 = v16 >> 1;
        if ((v16 & 1) == 0) {
          unint64_t v11 = v16 >> 1;
        }
        goto LABEL_16;
      }
    }
    else if (v13 >= 0x17)
    {
      size_t v14 = (char *)this + 9;
      goto LABEL_14;
    }
LABEL_25:
    uint64_t v22 = *((void *)this + 1);
    if (v22) {
      *((void *)this + 1) = v22 + 2 * (int)result;
    }
    else {
      *((unsigned char *)this + 8) = v22 + 2 * result;
    }
    return result;
  }
  if (v10)
  {
    uint64_t v15 = (char *)*((void *)this + 2);
    if (!v15) {
      return result;
    }
  }
  else
  {
    uint64_t v15 = (char *)this + 9;
  }
  if (v10) {
    unint64_t v21 = v10 >> 1;
  }
  else {
    unint64_t v21 = v10 >> 1;
  }
  v15[v21] = 0;
  return result;
}

uint64_t re::DynamicString::vassignf(re::DynamicString *this, const char *__format, va_list a3)
{
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    *((void *)this + 1) = 1;
    uint64_t v4 = (unsigned char *)*((void *)this + 2);
  }
  else
  {
    *((unsigned char *)this + 8) = v3 & 1;
    uint64_t v4 = (char *)this + 9;
  }
  *uint64_t v4 = 0;
  return re::DynamicString::vappendf(this, __format, a3);
}

void *re::DynamicString::substr@<X0>(re::DynamicString *this@<X0>, unint64_t a2@<X1>, size_t a3@<X2>, re::DynamicString *a4@<X8>)
{
  unint64_t v6 = *((void *)this + 1);
  if (v6) {
    unint64_t v7 = v6 >> 1;
  }
  else {
    unint64_t v7 = v6 >> 1;
  }
  if (v7 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index <= size()", "substr", 610, a2, v7);
    uint64_t result = (void *)_os_crash();
    __break(1u);
  }
  else
  {
    if (v7 - a2 >= a3) {
      size_t v9 = a3;
    }
    else {
      size_t v9 = v7 - a2;
    }
    *((void *)a4 + 1) = 0;
    *((void *)a4 + 2) = 0;
    *((void *)a4 + 3) = 0;
    re::DynamicString::setCapacity(a4, 0);
    *(void *)a4 = *(void *)this;
    re::DynamicString::setCapacity(a4, v9);
    if (*((unsigned char *)this + 8)) {
      unint64_t v10 = (char *)*((void *)this + 2);
    }
    else {
      unint64_t v10 = (char *)this + 9;
    }
    return re::DynamicString::assign(a4, &v10[a2], v9);
  }
  return result;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  unint64_t v3 = *(void *)(this + 8);
  if (v3) {
    unint64_t v4 = v3 >> 1;
  }
  else {
    unint64_t v4 = v3 >> 1;
  }
  if (v4) {
    return re::DynamicString::rfind(this, a2, v4 - 1, (uint64_t)a3);
  }
  *a3 = 0;
  return this;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v4 = *(void *)(this + 8);
  unint64_t v5 = v4 >> 1;
  if ((v4 & 1) == 0) {
    unint64_t v5 = v4 >> 1;
  }
  if (v5 <= a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) offset out of range. offset = %zu, size = %zu", "offset < size()", "rfind", 667, a3, v5);
    this = _os_crash();
    __break(1u);
  }
  else
  {
    if (v4) {
      uint64_t v6 = *(void *)(this + 16);
    }
    else {
      uint64_t v6 = this + 9;
    }
    uint64_t v7 = this + 9;
    uint64_t v8 = a3 + v6;
    uint64_t v9 = -(uint64_t)(a3 + v6);
    uint64_t v10 = v8 + 1;
    while (*(unsigned __int8 *)(v10 - 1) != a2)
    {
      uint64_t v11 = this + 9;
      if (v4) {
        uint64_t v11 = *(void *)(this + 16);
      }
      ++v9;
      if (--v10 == v11)
      {
        *(unsigned char *)a4 = 0;
        return this;
      }
    }
    if (v4) {
      uint64_t v7 = *(void *)(this + 16);
    }
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = -(v7 + v9);
  }
  return this;
}

uint64_t re::DynamicString::format@<X0>(re::DynamicString *this@<X0>, re::DynamicString *a2@<X8>, ...)
{
  va_start(va, a2);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  re::DynamicString::setCapacity(a2, 0);
  return re::DynamicString::vassignf(a2, (const char *)this, va);
}

uint64_t re::internal::assertLog(re::internal *this, uint64_t a2, ...)
{
  return os_log_with_args();
}

uint64_t *re::foundationCoreLogObjects(re *this)
{
  {
    re::foundationCoreLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Core");
  }
  return &re::foundationCoreLogObjects(void)::logObjects;
}

BOOL re::internal::enableSignposts(re::internal *this, uint64_t a2)
{
  {
    unsigned int v6 = a2;
    char v7 = (char)this;
    a2 = v6;
    LOBYTE(this) = v7;
    if (v3)
    {
      re::Defaults::intValue((re::Defaults *)"enableSignposts", (const char *)v6, (uint64_t)v8);
      if (v8[0]) {
        BOOL v4 = v9 == 0;
      }
      else {
        BOOL v4 = 0;
      }
      char v5 = !v4;
      re::internal::enableSignposts(BOOL,BOOL)::value = v5;
      a2 = v6;
      LOBYTE(this) = v7;
    }
  }
  if ((this & 1) == 0) {
    return re::internal::enableSignposts(BOOL,BOOL)::value != 0;
  }
  re::internal::enableSignposts(BOOL,BOOL)::value = a2;
  return a2;
}

BOOL re::internal::enableHighFrequencyNetworkTracing(re::internal *this, uint64_t a2)
{
  {
    unsigned int v6 = a2;
    char v7 = (char)this;
    a2 = v6;
    LOBYTE(this) = v7;
    if (v3)
    {
      re::Defaults::intValue((re::Defaults *)"enableHighFrequencyNetworkTracing", (const char *)v6, (uint64_t)v8);
      if (v8[0]) {
        BOOL v4 = v9 == 0;
      }
      else {
        BOOL v4 = 1;
      }
      char v5 = !v4;
      re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value = v5;
      a2 = v6;
      LOBYTE(this) = v7;
    }
  }
  if ((this & 1) == 0) {
    return re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value != 0;
  }
  re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value = a2;
  return a2;
}

void re::Defaults::intValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v4 = ;
  if (v4)
  {
    unsigned int v6 = v4;
    *(_DWORD *)(a3 + 4) = [v4 intValue];
    BOOL v4 = v6;
    char v5 = 1;
  }
  else
  {
    char v5 = 0;
  }
  *(unsigned char *)a3 = v5;
}

id anonymous namespace'::getValue(_anonymous_namespace_ *this, const char *a2)
{
  int v3 = [MEMORY[0x263EFFA40] standardUserDefaults];
  BOOL v4 = objc_msgSend(NSString, "stringWithFormat:", @"%s.%s", "com.apple.re", this);
  char v5 = [v3 objectForKey:v4];
  if (!v5)
  {
    unsigned int v6 = [NSString stringWithUTF8String:this];
    char v7 = [v3 objectForKey:v6];
    if (v7)
    {
      char v5 = v7;
      uint64_t v8 = v6;
    }
    else
    {
      uint64_t v9 = [v4 rangeOfString:@"." options:4];
      uint64_t v10 = [v4 substringToIndex:v9];
      uint64_t v8 = [v4 substringFromIndex:v9 + 1];

      if ([(__CFString *)v10 isEqualToString:@"com.apple.re.network.multipeerservice"])
      {

        uint64_t v10 = @"com.apple.renetwork.multipeerservice";
      }
      uint64_t v11 = [v3 dictionaryForKey:v10];
      char v5 = [v11 objectForKey:v8];

      if (!v5) {
        goto LABEL_9;
      }
    }
    unint64_t v12 = *re::foundationCoreLogObjects(v7);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
    }
LABEL_9:
  }
  return v5;
}

void re::Defaults::BOOLValue(re::Defaults *this@<X0>, const char *a2@<X1>, char *a3@<X8>)
{
  BOOL v4 = ;
  if (v4)
  {
    unsigned int v6 = v4;
    a3[1] = [v4 BOOLValue];
    BOOL v4 = v6;
    char v5 = 1;
  }
  else
  {
    char v5 = 0;
  }
  *a3 = v5;
}

void re::Defaults::uintValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v4 = ;
  if (v4)
  {
    unsigned int v6 = v4;
    *(_DWORD *)(a3 + 4) = [v4 unsignedIntValue];
    BOOL v4 = v6;
    char v5 = 1;
  }
  else
  {
    char v5 = 0;
  }
  *(unsigned char *)a3 = v5;
}

re::AlignedAllocator *re::AlignedAllocator::AlignedAllocator(re::AlignedAllocator *this, const char *a2, uint64_t a3, re::Allocator *a4)
{
  unsigned int v6 = re::Allocator::Allocator(this, a2, 1);
  *((void *)v6 + 8) = 0;
  *((void *)v6 + 9) = 0;
  *(_OWORD *)((char *)v6 + 20) = 0u;
  *(_OWORD *)((char *)v6 + 36) = 0u;
  *(void *)((char *)v6 + 52) = 0;
  *(void *)unsigned int v6 = &unk_26DD34328;
  *((void *)v6 + 10) = 0;
  *((void *)v6 + 11) = 0;
  re::BaseAllocator::init(v6);
  *((_DWORD *)this + 5) |= 1u;
  *((void *)this + 10) = a3;
  return this;
}

void re::BaseAllocator::~BaseAllocator(re::BaseAllocator *this)
{
  *(void *)this = &unk_26DD343B0;
  unint64_t v2 = (char *)this + 32;
  if (*((void *)this + 4)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 32);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v2);
  re::Allocator::~Allocator(this);
}

void re::AlignedAllocator::~AlignedAllocator(re::AlignedAllocator *this)
{
  uint64_t v3 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  if (v3)
  {
    *((void *)this + 10) = 0;
    *((void *)this + 11) = 0;
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v2);
  }
  re::BaseAllocator::~BaseAllocator(this);
}

{
  char *v2;
  uint64_t v3;
  uint64_t vars8;

  uint64_t v3 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  if (v3)
  {
    *((void *)this + 10) = 0;
    *((void *)this + 11) = 0;
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v2);
  }
  re::BaseAllocator::~BaseAllocator(this);
  JUMPOUT(0x22A6A9430);
}

void *re::AlignedAllocator::alloc(re::AlignedAllocator *this, size_t size)
{
  uint64_t v4 = *((void *)this + 11);
  if (v4)
  {
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t, size_t, void))(*(void *)v4 + 32))(v4, size, 0);
  }
  else
  {
    size_t v6 = (*((void *)this + 10) + 7) & 0xFFFFFFFFFFFFFFF8;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, v6, size, 0xC75C8B65uLL);
    uint64_t result = memptr;
  }
  __dmb(0xBu);
  return result;
}

void re::AlignedAllocator::free(re::AlignedAllocator *this, void *a2)
{
  __dmb(0xBu);
  uint64_t v2 = *((void *)this + 11);
  if (v2) {
    (*(void (**)(uint64_t, void *))(*(void *)v2 + 40))(v2, a2);
  }
  else {
    free(a2);
  }
}

uint64_t re::AlignedAllocator::statistics(re::AlignedAllocator *this)
{
  return 0;
}

uint64_t re::AlignedAllocator::parent(re::AlignedAllocator *this)
{
  return *((void *)this + 11);
}

re::Allocator *re::Allocator::Allocator(re::Allocator *this, const char *a2, int a3)
{
  *(void *)this = &unk_26DD34408;
  *((void *)this + 1) = a2;
  *((unsigned char *)this + 16) = a3;
  if (a3)
  {
    uint64_t v4 = re::globalMemoryTracker(this);
    if (*v4)
    {
      char v5 = re::globalMemoryTracker((re *)v4);
      re::MemoryTracker::track((os_unfair_lock_s *)v5, this);
    }
  }
  return this;
}

void re::Allocator::~Allocator(re::Allocator *this)
{
  *(void *)this = &unk_26DD34408;
  if (*((unsigned char *)this + 16))
  {
    uint64_t v2 = re::globalMemoryTracker(this);
    if (*v2)
    {
      uint64_t v3 = re::globalMemoryTracker((re *)v2);
      re::MemoryTracker::untrack((os_unfair_lock_s *)v3, this);
    }
  }
}

_anonymous_namespace_ *re::PerFrameAllocatorManager::init(_anonymous_namespace_ *this)
{
  if (*(unsigned char *)this) {
    return this;
  }
  uint64_t v1 = this;
  *((void *)v1 + 2) = 16;
  *((void *)v1 + 3) = v2;
  if (!v2) {
    goto LABEL_26;
  }
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((void *)v1 + 5) = 16;
  *((void *)v1 + 6) = v4;
  if (!v4) {
    goto LABEL_27;
  }
  unint64_t v6 = 0;
  *((_OWORD *)v4 + 6) = 0u;
  *((_OWORD *)v4 + 7) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *(_OWORD *)uint64_t v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *(unsigned char *)uint64_t v1 = 1;
  do
  {
    if (*((void *)v1 + 5) <= v6)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_25:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_26:
      re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_27:
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    *(void *)(*((void *)v1 + 6) + 8 * v6) = 0;
    if (*((void *)v1 + 2) <= v6) {
      goto LABEL_25;
    }
    *(void *)(*((void *)v1 + 3) + 8 * v6++) = 0;
  }
  while (v6 != 16);
  unint64_t v7 = *((void *)v1 + 18);
  if (v7 > 0xE)
  {
    if (v7 != 15)
    {
      unint64_t v12 = 15;
      uint64_t v13 = 1328;
      do
      {
        uint64_t v14 = *((void *)v1 + 20) + v13;
        re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v14 + 40);
        uint64_t v4 = (_anonymous_namespace_ *)re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v14);
        ++v12;
        v13 += 88;
      }
      while (v12 < *((void *)v1 + 18));
      goto LABEL_18;
    }
  }
  else
  {
    if (*((void *)v1 + 17) > 0xEuLL
      || (uint64_t v4 = (_anonymous_namespace_ *)re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity((void *)v1 + 16),
          unint64_t v7 = *((void *)v1 + 18),
          v7 <= 0xE))
    {
      unint64_t v8 = v7 - 15;
      uint64_t v9 = 88 * v7;
      do
      {
        uint64_t v10 = *((void *)v1 + 20) + v9;
        *(void *)(v10 + 80) = 0;
        *(_OWORD *)uint64_t v10 = 0uLL;
        *(_OWORD *)(v10 + 16) = 0uLL;
        *(_DWORD *)(v10 + 32) = 0;
        *(_OWORD *)(v10 + 40) = 0uLL;
        *(_OWORD *)(v10 + 56) = 0uLL;
        *(_DWORD *)(v10 + 72) = 0;
        v9 += 88;
      }
      while (!__CFADD__(v8++, 1));
    }
LABEL_18:
    *((void *)v1 + 18) = 15;
    ++*((_DWORD *)v1 + 38);
  }
  uint64_t v15 = 0;
  unint64_t v16 = (void *)*((void *)v1 + 20);
  do
  {
    void *v16 = 0x10000 << v15;
    v16 += 11;
    ++v15;
  }
  while (v15 != 15);
  unint64_t v17 = (char *)v1 + 56;
  re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(v17, 0);
  ++*((_DWORD *)v17 + 6);
  *((_DWORD *)v17 + 11) = 16;
  return re::DataArray<re::PerFrameAllocatorImpl>::allocBlock(v17);
}

re *re::PerFrameAllocatorManager::deinit(re *this)
{
  if (*(unsigned char *)this)
  {
    uint64_t v1 = this;
    this = (re *)re::DataArray<re::PerFrameAllocatorImpl>::deinit((uint64_t)this + 56);
    unint64_t v2 = *((void *)v1 + 18);
    if (v2)
    {
      for (unint64_t i = 0; i < v2; ++i)
      {
        uint64_t v4 = *((void *)v1 + 20);
        uint64_t v5 = v4 + 88 * i;
        unint64_t v8 = *(void *)(v5 + 64);
        unint64_t v7 = (unint64_t *)(v5 + 64);
        unint64_t v6 = v8;
        if (v8)
        {
          unint64_t v9 = 0;
          uint64_t v10 = (void *)(v4 + 88 * i + 80);
          do
          {
            uint64_t v11 = **(void **)(*v10 + 8 * v9);
            if (v11)
            {
              unint64_t v12 = re::globalAllocators(this);
              (*(void (**)(uint64_t, uint64_t))(*(void *)v12[2] + 40))(v12[2], v11);
              unint64_t v6 = *v7;
            }
            if (v6 <= v9)
            {
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_20:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_21:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_22:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            this = re::internal::destroyPersistent<re::internal::PerFrameAllocatorChunk>(*(re **)(*v10 + 8 * v9));
            unint64_t v6 = *v7;
            if (*v7 <= v9) {
              goto LABEL_20;
            }
            *(void *)(*v10 + 8 * v9++) = 0;
          }
          while (v6 > v9);
          unint64_t v2 = *((void *)v1 + 18);
        }
        *unint64_t v7 = 0;
        uint64_t v13 = v4 + 88 * i;
        ++*(_DWORD *)(v13 + 72);
        *(void *)(v13 + 24) = 0;
        ++*(_DWORD *)(v13 + 32);
      }
    }
    for (unint64_t j = 0; j != 16; ++j)
    {
      if (*((void *)v1 + 5) <= j) {
        goto LABEL_21;
      }
      *(void *)(*((void *)v1 + 6) + 8 * j) = 0;
      if (*((void *)v1 + 2) <= j) {
        goto LABEL_22;
      }
      *(void *)(*((void *)v1 + 3) + 8 * j) = 0;
    }
    *(unsigned char *)uint64_t v1 = 0;
  }
  return this;
}

re *re::internal::destroyPersistent<re::internal::PerFrameAllocatorChunk>(re *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = re::globalAllocators(result)[2];
    *(_OWORD *)((char *)v1 + 40) = 0u;
    *(_OWORD *)((char *)v1 + 56) = 0u;
    re::HashTable<unsigned long,unsigned long,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::deinit((uint64_t *)v1 + 10);
    re::Allocator::~Allocator((re *)((char *)v1 + 16));
    uint64_t v3 = *(uint64_t (**)(uint64_t, re *))(*(void *)v2 + 40);
    return (re *)v3(v2, v1);
  }
  return result;
}

void *re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity(void *result)
{
  if (result[1] != 15)
  {
    uint64_t v1 = result;
    if (result[2] <= 0xFuLL)
    {
      uint64_t v2 = *result;
      if (*v1)
      {
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 32))(v2, 1320, 8);
        if (result)
        {
          uint64_t v4 = result;
          if (v1[1])
          {
            uint64_t v5 = v1[4];
            uint64_t v6 = v1[2];
            if (v6)
            {
              uint64_t v7 = v5 + 88 * v6;
              unint64_t v8 = result;
              do
              {
                uint64_t v9 = *(void *)v5;
                v8[5] = 0;
                *unint64_t v8 = v9;
                v8[1] = 0;
                *((_DWORD *)v8 + 8) = 0;
                v8[2] = 0;
                v8[3] = 0;
                uint64_t v10 = v5 + 8;
                uint64_t v11 = *(void *)(v5 + 16);
                v8[1] = *(void *)(v5 + 8);
                *(void *)(v5 + 8) = 0;
                v8[2] = v11;
                *(void *)(v5 + 16) = 0;
                uint64_t v12 = v8[3];
                v8[3] = *(void *)(v5 + 24);
                *(void *)(v5 + 24) = v12;
                uint64_t v13 = v8[5];
                v8[5] = *(void *)(v5 + 40);
                *(void *)(v5 + 40) = v13;
                ++*(_DWORD *)(v5 + 32);
                ++*((_DWORD *)v8 + 8);
                v8[10] = 0;
                v8[7] = 0;
                v8[8] = 0;
                v8[6] = 0;
                *((_DWORD *)v8 + 18) = 0;
                uint64_t v14 = *(void *)(v5 + 48);
                uint64_t v15 = *(void *)(v5 + 56);
                uint64_t v16 = v5 + 48;
                v8[6] = v14;
                v8[7] = v15;
                *(void *)uint64_t v16 = 0;
                *(void *)(v16 + 8) = 0;
                uint64_t v17 = v8[8];
                v8[8] = *(void *)(v16 + 16);
                *(void *)(v16 + 16) = v17;
                uint64_t v18 = v8[10];
                v8[10] = *(void *)(v16 + 32);
                *(void *)(v16 + 32) = v18;
                ++*(_DWORD *)(v16 + 24);
                ++*((_DWORD *)v8 + 18);
                re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v16);
                re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v10);
                uint64_t v5 = v16 + 40;
                v8 += 11;
              }
              while (v5 != v7);
              uint64_t v5 = v1[4];
            }
            uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v1 + 40))(*v1, v5);
          }
          v1[4] = v4;
          v1[1] = 15;
        }
        else
        {
          re::internal::assertLog((re::internal *)6, v3, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, 1320, *(void *)(*v1 + 8));
          uint64_t result = (void *)_os_crash();
          __break(1u);
        }
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity(v1);
        ++*((_DWORD *)v1 + 6);
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::DataArray<re::PerFrameAllocatorImpl>::allocBlock(void *a1)
{
  uint64_t v3 = 184 * *((unsigned int *)a1 + 11);
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(void *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v6 = v4;
  uint64_t v1 = 4 * *((unsigned int *)a1 + 11);
  uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(void *)(*a1 + 8));
    uint64_t result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  uint64_t v9 = result;
  unint64_t v11 = a1[1];
  unint64_t v10 = a1[2];
  if (v10 >= v11)
  {
    unint64_t v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        unint64_t v13 = 2 * v11;
        if (!v11) {
          unint64_t v13 = 8;
        }
        if (v13 <= v12) {
          unint64_t v14 = v12;
        }
        else {
          unint64_t v14 = v13;
        }
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(a1, v14);
      }
      else
      {
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    unint64_t v10 = a1[2];
  }
  uint64_t v15 = (uint64_t *)(a1[4] + 16 * v10);
  uint64_t *v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

uint64_t re::InlineString<32ul>::vappendf(unint64_t *a1, char *__format, va_list a3)
{
  uint64_t result = vsnprintf((char *)a1 + *a1 + 8, 32 - *a1, __format, a3);
  if ((result & 0x80000000) != 0)
  {
    *((unsigned char *)a1 + *a1 + 8) = 0;
  }
  else
  {
    unint64_t v6 = *a1 + result;
    if (v6 >= 0x20)
    {
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "m_length + result < m_capacity", "vappendf", 446, a3, a3);
      uint64_t result = _os_crash();
      __break(1u);
    }
    else
    {
      *a1 = v6;
    }
  }
  return result;
}

pthread_t re::BaseAllocator::init(re::BaseAllocator *this)
{
  uint64_t v1 = this;
  *((void *)this + 3) = 0;
  uint64_t v1 = (re::BaseAllocator *)((char *)v1 + 32);
  re::DynamicArray<re::internal::MemBlock>::setCapacity(v1, 0);
  ++*((_DWORD *)v1 + 6);
  pthread_t result = pthread_self();
  *((void *)v1 + 5) = result;
  return result;
}

void *re::DynamicArray<re::internal::MemBlock>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      pthread_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x18uLL))
        {
          uint64_t v2 = 24 * a2;
          pthread_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 24 * v5[2]);
            pthread_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        pthread_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        pthread_t result = (void *)re::DynamicArray<re::internal::MemBlock>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t *re::foundationMemoryLogObjects(re *this)
{
  {
    re::foundationMemoryLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Memory");
  }
  return &re::foundationMemoryLogObjects(void)::logObjects;
}

uint64_t MurmurHash3_x64_128(uint64_t result, int a2, unsigned int a3, unint64_t *a4)
{
  uint64_t v4 = a3;
  if (a2 < 16)
  {
    uint64_t v7 = a3;
  }
  else
  {
    uint64_t v5 = (void *)(result + 8);
    uint64_t v6 = (a2 / 16);
    uint64_t v7 = v4;
    do
    {
      uint64_t v4 = 5
         * (__ROR8__((0x4CF5AD432745937FLL * ((0x88A129EA80000000 * *(v5 - 1)) | ((0x87C37B91114253D5 * *(v5 - 1)) >> 33))) ^ v4, 37)+ v7)+ 1390208809;
      uint64_t v7 = 5
         * (v4
          + __ROR8__((0x87C37B91114253D5* ((0x4E8B26FE00000000 * *v5) | ((unint64_t)(0x4CF5AD432745937FLL * *v5) >> 31))) ^ v7, 33))+ 944331445;
      v5 += 2;
      --v6;
    }
    while (v6);
  }
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  unint64_t v13 = 0;
  unint64_t v14 = 0;
  unint64_t v15 = 0;
  unint64_t v16 = 0;
  unint64_t v17 = 0;
  unint64_t v18 = 0;
  unint64_t v19 = 0;
  unint64_t v20 = 0;
  unint64_t v21 = (unsigned __int8 *)(result + 16 * (a2 / 16));
  switch(a2 & 0xF)
  {
    case 1:
      goto LABEL_21;
    case 2:
      goto LABEL_20;
    case 3:
      goto LABEL_19;
    case 4:
      goto LABEL_18;
    case 5:
      goto LABEL_17;
    case 6:
      goto LABEL_16;
    case 7:
      goto LABEL_15;
    case 8:
      goto LABEL_14;
    case 9:
      goto LABEL_13;
    case 0xA:
      goto LABEL_12;
    case 0xB:
      goto LABEL_11;
    case 0xC:
      goto LABEL_10;
    case 0xD:
      goto LABEL_9;
    case 0xE:
      goto LABEL_8;
    case 0xF:
      unint64_t v8 = (unint64_t)v21[14] << 48;
LABEL_8:
      unint64_t v9 = v8 | ((unint64_t)v21[13] << 40);
LABEL_9:
      unint64_t v10 = v9 ^ ((unint64_t)v21[12] << 32);
LABEL_10:
      unint64_t v11 = v10 ^ ((unint64_t)v21[11] << 24);
LABEL_11:
      unint64_t v12 = v11 ^ ((unint64_t)v21[10] << 16);
LABEL_12:
      unint64_t v13 = v12 ^ ((unint64_t)v21[9] << 8);
LABEL_13:
      v7 ^= 0x87C37B91114253D5
          * ((0x4E8B26FE00000000 * (v13 ^ v21[8])) | ((0x4CF5AD432745937FLL * (v13 ^ v21[8])) >> 31));
LABEL_14:
      unint64_t v14 = (unint64_t)v21[7] << 56;
LABEL_15:
      unint64_t v15 = v14 | ((unint64_t)v21[6] << 48);
LABEL_16:
      unint64_t v16 = v15 ^ ((unint64_t)v21[5] << 40);
LABEL_17:
      unint64_t v17 = v16 ^ ((unint64_t)v21[4] << 32);
LABEL_18:
      unint64_t v18 = v17 ^ ((unint64_t)v21[3] << 24);
LABEL_19:
      unint64_t v19 = v18 ^ ((unint64_t)v21[2] << 16);
LABEL_20:
      unint64_t v20 = v19 ^ ((unint64_t)v21[1] << 8);
LABEL_21:
      v4 ^= 0x4CF5AD432745937FLL
          * ((0x88A129EA80000000 * (v20 ^ *v21)) | ((0x87C37B91114253D5 * (v20 ^ *v21)) >> 33));
      break;
    default:
      break;
  }
  uint64_t v22 = v7 ^ a2;
  unint64_t v23 = (v4 ^ a2) + v22;
  unint64_t v24 = v23 + v22;
  unint64_t v25 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v23 ^ (v23 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v23 ^ (v23 >> 33))) >> 33));
  unint64_t v26 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) >> 33));
  unint64_t v27 = v26 ^ (v26 >> 33);
  unint64_t v28 = v27 + (v25 ^ (v25 >> 33));
  *a4 = v28;
  a4[1] = v28 + v27;
  return result;
}

uint64_t re::SharedObject::dispose(re::SharedObject *this)
{
  uint64_t v2 = *((void *)this + 2);
  (**(void (***)(re::SharedObject *))this)(this);
  uint64_t v3 = *(uint64_t (**)(uint64_t, re::SharedObject *))(*(void *)v2 + 40);
  return v3(v2, this);
}

uint64_t re::SharedObject::allocator(re::SharedObject *this)
{
  return *((void *)this + 2);
}

void re::MallocAllocator::~MallocAllocator(re::MallocAllocator *this)
{
  re::Allocator::~Allocator(this);
  JUMPOUT(0x22A6A9430);
}

void *re::MallocAllocator::alloc(re::MallocAllocator *this, size_t size, unint64_t a3)
{
  uint64_t v3 = 16;
  if (a3 > 0x10) {
    uint64_t v3 = a3;
  }
  memptr = 0;
  malloc_type_posix_memalign(&memptr, (v3 + 7) & 0xFFFFFFFFFFFFFFF8, size, 0xC75C8B65uLL);
  pthread_t result = memptr;
  __dmb(0xBu);
  return result;
}

void re::MallocAllocator::free(re::MallocAllocator *this, void *a2)
{
}

uint64_t re::MallocAllocator::statistics(re::MallocAllocator *this)
{
  return 0;
}

uint64_t re::MallocAllocator::parent(re::MallocAllocator *this)
{
  return 0;
}

uint64_t ArcObjectDestroy(char *a1, objc_selector *a2)
{
  if (a1) {
    uint64_t v2 = a1 - 8;
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v2 + 16))();
}

void ArcSharedObject::ArcSharedObject(ArcSharedObject *this, Class cls)
{
  uint64_t v2 = cls;
  *(void *)this = &unk_26DD34510;
  if (!cls)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2682A47A8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_2682A47A8))
    {
      uint64_t v4 = (objc_class *)objc_opt_class();
      ClassPair = objc_allocateClassPair(v4, "_REArcObject", 0);
      if (ClassPair)
      {
        Class = ClassPair;
        class_addMethod(ClassPair, sel_dealloc, (IMP)ArcObjectDestroy, (const char *)&unk_228CE091E);
        objc_registerClassPair(Class);
      }
      else
      {
        Class = objc_getClass("_REArcObject");
      }
      _MergedGlobals_0 = (uint64_t)Class;
      __cxa_guard_release(&qword_2682A47A8);
    }
    uint64_t v2 = (objc_class *)_MergedGlobals_0;
  }
  *((void *)this + 1) = 0;
  objc_constructInstance(v2, (char *)this + 8);
}

void ArcSharedObject::~ArcSharedObject(ArcSharedObject *this)
{
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

void ArcSharedObject::dispose(ArcSharedObject *this)
{
  (**(void (***)(ArcSharedObject *))this)(this);
  free(this);
}

unint64_t re::Hash<re::DynamicString>::operator()(uint64_t a1, uint64_t a2)
{
  v9[2] = *MEMORY[0x263EF8340];
  unint64_t v3 = *(void *)(a2 + 8);
  if (v3) {
    unint64_t v4 = v3 >> 1;
  }
  else {
    unint64_t v4 = v3 >> 1;
  }
  if (!v4) {
    return 0;
  }
  uint64_t v5 = a2 + 9;
  uint64_t v6 = *(void *)(a2 + 16);
  if (v3) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v5;
  }
  MurmurHash3_x64_128(v7, v4, 0, v9);
  return (v9[1] + (v9[0] << 6) + (v9[0] >> 2) - 0x61C8864680B583E9) ^ v9[0];
}

void RESyncCommitListCreate(re *a1)
{
  uint64_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 64, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)(v2 + 24) = 0;
  *(void *)uint64_t v2 = &unk_26DD34548;
  *(void *)(v2 + 56) = 0;
  *(void *)(v2 + 32) = 0;
  *(void *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 48) = 0;
}

uint64_t RESyncCommitListGetEntryCount(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t RESyncCommitListGetEntry(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(void *)(result + 40) <= a2) {
      return 0;
    }
    else {
      return *(void *)(result + 56) + 72 * a2;
    }
  }
  return result;
}

uint64_t RESyncCommitListAddCopy(void *a1, long long *a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)(a1 + 3), a2);
      return a1[7] + 72 * a1[5] - 72;
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::SyncCommit>::add(_anonymous_namespace_ *this, long long *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::SyncCommit>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = (_OWORD *)(*((void *)this + 4) + 72 * v4);
  long long v6 = *a2;
  *(_OWORD *)((char *)v5 + 13) = *(long long *)((char *)a2 + 13);
  *uint64_t v5 = v6;
  uint64_t result = re::DynamicArray<re::internal::SyncSnapshotEntry>::DynamicArray((uint64_t)(v5 + 2), (uint64_t *)a2 + 4);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t RESyncCommitListAddNewCommit(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v4 = 0;
    memset(v3, 0, sizeof(v3));
    memset(v2, 0, sizeof(v2));
    re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)(result + 24), (uint64_t)v2);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v3);
    return *(void *)(v1 + 56) + 72 * *(void *)(v1 + 40) - 72;
  }
  return result;
}

void re::DynamicArray<re::SyncCommit>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::SyncCommit>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  re::SyncCommit::SyncCommit(*((void *)this + 4) + 72 * v4, a2);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
}

uint64_t RESyncCommitListClear(uint64_t result)
{
  if (result) {
    return re::DynamicArray<re::SyncCommit>::clear(result + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::SyncCommit>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 72 * v2;
    uint64_t v4 = *(void *)(result + 32) + 32;
    do
    {
      uint64_t result = re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit(v4);
      v4 += 72;
      v3 -= 72;
    }
    while (v3);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

unsigned char *RESyncCommitIsAtomic(unsigned char *result)
{
  if (result) {
    return (unsigned char *)(*result & 1);
  }
  return result;
}

uint64_t RESyncCommitCaptureSnapshot(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      unint64_t v9 = (void *)(a1 + 32);
      unint64_t v16 = (re::SyncObject *)a2;
      unint64_t v10 = a2 + 1;
      uint64_t v11 = re::SyncSnapshot::writeObject(v9, &v16);
      uint64_t v13 = v12;

      uint64_t v14 = *(void *)(*(void *)(a2[11] + 16) + 88);
      *(unsigned char *)(v11 + 16) |= 8u;
      uint64_t result = (*(uint64_t (**)(void))(v14 + 16))();
      if (a5)
      {
        if (result)
        {
          *(unsigned char *)(v11 + 16) |= 8u;
          LODWORD(v15) = *(_DWORD *)(v13 + 24);
          if (*(_DWORD *)(v13 + 28)) {
            uint64_t v15 = (v15 + 1);
          }
          else {
            uint64_t v15 = v15;
          }
          *a5 = v15;
          return 1;
        }
      }
    }
  }
  return result;
}

BOOL RESyncCommitMarkDestroyed(uint64_t a1, uint64_t a2)
{
  BOOL v2 = 0;
  if (a1 && a2)
  {
    uint64_t v3 = (void *)(a1 + 32);
    uint64_t v7 = (re::SyncObject *)a2;
    uint64_t v4 = (void *)(a2 + 8);
    id v5 = (id)(a2 + 8);
    BOOL v2 = re::SyncSnapshot::writeDestroyedObject(v3, &v7);
  }
  return v2;
}

uint64_t RESyncCommitEnumerateForRead(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 48))
    {
      unint64_t v5 = 0;
      LODWORD(v2) = 1;
      do
      {
        v8[0] = re::SyncSnapshot::readAt((re::SyncSnapshot *)(a1 + 32), v5);
        v8[1] = v6;
        uint64_t v2 = v2 & (*(unsigned int (**)(uint64_t, void *))(a2 + 16))(a2, v8);
        ++v5;
      }
      while (v5 < *(void *)(a1 + 48));
    }
    else
    {
      return 1;
    }
  }
  return v2;
}

uint64_t RESyncCommitSetForwarded(uint64_t result)
{
  if (result) {
    *(unsigned char *)(result + 28) = 1;
  }
  return result;
}

uint64_t RESyncCommitGetSourcePeerID(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t RESyncCommitHoldWithID(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(unsigned char *)result |= 2u;
    *(void *)(result + 16) = a2;
  }
  return result;
}

uint64_t RESyncCommitUnhold(uint64_t result)
{
  if (result)
  {
    *(unsigned char *)result &= ~2u;
    *(void *)(result + 16) = 0;
  }
  return result;
}

uint64_t RESyncGenerateHoldID()
{
  uuid_generate_random((unsigned __int8 *)v1);
  return (v1[1] + (v1[0] << 6) + (v1[0] >> 2) - 0x61C8864680B583E9) ^ v1[0];
}

uint64_t re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 24 * v4;
        do
        {
          if (*(void *)v3)
          {

            *(void *)uint64_t v3 = 0;
          }
          v3 += 24;
          v5 -= 24;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::SyncCommitList::~SyncCommitList(re::SyncCommitList *this)
{
  *(void *)this = &unk_26DD34548;
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 24);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD34548;
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 24);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::DynamicArray<re::SyncCommit>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 72 * v4;
        uint64_t v6 = v3 + 32;
        do
        {
          re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit(v6);
          v6 += 72;
          v5 -= 72;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::SyncCommit>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::SyncCommit>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SyncCommit>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::SyncCommit>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::SyncCommit>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x48uLL))
        {
          uint64_t v2 = 72 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 72 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 72, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 72 * v9;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          re::SyncCommit::SyncCommit(v11, v8);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit(v8 + 32);
          v8 += 72;
          v11 += 72;
          v10 -= 72;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

__n128 re::SyncCommit::SyncCommit(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 13) = *(_OWORD *)(a2 + 13);
  *(__n128 *)a1 = result;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  uint64_t v3 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v3;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v4;
  uint64_t v5 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v5;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(a1 + 56);
  return result;
}

uint64_t re::DynamicArray<re::internal::SyncSnapshotEntry>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::internal::SyncSnapshotEntry>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(a1, *(void *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 24 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = (uint64_t *)(v9 + 24 * v4);
      uint64_t v11 = 3 * v8;
      uint64_t v12 = (uint64_t *)(v9 + 8 * v11);
      uint64_t v13 = a1[4] + 8 * v11;
      do
      {
        uint64_t v14 = *v12;
        *(void *)uint64_t v13 = *v12;
        if (v14) {
          id v15 = (id)(v14 + 8);
        }
        uint64_t v16 = v12[1];
        *(unsigned char *)(v13 + 16) = *((unsigned char *)v12 + 16);
        *(void *)(v13 + 8) = v16;
        v12 += 3;
        v13 += 24;
      }
      while (v12 != v10);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 24 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4] + 24 * v4;
      uint64_t v7 = 24 * v5 - 24 * v4;
      do
      {
        if (*(void *)v6)
        {

          *(void *)uint64_t v6 = 0;
        }
        v6 += 24;
        v7 -= 24;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x18uLL))
        {
          uint64_t v2 = 24 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 24 * v9;
        uint64_t v11 = v7;
        do
        {
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v12 = *(void *)(v8 + 8);
          *((unsigned char *)v11 + 16) = *(unsigned char *)(v8 + 16);
          v11[1] = v12;
          if (*(void *)v8)
          {

            *(void *)uint64_t v8 = 0;
          }
          v8 += 24;
          v11 += 3;
          v10 -= 24;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,re::internal::SyncSnapshotEntry *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    re::SharedPtr<re::SyncObject>::reset((uint64_t *)a3, *(void *)v4);
    uint64_t v6 = *(void *)(v4 + 8);
    *(unsigned char *)(a3 + 16) = *(unsigned char *)(v4 + 16);
    *(void *)(a3 + 8) = v6;
    a3 += 24;
    v4 += 24;
  }
  while (v4 != v5);
  return v5;
}

void re::SharedPtr<re::SyncObject>::reset(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (*a1 != a2)
  {
    if (a2)
    {
      id v5 = (id)(a2 + 8);
      uint64_t v2 = *a1;
    }
    if (v2) {

    }
    *a1 = a2;
  }
}

uint64_t RESyncSessionSend(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a1) {
    BOOL v4 = a2 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  BOOL v5 = v4 || a3 == 0;
  int v6 = v5;
  if (!v5)
  {
    if (a4)
    {
      uint64_t v7 = 0;
    }
    else
    {
      a1 = MEMORY[0x270FA5388]();
      uint64_t v7 = (uint64_t *)v9;
      long long v10 = 0u;
      uint64_t v11 = 0;
      memset(v9, 0, sizeof(v9));
      a4 = (uint64_t *)v9;
      HIDWORD(v10) = 0x7FFFFFFF;
    }
    *a4 = a1;
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 88))(a2, *(void *)(a3 + 56), *(void *)(a3 + 40));
    if (v7) {
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v7 + 5);
    }
  }
  return v6 ^ 1u;
}

uint64_t RESyncSessionSendRaw(re *a1, re *this, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v8 = 136315394;
    uint64_t v9 = "RESyncSessionSendRaw";
    __int16 v10 = 2080;
    uint64_t v11 = "service != __null";
LABEL_16:
    _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v8, 0x16u);
    return 0;
  }
  if (!this)
  {
    uint64_t v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v8 = 136315394;
    uint64_t v9 = "RESyncSessionSendRaw";
    __int16 v10 = 2080;
    uint64_t v11 = "session != __null";
    goto LABEL_16;
  }
  if (!a3)
  {
    uint64_t v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v8 = 136315394;
    uint64_t v9 = "RESyncSessionSendRaw";
    __int16 v10 = 2080;
    uint64_t v11 = "peerID != kRESyncInvalidPeerID";
    goto LABEL_16;
  }
  if (!a4)
  {
    uint64_t v7 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = 136315394;
      uint64_t v9 = "RESyncSessionSendRaw";
      __int16 v10 = 2080;
      uint64_t v11 = "data != __null";
      goto LABEL_16;
    }
    return 0;
  }
  BOOL v5 = *(uint64_t (**)(re *, uint64_t, uint64_t, uint64_t))(*(void *)this + 96);
  return v5(this, a3, a4, a5);
}

BOOL RESyncSessionSendAll(re *a1, uint64_t a2, re **a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v13 = *re::networkLogObjects(0);
    BOOL result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    unint64_t v18 = "RESyncSessionSendAll";
    __int16 v19 = 2080;
    unint64_t v20 = "service != __null";
    goto LABEL_19;
  }
  if (!a2)
  {
    uint64_t v13 = *re::networkLogObjects(a1);
    BOOL result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    unint64_t v18 = "RESyncSessionSendAll";
    __int16 v19 = 2080;
    unint64_t v20 = "commits != __null";
LABEL_19:
    _os_log_error_impl(&dword_228C70000, v13, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return 0;
  }
  BOOL v4 = a3;
  if (a3)
  {
    BOOL v5 = 0;
  }
  else
  {
    a1 = (re *)MEMORY[0x270FA5388]();
    BOOL v5 = (uint64_t *)v14;
    long long v15 = 0u;
    uint64_t v16 = 0;
    memset(v14, 0, sizeof(v14));
    BOOL v4 = (re **)v14;
    HIDWORD(v15) = 0x7FFFFFFF;
  }
  *BOOL v4 = a1;
  uint64_t v6 = (*(uint64_t (**)(re *))(*(void *)a1 + 128))(a1);
  if (v7)
  {
    int v8 = (uint64_t *)v6;
    uint64_t v9 = 8 * v7;
    do
    {
      uint64_t v10 = *v8;
      if (*v8) {
        id v11 = (id)(v10 + 8);
      }
      (*(void (**)(uint64_t, void, void, re **))(*(void *)v10 + 88))(v10, *(void *)(a2 + 56), *(void *)(a2 + 40), v4);

      ++v8;
      v9 -= 8;
    }
    while (v9);
  }
  if (v5) {
    re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v5 + 5);
  }
  return 1;
}

BOOL RESyncSessionReceive(re *a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v6 = *re::networkLogObjects(0);
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v10 = "RESyncSessionReceive";
    __int16 v11 = 2080;
    uint64_t v12 = "service != __null";
    goto LABEL_17;
  }
  if (!a2)
  {
    uint64_t v6 = *re::networkLogObjects(a1);
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v10 = "RESyncSessionReceive";
    __int16 v11 = 2080;
    uint64_t v12 = "session != __null";
    goto LABEL_17;
  }
  if (!a4)
  {
    uint64_t v6 = *re::networkLogObjects(a1);
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v10 = "RESyncSessionReceive";
    __int16 v11 = 2080;
    uint64_t v12 = "handler != __null";
LABEL_17:
    _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return 0;
  }
  if (a3)
  {
    BOOL v4 = 0;
  }
  else
  {
    MEMORY[0x270FA5388]();
    BOOL v4 = (uint64_t *)v7;
    long long v8 = 0u;
    memset(v7, 0, sizeof(v7));
    DWORD1(v8) = 0x7FFFFFFF;
    a3 = v7;
  }
  (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a2 + 72))(a2, a4, a3);
  if (v4) {
    re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v4 + 4);
  }
  return 1;
}

uint64_t RESyncSessionReceiveRaw(re *a1, re *this, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    BOOL v5 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315394;
      uint64_t v7 = "RESyncSessionReceiveRaw";
      __int16 v8 = 2080;
      uint64_t v9 = "service != __null";
      goto LABEL_14;
    }
    return 0;
  }
  if (!this)
  {
    BOOL v5 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315394;
      uint64_t v7 = "RESyncSessionReceiveRaw";
      __int16 v8 = 2080;
      uint64_t v9 = "session != __null";
      goto LABEL_14;
    }
    return 0;
  }
  if (!a3)
  {
    BOOL v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v6 = 136315394;
    uint64_t v7 = "RESyncSessionReceiveRaw";
    __int16 v8 = 2080;
    uint64_t v9 = "handler != __null";
LABEL_14:
    _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(re *, uint64_t))(*(void *)this + 80);
  return v3(this, a3);
}

uint64_t RESyncSessionReceiveAll(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (a1) {
    BOOL v3 = a3 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  uint64_t v4 = !v3;
  if (!v3)
  {
    int v6 = a2;
    if (a2)
    {
      uint64_t v7 = 0;
    }
    else
    {
      a1 = MEMORY[0x270FA5388]();
      int v6 = v15;
      long long v16 = 0u;
      memset(v15, 0, sizeof(v15));
      DWORD1(v16) = 0x7FFFFFFF;
      uint64_t v7 = (uint64_t *)v15;
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 128))(a1);
    if (v9)
    {
      uint64_t v10 = (uint64_t *)v8;
      uint64_t v11 = 8 * v9;
      do
      {
        uint64_t v12 = *v10;
        if (*v10) {
          id v13 = (id)(v12 + 8);
        }
        (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v12 + 72))(v12, a3, v6);

        ++v10;
        v11 -= 8;
      }
      while (v11);
    }
    if (v7) {
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v7 + 4);
    }
  }
  return v4;
}

uint64_t RESyncSessionSetViewFilterCB(uint64_t a1, uint64_t a2)
{
  if (a1) {
    BOOL v2 = a2 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  uint64_t v3 = !v2;
  if (!v2) {
    (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  }
  return v3;
}

uint64_t RESyncSessionHasViewFilterCB(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 56))(result) != 0;
  }
  return result;
}

uint64_t RESyncSessionGetNetSession(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 32))(&v3);
  uint64_t v1 = v3;
  if (v3) {

  }
  return v1;
}

uint64_t RESyncSessionIsPrivileged(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 32))(&v4, a1);
    if (v4)
    {
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v1 + 32))(&v3, v1);
      uint64_t v1 = *(unsigned char *)(v3 + 2218) != 0;

      if (v4) {
    }
      }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t RESyncSessionIsLocal(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 32))(&v4, a1);
    if (v4)
    {
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v1 + 32))(&v3, v1);
      uint64_t v1 = *(unsigned char *)(v3 + 2219) != 0;

      if (v4) {
    }
      }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t RESyncSessionPausePeer(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 120))();
  }
  return result;
}

uint64_t RESyncSessionResumePeer(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 128))();
  }
  return result;
}

double re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 32 * v3;
      do
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 32;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

re::SyncViewManager *re::SyncViewManager::SyncViewManager(re::SyncViewManager *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD34590;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_DWORD *)this + 22) = 0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 0;
  *(void *)((char *)this + 148) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_DWORD *)this + 48) = 0;
  *(void *)((char *)this + 196) = 0x7FFFFFFFLL;
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)this + 3, 0);
  ++*((_DWORD *)this + 12);
  return this;
}

void re::SyncViewManager::~SyncViewManager(re::SyncViewManager *this)
{
  *(void *)this = &unk_26DD34590;
  while (*((_DWORD *)this + 47))
  {
    uint64_t v2 = *((unsigned int *)this + 48);
    uint64_t v3 = *((void *)this + 22);
    uint64_t v4 = 0;
    if (v2)
    {
      uint64_t v5 = (int *)(v3 + 8);
      while (1)
      {
        int v6 = *v5;
        v5 += 6;
        if (v6 < 0) {
          break;
        }
        if (v2 == ++v4)
        {
          LODWORD(v4) = *((_DWORD *)this + 48);
          break;
        }
      }
    }
    int v7 = *(re::SyncViewer **)(v3 + 24 * v4 + 16);
    uint64_t v8 = (re *)re::SyncViewManager::removeViewer(this, v7, 1);
    if (v7)
    {
      uint64_t v9 = re::globalAllocators(v8)[2];
      (**(void (***)(re::SyncViewer *))v7)(v7);
      (*(void (**)(uint64_t, re::SyncViewer *))(*(void *)v9 + 40))(v9, v7);
    }
  }
  while (*((_DWORD *)this + 35))
  {
    uint64_t v10 = *((unsigned int *)this + 36);
    uint64_t v11 = *((void *)this + 16);
    uint64_t v12 = 0;
    if (v10)
    {
      id v13 = (int *)(v11 + 8);
      while (1)
      {
        int v14 = *v13;
        v13 += 6;
        if (v14 < 0) {
          break;
        }
        if (v10 == ++v12)
        {
          LODWORD(v12) = *((_DWORD *)this + 36);
          break;
        }
      }
    }
    re::SyncViewManager::removeView((uint64_t)this, *(void *)(v11 + 24 * v12 + 16));
  }
  if (*((void *)this + 3)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 24);
  }
  re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)this + 20);
  v15.n128_f64[0] = re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 14);
  if (*((void *)this + 3)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 24);
  }
  uint64_t v16 = *((void *)this + 8);
  if (v16)
  {
    if (*((void *)this + 12)) {
      (*(void (**)(uint64_t, __n128))(*(void *)v16 + 40))(v16, v15);
    }
    *((void *)this + 12) = 0;
    *((void *)this + 9) = 0;
    *((void *)this + 10) = 0;
    *((void *)this + 8) = 0;
    ++*((_DWORD *)this + 22);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 24);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::SyncViewManager::~SyncViewManager(this);
  JUMPOUT(0x22A6A9430);
}

void re::SyncViewManager::addView(re::SyncViewManager *this, re::SyncView *a2)
{
  uint64_t v3 = (char *)this + 112;
  uint64_t v5 = a2;
  if (a2) {
    uint64_t v4 = (char *)a2 + 8;
  }
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addNew((uint64_t)v3, (uint64_t *)&v5);
  if (v5) {

  }
  re::Event<re::SyncViewManager,re::SyncView *>::raise((uint64_t)this + 24, (uint64_t)this);
}

uint64_t re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addNew(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addAsMove(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

void re::Event<re::SyncViewManager,re::SyncView *>::raise(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3) {
    re::Event<re::SyncViewManager,re::SyncView *>::doDeferredActions((_anonymous_namespace_ *)a1);
  }
}

void re::SyncViewManager::removeView(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 112;
  uint64_t v4 = a2;
  if (a2) {
    id v3 = (id)(a2 + 8);
  }
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove(v2, &v4);
  if (v4) {
}
  }

uint64_t re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31)) % v2;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(v7 + 4 * v6);
  if (v8 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  if (*(void *)(v10 + 24 * v8 + 16) != v4)
  {
    while (1)
    {
      unsigned int v11 = v8;
      int v12 = *(_DWORD *)(v10 + 24 * v8 + 8);
      uint64_t v8 = v12 & 0x7FFFFFFF;
      if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        return 0;
      }
      if (*(void *)(v10 + 24 * v8 + 16) == v4)
      {
        *(_DWORD *)(v10 + 24 * v11 + 8) = *(_DWORD *)(v10 + 24 * v11 + 8) & 0x80000000 | *(_DWORD *)(v10 + 24 * v8 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v7 + 4 * v6) = *(_DWORD *)(v10 + 24 * v8 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v13 = *(void *)(a1 + 16);
  uint64_t v14 = v13 + 24 * v8;
  int v17 = *(_DWORD *)(v14 + 8);
  __n128 v15 = (int *)(v14 + 8);
  int v16 = v17;
  if (v17 < 0)
  {
    int *v15 = v16 & 0x7FFFFFFF;
    uint64_t v18 = v13 + 24 * v8;
    uint64_t v21 = *(void *)(v18 + 16);
    unint64_t v20 = (void *)(v18 + 16);
    uint64_t v19 = v21;
    if (v21)
    {

      *unint64_t v20 = 0;
    }
  }
  uint64_t v22 = *(void *)(a1 + 16) + 24 * v8;
  int v23 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v22 + 8) = *(_DWORD *)(v22 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v8;
  *(_DWORD *)(a1 + 40) = v23 + 1;
  return 1;
}

uint64_t re::SyncViewManager::forEachView(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 144);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (int *)(*(void *)(result + 128) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 6;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(result + 144);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    do
    {
      uint64_t v11 = *(void *)(*(void *)(v3 + 128) + 24 * v8 + 16);
      double result = (*(uint64_t (**)(void, uint64_t *))(**(void **)(a2 + 32) + 16))(*(void *)(a2 + 32), &v11);
      if (*(_DWORD *)(v3 + 144) <= (v5 + 1)) {
        int v9 = v5 + 1;
      }
      else {
        int v9 = *(_DWORD *)(v3 + 144);
      }
      int v10 = v5;
      while (1)
      {
        uint64_t v8 = (v10 + 1);
        if (v9 - 1 == v10) {
          break;
        }
        ++v10;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(*(void *)(v3 + 128) + 24 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v5) = v9;
LABEL_17:
      ;
    }
    while (v4 != v5);
  }
  return result;
}

uint64_t re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addNew(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::SyncViewManager::removeViewer(re::SyncViewManager *this, re::SyncViewer *a2, int a3)
{
  uint64_t v19 = a2;
  uint64_t v6 = *((unsigned int *)this + 36);
  if (v6)
  {
    uint64_t v7 = 0;
    unint64_t v8 = (int *)(*((void *)this + 16) + 8);
    while (1)
    {
      int v9 = *v8;
      v8 += 6;
      if (v9 < 0) {
        break;
      }
      if (v6 == ++v7)
      {
        LODWORD(v7) = *((_DWORD *)this + 36);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if (v6 != v7)
  {
    uint64_t v10 = v7;
    do
    {
      uint64_t v11 = *(re::SyncView **)(*((void *)this + 16) + 24 * v10 + 16);
      uint64_t v12 = *((void *)v11 + 15);
      uint64_t v13 = *((void *)v11 + 13);
      if (v13)
      {
        uint64_t v14 = 8 * v13;
        __n128 v15 = (re::SyncViewer **)*((void *)v11 + 15);
        while (*v15 != a2)
        {
          ++v15;
          v14 -= 8;
          if (!v14)
          {
            __n128 v15 = (re::SyncViewer **)(v12 + 8 * v13);
            break;
          }
        }
      }
      else
      {
        __n128 v15 = (re::SyncViewer **)*((void *)v11 + 15);
      }
      if (v13 != ((uint64_t)v15 - v12) >> 3)
      {
        if (a3) {
          re::SyncView::removeViewer((uint64_t)v11, a2);
        }
        else {
          re::SyncView::removeFromViewersWithoutNotifying(v11, a2);
        }
      }
      if (*((_DWORD *)this + 36) <= (v7 + 1)) {
        int v16 = v7 + 1;
      }
      else {
        int v16 = *((_DWORD *)this + 36);
      }
      while (1)
      {
        uint64_t v10 = (v7 + 1);
        if (v16 - 1 == v7) {
          break;
        }
        LODWORD(v7) = v7 + 1;
        int v17 = v10;
        if ((*(_DWORD *)(*((void *)this + 16) + 24 * v10 + 8) & 0x80000000) != 0) {
          goto LABEL_26;
        }
      }
      int v17 = v16;
LABEL_26:
      LODWORD(v7) = v17;
    }
    while (v6 != v17);
  }
  return re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::remove((uint64_t)this + 160, (uint64_t *)&v19);
}

uint64_t re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31)) % v2;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (*(void *)(v9 + 24 * v7 + 16) != v3)
  {
    while (1)
    {
      unsigned int v10 = v7;
      LODWORD(v7) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
      if (v7 == 0x7FFFFFFF) {
        return 0;
      }
      if (*(void *)(v9 + 24 * v7 + 16) == v3)
      {
        *(_DWORD *)(v9 + 24 * v10 + 8) = *(_DWORD *)(v9 + 24 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = v11 + 24 * v7;
  int v15 = *(_DWORD *)(v12 + 8);
  uint64_t v14 = (int *)(v12 + 8);
  int v13 = v15;
  if (v15 < 0)
  {
    int *v14 = v13 & 0x7FFFFFFF;
    uint64_t v11 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v11 + 24 * v7 + 8);
  }
  int v16 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v11 + 24 * v7 + 8) = *(_DWORD *)(a1 + 36) | v13 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v16 + 1;
  return 1;
}

uint64_t re::SyncViewManager::forEachViewer(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 192);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (int *)(*(void *)(result + 176) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 6;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(result + 192);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    do
    {
      uint64_t v11 = *(void *)(*(void *)(v3 + 176) + 24 * v8 + 16);
      double result = (*(uint64_t (**)(void, uint64_t *))(**(void **)(a2 + 32) + 16))(*(void *)(a2 + 32), &v11);
      if (*(_DWORD *)(v3 + 192) <= (v5 + 1)) {
        int v9 = v5 + 1;
      }
      else {
        int v9 = *(_DWORD *)(v3 + 192);
      }
      int v10 = v5;
      while (1)
      {
        uint64_t v8 = (v10 + 1);
        if (v9 - 1 == v10) {
          break;
        }
        ++v10;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(*(void *)(v3 + 176) + 24 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v5) = v9;
LABEL_17:
      ;
    }
    while (v4 != v5);
  }
  return result;
}

double re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 24 * v3;
      do
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 24;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          uint64_t v8 = *(void *)(v6 + 16);
          if (v8)
          {

            *(void *)(v6 + 16) = 0;
            unint64_t v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 24;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void *re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          int v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 32 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            int v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 32 * v5[2]);
            double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        double result = (void *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      int v10 = *(_DWORD *)(a1 + 28);
      signed int v11 = 2 * v10;
      uint64_t v12 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v11) {
          BOOL v13 = v8 == v11;
        }
        else {
          BOOL v13 = 1;
        }
        if (!v13 && (v10 & 0x80000000) == 0)
        {
          memset(v26, 0, 36);
          *(void *)&v26[36] = 0x7FFFFFFFLL;
          re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v26, v12, v11);
          long long v14 = *(_OWORD *)v26;
          *(_OWORD *)unint64_t v26 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v14;
          uint64_t v15 = *(void *)&v26[16];
          uint64_t v16 = *(void *)(a1 + 16);
          *(void *)&v26[16] = v16;
          *(void *)(a1 + 16) = v15;
          long long v18 = *(_OWORD *)&v26[24];
          *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
          unsigned int v17 = *(_DWORD *)&v26[32];
          *(_OWORD *)(a1 + 24) = v18;
          uint64_t v19 = v17;
          if (v17)
          {
            uint64_t v20 = v16 + 16;
            do
            {
              if ((*(_DWORD *)(v20 - 8) & 0x80000000) != 0) {
                re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::addAsMove(a1, *(void *)(v20 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v20 - 16), v20, v20);
              }
              v20 += 24;
              --v19;
            }
            while (v19);
          }
          re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)v26);
        }
      }
      else
      {
        if (v11) {
          signed int v23 = v11;
        }
        else {
          signed int v23 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v21 = *(void *)(a1 + 16);
    int v22 = *(_DWORD *)(v21 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v21 = *(void *)(a1 + 16);
    int v22 = *(_DWORD *)(v21 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v22 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v21 + 24 * v8 + 8) = v22 | 0x80000000;
  uint64_t v24 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(v24 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *a5 = 0;
  *(_DWORD *)(v24 + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    long long v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

void *re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(void *result, unint64_t a2)
{
  unint64_t v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v3 = result;
  uint64_t v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    uint64_t v5 = result[4];
    double result = (void *)(v5 + 32 * a2);
    unint64_t v6 = (char *)(v5 + 32 * v2);
    if (v6 != (char *)(result + 4))
    {
      double result = memmove(result, result + 4, v6 - (char *)(result + 4));
      uint64_t v4 = v3[2] - 1;
    }
  }
  _OWORD v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void re::Event<re::SyncViewManager,re::SyncView *>::doDeferredActions(_anonymous_namespace_ *a1)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v1 = *((void *)a1 + 7);
  if (v1)
  {
    uint64_t v3 = 0;
    for (unint64_t i = 0; i != v1; ++i)
    {
      unint64_t v5 = *((void *)a1 + 7);
      if (v5 <= i)
      {
        memset(v19, 0, sizeof(v19));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v11 = 136315906;
        uint64_t v12 = "operator[]";
        __int16 v13 = 1024;
        int v14 = 789;
        __int16 v15 = 2048;
        unint64_t v16 = i;
        __int16 v17 = 2048;
        unint64_t v18 = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v6 = *((void *)a1 + 9) + v3;
      uint64_t v7 = *(void *)(v6 + 32);
      long long v8 = *(_OWORD *)(v6 + 16);
      v9[0] = *(_OWORD *)v6;
      v9[1] = v8;
      uint64_t v10 = v7;
      if (LOBYTE(v9[0]))
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, (void *)v9 + 1, (uint64_t)v19);
        if (!LOBYTE(v19[0])) {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(a1, (uint64_t)v9 + 8);
        }
      }
      else
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable(a1, (void *)v9 + 1);
      }
      v3 += 40;
    }
  }
}

__n128 re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  unint64_t v5 = (_OWORD *)(*((void *)this + 4) + 32 * v4);
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  *unint64_t v5 = *(_OWORD *)a2;
  v5[1] = v7;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

BOOL re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable(void *a1, void *a2)
{
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, a2, (uint64_t)v5);
  int v3 = v5[0];
  if (v5[0]) {
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(a1, v6);
  }
  return v3 != 0;
}

uint64_t re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf@<X0>(uint64_t result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 32);
  uint64_t v4 = *(void *)(result + 16);
  if (v4)
  {
    uint64_t v5 = 32 * v4;
    unint64_t v6 = *(void **)(result + 32);
    while (1)
    {
      if (*v6 == *a2)
      {
        __n128 result = a2[2];
        if (v6[1] == a2[1] && v6[2] == result) {
          break;
        }
      }
      v6 += 4;
      v5 -= 32;
      if (!v5)
      {
        unint64_t v6 = (void *)(v3 + 32 * v4);
        break;
      }
    }
  }
  else
  {
    unint64_t v6 = *(void **)(result + 32);
  }
  uint64_t v8 = ((uint64_t)v6 - v3) >> 5;
  if (v8 == v4)
  {
    char v9 = 0;
  }
  else
  {
    *(void *)(a3 + 8) = v8;
    char v9 = 1;
  }
  *(unsigned char *)a3 = v9;
  return result;
}

void *re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)int v22 = v5;
      *(void *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        __int16 v13 = (void *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            unint64_t v14 = *(v13 - 2);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 24 * v17) = v14;
            *(void *)(*(void *)(a1 + 16) + 24 * v17 + 16) = *v13;
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

uint64_t re::UnicastStream::UnicastStream(uint64_t a1, id *a2, uint64_t a3, int a4, char a5, uint64_t a6, const void *a7)
{
  id to = 0;
  objc_copyWeak(&to, a2);
  re::TransportStream::TransportStream((_anonymous_namespace_ *)a1, &to, a3, a6);
  objc_destroyWeak(&to);
  id to = 0;
  *(void *)a1 = &unk_26DD345D8;
  *(void *)(a1 + 24) = &unk_26DD34630;
  *(_DWORD *)(a1 + 56) = a4;
  *(unsigned char *)(a1 + 60) = a5;
  re::PacketQueue::PacketQueue((re::PacketQueue *)(a1 + 64));
  *(void *)(a1 + 104) = _Block_copy(a7);
  return a1;
}

void re::UnicastStream::~UnicastStream(re::UnicastStream *this)
{
  *(void *)this = &unk_26DD345D8;
  *((void *)this + 3) = &unk_26DD34630;
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = re::PacketQueue::dequeue((re::UnicastStream *)((char *)this + 64));
    if (v3)
    {
      uint64_t v4 = (re::Packet *)v3;
      do
      {
        re::PacketPool::free(*(re::PacketPool **)(v2 + 376), v4);
        uint64_t v4 = (re::Packet *)re::PacketQueue::dequeue((re::UnicastStream *)((char *)this + 64));
      }
      while (v4);
    }
  }
  _Block_release(*((const void **)this + 13));
  *((void *)this + 13) = 0;
  re::PacketQueue::~PacketQueue((re::UnicastStream *)((char *)this + 64));
  re::TransportStream::~TransportStream(this);
}

{
  uint64_t vars8;

  re::UnicastStream::~UnicastStream(this);
  JUMPOUT(0x22A6A9430);
}

void non-virtual thunk to're::UnicastStream::~UnicastStream(re::UnicastStream *this)
{
}

{
  uint64_t vars8;

  re::UnicastStream::~UnicastStream((re::UnicastStream *)((char *)this - 24));
  JUMPOUT(0x22A6A9430);
}

char *re::UnicastStream::createPacket(re::UnicastStream *this, int a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    uint64_t v3 = (re::PacketPool **)(v2 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  return re::Transport::createMultiplexedPacket(v3, *((void *)this + 6), a2);
}

char *non-virtual thunk to're::UnicastStream::createPacket(re::UnicastStream *this, int a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    uint64_t v3 = (re::PacketPool **)(v2 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  return re::Transport::createMultiplexedPacket(v3, *((void *)this + 3), a2);
}

void re::UnicastStream::destroyPacket(re::UnicastStream *this, re::Packet *a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    uint64_t v3 = v2 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  re::PacketPool::free(*(re::PacketPool **)(v3 + 384), a2);
}

void non-virtual thunk to're::UnicastStream::destroyPacket(re::UnicastStream *this, re::Packet *a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    uint64_t v3 = v2 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  re::PacketPool::free(*(re::PacketPool **)(v3 + 384), a2);
}

uint64_t re::UnicastStream::send(re::UnicastStream *this, re::Packet *a2)
{
  uint64_t v3 = *((void *)this + 4);
  unint64_t v4 = *((void *)this + 5);
  if (v3) {
    uint64_t v5 = v3 - 8;
  }
  else {
    uint64_t v5 = 0;
  }
  int v6 = *((_DWORD *)this + 14);
  int v7 = *((unsigned __int8 *)this + 60);
  re::Packet::offsetTo((uint64_t)a2, 3);
  return re::Transport::send(v5, v4, (unint64_t)a2, 1u, v6, v7, 8);
}

uint64_t re::UnicastStream::receive(re::UnicastStream *this)
{
  return re::PacketQueue::dequeue((re::UnicastStream *)((char *)this + 64));
}

uint64_t re::SharedAppUnicast::SharedAppUnicast(uint64_t a1, id *a2, re *a3, uint64_t a4, uint64_t a5, uint64_t a6, id *a7, char a8, char a9)
{
  uint64_t v34 = a4;
  *(void *)a1 = 0;
  objc_copyWeak((id *)a1, a2);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a5;
  *(void *)(a1 + 24) = a6;
  *(void *)(a1 + 32) = 0;
  objc_copyWeak((id *)(a1 + 32), a7);
  *(unsigned char *)(a1 + 40) = a8;
  *(unsigned char *)(a1 + 41) = a9;
  *(_WORD *)(a1 + 42) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)(a1 + 84) = 0x7FFFFFFFLL;
  *(void *)(a1 + 96) = 0x8000000000000000;
  int v32 = 0;
  char v31 = 1;
  unsigned int v30 = 1;
  v28[0] = MEMORY[0x263EF8330];
  v28[1] = 0x40000000;
  v28[2] = ___ZN2re16SharedAppUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbb_block_invoke;
  v28[3] = &__block_descriptor_tmp;
  v28[4] = a1;
  long long v29 = v28;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},void({block_pointer})(unsigned long long)>(a3, &v34, &v32, &v31, &v30, (const void **)&v29, (uint64_t *)&v33);
  unint64_t v16 = v33;
  uint64_t v17 = v34;
  if (*(void *)a3) {
    int v18 = (re::Transport *)(*(void *)a3 - 8);
  }
  else {
    int v18 = 0;
  }
  WeakRetained = (char *)objc_loadWeakRetained(a2);
  if (WeakRetained) {
    int v20 = WeakRetained - 8;
  }
  else {
    int v20 = 0;
  }
  (*(void (**)(re::Packet **__return_ptr, char *))(*(void *)v20 + 32))(&v33, v20);
  BOOL v21 = re::Transport::registerStream(v18, v16, 1uLL, v17);
  if (v33)
  {

    v33 = 0;
  }

  if (v21)
  {
    int v22 = *(re::Packet **)(a1 + 8);
    *(void *)(a1 + 8) = v16;
    unint64_t v16 = v22;
  }
  v33 = 0;
  if (*(void *)a3) {
    uint64_t v23 = *(void *)a3 - 8;
  }
  else {
    uint64_t v23 = 0;
  }
  if (re::Transport::receive(v23, v34, 1u, (uint64_t *)&v33))
  {
    do
    {
      if (*(void *)a3) {
        uint64_t v24 = (re::Transport *)(*(void *)a3 - 8);
      }
      else {
        uint64_t v24 = 0;
      }
      if (re::Transport::dispatchPacketToStream(v24, v33, v34))
      {
        if (*(void *)a3) {
          uint64_t v25 = *(void *)a3 - 8;
        }
        else {
          uint64_t v25 = 0;
        }
        re::PacketPool::free(*(re::PacketPool **)(v25 + 384), v33);
      }
      if (*(void *)a3) {
        uint64_t v26 = *(void *)a3 - 8;
      }
      else {
        uint64_t v26 = 0;
      }
    }
    while (re::Transport::receive(v26, v34, 1u, (uint64_t *)&v33));
  }
  if (v16) {

  }
  return a1;
}

uint64_t ___ZN2re16SharedAppUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbb_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 43) = 1;
  return result;
}

BOOL re::SharedAppUnicast::shouldForward(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(*a2 + 80);
  if (v3)
  {
    do
    {
      uint64_t v4 = v2;
      uint64_t v2 = v3;
      if (*(unsigned char *)(*(void *)(*(void *)(v4 + 88) + 16) + 73)) {
        break;
      }
      uint64_t v3 = *(void *)(v3 + 80);
      uint64_t v4 = v2;
    }
    while (v3);
  }
  else
  {
    uint64_t v4 = *a2;
  }
  return *(unsigned char *)(v4 + 170) || *(unsigned char *)(a1 + 40) || *(unsigned char *)(a1 + 41) != 0;
}

void re::SharedAppUnicast::send(id *location, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v109 = *MEMORY[0x263EF8340];
  if (location[1])
  {
    re::SyncCommitDump::log(*(re **)a2, *(void *)(a2 + 8), "SendCommit");
    v103 = 0;
    v100[1] = 0;
    uint64_t v101 = 0;
    v100[0] = 0;
    int v102 = 0;
    long long v9 = *(re **)a2;
    uint64_t v10 = *(void *)(a2 + 8);
    if (*((unsigned char *)location + 42))
    {
      if (v10)
      {
        int v11 = (re *)((char *)v9 + 72 * v10);
        char v12 = 1;
        do
        {
          uint64_t v13 = *((void *)v9 + 6);
          if (v13)
          {
            uint64_t v14 = 24 * v13;
            unint64_t v15 = (unsigned char *)(*((void *)v9 + 8) + 16);
            do
            {
              unint64_t v16 = (uint64_t *)(v15 - 16);
              if ((*v15 & 2) != 0)
              {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace((uint64_t)(location + 6), v16, v15);
              }
              else
              {
                uint64_t v17 = (unsigned char *)re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add((uint64_t)(location + 6), v16, v15);
                if ((*v17 & 2) != 0) {
                  *uint64_t v17 = *v15;
                }
              }
              v15 += 24;
              v14 -= 24;
            }
            while (v14);
            char v12 = 0;
          }
          long long v9 = (re *)((char *)v9 + 72);
        }
        while (v9 != v11);
      }
      else
      {
        char v12 = 1;
      }
      if (std::chrono::steady_clock::now().__d_.__rep_ >= (uint64_t)location[12] && (v12 & 1) == 0)
      {
        v26.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        location[12] = (id)(v26.__d_.__rep_ + 5000000000);
        LODWORD(v88) = 0;
        long long v86 = 0u;
        long long v87 = 0u;
        *(void *)((char *)&v88 + 4) = 0x7FFFFFFFLL;
        uint64_t v27 = *(void *)(a2 + 8);
        if (v27)
        {
          unint64_t v28 = *(re **)a2;
          long long v29 = (re *)((char *)v28 + 72 * v27);
          do
          {
            uint64_t v30 = *((void *)v28 + 6);
            if (v30)
            {
              char v31 = (uint64_t *)*((void *)v28 + 8);
              uint64_t v32 = 24 * v30;
              do
              {
                uint64_t v33 = *v31;
                v31 += 3;
                v26.__d_.__rep_ = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&v86, (re::DynamicString *)(*(void *)(*(void *)(v33 + 88) + 16) + 40));
                v32 -= 24;
              }
              while (v32);
            }
            unint64_t v28 = (re *)((char *)v28 + 72);
          }
          while (v28 != v29);
        }
        unint64_t v97 = 0;
        v98 = 0;
        uint64_t v99 = 0;
        re::DynamicString::setCapacity(&v96, 0);
        int v34 = v88;
        if (v88)
        {
          uint64_t v35 = 0;
          v36 = (int *)(v87 + 8);
          while (1)
          {
            int v37 = *v36;
            v36 += 12;
            if (v37 < 0) {
              break;
            }
            if (v88 == ++v35)
            {
              LODWORD(v35) = v88;
              break;
            }
          }
        }
        else
        {
          LODWORD(v35) = 0;
        }
        if (v88 != v35)
        {
          uint64_t v38 = v35;
          uint64_t v39 = v87;
          do
          {
            uint64_t v40 = v39 + 48 * v38;
            unint64_t v41 = *(void *)(v40 + 24);
            v42 = *(const char **)(v40 + 32);
            v43 = (const char *)(v40 + 25);
            BOOL v44 = (v41 & 1) == 0;
            if (v41) {
              v45 = v42;
            }
            else {
              v45 = v43;
            }
            size_t v46 = v41 >> 1;
            size_t v47 = v41 >> 1;
            if (v44) {
              size_t v48 = v47;
            }
            else {
              size_t v48 = v46;
            }
            re::DynamicString::append((re::DynamicString *)&v96, v45, v48);
            re::DynamicString::append((re::DynamicString *)&v96, " ", 1uLL);
            uint64_t v39 = v87;
            if (v88 <= (int)v35 + 1) {
              int v49 = v35 + 1;
            }
            else {
              int v49 = v88;
            }
            int v50 = v35;
            while (1)
            {
              uint64_t v38 = (v50 + 1);
              if (v49 - 1 == v50) {
                break;
              }
              ++v50;
              LODWORD(v35) = v38;
              if ((*(_DWORD *)(v87 + 48 * v38 + 8) & 0x80000000) != 0) {
                goto LABEL_57;
              }
            }
            LODWORD(v35) = v49;
LABEL_57:
            ;
          }
          while (v34 != v35);
        }
        WeakRetained = (char *)objc_loadWeakRetained(location);
        if (WeakRetained) {
          v52 = WeakRetained - 8;
        }
        else {
          v52 = 0;
        }
        v53 = v52 + 8;
        (*(void (**)(unsigned char *__return_ptr))(*(void *)v52 + 32))(buf);
        v54 = *(NSObject **)(*(void *)buf + 3272);

        *(void *)buf = 0;
        if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
        {
          v55 = (char *)objc_loadWeakRetained(location);
          if (v55) {
            v56 = v55 - 8;
          }
          else {
            v56 = 0;
          }
          (*(void (**)(re::Session **__return_ptr, char *))(*(void *)v56 + 32))(&v95, v56);
          uint64_t v57 = re::Session::peerID(v95);
          v58 = location[1];
          uint64_t v59 = v58[4];
          if (v59) {
            v60 = (re::Transport *)(v59 - 8);
          }
          else {
            v60 = 0;
          }
          re::Transport::connectionAddress(v60, v58[5], (re::DynamicString *)&v91);
          if (v92) {
            v61 = v94;
          }
          else {
            v61 = v93;
          }
          if (v97) {
            v62 = v98;
          }
          else {
            v62 = (char *)&v97 + 1;
          }
          *(_DWORD *)buf = 134218498;
          *(void *)&uint8_t buf[4] = v57;
          __int16 v105 = 2080;
          v106 = v61;
          __int16 v107 = 2080;
          v108 = v62;
          _os_log_impl(&dword_228C70000, v54, OS_LOG_TYPE_INFO, "Sending sync data on paused connection to %llx ('%s'): %s", buf, 0x20u);
          if (v91 && (v92 & 1) != 0) {
            (*(void (**)(uint64_t, unsigned char *))(*(void *)v91 + 40))(v91, v94);
          }
          if (v95)
          {

            v95 = 0;
          }
        }
        if (v96)
        {
          if (v97) {
            (*(void (**)(uint64_t *, char *))(*v96 + 40))(v96, v98);
          }
        }
        re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v86);
      }
    }
    else
    {
      if (*((_DWORD *)location + 19))
      {
        uint64_t v22 = *(unsigned int *)(a4 + 96);
        if (v22)
        {
          uint64_t v23 = 0;
          uint64_t v24 = (int *)(*(void *)(a4 + 80) + 8);
          while (1)
          {
            int v25 = *v24;
            v24 += 8;
            if (v25 < 0) {
              break;
            }
            if (v22 == ++v23)
            {
              LODWORD(v23) = *(_DWORD *)(a4 + 96);
              break;
            }
          }
        }
        else
        {
          LODWORD(v23) = 0;
        }
        if (v22 != v23)
        {
          uint64_t v63 = v23;
          do
          {
            re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove((uint64_t)(location + 6), (uint64_t *)(*(void *)(a4 + 80) + 32 * v63 + 16));
            if (*(_DWORD *)(a4 + 96) <= (v23 + 1)) {
              int v64 = v23 + 1;
            }
            else {
              int v64 = *(_DWORD *)(a4 + 96);
            }
            int v65 = v23;
            while (1)
            {
              uint64_t v63 = (v65 + 1);
              if (v64 - 1 == v65) {
                break;
              }
              ++v65;
              LODWORD(v23) = v63;
              if ((*(_DWORD *)(*(void *)(a4 + 80) + 32 * v63 + 8) & 0x80000000) != 0) {
                goto LABEL_95;
              }
            }
            LODWORD(v23) = v64;
LABEL_95:
            ;
          }
          while (v22 != v23);
        }
        uint64_t v90 = 0;
        long long v88 = 0u;
        long long v89 = 0u;
        long long v86 = 0u;
        long long v87 = 0u;
        LOBYTE(v86) = 1;
        uint64_t v66 = *((unsigned int *)location + 20);
        if (v66)
        {
          uint64_t v67 = 0;
          v68 = (int *)((char *)location[8] + 8);
          while (1)
          {
            int v69 = *v68;
            v68 += 8;
            if (v69 < 0) {
              break;
            }
            if (v66 == ++v67)
            {
              LODWORD(v67) = *((_DWORD *)location + 20);
              break;
            }
          }
        }
        else
        {
          LODWORD(v67) = 0;
        }
        if (v66 != v67)
        {
          uint64_t v70 = v67;
          do
          {
            v71 = (char *)location[8] + 32 * v70;
            v74 = (uint64_t *)*((void *)v71 + 2);
            v73 = v71 + 16;
            v72 = v74;
            v96 = v74;
            if (v74) {
              v75 = v72 + 1;
            }
            unint64_t v97 = re::SyncObject::latestStateHandle(*(re::SyncObject **)v73);
            LOBYTE(v98) = v73[8];
            re::DynamicArray<re::internal::SyncSnapshotEntry>::add(&v88, (uint64_t)&v96);
            if (v96) {

            }
            if (*((_DWORD *)location + 20) <= (v67 + 1)) {
              int v76 = v67 + 1;
            }
            else {
              int v76 = *((_DWORD *)location + 20);
            }
            while (1)
            {
              uint64_t v70 = (v67 + 1);
              if (v76 - 1 == v67) {
                break;
              }
              LODWORD(v67) = v67 + 1;
              int v77 = v70;
              if ((*((_DWORD *)location[8] + 8 * v70 + 2) & 0x80000000) != 0) {
                goto LABEL_115;
              }
            }
            int v77 = v76;
LABEL_115:
            LODWORD(v67) = v77;
          }
          while (v66 != v77);
        }
        re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear((uint64_t)(location + 6));
        re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)v100, (uint64_t)&v86);
        uint64_t v78 = *(void *)(a2 + 8);
        if (v78)
        {
          v79 = *(re **)a2;
          uint64_t v80 = 72 * v78;
          do
          {
            re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)v100, (long long *)v79);
            v79 = (re *)((char *)v79 + 72);
            v80 -= 72;
          }
          while (v80);
        }
        long long v9 = v103;
        uint64_t v10 = v101;
        re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v88);
      }
      v81 = (char *)location[1] + 24;
      LODWORD(v87) = 0;
      BYTE4(v87) = 0;
      *((void *)&v87 + 1) = 0;
      *(void *)&long long v88 = 0;
      *(void *)&long long v86 = &unk_26DD352E8;
      *((void *)&v86 + 1) = 0;
      *((void *)&v88 + 1) = v81;
      *(void *)&long long v89 = 0;
      LOBYTE(v96) = 0;
      if (v10)
      {
        uint64_t v82 = 72 * v10;
        do
        {
          re::SharedAppSyncPacker::packCommit((unsigned __int8 *)&v96, (uint64_t)v9, (re::BitWriter *)&v86, a5, 0);
          long long v9 = (re *)((char *)v9 + 72);
          v82 -= 72;
        }
        while (v82);
        int v83 = DWORD2(v87);
        uint64_t v84 = v89;
        if (HIDWORD(v87)) {
          int v83 = DWORD2(v87) + 1;
        }
        if (v83)
        {
          id v85 = location[1];
          *(_DWORD *)(v89 + 24) = v83;
          *((void *)&v87 + 1) = 0;
          *(void *)&long long v88 = 0;
          *((void *)&v86 + 1) = 0;
          LODWORD(v87) = 0;
          *(void *)&long long v89 = 0;
          (*(void (**)(id))(*(void *)v85 + 48))(v85);
          uint64_t v84 = v89;
        }
        if (v84) {
          (*(void (**)(void))(**((void **)&v88 + 1) + 24))(*((void *)&v88 + 1));
        }
      }
    }
    re::DynamicArray<re::SyncCommit>::deinit((uint64_t)v100);
  }
  else
  {
    int v18 = (char *)objc_loadWeakRetained(location);
    if (v18) {
      uint64_t v19 = v18 - 8;
    }
    else {
      uint64_t v19 = 0;
    }
    int v20 = v19 + 8;
    (*(void (**)(long long *__return_ptr))(*(void *)v19 + 32))(&v86);
    BOOL v21 = *(NSObject **)(v86 + 3272);

    *(void *)&long long v86 = 0;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v86) = 0;
      _os_log_error_impl(&dword_228C70000, v21, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to send.", (uint8_t *)&v86, 2u);
    }
  }
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16);
    uint64_t v10 = v13;
    return v12 + 32 * v10 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  *(unsigned char *)(v11 + 32 * v10 + 24) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v12 = *(void *)(a1 + 16);
  return v12 + 32 * v10 + 24;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 32 * v10;
  return v12 + 24;
}

uint64_t re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(uint64_t a1, re::DynamicString *a2)
{
  unint64_t v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v13, (uint64_t)a2);
  unint64_t v5 = v4;
  unint64_t v6 = *(unsigned int *)(a1 + 24);
  if (!v6)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  unint64_t v7 = v4 % v6;
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % v6));
  if (v8 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v11 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, v7, v5, (int)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    return *(void *)(a1 + 16) + 48 * v11 + 16;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t v10 = v9 + 48 * v8 + 16;
    if (re::DynamicString::operator==(v10, (uint64_t)a2)) {
      return v10;
    }
    uint64_t v8 = *(_DWORD *)(v9 + 48 * v8 + 8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_228CDE530, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          uint64_t v8 = *(void *)(v6 + 16);
          if (v8)
          {

            *(void *)(v6 + 16) = 0;
            unint64_t v3 = *(unsigned int *)(a1 + 32);
          }
        }
        v4 += 32;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v9;
  }
}

BOOL re::SharedAppUnicast::receive(id *location, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = location;
  uint64_t v81 = *MEMORY[0x263EF8340];
  id v4 = location[1];
  if (v4)
  {
    if (*((unsigned char *)v3 + 43))
    {
      *((unsigned char *)v3 + 43) = 0;
      uint64_t v6 = (*(uint64_t (**)(id))(*(void *)v4 + 56))(v4);
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = v3 + 4;
        uint64_t v55 = a2;
        v56 = v3;
        while (1)
        {
          uint64_t v54 = v7;
          int v9 = *(_DWORD *)(v7 + 24);
          uint64_t v72 = *(void *)(v7 + 16);
          int v73 = v9;
          char v74 = 0;
          uint64_t v75 = 0;
          uint64_t v76 = 0;
          while (v73 != v75)
          {
            WeakRetained = (char *)objc_loadWeakRetained(v8);
            unsigned int v11 = WeakRetained - 8;
            if (!WeakRetained) {
              unsigned int v11 = 0;
            }
            __int16 v12 = *((_WORD *)v3 + 20);
            *(void *)int v65 = v11;
            long long v66 = *((_OWORD *)v3 + 1);
            long long v67 = 0u;
            long long v68 = 0u;
            unsigned int v69 = 0;
            uint64_t v70 = 0x7FFFFFFFLL;
            __int16 v71 = v12;
            if (WeakRetained) {

            }
            v59[0] = 0;
            uint64_t v64 = 0;
            memset(v62, 0, sizeof(v62));
            int v63 = 0;
            uint64_t v60 = 0;
            v61[0] = 0;
            *(void *)((char *)v61 + 5) = 0;
            int v13 = re::SharedAppSyncUnpacker::unpackCommit((_anonymous_namespace_ *)v65, (uint64_t)&v72, (uint64_t)v59, a2);
            int v14 = v13;
            if (!v13)
            {
              uint64_t v19 = v3[1];
              uint64_t v20 = v19[4];
              if (v20) {
                BOOL v21 = (re::Transport *)(v20 - 8);
              }
              else {
                BOOL v21 = 0;
              }
              re::Transport::connectionAddress(v21, v19[5], (re::DynamicString *)buf);
              uint64_t v22 = (char *)objc_loadWeakRetained(v3);
              if (v22) {
                uint64_t v23 = v22 - 8;
              }
              else {
                uint64_t v23 = 0;
              }
              uint64_t v24 = v23 + 8;
              (*(void (**)(unsigned char *__return_ptr))(*(void *)v23 + 32))(v77);
              int v25 = *(NSObject **)(*(void *)v77 + 3272);

              *(void *)int v77 = 0;
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              {
                id v47 = v3[2];
                size_t v48 = &buf[9];
                if (buf[8]) {
                  size_t v48 = *(unsigned char **)&buf[16];
                }
                *(_DWORD *)int v77 = 134218242;
                *(void *)&v77[4] = v47;
                __int16 v78 = 2082;
                v79 = v48;
                _os_log_error_impl(&dword_228C70000, v25, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s)", v77, 0x16u);
              }
              (*(void (**)(id, uint64_t))(*(void *)v3[1] + 40))(v3[1], v54);
              if (*(void *)buf && (buf[8] & 1) != 0) {
                (*(void (**)(void))(**(void **)buf + 40))();
              }
              goto LABEL_30;
            }
            int v58 = v13;
            unsigned int v15 = v69;
            if (v69)
            {
              uint64_t v16 = 0;
              uint64_t v17 = (int *)(v68 + 8);
              while (1)
              {
                int v18 = *v17;
                v17 += 10;
                if (v18 < 0) {
                  break;
                }
                if (v69 == ++v16)
                {
                  LODWORD(v16) = v69;
                  break;
                }
              }
            }
            else
            {
              LODWORD(v16) = 0;
            }
            if (v69 != v16)
            {
              uint64_t v26 = v16;
              uint64_t v27 = v68;
              while (1)
              {
                uint64_t v28 = v27 + 40 * v26;
                uint64_t v29 = *(void *)(v28 + 24);
                uint64_t v30 = *(void *)(v28 + 32);
                char v31 = (char *)objc_loadWeakRetained(v8);
                uint64_t v32 = v31;
                if (v31) {
                  uint64_t v33 = (re::SyncObjectStore *)(v31 - 8);
                }
                else {
                  uint64_t v33 = 0;
                }
                re::SyncObjectStore::findObject(v33, v29, v30, (re::SyncObjectTypedStore ***)v77);
                if (v32) {

                }
                int v34 = (re::SyncObject **)(v28 + 16);
                uint64_t v35 = *(void *)v77;
                if (*(void *)v77) {
                  break;
                }
                id v38 = objc_loadWeakRetained(v8);
                if (v38)
                {
                  uint64_t v39 = v38;
                  uint64_t v40 = (char *)objc_loadWeakRetained(v8);
                  unint64_t v41 = v40 - 8;
                  if (!v40) {
                    unint64_t v41 = 0;
                  }
                  uint64_t v42 = *(void *)(*(void *)(*((void *)*v34 + 11) + 16) + 32);
                  *(void *)buf = *((void *)*v34 + 3);
                  *(void *)&buf[8] = v42;
                  *(void *)&uint8_t buf[16] = 0;
                  BOOL v43 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v41 + 600), (uint64_t *)buf);
                  if (v40) {

                  }
                  if (!v43)
                  {
                    v45 = *re::networkLogObjects(v44);
                    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v46 = *((void *)*v34 + 3);
                      *(_DWORD *)buf = 134218240;
                      *(void *)&uint8_t buf[4] = v46;
                      *(_WORD *)&unsigned char buf[12] = 2048;
                      *(void *)&buf[14] = v30;
                      _os_log_error_impl(&dword_228C70000, v45, OS_LOG_TYPE_ERROR, "BindFailure: Object %llu with parent %llu", buf, 0x16u);
                    }
                  }
                  uint64_t v35 = *(void *)v77;
                  if (*(void *)v77) {
                    goto LABEL_40;
                  }
                }
LABEL_41:
                uint64_t v27 = v68;
                if (v69 <= (int)v16 + 1) {
                  unsigned int v36 = v16 + 1;
                }
                else {
                  unsigned int v36 = v69;
                }
                while (1)
                {
                  uint64_t v26 = (v16 + 1);
                  if (v36 - 1 == v16) {
                    break;
                  }
                  LODWORD(v16) = v16 + 1;
                  unsigned int v37 = v26;
                  if ((*(_DWORD *)(v68 + 40 * v26 + 8) & 0x80000000) != 0) {
                    goto LABEL_48;
                  }
                }
                unsigned int v37 = v36;
LABEL_48:
                LODWORD(v16) = v37;
                if (v15 == v37) {
                  goto LABEL_29;
                }
              }
              re::SyncObject::bindWithParent(*v34, *(re::SyncObject **)v77);
LABEL_40:

              goto LABEL_41;
            }
LABEL_29:
            re::SyncCommitDump::log((re *)v59, 1, "RecvCommit");
            a2 = v55;
            (*(void (**)(uint64_t, char *, uint64_t))(a3 + 16))(a3, v59, v55);
            unint64_t v3 = v56;
            int v14 = v58;
LABEL_30:
            re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v62);
            re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)&v67);
            if (!v14) {
              return 0;
            }
          }
          (*(void (**)(id, uint64_t))(*(void *)v3[1] + 40))(v3[1], v54);
          uint64_t v7 = (*(uint64_t (**)(id))(*(void *)v3[1] + 56))(v3[1]);
          BOOL result = 1;
          if (!v7) {
            return result;
          }
        }
      }
    }
    return 1;
  }
  else
  {
    int v50 = (char *)objc_loadWeakRetained(v3);
    if (v50) {
      v51 = v50 - 8;
    }
    else {
      v51 = 0;
    }
    v52 = v51 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v51 + 32))(v65);
    v53 = *(NSObject **)(*(void *)v65 + 3272);

    *(void *)int v65 = 0;
    BOOL result = os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)int v65 = 0;
      _os_log_error_impl(&dword_228C70000, v53, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to receive.", v65, 2u);
      return 0;
    }
  }
  return result;
}

double re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v5);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v5) = v7 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v6 + v5 + 8));
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        ++v4;
        v5 += 48;
      }
      while (v4 < v3);
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          uint64_t v8 = *(void *)(v6 + 16);
          if (v8)
          {

            *(void *)(v6 + 16) = 0;
            unint64_t v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 40;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},void({block_pointer})(unsigned long long)>(re *a1@<X0>, uint64_t *a2@<X1>, int *a3@<X2>, char *a4@<X3>, unsigned int *a5@<X4>, const void **a6@<X5>, uint64_t *a7@<X8>)
{
  int v14 = re::globalAllocators(a1);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14[2] + 32))(v14[2], 112, 8);
  id to = 0;
  objc_copyWeak(&to, (id *)a1);
  re::UnicastStream::UnicastStream(v15, &to, *a2, *a3, *a4, *a5, *a6);
  *a7 = v15;
  objc_destroyWeak(&to);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, unsigned char *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  uint64_t v14 = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  if (v14) {
    id v15 = (id)(v14 + 8);
  }
  *(unsigned char *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 24);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

double re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          uint64_t v8 = *(void *)(v6 + 16);
          if (v8)
          {

            *(void *)(v6 + 16) = 0;
            unint64_t v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 32;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, int a4, re::DynamicString *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 48 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 48 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 48 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 48 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 48 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 48 * v9) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 48 * v9 + 16), a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, (void *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 48;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 48 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 48 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 48 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 48 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 48 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 48 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 48 * v8) = a3;
  uint64_t v12 = *(void *)(a1 + 16) + 48 * v8;
  *(_OWORD *)(v12 + 16) = 0u;
  *(_OWORD *)(v12 + 32) = 0u;
  *(void *)(v12 + 40) = a5[3];
  uint64_t v13 = a5[1];
  *(void *)(v12 + 16) = *a5;
  *a5 = 0;
  uint64_t v14 = a5[2];
  a5[3] = 0;
  uint64_t v16 = *(void *)(v12 + 24);
  uint64_t v15 = *(void *)(v12 + 32);
  *(void *)(v12 + 24) = v13;
  *(void *)(v12 + 32) = v14;
  a5[1] = v16;
  a5[2] = v15;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = v9 + 32 * v7;
  if (*(void *)(v10 + 16) != v3)
  {
    while (1)
    {
      unsigned int v11 = v7;
      int v12 = *(_DWORD *)(v9 + 32 * v7 + 8);
      uint64_t v7 = v12 & 0x7FFFFFFF;
      if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        return 0;
      }
      uint64_t v13 = v9 + 32 * v7;
      if (*(void *)(v13 + 16) == v3)
      {
        *(_DWORD *)(v9 + 32 * v11 + 8) = *(_DWORD *)(v9 + 32 * v11 + 8) & 0x80000000 | *(_DWORD *)(v13 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v10 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v14 = *(void *)(a1 + 16) + 32 * v7;
  int v15 = *(_DWORD *)(v14 + 8);
  if (v15 < 0)
  {
    *(_DWORD *)(v14 + 8) = v15 & 0x7FFFFFFF;
    uint64_t v18 = *(void *)(v14 + 16);
    uint64_t v17 = (void *)(v14 + 16);
    uint64_t v16 = v18;
    if (v18)
    {

      *uint64_t v17 = 0;
    }
  }
  int v19 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v7 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v7 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v19 + 1;
  return 1;
}

uint64_t re::UnreliableAckedUnicastStream::UnreliableAckedUnicastStream(uint64_t a1, id *a2, uint64_t a3, char a4, uint64_t a5, const void *a6)
{
  id to = 0;
  objc_copyWeak(&to, a2);
  re::UnicastStream::UnicastStream(a1, &to, a3, 2, a4, a5, a6);
  objc_destroyWeak(&to);
  *(void *)a1 = &unk_26DD34678;
  *(void *)(a1 + 24) = &unk_26DD346D0;
  *(_WORD *)(a1 + 112) = 0;
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_WORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_WORD *)(a1 + 192) = 0;
  return a1;
}

char *re::UnreliableAckedUnicastStream::createPacket(re::UnreliableAckedUnicastStream *this, int a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    uint64_t v3 = (re::PacketPool **)(v2 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  MultiplexedPacket = re::Transport::createMultiplexedPacket(v3, *((void *)this + 6), a2 + 36);
  unint64_t v5 = MultiplexedPacket;
  if (MultiplexedPacket) {
    re::Packet::offsetBy((uint64_t)MultiplexedPacket, 36);
  }
  return v5;
}

uint64_t re::Packet::offsetBy(uint64_t this, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(this + 28);
  BOOL v3 = v2 >= a2;
  int v4 = v2 - a2;
  if (v3) {
    goto LABEL_5;
  }
  if ((a2 & 0x80000000) == 0 || (uint64_t v5 = *(void *)(this + 16), v5 - *(void *)(this + 8) < -(int)a2))
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "capacity() >= offset || (offset < 0 && -offset <= (static_cast<uint8_t*>(m_data) - static_cast<uint8_t*>(m_buffer)))", "offsetBy", 117);
    this = _os_crash();
    __break(1u);
LABEL_5:
    uint64_t v5 = *(void *)(this + 16);
  }
  *(void *)(this + 16) = v5 + (int)a2;
  *(_DWORD *)(this + 24) -= a2;
  *(_DWORD *)(this + 28) = v4;
  return this;
}

char *non-virtual thunk to're::UnreliableAckedUnicastStream::createPacket(re::UnreliableAckedUnicastStream *this, int a2)
{
  return re::UnreliableAckedUnicastStream::createPacket((re::UnreliableAckedUnicastStream *)((char *)this - 24), a2);
}

void re::UnreliableAckedUnicastStream::destroyPacket(re::UnreliableAckedUnicastStream *this, re::Packet *a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    uint64_t v3 = v2 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  re::PacketPool::free(*(re::PacketPool **)(v3 + 384), a2);
}

void non-virtual thunk to're::UnreliableAckedUnicastStream::destroyPacket(re::UnreliableAckedUnicastStream *this, re::Packet *a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    uint64_t v3 = v2 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  re::PacketPool::free(*(re::PacketPool **)(v3 + 384), a2);
}

uint64_t re::UnreliableAckedUnicastStream::send(re::UnreliableAckedUnicastStream *this, re::Packet *a2)
{
  re::Packet::offsetBy((uint64_t)a2, 4294967260);
  re::UnreliableAckedUnicastStream::writeHeader(this, a2);
  re::UnicastStream::send(this, a2);
  ++*((_WORD *)this + 96);
  uint64_t v4 = *((void *)this + 4);
  if (v4) {
    uint64_t v5 = v4 - 8;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(v5 + 568) + 32))(*(void *)(v5 + 568));
  *((void *)this + 25) = result;
  return result;
}

uint64_t re::UnreliableAckedUnicastStream::writeHeader(re::UnreliableAckedUnicastStream *this, re::Packet *a2)
{
  unsigned int v2 = *((_DWORD *)a2 + 7);
  if (v2 <= 0x23)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "packet.capacity() >= kHeaderSize", "writeHeader", 142);
    _os_crash();
    __break(1u);
    goto LABEL_5;
  }
  uint64_t v4 = *((void *)a2 + 2);
  v7[0] = &unk_26DD35FA8;
  v7[1] = v4;
  unsigned int v8 = v2;
  char v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)v7, *((unsigned __int16 *)this + 96), 0x10u);
  uint64_t result = re::AckWindow<256ul>::write((unsigned __int16 *)this + 56, (re::BitWriter *)v7);
  if (v9)
  {
LABEL_5:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "!writer.isOverflow()", "writeHeader", 148);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::UnreliableAckedUnicastStream::receive(re::UnreliableAckedUnicastStream *this)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  unsigned int v2 = (re::UnreliableAckedUnicastStream *)((char *)this + 64);
  uint64_t v3 = re::PacketQueue::dequeue((re::UnreliableAckedUnicastStream *)((char *)this + 64));
  if (v3)
  {
    v51 = (char *)this + 120;
    uint64_t v4 = (_OWORD *)((char *)this + 160);
    int v50 = v2;
    do
    {
      *(_OWORD *)&uint8_t buf[16] = 0u;
      long long v60 = 0u;
      int v5 = *(_DWORD *)(v3 + 24);
      *(void *)uint64_t v55 = *(void *)(v3 + 16);
      *(_DWORD *)&v55[8] = v5;
      LOBYTE(v56) = 0;
      *(void *)&v57[2] = 0;
      uint64_t v58 = 0;
      unsigned int v54 = 0;
      re::BitReader::readUInt32Bits((uint64_t *)v55, 0x10u, &v54);
      *(_WORD *)buf = v54;
      unsigned int v54 = 0;
      re::BitReader::readUInt32Bits((uint64_t *)v55, 0x10u, &v54);
      *(_WORD *)&buf[8] = v54;
      for (uint64_t i = 16; i != 48; i += 8)
      {
        unsigned int v54 = 0;
        re::BitReader::readUInt32Bits((uint64_t *)v55, 0x20u, &v54);
        uint64_t v7 = v54;
        unsigned int v54 = 0;
        re::BitReader::readUInt32Bits((uint64_t *)v55, 0x20u, &v54);
        *(void *)&buf[i] = v7 | ((unint64_t)v54 << 32);
      }
      if ((_BYTE)v56)
      {
        unsigned int v8 = (re *)(*(uint64_t (**)(re::UnreliableAckedUnicastStream *, uint64_t))(*(void *)this + 40))(this, v3);
        char v9 = *re::networkLogObjects(v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_228C70000, v9, OS_LOG_TYPE_ERROR, "Corrupt packet received. Will drop.", buf, 2u);
        }
        goto LABEL_100;
      }
      uint64_t v10 = (re *)re::Packet::offsetBy(v3, 36);
      v53[0] = *(_OWORD *)&buf[16];
      v53[1] = v60;
      long long v52 = *(_OWORD *)buf;
      unsigned int v11 = *(unsigned __int16 *)buf;
      uint64_t v12 = *((unsigned __int16 *)this + 56);
      unsigned int v13 = v12 - *(unsigned __int16 *)buf;
      if (v12 >= *(unsigned __int16 *)buf && v13 < 0x8000
        || v12 < *(unsigned __int16 *)buf && *(unsigned __int16 *)buf - v12 >= 0x8000)
      {
        unint64_t v14 = v13 >= 0x8000 ? v13 + 0x10000 : v12 - *(unsigned __int16 *)buf;
        if (v14 <= 0xFF)
        {
          uint64_t v10 = (re *)re::Bitset<256>::toWordIndex((uint64_t)v51, v14);
          if ((*(void *)&v51[8 * v10] >> v14))
          {
            int v15 = *re::networkLogObjects(v10);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v16 = *((void *)this + 4);
              if (v16) {
                uint64_t v17 = (re::Transport *)(v16 - 8);
              }
              else {
                uint64_t v17 = 0;
              }
              re::Transport::connectionAddress(v17, *((void *)this + 5), (re::DynamicString *)buf);
              uint64_t v18 = &buf[9];
              if (buf[8]) {
                uint64_t v18 = *(unsigned char **)&buf[16];
              }
              *(_DWORD *)uint64_t v55 = 134218242;
              *(void *)&v55[4] = (unsigned __int16)v52;
              __int16 v56 = 2082;
              *(void *)uint64_t v57 = v18;
              _os_log_impl(&dword_228C70000, v15, OS_LOG_TYPE_DEFAULT, "Received duplicate packet with seqNo=%zu. Ignoring.(address=%{public}s)", v55, 0x16u);
              if (*(void *)buf && (buf[8] & 1) != 0) {
                (*(void (**)(void))(**(void **)buf + 40))();
              }
            }
LABEL_53:
            (*(void (**)(re::UnreliableAckedUnicastStream *, uint64_t))(*(void *)this + 40))(this, v3);
            goto LABEL_100;
          }
          unsigned int v11 = (unsigned __int16)v52;
          LODWORD(v12) = *((unsigned __int16 *)this + 56);
          unsigned int v13 = v12 - (unsigned __int16)v52;
        }
      }
      if ((v12 >= v11 && v13 < 0x8000 || v12 < v11 && v11 - v12 >= 0x8000)
        && (v12 != v11 || (*v51 & 1) != 0))
      {
        uint64_t v26 = *re::networkLogObjects(v10);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          uint64_t v27 = *((unsigned __int16 *)this + 56);
          uint64_t v28 = *((void *)this + 4);
          if (v28) {
            uint64_t v29 = (re::Transport *)(v28 - 8);
          }
          else {
            uint64_t v29 = 0;
          }
          re::Transport::connectionAddress(v29, *((void *)this + 5), (re::DynamicString *)v55);
          uint64_t v30 = &v55[9];
          if (v55[8]) {
            uint64_t v30 = *(unsigned char **)&v57[2];
          }
          *(_DWORD *)buf = 134218754;
          *(void *)&uint8_t buf[4] = (unsigned __int16)v52;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v27 - 256;
          *(_WORD *)&buf[22] = 2048;
          *(void *)&unsigned char buf[24] = v27;
          LOWORD(v60) = 2082;
          *(void *)((char *)&v60 + 2) = v30;
          _os_log_impl(&dword_228C70000, v26, OS_LOG_TYPE_INFO, "Received out of order packet with seqNo=%zu. Ignoring.Current window=[%zu, %zu].(address=%{public}s)", buf, 0x2Au);
          if (*(void *)v55 && (v55[8] & 1) != 0) {
            (*(void (**)(void))(**(void **)v55 + 40))();
          }
          unsigned int v2 = v50;
        }
        goto LABEL_53;
      }
      unsigned int v19 = *((unsigned __int16 *)this + 76);
      int v20 = WORD4(v52);
      if (v53[0])
      {
        unsigned int v21 = v19 - WORD4(v52);
        if (v19 >= WORD4(v52) && v21 < 0x8000 || (unsigned int v22 = WORD4(v52) - v19, v19 < WORD4(v52)) && v22 >= 0x8000)
        {
          if (v21 >= 0x8000) {
            unint64_t v23 = v21 + 0x10000;
          }
          else {
            unint64_t v23 = (int)v21;
          }
          if (v23 < 0x100)
          {
            uint64_t v24 = 1 << v23;
            int v25 = (void *)v4 + re::Bitset<256>::toWordIndex((uint64_t)this + 160, v23);
LABEL_63:
            *v25 |= v24;
            unsigned int v19 = *((unsigned __int16 *)this + 76);
            int v20 = WORD4(v52);
            goto LABEL_64;
          }
          unsigned int v22 = WORD4(v52) - v19;
        }
        if (v19 <= WORD4(v52) && v22 < 0x8000 || v19 > WORD4(v52) && v21 >= 0x8000)
        {
          unint64_t v31 = WORD4(v52) + (v19 ^ 0xFFFF) + 1;
          if (v22 >= 0x8000) {
            unint64_t v32 = v31;
          }
          else {
            unint64_t v32 = (int)v22;
          }
          *((_WORD *)this + 76) = WORD4(v52);
          re::Bitset<256>::operator<<(buf, (uint64_t)this + 160, v32);
          long long v33 = *(_OWORD *)&buf[16];
          *uint64_t v4 = *(_OWORD *)buf;
          *((_OWORD *)this + 11) = v33;
          int v25 = (void *)((char *)this + 160);
          uint64_t v24 = 1;
          goto LABEL_63;
        }
      }
LABEL_64:
      if (v19 != v20)
      {
        uint64_t v35 = 0;
        while (1)
        {
          unsigned __int16 v36 = WORD4(v52) - v35;
          int v37 = (unsigned __int16)(WORD4(v52) - v35);
          unsigned int v38 = WORD4(v52) - v37;
          if ((WORD4(v52) < (unsigned __int16)v35 || v38 >= 0x8000)
            && (WORD4(v52) >= (unsigned __int16)v35 || v37 - WORD4(v52) < 0x8000))
          {
            goto LABEL_97;
          }
          unint64_t v39 = v38 >= 0x8000 ? v38 + 0x10000 : (int)v38;
          if (v39 > 0xFF
            || ((*((void *)v53 + re::Bitset<256>::toWordIndex((uint64_t)v53, v39)) >> v39) & 1) == 0)
          {
            goto LABEL_97;
          }
          unsigned int v40 = *((unsigned __int16 *)this + 76);
          unsigned int v41 = v40 - v37;
          if (v40 >= v36 && v41 < 0x8000 || (unsigned int v42 = v37 - v40, v40 < v36) && v42 >= 0x8000)
          {
            if (v41 >= 0x8000) {
              unint64_t v43 = v41 + 0x10000;
            }
            else {
              unint64_t v43 = (int)v41;
            }
            if (v43 < 0x100)
            {
              uint64_t v44 = 1 << v43;
              v45 = (void *)v4 + re::Bitset<256>::toWordIndex((uint64_t)this + 160, v43);
              goto LABEL_96;
            }
            unsigned int v42 = v37 - v40;
          }
          if ((v40 > v36 || v42 >= 0x8000) && (v40 <= v36 || v41 < 0x8000)) {
            goto LABEL_97;
          }
          unint64_t v46 = v37 + (v40 ^ 0xFFFF) + 1;
          if (v42 >= 0x8000) {
            unint64_t v47 = v46;
          }
          else {
            unint64_t v47 = (int)v42;
          }
          *((_WORD *)this + 76) = v36;
          re::Bitset<256>::operator<<(buf, (uint64_t)this + 160, v47);
          long long v48 = *(_OWORD *)&buf[16];
          *uint64_t v4 = *(_OWORD *)buf;
          *((_OWORD *)this + 11) = v48;
          v45 = (void *)((char *)this + 160);
          uint64_t v44 = 1;
LABEL_96:
          *v45 |= v44;
LABEL_97:
          if (++v35 == 256) {
            goto LABEL_98;
          }
        }
      }
      for (uint64_t j = 0; j != 2; ++j)
        v4[j] = vorrq_s8((int8x16_t)v4[j], (int8x16_t)v53[j]);
LABEL_98:
      if (*(_DWORD *)(v3 + 24)) {
        return v3;
      }
      (*(void (**)(re::UnreliableAckedUnicastStream *, uint64_t))(*(void *)this + 40))(this, v3);
      unsigned int v2 = v50;
LABEL_100:
      uint64_t v3 = re::PacketQueue::dequeue(v2);
    }
    while (v3);
  }
  return v3;
}

uint64_t re::UnreliableAckedUnicastStream::ack(uint64_t this, unsigned int a2)
{
  uint64_t v2 = this;
  uint64_t v3 = *(unsigned __int16 *)(this + 112);
  unsigned int v4 = v3 - a2;
  if (v3 >= a2 && v4 < 0x8000 || (unsigned int v5 = a2 - v3, v3 < a2) && v5 >= 0x8000)
  {
    unint64_t v6 = v4 + 0x10000;
    if (v4 < 0x8000) {
      unint64_t v6 = v3 - a2;
    }
    if (v6 < 0x100)
    {
      uint64_t v7 = this + 120;
      uint64_t v8 = 1 << v6;
      this = re::Bitset<256>::toWordIndex(this + 120, v6);
      char v9 = (void *)(v7 + 8 * this);
LABEL_18:
      *v9 |= v8;
      return this;
    }
    unsigned int v5 = a2 - v3;
  }
  if (v3 <= a2 && v5 < 0x8000 || v3 > a2 && v4 >= 0x8000)
  {
    unint64_t v10 = a2 + (v3 ^ 0xFFFF) + 1;
    if (v5 >= 0x8000) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = (int)v5;
    }
    *(_WORD *)(this + 112) = a2;
    char v9 = (void *)(this + 120);
    this = (uint64_t)re::Bitset<256>::operator<<(v13, this + 120, v11);
    long long v12 = v13[1];
    *(_OWORD *)(v2 + 120) = v13[0];
    *(_OWORD *)(v2 + 136) = v12;
    uint64_t v8 = 1;
    goto LABEL_18;
  }
  return this;
}

char *re::UnreliableAckedUnicastStream::update(re::UnreliableAckedUnicastStream *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    uint64_t v3 = v2 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t result = (char *)(*(uint64_t (**)(void))(**(void **)(v3 + 568) + 32))(*(void *)(v3 + 568));
  if ((unint64_t)&result[-*((void *)this + 25)] >= 0xA)
  {
    unsigned int v5 = result;
    uint64_t v6 = *((void *)this + 4);
    if (v6) {
      uint64_t v7 = (re::PacketPool **)(v6 - 8);
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t result = re::Transport::createMultiplexedPacket(v7, *((void *)this + 6), 36);
    if (result)
    {
      uint64_t v8 = result;
      re::UnreliableAckedUnicastStream::writeHeader(this, (re::Packet *)result);
      *((_DWORD *)v8 + 6) = 36;
      uint64_t result = (char *)re::UnicastStream::send(this, (re::Packet *)v8);
      ++*((_WORD *)this + 96);
      *((void *)this + 25) = v5;
    }
  }
  return result;
}

BOOL re::AckWindow<256ul>::write(unsigned __int16 *a1, re::BitWriter *this)
{
  uint64_t v3 = a1 + 4;
  re::BitWriter::writeUInt32Bits((uint64_t)this, *a1, 0x10u);
  for (uint64_t i = 0; i != 16; i += 4)
  {
    unsigned int v5 = *(_DWORD *)&v3[i + 2];
    re::BitWriter::writeUInt32Bits((uint64_t)this, *(_DWORD *)&v3[i], 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, v5, 0x20u);
  }
  return *((unsigned char *)this + 20) == 0;
}

void re::UnreliableAckedUnicastStream::~UnreliableAckedUnicastStream(re::UnreliableAckedUnicastStream *this)
{
  re::UnicastStream::~UnicastStream(this);
  JUMPOUT(0x22A6A9430);
}

void non-virtual thunk to're::UnreliableAckedUnicastStream::~UnreliableAckedUnicastStream(re::UnreliableAckedUnicastStream *this)
{
}

{
  uint64_t vars8;

  re::UnicastStream::~UnicastStream((re::UnreliableAckedUnicastStream *)((char *)this - 24));
  JUMPOUT(0x22A6A9430);
}

uint64_t re::Bitset<256>::toWordIndex(uint64_t a1, unint64_t a2)
{
  if (a2 < 0x100) {
    return a2 >> 6;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %d.", "b < kBitCount", "toWordIndex", 345, a2, 256, v2, v3);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

_OWORD *re::Bitset<256>::operator<<(_OWORD *result, uint64_t a2, unint64_t a3)
{
  *uint64_t result = 0u;
  result[1] = 0u;
  if (a3 <= 0xFF)
  {
    char v3 = a3;
    unsigned int v4 = (unint64_t *)a2;
    unsigned int v5 = result;
    uint64_t result = (_OWORD *)re::Bitset<256>::toWordIndex(a2, a3);
    if (result <= 3)
    {
      uint64_t v6 = 0;
      uint64_t v7 = (4 - result);
      uint64_t v8 = (uint64_t *)v5 + result;
      do
      {
        unint64_t v10 = *v4++;
        unint64_t v9 = v10;
        unint64_t v11 = v10 >> (64 - (v3 & 0x3Fu));
        if ((v3 & 0x3F) == 0) {
          unint64_t v11 = 0;
        }
        *v8++ = (v9 << (v3 & 0x3F)) | v6;
        uint64_t v6 = v11 & ~(-1 << v3);
        --v7;
      }
      while (v7);
    }
  }
  return result;
}

uint64_t re::LeaderElectionNone::setSession(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = a2;
  return result;
}

uint64_t re::LeaderElectionNone::setup(re::LeaderElectionNone *this, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(re::LeaderElectionNone *))(*(void *)this + 72))(this);
  if (result) {
    *(void *)(*((void *)this + 4) + 3136) = a2;
  }
  return result;
}

uint64_t re::LeaderElectionNone::processCapabilities(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 32);
  if (*(unsigned char *)(v1 + 2184)) {
    *(_DWORD *)(v1 + 3280) |= 1u;
  }
  return this;
}

uint64_t re::LeaderElectionNone::handleMigration(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(a1 + 32) + 3280) |= 1u;
  return a2;
}

uint64_t re::LeaderElectionNone::removePeer(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(void *)(this + 32);
  if (*(void *)(v2 + 3136) == a2) {
    *(_DWORD *)(v2 + 3032) = 12;
  }
  return this;
}

uint64_t re::LeaderElectionNone::isLeader(re::LeaderElectionNone *this)
{
  return *(_DWORD *)(*((void *)this + 4) + 3280) & 1;
}

uint64_t re::LeaderElectionNone::processPeerHelloSetLeader(uint64_t this, uint64_t a2)
{
  *(void *)(*(void *)(this + 32) + 3136) = a2;
  return this;
}

void re::LeaderElectionNone::~LeaderElectionNone(re::LeaderElectionNone *this)
{
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::LeaderElection::receiveMsg()
{
  return 0;
}

uint64_t re::SyncObjectManager::SyncObjectManager(uint64_t a1, long long *a2)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_DWORD *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_DWORD *)(a1 + 224) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(void *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(_OWORD *)(a1 + 288) = 0u;
  *(void *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 368) = 0;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_DWORD *)(a1 + 352) = 0;
  *(void *)a1 = &unk_26DD347D0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 30;
  *(void *)(a1 + 392) = 0xFFFFFFFF00010000;
  *(_OWORD *)(a1 + 408) = 0u;
  *(unsigned char *)(a1 + 400) = 0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(unsigned char *)(a1 + 440) = 1;
  *(_DWORD *)(a1 + 444) = 500;
  *(unsigned char *)(a1 + 448) = 1;
  *(unsigned char *)(a1 + 456) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 480) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 504) = 0;
  *(_DWORD *)(a1 + 544) = 0;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(void *)(a1 + 548) = 0x7FFFFFFFLL;
  *(_DWORD *)(a1 + 560) = 0;
  *(void *)(a1 + 584) = 0;
  *(_DWORD *)(a1 + 592) = 0;
  *(_OWORD *)(a1 + 568) = 0u;
  *(void *)(a1 + 608) = 0;
  *(void *)(a1 + 600) = 0;
  *(_DWORD *)(a1 + 616) = 2;
  *(void *)(a1 + 656) = 0;
  *(_OWORD *)(a1 + 620) = 0u;
  *(_OWORD *)(a1 + 636) = 0u;
  uint64_t v4 = *((void *)a2 + 4);
  unsigned int v5 = *(_DWORD *)(v4 + 2832);
  unsigned int v6 = *((_DWORD *)a2 + 5);
  if (v6 >= v5) {
    unsigned int v6 = *(_DWORD *)(v4 + 2832);
  }
  if (v5 >= *((_DWORD *)a2 + 4)) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = *((_DWORD *)a2 + 4);
  }
  *(_DWORD *)(a1 + 504) = v7;
  *(_DWORD *)(a1 + 560) = *(_DWORD *)(v4 + 2232);
  int v8 = *((unsigned __int8 *)a2 + 64);
  *(_DWORD *)(a1 + 616) = 2 * (*((unsigned char *)a2 + 64) == 0);
  if (v8) {
    int v9 = 2 * *(unsigned __int8 *)(v4 + 2219);
  }
  else {
    int v9 = 0;
  }
  *(_DWORD *)(a1 + 620) = v9;
  long long v10 = *a2;
  *(_OWORD *)(a1 + 385) = *(long long *)((char *)a2 + 9);
  *(_OWORD *)(a1 + 376) = v10;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 408), *((void *)a2 + 4));
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 416), *((void *)a2 + 5));
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 424), *((void *)a2 + 6));
  long long v11 = *(long long *)((char *)a2 + 56);
  *(unsigned char *)(a1 + 448) = *((unsigned char *)a2 + 72);
  *(_OWORD *)(a1 + 432) = v11;
  return a1;
}

void re::SyncObjectManager::~SyncObjectManager(re::SyncObjectManager *this)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26DD347D0;
  if (!*((unsigned char *)this + 456)) {
    goto LABEL_49;
  }
  *((unsigned char *)this + 456) = 0;
  uint64_t v2 = *((void *)this + 53);
  if (v2)
  {
    unint64_t v39 = this;
    *(void *)&long long v40 = re::SyncObjectManager::onViewAdded;
    *((void *)&v40 + 1) = 0;
    *(void *)&long long v41 = re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke;
    re::Event<re::SyncViewManager,re::SyncView *>::removeSubscription(v2 + 24, (long long *)&v39);
  }
  char v3 = (unsigned char *)*((void *)this + 51);
  if (!v3[2272]) {
    goto LABEL_49;
  }
  uint64_t v4 = (*(uint64_t (**)(unsigned char *))(*(void *)v3 + 40))(v3);
  if (v5)
  {
    unsigned int v6 = (uint64_t *)v4;
    uint64_t v7 = 8 * v5;
    do
    {
      uint64_t v8 = *v6;
      if (*v6)
      {
        id v9 = (id)(v8 + 8);
        uint64_t v38 = v8;
        id v10 = (id)(v8 + 8);
        re::SyncObjectManager::removePeerStateForParticipant((uint64_t)this, (uint64_t)&v38);

        uint64_t v38 = 0;
      }
      else
      {
        uint64_t v38 = 0;
        re::SyncObjectManager::removePeerStateForParticipant((uint64_t)this, (uint64_t)&v38);
      }
      ++v6;
      v7 -= 8;
    }
    while (v7);
  }
  uint64_t v11 = *((void *)this + 51);
  uint64_t v12 = *(void *)(v11 + 7520);
  if (v12 && *(void *)(v12 + 240))
  {
    unint64_t v13 = 0;
    while (1)
    {
      unint64_t v14 = (re::SyncObjectManager **)(*(void *)(v12 + 256) + 32 * v13);
      if (*v14 == this)
      {
        if (!*(_DWORD *)(v12 + 304))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v12 + 224), v13);
          goto LABEL_18;
        }
        LOBYTE(v39) = 0;
        long long v15 = *((_OWORD *)v14 + 1);
        long long v40 = *(_OWORD *)v14;
        long long v41 = v15;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v12 + 264), (uint64_t)&v39);
      }
      ++v13;
LABEL_18:
      if (v13 >= *(void *)(v12 + 240))
      {
        uint64_t v11 = *((void *)this + 51);
        break;
      }
    }
  }
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v11 + 2056, (uint64_t)this);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(*((void *)this + 51) + 1968, (uint64_t)this);
  uint64_t v16 = *((void *)this + 51);
  if (!*(void *)(v16 + 400)) {
    goto LABEL_30;
  }
  unint64_t v17 = 0;
  do
  {
    uint64_t v18 = *(void *)(v16 + 416) + 32 * v17;
    if (*(re::SyncObjectManager **)v18 != this) {
      goto LABEL_26;
    }
    if (*(_DWORD *)(v16 + 464))
    {
      LOBYTE(v39) = 0;
      long long v19 = *(_OWORD *)(v18 + 16);
      long long v40 = *(_OWORD *)v18;
      long long v41 = v19;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v16 + 424), (uint64_t)&v39);
LABEL_26:
      ++v17;
      continue;
    }
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v16 + 384), v17);
  }
  while (v17 < *(void *)(v16 + 400));
  uint64_t v16 = *((void *)this + 51);
LABEL_30:
  if (!*(void *)(v16 + 312)) {
    goto LABEL_39;
  }
  unint64_t v20 = 0;
  while (2)
  {
    unsigned int v21 = (re::SyncObjectManager **)(*(void *)(v16 + 328) + 32 * v20);
    if (*v21 == this)
    {
      if (*(_DWORD *)(v16 + 376))
      {
        LOBYTE(v39) = 0;
        long long v22 = *((_OWORD *)v21 + 1);
        long long v40 = *(_OWORD *)v21;
        long long v41 = v22;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v16 + 336), (uint64_t)&v39);
        goto LABEL_35;
      }
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v16 + 296), v20);
    }
    else
    {
LABEL_35:
      ++v20;
    }
    if (v20 < *(void *)(v16 + 312)) {
      continue;
    }
    break;
  }
  uint64_t v16 = *((void *)this + 51);
LABEL_39:
  if (!*(void *)(v16 + 224)) {
    goto LABEL_48;
  }
  unint64_t v23 = 0;
  while (2)
  {
    uint64_t v24 = (re::SyncObjectManager **)(*(void *)(v16 + 240) + 32 * v23);
    if (*v24 == this)
    {
      if (*(_DWORD *)(v16 + 288))
      {
        LOBYTE(v39) = 0;
        long long v25 = *((_OWORD *)v24 + 1);
        long long v40 = *(_OWORD *)v24;
        long long v41 = v25;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v16 + 248), (uint64_t)&v39);
        goto LABEL_44;
      }
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v16 + 208), v23);
    }
    else
    {
LABEL_44:
      ++v23;
    }
    if (v23 < *(void *)(v16 + 224)) {
      continue;
    }
    break;
  }
  uint64_t v16 = *((void *)this + 51);
LABEL_48:
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v16 + 120, (uint64_t)this);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(*((void *)this + 51) + 32, (uint64_t)this);
LABEL_49:
  uint64_t v26 = (const void *)*((void *)this + 76);
  if (v26)
  {
    _Block_release(v26);
    *((void *)this + 76) = 0;
  }
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 624);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 568);
  v27.n128_f64[0] = re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 64);
  uint64_t v28 = *((void *)this + 58);
  if (v28)
  {
    uint64_t v29 = *((void *)this + 62);
    if (v29)
    {
      uint64_t v30 = *((void *)this + 60);
      if (v30)
      {
        uint64_t v31 = v30 << 6;
        uint64_t v32 = v29 + 16;
        do
        {
          re::DynamicArray<re::SyncOwnershipRequest>::deinit(v32);
          uint64_t v33 = *(void *)(v32 - 8);
          if (v33)
          {

            *(void *)(v32 - 8) = 0;
          }
          uint64_t v34 = *(void *)(v32 - 16);
          if (v34)
          {

            *(void *)(v32 - 16) = 0;
          }
          v32 += 64;
          v31 -= 64;
        }
        while (v31);
        uint64_t v28 = *((void *)this + 58);
        uint64_t v29 = *((void *)this + 62);
      }
      (*(void (**)(uint64_t, uint64_t, __n128))(*(void *)v28 + 40))(v28, v29, v27);
    }
    *((void *)this + 62) = 0;
    *((void *)this + 59) = 0;
    *((void *)this + 60) = 0;
    *((void *)this + 58) = 0;
    ++*((_DWORD *)this + 122);
  }
  uint64_t v35 = *((void *)this + 53);
  if (v35)
  {

    *((void *)this + 53) = 0;
  }
  uint64_t v36 = *((void *)this + 52);
  if (v36)
  {

    *((void *)this + 52) = 0;
  }
  uint64_t v37 = *((void *)this + 51);
  if (v37)
  {

    *((void *)this + 51) = 0;
  }
  re::SyncSession::~SyncSession(this);
}

{
  uint64_t vars8;

  re::SyncObjectManager::~SyncObjectManager(this);
  JUMPOUT(0x22A6A9430);
}

void re::SyncSession::~SyncSession(re::SyncSession *this)
{
  *(void *)this = &unk_26DD34A08;
  uint64_t v2 = (void *)((char *)this + 24);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 36);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 25);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 14);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event(v2);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

uint64_t (***re::SyncObjectManager::startSync(re::SyncObjectManager *this))(void)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 51) + 40))(*((void *)this + 51));
  if (v3)
  {
    uint64_t v4 = (uint64_t *)v2;
    uint64_t v5 = 8 * v3;
    do
    {
      uint64_t v6 = *v4;
      if (*v4) {
        id v7 = (id)(v6 + 8);
      }
      uint64_t v8 = *(void *)(v6 + 152);
      if (v8 && ((*(uint64_t (**)(uint64_t))(*(void *)v8 + 48))(v8) & 1) == 0)
      {
        uint64_t v20 = v6;
        id v9 = (id)(v6 + 8);
        re::SyncObjectManager::addPeerStateForParticipant((uint64_t)this, &v20);

        uint64_t v20 = 0;
      }

      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  id v10 = (_DWORD *)(*((void *)this + 51) + 32);
  unsigned int v21 = this;
  long long v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onSessionWillDeinit;
  uint64_t v23 = 0;
  uint64_t v24 = re::Event<re::Session>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v10, (uint64_t)&v21);
  uint64_t v11 = (_DWORD *)(*((void *)this + 51) + 120);
  unsigned int v21 = this;
  long long v22 = re::SyncObjectManager::onSessionStarted;
  uint64_t v23 = 0;
  uint64_t v24 = re::Event<re::Session>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v11, (uint64_t)&v21);
  uint64_t v12 = (_DWORD *)(*((void *)this + 51) + 208);
  unsigned int v21 = this;
  long long v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onSessionStopped;
  uint64_t v23 = 0;
  uint64_t v24 = re::Event<re::Session,re::SessionError>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v12, (uint64_t)&v21);
  unint64_t v13 = (_DWORD *)(*((void *)this + 51) + 296);
  unsigned int v21 = this;
  long long v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onPeerJoined;
  uint64_t v23 = 0;
  uint64_t v24 = re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v13, (uint64_t)&v21);
  unint64_t v14 = (_DWORD *)(*((void *)this + 51) + 384);
  unsigned int v21 = this;
  long long v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onPeerLeft;
  uint64_t v23 = 0;
  uint64_t v24 = re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v14, (uint64_t)&v21);
  long long v15 = (_DWORD *)(*((void *)this + 51) + 1968);
  unsigned int v21 = this;
  long long v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onPeerPaused;
  uint64_t v23 = 0;
  uint64_t v24 = re::Event<re::Session,unsigned long long>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v15, (uint64_t)&v21);
  uint64_t v16 = (_DWORD *)(*((void *)this + 51) + 2056);
  unsigned int v21 = this;
  long long v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onPeerResumed;
  uint64_t v23 = 0;
  uint64_t v24 = re::Event<re::Session,unsigned long long>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v16, (uint64_t)&v21);
  uint64_t v17 = *(void *)(*((void *)this + 51) + 7520);
  if (v17)
  {
    unsigned int v21 = this;
    long long v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::handleCongestionEvent;
    uint64_t v23 = 0;
    uint64_t v24 = re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke;
    re::Event<re::Session>::addSubscription((_DWORD *)(v17 + 224), (uint64_t)&v21);
  }
  uint64_t v18 = *((void *)this + 53);
  if (v18)
  {
    unsigned int v21 = this;
    long long v22 = (uint64_t (*)(re::SyncObjectManager *, re::Session *))re::SyncObjectManager::onViewAdded;
    uint64_t v23 = 0;
    uint64_t v24 = re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke;
    re::Event<re::Session>::addSubscription((_DWORD *)(v18 + 24), (uint64_t)&v21);
  }
  *((unsigned char *)this + 456) = 1;
  return re::SyncObjectManager::reevaluateAllViewers(this);
}

uint64_t (***re::SyncObjectManager::reevaluateAllViewers(re::SyncObjectManager *this))(void)
{
  v5[5] = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 53);
  uint64_t v3 = re::globalAllocators(this)[2];
  v5[0] = &unk_26DD34880;
  v5[1] = this;
  v5[3] = v3;
  v5[4] = v5;
  re::SyncViewManager::forEachView(v2, (uint64_t)v5);
  return re::FunctionBase<24ul,void ()(re::SyncView *)>::destroyCallable((uint64_t)v5);
}

uint64_t re::SyncObjectManager::sendRate(re::SyncObjectManager *this)
{
  return *((void *)this + 47);
}

uint64_t (***re::SyncObjectManager::setViewFilter(uint64_t a1, void *aBlock))(void)
{
  uint64_t v4 = *(const void **)(a1 + 608);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = (uint64_t (***)(void))_Block_copy(aBlock);
  *(void *)(a1 + 608) = result;
  if (*(unsigned char *)(a1 + 456))
  {
    return re::SyncObjectManager::reevaluateAllViewers((re::SyncObjectManager *)a1);
  }
  return result;
}

uint64_t re::SyncObjectManager::viewFilter(re::SyncObjectManager *this)
{
  return *((void *)this + 76);
}

void re::SyncObjectManager::addPeerStateForParticipant(uint64_t a1, uint64_t *a2)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  uint64_t v4 = *re::networkLogObjects((re *)a1);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    uint64_t v6 = *(void *)(*a2 + 24);
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Adding new peer state. PeerID=%llu.", buf, 0xCu);
  }
  uint64_t v69 = 0;
  unint64_t v7 = *(void *)(a1 + 472);
  unint64_t v8 = *(void *)(a1 + 480);
  if (v8 >= v7)
  {
    unint64_t v9 = v8 + 1;
    if (v7 < v8 + 1)
    {
      if (*(void *)(a1 + 464))
      {
        uint64_t v10 = 2 * v7;
        BOOL v11 = v7 == 0;
        unint64_t v12 = 8;
        if (!v11) {
          unint64_t v12 = v10;
        }
        if (v12 <= v9) {
          unint64_t v13 = v9;
        }
        else {
          unint64_t v13 = v12;
        }
        re::DynamicArray<re::SyncObjectManager::PeerState>::setCapacity((void *)(a1 + 464), v13);
      }
      else
      {
        re::DynamicArray<re::SyncObjectManager::PeerState>::setCapacity((void *)(a1 + 464), v9);
        ++*(_DWORD *)(a1 + 488);
      }
    }
    unint64_t v8 = *(void *)(a1 + 480);
  }
  unint64_t v14 = *(void *)(a1 + 496) + (v8 << 6);
  *(_OWORD *)unint64_t v14 = 0u;
  *(_OWORD *)buf = 0u;
  *(_DWORD *)(v14 + 40) = 0;
  *(_OWORD *)(v14 + 24) = 0u;
  *(void *)(v14 + 16) = 0;
  *(_OWORD *)&uint8_t buf[16] = 0u;
  *(void *)&long long v67 = 0;
  uint64_t v68 = 0;
  DWORD2(v67) = 1;
  *(_DWORD *)(v14 + 40) = 1;
  *(_OWORD *)(v14 + 48) = 0u;
  ++*(void *)(a1 + 480);
  ++*(_DWORD *)(a1 + 488);
  re::DynamicArray<re::SyncOwnershipRequest>::deinit((uint64_t)&buf[16]);
  if (*(void *)&buf[8]) {

  }
  if (*(void *)buf) {
  uint64_t v15 = *(void *)(a1 + 496);
  }
  uint64_t v16 = *(void *)(a1 + 480) - 1;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v15 + (v16 << 6)), *a2);
  uint64_t v18 = *(void *)(*a2 + 24);
  uint64_t v19 = *(void *)(a1 + 480);
  if (v19)
  {
    int v20 = *(unsigned __int8 *)(a1 + 440);
    uint64_t v21 = *(void *)(a1 + 496);
    uint64_t v22 = v19 << 6;
    while (*(void *)(*(void *)v21 + 24) != v18)
    {
      v21 += 64;
      v22 -= 64;
      if (!v22) {
        goto LABEL_22;
      }
    }
    uint64_t v26 = *re::networkLogObjects(v17);
    BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_INFO);
    if (v20)
    {
      if (v27)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_228C70000, v26, OS_LOG_TYPE_INFO, "UNICAST reliable", buf, 2u);
      }
      uint64_t v28 = *(void *)(a1 + 408);
      uint64_t v60 = *(void *)(*(void *)v21 + 24);
      unint64_t v62 = *(void *)(*(void *)v21 + 32);
      uint64_t v29 = (re *)re::Session::peerID((re::Session *)v28);
      uint64_t v30 = *(void *)(a1 + 416);
      int v31 = (*(_DWORD *)(*(void *)v21 + 72) >> 1) & 1;
      uint64_t v32 = re::globalAllocators(v29);
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v32[2] + 32))(v32[2], 152, 8);
      if (a1) {
        uint64_t v33 = (void *)(a1 + 8);
      }
      else {
        uint64_t v33 = 0;
      }
      objc_initWeak((id *)buf, v33);
      objc_initWeak(&location, (id)(v28 + 2328));
      if (v30) {
        uint64_t v34 = (void *)(v30 + 8);
      }
      else {
        uint64_t v34 = 0;
      }
      objc_initWeak(&v64, v34);
      re::SyncReliableOrderedUnicast::SyncReliableOrderedUnicast(v25, (id *)buf, (re *)&location, v62, v60, (uint64_t)v29, &v64, *(unsigned char *)(a1 + 400), v31, *(unsigned char *)(a1 + 448));
    }
    else
    {
      if (v27)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_228C70000, v26, OS_LOG_TYPE_INFO, "UNICAST selective acked", buf, 2u);
      }
      uint64_t v35 = *(void *)(a1 + 408);
      uint64_t v61 = *(void *)(*(void *)v21 + 24);
      uint64_t v63 = *(void *)(*(void *)v21 + 32);
      uint64_t v36 = (re *)re::Session::peerID((re::Session *)v35);
      uint64_t v37 = *(void *)(a1 + 416);
      int v38 = (*(_DWORD *)(*(void *)v21 + 72) >> 1) & 1;
      unint64_t v39 = re::globalAllocators(v36);
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v39[2] + 32))(v39[2], 288, 8);
      if (a1) {
        long long v40 = (void *)(a1 + 8);
      }
      else {
        long long v40 = 0;
      }
      objc_initWeak((id *)buf, v40);
      objc_initWeak(&location, (id)(v35 + 2328));
      if (v37) {
        long long v41 = (void *)(v37 + 8);
      }
      else {
        long long v41 = 0;
      }
      objc_initWeak(&v64, v41);
      re::SyncSelectiveAckedUnicast::SyncSelectiveAckedUnicast(v25, (id *)buf, &location, v63, v61, (uint64_t)v36, &v64, *(unsigned char *)(a1 + 400), v38, *(unsigned char *)(a1 + 448), *(_DWORD *)(a1 + 444));
    }
    objc_destroyWeak(&v64);
    id v64 = 0;
    objc_destroyWeak(&location);
    id location = 0;
    objc_destroyWeak((id *)buf);
  }
  else
  {
LABEL_22:
    uint64_t v23 = *re::networkLogObjects(v17);
    BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    if (v24)
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v18;
      _os_log_error_impl(&dword_228C70000, v23, OS_LOG_TYPE_ERROR, "Invalid peerID %llu", buf, 0xCu);
    }
    uint64_t v25 = 0;
  }
  uint64_t v42 = v15 + (v16 << 6);
  uint64_t v45 = *(void *)(v42 + 8);
  uint64_t v44 = (uint64_t *)(v42 + 8);
  uint64_t v43 = v45;
  *uint64_t v44 = v25;
  if (v45) {

  }
  uint64_t v46 = *(void *)(*a2 + 24);
  unint64_t v47 = re::globalAllocators((re *)v24);
  uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v47[2] + 32))(v47[2], 112, 8);
  uint64_t v49 = v48;
  *(_DWORD *)(v48 + 32) = 0;
  *(void *)(v48 + 16) = 0;
  *(void *)(v48 + 24) = 0;
  *(void *)(v48 + 40) = 0;
  *(void *)(v48 + 48) = a1;
  *(void *)uint64_t v48 = &unk_26DD36158;
  *(void *)(v48 + 8) = 0;
  *(_OWORD *)(v48 + 64) = 0u;
  *(_OWORD *)(v48 + 80) = 0u;
  *(_DWORD *)(v48 + 96) = 0;
  *(void *)(v48 + 100) = 0x7FFFFFFFLL;
  *(void *)(v48 + 56) = v46;
  uint64_t v50 = *(void *)(a1 + 424);
  if (v50)
  {
    *(void *)buf = v48;
    re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addNew(v50 + 160, (uint64_t *)buf);
    uint64_t v51 = *(void *)(a1 + 424);
    uint64_t v52 = v15 + (v16 << 6);
    *(void *)(v52 + 56) = v49;
    v53 = (uint64_t *)(v52 + 56);
    if (v51 && *(void *)(a1 + 608))
    {
      *(void *)buf = a1;
      uint64_t v54 = *(void *)(v15 + (v16 << 6));
      *(void *)&buf[8] = v54;
      if (v54) {
        id v55 = (id)(v54 + 8);
      }
      uint64_t v56 = *v44;
      *(void *)&uint8_t buf[16] = v56;
      if (v56) {
        id v57 = (id)(v56 + 8);
      }
      uint64_t v58 = (re *)re::DynamicArray<re::SyncOwnershipRequest>::DynamicArray((uint64_t)&buf[24], (uint64_t *)(v15 + (v16 << 6) + 16));
      uint64_t v70 = *v53;
      uint64_t v72 = re::globalAllocators(v58)[2];
      uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v72 + 32))(v72, 80, 0);
      *(void *)uint64_t v59 = &unk_26DD34930;
      *(_OWORD *)(v59 + 8) = *(_OWORD *)buf;
      *(void *)(v59 + 24) = *(void *)&buf[16];
      *(_OWORD *)&buf[8] = 0u;
      *(_DWORD *)(v59 + 56) = 0;
      *(void *)(v59 + 32) = *(void *)&buf[24];
      *(void *)&unsigned char buf[24] = 0;
      *(void *)(v59 + 40) = v67;
      *(void *)(v59 + 48) = 0;
      *(void *)(v59 + 48) = *((void *)&v67 + 1);
      long long v67 = 0u;
      *(void *)(v59 + 64) = v69;
      uint64_t v69 = 0;
      LODWORD(v68) = v68 + 1;
      *(_DWORD *)(v59 + 56) = 1;
      *(void *)(v59 + 72) = v70;
      uint64_t v73 = v59;
      re::SyncViewManager::forEachView(v51, (uint64_t)v71);
      re::FunctionBase<24ul,void ()(re::SyncView *)>::destroyCallable((uint64_t)v71);
      re::DynamicArray<re::SyncOwnershipRequest>::deinit((uint64_t)&buf[24]);
      if (*(void *)&buf[16])
      {

        *(void *)&uint8_t buf[16] = 0;
      }
      if (*(void *)&buf[8]) {
    }
      }
  }
  else
  {
    *(void *)(v15 + (v16 << 6) + 56) = v48;
  }
}

uint64_t re::SyncObjectManager::onSessionWillDeinit(re::NetworkSyncManager **this, re::Session *a2)
{
  return 0;
}

uint64_t re::SyncObjectManager::onSessionStarted(re::SyncObjectManager *this, re::Session *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v3 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 134217984;
    uint64_t v6 = a2;
    _os_log_impl(&dword_228C70000, v3, OS_LOG_TYPE_DEFAULT, "SyncObjectManager: session started (%p).", (uint8_t *)&v5, 0xCu);
  }
  return 0;
}

uint64_t re::SyncObjectManager::onSessionStopped(re *a1, uint64_t a2, int a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134218240;
    uint64_t v8 = a2;
    __int16 v9 = 1024;
    int v10 = a3;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "SyncObjectManager: session stopped (%p) with error: %d.", (uint8_t *)&v7, 0x12u);
  }
  return 0;
}

uint64_t re::SyncObjectManager::onPeerJoined(re *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (void *)*a3;
    if (*(unsigned char *)(*a3 + 48)) {
      int v7 = (char *)v6[7];
    }
    else {
      int v7 = (char *)v6 + 49;
    }
    uint64_t v8 = v6[3];
    uint64_t v9 = v6[19];
    if (v9) {
      int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
    }
    else {
      int v10 = "nullptr";
    }
    *(_DWORD *)buf = 134218498;
    uint64_t v17 = v8;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2080;
    uint64_t v21 = v10;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "New peer joined object syncing. PeerID=%llu. Address='%s'. Identity='%s'.", buf, 0x20u);
  }
  uint64_t v11 = *a3;
  uint64_t v15 = v11;
  if (v11)
  {
    unint64_t v12 = (void *)(v11 + 8);
    id v13 = (id)(v11 + 8);
    re::SyncObjectManager::addPeerStateForParticipant((uint64_t)a1, &v15);
  }
  else
  {
    re::SyncObjectManager::addPeerStateForParticipant((uint64_t)a1, &v15);
  }
  return 0;
}

uint64_t re::SyncObjectManager::onPeerLeft(re *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (void *)*a3;
    if (*(unsigned char *)(*a3 + 48)) {
      int v7 = (char *)v6[7];
    }
    else {
      int v7 = (char *)v6 + 49;
    }
    uint64_t v8 = v6[3];
    uint64_t v9 = v6[19];
    if (v9) {
      int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
    }
    else {
      int v10 = "nullptr";
    }
    *(_DWORD *)buf = 134218498;
    uint64_t v17 = v8;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2080;
    uint64_t v21 = v10;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "Peer left syncing. PeerID=%llu. Address='%s'. Identity='%s'.", buf, 0x20u);
  }
  uint64_t v11 = *a3;
  uint64_t v15 = v11;
  if (v11)
  {
    unint64_t v12 = (void *)(v11 + 8);
    id v13 = (id)(v11 + 8);
    re::SyncObjectManager::removePeerStateForParticipant((uint64_t)a1, (uint64_t)&v15);
  }
  else
  {
    re::SyncObjectManager::removePeerStateForParticipant((uint64_t)a1, (uint64_t)&v15);
  }
  return 0;
}

uint64_t re::SyncObjectManager::onPeerPaused(re::SyncObjectManager *this, re::Session *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134217984;
    uint64_t v8 = a3;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "Pausing peerID %llu.", (uint8_t *)&v7, 0xCu);
  }
  (*(void (**)(re::SyncObjectManager *, uint64_t))(*(void *)this + 120))(this, a3);
  return 0;
}

uint64_t re::SyncObjectManager::onPeerResumed(re::SyncObjectManager *this, re::Session *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134217984;
    uint64_t v8 = a3;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "Resuming peerID %llu", (uint8_t *)&v7, 0xCu);
  }
  (*(void (**)(re::SyncObjectManager *, uint64_t))(*(void *)this + 128))(this, a3);
  return 0;
}

uint64_t re::SyncObjectManager::handleCongestionEvent(re *a1)
{
  uint64_t v1 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_debug_impl(&dword_228C70000, v1, OS_LOG_TYPE_DEBUG, "Emiting congestion event.", v3, 2u);
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  return 0;
}

void re::SyncObjectManager::removePeerStateForParticipant(uint64_t a1, uint64_t a2)
{
  uint64_t v92 = *MEMORY[0x263EF8340];
  uint64_t v4 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(*(void *)a2 + 24);
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Removing peer state. PeerID=%llu.", buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 480);
  if (v6)
  {
    uint64_t v7 = *(void *)(*(void *)a2 + 24);
    uint64_t v8 = *(void *)(a1 + 496);
    uint64_t v9 = -v8;
    int v10 = (re::SyncViewer **)(v8 + 56);
    uint64_t v11 = v6 << 6;
    while (*((void *)*(v10 - 7) + 3) != v7)
    {
      v9 -= 64;
      v10 += 8;
      v11 -= 64;
      if (!v11) {
        return;
      }
    }
    uint64_t v85 = v9;
    re::SyncObjectStore::types(*(void **)(a1 + 416), (uint64_t)buf);
    if (*(void *)&buf[16])
    {
      uint64_t v13 = 0;
      unint64_t v14 = (uint64_t *)v89;
      long long v86 = (uint64_t *)(v89 + 8 * *(void *)&buf[16]);
      while (1)
      {
        uint64_t v15 = *v14;
        if (*(unsigned char *)(*(void *)(*v14 + 16) + 73))
        {
          uint64_t v16 = *(void *)(v15 + 64);
          if (v16) {
            break;
          }
        }
LABEL_69:
        if (++v14 == v86) {
          goto LABEL_72;
        }
      }
      uint64_t v17 = *(re::SyncObject ***)(v15 + 80);
      __int16 v18 = &v17[v16];
      while (re::SyncObject::fromPeerID(*v17) != v7)
      {
        uint64_t v19 = *v17;
        __int16 v20 = (re::SyncObject *)*((void *)*v17 + 10);
        if (v20)
        {
          uint64_t v21 = (re::SyncObject *)*((void *)*v17 + 10);
          uint64_t v22 = *v17;
          do
          {
            uint64_t v23 = v22;
            uint64_t v22 = v21;
            if (*(unsigned char *)(*(void *)(*((void *)v23 + 11) + 16) + 73)) {
              break;
            }
            uint64_t v21 = (re::SyncObject *)*((void *)v21 + 10);
            uint64_t v23 = v22;
          }
          while (v21);
          if (*((void *)v23 + 20) == v7) {
            break;
          }
          do
          {
            BOOL v24 = v19;
            uint64_t v19 = v20;
            if (*(unsigned char *)(*(void *)(*((void *)v24 + 11) + 16) + 73)) {
              break;
            }
            __int16 v20 = (re::SyncObject *)*((void *)v20 + 10);
            BOOL v24 = v19;
          }
          while (v20);
        }
        else
        {
          BOOL v24 = *v17;
          if (*((void *)v19 + 20) == v7) {
            break;
          }
        }
        uint64_t v25 = *((void *)v24 + 17);
        if (v25) {
          BOOL v26 = v25 == v7;
        }
        else {
          BOOL v26 = 0;
        }
        if (v26) {
          break;
        }
LABEL_68:
        if (++v17 == v18) {
          goto LABEL_69;
        }
      }
      uint64_t v27 = re::Session::peerID(*(re::Session **)(a1 + 408));
      uint64_t v28 = *v17;
      uint64_t v29 = (re::SyncObject *)*((void *)*v17 + 10);
      uint64_t v30 = *v17;
      if (!v29) {
        goto LABEL_33;
      }
      int v31 = *v17;
      do
      {
        uint64_t v30 = v31;
        int v31 = v29;
        if (*(unsigned char *)(*(void *)(*((void *)v30 + 11) + 16) + 73)) {
          break;
        }
        uint64_t v29 = (re::SyncObject *)*((void *)v29 + 10);
        uint64_t v30 = v31;
      }
      while (v29);
      if (v28)
      {
LABEL_33:
        uint64_t v32 = *((void *)v30 + 20);
        uint64_t v33 = *v17;
        while (!*(unsigned char *)(*(void *)(*((void *)v33 + 11) + 16) + 74))
        {
          uint64_t v33 = (re::SyncObject *)*((void *)v33 + 10);
          if (!v33) {
            goto LABEL_46;
          }
        }
        uint64_t v34 = *((void *)v33 + 12);
        if (v34)
        {
          uint64_t v35 = *(void *)(v34 + 104);
          if (v35)
          {
            uint64_t v36 = *(uint64_t **)(v34 + 120);
            uint64_t v37 = 8 * v35;
            do
            {
              uint64_t v38 = *v36++;
              unint64_t v39 = *(void *)(v38 + 56);
              if (v27 - 1 >= v39 && v39 != v32) {
                uint64_t v27 = v39;
              }
              v37 -= 8;
            }
            while (v37);
          }
        }
      }
LABEL_46:
      unint64_t v41 = re::SyncObject::latestStateHandle(v28);
      if (v41 == -1)
      {
        uint64_t v51 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          uint64_t v52 = *((void *)*v17 + 3);
          v53 = *(void **)(*((void *)*v17 + 11) + 16);
          uint64_t v54 = v53[4];
          uint64_t v55 = v53[6];
          uint64_t v56 = (char *)v53[7];
          id v57 = (char *)v53 + 49;
          if (v55) {
            id v57 = v56;
          }
          *(_DWORD *)long long v87 = 134218498;
          *(void *)&v87[4] = v52;
          *(_WORD *)&v87[12] = 2048;
          *(void *)&v87[14] = v54;
          *(_WORD *)&v87[22] = 2080;
          *(void *)&v87[24] = v57;
          _os_log_error_impl(&dword_228C70000, v51, OS_LOG_TYPE_ERROR, "Sync object without snapshot while gathering orphans (id: %llu, type: %llu[%s]).", v87, 0x20u);
        }
        goto LABEL_66;
      }
      int v42 = *(unsigned __int8 *)(a1 + 400);
      uint64_t v43 = re::Session::peerID(*(re::Session **)(a1 + 408));
      uint64_t v44 = *v17;
      uint64_t v45 = (re::SyncObject *)*((void *)*v17 + 10);
      uint64_t v46 = *v17;
      if (v45)
      {
        unint64_t v47 = *v17;
        do
        {
          uint64_t v46 = v47;
          unint64_t v47 = v45;
          if (*(unsigned char *)(*(void *)(*((void *)v46 + 11) + 16) + 73)) {
            break;
          }
          uint64_t v45 = (re::SyncObject *)*((void *)v45 + 10);
          uint64_t v46 = v47;
        }
        while (v45);
      }
      if (*((unsigned char *)v46 + 171))
      {
        BOOL v48 = v42 != 0;
        if (v43 == v27) {
          uint64_t v49 = 0;
        }
        else {
          uint64_t v49 = v27;
        }
        *((void *)v44 + 17) = 0;
        *((void *)v44 + 20) = v49;
        if (v43 == v27) {
          BOOL v48 = 1;
        }
        *((unsigned char *)v44 + 170) = v48;
        *(void *)long long v87 = v44;
        char v50 = 4;
      }
      else
      {
        *((unsigned char *)v44 + 128) |= 4u;
        uint64_t v44 = *v17;
        *(void *)long long v87 = v44;
        char v50 = 2;
        if (!v44) {
          goto LABEL_64;
        }
      }
      uint64_t v58 = (char *)v44 + 8;
LABEL_64:
      *(void *)&v87[8] = v41;
      v87[16] = v50;
      re::DynamicArray<re::internal::SyncSnapshotEntry>::add((void *)(a1 + 624), (uint64_t)v87);
      if (*(void *)v87) {

      }
LABEL_66:
      if (v41 != -1) {
        ++v13;
      }
      goto LABEL_68;
    }
    uint64_t v13 = 0;
LABEL_72:
    uint64_t v59 = *(re **)buf;
    if (*(void *)buf)
    {
      uint64_t v12 = v89;
      if ((void)v89) {
        uint64_t v59 = (re *)(*(uint64_t (**)(void))(**(void **)buf + 40))();
      }
    }
    uint64_t v60 = *(void *)(a1 + 640);
    if (v60)
    {
      uint64_t v61 = *(void *)(a1 + 656);
      uint64_t v62 = 24 * v60;
      do
      {
        if ((*(unsigned char *)(*(void *)v61 + 128) & 4) != 0) {
          re::SyncObjectManager::destroyObject(v61);
        }
        v61 += 24;
        v62 -= 24;
      }
      while (v62);
    }
    if (v13)
    {
      uint64_t v63 = *re::networkLogObjects(v59);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v64 = re::Session::peerID(*(re::Session **)(a1 + 408));
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v64;
        _os_log_impl(&dword_228C70000, v63, OS_LOG_TYPE_DEFAULT, "Found %zu orphaned objects. localPeerID=%llu. ", buf, 0x16u);
      }
    }
    int v65 = *v10;
    long long v66 = *(re::SyncViewManager **)(a1 + 424);
    if (v66) {
      long long v66 = (re::SyncViewManager *)re::SyncViewManager::removeViewer(v66, *v10, 0);
    }
    if (v65)
    {
      uint64_t v67 = re::globalAllocators(v66)[2];
      (**(void (***)(re::SyncViewer *))v65)(v65);
      (*(void (**)(uint64_t, re::SyncViewer *))(*(void *)v67 + 40))(v67, v65);
    }
    *int v10 = 0;
    uint64_t v68 = *(void *)(a1 + 496);
    unint64_t v69 = (-v85 - v68) >> 6;
    unint64_t v70 = *(void *)(a1 + 480);
    if (v70 <= v69)
    {
      long long v90 = 0u;
      long long v91 = 0u;
      long long v89 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v87 = 136315906;
      *(void *)&v87[4] = "removeAt";
      *(_WORD *)&v87[12] = 1024;
      *(_DWORD *)&v87[14] = 931;
      *(_WORD *)&v87[18] = 2048;
      *(void *)&v87[20] = v69;
      *(_WORD *)&v87[28] = 2048;
      *(void *)&v87[30] = v70;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_107;
    }
    if (v70 - 1 > v69)
    {
      uint64_t v71 = v68 + (v70 << 6);
      uint64_t v72 = (long long *)(v68 + (v69 << 6));
      long long v73 = *v72;
      long long *v72 = *(_OWORD *)(v71 - 64);
      uint64_t v74 = (uint64_t *)(v72 + 1);
      *(_OWORD *)(v71 - 64) = v73;
      if (v72 != (long long *)(v71 - 64))
      {
        uint64_t v75 = *v74;
        uint64_t v76 = *(void *)(v71 - 48);
        if (*v74) {
          BOOL v77 = v76 == 0;
        }
        else {
          BOOL v77 = 1;
        }
        if (!v77 && v75 != v76)
        {
LABEL_107:
          re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
          _os_crash();
          __break(1u);
        }
        uint64_t *v74 = v76;
        *(void *)(v71 - 48) = v75;
        uint64_t v79 = v68 + (v69 << 6);
        long long v80 = *(_OWORD *)(v79 + 24);
        *(_OWORD *)(v79 + 24) = *(_OWORD *)(v71 - 40);
        *(_OWORD *)(v71 - 40) = v80;
        uint64_t v81 = *(void *)(v79 + 48);
        *(void *)(v79 + 48) = *(void *)(v71 - 16);
        *(void *)(v71 - 16) = v81;
        ++*(_DWORD *)(v71 - 24);
        ++*(_DWORD *)(v79 + 40);
        unint64_t v70 = *(void *)(a1 + 480);
      }
      *((void *)v72 + 7) = *(void *)(v71 - 8);
      uint64_t v68 = *(void *)(a1 + 496);
    }
    uint64_t v82 = v68 + (v70 << 6);
    re::DynamicArray<re::SyncOwnershipRequest>::deinit(v82 - 48);
    uint64_t v83 = *(void *)(v82 - 56);
    if (v83)
    {

      *(void *)(v82 - 56) = 0;
    }
    uint64_t v84 = *(void *)(v82 - 64);
    if (v84)
    {

      *(void *)(v82 - 64) = 0;
    }
    --*(void *)(a1 + 480);
    ++*(_DWORD *)(a1 + 488);
  }
}

void re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 16))
  {
    unint64_t v4 = 0;
    uint64_t v5 = (_anonymous_namespace_ *)(a1 + 40);
    do
    {
      uint64_t v6 = (long long *)(*(void *)(a1 + 32) + 32 * v4);
      if (*(void *)v6 == a2)
      {
        if (!*(_DWORD *)(a1 + 80))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v4);
          continue;
        }
        v8[0] = 0;
        long long v7 = v6[1];
        long long v9 = *v6;
        long long v10 = v7;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add(v5, (uint64_t)v8);
      }
      ++v4;
    }
    while (v4 < *(void *)(a1 + 16));
  }
}

uint64_t re::SyncObjectManager::onViewAdded(re::SyncObjectManager *this, re::SyncViewManager *a2, re::SyncView *a3)
{
  v8[5] = *MEMORY[0x263EF8340];
  uint64_t v6 = re::globalAllocators(this)[2];
  void v8[2] = a3;
  v8[3] = v6;
  v8[0] = &unk_26DD348D8;
  v8[1] = this;
  unsigned char v8[4] = v8;
  re::SyncViewManager::forEachViewer((uint64_t)a2, (uint64_t)v8);
  re::FunctionBase<24ul,void ()(re::SyncViewer *)>::destroyCallable((uint64_t)v8);
  return 0;
}

void re::SyncObjectManager::receive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v48, 6008, a1);
  *(void *)a3 = a1;
  uint64_t v5 = *(void *)(a1 + 480);
  if (v5)
  {
    uint64_t v6 = *(void **)(a1 + 496);
    long long v7 = &v6[8 * v5];
    uint64_t v8 = MEMORY[0x263EF8330];
    while (1)
    {
      uint64_t v9 = *v6;
      *(void *)(a3 + 8) = *(void *)(*v6 + 24);
      *(_DWORD *)(a3 + 24) = *(_DWORD *)(v9 + 72);
      uint64_t v10 = v6[1];
      v47[0] = v8;
      v47[1] = 0x40000000;
      v47[2] = ___ZN2re17SyncObjectManager7receiveEU13block_pointerFbP13RESyncSessionPK12RESyncCommitERNS_21SyncObjectReadContextE_block_invoke;
      v47[3] = &unk_264854600;
      v47[5] = a1;
      v47[6] = a3;
      v47[4] = a2;
      uint64_t v11 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)v10 + 40))(v10, a3, v47);
      if ((v11 & 1) == 0) {
        break;
      }
      uint64_t v12 = v6[1];
      uint64_t v13 = *(void *)(*v6 + 24);
      uint64_t v14 = re::globalAllocators(v11)[2];
      *(void *)&v50[16] = v13;
      *(void *)&v50[24] = v14;
      *(void *)char v50 = &unk_26DD34988;
      *(void *)&v50[8] = a1;
      v51[0] = v50;
      LOBYTE(v12) = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v12 + 56))(v12, v50);
      uint64_t v15 = (re *)re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable((uint64_t)v50);
      if ((v12 & 1) == 0)
      {
        uint64_t v16 = *re::networkLogObjects(v15);
        BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
        if (v17)
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_228C70000, v16, OS_LOG_TYPE_ERROR, "[Ownership] Corrupt ownership request.", buf, 2u);
        }
        __int16 v18 = *re::networkLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          if (*(unsigned char *)(v9 + 48)) {
            uint64_t v19 = *(void *)(v9 + 56);
          }
          else {
            uint64_t v19 = v9 + 49;
          }
          uint64_t v20 = *(void *)(v9 + 24);
          uint64_t v21 = *(void *)(v9 + 152);
          uint64_t v22 = "nullptr";
          if (v21)
          {
            uint64_t v45 = *(void *)(v9 + 24);
            uint64_t v22 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v21 + 32))(v21);
            uint64_t v20 = v45;
          }
          *(_DWORD *)char v50 = 134218498;
          *(void *)&v50[4] = v20;
          *(_WORD *)&v50[12] = 2082;
          *(void *)&v50[14] = v19;
          *(_WORD *)&v50[22] = 2082;
          *(void *)&v50[24] = v22;
          _os_log_error_impl(&dword_228C70000, v18, OS_LOG_TYPE_ERROR, "Failed to parse ownership requests. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)", v50, 0x20u);
        }
        re::Transport::disconnect((re::Transport *)(*(void *)(a1 + 408) + 2320), *(void *)(v9 + 32), 0);
      }
      v6 += 8;
      if (v6 == v7) {
        goto LABEL_19;
      }
    }
    uint64_t v23 = *re::networkLogObjects(v11);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      if (*(unsigned char *)(v9 + 48)) {
        uint64_t v41 = *(void *)(v9 + 56);
      }
      else {
        uint64_t v41 = v9 + 49;
      }
      uint64_t v42 = *(void *)(v9 + 24);
      uint64_t v43 = *(void *)(v9 + 152);
      if (v43) {
        uint64_t v44 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v43 + 32))(v43);
      }
      else {
        uint64_t v44 = "nullptr";
      }
      *(_DWORD *)char v50 = 134218498;
      *(void *)&v50[4] = v42;
      *(_WORD *)&v50[12] = 2082;
      *(void *)&v50[14] = v41;
      *(_WORD *)&v50[22] = 2082;
      *(void *)&v50[24] = v44;
      _os_log_error_impl(&dword_228C70000, v23, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)", v50, 0x20u);
    }
    re::Transport::disconnect((re::Transport *)(*(void *)(a1 + 408) + 2320), *(void *)(v9 + 32), 0);
  }
LABEL_19:
  if (*(void *)(a1 + 640))
  {
    v50[0] = 0;
    uint64_t v53 = 0;
    memset(v51, 0, sizeof(v51));
    int v52 = 0;
    *(void *)&v50[8] = 0;
    *(void *)&v50[16] = 0;
    *(void *)&v50[21] = 0;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v51, (uint64_t *)(a1 + 624));
    (*(void (**)(uint64_t, uint64_t, unsigned char *))(a2 + 16))(a2, a1, v50);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(a1 + 624);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v51);
  }
  uint64_t v24 = *(unsigned int *)(a1 + 544);
  if (v24)
  {
    uint64_t v25 = 0;
    BOOL v26 = (int *)(*(void *)(a1 + 528) + 8);
    while (1)
    {
      int v27 = *v26;
      v26 += 8;
      if (v27 < 0) {
        break;
      }
      if (v24 == ++v25)
      {
        LODWORD(v25) = *(_DWORD *)(a1 + 544);
        break;
      }
    }
  }
  else
  {
    LODWORD(v25) = 0;
  }
  if (v24 != v25)
  {
    uint64_t v28 = v25;
    do
    {
      uint64_t v29 = *(void *)(a1 + 528) + 32 * v28;
      v30.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
      if (*(void *)(v29 + 24) < v30.__d_.__rep_)
      {
        int v31 = (unint64_t *)(v29 + 16);
        uint64_t v32 = *re::networkLogObjects((re *)v30.__d_.__rep_);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v40 = *(void *)(*v31 + 24);
          *(_DWORD *)char v50 = 134217984;
          *(void *)&v50[4] = v40;
          _os_log_debug_impl(&dword_228C70000, v32, OS_LOG_TYPE_DEBUG, "[Ownership] Ownership response for: %llu timed out", v50, 0xCu);
        }
        uint64_t v33 = *(void *)(a1 + 432);
        if (v33)
        {
          uint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)v33 + 56))(v33);
          unint64_t v35 = *v31;
          if (*v31)
          {
            for (unint64_t i = *(void *)(v35 + 80); i; unint64_t i = *(void *)(i + 80))
            {
              unint64_t v37 = v35;
              unint64_t v35 = i;
              if (*(unsigned char *)(*(void *)(*(void *)(v37 + 88) + 16) + 73)) {
                break;
              }
            }
          }
          re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::raise(v34, a1);
        }
        re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(a1 + 512, *v31);
      }
      if (*(_DWORD *)(a1 + 544) <= (v25 + 1)) {
        int v38 = v25 + 1;
      }
      else {
        int v38 = *(_DWORD *)(a1 + 544);
      }
      while (1)
      {
        uint64_t v28 = (v25 + 1);
        if (v38 - 1 == v25) {
          break;
        }
        LODWORD(v25) = v25 + 1;
        int v39 = v28;
        if ((*(_DWORD *)(*(void *)(a1 + 528) + 32 * v28 + 8) & 0x80000000) != 0) {
          goto LABEL_47;
        }
      }
      int v39 = v38;
LABEL_47:
      LODWORD(v25) = v39;
    }
    while (v24 != v39);
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v48);
}

uint64_t ___ZN2re17SyncObjectManager7receiveEU13block_pointerFbP13RESyncSessionPK12RESyncCommitERNS_21SyncObjectReadContextE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void **)(a1 + 40);
  uint64_t v4 = *(void *)(a2 + 48);
  if (v4)
  {
    uint64_t v5 = *(uint64_t **)(a2 + 64);
    uint64_t v6 = &v5[3 * v4];
    do
    {
      if ((*(unsigned char *)(*v5 + 128) & 4) != 0) {
        re::SyncObjectManager::destroyObject((uint64_t)v5);
      }
      if ((v5[2] & 4) == 0) {
        goto LABEL_32;
      }
      (*(void (**)(unsigned char *__return_ptr))(***(void ***)(a1 + 48) + 32))(buf);
      uint64_t v7 = re::Session::peerID(*(re::Session **)buf);
      if (*(void *)buf) {

      }
      uint64_t v8 = *v5;
      uint64_t v9 = *(void *)(*v5 + 136);
      if (v9) {
        BOOL v10 = v9 == v7;
      }
      else {
        BOOL v10 = 0;
      }
      if (v10)
      {
        uint64_t v18 = *(void *)(v8 + 80);
        if (v18)
        {
          uint64_t v19 = *v5;
          do
          {
            uint64_t v20 = v19;
            uint64_t v19 = v18;
            if (*(unsigned char *)(*(void *)(*(void *)(v20 + 88) + 16) + 73)) {
              break;
            }
            uint64_t v18 = *(void *)(v18 + 80);
          }
          while (v18);
        }
        __int16 v21 = *(_WORD *)(v8 + 144);
        *(void *)(v8 + 136) = 0;
        *(void *)(v8 + 160) = 0;
        *(_WORD *)(v8 + 168) = v21;
        *(unsigned char *)(v8 + 170) = 1;
        unint64_t v22 = v3[73];
        re::SyncObjectManager::gatherObjectsWithChildren(v5, v3 + 71);
        while (v22 < v3[73])
        {
          uint64_t v23 = *(void *)(v3[75] + 8 * v22);
          uint64_t v24 = *(void *)(v23 + 80);
          uint64_t v25 = v23;
          if (v24)
          {
            uint64_t v26 = *(void *)(v3[75] + 8 * v22);
            do
            {
              uint64_t v25 = v26;
              uint64_t v26 = v24;
              if (*(unsigned char *)(*(void *)(*(void *)(v25 + 88) + 16) + 73)) {
                break;
              }
              uint64_t v24 = *(void *)(v24 + 80);
              uint64_t v25 = v26;
            }
            while (v24);
          }
          long long v27 = *(_OWORD *)(v25 + 136);
          long long v28 = *(_OWORD *)(v25 + 152);
          *(_DWORD *)(v23 + 168) = *(_DWORD *)(v25 + 168);
          *(_OWORD *)(v23 + 152) = v28;
          *(_OWORD *)(v23 + 136) = v27;
          ++v22;
        }
        int v29 = re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove((uint64_t)(v3 + 64), *v5);
        uint64_t v30 = v3[54];
        if (v29)
        {
          if (!v30) {
            goto LABEL_32;
          }
          uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 56))(v30);
          re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::raise(v31, (uint64_t)v3);
          uint64_t v33 = *re::networkLogObjects(v32);
          if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_32;
          }
          uint64_t v34 = *(void *)(*v5 + 24);
          *(_DWORD *)buf = 134217984;
          *(void *)&uint8_t buf[4] = v34;
          uint64_t v16 = v33;
          BOOL v17 = "[Ownership] Received ownership granted response for: %llu";
        }
        else
        {
          if (!v30) {
            goto LABEL_32;
          }
          uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 64))(v30);
          re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::raise(v35, (uint64_t)v3);
          unint64_t v37 = *re::networkLogObjects(v36);
          if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_32;
          }
          uint64_t v38 = *(void *)(*v5 + 24);
          *(_DWORD *)buf = 134217984;
          *(void *)&uint8_t buf[4] = v38;
          uint64_t v16 = v37;
          BOOL v17 = "[Ownership] Received ownership handoff for: %llu";
        }
      }
      else
      {
        uint64_t v11 = v3[54];
        if (!v11) {
          goto LABEL_32;
        }
        uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 72))(v11);
        re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::raise(v12, (uint64_t)v3);
        uint64_t v14 = *re::networkLogObjects(v13);
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_32;
        }
        uint64_t v15 = *(void *)(*v5 + 24);
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = v15;
        uint64_t v16 = v14;
        BOOL v17 = "[Ownership] Received ownership change: %llu";
      }
      _os_log_debug_impl(&dword_228C70000, v16, OS_LOG_TYPE_DEBUG, v17, buf, 0xCu);
LABEL_32:
      v5 += 3;
    }
    while (v5 != v6);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void re::SyncObjectManager::destroyObject(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 200);
  if (v3)
  {
    unint64_t v4 = v3 - 1;
    do
    {
      unint64_t v5 = *(void *)(*(void *)a1 + 200);
      if (v5 <= v4)
      {
        v12[1] = 0;
        memset(v21, 0, sizeof(v21));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v13 = 136315906;
        uint64_t v14 = "operator[]";
        __int16 v15 = 1024;
        int v16 = 789;
        __int16 v17 = 2048;
        unint64_t v18 = v4;
        __int16 v19 = 2048;
        unint64_t v20 = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v6 = *(void *)(*(void *)(*(void *)a1 + 216) + 8 * v4);
      *(void *)&v21[0] = v6;
      if (v6)
      {
        uint64_t v7 = (void *)(v6 + 8);
        id v8 = (id)(v6 + 8);
        re::SyncObjectManager::destroyObject(v21);
      }
      else
      {
        re::SyncObjectManager::destroyObject(v21);
      }
      --v4;
    }
    while (v4 != -1);
    uint64_t v2 = *(void **)a1;
  }
  uint64_t v9 = v2[11];
  if (*(unsigned char *)(*(void *)(v9 + 16) + 74))
  {
    uint64_t v10 = v2[12];
    if (v10)
    {
      re::SyncView::removeObject(v10, (uint64_t)(v2 + 12));
      uint64_t v2 = *(void **)a1;
      uint64_t v9 = *(void *)(*(void *)a1 + 88);
    }
  }
  v12[0] = v2;
  uint64_t v11 = v2 + 1;
  re::SyncObjectTypedStore::removeObject(v9, (uint64_t)v12);
  if (v12[0]) {
}
  }

void re::SyncObjectManager::gatherObjectsWithChildren(uint64_t *a1, void *a2)
{
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::add(a2, a1);
  uint64_t v4 = *(void *)(*a1 + 200);
  if (v4)
  {
    unint64_t v5 = *(uint64_t **)(*a1 + 216);
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = *v5;
      uint64_t v9 = v7;
      if (v7) {
        id v8 = (id)(v7 + 8);
      }
      re::SyncObjectManager::gatherObjectsWithChildren(&v9, a2);
      if (v9) {

      }
      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  unint64_t v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(v5 + 4 * v4);
  if (v6 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = v8 + 32 * v6;
  if (*(void *)(v9 + 16) != a2)
  {
    while (1)
    {
      unsigned int v10 = v6;
      int v11 = *(_DWORD *)(v8 + 32 * v6 + 8);
      uint64_t v6 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        return 0;
      }
      uint64_t v12 = v8 + 32 * v6;
      if (*(void *)(v12 + 16) == a2)
      {
        *(_DWORD *)(v8 + 32 * v10 + 8) = *(_DWORD *)(v8 + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(v12 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v13 = *(void *)(a1 + 16) + 32 * v6;
  int v14 = *(_DWORD *)(v13 + 8);
  if (v14 < 0)
  {
    *(_DWORD *)(v13 + 8) = v14 & 0x7FFFFFFF;
    uint64_t v17 = *(void *)(v13 + 16);
    int v16 = (void *)(v13 + 16);
    uint64_t v15 = v17;
    if (v17)
    {

      void *v16 = 0;
    }
  }
  int v18 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v6 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v6 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v18 + 1;
  return 1;
}

void re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::raise(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      uint64_t v7 = 0;
      for (unint64_t i = 0; i != v6; ++i)
      {
        unint64_t v9 = *(void *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v15 = 136315906;
          int v16 = "operator[]";
          __int16 v17 = 1024;
          int v18 = 789;
          __int16 v19 = 2048;
          unint64_t v20 = i;
          __int16 v21 = 2048;
          unint64_t v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = *(void *)(a1 + 72) + v7;
        uint64_t v11 = *(void *)(v10 + 32);
        long long v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        uint64_t v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, *((unint64_t *)&v23[0] + 1));
          }
        }
        v7 += 40;
      }
    }
  }
}

void re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::raise(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      uint64_t v7 = 0;
      for (unint64_t i = 0; i != v6; ++i)
      {
        unint64_t v9 = *(void *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v15 = 136315906;
          int v16 = "operator[]";
          __int16 v17 = 1024;
          int v18 = 789;
          __int16 v19 = 2048;
          unint64_t v20 = i;
          __int16 v21 = 2048;
          unint64_t v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = *(void *)(a1 + 72) + v7;
        uint64_t v11 = *(void *)(v10 + 32);
        long long v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        uint64_t v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, *((unint64_t *)&v23[0] + 1));
          }
        }
        v7 += 40;
      }
    }
  }
}

void re::SyncObjectManager::send(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  *(void *)(a4 + 8) = a1;
  uint64_t v41 = a2;
  uint64_t v42 = a3;
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v40, 6018, a1);
  if (v5)
  {
    uint64_t v8 = v6;
    do
    {
      uint64_t v9 = *(void *)(v8 + 48);
      if (v9)
      {
        uint64_t v10 = *(uint64_t **)(v8 + 64);
        uint64_t v11 = &v10[3 * v9];
        do
        {
          uint64_t v12 = *v10;
          uint64_t v13 = *(void *)(*v10 + 80);
          uint64_t v14 = *v10;
          if (v13)
          {
            uint64_t v15 = *v10;
            do
            {
              uint64_t v14 = v15;
              uint64_t v15 = v13;
              if (*(unsigned char *)(*(void *)(*(void *)(v14 + 88) + 16) + 73)) {
                break;
              }
              uint64_t v13 = *(void *)(v13 + 80);
              uint64_t v14 = v15;
            }
            while (v13);
          }
          if ((*(unsigned char *)(v14 + 170) || *(unsigned char *)(a1 + 400)) && (*(unsigned char *)(v12 + 128) & 4) != 0)
          {
            if (*(unsigned char *)(*(void *)(*(void *)(v12 + 88) + 16) + 74))
            {
              uint64_t v18 = *(void *)(v12 + 96);
              uint64_t v17 = v12 + 96;
              uint64_t v16 = v18;
              if (v18) {
                re::SyncView::removeObject(v16, v17);
              }
            }
          }
          v10 += 3;
        }
        while (v10 != v11);
      }
      v8 += 72;
    }
    while (v8 != v6 + 72 * v5);
  }
  uint64_t v19 = *(void *)(a1 + 480);
  if (v19)
  {
    unint64_t v20 = *(uint64_t **)(a1 + 496);
    __int16 v21 = &v20[8 * v19];
    do
    {
      uint64_t v22 = *v20;
      uint64_t v23 = *(void *)(*v20 + 152);
      if (!v23 || ((*(uint64_t (**)(uint64_t))(*(void *)v23 + 48))(v23) & 1) == 0)
      {
        *(void *)(a4 + 16) = *(void *)(v22 + 24);
        *(_DWORD *)(a4 + 32) = *(_DWORD *)(v22 + 72);
        uint64_t v24 = v20[1];
        uint64_t v25 = *(void *)(a1 + 584);
        uint64_t v38 = *(void *)(a1 + 600);
        uint64_t v39 = v25;
        (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t, uint64_t))(*(void *)v24 + 32))(v24, &v41, &v38, v20[7], a4);
        uint64_t v26 = v20[1];
        uint64_t v27 = v20[4];
        uint64_t v38 = v20[6];
        uint64_t v39 = v27;
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v26 + 48))(v26, &v38);
        uint64_t v28 = v20[4];
        v20[4] = 0;
        if (v28)
        {
          uint64_t v29 = 80 * v28;
          uint64_t v30 = v20[6] + 24;
          do
          {
            re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v30);
            v30 += 80;
            v29 -= 80;
          }
          while (v29);
        }
        ++*((_DWORD *)v20 + 10);
        re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear(v20[7] + 64);
      }
      v20 += 8;
    }
    while (v20 != v21);
    uint64_t v6 = v41;
    uint64_t v5 = v42;
  }
  if (v5)
  {
    uint64_t v31 = v6 + 72 * v5;
    do
    {
      uint64_t v32 = *(void *)(v6 + 48);
      if (v32)
      {
        uint64_t v33 = *(void *)(v6 + 64);
        uint64_t v34 = v33 + 24 * v32;
        do
        {
          uint64_t v35 = *(void *)(*(void *)v33 + 80);
          uint64_t v36 = *(void *)v33;
          if (v35)
          {
            uint64_t v37 = *(void *)v33;
            do
            {
              uint64_t v36 = v37;
              uint64_t v37 = v35;
              if (*(unsigned char *)(*(void *)(*(void *)(v36 + 88) + 16) + 73)) {
                break;
              }
              uint64_t v35 = *(void *)(v35 + 80);
              uint64_t v36 = v37;
            }
            while (v35);
          }
          if ((*(unsigned char *)(v36 + 170) || *(unsigned char *)(a1 + 400)) && (*(unsigned char *)(*(void *)v33 + 128) & 4) != 0) {
            re::SyncObjectManager::destroyObject(v33);
          }
          v33 += 24;
        }
        while (v33 != v34);
      }
      v6 += 72;
    }
    while (v6 != v31);
  }
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::clear(a1 + 568);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v40);
}

void re::DynamicArray<re::SharedPtr<re::SyncObject>>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = 8 * v2;
    do
    {
      if (*(void *)v3)
      {

        *(void *)uint64_t v3 = 0;
      }
      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void *re::SyncObjectManager::session@<X0>(void *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = this[51];
  *a2 = v2;
  if (v2) {
    return (id)(v2 + 8);
  }
  return this;
}

void *re::DynamicArray<re::SharedPtr<re::SyncObject>>::add(void *this, uint64_t *a2)
{
  uint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::SharedPtr<re::SyncObject>>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  uint64_t v5 = *a2;
  *(void *)(v3[4] + 8 * v4) = *a2;
  if (v5)
  {
    this = (id)(v5 + 8);
    unint64_t v4 = v3[2];
  }
  _OWORD v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::SyncObjectManager::requestOwnership(uint64_t a1, uint64_t *a2, char a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v12 = *a2;
  uint64_t v13 = *(void *)(*a2 + 80);
  if (v13)
  {
    do
    {
      uint64_t v14 = v12;
      uint64_t v12 = v13;
      if (*(unsigned char *)(*(void *)(*(void *)(v14 + 88) + 16) + 73)) {
        break;
      }
      uint64_t v13 = *(void *)(v13 + 80);
      uint64_t v14 = v12;
    }
    while (v13);
  }
  else
  {
    uint64_t v14 = *a2;
  }
  if (!*(void *)(v14 + 160)) {
    return;
  }
  v15.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = v15.__d_.__rep_;
  uint64_t v17 = *a2;
  unint64_t v18 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v19 = (0x94D049BB133111EBLL * (v18 ^ (v18 >> 27))) ^ ((0x94D049BB133111EBLL * (v18 ^ (v18 >> 27))) >> 31);
  unint64_t v20 = *(void *)(a1 + 512);
  if (v20)
  {
    unint64_t v20 = v19 % *(unsigned int *)(a1 + 536);
    uint64_t v21 = *(unsigned int *)(*(void *)(a1 + 520) + 4 * v20);
    if (v21 != 0x7FFFFFFF)
    {
      uint64_t v46 = *(void *)(a1 + 528);
      if (*(void *)(v46 + 32 * v21 + 16) == v17) {
        goto LABEL_17;
      }
      while (1)
      {
        uint64_t v21 = *(_DWORD *)(v46 + 32 * v21 + 8) & 0x7FFFFFFF;
        if (v21 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v46 + 32 * v21 + 16) == v17) {
          goto LABEL_17;
        }
      }
    }
  }
  uint64_t v22 = *(unsigned int *)(a1 + 548);
  if (v22 == 0x7FFFFFFF)
  {
    uint64_t v22 = *(unsigned int *)(a1 + 544);
    int v23 = v22;
    if (v22 == *(_DWORD *)(a1 + 536))
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(a1 + 512, 2 * *(_DWORD *)(a1 + 540));
      LODWORD(v20) = v19 % *(unsigned int *)(a1 + 536);
      int v23 = *(_DWORD *)(a1 + 544);
      uint64_t v17 = *a2;
    }
    *(_DWORD *)(a1 + 544) = v23 + 1;
    uint64_t v24 = *(void *)(a1 + 528);
    int v25 = *(_DWORD *)(v24 + 32 * v22 + 8);
  }
  else
  {
    uint64_t v24 = *(void *)(a1 + 528);
    int v25 = *(_DWORD *)(v24 + 32 * v22 + 8);
    *(_DWORD *)(a1 + 548) = v25 & 0x7FFFFFFF;
  }
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v26 = rep + (uint64_t)(a6 * 1000000000.0);
  *(_DWORD *)(v24 + 32 * v22 + 8) = v25 | 0x80000000;
  uint64_t v27 = *(void *)(a1 + 520);
  uint64_t v28 = v20;
  *(_DWORD *)(*(void *)(a1 + 528) + 32 * v22 + 8) = *(_DWORD *)(*(void *)(a1 + 528) + 32 * v22 + 8) & 0x80000000 | *(_DWORD *)(v27 + 4 * v20);
  *(void *)(*(void *)(a1 + 528) + 32 * v22) = v19;
  *(void *)(*(void *)(a1 + 528) + 32 * v22 + 16) = v17;
  if (v17)
  {
    v15.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)(id)(v17 + 8);
    uint64_t v27 = *(void *)(a1 + 520);
  }
  *(void *)(*(void *)(a1 + 528) + 32 * v22 + 24) = v26;
  *(_DWORD *)(v27 + 4 * v28) = v22;
  ++*(_DWORD *)(a1 + 540);
  ++*(_DWORD *)(a1 + 552);
  uint64_t v17 = *a2;
LABEL_17:
  uint64_t v29 = *(void *)(v17 + 80);
  if (v29)
  {
    do
    {
      uint64_t v30 = v17;
      uint64_t v17 = v29;
      if (*(unsigned char *)(*(void *)(*(void *)(v30 + 88) + 16) + 73)) {
        break;
      }
      uint64_t v29 = *(void *)(v29 + 80);
      uint64_t v30 = v17;
    }
    while (v29);
  }
  else
  {
    uint64_t v30 = v17;
  }
  uint64_t v31 = *(void *)(a1 + 480);
  if (v31)
  {
    uint64_t v32 = *(void *)(v30 + 160);
    uint64_t v33 = (void *)(*(void *)(a1 + 496) + 48);
    uint64_t v34 = v31 << 6;
    while (*(void *)(*(v33 - 6) + 24) != v32)
    {
      v33 += 8;
      v34 -= 64;
      if (!v34) {
        return;
      }
    }
    uint64_t v35 = *re::networkLogObjects((re *)v15.__d_.__rep_);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
    {
      uint64_t v36 = *(void *)(*a2 + 24);
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v36;
      _os_log_impl(&dword_228C70000, v35, OS_LOG_TYPE_INFO, "[Ownership] Requesting ownership for: %llu", buf, 0xCu);
    }
    uint64_t v37 = *(void *)(*a2 + 24);
    *(void *)buf = *(void *)(*(void *)(*(void *)(*a2 + 88) + 16) + 32);
    *(void *)&buf[8] = v37;
    char v53 = a3;
    v51[0] = a4;
    v51[1] = a5;
    uint64_t v38 = (_anonymous_namespace_ *)re::DynamicArray<unsigned char>::DynamicArray((uint64_t)&v54, (uint64_t)v51);
    *(void *)&long long v59 = v58;
    *((void *)&v59 + 1) = v56;
    unint64_t v39 = *(v33 - 3);
    unint64_t v40 = *(v33 - 2);
    if (v40 >= v39)
    {
      unint64_t v41 = v40 + 1;
      if (v39 < v40 + 1)
      {
        if (*(v33 - 4))
        {
          uint64_t v42 = 2 * v39;
          BOOL v43 = v39 == 0;
          unint64_t v44 = 8;
          if (!v43) {
            unint64_t v44 = v42;
          }
          if (v44 <= v41) {
            unint64_t v45 = v41;
          }
          else {
            unint64_t v45 = v44;
          }
          re::DynamicArray<re::SyncOwnershipRequest>::setCapacity(v33 - 4, v45);
        }
        else
        {
          re::DynamicArray<re::SyncOwnershipRequest>::setCapacity(v33 - 4, v41);
          ++*((_DWORD *)v33 - 2);
        }
      }
      unint64_t v40 = *(v33 - 2);
    }
    uint64_t v47 = *v33 + 80 * v40;
    long long v48 = *(_OWORD *)buf;
    *(unsigned char *)(v47 + 16) = v53;
    *(_OWORD *)uint64_t v47 = v48;
    *(void *)(v47 + 56) = 0;
    *(void *)(v47 + 32) = 0;
    *(void *)(v47 + 40) = 0;
    *(void *)(v47 + 24) = 0;
    *(_DWORD *)(v47 + 48) = 0;
    *(void *)(v47 + 24) = v54;
    uint64_t v54 = 0;
    *(void *)(v47 + 32) = v55;
    uint64_t v55 = 0;
    uint64_t v49 = *(void *)(v47 + 40);
    *(void *)(v47 + 40) = v56;
    uint64_t v56 = v49;
    uint64_t v50 = *(void *)(v47 + 56);
    *(void *)(v47 + 56) = v58;
    uint64_t v58 = v50;
    ++v57;
    ++*(_DWORD *)(v47 + 48);
    *(_OWORD *)(v47 + 64) = v59;
    ++*(v33 - 2);
    ++*((_DWORD *)v33 - 2);
    if (v54)
    {
      if (v58) {
        (*(void (**)(void))(*(void *)v54 + 40))();
      }
    }
  }
}

double re::SyncObjectManager::adjustTimeForSender(re::SyncObjectManager *this, double a2, uint64_t a3)
{
  uint64_t v4 = *((void *)this + 60);
  if (v4)
  {
    uint64_t v5 = *((void *)this + 62);
    uint64_t v6 = v4 << 6;
    while (*(void *)(*(void *)v5 + 24) != a3)
    {
      v5 += 64;
      v6 -= 64;
      if (!v6) {
        return a2;
      }
    }
    re::Transport::connectionStats((re::Transport *)(*((void *)this + 51) + 2320), *(void *)(*(void *)v5 + 32), (uint64_t)v9);
    if (v9[0])
    {
      LODWORD(v7) = v10;
      return a2 + (double)v7 / 1000.0 * 0.5;
    }
  }
  return a2;
}

uint64_t re::SyncObjectManager::pausePeer(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(void *)(this + 480);
  if (v2)
  {
    uint64_t v3 = *(void *)(this + 496) + 8;
    uint64_t v4 = v2 << 6;
    while (*(void *)(*(void *)(v3 - 8) + 24) != a2)
    {
      v3 += 64;
      v4 -= 64;
      if (!v4) {
        return this;
      }
    }
    return (*(uint64_t (**)(void))(**(void **)v3 + 64))();
  }
  return this;
}

uint64_t re::SyncObjectManager::resumePeer(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(void *)(this + 480);
  if (v2)
  {
    uint64_t v3 = *(void *)(this + 496) + 8;
    uint64_t v4 = v2 << 6;
    while (*(void *)(*(void *)(v3 - 8) + 24) != a2)
    {
      v3 += 64;
      v4 -= 64;
      if (!v4) {
        return this;
      }
    }
    return (*(uint64_t (**)(void))(**(void **)v3 + 72))();
  }
  return this;
}

uint64_t re::SyncSession::receive()
{
  return 0;
}

uint64_t re::SyncSession::send()
{
  return 0;
}

void *re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event(void *a1)
{
  if (*a1) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)a1);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)(a1 + 5));
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)a1);
  return a1;
}

void re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::~Callable()
{
}

void re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = v2[60];
  if (v3)
  {
    uint64_t v4 = *a2;
    uint64_t v5 = v2[62];
    uint64_t v6 = v5 + (v3 << 6);
    do
    {
      unint64_t v7 = *(re::SyncViewer **)(v5 + 56);
      if (v7)
      {
        if (*((void *)v7 + 7) == *(void *)(v4 + 24))
        {
          uint64_t v8 = *(void *)(v4 + 120);
          uint64_t v9 = *(void *)(v4 + 104);
          if (v9)
          {
            uint64_t v10 = 8 * v9;
            uint64_t v11 = *(re::SyncViewer ***)(v4 + 120);
            while (*v11 != v7)
            {
              ++v11;
              v10 -= 8;
              if (!v10)
              {
                uint64_t v11 = (re::SyncViewer **)(v8 + 8 * v9);
                break;
              }
            }
          }
          else
          {
            uint64_t v11 = *(re::SyncViewer ***)(v4 + 120);
          }
          if (v9 != ((uint64_t)v11 - v8) >> 3) {
            goto LABEL_31;
          }
        }
        else
        {
          uint64_t v12 = v2[76];
          if (!v12)
          {
            uint64_t v18 = *(void *)(v4 + 120);
            uint64_t v19 = *(void *)(v4 + 104);
            if (v19)
            {
              uint64_t v20 = 8 * v19;
              uint64_t v21 = *(re::SyncViewer ***)(v4 + 120);
              while (*v21 != v7)
              {
                ++v21;
                v20 -= 8;
                if (!v20)
                {
                  uint64_t v21 = (re::SyncViewer **)(v18 + 8 * v19);
                  break;
                }
              }
            }
            else
            {
              uint64_t v21 = *(re::SyncViewer ***)(v4 + 120);
            }
            if (v19 == ((uint64_t)v21 - v18) >> 3) {
              goto LABEL_31;
            }
LABEL_30:
            re::SyncView::removeViewer(v4, v7);
            goto LABEL_31;
          }
          int v13 = (*(uint64_t (**)(uint64_t, void *))(v12 + 16))(v12, v2);
          uint64_t v14 = *(void *)(v4 + 120);
          uint64_t v15 = *(void *)(v4 + 104);
          if (v15)
          {
            uint64_t v16 = 8 * v15;
            uint64_t v17 = *(re::SyncViewer ***)(v4 + 120);
            while (*v17 != v7)
            {
              ++v17;
              v16 -= 8;
              if (!v16)
              {
                uint64_t v17 = (re::SyncViewer **)(v14 + 8 * v15);
                break;
              }
            }
          }
          else
          {
            uint64_t v17 = *(re::SyncViewer ***)(v4 + 120);
          }
          if (v13 == (v15 != ((uint64_t)v17 - v14) >> 3)) {
            goto LABEL_31;
          }
          if (!v13) {
            goto LABEL_30;
          }
        }
        re::SyncView::addViewer((re::SyncViewer ***)v4, v7);
      }
LABEL_31:
      v5 += 64;
    }
    while (v5 != v6);
  }
}

void *re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD34880;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD34880;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::size()
{
  return 16;
}

uint64_t (***re::FunctionBase<24ul,void ()(re::SyncView *)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::~Callable()
{
}

void re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::operator()(uint64_t a1, re::SyncViewer **a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  uint64_t v4 = v3[60];
  if (v4)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = *((void *)*a2 + 7);
    uint64_t v8 = v3[62];
    uint64_t v9 = v4 << 6;
    while (*(void *)(*(void *)v8 + 24) != v7)
    {
      v8 += 64;
      v9 -= 64;
      if (!v9) {
        return;
      }
    }
    uint64_t v10 = *(void *)(a1 + 16);
    if (v7 != *(void *)(v10 + 24) && v7 != *(void *)(v10 + 32))
    {
      uint64_t v11 = v3[76];
      if (!v11 || !(*(unsigned int (**)(void))(v11 + 16))()) {
        return;
      }
      uint64_t v10 = *(void *)(a1 + 16);
    }
    re::SyncView::addViewer((re::SyncViewer ***)v10, v6);
  }
}

uint64_t re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD348D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD348D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::size()
{
  return 24;
}

uint64_t (***re::FunctionBase<24ul,void ()(re::SyncViewer *)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::SyncOwnershipRequest>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 80 * v4;
        uint64_t v6 = v3 + 24;
        do
        {
          re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v6);
          v6 += 80;
          v5 -= 80;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::SyncOwnershipRequest>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::SyncOwnershipRequest>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    unint64_t v6 = a2[2];
    if (v6 >= *(void *)(a1 + 16))
    {
      re::DynamicArray<re::SyncOwnershipRequest>::setCapacity((void *)a1, a2[2]);
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,0>((long long *)a2[4], (long long *)(a2[4] + 80 * *(void *)(a1 + 16)), *(void *)(a1 + 32));
      uint64_t v10 = *(void *)(a1 + 16);
      if (v10 != v6)
      {
        uint64_t v11 = a2[4];
        uint64_t v12 = v11 + 80 * v6;
        uint64_t v13 = 80 * v10 + 24;
        uint64_t v14 = v11 + v13;
        uint64_t v15 = *(void *)(a1 + 32) + v13;
        do
        {
          long long v16 = *(_OWORD *)(v14 - 24);
          *(unsigned char *)(v15 - 8) = *(unsigned char *)(v14 - 8);
          *(_OWORD *)(v15 - 24) = v16;
          uint64_t v17 = re::DynamicArray<unsigned char>::DynamicArray(v15, (uint64_t *)v14);
          *(_OWORD *)(v17 + 40) = *(_OWORD *)(v14 + 40);
          uint64_t v18 = v14 + 56;
          v14 += 80;
          uint64_t v15 = v17 + 80;
        }
        while (v18 != v12);
      }
    }
    else
    {
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,0>((long long *)a2[4], (long long *)(a2[4] + 80 * v6), *(void *)(a1 + 32));
      uint64_t v7 = *(void *)(a1 + 16);
      if (v6 != v7)
      {
        uint64_t v8 = 80 * v7 - 80 * v6;
        uint64_t v9 = *(void *)(a1 + 32) + 80 * v6 + 24;
        do
        {
          re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v9);
          v9 += 80;
          v8 -= 80;
        }
        while (v8);
      }
    }
    *(void *)(a1 + 16) = v6;
  }
  return a1;
}

void *re::DynamicArray<re::SyncOwnershipRequest>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::SyncOwnershipRequest>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x50uLL))
        {
          uint64_t v2 = 80 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 80 * v9;
        uint64_t v11 = v7;
        do
        {
          long long v12 = *(_OWORD *)v8;
          *((unsigned char *)v11 + 16) = *(unsigned char *)(v8 + 16);
          *(_OWORD *)uint64_t v11 = v12;
          v11[7] = 0;
          v11[4] = 0;
          v11[5] = 0;
          v11[3] = 0;
          *((_DWORD *)v11 + 12) = 0;
          uint64_t v13 = *(void *)(v8 + 24);
          uint64_t v14 = *(void *)(v8 + 32);
          uint64_t v15 = v8 + 24;
          v11[3] = v13;
          v11[4] = v14;
          *(void *)uint64_t v15 = 0;
          *(void *)(v15 + 8) = 0;
          uint64_t v16 = v11[5];
          v11[5] = *(void *)(v15 + 16);
          *(void *)(v15 + 16) = v16;
          uint64_t v17 = v11[7];
          v11[7] = *(void *)(v15 + 32);
          *(void *)(v15 + 32) = v17;
          ++*(_DWORD *)(v15 + 24);
          ++*((_DWORD *)v11 + 12);
          *((_OWORD *)v11 + 4) = *(_OWORD *)(v15 + 40);
          re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v15);
          uint64_t v8 = v15 + 56;
          v11 += 10;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

__n128 std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,re::SyncOwnershipRequest *,0>(long long *a1, long long *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    unint64_t v5 = a1;
    do
    {
      long long v6 = *v5;
      *(unsigned char *)(a3 + 16) = *((unsigned char *)v5 + 16);
      *(_OWORD *)a3 = v6;
      re::DynamicArray<unsigned char>::operator=(a3 + 24, (uint64_t *)v5 + 3);
      __n128 result = (__n128)v5[4];
      *(__n128 *)(a3 + 64) = result;
      v5 += 5;
      a3 += 80;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<unsigned char>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4) {
        re::DynamicArray<unsigned char>::copy((void **)a1, (uint64_t)a2);
      }
      else {
        *(void *)(a1 + 16) = 0;
      }
      ++*(_DWORD *)(a1 + 24);
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<unsigned char>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<unsigned char>::copy((void **)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void **re::DynamicArray<unsigned char>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  size_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<unsigned char>::setCapacity(result, *(void *)(a2 + 16));
    size_t v5 = (size_t)v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), v5);
      long long v6 = (char *)v3[2];
    }
    else
    {
      long long v6 = 0;
    }
    __n128 result = (void **)memcpy(&v6[(void)v3[4]], &v6[*(void *)(a2 + 32)], v4 - (void)v6);
  }
  else if (v4)
  {
    __n128 result = (void **)memmove(result[4], *(const void **)(a2 + 32), v4);
  }
  _OWORD v3[2] = (void *)v4;
  return result;
}

void *re::DynamicArray<unsigned char>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2 != a2)
  {
    size_t v4 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (*v4)
      {
        if (!a2)
        {
          long long v6 = 0;
          if (!v2) {
            goto LABEL_8;
          }
          goto LABEL_7;
        }
        __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2, 1);
        if (result)
        {
          long long v6 = result;
          if (!v4[1])
          {
LABEL_8:
            v4[4] = v6;
            v4[1] = a2;
            return result;
          }
LABEL_7:
          memcpy(v6, (const void *)v4[4], v4[2]);
          __n128 result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v4 + 40))(*v4, v4[4]);
          goto LABEL_8;
        }
        re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, a2, *(void *)(*v4 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        __n128 result = (void *)re::DynamicArray<unsigned char>::setCapacity(v4, a2);
        ++*((_DWORD *)v4 + 6);
      }
    }
  }
  return result;
}

uint64_t re::DynamicArray<unsigned char>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<unsigned char>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<unsigned char>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

void *re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::~Callable(void *a1)
{
  *a1 = &unk_26DD34930;
  re::DynamicArray<re::SyncOwnershipRequest>::deinit((uint64_t)(a1 + 4));
  uint64_t v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  uint64_t v3 = a1[2];
  if (v3)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::~Callable(void *a1)
{
  *a1 = &unk_26DD34930;
  re::DynamicArray<re::SyncOwnershipRequest>::deinit((uint64_t)(a1 + 4));
  uint64_t v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  uint64_t v3 = a1[2];
  if (v3)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(re::SyncViewer **)(a1 + 72);
  if (*((void *)v3 + 7) != *(void *)(v2 + 24))
  {
    if (!(*(unsigned int (**)(void))(*(void *)(*(void *)(a1 + 8) + 608) + 16))()) {
      return;
    }
    uint64_t v3 = *(re::SyncViewer **)(a1 + 72);
  }
  re::SyncView::addViewer((re::SyncViewer ***)v2, v3);
}

void *re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::cloneInto(void *a1, void *a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  *a2 = &unk_26DD34930;
  a2[1] = v5;
  a2[2] = v4;
  if (v4) {
    id v6 = (id)(v4 + 8);
  }
  uint64_t v7 = a1[3];
  a2[3] = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  re::DynamicArray<re::SyncOwnershipRequest>::DynamicArray((uint64_t)(a2 + 4), a1 + 4);
  a2[9] = a1[9];
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD34930;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_DWORD *)(a2 + 56) = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(void *)(a2 + 40) = v2;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v3 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v3;
  uint64_t v4 = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = v4;
  ++*(_DWORD *)(a1 + 56);
  ++*(_DWORD *)(a2 + 56);
  *(void *)(a2 + 72) = *(void *)(a1 + 72);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::size()
{
  return 80;
}

re::internal::AriadneSignpostScopeGuard *re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard(re::internal::AriadneSignpostScopeGuard *this, int a2, uint64_t a3)
{
  *(_DWORD *)this = a2;
  *((void *)this + 1) = a3;
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  return this;
}

uint64_t re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::internal::SyncSnapshotEntry>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::internal::SyncSnapshotEntry>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = 24 * v2;
    do
    {
      if (*(void *)v3)
      {

        *(void *)uint64_t v3 = 0;
      }
      v3 += 24;
      v4 -= 24;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard(re::internal::AriadneSignpostScopeGuard *this)
{
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
}

void re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::~Callable()
{
}

void re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t Object = (uint64_t)re::SyncObjectStore::findObject(*(re::SyncObjectStore **)(v4 + 416), *(void *)a2, *(void *)(a2 + 8), (re::SyncObjectTypedStore ***)v39);
  id v6 = v39[0];
  if (v39[0])
  {
    if (!*(unsigned char *)(*(void *)(*((void *)v39[0] + 11) + 16) + 73)) {
      goto LABEL_52;
    }
    uint64_t v7 = (re::SyncObject *)*((void *)v39[0] + 10);
    id v8 = v39[0];
    if (v7)
    {
      uint64_t v9 = (re::SyncObject *)*((void *)v39[0] + 10);
      uint64_t v10 = v39[0];
      do
      {
        id v8 = v10;
        uint64_t v10 = v9;
        if (*(unsigned char *)(*(void *)(*((void *)v8 + 11) + 16) + 73)) {
          break;
        }
        uint64_t v9 = (re::SyncObject *)*((void *)v9 + 10);
        id v8 = v10;
      }
      while (v9);
    }
    if (*((void *)v8 + 20) || !*((void *)v39[0] + 20) && *((void *)v39[0] + 17))
    {
LABEL_52:

      return;
    }
    if (v7)
    {
      uint64_t v11 = (re::SyncObject *)*((void *)v39[0] + 10);
      long long v12 = v39[0];
      do
      {
        uint64_t v13 = v12;
        long long v12 = v11;
        if (*(unsigned char *)(*(void *)(*((void *)v13 + 11) + 16) + 73)) {
          break;
        }
        uint64_t v11 = (re::SyncObject *)*((void *)v11 + 10);
        uint64_t v13 = v12;
      }
      while (v11);
      BOOL v14 = *((unsigned char *)v13 + 152) != 0;
      BOOL v38 = *((unsigned char *)v13 + 152) == 0;
      do
      {
        uint64_t v15 = v6;
        id v6 = v7;
        if (*(unsigned char *)(*(void *)(*((void *)v15 + 11) + 16) + 73)) {
          break;
        }
        uint64_t v7 = (re::SyncObject *)*((void *)v7 + 10);
        uint64_t v15 = v6;
      }
      while (v7);
      int v16 = *((unsigned __int8 *)v15 + 152);
    }
    else
    {
      int v16 = *((unsigned __int8 *)v39[0] + 152);
      BOOL v14 = v16 != 0;
      BOOL v38 = *((unsigned char *)v39[0] + 152) == 0;
    }
    if (!v16) {
      goto LABEL_48;
    }
    uint64_t v17 = *(void *)(v4 + 432);
    if (v17)
    {
      uint64_t Object = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 48))(v17);
      uint64_t v18 = Object;
      uint64_t v19 = *(re::SyncObject **)(a1 + 16);
      uint64_t v20 = *(re::SyncObject **)(a2 + 72);
      v39[2] = *(re::SyncObject **)(a2 + 64);
      v39[3] = v19;
      v39[1] = v20;
      int v21 = *(_DWORD *)(Object + 80);
      *(_DWORD *)(Object + 80) = v21 + 1;
      if (*(void *)(Object + 16))
      {
        unint64_t v22 = 0;
        do
        {
          uint64_t Object = (*(uint64_t (**)(uint64_t))(*(void *)(v18 + 32) + 32 * v22 + 24))(v4);
          if (Object == 1) {
            uint64_t Object = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)v18, v22);
          }
          else {
            ++v22;
          }
        }
        while (v22 < *(void *)(v18 + 16));
        int v21 = *(_DWORD *)(v18 + 80) - 1;
      }
      *(_DWORD *)(v18 + 80) = v21;
      if (!v21)
      {
        uint64_t v23 = *(void *)(v18 + 56);
        if (v23)
        {
          uint64_t v24 = 0;
          for (unint64_t i = 0; i != v23; ++i)
          {
            unint64_t v26 = *(void *)(v18 + 56);
            if (v26 <= i)
            {
              v39[4] = 0;
              memset(buf, 0, sizeof(buf));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v42 = 136315906;
              BOOL v43 = "operator[]";
              __int16 v44 = 1024;
              int v45 = 789;
              __int16 v46 = 2048;
              unint64_t v47 = i;
              __int16 v48 = 2048;
              unint64_t v49 = v26;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            uint64_t v27 = *(void *)(v18 + 72) + v24;
            uint64_t v28 = *(void *)(v27 + 32);
            long long v29 = *(_OWORD *)(v27 + 16);
            v40[0] = *(_OWORD *)v27;
            v40[1] = v29;
            uint64_t v41 = v28;
            if (LOBYTE(v40[0]))
            {
              uint64_t Object = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v18, (void *)v40 + 1, (uint64_t)buf);
              if (!LOBYTE(buf[0])) {
                re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)v18, (uint64_t)v40 + 8);
              }
            }
            else
            {
              uint64_t Object = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v18, (void *)v40 + 1, (uint64_t)buf);
              if (LOBYTE(buf[0])) {
                uint64_t Object = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)v18, *((unint64_t *)&buf[0] + 1));
              }
            }
            v24 += 40;
          }
        }
      }
      if (v38) {
        goto LABEL_40;
      }
LABEL_49:
      uint64_t v33 = *re::networkLogObjects((re *)Object);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v37 = *(void *)a2;
        uint64_t v36 = *(void *)(a2 + 8);
        LODWORD(buf[0]) = 134218240;
        *(void *)((char *)buf + 4) = v36;
        WORD6(buf[0]) = 2048;
        *(void *)((char *)buf + 14) = v37;
        _os_log_debug_impl(&dword_228C70000, v33, OS_LOG_TYPE_DEBUG, "[Ownership] Rejected request for locked object %llu (%llu)", (uint8_t *)buf, 0x16u);
      }
LABEL_51:
      id v6 = v39[0];
      if (!v39[0]) {
        return;
      }
      goto LABEL_52;
    }
    uint64_t v32 = *re::networkLogObjects(0);
    uint64_t Object = os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
    if (Object)
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl(&dword_228C70000, v32, OS_LOG_TYPE_ERROR, "[Ownership] No NetworkSyncManager found, ownership request not forwarded.", (uint8_t *)buf, 2u);
      if (v14) {
        goto LABEL_49;
      }
    }
    else
    {
LABEL_48:
      if (v14) {
        goto LABEL_49;
      }
    }
LABEL_40:
    uint64_t v30 = *re::networkLogObjects((re *)Object);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v35 = *(void *)a2;
      uint64_t v34 = *(void *)(a2 + 8);
      LODWORD(buf[0]) = 134218240;
      *(void *)((char *)buf + 4) = v34;
      WORD6(buf[0]) = 2048;
      *(void *)((char *)buf + 14) = v35;
      _os_log_debug_impl(&dword_228C70000, v30, OS_LOG_TYPE_DEBUG, "[Ownership] Granted request for object %llu (%llu)", (uint8_t *)buf, 0x16u);
    }
    uint64_t v31 = v39[0];
    if (!*((void *)v39[0] + 20) && !*((void *)v39[0] + 17)) {
      *((unsigned char *)v39[0] + 152) = *(unsigned char *)(a2 + 16);
    }
    if (re::SyncObject::handOff(v31, *(void *)(a1 + 16))) {
      re::DynamicArray<re::SharedPtr<re::SyncObject>>::add((void *)(v4 + 568), (uint64_t *)v39);
    }
    goto LABEL_51;
  }
}

uint64_t re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD34988;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD34988;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SyncObjectManager::receiveOwnershipRequests(re::SyncObjectManager::PeerState &)::$_0,void ()(re::SyncOwnershipRequest const&)>::size()
{
  return 24;
}

uint64_t (***re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable(uint64_t a1))(void)
{
  __n128 result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    __n128 result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      __n128 result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 8 * v4;
        do
        {
          if (*(void *)v3)
          {

            *(void *)uint64_t v3 = 0;
          }
          v3 += 8;
          v5 -= 8;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double re::Event<re::Session>::addSubscription(_DWORD *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, (void *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (a1[20])
    {
      v6[0] = 1;
      long long v5 = *(_OWORD *)(a2 + 16);
      long long v7 = *(_OWORD *)a2;
      long long v8 = v5;
      *(void *)&double result = re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 10), (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(void *)&double result = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, a2).n128_u64[0];
    }
  }
  return result;
}

__n128 re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 40 * v4;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  *(__n128 *)uint64_t v5 = result;
  *(_OWORD *)(v5 + 16) = v7;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          unint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 40 * v5[2]);
            __n128 result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        __n128 result = (void *)re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::Event<re::Session>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

uint64_t re::Event<re::Session,re::SessionError>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke(uint64_t a1, void *a2, unsigned int *a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = (uint64_t (*)(void *, uint64_t, uint64_t *))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t *))(*v6 + v5);
  }
  uint64_t v7 = *a3;
  uint64_t v11 = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  uint64_t v9 = v5(v6, a1, &v11);
  if (v11) {

  }
  return v9;
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v7 = (uint64_t (*)(void *, uint64_t, uint64_t *, void))a2[1];
  uint64_t v6 = a2[2];
  id v8 = (void *)(*a2 + (v6 >> 1));
  if (v6) {
    uint64_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t *, void))(*v8 + v7);
  }
  uint64_t v9 = *a3;
  uint64_t v13 = v9;
  if (v9) {
    id v10 = (id)(v9 + 8);
  }
  uint64_t v11 = v7(v8, a1, &v13, *a4);
  if (v13) {

  }
  return v11;
}

uint64_t re::Event<re::Session,unsigned long long>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

uint64_t re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SyncObjectManager>(re::SyncObjectManager *,REEventHandlerResult (re::SyncObjectManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

void re::Event<re::SyncViewManager,re::SyncView *>::removeSubscription(uint64_t a1, long long *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, a2, (uint64_t)v5);
  if (v5[0])
  {
    if (*(_DWORD *)(a1 + 80))
    {
      v5[0] = 0;
      long long v4 = a2[1];
      long long v6 = *a2;
      long long v7 = v4;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 40), (uint64_t)v5);
    }
    else
    {
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable((void *)a1, a2);
    }
  }
}

void *re::DynamicArray<re::SyncObjectManager::PeerState>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::SyncObjectManager::PeerState>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 58)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 64, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          unint64_t v2 = a2 << 6;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2 << 6, 8);
          if (result)
          {
            long long v7 = result;
            if (!v5[1]) {
              goto LABEL_20;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      long long v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 32;
        uint64_t v11 = v9 << 6;
        long long v12 = v7;
        do
        {
          *(_OWORD *)long long v12 = *(_OWORD *)(v10 - 32);
          *(_OWORD *)(v10 - 32) = 0u;
          v12[6] = 0;
          void v12[2] = 0;
          *(_OWORD *)(v12 + 3) = 0u;
          *((_DWORD *)v12 + 10) = 0;
          uint64_t v13 = *(void *)(v10 - 8);
          void v12[2] = *(void *)(v10 - 16);
          *(void *)(v10 - 16) = 0;
          v12[3] = v13;
          *(void *)(v10 - 8) = 0;
          uint64_t v14 = v12[4];
          v12[4] = *(void *)v10;
          *(void *)uint64_t v10 = v14;
          uint64_t v15 = v12[6];
          v12[6] = *(void *)(v10 + 16);
          *(void *)(v10 + 16) = v15;
          ++*(_DWORD *)(v10 + 8);
          ++*((_DWORD *)v12 + 10);
          v12[7] = *(void *)(v10 + 24);
          re::DynamicArray<re::SyncOwnershipRequest>::deinit(v10 - 16);
          uint64_t v16 = *(void *)(v10 - 24);
          if (v16)
          {

            *(void *)(v10 - 24) = 0;
          }
          uint64_t v17 = *(void *)(v10 - 32);
          if (v17)
          {

            *(void *)(v10 - 32) = 0;
          }
          v10 += 64;
          v12 += 8;
          v11 -= 64;
        }
        while (v11);
        uint64_t v8 = v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

void *re::DynamicArray<re::SharedPtr<re::SyncObject>>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    long long v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 8 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_15;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 8 * v9;
        uint64_t v11 = v7;
        long long v12 = (void *)v5[4];
        do
        {
          *v11++ = *v12;
          *v12++ = 0;
          v10 -= 8;
        }
        while (v10);
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v24, 0, 36);
      *(void *)&v24[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v24, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v24;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v24[8];
      *(_OWORD *)uint64_t v24 = v5;
      *(void *)&v24[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v24[24];
      *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v24[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = (uint64_t *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            unint64_t v14 = *(v13 - 2);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashTable<re::SharedPtr<re::SyncObject>,std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 32 * v17) = v14;
            uint64_t v21 = *v13;
            *(void *)(*(void *)(a1 + 16) + 32 * v17 + 16) = *v13;
            if (v21)
            {
              id v22 = (id)(v21 + 8);
              uint64_t v12 = *(void *)(a1 + 8);
            }
            *(void *)(*(void *)(a1 + 16) + 32 * v17 + 24) = v13[1];
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 4;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v24);
    }
  }
  else
  {
    if (a2) {
      signed int v23 = a2;
    }
    else {
      signed int v23 = 3;
    }
  }
}

void re::MultipeerManager::applySessionConfigDefaults(uint64_t a1, const char *a2)
{
  re::Defaults::intValue((re::Defaults *)"network.multipeerservice.sessionInitTimeOutMs", a2, (uint64_t)v25);
  re::Defaults::intValue((re::Defaults *)"network.multipeerservice.sessionHandshakeTimeOutMs", v3, (uint64_t)v23);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.sessionIsLeader", v4, v22);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.sessionForceAuthorityOverIncomingObjects", v5, v21);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.sessionShutdownOnVersionMismatch", v6, v20);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.sessionUseReliableSync", v7, v19);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.enableThrottling", v8, v18);
  re::Defaults::BOOLValue((re::Defaults *)"network.multipeerservice.enableMessageFragmentation", v9, v17);
  re::Defaults::intValue((re::Defaults *)"network.multipeerservice.sessionResendPeriodMs", v10, (uint64_t)v15);
  re::Defaults::intValue((re::Defaults *)"network.multipeerservice.syncPacketSizeLimit", v11, (uint64_t)v13);
  if (v25[0]) {
    *(_DWORD *)(a1 + 24) = v26;
  }
  if (v23[0]) {
    *(_DWORD *)(a1 + 28) = v24;
  }
  if (v22[0]) {
    *(unsigned char *)(a1 + 40) = v22[1];
  }
  if (v21[0]) {
    *(unsigned char *)(a1 + 72) = v21[1];
  }
  if (v20[0]) {
    *(unsigned char *)(a1 + 78) = v20[1];
  }
  if (v19[0]) {
    char v12 = v19[1];
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(a1 + 79) = v12;
  if (v18[0]) {
    *(unsigned char *)(a1 + 76) = v18[1];
  }
  if (v17[0]) {
    *(unsigned char *)(a1 + 77) = v17[1];
  }
  if (v15[0]) {
    *(_DWORD *)(a1 + 80) = v16;
  }
  if (v13[0]) {
    *(_DWORD *)(a1 + 84) = v14;
  }
}

BOOL re::MultipeerManager::initView(uint64_t *a1, id *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v4 = re::globalAllocators((re *)a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 248, 8);
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 192) = 0u;
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(void *)(v5 + 240) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v5, 0);
  *(void *)(v5 + 24) = 0;
  *(void *)uint64_t v5 = &unk_26DD36A08;
  *(void *)(v5 + 32) = 0;
  *(void *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 48) = 0;
  *(void *)(v5 + 96) = 0;
  *(_DWORD *)(v5 + 104) = 0;
  *(_OWORD *)(v5 + 56) = 0u;
  *(_OWORD *)(v5 + 72) = 0u;
  *(_DWORD *)(v5 + 88) = 0;
  *(void *)(v5 + 120) = 0;
  *(void *)(v5 + 128) = 0;
  *(void *)(v5 + 112) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  *(void *)(v5 + 184) = 0;
  *(_DWORD *)(v5 + 192) = 0;
  *(_DWORD *)(v5 + 176) = 0;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(void *)(v5 + 240) = 0;
  *(_OWORD *)(v5 + 200) = 0u;
  *(_OWORD *)(v5 + 216) = 0u;
  *(_DWORD *)(v5 + 232) = 0;
  id v16 = *a2;
  v6.var0 = &v16;
  BOOL v7 = re::MultipeerDiscoveryView::init((id *)v5, v6);

  if (v7)
  {
    re::SharedPtr<re::SyncObject>::reset(a1 + 8, v5);
  }
  else
  {
    long long v9 = *re::networkLogObjects(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v11 = *a2;
      char v12 = v9;
      uint64_t v13 = [v11 myPeerID];
      id v14 = [v13 displayName];
      uint64_t v15 = [v14 UTF8String];
      *(_DWORD *)buf = 136315138;
      uint64_t v18 = v15;
      _os_log_error_impl(&dword_228C70000, v12, OS_LOG_TYPE_ERROR, "Failed to initiate RE discovery with MCSession (%s).", buf, 0xCu);
    }
  }

  return v7;
}

void re::MultipeerManager::~MultipeerManager(id *this)
{
  *this = &unk_26DD34AC0;
  if (*((unsigned char *)this + 24))
  {
    re::MultipeerManager::stopSync((re::MultipeerManager *)this);
    uint64_t v2 = (char *)this[4];
    if (v2)
    {

      this[4] = 0;
    }
    *((unsigned char *)this + 24) = 0;
  }
  else
  {
    uint64_t v3 = (char *)this[4];
    if (v3)
    {

      this[4] = 0;
    }
  }
  id v4 = this[1];
  this[1] = 0;
}

{
  uint64_t vars8;

  re::MultipeerManager::~MultipeerManager(this);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::MultipeerManager::setHandshakeTimeoutAndCountMs(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(this + 40) = a2;
  *(_DWORD *)(this + 44) = a3;
  return this;
}

BOOL re::MultipeerManager::createSessionAndStartSync(uint64_t a1, uint64_t a2)
{
  v34[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a2 + 64);
  if (!v2 || (id v5 = *(id *)(v2 + 200), v5, !v5))
  {
    ObjCObject v6 = *re::networkLogObjects((re *)a1);
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v21) = 0;
    unsigned int v8 = "No MCSession object provided.";
    goto LABEL_8;
  }
  if (*(void *)(a1 + 32))
  {
    ObjCObject v6 = *re::networkLogObjects((re *)a1);
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v21) = 0;
    unsigned int v8 = "Already syncing over another session. Stop it first.";
LABEL_8:
    _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v21, 2u);
    return 0;
  }
  id v21 = *(id *)a2;
  long long v22 = *(_OWORD *)(a2 + 8);
  uint64_t v9 = *(void *)(a2 + 32);
  uint64_t v23 = *(void *)(a2 + 24);
  uint64_t v24 = v9;
  if (v9) {
    id v10 = (id)(v9 + 8);
  }
  long long v25 = *(_OWORD *)(a2 + 40);
  uint64_t v11 = *(void *)(a2 + 64);
  uint64_t v26 = *(void *)(a2 + 56);
  uint64_t v27 = v11;
  if (v11) {
    id v12 = (id)(v11 + 8);
  }
  long long v28 = *(_OWORD *)(a2 + 72);
  uint64_t v13 = *(void *)(a2 + 104);
  uint64_t v29 = *(void *)(a2 + 88);
  uint64_t v31 = v13;
  if (v13) {
    id v14 = (id)(v13 + 8);
  }
  uint64_t v15 = *(void *)(a2 + 112);
  uint64_t v32 = v15;
  if (v15) {
    id v16 = (id)(v15 + 8);
  }
  int v33 = *(_DWORD *)(a2 + 120);
  unsigned int v17 = *(_DWORD *)(a1 + 40);
  if (v17 <= 1) {
    unsigned int v17 = 1;
  }
  HIDWORD(v23) = *(_DWORD *)(a1 + 44);
  unsigned int v30 = v17;
  id v21 = *(id *)(a1 + 8);

  uint64_t v18 = *(void *)(a1 + 16);
  (*(void (**)(void *__return_ptr, uint64_t, id *))(*(void *)v18 + 104))(v34, v18, &v21);
  uint64_t v19 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v34[0];
  v34[0] = v19;
  if (v19) {

  }
  int v20 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v18 + 40))(v18);
  v34[0] = a1;
  v34[1] = re::MultipeerManager::sessionRemovedFromSync;
  v34[2] = 0;
  v34[3] = re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::MultipeerManager>(re::MultipeerManager *,REEventHandlerResult (re::MultipeerManager::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v20, (uint64_t)v34);
  if (v32)
  {

    uint64_t v32 = 0;
  }
  if (v31)
  {

    uint64_t v31 = 0;
  }
  if (v27)
  {

    uint64_t v27 = 0;
  }
  if (v24) {

  }
  return 1;
}

uint64_t re::MultipeerManager::sessionRemovedFromSync(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*a3 != v3) {
    return 0;
  }
  if (v3)
  {

    *(void *)(a1 + 32) = 0;
  }
  return 1;
}

void re::MultipeerManager::stopSync(re::MultipeerManager *this)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v1 = *((void *)this + 4);
  if (v1)
  {
    uint64_t v3 = *((void *)this + 2);
    uint64_t v12 = *((void *)this + 4);
    id v4 = (id)(v1 + 8);
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 112))(v3, &v12);
    if (v12)
    {

      uint64_t v12 = 0;
    }
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
    if (*(void *)(v5 + 16))
    {
      uint64_t v6 = v5;
      unint64_t v7 = 0;
      unsigned int v8 = (_anonymous_namespace_ *)(v5 + 40);
      do
      {
        uint64_t v9 = (re::MultipeerManager **)(*(void *)(v6 + 32) + 32 * v7);
        if (*v9 == this)
        {
          if (!*(_DWORD *)(v6 + 80))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)v6, v7);
            continue;
          }
          v13[0] = 0;
          long long v10 = *((_OWORD *)v9 + 1);
          long long v14 = *(_OWORD *)v9;
          long long v15 = v10;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add(v8, (uint64_t)v13);
        }
        ++v7;
      }
      while (v7 < *(void *)(v6 + 16));
    }
    uint64_t v11 = *((void *)this + 4);
    if (v11)
    {

      *((void *)this + 4) = 0;
    }
  }
}

void re::MultipeerManager::session(re::MultipeerManager *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 4);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 2208);
    if (v4) {
      id v5 = (id)(v4 + 8);
    }
    *a2 = *(id *)(v4 + 200);
  }
  else
  {
    *a2 = 0;
  }
}

void *re::MultipeerManager::internalSession@<X0>(void *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = this[4];
  *a2 = v2;
  if (v2) {
    return (id)(v2 + 8);
  }
  return this;
}

void re::MultipeerManager::mcPeerID(re::MultipeerManager *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  id v5 = (void *)*((void *)this + 4);
  uint64_t v6 = (re::MultipeerDiscoveryView *)v5[276];
  if (v6)
  {
    unsigned int v8 = (char *)v6 + 8;

    id v5 = (void *)*((void *)this + 4);
  }
  uint64_t v9 = v5[287];
  if (v9)
  {
    long long v10 = (uint64_t *)v5[289];
    uint64_t v11 = 8 * v9;
    while (1)
    {
      uint64_t v12 = *v10;
      if (*(void *)(*v10 + 24) == a2) {
        break;
      }
      ++v10;
      v11 -= 8;
      if (!v11) {
        goto LABEL_20;
      }
    }
    uint64_t v13 = (void *)(v12 + 8);
    id v14 = (id)(v12 + 8);
    if ((*(uint64_t (**)(re::MultipeerDiscoveryView *))(*(void *)v6 + 48))(v6))
    {
      unint64_t v15 = 0;
      do
      {
        (*(void (**)(uint64_t *__return_ptr, re::MultipeerDiscoveryView *, unint64_t))(*(void *)v6 + 56))(&v17, v6, v15);
        (*(void (**)(_OWORD *__return_ptr))(*(void *)v17 + 40))(v18);
        BOOL v16 = re::DynamicString::operator==(v12 + 40, (uint64_t)v18);
        if (*(void *)&v18[0])
        {
          if (BYTE8(v18[0])) {
            (*(void (**)(void))(**(void **)&v18[0] + 40))();
          }
          memset(v18, 0, sizeof(v18));
        }
        if (v17) {

        }
        if (v16)
        {
          re::MultipeerDiscoveryView::multipeerIdAtIndex(v6, v15, a3);

          return;
        }
        ++v15;
      }
      while (v15 < (*(uint64_t (**)(re::MultipeerDiscoveryView *))(*(void *)v6 + 48))(v6));
      if (!v12) {
        goto LABEL_20;
      }
    }
  }
LABEL_20:
  *a3 = 0;
}

uint64_t re::MultipeerManager::internalPeerID(re::MultipeerManager *this, ObjCObject a2)
{
  uint64_t v5 = *(void *)(*((void *)this + 4) + 2208);
  if (v5)
  {
    id v6 = (id)(v5 + 8);
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5))
  {
    unint64_t v7 = 0;
    while (1)
    {
      re::MultipeerDiscoveryView::multipeerIdAtIndex((re::MultipeerDiscoveryView *)v5, v7, &v15);
      uint64_t v8 = *(void *)a2.var0;
      uint64_t v9 = v15;
      LODWORD(v8) = [v9 isEqual:v8];

      if (v8) {
        break;
      }
LABEL_13:
      if (++v7 >= (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5)) {
        return 0;
      }
    }
    (*(void (**)(char **__return_ptr, uint64_t, unint64_t))(*(void *)v5 + 56))(&v15, v5, v7);
    uint64_t v10 = (*(uint64_t (**)(void))(**((void **)this + 4) + 40))(*((void *)this + 4));
    if (v11)
    {
      uint64_t v12 = 8 * v11;
      while (*(char **)(*(void *)v10 + 152) != v15)
      {
        v10 += 8;
        v12 -= 8;
        if (!v12) {
          goto LABEL_10;
        }
      }
      int v13 = 0;
      uint64_t v2 = *(void *)(*(void *)v10 + 24);
      if (!v15)
      {
LABEL_12:
        if (!v13) {
          return v2;
        }
        goto LABEL_13;
      }
    }
    else
    {
LABEL_10:
      int v13 = 1;
      if (!v15) {
        goto LABEL_12;
      }
    }

    goto LABEL_12;
  }
  return 0;
}

uint64_t re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::MultipeerManager>(re::MultipeerManager *,REEventHandlerResult (re::MultipeerManager::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = (uint64_t (*)(void *, uint64_t, uint64_t *))a2[1];
  uint64_t v4 = a2[2];
  id v6 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t *))(*v6 + v5);
  }
  uint64_t v7 = *a3;
  uint64_t v11 = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  uint64_t v9 = v5(v6, a1, &v11);
  if (v11) {

  }
  return v9;
}

uint64_t RESyncBitReaderGetRequiredSize()
{
  return 32;
}

uint64_t RESyncBitReaderConstructNoAlloc(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = 0;
  if (a1 && a2 >= 0x20)
  {
    *(void *)a1 = a3;
    *(_DWORD *)(a1 + 8) = a4;
    *(unsigned char *)(a1 + 12) = 0;
    uint64_t v4 = a1;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
  }
  return v4;
}

uint64_t RESyncBitReaderReadData(uint64_t a1, void *__dst, size_t __n)
{
  if (*(unsigned char *)(a1 + 12)) {
    return 0;
  }
  int v4 = __n;
  int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  if (v6 - (int)v7 >= __n)
  {
    *(_DWORD *)(a1 + 20) = 0;
    *(void *)(a1 + 24) = 0;
    memcpy(__dst, (const void *)(*(void *)a1 + v7), __n);
    *(_DWORD *)(a1 + 16) += v4;
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 12) = 1;
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 20) = 0;
  }
  return result;
}

uint64_t RESyncBitReaderDataPtr(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 12)) {
    return 0;
  }
  else {
    return *(void *)a1 + *(unsigned int *)(a1 + 16);
  }
}

uint64_t RESyncBitReaderSkipData(uint64_t result, int a2)
{
  if (!*(unsigned char *)(result + 12))
  {
    *(void *)(result + 24) = 0;
    unsigned int v2 = *(_DWORD *)(result + 16) + a2;
    *(void *)(result + 16) = v2;
    if (v2 > *(_DWORD *)(result + 8)) {
      *(unsigned char *)(result + 12) = 1;
    }
  }
  return result;
}

uint64_t *RESyncBitReaderReadUInt8(uint64_t *a1, unsigned char *a2)
{
  unsigned int v4 = 0;
  uint64_t result = re::BitReader::readUInt32Bits(a1, 8u, &v4);
  *a2 = v4;
  return result;
}

uint64_t *RESyncBitReaderReadUInt16(uint64_t *a1, _WORD *a2)
{
  unsigned int v4 = 0;
  uint64_t result = re::BitReader::readUInt32Bits(a1, 0x10u, &v4);
  *a2 = v4;
  return result;
}

uint64_t *RESyncBitReaderReadUInt32(uint64_t *a1, unsigned int *a2)
{
  unsigned int v4 = 0;
  uint64_t result = re::BitReader::readUInt32Bits(a1, 0x20u, &v4);
  *a2 = v4;
  return result;
}

uint64_t *RESyncBitReaderReadBool(uint64_t *a1, BOOL *a2)
{
  unsigned int v4 = 0;
  uint64_t result = re::BitReader::readUInt32Bits(a1, 1u, &v4);
  *a2 = v4 != 0;
  return result;
}

float RESyncBitReaderReadFloat(uint64_t *a1, unsigned int *a2)
{
  re::BitReader::readUInt32Bits(a1, 0x20u, &v4);
  float result = *(float *)&v4;
  *a2 = v4;
  return result;
}

uint64_t RESyncBitReaderAlignToByte(uint64_t result)
{
  *(_DWORD *)(result + 20) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

uint64_t RESyncBitReaderMakeMarker(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  uint64_t v2 = (8 - v1);
  BOOL v3 = v1 == 0;
  BOOL v4 = v1 != 0;
  uint64_t v5 = v2 << 32;
  if (v3) {
    uint64_t v5 = 0;
  }
  return v5 | (*(_DWORD *)(a1 + 16) - v4);
}

uint64_t RESyncBitReaderIsOverflow(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 12);
}

uint64_t RESyncBitReaderBitsLeft(_DWORD *a1)
{
  return (a1[5] + 8 * (a1[2] - a1[4]));
}

uint64_t RESyncBitReaderBytesLeft(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 16));
}

uint64_t RESyncBitReaderBytesRead(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if (*(_DWORD *)(a1 + 20)) {
    return v1 + 1;
  }
  else {
    return v1;
  }
}

uint64_t RESyncBitReaderSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t RESyncBitReaderBuffer(uint64_t a1)
{
  return *(void *)a1;
}

nw_protocol_definition_t re::NWProtocolFramer::create(re::NWProtocolFramer *this)
{
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  v4[2] = ___ZN2re16NWProtocolFramer6createEv_block_invoke_3;
  v4[3] = &unk_2648546B0;
  id v5 = &__block_literal_global;
  id v6 = &__block_literal_global_8;
  unsigned int v1 = _Block_copy(v4);
  nw_protocol_definition_t definition = nw_framer_create_definition("re-net-header", 0, v1);

  return definition;
}

uint64_t ___ZN2re16NWProtocolFramer6createEv_block_invoke(uint64_t a1, void *a2)
{
  value_4[5] = *MEMORY[0x263EF8340];
  uint64_t v2 = a2;
  *(_DWORD *)temp_buffer = 0;
  unsigned __int8 value = 0;
  uint64_t v3 = 8;
  if (nw_framer_parse_input(v2, 8uLL, 8uLL, temp_buffer, &__block_literal_global_3))
  {
    uint64_t v3 = 8;
    while (1)
    {
      *(_DWORD *)temp_buffer = bswap32(*(unsigned int *)temp_buffer);
      uint64_t v4 = re::internal::enableSignposts(0, 0);
      if (v4)
      {
        uint64_t v4 = re::internal::enableHighFrequencyNetworkTracing(0, 0);
        if (v4) {
          uint64_t v4 = kdebug_trace();
        }
      }
      if (value > 9u) {
        break;
      }
      id v5 = nw_framer_message_create(v2);
      nw_framer_message_set_value(v5, "channel", (void *)value, 0);
      BOOL v6 = nw_framer_deliver_input_no_copy(v2, *(unsigned int *)temp_buffer, v5, 1);

      if (!v6) {
        goto LABEL_13;
      }
      *(_DWORD *)temp_buffer = 0;
      unsigned __int8 value = 0;
      if (!nw_framer_parse_input(v2, 8uLL, 8uLL, temp_buffer, &__block_literal_global_3)) {
        goto LABEL_14;
      }
    }
    uint64_t v7 = *re::networkLogObjects((re *)v4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(value_4[0]) = 67109120;
      HIDWORD(value_4[0]) = value;
      _os_log_impl(&dword_228C70000, v7, OS_LOG_TYPE_DEFAULT, "Message received on unknown channel %d", (uint8_t *)value_4, 8u);
    }
    value_4[0] = MEMORY[0x263EF8330];
    value_4[1] = 3221225472;
    value_4[2] = ___Z20nw_framer_skip_bytesPU23objcproto12OS_nw_framer8NSObjectm_block_invoke;
    value_4[3] = &__block_descriptor_40_e14_Q28__0_8Q16B24l;
    value_4[4] = *(unsigned int *)temp_buffer;
    nw_framer_parse_input(v2, 0, 0, 0, value_4);
LABEL_13:
    uint64_t v3 = 0;
  }
LABEL_14:

  return v3;
}

uint64_t ___ZN2re16NWProtocolFramer6createEv_block_invoke_2(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 < 8 || a2 == 0) {
    return 0;
  }
  else {
    return 8;
  }
}

void ___ZN2re16NWProtocolFramer6createEv_block_invoke_5(uint64_t a1, void *a2, NSObject *a3, size_t a4)
{
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2020000000;
  char v13 = 0;
  access_value[0] = MEMORY[0x263EF8330];
  access_value[1] = 3221225472;
  access_value[2] = ___ZN2re16NWProtocolFramer6createEv_block_invoke_2_9;
  access_value[3] = &unk_264854688;
  access_value[4] = &v10;
  BOOL v6 = a2;
  nw_framer_message_access_value(a3, "channel", access_value);
  unsigned int v7 = bswap32(a4);
  char v8 = *((unsigned char *)v11 + 24);
  nw_framer_write_output(v6, (const uint8_t *)&v7, 8uLL);
  nw_framer_write_output_no_copy(v6, a4);

  if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyNetworkTracing(0, 0)) {
    kdebug_trace();
  }
  _Block_object_dispose(&v10, 8);
}

uint64_t ___ZN2re16NWProtocolFramer6createEv_block_invoke_2_9(uint64_t a1, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  return 1;
}

uint64_t ___ZN2re16NWProtocolFramer6createEv_block_invoke_3(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = a2;
  nw_framer_set_input_handler(v4, v3);
  nw_framer_set_output_handler(v4, *(nw_framer_output_handler_t *)(a1 + 40));

  return 1;
}

id re::NWProtocolFramer::definition(re::NWProtocolFramer *this)
{
  unsigned int v1 = &re::StackScratchAllocator::s_rootsWithPersistentBlocks[56];
  {
    unsigned int v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    if (v4)
    {
      re::NWProtocolFramer::definition(void)::nw_protocol_definition_t definition = re::NWProtocolFramer::create(v4);
      unsigned int v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    }
  }
  uint64_t v2 = (void *)v1[228];
  return v2;
}

uint64_t RESyncCapabilityAlmond()
{
  return 8;
}

uint64_t RESyncCapabilityPistachio()
{
  return 16;
}

uint64_t RESyncCapabilityWalnut()
{
  return 32;
}

void *RESyncMCServiceConfigCreateNoAlloc(void *a1, unint64_t a2)
{
  float result = 0;
  if (a1)
  {
    if (a2 >= 0x10)
    {
      uint64_t v4 = MEMORY[0x263EF83A0];
      id v5 = MEMORY[0x263EF83A0];
      *a1 = v4;
      return a1;
    }
  }
  return result;
}

void RESyncMCServiceConfigDestroyNoDealloc(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;

  uint64_t v3 = *a1;
}

uint64_t RESyncMCServiceCreate(re *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = re::globalAllocators(a1);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 48, 8);
  *(_OWORD *)(v3 + 24) = 0u;
  *(void *)(v3 + 40) = 0;
  *(_OWORD *)(v3 + 8) = 0u;
  *(void *)uint64_t v3 = &unk_26DD34AC0;
  uint64_t v4 = MEMORY[0x263EF83A0];
  id v5 = MEMORY[0x263EF83A0];
  *(void *)(v3 + 8) = v4;
  *(unsigned char *)(v3 + 24) = 0;
  *(void *)(v3 + 32) = 0;
  *(void *)(v3 + 40) = 0x61A800000002;
  objc_storeStrong((id *)(v3 + 8), *(id *)a1);
  *(void *)(v3 + 16) = *((void *)a1 + 1);
  *(unsigned char *)(v3 + 24) = 1;
  return v3;
}

re *RESyncMCServiceDestroy(re *result)
{
  if (result)
  {
    unsigned int v1 = result;
    uint64_t v2 = re::globalAllocators(result)[2];
    (**(void (***)(re *))v1)(v1);
    uint64_t v3 = *(uint64_t (**)(uint64_t, re *))(*(void *)v2 + 40);
    return (re *)v3(v2, v1);
  }
  return result;
}

uint64_t RESyncMCServiceConfigGetSize()
{
  return 16;
}

void RESyncMCServiceConfigSetDispatchQueue(id *a1, void *a2)
{
  id v4 = a2;
  if (a1 && v4)
  {
    id v5 = v4;
    objc_storeStrong(a1, a2);
    id v4 = v5;
  }
}

uint64_t RESyncMCServiceConfigSetSyncService(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2) {
      *(void *)(result + 8) = a2;
    }
  }
  return result;
}

uint64_t RESyncMCServiceStartSyncWithMCSession(uint64_t a1, void *a2)
{
  id v3 = a2;
  v13[0] = MEMORY[0x263EF83A0];
  v13[1] = 0x7B61A86B3;
  _OWORD v13[2] = 0;
  v13[3] = 0x61A800000000;
  uint64_t v14 = 0;
  char v15 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  int v19 = 0;
  int v20 = 16777473;
  uint64_t v21 = 500;
  int v22 = 10485760;
  __int16 v23 = 257;
  int v24 = 10;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  int v27 = 0;
  re::MultipeerManager::applySessionConfigDefaults((uint64_t)v13, v4);
  re::make::shared::object<re::LeaderElectionLowestPeerID>(v5, &v12);
  uint64_t v6 = v12;
  uint64_t v12 = 0;
  uint64_t v7 = v14;
  uint64_t v14 = v6;
  if (v7)
  {

    if (v12) {
  }
    }
  id v8 = v3;
  id v11 = v8;
  if (re::MultipeerManager::initView(v13, &v11)) {
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 24))(a1, v13);
  }
  else {
    uint64_t v9 = 0;
  }

  if (v26)
  {

    uint64_t v26 = 0;
  }
  if (v25)
  {

    uint64_t v25 = 0;
  }
  if (v18)
  {

    uint64_t v18 = 0;
  }
  if (v14) {

  }
  return v9;
}

uint64_t RESyncMCServiceStopSync(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 32))();
}

id RESyncMCServiceGetMCSession(uint64_t a1)
{
  (*(void (**)(id *__return_ptr))(*(void *)a1 + 40))(&v3);
  id v1 = v3;

  return v1;
}

uint64_t RESyncMCServiceGetInternalSession(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 48))(&v3);
  uint64_t v1 = v3;
  if (v3) {

  }
  return v1;
}

id RESyncMCServiceGetMCPeerID(uint64_t a1)
{
  (*(void (**)(id *__return_ptr))(*(void *)a1 + 56))(&v3);
  id v1 = v3;

  return v1;
}

uint64_t RESyncMCServiceGetInternalPeerID(uint64_t a1, void *a2)
{
  id v6 = a2;
  id v3 = *(uint64_t (**)(uint64_t, id *))(*(void *)a1 + 64);

  uint64_t v4 = v3(a1, &v6);
  return v4;
}

uint64_t RESyncMCServiceSetHandshakeCountAndTimeoutMs(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void re::make::shared::object<re::LeaderElectionLowestPeerID>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  id v3 = re::globalAllocators(a1);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 40, 8);
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(void *)(v4 + 32) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(void *)uint64_t v4 = &unk_26DD361E8;
  *a2 = v4;
}

uint64_t re::SyncHistoryResetRequest::write(re::SyncHistoryResetRequest *this, re::BitWriter *a2)
{
  unsigned int v4 = *((_DWORD *)this + 1);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *(_DWORD *)this, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, v4, 0x20u);
  unsigned int v5 = *((_DWORD *)this + 3);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((_DWORD *)this + 2), 0x20u);
  return re::BitWriter::writeUInt32Bits((uint64_t)a2, v5, 0x20u);
}

void *re::SyncOpaqueTypeInfo::make@<X0>(re::SyncOpaqueTypeInfo *this@<X0>, uint64_t a2@<X8>)
{
  re::SyncObjectTypeInfo::SyncObjectTypeInfo((re::SyncObjectTypeInfo *)a2);
  *(unsigned char *)(a2 + 72) = 1;
  *(void *)(a2 + 32) = this;
  v5[0] = "Opaque";
  v5[1] = 6;
  re::DynamicString::operator=((re::DynamicString *)(a2 + 40), (uint64_t)v5);
  re::SyncObjectTypeInfo::setReadSnapshotCb(a2, &__block_literal_global_0);
  re::SyncObjectTypeInfo::setWriteSnapshotCb(a2, &__block_literal_global_5);
  re::SyncObjectTypeInfo::setReadPayloadCb(a2, &__block_literal_global_9);
  return re::SyncObjectTypeInfo::setWritePayloadCb(a2, &__block_literal_global_13);
}

uint64_t ___ZN2re18SyncOpaqueTypeInfo4makeEy_block_invoke()
{
  return 0;
}

uint64_t ___ZN2re18SyncOpaqueTypeInfo4makeEy_block_invoke_2()
{
  return 0;
}

BOOL ___ZN2re18SyncOpaqueTypeInfo4makeEy_block_invoke_3(int a1, uint64_t a2, re::BitWriter *this)
{
  if (*(unsigned char *)(a2 + 12))
  {
    unsigned int v5 = 0;
    LODWORD(v6) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(a2 + 16);
    unsigned int v5 = (const void *)(*(void *)a2 + v6);
  }
  re::BitWriter::writeData(this, v5, (*(_DWORD *)(a2 + 8) - v6));
  if (!*(unsigned char *)(a2 + 12))
  {
    unsigned int v7 = *(_DWORD *)(a2 + 8);
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 16) = v7;
  }
  return *((unsigned char *)this + 20) == 0;
}

uint64_t ___ZN2re18SyncOpaqueTypeInfo4makeEy_block_invoke_4(int a1, uint64_t a2, re::BitWriter *this)
{
  if (*(unsigned char *)(a2 + 12))
  {
    id v3 = 0;
    LODWORD(v4) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    uint64_t v4 = *(unsigned int *)(a2 + 16);
    id v3 = (const void *)(*(void *)a2 + v4);
  }
  return re::BitWriter::writeData(this, v3, (*(_DWORD *)(a2 + 8) - v4));
}

re::SyncObjectTypeInfo *re::SyncObjectTypeInfo::SyncObjectTypeInfo(re::SyncObjectTypeInfo *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD36F88;
  *((unsigned char *)this + 24) = 1;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  re::DynamicString::setCapacity((void *)this + 5, 0);
  *((_WORD *)this + 36) = 0;
  *((unsigned char *)this + 74) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  return this;
}

double RESyncProtocolLayerObserverCreate(re *a1)
{
  id v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 168, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_OWORD *)(v2 + 144) = 0u;
  *(void *)(v2 + 160) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)uint64_t v2 = &unk_26DD34C20;
  double result = 0.0;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  return result;
}

void RESyncProtocolLayerObserverOnCreate(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[3]);
      a1[3] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnCreate";
      __int16 v7 = 2080;
      id v8 = "protocolLayerCreate != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnCreate";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnDestroy(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[4]);
      a1[4] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnDestroy";
      __int16 v7 = 2080;
      id v8 = "protocolLayerDestroy != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnDestroy";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnInit(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[5]);
      a1[5] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnInit";
      __int16 v7 = 2080;
      id v8 = "protocolLayerInit != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnInit";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnInitWithConfig(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[6]);
      a1[6] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnInitWithConfig";
      __int16 v7 = 2080;
      id v8 = "protocolLayerInitWithConfig != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnInitWithConfig";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnDeinit(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[7]);
      a1[7] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnDeinit";
      __int16 v7 = 2080;
      id v8 = "protocolLayerDeinit != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnDeinit";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnOpen(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[8]);
      a1[8] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnOpen";
      __int16 v7 = 2080;
      id v8 = "protocolLayerOpen != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnOpen";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnOpenNullable(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[9]);
      a1[9] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnOpenNullable";
      __int16 v7 = 2080;
      id v8 = "protocolLayerOpenNullable != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnOpenNullable";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnClose(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[10]);
      a1[10] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnClose";
      __int16 v7 = 2080;
      id v8 = "protocolLayerClose != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnClose";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnDisconnect(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[11]);
      a1[11] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnDisconnect";
      __int16 v7 = 2080;
      id v8 = "protocolLayerDisconnect != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnDisconnect";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnSend(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[12]);
      a1[12] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnSend";
      __int16 v7 = 2080;
      id v8 = "protocolLayerSend != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnSend";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnUpdate(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[13]);
      a1[13] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnUpdate";
      __int16 v7 = 2080;
      id v8 = "protocolLayerUpdate != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnUpdate";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnWait(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[14]);
      a1[14] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnWait";
      __int16 v7 = 2080;
      id v8 = "protocolLayerWait != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnWait";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnWakeup(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[15]);
      a1[15] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnWakeup";
      __int16 v7 = 2080;
      id v8 = "protocolLayerWakeup != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnWakeup";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnLocalAddresses(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[16]);
      a1[16] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnLocalAddresses";
      __int16 v7 = 2080;
      id v8 = "protocolLayerLocalAddresses != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnLocalAddresses";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnHostStats(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[17]);
      a1[17] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnHostStats";
      __int16 v7 = 2080;
      id v8 = "protocolLayerHostStats != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnHostStats";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnSetDisconnectTimeout(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[18]);
      a1[18] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnSetDisconnectTimeout";
      __int16 v7 = 2080;
      id v8 = "protocolLayerSetDisconnectTimeout != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnSetDisconnectTimeout";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnPreferredPacketSize(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[19]);
      a1[19] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnPreferredPacketSize";
      __int16 v7 = 2080;
      id v8 = "protocolLayerPreferredPacketSize != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnPreferredPacketSize";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void RESyncProtocolLayerObserverOnSetListener(const void **a1, const void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      _Block_release(a1[20]);
      a1[20] = _Block_copy(a2);
      return;
    }
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnSetListener";
      __int16 v7 = 2080;
      id v8 = "protocolLayerSetListener != __null";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "RESyncProtocolLayerObserverOnSetListener";
      __int16 v7 = 2080;
      id v8 = "observer != __null";
LABEL_9:
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
  }
}

uint64_t RESyncProtocolLayerConfigGetPacketPool(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 24);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    uint64_t v4 = "RESyncProtocolLayerConfigGetPacketPool";
    __int16 v5 = 2080;
    uint64_t v6 = "config != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncProtocolLayerConfigGetNetworkQueue(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 32);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    uint64_t v4 = "RESyncProtocolLayerConfigGetNetworkQueue";
    __int16 v5 = 2080;
    uint64_t v6 = "config != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncCreateDefaultProtocolLayerUDP()
{
  return 0;
}

uint64_t RESyncCreateDefaultProtocolLayerTCP(_anonymous_namespace_ *a1, uint64_t a2)
{
  __int16 v2 = (__int16)a1;
  if (a1 >= 0x10000)
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) listenPort %u exceeds numeric limits of type Port", "!overflow", "RESyncCreateDefaultProtocolLayerTCP", 513, a1);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    int v7 = 128;
    __int16 v10 = v2;
    uint64_t v4 = re::globalAllocators(v3);
    uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 208, 8);
    re::TcpProtocolLayer::TcpProtocolLayer(v5, (uint64_t)&v7);
    if (v8)
    {
      if (v9) {
        (*(void (**)(void))(*(void *)v8 + 40))();
      }
    }
    return v5;
  }
  return result;
}

uint64_t RESyncCreateDefaultProtocolLayerNW(_anonymous_namespace_ *a1, uint64_t a2)
{
  __int16 v2 = (__int16)a1;
  if (a1 >= 0x10000)
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) listenPort %u exceeds numeric limits of type Port", "!overflow", "RESyncCreateDefaultProtocolLayerNW", 524, a1);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v8 = 0;
    re::DynamicString::setCapacity(&v7, 0);
    int v12 = 0;
    uint64_t v13 = 0;
    v6[0] = 1;
    __int16 v11 = v2;
    re::make::shared::object<re::NWProtocolLayer,re::NWProtocolLayer::Config &>((re *)&v5, (uint64_t)v6);
    uint64_t v3 = v5;
    if (v7)
    {
      if (v8) {
        (*(void (**)(void))(*v7 + 40))();
      }
    }
    return v3;
  }
  return result;
}

uint64_t RESyncCreateProtocolLayerNWWithoutListener(_anonymous_namespace_ *a1)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v6 = 0;
  re::DynamicString::setCapacity(&v5, 0);
  __int16 v9 = 0;
  int v10 = 0;
  uint64_t v11 = 0;
  v4[0] = 0;
  re::make::shared::object<re::NWProtocolLayer,re::NWProtocolLayer::Config &>((re *)&v3, (uint64_t)v4);
  uint64_t v1 = v3;
  if (v5 && (v6 & 1) != 0) {
    (*(void (**)(void))(*v5 + 40))();
  }
  return v1;
}

re::DebugProtocolLayer *RESyncCreateDefaultProtocolLayerDebug(re *a1)
{
  re::make::shared::object<re::DebugProtocolLayer>(a1, &v2);
  return v2;
}

uint64_t RESyncCustomProtocolLayerCreate(void *a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (a1)
  {
    __int16 v2 = a1 + 1;
    uint64_t v3 = a1 + 1;
    if ((a1[5] != 0) == (a1[6] == 0))
    {
      if (a1[7])
      {
        if ((a1[8] != 0) == (a1[9] == 0))
        {
          if (a1[10])
          {
            if (a1[11])
            {
              if (!a1[12] && !a1[13])
              {
                uint64_t v11 = *re::networkLogObjects(v3);
                if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
                {
                  int v12 = 136315394;
                  uint64_t v13 = "RESyncCustomProtocolLayerCreate";
                  __int16 v14 = 2080;
                  char v15 = "RESyncProtocolLayerObserverOnUpdate() observer implementation is required.";
                  goto LABEL_44;
                }
                goto LABEL_45;
              }
              if ((a1[14] == 0) == (a1[15] == 0))
              {
                if (a1[16])
                {
                  if (a1[17])
                  {
                    if (a1[18])
                    {
                      if (a1[19])
                      {
                        uint64_t v4 = re::globalAllocators(v3);
                        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 160, 8);
                        ArcSharedObject::ArcSharedObject((ArcSharedObject *)v5, 0);
                        *(void *)(v5 + 24) = a1;
                        *(void *)uint64_t v5 = &unk_26DD34C68;
                        id v6 = v2;
                        uint64_t v7 = *(void *)(v5 + 24);
                        *(void *)(v5 + 32) = 0;
                        *(_DWORD *)(v5 + 40) = 0;
                        *(void *)(v5 + 48) = 850045863;
                        *(_OWORD *)(v5 + 88) = 0u;
                        *(_OWORD *)(v5 + 72) = 0u;
                        *(_OWORD *)(v5 + 56) = 0u;
                        *(void *)(v5 + 104) = 0;
                        *(void *)(v5 + 112) = 1018212795;
                        *(_OWORD *)(v5 + 120) = 0u;
                        *(_OWORD *)(v5 + 136) = 0u;
                        *(void *)(v5 + 152) = 0;
                        uint64_t v8 = *(void *)(v7 + 24);
                        if (v8) {
                          (*(void (**)(void))(v8 + 16))();
                        }

                        goto LABEL_17;
                      }
                      uint64_t v11 = *re::networkLogObjects(v3);
                      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
                      {
                        int v12 = 136315394;
                        uint64_t v13 = "RESyncCustomProtocolLayerCreate";
                        __int16 v14 = 2080;
                        char v15 = "RESyncProtocolLayerObserverOnPreferredPacketSize() observer implementation is required.";
                        goto LABEL_44;
                      }
LABEL_45:
                      uint64_t v5 = 0;
LABEL_17:

                      return v5;
                    }
                    uint64_t v11 = *re::networkLogObjects(v3);
                    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_45;
                    }
                    int v12 = 136315394;
                    uint64_t v13 = "RESyncCustomProtocolLayerCreate";
                    __int16 v14 = 2080;
                    char v15 = "RESyncProtocolLayerObserverOnSetDisconnectTimeout() observer implementation is required.";
                  }
                  else
                  {
                    uint64_t v11 = *re::networkLogObjects(v3);
                    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_45;
                    }
                    int v12 = 136315394;
                    uint64_t v13 = "RESyncCustomProtocolLayerCreate";
                    __int16 v14 = 2080;
                    char v15 = "RESyncProtocolLayerObserverOnHostStats() observer implementation is required.";
                  }
                }
                else
                {
                  uint64_t v11 = *re::networkLogObjects(v3);
                  if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_45;
                  }
                  int v12 = 136315394;
                  uint64_t v13 = "RESyncCustomProtocolLayerCreate";
                  __int16 v14 = 2080;
                  char v15 = "RESyncProtocolLayerObserverOnLocalAddresses() observer implementation is required.";
                }
              }
              else
              {
                uint64_t v11 = *re::networkLogObjects(v3);
                if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_45;
                }
                int v12 = 136315394;
                uint64_t v13 = "RESyncCustomProtocolLayerCreate";
                __int16 v14 = 2080;
                char v15 = "None or both RESyncProtocolLayerObserverOnWait() and RESyncProtocolLayerObserverOnWakeup() observe"
                      "r implementations are required.";
              }
            }
            else
            {
              uint64_t v11 = *re::networkLogObjects(v3);
              if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
                goto LABEL_45;
              }
              int v12 = 136315394;
              uint64_t v13 = "RESyncCustomProtocolLayerCreate";
              __int16 v14 = 2080;
              char v15 = "RESyncProtocolLayerObserverOnDisconnect() observer implementation is required.";
            }
          }
          else
          {
            uint64_t v11 = *re::networkLogObjects(v3);
            if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
              goto LABEL_45;
            }
            int v12 = 136315394;
            uint64_t v13 = "RESyncCustomProtocolLayerCreate";
            __int16 v14 = 2080;
            char v15 = "RESyncProtocolLayerObserverOnClose() observer implementation is required.";
          }
        }
        else
        {
          uint64_t v11 = *re::networkLogObjects(v3);
          if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
            goto LABEL_45;
          }
          int v12 = 136315394;
          uint64_t v13 = "RESyncCustomProtocolLayerCreate";
          __int16 v14 = 2080;
          char v15 = "Either RESyncProtocolLayerObserverOnOpen() or RESyncProtocolLayerObserverOnOpenNullable() observer imple"
                "mentation is required.";
        }
      }
      else
      {
        uint64_t v11 = *re::networkLogObjects(v3);
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          goto LABEL_45;
        }
        int v12 = 136315394;
        uint64_t v13 = "RESyncCustomProtocolLayerCreate";
        __int16 v14 = 2080;
        char v15 = "RESyncProtocolLayerObserverOnDeinit() observer implementation is required.";
      }
    }
    else
    {
      uint64_t v11 = *re::networkLogObjects(v3);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        goto LABEL_45;
      }
      int v12 = 136315394;
      uint64_t v13 = "RESyncCustomProtocolLayerCreate";
      __int16 v14 = 2080;
      char v15 = "Either RESyncProtocolLayerObserverOnInit() or RESyncProtocolLayerObserverOnInitWithConfig() observer impleme"
            "ntation is required.";
    }
LABEL_44:
    _os_log_error_impl(&dword_228C70000, v11, OS_LOG_TYPE_ERROR, "%s: %s", (uint8_t *)&v12, 0x16u);
    goto LABEL_45;
  }
  int v10 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v12 = 136315394;
    uint64_t v13 = "RESyncCustomProtocolLayerCreate";
    __int16 v14 = 2080;
    char v15 = "observer != __null";
    _os_log_error_impl(&dword_228C70000, v10, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v12, 0x16u);
  }
  return 0;
}

void RESyncCustomProtocolLayerSetThreadModeDispatchTransport(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(_DWORD *)(a1 + 40) = 2;
  }
  else
  {
    uint64_t v1 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      int v2 = 136315394;
      uint64_t v3 = "RESyncCustomProtocolLayerSetThreadModeDispatchTransport";
      __int16 v4 = 2080;
      uint64_t v5 = "protocolLayer != __null";
      _os_log_error_impl(&dword_228C70000, v1, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v2, 0x16u);
    }
  }
}

void RESyncCustomProtocolLayerOnConnected(re *a1, uint64_t a2, const char *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "RESyncCustomProtocolLayerOnConnected";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "protocolLayer != __null";
    goto LABEL_16;
  }
  if (!a2)
  {
    uint64_t v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "RESyncCustomProtocolLayerOnConnected";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "handle != __null";
LABEL_16:
    _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return;
  }
  uint64_t v5 = (void (***)(void, re *, uint64_t, uint8_t *))*((void *)a1 + 4);
  if (v5)
  {
    re::DynamicString::DynamicString((re::DynamicString *)buf, (const re::DynamicString *)&v8);
    (**v5)(v5, a1, a2, buf);
    if (*(void *)buf)
    {
      if (buf[8]) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
      memset(buf, 0, 32);
    }
    if (v8)
    {
      if (v9) {
        (*(void (**)(void))(*(void *)v8 + 40))();
      }
    }
  }
}

void RESyncCustomProtocolLayerOnDisconnected(re *a1, uint64_t a2, const char *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "RESyncCustomProtocolLayerOnDisconnected";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "protocolLayer != __null";
    goto LABEL_16;
  }
  if (!a2)
  {
    uint64_t v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "RESyncCustomProtocolLayerOnDisconnected";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "handle != __null";
LABEL_16:
    _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return;
  }
  uint64_t v5 = *((void *)a1 + 4);
  if (v5)
  {
    re::DynamicString::DynamicString((re::DynamicString *)buf, (const re::DynamicString *)&v8);
    (*(void (**)(uint64_t, re *, uint64_t, uint8_t *))(*(void *)v5 + 8))(v5, a1, a2, buf);
    if (*(void *)buf)
    {
      if (buf[8]) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
      memset(buf, 0, 32);
    }
    if (v8)
    {
      if (v9) {
        (*(void (**)(void))(*(void *)v8 + 40))();
      }
    }
  }
}

void RESyncCustomProtocolLayerOnError(re *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __int16 v4 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v5 = 136315394;
    uint64_t v6 = "RESyncCustomProtocolLayerOnError";
    __int16 v7 = 2080;
    uint64_t v8 = "protocolLayer != __null";
    goto LABEL_12;
  }
  if (!a2)
  {
    __int16 v4 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v5 = 136315394;
    uint64_t v6 = "RESyncCustomProtocolLayerOnError";
    __int16 v7 = 2080;
    uint64_t v8 = "handle != __null";
LABEL_12:
    _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    return;
  }
  uint64_t v2 = *((void *)a1 + 4);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)v2 + 16);
    v3();
  }
}

void RESyncCustomProtocolLayerOnReceiveData(re *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    __int16 v7 = "RESyncCustomProtocolLayerOnReceiveData";
    __int16 v8 = 2080;
    uint64_t v9 = "protocolLayer != __null";
    goto LABEL_15;
  }
  if (!a2)
  {
    int v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    __int16 v7 = "RESyncCustomProtocolLayerOnReceiveData";
    __int16 v8 = 2080;
    uint64_t v9 = "fromHandle != __null";
    goto LABEL_15;
  }
  if (a3 >= 0xA)
  {
    int v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    __int16 v7 = "RESyncCustomProtocolLayerOnReceiveData";
    __int16 v8 = 2080;
    uint64_t v9 = "channel < kRESyncChannelIdMaxChannels";
LABEL_15:
    _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return;
  }
  uint64_t v3 = *((void *)a1 + 4);
  if (v3)
  {
    __int16 v4 = *(void (**)(void))(*(void *)v3 + 24);
    v4();
  }
}

void RESyncCustomProtocolLayerOnReceiveDataNoAsync(re *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    __int16 v7 = "RESyncCustomProtocolLayerOnReceiveDataNoAsync";
    __int16 v8 = 2080;
    uint64_t v9 = "protocolLayer != __null";
    goto LABEL_15;
  }
  if (!a2)
  {
    int v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    __int16 v7 = "RESyncCustomProtocolLayerOnReceiveDataNoAsync";
    __int16 v8 = 2080;
    uint64_t v9 = "fromHandle != __null";
    goto LABEL_15;
  }
  if (a3 >= 0xA)
  {
    int v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    __int16 v7 = "RESyncCustomProtocolLayerOnReceiveDataNoAsync";
    __int16 v8 = 2080;
    uint64_t v9 = "channel < kRESyncChannelIdMaxChannels";
LABEL_15:
    _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return;
  }
  uint64_t v3 = *((void *)a1 + 4);
  if (v3)
  {
    __int16 v4 = *(void (**)(void))(*(void *)v3 + 32);
    v4();
  }
}

void RESyncCustomProtocolLayerOnReceive(re *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  *a6 = 1;
}

void RESyncCustomProtocolLayerOnUnresponsive(re *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __int16 v4 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v5 = 136315394;
    int v6 = "RESyncCustomProtocolLayerOnUnresponsive";
    __int16 v7 = 2080;
    __int16 v8 = "protocolLayer != __null";
    goto LABEL_12;
  }
  if (!a2)
  {
    __int16 v4 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v5 = 136315394;
    int v6 = "RESyncCustomProtocolLayerOnUnresponsive";
    __int16 v7 = 2080;
    __int16 v8 = "handle != __null";
LABEL_12:
    _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    return;
  }
  uint64_t v2 = *((void *)a1 + 4);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)v2 + 40);
    v3();
  }
}

void RESyncCustomProtocolLayerOnResponsive(re *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __int16 v4 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v5 = 136315394;
    int v6 = "RESyncCustomProtocolLayerOnResponsive";
    __int16 v7 = 2080;
    __int16 v8 = "protocolLayer != __null";
    goto LABEL_12;
  }
  if (!a2)
  {
    __int16 v4 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v5 = 136315394;
    int v6 = "RESyncCustomProtocolLayerOnResponsive";
    __int16 v7 = 2080;
    __int16 v8 = "handle != __null";
LABEL_12:
    _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    return;
  }
  uint64_t v2 = *((void *)a1 + 4);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)v2 + 48);
    v3();
  }
}

char *RESyncPacketPoolAllocPacket(re::PacketPool *a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a1)
  {
    return re::PacketPool::allocate(a1, a2);
  }
  else
  {
    uint64_t v3 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = 136315394;
      int v5 = "RESyncPacketPoolAllocPacket";
      __int16 v6 = 2080;
      __int16 v7 = "pool != __null";
      _os_log_error_impl(&dword_228C70000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v4, 0x16u);
    }
    return 0;
  }
}

void RESyncPacketPoolFreePacket(re *a1, re::Packet *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v3 = 136315394;
    int v4 = "RESyncPacketPoolFreePacket";
    __int16 v5 = 2080;
    __int16 v6 = "pool != __null";
    goto LABEL_11;
  }
  if (!a2)
  {
    uint64_t v2 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v3 = 136315394;
    int v4 = "RESyncPacketPoolFreePacket";
    __int16 v5 = 2080;
    __int16 v6 = "packet != __null";
LABEL_11:
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return;
  }
  re::PacketPool::free(a1, a2);
}

_anonymous_namespace_::AddressList *RESyncAddressListCreate(re *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1 && a2)
  {
    uint64_t v7 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = 136315394;
      uint64_t v9 = "RESyncAddressListCreate";
      __int16 v10 = 2080;
      uint64_t v11 = "addresses != __null || addressesCount == 0";
      _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v8, 0x16u);
    }
    return 0;
  }
  else
  {
    int v4 = re::globalAllocators(a1);
    __int16 v5 = (_anonymous_namespace_::AddressList *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 64, 8);
  }
}

_anonymous_namespace_::AddressList *RESyncAddressListCreateWithAddress(char *a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  __int16 v5 = a1;
  if (a1)
  {
    uint64_t v1 = re::globalAllocators((re *)a1);
    uint64_t v2 = (_anonymous_namespace_::AddressList *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 64, 8);
  }
  else
  {
    int v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v7 = "RESyncAddressListCreateWithAddress";
      __int16 v8 = 2080;
      uint64_t v9 = "address != __null";
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    }
    return 0;
  }
}

uint64_t RESyncAddressListGetAddressAtIndex(uint64_t a1, unint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      __int16 v6 = "RESyncAddressListGetAddressAtIndex";
      __int16 v7 = 2080;
      __int16 v8 = "addressList != __null";
      _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v5, 0x16u);
    }
    return 0;
  }
  if (*(void *)(a1 + 40) <= a2) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 56) + 32 * a2;
  if (*(unsigned char *)(v2 + 8)) {
    return *(void *)(v2 + 16);
  }
  else {
    return v2 + 9;
  }
}

uint64_t RESyncAddressListGetSize(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 40);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    int v4 = "RESyncAddressListGetSize";
    __int16 v5 = 2080;
    __int16 v6 = "addressList != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncPacketGetData(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 16);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    int v4 = "RESyncPacketGetData";
    __int16 v5 = 2080;
    __int16 v6 = "packet != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncPacketGetSize(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(unsigned int *)(a1 + 24);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  uint64_t result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v3 = 136315394;
    int v4 = "RESyncPacketGetSize";
    __int16 v5 = 2080;
    __int16 v6 = "packet != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  return result;
}

void RESyncPacketSetSize(uint64_t a1, int a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(_DWORD *)(a1 + 24) = a2;
  }
  else
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      int v4 = "RESyncPacketSetSize";
      __int16 v5 = 2080;
      __int16 v6 = "packet != __null";
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncPacketGetCapacity(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(unsigned int *)(a1 + 28);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  uint64_t result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v3 = 136315394;
    int v4 = "RESyncPacketGetCapacity";
    __int16 v5 = 2080;
    __int16 v6 = "packet != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  return result;
}

uint64_t RESyncPacketGetDeliveryMethod(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(unsigned int *)(a1 + 32);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  uint64_t result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v3 = 136315394;
    int v4 = "RESyncPacketGetDeliveryMethod";
    __int16 v5 = 2080;
    __int16 v6 = "packet != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  return result;
}

re::ProtocolHandle *RESyncProtocolHandleCreate(re *a1)
{
  uint64_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 1768, 8);
  bzero(v2, 0x6E8uLL);
  return re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v2);
}

uint64_t RESyncProtocolHandleGetConnection(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 24);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    int v4 = "RESyncProtocolHandleGetConnection";
    __int16 v5 = 2080;
    __int16 v6 = "handle != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncProtocolHandleConnectionSetStats(uint64_t a1, int *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __int16 v6 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v9 = "RESyncProtocolHandleConnectionSetStats";
    __int16 v10 = 2080;
    uint64_t v11 = "handle != __null";
    goto LABEL_11;
  }
  if (!a2)
  {
    __int16 v6 = *re::networkLogObjects((re *)a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v9 = "RESyncProtocolHandleConnectionSetStats";
    __int16 v10 = 2080;
    uint64_t v11 = "stats != __null";
LABEL_11:
    _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return;
  }
  int v3 = *a2;
  int v4 = a2[1];
  __int16 v5 = (os_unfair_lock_s *)(a1 + 1760);
  long long v7 = *(_OWORD *)(a2 + 2);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1760));
  *(_DWORD *)(a1 + 1736) = v3;
  *(_DWORD *)(a1 + 1740) = v4;
  *(_OWORD *)(a1 + 1744) = v7;
  os_unfair_lock_unlock(v5);
}

void RESyncProtocolHandleConnectionGetStats(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (a1)
  {
    int v4 = (os_unfair_lock_s *)(a1 + 1760);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1760));
    int v5 = *(_DWORD *)(a1 + 1736);
    int v6 = *(_DWORD *)(a1 + 1740);
    long long v8 = *(_OWORD *)(a1 + 1744);
    os_unfair_lock_unlock(v4);
    *(_DWORD *)a2 = v5;
    *(_DWORD *)(a2 + 4) = v6;
    *(_OWORD *)(a2 + 8) = v8;
  }
  else
  {
    long long v7 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      __int16 v10 = "RESyncProtocolHandleConnectionGetStats";
      __int16 v11 = 2080;
      uint64_t v12 = "handle != __null";
      _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
}

uint64_t RESyncProtocolHandleGetUserData(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 1728);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    int v4 = "RESyncProtocolHandleGetUserData";
    __int16 v5 = 2080;
    int v6 = "handle != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncProtocolHandleSetUserData(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(void *)(a1 + 1728) = a2;
  }
  else
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      int v4 = "RESyncProtocolHandleSetUserData";
      __int16 v5 = 2080;
      int v6 = "handle != __null";
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncGetChannelIdMaxChannels()
{
  return 10;
}

uint64_t RESyncProtocolHandleQueueDeqeue(re *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    __int16 v5 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315394;
      uint64_t v7 = "RESyncProtocolHandleQueueDeqeue";
      __int16 v8 = 2080;
      uint64_t v9 = "handle != __null";
      goto LABEL_17;
    }
    return 0;
  }
  if (a3 >= 0xA)
  {
    __int16 v5 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315394;
      uint64_t v7 = "RESyncProtocolHandleQueueDeqeue";
      __int16 v8 = 2080;
      uint64_t v9 = "channelId < kRESyncChannelIdMaxChannels";
      goto LABEL_17;
    }
    return 0;
  }
  if (a2 >= 2)
  {
    __int16 v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v6 = 136315394;
    uint64_t v7 = "RESyncProtocolHandleQueueDeqeue";
    __int16 v8 = 2080;
    uint64_t v9 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
LABEL_17:
    _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return 0;
  }
  if (a2) {
    int v3 = (re *)((char *)a1 + 40 * a3 + 1312);
  }
  else {
    int v3 = (re *)((char *)a1 + 40 * a3 + 912);
  }
  return re::PacketQueue::dequeue(v3);
}

void RESyncProtocolHandleQueueEnqeue(re *a1, unsigned int a2, unsigned int a3, unint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int v6 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v7 = 136315394;
    __int16 v8 = "RESyncProtocolHandleQueueEnqeue";
    __int16 v9 = 2080;
    uint64_t v10 = "handle != __null";
    goto LABEL_17;
  }
  if (a3 >= 0xA)
  {
    int v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v7 = 136315394;
    __int16 v8 = "RESyncProtocolHandleQueueEnqeue";
    __int16 v9 = 2080;
    uint64_t v10 = "channelId < kRESyncChannelIdMaxChannels";
    goto LABEL_17;
  }
  if (a2 >= 2)
  {
    int v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v7 = 136315394;
    __int16 v8 = "RESyncProtocolHandleQueueEnqeue";
    __int16 v9 = 2080;
    uint64_t v10 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
    goto LABEL_17;
  }
  if (!a4)
  {
    int v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v7 = 136315394;
    __int16 v8 = "RESyncProtocolHandleQueueEnqeue";
    __int16 v9 = 2080;
    uint64_t v10 = "_packet != __null";
LABEL_17:
    _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v7, 0x16u);
    return;
  }
  unsigned int v4 = *(_DWORD *)(a4 + 24);
  __int16 v5 = (char *)a1 + 40 * a3;
  if (a2)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)v5 + 334, v4, memory_order_release);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 168, *(unsigned int *)(a4 + 28), memory_order_release);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 166, 1uLL, memory_order_release);
    atomic_store(a4, *((unint64_t **)v5 + 164));
    *((void *)v5 + 164) = a4;
  }
  else
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)v5 + 234, v4, memory_order_release);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 118, *(unsigned int *)(a4 + 28), memory_order_release);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v5 + 116, 1uLL, memory_order_release);
    atomic_store(a4, *((unint64_t **)v5 + 114));
    *((void *)v5 + 114) = a4;
  }
}

uint64_t RESyncProtocolHandleQueueGetSizeInBytes(re *a1, unsigned int a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v8 = 136315394;
    __int16 v9 = "RESyncProtocolHandleQueueGetSizeInBytes";
    __int16 v10 = 2080;
    uint64_t v11 = "handle != __null";
LABEL_15:
    _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v8, 0x16u);
    return 0;
  }
  if (a2 >= 2)
  {
    int v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v8 = 136315394;
    __int16 v9 = "RESyncProtocolHandleQueueGetSizeInBytes";
    __int16 v10 = 2080;
    uint64_t v11 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
    goto LABEL_15;
  }
  uint64_t v3 = 0;
  uint64_t result = 0;
  if (a2)
  {
    __int16 v5 = (char *)a1 + 1336;
    do
    {
      result += atomic_load_explicit((atomic_uint *volatile)&v5[v3], memory_order_acquire);
      v3 += 40;
    }
    while (v3 != 400);
  }
  else
  {
    int v6 = (char *)a1 + 936;
    do
    {
      result += atomic_load_explicit((atomic_uint *volatile)&v6[v3], memory_order_acquire);
      v3 += 40;
    }
    while (v3 != 400);
  }
  return result;
}

uint64_t RESyncProtocolHandleQueueGetCapacityInBytes(re *a1, unsigned int a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int v7 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v8 = 136315394;
    __int16 v9 = "RESyncProtocolHandleQueueGetCapacityInBytes";
    __int16 v10 = 2080;
    uint64_t v11 = "handle != __null";
LABEL_15:
    _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v8, 0x16u);
    return 0;
  }
  if (a2 >= 2)
  {
    int v7 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v8 = 136315394;
    __int16 v9 = "RESyncProtocolHandleQueueGetCapacityInBytes";
    __int16 v10 = 2080;
    uint64_t v11 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
    goto LABEL_15;
  }
  uint64_t v3 = 0;
  uint64_t result = 0;
  if (a2)
  {
    __int16 v5 = (char *)a1 + 1344;
    do
    {
      result += atomic_load_explicit((atomic_ullong *volatile)&v5[v3], memory_order_acquire);
      v3 += 40;
    }
    while (v3 != 400);
  }
  else
  {
    int v6 = (char *)a1 + 944;
    do
    {
      result += atomic_load_explicit((atomic_ullong *volatile)&v6[v3], memory_order_acquire);
      v3 += 40;
    }
    while (v3 != 400);
  }
  return result;
}

unint64_t RESyncProtocolHandleQueueGetSize(re *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int v6 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136315394;
      int v8 = "RESyncProtocolHandleQueueGetSize";
      __int16 v9 = 2080;
      __int16 v10 = "handle != __null";
      goto LABEL_16;
    }
    return 0;
  }
  if (a3 >= 0xA)
  {
    int v6 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136315394;
      int v8 = "RESyncProtocolHandleQueueGetSize";
      __int16 v9 = 2080;
      __int16 v10 = "channelId < kRESyncChannelIdMaxChannels";
      goto LABEL_16;
    }
    return 0;
  }
  if (a2 >= 2)
  {
    int v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v7 = 136315394;
    int v8 = "RESyncProtocolHandleQueueGetSize";
    __int16 v9 = 2080;
    __int16 v10 = "type == kRESyncPacketQueueTypeSend || type == kRESyncPacketQueueTypeReceive";
LABEL_16:
    _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v7, 0x16u);
    return 0;
  }
  uint64_t v3 = (char *)a1 + 40 * a3;
  if (a2) {
    unsigned int v4 = (atomic_ullong *)(v3 + 1328);
  }
  else {
    unsigned int v4 = (atomic_ullong *)(v3 + 928);
  }
  return atomic_load_explicit(v4, memory_order_acquire);
}

re::ProtocolHandle *re::ProtocolHandle::ProtocolHandle(re::ProtocolHandle *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *((void *)this + 3) = 0;
  *(void *)this = &unk_26DD34DF0;
  for (uint64_t i = 32; i != 432; i += 40)
    re::PacketQueue::PacketQueue((re::ProtocolHandle *)((char *)this + i));
  uint64_t v3 = 432;
  do
  {
    unsigned int v4 = (char *)this + v3;
    *((_DWORD *)v4 + 8) = 0;
    *(_OWORD *)unsigned int v4 = 0uLL;
    *((_OWORD *)v4 + 1) = 0uLL;
    *(void *)(v4 + 36) = 0x7FFFFFFFLL;
    v3 += 48;
  }
  while (v4 + 48 != (char *)this + 912);
  for (uint64_t j = 912; j != 1312; j += 40)
    re::PacketQueue::PacketQueue((re::ProtocolHandle *)((char *)this + j));
  for (uint64_t k = 1312; k != 1712; k += 40)
    re::PacketQueue::PacketQueue((re::ProtocolHandle *)((char *)this + k));
  *((void *)this + 220) = 0;
  *((void *)this + 215) = 0;
  *((void *)this + 216) = 0;
  *((void *)this + 214) = 0;
  return this;
}

void re::ProtocolHandle::~ProtocolHandle(re::ProtocolHandle *this)
{
  re::ProtocolHandle::~ProtocolHandle(this);
  JUMPOUT(0x22A6A9430);
}

{
  uint64_t i;
  uint64_t j;
  uint64_t k;

  *(void *)this = &unk_26DD34DF0;
  for (uint64_t i = 1672; i != 1272; i -= 40)
    re::PacketQueue::~PacketQueue((re::ProtocolHandle *)((char *)this + i));
  do
  {
    re::PacketQueue::~PacketQueue((re::ProtocolHandle *)((char *)this + i));
    i -= 40;
  }
  while (i != 872);
  for (uint64_t j = 864; j != 384; j -= 48)
    re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit((uint64_t *)((char *)this + j));
  for (uint64_t k = 392; k != -8; k -= 40)
    re::PacketQueue::~PacketQueue((re::ProtocolHandle *)((char *)this + k));
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

double re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 80;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(result + 8) = v1 & 0x7FFFFFFF;
    uint64_t v2 = (uint64_t *)(result + 16);
    re::FixedArray<BOOL>::deinit((uint64_t *)(result + 40));
    return re::FixedArray<BOOL>::deinit(v2);
  }
  return result;
}

uint64_t re::FixedArray<BOOL>::deinit(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    if (a1[1])
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, a1[2]);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  return result;
}

void anonymous namespace'::ProtocolLayerObserver::~ProtocolLayerObserver(const void **this)
{
  *this = &unk_26DD34C20;
  _Block_release(this[3]);
  _Block_release(this[4]);
  _Block_release(this[5]);
  _Block_release(this[6]);
  _Block_release(this[7]);
  _Block_release(this[8]);
  _Block_release(this[9]);
  _Block_release(this[10]);
  _Block_release(this[11]);
  _Block_release(this[12]);
  _Block_release(this[13]);
  _Block_release(this[14]);
  _Block_release(this[15]);
  _Block_release(this[16]);
  _Block_release(this[17]);
  _Block_release(this[18]);
  _Block_release(this[19]);
  _Block_release(this[20]);
  *this = &unk_26DD34510;
  objc_destructInstance(this + 1);
}

{
  uint64_t vars8;

  JUMPOUT(0x22A6A9430);
}

uint64_t re::make::shared::object<re::NWProtocolLayer,re::NWProtocolLayer::Config &>(re *a1, uint64_t a2)
{
  unint64_t v4 = re::globalAllocators(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 224, 8);
  uint64_t result = re::NWProtocolLayer::NWProtocolLayer(v5, a2);
  *(void *)a1 = result;
  return result;
}

re::DebugProtocolLayer *re::make::shared::object<re::DebugProtocolLayer>@<X0>(re *a1@<X0>, re::DebugProtocolLayer **a2@<X8>)
{
  uint64_t v3 = re::globalAllocators(a1);
  unint64_t v4 = (re::DebugProtocolLayer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 184, 8);
  uint64_t result = re::DebugProtocolLayer::DebugProtocolLayer(v4);
  *a2 = result;
  return result;
}

void anonymous namespace'::SyncCustomProtocolLayer::~SyncCustomProtocolLayer(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 3) + 32);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 112));
  std::mutex::~mutex((std::mutex *)((char *)this + 48));
  uint64_t v3 = *((void *)this + 3);
  if (v3)
  {

    *((void *)this + 3) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  JUMPOUT(0x22A6A9430);
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::init(re *a1, int8x16_t *a2)
{
  uint64_t v3 = *((void *)a1 + 3);
  if (*(void *)(v3 + 48))
  {
    uint64_t v5 = re::globalAllocators(a1);
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 40, 8);
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
    *(void *)(v6 + 32) = 0;
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)v6, 0);
    *(void *)uint64_t v6 = &unk_26DD34D30;
    *(int8x16_t *)(v6 + 24) = vextq_s8(*a2, *a2, 8uLL);
    uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(*((void *)a1 + 3) + 48) + 16))();

    return v7;
  }
  else
  {
    __int16 v9 = *(uint64_t (**)(void))(*(void *)(v3 + 40) + 16);
    return v9();
  }
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::deinit(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 56) + 16))();
  *((void *)this + 4) = 0;
  return result;
}

char *anonymous namespace'::SyncCustomProtocolLayer::open@<X0>(_anonymous_namespace_::SyncCustomProtocolLayer *this@<X0>, const Address *a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *((void *)this + 3);
  uint64_t v5 = *(void *)(v4 + 64);
  if (!v5) {
    uint64_t v5 = *(void *)(v4 + 72);
  }
  if (a2->var0.var1.var0.var0.var1) {
    var1 = a2->var0.var1.var0.var1;
  }
  else {
    var1 = a2->var0.var1.var1.var2;
  }
  uint64_t result = (char *)(*(uint64_t (**)(uint64_t, char *))(v5 + 16))(v5, var1);
  *a3 = result;
  if (result)
  {
    int v8 = result + 8;
    return (char *)v8;
  }
  return result;
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::close(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 80) + 16))();
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::disconnect(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 88) + 16))();
}

BOOL anonymous namespace'::SyncCustomProtocolLayer::drainsPacketSink(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  return *(void *)(*((void *)this + 3) + 96) != 0;
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::send(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 24) + 96);
  uint64_t v5 = MEMORY[0x263EF8330];
  uint64_t v6 = 0x40000000;
  uint64_t v7 = ___ZN12_GLOBAL__N_123SyncCustomProtocolLayer4sendEPN2re14ProtocolHandleERNS2_10PacketSinkE_block_invoke;
  int v8 = &__block_descriptor_tmp_2;
  uint64_t v9 = a3;
  return (*(uint64_t (**)(void))(v3 + 16))();
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::update(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t result = *(void *)(*((void *)this + 3) + 104);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void anonymous namespace'::SyncCustomProtocolLayer::wait(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 3) + 112);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(v2 + 16);
    v3();
  }
  else
  {
    v4.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 48);
    v4.__owns_ = 1;
    std::mutex::lock((std::mutex *)((char *)this + 48));
    std::condition_variable::wait((std::condition_variable *)((char *)this + 112), &v4);
    if (v4.__owns_) {
      std::mutex::unlock(v4.__m_);
    }
  }
}

void anonymous namespace'::SyncCustomProtocolLayer::wakeup(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 3) + 120);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  else {
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 112));
  }
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::setListener(_anonymous_namespace_::SyncCustomProtocolLayer *this, ProtocolLayerListener *a2)
{
  *((void *)this + 4) = a2;
  uint64_t result = *(void *)(*((void *)this + 3) + 160);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

unint64_t anonymous namespace'::SyncCustomProtocolLayer::localAddresses(_anonymous_namespace_::SyncCustomProtocolLayer *this, re::Address *a2, unint64_t a3)
{
  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 128) + 16))();
  unint64_t Size = RESyncAddressListGetSize(v5);
  unint64_t v7 = Size;
  if (a2)
  {
    if (Size >= a3) {
      unint64_t v7 = a3;
    }
    if (v7)
    {
      for (unint64_t i = 0; i != v7; ++i)
      {
        AddressAtIndex = (_anonymous_namespace_ *)RESyncAddressListGetAddressAtIndex(v5, i);
        re::DynamicString::DynamicString((re::DynamicString *)v13, (const re::DynamicString *)&v11);
        re::DynamicString::operator=(a2, (re::DynamicString *)v13);
        if (*(void *)&v13[0])
        {
          if (BYTE8(v13[0])) {
            (*(void (**)(void))(**(void **)&v13[0] + 40))();
          }
          memset(v13, 0, sizeof(v13));
        }
        if (v11 && (v12 & 1) != 0) {
          (*(void (**)(void))(*(void *)v11 + 40))();
        }
        a2 = (re::Address *)((char *)a2 + 32);
      }
    }
  }

  return v7;
}

double anonymous namespace'::SyncCustomProtocolLayer::hostStats(uint64_t a1, uint64_t a2)
{
  long long v5 = 0uLL;
  uint64_t v4 = 0;
  if ((*(unsigned int (**)(void))(*(void *)(*(void *)(a1 + 24) + 136) + 16))())
  {
    *(void *)a2 = v4;
    double result = *(double *)&v5;
    *(_OWORD *)(a2 + 8) = v5;
  }
  return result;
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::setDisconnectTimeout(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 144) + 16))();
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::preferredPacketSize(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 152) + 16))();
}

uint64_t anonymous namespace'::SyncCustomProtocolLayer::preferredThreadMode(_anonymous_namespace_::SyncCustomProtocolLayer *this)
{
  return *((unsigned int *)this + 10);
}

void anonymous namespace'::CustomProtocolLayerConfig::~CustomProtocolLayerConfig(_anonymous_namespace_::CustomProtocolLayerConfig *this)
{
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

void ___ZN12_GLOBAL__N_123SyncCustomProtocolLayer4sendEPN2re14ProtocolHandleERNS2_10PacketSinkE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v3 = *(void *)v2;
  if (*(void *)v2 != *((void *)v2 + 1))
  {
    do
    {
      unint64_t v5 = atomic_load(*(unint64_t **)(v3 + 8));
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(*(void *)v2 + 16), memory_order_acquire);
      if (v5)
      {
        unint64_t v7 = explicit + 1;
        do
        {
          if (!--v7) {
            break;
          }
          if (!(*(unsigned int (**)(uint64_t, void, void, void, void))(a2 + 16))(a2, v2[16], *(void *)(v5 + 16), *(unsigned int *)(v5 + 24), *(unsigned int *)(v5 + 32)))return; {
          int v8 = (re::PacketPool **)re::PacketQueue::dequeue(*(re::PacketQueue **)v2);
          }
          re::PacketPool::free(v8[7], (re::Packet *)v8);
          unint64_t v5 = atomic_load(*(unint64_t **)(*(void *)v2 + 8));
        }
        while (v5);
      }
      uint64_t v9 = *((void *)v2 + 1);
      uint64_t v3 = *(void *)v2 + 40;
      *(void *)uint64_t v2 = v3;
      ++v2[16];
    }
    while (v3 != v9);
  }
}

_anonymous_namespace_::AddressList *anonymous namespace'::AddressList::AddressList(_anonymous_namespace_::AddressList *this, const char **a2, uint64_t a3)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD34D78;
  *((void *)this + 3) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  for (*((_DWORD *)this + 12) = 0; a3; --a3)
  {
    unint64_t v7 = *a2;
    if (*a2)
    {
      unint64_t v9 = *((void *)this + 4);
      unint64_t v10 = *((void *)this + 5);
      if (v10 >= v9)
      {
        unint64_t v11 = v10 + 1;
        if (v9 < v10 + 1)
        {
          if (*((void *)this + 3))
          {
            if (v9) {
              unint64_t v12 = 2 * v9;
            }
            else {
              unint64_t v12 = 8;
            }
            if (v12 <= v11) {
              unint64_t v13 = v10 + 1;
            }
            else {
              unint64_t v13 = v12;
            }
            re::DynamicArray<re::DynamicString>::setCapacity((void *)this + 3, v13);
          }
          else
          {
            re::DynamicArray<re::DynamicString>::setCapacity((void *)this + 3, v11);
            ++*((_DWORD *)this + 12);
          }
        }
        unint64_t v10 = *((void *)this + 5);
      }
      uint64_t v14 = *((void *)this + 7) + 32 * v10;
      *(_OWORD *)uint64_t v14 = 0u;
      *(_OWORD *)(v14 + 16) = 0u;
      *(void *)uint64_t v14 = v18;
      uint64_t v18 = 0;
      uint64_t v15 = *(void *)(v14 + 16);
      *(void *)(v14 + 16) = v20;
      uint64_t v20 = v15;
      *(void *)(v14 + 24) = v21;
      uint64_t v21 = 0;
      uint64_t v16 = *(void *)(v14 + 8);
      *(void *)(v14 + 8) = v19;
      uint64_t v19 = v16;
      ++*((void *)this + 5);
      ++*((_DWORD *)this + 12);
      uint64_t v6 = v18;
      if (v18 && (v16 & 1) != 0) {
        uint64_t v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v18 + 40))();
      }
    }
    ++a2;
  }
  return this;
}

void anonymous namespace'::AddressList::~AddressList(_anonymous_namespace_::AddressList *this)
{
  *(void *)this = &unk_26DD34D78;
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)this + 24);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD34D78;
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)this + 24);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

void *re::DynamicArray<re::DynamicString>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::DynamicString>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 32 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      int v8 = (re::DynamicString *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = (re::DynamicString *)((char *)v8 + 32 * v9);
        unint64_t v11 = v7;
        do
        {
          *(_OWORD *)unint64_t v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          v11[3] = *((void *)v8 + 3);
          uint64_t v12 = *((void *)v8 + 1);
          *unint64_t v11 = *(void *)v8;
          *(void *)int v8 = 0;
          uint64_t v13 = *((void *)v8 + 2);
          *((void *)v8 + 3) = 0;
          uint64_t v15 = v11[1];
          uint64_t v14 = v11[2];
          v11[1] = v12;
          v11[2] = v13;
          *((void *)v8 + 1) = v15;
          *((void *)v8 + 2) = v14;
          re::DynamicString::deinit(v8);
          int v8 = (re::DynamicString *)((char *)v8 + 32);
          v11 += 4;
        }
        while (v8 != v10);
        int v8 = (re::DynamicString *)v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, re::DynamicString *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::DynamicString>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::DynamicString **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 32 * v4;
        do
        {
          re::DynamicString::deinit(v3);
          uint64_t v3 = (re::DynamicString *)((char *)v3 + 32);
          v5 -= 32;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::DynamicString **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::DynamicString *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::SharedAppSyncManager::~SharedAppSyncManager(re::SharedAppSyncManager *this)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26DD34E58;
  if (!*((unsigned char *)this + 448)) {
    goto LABEL_47;
  }
  *((unsigned char *)this + 448) = 0;
  uint64_t v2 = (const void *)*((void *)this + 63);
  if (v2)
  {
    _Block_release(v2);
    *((void *)this + 63) = 0;
  }
  uint64_t v3 = *((void *)this + 53);
  if (v3)
  {
    uint64_t v34 = this;
    *(void *)&long long v35 = re::SharedAppSyncManager::onViewAdded;
    *((void *)&v35 + 1) = 0;
    *(void *)&long long v36 = re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke;
    re::Event<re::SyncViewManager,re::SyncView *>::removeSubscription(v3 + 24, (long long *)&v34);
  }
  uint64_t v4 = (unsigned char *)*((void *)this + 51);
  if (!v4[2272]) {
    goto LABEL_47;
  }
  uint64_t v5 = (*(uint64_t (**)(unsigned char *))(*(void *)v4 + 40))(v4);
  if (v6)
  {
    unint64_t v7 = (uint64_t *)v5;
    uint64_t v8 = 8 * v6;
    do
    {
      uint64_t v9 = *v7;
      if (*v7)
      {
        id v10 = (id)(v9 + 8);
        v31.isa = (Class)v9;
        id v11 = (id)(v9 + 8);
        re::SharedAppSyncManager::removePeerStateForParticipant((uint64_t)this, &v31);

        v31.isa = 0;
      }
      else
      {
        v31.isa = 0;
        re::SharedAppSyncManager::removePeerStateForParticipant((uint64_t)this, &v31);
      }
      ++v7;
      v8 -= 8;
    }
    while (v8);
  }
  uint64_t v12 = *((void *)this + 51);
  uint64_t v13 = *(void *)(v12 + 7520);
  if (v13)
  {
    *(void *)&long long v32 = this;
    *((void *)&v32 + 1) = re::SharedAppSyncManager::handleCongestionEvent;
    *(void *)&long long v33 = 0;
    *((void *)&v33 + 1) = re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke;
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v13 + 224, &v32, (uint64_t)&v34);
    if ((_BYTE)v34)
    {
      if (*(_DWORD *)(v13 + 304))
      {
        LOBYTE(v34) = 0;
        long long v35 = v32;
        long long v36 = v33;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v13 + 264), (uint64_t)&v34);
      }
      else
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable((void *)(v13 + 224), &v32);
      }
    }
    uint64_t v12 = *((void *)this + 51);
  }
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v12 + 2056, (uint64_t)this);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(*((void *)this + 51) + 1968, (uint64_t)this);
  uint64_t v14 = *((void *)this + 51);
  if (*(void *)(v14 + 400))
  {
    unint64_t v15 = 0;
    while (1)
    {
      uint64_t v16 = (re::SharedAppSyncManager **)(*(void *)(v14 + 416) + 32 * v15);
      if (*v16 == this)
      {
        if (!*(_DWORD *)(v14 + 464))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v14 + 384), v15);
          goto LABEL_25;
        }
        LOBYTE(v34) = 0;
        long long v17 = *((_OWORD *)v16 + 1);
        long long v35 = *(_OWORD *)v16;
        long long v36 = v17;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v14 + 424), (uint64_t)&v34);
      }
      ++v15;
LABEL_25:
      if (v15 >= *(void *)(v14 + 400))
      {
        uint64_t v14 = *((void *)this + 51);
        break;
      }
    }
  }
  if (!*(void *)(v14 + 312)) {
    goto LABEL_37;
  }
  unint64_t v18 = 0;
  do
  {
    uint64_t v19 = *(void *)(v14 + 328) + 32 * v18;
    if (*(re::SharedAppSyncManager **)v19 != this) {
      goto LABEL_33;
    }
    if (*(_DWORD *)(v14 + 376))
    {
      LOBYTE(v34) = 0;
      long long v20 = *(_OWORD *)(v19 + 16);
      long long v35 = *(_OWORD *)v19;
      long long v36 = v20;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v14 + 336), (uint64_t)&v34);
LABEL_33:
      ++v18;
      continue;
    }
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v14 + 296), v18);
  }
  while (v18 < *(void *)(v14 + 312));
  uint64_t v14 = *((void *)this + 51);
LABEL_37:
  if (!*(void *)(v14 + 224)) {
    goto LABEL_46;
  }
  unint64_t v21 = 0;
  while (2)
  {
    int v22 = (re::SharedAppSyncManager **)(*(void *)(v14 + 240) + 32 * v21);
    if (*v22 == this)
    {
      if (*(_DWORD *)(v14 + 288))
      {
        LOBYTE(v34) = 0;
        long long v23 = *((_OWORD *)v22 + 1);
        long long v35 = *(_OWORD *)v22;
        long long v36 = v23;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v14 + 248), (uint64_t)&v34);
        goto LABEL_42;
      }
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v14 + 208), v21);
    }
    else
    {
LABEL_42:
      ++v21;
    }
    if (v21 < *(void *)(v14 + 224)) {
      continue;
    }
    break;
  }
  uint64_t v14 = *((void *)this + 51);
LABEL_46:
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v14 + 120, (uint64_t)this);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(*((void *)this + 51) + 32, (uint64_t)this);
LABEL_47:
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 512);
  uint64_t v24 = *((void *)this + 57);
  if (v24)
  {
    uint64_t v25 = (re *)*((void *)this + 61);
    if (v25)
    {
      uint64_t v26 = *((void *)this + 59);
      if (v26)
      {
        uint64_t v27 = 8 * v26;
        do
        {
          std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::~unique_ptr[abi:nn180100](v25);
          uint64_t v25 = (re *)((char *)v25 + 8);
          v27 -= 8;
        }
        while (v27);
        uint64_t v24 = *((void *)this + 57);
        uint64_t v25 = (re *)*((void *)this + 61);
      }
      (*(void (**)(uint64_t, re *))(*(void *)v24 + 40))(v24, v25);
    }
    *((void *)this + 61) = 0;
    *((void *)this + 58) = 0;
    *((void *)this + 59) = 0;
    *((void *)this + 57) = 0;
    ++*((_DWORD *)this + 120);
  }
  uint64_t v28 = *((void *)this + 53);
  if (v28)
  {

    *((void *)this + 53) = 0;
  }
  uint64_t v29 = *((void *)this + 52);
  if (v29)
  {

    *((void *)this + 52) = 0;
  }
  uint64_t v30 = *((void *)this + 51);
  if (v30)
  {

    *((void *)this + 51) = 0;
  }
  re::SyncSession::~SyncSession(this);
}

{
  uint64_t vars8;

  re::SharedAppSyncManager::~SharedAppSyncManager(this);
  JUMPOUT(0x22A6A9430);
}

void re::SharedAppSyncManager::init(uint64_t a1, long long *a2)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)a2 + 4);
  unsigned int v5 = *(_DWORD *)(v4 + 2832);
  unsigned int v6 = *((_DWORD *)a2 + 5);
  if (v6 >= v5) {
    unsigned int v6 = *(_DWORD *)(v4 + 2832);
  }
  if (v5 >= *((_DWORD *)a2 + 4)) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = *((_DWORD *)a2 + 4);
  }
  *(_DWORD *)(a1 + 496) = v7;
  *(_DWORD *)(a1 + 500) = *(_DWORD *)(v4 + 2232);
  long long v8 = *a2;
  *(_OWORD *)(a1 + 385) = *(long long *)((char *)a2 + 9);
  *(_OWORD *)(a1 + 376) = v8;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 408), *((void *)a2 + 4));
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 416), *((void *)a2 + 5));
  uint64_t v9 = (uint64_t *)(a1 + 424);
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 424), *((void *)a2 + 6));
  uint64_t v10 = *((void *)a2 + 7);
  *(_DWORD *)(a1 + 440) = *((_DWORD *)a2 + 16);
  *(void *)(a1 + 432) = v10;
  uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 408) + 40))(*(void *)(a1 + 408));
  if (v12)
  {
    uint64_t v13 = (uint64_t *)v11;
    uint64_t v14 = 8 * v12;
    do
    {
      uint64_t v15 = *v13;
      if (*v13) {
        id v16 = (id)(v15 + 8);
      }
      uint64_t v17 = *(void *)(v15 + 152);
      if (v17 && ((*(uint64_t (**)(uint64_t))(*(void *)v17 + 48))(v17) & 1) == 0)
      {
        uint64_t v28 = v15;
        id v18 = (id)(v15 + 8);
        re::SharedAppSyncManager::addPeerStateForParticipant(a1, &v28);

        uint64_t v28 = 0;
      }

      ++v13;
      v14 -= 8;
    }
    while (v14);
  }
  uint64_t v19 = (_DWORD *)(*(void *)(a1 + 408) + 32);
  uint64_t v29 = a1;
  uint64_t v30 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onSessionWillDeinit;
  uint64_t v31 = 0;
  long long v32 = re::Event<re::Session>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v19, (uint64_t)&v29);
  long long v20 = (_DWORD *)(*(void *)(a1 + 408) + 120);
  uint64_t v29 = a1;
  uint64_t v30 = re::SharedAppSyncManager::onSessionStarted;
  uint64_t v31 = 0;
  long long v32 = re::Event<re::Session>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v20, (uint64_t)&v29);
  unint64_t v21 = (_DWORD *)(*(void *)(a1 + 408) + 208);
  uint64_t v29 = a1;
  uint64_t v30 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onSessionStopped;
  uint64_t v31 = 0;
  long long v32 = re::Event<re::Session,re::SessionError>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v21, (uint64_t)&v29);
  int v22 = (_DWORD *)(*(void *)(a1 + 408) + 296);
  uint64_t v29 = a1;
  uint64_t v30 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onPeerJoined;
  uint64_t v31 = 0;
  long long v32 = re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v22, (uint64_t)&v29);
  long long v23 = (_DWORD *)(*(void *)(a1 + 408) + 384);
  uint64_t v29 = a1;
  uint64_t v30 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onPeerLeft;
  uint64_t v31 = 0;
  long long v32 = re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v23, (uint64_t)&v29);
  uint64_t v24 = (_DWORD *)(*(void *)(a1 + 408) + 1968);
  uint64_t v29 = a1;
  uint64_t v30 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onPeerPaused;
  uint64_t v31 = 0;
  long long v32 = re::Event<re::Session,unsigned long long>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v24, (uint64_t)&v29);
  uint64_t v25 = (_DWORD *)(*(void *)(a1 + 408) + 2056);
  uint64_t v29 = a1;
  uint64_t v30 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onPeerResumed;
  uint64_t v31 = 0;
  long long v32 = re::Event<re::Session,unsigned long long>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v25, (uint64_t)&v29);
  uint64_t v26 = *(void *)(*(void *)(a1 + 408) + 7520);
  if (v26)
  {
    uint64_t v29 = a1;
    uint64_t v30 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::handleCongestionEvent;
    uint64_t v31 = 0;
    long long v32 = re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke;
    re::Event<re::Session>::addSubscription((_DWORD *)(v26 + 224), (uint64_t)&v29);
  }
  uint64_t v27 = *v9;
  if (*v9)
  {
    uint64_t v29 = a1;
    uint64_t v30 = (uint64_t (*)(re::SharedAppSyncManager *, re::Session *))re::SharedAppSyncManager::onViewAdded;
    uint64_t v31 = 0;
    long long v32 = re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke;
    re::Event<re::Session>::addSubscription((_DWORD *)(v27 + 24), (uint64_t)&v29);
  }
  *(unsigned char *)(a1 + 448) = 1;
}

uint64_t re::SharedAppSyncManager::sendRate(re::SharedAppSyncManager *this)
{
  return *((void *)this + 47);
}

uint64_t (***re::SharedAppSyncManager::setViewFilter(uint64_t a1, void *aBlock))(void)
{
  v9[5] = *MEMORY[0x263EF8340];
  uint64_t v4 = *(const void **)(a1 + 504);
  if (v4) {
    _Block_release(v4);
  }
  unsigned int v5 = (re *)_Block_copy(aBlock);
  *(void *)(a1 + 504) = v5;
  uint64_t v6 = *(void *)(a1 + 424);
  uint64_t v7 = re::globalAllocators(v5)[2];
  v9[0] = &unk_26DD34F20;
  v9[1] = a1;
  unint64_t v9[3] = v7;
  unsigned char v9[4] = v9;
  re::SyncViewManager::forEachView(v6, (uint64_t)v9);
  return re::FunctionBase<24ul,void ()(re::SyncView *)>::destroyCallable((uint64_t)v9);
}

uint64_t re::SharedAppSyncManager::viewFilter(re::SharedAppSyncManager *this)
{
  return *((void *)this + 63);
}

re *re::SharedAppSyncManager::addPeerStateForParticipant(uint64_t a1, uint64_t *a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v4 = *re::networkLogObjects((re *)a1);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    uint64_t v6 = *(void *)(*a2 + 24);
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Adding new peer state. PeerID=%llu.", buf, 0xCu);
  }
  uint64_t v7 = re::globalAllocators((re *)v5);
  long long v8 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[2] + 32))(v7[2], 296, 8);
  uint64_t v9 = *a2;
  if (*a2) {
    id v10 = (id)(v9 + 8);
  }
  void v8[2] = 0;
  v8[3] = 0;
  *((_DWORD *)v8 + 8) = 0;
  v8[5] = 0;
  void v8[6] = a1;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_DWORD *)v8 + 24) = 0;
  *(uint64_t *)((char *)v8 + 100) = 0x7FFFFFFFLL;
  *long long v8 = (uint64_t)&unk_26DD34E20;
  v8[1] = 0;
  v8[14] = v9;
  uint64_t v11 = v8 + 14;
  objc_initWeak((id *)buf, (id)(a1 + 8));
  objc_initWeak(&location, (id)(*(void *)(a1 + 408) + 2328));
  uint64_t v13 = *(void *)(v8[14] + 24);
  uint64_t v12 = *(void *)(v8[14] + 32);
  uint64_t v14 = re::Session::peerID(*(re::Session **)(a1 + 408));
  uint64_t v15 = *(void *)(a1 + 416);
  if (v15) {
    id v16 = (void *)(v15 + 8);
  }
  else {
    id v16 = 0;
  }
  objc_initWeak(&v30, v16);
  re::SharedAppUnicast::SharedAppUnicast((uint64_t)(v8 + 15), (id *)buf, (re *)&location, v12, v13, v14, &v30, *(unsigned char *)(a1 + 400), (*(_DWORD *)(*v11 + 72) & 2) != 0);
  objc_destroyWeak(&v30);
  id v30 = 0;
  objc_destroyWeak(&location);
  id location = 0;
  objc_destroyWeak((id *)buf);
  uint64_t v17 = *v11;
  v8[29] = *(void *)(*v11 + 24);
  v8[30] = 0;
  *((_DWORD *)v8 + 62) = 0;
  *((unsigned char *)v8 + 252) = 0;
  v8[36] = 0;
  v8[33] = 0;
  v8[34] = 0;
  v8[32] = 0;
  *((_DWORD *)v8 + 70) = 0;
  v8[7] = *(void *)(v17 + 24);
  *((unsigned char *)v8 + 224) = 1;
  id location = v8;
  re::SharedPtr<re::SyncObject>::reset(v8 + 14, *a2);
  uint64_t v19 = *(void *)(a1 + 424);
  if (v19)
  {
    *(void *)buf = v8;
    id v18 = (re *)re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::addNew(v19 + 160, (uint64_t *)buf);
    uint64_t v20 = *(void *)(a1 + 424);
    if (v20)
    {
      if (*(void *)(a1 + 504))
      {
        uint64_t v21 = re::globalAllocators(v18)[2];
        v32[0] = &unk_26DD34FD0;
        v32[1] = a1;
        v32[2] = &location;
        v32[3] = v21;
        v32[4] = v32;
        re::SyncViewManager::forEachView(v20, (uint64_t)v32);
        id v18 = (re *)re::FunctionBase<24ul,void ()(re::SyncView *)>::destroyCallable((uint64_t)v32);
      }
    }
  }
  unint64_t v23 = *(void *)(a1 + 464);
  unint64_t v22 = *(void *)(a1 + 472);
  if (v22 >= v23)
  {
    unint64_t v24 = v22 + 1;
    if (v23 < v22 + 1)
    {
      if (*(void *)(a1 + 456))
      {
        unint64_t v25 = 2 * v23;
        if (!v23) {
          unint64_t v25 = 8;
        }
        if (v25 <= v24) {
          unint64_t v26 = v24;
        }
        else {
          unint64_t v26 = v25;
        }
        re::DynamicArray<std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>>::setCapacity((void *)(a1 + 456), v26);
      }
      else
      {
        re::DynamicArray<std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>>::setCapacity((void *)(a1 + 456), v24);
        ++*(_DWORD *)(a1 + 480);
      }
    }
    unint64_t v22 = *(void *)(a1 + 472);
  }
  uint64_t v27 = *(void *)(a1 + 488);
  id v28 = location;
  id location = 0;
  *(void *)(v27 + 8 * v22) = v28;
  *(void *)(a1 + 472) = v22 + 1;
  ++*(_DWORD *)(a1 + 480);
  return std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::~unique_ptr[abi:nn180100]((re *)&location);
}

uint64_t re::SharedAppSyncManager::onSessionWillDeinit(re::NetworkSyncManager **this, re::Session *a2)
{
  return 0;
}

uint64_t re::SharedAppSyncManager::onSessionStarted(re::SharedAppSyncManager *this, re::Session *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v3 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 134217984;
    uint64_t v6 = a2;
    _os_log_impl(&dword_228C70000, v3, OS_LOG_TYPE_DEFAULT, "SharedAppSyncManager: session started (%p).", (uint8_t *)&v5, 0xCu);
  }
  return 0;
}

uint64_t re::SharedAppSyncManager::onSessionStopped(re *a1, uint64_t a2, int a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134218240;
    uint64_t v8 = a2;
    __int16 v9 = 1024;
    int v10 = a3;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "SharedAppSyncManager: session stopped (%p) with error: %d.", (uint8_t *)&v7, 0x12u);
  }
  return 0;
}

uint64_t re::SharedAppSyncManager::onPeerJoined(re *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (void *)*a3;
    if (*(unsigned char *)(*a3 + 48)) {
      int v7 = (char *)v6[7];
    }
    else {
      int v7 = (char *)v6 + 49;
    }
    uint64_t v8 = v6[3];
    uint64_t v9 = v6[19];
    if (v9) {
      int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
    }
    else {
      int v10 = "nullptr";
    }
    *(_DWORD *)buf = 134218498;
    uint64_t v17 = v8;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2080;
    uint64_t v21 = v10;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "New peer joined object syncing. PeerID=%llu. Address='%s'. Identity='%s'.", buf, 0x20u);
  }
  uint64_t v11 = *a3;
  uint64_t v15 = v11;
  if (v11)
  {
    uint64_t v12 = (void *)(v11 + 8);
    id v13 = (id)(v11 + 8);
    re::SharedAppSyncManager::addPeerStateForParticipant((uint64_t)a1, &v15);
  }
  else
  {
    re::SharedAppSyncManager::addPeerStateForParticipant((uint64_t)a1, &v15);
  }
  return 0;
}

uint64_t re::SharedAppSyncManager::onPeerLeft(re *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (void *)*a3;
    if (*(unsigned char *)(*a3 + 48)) {
      int v7 = (char *)v6[7];
    }
    else {
      int v7 = (char *)v6 + 49;
    }
    uint64_t v8 = v6[3];
    uint64_t v9 = v6[19];
    if (v9) {
      int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
    }
    else {
      int v10 = "nullptr";
    }
    *(_DWORD *)buf = 134218498;
    uint64_t v17 = v8;
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    __int16 v20 = 2080;
    uint64_t v21 = v10;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "Peer left syncing. PeerID=%llu. Address='%s'. Identity='%s'.", buf, 0x20u);
  }
  uint64_t v11 = *a3;
  v15.isa = (Class)v11;
  if (v11)
  {
    uint64_t v12 = (void *)(v11 + 8);
    id v13 = (id)(v11 + 8);
    re::SharedAppSyncManager::removePeerStateForParticipant((uint64_t)a1, &v15);
  }
  else
  {
    re::SharedAppSyncManager::removePeerStateForParticipant((uint64_t)a1, &v15);
  }
  return 0;
}

uint64_t re::SharedAppSyncManager::onPeerPaused(re::SharedAppSyncManager *this, re::Session *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134217984;
    uint64_t v8 = a3;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "Pausing peerID %llu.", (uint8_t *)&v7, 0xCu);
  }
  (*(void (**)(re::SharedAppSyncManager *, uint64_t))(*(void *)this + 120))(this, a3);
  return 0;
}

uint64_t re::SharedAppSyncManager::onPeerResumed(re::SharedAppSyncManager *this, re::Session *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v5 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134217984;
    uint64_t v8 = a3;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "Resuming peerID %llu", (uint8_t *)&v7, 0xCu);
  }
  (*(void (**)(re::SharedAppSyncManager *, uint64_t))(*(void *)this + 128))(this, a3);
  return 0;
}

uint64_t re::SharedAppSyncManager::handleCongestionEvent(re *a1)
{
  int v1 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_debug_impl(&dword_228C70000, v1, OS_LOG_TYPE_DEBUG, "Emiting congestion event.", v3, 2u);
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  return 0;
}

void re::SharedAppSyncManager::removePeerStateForParticipant(uint64_t a1, NSObject *a2)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v4 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *((void *)a2->isa + 3);
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Removing peer state. PeerID=%llu.", buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 472);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = *((void *)a2->isa + 3);
    while (*(void *)(*(void *)(*(void *)(a1 + 488) + 8 * v7) + 56) != v8)
    {
      if (v6 == ++v7) {
        return;
      }
    }
    if ((v7 & 0x80000000) == 0)
    {
      re::SyncObjectStore::types(*(void **)(a1 + 416), (uint64_t)buf);
      uint64_t v41 = a1;
      uint64_t v9 = 0;
      if (*(void *)&buf[16])
      {
        a2 = (a1 + 512);
        int v10 = (uint64_t *)v45;
        int v42 = (uint64_t *)(v45 + 8 * *(void *)&buf[16]);
        do
        {
          uint64_t v11 = *v10;
          if (*(unsigned char *)(*(void *)(*v10 + 16) + 73))
          {
            uint64_t v12 = *(void *)(v11 + 64);
            if (v12)
            {
              id v13 = *(re::SyncObject ***)(v11 + 80);
              uint64_t v14 = &v13[v12];
              do
              {
                uint64_t v15 = re::SyncObject::fromPeerID(*v13);
                id v16 = *v13;
                if (v15 == v8) {
                  goto LABEL_20;
                }
                uint64_t v17 = (re::SyncObject *)*((void *)v16 + 10);
                __int16 v18 = *v13;
                if (v17)
                {
                  uint64_t v19 = *v13;
                  do
                  {
                    __int16 v18 = v19;
                    uint64_t v19 = v17;
                    if (*(unsigned char *)(*(void *)(*((void *)v18 + 11) + 16) + 73)) {
                      break;
                    }
                    uint64_t v17 = (re::SyncObject *)*((void *)v17 + 10);
                    __int16 v18 = v19;
                  }
                  while (v17);
                }
                if (*((void *)v18 + 20) == v8)
                {
LABEL_20:
                  unint64_t v20 = re::SyncObject::latestStateHandle(v16);
                  if (v20 == -1)
                  {
                    unint64_t v23 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
                    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v24 = *((void *)*v13 + 3);
                      unint64_t v25 = *(void **)(*((void *)*v13 + 11) + 16);
                      uint64_t v26 = v25[4];
                      uint64_t v27 = v25[6];
                      id v28 = (char *)v25[7];
                      uint64_t v29 = (char *)v25 + 49;
                      if (v27) {
                        uint64_t v29 = v28;
                      }
                      *(_DWORD *)BOOL v43 = 134218498;
                      *(void *)&v43[4] = v24;
                      *(_WORD *)&v43[12] = 2048;
                      *(void *)&v43[14] = v26;
                      *(_WORD *)&v43[22] = 2080;
                      *(void *)&v43[24] = v29;
                      _os_log_error_impl(&dword_228C70000, v23, OS_LOG_TYPE_ERROR, "Sync object without snapshot while gathering orphans (id: %llu, type: %llu[%s]).", v43, 0x20u);
                    }
                  }
                  else
                  {
                    *((unsigned char *)*v13 + 128) |= 4u;
                    uint64_t v21 = *v13;
                    *(void *)BOOL v43 = v21;
                    if (v21) {
                      uint64_t v22 = (char *)v21 + 8;
                    }
                    *(void *)&v43[8] = v20;
                    v43[16] = 2;
                    re::DynamicArray<re::internal::SyncSnapshotEntry>::add(a2, (uint64_t)v43);
                    if (*(void *)v43) {
                  }
                    }
                  if (v20 != -1) {
                    ++v9;
                  }
                }
                ++v13;
              }
              while (v13 != v14);
            }
          }
          ++v10;
        }
        while (v10 != v42);
      }
      id v30 = *(re **)buf;
      if (*(void *)buf && (void)v45) {
        id v30 = (re *)(*(uint64_t (**)(void))(**(void **)buf + 40))();
      }
      uint64_t v31 = *(void *)(v41 + 528);
      if (v31)
      {
        a2 = *(NSObject **)(v41 + 544);
        uint64_t v32 = 24 * v31;
        do
        {
          if ((*((unsigned char *)a2->isa + 128) & 4) != 0) {
            re::SyncObjectManager::destroyObject((uint64_t)a2);
          }
          a2 += 3;
          v32 -= 24;
        }
        while (v32);
      }
      if (v9)
      {
        a2 = *re::networkLogObjects(v30);
        if (os_log_type_enabled(a2, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v33 = re::Session::peerID(*(re::Session **)(v41 + 408));
          *(_DWORD *)buf = 134218240;
          *(void *)&uint8_t buf[4] = v9;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v33;
          _os_log_impl(&dword_228C70000, a2, OS_LOG_TYPE_DEFAULT, "Found %zu orphaned objects. localPeerID=%llu. ", buf, 0x16u);
        }
      }
      uint64_t v34 = *(re::SyncViewManager **)(v41 + 424);
      if (v34)
      {
        a2 = *(NSObject **)(v41 + 472);
        if ((unint64_t)a2 <= v7) {
          goto LABEL_55;
        }
        uint64_t v34 = (re::SyncViewManager *)re::SyncViewManager::removeViewer(v34, *(re::SyncViewer **)(*(void *)(v41 + 488) + 8 * v7), 0);
      }
      unint64_t v35 = *(void *)(v41 + 472);
      if (v35 > v7)
      {
        if (v35 - 1 > v7)
        {
          uint64_t v36 = *(void *)(v41 + 488);
          uint64_t v37 = v36 + 8 * v35;
          uint64_t v38 = *(void *)(v37 - 8);
          *(void *)(v37 - 8) = 0;
          unint64_t v39 = *(void (****)(void))(v36 + 8 * v7);
          *(void *)(v36 + 8 * v7) = v38;
          if (v39)
          {
            uint64_t v40 = re::globalAllocators(v34)[2];
            (**v39)(v39);
            (*(void (**)(uint64_t, void (***)(void)))(*(void *)v40 + 40))(v40, v39);
            unint64_t v35 = *(void *)(v41 + 472);
          }
        }
        std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::~unique_ptr[abi:nn180100]((re *)(*(void *)(v41 + 488) + 8 * v35 - 8));
        --*(void *)(v41 + 472);
        ++*(_DWORD *)(v41 + 480);
        return;
      }
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)BOOL v43 = 136315906;
      *(void *)&v43[4] = "removeAt";
      *(_WORD *)&v43[12] = 1024;
      *(_DWORD *)&v43[14] = 931;
      *(_WORD *)&v43[18] = 2048;
      *(void *)&v43[20] = v7;
      *(_WORD *)&v43[28] = 2048;
      *(void *)&v43[30] = v35;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_55:
      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)BOOL v43 = 136315906;
      *(void *)&v43[4] = "operator[]";
      *(_WORD *)&v43[12] = 1024;
      *(_DWORD *)&v43[14] = 789;
      *(_WORD *)&v43[18] = 2048;
      *(void *)&v43[20] = v7;
      *(_WORD *)&v43[28] = 2048;
      *(void *)&v43[30] = a2;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
}

uint64_t re::SharedAppSyncManager::onViewAdded(re::SharedAppSyncManager *this, re::SyncViewManager *a2, re::SyncView *a3)
{
  v8[5] = *MEMORY[0x263EF8340];
  uint64_t v6 = re::globalAllocators(this)[2];
  void v8[2] = a3;
  v8[3] = v6;
  v8[0] = &unk_26DD34F78;
  v8[1] = this;
  unsigned char v8[4] = v8;
  re::SyncViewManager::forEachViewer((uint64_t)a2, (uint64_t)v8);
  re::FunctionBase<24ul,void ()(re::SyncViewer *)>::destroyCallable((uint64_t)v8);
  return 0;
}

uint64_t re::SharedAppSyncManager::findPeer(re::SharedAppSyncManager *this, uint64_t a2)
{
  unint64_t v2 = *((void *)this + 59);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t v4 = *((void *)this + 61);
  while (*(void *)(*(void *)(v4 + 8 * v3) + 56) != a2)
  {
    if (v2 == ++v3) {
      return 0;
    }
  }
  if ((v3 & 0x80000000) != 0) {
    return 0;
  }
  if (v2 <= v3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(v4 + 8 * v3);
}

uint64_t re::SharedAppSyncManager::receive(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 472);
  if (!v2) {
    return 1;
  }
  uint64_t v4 = *(uint64_t **)(a1 + 488);
  uint64_t v5 = &v4[v2];
  do
  {
    uint64_t v6 = *v4;
    uint64_t v7 = *(void *)(*v4 + 128);
    BOOL v8 = v7 != 0;
    if (!v7) {
      break;
    }
    if (*(unsigned char *)(v6 + 163))
    {
      uint64_t v9 = *(void *)(v6 + 112);
      *(unsigned char *)(v6 + 163) = 0;
      while (1)
      {
        uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(v6 + 128) + 56))(*(void *)(v6 + 128));
        if (!v10) {
          break;
        }
        uint64_t v11 = v10;
        char v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(a2 + 16))(a2, v9, *(void *)(v10 + 16), *(unsigned int *)(v10 + 24));
        (*(void (**)(void, uint64_t))(**(void **)(v6 + 128) + 40))(*(void *)(v6 + 128), v11);
        if ((v12 & 1) == 0) {
          return 0;
        }
      }
    }
    ++v4;
  }
  while (v4 != v5);
  return v8;
}

void re::SharedAppSyncManager::receive(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v19, 6008, (uint64_t)a1);
  *(void *)a3 = a1;
  uint64_t v6 = a1[59];
  if (v6)
  {
    uint64_t v7 = (uint64_t *)a1[61];
    uint64_t v8 = MEMORY[0x263EF8330];
    uint64_t v9 = 8 * v6;
    while (1)
    {
      uint64_t v10 = *v7;
      uint64_t v11 = *(void *)(*v7 + 112);
      *(void *)(a3 + 8) = *(void *)(v11 + 24);
      *(_DWORD *)(a3 + 24) = *(_DWORD *)(v11 + 72);
      v18[0] = v8;
      v18[1] = 0x40000000;
      _OWORD v18[2] = ___ZN2re20SharedAppSyncManager7receiveEU13block_pointerFbP13RESyncSessionPK12RESyncCommitERNS_21SyncObjectReadContextE_block_invoke;
      v18[3] = &unk_264854778;
      v18[4] = a2;
      v18[5] = a1;
      BOOL v12 = re::SharedAppUnicast::receive((id *)(v10 + 120), a3, (uint64_t)v18);
      if (!v12) {
        break;
      }
      ++v7;
      v9 -= 8;
      if (!v9) {
        goto LABEL_8;
      }
    }
    id v13 = *re::networkLogObjects((re *)v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      if (*(unsigned char *)(v11 + 48)) {
        uint64_t v14 = *(void *)(v11 + 56);
      }
      else {
        uint64_t v14 = v11 + 49;
      }
      uint64_t v15 = *(void *)(v11 + 24);
      uint64_t v16 = *(void *)(v11 + 152);
      if (v16) {
        uint64_t v17 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v16 + 32))(v16);
      }
      else {
        uint64_t v17 = "nullptr";
      }
      *(_DWORD *)buf = 134218498;
      *(void *)uint64_t v21 = v15;
      *(_WORD *)&v21[8] = 2082;
      *(void *)&v21[10] = v14;
      *(_WORD *)&v21[18] = 2082;
      *(void *)&v21[20] = v17;
      _os_log_error_impl(&dword_228C70000, v13, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s, identity=%{public}s)", buf, 0x20u);
    }
    re::Transport::disconnect((re::Transport *)(a1[51] + 2320), *(void *)(v11 + 32), 0);
  }
LABEL_8:
  if (a1[66])
  {
    buf[0] = 0;
    uint64_t v24 = 0;
    memset(v22, 0, sizeof(v22));
    int v23 = 0;
    *(void *)&v21[4] = 0;
    *(void *)&v21[12] = 0;
    *(void *)&v21[17] = 0;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v22, a1 + 64);
    (*(void (**)(uint64_t, void *, uint8_t *))(a2 + 16))(a2, a1, buf);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::clear((uint64_t)(a1 + 64));
    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v22);
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v19);
}

uint64_t ___ZN2re20SharedAppSyncManager7receiveEU13block_pointerFbP13RESyncSessionPK12RESyncCommitERNS_21SyncObjectReadContextE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  if (v3)
  {
    uint64_t v4 = *(void *)(a2 + 64);
    uint64_t v5 = 24 * v3;
    do
    {
      if ((*(unsigned char *)(*(void *)v4 + 128) & 4) != 0) {
        re::SyncObjectManager::destroyObject(v4);
      }
      v4 += 24;
      v5 -= 24;
    }
    while (v5);
  }
  uint64_t v6 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  return v6();
}

void re::SharedAppSyncManager::send(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a4 + 8) = a1;
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v75, 6018, a1);
  uint64_t v7 = a2 + 72 * a3;
  uint64_t v73 = a3;
  if (a3)
  {
    uint64_t v8 = a2;
    do
    {
      uint64_t v9 = *(void *)(v8 + 48);
      if (v9)
      {
        uint64_t v10 = *(uint64_t **)(v8 + 64);
        uint64_t v11 = &v10[3 * v9];
        do
        {
          uint64_t v12 = *v10;
          uint64_t v13 = *(void *)(*v10 + 80);
          uint64_t v14 = *v10;
          if (v13)
          {
            uint64_t v15 = *v10;
            do
            {
              uint64_t v14 = v15;
              uint64_t v15 = v13;
              if (*(unsigned char *)(*(void *)(*(void *)(v14 + 88) + 16) + 73)) {
                break;
              }
              uint64_t v13 = *(void *)(v13 + 80);
              uint64_t v14 = v15;
            }
            while (v13);
          }
          if ((*(unsigned char *)(v14 + 170) || *(unsigned char *)(a1 + 400)) && (*(unsigned char *)(v12 + 128) & 4) != 0)
          {
            if (*(unsigned char *)(*(void *)(*(void *)(v12 + 88) + 16) + 74))
            {
              uint64_t v18 = *(void *)(v12 + 96);
              uint64_t v17 = v12 + 96;
              uint64_t v16 = v18;
              if (v18) {
                re::SyncView::removeObject(v16, v17);
              }
            }
          }
          v10 += 3;
        }
        while (v10 != v11);
      }
      v8 += 72;
    }
    while (v8 != v7);
  }
  uint64_t v19 = *(void *)(a1 + 472);
  if (v19)
  {
    unint64_t v20 = *(uint64_t **)(a1 + 488);
    uint64_t v21 = &v20[v19];
    do
    {
      long long v80 = 0;
      uint64_t v77 = 0;
      uint64_t v78 = 0;
      uint64_t v76 = 0;
      int v79 = 0;
      uint64_t v22 = *v20;
      uint64_t v23 = *(unsigned int *)(*v20 + 96);
      if (v23)
      {
        uint64_t v24 = 0;
        uint64_t v25 = (int *)(*(void *)(v22 + 80) + 8);
        while (1)
        {
          int v26 = *v25;
          v25 += 8;
          if (v26 < 0) {
            break;
          }
          if (v23 == ++v24)
          {
            LODWORD(v24) = *(_DWORD *)(*v20 + 96);
            break;
          }
        }
      }
      else
      {
        LODWORD(v24) = 0;
      }
      if (v23 != v24)
      {
        uint64_t v27 = v24;
        do
        {
          uint64_t v28 = *(void *)(v22 + 80) + 32 * v27;
          uint64_t v29 = (re::SyncObject **)(v28 + 16);
          int v30 = *(_DWORD *)(v28 + 24);
          if (re::SharedAppUnicast::shouldForward(*v20 + 120, (uint64_t *)(v28 + 16)))
          {
            if (v30)
            {
              v74[0] = *v29;
              re::DynamicArray<re::Allocator const*>::add(&v76, v74);
            }
            else
            {
              addToViewRecursive(v29, *v20 + 224, *(void *)(*v20 + 56));
            }
          }
          if (*(_DWORD *)(v22 + 96) <= (v24 + 1)) {
            int v31 = v24 + 1;
          }
          else {
            int v31 = *(_DWORD *)(v22 + 96);
          }
          while (1)
          {
            uint64_t v27 = (v24 + 1);
            if (v31 - 1 == v24) {
              break;
            }
            LODWORD(v24) = v24 + 1;
            int v32 = v27;
            if ((*(_DWORD *)(*(void *)(v22 + 80) + 32 * v27 + 8) & 0x80000000) != 0) {
              goto LABEL_38;
            }
          }
          int v32 = v31;
LABEL_38:
          LODWORD(v24) = v32;
        }
        while (v23 != v32);
        if (v78)
        {
          uint64_t v33 = v80;
          uint64_t v34 = 8 * v78;
          do
          {
            uint64_t v35 = *v33;
            v74[0] = (re::SyncObject *)v35;
            if (v35) {
              id v36 = (id)(v35 + 8);
            }
            removeFromViewRecursive(v74, *v20 + 224, *(void *)(*v20 + 56));
            if (v74[0]) {

            }
            ++v33;
            v34 -= 8;
          }
          while (v34);
        }
      }
      if (v76 && v80) {
        (*(void (**)(void))(*(void *)v76 + 40))();
      }
      ++v20;
    }
    while (v20 != v21);
  }
  long long v80 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v76 = 0;
  int v79 = 0;
  if (v73)
  {
    uint64_t v37 = a2;
    do
    {
      if (*(unsigned char *)(v37 + 28))
      {
        uint64_t v38 = *(void *)(v37 + 48);
        if (v38)
        {
          unint64_t v39 = *(uint64_t **)(v37 + 64);
          uint64_t v40 = &v39[3 * v38];
          do
          {
            uint64_t v41 = (void *)*v39;
            if (*v39)
            {
              while (!*(unsigned char *)(*(void *)(v41[11] + 16) + 74))
              {
                uint64_t v41 = (void *)v41[10];
                if (!v41) {
                  goto LABEL_71;
                }
              }
              uint64_t v42 = v41[12];
              if (v42)
              {
                uint64_t v43 = *(void *)(v42 + 104);
                if (v43)
                {
                  __int16 v44 = *(re::SyncObjectViewer ***)(v42 + 120);
                  uint64_t v45 = 8 * v43;
                  do
                  {
                    long long v46 = *v44;
                    if (*((void *)*v44 + 6) == a1)
                    {
                      BOOL v47 = *(unsigned char *)(v37 + 28) && *(void *)(v37 + 8) == *((void *)v46 + 7);
                      if (!v47
                        && re::SharedAppUnicast::shouldForward((uint64_t)v46 + 120, v39)
                        && entryIsAddable((re::SyncObject **)v39, v46))
                      {
                        re::DynamicArray<re::internal::SyncSnapshotEntry>::add((void *)v46 + 32, v39);
                      }
                    }
                    ++v44;
                    v45 -= 8;
                  }
                  while (v45);
                }
              }
            }
LABEL_71:
            v39 += 3;
          }
          while (v39 != v40);
        }
      }
      else
      {
        v74[0] = (re::SyncObject *)v37;
        re::DynamicArray<re::Allocator const*>::add(&v76, v74);
      }
      v37 += 72;
    }
    while (v37 != v7);
    if (v78)
    {
      uint64_t v48 = v80;
      unint64_t v49 = &v80[v78];
      do
      {
        uint64_t v50 = *(void *)(*v48 + 48);
        if (v50)
        {
          uint64_t v51 = *(uint64_t **)(*v48 + 64);
          int v52 = &v51[3 * v50];
          do
          {
            char v53 = (void *)*v51;
            if (*v51)
            {
              while (!*(unsigned char *)(*(void *)(v53[11] + 16) + 74))
              {
                char v53 = (void *)v53[10];
                if (!v53) {
                  goto LABEL_91;
                }
              }
              uint64_t v54 = v53[12];
              if (v54)
              {
                uint64_t v55 = *(void *)(v54 + 104);
                if (v55)
                {
                  uint64_t v56 = *(re::SyncObjectViewer ***)(v54 + 120);
                  uint64_t v57 = 8 * v55;
                  do
                  {
                    uint64_t v58 = *v56;
                    if (*((void *)*v56 + 6) == a1
                      && re::SharedAppUnicast::shouldForward((uint64_t)v58 + 120, v51)
                      && entryIsAddable((re::SyncObject **)v51, v58))
                    {
                      re::DynamicArray<re::internal::SyncSnapshotEntry>::add((void *)v58 + 32, v51);
                    }
                    ++v56;
                    v57 -= 8;
                  }
                  while (v57);
                }
              }
            }
LABEL_91:
            v51 += 3;
          }
          while (v51 != v52);
        }
        ++v48;
      }
      while (v48 != v49);
    }
    if (v76 && v80) {
      (*(void (**)(void))(*(void *)v76 + 40))();
    }
  }
  uint64_t v59 = *(void *)(a1 + 472);
  if (v59)
  {
    uint64_t v60 = *(uint64_t **)(a1 + 488);
    uint64_t v61 = 8 * v59;
    do
    {
      uint64_t v62 = *v60;
      uint64_t v63 = *(void *)(*v60 + 112);
      uint64_t v64 = *(void *)(v63 + 152);
      if (v64 && (int v65 = (*(uint64_t (**)(uint64_t))(*(void *)v64 + 48))(v64), v62 = *v60, v65))
      {
        re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(v62 + 256);
      }
      else
      {
        if (*(void *)(v62 + 272))
        {
          *(void *)(a4 + 16) = *(void *)(v63 + 24);
          *(_DWORD *)(a4 + 32) = *(_DWORD *)(v63 + 72);
          uint64_t v76 = v62 + 224;
          uint64_t v77 = 1;
          v74[0] = 0;
          v74[1] = 0;
          re::SharedAppUnicast::send((id *)(v62 + 120), (uint64_t)&v76, (uint64_t)v74, v62, a4);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(*v60 + 256);
          uint64_t v62 = *v60;
        }
        re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear(v62 + 64);
      }
      ++v60;
      v61 -= 8;
    }
    while (v61);
  }
  if (v73)
  {
    do
    {
      uint64_t v66 = *(void *)(a2 + 48);
      if (v66)
      {
        uint64_t v67 = *(void *)(a2 + 64);
        uint64_t v68 = v67 + 24 * v66;
        do
        {
          uint64_t v69 = *(void *)(*(void *)v67 + 80);
          uint64_t v70 = *(void *)v67;
          if (v69)
          {
            uint64_t v71 = *(void *)v67;
            do
            {
              uint64_t v70 = v71;
              uint64_t v71 = v69;
              if (*(unsigned char *)(*(void *)(*(void *)(v70 + 88) + 16) + 73)) {
                break;
              }
              uint64_t v69 = *(void *)(v69 + 80);
              uint64_t v70 = v71;
            }
            while (v69);
          }
          if ((*(unsigned char *)(v70 + 170) || *(unsigned char *)(a1 + 400)) && (*(unsigned char *)(*(void *)v67 + 128) & 4) != 0) {
            re::SyncObjectManager::destroyObject(v67);
          }
          v67 += 24;
        }
        while (v67 != v68);
      }
      a2 += 72;
    }
    while (a2 != v7);
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v75);
}

BOOL re::SharedAppSyncManager::send(re::SharedAppSyncManager *a1, uint64_t a2, const void *a3, size_t a4)
{
  uint64_t Peer = re::SharedAppSyncManager::findPeer(a1, a2);
  uint64_t v7 = Peer;
  if (Peer)
  {
    if (a4)
    {
      uint64_t v8 = (*(uint64_t (**)(void, size_t))(**(void **)(Peer + 128) + 32))(*(void *)(Peer + 128), a4);
      if (v8)
      {
        uint64_t v9 = v8;
        memcpy(*(void **)(v8 + 16), a3, a4);
        *(_DWORD *)(v9 + 24) = a4;
        (*(void (**)(void, uint64_t))(**(void **)(v7 + 128) + 48))(*(void *)(v7 + 128), v9);
      }
    }
  }
  return v7 != 0;
}

void removeFromViewRecursive(re::SyncObject **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v4 = *a1;
  if (*((void *)v4 + 8) == *((void *)v4 + 9))
  {
    uint64_t v5 = *re::networkLogObjects(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *((void *)*a1 + 3);
      uint64_t v7 = *(void **)(*((void *)*a1 + 11) + 16);
      uint64_t v8 = v7[4];
      uint64_t v9 = v7[6];
      uint64_t v10 = (char *)v7[7];
      uint64_t v11 = (char *)v7 + 49;
      if (v9) {
        uint64_t v11 = v10;
      }
      *(_DWORD *)unint64_t v20 = 134218498;
      *(void *)&v20[4] = v6;
      __int16 v21 = 2048;
      uint64_t v22 = v8;
      __int16 v23 = 2080;
      uint64_t v24 = v11;
      _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "Sync object without snapshot while removing view (id: %llu, type: %llu[%s]).", v20, 0x20u);
    }
  }
  else
  {
    if ((*((unsigned char *)v4 + 128) & 4) == 0
      || (unint64_t LatestState = re::SyncObject::getLatestState(v4)) == 0
      || *(void *)(LatestState + 88) != a3)
    {
      re::SyncSnapshot::removeFromView((void *)(a2 + 32), a1);
    }
    uint64_t v15 = *((void *)*a1 + 25);
    if (v15)
    {
      uint64_t v16 = (uint64_t *)*((void *)*a1 + 27);
      uint64_t v17 = 8 * v15;
      do
      {
        uint64_t v18 = *v16;
        *(void *)unint64_t v20 = v18;
        if (v18) {
          id v19 = (id)(v18 + 8);
        }
        removeFromViewRecursive(v20, a2, a3);
        if (*(void *)v20) {

        }
        ++v16;
        v17 -= 8;
      }
      while (v17);
    }
  }
}

re::SyncObject *entryIsAddable(re::SyncObject **a1, re::SyncObjectViewer *a2)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t v4 = result;
    while (!*(unsigned char *)(*(void *)(*((void *)v4 + 11) + 16) + 74))
    {
      uint64_t v4 = (re::SyncObject *)*((void *)v4 + 10);
      if (!v4) {
        return 0;
      }
    }
    uint64_t v5 = *((void *)v4 + 12);
    if (!v5) {
      return 0;
    }
    uint64_t v6 = *(re::SyncObjectViewer ***)(v5 + 120);
    uint64_t v7 = *(void *)(v5 + 104);
    if (v7)
    {
      uint64_t v8 = 8 * v7;
      uint64_t v9 = v6;
      while (*v9 != a2)
      {
        ++v9;
        v8 -= 8;
        if (!v8)
        {
          uint64_t v9 = &v6[v7];
          break;
        }
      }
    }
    else
    {
      uint64_t v9 = v6;
    }
    if (v7 == v9 - v6) {
      return 0;
    }
    uint64_t v10 = *((void *)a2 + 7);
    unint64_t LatestState = re::SyncObject::getLatestState(result);
    if (LatestState)
    {
      if (*(void *)(LatestState + 88) == v10) {
        return 0;
      }
    }
    return (re::SyncObject *)!re::SyncObjectViewer::isViewChangePending(a2, v4);
  }
  return result;
}

void *re::DynamicArray<re::internal::SyncSnapshotEntry>::add(void *this, uint64_t *a2)
{
  uint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::internal::SyncSnapshotEntry>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  uint64_t v5 = v3[4];
  uint64_t v6 = *a2;
  *(void *)(v5 + 24 * v4) = *a2;
  if (v6) {
    this = (id)(v6 + 8);
  }
  uint64_t v7 = v5 + 24 * v4;
  uint64_t v8 = a2[1];
  *(unsigned char *)(v7 + 16) = *((unsigned char *)a2 + 16);
  *(void *)(v7 + 8) = v8;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

void *re::SharedAppSyncManager::session@<X0>(void *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = this[51];
  *a2 = v2;
  if (v2) {
    return (id)(v2 + 8);
  }
  return this;
}

void re::SharedAppSyncManager::requestOwnership(re *a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v3 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    uint64_t v4 = *(void *)(*(void *)a2 + 24);
    int v5 = 134217984;
    uint64_t v6 = v4;
    _os_log_error_impl(&dword_228C70000, v3, OS_LOG_TYPE_ERROR, "[Ownership] Requesting ownership when using Shared App Sync (guid: %llu)", (uint8_t *)&v5, 0xCu);
  }
}

double re::SharedAppSyncManager::adjustTimeForSender(re::SharedAppSyncManager *this, double a2, uint64_t a3)
{
  uint64_t Peer = re::SharedAppSyncManager::findPeer(this, a3);
  if (Peer)
  {
    uint64_t v6 = *(void *)(Peer + 112);
    if (v6)
    {
      re::Transport::connectionStats((re::Transport *)(*((void *)this + 51) + 2320), *(void *)(v6 + 32), (uint64_t)v9);
      if (v9[0])
      {
        LODWORD(v7) = v10;
        return a2 + (double)v7 / 1000.0 * 0.5;
      }
    }
  }
  return a2;
}

uint64_t re::SharedAppSyncManager::pausePeer(re::SharedAppSyncManager *this, uint64_t a2)
{
  uint64_t result = re::SharedAppSyncManager::findPeer(this, a2);
  if (result)
  {
    if (*(void *)(result + 112)) {
      *(unsigned char *)(result + 162) = 1;
    }
  }
  return result;
}

uint64_t re::SharedAppSyncManager::resumePeer(re::SharedAppSyncManager *this, uint64_t a2)
{
  uint64_t result = re::SharedAppSyncManager::findPeer(this, a2);
  if (result)
  {
    if (*(void *)(result + 112)) {
      *(unsigned char *)(result + 162) = 0;
    }
  }
  return result;
}

void re::SharedAppSyncManager::PeerState::~PeerState(re::SharedAppSyncManager::PeerState *this)
{
  *(void *)this = &unk_26DD34E20;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 256);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 21);
  objc_destroyWeak((id *)this + 19);
  *((void *)this + 19) = 0;
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {

    *((void *)this + 16) = 0;
  }
  objc_destroyWeak((id *)this + 15);
  *((void *)this + 15) = 0;
  uint64_t v3 = *((void *)this + 14);
  if (v3)
  {

    *((void *)this + 14) = 0;
  }
  *(void *)this = &unk_26DD36158;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 8);
  re::SyncViewer::~SyncViewer((re::SyncView ***)this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26DD34E20;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 256);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 21);
  objc_destroyWeak((id *)this + 19);
  *((void *)this + 19) = 0;
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {

    *((void *)this + 16) = 0;
  }
  objc_destroyWeak((id *)this + 15);
  *((void *)this + 15) = 0;
  uint64_t v3 = *((void *)this + 14);
  if (v3)
  {

    *((void *)this + 14) = 0;
  }
  *(void *)this = &unk_26DD36158;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 8);
  re::SyncViewer::~SyncViewer((re::SyncView ***)this);
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::~Callable()
{
}

void re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = v2[59];
  if (v3)
  {
    uint64_t v4 = *a2;
    int v5 = (re::SyncViewer **)v2[61];
    uint64_t v6 = &v5[v3];
    do
    {
      unint64_t v7 = *v5;
      if (*((void *)*v5 + 7) == *(void *)(v4 + 24))
      {
        uint64_t v8 = *(void *)(v4 + 120);
        uint64_t v9 = *(void *)(v4 + 104);
        if (v9)
        {
          uint64_t v10 = 8 * v9;
          uint64_t v11 = *(re::SyncViewer ***)(v4 + 120);
          while (*v11 != v7)
          {
            ++v11;
            v10 -= 8;
            if (!v10)
            {
              uint64_t v11 = (re::SyncViewer **)(v8 + 8 * v9);
              break;
            }
          }
        }
        else
        {
          uint64_t v11 = *(re::SyncViewer ***)(v4 + 120);
        }
        if (v9 != ((uint64_t)v11 - v8) >> 3) {
          goto LABEL_30;
        }
      }
      else
      {
        uint64_t v12 = v2[63];
        if (!v12)
        {
          uint64_t v18 = *(void *)(v4 + 120);
          uint64_t v19 = *(void *)(v4 + 104);
          if (v19)
          {
            uint64_t v20 = 8 * v19;
            __int16 v21 = *(re::SyncViewer ***)(v4 + 120);
            while (*v21 != v7)
            {
              ++v21;
              v20 -= 8;
              if (!v20)
              {
                __int16 v21 = (re::SyncViewer **)(v18 + 8 * v19);
                break;
              }
            }
          }
          else
          {
            __int16 v21 = *(re::SyncViewer ***)(v4 + 120);
          }
          if (v19 == ((uint64_t)v21 - v18) >> 3) {
            goto LABEL_30;
          }
LABEL_29:
          re::SyncView::removeViewer(v4, v7);
          goto LABEL_30;
        }
        int v13 = (*(uint64_t (**)(uint64_t, void *))(v12 + 16))(v12, v2);
        unint64_t v7 = *v5;
        uint64_t v14 = *(void *)(v4 + 120);
        uint64_t v15 = *(void *)(v4 + 104);
        if (v15)
        {
          uint64_t v16 = 8 * v15;
          uint64_t v17 = *(re::SyncViewer ***)(v4 + 120);
          while (*v17 != v7)
          {
            ++v17;
            v16 -= 8;
            if (!v16)
            {
              uint64_t v17 = (re::SyncViewer **)(v14 + 8 * v15);
              break;
            }
          }
        }
        else
        {
          uint64_t v17 = *(re::SyncViewer ***)(v4 + 120);
        }
        if (v13 == (v15 != ((uint64_t)v17 - v14) >> 3)) {
          goto LABEL_30;
        }
        if (!v13) {
          goto LABEL_29;
        }
      }
      re::SyncView::addViewer((re::SyncViewer ***)v4, v7);
LABEL_30:
      ++v5;
    }
    while (v5 != v6);
  }
}

void *re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD34F20;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD34F20;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::reevaluateAllViewers(void)::$_0,void ()(re::SyncView *)>::size()
{
  return 16;
}

void re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::~Callable()
{
}

void re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::operator()(uint64_t a1, re::SyncViewer **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(re::SharedAppSyncManager **)(a1 + 8);
  if (re::SharedAppSyncManager::findPeer(v4, *((void *)*a2 + 7)))
  {
    uint64_t v5 = *((void *)v3 + 7);
    uint64_t v6 = *(void *)(a1 + 16);
    if (v5 != *(void *)(v6 + 24) && v5 != *(void *)(v6 + 32))
    {
      uint64_t v7 = *((void *)v4 + 63);
      if (!v7 || !(*(unsigned int (**)(uint64_t, re::SharedAppSyncManager *))(v7 + 16))(v7, v4)) {
        return;
      }
      uint64_t v6 = *(void *)(a1 + 16);
    }
    re::SyncView::addViewer((re::SyncViewer ***)v6, v3);
  }
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD34F78;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD34F78;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::onViewAdded(re::SyncViewManager *,re::SyncView *)::$_0,void ()(re::SyncViewer *)>::size()
{
  return 24;
}

void re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::~Callable()
{
}

void re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = **(re::SyncViewer ***)(a1 + 16);
  if (*((void *)v3 + 7) != *(void *)(v2 + 24))
  {
    if (!(*(unsigned int (**)(void))(*(void *)(*(void *)(a1 + 8) + 504) + 16))()) {
      return;
    }
    uint64_t v3 = **(re::SyncViewer ***)(a1 + 16);
  }
  re::SyncView::addViewer((re::SyncViewer ***)v2, v3);
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD34FD0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD34FD0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::SharedAppSyncManager::addPeerStateForParticipant(re::SharedPtr<re::SessionParticipant>)::$_0,void ()(re::SyncView *)>::size()
{
  return 24;
}

BOOL re::SyncObjectViewer::isViewChangePending(re::SyncObjectViewer *this, re::SyncObject *a2)
{
  uint64_t v2 = (char *)this + 64;
  uint64_t v6 = a2;
  if (a2) {
    uint64_t v3 = (char *)a2 + 8;
  }
  BOOL v4 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::containsKey((uint64_t)v2, (uint64_t *)&v6);
  if (v6) {

  }
  return v4;
}

BOOL re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::containsKey(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(v6 + 32 * v4 + 16) == v2) {
    return 1;
  }
  do
  {
    uint64_t v4 = *(_DWORD *)(v6 + 32 * v4 + 8) & 0x7FFFFFFF;
    BOOL result = v4 != 0x7FFFFFFF;
  }
  while (v4 != 0x7FFFFFFF && *(void *)(v6 + 32 * v4 + 16) != v2);
  return result;
}

uint64_t re::Event<re::Session>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke(uint64_t a1, void *a2)
{
  unint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    unint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

uint64_t re::Event<re::Session,re::SessionError>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke(uint64_t a1, void *a2, unsigned int *a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = (uint64_t (*)(void *, uint64_t, uint64_t *))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t *))(*v6 + v5);
  }
  uint64_t v7 = *a3;
  uint64_t v11 = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  uint64_t v9 = v5(v6, a1, &v11);
  if (v11) {

  }
  return v9;
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v7 = (uint64_t (*)(void *, uint64_t, uint64_t *, void))a2[1];
  uint64_t v6 = a2[2];
  id v8 = (void *)(*a2 + (v6 >> 1));
  if (v6) {
    uint64_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t *, void))(*v8 + v7);
  }
  uint64_t v9 = *a3;
  uint64_t v13 = v9;
  if (v9) {
    id v10 = (id)(v9 + 8);
  }
  uint64_t v11 = v7(v8, a1, &v13, *a4);
  if (v13) {

  }
  return v11;
}

uint64_t re::Event<re::Session,unsigned long long>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::PacketStatsFilter*,re::CongestionEventData const&))::{lambda(re::PacketStatsFilter*,re::Event<re::PacketStatsFilter,re::CongestionEventData const&>::Subscription const&,re::CongestionEventData const&)#1}::__invoke(uint64_t a1, void *a2)
{
  unint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    unint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

uint64_t re::Event<re::SyncViewManager,re::SyncView *>::createSubscription<re::SharedAppSyncManager>(re::SharedAppSyncManager *,REEventHandlerResult (re::SharedAppSyncManager::*)(re::SyncViewManager*,re::SyncView *))::{lambda(re::SyncViewManager*,re::Event<re::SyncViewManager,re::SyncView *>::Subscription const&,re::SyncView *&&)#1}::__invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

re *std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::~unique_ptr[abi:nn180100](re *a1)
{
  uint64_t v2 = *(void (****)(void))a1;
  *(void *)a1 = 0;
  if (v2)
  {
    uint64_t v3 = re::globalAllocators(a1)[2];
    (**v2)(v2);
    (*(void (**)(uint64_t, void (***)(void)))(*(void *)v3 + 40))(v3, v2);
  }
  return a1;
}

void *re::DynamicArray<std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      BOOL result = (void *)*result;
      if (!*v5)
      {
        BOOL result = (void *)re::DynamicArray<std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 8 * a2;
          BOOL result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        BOOL result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      id v8 = (re *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 8 * v9;
        uint64_t v11 = v7;
        uint64_t v12 = (re *)v5[4];
        do
        {
          uint64_t v13 = *(void *)v8;
          *(void *)uint64_t v12 = 0;
          uint64_t v12 = (re *)((char *)v12 + 8);
          *v11++ = v13;
          std::unique_ptr<re::SharedAppSyncManager::PeerState,re::SyncDeleter<re::SharedAppSyncManager::PeerState>>::~unique_ptr[abi:nn180100](v8);
          id v8 = v12;
          v10 -= 8;
        }
        while (v10);
        id v8 = (re *)v5[4];
      }
      BOOL result = (void *)(*(uint64_t (**)(void, re *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void addToViewRecursive(re::SyncObject **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*((void *)v4 + 8) != *((void *)v4 + 9))
  {
    unint64_t LatestState = re::SyncObject::getLatestState(v4);
    if ((!LatestState || *(void *)(LatestState + 88) != a3) && (*((unsigned char *)*a1 + 128) & 4) == 0) {
      re::SyncSnapshot::addToView((void *)(a2 + 32), a1);
    }
    uint64_t v8 = *((void *)*a1 + 25);
    if (v8)
    {
      uint64_t v9 = (uint64_t *)*((void *)*a1 + 27);
      uint64_t v10 = 8 * v8;
      do
      {
        uint64_t v11 = *v9;
        uint64_t v13 = v11;
        if (v11) {
          id v12 = (id)(v11 + 8);
        }
        addToViewRecursive(&v13, a2, a3);
        if (v13) {

        }
        ++v9;
        v10 -= 8;
      }
      while (v10);
    }
  }
}

void *re::DynamicArray<re::internal::SyncSnapshotEntry>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::internal::SyncSnapshotEntry>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

double RESyncDiscoveryViewObserverCreate(re *a1)
{
  int v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 80, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)uint64_t v2 = &unk_26DD35090;
  double result = 0.0;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(void *)(v2 + 72) = 0;
  return result;
}

void *RESyncDiscoveryViewObserverOnCreate(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 24) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnDestroy(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 32);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 32) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnGetIdentitiesCount(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 40) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnGetIdentityAtIndex(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 48) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnGetAuthData(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 56);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 56) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnRequestIdentity(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 64);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 64) = result;
  return result;
}

void *RESyncDiscoveryViewObserverOnCreateProtocolLayer(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 72);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 72) = result;
  return result;
}

double RESyncDiscoveryIdentityObserverCreate(re *a1)
{
  int v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 64, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)uint64_t v2 = &unk_26DD350D8;
  double result = 0.0;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(void *)(v2 + 56) = 0;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnCreate(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 24) = result;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnDestroy(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 32);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 32) = result;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnGetDisplayName(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 40) = result;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnGetAddress(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 48) = result;
  return result;
}

void *RESyncDiscoveryIdentityObserverOnIsLocal(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 56);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 56) = result;
  return result;
}

uint64_t RESyncDiscoveryViewCreateWithAddresses(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = (const char **)a1;
  v29[5] = *MEMORY[0x263EF8340];
  if (!a1 && a2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid addresses.", "addresses != nullptr || addressesCount == 0", "RESyncDiscoveryViewCreateWithAddresses", 359);
    _os_crash();
    __break(1u);
LABEL_30:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid protocol provided.", "protocolLayer != nullptr", "RESyncDiscoveryViewCreateWithAddresses", 360);
    _os_crash();
    __break(1u);
  }
  if (!a3) {
    goto LABEL_30;
  }
  uint64_t v28 = 0;
  unint64_t v25 = 0;
  unint64_t v26 = 0;
  uint64_t v24 = 0;
  int v27 = 0;
  if (a2)
  {
    do
    {
      BOOL v6 = *v5;
      if (*v5)
      {
        unint64_t v7 = re::DynamicString::DynamicString((re::DynamicString *)v23, (const re::DynamicString *)&v21);
        unint64_t v8 = v26;
        if (v26 >= v25)
        {
          unint64_t v9 = v26 + 1;
          if (v25 < v26 + 1)
          {
            if (v24)
            {
              if (v25) {
                unint64_t v10 = 2 * v25;
              }
              else {
                unint64_t v10 = 8;
              }
              if (v10 <= v9) {
                unint64_t v11 = v26 + 1;
              }
              else {
                unint64_t v11 = v10;
              }
              re::DynamicArray<re::Address>::setCapacity(&v24, v11);
            }
            else
            {
              re::DynamicArray<re::Address>::setCapacity(&v24, v9);
              ++v27;
            }
          }
          unint64_t v8 = v26;
        }
        re::DynamicString::DynamicString((_anonymous_namespace_ *)((char *)v28 + 32 * v8), (const re::DynamicString *)v23);
        ++v26;
        ++v27;
        if (*(void *)&v23[0])
        {
          if (BYTE8(v23[0])) {
            (*(void (**)(void))(**(void **)&v23[0] + 40))();
          }
          memset(v23, 0, sizeof(v23));
        }
        a1 = v21;
        if (v21 && (v22 & 1) != 0) {
          a1 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v21 + 40))();
        }
      }
      ++v5;
      --v4;
    }
    while (v4);
  }
  id v12 = (void *)(a3 + 8);
  id v13 = (id)(a3 + 8);
  uint64_t v14 = v28;
  uint64_t v15 = v26;
  uint64_t v16 = re::globalAllocators((re *)(id)(a3 + 8))[2];
  v29[0] = &unk_26DD35028;
  v29[1] = a3;
  v29[3] = v16;
  v29[4] = v29;
  re::DebugDiscoveryView::createWithAddresses(v14, v15, (uint64_t)v29, (uint64_t *)v23);
  re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::destroyCallable((uint64_t)v29);
  uint64_t v17 = *(void *)&v23[0];
  uint64_t v18 = (void *)(*(void *)&v23[0] + 8);
  id v19 = (id)(*(void *)&v23[0] + 8);
  if (v17) {

  }
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v24);
  return v17;
}

uint64_t RESyncDiscoveryViewAddAddress(_anonymous_namespace_ *a1, const char *a2)
{
  re::DynamicString::DynamicString((re::DynamicString *)v7, (const re::DynamicString *)&v5);
  re::DebugDiscoveryView::addIdentityWithAddress(a1, (const re::Address *)v7);
  if (*(void *)&v7[0])
  {
    if (BYTE8(v7[0])) {
      (*(void (**)(void))(**(void **)&v7[0] + 40))();
    }
    memset(v7, 0, sizeof(v7));
  }
  uint64_t result = v5;
  if (v5)
  {
    if (v6) {
      return (*(uint64_t (**)(void))(*(void *)v5 + 40))();
    }
  }
  return result;
}

uint64_t RESyncDiscoveryViewRemoveAddress(_anonymous_namespace_ *a1, const char *a2)
{
  re::DynamicString::DynamicString((re::DynamicString *)v7, (const re::DynamicString *)&v5);
  re::DebugDiscoveryView::removeIdentityWithAddress(a1, (const re::Address *)v7);
  if (*(void *)&v7[0])
  {
    if (BYTE8(v7[0])) {
      (*(void (**)(void))(**(void **)&v7[0] + 40))();
    }
    memset(v7, 0, sizeof(v7));
  }
  uint64_t result = v5;
  if (v5)
  {
    if (v6) {
      return (*(uint64_t (**)(void))(*(void *)v5 + 40))();
    }
  }
  return result;
}

uint64_t RESyncDiscoveryViewGetIdentitiesCount(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t RESyncDiscoveryViewGetIdentityAtIndex(uint64_t a1, unint64_t a2)
{
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1) <= a2) {
    return 0;
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, unint64_t))(*(void *)a1 + 56))(&v6, a1, a2);
  uint64_t v4 = v6;
  if (v6) {

  }
  return v4;
}

uint64_t RESyncDiscoveryViewGetIdentityWithAddress(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = 0;
    do
    {
      while (1)
      {
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 56))(&v17, a1, v6);
        if (v17) {
          break;
        }
LABEL_14:
        if (++v6 == v5) {
          return 0;
        }
      }
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v17 + 40))(&v14);
      uint64_t v7 = v15 & 1;
      if (v15) {
        unint64_t v8 = *(const char **)&v16[7];
      }
      else {
        unint64_t v8 = v16;
      }
      int v9 = strcmp(v8, a2);
      if (v14) {
        BOOL v10 = v7 == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      uint64_t v11 = v17;
      if (v17)
      {

        if (!v9) {
          return v11;
        }
        goto LABEL_14;
      }
      ++v6;
      if (v9) {
        BOOL v12 = v6 == v5;
      }
      else {
        BOOL v12 = 1;
      }
    }
    while (!v12);
  }
  return 0;
}

void RESyncDiscoveryViewNotifyJoin(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  if (a2) {
    id v5 = (id)(a2 + 8);
  }
  re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(v4, a1);
  if (a2) {
}
  }

void re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    re::Event<re::SyncViewManager,re::SyncView *>::doDeferredActions((_anonymous_namespace_ *)a1);
  }
}

void RESyncDiscoveryViewNotifyLeave(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (a2) {
    id v5 = (id)(a2 + 8);
  }
  re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(v4, a1);
  if (a2) {
}
  }

uint64_t RESyncDiscoveryViewCreateWithObserver(char *a1)
{
  int v1 = a1;
  if (a1) {
    a1 = a1 + 8;
  }
  uint64_t v2 = re::globalAllocators((re *)a1);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 208, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v3, 0);
  *(void *)(v3 + 24) = v1;
  *(void *)uint64_t v3 = &unk_26DD35120;
  uint64_t v4 = v1 + 8;
  id v5 = v4;
  uint64_t v6 = *(void *)(v3 + 24);
  *(void *)(v3 + 32) = 0;
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 56) = 0;
  *(void *)(v3 + 104) = 0;
  *(_DWORD *)(v3 + 112) = 0;
  *(_DWORD *)(v3 + 96) = 0;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(void *)(v3 + 120) = 0;
  *(void *)(v3 + 128) = 0;
  *(void *)(v3 + 136) = 0;
  *(_DWORD *)(v3 + 144) = 0;
  *(void *)(v3 + 192) = 0;
  *(_DWORD *)(v3 + 200) = 0;
  *(_DWORD *)(v3 + 184) = 0;
  *(_OWORD *)(v3 + 168) = 0u;
  *(_OWORD *)(v3 + 152) = 0u;
  uint64_t v7 = *(uint64_t (***)(void))(v6 + 24);
  if (v7) {
    uint64_t v7 = (uint64_t (**)(void))v7[2]();
  }
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(v3 + 32), 0);
  ++*(_DWORD *)(v3 + 56);
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(v3 + 120), 0);
  ++*(_DWORD *)(v3 + 144);

  id v9 = (id)(v3 + 8);
  return v3;
}

void *RESyncIdentityCreateWithObserver(char *a1)
{
  int v1 = a1;
  if (a1) {
    a1 = a1 + 8;
  }
  uint64_t v2 = re::globalAllocators((re *)a1);
  uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 32, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v3, 0);
  v3[3] = v1;
  *uint64_t v3 = &unk_26DD351A8;
  uint64_t v4 = v1 + 8;
  id v5 = v4;
  uint64_t v6 = *(void *)(v3[3] + 24);
  if (v6) {
    (*(void (**)(void))(v6 + 16))();
  }

  uint64_t v7 = v3 + 1;
  return v3;
}

uint64_t RESyncIdentityGetDisplayName(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 32))();
}

size_t RESyncIdentityGetAddress(uint64_t a1, char *a2, size_t a3)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 40))(&v11);
  char v5 = v12;
  if (v12) {
    uint64_t v6 = *(const char **)&v13[7];
  }
  else {
    uint64_t v6 = v13;
  }
  size_t v7 = strlen(v6);
  size_t v8 = v7;
  if (a2 && v7 < a3) {
    strcpy(a2, v6);
  }
  if (v11) {
    BOOL v9 = (v5 & 1) == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9) {
    (*(void (**)(void))(*(void *)v11 + 40))();
  }
  return v8;
}

uint64_t RESyncIdentityIsLocal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

void *re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD35028;
  uint64_t v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD35028;
  uint64_t v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void *re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::operator()@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[1];
  *a2 = v2;
  if (v2) {
    return (id)(v2 + 8);
  }
  return result;
}

void *re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_26DD35028;
  a2[1] = v3;
  if (v3) {
    id v4 = (id)(v3 + 8);
  }
  return a2;
}

void *re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD35028;
  a2[1] = v2;
  *(void *)(a1 + 8) = 0;
  return a2;
}

uint64_t re::internal::Callable<RESyncDiscoveryViewCreateWithAddresses::$_0,re::SharedPtr<re::ProtocolLayer> ()(void)>::size()
{
  return 16;
}

uint64_t (***re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void anonymous namespace'::DiscoveryViewObserver::~DiscoveryViewObserver(_anonymous_namespace_::DiscoveryViewObserver *this)
{
  *(void *)this = &unk_26DD35090;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 4);
  if (v3) {
    _Block_release(v3);
  }
  id v4 = (const void *)*((void *)this + 5);
  if (v4) {
    _Block_release(v4);
  }
  char v5 = (const void *)*((void *)this + 6);
  if (v5) {
    _Block_release(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 7);
  if (v6) {
    _Block_release(v6);
  }
  size_t v7 = (const void *)*((void *)this + 8);
  if (v7) {
    _Block_release(v7);
  }
  size_t v8 = (const void *)*((void *)this + 9);
  if (v8) {
    _Block_release(v8);
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  JUMPOUT(0x22A6A9430);
}

void anonymous namespace'::DiscoveryIdentityObserver::~DiscoveryIdentityObserver(_anonymous_namespace_::DiscoveryIdentityObserver *this)
{
  *(void *)this = &unk_26DD350D8;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 4);
  if (v3) {
    _Block_release(v3);
  }
  id v4 = (const void *)*((void *)this + 5);
  if (v4) {
    _Block_release(v4);
  }
  char v5 = (const void *)*((void *)this + 6);
  if (v5) {
    _Block_release(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 7);
  if (v6) {
    _Block_release(v6);
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  JUMPOUT(0x22A6A9430);
}

void *re::DynamicArray<re::Address>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    char v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::Address>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 32 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            size_t v7 = (re::DynamicString *)result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      size_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      size_t v8 = (const re::DynamicString *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 32 * v9;
        uint64_t v11 = v7;
        do
        {
          re::DynamicString::DynamicString(v11, v8);
          re::DynamicString::deinit(v8);
          size_t v8 = (const re::DynamicString *)((char *)v8 + 32);
          uint64_t v11 = (re::DynamicString *)((char *)v11 + 32);
          v10 -= 32;
        }
        while (v10);
        size_t v8 = (const re::DynamicString *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, const re::DynamicString *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void anonymous namespace'::DiscoveryViewProxy::~DiscoveryViewProxy(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 3) + 32);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  if (*((void *)this + 15)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 120);
  }
  if (*((void *)this + 4)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 32);
  }
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 15);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 4);
  uint64_t v3 = *((void *)this + 3);
  if (v3)
  {

    *((void *)this + 3) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  JUMPOUT(0x22A6A9430);
}

uint64_t anonymous namespace'::DiscoveryViewProxy::didJoinEvent(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  return (uint64_t)this + 32;
}

uint64_t anonymous namespace'::DiscoveryViewProxy::didLeaveEvent(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  return (uint64_t)this + 120;
}

uint64_t anonymous namespace'::DiscoveryViewProxy::identitiesCount(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 40) + 16))();
}

char *anonymous namespace'::DiscoveryViewProxy::identityAtIndex@<X0>(_anonymous_namespace_::DiscoveryViewProxy *this@<X0>, void *a2@<X8>)
{
  uint64_t result = (char *)(*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 48) + 16))();
  *a2 = result;
  if (result)
  {
    id v4 = result + 8;
    return (char *)v4;
  }
  return result;
}

uint64_t anonymous namespace'::DiscoveryViewProxy::authData(_anonymous_namespace_::DiscoveryViewProxy *this)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v2 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)(*((void *)this + 3) + 56) + 16))(&v2);
  return v3;
}

uint64_t anonymous namespace'::DiscoveryViewProxy::requestIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7[0] = 0;
  v7[1] = a3;
  _OWORD v7[2] = a4;
  uint64_t v4 = *(void *)(*(void *)(a1 + 24) + 64);
  if (*(void *)(a2 + 8)) {
    uint64_t v5 = *(void *)(a2 + 16);
  }
  else {
    uint64_t v5 = a2 + 9;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(v4 + 16))(v4, v5, v7);
}

uint64_t anonymous namespace'::DiscoveryViewProxy::removeIdentity()
{
  return 0;
}

uint64_t anonymous namespace'::DiscoveryViewProxy::createProtocolLayer@<X0>(_anonymous_namespace_::DiscoveryViewProxy *this@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 72) + 16))();
  *a2 = result;
  return result;
}

void anonymous namespace'::DiscoveryIdentityProxy::~DiscoveryIdentityProxy(_anonymous_namespace_::DiscoveryIdentityProxy *this)
{
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = *(void *)(v2 + 32);
  if (!v3 || ((*(void (**)(void))(v3 + 16))(), (uint64_t v2 = *((void *)this + 3)) != 0))
  {

    *((void *)this + 3) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  JUMPOUT(0x22A6A9430);
}

uint64_t anonymous namespace'::DiscoveryIdentityProxy::displayName(_anonymous_namespace_::DiscoveryIdentityProxy *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 40) + 16))();
}

uint64_t anonymous namespace'::DiscoveryIdentityProxy::address@<X0>(_anonymous_namespace_::DiscoveryIdentityProxy *this@<X0>, re::DynamicString *a2@<X8>)
{
  uint64_t v3 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 48) + 16))();
  re::DynamicString::DynamicString(a2, (const re::DynamicString *)&v5);
  uint64_t result = v5;
  if (v5)
  {
    if (v6) {
      return (*(uint64_t (**)(void))(*(void *)v5 + 40))();
    }
  }
  return result;
}

uint64_t anonymous namespace'::DiscoveryIdentityProxy::isLocal(_anonymous_namespace_::DiscoveryIdentityProxy *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 3) + 56) + 16))();
}

re::RoutingTable *re::RoutingTable::RoutingTable(re::RoutingTable *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD35238;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *(void *)((char *)this + 108) = 0x7FFFFFFFLL;
  *((void *)this + 15) = 0;
  uuid_generate_random((unsigned __int8 *)v4);
  *((void *)this + 3) = (v4[1] + (v4[0] << 6) + (v4[0] >> 2) - 0x61C8864680B583E9) ^ v4[0];
  return this;
}

unint64_t *re::RoutingTable::getRoute@<X0>(re::RoutingTable *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  v9[0] = a2;
  uint64_t result = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 72, v9);
  if (result)
  {
    unint64_t v6 = *result;
    unint64_t v7 = *((void *)this + 6);
    if (v7 <= *result)
    {
      v9[1] = 0;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v18 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v10 = 136315906;
      uint64_t v11 = "operator[]";
      __int16 v12 = 1024;
      int v13 = 789;
      __int16 v14 = 2048;
      unint64_t v15 = v6;
      __int16 v16 = 2048;
      unint64_t v17 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v8 = *((void *)this + 8) + 40 * v6;
    *(void *)(v8 + 32) = *((void *)this + 15);
    *(unsigned char *)a3 = 1;
    *(_OWORD *)(a3 + 8) = *(_OWORD *)(v8 + 8);
    *(void *)(a3 + 24) = *(void *)(v8 + 24);
  }
  else
  {
    *(unsigned char *)a3 = 0;
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(v6 + 32 * v4 + 16) != v2)
  {
    while (1)
    {
      uint64_t v4 = *(_DWORD *)(v6 + 32 * v4 + 8) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v6 + 32 * v4 + 16) == v2) {
        return v6 + 32 * v4 + 24;
      }
    }
    return 0;
  }
  return v6 + 32 * v4 + 24;
}

unint64_t *re::RoutingTable::addRoute(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  v23[0] = a2;
  uint64_t v5 = a1 + 72;
  uint64_t result = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 72, v23);
  if (result)
  {
    unint64_t v7 = *result;
    unint64_t v8 = *(void *)(a1 + 48);
    if (v8 <= *result)
    {
      v23[1] = 0;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      long long v31 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v24 = 136315906;
      *(void *)&v24[4] = "operator[]";
      __int16 v25 = 1024;
      int v26 = 789;
      __int16 v27 = 2048;
      unint64_t v28 = v7;
      __int16 v29 = 2048;
      unint64_t v30 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v9 = *(void *)(a1 + 64);
    if (*((_DWORD *)a3 + 4) < *(_DWORD *)(v9 + 40 * v7 + 24))
    {
      long long v10 = *a3;
      uint64_t v11 = v9 + 40 * v7;
      *(_DWORD *)(v11 + 24) = *((_DWORD *)a3 + 4);
      *(_OWORD *)(v11 + 8) = v10;
    }
  }
  else
  {
    uint64_t v12 = v23[0];
    long long v31 = *a3;
    LODWORD(v32) = *((_DWORD *)a3 + 4);
    uint64_t v13 = *(void *)(a1 + 120);
    unint64_t v14 = *(void *)(a1 + 40);
    unint64_t v15 = *(void *)(a1 + 48);
    if (v15 >= v14)
    {
      unint64_t v16 = v15 + 1;
      if (v14 < v15 + 1)
      {
        if (*(void *)(a1 + 32))
        {
          uint64_t v17 = 2 * v14;
          BOOL v18 = v14 == 0;
          unint64_t v19 = 8;
          if (!v18) {
            unint64_t v19 = v17;
          }
          if (v19 <= v16) {
            unint64_t v20 = v16;
          }
          else {
            unint64_t v20 = v19;
          }
          re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity((void *)(a1 + 32), v20);
        }
        else
        {
          re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity((void *)(a1 + 32), v16);
          ++*(_DWORD *)(a1 + 56);
        }
      }
      unint64_t v15 = *(void *)(a1 + 48);
    }
    uint64_t v21 = *(void *)(a1 + 64) + 40 * v15;
    *(void *)uint64_t v21 = v12;
    *(_OWORD *)(v21 + 8) = v31;
    *(_DWORD *)(v21 + 24) = v32;
    *(void *)(v21 + 32) = v13;
    uint64_t v22 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = v22 + 1;
    ++*(_DWORD *)(a1 + 56);
    *(void *)uint64_t v24 = v22;
    return (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(v5, v23, v24);
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 32 * v10;
  return v12 + 24;
}

unint64_t *re::RoutingTable::removeRouteForPeerID(re::RoutingTable *this, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t result = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 72, &v4);
  if (result) {
    return (unint64_t *)re::RoutingTable::removeEntryAtIndex(this, *result);
  }
  return result;
}

uint64_t re::RoutingTable::removeEntryAtIndex(re::RoutingTable *this, unint64_t a2)
{
  unint64_t v2 = *((void *)this + 6);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v4 = *((void *)this + 8);
  uint64_t v5 = (long long *)(v4 + 40 * a2);
  uint64_t v6 = v4 + 40 * v2;
  long long v7 = *v5;
  long long v8 = v5[1];
  uint64_t v9 = *((void *)v5 + 4);
  uint64_t v10 = *(void *)(v6 - 8);
  long long v11 = *(_OWORD *)(v6 - 24);
  *uint64_t v5 = *(_OWORD *)(v6 - 40);
  v5[1] = v11;
  *((void *)v5 + 4) = v10;
  *(void *)(v6 - 8) = v9;
  *(_OWORD *)(v6 - 24) = v8;
  *(_OWORD *)(v6 - 40) = v7;
  if (*((void *)this + 6) <= a2) {
    goto LABEL_13;
  }
  uint64_t v12 = (char *)this + 72;
  uint64_t v13 = *((void *)this + 8);
  LODWORD(v14) = 0x7FFFFFFF;
  if (*((void *)this + 9))
  {
    unint64_t v15 = *(void *)(v13 + 40 * a2);
    unint64_t v16 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) >> 27));
    uint64_t v17 = *(unsigned int *)(*((void *)this + 10) + 4 * ((v16 ^ (v16 >> 31)) % *((unsigned int *)this + 24)));
    if (v17 != 0x7FFFFFFF)
    {
      uint64_t v18 = *((void *)this + 11);
      LODWORD(v14) = v17;
      if (*(void *)(v18 + 32 * v17 + 16) != v15)
      {
        uint64_t v14 = v17;
        while (1)
        {
          uint64_t v14 = *(_DWORD *)(v18 + 32 * v14 + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v18 + 32 * v14 + 16) == v15) {
            goto LABEL_11;
          }
        }
        LODWORD(v14) = 0x7FFFFFFF;
      }
    }
  }
LABEL_11:
  *(void *)(*((void *)this + 11) + 32 * v14 + 24) = a2;
  uint64_t result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v12, (uint64_t *)(v13 + 40 * *((void *)this + 6) - 40));
  --*((void *)this + 6);
  ++*((_DWORD *)this + 14);
  return result;
}

re::RoutingTable *re::RoutingTable::removeRoutesForTransport(re::RoutingTable *this, re::Transport *a2)
{
  uint64_t v2 = *((void *)this + 6);
  if (v2)
  {
    uint64_t v4 = this;
    unint64_t v5 = v2 - 1;
    uint64_t v6 = 40 * v2 - 32;
    do
    {
      if (*((void *)v4 + 6) <= v5)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (*(re::Transport **)(*((void *)v4 + 8) + v6) == a2) {
        this = (re::RoutingTable *)re::RoutingTable::removeEntryAtIndex(v4, v5);
      }
      --v5;
      v6 -= 40;
    }
    while (v5 != -1);
  }
  return this;
}

re::RoutingTable *re::RoutingTable::removeRoutesForConnection(re::RoutingTable *this, re::Transport *a2, uint64_t a3)
{
  uint64_t v3 = *((void *)this + 6);
  if (v3)
  {
    uint64_t v6 = this;
    unint64_t v7 = v3 - 1;
    uint64_t v8 = 40 * v3;
    do
    {
      if (*((void *)v6 + 6) <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v9 = *((void *)v6 + 8) + v8;
      if (*(re::Transport **)(v9 - 32) == a2 && *(void *)(v9 - 24) == a3) {
        this = (re::RoutingTable *)re::RoutingTable::removeEntryAtIndex(v6, v7);
      }
      --v7;
      v8 -= 40;
    }
    while (v7 != -1);
  }
  return this;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v4 = ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(v5 + 4 * v4);
  if (v6 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = v8 + 32 * v6;
  if (*(void *)(v9 + 16) != v2)
  {
    while (1)
    {
      unsigned int v10 = v6;
      uint64_t v6 = *(_DWORD *)(v8 + 32 * v6 + 8) & 0x7FFFFFFF;
      if (v6 == 0x7FFFFFFF) {
        return 0;
      }
      uint64_t v11 = v8 + 32 * v6;
      if (*(void *)(v11 + 16) == v2)
      {
        *(_DWORD *)(v8 + 32 * v10 + 8) = *(_DWORD *)(v8 + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v13 = v12 + 32 * v6;
  int v16 = *(_DWORD *)(v13 + 8);
  unint64_t v15 = (int *)(v13 + 8);
  int v14 = v16;
  if (v16 < 0)
  {
    int *v15 = v14 & 0x7FFFFFFF;
    uint64_t v12 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v12 + 32 * v6 + 8);
  }
  int v17 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v12 + 32 * v6 + 8) = *(_DWORD *)(a1 + 36) | v14 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v17 + 1;
  return 1;
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep re::RoutingTable::update(re::RoutingTable *this)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = std::chrono::steady_clock::now().__d_.__rep_;
  *((void *)this + 15) = result / 1000000000;
  unint64_t v3 = *((void *)this + 6);
  if (v3 >= 0x200)
  {
    unint64_t v4 = v3 - 1;
    uint64_t v5 = 40 * v3;
    do
    {
      if (*((void *)this + 6) <= v4)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v6 = *((void *)this + 8) + v5;
      if (*(_DWORD *)(v6 - 16) >= 2u && *((void *)this + 15) - *(void *)(v6 - 8) >= 0x258uLL) {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = re::RoutingTable::removeEntryAtIndex(this, v4);
      }
      --v4;
      v5 -= 40;
    }
    while (v4 != -1);
  }
  return result;
}

void re::RoutingTable::~RoutingTable(re::RoutingTable *this)
{
  *(void *)this = &unk_26DD35238;
  uint64_t v2 = (char *)this + 32;
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 9);
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v2);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  char *v2;
  uint64_t vars8;

  *(void *)this = &unk_26DD35238;
  uint64_t v2 = (char *)this + 32;
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 9);
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v2);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

void re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    int v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (void *)(*(void *)&v13[16] + v10 + 16), (void *)(*(void *)&v13[16] + v10 + 24));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep re::NetworkClockDefault::timestampMs(re::NetworkClockDefault *this)
{
  return std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
}

void re::NetworkClockDefault::~NetworkClockDefault(re::NetworkClockDefault *this)
{
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

void re::DynamicPacketBitWriter::~DynamicPacketBitWriter(re::DynamicPacketBitWriter *this)
{
  if (*((void *)this + 6))
  {
    (*(void (**)(void))(**((void **)this + 5) + 24))(*((void *)this + 5));
    *((void *)this + 6) = 0;
  }
}

{
  uint64_t vars8;

  if (*((void *)this + 6))
  {
    (*(void (**)(void))(**((void **)this + 5) + 24))(*((void *)this + 5));
    *((void *)this + 6) = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void *re::DynamicPacketBitWriter::grow(void *this, uint64_t a2)
{
  int v2 = a2;
  uint64_t v3 = (uint64_t)this;
  if (a2 <= 0x10000) {
    a2 = 0x10000;
  }
  else {
    a2 = a2;
  }
  uint64_t v4 = *((void *)this + 6);
  if (!v4
    || ((int v5 = *((_DWORD *)this + 4), v6 = v5 + v2, 2 * v5 <= v6) ? (a2 = v6) : (a2 = (2 * v5)),
        a2 > *(_DWORD *)(v4 + 28)))
  {
    this = (void *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 5) + 16))(*((void *)this + 5), a2);
    if (this)
    {
      unsigned int v7 = this;
      this = memmove(*((void **)this + 2), *(const void **)(v3 + 8), *(unsigned int *)(v3 + 16));
      if (*(void *)(v3 + 48)) {
        this = (void *)(*(uint64_t (**)(void))(**(void **)(v3 + 40) + 24))(*(void *)(v3 + 40));
      }
      *(void *)(v3 + 48) = v7;
      *(void *)(v3 + 8) = v7[2];
      *(_DWORD *)(v3 + 16) = *((_DWORD *)v7 + 7);
    }
    else
    {
      *(unsigned char *)(v3 + 20) = 1;
    }
  }
  return this;
}

re::SyncObjectTypeInfo *RESyncSyncableTypeInfoCreate(re *a1)
{
  int v1 = re::globalAllocators(a1);
  int v2 = (re::SyncObjectTypeInfo *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 144, 8);
  *(_OWORD *)int v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 5) = 0u;
  *((_OWORD *)v2 + 6) = 0u;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  return re::SyncObjectTypeInfo::SyncObjectTypeInfo(v2);
}

uint64_t RESyncSyncableTypeInfoSetTypeId(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 32) = a2;
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoGetTypeId(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

_anonymous_namespace_ *RESyncSyncableTypeInfoSetDebugName(_anonymous_namespace_ *result, const char *a2)
{
  if (result)
  {
    if (a2)
    {
      uint64_t v3 = result;
      re::DynamicString::operator=((_anonymous_namespace_ *)((char *)v3 + 40), (re::DynamicString *)&v4);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = v4;
      if (v4)
      {
        if (v5) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v4 + 40))();
        }
      }
    }
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoGetDebugName(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 48)) {
      return *(void *)(result + 56);
    }
    else {
      result += 49;
    }
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetSupportsNetworkSync(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 24) = a2;
  }
  return result;
}

BOOL RESyncSyncableTypeInfoSupportsNetworkSync(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 24) != 0;
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetSupportsOwnershipTransfer(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 73) = a2;
  }
  return result;
}

BOOL RESyncSyncableTypeInfoSupportsOwnershipTransfer(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 73) != 0;
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetSupportsViews(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 74) = a2;
  }
  return result;
}

BOOL RESyncSyncableTypeInfoSupportsViews(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 74) != 0;
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoGetReadSnapshotCb(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetReadSnapshotCb(uint64_t a1, void *aBlock)
{
  if (a1) {
    return (uint64_t)re::SyncObjectTypeInfo::setReadSnapshotCb(a1, aBlock);
  }
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetWriteSnapshotCb(uint64_t result)
{
  if (result) {
    return *(void *)(result + 88);
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetWriteSnapshotCb(uint64_t a1, void *aBlock)
{
  if (a1) {
    return (uint64_t)re::SyncObjectTypeInfo::setWriteSnapshotCb(a1, aBlock);
  }
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetReadPayloadCb(uint64_t result)
{
  if (result) {
    return *(void *)(result + 96);
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetReadPayloadCb(uint64_t a1, void *aBlock)
{
  if (a1) {
    return (uint64_t)re::SyncObjectTypeInfo::setReadPayloadCb(a1, aBlock);
  }
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetReadPayloadDeltaCb(uint64_t result)
{
  if (result) {
    return *(void *)(result + 104);
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetReadPayloadDeltaCb(uint64_t a1, void *aBlock)
{
  if (a1) {
    return (uint64_t)re::SyncObjectTypeInfo::setReadPayloadDeltaCb(a1, aBlock);
  }
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetWritePayloadCb(uint64_t result)
{
  if (result) {
    return *(void *)(result + 112);
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetWritePayloadCb(uint64_t a1, void *aBlock)
{
  if (a1) {
    return (uint64_t)re::SyncObjectTypeInfo::setWritePayloadCb(a1, aBlock);
  }
  return a1;
}

uint64_t RESyncSyncableTypeInfoGetWritePayloadDeltaCb(uint64_t result)
{
  if (result) {
    return *(void *)(result + 120);
  }
  return result;
}

uint64_t RESyncSyncableTypeInfoSetWritePayloadDeltaCb(uint64_t a1, void *aBlock)
{
  if (a1) {
    return (uint64_t)re::SyncObjectTypeInfo::setWritePayloadDeltaCb(a1, aBlock);
  }
  return a1;
}

uint64_t RESyncSyncableTypeInfoSetShouldPackCb(uint64_t a1, void *aBlock)
{
  if (a1) {
    return (uint64_t)re::SyncObjectTypeInfo::setShouldPackCb(a1, aBlock);
  }
  return a1;
}

uint64_t RESyncSyncableTypeInfoSetShouldUnpackCb(uint64_t a1, void *aBlock)
{
  if (a1) {
    return (uint64_t)re::SyncObjectTypeInfo::setShouldUnpackCb(a1, aBlock);
  }
  return a1;
}

uint64_t RESyncCongestionGetBandwidthEventDataSize()
{
  return 24;
}

void *RESyncCongestionCreateBandwidthEventDataNoAlloc(void *a1, unint64_t a2)
{
  int v2 = 0;
  if (a1 && a2 >= 0x18)
  {
    *a1 = 0;
    a1[1] = 0;
    int v2 = a1;
    a1[2] = 0;
  }
  return v2;
}

uint64_t RESyncCongestionBandwidthEventDataSetTotalAvailableBitsPerSecond(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 8)) {
    *(unsigned char *)(a1 + 8) = 1;
  }
  uint64_t result = 0;
  *(void *)(a1 + 16) = a2;
  return result;
}

uint64_t re::NWProtocolLayer::NWProtocolLayer(uint64_t a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_26DD35328;
  *(unsigned char *)(a1 + 32) = *(unsigned char *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 8));
  long long v4 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 88) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = v4;
  *(_DWORD *)(a1 + 96) = 10;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  char v5 = objc_alloc_init(NWProtocolDelegate);
  *(void *)(a1 + 120) = v5;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = re::NWProtocolFramer::definition((re::NWProtocolFramer *)v5);
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 188) = 0u;
  *(void *)(a1 + 204) = 0x7FFFFFFFLL;
  *(_DWORD *)(a1 + 216) = 0;
  *(void *)(*(void *)(a1 + 120) + 8) = a1;
  return a1;
}

void re::NWProtocolLayer::~NWProtocolLayer(re::NWProtocolLayer *this)
{
  *(void *)this = &unk_26DD35328;
  if (*((void *)this + 3)) {
    re::NWProtocolLayer::deinit((os_unfair_lock_s *)this);
  }
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 21);
  int v2 = (void *)*((void *)this + 20);
  *((void *)this + 20) = 0;

  re::DynamicString::deinit((re::NWProtocolLayer *)((char *)this + 40));
  uint64_t v3 = *((void *)this + 3);
  if (v3)
  {

    *((void *)this + 3) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::NWProtocolLayer::~NWProtocolLayer(this);
  JUMPOUT(0x22A6A9430);
}

void re::NWProtocolLayer::assertNetworkQueue(re::NWProtocolLayer *this)
{
  int v1 = this;
  dispatch_assert_queue_V2((dispatch_queue_t)v1);
}

uint64_t re::NWProtocolLayer::init(uint64_t a1, uint64_t a2)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    id v5 = (id)(v4 + 8);
  }
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v4;
  if (v6) {

  }
  objc_storeStrong((id *)(a1 + 160), *(id *)a2);
  nw_parameters_t v7 = nw_parameters_create();
  long long v8 = *(void **)(a1 + 152);
  *(void *)(a1 + 152) = v7;

  nw_parameters_set_reuse_local_address(*(nw_parameters_t *)(a1 + 152), 1);
  nw_parameters_set_no_delay();
  unsigned int v9 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(a1 + 152));
  options = nw_tcp_create_options();
  unint64_t v11 = options;
  if (*(_DWORD *)(a1 + 96))
  {
    nw_tcp_options_set_enable_keepalive(options, 1);
    nw_tcp_options_set_keepalive_idle_time(v11, *(_DWORD *)(a1 + 96));
    nw_tcp_options_set_keepalive_count(v11, 4u);
    nw_tcp_options_set_keepalive_interval(v11, 5u);
  }
  else
  {
    nw_tcp_options_set_enable_keepalive(options, 0);
  }
  nw_protocol_stack_set_transport_protocol(v9, v11);
  signed int v12 = nw_framer_create_options(*(nw_protocol_definition_t *)(a1 + 136));
  nw_protocol_stack_prepend_application_protocol(v9, v12);

  nw_parameters_t v13 = nw_parameters_create();
  int v14 = *(void **)(a1 + 144);
  *(void *)(a1 + 144) = v13;

  uint64_t v15 = 1;
  nw_parameters_set_reuse_local_address(*(nw_parameters_t *)(a1 + 144), 1);
  nw_parameters_set_no_delay();
  int v16 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(a1 + 144));
  int v17 = nw_framer_create_options(*(nw_protocol_definition_t *)(a1 + 136));
  nw_protocol_stack_prepend_application_protocol(v16, v17);

  uint64_t v18 = (void *)nw_context_create();
  nw_context_set_isolate_protocol_stack();
  nw_context_set_scheduling_mode();
  nw_parameters_set_context();

  if (*(unsigned char *)(a1 + 32))
  {
    unint64_t v19 = [[NWListener alloc] initWithLayer:a1];
    unint64_t v20 = *(void **)(a1 + 128);
    *(void *)(a1 + 128) = v19;

    uint64_t v21 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    uint64_t v22 = dispatch_get_global_queue(21, 0);
    dispatch_queue_t v23 = dispatch_queue_create_with_target_V2("re-nw-protocol-listener", v21, v22);
    uint64_t v24 = *(void *)(a1 + 128);
    __int16 v25 = *(void **)(v24 + 8);
    *(void *)(v24 + 8) = v23;

    objc_storeStrong((id *)(*(void *)(a1 + 128) + 16), *(id *)(a1 + 160));
    int v26 = (re *)nw_parameters_copy(*(nw_parameters_t *)(a1 + 152));
    __int16 v27 = v26;
    unint64_t v28 = *(void *)(a1 + 48);
    unint64_t v29 = v28 >> 1;
    if ((v28 & 1) == 0) {
      unint64_t v29 = v28 >> 1;
    }
    if (v29)
    {
      host_with_numeric_port = nw_endpoint_create_host_with_numeric_port();
      nw_parameters_set_local_endpoint(v27, host_with_numeric_port);
    }
    int v31 = *(unsigned __int16 *)(a1 + 72);
    long long v32 = *re::networkLogObjects(v26);
    BOOL v33 = os_log_type_enabled(v32, OS_LOG_TYPE_INFO);
    if (v31)
    {
      if (v33)
      {
        unint64_t v34 = *(void *)(a1 + 48);
        unint64_t v35 = v34 >> 1;
        if ((v34 & 1) == 0) {
          unint64_t v35 = v34 >> 1;
        }
        if (v35)
        {
          if (v34) {
            uint64_t v36 = *(const char **)(a1 + 56);
          }
          else {
            uint64_t v36 = (const char *)(a1 + 49);
          }
        }
        else
        {
          uint64_t v36 = "any";
        }
        int v40 = *(unsigned __int16 *)(a1 + 72);
        *(_DWORD *)buf = 136315394;
        unint64_t v49 = v36;
        __int16 v50 = 1024;
        int v51 = v40;
        _os_log_impl(&dword_228C70000, v32, OS_LOG_TYPE_INFO, "NWListener.init address=%s port=%d", buf, 0x12u);
      }
      snprintf((char *)buf, 0x10uLL, "%d", *(unsigned __int16 *)(a1 + 72));
      uint64_t v41 = *(void **)(a1 + 128);
      nw_listener_t v42 = nw_listener_create_with_port((const char *)buf, v27);
    }
    else
    {
      if (v33)
      {
        unint64_t v37 = *(void *)(a1 + 48);
        unint64_t v38 = v37 >> 1;
        if ((v37 & 1) == 0) {
          unint64_t v38 = v37 >> 1;
        }
        if (v38)
        {
          if (v37) {
            unint64_t v39 = *(const char **)(a1 + 56);
          }
          else {
            unint64_t v39 = (const char *)(a1 + 49);
          }
        }
        else
        {
          unint64_t v39 = "any";
        }
        *(_DWORD *)buf = 136315138;
        unint64_t v49 = v39;
        _os_log_impl(&dword_228C70000, v32, OS_LOG_TYPE_INFO, "NWListener.init address=%s port=any", buf, 0xCu);
      }
      uint64_t v41 = *(void **)(a1 + 128);
      nw_listener_t v42 = nw_listener_create(v27);
    }
    nw_listener_t v43 = v42;
    [v41 setListener:v42];

    [*(id *)(a1 + 128) waitForReady];
    int v44 = *(_DWORD *)(*(void *)(a1 + 128) + 40);

    if (v44 == 2)
    {
      return 1;
    }
    else
    {
      long long v46 = *re::networkLogObjects(v45);
      uint64_t v15 = 0;
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_228C70000, v46, OS_LOG_TYPE_DEFAULT, "Unable to initialize listener", buf, 2u);
        return 0;
      }
    }
  }
  return v15;
}

void re::NWProtocolLayer::deinit(os_unfair_lock_s *this)
{
  int v2 = this + 54;
  os_unfair_lock_lock(this + 54);
  while (this[49]._os_unfair_lock_opaque)
  {
    uint64_t os_unfair_lock_opaque = this[50]._os_unfair_lock_opaque;
    uint64_t v4 = *(void *)&this[46]._os_unfair_lock_opaque;
    uint64_t v5 = 0;
    if (os_unfair_lock_opaque)
    {
      uint64_t v6 = (int *)(v4 + 8);
      while (1)
      {
        int v7 = *v6;
        v6 += 6;
        if (v7 < 0) {
          break;
        }
        if (os_unfair_lock_opaque == ++v5)
        {
          LODWORD(v5) = this[50];
          break;
        }
      }
    }
    re::NWProtocolLayer::removeConnection((uint64_t)this, *(void *)(v4 + 24 * v5 + 16), 1);
  }
  long long v8 = *(void **)&this[32]._os_unfair_lock_opaque;
  if (v8)
  {
    [v8 stopListening];
    unsigned int v9 = *(void **)&this[32]._os_unfair_lock_opaque;
    void v9[6] = 0;
    *(void *)&this[32]._uint64_t os_unfair_lock_opaque = 0;
  }
  *(void *)(*(void *)&this[30]._os_unfair_lock_opaque + 8) = 0;
  uint64_t v10 = *(void *)&this[6]._os_unfair_lock_opaque;
  if (v10)
  {

    *(void *)&this[6]._uint64_t os_unfair_lock_opaque = 0;
  }
  os_unfair_lock_unlock(v2);
}

void re::NWProtocolLayer::removeConnection(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a1 + 160));
  int v7 = *re::networkLogObjects(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    int v32 = 134217984;
    unint64_t v33 = a2;
    _os_log_debug_impl(&dword_228C70000, v7, OS_LOG_TYPE_DEBUG, "NWProtocolLayer.removeConnection %p", (uint8_t *)&v32, 0xCu);
    if (!a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  if (a2) {
LABEL_3:
  }
    id v8 = (id)(a2 + 8);
LABEL_4:
  unsigned int v9 = *(NSObject **)(a2 + 1768);
  if (v9)
  {
    nw_connection_set_state_changed_handler(v9, 0);
    if (*(_DWORD *)(a2 + 1776) != 5)
    {
      unint64_t v11 = *re::networkLogObjects(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        int v32 = 134217984;
        unint64_t v33 = a2;
        _os_log_debug_impl(&dword_228C70000, v11, OS_LOG_TYPE_DEBUG, "NWProtocolLayer.cancelling %p", (uint8_t *)&v32, 0xCu);
      }
      signed int v12 = *(NSObject **)(a2 + 1768);
      if (a3) {
        nw_connection_force_cancel(v12);
      }
      else {
        nw_connection_cancel(v12);
      }
    }
  }
  unint64_t v13 = *(unsigned int *)(a1 + 192);
  if (!v13
    || (unint64_t v14 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27)),
        unint64_t v15 = (v14 ^ (v14 >> 31)) % v13,
        uint64_t v16 = *(void *)(a1 + 176),
        uint64_t v17 = *(unsigned int *)(v16 + 4 * v15),
        v17 == 0x7FFFFFFF))
  {
    re::NWProtocolHandle::reset((re::NWProtocolHandle *)a2);
LABEL_24:

    return;
  }
  uint64_t v18 = *(void *)(a1 + 184);
  if (*(void *)(v18 + 24 * v17 + 16) == a2)
  {
    *(_DWORD *)(v16 + 4 * v15) = *(_DWORD *)(v18 + 24 * v17 + 8) & 0x7FFFFFFF;
LABEL_19:
    uint64_t v21 = *(void *)(a1 + 184);
    uint64_t v22 = v21 + 24 * v17;
    int v25 = *(_DWORD *)(v22 + 8);
    dispatch_queue_t v23 = (int *)(v22 + 8);
    int v24 = v25;
    if (v25 < 0)
    {
      *dispatch_queue_t v23 = v24 & 0x7FFFFFFF;
      uint64_t v26 = v21 + 24 * v17;
      uint64_t v29 = *(void *)(v26 + 16);
      unint64_t v28 = (void *)(v26 + 16);
      uint64_t v27 = v29;
      if (v29)
      {

        *unint64_t v28 = 0;
      }
    }
    uint64_t v30 = *(void *)(a1 + 184) + 24 * v17;
    *(_DWORD *)(v30 + 8) = *(_DWORD *)(v30 + 8) & 0x80000000 | *(_DWORD *)(a1 + 204);
    --*(_DWORD *)(a1 + 196);
    int v31 = *(_DWORD *)(a1 + 208) + 1;
    *(_DWORD *)(a1 + 204) = v17;
    *(_DWORD *)(a1 + 208) = v31;
  }
  else
  {
    while (1)
    {
      unsigned int v19 = v17;
      int v20 = *(_DWORD *)(v18 + 24 * v17 + 8);
      uint64_t v17 = v20 & 0x7FFFFFFF;
      if ((v20 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v18 + 24 * v17 + 16) == a2)
      {
        *(_DWORD *)(v18 + 24 * v19 + 8) = *(_DWORD *)(v18 + 24 * v19 + 8) & 0x80000000 | *(_DWORD *)(v18 + 24 * v17 + 8) & 0x7FFFFFFF;
        goto LABEL_19;
      }
    }
  }
  re::NWProtocolHandle::reset((re::NWProtocolHandle *)a2);
  if (a2) {
    goto LABEL_24;
  }
}

void re::NWProtocolLayer::open(nw_parameters_t *this@<X0>, const re::Address *a2@<X1>, void *a3@<X8>)
{
  v29[4] = *MEMORY[0x263EF8340];
  IPPortPair = (re *)re::Address::getIPPortPair(a2, (uint64_t)v28);
  if (!v28[0])
  {
    if (*((unsigned char *)a2 + 8))
    {
      unint64_t v13 = (const char *)*((void *)a2 + 2);
      if (strncmp(v13, "fd://", 5uLL))
      {
LABEL_18:
        uint64_t v12 = 0;
        goto LABEL_19;
      }
    }
    else
    {
      unint64_t v13 = (char *)a2 + 9;
      if (*(_DWORD *)((char *)a2 + 9) != 792355942 || *((unsigned char *)a2 + 13) != 47) {
        goto LABEL_18;
      }
    }
    int v25 = 0;
    unint64_t v15 = (re *)strtol(v13 + 5, &v25, 10);
    int v16 = (int)v15;
    if ((int)v15 < 1) {
      goto LABEL_27;
    }
    unint64_t v17 = *((void *)a2 + 1);
    uint64_t v18 = (char *)*((void *)a2 + 2);
    if ((v17 & 1) == 0) {
      uint64_t v18 = (char *)a2 + 9;
    }
    unint64_t v19 = v17 >> 1;
    unint64_t v20 = v17 >> 1;
    if (*((void *)a2 + 1)) {
      unint64_t v20 = v19;
    }
    if (v25 != &v18[v20]) {
      goto LABEL_27;
    }
    uint64_t v21 = *re::networkLogObjects(v15);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)&buf.sa_len = 67109120;
      *(_DWORD *)&buf.sa_data[2] = v16;
      _os_log_impl(&dword_228C70000, v21, OS_LOG_TYPE_INFO, "NWProtocolLayer.openConnection file-descriptor=%d", &buf.sa_len, 8u);
    }
    *(void *)&buf.sa_len = 0;
    *(void *)&buf.sa_data[6] = 0;
    socklen_t v26 = 16;
    getsockname(v16, &buf, &v26);
    uint64_t v22 = (void *)nw_connection_create_with_connected_socket_and_parameters();
    if (v22)
    {
      dispatch_queue_t v23 = v22;
      re::NWProtocolLayer::addConnection((unint64_t *)&buf.sa_len, (uint64_t)this, v22);
      uint64_t v12 = *(void *)&buf.sa_len;

      if (v12)
      {

        id v24 = (id)(v12 + 8);
      }
    }
    else
    {
LABEL_27:
      uint64_t v12 = 0;
    }
    goto LABEL_11;
  }
  int v7 = *re::networkLogObjects(IPPortPair);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    id v8 = v7;
    if (*((void *)a2 + 1)) {
      unsigned int v9 = (char *)*((void *)a2 + 2);
    }
    else {
      unsigned int v9 = (char *)a2 + 9;
    }
    *(_DWORD *)&buf.sa_len = 136315138;
    *(void *)&buf.sa_data[2] = v9;
    _os_log_impl(&dword_228C70000, v8, OS_LOG_TYPE_INFO, "NWProtocolLayer.open address=%s", &buf.sa_len, 0xCu);
  }
  re::IP::generateString((re::IP *)v29, (re::DynamicString *)&buf);
  host_with_numeric_port = nw_endpoint_create_host_with_numeric_port();
  if (*(void *)&buf.sa_len && (buf.sa_data[6] & 1) != 0) {
    (*(void (**)(void))(**(void **)&buf.sa_len + 40))();
  }
  nw_connection_t v11 = nw_connection_create(host_with_numeric_port, this[19]);
  re::NWProtocolLayer::addConnection((unint64_t *)&buf.sa_len, (uint64_t)this, v11);
  uint64_t v12 = *(void *)&buf.sa_len;

LABEL_11:
  if (v12) {
    re::DynamicString::operator=((re::DynamicString *)(v12 + 1784), a2);
  }
LABEL_19:
  *a3 = v12;
}

void re::NWProtocolLayer::addConnection(unint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v6 = a3;
  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a2 + 160));
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 216));
  id v8 = re::globalAllocators(v7);
  unint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 1872, 8);
  bzero((void *)v9, 0x750uLL);
  uint64_t v10 = re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v9);
  *(void *)unint64_t v9 = &unk_26DD353F0;
  *(void *)(v9 + 1768) = 0;
  *(_DWORD *)(v9 + 1776) = 0;
  *(_OWORD *)(v9 + 1784) = 0u;
  *(_OWORD *)(v9 + 1800) = 0u;
  re::DynamicString::setCapacity((void *)(v9 + 1784), 0);
  *(_WORD *)(v9 + 1864) = 0;
  *(_OWORD *)(v9 + 1832) = 0u;
  *(_OWORD *)(v9 + 1848) = 0u;
  *(_OWORD *)(v9 + 1816) = 0u;
  *a1 = v9;
  objc_storeStrong((id *)(v9 + 1768), a3);
  uint64_t v12 = *re::networkLogObjects(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)sockaddr buf = 134217984;
    unint64_t v53 = v9;
    _os_log_debug_impl(&dword_228C70000, v12, OS_LOG_TYPE_DEBUG, "NWProtocolLayer.addConnection %p", buf, 0xCu);
  }
  id v13 = *(id *)(a2 + 120);
  unint64_t v14 = *(id *)(a2 + 160);
  nw_connection_set_queue(v6, v14);

  handler[0] = MEMORY[0x263EF8330];
  handler[1] = 3221225472;
  handler[2] = ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke;
  handler[3] = &unk_264854838;
  id v15 = v13;
  id v50 = v15;
  int v16 = v6;
  int v51 = v16;
  nw_connection_set_state_changed_handler(v16, handler);
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2;
  aBlock[3] = &unk_264854860;
  id v17 = v15;
  id v47 = v17;
  uint64_t v18 = v16;
  uint64_t v48 = v18;
  unint64_t v19 = _Block_copy(aBlock);
  unint64_t v20 = *(void **)(v9 + 1816);
  *(void *)(v9 + 1816) = v19;

  v43[0] = MEMORY[0x263EF8330];
  v43[1] = 3221225472;
  v43[2] = ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_3;
  v43[3] = &unk_264854888;
  id v21 = v17;
  id v44 = v21;
  uint64_t v22 = v18;
  uint64_t v45 = v22;
  dispatch_queue_t v23 = _Block_copy(v43);
  id v24 = *(void **)(v9 + 1824);
  *(void *)(v9 + 1824) = v23;

  v40[0] = MEMORY[0x263EF8330];
  v40[1] = 3221225472;
  _OWORD v40[2] = ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_4;
  v40[3] = &unk_2648548B0;
  id v41 = v21;
  nw_listener_t v42 = v22;
  int v25 = v22;
  id v26 = v21;
  uint64_t v27 = _Block_copy(v40);
  unint64_t v28 = *(void **)(v9 + 1832);
  *(void *)(v9 + 1832) = v27;

  nw_connection_start(v25);
  unint64_t v29 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) >> 27));
  unint64_t v30 = v29 ^ (v29 >> 31);
  unint64_t v31 = *(unsigned int *)(a2 + 192);
  if (v31)
  {
    unint64_t v32 = v30 % v31;
    uint64_t v33 = *(unsigned int *)(*(void *)(a2 + 176) + 4 * (v30 % v31));
    if (v33 != 0x7FFFFFFF)
    {
      uint64_t v34 = *(void *)(a2 + 184);
      if (*(void *)(v34 + 24 * v33 + 16) == v9) {
        goto LABEL_16;
      }
      while (1)
      {
        LODWORD(v33) = *(_DWORD *)(v34 + 24 * v33 + 8) & 0x7FFFFFFF;
        if (v33 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v34 + 24 * v33 + 16) == v9) {
          goto LABEL_16;
        }
      }
    }
  }
  else
  {
    LODWORD(v32) = 0;
  }
  uint64_t v35 = *(unsigned int *)(a2 + 204);
  if (v35 == 0x7FFFFFFF)
  {
    uint64_t v35 = *(unsigned int *)(a2 + 200);
    int v36 = v35;
    if (v35 == v31)
    {
      re::HashSetBase<re::SharedPtr<re::NWProtocolHandle>,re::SharedPtr<re::NWProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::NWProtocolHandle>>,re::Hash<re::SharedPtr<re::NWProtocolHandle>>,re::EqualTo<re::SharedPtr<re::NWProtocolHandle>>,true,false>::setCapacity(a2 + 168, 2 * *(_DWORD *)(a2 + 196));
      LODWORD(v32) = v30 % *(unsigned int *)(a2 + 192);
      int v36 = *(_DWORD *)(a2 + 200);
    }
    *(_DWORD *)(a2 + 200) = v36 + 1;
    uint64_t v37 = *(void *)(a2 + 184);
    int v38 = *(_DWORD *)(v37 + 24 * v35 + 8);
  }
  else
  {
    uint64_t v37 = *(void *)(a2 + 184);
    int v38 = *(_DWORD *)(v37 + 24 * v35 + 8);
    *(_DWORD *)(a2 + 204) = v38 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v37 + 24 * v35 + 8) = v38 | 0x80000000;
  *(_DWORD *)(*(void *)(a2 + 184) + 24 * v35 + 8) = *(_DWORD *)(*(void *)(a2 + 184) + 24 * v35 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a2 + 176) + 4 * v32);
  *(void *)(*(void *)(a2 + 184) + 24 * v35) = v30;
  *(void *)(*(void *)(a2 + 184) + 24 * v35 + 16) = v9;
  id v39 = (id)(v9 + 8);
  *(_DWORD *)(*(void *)(a2 + 176) + 4 * v32) = v35;
  ++*(_DWORD *)(a2 + 196);
  ++*(_DWORD *)(a2 + 208);
LABEL_16:

  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 216));
}

void re::NWProtocolLayer::close(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a1 + 160));
  int v7 = *re::networkLogObjects(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    int v8 = 134218240;
    unint64_t v9 = a2;
    __int16 v10 = 1024;
    int v11 = a3;
    _os_log_impl(&dword_228C70000, v7, OS_LOG_TYPE_INFO, "NWProtocolLayer.close %p force=%d", (uint8_t *)&v8, 0x12u);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
  re::NWProtocolLayer::removeConnection(a1, a2, 0);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 216));
}

void re::NWProtocolLayer::disconnect(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a1 + 160));
  int v7 = *re::networkLogObjects(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    int v9 = 134218240;
    uint64_t v10 = a2;
    __int16 v11 = 1024;
    int v12 = a3;
    _os_log_impl(&dword_228C70000, v7, OS_LOG_TYPE_INFO, "NWProtocolLayer.disconnect %p force=%d", (uint8_t *)&v9, 0x12u);
  }
  if (a3)
  {
    nw_connection_force_cancel(*(nw_connection_t *)(a2 + 1768));
    *(_DWORD *)(a2 + 1776) = 5;
    *(_WORD *)(a2 + 1864) = 257;
    uint64_t v8 = *(void *)(a1 + 112);
    if (v8) {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 8))(v8, a1, a2, a2 + 1784);
    }
  }
  else
  {
    *(unsigned char *)(a2 + 1865) = 1;
    nw_connection_send(*(nw_connection_t *)(a2 + 1768), 0, (nw_content_context_t)*MEMORY[0x263F14450], 1, (nw_connection_send_completion_t)*MEMORY[0x263F14438]);
  }
}

void re::NWProtocolLayer::update(re::NWProtocolLayer *this)
{
  re::NWProtocolLayer::assertNetworkQueue(*((re::NWProtocolLayer **)this + 20));
  os_unfair_lock_lock((os_unfair_lock_t)this + 54);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v37, 6022, (uint64_t)this);
  uint64_t v2 = *((unsigned int *)this + 50);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (int *)(*((void *)this + 23) + 8);
    while (1)
    {
      int v5 = *v4;
      v4 += 6;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 50);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  unsigned int v6 = *((_DWORD *)this + 50);
  if (v2 != v3)
  {
    uint64_t v7 = v3;
    do
    {
      uint64_t v8 = *(void *)(*((void *)this + 23) + 24 * v7 + 16);
      if (*(void *)(v8 + 1768))
      {
        uint64_t v9 = 936;
        do
        {
          unsigned int explicit = atomic_load_explicit((atomic_uint *volatile)(v8 + v9), memory_order_acquire);
          if (explicit) {
            break;
          }
          BOOL v11 = v9 == 1296;
          v9 += 40;
        }
        while (!v11);
        if (explicit)
        {
          int v12 = *(NSObject **)(v8 + 1768);
          v36[0] = MEMORY[0x263EF8330];
          v36[1] = 3221225472;
          v36[2] = ___ZN2re15NWProtocolLayer6updateEv_block_invoke;
          v36[3] = &__block_descriptor_48_e5_v8__0l;
          v36[4] = this;
          v36[5] = v8;
          nw_connection_batch(v12, v36);
        }
      }
      unsigned int v6 = *((_DWORD *)this + 50);
      if (v6 <= (int)v3 + 1) {
        int v13 = v3 + 1;
      }
      else {
        int v13 = *((_DWORD *)this + 50);
      }
      while (1)
      {
        uint64_t v7 = (v3 + 1);
        if (v13 - 1 == v3) {
          break;
        }
        LODWORD(v3) = v3 + 1;
        int v14 = v7;
        if ((*(_DWORD *)(*((void *)this + 23) + 24 * v7 + 8) & 0x80000000) != 0) {
          goto LABEL_23;
        }
      }
      int v14 = v13;
LABEL_23:
      LODWORD(v3) = v14;
    }
    while (v2 != v14);
  }
  uint64_t v15 = 0;
  if (v6)
  {
    int v16 = (int *)(*((void *)this + 23) + 8);
    while (1)
    {
      int v17 = *v16;
      v16 += 6;
      if (v17 < 0) {
        break;
      }
      if (v6 == ++v15)
      {
        LODWORD(v15) = v6;
        break;
      }
    }
  }
  if (v6 != v15)
  {
    uint64_t v18 = v15;
    do
    {
      re::NWProtocolLayer::scheduleReceives((uint64_t)this, *(void *)(*((void *)this + 23) + 24 * v18 + 16));
      if (*((_DWORD *)this + 50) <= (v15 + 1)) {
        int v19 = v15 + 1;
      }
      else {
        int v19 = *((_DWORD *)this + 50);
      }
      int v20 = v15;
      while (1)
      {
        uint64_t v18 = (v20 + 1);
        if (v19 - 1 == v20) {
          break;
        }
        ++v20;
        LODWORD(v15) = v18;
        if ((*(_DWORD *)(*((void *)this + 23) + 24 * v18 + 8) & 0x80000000) != 0) {
          goto LABEL_39;
        }
      }
      LODWORD(v15) = v19;
LABEL_39:
      ;
    }
    while (v6 != v15);
  }
  if (CFAbsoluteTimeGetCurrent() - *((double *)this + 13) > 1.0)
  {
    *((CFAbsoluteTime *)this + 13) = CFAbsoluteTimeGetCurrent();
    uint64_t v21 = *((unsigned int *)this + 50);
    if (v21)
    {
      uint64_t v22 = 0;
      dispatch_queue_t v23 = (int *)(*((void *)this + 23) + 8);
      while (1)
      {
        int v24 = *v23;
        v23 += 6;
        if (v24 < 0) {
          break;
        }
        if (v21 == ++v22)
        {
          LODWORD(v22) = *((_DWORD *)this + 50);
          break;
        }
      }
    }
    else
    {
      LODWORD(v22) = 0;
    }
    if (v21 != v22)
    {
      uint64_t v25 = v22;
      unsigned int v26 = *((_DWORD *)this + 50);
      do
      {
        uint64_t v27 = *(void *)(*((void *)this + 23) + 24 * v25 + 16);
        unint64_t v28 = *(NSObject **)(v27 + 1768);
        if (v28 && *(_DWORD *)(v27 + 1776) == 3)
        {
          unint64_t v29 = *(NSObject **)(v27 + 1848);
          if (v29)
          {
            unint64_t v30 = *((id *)this + 20);
            nw_data_transfer_report_collect(v29, v30, *(nw_data_transfer_report_collect_block_t *)(v27 + 1832));

            unint64_t v31 = *(void **)(v27 + 1848);
            *(void *)(v27 + 1848) = 0;

            unint64_t v28 = *(NSObject **)(v27 + 1768);
          }
          nw_data_transfer_report_t new_data_transfer_report = nw_connection_create_new_data_transfer_report(v28);
          uint64_t v33 = *(void **)(v27 + 1848);
          *(void *)(v27 + 1848) = new_data_transfer_report;

          unsigned int v26 = *((_DWORD *)this + 50);
        }
        if (v26 <= (int)v22 + 1) {
          unsigned int v34 = v22 + 1;
        }
        else {
          unsigned int v34 = v26;
        }
        while (1)
        {
          uint64_t v25 = (v22 + 1);
          if (v34 - 1 == v22) {
            break;
          }
          LODWORD(v22) = v22 + 1;
          unsigned int v35 = v25;
          if ((*(_DWORD *)(*((void *)this + 23) + 24 * v25 + 8) & 0x80000000) != 0) {
            goto LABEL_61;
          }
        }
        unsigned int v35 = v34;
LABEL_61:
        LODWORD(v22) = v35;
      }
      while (v21 != v35);
    }
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v37);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 54);
}

uint64_t ___ZN2re15NWProtocolLayer6updateEv_block_invoke(uint64_t a1)
{
  int v1 = 0;
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  do
  {
    uint64_t result = re::PacketQueue::dequeue((re::PacketQueue *)(v3 + 40 * (void)v1 + 912));
    if (result)
    {
      uint64_t v5 = result;
      do
      {
        message = nw_framer_protocol_create_message(*(nw_protocol_definition_t *)(v2 + 136));
        nw_framer_message_set_value(message, "channel", v1, 0);
        uint64_t v7 = nw_content_context_create("re-nw");
        nw_content_context_set_metadata_for_protocol(v7, message);
        uint64_t v8 = dispatch_data_create(*(const void **)(v5 + 16), *(unsigned int *)(v5 + 24), 0, 0);
        atomic_fetch_add((atomic_uint *volatile)(v3 + 1856), 1u);
        nw_connection_send(*(nw_connection_t *)(v3 + 1768), v8, v7, 1, *(nw_connection_send_completion_t *)(v3 + 1816));
        if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyNetworkTracing(0, 0)) {
          kdebug_trace();
        }
        re::PacketPool::free(*(re::PacketPool **)(v2 + 24), (re::Packet *)v5);

        uint64_t result = re::PacketQueue::dequeue((re::PacketQueue *)(v3 + 40 * (void)v1 + 912));
        uint64_t v5 = result;
      }
      while (result);
    }
    int v1 = (char *)v1 + 1;
  }
  while (v1 != (void *)10);
  return result;
}

void re::NWProtocolLayer::scheduleReceives(uint64_t a1, uint64_t a2)
{
  re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(a1 + 160));
  if (*(void *)(a2 + 1768) && *(_DWORD *)(a2 + 1776) == 3 && !*(unsigned char *)(a2 + 1864))
  {
    unsigned int v4 = atomic_load((unsigned int *)(a2 + 1860));
    unsigned int v5 = *(_DWORD *)(a1 + 80);
    if (!v5) {
      unsigned int v5 = 10;
    }
    if (v4 < v5)
    {
      unint64_t v6 = 0;
      for (uint64_t i = 1344; i != 1744; i += 40)
        v6 += atomic_load_explicit((atomic_ullong *volatile)(a2 + i), memory_order_acquire);
      unint64_t v8 = *(void *)(a1 + 88);
      if (!v8) {
        unint64_t v8 = 10485760;
      }
      if (v6 < v8)
      {
        uint64_t v9 = *(NSObject **)(a2 + 1768);
        v10[0] = MEMORY[0x263EF8330];
        v10[1] = 3221225472;
        v10[2] = ___ZN2re15NWProtocolLayer16scheduleReceivesEPNS_16NWProtocolHandleE_block_invoke;
        v10[3] = &__block_descriptor_48_e5_v8__0l;
        v10[4] = a1;
        v10[5] = a2;
        nw_connection_batch(v9, v10);
      }
    }
  }
}

void ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke(uint64_t a1, int a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  if (v3)
  {
    id v6 = *(id *)(a1 + 40);
    id v7 = a3;
    re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(v3 + 160));
    unint64_t v8 = (re::NWProtocolHandle *)re::NWProtocolLayer::handleFor(v3, v6);
    if (v8)
    {
      uint64_t v9 = v8;
      *((_DWORD *)v8 + 444) = a2;
      uint64_t v10 = *re::networkLogObjects(v8);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        BOOL v11 = v10;
        int v15 = 134218498;
        int v16 = v9;
        __int16 v17 = 2080;
        uint64_t v18 = nw_connection_state_to_string();
        __int16 v19 = 2080;
        uint64_t v20 = nw_connection_state_to_string();
        _os_log_impl(&dword_228C70000, v11, OS_LOG_TYPE_INFO, "NWProtocolLayer.onConnectionStateChanged %p prevState=%s newState=%s", (uint8_t *)&v15, 0x20u);
      }
      switch(a2)
      {
        case 5:
          re::NWProtocolHandle::reset(v9);
          break;
        case 4:
          uint64_t v14 = *(void *)(v3 + 112);
          if (v14 && !*((unsigned char *)v9 + 1864))
          {
            if (v7) {
              (*(void (**)(uint64_t, uint64_t, re::NWProtocolHandle *, uint64_t))(*(void *)v14 + 16))(v14, v3, v9, 2);
            }
            else {
              (*(void (**)(uint64_t, uint64_t, re::NWProtocolHandle *, unsigned char *))(*(void *)v14 + 8))(v14, v3, v9, (unsigned char *)v9 + 1784);
            }
          }
          break;
        case 3:
          int v12 = *(void (****)(void, uint64_t, re::NWProtocolHandle *, uint64_t))(v3 + 112);
          if (v12) {
            (**v12)(v12, v3, v9, (uint64_t)v9 + 1784);
          }
          re::NWProtocolLayer::scheduleReceives(v3, (uint64_t)v9);
          break;
      }
    }
    else
    {
      int v13 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        LOWORD(v15) = 0;
        _os_log_impl(&dword_228C70000, v13, OS_LOG_TYPE_INFO, "NWProtocolLayer.onConnectionStateChanged for unknown connection", (uint8_t *)&v15, 2u);
      }
    }
  }
}

uint64_t ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 32) + 8);
  if (v1)
  {
    id v2 = *(id *)(result + 40);
    re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(v1 + 160));
    uint64_t v3 = re::NWProtocolLayer::handleFor(v1, v2);

    if (v3)
    {
      atomic_fetch_add((atomic_uint *volatile)(v3 + 1856), 0xFFFFFFFF);
      uint64_t result = re::internal::enableSignposts(0, 0);
      if (!result) {
        return result;
      }
      uint64_t result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
      if (!result) {
        return result;
      }
    }
    else
    {
      uint64_t result = re::internal::enableSignposts(0, 0);
      if (!result) {
        return result;
      }
      uint64_t result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
      if (!result) {
        return result;
      }
    }
    return kdebug_trace();
  }
  return result;
}

void ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_3(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (v5)
  {
    id v10 = *(id *)(a1 + 40);
    BOOL v11 = a2;
    int v12 = a3;
    int v13 = a5;
    re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(v5 + 160));
    uint64_t v14 = re::NWProtocolLayer::handleFor(v5, v10);
    if (v14)
    {
      uint64_t v15 = v14;
      atomic_fetch_add((atomic_uint *volatile)(v14 + 1860), 0xFFFFFFFF);
      if (v11 && v12)
      {
        uint64_t v30 = 0;
        unint64_t v31 = &v30;
        uint64_t v32 = 0x2020000000;
        char v33 = 0;
        int v16 = nw_content_context_copy_protocol_metadata(v12, *(nw_protocol_definition_t *)(v5 + 136));
        __int16 v17 = v16;
        if (v16 && nw_protocol_metadata_is_framer_message(v16))
        {
          access_value[0] = MEMORY[0x263EF8330];
          access_value[1] = 3221225472;
          access_value[2] = ___ZN2re15NWProtocolLayer16onReceiveMessageEPU27objcproto16OS_nw_connection8NSObjectPU27objcproto16OS_dispatch_dataS1_PU32objcproto21OS_nw_content_contextS1_bPU22objcproto11OS_nw_errorS1__block_invoke;
          access_value[3] = &unk_264854688;
          access_value[4] = &v30;
          nw_framer_message_access_value(v17, "channel", access_value);
        }

        uint64_t v18 = *(re::PacketPool **)(v5 + 24);
        size_t size = dispatch_data_get_size(v11);
        uint64_t v20 = v11;
        uint64_t v21 = re::PacketPool::allocate(v18, size);
        *((_DWORD *)v21 + 6) = size;
        uint64_t v22 = *((void *)v21 + 2);
        *(void *)&long long applier = MEMORY[0x263EF8330];
        *((void *)&applier + 1) = 3221225472;
        unsigned int v35 = ___ZN12_GLOBAL__N_119newPacketForContentEPN2re10PacketPoolEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
        int v36 = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
        uint64_t v37 = v22;
        dispatch_data_apply(v20, &applier);

        if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyNetworkTracing(0, 0)) {
          kdebug_trace();
        }
        uint64_t v23 = *(void *)(v5 + 112);
        if (v23) {
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void, void))(*(void *)v23 + 24))(v23, v5, v15, *((unsigned __int8 *)v31 + 24), *((void *)v21 + 2), *((unsigned int *)v21 + 6));
        }
        re::PacketPool::free(*(re::PacketPool **)(v5 + 24), (re::Packet *)v21);
        _Block_object_dispose(&v30, 8);
      }
      else if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyNetworkTracing(0, 0))
      {
        kdebug_trace();
      }
      if (v12 && a4 && (BOOL is_final = nw_content_context_get_is_final(v12)))
      {
        if (!*(unsigned char *)(v15 + 1864) && *(_DWORD *)(v15 + 1776) == 3)
        {
          uint64_t v27 = *re::networkLogObjects((re *)is_final);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
          {
            LODWORD(applier) = 134217984;
            *(void *)((char *)&applier + 4) = v15;
            _os_log_impl(&dword_228C70000, v27, OS_LOG_TYPE_INFO, "NWProtocolLayer.onReceiveMessage %p readClosed", (uint8_t *)&applier, 0xCu);
          }
          *(unsigned char *)(v15 + 1864) = 1;
          uint64_t v28 = *(void *)(v5 + 112);
          if (v28) {
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v28 + 8))(v28, v5, v15, v15 + 1784);
          }
        }
      }
      else
      {
        re::NWProtocolLayer::scheduleReceives(v5, v15);
      }
    }
    else
    {
      uint64_t error_domain = re::internal::enableSignposts(0, 0);
      if (error_domain)
      {
        uint64_t error_domain = re::internal::enableHighFrequencyNetworkTracing(0, 0);
        if (error_domain) {
          uint64_t error_domain = kdebug_trace();
        }
      }
      if (!v13
        || (uint64_t error_domain = nw_error_get_error_domain(v13), error_domain != 1)
        || (uint64_t error_domain = nw_error_get_error_code(v13), error_domain != 89))
      {
        uint64_t v25 = *re::networkLogObjects((re *)error_domain);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
        {
          LOWORD(applier) = 0;
          _os_log_impl(&dword_228C70000, v25, OS_LOG_TYPE_INFO, "NWProtocolLayer.onReceiveMessage for unknown connection", (uint8_t *)&applier, 2u);
        }
      }
    }
  }
}

void ___ZN2re15NWProtocolLayer13addConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    report = a2;
    id v4 = v3;
    re::NWProtocolLayer::assertNetworkQueue(*(re::NWProtocolLayer **)(v2 + 160));
    uint64_t v5 = re::NWProtocolLayer::handleFor(v2, v4);

    if (v5)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 1760));
      int v6 = *(_DWORD *)(v5 + 1736);
      int v7 = *(_DWORD *)(v5 + 1744);
      int v8 = *(_DWORD *)(v5 + 1748);
      int v9 = *(_DWORD *)(v5 + 1752);
      int v10 = *(_DWORD *)(v5 + 1756);
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 1760));
      uint32_t v11 = *MEMORY[0x263F14460];
      uint64_t sent_transport_byte_count = nw_data_transfer_report_get_sent_transport_byte_count(report, *MEMORY[0x263F14460]);
      uint64_t sent_transport_retransmitted_byte_count = nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(report, v11);
      int v14 = v7 + nw_data_transfer_report_get_received_transport_byte_count(report, v11);
      int v15 = v8 + sent_transport_byte_count;
      int v16 = v9 + nw_data_transfer_report_get_received_ip_packet_count(report, v11);
      int v17 = v10 + nw_data_transfer_report_get_sent_ip_packet_count(report, v11);
      if (sent_transport_byte_count) {
        float v18 = (double)sent_transport_retransmitted_byte_count / (double)sent_transport_byte_count;
      }
      else {
        float v18 = 0.0;
      }
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 1760));
      *(_DWORD *)(v5 + 1736) = v6;
      *(float *)(v5 + 1740) = v18;
      *(_DWORD *)(v5 + 1744) = v14;
      *(_DWORD *)(v5 + 1748) = v15;
      *(_DWORD *)(v5 + 1752) = v16;
      *(_DWORD *)(v5 + 1756) = v17;
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 1760));
    }
  }
}

void re::NWProtocolHandle::reset(re::NWProtocolHandle *this)
{
  uint64_t v2 = (void *)*((void *)this + 221);
  *((void *)this + 221) = 0;

  *((_DWORD *)this + 444) = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  re::DynamicString::setCapacity(&v9, 0);
  re::DynamicString::operator=((re::NWProtocolHandle *)((char *)this + 1784), (re::DynamicString *)&v9);
  if (v9 && (v10 & 1) != 0) {
    (*(void (**)(void))(*v9 + 40))();
  }
  id v4 = (void *)*((void *)this + 227);
  *((void *)this + 227) = 0;

  uint64_t v5 = (void *)*((void *)this + 228);
  *((void *)this + 228) = 0;

  int v6 = (void *)*((void *)this + 229);
  *((void *)this + 229) = 0;

  *((_WORD *)this + 932) = 0;
  int v7 = (void *)*((void *)this + 230);
  *((void *)this + 230) = 0;

  int v8 = (void *)*((void *)this + 231);
  *((void *)this + 231) = 0;
}

uint64_t re::NWProtocolLayer::handleFor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (os_unfair_lock_s *)(a1 + 216);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
  uint64_t v5 = *(unsigned int *)(a1 + 200);
  if (v5)
  {
    uint64_t v6 = 0;
    int v7 = (int *)(*(void *)(a1 + 184) + 8);
    while (1)
    {
      int v8 = *v7;
      v7 += 6;
      if (v8 < 0) {
        break;
      }
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(a1 + 200);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if (v5 == v6)
  {
LABEL_18:
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v9 = v6;
    uint64_t v10 = *(void *)(a1 + 184);
    while (1)
    {
      uint64_t v11 = *(void *)(v10 + 24 * v9 + 16);
      if (*(id *)(v11 + 1768) == v3) {
        break;
      }
      if (v5 <= (int)v6 + 1) {
        int v12 = v6 + 1;
      }
      else {
        int v12 = v5;
      }
      while (1)
      {
        uint64_t v9 = (v6 + 1);
        if (v12 - 1 == v6) {
          break;
        }
        LODWORD(v6) = v6 + 1;
        int v13 = v9;
        if ((*(_DWORD *)(v10 + 24 * v9 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      int v13 = v12;
LABEL_17:
      LODWORD(v6) = v13;
      if (v5 == v13) {
        goto LABEL_18;
      }
    }
  }
  os_unfair_lock_unlock(v4);

  return v11;
}

uint64_t ___ZN2re15NWProtocolLayer16onReceiveMessageEPU27objcproto16OS_nw_connection8NSObjectPU27objcproto16OS_dispatch_dataS1_PU32objcproto21OS_nw_content_contextS1_bPU22objcproto11OS_nw_errorS1__block_invoke(uint64_t a1, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  return 1;
}

uint64_t ___ZN2re15NWProtocolLayer16scheduleReceivesEPNS_16NWProtocolHandleE_block_invoke(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)(a1 + 32) + 80)) {
    int v2 = *(_DWORD *)(*(void *)(a1 + 32) + 80);
  }
  else {
    int v2 = 10;
  }
  signed int v3 = atomic_load((unsigned int *)(*(void *)(a1 + 40) + 1860));
  if (v3 < v2)
  {
    do
    {
      atomic_fetch_add((atomic_uint *volatile)(*(void *)(a1 + 40) + 1860), 1u);
      nw_connection_receive_message(*(nw_connection_t *)(*(void *)(a1 + 40) + 1768), *(nw_connection_receive_completion_t *)(*(void *)(a1 + 40) + 1824));
      signed int v4 = atomic_load((unsigned int *)(*(void *)(a1 + 40) + 1860));
    }
    while (v4 < v2);
  }
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    uint64_t result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
    if (result)
    {
      return kdebug_trace();
    }
  }
  return result;
}

void re::NWProtocolLayer::wait(re::NWProtocolLayer *this, uint64_t a2)
{
}

void re::NWProtocolLayer::wakeup(re::NWProtocolLayer *this, uint64_t a2)
{
}

uint64_t re::NWProtocolLayer::setListener(uint64_t this, ProtocolLayerListener *a2)
{
  *(void *)(this + 112) = a2;
  return this;
}

unint64_t re::NWProtocolLayer::localAddresses(re::NWProtocolLayer *this, re::Address *a2, unint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)this + 16);
  if (!v3 || *(_DWORD *)(v3 + 40) != 2) {
    return 0;
  }
  port = (const char *)nw_listener_get_port(*(nw_listener_t *)(v3 + 32));
  if (*((unsigned char *)this + 48)) {
    int v8 = (re::Address *)*((void *)this + 7);
  }
  else {
    int v8 = (re::NWProtocolLayer *)((char *)this + 49);
  }
  if (*(unsigned char *)v8 && strcmp((const char *)v8, "0.0.0.0"))
  {
    if (a3)
    {
      re::Address::makeFromIPAndPort(v8, port, (re::DynamicString *)buf);
      re::DynamicString::operator=(a2, (re::DynamicString *)buf);
      if (*(void *)buf)
      {
        if (v28) {
          (*(void (**)(void))(**(void **)buf + 40))();
        }
      }
    }
    return 1;
  }
  uint64_t v25 = 0;
  uint64_t v10 = (re *)getifaddrs(&v25);
  if ((v10 & 0x80000000) != 0)
  {
    uint64_t v21 = *re::networkLogObjects(v10);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = v21;
      int v23 = *__error();
      *(_DWORD *)sockaddr buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v23;
      _os_log_impl(&dword_228C70000, v22, OS_LOG_TYPE_DEFAULT, "NWProtocolLayer: Unable to list network adapters(errno=%d).", buf, 8u);
    }
    return 0;
  }
  int v12 = v25;
  if (v25)
  {
    unint64_t v9 = 0;
    do
    {
      ifa_addr = v12->ifa_addr;
      if (ifa_addr)
      {
        unsigned int ifa_flags = v12->ifa_flags;
        if ((ifa_flags & 1) != 0 && ifa_addr->sa_family == 2)
        {
          int v15 = *(_DWORD *)&ifa_addr->sa_data[2];
          ifa_addr = (sockaddr *)((char *)ifa_addr + 4);
          int v14 = v15;
          if ((unsigned __int16)v15 != 65193 && ((ifa_flags & 8) == 0 || v14 == 16777343))
          {
            int v16 = (re::Address *)inet_ntop(2, ifa_addr, v26, 0x11u);
            if (v16)
            {
              if (v9 < a3)
              {
                re::Address::makeFromIPAndPort(v16, port, (re::DynamicString *)buf);
                re::DynamicString::operator=((re::Address *)((char *)a2 + 32 * v9), (re::DynamicString *)buf);
                if (*(void *)buf)
                {
                  if (v28) {
                    (*(void (**)(void))(**(void **)buf + 40))();
                  }
                }
              }
              ++v9;
            }
            else
            {
              int v17 = *re::networkLogObjects(0);
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                float v18 = v17;
                int v19 = *__error();
                *(_DWORD *)sockaddr buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v19;
                _os_log_impl(&dword_228C70000, v18, OS_LOG_TYPE_DEFAULT, "NWProtocolLayer: Failed to get string representation of ip(errno=%d).", buf, 8u);
              }
            }
          }
        }
      }
      int v12 = v12->ifa_next;
    }
    while (v12);
    uint64_t v20 = v25;
  }
  else
  {
    uint64_t v20 = 0;
    unint64_t v9 = 0;
  }
  MEMORY[0x22A6A9750](v20, ifa_addr);
  return v9;
}

uint64_t re::NWProtocolLayer::hostStats(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 200);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (int *)(*(void *)(a1 + 184) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 6;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a1 + 200);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    do
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 184) + 24 * v8 + 16);
      os_unfair_lock_lock((os_unfair_lock_t)(v9 + 1760));
      int v10 = *(_DWORD *)(v9 + 1736);
      float v11 = *(float *)(v9 + 1740);
      int32x4_t v16 = *(int32x4_t *)(v9 + 1744);
      os_unfair_lock_unlock((os_unfair_lock_t)(v9 + 1760));
      *(int32x4_t *)(a2 + 8) = vaddq_s32(*(int32x4_t *)(a2 + 8), v16);
      *(float *)(a2 + 4) = v11 + *(float *)(a2 + 4);
      *(_DWORD *)a2 += v10;
      if (*(_DWORD *)(a1 + 200) <= (v5 + 1)) {
        int v12 = v5 + 1;
      }
      else {
        int v12 = *(_DWORD *)(a1 + 200);
      }
      int v13 = v5;
      while (1)
      {
        uint64_t v8 = (v13 + 1);
        if (v12 - 1 == v13) {
          break;
        }
        ++v13;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(*(void *)(a1 + 184) + 24 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v5) = v12;
LABEL_17:
      ;
    }
    while (v4 != v5);
  }
  unsigned int v14 = *(_DWORD *)(a1 + 196);
  if (v14)
  {
    *(float *)(a2 + 4) = *(float *)(a2 + 4) / (float)v14;
    *(_DWORD *)a2 /= v14;
  }
  return 1;
}

uint64_t re::NWProtocolLayer::setDisconnectTimeout(uint64_t this, unsigned int a2)
{
  if (a2 <= 0x3E8) {
    unsigned int v2 = 1000;
  }
  else {
    unsigned int v2 = a2;
  }
  *(_DWORD *)(this + 96) = v2 / 0x3E8;
  return this;
}

uint64_t re::NWProtocolLayer::preferredPacketSize(re::NWProtocolLayer *this)
{
  return 0x10000;
}

uint64_t re::NWProtocolLayer::preferredThreadMode(re::NWProtocolLayer *this)
{
  return 2;
}

uint64_t re::ProtocolLayer::drainsPacketSink(re::ProtocolLayer *this)
{
  return 0;
}

void re::NWProtocolHandle::~NWProtocolHandle(id *this)
{
  re::NWProtocolHandle::~NWProtocolHandle(this);
  JUMPOUT(0x22A6A9430);
}

{
  uint64_t vars8;

  *this = &unk_26DD353F0;
  re::NWProtocolHandle::reset((re::NWProtocolHandle *)this);

  re::DynamicString::deinit((re::DynamicString *)(this + 223));
  re::ProtocolHandle::~ProtocolHandle((re::ProtocolHandle *)this);
}

uint64_t ___ZN12_GLOBAL__N_119newPacketForContentEPN2re10PacketPoolEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  return 1;
}

void re::HashSetBase<re::SharedPtr<re::NWProtocolHandle>,re::SharedPtr<re::NWProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::NWProtocolHandle>>,re::Hash<re::SharedPtr<re::NWProtocolHandle>>,re::EqualTo<re::SharedPtr<re::NWProtocolHandle>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)uint64_t v22 = v5;
      *(void *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        int v13 = (void *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            unint64_t v14 = *(v13 - 2);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashSetBase<re::SharedPtr<re::NWProtocolHandle>,re::SharedPtr<re::NWProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::NWProtocolHandle>>,re::Hash<re::SharedPtr<re::NWProtocolHandle>>,re::EqualTo<re::SharedPtr<re::NWProtocolHandle>>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 24 * v17) = v14;
            *(void *)(*(void *)(a1 + 16) + 24 * v17 + 16) = *v13;
            void *v13 = 0;
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

uint64_t re::SyncOwnershipRequest::write(re::SyncOwnershipRequest *this, re::BitWriter *a2)
{
  unsigned int v4 = *((_DWORD *)this + 1);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *(_DWORD *)this, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, v4, 0x20u);
  unsigned int v5 = *((_DWORD *)this + 3);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((_DWORD *)this + 2), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, v5, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int8 *)this + 16), 1u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((_DWORD *)this + 18), 0x20u);
  uint64_t v6 = (const void *)*((void *)this + 8);
  uint64_t v7 = *((unsigned int *)this + 18);
  return re::BitWriter::writeData(a2, v6, v7);
}

uint64_t re::SyncOwnershipRequest::read(re::SyncOwnershipRequest *this, re::BitReader *a2)
{
  re::BitReader::readUInt64(a2, (unint64_t *)this);
  re::BitReader::readUInt64(a2, (unint64_t *)this + 1);
  unsigned int v9 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 1u, &v9);
  *((unsigned char *)this + 16) = v9 != 0;
  unsigned int v10 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 0x20u, &v10);
  uint64_t result = 0;
  uint64_t v5 = v10;
  unsigned int v6 = *((_DWORD *)a2 + 2);
  uint64_t v7 = *((unsigned int *)a2 + 4);
  if (v10 <= v6 - v7)
  {
    if (*((unsigned char *)a2 + 12))
    {
      uint64_t result = 0;
      *((void *)this + 8) = 0;
      *((void *)this + 9) = v5;
    }
    else
    {
      *((void *)this + 8) = *(void *)a2 + v7;
      *((void *)this + 9) = v5;
      *((void *)a2 + 3) = 0;
      unsigned int v8 = v7 + v5;
      *((void *)a2 + 2) = v8;
      uint64_t result = 1;
      if (v8 > v6)
      {
        *((unsigned char *)a2 + 12) = 1;
        return 0;
      }
    }
  }
  return result;
}

uint64_t re::DynamicArray<unsigned char>::DynamicArray(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  unint64_t v3 = *(void *)(a2 + 8);
  if (v3)
  {
    re::DynamicArray<unsigned char>::setCapacity((void *)a1, v3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<unsigned char>::copy((void *)a1, 0, *(char **)a2, *(void *)(a2 + 8));
  }
  return a1;
}

void *re::DynamicArray<unsigned char>::copy(void *this, unint64_t a2, char *__src, size_t __len)
{
  if (!__len) {
    return this;
  }
  unint64_t v5 = a2;
  unsigned int v6 = this;
  size_t v7 = this[2];
  if (v7 + 1 <= a2)
  {
    uint64_t v12 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v13) = 136315906;
    *(void *)((char *)&v13 + 4) = "copy";
    WORD6(v13) = 1024;
    HIWORD(v13) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size_t size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, v5, v4, v12, v13);
    _os_crash();
    __break(1u);
  }
  size_t v4 = __len;
  size_t v8 = a2 + __len;
  if (__CFADD__(a2, __len)) {
    goto LABEL_12;
  }
  if (v7 >= v8)
  {
    this = memmove((void *)(this[4] + a2), __src, __len);
  }
  else
  {
    re::DynamicArray<unsigned char>::growCapacity(this, a2 + __len);
    uint64_t v10 = v6[2];
    int v11 = &__src[v10 - v5];
    if (v10 != v5)
    {
      memmove((void *)(v6[4] + v5), __src, v10 - v5);
      unint64_t v5 = v6[2];
    }
    this = memcpy((void *)(v6[4] + v5), v11, &__src[v4] - v11);
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

void *re::DynamicArray<unsigned char>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    size_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<unsigned char>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<unsigned char>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::entryIsAddable(re::SyncObject **a1, re::SyncObjectViewer *a2)
{
  unint64_t v2 = *a1;
  if (*a1)
  {
    while (!*(unsigned char *)(*(void *)(*((void *)v2 + 11) + 16) + 74))
    {
      unint64_t v2 = (re::SyncObject *)*((void *)v2 + 10);
      if (!v2) {
        return 0;
      }
    }
    if (*((void *)v2 + 12))
    {
      uint64_t result = (*(uint64_t (**)(re::SyncObjectViewer *))(*(void *)a2 + 16))(a2);
      if (!result) {
        return result;
      }
      BOOL v6 = *a1;
      uint64_t v7 = *((void *)a2 + 7);
      unint64_t LatestState = re::SyncObject::getLatestState(v6);
      if (!LatestState || *(void *)(LatestState + 88) != v7) {
        return !re::SyncObjectViewer::isViewChangePending(a2, v2);
      }
    }
  }
  return 0;
}

BOOL re::SyncCommitBuilder::shouldForward(unsigned char *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(*a2 + 80);
  if (v3)
  {
    do
    {
      uint64_t v4 = v2;
      uint64_t v2 = v3;
      if (*(unsigned char *)(*(void *)(*(void *)(v4 + 88) + 16) + 73)) {
        break;
      }
      uint64_t v3 = *(void *)(v3 + 80);
      uint64_t v4 = v2;
    }
    while (v3);
  }
  else
  {
    uint64_t v4 = *a2;
  }
  return *(unsigned char *)(v4 + 170) || *a1 || a1[1] != 0;
}

void re::SyncCommitBuilder::~SyncCommitBuilder(re::SyncCommitBuilder *this)
{
}

uint64_t re::SyncCommitBuilder::buildUpdate(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 28)) {
    BOOL v2 = *(void *)(a2 + 8) == *(void *)(*(void *)(result + 8) + 56);
  }
  else {
    BOOL v2 = 0;
  }
  if (v2) {
    return result;
  }
  uint64_t v4 = result;
  if (*(unsigned char *)(a2 + 28))
  {
    int v6 = *(_DWORD *)(result + 144);
    uint64_t v5 = (re::SyncCommitChannel *)(result + 144);
    if (v6)
    {
      uint64_t result = *(void *)(v4 + 160);
      goto LABEL_11;
    }
  }
  else
  {
    int v7 = *(_DWORD *)(result + 208);
    uint64_t v5 = (re::SyncCommitChannel *)(result + 208);
    if (v7)
    {
      uint64_t result = *(void *)(v4 + 224);
      goto LABEL_11;
    }
  }
  uint64_t result = re::SyncCommitChannel::newCommit(v5);
LABEL_11:
  uint64_t v8 = *(void *)(a2 + 48);
  if (v8)
  {
    unsigned int v9 = *(re::SyncObject ***)(a2 + 64);
    uint64_t v10 = &v9[3 * v8];
    int v11 = (void *)(result + 32);
    do
    {
      uint64_t v12 = *v9;
      long long v13 = (re::SyncObject *)*((void *)*v9 + 10);
      if (v13)
      {
        do
        {
          unint64_t v14 = v12;
          uint64_t v12 = v13;
          if (*(unsigned char *)(*(void *)(*((void *)v14 + 11) + 16) + 73)) {
            break;
          }
          long long v13 = (re::SyncObject *)*((void *)v13 + 10);
          unint64_t v14 = v12;
        }
        while (v13);
      }
      else
      {
        unint64_t v14 = *v9;
      }
      if (*((unsigned char *)v14 + 170) || *(unsigned char *)v4 || *(unsigned char *)(v4 + 1))
      {
        uint64_t result = re::entryIsAddable(v9, *(re::SyncObjectViewer **)(v4 + 8));
        if (result) {
          uint64_t result = (uint64_t)re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v11, (uint64_t *)v9);
        }
      }
      v9 += 3;
    }
    while (v9 != v10);
  }
  return result;
}

void re::SyncCommitBuilder::buildOwnershipChanges(uint64_t a1, re::SyncObject **a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v3 = a2;
    uint64_t v5 = &a2[a3];
    int v6 = (void *)(a1 + 304);
    do
    {
      int v7 = *v3;
      if (*v3)
      {
        uint64_t v8 = *v3;
        while (!*(unsigned char *)(*(void *)(*((void *)v8 + 11) + 16) + 74))
        {
          uint64_t v8 = (re::SyncObject *)*((void *)v8 + 10);
          if (!v8) {
            goto LABEL_26;
          }
        }
        if (*((void *)v8 + 12))
        {
          while (!*(unsigned char *)(*(void *)(*((void *)v7 + 11) + 16) + 74))
          {
            int v7 = (re::SyncObject *)*((void *)v7 + 10);
            if (!v7)
            {
              uint64_t v9 = 0;
              goto LABEL_13;
            }
          }
          uint64_t v9 = *((void *)v7 + 12);
LABEL_13:
          uint64_t v10 = (re *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), v9);
          if (v10)
          {
            int v11 = *re::networkLogObjects(v10);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
            {
              uint64_t v12 = *((void *)*v3 + 3);
              *(_DWORD *)sockaddr buf = 134217984;
              *(void *)&uint8_t buf[4] = v12;
              _os_log_impl(&dword_228C70000, v11, OS_LOG_TYPE_INFO, "[Ownership] Adding ownership changes for: %llu", buf, 0xCu);
            }
            BOOL v13 = re::SyncObject::takeOverLatestState(*v3);
            if (v13)
            {
              unint64_t v14 = *v3;
              *(void *)sockaddr buf = v14;
              if (v14)
              {
                unint64_t v15 = (char *)v14 + 8;
                unint64_t v16 = *v3;
              }
              else
              {
                unint64_t v16 = 0;
              }
              *(void *)&uint8_t buf[8] = re::SyncObject::latestStateHandle(v16);
              buf[16] &= 0xF0u;
              re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v6, (uint64_t)buf);
              if (*(void *)buf) {
            }
              }
            else
            {
              uint64_t v17 = *re::networkLogObjects((re *)v13);
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              {
                uint64_t v18 = *((void *)*v3 + 3);
                uint64_t v19 = *(void **)(*((void *)*v3 + 11) + 16);
                uint64_t v20 = v19[4];
                uint64_t v21 = v19[6];
                uint64_t v22 = (char *)v19[7];
                int v23 = (char *)v19 + 49;
                if (v21) {
                  int v23 = v22;
                }
                *(_DWORD *)sockaddr buf = 134218498;
                *(void *)&uint8_t buf[4] = v18;
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v20;
                __int16 v25 = 2080;
                unsigned int v26 = v23;
                _os_log_error_impl(&dword_228C70000, v17, OS_LOG_TYPE_ERROR, "Encountered sync object without snapshot while packing ownership broadcasts! (id: %llu, type: %llu[%s])", buf, 0x20u);
              }
            }
          }
        }
      }
LABEL_26:
      ++v3;
    }
    while (v3 != v5);
  }
}

void re::SyncCommitBuilder::buildViewAdd(uint64_t a1, re::SyncObject **a2)
{
  int v5 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = (re::SyncCommitChannel *)(a1 + 16);
  if (v5) {
    uint64_t v6 = *(void *)(a1 + 32);
  }
  else {
    uint64_t v6 = re::SyncCommitChannel::newCommit(v4);
  }
  re::SyncCommitBuilder::addToViewRecursive(a1, a2, v6);
}

void re::SyncCommitBuilder::addToViewRecursive(uint64_t a1, re::SyncObject **a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  int v5 = *a2;
  if (*((void *)*a2 + 8) == *((void *)*a2 + 9))
  {
    uint64_t v6 = *re::networkLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *((void *)*a2 + 3);
      uint64_t v8 = *(void **)(*((void *)*a2 + 11) + 16);
      uint64_t v9 = v8[4];
      uint64_t v10 = v8[6];
      int v11 = (char *)v8[7];
      uint64_t v12 = (char *)v8 + 49;
      if (v10) {
        uint64_t v12 = v11;
      }
      *(_DWORD *)uint64_t v21 = 134218498;
      *(void *)&v21[4] = v7;
      __int16 v22 = 2048;
      uint64_t v23 = v9;
      __int16 v24 = 2080;
      __int16 v25 = v12;
      _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "Sync object without snapshot while adding view to commit (id: %llu, type: %llu[%s]).", v21, 0x20u);
    }
  }
  else
  {
    uint64_t v14 = *(void *)(*(void *)(a1 + 8) + 56);
    unint64_t LatestState = re::SyncObject::getLatestState(v5);
    if ((!LatestState || *(void *)(LatestState + 88) != v14) && (*((unsigned char *)*a2 + 128) & 4) == 0) {
      re::SyncSnapshot::addToView((void *)(a3 + 32), a2);
    }
    uint64_t v16 = *((void *)*a2 + 25);
    if (v16)
    {
      uint64_t v17 = (uint64_t *)*((void *)*a2 + 27);
      uint64_t v18 = 8 * v16;
      do
      {
        uint64_t v19 = *v17;
        *(void *)uint64_t v21 = v19;
        if (v19) {
          id v20 = (id)(v19 + 8);
        }
        re::SyncCommitBuilder::addToViewRecursive(a1, v21, a3);
        if (*(void *)v21) {

        }
        ++v17;
        v18 -= 8;
      }
      while (v18);
    }
  }
}

void re::SyncCommitBuilder::buildViewRemoval(uint64_t a1, re::SyncObject **a2)
{
  int v5 = *(_DWORD *)(a1 + 80);
  uint64_t v4 = (re::SyncCommitChannel *)(a1 + 80);
  if (v5) {
    uint64_t v6 = *(void *)(a1 + 96);
  }
  else {
    uint64_t v6 = re::SyncCommitChannel::newCommit(v4);
  }
  re::SyncCommitBuilder::removeFromViewRecursive(a1, a2, v6);
}

void re::SyncCommitBuilder::removeFromViewRecursive(uint64_t a1, re::SyncObject **a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  int v5 = *a2;
  if (*((void *)*a2 + 8) == *((void *)*a2 + 9))
  {
    uint64_t v6 = *re::networkLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *((void *)*a2 + 3);
      uint64_t v8 = *(void **)(*((void *)*a2 + 11) + 16);
      uint64_t v9 = v8[4];
      uint64_t v10 = v8[6];
      int v11 = (char *)v8[7];
      uint64_t v12 = (char *)v8 + 49;
      if (v10) {
        uint64_t v12 = v11;
      }
      *(_DWORD *)uint64_t v21 = 134218498;
      *(void *)&v21[4] = v7;
      __int16 v22 = 2048;
      uint64_t v23 = v9;
      __int16 v24 = 2080;
      __int16 v25 = v12;
      _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "Sync object without snapshot while removing view from commit (id: %llu, type: %llu[%s]).", v21, 0x20u);
    }
  }
  else
  {
    if ((*((unsigned char *)v5 + 128) & 4) == 0
      || (uint64_t v14 = *(void *)(*(void *)(a1 + 8) + 56), (LatestState = re::SyncObject::getLatestState(v5)) == 0)
      || *(void *)(LatestState + 88) != v14)
    {
      re::SyncSnapshot::removeFromView((void *)(a3 + 32), a2);
    }
    uint64_t v16 = *((void *)*a2 + 25);
    if (v16)
    {
      uint64_t v17 = (uint64_t *)*((void *)*a2 + 27);
      uint64_t v18 = 8 * v16;
      do
      {
        uint64_t v19 = *v17;
        *(void *)uint64_t v21 = v19;
        if (v19) {
          id v20 = (id)(v19 + 8);
        }
        re::SyncCommitBuilder::removeFromViewRecursive(a1, v21, a3);
        if (*(void *)v21) {

        }
        ++v17;
        v18 -= 8;
      }
      while (v18);
    }
  }
}

re::SyncCommitChannel *re::SyncCommitBuilder::begin(re::SyncCommitBuilder *this)
{
  int v3 = *((_DWORD *)this + 4);
  BOOL v2 = (re::SyncCommitBuilder *)((char *)this + 16);
  if ((v3 - 1) <= 1) {
    re::SyncCommitChannel::newCommit(v2);
  }
  if ((*((_DWORD *)this + 20) - 1) <= 1) {
    re::SyncCommitChannel::newCommit((re::SyncCommitBuilder *)((char *)this + 80));
  }
  uint64_t result = (re::SyncCommitBuilder *)((char *)this + 144);
  if ((*((_DWORD *)this + 36) - 1) <= 1) {
    uint64_t result = (re::SyncCommitChannel *)re::SyncCommitChannel::newCommit(result);
  }
  int v6 = *((_DWORD *)this + 52);
  int v5 = (re::SyncCommitBuilder *)((char *)this + 208);
  if ((v6 - 1) <= 1)
  {
    return (re::SyncCommitChannel *)re::SyncCommitChannel::newCommit(v5);
  }
  return result;
}

uint64_t re::SyncCommitBuilder::end(void *a1, _anonymous_namespace_ *a2)
{
  uint64_t v11 = *(void *)(a1[1] + 56);
  v12[0] = 0;
  v12[1] = 0;
  uint64_t v13 = 0;
  int v14 = 0;
  uint64_t v18 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  int v17 = 0;
  re::SyncCommitChannel::endFrame((re::SyncCommitChannel *)(a1 + 2), (re::SyncCommitResult *)&v11);
  re::SyncCommitChannel::endFrame((re::SyncCommitChannel *)(a1 + 10), (re::SyncCommitResult *)&v11);
  re::SyncCommitChannel::endFrame((re::SyncCommitChannel *)(a1 + 18), (re::SyncCommitResult *)&v11);
  re::SyncCommitChannel::endFrame((re::SyncCommitChannel *)(a1 + 26), (re::SyncCommitResult *)&v11);
  if (a1[40]) {
    re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)((char *)&v15 + 8), (uint64_t)(a1 + 34));
  }
  uint64_t v4 = *((void *)&v16 + 1);
  unint64_t v5 = v13 + *((void *)a2 + 2) + *((void *)&v16 + 1);
  if (*((void *)a2 + 1) < v5)
  {
    re::DynamicArray<re::SyncCommit>::setCapacity(a2, v5);
    uint64_t v4 = *((void *)&v16 + 1);
  }
  if (v4)
  {
    uint64_t v6 = v18;
    uint64_t v7 = 72 * v4;
    do
    {
      re::DynamicArray<re::SyncCommit>::add(a2, v6);
      v6 += 72;
      v7 -= 72;
    }
    while (v7);
  }
  if (v13)
  {
    uint64_t v8 = v15;
    uint64_t v9 = 72 * v13;
    do
    {
      re::DynamicArray<re::SyncCommit>::add(a2, v8);
      v8 += 72;
      v9 -= 72;
    }
    while (v9);
  }
  re::DynamicArray<re::SyncCommit>::deinit((uint64_t)&v15 + 8);
  return re::DynamicArray<re::SyncCommit>::deinit((uint64_t)v12);
}

uint64_t re::SyncCommitChannel::endFrame(re::SyncCommitChannel *this, re::SyncCommitResult *a2)
{
  *((void *)this + 2) = 0;
  uint64_t v3 = *((void *)this + 5);
  if (v3)
  {
    uint64_t v5 = *((void *)this + 7);
    uint64_t v6 = v5 + 72 * v3;
    uint64_t v7 = (re::SyncCommitResult *)((char *)a2 + 48);
    do
    {
      if (*(void *)(v5 + 48))
      {
        if (*(_DWORD *)this == 2)
        {
          uint64_t v8 = re::SyncCommitResult::sharedCommit(a2, *((unsigned __int8 *)this + 4));
          if (*(void *)(v5 + 48))
          {
            uint64_t v9 = 0;
            unint64_t v10 = 0;
            uint64_t v11 = v8 + 32;
            do
            {
              re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v11, (uint64_t *)(*(void *)(v5 + 64) + v9));
              ++v10;
              v9 += 24;
            }
            while (v10 < *(void *)(v5 + 48));
          }
        }
        else
        {
          re::DynamicArray<re::SyncCommit>::add(v7, v5);
        }
      }
      v5 += 72;
    }
    while (v5 != v6);
  }
  return re::DynamicArray<re::SyncCommit>::clear((uint64_t)this + 24);
}

uint64_t re::SyncCommitChannel::newCommit(re::SyncCommitChannel *this)
{
  *((void *)&v4 + 1) = *((void *)this + 1);
  uint64_t v5 = 0;
  int v6 = 0;
  char v7 = 0;
  uint64_t v10 = 0;
  memset(v8, 0, sizeof(v8));
  int v9 = 0;
  LOBYTE(v4) = *((unsigned char *)this + 4);
  re::DynamicArray<re::SyncCommit>::add((re::SyncCommitChannel *)((char *)this + 24), &v4);
  uint64_t v2 = *((void *)this + 7) + 72 * *((void *)this + 5) - 72;
  *((void *)this + 2) = v2;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v8);
  return v2;
}

unsigned __int8 *re::SyncCommitResult::sharedCommit(re::SyncCommitResult *this, int a2)
{
  uint64_t v3 = *((void *)this + 3);
  if (v3)
  {
    long long v4 = (unsigned __int8 *)*((void *)this + 5);
    uint64_t v5 = 72 * v3;
    while (*v4 != a2)
    {
      v4 += 72;
      v5 -= 72;
      if (!v5) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    *((void *)&v7 + 1) = *(void *)this;
    uint64_t v8 = 0;
    int v9 = 0;
    char v10 = 0;
    uint64_t v13 = 0;
    memset(v11, 0, sizeof(v11));
    int v12 = 0;
    LOBYTE(v7) = a2;
    re::DynamicArray<re::SyncCommit>::add((re::SyncCommitResult *)((char *)this + 8), &v7);
    long long v4 = (unsigned __int8 *)(*((void *)this + 5) + 72 * *((void *)this + 3) - 72);
    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v11);
  }
  return v4;
}

_anonymous_namespace_ *re::TransportStream::TransportStream(_anonymous_namespace_ *a1, id *a2, uint64_t a3, uint64_t a4)
{
  ArcSharedObject::ArcSharedObject(a1, 0);
  *(void *)a1 = &unk_26DD35438;
  *((void *)a1 + 3) = &unk_26DD35490;
  *(void *)(v8 + 32) = 0;
  objc_copyWeak((id *)(v8 + 32), a2);
  *((void *)a1 + 5) = a3;
  *((void *)a1 + 6) = a4;
  return a1;
}

void re::TransportStream::~TransportStream(re::TransportStream *this)
{
  *(void *)this = &unk_26DD35438;
  uint64_t v3 = (id *)((char *)this + 32);
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 3) = &unk_26DD35490;
  if (v2) {
    long long v4 = (re::Transport *)(v2 - 8);
  }
  else {
    long long v4 = 0;
  }
  re::Transport::removeStream(v4, *((void *)this + 5), *((void *)this + 6));
  objc_destroyWeak(v3);
  *uint64_t v3 = 0;
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

uint64_t ___Z20nw_framer_skip_bytesPU23objcproto12OS_nw_framer8NSObjectm_block_invoke(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t re::SharedAppSyncPacker::packCommit(unsigned __int8 *a1, uint64_t a2, re::BitWriter *this, uint64_t a4, unint64_t a5)
{
  long long v7 = this;
  uint64_t v84 = *MEMORY[0x263EF8340];
  re::BitWriter::alignToByte(this);
  uint64_t v11 = (_anonymous_namespace_ *)re::BitWriter::bytesLeft(v7, v10);
  LODWORD(v12) = *((_DWORD *)v7 + 6);
  if (*((_DWORD *)v7 + 7)) {
    uint64_t v12 = (v12 + 1);
  }
  else {
    uint64_t v12 = v12;
  }
  uint64_t v75 = v7;
  int v76 = v12;
  uint64_t v77 = 0;
  uint64_t v64 = *((void *)v7 + 1) + v12;
  unsigned int v65 = 0;
  unsigned int v66 = v11;
  uint64_t v13 = &v64;
  uint64_t v67 = &v75;
  uint64_t v68 = re::SharedAppSyncPacker::packCommit(re::SyncCommit const&,re::BitWriter &,re::SyncObjectWriteContext const&,unsigned long)::$_0::__invoke;
  unint64_t v70 = 0;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  re::DynamicString::setCapacity(&v69, 0);
  int v73 = 6;
  uint64_t v74 = 0;
  uint64_t v77 = &v64;
  if (*(void *)(a2 + 48) >= 0xFFFFFFFFuLL)
  {
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) ", "commit.snapshot.size() < ~uint32_t()", "writeCommit", 72);
    _os_crash();
    __break(1u);
    goto LABEL_81;
  }
  LODWORD(v13) = v65;
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)&v64);
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>((re::snapshot::EncoderOPACK *)&v64, (unsigned __int8 *)a2);
  if ((*(unsigned char *)a2 & 2) != 0) {
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned long long>((re::snapshot::EncoderOPACK *)&v64, (uint64_t *)(a2 + 16));
  }
  re::snapshot::EncoderOPACK::endObject((unsigned int *)&v64);
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)&v64);
  uint64_t v15 = v65;
  if (v65 >= v66)
  {
LABEL_81:
    if ((re::snapshot::Encoder::grow((re::snapshot::Encoder *)&v64, v15 + 1) & 1) == 0)
    {
      uint64_t v57 = 0;
      unsigned int v65 = v13;
      goto LABEL_72;
    }
  }
  uint64_t v61 = v7;
  if (*(void *)(a2 + 48) <= a5)
  {
    uint64_t v17 = 0;
    unsigned int v16 = 0;
    goto LABEL_71;
  }
  uint64_t v60 = a1;
  unsigned int v16 = 0;
  uint64_t v17 = 0;
  uint64_t v62 = a2;
  while (1)
  {
    uint64_t v18 = *(void *)(a2 + 64);
    uint64_t v19 = (uint64_t *)(v18 + 24 * a5);
    uint64_t v20 = *v19;
    uint64_t v21 = *(void *)(*(void *)(*(void *)(*v19 + 88) + 16) + 128);
    if (v21)
    {
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(v21 + 16))(v21, a4))
      {
        ++v16;
        goto LABEL_54;
      }
      uint64_t v20 = *v19;
    }
    unsigned int v63 = v65;
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)&v64, *(void *)(v20 + 24));
    if ((*(unsigned char *)(v18 + 24 * a5 + 16) & 2) != 0) {
      unsigned __int8 v22 = 5;
    }
    else {
      unsigned __int8 v22 = 1;
    }
    unsigned __int8 v78 = v22;
    uint64_t v23 = *(void **)(v20 + 80);
    __int16 v24 = (void *)v20;
    if (v23)
    {
      __int16 v25 = (void *)v20;
      do
      {
        __int16 v24 = v25;
        __int16 v25 = v23;
        if (*(unsigned char *)(*(void *)(v24[11] + 16) + 73)) {
          break;
        }
        uint64_t v23 = (void *)v23[10];
        __int16 v24 = v25;
      }
      while (v23);
    }
    if (!v24[20] && v24[17]) {
      unsigned __int8 v78 = v22 | 0x10;
    }
    re::snapshot::EncoderOPACK::beginObject((unsigned int *)&v64);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>((re::snapshot::EncoderOPACK *)&v64, &v78);
    *(_WORD *)sockaddr buf = *(_WORD *)(v20 + 176);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned short>((re::snapshot::EncoderOPACK *)&v64, (unsigned __int16 *)buf);
    uint64_t v26 = *(void *)(v20 + 80);
    if (v26)
    {
      uint64_t v27 = (void *)(v26 + 8);
      id v28 = (id)(v26 + 8);
    }
    else
    {
      re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,re::SyncOwnershipInfo>((re::snapshot::EncoderOPACK *)&v64, v20 + 136);
    }
    *(void *)sockaddr buf = *(void *)(*(void *)(*(void *)(v20 + 88) + 16) + 32);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<6,unsigned long long>((re::snapshot::EncoderOPACK *)&v64, (uint64_t *)buf);
    if (v78)
    {
      uint64_t v29 = *(void *)(v20 + 80);
      if (v29)
      {
        uint64_t v30 = (void *)(v29 + 8);
        id v31 = (id)(v29 + 8);

        uint64_t v32 = *(void *)(v20 + 80);
        if (v32) {
          id v33 = (id)(v32 + 8);
        }
        *(void *)sockaddr buf = *(void *)(*(void *)(*(void *)(v32 + 88) + 16) + 32);
        re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<8,unsigned long long>((re::snapshot::EncoderOPACK *)&v64, (uint64_t *)buf);

        uint64_t v34 = *(void *)(v20 + 80);
        if (v34) {
          id v35 = (id)(v34 + 8);
        }
        *(void *)sockaddr buf = *(void *)(v34 + 24);
        re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<9,unsigned long long>((re::snapshot::EncoderOPACK *)&v64, (uint64_t *)buf);
      }
    }
    uint64_t v36 = v65;
    if (v65 >= v66)
    {
      re::snapshot::EncoderOPACK::writeInteger((unsigned int *)&v64, 11);
    }
    else
    {
      ++v65;
      *(unsigned char *)(v64 + v36) = 19;
    }
    unint64_t LatestState = re::SyncObject::getLatestState((re::SyncObject *)v20);
    if (LatestState)
    {
      unint64_t v38 = LatestState;
      unsigned int v39 = *(_DWORD *)(LatestState + 24);
      unint64_t v40 = *(_DWORD *)(LatestState + 28) ? v39 + 1 : v39;
      re::snapshot::EncoderOPACK::beginData((unsigned int *)&v64, v40, v40);
      unsigned int v41 = *(_DWORD *)(v38 + 24);
      size_t v42 = *(_DWORD *)(v38 + 28) ? v41 + 1 : v41;
      re::snapshot::Encoder::writeRaw<true>((unsigned int *)&v64, *(void **)(v38 + 8), v42);
    }
    else
    {
      nw_listener_t v43 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        uint64_t v48 = *(void *)(v20 + 24);
        unint64_t v49 = *(void **)(*(void *)(v20 + 88) + 16);
        uint64_t v50 = v49[4];
        uint64_t v51 = v49[6];
        uint64_t v52 = (char *)v49[7];
        unint64_t v53 = (char *)v49 + 49;
        if (v51) {
          unint64_t v53 = v52;
        }
        *(_DWORD *)sockaddr buf = 134218498;
        *(void *)&uint8_t buf[4] = v48;
        __int16 v80 = 2048;
        uint64_t v81 = v50;
        __int16 v82 = 2080;
        uint64_t v83 = v53;
        _os_log_error_impl(&dword_228C70000, v43, OS_LOG_TYPE_ERROR, "Could not find latest state for object (id: %llu, type: %llu[%s]).", buf, 0x20u);
      }
    }
    id v44 = re::snapshot::EncoderOPACK::endObject((unsigned int *)&v64);
    if ((v70 & 1) != 0 ? v70 >> 1 : v70 >> 1) {
      break;
    }
    if (v65 >= v66 && !re::snapshot::Encoder::grow((re::snapshot::Encoder *)&v64, v65 + 1)) {
      goto LABEL_70;
    }
    ++v17;
    uint64_t v46 = *(void *)a4;
    if (*(void *)a4)
    {
      (*(void (**)(unsigned char *__return_ptr))(**(void **)(a4 + 8) + 32))(buf);
      if (*(void *)buf) {

      }
      uint64_t v47 = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 80))(v46);
      re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::raise(v47, v46);
      a2 = v62;
    }
LABEL_54:
    if (++a5 >= *(void *)(a2 + 48)) {
      goto LABEL_71;
    }
  }
  int v54 = *v60;
  uint64_t v55 = *re::networkLogObjects((re *)v44);
  if (v54)
  {
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
    {
      if (v70) {
        uint64_t v56 = v71;
      }
      else {
        uint64_t v56 = (char *)&v70 + 1;
      }
      *(_DWORD *)sockaddr buf = 136315138;
      *(void *)&uint8_t buf[4] = v56;
      _os_log_debug_impl(&dword_228C70000, v55, OS_LOG_TYPE_DEBUG, "Error writing OPACK object data: %s", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
  {
    if (v70) {
      uint64_t v59 = v71;
    }
    else {
      uint64_t v59 = (char *)&v70 + 1;
    }
    *(_DWORD *)sockaddr buf = 136315138;
    *(void *)&uint8_t buf[4] = v59;
    _os_log_error_impl(&dword_228C70000, v55, OS_LOG_TYPE_ERROR, "Error writing OPACK object data: %s", buf, 0xCu);
  }
LABEL_70:
  unsigned int v65 = v63;
LABEL_71:
  re::snapshot::EncoderOPACK::endObject((unsigned int *)&v64);
  uint64_t v57 = v17 + v16;
  LODWORD(v13) = v65;
  long long v7 = v61;
LABEL_72:
  re::BitWriter::rollbackTo((uint64_t)v7, (v13 + v76));
  if (v69 && (v70 & 1) != 0) {
    (*(void (**)(void))(*v69 + 40))();
  }
  return v57;
}

unsigned int *re::snapshot::EncoderOPACK::beginObject(unsigned int *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[2];
  if (v2 < this[3]) {
    goto LABEL_2;
  }
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v2 + 1);
  if (this)
  {
    LODWORD(v2) = v1[2];
LABEL_2:
    uint64_t v3 = *(void *)v1;
    void v1[2] = v2 + 1;
    *(unsigned char *)(v3 + v2) = -17;
  }
  return this;
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>(re::snapshot::EncoderOPACK *this, unsigned __int8 *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 9;
  }
  int v6 = *a2;
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, v6);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 2);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 10;
  }
  uint64_t v6 = *a2;
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, v6);
}

unsigned int *re::snapshot::EncoderOPACK::endObject(unsigned int *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[2];
  if (v2 < this[3]) {
    goto LABEL_2;
  }
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v2 + 1);
  if (this)
  {
    LODWORD(v2) = v1[2];
LABEL_2:
    uint64_t v3 = *(void *)v1;
    void v1[2] = v2 + 1;
    *(unsigned char *)(v3 + v2) = 3;
  }
  return this;
}

void re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::raise(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3) {
    re::Event<re::SyncViewManager,re::SyncView *>::doDeferredActions((_anonymous_namespace_ *)a1);
  }
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned short>(re::snapshot::EncoderOPACK *this, unsigned __int16 *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 2);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 10;
  }
  int v6 = *a2;
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, v6);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,re::SyncOwnershipInfo>(re::snapshot::EncoderOPACK *this, uint64_t a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 3);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 11;
  }
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)this);
  re::snapshotMapFields(this, a2);
  return re::snapshot::EncoderOPACK::endObject((unsigned int *)this);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<6,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 6);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 14;
  }
  uint64_t v6 = *a2;
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, v6);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<8,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 8);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 16;
  }
  uint64_t v6 = *a2;
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, v6);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<9,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 9);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 17;
  }
  uint64_t v6 = *a2;
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, v6);
}

unsigned int *re::snapshot::Encoder::writeRaw<true>(unsigned int *this, void *__src, size_t __len)
{
  uint64_t v5 = this;
  uint64_t v6 = this[2];
  if (v6 + __len <= this[3])
  {
    if (!__len)
    {
LABEL_4:
      void v5[2] = v6 + __len;
      return this;
    }
LABEL_3:
    this = (unsigned int *)memmove((void *)(*(void *)v5 + v6), __src, __len);
    LODWORD(v6) = v5[2];
    goto LABEL_4;
  }
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v6 + __len);
  if (this)
  {
    LODWORD(v6) = v5[2];
    if (!__len) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  return this;
}

uint64_t re::SharedAppSyncPacker::packCommit(re::SyncCommit const&,re::BitWriter &,re::SyncObjectWriteContext const&,unsigned long)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(re::BitWriter **)a1;
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  re::BitWriter::rollbackTo(*(void *)a1, (*(_DWORD *)(*(void *)(a1 + 16) + 8) + v5));
  (*(void (**)(re::BitWriter *, uint64_t))(*(void *)v4 + 16))(v4, a3);
  re::BitWriter::bytesLeft(v4, v6);
  return *((void *)v4 + 1) + v5;
}

uint64_t re::snapshot::Encoder::grow(re::snapshot::Encoder *this, unint64_t a2)
{
  uint64_t v4 = (const void *)(*((uint64_t (**)(void, void, unint64_t))this + 3))(*((void *)this + 2), *(void *)this, a2);
  *(void *)this = v4;
  *((_DWORD *)this + 3) = v5;
  if (v4) {
    BOOL v6 = a2 > v5;
  }
  else {
    BOOL v6 = 1;
  }
  uint64_t v7 = !v6;
  if (v6) {
    re::snapshot::Encoder::error(this, "couldn't grow buffer to %zu bytes (buffer = %p, capacity = %d)", a2, v4, v5);
  }
  return v7;
}

double re::SyncView::SyncView(re::SyncView *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD35508;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  *(void *)&double result = 0x7FFFFFFFLL;
  *(void *)((char *)this + 76) = 0x7FFFFFFFLL;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 28) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  return result;
}

void re::SyncView::~SyncView(re::SyncView *this)
{
  *(void *)this = &unk_26DD35508;
  while (*((void *)this + 13))
    re::SyncView::removeFromViewersAtWithoutNotifying((uint64_t)this, 0);
  uint64_t v2 = *((void *)this + 11);
  if (v2)
  {
    if (*((void *)this + 15)) {
      (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    }
    *((void *)this + 15) = 0;
    *((void *)this + 12) = 0;
    *((void *)this + 13) = 0;
    *((void *)this + 11) = 0;
    ++*((_DWORD *)this + 28);
  }
  re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)this + 5);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::SyncView::~SyncView(this);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::SyncView::removeFromViewersAtWithoutNotifying(uint64_t this, unint64_t a2)
{
  unint64_t v2 = *(void *)(this + 104);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v3 = *(void *)(*(void *)(this + 120) + 8 * a2);
  uint64_t v4 = *(void **)(v3 + 40);
  unint64_t v5 = *(void *)(v3 + 24);
  BOOL v6 = v4;
  if (v5)
  {
    uint64_t v7 = 8 * v5;
    BOOL v6 = *(void **)(v3 + 40);
    while (*v6 != this)
    {
      ++v6;
      v7 -= 8;
      if (!v7)
      {
        BOOL v6 = &v4[v5];
        break;
      }
    }
  }
  unint64_t v8 = v6 - v4;
  if (v8 != v5)
  {
    if (v5 > v8)
    {
      if (v5 - 1 > v8) {
        v4[v8] = v4[v5 - 1];
      }
      *(void *)(v3 + 24) = v5 - 1;
      ++*(_DWORD *)(v3 + 32);
      goto LABEL_12;
    }
LABEL_16:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_12:
  if (v2 - 1 > a2) {
    *(void *)(*(void *)(this + 120) + 8 * a2) = *(void *)(*(void *)(this + 120) + 8 * v2 - 8);
  }
  *(void *)(this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = v2 - 1;
  ++*(_DWORD *)(this + 112);
  return this;
}

void re::SyncView::addViewer(re::SyncViewer ***this, re::SyncViewer *a2)
{
  uint64_t v3 = (re::SyncView *)this;
  uint64_t v4 = this[15];
  unint64_t v5 = this[13];
  if (v5)
  {
    uint64_t v6 = 8 * (void)v5;
    uint64_t v7 = this[15];
    while (*v7 != a2)
    {
      ++v7;
      v6 -= 8;
      if (!v6)
      {
        uint64_t v7 = &v4[(void)v5];
        break;
      }
    }
  }
  else
  {
    uint64_t v7 = this[15];
  }
  if (v5 != (re::SyncViewer **)(v7 - v4))
  {
    unint64_t v8 = *re::networkLogObjects((re *)this);
    this = (re::SyncViewer ***)os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      v29[0] = 0;
      _os_log_impl(&dword_228C70000, v8, OS_LOG_TYPE_DEFAULT, "SyncViewer already viewing this View", (uint8_t *)v29, 2u);
    }
  }
  unint64_t v9 = *((void *)v3 + 12);
  unint64_t v10 = *((void *)v3 + 13);
  if (v10 >= v9)
  {
    unint64_t v11 = v10 + 1;
    if (v9 < v10 + 1)
    {
      if (*((void *)v3 + 11))
      {
        uint64_t v12 = 2 * v9;
        BOOL v13 = v9 == 0;
        unint64_t v14 = 8;
        if (!v13) {
          unint64_t v14 = v12;
        }
        if (v14 <= v11) {
          unint64_t v15 = v11;
        }
        else {
          unint64_t v15 = v14;
        }
        this = (re::SyncViewer ***)re::DynamicArray<re::Allocator const*>::setCapacity((void *)v3 + 11, v15);
      }
      else
      {
        this = (re::SyncViewer ***)re::DynamicArray<re::Allocator const*>::setCapacity((void *)v3 + 11, v11);
        ++*((_DWORD *)v3 + 28);
      }
    }
    unint64_t v10 = *((void *)v3 + 13);
  }
  *(void *)(*((void *)v3 + 15) + 8 * v10) = a2;
  *((void *)v3 + 13) = v10 + 1;
  ++*((_DWORD *)v3 + 28);
  unint64_t v16 = *((void *)a2 + 2);
  unint64_t v17 = *((void *)a2 + 3);
  if (v17 >= v16)
  {
    unint64_t v18 = v17 + 1;
    if (v16 < v17 + 1)
    {
      if (*((void *)a2 + 1))
      {
        uint64_t v19 = 2 * v16;
        BOOL v13 = v16 == 0;
        unint64_t v20 = 8;
        if (!v13) {
          unint64_t v20 = v19;
        }
        if (v20 <= v18) {
          unint64_t v21 = v18;
        }
        else {
          unint64_t v21 = v20;
        }
        re::DynamicArray<re::Allocator const*>::setCapacity((void *)a2 + 1, v21);
      }
      else
      {
        re::DynamicArray<re::Allocator const*>::setCapacity((void *)a2 + 1, v18);
        ++*((_DWORD *)a2 + 8);
      }
    }
    unint64_t v17 = *((void *)a2 + 3);
  }
  *(void *)(*((void *)a2 + 5) + 8 * v17) = v3;
  *((void *)a2 + 3) = v17 + 1;
  ++*((_DWORD *)a2 + 8);
  uint64_t v22 = *((unsigned int *)v3 + 18);
  if (v22)
  {
    uint64_t v23 = 0;
    __int16 v24 = (int *)(*((void *)v3 + 7) + 8);
    while (1)
    {
      int v25 = *v24;
      v24 += 6;
      if (v25 < 0) {
        break;
      }
      if (v22 == ++v23)
      {
        LODWORD(v23) = *((_DWORD *)v3 + 18);
        break;
      }
    }
  }
  else
  {
    LODWORD(v23) = 0;
  }
  if (v22 != v23)
  {
    uint64_t v26 = v23;
    do
    {
      (*(void (**)(re::SyncViewer *, void))(*(void *)a2 + 24))(a2, *(void *)(*((void *)v3 + 7) + 24 * v26 + 16));
      if (*((_DWORD *)v3 + 18) <= (v23 + 1)) {
        int v27 = v23 + 1;
      }
      else {
        int v27 = *((_DWORD *)v3 + 18);
      }
      int v28 = v23;
      while (1)
      {
        uint64_t v26 = (v28 + 1);
        if (v27 - 1 == v28) {
          break;
        }
        ++v28;
        LODWORD(v23) = v26;
        if ((*(_DWORD *)(*((void *)v3 + 7) + 24 * v26 + 8) & 0x80000000) != 0) {
          goto LABEL_48;
        }
      }
      LODWORD(v23) = v27;
LABEL_48:
      ;
    }
    while (v22 != v23);
  }
}

uint64_t re::SyncView::removeViewer(uint64_t this, re::SyncViewer *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *(void *)(this + 120);
  uint64_t v5 = *(void *)(this + 104);
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    uint64_t v7 = *(re::SyncViewer ***)(this + 120);
    while (*v7 != a2)
    {
      ++v7;
      v6 -= 8;
      if (!v6)
      {
        uint64_t v7 = (re::SyncViewer **)(v4 + 8 * v5);
        break;
      }
    }
  }
  else
  {
    uint64_t v7 = *(re::SyncViewer ***)(this + 120);
  }
  unint64_t v8 = ((uint64_t)v7 - v4) >> 3;
  if (v8 != v5)
  {
    uint64_t v9 = *(unsigned int *)(this + 72);
    if (v9)
    {
      uint64_t v10 = 0;
      unint64_t v11 = (int *)(*(void *)(this + 56) + 8);
      while (1)
      {
        int v12 = *v11;
        v11 += 6;
        if (v12 < 0) {
          break;
        }
        if (v9 == ++v10)
        {
          LODWORD(v10) = *(_DWORD *)(this + 72);
          break;
        }
      }
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if (v9 != v10)
    {
      uint64_t v13 = v10;
      do
      {
        (*(void (**)(re::SyncViewer *, void))(*(void *)a2 + 32))(a2, *(void *)(*(void *)(v3 + 56) + 24 * v13 + 16));
        if (*(_DWORD *)(v3 + 72) <= (v10 + 1)) {
          int v14 = v10 + 1;
        }
        else {
          int v14 = *(_DWORD *)(v3 + 72);
        }
        int v15 = v10;
        while (1)
        {
          uint64_t v13 = (v15 + 1);
          if (v14 - 1 == v15) {
            break;
          }
          ++v15;
          LODWORD(v10) = v13;
          if ((*(_DWORD *)(*(void *)(v3 + 56) + 24 * v13 + 8) & 0x80000000) != 0) {
            goto LABEL_24;
          }
        }
        LODWORD(v10) = v14;
LABEL_24:
        ;
      }
      while (v9 != v10);
    }
    return re::SyncView::removeFromViewersAtWithoutNotifying(v3, v8);
  }
  return this;
}

BOOL re::SyncView::removeFromViewersWithoutNotifying(re::SyncView *this, re::SyncViewer *a2)
{
  uint64_t v2 = *((void *)this + 15);
  uint64_t v3 = *((void *)this + 13);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = (re::SyncViewer **)*((void *)this + 15);
    while (*v5 != a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        uint64_t v5 = (re::SyncViewer **)(v2 + 8 * v3);
        break;
      }
    }
  }
  else
  {
    uint64_t v5 = (re::SyncViewer **)*((void *)this + 15);
  }
  uint64_t v6 = (uint64_t)v5 - v2;
  uint64_t v7 = v6 >> 3;
  if (v6 >> 3 != v3) {
    re::SyncView::removeFromViewersAtWithoutNotifying((uint64_t)this, v6 >> 3);
  }
  return v7 != v3;
}

void re::HashSetBase<re::SyncViewable *,re::SyncViewable *,re::internal::ValueAsKey<re::SyncViewable *>,re::Hash<re::SyncViewable *>,re::EqualTo<re::SyncViewable *>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (v7)
  {
    unint64_t v8 = v6 % v7;
    uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
    if (v9 != 0x7FFFFFFF)
    {
      uint64_t v10 = *(void *)(a1 + 16);
      if (*(void *)(v10 + 24 * v9 + 16) == v4) {
        return;
      }
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
        if (v9 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v10 + 24 * v9 + 16) == v4) {
          return;
        }
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  uint64_t v11 = *(unsigned int *)(a1 + 36);
  if (v11 == 0x7FFFFFFF)
  {
    uint64_t v11 = *(unsigned int *)(a1 + 32);
    int v12 = v11;
    if (v11 == v7)
    {
      re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v8) = v6 % *(unsigned int *)(a1 + 24);
      int v12 = *(_DWORD *)(a1 + 32);
      uint64_t v4 = *a2;
    }
    *(_DWORD *)(a1 + 32) = v12 + 1;
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
  }
  else
  {
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
    *(_DWORD *)(a1 + 36) = v14 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v13 + 24 * v11 + 8) = v14 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * v8);
  *(void *)(*(void *)(a1 + 16) + 24 * v11) = v6;
  *(void *)(*(void *)(a1 + 16) + 24 * v11 + 16) = v4;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v8) = v11;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
}

void re::SyncView::removeObject(uint64_t a1, uint64_t a2)
{
  unint64_t v8 = (void *)a2;
  if (re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::remove(a1 + 40, (uint64_t *)&v8))
  {
    uint64_t v3 = *(void *)(a1 + 104);
    if (v3)
    {
      uint64_t v4 = *(uint64_t **)(a1 + 120);
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *v4++;
        (*(void (**)(uint64_t, void *))(*(void *)v6 + 32))(v6, v8);
        v5 -= 8;
      }
      while (v5);
    }
    unint64_t v7 = v8;
    if (*v8)
    {

      *unint64_t v7 = 0;
    }
  }
}

void re::SyncView::transferObject(uint64_t a1, uint64_t *a2)
{
  uint64_t v34 = a2;
  uint64_t v3 = *a2;
  if (*a2)
  {
    if (v3 == a1) {
      return;
    }
    re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::remove(v3 + 40, (uint64_t *)&v34);
    re::HashSetBase<re::SyncViewable *,re::SyncViewable *,re::internal::ValueAsKey<re::SyncViewable *>,re::Hash<re::SyncViewable *>,re::EqualTo<re::SyncViewable *>,true,false>::add(a1 + 40, (uint64_t *)&v34);
    if (a1) {
      id v4 = (id)(a1 + 8);
    }
    uint64_t v5 = *v34;
    *uint64_t v34 = a1;
    if (v5) {

    }
    __dst = 0;
    v30[1] = 0;
    unint64_t v31 = 0;
    v30[0] = 0;
    int v32 = 0;
    if (*(void *)(v3 + 88))
    {
      unint64_t v6 = *(void *)(v3 + 104);
      v30[0] = *(void *)(v3 + 88);
      re::DynamicArray<re::Allocator const*>::setCapacity(v30, v6);
      ++v32;
      unint64_t v7 = *(void *)(v3 + 104);
      if (v7 >= v31)
      {
        re::DynamicArray<re::Allocator const*>::setCapacity(v30, *(void *)(v3 + 104));
        unint64_t v18 = v31;
        unint64_t v8 = (unint64_t *)__dst;
        if (v31) {
          memmove(__dst, *(const void **)(v3 + 120), 8 * v31);
        }
        memcpy(&v8[v18], (const void *)(*(void *)(v3 + 120) + 8 * v18), 8 * v7 - 8 * v18);
        unint64_t v31 = v7;
        uint64_t v9 = &v8[v7];
        if (v7)
        {
          uint64_t v10 = 126 - 2 * __clz(v7);
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v8 = (unint64_t *)__dst;
        if (v7)
        {
          memmove(__dst, *(const void **)(v3 + 120), 8 * v7);
          unint64_t v31 = v7;
          uint64_t v9 = &v8[v7];
          uint64_t v10 = 126 - 2 * __clz(v7);
          unint64_t v7 = 1;
LABEL_26:
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **,false>(v8, v9, v10, 1);
          unint64_t v19 = *(void *)(a1 + 104);
          unint64_t v20 = 126 - 2 * __clz(v19);
          if (v19) {
            uint64_t v21 = v20;
          }
          else {
            uint64_t v21 = 0;
          }
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **,false>(*(unint64_t **)(a1 + 120), (unint64_t *)(*(void *)(a1 + 120) + 8 * v19), v21, 1);
          uint64_t v22 = *(void *)(a1 + 104);
          if (v7 | v22)
          {
            uint64_t v23 = *(unint64_t **)(a1 + 120);
            __int16 v24 = &v23[v22];
            int v25 = v8;
            do
            {
              if (v25 == v9)
              {
                uint64_t v28 = *v23++;
                (*(void (**)(uint64_t, uint64_t *))(*(void *)v28 + 24))(v28, v34);
                int v25 = v9;
              }
              else if (v23 == v24)
              {
                uint64_t v29 = *v25++;
                (*(void (**)(uint64_t, uint64_t *))(*(void *)v29 + 32))(v29, v34);
                uint64_t v23 = v24;
              }
              else
              {
                unint64_t v26 = *v23;
                unint64_t v27 = *v25;
                if (*v23 >= *v25)
                {
                  if (v27 >= v26) {
                    ++v23;
                  }
                  else {
                    (*(void (**)(unint64_t, uint64_t *))(*(void *)v27 + 32))(v27, v34);
                  }
                  ++v25;
                }
                else
                {
                  (*(void (**)(void, uint64_t *))(*(void *)v26 + 24))(*v23++, v34);
                }
              }
            }
            while (v25 != v9 || v23 != v24);
          }
          if (v8)
          {
            if (v30[0]) {
              (*(void (**)(uint64_t, unint64_t *))(*(void *)v30[0] + 40))(v30[0], v8);
            }
          }
          return;
        }
        unint64_t v31 = 0;
        uint64_t v9 = (unint64_t *)__dst;
      }
    }
    else
    {
      uint64_t v9 = 0;
      unint64_t v8 = 0;
      unint64_t v7 = 0;
    }
    uint64_t v10 = 0;
    goto LABEL_26;
  }
  v30[0] = (uint64_t)a2;
  re::HashSetBase<re::SyncViewable *,re::SyncViewable *,re::internal::ValueAsKey<re::SyncViewable *>,re::Hash<re::SyncViewable *>,re::EqualTo<re::SyncViewable *>,true,false>::add(a1 + 40, v30);
  if (a1) {
    id v12 = (id)(a1 + 8);
  }
  uint64_t v13 = *a2;
  *a2 = a1;
  if (v13) {

  }
  uint64_t v14 = *(void *)(a1 + 104);
  if (v14)
  {
    int v15 = *(uint64_t **)(a1 + 120);
    uint64_t v16 = 8 * v14;
    do
    {
      uint64_t v17 = *v15++;
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v17 + 24))(v17, a2);
      v16 -= 8;
    }
    while (v16);
  }
}

void re::SyncViewer::~SyncViewer(re::SyncView ***this)
{
  *this = (re::SyncView **)&unk_26DD35538;
  while (this[3])
    re::SyncView::removeFromViewersWithoutNotifying(*this[5], (re::SyncViewer *)this);
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)(this + 1));
}

BOOL re::SyncViewer::includes(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 120);
  uint64_t v3 = *(void *)(a2 + 104);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = *(void **)(a2 + 120);
    while (*v5 != a1)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        uint64_t v5 = (void *)(v2 + 8 * v3);
        return v3 != ((uint64_t)v5 - v2) >> 3;
      }
    }
  }
  else
  {
    uint64_t v5 = *(void **)(a2 + 120);
  }
  return v3 != ((uint64_t)v5 - v2) >> 3;
}

unint64_t *std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **,false>(unint64_t *result, unint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unint64_t v39 = *(a2 - 1);
                unint64_t v40 = *v10;
                if (v39 < *v10)
                {
                  *uint64_t v10 = v39;
                  *(a2 - 1) = v40;
                }
                break;
              case 3uLL:
                double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v10, v10 + 1, a2 - 1);
                break;
              case 4uLL:
                double result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v10, v10 + 1, v10 + 2, a2 - 1);
                break;
              case 5uLL:
                double result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v10, v10 + 1, v10 + 2, v10 + 3, a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            unsigned int v41 = v10 + 1;
            BOOL v43 = v10 == a2 || v41 == a2;
            if (a4)
            {
              if (!v43)
              {
                uint64_t v44 = 8;
                uint64_t v45 = v10;
                do
                {
                  unint64_t v47 = *v45;
                  unint64_t v46 = v45[1];
                  uint64_t v45 = v41;
                  if (v46 < v47)
                  {
                    uint64_t v48 = v44;
                    do
                    {
                      *(unint64_t *)((char *)v10 + v48) = v47;
                      uint64_t v49 = v48 - 8;
                      if (v48 == 8)
                      {
                        uint64_t v50 = v10;
                        goto LABEL_82;
                      }
                      unint64_t v47 = *(unint64_t *)((char *)v10 + v48 - 16);
                      v48 -= 8;
                    }
                    while (v46 < v47);
                    uint64_t v50 = (unint64_t *)((char *)v10 + v49);
LABEL_82:
                    *uint64_t v50 = v46;
                  }
                  unsigned int v41 = v45 + 1;
                  v44 += 8;
                }
                while (v45 + 1 != a2);
              }
            }
            else if (!v43)
            {
              do
              {
                unint64_t v75 = *v9;
                unint64_t v74 = v9[1];
                uint64_t v9 = v41;
                if (v74 < v75)
                {
                  do
                  {
                    *unsigned int v41 = v75;
                    unint64_t v75 = *(v41 - 2);
                    --v41;
                  }
                  while (v74 < v75);
                  *unsigned int v41 = v74;
                }
                unsigned int v41 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v51 = (v12 - 2) >> 1;
              int64_t v52 = v51;
              do
              {
                int64_t v53 = v52;
                if (v51 >= v52)
                {
                  uint64_t v54 = (2 * v52) | 1;
                  uint64_t v55 = &v10[v54];
                  if (2 * v53 + 2 < (uint64_t)v12)
                  {
                    unint64_t v57 = v55[1];
                    BOOL v56 = *v55 >= v57;
                    if (*v55 < v57) {
                      ++v55;
                    }
                    else {
                      unint64_t v57 = *v55;
                    }
                    if (!v56) {
                      uint64_t v54 = 2 * v53 + 2;
                    }
                  }
                  else
                  {
                    unint64_t v57 = *v55;
                  }
                  uint64_t v58 = &v10[v53];
                  unint64_t v59 = *v58;
                  if (v57 >= *v58)
                  {
                    do
                    {
                      unint64_t *v58 = v57;
                      uint64_t v58 = v55;
                      if (v51 < v54) {
                        break;
                      }
                      uint64_t v60 = (2 * v54) | 1;
                      uint64_t v55 = &v10[v60];
                      uint64_t v54 = 2 * v54 + 2;
                      if (v54 < (uint64_t)v12)
                      {
                        unint64_t v57 = *v55;
                        double result = v55 + 1;
                        if (*v55 >= v55[1])
                        {
                          uint64_t v54 = v60;
                        }
                        else
                        {
                          unint64_t v57 = v55[1];
                          ++v55;
                        }
                      }
                      else
                      {
                        unint64_t v57 = *v55;
                        uint64_t v54 = v60;
                      }
                    }
                    while (v57 >= v59);
                    unint64_t *v58 = v59;
                  }
                }
                int64_t v52 = v53 - 1;
              }
              while (v53);
              uint64_t v61 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v62 = 0;
                unint64_t v63 = *v10;
                uint64_t v64 = v10;
                do
                {
                  unsigned int v65 = &v64[v62 + 1];
                  uint64_t v66 = (2 * v62) | 1;
                  uint64_t v62 = 2 * v62 + 2;
                  if (v62 < v61)
                  {
                    unint64_t v67 = *v65;
                    if (*v65 >= v65[1])
                    {
                      uint64_t v62 = v66;
                    }
                    else
                    {
                      unint64_t v67 = v65[1];
                      ++v65;
                    }
                  }
                  else
                  {
                    unint64_t v67 = *v65;
                    uint64_t v62 = v66;
                  }
                  *uint64_t v64 = v67;
                  uint64_t v64 = v65;
                }
                while (v62 <= (uint64_t)((unint64_t)(v61 - 2) >> 1));
                if (v65 == --a2)
                {
                  *unsigned int v65 = v63;
                }
                else
                {
                  *unsigned int v65 = *a2;
                  *a2 = v63;
                  uint64_t v68 = (char *)v65 - (char *)v10 + 8;
                  if (v68 >= 9)
                  {
                    unint64_t v69 = (((unint64_t)v68 >> 3) - 2) >> 1;
                    unint64_t v70 = &v10[v69];
                    unint64_t v71 = *v70;
                    unint64_t v72 = *v65;
                    if (*v70 < *v65)
                    {
                      do
                      {
                        *unsigned int v65 = v71;
                        unsigned int v65 = v70;
                        if (!v69) {
                          break;
                        }
                        unint64_t v69 = (v69 - 1) >> 1;
                        unint64_t v70 = &v10[v69];
                        unint64_t v71 = *v70;
                      }
                      while (*v70 < v72);
                      *unsigned int v65 = v72;
                    }
                  }
                }
              }
              while (v61-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = &v10[v12 >> 1];
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v9, &v9[v12 >> 1], a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v9 + 1, v14 - 1, a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v9 + 2, &v9[v13 + 1], a2 - 3);
            double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v14 - 1, v14, &v9[v13 + 1]);
            unint64_t v15 = *v9;
            *uint64_t v9 = *v14;
            unint64_t *v14 = v15;
          }
          else
          {
            double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(&v9[v12 >> 1], v9, a2 - 1);
          }
          --a3;
          unint64_t v16 = *v9;
          if ((a4 & 1) != 0 || *(v9 - 1) < v16) {
            break;
          }
          if (v16 >= *(a2 - 1))
          {
            unint64_t v31 = v9 + 1;
            do
            {
              uint64_t v10 = v31;
              if (v31 >= a2) {
                break;
              }
              ++v31;
            }
            while (v16 >= *v10);
          }
          else
          {
            uint64_t v10 = v9;
            do
            {
              unint64_t v30 = v10[1];
              ++v10;
            }
            while (v16 >= v30);
          }
          int v32 = a2;
          if (v10 < a2)
          {
            int v32 = a2;
            do
              unint64_t v33 = *--v32;
            while (v16 < v33);
          }
          if (v10 < v32)
          {
            unint64_t v34 = *v10;
            unint64_t v35 = *v32;
            do
            {
              *uint64_t v10 = v35;
              *int v32 = v34;
              do
              {
                unint64_t v36 = v10[1];
                ++v10;
                unint64_t v34 = v36;
              }
              while (v16 >= v36);
              do
              {
                unint64_t v37 = *--v32;
                unint64_t v35 = v37;
              }
              while (v16 < v37);
            }
            while (v10 < v32);
          }
          unint64_t v38 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            *uint64_t v9 = *v38;
          }
          a4 = 0;
          *unint64_t v38 = v16;
        }
        uint64_t v17 = 0;
        do
          unint64_t v18 = v9[++v17];
        while (v18 < v16);
        unint64_t v19 = &v9[v17];
        unint64_t v20 = a2;
        if (v17 == 1)
        {
          unint64_t v20 = a2;
          do
          {
            if (v19 >= v20) {
              break;
            }
            unint64_t v22 = *--v20;
          }
          while (v22 >= v16);
        }
        else
        {
          do
            unint64_t v21 = *--v20;
          while (v21 >= v16);
        }
        if (v19 >= v20)
        {
          uint64_t v28 = v19 - 1;
        }
        else
        {
          unint64_t v23 = *v20;
          __int16 v24 = &v9[v17];
          int v25 = v20;
          do
          {
            *__int16 v24 = v23;
            *int v25 = v18;
            do
            {
              unint64_t v26 = v24[1];
              ++v24;
              unint64_t v18 = v26;
            }
            while (v26 < v16);
            do
            {
              unint64_t v27 = *--v25;
              unint64_t v23 = v27;
            }
            while (v27 >= v16);
          }
          while (v24 < v25);
          uint64_t v28 = v24 - 1;
        }
        if (v28 != v9) {
          *uint64_t v9 = *v28;
        }
        *uint64_t v28 = v16;
        if (v19 >= v20) {
          break;
        }
LABEL_33:
        double result = (unint64_t *)std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **,false>(v9, v28, a3, a4 & 1);
        a4 = 0;
        uint64_t v10 = v28 + 1;
      }
      BOOL v29 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v9, v28);
      uint64_t v10 = v28 + 1;
      double result = (unint64_t *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(v28 + 1, a2);
      if (result) {
        break;
      }
      if (!v29) {
        goto LABEL_33;
      }
    }
    a2 = v28;
    if (!v29) {
      continue;
    }
    return result;
  }
}

unint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  unint64_t v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      *a2 = v5;
      *a3 = v3;
      unint64_t v6 = *result;
      if (*a2 < *result)
      {
        *double result = *a2;
        *a2 = v6;
      }
    }
  }
  else
  {
    if (v5 >= v3)
    {
      *double result = v3;
      *a2 = v4;
      if (*a3 >= v4) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *double result = v5;
    }
    *a3 = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(a2 - 1);
      unint64_t v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      unint64_t v8 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a1 + 1, a1 + 2);
      uint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    unint64_t v12 = *v9;
    unint64_t v13 = *v8;
    if (*v9 < *v8)
    {
      uint64_t v14 = v11;
      while (1)
      {
        *(unint64_t *)((char *)a1 + v14) = v13;
        uint64_t v15 = v14 - 8;
        if (v14 == 8) {
          break;
        }
        unint64_t v13 = *(unint64_t *)((char *)a1 + v14 - 16);
        v14 -= 8;
        if (v12 >= v13)
        {
          unint64_t v16 = (unint64_t *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      unint64_t v16 = a1;
LABEL_12:
      unint64_t *v16 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    unint64_t v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

unint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a2, a3);
  unint64_t v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    unint64_t v10 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v10;
      unint64_t v11 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

unint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  BOOL result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::SyncViewer **>(a1, a2, a3, a4);
  unint64_t v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    unint64_t v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      unint64_t v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        unint64_t v14 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

uint64_t re::SyncSendBuffer::SyncSendBuffer(uint64_t a1, id *a2, id *a3, uint64_t a4)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)a1 = &unk_26DD35598;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0u;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 60) = 0x7FFFFFFFLL;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(void *)(a1 + 148) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_DWORD *)(a1 + 192) = 0;
  *(void *)(a1 + 196) = 0x7FFFFFFFLL;
  *(unsigned char *)(a1 + 208) = 0;
  *(void *)(a1 + 2re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 229) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  objc_copyWeak((id *)(a1 + 280), a2);
  *(void *)(a1 + 288) = 0;
  objc_copyWeak((id *)(a1 + 288), a3);
  *(void *)(a1 + 296) = a4;
  if (a4) {
    id v8 = (id)(a4 + 8);
  }
  *(_DWORD *)(a1 + re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 304) = 500;
  return a1;
}

void re::SyncSendBuffer::resend(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  uint64_t v6 = a2;
  uint64_t v7 = a1;
  uint64_t v133 = *MEMORY[0x263EF8340];
  id location = (id *)*(unsigned int *)(a1 + 144);
  uint64_t v8 = 0;
  if (location)
  {
    unint64_t v9 = (_DWORD *)(*(void *)(a1 + 128) + 8);
    while ((*v9 & 0x80000000) == 0)
    {
      v9 += 244;
      if (location == (id *)++v8)
      {
        LODWORD(v8) = *(_DWORD *)(a1 + 144);
        break;
      }
    }
  }
  unsigned int v10 = *(_DWORD *)(a1 + 144);
  if (location != v8)
  {
    uint64_t v11 = v8;
    do
    {
      uint64_t v12 = *(void *)(v7 + 128) + 976 * v11;
      uint64_t v13 = v12 + 24;
      unsigned __int16 v14 = *(_WORD *)(v12 + 632) - 32;
      uint64_t v15 = v12 + 536;
      uint64_t v16 = v12 + 600;
      do
      {
        uint64_t v17 = v14 & 0x1F;
        if (*(unsigned __int16 *)(v15 + 2 * v17) == v14 && *(unsigned char *)(v16 + v17))
        {
          if ((unsigned int v18 = *a4, v19 = v18 - v14, v18 >= v14) && v19 < 0x8000 || v18 < v14 && v14 - v18 >= 0x8000)
          {
            unint64_t v20 = v19 >= 0x8000 ? v19 + 0x10000 : (int)v19;
            if (v20 <= 0xFF
              && ((*(void *)&a4[4 * re::Bitset<256>::toWordIndex((uint64_t)(a4 + 4), v20) + 4] >> v20) & 1) != 0)
            {
              *(unsigned char *)(v13 + 16 * v17 + 10) = 1;
            }
          }
        }
        ++v14;
      }
      while (*(unsigned __int16 *)(v13 + 608) != v14);
      unsigned int v10 = *(_DWORD *)(v7 + 144);
      if (v10 <= (int)v8 + 1) {
        int v21 = v8 + 1;
      }
      else {
        int v21 = *(_DWORD *)(v7 + 144);
      }
      uint64_t v6 = a2;
      while (1)
      {
        uint64_t v11 = (v8 + 1);
        if (v21 - 1 == v8) {
          break;
        }
        LODWORD(v8) = v8 + 1;
        int v22 = v11;
        if ((*(_DWORD *)(*(void *)(v7 + 128) + 976 * v11 + 8) & 0x80000000) != 0) {
          goto LABEL_30;
        }
      }
      int v22 = v21;
LABEL_30:
      LODWORD(v8) = v22;
    }
    while (location != v22);
  }
  if (!a3) {
    goto LABEL_46;
  }
  uint64_t v23 = v6 + 72 * a3;
  do
  {
    uint64_t v24 = *(void *)(v6 + 48);
    if (v24)
    {
      int v25 = *(unint64_t **)(v6 + 64);
      unint64_t v26 = &v25[3 * v24];
      do
      {
        unint64_t v27 = *v25;
        *(void *)sockaddr buf = v27;
        unint64_t v28 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v27 ^ (v27 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v27 ^ (v27 >> 30))) >> 27));
        unint64_t v29 = v28 ^ (v28 >> 31);
        unint64_t v30 = *(unsigned int *)(v7 + 184);
        if (v30)
        {
          unint64_t v31 = v29 % v30;
          uint64_t v32 = *(unsigned int *)(*(void *)(v7 + 168) + 4 * (v29 % v30));
          if (v32 != 0x7FFFFFFF)
          {
            uint64_t v33 = *(void *)(v7 + 176);
            while (*(void *)(v33 + 24 * v32 + 16) != v27)
            {
              LODWORD(v32) = *(_DWORD *)(v33 + 24 * v32 + 8) & 0x7FFFFFFF;
              if (v32 == 0x7FFFFFFF) {
                goto LABEL_42;
              }
            }
            goto LABEL_43;
          }
        }
        else
        {
          LODWORD(v31) = 0;
        }
LABEL_42:
        re::HashSetBase<re::SyncObject *,re::SyncObject *,re::internal::ValueAsKey<re::SyncObject *>,re::Hash<re::SyncObject *>,re::EqualTo<re::SyncObject *>,true,false>::addAsMove(v7 + 160, v31, v29, buf);
        ++*(_DWORD *)(v7 + 200);
LABEL_43:
        v25 += 3;
      }
      while (v25 != v26);
    }
    v6 += 72;
  }
  while (v6 != v23);
  unsigned int v10 = *(_DWORD *)(v7 + 144);
LABEL_46:
  uint64_t v34 = 0;
  if (v10)
  {
    unint64_t v35 = (_DWORD *)(*(void *)(v7 + 128) + 8);
    while ((*v35 & 0x80000000) == 0)
    {
      v35 += 244;
      if (v10 == ++v34)
      {
        LODWORD(v34) = v10;
        break;
      }
    }
  }
  if (v10 != v34)
  {
    uint64_t v36 = v34;
    locationa = (id *)(v7 + 288);
    v116 = (_anonymous_namespace_ *)(v7 + 72);
    v117 = (_anonymous_namespace_ *)(v7 + 240);
    unsigned int v118 = v10;
    uint64_t v123 = v7;
    while (1)
    {
      uint64_t v37 = *(void *)(v7 + 128);
      uint64_t v38 = v37 + 976 * v36;
      unint64_t v40 = *(re::SyncObject **)(v38 + 16);
      unint64_t v39 = (unsigned __int16 *)(v38 + 16);
      unint64_t v41 = re::SyncObject::latestStateHandle(v40);
      if (v41 != -1) {
        break;
      }
      unint64_t v69 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      {
        uint64_t v70 = *(void *)(*(void *)v39 + 24);
        unint64_t v71 = *(void **)(*(void *)(*(void *)v39 + 88) + 16);
        uint64_t v72 = v71[4];
        uint64_t v73 = v71[6];
        unint64_t v74 = (char *)v71[7];
        unint64_t v75 = (char *)v71 + 49;
        if (v73) {
          unint64_t v75 = v74;
        }
        *(_DWORD *)sockaddr buf = 134218498;
        *(void *)&uint8_t buf[4] = v70;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v72;
        __int16 v131 = 2080;
        v132 = v75;
        _os_log_error_impl(&dword_228C70000, v69, OS_LOG_TYPE_ERROR, "Sync object without snapshot among snapshot resend entries (id: %llu, type: %llu[%s]).", buf, 0x20u);
      }
LABEL_120:
      unsigned int v97 = *(_DWORD *)(v7 + 144);
      if (v97 <= (int)v34 + 1) {
        unsigned int v97 = v34 + 1;
      }
      while (1)
      {
        uint64_t v36 = (v34 + 1);
        if (v97 - 1 == v34) {
          break;
        }
        LODWORD(v34) = v34 + 1;
        unsigned int v98 = v36;
        if ((*(_DWORD *)(*(void *)(v7 + 128) + 976 * v36 + 8) & 0x80000000) != 0) {
          goto LABEL_126;
        }
      }
      unsigned int v98 = v97;
LABEL_126:
      LODWORD(v34) = v98;
      if (v10 == v98) {
        goto LABEL_127;
      }
    }
    uint64_t v119 = v37;
    v129 = (uint64_t *)v39;
    size_t v42 = v39 + 4;
    unsigned int v43 = v39[308];
    unsigned __int16 v44 = v43 - 32;
    int v45 = (unsigned __int16)(v43 - 32);
    if (v43 > 0x1F || v45 - v43 >= 0x8000)
    {
      int v46 = v39[308];
      unsigned __int16 v47 = v39[308];
      while (v47 <= v44 || !((v46 - v45) >> 15))
      {
        uint64_t v48 = --v47 & 0x1F;
        if (v39[v48 + 260] == v47 && *((unsigned char *)v39 + v48 + 584))
        {
          uint64_t v49 = &v42[8 * v48];
          goto LABEL_64;
        }
        int v46 = v47;
        if (v47 <= v44 && !((v45 - v47) >> 15)) {
          break;
        }
      }
    }
    uint64_t v49 = 0;
LABEL_64:
    int v50 = 0;
    char v51 = 0;
    char v52 = 0;
    int v53 = (*(unsigned __int8 *)(*(void *)v39 + 128) >> 2) & 1;
    unsigned __int16 v54 = *(_WORD *)(*(void *)v39 + 176);
    uint64_t v55 = v39 + 260;
    BOOL v56 = v39 + 292;
    int v57 = a3;
    v125 = v39 + 292;
    do
    {
      uint64_t v58 = v44 & 0x1F;
      if (v55[v58] == v44 && *((unsigned char *)v56 + v58))
      {
        unint64_t v59 = &v42[8 * v58];
        if (*((unsigned char *)v59 + 10))
        {
          uint64_t v60 = v55;
          int v61 = v50;
          id WeakRetained = objc_loadWeakRetained(locationa);
          if (WeakRetained)
          {
            unint64_t v63 = WeakRetained;
            re::SyncAckedStateBuffer::addAcked((uint64_t)WeakRetained - 8, v129, *(void *)v59, v42[8 * v58 + 6]);
          }
          unint64_t v41 = *(void *)v59;
          unsigned int v43 = *(void *)v59 == *(void *)v49
             && (uint64_t v64 = &v42[8 * v58], *((unsigned __int8 *)v64 + 9) == *((unsigned __int8 *)v49 + 9))
             && v64[6] == v49[6];
          uint64_t v55 = v60;
          uint64_t v7 = v123;
          BOOL v56 = v125;
          int v50 = v61 | v43;
          char v52 = *((unsigned char *)v59 + 10);
          LOWORD(v43) = v42[304];
        }
        else
        {
          char v52 = 0;
          unint64_t v41 = *(void *)v59;
        }
        char v51 = *((unsigned char *)v59 + 8);
        int v53 = *((unsigned __int8 *)v59 + 9);
        int v57 = *((unsigned __int8 *)v59 + 11);
        unsigned __int16 v54 = v59[6];
      }
      ++v44;
    }
    while (v44 != (unsigned __int16)v43);
    uint64_t v65 = *v129;
    uint64_t v66 = *(void *)(*v129 + 80);
    if (v66)
    {
      char v121 = v51;
      LODWORD(a3) = v57;
      char v126 = v52;
      int v67 = v53;
      unint64_t v120 = v41;
      unsigned int v10 = v118;
      do
      {
        uint64_t v68 = v65;
        uint64_t v65 = v66;
        if (*(unsigned char *)(*(void *)(*(void *)(v68 + 88) + 16) + 73)) {
          break;
        }
        uint64_t v66 = *(void *)(v66 + 80);
        uint64_t v68 = v65;
      }
      while (v66);
    }
    else
    {
      char v121 = v51;
      LODWORD(a3) = v57;
      char v126 = v52;
      int v67 = v53;
      unint64_t v120 = v41;
      uint64_t v68 = *v129;
      unsigned int v10 = v118;
    }
    char v76 = v50 | (*(unsigned char *)(v68 + 170) == 0);
    id v77 = objc_loadWeakRetained(locationa);
    unsigned __int8 v78 = v77;
    if (v77 && v76 & 1 | (v67 != 0))
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove((uint64_t)v77 + 16, v129);
    }
    else if (!v77)
    {
      goto LABEL_93;
    }

LABEL_93:
    unint64_t v79 = *v129;
    if (v76)
    {
      if (v79) {
        id v80 = (id)(v79 + 8);
      }
      unint64_t v81 = *(void *)(v7 + 80);
      unint64_t v82 = *(void *)(v7 + 88);
      char v83 = v121;
      char v84 = v126;
      if (v82 >= v81)
      {
        unint64_t v85 = v82 + 1;
        if (v81 < v82 + 1)
        {
          if (*(void *)v116)
          {
            uint64_t v86 = 2 * v81;
            BOOL v87 = v81 == 0;
            unint64_t v88 = 8;
            if (!v87) {
              unint64_t v88 = v86;
            }
            if (v88 <= v85) {
              unint64_t v89 = v85;
            }
            else {
              unint64_t v89 = v88;
            }
            re::DynamicArray<re::Pair<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::StateData,true>>::setCapacity(v116, v89);
          }
          else
          {
            re::DynamicArray<re::Pair<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::StateData,true>>::setCapacity(v116, v85);
            ++*(_DWORD *)(v7 + 96);
          }
          char v84 = v126;
          char v83 = v121;
        }
        unint64_t v82 = *(void *)(v7 + 88);
      }
      uint64_t v96 = *(void *)(v7 + 104) + 24 * v82;
      *(void *)uint64_t v96 = v79;
      *(void *)(v96 + 8) = v120;
      *(unsigned char *)(v96 + 16) = v83;
      *(unsigned char *)(v96 + 17) = v67;
      *(unsigned char *)(v96 + 18) = v84;
      *(unsigned char *)(v96 + 19) = a3;
      *(_WORD *)(v96 + 20) = v54;
      ++*(void *)(v7 + 88);
      ++*(_DWORD *)(v7 + 96);
    }
    else
    {
      unint64_t v90 = *(unsigned int *)(v7 + 184);
      if (!v90
        || (unint64_t v91 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v79 ^ (v79 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v79 ^ (v79 >> 30))) >> 27)),
            uint64_t v92 = *(unsigned int *)(*(void *)(v7 + 168) + 4 * ((v91 ^ (v91 >> 31)) % v90)),
            v92 == 0x7FFFFFFF))
      {
LABEL_110:
        if ((*(uint64_t (**)(void))(**(void **)(v7 + 296) + 32))(*(void *)(v7 + 296))
           - *(void *)(v119 + 976 * v36 + 968) > (unint64_t)*(unsigned int *)(v7 + 304))
        {
          uint64_t v94 = *v129;
          *(void *)sockaddr buf = v94;
          if (v94) {
            id v95 = (id)(v94 + 8);
          }
          *(void *)&uint8_t buf[8] = v120;
          uint8_t buf[16] = buf[16] & 0xF0 | (2 * v67);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v117, (uint64_t)buf);
          if (*(void *)buf) {
        }
          }
      }
      else
      {
        uint64_t v93 = *(void *)(v7 + 176);
        while (*(void *)(v93 + 24 * v92 + 16) != v79)
        {
          LODWORD(v92) = *(_DWORD *)(v93 + 24 * v92 + 8) & 0x7FFFFFFF;
          if (v92 == 0x7FFFFFFF) {
            goto LABEL_110;
          }
        }
      }
    }
    goto LABEL_120;
  }
LABEL_127:
  if (*(_DWORD *)(v7 + 188))
  {
    uint64_t v99 = *(unsigned int *)(v7 + 184);
    if (v99) {
      memset_pattern16(*(void **)(v7 + 168), &unk_228CDE530, 4 * v99);
    }
    uint64_t v100 = *(unsigned int *)(v7 + 192);
    if (v100)
    {
      uint64_t v101 = 0;
      uint64_t v102 = 24 * v100;
      do
      {
        uint64_t v103 = *(void *)(v7 + 176) + v101;
        int v104 = *(_DWORD *)(v103 + 8);
        if (v104 < 0) {
          *(_DWORD *)(v103 + 8) = v104 & 0x7FFFFFFF;
        }
        v101 += 24;
      }
      while (v102 != v101);
    }
    *(_DWORD *)(v7 + 188) = 0;
    *(_DWORD *)(v7 + 192) = 0;
    int v105 = *(_DWORD *)(v7 + 200) + 1;
    *(_DWORD *)(v7 + 196) = 0x7FFFFFFF;
    *(_DWORD *)(v7 + 200) = v105;
  }
  if (*(void *)(v7 + 256))
  {
    *(unsigned char *)(v7 + 208) = 0x80;
    (*(void (**)(void, uint64_t))(**(void **)(a5 + 32) + 16))(*(void *)(a5 + 32), v7 + 208);
  }
  re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(v7 + 240);
  uint64_t v106 = *(void *)(v7 + 88);
  if (v106)
  {
    uint64_t v107 = *(void *)(v7 + 104);
    uint64_t v108 = 24 * v106;
    do
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v7 + 112, (uint64_t *)v107);
      if (*(unsigned char *)(v107 + 17))
      {
        uint64_t v109 = (char *)objc_loadWeakRetained((id *)(v7 + 280));
        if (v109) {
          v110 = v109 - 8;
        }
        else {
          v110 = 0;
        }
        v111 = v110 + 8;
        (*(void (**)(char *, void, void))(*(void *)v110 + 40))(v110, *(void *)(*(void *)v107 + 24), *(void *)(*(void *)(*(void *)(*(void *)v107 + 88) + 16) + 32));
      }
      v107 += 24;
      v108 -= 24;
    }
    while (v108);
    uint64_t v112 = *(void *)(v7 + 88);
    uint64_t v113 = *(void *)(v7 + 104);
    *(void *)(v7 + 88) = 0;
    if (v112)
    {
      uint64_t v114 = 24 * v112;
      do
      {
        if (*(void *)v113)
        {

          *(void *)uint64_t v113 = 0;
        }
        v113 += 24;
        v114 -= 24;
      }
      while (v114);
    }
  }
  else
  {
    *(void *)(v7 + 88) = 0;
  }
  ++*(_DWORD *)(v7 + 96);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (*(void *)(v9 + 976 * v7 + 16) != v3)
  {
    while (1)
    {
      unsigned int v10 = v7;
      int v11 = *(_DWORD *)(v9 + 976 * v7 + 8);
      uint64_t v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        return 0;
      }
      if (*(void *)(v9 + 976 * v7 + 16) == v3)
      {
        *(_DWORD *)(v9 + 976 * v10 + 8) = *(_DWORD *)(v9 + 976 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 976 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 976 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v13 = v12 + 976 * v7;
  int v16 = *(_DWORD *)(v13 + 8);
  unsigned __int16 v14 = (int *)(v13 + 8);
  int v15 = v16;
  if (v16 < 0)
  {
    int *v14 = v15 & 0x7FFFFFFF;
    uint64_t v17 = v12 + 976 * v7;
    uint64_t v20 = *(void *)(v17 + 16);
    unsigned int v19 = (void *)(v17 + 16);
    uint64_t v18 = v20;
    if (v20)
    {

      *unsigned int v19 = 0;
    }
  }
  uint64_t v21 = *(void *)(a1 + 16) + 976 * v7;
  int v22 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v22 + 1;
  return 1;
}

void re::SyncSendBuffer::objectsSent(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v5 = a2;
    uint64_t v49 = a2 + 24 * a3;
    int v50 = (void *)(a1 + 112);
    unsigned __int16 v7 = a4 + 1;
    uint64_t v8 = a4 & 0x1F;
    while (1)
    {
      unint64_t v9 = re::SyncObject::latestStateHandle(*(re::SyncObject **)v5);
      if (v9 == -1)
      {
        unint64_t v27 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          uint64_t v28 = *(void *)(*(void *)v5 + 24);
          unint64_t v29 = *(void **)(*(void *)(*(void *)v5 + 88) + 16);
          uint64_t v30 = v29[4];
          uint64_t v31 = v29[6];
          uint64_t v32 = (char *)v29[7];
          uint64_t v33 = (char *)v29 + 49;
          if (v31) {
            uint64_t v33 = v32;
          }
          *(_DWORD *)sockaddr buf = 134218498;
          uint64_t v52 = v28;
          __int16 v53 = 2048;
          uint64_t v54 = v30;
          __int16 v55 = 2080;
          BOOL v56 = v33;
          _os_log_error_impl(&dword_228C70000, v27, OS_LOG_TYPE_ERROR, "Sync object without snapshot among sent snapshot entries (id: %llu, type: %llu[%s]).", buf, 0x20u);
        }
        goto LABEL_33;
      }
      unint64_t v10 = v9;
      for (uint64_t i = 0; i != 512; i += 16)
      {
        uint64_t v12 = &buf[i];
        *((_WORD *)v12 + 4) = 0;
        v12[10] = 0;
        *((_WORD *)v12 + 6) = 0;
      }
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      v57[48] = 32;
      v15.i64[0] = 0x10001000100010;
      v15.i64[1] = 0x10001000100010;
      do
      {
        *((unsigned char *)&v57[32] + v14) = 0;
        v57[v14] = v14;
        int v16 = &buf[v13];
        *((_WORD *)v16 + 6) = 0;
        *(void *)int v16 = 0;
        *(_DWORD *)(v16 + 7) = 0;
        ++v14;
        v13 += 16;
      }
      while (v14 != 32);
      v57[212] = 64;
      uint64_t v17 = 744;
      uint64_t v18 = 872;
      int16x8_t v19 = (int16x8_t)xmmword_228CDEEC0;
      int16x8_t v20 = (int16x8_t)xmmword_228CDEEB0;
      do
      {
        *(_OWORD *)&buf[v18] = 0uLL;
        uint64_t v21 = &buf[v17];
        *(int16x8_t *)uint64_t v21 = v19;
        *((int16x8_t *)v21 + 1) = v20;
        int16x8_t v19 = vaddq_s16(v19, v15);
        int16x8_t v20 = vaddq_s16(v20, v15);
        v18 += 16;
        v17 += 32;
      }
      while (v17 != 872);
      uint64_t v58 = 0;
      unint64_t v22 = 0xBF58476D1CE4E5B9 * (*(void *)v5 ^ (*(void *)v5 >> 30));
      unint64_t v23 = (0x94D049BB133111EBLL * (v22 ^ (v22 >> 27))) ^ ((0x94D049BB133111EBLL * (v22 ^ (v22 >> 27))) >> 31);
      if (!*v50) {
        break;
      }
      unint64_t v24 = v23 % *(unsigned int *)(a1 + 136);
      uint64_t v25 = *(unsigned int *)(*(void *)(a1 + 120) + 4 * v24);
      if (v25 == 0x7FFFFFFF) {
        goto LABEL_21;
      }
      uint64_t v26 = *(void *)(a1 + 128);
      while (*(void *)(v26 + 976 * v25 + 16) != *(void *)v5)
      {
        LODWORD(v25) = *(_DWORD *)(v26 + 976 * v25 + 8) & 0x7FFFFFFF;
        if (v25 == 0x7FFFFFFF) {
          goto LABEL_21;
        }
      }
      uint64_t v35 = v26 + 976 * v25;
LABEL_23:
      uint64_t v36 = v35 + 24;
      *(void *)(v35 + 968) = (*(uint64_t (**)(void))(**(void **)(a1 + 296) + 32))(*(void *)(a1 + 296));
      unsigned int v37 = *(unsigned __int16 *)(v36 + 608);
      if ((v37 > a4 || a4 - v37 >= 0x8000) && (v37 <= a4 || v37 - a4 < 0x8000))
      {
        unsigned int v43 = v37 - 32;
        unsigned int v44 = (unsigned __int16)(v37 - 32);
        if (v44 <= a4 && a4 - (unsigned __int16)v43 < 0x8000) {
          goto LABEL_30;
        }
        unsigned int v45 = (v44 - a4) >> 15;
        if (a4 < (unsigned __int16)v43 && v45 != 0) {
          goto LABEL_30;
        }
        unsigned __int16 v47 = v37 - (v37 < 0x20);
        do
        {
          *(unsigned char *)(v36 + 576 + (v43 & 0x1F)) = 0;
          uint64_t v48 = v36 + 16 * (v43 & 0x1F);
          *(_WORD *)(v48 + 12) = 0;
          *(void *)uint64_t v48 = 0;
          *(_DWORD *)(v48 + 7) = 0;
          ++v43;
        }
        while ((unsigned __int16)v43 != v47);
      }
      else
      {
        unsigned __int16 v38 = v7 - (v37 > v7);
        if (v37 != v38)
        {
          do
          {
            *(unsigned char *)(v36 + 576 + (v37 & 0x1F)) = 0;
            uint64_t v39 = v36 + 16 * (v37 & 0x1F);
            *(_WORD *)(v39 + 12) = 0;
            *(void *)uint64_t v39 = 0;
            *(_DWORD *)(v39 + 7) = 0;
            ++v37;
          }
          while ((unsigned __int16)v37 != v38);
        }
      }
      *(_WORD *)(v36 + 608) = v7;
LABEL_30:
      LOBYTE(vre::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 1;
      *(unsigned char *)(v36 + v8 + 576) = 1;
      *(_WORD *)(v36 + 2 * v8 + 512) = a4;
      unint64_t v41 = *(re::SyncObject **)v5;
      if ((*(unsigned char *)(*(void *)v5 + 128) & 4) == 0) {
        int v40 = (*(unsigned __int8 *)(v5 + 16) >> 1) & 1;
      }
      uint64_t v42 = v36 + 16 * v8;
      *(unsigned char *)(v42 + 9) = v40;
      *(void *)uint64_t v42 = v10;
      *(_WORD *)(v42 + 12) = *((_WORD *)v41 + 88);
LABEL_33:
      v5 += 24;
      if (v5 == v49) {
        return;
      }
    }
    LODWORD(v24) = 0;
LABEL_21:
    unsigned int v34 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove((uint64_t)v50, v24, v23, (uint64_t *)v5, (uint64_t)buf);
    ++*(_DWORD *)(a1 + 152);
    uint64_t v35 = *(void *)(a1 + 128) + 976 * v34;
    goto LABEL_23;
  }
}

uint64_t re::SyncSendBuffer::resetAcks(uint64_t a1, uint64_t *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 288));
  if (WeakRetained)
  {
    uint64_t v5 = WeakRetained;
    re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove((uint64_t)WeakRetained + 16, a2);
  }
  for (uint64_t i = 0; i != 512; i += 16)
  {
    unsigned __int16 v7 = &v18[i];
    *((_WORD *)v7 + 4) = 0;
    v7[10] = 0;
    *((_WORD *)v7 + 6) = 0;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  __int16 v19 = 32;
  do
  {
    v18[v9 + 576] = 0;
    *(_WORD *)&v18[2 * v9 + 512] = v9;
    unint64_t v10 = &v18[v8];
    *((_WORD *)v10 + 6) = 0;
    *(void *)unint64_t v10 = 0;
    *(_DWORD *)(v10 + 7) = 0;
    ++v9;
    v8 += 16;
  }
  while (v9 != 32);
  __int16 v20 = 64;
  int16x8_t v11 = (int16x8_t)xmmword_228CDEEB0;
  int16x8_t v12 = (int16x8_t)xmmword_228CDEEC0;
  uint64_t v13 = 872;
  uint64_t v14 = 744;
  v15.i64[0] = 0x10001000100010;
  v15.i64[1] = 0x10001000100010;
  do
  {
    *(_OWORD *)&v18[v13] = 0uLL;
    int v16 = &v18[v14];
    *(int16x8_t *)int v16 = v12;
    *((int16x8_t *)v16 + 1) = v11;
    int16x8_t v12 = vaddq_s16(v12, v15);
    int16x8_t v11 = vaddq_s16(v11, v15);
    v13 += 16;
    v14 += 32;
  }
  while (v14 != 872);
  uint64_t v21 = 0;
  return re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(a1 + 112, a2, v18);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(uint64_t a1, uint64_t *a2, char *__src)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_10;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_10:
    unsigned int v25 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, v9, v8, a2, (uint64_t)__src);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v24 = *(void *)(a1 + 16) + 976 * v25;
    return v24 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 976 * v10 + 16) != v6)
  {
    int v12 = *(_DWORD *)(v11 + 976 * v10 + 8);
    uint64_t v10 = v12 & 0x7FFFFFFF;
    if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF) {
      goto LABEL_10;
    }
  }
  uint64_t v13 = v11 + 976 * v10;
  uint64_t v14 = v13 + 24;
  if ((char *)(v13 + 24) != __src)
  {
    memmove((void *)(v13 + 24), __src, 0x1FEuLL);
    long long v15 = *((_OWORD *)__src + 35);
    long long v17 = *((_OWORD *)__src + 32);
    long long v16 = *((_OWORD *)__src + 33);
    *(_OWORD *)(v14 + 544) = *((_OWORD *)__src + 34);
    *(_OWORD *)(v14 + 560) = v15;
    *(_OWORD *)(v14 + 512) = v17;
    *(_OWORD *)(v14 + 528) = v16;
    long long v18 = *((_OWORD *)__src + 37);
    *(_OWORD *)(v14 + 576) = *((_OWORD *)__src + 36);
    *(_OWORD *)(v14 + 592) = v18;
    *(_WORD *)(v14 + 608) = *((_WORD *)__src + 304);
    __int16 v19 = (_OWORD *)(v11 + 976 * v10);
    memmove(v19 + 40, __src + 616, 0x80uLL);
    memmove(v19 + 48, __src + 744, 0x80uLL);
    long long v20 = *(_OWORD *)(__src + 920);
    long long v22 = *(_OWORD *)(__src + 872);
    long long v21 = *(_OWORD *)(__src + 888);
    v19[58] = *(_OWORD *)(__src + 904);
    v19[59] = v20;
    v19[56] = v22;
    v19[57] = v21;
  }
  uint64_t v23 = v11 + 976 * v10;
  *(_WORD *)(v23 + 960) = *((_WORD *)__src + 468);
  *(void *)(v23 + 968) = *((void *)__src + 118);
  ++*(_DWORD *)(a1 + 40);
  uint64_t v24 = *(void *)(a1 + 16) + 976 * v10;
  return v24 + 24;
}

uint64_t re::SyncSendBuffer::addAck(uint64_t a1, re::SyncObject **a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 288));
  if (WeakRetained)
  {
    uint64_t v5 = WeakRetained;
    uint64_t v6 = (uint64_t)WeakRetained - 8;
    unint64_t v7 = re::SyncObject::latestStateHandle(*a2);
    re::SyncAckedStateBuffer::addAcked(v6, (uint64_t *)a2, v7, *((unsigned __int16 *)*a2 + 88));
  }
  return re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(a1 + 112, (uint64_t *)a2);
}

void re::SyncSendBuffer::~SyncSendBuffer(re::SyncSendBuffer *this)
{
  re::SyncSendBuffer::~SyncSendBuffer(this);
  JUMPOUT(0x22A6A9430);
}

{
  uint64_t v2;
  __n128 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t i;
  uint64_t v13;
  int v14;
  uint64_t v15;

  *(void *)this = &unk_26DD35598;
  uint64_t v2 = *((void *)this + 37);
  if (v2)
  {

    *((void *)this + 37) = 0;
  }
  objc_destroyWeak((id *)this + 36);
  *((void *)this + 36) = 0;
  objc_destroyWeak((id *)this + 35);
  *((void *)this + 35) = 0;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 240);
  re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)this + 20);
  v3.n128_f64[0] = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 14);
  unint64_t v4 = *((void *)this + 9);
  if (v4)
  {
    uint64_t v5 = *((void *)this + 13);
    if (v5)
    {
      uint64_t v6 = *((void *)this + 11);
      if (v6)
      {
        unint64_t v7 = 24 * v6;
        do
        {
          if (*(void *)v5)
          {

            *(void *)uint64_t v5 = 0;
          }
          v5 += 24;
          v7 -= 24;
        }
        while (v7);
        unint64_t v4 = *((void *)this + 9);
        uint64_t v5 = *((void *)this + 13);
      }
      (*(void (**)(uint64_t, uint64_t, __n128))(*(void *)v4 + 40))(v4, v5, v3);
    }
    *((void *)this + 13) = 0;
    *((void *)this + 10) = 0;
    *((void *)this + 11) = 0;
    *((void *)this + 9) = 0;
    ++*((_DWORD *)this + 24);
  }
  unint64_t v9 = (uint64_t *)((char *)this + 24);
  unint64_t v8 = *((void *)this + 3);
  if (v8)
  {
    uint64_t v10 = *((unsigned int *)this + 14);
    if (v10)
    {
      uint64_t v11 = 0;
      for (uint64_t i = 0; i < v10; ++i)
      {
        uint64_t v13 = *((void *)this + 5) + v11;
        uint64_t v14 = *(_DWORD *)(v13 + 8);
        if (v14 < 0)
        {
          *(_DWORD *)(v13 + 8) = v14 & 0x7FFFFFFF;
          long long v15 = *(void *)(v13 + 16);
          if (v15)
          {

            *(void *)(v13 + 16) = 0;
            uint64_t v10 = *((unsigned int *)this + 14);
          }
        }
        v11 += 40;
      }
      unint64_t v8 = *v9;
    }
    (*(void (**)(uint64_t, void, __n128))(*(void *)v8 + 40))(v8, *((void *)this + 4), v3);
    *((_DWORD *)this + 14) = 0;
    *(_OWORD *)unint64_t v9 = 0u;
    *(_OWORD *)((char *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0u;
    *(void *)((char *)this + 60) = 0x7FFFFFFFLL;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

void re::HashSetBase<re::SyncObject *,re::SyncObject *,re::internal::ValueAsKey<re::SyncObject *>,re::Hash<re::SyncObject *>,re::EqualTo<re::SyncObject *>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4)
{
  uint64_t v7 = *(unsigned int *)(a1 + 36);
  if (v7 == 0x7FFFFFFF)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 32);
    int v8 = v7;
    if (v7 == *(_DWORD *)(a1 + 24))
    {
      int v9 = *(_DWORD *)(a1 + 28);
      signed int v10 = 2 * v9;
      uint64_t v11 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v10) {
          BOOL v12 = v7 == v10;
        }
        else {
          BOOL v12 = 1;
        }
        if (!v12 && (v9 & 0x80000000) == 0)
        {
          memset(v23, 0, 36);
          *(void *)&v23[36] = 0x7FFFFFFFLL;
          re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v23, v11, v10);
          long long v13 = *(_OWORD *)v23;
          *(_OWORD *)uint64_t v23 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v13;
          uint64_t v14 = *(void *)&v23[16];
          uint64_t v15 = *(void *)(a1 + 16);
          *(void *)&v23[16] = v15;
          *(void *)(a1 + 16) = v14;
          long long v17 = *(_OWORD *)&v23[24];
          *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
          unsigned int v16 = *(_DWORD *)&v23[32];
          *(_OWORD *)(a1 + 24) = v17;
          uint64_t v18 = v16;
          if (v16)
          {
            uint64_t v19 = v15 + 16;
            do
            {
              if ((*(_DWORD *)(v19 - 8) & 0x80000000) != 0) {
                re::HashSetBase<re::SyncObject *,re::SyncObject *,re::internal::ValueAsKey<re::SyncObject *>,re::Hash<re::SyncObject *>,re::EqualTo<re::SyncObject *>,true,false>::addAsMove(a1, *(void *)(v19 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v19 - 16), v19);
              }
              v19 += 24;
              --v18;
            }
            while (v18);
          }
          re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)v23);
        }
      }
      else
      {
        if (v10) {
          signed int v22 = v10;
        }
        else {
          signed int v22 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    uint64_t v20 = *(void *)(a1 + 16);
    int v21 = *(_DWORD *)(v20 + 24 * v7 + 8);
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 16);
    int v21 = *(_DWORD *)(v20 + 24 * v7 + 8);
    *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v20 + 24 * v7 + 8) = v21 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v7 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v7 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v7) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v7 + 16) = *a4;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v7;
  ++*(_DWORD *)(a1 + 28);
}

void *re::DynamicArray<re::Pair<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::StateData,true>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      BOOL result = (void *)*result;
      if (!*v5)
      {
        BOOL result = (void *)re::DynamicArray<re::Pair<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::StateData,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x18uLL))
        {
          uint64_t v2 = 24 * a2;
          BOOL result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        BOOL result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 24 * v9;
        uint64_t v11 = v7;
        do
        {
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          *(_OWORD *)(v11 + 1) = *(_OWORD *)(v8 + 8);
          if (*(void *)v8)
          {

            *(void *)uint64_t v8 = 0;
          }
          v8 += 24;
          v11 += 3;
          v10 -= 24;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      BOOL result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v43, 0, 36);
          *(void *)&v43[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v43, v13, v12);
          long long v15 = *(_OWORD *)v43;
          *(_OWORD *)unsigned int v43 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v43[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v43[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v43[24];
          *(_OWORD *)&v43[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v43[32];
          *(_OWORD *)(a1 + 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            uint64_t v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0) {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(void *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v21 - 16), v21, v21 + 8);
              }
              v21 += 976;
              --v20;
            }
            while (v20);
          }
          re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v43);
        }
      }
      else
      {
        if (v12) {
          signed int v24 = 2 * v11;
        }
        else {
          signed int v24 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 976 * v9 + 8);
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 976 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  uint64_t v25 = 976 * v9;
  *(_DWORD *)(v22 + v25 + 8) = v23 | 0x80000000;
  uint64_t v26 = a2;
  *(_DWORD *)(*(void *)(a1 + 16) + v25 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + v25 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + v25) = a3;
  uint64_t v27 = *a4;
  *(void *)(*(void *)(a1 + 16) + v25 + 16) = *a4;
  if (v27) {
    id v28 = (id)(v27 + 8);
  }
  uint64_t v29 = 0;
  uint64_t v30 = *(void *)(a1 + 16);
  uint64_t v31 = v30 + 976 * v9;
  uint64_t v32 = v31 + 24;
  do
  {
    uint64_t v33 = v31 + v29;
    *(_WORD *)(v33 + 32) = 0;
    *(unsigned char *)(v33 + 34) = 0;
    *(_WORD *)(v33 + 36) = 0;
    v29 += 16;
  }
  while (v29 != 512);
  memmove((void *)(v31 + 24), (const void *)a5, 0x1FEuLL);
  long long v34 = *(_OWORD *)(a5 + 560);
  long long v36 = *(_OWORD *)(a5 + 512);
  long long v35 = *(_OWORD *)(a5 + 528);
  *(_OWORD *)(v32 + 544) = *(_OWORD *)(a5 + 544);
  *(_OWORD *)(v32 + 560) = v34;
  *(_OWORD *)(v32 + 512) = v36;
  *(_OWORD *)(v32 + 528) = v35;
  long long v37 = *(_OWORD *)(a5 + 592);
  *(_OWORD *)(v32 + 576) = *(_OWORD *)(a5 + 576);
  *(_OWORD *)(v32 + 592) = v37;
  *(_WORD *)(v32 + 608) = *(_WORD *)(a5 + 608);
  uint64_t v38 = v30 + 976 * v9;
  memmove((void *)(v38 + 640), (const void *)(a5 + 616), 0x80uLL);
  memmove((void *)(v38 + 768), (const void *)(a5 + 744), 0x80uLL);
  long long v39 = *(_OWORD *)(a5 + 872);
  long long v40 = *(_OWORD *)(a5 + 888);
  long long v41 = *(_OWORD *)(a5 + 920);
  *(_OWORD *)(v38 + 928) = *(_OWORD *)(a5 + 904);
  *(_OWORD *)(v38 + 944) = v41;
  *(_OWORD *)(v38 + 896) = v39;
  *(_OWORD *)(v38 + 912) = v40;
  *(_WORD *)(v38 + 960) = *(_WORD *)(a5 + 936);
  *(void *)(v38 + 968) = *(void *)(a5 + 944);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v26) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 976 * v10, 16);
  if (v12)
  {
    BOOL v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

double re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSendBuffer::ResendData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          uint64_t v8 = *(void *)(v6 + 16);
          if (v8)
          {

            *(void *)(v6 + 16) = 0;
            unint64_t v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 976;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::SyncUnpacker::unpackCommit(_anonymous_namespace_ *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(unsigned char *)(a4 + 24) & 0x20) != 0)
  {
    uint64_t v9 = *(unsigned int *)(a2 + 16);
    if (*(unsigned char *)(a2 + 12)) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = *(void *)a2 + v9;
    }
    uint64_t v11 = (*(_DWORD *)(a2 + 8) - v9);
    v14[0] = v10;
    v14[1] = v11;
    int v17 = -1;
    char v18 = 0;
    uint64_t v19 = 0;
    uint64_t v21 = 0;
    uint64_t v15 = v10;
    uint64_t v16 = v10 + v11;
    uint64_t result = re::SyncUnpacker::parseCommit((uint64_t **)this, (re::snapshot::DecoderOPACK *)v14, a3, a4);
    if (!*(unsigned char *)(a2 + 12))
    {
      int v12 = v15 - LODWORD(v14[0]);
      *(void *)(a2 + 24) = 0;
      unsigned int v13 = *(_DWORD *)(a2 + 16) + v12;
      *(void *)(a2 + 16) = v13;
      if (v13 > *(_DWORD *)(a2 + 8)) {
        *(unsigned char *)(a2 + 12) = 1;
      }
    }
  }
  else
  {
    return re::SyncUnpacker::parseCommit((uint64_t **)this, (re::BitReader *)a2, a3, a4);
  }
  return result;
}

uint64_t re::SyncUnpacker::parseCommit(uint64_t **a1, re::snapshot::DecoderOPACK *this, uint64_t a3, uint64_t a4)
{
  uint64_t v161 = *MEMORY[0x263EF8340];
  uint64_t v8 = (re *)re::snapshot::DecoderOPACK::beginObject(this, 0);
  if ((v8 & 1) == 0)
  {
    uint64_t v119 = *re::networkLogObjects(v8);
    uint64_t result = os_log_type_enabled(v119, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)sockaddr buf = 0;
      char v121 = "Commit doesn't begin with an object header";
      goto LABEL_218;
    }
    return result;
  }
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>((uint64_t)this, (unsigned char *)a3);
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned long long>((uint64_t)this, (void *)(a3 + 16));
  re::snapshot::DecoderOPACK::endObject((uint64_t *)this, 0);
  *(void *)(a3 + 8) = a1[2];
  unint64_t v131 = 0;
  uint64_t v9 = (re *)re::snapshot::DecoderOPACK::beginDictionary(this, &v131);
  if (v9)
  {
    v130 = (_anonymous_namespace_ *)(a3 + 32);
    while (1)
    {
      if (re::snapshot::DecoderOPACK::endDictionary(this, &v131)) {
        return 2;
      }
      Integer = (re *)re::snapshot::DecoderOPACK::readInteger(this, 0);
      uint64_t v11 = Integer;
      if (Integer == -1)
      {
        v122 = *re::networkLogObjects(Integer);
        uint64_t shouldAcceptUpdate = os_log_type_enabled(v122, OS_LOG_TYPE_ERROR);
        if (!shouldAcceptUpdate) {
          goto LABEL_216;
        }
        *(_WORD *)sockaddr buf = 0;
        uint64_t v123 = "Expected object short id";
        goto LABEL_221;
      }
      int v12 = (re *)re::snapshot::DecoderOPACK::beginObject(this, 0);
      if ((v12 & 1) == 0)
      {
        v122 = *re::networkLogObjects(v12);
        uint64_t shouldAcceptUpdate = os_log_type_enabled(v122, OS_LOG_TYPE_ERROR);
        if (!shouldAcceptUpdate) {
          goto LABEL_216;
        }
        *(_WORD *)sockaddr buf = 0;
        uint64_t v123 = "Expected object header";
        goto LABEL_221;
      }
      unsigned __int8 v143 = 0;
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>((uint64_t)this, &v143);
      unsigned __int16 v142 = 0;
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned short>((uint64_t)this, &v142);
      *(void *)&long long v139 = 0;
      WORD4(v139) = 0;
      LOBYTE(v140[0]) = 0;
      v140[1] = 0;
      *(_DWORD *)v141 = 0x10000;
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,re::SyncOwnershipInfo>((uint64_t)this, (uint64_t)&v139);
      unint64_t v13 = v140[1];
      if (!v140[1])
      {
        unint64_t v13 = (unint64_t)a1[2];
        v140[1] = v13;
      }
      BOOL v14 = (uint64_t *)v13 == a1[3] || *((unsigned char *)a1 + 120) && v13 == *(void *)(a4 + 8);
      LOBYTE(v141[1]) = v14;
      unsigned __int8 v15 = v143;
      v138 = (re::SyncOpaqueTypeInfo *)-1;
      int v16 = v143 & 5;
      if (v16)
      {
        if (re::snapshot::DecoderOPACK::advanceTo<5>((uint64_t)this))
        {
          uint64_t v17 = re::snapshot::DecoderOPACK::readInteger(this, 0);
          char v18 = (unsigned __int8 *)*((void *)this + 2);
          if ((unint64_t)v18 >= *((void *)this + 3) || (int v19 = *v18, v19 == 3))
          {
            int v20 = 0x7FFFFFFF;
          }
          else if ((v19 - 7) > 0x28)
          {
            int v20 = re::snapshot::DecoderOPACK::readInteger(this, 0x7FFFFFFFLL);
          }
          else
          {
            *((void *)this + 2) = v18 + 1;
            int v20 = v19 - 8;
          }
          *((_DWORD *)this + 8) = v20;
        }
        else
        {
          uint64_t v17 = 0;
        }
        re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<6,unsigned long long>((uint64_t)this, &v138);
      }
      else
      {
        uint64_t v17 = 0;
      }
      int v21 = *((_DWORD *)this + 8);
      if (v21 <= 6) {
        break;
      }
LABEL_34:
      if (v21 == 7)
      {
        unsigned __int16 v26 = re::snapshot::DecoderOPACK::readInteger(this, 0);
        uint64_t v27 = (unsigned __int8 *)*((void *)this + 2);
        if ((unint64_t)v27 < *((void *)this + 3))
        {
          int v28 = *v27;
          if (v28 != 3)
          {
            if ((v28 - 7) > 0x28)
            {
              int v29 = re::snapshot::DecoderOPACK::readInteger(this, 0x7FFFFFFFLL);
            }
            else
            {
              *((void *)this + 2) = v27 + 1;
              int v29 = v28 - 8;
            }
            goto LABEL_41;
          }
        }
LABEL_40:
        int v29 = 0x7FFFFFFF;
LABEL_41:
        *((_DWORD *)this + 8) = v29;
        goto LABEL_43;
      }
      unsigned __int16 v26 = 0;
LABEL_43:
      uint64_t v136 = -1;
      uint64_t v137 = 0;
      if (v15)
      {
        re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<8,unsigned long long>((uint64_t)this, &v136);
        re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<9,unsigned long long>((uint64_t)this, &v137);
      }
      uint64_t v134 = 0;
      uint64_t v135 = 0;
      uint64_t v30 = (re *)re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<11,re::Slice<unsigned char>>((uint64_t)this, &v134);
      if (*((void *)this + 3) == *((void *)this + 2))
      {
        v122 = *re::networkLogObjects(v30);
        uint64_t shouldAcceptUpdate = os_log_type_enabled(v122, OS_LOG_TYPE_ERROR);
        if (!shouldAcceptUpdate) {
          goto LABEL_216;
        }
        *(_WORD *)sockaddr buf = 0;
        uint64_t v123 = "Failed to unpack sync object.";
LABEL_221:
        _os_log_error_impl(&dword_228C70000, v122, OS_LOG_TYPE_ERROR, v123, buf, 2u);
LABEL_216:
        uint64_t v119 = *re::networkLogObjects((re *)shouldAcceptUpdate);
        uint64_t result = os_log_type_enabled(v119, OS_LOG_TYPE_ERROR);
        if (result)
        {
          *(_WORD *)sockaddr buf = 0;
          char v121 = "Failure reading object in commit";
LABEL_218:
          _os_log_error_impl(&dword_228C70000, v119, OS_LOG_TYPE_ERROR, v121, buf, 2u);
          return 0;
        }
        return result;
      }
      re::snapshot::DecoderOPACK::endObject((uint64_t *)this, 0);
      uint64_t v31 = *a1;
      if (v16)
      {
        uint64_t v32 = *v31;
        if ((v15 & 4) != 0) {
          (*(void (**)(void))(v32 + 64))();
        }
        else {
          (*(void (**)(void))(v32 + 48))();
        }
      }
      else
      {
        uint64_t v17 = (*(uint64_t (**)(uint64_t *, re *))(*v31 + 56))(v31, v11);
        v138 = v33;
      }
      long long v34 = a1[1];
      *(void *)sockaddr buf = v138;
      long long v35 = (re *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(v34 + 63), (uint64_t *)buf);
      if (!v35 || (uint64_t v36 = *(void *)(*(void *)v35 + 16)) == 0)
      {
        long long v37 = *re::networkLogObjects(v35);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)sockaddr buf = 134217984;
          *(void *)&uint8_t buf[4] = v138;
          _os_log_impl(&dword_228C70000, v37, OS_LOG_TYPE_DEFAULT, "Unknown object typeID=%llu. Assuming opaque type.", buf, 0xCu);
        }
        uint64_t v38 = (re::SyncObjectStore *)a1[1];
        re::SyncOpaqueTypeInfo::make(v138, (uint64_t)buf);
        re::SyncObjectStore::addType(v38, (const re::SyncObjectTypeInfo *)buf);
        re::SyncObjectTypeInfo::~SyncObjectTypeInfo((re::SyncObjectTypeInfo *)buf);
        long long v39 = a1[1];
        *(void *)sockaddr buf = v138;
        uint64_t v40 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(v39 + 63), (uint64_t *)buf);
        if (v40) {
          uint64_t v36 = *(void *)(*(void *)v40 + 16);
        }
        else {
          uint64_t v36 = 0;
        }
      }
      uint64_t shouldAcceptUpdate = *(void *)(v36 + 136);
      if (!shouldAcceptUpdate
        || (uint64_t shouldAcceptUpdate = (*(uint64_t (**)(uint64_t, uint64_t))(shouldAcceptUpdate + 16))(shouldAcceptUpdate, a4), shouldAcceptUpdate))
      {
        if (!v17)
        {
          unsigned __int16 v47 = *re::networkLogObjects((re *)shouldAcceptUpdate);
          int v46 = 2;
          uint64_t shouldAcceptUpdate = os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG);
          if (shouldAcceptUpdate)
          {
            *(_DWORD *)sockaddr buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v11;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v143;
            _os_log_debug_impl(&dword_228C70000, v47, OS_LOG_TYPE_DEBUG, "Cannot find guid for object with id=%d, flags=0x%02X. Skipping update.", buf, 0xEu);
          }
          goto LABEL_200;
        }
        uint64_t Object = re::SyncObjectStore::findObject((re::SyncObjectStore *)a1[1], (uint64_t)v138, v17, (re::SyncObjectTypedStore ***)&v133);
        unsigned int v43 = v133;
        if (v133)
        {
          if (v15)
          {
            uint64_t v45 = 0;
LABEL_74:
            int v52 = 1;
          }
          else
          {
            uint64_t Baseline = re::SyncObject::findBaseline(v133, v26, (uint64_t)a1[2]);
            if (Baseline)
            {
              uint64_t v45 = Baseline;
              goto LABEL_74;
            }
            unint64_t v71 = *re::networkLogObjects(0);
            if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
            {
              if (*(unsigned char *)(v36 + 48)) {
                uint64_t v72 = *(void *)(v36 + 56);
              }
              else {
                uint64_t v72 = v36 + 49;
              }
              *(_DWORD *)sockaddr buf = 134218498;
              *(void *)&uint8_t buf[4] = v17;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v72;
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)v156 = v138;
              _os_log_impl(&dword_228C70000, v71, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing baseline for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
            }
            if ((v15 & 4) == 0)
            {
              *(void *)sockaddr buf = v138;
              *(void *)&uint8_t buf[8] = v17;
              re::DynamicArray<re::PoolAllocator::PoolFreeList>::add((uint64_t)(a1 + 10), (__n128 *)buf);
            }
            int v52 = 0;
            uint64_t v45 = 0;
          }
          __int16 v53 = v43;
LABEL_76:
          uint64_t shouldAcceptUpdate = re::SyncObject::shouldAcceptUpdate(v53, v140[1], v141[0]);
          if (*((unsigned char *)a1 + 121) || shouldAcceptUpdate)
          {
            if (shouldAcceptUpdate
              && (uint64_t v54 = a1[3],
                  unsigned int v55 = *((unsigned __int16 *)v53 + 84),
                  long long v56 = *(_OWORD *)v140,
                  *(_OWORD *)((char *)v53 + 136) = v139,
                  *(_OWORD *)((char *)v53 + 152) = v56,
                  *((_DWORD *)v53 + 42) = *(_DWORD *)v141,
                  *(unsigned char *)(*(void *)(*((void *)v53 + 11) + 16) + 73))
              && (v55 < v141[0] || ((uint64_t *)v139 == v54 ? (BOOL v57 = (void)v139 == 0) : (BOOL v57 = 1), !v57)))
            {
              char v129 = 4;
              if (!v52)
              {
LABEL_98:
                char v65 = 0;
LABEL_99:
                if (v137 && !*((void *)v53 + 10))
                {
                  *(void *)sockaddr buf = v136;
                  *(void *)&uint8_t buf[8] = v137;
                  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace((uint64_t)(a1 + 4), (uint64_t *)&v133, buf);
                  __int16 v53 = v133;
                }
                unint64_t v66 = re::SyncObject::latestStateHandle(v53);
                if (v66 != -1)
                {
                  unint64_t v67 = v66;
                  memset(buf, 0, 17);
                  re::SharedPtr<re::SyncObject>::reset((uint64_t *)buf, (uint64_t)v133);
                  *(void *)&uint8_t buf[8] = v67;
                  char v68 = v129 | v65 | buf[16] & 0xF2 | (v43 == 0);
                  uint8_t buf[16] = v68;
                  if ((v15 & 4) != 0)
                  {
                    *((unsigned char *)v133 + 128) |= 4u;
                    uint8_t buf[16] = v68 | 2;
                  }
                  uint64_t shouldAcceptUpdate = (uint64_t)re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v130, (uint64_t)buf);
                  if (*(void *)buf) {

                  }
LABEL_144:
                  int v46 = 2;
LABEL_198:
                  if (v133) {

                  }
                  goto LABEL_200;
                }
                uint64_t v73 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
                uint64_t shouldAcceptUpdate = os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
                if (shouldAcceptUpdate)
                {
                  uint64_t v74 = *((void *)v133 + 3);
                  unint64_t v75 = *(void **)(*((void *)v133 + 11) + 16);
                  uint64_t v76 = v75[4];
                  uint64_t v77 = v75[6];
                  unsigned __int8 v78 = (char *)v75[7];
                  unint64_t v79 = (char *)v75 + 49;
                  if (v77) {
                    unint64_t v79 = v78;
                  }
                  *(_DWORD *)sockaddr buf = 134218498;
                  *(void *)&uint8_t buf[4] = v74;
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&buf[14] = v76;
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  *(void *)v156 = v79;
                  _os_log_error_impl(&dword_228C70000, v73, OS_LOG_TYPE_ERROR, "Sync object without snapshot while parsing object (id: %llu, type: %llu[%s]).", buf, 0x20u);
                }
LABEL_197:
                int v46 = 0;
                goto LABEL_198;
              }
            }
            else
            {
              char v129 = 0;
              if (!v52) {
                goto LABEL_98;
              }
            }
            if (!re::SyncObject::isStateDataChanged(v53, v142, (uint64_t)a1[2])) {
              goto LABEL_98;
            }
            unsigned __int16 v128 = v142;
            uint64_t v124 = v134;
            int log = v135;
            DWORD2(v150) = 0;
            BYTE12(v150) = 0;
            long long v151 = 0uLL;
            v149 = &unk_26DD35FD0;
            *(void *)&long long v150 = 0;
            uint64_t v154 = 0;
            int v153 = 0;
            memset(v152, 0, sizeof(v152));
            if (*((void *)v53 + 9) - *((void *)v53 + 8) == *((void *)v53 + 6)
              && (OldestState = (re *)re::SyncObject::getOldestState(v53), OldestState == (re *)v45))
            {
              uint64_t v94 = *re::networkLogObjects(OldestState);
              if (os_log_type_enabled(v94, OS_LOG_TYPE_INFO))
              {
                *(_WORD *)sockaddr buf = 0;
                _os_log_impl(&dword_228C70000, v94, OS_LOG_TYPE_INFO, "Baseline would be invalidated by new state! Will read into temp location.", buf, 2u);
              }
              uint64_t v60 = &v149;
              unsigned __int16 v59 = v128;
            }
            else
            {
              unsigned __int16 v59 = v128;
              uint64_t v60 = (void **)re::SyncObject::addState(v53, v128, (uint64_t)a1[2]);
            }
            *((_WORD *)v53 + 88) = v59;
            uint64_t v144 = v124;
            int v145 = log;
            char v146 = 0;
            uint64_t v147 = 0;
            uint64_t v148 = 0;
            if (v45)
            {
              uint64_t v61 = *(void *)(v36 + 104);
              uint64_t v62 = v60;
              if (v61)
              {
                int v63 = *(_DWORD *)(v45 + 24);
                if (*(_DWORD *)(v45 + 28)) {
                  ++v63;
                }
                *(void *)sockaddr buf = *(void *)(v45 + 8);
                *(_DWORD *)&uint8_t buf[8] = v63;
                unsigned char buf[12] = 0;
                *(void *)&uint8_t buf[16] = 0;
                *(void *)v156 = 0;
                uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t *, unsigned char *, void **, uint64_t))(v61 + 16))(v61, &v144, buf, v62, a4);
                if (v64) {
                  goto LABEL_168;
                }
LABEL_161:
                if (v62 != &v149)
                {
                  uint64_t v96 = *((void *)v53 + 9);
                  if (*((void *)v53 + 8) != v96) {
                    *((void *)v53 + 9) = v96 - 1;
                  }
                }
                unsigned int v97 = *re::networkLogObjects((re *)v64);
                if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v113 = *((void *)v53 + 3);
                  uint64_t v114 = a1[2];
                  *(_DWORD *)sockaddr buf = 134218240;
                  *(void *)&uint8_t buf[4] = v113;
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&buf[14] = v114;
                  _os_log_error_impl(&dword_228C70000, v97, OS_LOG_TYPE_ERROR, "Failed to parse object data.(guid=%llu, peerID=%llu)", buf, 0x16u);
                }
                int v98 = 0;
              }
              else
              {
                loga = *re::networkLogObjects(0);
                uint64_t v64 = os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT);
                if (v64)
                {
                  uint64_t v90 = *((void *)v53 + 3);
                  uint64_t v91 = *(void *)(v36 + 32);
                  if (*(void *)(v36 + 48)) {
                    uint64_t v92 = *(void *)(v36 + 56);
                  }
                  else {
                    uint64_t v92 = v36 + 49;
                  }
                  *(_DWORD *)sockaddr buf = 134218498;
                  *(void *)&uint8_t buf[4] = v90;
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&buf[14] = v91;
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  *(void *)v156 = v92;
                  _os_log_impl(&dword_228C70000, loga, OS_LOG_TYPE_DEFAULT, "Cannot parse state for syncobject %llu of type %llu(%s), readDeltaCb not available.", buf, 0x20u);
                }
                if (v62 == &v149 || (uint64_t v93 = *((void *)v53 + 9), *((void *)v53 + 8) == v93))
                {
                  uint64_t v62 = 0;
                }
                else
                {
                  uint64_t v62 = 0;
                  *((void *)v53 + 9) = v93 - 1;
                }
LABEL_168:
                if (v145 != v147)
                {
                  logb = *re::networkLogObjects((re *)v64);
                  if (os_log_type_enabled(logb, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v99 = "readDeltaCb";
                    if (!v45) {
                      uint64_t v99 = "readCb";
                    }
                    if (*(void *)(v36 + 48)) {
                      uint64_t v100 = *(void *)(v36 + 56);
                    }
                    else {
                      uint64_t v100 = v36 + 49;
                    }
                    uint64_t v101 = *(void *)(v36 + 32);
                    *(_DWORD *)sockaddr buf = 136315650;
                    *(void *)&uint8_t buf[4] = v99;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = v100;
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    *(void *)v156 = v101;
                    _os_log_impl(&dword_228C70000, logb, OS_LOG_TYPE_DEFAULT, "Read buffer is not fully consumed by %s of type %s: %llu", buf, 0x20u);
                  }
                }
                if (v62 == &v149)
                {
                  unint64_t v107 = re::SyncObject::addState(v53, v128, (uint64_t)a1[2]);
                  uint64_t v108 = *(void *)(v107 + 40);
                  v107 += 40;
                  long long v109 = *(_OWORD *)(v107 - 16);
                  *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v107 - 32);
                  *(_OWORD *)v156 = v109;
                  *(void *)sockaddr buf = &unk_26DD35FD0;
                  *(void *)&v156[16] = v108;
                  *(void *)unint64_t v107 = 0;
                  uint64_t v110 = *(void *)(v107 + 16);
                  uint64_t v157 = *(void *)(v107 + 8);
                  *(void *)(v107 + 8) = 0;
                  uint64_t v158 = v110;
                  *(void *)(v107 + 16) = 0;
                  uint64_t v160 = *(void *)(v107 + 32);
                  *(void *)(v107 + 32) = 0;
                  ++*(_DWORD *)(v107 + 24);
                  int v159 = 1;
                  long long v111 = v151;
                  *(_OWORD *)(v107 - 32) = v150;
                  *(_OWORD *)(v107 - 16) = v111;
                  re::DynamicArray<unsigned char>::operator=(v107, (uint64_t)v152);
                  long long v150 = *(_OWORD *)&buf[8];
                  long long v151 = *(_OWORD *)v156;
                  re::DynamicArray<unsigned char>::operator=((uint64_t)v152, (uint64_t)&v156[16]);
                  if (*(void *)&v156[16])
                  {
                    if (v160) {
                      (*(void (**)(void))(**(void **)&v156[16] + 40))();
                    }
                  }
                }
                int v98 = 1;
              }
              uint64_t v102 = (re *)v152[0];
              if (v152[0] && v154) {
                uint64_t v102 = (re *)(*(uint64_t (**)(void))(*(void *)v152[0] + 40))();
              }
              if (v98)
              {
                char v65 = 8;
                __int16 v53 = v133;
                goto LABEL_99;
              }
              uint64_t v103 = *re::networkLogObjects(v102);
              uint64_t shouldAcceptUpdate = os_log_type_enabled(v103, OS_LOG_TYPE_ERROR);
              if (shouldAcceptUpdate)
              {
                if (*(unsigned char *)(v36 + 48)) {
                  uint64_t v112 = *(void *)(v36 + 56);
                }
                else {
                  uint64_t v112 = v36 + 49;
                }
                v115 = a1[2];
                *(_DWORD *)sockaddr buf = 134218754;
                *(void *)&uint8_t buf[4] = v17;
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v138;
                *(_WORD *)&unsigned char buf[22] = 2080;
                *(void *)v156 = v112;
                *(_WORD *)&v156[8] = 2048;
                *(void *)&v156[10] = v115;
                _os_log_error_impl(&dword_228C70000, v103, OS_LOG_TYPE_ERROR, "Failed to parse object state.(guid=%llu, type=%llu(%s), peerID=%llu)", buf, 0x2Au);
                if (v43) {
                  goto LABEL_197;
                }
              }
              else if (v43)
              {
                goto LABEL_197;
              }
              uint64_t v104 = (uint64_t)a1[1];
              v132 = v133;
              if (v133)
              {
                int v105 = (char *)v133 + 8;
                uint64_t v106 = (char *)v133 + 8;
                re::SyncObjectStore::removeObject(v104, (uint64_t *)&v132);
              }
              else
              {
                re::SyncObjectStore::removeObject(v104, (uint64_t *)&v132);
              }
              goto LABEL_197;
            }
            uint64_t v88 = *(void *)(v36 + 96);
            uint64_t v62 = v60;
            if (v88)
            {
              uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t *, void **, uint64_t))(v88 + 16))(v88, &v144, v60, a4);
              if (v64) {
                goto LABEL_168;
              }
            }
            else
            {
              id v95 = *re::networkLogObjects(0);
              uint64_t v64 = os_log_type_enabled(v95, OS_LOG_TYPE_ERROR);
              if (v64)
              {
                uint64_t v116 = *((void *)v53 + 3);
                uint64_t v117 = *(void *)(v36 + 32);
                if (*(void *)(v36 + 48)) {
                  uint64_t v118 = *(void *)(v36 + 56);
                }
                else {
                  uint64_t v118 = v36 + 49;
                }
                *(_DWORD *)sockaddr buf = 134218498;
                *(void *)&uint8_t buf[4] = v116;
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v117;
                *(_WORD *)&unsigned char buf[22] = 2080;
                *(void *)v156 = v118;
                _os_log_error_impl(&dword_228C70000, v95, OS_LOG_TYPE_ERROR, "Cannot parse state for syncobject %llu of type %llu(%s), readCb not available.", buf, 0x20u);
              }
            }
            goto LABEL_161;
          }
LABEL_125:
          int v46 = 2;
          goto LABEL_198;
        }
        if ((v15 & 4) == 0)
        {
          uint64_t v48 = a1[1];
          *(void *)sockaddr buf = v17;
          *(void *)&uint8_t buf[8] = v138;
          *(void *)&uint8_t buf[16] = 0;
          BOOL v49 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v48 + 75), (uint64_t *)buf);
          if (v49)
          {
            int v50 = *re::networkLogObjects((re *)v49);
            uint64_t shouldAcceptUpdate = os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
            if (!shouldAcceptUpdate) {
              goto LABEL_125;
            }
            if (*(unsigned char *)(v36 + 48)) {
              uint64_t v51 = *(void *)(v36 + 56);
            }
            else {
              uint64_t v51 = v36 + 49;
            }
            *(_DWORD *)sockaddr buf = 134218498;
            *(void *)&uint8_t buf[4] = v17;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v51;
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(void *)v156 = v138;
            char v84 = v50;
            unint64_t v85 = "Discarding incoming object already tombstoned, guid=%llu, type=%s(%llu)";
LABEL_142:
            uint32_t v89 = 32;
          }
          else
          {
            id v80 = a1[1];
            *(void *)sockaddr buf = v137;
            *(void *)&uint8_t buf[8] = v136;
            *(void *)&uint8_t buf[16] = 0;
            BOOL v81 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v80 + 75), (uint64_t *)buf);
            if (!v81)
            {
              if (v15)
              {
                re::SyncObjectStore::createIncomingObject((re::SyncObjectStore *)a1[1], (const re::SyncOwnershipInfo *)&v139, (unint64_t)v138, v17, (uint64_t *)buf);
                uint64_t v45 = 0;
                __int16 v53 = *(re::SyncObject **)buf;
                uint64_t v133 = *(re::SyncObject **)buf;
                int v52 = 1;
                goto LABEL_76;
              }
              uint64_t v86 = *re::networkLogObjects((re *)v81);
              uint64_t shouldAcceptUpdate = os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT);
              if (shouldAcceptUpdate)
              {
                if (*(unsigned char *)(v36 + 48)) {
                  uint64_t v87 = *(void *)(v36 + 56);
                }
                else {
                  uint64_t v87 = v36 + 49;
                }
                *(_DWORD *)sockaddr buf = 134218498;
                *(void *)&uint8_t buf[4] = v17;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v87;
                *(_WORD *)&unsigned char buf[22] = 2048;
                *(void *)v156 = v138;
                _os_log_impl(&dword_228C70000, v86, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing object for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
                int v46 = 1;
              }
              else
              {
                int v46 = 1;
              }
              goto LABEL_198;
            }
            unint64_t v82 = *re::networkLogObjects((re *)v81);
            uint64_t shouldAcceptUpdate = os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT);
            if (!shouldAcceptUpdate) {
              goto LABEL_125;
            }
            if (*(unsigned char *)(v36 + 48)) {
              uint64_t v83 = *(void *)(v36 + 56);
            }
            else {
              uint64_t v83 = v36 + 49;
            }
            *(_DWORD *)sockaddr buf = 134218754;
            *(void *)&uint8_t buf[4] = v17;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v83;
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(void *)v156 = v138;
            *(_WORD *)&v156[8] = 2048;
            *(void *)&v156[10] = v137;
            char v84 = v82;
            unint64_t v85 = "Discarding incoming object with parent already tombstoned, guid=%llu, type=%s(%llu), parentGuid=%llu";
            uint32_t v89 = 42;
          }
          _os_log_impl(&dword_228C70000, v84, OS_LOG_TYPE_DEFAULT, v85, buf, v89);
          goto LABEL_144;
        }
        unint64_t v69 = *re::networkLogObjects((re *)Object);
        uint64_t shouldAcceptUpdate = os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT);
        if (!shouldAcceptUpdate) {
          goto LABEL_125;
        }
        if (*(unsigned char *)(v36 + 48)) {
          uint64_t v70 = *(void *)(v36 + 56);
        }
        else {
          uint64_t v70 = v36 + 49;
        }
        *(_DWORD *)sockaddr buf = 134218498;
        *(void *)&uint8_t buf[4] = v17;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v70;
        *(_WORD *)&unsigned char buf[22] = 2048;
        *(void *)v156 = v138;
        char v84 = v69;
        unint64_t v85 = "Discarding incoming object already in destroyed state, guid=%llu, type=%s(%llu)";
        goto LABEL_142;
      }
      int v46 = 2;
LABEL_200:
      if (!v46) {
        goto LABEL_216;
      }
    }
    while (1)
    {
      uint64_t v22 = (unsigned __int8 *)*((void *)this + 2);
      if ((unint64_t)v22 >= *((void *)this + 3))
      {
        int v23 = 0;
      }
      else
      {
        *((void *)this + 2) = v22 + 1;
        int v23 = *v22;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)this, v23);
      signed int v24 = (unsigned __int8 *)*((void *)this + 2);
      if ((unint64_t)v24 >= *((void *)this + 3)) {
        break;
      }
      int v25 = *v24;
      if (v25 == 3) {
        break;
      }
      if ((v25 - 7) > 0x28)
      {
        int v21 = re::snapshot::DecoderOPACK::readInteger(this, 0x7FFFFFFFLL);
      }
      else
      {
        *((void *)this + 2) = v24 + 1;
        int v21 = v25 - 8;
      }
      *((_DWORD *)this + 8) = v21;
      if (v21 >= 7) {
        goto LABEL_34;
      }
    }
    unsigned __int16 v26 = 0;
    goto LABEL_40;
  }
  uint64_t v119 = *re::networkLogObjects(v9);
  uint64_t result = os_log_type_enabled(v119, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)sockaddr buf = 0;
    char v121 = "Expected dictionary of entries";
    goto LABEL_218;
  }
  return result;
}

uint64_t re::SyncUnpacker::parseCommit(uint64_t **a1, re::BitReader *this, uint64_t a3, uint64_t a4)
{
  uint64_t v201 = *MEMORY[0x263EF8340];
  *(_DWORD *)sockaddr buf = 0;
  re::BitReader::readUInt32Bits((uint64_t *)this, 8u, (unsigned int *)buf);
  char v7 = buf[0];
  *(unsigned char *)a3 = buf[0];
  if ((v7 & 2) != 0) {
    re::BitReader::readUInt64(this, (unint64_t *)(a3 + 16));
  }
  *(void *)(a3 + 8) = a1[2];
  *(_DWORD *)sockaddr buf = 0;
  UInt32Bits = re::BitReader::readUInt32Bits((uint64_t *)this, 0x20u, (unsigned int *)buf);
  if (*((unsigned char *)this + 12))
  {
    uint64_t v9 = *re::networkLogObjects((re *)UInt32Bits);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      uint64_t v147 = "Failed to parse commit header.";
      uint64_t v148 = v9;
      uint32_t v149 = 2;
LABEL_207:
      _os_log_error_impl(&dword_228C70000, v148, OS_LOG_TYPE_ERROR, v147, buf, v149);
    }
    return 0;
  }
  int v167 = *(_DWORD *)buf;
  if (!*(_DWORD *)buf) {
    return 2;
  }
  int v12 = 0;
  uint64_t v161 = (_anonymous_namespace_ *)(a3 + 32);
  uint64_t v159 = a3;
  LODWORD(v10) = 2;
  while (1)
  {
    *((_DWORD *)this + 5) = 0;
    *((void *)this + 3) = 0;
    *(_DWORD *)sockaddr buf = 0;
    re::BitReader::readUInt32Bits((uint64_t *)this, 8u, (unsigned int *)buf);
    unsigned int v13 = *(_DWORD *)buf;
    *(_DWORD *)sockaddr buf = 0;
    re::BitReader::readUInt32Bits((uint64_t *)this, 0x10u, (unsigned int *)buf);
    unsigned __int16 v14 = *(_WORD *)buf;
    *(void *)&long long v174 = 0;
    WORD4(v174) = 0;
    LOBYTE(v175) = 0;
    *((void *)&v175 + 1) = 0;
    *(_DWORD *)v176 = 0x10000;
    re::SyncOwnershipInfo::read((re::SyncOwnershipInfo *)&v174, this, (v13 >> 4) & 1, 1);
    unsigned __int8 v15 = (uint64_t *)*((void *)&v175 + 1);
    if (!*((void *)&v175 + 1))
    {
      unsigned __int8 v15 = a1[2];
      *((void *)&v175 + 1) = v15;
    }
    if (v15 == a1[3])
    {
      BOOL v16 = 1;
    }
    else if (*((unsigned char *)a1 + 120))
    {
      BOOL v16 = v15 == *(uint64_t **)(a4 + 8);
    }
    else
    {
      BOOL v16 = 0;
    }
    unsigned __int16 v165 = v14;
    LOBYTE(v176[1]) = v16;
    uint64_t v173 = 0;
    *(void *)sockaddr buf = 0;
    re::BiasedVLQ::read((re::BiasedVLQ *)buf, this, &v173);
    unint64_t v171 = -1;
    unint64_t v172 = 0;
    if ((v13 & 5) != 0)
    {
      re::BitReader::readUInt64(this, &v172);
      re::BitReader::readUInt64(this, &v171);
      uint64_t v17 = v172;
      int v18 = v173;
      int v19 = (re::SyncOpaqueTypeInfo *)v171;
      uint64_t v20 = **a1;
      if ((v13 & 4) != 0) {
        (*(void (**)(void))(v20 + 64))();
      }
      else {
        (*(void (**)(void))(v20 + 48))();
      }
    }
    else
    {
      int v18 = v173;
      uint64_t v17 = (*(uint64_t (**)(uint64_t *, uint64_t))(**a1 + 56))(*a1, v173);
      int v19 = (re::SyncOpaqueTypeInfo *)v21;
      unint64_t v171 = v21;
      unint64_t v172 = v17;
    }
    uint64_t v22 = a1[1];
    *(void *)sockaddr buf = v19;
    int v23 = (re *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(v22 + 63), (uint64_t *)buf);
    if (!v23 || (uint64_t v24 = *(void *)(*(void *)v23 + 16)) == 0)
    {
      int v25 = *re::networkLogObjects(v23);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)sockaddr buf = 134217984;
        *(void *)&uint8_t buf[4] = v19;
        _os_log_impl(&dword_228C70000, v25, OS_LOG_TYPE_DEFAULT, "Unknown object typeID=%llu. Assuming opaque type.", buf, 0xCu);
      }
      unsigned __int16 v26 = (re::SyncObjectStore *)a1[1];
      re::SyncOpaqueTypeInfo::make(v19, (uint64_t)buf);
      re::SyncObjectStore::addType(v26, (const re::SyncObjectTypeInfo *)buf);
      re::SyncObjectTypeInfo::~SyncObjectTypeInfo((re::SyncObjectTypeInfo *)buf);
      uint64_t v27 = a1[1];
      *(void *)sockaddr buf = v19;
      uint64_t v28 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(v27 + 63), (uint64_t *)buf);
      if (v28) {
        uint64_t v24 = *(void *)(*(void *)v28 + 16);
      }
      else {
        uint64_t v24 = 0;
      }
    }
    unint64_t v169 = 0;
    unint64_t v170 = 0;
    if (v13)
    {
      re::BitReader::readUInt64(this, &v170);
      int v29 = re::BitReader::readUInt64(this, &v169);
      unsigned __int16 v30 = 0;
    }
    else
    {
      *(_DWORD *)sockaddr buf = 0;
      int v29 = re::BitReader::readUInt32Bits((uint64_t *)this, 0x10u, (unsigned int *)buf);
      unsigned __int16 v30 = *(_WORD *)buf;
    }
    if (*((unsigned char *)this + 12))
    {
      uint64_t v31 = *re::networkLogObjects((re *)v29);
      uint64_t v32 = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
      if (v32)
      {
        *(_WORD *)sockaddr buf = 0;
        _os_log_error_impl(&dword_228C70000, v31, OS_LOG_TYPE_ERROR, "Failed to parse object header.", buf, 2u);
      }
      int v33 = 0;
      goto LABEL_35;
    }
    uint64_t v34 = *(void *)(v24 + 136);
    if (v34)
    {
      uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(v34 + 16))(v34, a4);
      if ((v34 & 1) == 0)
      {
        uint64_t v32 = re::SyncUnpacker::skipObjectState(this, v35, v36, v37, v38);
        int v33 = 2;
        goto LABEL_35;
      }
    }
    if (v17)
    {
      uint64_t Object = re::SyncObjectStore::findObject((re::SyncObjectStore *)a1[1], (uint64_t)v19, v17, (re::SyncObjectTypedStore ***)&v168);
      if (v168)
      {
        v163 = v168;
        if (v13)
        {
          uint64_t v162 = 0;
          int v43 = 1;
          long long v41 = v168;
          goto LABEL_80;
        }
        int v40 = v30;
        long long v41 = v168;
        uint64_t Baseline = re::SyncObject::findBaseline(v168, v40, (uint64_t)a1[2]);
        if (!Baseline)
        {
          unsigned __int16 v59 = *re::networkLogObjects(0);
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v24 + 48)) {
              uint64_t v60 = *(void *)(v24 + 56);
            }
            else {
              uint64_t v60 = v24 + 49;
            }
            *(_DWORD *)sockaddr buf = 134218498;
            *(void *)&uint8_t buf[4] = v17;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v60;
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(void *)v196 = v19;
            _os_log_impl(&dword_228C70000, v59, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing baseline for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
          }
          if ((v13 & 4) == 0)
          {
            *(void *)sockaddr buf = v19;
            *(void *)&uint8_t buf[8] = v17;
            re::DynamicArray<re::PoolAllocator::PoolFreeList>::add((uint64_t)(a1 + 10), (__n128 *)buf);
          }
          int v43 = 0;
          uint64_t v162 = 0;
          long long v41 = v163;
LABEL_80:
          BOOL shouldAcceptUpdate = re::SyncObject::shouldAcceptUpdate(v41, *((uint64_t *)&v175 + 1), v176[0]);
          if (*((unsigned char *)a1 + 121) || shouldAcceptUpdate)
          {
            if (shouldAcceptUpdate
              && (unint64_t v75 = a1[3],
                  unsigned int v76 = *((unsigned __int16 *)v41 + 84),
                  long long v77 = v175,
                  *(_OWORD *)((char *)v41 + 136) = v174,
                  *(_OWORD *)((char *)v41 + 152) = v77,
                  *((_DWORD *)v41 + 42) = *(_DWORD *)v176,
                  *(unsigned char *)(*(void *)(*((void *)v41 + 11) + 16) + 73))
              && (v76 < v176[0] || ((uint64_t *)v174 == v75 ? (BOOL v78 = (void)v174 == 0) : (BOOL v78 = 1), !v78)))
            {
              char v160 = 4;
              if (!v43) {
                goto LABEL_103;
              }
            }
            else
            {
              char v160 = 0;
              if (!v43) {
                goto LABEL_103;
              }
            }
            if (re::SyncObject::isStateDataChanged(v41, v165, (uint64_t)a1[2]))
            {
              DWORD2(v183) = 0;
              BYTE12(v183) = 0;
              long long v184 = 0uLL;
              v182 = &unk_26DD35FD0;
              *(void *)&long long v183 = 0;
              uint64_t v187 = 0;
              int v186 = 0;
              memset(v185, 0, sizeof(v185));
              if (*((void *)v41 + 9) - *((void *)v41 + 8) == *((void *)v41 + 6)
                && (OldestState = (re *)re::SyncObject::getOldestState(v41), OldestState == (re *)v162))
              {
                long long v109 = *re::networkLogObjects(OldestState);
                if (os_log_type_enabled(v109, OS_LOG_TYPE_INFO))
                {
                  *(_WORD *)sockaddr buf = 0;
                  _os_log_impl(&dword_228C70000, v109, OS_LOG_TYPE_INFO, "Baseline would be invalidated by new state! Will read into temp location.", buf, 2u);
                }
                os_log_t v157 = (os_log_t)&v182;
                unsigned __int16 v80 = v165;
              }
              else
              {
                unsigned __int16 v80 = v165;
                os_log_t v157 = (os_log_t)re::SyncObject::addState(v41, v165, (uint64_t)a1[2]);
              }
              *((_WORD *)v41 + 88) = v80;
              BOOL v151 = *((_DWORD *)this + 5) != 0;
              int v152 = *((_DWORD *)this + 4);
              uint64_t v193 = 0;
              *(void *)sockaddr buf = 0;
              re::BiasedVLQ::read((re::BiasedVLQ *)buf, this, &v193);
              int v81 = *((_DWORD *)this + 5);
              uint64_t v82 = (8 - v81);
              BOOL v78 = v81 == 0;
              BOOL v83 = v81 != 0;
              char v84 = (v82 << 32);
              if (v78) {
                char v84 = 0;
              }
              int v154 = v193;
              os_log_t log = v84;
              uint64_t v150 = (*((_DWORD *)this + 4) - v83);
              int v85 = v150 + v193;
              uint64_t v86 = (re *)re::BitReader::seekTo((uint64_t)this, (v150 + v193));
              if (*((unsigned char *)this + 12))
              {
                uint64_t v87 = *re::networkLogObjects(v86);
                if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)sockaddr buf = 67109120;
                  *(_DWORD *)&uint8_t buf[4] = v154;
                  _os_log_error_impl(&dword_228C70000, v87, OS_LOG_TYPE_ERROR, "Buffer overflowe trying to extract sync object state buffer (len=%u) from packet reader!", buf, 8u);
                }
                uint64_t v177 = 0;
                int v178 = 0;
                char v179 = 0;
                uint64_t v180 = 0;
                uint64_t v181 = 0;
              }
              else
              {
                int v99 = v85;
                unsigned int v100 = v150;
                unsigned int v101 = v150 + v151 - v152;
                unsigned int v102 = v101 - 1;
                if (v101 <= 1)
                {
                  uint64_t v107 = v150;
                }
                else
                {
                  uint64_t v103 = *(void *)this;
                  uint64_t v104 = v150 - v102;
                  int v105 = (unsigned __int8 *)(*(void *)this + v104);
                  v188 = &v105[v154];
                  unsigned int v189 = v102;
                  char v190 = 0;
                  uint64_t v191 = 0;
                  uint64_t v192 = 0;
                  if (log) {
                    unsigned int v100 = v150 + 1;
                  }
                  *(void *)sockaddr buf = &unk_26DD35FA8;
                  *(void *)&uint8_t buf[8] = v103;
                  *(_DWORD *)&uint8_t buf[16] = v100;
                  *(_DWORD *)v196 = v150 - v102;
                  *(_DWORD *)&v196[4] = HIDWORD(log);
                  *(void *)&v196[8] = 0;
                  uint64_t v153 = v150 - v102;
                  if (HIDWORD(log)) {
                    unsigned int v106 = v104 + 1;
                  }
                  else {
                    unsigned int v106 = v150 - v102;
                  }
                  buf[20] = v106 > v100;
                  if (HIDWORD(log) && v106 <= v100) {
                    *(void *)&v196[8] = (0xFFuLL >> (8 - BYTE4(log))) & *v105;
                  }
                  do
                  {
                    unsigned int v194 = 0;
                    re::BitReader::readUInt32Bits((uint64_t *)&v188, 8u, &v194);
                    re::BitWriter::writeUInt32Bits((uint64_t)buf, v194, 8u);
                    --v102;
                  }
                  while (v102);
                  uint64_t v107 = v153;
                  int v99 = v153 + v154;
                }
                uint64_t v177 = *(void *)this;
                int v178 = v99;
                char v179 = 0;
                uint64_t v180 = 0;
                uint64_t v181 = 0;
                re::BitReader::seekTo((uint64_t)&v177, v107 | (unint64_t)log);
              }
              if (v162)
              {
                uint64_t v110 = *(void *)(v24 + 104);
                if (!v110)
                {
                  loga = *re::networkLogObjects(0);
                  uint64_t v113 = os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT);
                  if (v113)
                  {
                    uint64_t v116 = *((void *)v41 + 3);
                    uint64_t v117 = *(void *)(v24 + 32);
                    if (*(void *)(v24 + 48)) {
                      uint64_t v118 = *(void *)(v24 + 56);
                    }
                    else {
                      uint64_t v118 = v24 + 49;
                    }
                    *(_DWORD *)sockaddr buf = 134218498;
                    *(void *)&uint8_t buf[4] = v116;
                    *(_WORD *)&unsigned char buf[12] = 2048;
                    *(void *)&buf[14] = v117;
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    *(void *)v196 = v118;
                    _os_log_impl(&dword_228C70000, loga, OS_LOG_TYPE_DEFAULT, "Cannot parse state for syncobject %llu of type %llu(%s), readDeltaCb not available.", buf, 0x20u);
                  }
                  if (v157 == (os_log_t)&v182 || (uint64_t v119 = *((void *)v41 + 9), *((void *)v41 + 8) == v119))
                  {
                    v115 = 0;
                  }
                  else
                  {
                    v115 = 0;
                    *((void *)v41 + 9) = v119 - 1;
                  }
                  goto LABEL_168;
                }
                int v111 = *(_DWORD *)(v162 + 24);
                if (*(_DWORD *)(v162 + 28)) {
                  ++v111;
                }
                *(void *)sockaddr buf = *(void *)(v162 + 8);
                *(_DWORD *)&uint8_t buf[8] = v111;
                unsigned char buf[12] = 0;
                *(void *)&uint8_t buf[16] = 0;
                *(void *)v196 = 0;
                p_isa = &v157->isa;
                uint64_t v113 = (*(uint64_t (**)(uint64_t, uint64_t *, unsigned char *, os_log_t, uint64_t))(v110 + 16))(v110, &v177, buf, v157, a4);
                if ((v113 & 1) == 0) {
                  goto LABEL_161;
                }
              }
              else
              {
                uint64_t v114 = *(void *)(v24 + 96);
                if (!v114)
                {
                  v166 = *re::networkLogObjects(0);
                  uint64_t v113 = os_log_type_enabled(v166, OS_LOG_TYPE_ERROR);
                  p_isa = &v157->isa;
                  if (v113)
                  {
                    uint64_t v142 = *((void *)v41 + 3);
                    uint64_t v143 = *(void *)(v24 + 32);
                    if (*(void *)(v24 + 48)) {
                      uint64_t v144 = *(void *)(v24 + 56);
                    }
                    else {
                      uint64_t v144 = v24 + 49;
                    }
                    *(_DWORD *)sockaddr buf = 134218498;
                    *(void *)&uint8_t buf[4] = v142;
                    *(_WORD *)&unsigned char buf[12] = 2048;
                    *(void *)&buf[14] = v143;
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    *(void *)v196 = v144;
                    _os_log_error_impl(&dword_228C70000, v166, OS_LOG_TYPE_ERROR, "Cannot parse state for syncobject %llu of type %llu(%s), readCb not available.", buf, 0x20u);
                  }
                  goto LABEL_161;
                }
                p_isa = &v157->isa;
                uint64_t v113 = (*(uint64_t (**)(uint64_t, uint64_t *, os_log_t, uint64_t))(v114 + 16))(v114, &v177, v157, a4);
                if (!v113)
                {
LABEL_161:
                  if (p_isa != &v182)
                  {
                    uint64_t v120 = *((void *)v41 + 9);
                    if (*((void *)v41 + 8) != v120) {
                      *((void *)v41 + 9) = v120 - 1;
                    }
                  }
                  char v121 = *re::networkLogObjects((re *)v113);
                  if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v139 = *((void *)v41 + 3);
                    v140 = a1[2];
                    *(_DWORD *)sockaddr buf = 134218240;
                    *(void *)&uint8_t buf[4] = v139;
                    *(_WORD *)&unsigned char buf[12] = 2048;
                    *(void *)&buf[14] = v140;
                    _os_log_error_impl(&dword_228C70000, v121, OS_LOG_TYPE_ERROR, "Failed to parse object data.(guid=%llu, peerID=%llu)", buf, 0x16u);
                  }
                  int v122 = 0;
LABEL_178:
                  unsigned __int16 v128 = (re *)v185[0];
                  if (v185[0] && v187) {
                    unsigned __int16 v128 = (re *)(*(uint64_t (**)(void))(*(void *)v185[0] + 40))();
                  }
                  if (!v122)
                  {
                    char v129 = *re::networkLogObjects(v128);
                    uint64_t v32 = os_log_type_enabled(v129, OS_LOG_TYPE_ERROR);
                    if (v32)
                    {
                      if (*(unsigned char *)(v24 + 48)) {
                        uint64_t v138 = *(void *)(v24 + 56);
                      }
                      else {
                        uint64_t v138 = v24 + 49;
                      }
                      v141 = a1[2];
                      *(_DWORD *)sockaddr buf = 134218754;
                      *(void *)&uint8_t buf[4] = v17;
                      *(_WORD *)&unsigned char buf[12] = 2048;
                      *(void *)&buf[14] = v19;
                      *(_WORD *)&unsigned char buf[22] = 2080;
                      *(void *)v196 = v138;
                      *(_WORD *)&v196[8] = 2048;
                      *(void *)&v196[10] = v141;
                      _os_log_error_impl(&dword_228C70000, v129, OS_LOG_TYPE_ERROR, "Failed to parse object state.(guid=%llu, type=%llu(%s), peerID=%llu)", buf, 0x2Au);
                    }
                    if (!v163)
                    {
                      uint64_t v130 = (uint64_t)a1[1];
                      *(void *)sockaddr buf = v168;
                      if (v168)
                      {
                        unint64_t v131 = (char *)v168 + 8;
                        v132 = (char *)v168 + 8;
                        re::SyncObjectStore::removeObject(v130, (uint64_t *)buf);
                      }
                      else
                      {
                        re::SyncObjectStore::removeObject(v130, (uint64_t *)buf);
                      }
                    }
                    goto LABEL_194;
                  }
                  char v88 = 8;
                  long long v41 = v168;
LABEL_104:
                  if (v169 && !*((void *)v41 + 10))
                  {
                    *(void *)sockaddr buf = v170;
                    *(void *)&uint8_t buf[8] = v169;
                    re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace((uint64_t)(a1 + 4), (uint64_t *)&v168, buf);
                    long long v41 = v168;
                  }
                  unint64_t v89 = re::SyncObject::latestStateHandle(v41);
                  if (v89 != -1)
                  {
                    unint64_t v90 = v89;
                    memset(buf, 0, 17);
                    re::SharedPtr<re::SyncObject>::reset((uint64_t *)buf, (uint64_t)v168);
                    *(void *)&uint8_t buf[8] = v90;
                    char v91 = v160 | v88 | (v163 == 0) | buf[16] & 0xF2;
                    uint8_t buf[16] = v91;
                    if ((v13 & 4) != 0)
                    {
                      *((unsigned char *)v168 + 128) |= 4u;
                      uint8_t buf[16] = v91 | 2;
                    }
                    uint64_t v32 = (uint64_t)re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v161, (uint64_t)buf);
                    if (*(void *)buf) {

                    }
                    goto LABEL_132;
                  }
                  uint64_t v92 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
                  uint64_t v32 = os_log_type_enabled(v92, OS_LOG_TYPE_ERROR);
                  if (v32)
                  {
                    uint64_t v93 = *((void *)v168 + 3);
                    uint64_t v94 = *(void **)(*((void *)v168 + 11) + 16);
                    uint64_t v95 = v94[4];
                    uint64_t v96 = v94[6];
                    unsigned int v97 = (char *)v94[7];
                    int v98 = (char *)v94 + 49;
                    if (v96) {
                      int v98 = v97;
                    }
                    *(_DWORD *)sockaddr buf = 134218498;
                    *(void *)&uint8_t buf[4] = v93;
                    *(_WORD *)&unsigned char buf[12] = 2048;
                    *(void *)&buf[14] = v95;
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    *(void *)v196 = v98;
                    _os_log_error_impl(&dword_228C70000, v92, OS_LOG_TYPE_ERROR, "Sync object without snapshot while parsing object (id: %llu, type: %llu[%s]).", buf, 0x20u);
                  }
LABEL_194:
                  int v33 = 0;
LABEL_133:
                  if (v168) {

                  }
                  goto LABEL_35;
                }
              }
              v115 = (void **)p_isa;
LABEL_168:
              if (v178 != v180)
              {
                uint64_t v123 = v115;
                uint64_t v158 = *re::networkLogObjects((re *)v113);
                BOOL v124 = os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT);
                v115 = v123;
                if (v124)
                {
                  v125 = "readDeltaCb";
                  if (!v162) {
                    v125 = "readCb";
                  }
                  if (*(void *)(v24 + 48)) {
                    uint64_t v126 = *(void *)(v24 + 56);
                  }
                  else {
                    uint64_t v126 = v24 + 49;
                  }
                  uint64_t v127 = *(void *)(v24 + 32);
                  *(_DWORD *)sockaddr buf = 136315650;
                  *(void *)&uint8_t buf[4] = v125;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = v126;
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  *(void *)v196 = v127;
                  _os_log_impl(&dword_228C70000, v158, OS_LOG_TYPE_DEFAULT, "Read buffer is not fully consumed by %s of type %s: %llu", buf, 0x20u);
                  v115 = v123;
                }
              }
              if (v115 == &v182)
              {
                unint64_t v133 = re::SyncObject::addState(v41, v165, (uint64_t)a1[2]);
                uint64_t v134 = *(void *)(v133 + 40);
                v133 += 40;
                long long v135 = *(_OWORD *)(v133 - 16);
                *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v133 - 32);
                *(_OWORD *)v196 = v135;
                *(void *)sockaddr buf = &unk_26DD35FD0;
                *(void *)&v196[16] = v134;
                *(void *)unint64_t v133 = 0;
                uint64_t v136 = *(void *)(v133 + 16);
                uint64_t v197 = *(void *)(v133 + 8);
                *(void *)(v133 + 8) = 0;
                uint64_t v198 = v136;
                *(void *)(v133 + 16) = 0;
                uint64_t v200 = *(void *)(v133 + 32);
                *(void *)(v133 + 32) = 0;
                ++*(_DWORD *)(v133 + 24);
                int v199 = 1;
                long long v137 = v184;
                *(_OWORD *)(v133 - 32) = v183;
                *(_OWORD *)(v133 - 16) = v137;
                re::DynamicArray<unsigned char>::operator=(v133, (uint64_t)v185);
                long long v183 = *(_OWORD *)&buf[8];
                long long v184 = *(_OWORD *)v196;
                re::DynamicArray<unsigned char>::operator=((uint64_t)v185, (uint64_t)&v196[16]);
                if (*(void *)&v196[16])
                {
                  if (v200) {
                    (*(void (**)(void))(**(void **)&v196[16] + 40))();
                  }
                }
              }
              int v122 = 1;
              goto LABEL_178;
            }
LABEL_103:
            re::SyncUnpacker::skipObjectState(this, v52, v53, v54, v55);
            char v88 = 0;
            goto LABEL_104;
          }
LABEL_131:
          uint64_t v32 = re::SyncUnpacker::skipObjectState(this, v52, v53, v54, v55);
LABEL_132:
          int v33 = 2;
          goto LABEL_133;
        }
        uint64_t v162 = Baseline;
LABEL_48:
        int v43 = 1;
        goto LABEL_80;
      }
      if ((v13 & 4) != 0)
      {
        BOOL v57 = *re::networkLogObjects((re *)Object);
        if (!os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_131;
        }
        if (*(unsigned char *)(v24 + 48)) {
          uint64_t v58 = *(void *)(v24 + 56);
        }
        else {
          uint64_t v58 = v24 + 49;
        }
        *(_DWORD *)sockaddr buf = 134218498;
        *(void *)&uint8_t buf[4] = v17;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v58;
        *(_WORD *)&unsigned char buf[22] = 2048;
        *(void *)v196 = v19;
        unint64_t v66 = v57;
        unint64_t v67 = "Discarding incoming object already in destroyed state, guid=%llu, type=%s(%llu)";
      }
      else
      {
        v163 = v168;
        BOOL v49 = a1[1];
        *(void *)sockaddr buf = v17;
        *(void *)&uint8_t buf[8] = v19;
        *(void *)&uint8_t buf[16] = 0;
        BOOL v50 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v49 + 75), (uint64_t *)buf);
        if (!v50)
        {
          uint64_t v61 = a1[1];
          unint64_t v62 = v169;
          *(void *)sockaddr buf = v169;
          *(void *)&uint8_t buf[8] = v170;
          *(void *)&uint8_t buf[16] = 0;
          BOOL v63 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v61 + 75), (uint64_t *)buf);
          if (!v63)
          {
            if ((v13 & 1) == 0)
            {
              char v68 = *re::networkLogObjects((re *)v63);
              if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
              {
                if (*(unsigned char *)(v24 + 48)) {
                  uint64_t v73 = *(void *)(v24 + 56);
                }
                else {
                  uint64_t v73 = v24 + 49;
                }
                *(_DWORD *)sockaddr buf = 134218498;
                *(void *)&uint8_t buf[4] = v17;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v73;
                *(_WORD *)&unsigned char buf[22] = 2048;
                *(void *)v196 = v19;
                _os_log_impl(&dword_228C70000, v68, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing object for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
              }
              uint64_t v32 = re::SyncUnpacker::skipObjectState(this, v69, v70, v71, v72);
              int v33 = 1;
              goto LABEL_133;
            }
            re::SyncObjectStore::createIncomingObject((re::SyncObjectStore *)a1[1], (const re::SyncOwnershipInfo *)&v174, (unint64_t)v19, v17, (uint64_t *)buf);
            uint64_t v162 = 0;
            long long v41 = *(re::SyncObject **)buf;
            v168 = *(re::SyncObject **)buf;
            goto LABEL_48;
          }
          uint64_t v64 = *re::networkLogObjects((re *)v63);
          if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_131;
          }
          if (*(unsigned char *)(v24 + 48)) {
            uint64_t v65 = *(void *)(v24 + 56);
          }
          else {
            uint64_t v65 = v24 + 49;
          }
          *(_DWORD *)sockaddr buf = 134218754;
          *(void *)&uint8_t buf[4] = v17;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v65;
          *(_WORD *)&unsigned char buf[22] = 2048;
          *(void *)v196 = v19;
          *(_WORD *)&v196[8] = 2048;
          *(void *)&v196[10] = v62;
          unint64_t v66 = v64;
          unint64_t v67 = "Discarding incoming object with parent already tombstoned, guid=%llu, type=%s(%llu), parentGuid=%llu";
          uint32_t v108 = 42;
LABEL_130:
          _os_log_impl(&dword_228C70000, v66, OS_LOG_TYPE_DEFAULT, v67, buf, v108);
          goto LABEL_131;
        }
        uint64_t v51 = *re::networkLogObjects((re *)v50);
        if (!os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_131;
        }
        if (*(unsigned char *)(v24 + 48)) {
          uint64_t v56 = *(void *)(v24 + 56);
        }
        else {
          uint64_t v56 = v24 + 49;
        }
        *(_DWORD *)sockaddr buf = 134218498;
        *(void *)&uint8_t buf[4] = v17;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v56;
        *(_WORD *)&unsigned char buf[22] = 2048;
        *(void *)v196 = v19;
        unint64_t v66 = v51;
        unint64_t v67 = "Discarding incoming object already tombstoned, guid=%llu, type=%s(%llu)";
      }
      uint32_t v108 = 32;
      goto LABEL_130;
    }
    unsigned int v44 = *re::networkLogObjects((re *)v34);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)sockaddr buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v18;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v13;
      _os_log_debug_impl(&dword_228C70000, v44, OS_LOG_TYPE_DEBUG, "Cannot find guid for object with id=%d, flags=0x%02X. Skipping update.", buf, 0xEu);
    }
    uint64_t v32 = re::SyncUnpacker::skipObjectState(this, v45, v46, v47, v48);
    int v33 = 1;
LABEL_35:
    uint64_t v10 = v33 >= (int)v10 ? v10 : v33;
    if (!v10) {
      break;
    }
    if (++v12 == v167) {
      return v10;
    }
  }
  int v145 = *re::networkLogObjects((re *)v32);
  if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
  {
    uint64_t v146 = *(void *)(v159 + 16);
    *(_DWORD *)sockaddr buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v12;
    *(_WORD *)&uint8_t buf[8] = 2048;
    *(void *)&buf[10] = v146;
    uint64_t v147 = "Failed to parse object %u from commit %llu.";
    uint64_t v148 = v145;
    uint32_t v149 = 18;
    goto LABEL_207;
  }
  return 0;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>(uint64_t a1, unsigned char *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<1>(a1);
  if (result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned long long>(uint64_t a1, void *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<2>(a1);
  if (result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned short>(uint64_t a1, _WORD *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<2>(a1);
  if (result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,re::SyncOwnershipInfo>(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<3>(a1);
  if (result)
  {
    if (re::snapshot::DecoderOPACK::beginObject((re::snapshot::DecoderOPACK *)a1, 0))
    {
      re::snapshotMapFields(a1, a2);
      re::snapshot::DecoderOPACK::endObject((uint64_t *)a1, 0);
    }
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<6,unsigned long long>(uint64_t a1, void *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<6>(a1);
  if (result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<8,unsigned long long>(uint64_t a1, void *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<8>(a1);
  if (result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<9,unsigned long long>(uint64_t a1, void *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<9>(a1);
  if (result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<11,re::Slice<unsigned char>>(uint64_t a1, uint64_t *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<11>(a1);
  if (result)
  {
    unint64_t v10 = 0;
    if (re::snapshot::DecoderOPACK::beginData((re::snapshot::DecoderOPACK *)a1, &v10, 0))
    {
      long long v9 = *(_OWORD *)a1;
      unint64_t v5 = v10;
      *a2 = re::Slice<unsigned char>::range(&v9, *(void *)(a1 + 16) - v9, *(void *)(a1 + 16) - v9 + v10);
      a2[1] = v6;
      char v7 = (unsigned __int8 *)(*(void *)(a1 + 16) + v5);
      *(void *)(a1 + 16) = v7;
    }
    else
    {
      char v7 = *(unsigned __int8 **)(a1 + 16);
    }
    if ((unint64_t)v7 >= *(void *)(a1 + 24) || (int v8 = *v7, v8 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v8 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v7 + 1;
      uint64_t result = (v8 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(uint64_t a1, uint64_t *a2, _OWORD *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 40 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 40 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 40 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  *(_OWORD *)(v11 + 40 * v10 + 24) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v12 = *(void *)(a1 + 16) + 40 * v10;
  return v12 + 24;
}

uint64_t re::SyncUnpacker::skipObjectState(re::SyncUnpacker *this, const re::SyncObjectTypeInfo *a2, unint64_t a3, unsigned __int8 a4, re::BitReader *a5)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  re::BiasedVLQ::read((re::BiasedVLQ *)&v8, this, &v9);
  uint64_t v6 = *((_DWORD *)this + 4) + v9 - (*((_DWORD *)this + 5) != 0);
  return re::BitReader::seekTo((uint64_t)this, v6);
}

BOOL re::snapshot::DecoderOPACK::advanceTo<1>(uint64_t a1)
{
  int Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 0)
  {
    while (1)
    {
      unint64_t v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(void *)(a1 + 24))
      {
        int v4 = 0;
      }
      else
      {
        *(void *)(a1 + 16) = v5 + 1;
        int v4 = *v5;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      uint64_t v6 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v6 >= *(void *)(a1 + 24)) {
        break;
      }
      int v3 = *v6;
      if (v3 == 3) {
        break;
      }
      if ((v3 - 7) > 0x28)
      {
        int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(void *)(a1 + 16) = v6 + 1;
        int Integer = v3 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 1) {
        return Integer == 1;
      }
    }
    int Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 1;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<2>(uint64_t a1)
{
  int Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 1)
  {
    while (1)
    {
      int v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(void *)(a1 + 24))
      {
        int v4 = 0;
      }
      else
      {
        *(void *)(a1 + 16) = v3 + 1;
        int v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      unint64_t v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(void *)(a1 + 24)) {
        break;
      }
      int v6 = *v5;
      if (v6 == 3) {
        break;
      }
      if ((v6 - 7) > 0x28)
      {
        int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(void *)(a1 + 16) = v5 + 1;
        int Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 2) {
        return Integer == 2;
      }
    }
    int Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 2;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<3>(uint64_t a1)
{
  int Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 2)
  {
    while (1)
    {
      int v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(void *)(a1 + 24))
      {
        int v4 = 0;
      }
      else
      {
        *(void *)(a1 + 16) = v3 + 1;
        int v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      unint64_t v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(void *)(a1 + 24)) {
        break;
      }
      int v6 = *v5;
      if (v6 == 3) {
        break;
      }
      if ((v6 - 7) > 0x28)
      {
        int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(void *)(a1 + 16) = v5 + 1;
        int Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 3) {
        return Integer == 3;
      }
    }
    int Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 3;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<5>(uint64_t a1)
{
  int Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 4)
  {
    while (1)
    {
      int v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(void *)(a1 + 24))
      {
        int v4 = 0;
      }
      else
      {
        *(void *)(a1 + 16) = v3 + 1;
        int v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      unint64_t v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(void *)(a1 + 24)) {
        break;
      }
      int v6 = *v5;
      if (v6 == 3) {
        break;
      }
      if ((v6 - 7) > 0x28)
      {
        int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(void *)(a1 + 16) = v5 + 1;
        int Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 5) {
        return Integer == 5;
      }
    }
    int Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 5;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<6>(uint64_t a1)
{
  int Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 5)
  {
    while (1)
    {
      int v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(void *)(a1 + 24))
      {
        int v4 = 0;
      }
      else
      {
        *(void *)(a1 + 16) = v3 + 1;
        int v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      unint64_t v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(void *)(a1 + 24)) {
        break;
      }
      int v6 = *v5;
      if (v6 == 3) {
        break;
      }
      if ((v6 - 7) > 0x28)
      {
        int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(void *)(a1 + 16) = v5 + 1;
        int Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 6) {
        return Integer == 6;
      }
    }
    int Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 6;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<8>(uint64_t a1)
{
  int Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 7)
  {
    while (1)
    {
      int v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(void *)(a1 + 24))
      {
        int v4 = 0;
      }
      else
      {
        *(void *)(a1 + 16) = v3 + 1;
        int v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      unint64_t v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(void *)(a1 + 24)) {
        break;
      }
      int v6 = *v5;
      if (v6 == 3) {
        break;
      }
      if ((v6 - 7) > 0x28)
      {
        int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(void *)(a1 + 16) = v5 + 1;
        int Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 8) {
        return Integer == 8;
      }
    }
    int Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 8;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<9>(uint64_t a1)
{
  int Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 8)
  {
    while (1)
    {
      int v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(void *)(a1 + 24))
      {
        int v4 = 0;
      }
      else
      {
        *(void *)(a1 + 16) = v3 + 1;
        int v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      unint64_t v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(void *)(a1 + 24)) {
        break;
      }
      int v6 = *v5;
      if (v6 == 3) {
        break;
      }
      if ((v6 - 7) > 0x28)
      {
        int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(void *)(a1 + 16) = v5 + 1;
        int Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 9) {
        return Integer == 9;
      }
    }
    int Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 9;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<11>(uint64_t a1)
{
  int Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 10)
  {
    while (1)
    {
      int v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(void *)(a1 + 24))
      {
        int v4 = 0;
      }
      else
      {
        *(void *)(a1 + 16) = v3 + 1;
        int v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      unint64_t v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(void *)(a1 + 24)) {
        break;
      }
      int v6 = *v5;
      if (v6 == 3) {
        break;
      }
      if ((v6 - 7) > 0x28)
      {
        int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(void *)(a1 + 16) = v5 + 1;
        int Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 11) {
        return Integer == 11;
      }
    }
    int Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 11;
}

uint64_t re::Slice<unsigned char>::range(void *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. fromInclusive = %zu, size_t size = %zu", "fromInclusive <= size()", "range", 241, a2, v3);
    _os_crash();
    __break(1u);
  }
  else if (v3 >= a3)
  {
    return *a1 + a2;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. toExclusive = %zu, size_t size = %zu", "toExclusive <= size()", "range", 242, a2, v3);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, _OWORD *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 40 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 40 * v9) = a3;
  uint64_t v14 = *a4;
  *(void *)(*(void *)(a1 + 16) + 40 * v9 + 16) = *a4;
  if (v14) {
    id v15 = (id)(v14 + 8);
  }
  *(_OWORD *)(*(void *)(a1 + 16) + 40 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 24);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 40;
        }
        while (v11 < v9);
      }
      re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::DynamicArray<unsigned char>::operator=(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)a2;
    if (*(void *)result) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4 || v2 == v3)
    {
      uint64_t v6 = *(void *)(result + 8);
      uint64_t v7 = *(void *)(a2 + 8);
      *(void *)uint64_t result = v3;
      *(void *)(result + 8) = v7;
      *(void *)a2 = v2;
      *(void *)(a2 + 8) = v6;
      uint64_t v8 = *(void *)(result + 16);
      *(void *)(result + 16) = *(void *)(a2 + 16);
      *(void *)(a2 + 16) = v8;
      uint64_t v9 = *(void *)(result + 32);
      *(void *)(result + 32) = *(void *)(a2 + 32);
      *(void *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      uint64_t result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::IP::makeFromString@<X0>(re::IP *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  *((void *)&v6 + 1) = 0;
  uint64_t v7 = 0;
  uint64_t result = inet_pton(2, (const char *)this, (char *)&v6 + 8);
  if (result)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    uint64_t result = inet_pton(30, (const char *)this, (char *)&v6 + 8);
    if (!result)
    {
      *(unsigned char *)a2 = 0;
      return result;
    }
    LOBYTE(v6) = 1;
  }
  *(unsigned char *)a2 = 1;
  *(void *)(a2 + 24) = v7;
  *(_OWORD *)(a2 + 8) = v6;
  return result;
}

re::DynamicString *re::IP::generateString@<X0>(re::IP *this@<X0>, re::DynamicString *a2@<X8>)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  __s[0] = 0;
  uint64_t v3 = (char *)this + 8;
  if (*(unsigned char *)this) {
    int v4 = 30;
  }
  else {
    int v4 = 2;
  }
  long long v5 = (_anonymous_namespace_ *)inet_ntop(v4, v3, __s, 0x31u);
}

uint64_t re::Address::getIPPortPair@<X0>(re::Address *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t result = re::DynamicString::rfind((uint64_t)this, 58, v19);
  if (!v19[0]) {
    goto LABEL_12;
  }
  size_t v6 = v20;
  if (!v20) {
    goto LABEL_12;
  }
  __endptr = 0;
  uint64_t v7 = (*((void *)this + 1) & 1) != 0 ? (re::Address *)*((void *)this + 2) : (re::Address *)((char *)this + 9);
  uint64_t result = strtol((const char *)v7 + v20 + 1, &__endptr, 10);
  if (result >= 0x10000) {
    goto LABEL_12;
  }
  unint64_t v8 = *((void *)this + 1);
  uint64_t v9 = (char *)*((void *)this + 2);
  if ((v8 & 1) == 0) {
    uint64_t v9 = (char *)this + 9;
  }
  unint64_t v10 = v8 >> 1;
  unint64_t v11 = v8 >> 1;
  if (*((void *)this + 1)) {
    unint64_t v11 = v10;
  }
  if (__endptr == &v9[v11])
  {
    __int16 v12 = result;
    re::DynamicString::substr(this, 0, v6, (re::DynamicString *)&v15);
    if (v16) {
      uint64_t v13 = *(re::IP **)&v17[7];
    }
    else {
      uint64_t v13 = (re::IP *)v17;
    }
    re::IP::makeFromString(v13, (uint64_t)v21);
    char v14 = v21[0];
    if (v21[0])
    {
      *(_OWORD *)(a2 + 8) = v22;
      *(void *)(a2 + 24) = v23;
      *(_WORD *)(a2 + 32) = v12;
      char v14 = 1;
    }
    *(unsigned char *)a2 = v14;
    uint64_t result = v15;
    if (v15)
    {
      if (v16) {
        return (*(uint64_t (**)(void))(*(void *)v15 + 40))();
      }
    }
  }
  else
  {
LABEL_12:
    *(unsigned char *)a2 = 0;
  }
  return result;
}

size_t re::Address::hash(re::Address *this)
{
  _OWORD v3[2] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 8)) {
    uint64_t v1 = (const char *)*((void *)this + 2);
  }
  else {
    uint64_t v1 = (char *)this + 9;
  }
  size_t result = strlen(v1);
  if (result)
  {
    MurmurHash3_x64_128((uint64_t)v1, result, 0, v3);
    return (v3[1] + (v3[0] << 6) + (v3[0] >> 2) - 0x61C8864680B583E9) ^ v3[0];
  }
  return result;
}

uint64_t re::Address::makeFromIPAndPort@<X0>(unsigned __int16 *a1@<X0>, re::DynamicString *a2@<X8>)
{
  re::IP::generateString((re::IP *)a1, (re::DynamicString *)&v5);
  re::DynamicString::appendf((re::DynamicString *)&v5, ":%hu", a1[12]);
  re::DynamicString::DynamicString(a2, (const re::DynamicString *)&v5);
  uint64_t result = v5;
  if (v5)
  {
    if (v6) {
      return (*(uint64_t (**)(void))(*(void *)v5 + 40))();
    }
  }
  return result;
}

uint64_t re::Address::makeFromIPAndPort@<X0>(re::Address *this@<X0>, const char *a2@<X1>, re::DynamicString *a3@<X8>)
{
  int v3 = (int)a2;
  re::DynamicString::appendf((re::DynamicString *)&v7, ":%hu", v3);
  re::DynamicString::DynamicString(a3, (const re::DynamicString *)&v7);
  uint64_t result = v7;
  if (v7)
  {
    if (v8) {
      return (*(uint64_t (**)(void))(*(void *)v7 + 40))();
    }
  }
  return result;
}

double RESyncCreateSyncObjectContext(re *a1)
{
  uint64_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 48, 8);
  double result = 0.0;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  *(_DWORD *)(v2 + 36) = 0x7FFFFFFF;
  return result;
}

re *RESyncDestroySyncObjectContext(re *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t *)result;
    uint64_t v2 = re::globalAllocators(result)[2];
    v3.n128_f64[0] = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v1);
    int v4 = *(uint64_t (**)(uint64_t, uint64_t *, __n128))(*(void *)v2 + 40);
    return (re *)v4(v2, v1, v3);
  }
  return result;
}

uint64_t RESyncGetSyncObjectContextRequiredSize()
{
  return 48;
}

double RESyncCreateSyncObjectContextNoAlloc(uint64_t a1)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
  return result;
}

BOOL RESyncAddSyncObjectContextEntry(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  __n128 v3 = (void *)re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<void *&>(a1, &v5, &v6);
  return *v3 == v6;
}

uint64_t re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<void *&>(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<void *&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 32 * v10;
  return v12 + 24;
}

uint64_t RESyncGetSyncObjectContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v5 = a2;
  uint64_t v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1, &v5);
  if (v2) {
    return *(void *)v2;
  }
  int v4 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)sockaddr buf = 134217984;
    uint64_t v7 = v5;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_INFO, "RESyncGetSyncObjectContextEntry: Couldn't find entry with id=%llu", buf, 0xCu);
  }
  return 0;
}

uint64_t RESyncRemoveSyncObjectContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v6 = a2;
  uint64_t v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a1, &v6);
  uint64_t v3 = v2;
  if ((v2 & 1) == 0)
  {
    int v4 = *re::networkLogObjects((re *)v2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)sockaddr buf = 134217984;
      uint64_t v8 = v6;
      _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "RESyncRemoveSyncObjectContextEntry: Couldn't find entry with id=%llu", buf, 0xCu);
    }
  }
  return v3;
}

uint64_t re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<void *&>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)unsigned int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<void *&>(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 24);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned long long>(uint64_t a1, void *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<1>(a1);
  if (result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    long long v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 9;
  }
  uint64_t v6 = *a2;
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, v6);
}

unsigned int *re::snapshotMapFields(re::snapshot::EncoderOPACK *a1, uint64_t a2)
{
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,BOOL>(a1, (unsigned __int8 *)(a2 + 16));
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,BOOL>(a1, (unsigned __int8 *)(a2 + 35));
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,unsigned short>(a1, (unsigned __int16 *)(a2 + 32));
  uint64_t result = re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<4,unsigned long long>(a1, (uint64_t *)(a2 + 24));
  if (!*(void *)(a2 + 24) && *(void *)a2)
  {
    return re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<5,re::HandOffData>(a1, a2);
  }
  return result;
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,BOOL>(re::snapshot::EncoderOPACK *this, unsigned __int8 *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 9;
  }
  int v6 = *a2;
  return re::snapshot::EncoderOPACK::operator<<((unsigned int *)this, v6);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,BOOL>(re::snapshot::EncoderOPACK *this, unsigned __int8 *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 2);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 10;
  }
  int v6 = *a2;
  return re::snapshot::EncoderOPACK::operator<<((unsigned int *)this, v6);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,unsigned short>(re::snapshot::EncoderOPACK *this, unsigned __int16 *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 3);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 11;
  }
  int v6 = *a2;
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, v6);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<4,unsigned long long>(re::snapshot::EncoderOPACK *this, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 4);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 12;
  }
  uint64_t v6 = *a2;
  return re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, v6);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<5,re::HandOffData>(re::snapshot::EncoderOPACK *this, uint64_t a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 5);
  }
  else
  {
    uint64_t v5 = *(void *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(unsigned char *)(v5 + v4) = 13;
  }
  re::snapshot::EncoderOPACK::beginObject((unsigned int *)this);
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned long long>(this, (uint64_t *)a2);
  re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned short>(this, (unsigned __int16 *)(a2 + 8));
  return re::snapshot::EncoderOPACK::endObject((unsigned int *)this);
}

uint64_t re::snapshotMapFields(uint64_t a1, uint64_t a2)
{
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,BOOL>(a1, (unsigned char *)(a2 + 16));
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,BOOL>(a1, (unsigned char *)(a2 + 35));
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,unsigned short>(a1, (_WORD *)(a2 + 32));
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<4,unsigned long long>(a1, (void *)(a2 + 24));
  return re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<5,re::HandOffData>(a1, a2);
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,BOOL>(uint64_t a1, unsigned char *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<1>(a1);
  if (result)
  {
    re::snapshot::DecoderOPACK::operator>>((uint64_t *)a1, a2);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,BOOL>(uint64_t a1, unsigned char *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<2>(a1);
  if (result)
  {
    re::snapshot::DecoderOPACK::operator>>((uint64_t *)a1, a2);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,unsigned short>(uint64_t a1, _WORD *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<3>(a1);
  if (result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<4,unsigned long long>(uint64_t a1, void *a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<4>(a1);
  if (result)
  {
    *a2 = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0);
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<5,re::HandOffData>(uint64_t a1, uint64_t a2)
{
  uint64_t result = re::snapshot::DecoderOPACK::advanceTo<5>(a1);
  if (result)
  {
    if (re::snapshot::DecoderOPACK::beginObject((re::snapshot::DecoderOPACK *)a1, 0))
    {
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned long long>(a1, (void *)a2);
      re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned short>(a1, (_WORD *)(a2 + 8));
      re::snapshot::DecoderOPACK::endObject((uint64_t *)a1, 0);
    }
    uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(void *)(a1 + 24) || (int v6 = *v5, v6 == 3))
    {
      uint64_t result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      uint64_t result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(void *)(a1 + 16) = v5 + 1;
      uint64_t result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

BOOL re::SyncOwnershipInfo::read(re::SyncOwnershipInfo *this, re::BitReader *a2, int a3, int a4)
{
  unsigned int v9 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 1u, &v9);
  *((unsigned char *)this + 16) = v9 != 0;
  unsigned int v9 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 1u, &v9);
  *((unsigned char *)this + 35) = v9 != 0;
  unsigned int v9 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)a2, 0x10u, &v9);
  *((_WORD *)this + 16) = v9;
  if (a4) {
    re::BitReader::readUInt64(a2, (unint64_t *)this + 3);
  }
  if (a3)
  {
    re::BitReader::readUInt64(a2, (unint64_t *)this);
    unsigned int v9 = 0;
    re::BitReader::readUInt32Bits((uint64_t *)a2, 0x10u, &v9);
    *((_WORD *)this + 4) = v9;
  }
  return *((unsigned char *)a2 + 12) == 0;
}

BOOL re::SyncOwnershipInfo::write(re::SyncOwnershipInfo *this, re::BitWriter *a2, int a3)
{
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int8 *)this + 16), 1u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int8 *)this + 35), 1u);
  re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int16 *)this + 16), 0x10u);
  if (a3)
  {
    unsigned int v6 = *((_DWORD *)this + 7);
    re::BitWriter::writeUInt32Bits((uint64_t)a2, *((_DWORD *)this + 6), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)a2, v6, 0x20u);
  }
  if (!*((void *)this + 3))
  {
    uint64_t v7 = *(void *)this;
    if (*(void *)this)
    {
      re::BitWriter::writeUInt32Bits((uint64_t)a2, *(void *)this, 0x20u);
      re::BitWriter::writeUInt32Bits((uint64_t)a2, HIDWORD(v7), 0x20u);
      re::BitWriter::writeUInt32Bits((uint64_t)a2, *((unsigned __int16 *)this + 4), 0x10u);
    }
  }
  return *((unsigned char *)a2 + 20) == 0;
}

BOOL re::snapshot::DecoderOPACK::advanceTo<4>(uint64_t a1)
{
  int Integer = *(_DWORD *)(a1 + 32);
  if (Integer <= 3)
  {
    while (1)
    {
      uint64_t v3 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v3 >= *(void *)(a1 + 24))
      {
        int v4 = 0;
      }
      else
      {
        *(void *)(a1 + 16) = v3 + 1;
        int v4 = *v3;
      }
      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v4);
      uint64_t v5 = *(unsigned __int8 **)(a1 + 16);
      if ((unint64_t)v5 >= *(void *)(a1 + 24)) {
        break;
      }
      int v6 = *v5;
      if (v6 == 3) {
        break;
      }
      if ((v6 - 7) > 0x28)
      {
        int Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
      }
      else
      {
        *(void *)(a1 + 16) = v5 + 1;
        int Integer = v6 - 8;
      }
      *(_DWORD *)(a1 + 32) = Integer;
      if (Integer >= 4) {
        return Integer == 4;
      }
    }
    int Integer = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 32) = 0x7FFFFFFF;
  }
  return Integer == 4;
}

uint64_t *re::networkLogObjects(re *this)
{
  {
    re::networkLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Network");
  }
  return &re::networkLogObjects(void)::logObjects;
}

double RESyncCreateSyncObjectWriteContext(re *a1)
{
  uint64_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 88, 8);
  double result = 0.0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(void *)(v2 + 80) = 0;
  *(_DWORD *)(v2 + 76) = 0x7FFFFFFF;
  return result;
}

re *RESyncDestroySyncObjectWriteContext(re *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = re::globalAllocators(result)[2];
    v3.n128_f64[0] = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v1 + 5);
    int v4 = *(uint64_t (**)(uint64_t, re *, __n128))(*(void *)v2 + 40);
    return (re *)v4(v2, v1, v3);
  }
  return result;
}

uint64_t RESyncGetSyncObjectWriteContextRequiredSize()
{
  return 88;
}

uint64_t RESyncCreateSyncObjectWriteContextNoAlloc(uint64_t result, unint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (!result)
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v3 = 136315394;
    int v4 = "RESyncCreateSyncObjectWriteContextNoAlloc";
    __int16 v5 = 2080;
    int v6 = "bytes != __null";
LABEL_10:
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  if (a2 <= 0x57)
  {
    uint64_t v2 = *re::networkLogObjects((re *)result);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v3 = 136315394;
    int v4 = "RESyncCreateSyncObjectWriteContextNoAlloc";
    __int16 v5 = 2080;
    int v6 = "size >= sizeof(re::SyncObjectWriteContext)";
    goto LABEL_10;
  }
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(void *)(result + 80) = 0;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)double result = 0u;
  *(_DWORD *)(result + 76) = 0x7FFFFFFF;
  return result;
}

void RESyncDestroySyncObjectWriteContextNoDealloc(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = (uint64_t *)(a1 + 40);
    re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v1);
  }
  else
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      int v4 = "RESyncDestroySyncObjectWriteContextNoDealloc";
      __int16 v5 = 2080;
      int v6 = "context != __null";
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

BOOL RESyncAddSyncObjectWriteContextEntry(re *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v10 = (const char *)a3;
  uint64_t v11 = a2;
  if (!a1)
  {
    unsigned int v9 = *re::networkLogObjects(0);
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)sockaddr buf = 136315394;
    unsigned int v13 = "RESyncAddSyncObjectWriteContextEntry";
    __int16 v14 = 2080;
    uint64_t v15 = "context != __null";
    int v6 = "%s: Invalid parameter not satisfying %s.";
    goto LABEL_13;
  }
  if (!a2)
  {
    unsigned int v9 = *re::networkLogObjects(a1);
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)sockaddr buf = 136315394;
    unsigned int v13 = "RESyncAddSyncObjectWriteContextEntry";
    __int16 v14 = 2080;
    uint64_t v15 = "entry != __null";
    int v6 = "%s: Invalid parameter not satisfying %s.";
LABEL_13:
    uint64_t v7 = v9;
    uint32_t v8 = 22;
    goto LABEL_6;
  }
  int v3 = (re *)re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<void *&>((uint64_t)a1 + 40, (uint64_t *)&v10, &v11);
  if (*(void *)v3 == v11) {
    return 1;
  }
  int v4 = *re::networkLogObjects(v3);
  BOOL result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)sockaddr buf = 134217984;
    unsigned int v13 = v10;
    int v6 = "RESyncAddSyncObjectWriteContextEntry: Failed to add entry using id=%llu, possible duplicate!";
    uint64_t v7 = v4;
    uint32_t v8 = 12;
LABEL_6:
    _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    return 0;
  }
  return result;
}

uint64_t RESyncGetSyncObjectWriteContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int v6 = (const char *)a2;
  if (a1)
  {
    uint64_t v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 40, (uint64_t *)&v6);
    if (v2) {
      return *(void *)v2;
    }
    int v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)sockaddr buf = 134217984;
      uint32_t v8 = v6;
      _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_INFO, "RESyncGetSyncObjectWriteContextEntry: Couldn't find entry with id=%llu.", buf, 0xCu);
    }
  }
  else
  {
    __int16 v5 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)sockaddr buf = 136315394;
      uint32_t v8 = "RESyncGetSyncObjectWriteContextEntry";
      __int16 v9 = 2080;
      uint64_t v10 = "context != __null";
      _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    }
  }
  return 0;
}

BOOL RESyncRemoveSyncObjectWriteContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v7 = (const char *)a2;
  if (a1)
  {
    uint64_t v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a1 + 40, (uint64_t *)&v7);
    if (v2) {
      return 1;
    }
    int v4 = *re::networkLogObjects((re *)v2);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (v5)
    {
      *(_DWORD *)sockaddr buf = 134217984;
      __int16 v9 = v7;
      _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "RESyncRemoveSyncObjectWriteContextEntry: Couldn't find entry with id=%llu.", buf, 0xCu);
      return 0;
    }
  }
  else
  {
    int v6 = *re::networkLogObjects(0);
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_DWORD *)sockaddr buf = 136315394;
      __int16 v9 = "RESyncRemoveSyncObjectWriteContextEntry";
      __int16 v10 = 2080;
      uint64_t v11 = "context != __null";
      _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
      return 0;
    }
  }
  return result;
}

uint64_t RESyncObjectWriteContextGetSession(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 8);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    int v4 = "RESyncObjectWriteContextGetSession";
    __int16 v5 = 2080;
    int v6 = "context != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncObjectWriteContextGetDestinationPeerID(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 16);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    int v4 = "RESyncObjectWriteContextGetDestinationPeerID";
    __int16 v5 = 2080;
    int v6 = "context != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

BOOL RESyncObjectWriteContextSupportsProtocolLevelAlmond(uint64_t a1)
{
  return RESyncObjectWriteContextSupportsProtocolLevel(a1, 8);
}

BOOL RESyncObjectWriteContextSupportsProtocolLevel(uint64_t a1, int a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a1) {
    return (a2 & ~*(_DWORD *)(a1 + 32)) == 0;
  }
  int v3 = *re::networkLogObjects(0);
  BOOL result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v4 = 136315394;
    __int16 v5 = "RESyncObjectWriteContextSupportsProtocolLevel";
    __int16 v6 = 2080;
    uint64_t v7 = "context != __null";
    _os_log_error_impl(&dword_228C70000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v4, 0x16u);
    return 0;
  }
  return result;
}

BOOL RESyncObjectWriteContextSupportsProtocolLevelPistachio(uint64_t a1)
{
  return RESyncObjectWriteContextSupportsProtocolLevel(a1, 16);
}

BOOL RESyncObjectWriteContextSupportsProtocolLevelWalnut(uint64_t a1)
{
  return RESyncObjectWriteContextSupportsProtocolLevel(a1, 32);
}

BOOL RESyncObjectWriteContextIsLocalSession(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 8) + 32))(v4);
    BOOL v1 = *(unsigned char *)(*(void *)v4 + 2219) != 0;
  }
  else
  {
    int v3 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v4 = 136315394;
      *(void *)&void v4[4] = "RESyncObjectWriteContextIsLocalSession";
      __int16 v5 = 2080;
      __int16 v6 = "context != __null";
      _os_log_error_impl(&dword_228C70000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", v4, 0x16u);
    }
    return 0;
  }
  return v1;
}

void re::DynamicArray<unsigned int>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<unsigned int>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2)
    {
      __int16 v5 = (void *)(*(void *)(a1 + 32) + 4 * v4);
      uint64_t v6 = 4 * a2 - 4 * v4;
      if (v6 >= 1) {
        bzero(v5, 4 * (((unint64_t)v6 >> 2) - ((unint64_t)v6 > 3)) + 4);
      }
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

re::SyncObjectShortIDManagerImpl *re::SyncObjectShortIDManagerImpl::SyncObjectShortIDManagerImpl(re::SyncObjectShortIDManagerImpl *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD355E0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  *(void *)((char *)this + 60) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(void *)((char *)this + 108) = 0x7FFFFFFFLL;
  *((void *)this + 16) = 0;
  *(void *)(v2 + 120) = 0;
  *((_DWORD *)this + 34) = 1;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 18) = 0;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 48) = 1;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((_DWORD *)this + 56) = 0;
  *((void *)this + 27) = 0;
  uint64_t v3 = re::BucketArray<re::SyncObjectShortIDBlock,4ul>::addUninitialized(v2 + 120);
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)uint64_t v3 = 0u;
  *(_DWORD *)(v3 + 44) = 127;
  re::DynamicArray<unsigned int>::resize(v3, 0x80uLL);
  uint64_t v4 = *(void *)(v3 + 16);
  if (v4)
  {
    __int16 v5 = *(_DWORD **)(v3 + 32);
    uint64_t v6 = 4 * v4;
    int v7 = 127;
    do
    {
      *v5++ = v7--;
      v6 -= 4;
    }
    while (v6);
  }
  *(void *)re::BucketArray<unsigned long,4ul>::addUninitialized((uint64_t)this + 176) = 0;
  return this;
}

uint64_t re::SyncObjectShortIDManagerImpl::mapOutgoing(re::SyncObjectShortIDManagerImpl *this, unint64_t a2, unint64_t a3)
{
  uint64_t v8 = *((void *)this + 3);
  uint64_t v6 = (char *)this + 24;
  LODWORD(v7) = v8;
  unint64_t v9 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  unint64_t v10 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
  unint64_t v11 = ((v10 ^ (v10 >> 31)) + ((v9 ^ (v9 >> 31)) << 6) + ((v9 ^ (v9 >> 31)) >> 2) - 0x61C8864680B583E9) ^ v9 ^ (v9 >> 31);
  if (v8)
  {
    unint64_t v7 = v11 % *((unsigned int *)this + 12);
    uint64_t v12 = *(unsigned int *)(*((void *)this + 4) + 4 * v7);
    if (v12 != 0x7FFFFFFF)
    {
      uint64_t v20 = *((void *)this + 5);
      uint64_t v21 = v20 + 40 * v12;
      uint64_t v23 = *(void *)(v21 + 16);
      uint64_t v22 = *(void *)(v21 + 24);
      if (v23 == a2 && v22 == a3)
      {
LABEL_19:
        uint64_t v19 = v20 + 40 * v12;
        goto LABEL_20;
      }
      while (1)
      {
        LODWORD(v12) = *(_DWORD *)(v20 + 40 * v12 + 8) & 0x7FFFFFFF;
        if (v12 == 0x7FFFFFFF) {
          break;
        }
        uint64_t v25 = v20 + 40 * v12;
        uint64_t v27 = *(void *)(v25 + 16);
        uint64_t v26 = *(void *)(v25 + 24);
        if (v27 == a2 && v26 == a3) {
          goto LABEL_19;
        }
      }
    }
  }
  uint64_t v13 = *((unsigned int *)this + 15);
  if (v13 == 0x7FFFFFFF)
  {
    uint64_t v13 = *((unsigned int *)this + 14);
    int v14 = v13;
    if (v13 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::setCapacity((uint64_t)v6, 2 * *((_DWORD *)this + 13));
      LODWORD(v7) = v11 % *((unsigned int *)this + 12);
      int v14 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v14 + 1;
    uint64_t v15 = *((void *)this + 5);
    int v16 = *(_DWORD *)(v15 + 40 * v13 + 8);
  }
  else
  {
    uint64_t v15 = *((void *)this + 5);
    int v16 = *(_DWORD *)(v15 + 40 * v13 + 8);
    *((_DWORD *)this + 15) = v16 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v15 + 40 * v13 + 8) = v16 | 0x80000000;
  uint64_t v17 = *((void *)this + 4);
  *(_DWORD *)(*((void *)this + 5) + 40 * v13 + 8) = *(_DWORD *)(*((void *)this + 5) + 40 * v13 + 8) & 0x80000000 | *(_DWORD *)(v17 + 4 * v7);
  *(void *)(*((void *)this + 5) + 40 * v13) = v11;
  uint64_t v18 = *((void *)this + 5) + 40 * v13;
  *(void *)(v18 + 16) = a2;
  *(void *)(v18 + 24) = a3;
  *(_DWORD *)(*((void *)this + 5) + 40 * v13 + 32) = -1;
  *(_DWORD *)(v17 + 4 * v7) = v13;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
  uint64_t v19 = *((void *)this + 5) + 40 * v13;
LABEL_20:
  int v29 = (unsigned int *)(v19 + 32);
  uint64_t result = *(unsigned int *)(v19 + 32);
  if (result == -1)
  {
    uint64_t v31 = *((void *)this + 27);
    if (v31) {
      goto LABEL_26;
    }
    uint64_t v32 = *((void *)this + 20);
    uint64_t v33 = re::BucketArray<re::SyncObjectShortIDBlock,4ul>::addUninitialized((uint64_t)this + 120);
    *(_OWORD *)uint64_t v33 = 0u;
    *(_OWORD *)(v33 + 16) = 0u;
    *(void *)(v33 + 32) = 0;
    int v34 = (v32 << 7) | 0x7F;
    *(_DWORD *)(v33 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v32 << 7;
    *(_DWORD *)(v33 + 44) = v34;
    re::DynamicArray<unsigned int>::resize(v33, 0x80uLL);
    uint64_t v35 = *(void *)(v33 + 16);
    if (v35)
    {
      unint64_t v36 = *(_DWORD **)(v33 + 32);
      uint64_t v37 = 4 * v35;
      do
      {
        *v36++ = v34--;
        v37 -= 4;
      }
      while (v37);
    }
    *(void *)re::BucketArray<unsigned long,4ul>::addUninitialized((uint64_t)this + 176) = v32;
    uint64_t v31 = *((void *)this + 27);
    if (v31)
    {
LABEL_26:
      long long v39 = (unint64_t *)re::BucketArray<unsigned long,4ul>::operator[]((uint64_t)this + 176, v31 - 1);
      uint64_t v40 = re::BucketArray<re::SyncObjectShortIDBlock,4ul>::operator[]((uint64_t)this + 120, *v39);
      uint64_t v41 = *(void *)(v40 + 16) - 1;
      uint64_t result = *(unsigned int *)(*(void *)(v40 + 32) + 4 * v41);
      *(void *)(v40 + 16) = v41;
      ++*(_DWORD *)(v40 + 24);
      *int v29 = result;
      if (!v41)
      {
        re::BucketArray<unsigned long,4ul>::operator[]((uint64_t)this + 176, *((void *)this + 27) - 1);
        --*((void *)this + 27);
        ++*((_DWORD *)this + 56);
        return *v29;
      }
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v38, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
      uint64_t result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::BucketArray<re::SyncObjectShortIDBlock,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size_t size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 48 * (a2 & 3);
}

uint64_t re::SyncObjectShortIDManagerImpl::unmapOutgoing(uint64_t this, unint64_t a2, unint64_t a3)
{
  if (*(void *)(this + 24))
  {
    uint64_t v3 = this;
    unint64_t v4 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
    unint64_t v5 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    unint64_t v6 = (((v4 ^ (v4 >> 31)) + ((v5 ^ (v5 >> 31)) << 6) + ((v5 ^ (v5 >> 31)) >> 2) - 0x61C8864680B583E9) ^ v5 ^ (v5 >> 31))
       % *(unsigned int *)(this + 48);
    uint64_t v7 = *(void *)(this + 32);
    uint64_t v8 = *(unsigned int *)(v7 + 4 * v6);
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(this + 40);
      uint64_t v10 = v9 + 40 * v8;
      uint64_t v12 = *(void *)(v10 + 16);
      uint64_t v11 = *(void *)(v10 + 24);
      BOOL v13 = v12 == a2 && v11 == a3;
      char v14 = v13;
      if (v13)
      {
        uint64_t v15 = (unsigned int *)(v9 + 40 * v8 + 32);
LABEL_12:
        *(_DWORD *)(v7 + 4 * v6) = *(_DWORD *)(v9 + 40 * v8 + 8) & 0x7FFFFFFF;
LABEL_13:
        uint64_t v16 = *(void *)(this + 40);
        uint64_t v17 = v16 + 40 * v8;
        int v20 = *(_DWORD *)(v17 + 8);
        uint64_t v19 = (int *)(v17 + 8);
        int v18 = v20;
        if (v20 < 0)
        {
          *uint64_t v19 = v18 & 0x7FFFFFFF;
          uint64_t v16 = *(void *)(this + 40);
          int v18 = *(_DWORD *)(v16 + 40 * v8 + 8);
        }
        int v21 = *(_DWORD *)(this + 64);
        *(_DWORD *)(v16 + 40 * v8 + 8) = *(_DWORD *)(this + 60) | v18 & 0x80000000;
        --*(_DWORD *)(this + 52);
        *(_DWORD *)(this + 60) = v8;
        *(_DWORD *)(this + 64) = v21 + 1;
LABEL_16:
        unint64_t v22 = (unint64_t)*v15 >> 7;
        this = re::BucketArray<re::SyncObjectShortIDBlock,4ul>::operator[](this + 120, v22);
        uint64_t v23 = this;
        int v24 = *v15;
        unint64_t v25 = *(void *)(this + 8);
        unint64_t v26 = *(void *)(this + 16);
        unint64_t v27 = v26;
        if (v26 >= v25)
        {
          if (v25 < v26 + 1)
          {
            if (*(void *)this)
            {
              uint64_t v28 = 2 * v25;
              BOOL v13 = v25 == 0;
              unint64_t v29 = 8;
              if (!v13) {
                unint64_t v29 = v28;
              }
              if (v29 <= v26 + 1) {
                unint64_t v30 = v26 + 1;
              }
              else {
                unint64_t v30 = v29;
              }
              this = (uint64_t)re::DynamicArray<unsigned int>::setCapacity((void *)this, v30);
            }
            else
            {
              this = (uint64_t)re::DynamicArray<unsigned int>::setCapacity((void *)v23, v26 + 1);
              ++*(_DWORD *)(v23 + 24);
            }
          }
          unint64_t v27 = *(void *)(v23 + 16);
        }
        *(_DWORD *)(*(void *)(v23 + 32) + 4 * v27) = v24;
        *(void *)(v23 + 16) = v27 + 1;
        ++*(_DWORD *)(v23 + 24);
        if (!v26)
        {
          uint64_t v41 = v3 + 176;
          unint64_t v42 = *(void *)(v3 + 216);
          this = re::BucketArray<unsigned long,4ul>::addUninitialized(v41);
          *(void *)this = v22;
          if (v42)
          {
            do
            {
              unint64_t v43 = v42 - 1;
              this = re::BucketArray<unsigned long,4ul>::operator[](v41, v42 - 1);
              if (*(void *)this >= v22) {
                break;
              }
              uint64_t v44 = *(void *)re::BucketArray<unsigned long,4ul>::operator[](v41, v42 - 1);
              *(void *)re::BucketArray<unsigned long,4ul>::operator[](v41, v42) = v44;
              this = re::BucketArray<unsigned long,4ul>::operator[](v41, v42 - 1);
              *(void *)this = v22;
              --v42;
            }
            while (v43);
          }
        }
      }
      else
      {
        while (1)
        {
          unsigned int v31 = *(_DWORD *)(v9 + 40 * *(unsigned int *)(v7 + 4 * v6) + 8) & 0x7FFFFFFF;
          if (v31 == 0x7FFFFFFF) {
            break;
          }
          uint64_t v32 = v9 + 40 * v31;
          uint64_t v34 = *(void *)(v32 + 16);
          uint64_t v33 = *(void *)(v32 + 24);
          if (v34 == a2 && v33 == a3)
          {
            uint64_t v15 = (unsigned int *)(v9 + 40 * v31 + 32);
            if (v14) {
              goto LABEL_12;
            }
            while (1)
            {
              unsigned int v36 = v8;
              LODWORD(v8) = *(_DWORD *)(v9 + 40 * v8 + 8) & 0x7FFFFFFF;
              if (v8 == 0x7FFFFFFF) {
                goto LABEL_16;
              }
              uint64_t v37 = v9 + 40 * v8;
              uint64_t v39 = *(void *)(v37 + 16);
              uint64_t v38 = *(void *)(v37 + 24);
              if (v39 == a2 && v38 == a3)
              {
                *(_DWORD *)(v9 + 40 * v36 + 8) = *(_DWORD *)(v9 + 40 * v36 + 8) & 0x80000000 | *(_DWORD *)(v9 + 40 * v8 + 8) & 0x7FFFFFFF;
                goto LABEL_13;
              }
            }
          }
        }
      }
    }
  }
  return this;
}

uint64_t re::BucketArray<unsigned long,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size_t size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 2) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 2)) + 8 * (a2 & 3);
}

void re::SyncObjectShortIDManagerImpl::mapIncoming(re::SyncObjectShortIDManagerImpl *this, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = *((void *)this + 9);
  uint64_t v8 = (char *)this + 72;
  LODWORD(v9) = v10;
  unint64_t v11 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  unint64_t v12 = (0x94D049BB133111EBLL * (v11 ^ (v11 >> 27))) ^ ((0x94D049BB133111EBLL * (v11 ^ (v11 >> 27))) >> 31);
  if (v10)
  {
    unint64_t v9 = v12 % *((unsigned int *)this + 24);
    uint64_t v13 = *(unsigned int *)(*((void *)this + 10) + 4 * v9);
    if (v13 != 0x7FFFFFFF)
    {
      uint64_t v21 = *((void *)this + 11);
      if (*(_DWORD *)(v21 + 32 * v13 + 12) == a2)
      {
LABEL_12:
        uint64_t v20 = v21 + 32 * v13;
        goto LABEL_13;
      }
      while (1)
      {
        uint64_t v13 = *(_DWORD *)(v21 + 32 * v13 + 8) & 0x7FFFFFFF;
        if (v13 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v21 + 32 * v13 + 12) == a2) {
          goto LABEL_12;
        }
      }
    }
  }
  uint64_t v14 = *((unsigned int *)this + 27);
  if (v14 == 0x7FFFFFFF)
  {
    uint64_t v14 = *((unsigned int *)this + 26);
    int v15 = v14;
    if (v14 == *((_DWORD *)this + 24))
    {
      re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity((uint64_t)v8, 2 * *((_DWORD *)this + 25));
      LODWORD(v9) = v12 % *((unsigned int *)this + 24);
      int v15 = *((_DWORD *)this + 26);
    }
    *((_DWORD *)this + 26) = v15 + 1;
    uint64_t v16 = *((void *)this + 11);
    int v17 = *(_DWORD *)(v16 + 32 * v14 + 8);
  }
  else
  {
    uint64_t v16 = *((void *)this + 11);
    int v17 = *(_DWORD *)(v16 + 32 * v14 + 8);
    *((_DWORD *)this + 27) = v17 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v16 + 32 * v14 + 8) = v17 | 0x80000000;
  uint64_t v18 = *((void *)this + 10);
  *(_DWORD *)(*((void *)this + 11) + 32 * v14 + 8) = *(_DWORD *)(*((void *)this + 11) + 32 * v14 + 8) & 0x80000000 | *(_DWORD *)(v18 + 4 * v9);
  *(void *)(*((void *)this + 11) + 32 * v14) = v12;
  *(_DWORD *)(*((void *)this + 11) + 32 * v14 + 12) = a2;
  uint64_t v19 = *((void *)this + 11) + 32 * v14;
  *(void *)(v19 + 16) = a3;
  *(void *)(v19 + 24) = a4;
  *(_DWORD *)(v18 + 4 * v9) = v14;
  ++*((_DWORD *)this + 25);
  ++*((_DWORD *)this + 28);
  uint64_t v20 = *((void *)this + 11) + 32 * v14;
LABEL_13:
  uint64_t v23 = *(void *)(v20 + 16);
  unint64_t v22 = (void *)(v20 + 16);
  if (v23 != a3 || v22[1] != a4)
  {
    *unint64_t v22 = a3;
    v22[1] = a4;
  }
}

uint64_t re::SyncObjectShortIDManagerImpl::mapIncoming(re::SyncObjectShortIDManagerImpl *this, unsigned int a2)
{
  uint64_t result = re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)this + 72, a2);
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(uint64_t a1, unsigned int a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v5 + 32 * v3 + 12) != a2)
  {
    while (1)
    {
      uint64_t v3 = *(_DWORD *)(v5 + 32 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(_DWORD *)(v5 + 32 * v3 + 12) == a2) {
        return v5 + 32 * v3 + 16;
      }
    }
    return 0;
  }
  return v5 + 32 * v3 + 16;
}

void *re::SyncObjectShortIDManagerImpl::unmapIncoming(re::SyncObjectShortIDManagerImpl *this, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (void *)((char *)this + 72);
  uint64_t result = (void *)re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)this + 72, a2);
  if (result)
  {
    if (*result == a3 && result[1] == a4)
    {
      if (*v8)
      {
        unint64_t v10 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
        unint64_t v11 = ((0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) ^ ((0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) >> 31))
            % *((unsigned int *)this + 24);
        uint64_t v12 = *((void *)this + 10);
        uint64_t v13 = *(unsigned int *)(v12 + 4 * v11);
        if (v13 != 0x7FFFFFFF)
        {
          uint64_t v14 = *((void *)this + 11);
          uint64_t v15 = v14 + 32 * v13;
          if (*(_DWORD *)(v15 + 12) == a2)
          {
            *(_DWORD *)(v12 + 4 * v11) = *(_DWORD *)(v15 + 8) & 0x7FFFFFFF;
LABEL_11:
            uint64_t v18 = *((void *)this + 11);
            uint64_t v19 = v18 + 32 * v13;
            int v22 = *(_DWORD *)(v19 + 8);
            uint64_t v21 = (int *)(v19 + 8);
            int v20 = v22;
            if (v22 < 0)
            {
              *uint64_t v21 = v20 & 0x7FFFFFFF;
              uint64_t v18 = *((void *)this + 11);
              int v20 = *(_DWORD *)(v18 + 32 * v13 + 8);
            }
            int v23 = *((_DWORD *)this + 28);
            *(_DWORD *)(v18 + 32 * v13 + 8) = *((_DWORD *)this + 27) | v20 & 0x80000000;
            --*((_DWORD *)this + 25);
            *((_DWORD *)this + 27) = v13;
            *((_DWORD *)this + 28) = v23 + 1;
          }
          else
          {
            while (1)
            {
              unsigned int v16 = v13;
              uint64_t v13 = *(_DWORD *)(v14 + 32 * v13 + 8) & 0x7FFFFFFF;
              if (v13 == 0x7FFFFFFF) {
                break;
              }
              uint64_t v17 = v14 + 32 * v13;
              if (*(_DWORD *)(v17 + 12) == a2)
              {
                *(_DWORD *)(v14 + 32 * v16 + 8) = *(_DWORD *)(v14 + 32 * v16 + 8) & 0x80000000 | *(_DWORD *)(v17 + 8) & 0x7FFFFFFF;
                goto LABEL_11;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void re::SyncObjectShortIDManagerImpl::~SyncObjectShortIDManagerImpl(re::SyncObjectShortIDManagerImpl *this)
{
  unint64_t v2 = (char *)this + 176;
  re::BucketArray<unsigned long,4ul>::deinit((uint64_t)this + 176);
  re::DynamicOverflowArray<unsigned long *,2ul>::deinit((uint64_t)v2);
  re::BucketArray<re::SyncObjectShortIDBlock,4ul>::deinit((uint64_t)this + 120);
  re::DynamicOverflowArray<unsigned long *,2ul>::deinit((uint64_t)this + 120);
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 9);
  re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)this + 3);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  char *v2;
  uint64_t vars8;

  unint64_t v2 = (char *)this + 176;
  re::BucketArray<unsigned long,4ul>::deinit((uint64_t)this + 176);
  re::DynamicOverflowArray<unsigned long *,2ul>::deinit((uint64_t)v2);
  re::BucketArray<re::SyncObjectShortIDBlock,4ul>::deinit((uint64_t)this + 120);
  re::DynamicOverflowArray<unsigned long *,2ul>::deinit((uint64_t)this + 120);
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 9);
  re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)this + 3);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::BucketArray<unsigned long,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
      re::BucketArray<unsigned long,4ul>::operator[](a1, i);
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<unsigned long,4ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<unsigned long *,2ul>::deinit(a1);
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::freeElementBucket(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (a1[2]) {
    uint64_t v3 = a1 + 3;
  }
  else {
    uint64_t v3 = (uint64_t *)a1[4];
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, v3[a1[1] - 1]);
  int v5 = *((_DWORD *)a1 + 4);
  --a1[1];
  *((_DWORD *)a1 + 4) = v5 + 2;
  return result;
}

uint64_t re::DynamicOverflowArray<unsigned long *,2ul>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    int v3 = *(_DWORD *)(a1 + 16);
    if ((v3 & 1) == 0)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 40))(result, *(void *)(a1 + 32));
      int v3 = *(_DWORD *)(a1 + 16);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = (v3 | 1) + 2;
  }
  return result;
}

uint64_t re::BucketArray<re::SyncObjectShortIDBlock,4ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
    {
      unint64_t v4 = (void *)re::BucketArray<re::SyncObjectShortIDBlock,4ul>::operator[](a1, i);
      if (*v4)
      {
        if (v4[4]) {
          (*(void (**)(void))(*(void *)*v4 + 40))(*v4);
        }
        void v4[4] = 0;
        v4[1] = 0;
        void v4[2] = 0;
        *unint64_t v4 = 0;
        ++*((_DWORD *)v4 + 6);
      }
    }
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<unsigned long,4ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<unsigned long *,2ul>::deinit(a1);
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

double re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 40 * v3;
      do
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 40;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void *re::DynamicArray<unsigned int>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          int v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 62)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 4, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 4 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 4 * a2, 4);
          if (result)
          {
            int v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 4 * v5[2]);
            double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        double result = (void *)re::DynamicArray<unsigned int>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::BucketArray<re::SyncObjectShortIDBlock,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::SyncObjectShortIDBlock,4ul>::setBucketsCapacity((void *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 48 * (v2 & 3);
}

void *re::BucketArray<re::SyncObjectShortIDBlock,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        double result = (void *)re::BucketArray<unsigned long,4ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          double result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 192, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              double result = re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            double result = re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    double result = (void *)re::BucketArray<re::SyncObjectShortIDBlock,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

void *re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(void *result, unint64_t a2)
{
  unint64_t v4 = result;
  uint64_t v5 = *result;
  if (a2 && !v5)
  {
    double result = (void *)re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v4, a2);
    int v6 = *((_DWORD *)v4 + 4) + 2;
LABEL_4:
    *((_DWORD *)v4 + 4) = v6;
    return result;
  }
  int v7 = *((_DWORD *)result + 4);
  if (v7) {
    uint64_t v8 = 2;
  }
  else {
    uint64_t v8 = result[3];
  }
  if (v8 != a2)
  {
    unint64_t v9 = result[1];
    if (v9 <= a2 && (a2 > 2 || (v7 & 1) == 0))
    {
      if (a2 < 3)
      {
        unint64_t v14 = result + 3;
        uint64_t v15 = v4[4];
        if (v7) {
          unint64_t v16 = v4 + 3;
        }
        else {
          unint64_t v16 = (const void *)v4[4];
        }
        memcpy(v14, v16, 8 * v9);
        double result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 40))(v5, v15);
        int v6 = *((_DWORD *)v4 + 4) | 1;
        goto LABEL_4;
      }
      if (a2 >> 61)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 646, 8, a2);
        _os_crash();
        __break(1u);
      }
      else
      {
        uint64_t v2 = 8 * a2;
        unint64_t v10 = (void *)(*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)v5 + 32))(*result, 8 * a2, 8);
        if (v10)
        {
          unint64_t v12 = v10;
          if (v4[2]) {
            unint64_t v13 = v4 + 3;
          }
          else {
            unint64_t v13 = (const void *)v4[4];
          }
          double result = memcpy(v10, v13, 8 * v4[1]);
          int v17 = *((_DWORD *)v4 + 4);
          if ((v17 & 1) == 0)
          {
            double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v4 + 40))(*v4, v4[4]);
            int v17 = *((_DWORD *)v4 + 4);
          }
          *((_DWORD *)v4 + 4) = v17 & 0xFFFFFFFE;
          v4[3] = a2;
          void v4[4] = v12;
          return result;
        }
      }
      re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, v2, *(void *)(*v4 + 8));
      double result = (void *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<unsigned long,4ul>::setBucketsCapacity((void *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 3);
}

void *re::BucketArray<unsigned long,4ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        double result = (void *)re::BucketArray<unsigned long,4ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          double result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 32, 0);
          int v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_22;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_18;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_18:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              double result = re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            double result = re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<re::SyncObjectShortIDBlock *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    double result = (void *)re::BucketArray<unsigned long,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

unint64_t re::Hash<re::Pair<unsigned long long,unsigned long long,true>>::operator()(uint64_t a1, void *a2)
{
  unint64_t v2 = 0xBF58476D1CE4E5B9 * (*a2 ^ (*a2 >> 30));
  unint64_t v3 = (0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31);
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (a2[1] ^ (a2[1] >> 30));
  return (((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
        + (v3 << 6)
        + (v3 >> 2)
        - 0x61C8864680B583E9) ^ v3;
}

void re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)int v22 = v5;
      *(void *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = v6 + 16;
        do
        {
          if ((*(_DWORD *)(v13 - 8) & 0x80000000) != 0)
          {
            unint64_t v14 = *(void *)(v13 - 16);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 40 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 40 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 40 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 40 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 40 * v17) = v14;
            *(_OWORD *)(*(void *)(a1 + 16) + 40 * v17 + 16) = *(_OWORD *)v13;
            *(_DWORD *)(*(void *)(a1 + 16) + 40 * v17 + 32) = *(_DWORD *)(v13 + 16);
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 40;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

void re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)int v22 = v5;
      *(void *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = (_OWORD *)(v6 + 16);
        do
        {
          if ((*((_DWORD *)v13 - 2) & 0x80000000) != 0)
          {
            unint64_t v14 = *((void *)v13 - 2);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashTable<unsigned int,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 32 * v17) = v14;
            *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 12) = *((_DWORD *)v13 - 1);
            *(_OWORD *)(*(void *)(a1 + 16) + 32 * v17 + 16) = *v13;
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 2;
          --v10;
        }
        while (v10);
      }
      re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

char *PacketUtils::move(PacketUtils *this, re::PacketPool **a2, re::PacketPool **a3, re::Transport *a4)
{
  uint64_t v4 = this;
  if (a2 != a3)
  {
    uint64_t v6 = re::PacketPool::allocate(a3[48], (*((_DWORD *)this + 6) + 3));
    re::Packet::offsetBy((uint64_t)v6, 3);
    uint64_t v7 = *((void *)v6 + 1);
    *(unsigned char *)(v7 + 2) = 0;
    *(_WORD *)uint64_t v7 = 0;
    *((_DWORD *)v6 + 6) = *((_DWORD *)v4 + 6);
    memcpy(*((void **)v6 + 2), *((const void **)v4 + 2), *((unsigned int *)v4 + 6));
    re::PacketPool::free(a2[48], v4);
    return v6;
  }
  return (char *)v4;
}

void re::Session::~Session(re::Session *this)
{
  *(void *)this = &unk_26DD35668;
  *((void *)this + 3) = &unk_26DD35700;
  if (*((unsigned char *)this + 2272)) {
    re::Session::deinit(this);
  }
  uint64_t v2 = 0;
  *((void *)this + 941) = &unk_26DD35DB0;
  do
  {
    v3.n128_f64[0] = re::Queue<re::Function<void ()(void)>>::deinit((uint64_t *)((char *)this + v2 + 7592));
    v2 -= 48;
  }
  while (v2 != -96);
  uint64_t v4 = *((void *)this + 940);
  if (v4)
  {

    *((void *)this + 9re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  }
  if (*((void *)this + 929)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 7432);
  }
  uint64_t v5 = *((void *)this + 934);
  if (v5)
  {
    if (*((void *)this + 938)) {
      (*(void (**)(uint64_t, __n128))(*(void *)v5 + 40))(v5, v3);
    }
    *((void *)this + 938) = 0;
    *((void *)this + 935) = 0;
    *((void *)this + 936) = 0;
    *((void *)this + 934) = 0;
    ++*((_DWORD *)this + 1874);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 7432);
  uint64_t v6 = *((void *)this + 928);
  if (v6)
  {

    *((void *)this + 928) = 0;
  }
  uint64_t v7 = *((void *)this + 403);
  if (v7)
  {
    if (*((void *)this + 407)) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    *((void *)this + 407) = 0;
    *((void *)this + 404) = 0;
    *((void *)this + 405) = 0;
    *((void *)this + 403) = 0;
    ++*((_DWORD *)this + 812);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 3184);
  re::DynamicArray<re::Session::BacklogItem>::deinit((uint64_t)this + 3144);
  double v8 = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 386);
  uint64_t v9 = *((void *)this + 381);
  if (v9)
  {
    if (*((void *)this + 385)) {
      (*(void (**)(uint64_t, double))(*(void *)v9 + 40))(v9, v8);
    }
    *((void *)this + 385) = 0;
    *((void *)this + 382) = 0;
    *((void *)this + 383) = 0;
    *((void *)this + 381) = 0;
    ++*((_DWORD *)this + 768);
  }
  uint64_t v10 = *((void *)this + 380);
  if (v10)
  {

    *((void *)this + 380) = 0;
  }
  re::Transport::~Transport((re::Session *)((char *)this + 2320));
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 2280);
  uint64_t v11 = *((void *)this + 282);
  if (v11)
  {

    *((void *)this + 282) = 0;
  }
  uint64_t v12 = *((void *)this + 281);
  if (v12)
  {

    *((void *)this + 281) = 0;
  }
  uint64_t v13 = *((void *)this + 276);
  if (v13)
  {

    *((void *)this + 276) = 0;
  }
  uint64_t v14 = *((void *)this + 272);
  if (v14)
  {

    *((void *)this + 272) = 0;
  }
  re::Event<re::Session>::~Event((uint64_t)this + 2056);
  re::Event<re::Session>::~Event((uint64_t)this + 1968);
  re::Event<re::Session>::~Event((uint64_t)this + 1880);
  re::Event<re::Session>::~Event((uint64_t)this + 1792);
  re::Event<re::Session>::~Event((uint64_t)this + 1704);
  re::Event<re::Session>::~Event((uint64_t)this + 1616);
  re::Event<re::Session>::~Event((uint64_t)this + 1528);
  if (*((void *)this + 180)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 1440);
  }
  uint64_t v15 = *((void *)this + 185);
  if (v15)
  {
    if (*((void *)this + 189)) {
      (*(void (**)(uint64_t))(*(void *)v15 + 40))(v15);
    }
    *((void *)this + 189) = 0;
    *((void *)this + 186) = 0;
    *((void *)this + 187) = 0;
    *((void *)this + 185) = 0;
    ++*((_DWORD *)this + 376);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 1440);
  uint64_t v16 = 880;
  do
  {
    uint64_t v17 = (void *)((char *)this + v16);
    if (*(void *)((char *)this + v16 + 472)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + v16 + 472);
    }
    uint64_t v18 = v17[64];
    if (v18)
    {
      uint64_t v19 = (char *)this + v16;
      if (*(void *)((char *)this + v16 + 544)) {
        (*(void (**)(uint64_t))(*(void *)v18 + 40))(v18);
      }
      *((void *)v19 + 68) = 0;
      v17[65] = 0;
      v17[66] = 0;
      v17[64] = 0;
      ++*((_DWORD *)v19 + 134);
    }
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + v16 + 472);
    v16 -= 88;
  }
  while (v16);
  if (*((void *)this + 59)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 472);
  }
  uint64_t v20 = *((void *)this + 64);
  if (v20)
  {
    if (*((void *)this + 68)) {
      (*(void (**)(uint64_t))(*(void *)v20 + 40))(v20);
    }
    *((void *)this + 68) = 0;
    *((void *)this + 65) = 0;
    *((void *)this + 66) = 0;
    *((void *)this + 64) = 0;
    ++*((_DWORD *)this + 134);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 472);
  if (*((void *)this + 48)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 384);
  }
  uint64_t v21 = *((void *)this + 53);
  if (v21)
  {
    if (*((void *)this + 57)) {
      (*(void (**)(uint64_t))(*(void *)v21 + 40))(v21);
    }
    *((void *)this + 57) = 0;
    *((void *)this + 54) = 0;
    *((void *)this + 55) = 0;
    *((void *)this + 53) = 0;
    ++*((_DWORD *)this + 112);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 384);
  if (*((void *)this + 37)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 296);
  }
  uint64_t v22 = *((void *)this + 42);
  if (v22)
  {
    if (*((void *)this + 46)) {
      (*(void (**)(uint64_t))(*(void *)v22 + 40))(v22);
    }
    *((void *)this + 46) = 0;
    *((void *)this + 43) = 0;
    *((void *)this + 44) = 0;
    *((void *)this + 42) = 0;
    ++*((_DWORD *)this + 90);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 296);
  if (*((void *)this + 26)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 208);
  }
  uint64_t v23 = *((void *)this + 31);
  if (v23)
  {
    if (*((void *)this + 35)) {
      (*(void (**)(uint64_t))(*(void *)v23 + 40))(v23);
    }
    *((void *)this + 35) = 0;
    *((void *)this + 32) = 0;
    *((void *)this + 33) = 0;
    *((void *)this + 31) = 0;
    ++*((_DWORD *)this + 68);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 208);
  re::Event<re::Session>::~Event((uint64_t)this + 120);
  re::Event<re::Session>::~Event((uint64_t)this + 32);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::Session::~Session(this);
  JUMPOUT(0x22A6A9430);
}

BOOL re::Session::init(uint64_t a1, long long *a2)
{
  uint64_t v99 = *MEMORY[0x263EF8340];
  long long v4 = *a2;
  *(_OWORD *)(a1 + 2160) = a2[1];
  *(_OWORD *)(a1 + 2144) = v4;
  uint64_t v5 = *((void *)a2 + 4);
  uint64_t v6 = *(void *)(a1 + 2176);
  if (v6 != v5)
  {
    if (v5)
    {
      id v7 = (id)(v5 + 8);
      uint64_t v6 = *(void *)(a1 + 2176);
    }
    if (v6) {

    }
    *(void *)(a1 + 2176) = v5;
  }
  long long v8 = *(long long *)((char *)a2 + 40);
  *(void *)(a1 + 2200) = *((void *)a2 + 7);
  *(_OWORD *)(a1 + 2184) = v8;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 2208), *((void *)a2 + 8));
  long long v9 = *(long long *)((char *)a2 + 72);
  *(_OWORD *)(a1 + 2228) = *(long long *)((char *)a2 + 84);
  *(_OWORD *)(a1 + 2216) = v9;
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 2248), *((void *)a2 + 13));
  uint64_t v10 = (_anonymous_namespace_ **)(a1 + 2256);
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 2256), *((void *)a2 + 14));
  *(_DWORD *)(a1 + 2264) = *((_DWORD *)a2 + 30);
  if (!*(void *)(a1 + 2256))
  {
    uint64_t v12 = re::globalAllocators(v11);
    uint64_t v13 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12[2] + 32))(v12[2], 24, 8);
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = 0;
    *(void *)uint64_t v13 = 0;
    ArcSharedObject::ArcSharedObject(v13, 0);
    *(void *)uint64_t v13 = &unk_26DD35280;
    uint64_t v14 = *v10;
    *uint64_t v10 = v13;
    if (v14) {
  }
    }
  uint64_t v15 = *(void *)(a1 + 2176);
  if (v15)
  {
    id v16 = (id)(v15 + 8);
    uint64_t v17 = v15;
  }
  else
  {
    re::make::shared::object<re::LeaderElectionLowestPeerID>(v11, &v87);
    uint64_t v17 = v87;
    uint64_t v87 = 0;
  }
  uint64_t v18 = *(void *)(a1 + 7424);
  *(void *)(a1 + 7424) = v17;
  if (v18) {

  }
  if (!v15 && v87) {
  uint64_t v19 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 7424) + 104))(*(void *)(a1 + 7424), a1);
  }
  *(_DWORD *)(a1 + 3032) = 1;
  uint64_t v20 = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity((void *)(a1 + 2280), 0x80uLL);
  ++*(_DWORD *)(a1 + 2304);
  uint64_t v21 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 32), 0);
  ++*(_DWORD *)(a1 + 56);
  uint64_t v22 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 120), 0);
  ++*(_DWORD *)(a1 + 144);
  uint64_t v23 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 208), 0);
  ++*(_DWORD *)(a1 + 232);
  int v24 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 296), 0);
  ++*(_DWORD *)(a1 + 320);
  unint64_t v25 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 384), 0);
  ++*(_DWORD *)(a1 + 408);
  unint64_t v26 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 1528), 0);
  ++*(_DWORD *)(a1 + 1552);
  unint64_t v27 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 472), 0);
  ++*(_DWORD *)(a1 + 496);
  uint64_t v28 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 1440), 0);
  ++*(_DWORD *)(a1 + 1464);
  unint64_t v29 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 1704), 0);
  ++*(_DWORD *)(a1 + 1728);
  uint64_t v30 = 560;
  do
  {
    uint64_t v31 = a1 + v30;
    unint64_t v29 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + v30), 0);
    ++*(_DWORD *)(v31 + 24);
    v30 += 88;
  }
  while (v31 + 88 != a1 + 1440);
  uint64_t v32 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 1616), 0);
  ++*(_DWORD *)(a1 + 1640);
  uint64_t v33 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 1792), 0);
  ++*(_DWORD *)(a1 + 1816);
  uint64_t v34 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 1880), 0);
  ++*(_DWORD *)(a1 + 1904);
  uint64_t v35 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 1968), 0);
  ++*(_DWORD *)(a1 + 1992);
  unsigned int v36 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 2056), 0);
  ++*(_DWORD *)(a1 + 2080);
  uint64_t v37 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 7432), 0);
  ++*(_DWORD *)(a1 + 7456);
  uint64_t v38 = *(void *)(a1 + 2256);
  if (v38) {
    uint64_t v37 = (re *)(id)(v38 + 8);
  }
  uint64_t v39 = re::globalAllocators(v37);
  uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v39[2] + 32))(v39[2], 312, 8);
  *(_OWORD *)uint64_t v40 = 0u;
  *(_OWORD *)(v40 + 16) = 0u;
  *(_OWORD *)(v40 + 32) = 0u;
  *(_OWORD *)(v40 + 48) = 0u;
  *(_OWORD *)(v40 + 64) = 0u;
  *(_OWORD *)(v40 + 80) = 0u;
  *(_OWORD *)(v40 + 96) = 0u;
  *(_OWORD *)(v40 + 112) = 0u;
  *(_OWORD *)(v40 + 128) = 0u;
  *(_OWORD *)(v40 + 144) = 0u;
  *(_OWORD *)(v40 + 160) = 0u;
  *(_OWORD *)(v40 + 176) = 0u;
  *(_OWORD *)(v40 + 192) = 0u;
  *(_OWORD *)(v40 + 208) = 0u;
  *(_OWORD *)(v40 + 224) = 0u;
  *(_OWORD *)(v40 + 2re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(v40 + 256) = 0u;
  *(_OWORD *)(v40 + 272) = 0u;
  *(_OWORD *)(v40 + 288) = 0u;
  *(void *)(v40 + re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 304) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v40, 0);
  *(void *)uint64_t v40 = &unk_26DD36FD0;
  *(unsigned char *)(v40 + 24) = 0;
  *(void *)(v40 + 32) = 0;
  *(void *)(v40 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  *(void *)(v40 + 48) = 100000000;
  *(_DWORD *)(v40 + 56) = 1000;
  *(void *)(v40 + 64) = 0;
  *(void *)(v40 + 72) = 0;
  *(void *)(v40 + 80) = 100000000;
  *(_DWORD *)(v40 + 200) = 0;
  *(void *)(v40 + 208) = 0;
  *(_DWORD *)(v40 + 216) = 0;
  *(_OWORD *)(v40 + 88) = 0u;
  *(_OWORD *)(v40 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0u;
  *(void *)(v40 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 232) = 0;
  *(void *)(v40 + 2re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  *(void *)(v40 + 224) = 0;
  *(_DWORD *)(v40 + 248) = 0;
  *(void *)(v40 + 296) = 0;
  *(_DWORD *)(v40 + re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 304) = 0;
  *(_OWORD *)(v40 + 256) = 0u;
  *(_OWORD *)(v40 + 272) = 0u;
  *(_DWORD *)(v40 + 288) = 0;
  uint64_t v42 = *(void *)(a1 + 7520);
  *(void *)(a1 + 7520) = v40;
  if (v42) {

  }
  *(void *)&long long v84 = a1 + 7432;
  *((void *)&v84 + 1) = 100000000;
  int v85 = 1000;
  uint64_t v86 = v38;
  re::Defaults::intValue((re::Defaults *)"network.session.maxTotalBandwidthBpsLocal", v41, (uint64_t)v82);
  if (v82[0])
  {
    if (*(unsigned char *)(a1 + 2219))
    {
      *((void *)&v84 + 1) = v83;
      uint64_t v45 = *re::networkLogObjects(v43);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)sockaddr buf = 134217984;
        *(void *)&uint8_t buf[4] = *((void *)&v84 + 1);
        _os_log_impl(&dword_228C70000, v45, OS_LOG_TYPE_DEFAULT, "Session: config override netMaxTotalBandwidthBpsLocal=%llu", buf, 0xCu);
      }
    }
  }
  re::Defaults::intValue((re::Defaults *)"network.session.maxTotalBandwidthBpsRemote", v44, (uint64_t)v80);
  if (v80[0])
  {
    if (!*(unsigned char *)(a1 + 2219))
    {
      *((void *)&v84 + 1) = v81;
      unsigned __int8 v47 = *re::networkLogObjects(v46);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)sockaddr buf = 134217984;
        *(void *)&uint8_t buf[4] = *((void *)&v84 + 1);
        _os_log_impl(&dword_228C70000, v47, OS_LOG_TYPE_DEFAULT, "Session: config override netMaxTotalBandwidthBpsRemote=%llu", buf, 0xCu);
      }
    }
  }
  re::PacketStatsFilter::init(*(void *)(a1 + 7520), &v84);
  *(void *)sockaddr buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  uint8_t buf[16] = 1;
  memset(v91, 0, sizeof(v91));
  long long v92 = 0u;
  __int16 v93 = 257;
  uint64_t v94 = a1;
  (*(void (**)(uint8_t *__return_ptr))(**((void **)a2 + 8) + 88))(v95);
  uint64_t v48 = *(void *)buf;
  *(void *)sockaddr buf = *(void *)v95;
  *(void *)uint64_t v95 = v48;
  if (v48) {

  }
  *(void *)&uint8_t buf[8] = *(void *)a2;
  uint8_t buf[16] = *((unsigned char *)a2 + 92);
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)v91, *((void *)a2 + 13));
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)v91 + 1, v38);
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)&v92 + 1, *(void *)(a1 + 7520));
  LOBYTE(v93) = re::NetworkFeatureFlags::overrideTransportThrottling(*((unsigned __int8 *)a2 + 76));
  HIBYTE(v93) = re::NetworkFeatureFlags::overrideMessageFragmentation(*((unsigned __int8 *)a2 + 77));
  if (*((unsigned char *)a2 + 79))
  {
    BOOL v49 = "NetworkReliable";
  }
  else
  {
    DWORD1(v91[1]) = *((_DWORD *)a2 + 22);
    BOOL v49 = "NetworkUnreliable";
  }
  *(void *)(a1 + 3272) = os_log_create("com.apple.re", v49);
  BOOL v50 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**((void **)a2 + 8) + 32))(*((void *)a2 + 8));
  *(void *)uint64_t v95 = a1;
  uint64_t v96 = re::Session::discoveryViewDidJoin;
  uint64_t v97 = 0;
  int v98 = re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::createSubscription<re::Session>(re::Session *,REEventHandlerResult (re::Session::*)(re::DiscoveryView*,re::SharedPtr<re::DiscoveryIdentity>))::{lambda(re::DiscoveryView*,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription const&,re::SharedPtr<re::DiscoveryIdentity>&&)#1}::__invoke;
  double v51 = re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::addSubscription(v50, (uint64_t)v95);
  int v52 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, double))(**((void **)a2 + 8) + 40))(*((void *)a2 + 8), v51);
  *(void *)uint64_t v95 = a1;
  uint64_t v96 = re::Session::discoveryViewDidLeave;
  uint64_t v97 = 0;
  int v98 = re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::createSubscription<re::Session>(re::Session *,REEventHandlerResult (re::Session::*)(re::DiscoveryView*,re::SharedPtr<re::DiscoveryIdentity>))::{lambda(re::DiscoveryView*,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription const&,re::SharedPtr<re::DiscoveryIdentity>&&)#1}::__invoke;
  re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::addSubscription(v52, (uint64_t)v95);
  BOOL v53 = re::Transport::init(a1 + 2320, (uint64_t *)buf);
  BOOL v54 = v53;
  if (v53)
  {
    if (*((void *)&v92 + 1))
    {

      *((void *)&v92 + 1) = 0;
    }
    if (*((void *)&v91[0] + 1))
    {

      *((void *)&v91[0] + 1) = 0;
    }
    if (*(void *)&v91[0])
    {

      *(void *)&v91[0] = 0;
    }
    if (*(void *)buf) {

    }
    unsigned int v55 = re::make::shared::object<re::RoutingTable>((re *)v53, (re::RoutingTable **)buf);
    uint64_t v56 = *(void *)(a1 + 3040);
    *(void *)(a1 + 30re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = *(void *)buf;
    *(void *)sockaddr buf = v56;
    if (v56) {

    }
    (*(void (**)(void))(**(void **)(a1 + 7424) + 48))(*(void *)(a1 + 7424));
    if (*((unsigned char *)a2 + 72)) {
      int v57 = *(_DWORD *)(a1 + 3280) | 2;
    }
    else {
      int v57 = *(_DWORD *)(a1 + 3280);
    }
    int v58 = *((_DWORD *)a2 + 30);
    if (!v58) {
      int v58 = 56;
    }
    *(_DWORD *)(a1 + 3280) = v58 | v57;
    unsigned __int16 v59 = (re *)re::Session::peerID((re::Session *)a1);
    uint64_t v60 = re::globalAllocators(v59);
    uint64_t v61 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v60[2] + 32))(v60[2], 160, 8);
    *(void *)sockaddr buf = re::SessionParticipant::SessionParticipant(v61, (uint64_t)v59, *(_DWORD *)(a1 + 3280), *((char **)a2 + 6), *((void *)a2 + 7));
    re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::add((_anonymous_namespace_ *)(a1 + 2280), buf);
    if (*(void *)buf) {

    }
    if ((*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8)))
    {
      unint64_t v62 = 0;
      do
      {
        (*(void (**)(uint64_t *__return_ptr))(**((void **)a2 + 8) + 56))(&v79);
        re::Session::addIdentity(a1, &v79);
        if (v79)
        {

          uint64_t v79 = 0;
        }
        ++v62;
      }
      while (v62 < (*(uint64_t (**)(void))(**((void **)a2 + 8) + 48))(*((void *)a2 + 8)));
    }
    re::Session::localParticipant(buf, a1);
    uint64_t v63 = *(void *)(*(void *)buf + 152);

    if (!v63)
    {
      uint64_t v65 = *re::networkLogObjects(v64);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)sockaddr buf = 0;
        _os_log_impl(&dword_228C70000, v65, OS_LOG_TYPE_DEFAULT, "No local identity set for session.", buf, 2u);
      }
    }
    unsigned int v66 = *(_DWORD *)(a1 + 2172);
    if (v66)
    {
      unsigned int v67 = *(_DWORD *)(a1 + 2240);
      if (v67 <= 1) {
        unsigned int v67 = 1;
      }
      *(void *)(a1 + 3296) = v66 / v67;
    }
    re::Session::stateSet((int *)a1, 1);
    *(unsigned char *)(a1 + 2272) = 1;
    unint64_t v69 = *re::networkLogObjects(v68);
    BOOL v70 = os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT);
    if (v70)
    {
      int v71 = *((unsigned __int8 *)a2 + 75);
      int v72 = *((unsigned __int8 *)a2 + 79);
      int v73 = *((_DWORD *)a2 + 20);
      int v74 = *((_DWORD *)a2 + 21);
      int v75 = *((_DWORD *)a2 + 22);
      *(_DWORD *)sockaddr buf = 134219264;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v71;
      __int16 v89 = 1024;
      int v90 = v72;
      LOWORD(v91[0]) = 1024;
      *(_DWORD *)((char *)v91 + 2) = v73;
      WORD3(v91[0]) = 1024;
      DWORD2(v91[0]) = v74;
      WORD6(v91[0]) = 1024;
      *(_DWORD *)((char *)v91 + 14) = v75;
      _os_log_impl(&dword_228C70000, v69, OS_LOG_TYPE_DEFAULT, "Session: initialized (%p) {isLocal=%d, useReliableSync=%d, resendPeriodMs=%u, syncPacketSizeLimit=%u, syncInboundQueueLimit=%u}", buf, 0x2Au);
    }
    unsigned int v76 = *re::networkLogObjects((re *)v70);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)sockaddr buf = 134217984;
      *(void *)&uint8_t buf[4] = *((void *)&v84 + 1);
      _os_log_impl(&dword_228C70000, v76, OS_LOG_TYPE_INFO, "Session: max bandwidth: %llu bps", buf, 0xCu);
    }
  }
  else
  {
    long long v77 = *re::networkLogObjects((re *)v53);
    if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v95 = 0;
      _os_log_error_impl(&dword_228C70000, v77, OS_LOG_TYPE_ERROR, "Cannot initialize transport.", v95, 2u);
    }
    if (*((void *)&v92 + 1))
    {

      *((void *)&v92 + 1) = 0;
    }
    if (*((void *)&v91[0] + 1))
    {

      *((void *)&v91[0] + 1) = 0;
    }
    if (*(void *)&v91[0])
    {

      *(void *)&v91[0] = 0;
    }
    if (*(void *)buf) {
  }
    }
  if (v38) {

  }
  return v54;
}

uint64_t re::Session::discoveryViewDidJoin(re *a1, uint64_t a2, uint64_t *a3)
{
  __n128 v3 = a1;
  v7[5] = *MEMORY[0x263EF8340];
  uint64_t v4 = *a3;
  if (*a3) {
    a1 = (re *)(id)(v4 + 8);
  }
  uint64_t v5 = re::globalAllocators(a1)[2];
  _OWORD v7[2] = v4;
  void v7[3] = v5;
  v7[0] = &unk_26DD357F8;
  v7[1] = v3;
  v7[4] = v7;
  if (!*((unsigned char *)v3 + 7648)) {
    re::network::EventQueue<re::Function<void ()(void)>>::push((os_unfair_lock_s *)v3 + 1884, (uint64_t)v7);
  }
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v7);
  return 0;
}

uint64_t re::Session::discoveryViewDidLeave(re *a1, uint64_t a2, uint64_t *a3)
{
  __n128 v3 = a1;
  v7[5] = *MEMORY[0x263EF8340];
  uint64_t v4 = *a3;
  if (*a3) {
    a1 = (re *)(id)(v4 + 8);
  }
  uint64_t v5 = re::globalAllocators(a1)[2];
  _OWORD v7[2] = v4;
  void v7[3] = v5;
  v7[0] = &unk_26DD35850;
  v7[1] = v3;
  v7[4] = v7;
  if (!*((unsigned char *)v3 + 7648)) {
    re::network::EventQueue<re::Function<void ()(void)>>::push((os_unfair_lock_s *)v3 + 1884, (uint64_t)v7);
  }
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v7);
  return 0;
}

void re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    id v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

_anonymous_namespace_ *re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::add(_anonymous_namespace_ *result, void *a2)
{
  __n128 v3 = result;
  unint64_t v5 = *((void *)result + 1);
  unint64_t v4 = *((void *)result + 2);
  if (v4 >= v5)
  {
    unint64_t v6 = v4 + 1;
    if (v5 < v4 + 1)
    {
      if (*(void *)result)
      {
        unint64_t v7 = 2 * v5;
        if (!v5) {
          unint64_t v7 = 8;
        }
        if (v7 <= v6) {
          unint64_t v8 = v6;
        }
        else {
          unint64_t v8 = v7;
        }
        double result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(result, v8);
      }
      else
      {
        double result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    unint64_t v4 = *((void *)v3 + 2);
  }
  *(void *)(*((void *)v3 + 4) + 8 * v4) = *a2;
  *a2 = 0;
  *((void *)v3 + 2) = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::Session::peerID(re::Session *this)
{
  uint64_t v1 = *((void *)this + 380);
  if (v1) {
    return *(void *)(v1 + 24);
  }
  __n128 v3 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)unint64_t v4 = 0;
    _os_log_impl(&dword_228C70000, v3, OS_LOG_TYPE_INFO, "Routing table is nil, returning kInvalidPeerID", v4, 2u);
  }
  return 0;
}

void re::Session::addIdentity(uint64_t a1, uint64_t *a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  if ((*(unsigned int (**)(void))(*(void *)*a2 + 48))())
  {
    re::Session::localParticipant(buf, a1);
    uint64_t v4 = *(void *)buf;
    uint64_t v5 = *a2;
    if (v5)
    {
      id v6 = (id)(v5 + 8);
      re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v4 + 152), v5);

      if (!v4) {
        return;
      }
    }
    else
    {
      re::SharedPtr<re::SyncObject>::reset((uint64_t *)(*(void *)buf + 152), 0);
      if (!v4) {
        return;
      }
    }

    return;
  }
  unint64_t v7 = (re *)(*(void *(**)(uint64_t *__return_ptr))(*(void *)*a2 + 40))(&v25);
  unint64_t v8 = *(void *)(a1 + 3160);
  if (!v8)
  {
LABEL_22:
    uint64_t v17 = *re::networkLogObjects(v7);
    BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
    if (v18)
    {
      uint64_t v19 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
      if (v26) {
        uint64_t v20 = v28;
      }
      else {
        uint64_t v20 = v27;
      }
      *(_DWORD *)sockaddr buf = 136315394;
      *(void *)&uint8_t buf[4] = v19;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v20;
      _os_log_impl(&dword_228C70000, v17, OS_LOG_TYPE_DEFAULT, "No pending connection for identity '%s (%s)'. Will initiate a new one.", buf, 0x16u);
    }
    *((void *)&v41 + 1) = 0;
    memset(buf, 0, 28);
    long long v39 = 0u;
    long long v40 = 0u;
    LODWORD(v41) = 0;
    re::DynamicArray<unsigned char>::setCapacity((void *)&v39 + 1, 0);
    LODWORD(v41) = v41 + 1;
    *(void *)sockaddr buf = re::Transport::connect((re::Transport *)(a1 + 2320), (const re::Address *)&v25);
    *(void *)&long long v39 = (*(uint64_t (**)(void))(**(void **)(a1 + 2256) + 32))(*(void *)(a1 + 2256));
    re::SharedPtr<re::SyncObject>::reset((uint64_t *)&buf[16], *a2);
    re::DynamicArray<re::Session::BacklogItem>::add(a1 + 3144, (uint64_t)buf);
    if (*((void *)&v39 + 1))
    {
      if (*((void *)&v41 + 1)) {
        (*(void (**)(void))(**((void **)&v39 + 1) + 40))();
      }
      *((void *)&v41 + 1) = 0;
      long long v40 = 0uLL;
      *((void *)&v39 + 1) = 0;
      LODWORD(v41) = v41 + 1;
    }
    if (*(void *)&buf[16]) {

    }
    goto LABEL_42;
  }
  uint64_t v9 = 0;
  unint64_t v10 = 0;
  while (1)
  {
    uint64_t v11 = *(void *)(*(void *)(a1 + 3176) + v9);
    if (v11) {
      break;
    }
LABEL_21:
    ++v10;
    v9 += 80;
    if (v10 >= v8) {
      goto LABEL_22;
    }
  }
  re::Transport::connectionAddress((re::Transport *)(a1 + 2320), v11, (re::DynamicString *)buf);
  if (v26) {
    uint64_t v12 = v28;
  }
  else {
    uint64_t v12 = v27;
  }
  uint64_t v13 = buf[8] & 1;
  if (buf[8]) {
    uint64_t v14 = *(const char **)&buf[16];
  }
  else {
    uint64_t v14 = (const char *)&buf[9];
  }
  int v15 = strcmp(v12, v14);
  unint64_t v7 = *(re **)buf;
  if (*(void *)buf) {
    BOOL v16 = v13 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16) {
    unint64_t v7 = (re *)(*(uint64_t (**)(void))(**(void **)buf + 40))();
  }
  if (v15)
  {
    unint64_t v8 = *(void *)(a1 + 3160);
    goto LABEL_21;
  }
  uint64_t v21 = *re::networkLogObjects(v7);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
    if (v26) {
      uint64_t v23 = v28;
    }
    else {
      uint64_t v23 = v27;
    }
    *(_DWORD *)sockaddr buf = 136315394;
    *(void *)&uint8_t buf[4] = v22;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v23;
    _os_log_impl(&dword_228C70000, v21, OS_LOG_TYPE_DEFAULT, "Found backlog item for identity: %s (%s).", buf, 0x16u);
  }
  unint64_t v24 = *(void *)(a1 + 3160);
  if (v24 <= v10)
  {
    uint64_t v29 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v39 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v30 = 136315906;
    uint64_t v31 = "operator[]";
    __int16 v32 = 1024;
    int v33 = 789;
    __int16 v34 = 2048;
    unint64_t v35 = v10;
    __int16 v36 = 2048;
    unint64_t v37 = v24;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(*(void *)(a1 + 3176) + v9 + 16), *a2);
  re::Session::stateEvent(a1, 3);
LABEL_42:
  if (v25)
  {
    if (v26) {
      (*(void (**)(void))(*(void *)v25 + 40))();
    }
  }
}

void *re::Session::localParticipant(void *this, uint64_t a2)
{
  if (!*(void *)(a2 + 2296))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = **(void **)(a2 + 2312);
  *this = v2;
  if (v2)
  {
    return (id)(v2 + 8);
  }
  return this;
}

void re::Session::stateSet(int *a1, int a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v4 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    unint64_t v8 = v5;
    __int16 v9 = 2080;
    unint64_t v10 = v6;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Session: changing state %s->%s", (uint8_t *)&v7, 0x16u);
  }
  re::Session::stateEvent((BOOL)a1, 1);
  a1[816] = a2;
  re::Session::stateEvent((BOOL)a1, 0);
}

void re::Session::deinit(re::Session *this)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 2272))
  {
    if (*((_DWORD *)this + 816) != 3) {
      re::Session::stopSession((uint64_t)this, 1);
    }
    re::Event<re::Session>::raise((uint64_t)this + 32, (uint64_t)this);
    *((unsigned char *)this + 2272) = 0;
    re::Transport::deinit((re::Session *)((char *)this + 2320));
    re::DynamicArray<re::Session::BacklogItem>::deinit((uint64_t)this + 3144);
    re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 2280);
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 3184);
    re::PacketStatsFilter::deInit(*((re::PacketStatsFilter **)this + 940));
    if (*((void *)this + 929)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 7432);
    }
    (*(void (**)(void))(**((void **)this + 928) + 32))(*((void *)this + 928));
    if (*((void *)this + 257)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 2056);
    }
    if (*((void *)this + 246)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 1968);
    }
    if (*((void *)this + 202)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 1616);
    }
    if (*((void *)this + 224)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 1792);
    }
    if (*((void *)this + 235)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 1880);
    }
    uint64_t v2 = 0;
    __n128 v3 = (char *)this + 560;
    do
    {
      if (*(void *)&v3[v2]) {
        re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)&v3[v2]);
      }
      v2 += 88;
    }
    while (v2 != 880);
    if (*((void *)this + 213)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 1704);
    }
    if (*((void *)this + 180)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 1440);
    }
    if (*((void *)this + 59)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 472);
    }
    if (*((void *)this + 191)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 1528);
    }
    if (*((void *)this + 48)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 384);
    }
    if (*((void *)this + 37)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 296);
    }
    if (*((void *)this + 26)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 208);
    }
    uint64_t v4 = (re::Session *)((char *)this + 120);
    if (*((void *)this + 15)) {
      uint64_t v4 = (re *)re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v4);
    }
    if (*((void *)this + 4)) {
      uint64_t v4 = (re *)re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 32);
    }
    uint64_t v5 = *re::networkLogObjects(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 134217984;
      int v7 = this;
      _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "Session: deinitialized (%p).", (uint8_t *)&v6, 0xCu);
    }
  }
}

void re::Session::stopSession(uint64_t a1, int a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 3264) != 3)
  {
    *(_DWORD *)(a1 + 3032) = a2;
    re::Session::stateSet((int *)a1, 3);
    uint64_t v4 = *(void *)(a1 + 3160);
    *(void *)(a1 + 3160) = 0;
    if (v4)
    {
      uint64_t v5 = 80 * v4;
      uint64_t v6 = *(void *)(a1 + 3176) + 40;
      do
      {
        re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v6);
        uint64_t v7 = *(void *)(v6 - 24);
        if (v7)
        {

          *(void *)(v6 - 24) = 0;
        }
        v6 += 80;
        v5 -= 80;
      }
      while (v5);
    }
    ++*(_DWORD *)(a1 + 3168);
    *(void *)(a1 + 3200) = 0;
    ++*(_DWORD *)(a1 + 3208);
    uint64_t v8 = *(void *)(a1 + 3064);
    if (v8)
    {
      __int16 v9 = *(re::Packet ***)(a1 + 3080);
      uint64_t v10 = 40 * v8;
      do
      {
        uint64_t v11 = *v9;
        v9 += 5;
        re::PacketPool::free(*(re::PacketPool **)(a1 + 2704), v11);
        v10 -= 40;
      }
      while (v10);
    }
    *(void *)(a1 + 3064) = 0;
    ++*(_DWORD *)(a1 + 3072);
    *(unsigned char *)(a1 + 7648) = 1;
    (*(void (**)(void))(*(void *)(a1 + 7528) + 24))();
    uint64_t v12 = *(void *)(a1 + 2208);
    if (v12)
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 40))(v12);
      re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(v13, a1);
      uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(a1 + 2208) + 32))(*(void *)(a1 + 2208));
      re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(v14, a1);
    }
    int v15 = re::RoutingTable::removeRoutesForTransport(*(re::RoutingTable **)(a1 + 3040), (re::Transport *)(a1 + 2320));
    BOOL v16 = *re::networkLogObjects(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 134218240;
      uint64_t v18 = a1;
      __int16 v19 = 1024;
      int v20 = a2;
      _os_log_impl(&dword_228C70000, v16, OS_LOG_TYPE_DEFAULT, "Session: stopped (%p) with error: %d", (uint8_t *)&v17, 0x12u);
    }
  }
}

void re::Event<re::Session>::raise(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      uint64_t v7 = 0;
      for (unint64_t i = 0; i != v6; ++i)
      {
        unint64_t v9 = *(void *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v15 = 136315906;
          BOOL v16 = "operator[]";
          __int16 v17 = 1024;
          int v18 = 789;
          __int16 v19 = 2048;
          unint64_t v20 = i;
          __int16 v21 = 2048;
          unint64_t v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = *(void *)(a1 + 72) + v7;
        uint64_t v11 = *(void *)(v10 + 32);
        long long v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        uint64_t v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, *((unint64_t *)&v23[0] + 1));
          }
        }
        v7 += 40;
      }
    }
  }
}

uint64_t re::DynamicArray<re::Session::BacklogItem>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 80 * v4;
        uint64_t v6 = v3 + 40;
        do
        {
          re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v6);
          uint64_t v7 = *(void *)(v6 - 24);
          if (v7)
          {

            *(void *)(v6 - 24) = 0;
          }
          v6 += 80;
          v5 -= 80;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::Session::participants(re::Session *this)
{
  return *((void *)this + 289);
}

void re::Session::setRoutingTable(re::Session *this, uint64_t *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v4 = *a2;
  if (*a2 && (uint64_t v5 = (void *)*((void *)this + 380)) != 0)
  {
    uint64_t v6 = v5[6];
    if (v6)
    {
      uint64_t v7 = (uint64_t *)v5[8];
      uint64_t v8 = &v7[5 * v6];
      do
      {
        unint64_t v9 = (long long *)(v7 + 1);
        uint64_t v10 = *v7;
        v7 += 5;
        re::RoutingTable::addRoute(v4, v10, v9);
      }
      while (v7 != v8);
      uint64_t v4 = *a2;
      uint64_t v5 = (void *)*((void *)this + 380);
    }
    if (v5 == (void *)v4)
    {
      uint64_t v4 = (uint64_t)v5;
    }
    else
    {
      if (v4)
      {
        id v11 = (id)(v4 + 8);
        uint64_t v5 = (void *)*((void *)this + 380);
      }
      if (v5) {

      }
      *((void *)this + 380) = v4;
    }
    uint64_t v13 = *(void *)(v4 + 24);
    re::Session::assignLocalPeerID(this, v13);
  }
  else
  {
    long long v12 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v14 = *((unsigned __int8 *)this + 2272);
      uint64_t v15 = *a2;
      uint64_t v16 = *((void *)this + 380);
      v17[0] = 67109632;
      v17[1] = v14;
      __int16 v18 = 2048;
      uint64_t v19 = v15;
      __int16 v20 = 2048;
      uint64_t v21 = v16;
      _os_log_error_impl(&dword_228C70000, v12, OS_LOG_TYPE_ERROR, "Cannot set routing table {isInitialized: %d, routingTable parameter: %p, session routing table:%p}", (uint8_t *)v17, 0x1Cu);
    }
  }
}

uint64_t re::Session::assignLocalPeerID(re::Session *this, uint64_t a2)
{
  re::Session::localParticipant(&v7, (uint64_t)this);
  uint64_t v4 = v7;
  *(void *)(v7 + 24) = a2;

  uint64_t v5 = *(uint64_t (**)(void))(**((void **)this + 928) + 40);
  return v5();
}

void re::Session::processIncomingMessages(re::Session *this, unint64_t a2)
{
  uint64_t v175 = *MEMORY[0x263EF8340];
  if (!a2) {
    return;
  }
  uint64_t v4 = (_DWORD *)re::DataArray<re::Connection>::tryGet((uint64_t)this + 2440, a2);
  if (!v4) {
    return;
  }
  if (*v4 != 1) {
    return;
  }
  uint64_t v162 = 0;
  v155 = (re::Session *)((char *)this + 2320);
  if (!re::Transport::receive((uint64_t)this + 2320, a2, 0, (uint64_t *)&v162)) {
    return;
  }
  int v154 = (char *)this + 3088;
  v156 = (void *)((char *)this + 3048);
LABEL_6:
  uint64_t v5 = v162;
  unsigned int v6 = *((_DWORD *)v162 + 6);
  uint64_t v157 = *((void *)v162 + 2);
  unsigned int v158 = v6;
  BOOL v159 = 0;
  uint64_t v160 = 0;
  uint64_t v161 = 0;
  if (!v6) {
    goto LABEL_146;
  }
  while (2)
  {
    re::Session::readRoutingHeader((re::Session *)&v167, (re::BitReader *)&v157);
    if (!(_BYTE)v167
      || (*(_DWORD *)v171 = 0, uint64_t v7 = re::BitReader::readUInt32Bits(&v157, 8u, (unsigned int *)v171), v159))
    {
      unsigned int v41 = 6;
LABEL_183:
      re::PacketPool::free(*((re::PacketPool **)this + 338), v162);
      uint64_t v118 = *re::networkLogObjects(v117);
      uint64_t v119 = os_log_type_enabled(v118, OS_LOG_TYPE_ERROR);
      if (v119)
      {
        re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
        uint64_t v147 = &v171[9];
        if (v171[8]) {
          uint64_t v147 = *(uint8_t **)&v171[16];
        }
        *(_DWORD *)v166 = 136315394;
        *(void *)&v166[4] = v147;
        *(_WORD *)&v166[12] = 1024;
        *(_DWORD *)&v166[14] = v41;
        _os_log_error_impl(&dword_228C70000, v118, OS_LOG_TYPE_ERROR, "Received corrupt message from '%s'. Packet error: %d, Disconnecting.", v166, 0x12u);
        uint64_t v119 = *(void *)v171;
        if (*(void *)v171 && (v171[8] & 1) != 0) {
          uint64_t v119 = (*(uint64_t (**)(void))(**(void **)v171 + 40))();
        }
      }
      unint64_t v164 = a2;
      unsigned int v163 = v41;
      int v120 = *((_DWORD *)this + 380);
      *((_DWORD *)this + 380) = v120 + 1;
      if (*((void *)this + 182))
      {
        unint64_t v121 = 0;
        do
        {
          uint64_t v119 = (*(uint64_t (**)(re::Session *))(*((void *)this + 184) + 32 * v121 + 24))(this);
          if (v119 == 1) {
            uint64_t v119 = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)this + 180, v121);
          }
          else {
            ++v121;
          }
        }
        while (v121 < *((void *)this + 182));
        int v120 = *((_DWORD *)this + 380) - 1;
      }
      *((_DWORD *)this + 380) = v120;
      if (!v120)
      {
        uint64_t v122 = *((void *)this + 187);
        if (v122)
        {
          uint64_t v123 = 0;
          for (unint64_t i = 0; i != v122; ++i)
          {
            unint64_t v125 = *((void *)this + 187);
            if (v125 <= i)
            {
              *(void *)sockaddr buf = 0;
              long long v173 = 0u;
              long long v174 = 0u;
              long long v172 = 0u;
              memset(v171, 0, sizeof(v171));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v167 = 136315906;
              *(void *)v168 = "operator[]";
              *(_WORD *)&v168[8] = 1024;
              *(_DWORD *)&v168[10] = 789;
              *(_WORD *)&v168[14] = 2048;
              *(void *)&v168[16] = i;
              __int16 v169 = 2048;
              unint64_t v170 = v125;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            uint64_t v126 = *((void *)this + 189) + v123;
            *(_OWORD *)v166 = *(_OWORD *)v126;
            *(_OWORD *)&v166[16] = *(_OWORD *)(v126 + 16);
            *(void *)&v166[32] = *(void *)(v126 + 32);
            if (v166[0])
            {
              uint64_t v119 = re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf((uint64_t)v171, *((void *)this + 182), *((char **)this + 184), &v166[8]);
              if (!v171[0])
              {
                unint64_t v127 = *((void *)this + 182);
                unint64_t v128 = *((void *)this + 181);
                if (v127 >= v128)
                {
                  unint64_t v129 = v127 + 1;
                  if (v128 < v127 + 1)
                  {
                    if (*((void *)this + 180))
                    {
                      uint64_t v130 = 2 * v128;
                      BOOL v131 = v128 == 0;
                      unint64_t v132 = 8;
                      if (!v131) {
                        unint64_t v132 = v130;
                      }
                      if (v132 <= v129) {
                        unint64_t v133 = v129;
                      }
                      else {
                        unint64_t v133 = v132;
                      }
                      uint64_t v119 = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)this + 180, v133);
                    }
                    else
                    {
                      uint64_t v119 = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)this + 180, v129);
                      ++*((_DWORD *)this + 366);
                    }
                  }
                  unint64_t v127 = *((void *)this + 182);
                }
                uint64_t v134 = (_OWORD *)(*((void *)this + 184) + 32 * v127);
                *uint64_t v134 = *(_OWORD *)&v166[8];
                v134[1] = *(_OWORD *)&v166[24];
                ++*((void *)this + 182);
                ++*((_DWORD *)this + 366);
              }
            }
            else
            {
              uint64_t v119 = re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf((uint64_t)v171, *((void *)this + 182), *((char **)this + 184), &v166[8]);
              if (v171[0]) {
                uint64_t v119 = (uint64_t)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)this + 180, *(unint64_t *)&v171[8]);
              }
            }
            v123 += 40;
          }
        }
      }
      uint64_t v135 = *((void *)this + 287);
      if (v135)
      {
        uint64_t v136 = (uint64_t *)*((void *)this + 289);
        uint64_t v137 = 8 * v135;
        while (1)
        {
          uint64_t v138 = *v136;
          if (*(void *)(*v136 + 32) == a2) {
            break;
          }
          ++v136;
          v137 -= 8;
          if (!v137) {
            goto LABEL_216;
          }
        }
        id v140 = (id)(v138 + 8);
        v141 = re::PacketPool::allocate(*((re::PacketPool **)this + 338), 67);
        re::Packet::offsetBy((uint64_t)v141, 3);
        uint64_t v142 = *((void *)v141 + 1);
        *(unsigned char *)(v142 + 2) = 0;
        *(_WORD *)uint64_t v142 = 0;
        uint64_t v143 = *((void *)v141 + 2);
        int v144 = *((_DWORD *)v141 + 7);
        *(void *)unint64_t v171 = &unk_26DD35FA8;
        *(void *)&v171[8] = v143;
        *(_DWORD *)&v171[16] = v144;
        v171[20] = 0;
        *(void *)&v171[24] = 0;
        *(void *)&long long v172 = 0;
        re::BitWriter::writeUInt32Bits((uint64_t)v171, 0, 0x20u);
        re::BitWriter::writeUInt32Bits((uint64_t)v171, 0, 0x20u);
        re::BitWriter::writeUInt32Bits((uint64_t)v171, 0, 0x20u);
        re::BitWriter::writeUInt32Bits((uint64_t)v171, 0, 0x20u);
        re::BitWriter::writeUInt32Bits((uint64_t)v171, 3u, 8u);
        re::BitWriter::writeUInt32Bits((uint64_t)v171, v41, 0x20u);
        int v145 = *(_DWORD *)&v171[24];
        if (*(_DWORD *)&v171[28]) {
          int v145 = *(_DWORD *)&v171[24] + 1;
        }
        *((_DWORD *)v141 + 6) = v145;
        re::Transport::send((uint64_t)v155, a2, (unint64_t)v141, 0, 0, 0, *(_DWORD *)(v138 + 72));
      }
      else
      {
LABEL_216:
        uint64_t v139 = *re::networkLogObjects((re *)v119);
        if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)unint64_t v171 = 0;
          _os_log_error_impl(&dword_228C70000, v139, OS_LOG_TYPE_ERROR, "sendSessionError: missing participant for connection!", v171, 2u);
        }
      }
      re::Transport::disconnect(v155, a2, 0);
      if (v41 != 4 || !*((unsigned char *)this + 2222)) {
        goto LABEL_223;
      }
      uint64_t v153 = *re::networkLogObjects(v146);
      if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unint64_t v171 = 134217984;
        *(void *)&v171[4] = this;
        _os_log_impl(&dword_228C70000, v153, OS_LOG_TYPE_DEFAULT, "Stopping Session (%p) with packet error=kProtocolMismatch", v171, 0xCu);
      }
      re::Session::stopSession((uint64_t)this, 4);
      return;
    }
    int v8 = v171[0];
    unint64_t v10 = *(void *)&v168[4];
    unint64_t v9 = *(void *)&v168[12];
    switch(v171[0])
    {
      case 1u:
        id v11 = *re::networkLogObjects((re *)v7);
        long long v12 = (re *)os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
        if (v12)
        {
          re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
          __int16 v89 = &v171[9];
          if (v171[8]) {
            __int16 v89 = *(uint8_t **)&v171[16];
          }
          *(_DWORD *)v166 = 136315138;
          *(void *)&v166[4] = v89;
          _os_log_debug_impl(&dword_228C70000, v11, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kPeerHello from %s", v166, 0xCu);
          long long v12 = *(re **)v171;
          if (*(void *)v171 && (v171[8] & 1) != 0) {
            long long v12 = (re *)(*(uint64_t (**)(void))(**(void **)v171 + 40))();
          }
        }
        if (!v9)
        {
          unint64_t v164 = 0;
          *(void *)sockaddr buf = 0;
          *(_DWORD *)unint64_t v171 = 0;
          uint64_t v13 = re::BitReader::readUInt32Bits(&v157, 0x20u, (unsigned int *)v171);
          int v14 = *(_DWORD *)v171;
          if (*((_DWORD *)this + 538) != *(_DWORD *)v171)
          {
            uint64_t v99 = *re::networkLogObjects((re *)v13);
            uint64_t v26 = os_log_type_enabled(v99, OS_LOG_TYPE_ERROR);
            if (v26)
            {
              int v148 = *((_DWORD *)this + 538);
              *(_DWORD *)unint64_t v171 = 67109376;
              *(_DWORD *)&v171[4] = v14;
              *(_WORD *)&v171[8] = 1024;
              *(_DWORD *)&v171[10] = v148;
              _os_log_error_impl(&dword_228C70000, v99, OS_LOG_TYPE_ERROR, "Mismatched AppId, received 0x%X expecting 0x%X", v171, 0xEu);
            }
            unsigned int v41 = 3;
            goto LABEL_179;
          }
          *(_DWORD *)unint64_t v171 = 0;
          uint64_t v15 = re::BitReader::readUInt32Bits(&v157, 0x20u, (unsigned int *)v171);
          int v16 = *(_DWORD *)v171;
          if (*((_DWORD *)this + 539) == *(_DWORD *)v171)
          {
            __int16 v17 = re::BitReader::readUInt64((re::BitReader *)&v157, &v164);
            unint64_t v18 = v164;
            if (*((void *)this + 270) == v164)
            {
              UInt64 = re::BitReader::readUInt64((re::BitReader *)&v157, (unint64_t *)buf);
              __int16 v20 = *re::networkLogObjects((re *)UInt64);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)unint64_t v171 = 134217984;
                *(void *)&v171[4] = *(void *)buf;
              }
              *(_DWORD *)unint64_t v171 = 0;
              re::BitReader::readUInt32Bits(&v157, 0x20u, (unsigned int *)v171);
              int v21 = *(_DWORD *)v171;
              *(_DWORD *)unint64_t v171 = 0;
              uint64_t v22 = re::BitReader::readUInt32Bits(&v157, 0x20u, (unsigned int *)v171);
              if (v159
                || (uint64_t v23 = *(unsigned int *)v171, v24 = v160, v158 - v160 < *(_DWORD *)v171))
              {
                char v91 = *re::networkLogObjects((re *)v22);
                uint64_t v26 = os_log_type_enabled(v91, OS_LOG_TYPE_ERROR);
                if (v26)
                {
                  re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
                  long long v92 = &v171[9];
                  if (v171[8]) {
                    long long v92 = *(uint8_t **)&v171[16];
                  }
                  *(_DWORD *)v166 = 136315138;
                  *(void *)&v166[4] = v92;
                  __int16 v93 = v91;
                  uint64_t v94 = "Cannot read discovery data. Hello message from %s is corrupt.";
                  goto LABEL_175;
                }
              }
              else
              {
                uint64_t v25 = v157;
                uint64_t v161 = 0;
                uint64_t v160 = (v160 + *(_DWORD *)v171);
                BOOL v159 = (int)v24 + *(_DWORD *)v171 > v158;
                *(_DWORD *)unint64_t v171 = 0;
                uint64_t v26 = (uint64_t)re::BitReader::readUInt32Bits(&v157, 0x20u, (unsigned int *)v171);
                if (v159)
                {
                  unsigned int v106 = *re::networkLogObjects((re *)v26);
                  uint64_t v26 = os_log_type_enabled(v106, OS_LOG_TYPE_ERROR);
                  if (v26)
                  {
                    re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
                    uint64_t v107 = &v171[9];
                    if (v171[8]) {
                      uint64_t v107 = *(uint8_t **)&v171[16];
                    }
                    *(_DWORD *)v166 = 136315138;
                    *(void *)&v166[4] = v107;
                    __int16 v93 = v106;
                    uint64_t v94 = "Hello message received from %s is corrupt.";
                    goto LABEL_175;
                  }
                }
                else
                {
                  unint64_t v27 = *(unsigned int *)v171;
                  if (*(_DWORD *)v171 > 0x400000u)
                  {
                    uint32_t v108 = *re::networkLogObjects((re *)v26);
                    uint64_t v26 = os_log_type_enabled(v108, OS_LOG_TYPE_ERROR);
                    if (v26)
                    {
                      *(_DWORD *)unint64_t v171 = 67109376;
                      *(_DWORD *)&v171[4] = v27;
                      *(_WORD *)&v171[8] = 2048;
                      *(void *)&v171[10] = 0x400000;
                      _os_log_error_impl(&dword_228C70000, v108, OS_LOG_TYPE_ERROR, "User context is bigger than maximum allowed (%u > %zu)", v171, 0x12u);
                    }
                    goto LABEL_178;
                  }
                  uint64_t v28 = *((void *)this + 395);
                  if (v28)
                  {
                    uint64_t v29 = v25 + v24;
                    uint64_t v30 = *((void *)this + 397) + 40;
                    uint64_t v31 = 80 * v28;
                    while (*(void *)(v30 - 40) != a2)
                    {
                      v30 += 80;
                      v31 -= 80;
                      if (!v31) {
                        goto LABEL_25;
                      }
                    }
                    *(void *)(v30 - 32) = *(void *)buf;
                    *(_DWORD *)(v30 - 16) = v21;
                    if (!v27) {
                      goto LABEL_90;
                    }
                    re::DynamicArray<unsigned char>::resize(v30, v27);
                    if (!v159)
                    {
                      int v79 = v160;
                      if (v158 - v160 >= v27)
                      {
                        unsigned __int16 v80 = *(void **)(v30 + 32);
                        HIDWORD(v160) = 0;
                        uint64_t v161 = 0;
                        uint64_t v26 = (uint64_t)memcpy(v80, (const void *)(v157 + v160), v27);
                        LODWORD(v160) = v79 + v27;
LABEL_90:
                        if ((v21 & 2) != 0 && (!*((unsigned char *)this + 2219) || !*(void *)(v30 - 24)))
                        {
                          unsigned int v41 = 15;
                          goto LABEL_179;
                        }
                        uint64_t v81 = *((void *)this + 276);
                        if (v81)
                        {
                          if (!*(void *)(v30 - 24))
                          {
                            re::Transport::connectionAddress(v155, *(void *)(v30 - 40), (re::DynamicString *)v171);
                            (*(void (**)(uint64_t, uint8_t *, uint64_t, uint64_t))(*(void *)v81 + 72))(v81, v171, v29, v23);
                            uint64_t v26 = *(void *)v171;
                            if (*(void *)v171)
                            {
                              if (v171[8]) {
                                uint64_t v26 = (*(uint64_t (**)(void))(**(void **)v171 + 40))();
                              }
                            }
                          }
                        }
                        char v37 = 1;
                        if ((v21 & 1) == 0) {
                          goto LABEL_98;
                        }
                        goto LABEL_96;
                      }
                      BOOL v159 = 1;
                      uint64_t v160 = v158;
                    }
                    int v111 = *re::networkLogObjects(v78);
                    uint64_t v26 = os_log_type_enabled(v111, OS_LOG_TYPE_ERROR);
                    if (v26)
                    {
                      re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
                      uint64_t v112 = &v171[9];
                      if (v171[8]) {
                        uint64_t v112 = *(uint8_t **)&v171[16];
                      }
                      *(_DWORD *)v166 = 136315138;
                      *(void *)&v166[4] = v112;
                      __int16 v93 = v111;
                      uint64_t v94 = "User context data received from %s is corrupt.";
                      goto LABEL_175;
                    }
                  }
                  else
                  {
LABEL_25:
                    uint64_t v32 = *((void *)this + 287);
                    if (!v32)
                    {
LABEL_29:
                      char v37 = 0;
                      if ((v21 & 1) == 0) {
                        goto LABEL_98;
                      }
LABEL_96:
                      if (!*((void *)this + 392))
                      {
                        uint64_t v26 = (*(uint64_t (**)(void, void))(**((void **)this + 928) + 56))(*((void *)this + 928), *(void *)buf);
LABEL_98:
                        if (v37)
                        {
                          int v82 = *((_DWORD *)this + 816);
                          if (v82 == 2)
                          {
                            re::Session::stateEvent((BOOL)this, 3);
                          }
                          else if (v82 == 1)
                          {
                            uint64_t v83 = re::Session::peerID(this);
                            re::Session::assignLocalPeerID(this, v83);
                            re::Session::stateSet((int *)this, 2);
                          }
                          goto LABEL_106;
                        }
                        long long v109 = *re::networkLogObjects((re *)v26);
                        uint64_t v26 = os_log_type_enabled(v109, OS_LOG_TYPE_ERROR);
                        if (v26)
                        {
                          uint64_t v150 = *(void *)buf;
                          re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
                          BOOL v151 = &v171[9];
                          if (v171[8]) {
                            BOOL v151 = *(uint8_t **)&v171[16];
                          }
                          *(_DWORD *)v166 = 134218242;
                          *(void *)&v166[4] = v150;
                          *(_WORD *)&v166[12] = 2080;
                          *(void *)&v166[14] = v151;
                          _os_log_error_impl(&dword_228C70000, v109, OS_LOG_TYPE_ERROR, "Cannot bind peerID %llu with connection for peer %s", v166, 0x16u);
                          uint64_t v26 = *(void *)v171;
                          if (*(void *)v171 && (v171[8] & 1) != 0) {
                            uint64_t v26 = (*(uint64_t (**)(void))(**(void **)v171 + 40))();
                          }
                        }
                        unsigned int v41 = 7;
                        goto LABEL_179;
                      }
                      uint64_t v110 = *re::networkLogObjects((re *)v26);
                      uint64_t v26 = os_log_type_enabled(v110, OS_LOG_TYPE_ERROR);
                      if (v26)
                      {
                        uint64_t v152 = *((void *)this + 392);
                        *(_DWORD *)unint64_t v171 = 134218240;
                        *(void *)&v171[4] = v152;
                        *(_WORD *)&v171[12] = 2048;
                        *(void *)&v171[14] = *(void *)buf;
                        _os_log_error_impl(&dword_228C70000, v110, OS_LOG_TYPE_ERROR, "Two nodes claim to be session leaders (%llu and %llu)", v171, 0x16u);
                      }
                      unsigned int v41 = 5;
LABEL_179:
                      v115 = *re::networkLogObjects((re *)v26);
                      BOOL v43 = os_log_type_enabled(v115, OS_LOG_TYPE_ERROR);
                      if (v43)
                      {
                        *(_WORD *)unint64_t v171 = 0;
                        _os_log_error_impl(&dword_228C70000, v115, OS_LOG_TYPE_ERROR, "Error receiving message of type kPeerHello", v171, 2u);
                      }
                      goto LABEL_181;
                    }
                    uint64_t v33 = *(void *)buf;
                    __int16 v34 = (uint64_t *)*((void *)this + 289);
                    uint64_t v35 = 8 * v32;
                    while (1)
                    {
                      uint64_t v36 = *v34;
                      if (*(void *)(*v34 + 24) == *(void *)buf) {
                        break;
                      }
                      ++v34;
                      v35 -= 8;
                      if (!v35) {
                        goto LABEL_29;
                      }
                    }
                    long long v84 = (void *)(v36 + 8);
                    id v85 = (id)(v36 + 8);

                    uint64_t v87 = *re::networkLogObjects(v86);
                    BOOL v88 = os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG);
                    if (v88)
                    {
                      *(_DWORD *)unint64_t v171 = 134217984;
                      *(void *)&v171[4] = v33;
                      if (!v27) {
                        goto LABEL_106;
                      }
                    }
                    else if (!v27)
                    {
                      goto LABEL_106;
                    }
                    uint64_t v161 = 0;
                    uint64_t v160 = (v160 + v27);
                    if (v160 <= v158) {
                      goto LABEL_106;
                    }
                    BOOL v159 = 1;
                    uint64_t v113 = *re::networkLogObjects((re *)v88);
                    uint64_t v26 = os_log_type_enabled(v113, OS_LOG_TYPE_ERROR);
                    if (v26)
                    {
                      re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
                      uint64_t v114 = &v171[9];
                      if (v171[8]) {
                        uint64_t v114 = *(uint8_t **)&v171[16];
                      }
                      *(_DWORD *)v166 = 136315138;
                      *(void *)&v166[4] = v114;
                      __int16 v93 = v113;
                      uint64_t v94 = "User context data received from %s for existing participant is corrupt.";
LABEL_175:
                      _os_log_error_impl(&dword_228C70000, v93, OS_LOG_TYPE_ERROR, v94, v166, 0xCu);
                      uint64_t v26 = *(void *)v171;
                      if (*(void *)v171 && (v171[8] & 1) != 0) {
                        uint64_t v26 = (*(uint64_t (**)(void))(**(void **)v171 + 40))();
                      }
                    }
                  }
                }
              }
LABEL_178:
              unsigned int v41 = 6;
              goto LABEL_179;
            }
            int v105 = *re::networkLogObjects((re *)v17);
            uint64_t v26 = os_log_type_enabled(v105, OS_LOG_TYPE_ERROR);
            if (!v26)
            {
LABEL_153:
              unsigned int v41 = 4;
              goto LABEL_179;
            }
            uint64_t v149 = *((void *)this + 270);
            *(_DWORD *)unint64_t v171 = 134218240;
            *(void *)&v171[4] = v18;
            *(_WORD *)&v171[12] = 2048;
            *(void *)&v171[14] = v149;
            unsigned int v102 = v105;
            uint64_t v103 = "Mismatched component schema, received 0x%llX expecting 0x%llX";
            uint32_t v104 = 22;
          }
          else
          {
            unsigned int v100 = *re::networkLogObjects((re *)v15);
            uint64_t v26 = os_log_type_enabled(v100, OS_LOG_TYPE_ERROR);
            if (!v26) {
              goto LABEL_153;
            }
            int v101 = *((_DWORD *)this + 539);
            *(_DWORD *)unint64_t v171 = 67109376;
            *(_DWORD *)&v171[4] = v16;
            *(_WORD *)&v171[8] = 1024;
            *(_DWORD *)&v171[10] = v101;
            unsigned int v102 = v100;
            uint64_t v103 = "Mismatched protocol, received 0x%X expecting 0x%X";
            uint32_t v104 = 14;
          }
          _os_log_error_impl(&dword_228C70000, v102, OS_LOG_TYPE_ERROR, v103, v171, v104);
          goto LABEL_153;
        }
        uint64_t v96 = *re::networkLogObjects(v12);
        BOOL v43 = os_log_type_enabled(v96, OS_LOG_TYPE_ERROR);
        if (v43)
        {
          *(_WORD *)unint64_t v171 = 0;
          _os_log_error_impl(&dword_228C70000, v96, OS_LOG_TYPE_ERROR, "Error receiving message of type kPeerHello: invalid peerid", v171, 2u);
        }
        unsigned int v41 = 8;
LABEL_181:
        uint64_t v116 = *re::networkLogObjects((re *)v43);
        if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)unint64_t v171 = 67109120;
          *(_DWORD *)&v171[4] = v41;
          _os_log_error_impl(&dword_228C70000, v116, OS_LOG_TYPE_ERROR, "Aborting transport receive due to packet error: %d", v171, 8u);
        }
        goto LABEL_183;
      case 3u:
        uint64_t v38 = *re::networkLogObjects((re *)v7);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        {
          re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
          int v90 = &v171[9];
          if (v171[8]) {
            int v90 = *(uint8_t **)&v171[16];
          }
          *(_DWORD *)v166 = 136315138;
          *(void *)&v166[4] = v90;
          _os_log_debug_impl(&dword_228C70000, v38, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kSessionError from %s", v166, 0xCu);
          if (*(void *)v171 && (v171[8] & 1) != 0) {
            (*(void (**)(void))(**(void **)v171 + 40))();
          }
        }
        *(_DWORD *)unint64_t v171 = 0;
        long long v39 = re::BitReader::readUInt32Bits(&v157, 0x20u, (unsigned int *)v171);
        int v40 = *(_DWORD *)v171;
        if (*(_DWORD *)v171 >= 0x11u) {
          unsigned int v41 = 6;
        }
        else {
          unsigned int v41 = *(_DWORD *)v171;
        }
        uint64_t v42 = *re::networkLogObjects((re *)v39);
        BOOL v43 = os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
        if (v43)
        {
          *(_DWORD *)unint64_t v171 = 134218240;
          *(void *)&v171[4] = a2;
          *(_WORD *)&v171[12] = 1024;
          *(_DWORD *)&v171[14] = v40;
          _os_log_error_impl(&dword_228C70000, v42, OS_LOG_TYPE_ERROR, "Connection error received from ConnectionId(%llu) Error = 0x%X", v171, 0x12u);
        }
        if (v41 != 1) {
          goto LABEL_181;
        }
        BOOL v44 = v159;
        goto LABEL_107;
      case 4u:
        uint64_t v45 = *re::networkLogObjects((re *)v7);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)unint64_t v171 = 0;
          _os_log_debug_impl(&dword_228C70000, v45, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kRouteRequest", v171, 2u);
        }
        *(_DWORD *)unint64_t v171 = 0;
        unint64_t v46 = re::BitReader::readUInt32Bits(&v157, 0x20u, (unsigned int *)v171);
        if (v159)
        {
          uint64_t v97 = *re::networkLogObjects((re *)v46);
          if (!os_log_type_enabled(v97, OS_LOG_TYPE_ERROR)) {
            goto LABEL_145;
          }
          re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
          int v98 = &v171[9];
          if (v171[8]) {
            int v98 = *(uint8_t **)&v171[16];
          }
          goto LABEL_232;
        }
        unsigned int v47 = *(_DWORD *)v171;
        *(void *)v166 = (char *)this + 2320;
        *(void *)&v166[8] = a2;
        *(_DWORD *)&v166[16] = *(_DWORD *)v171;
        re::RoutingTable::addRoute(*((void *)this + 380), v10, (long long *)v166);
        re::RoutingTable::getRoute(*((re::RoutingTable **)this + 380), v9, (uint64_t)v171);
        if (v171[0])
        {
          unsigned int v48 = *(_DWORD *)&v171[24] + 1;
          BOOL v49 = (re::Session *)*((void *)this + 380);
          uint64_t v50 = v9;
          uint64_t v51 = v10;
LABEL_81:
          re::Session::sendRouteResponse(v49, v50, v51, v48);
        }
        else if (v47 <= 1)
        {
          re::Session::broadcastRouteRequest((BOOL)this, a2, v10, v9, v47 + 1);
        }
        goto LABEL_106;
      case 5u:
        int v52 = *re::networkLogObjects((re *)v7);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)unint64_t v171 = 0;
          _os_log_debug_impl(&dword_228C70000, v52, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kRouteResponse", v171, 2u);
        }
        *(_DWORD *)unint64_t v171 = 0;
        BOOL v53 = re::BitReader::readUInt32Bits(&v157, 0x20u, (unsigned int *)v171);
        if (v159)
        {
          uint64_t v97 = *re::networkLogObjects((re *)v53);
          if (!os_log_type_enabled(v97, OS_LOG_TYPE_ERROR)) {
            goto LABEL_145;
          }
          re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
          int v98 = &v171[9];
          if (v171[8]) {
            int v98 = *(uint8_t **)&v171[16];
          }
          goto LABEL_232;
        }
        unsigned int v54 = *(_DWORD *)v171;
        *(void *)v166 = (char *)this + 2320;
        *(void *)&v166[8] = a2;
        *(_DWORD *)&v166[16] = *(_DWORD *)v171;
        re::RoutingTable::addRoute(*((void *)this + 380), v10, (long long *)v166);
        *(void *)unint64_t v171 = v9;
        *(void *)&v171[8] = v10;
        re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::remove((uint64_t)v154, v171);
        if (re::Session::peerID(this) == v9)
        {
          unint64_t v55 = *((void *)this + 383);
          if (v55)
          {
            unint64_t v56 = 0;
            do
            {
              uint64_t v57 = *((void *)this + 385);
              uint64_t v58 = v57 + 40 * v56;
              if (*(void *)(v58 + 8) == v10)
              {
                Route = re::RoutingTable::getRoute(*((re::RoutingTable **)this + 380), v10, (uint64_t)v171);
                uint64_t v60 = *(void *)(*(void *)&v171[8] + 600);
                if (v60)
                {
                  uint64_t v61 = *(void *)(v60 + 2296);
                  if (v61)
                  {
                    unint64_t v62 = *(uint64_t **)(v60 + 2312);
                    uint64_t v63 = 8 * v61;
                    while (1)
                    {
                      uint64_t v64 = *v62;
                      if (*(void *)(*v62 + 32) == *(void *)&v171[16]) {
                        break;
                      }
                      ++v62;
                      v63 -= 8;
                      if (!v63) {
                        goto LABEL_56;
                      }
                    }
                    id v67 = (id)(v64 + 8);
                    unint64_t v69 = PacketUtils::move(*(PacketUtils **)v58, (re::PacketPool **)v155, *(re::PacketPool ***)&v171[8], v68);
                    re::Transport::send(*(uint64_t *)&v171[8], *(unint64_t *)&v171[16], (unint64_t)v69, *(unsigned __int8 *)(v57 + 40 * v56 + 16), 0, *(unsigned __int8 *)(v57 + 40 * v56 + 32), *(_DWORD *)(v64 + 72));
                    re::DynamicArray<re::Session::PendingMessage>::removeStableAt(v156, v56);
                  }
                  else
                  {
LABEL_56:
                    uint64_t v65 = *re::networkLogObjects((re *)Route);
                    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)sockaddr buf = 0;
                      _os_log_error_impl(&dword_228C70000, v65, OS_LOG_TYPE_ERROR, "receiveRouteResponse: missing participant for connection!", buf, 2u);
                    }
                    re::PacketPool::free(*((re::PacketPool **)this + 338), *(re::Packet **)v58);
                    re::DynamicArray<re::Session::PendingMessage>::removeStableAt(v156, v56);
                  }
                }
                else
                {
                  unsigned int v66 = *re::networkLogObjects((re *)Route);
                  if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)sockaddr buf = 0;
                    _os_log_error_impl(&dword_228C70000, v66, OS_LOG_TYPE_ERROR, "receiveRouteResponse: missing session for transport!", buf, 2u);
                  }
                }
                unint64_t v55 = *((void *)this + 383);
              }
              else
              {
                ++v56;
              }
            }
            while (v56 < v55);
          }
          goto LABEL_106;
        }
        if (v54 > 2) {
          goto LABEL_106;
        }
        unsigned int v48 = v54 + 1;
        BOOL v49 = (re::Session *)*((void *)this + 380);
        uint64_t v50 = v10;
        uint64_t v51 = v9;
        goto LABEL_81;
      case 6u:
        BOOL v70 = *re::networkLogObjects((re *)v7);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)unint64_t v171 = 0;
          _os_log_debug_impl(&dword_228C70000, v70, OS_LOG_TYPE_DEBUG, "Received SessionMessages::kRouteFail", v171, 2u);
        }
        *(_DWORD *)unint64_t v171 = 0;
        int v71 = re::BitReader::readUInt32Bits(&v157, 0x20u, (unsigned int *)v171);
        if (!v159)
        {
          unsigned int v72 = *(_DWORD *)v171;
          *(void *)unint64_t v171 = v10;
          *(void *)&v171[8] = v9;
          re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::remove((uint64_t)v154, v171);
          int v73 = (re *)re::Session::peerID(this);
          if (v73 == (re *)v9)
          {
            int v74 = *re::networkLogObjects(v73);
            if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unint64_t v171 = 134217984;
              *(void *)&v171[4] = v9;
              _os_log_impl(&dword_228C70000, v74, OS_LOG_TYPE_DEFAULT, "Received route failure for PeerID. (%llu)", v171, 0xCu);
            }
            re::RoutingTable::removeRouteForPeerID(*((re::RoutingTable **)this + 380), v10);
            unint64_t v75 = *((void *)this + 383);
            if (v75)
            {
              unint64_t v76 = 0;
              do
              {
                uint64_t v77 = *((void *)this + 385);
                if (*(void *)(v77 + 40 * v76 + 8) == v10)
                {
                  re::PacketPool::free(*((re::PacketPool **)this + 338), *(re::Packet **)(v77 + 40 * v76));
                  re::DynamicArray<re::Session::PendingMessage>::removeStableAt(v156, v76);
                  unint64_t v75 = *((void *)this + 383);
                }
                else
                {
                  ++v76;
                }
              }
              while (v76 < v75);
            }
            re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 1528, (uint64_t)this);
          }
          else if (v72 <= 2)
          {
            re::Session::sendRouteFail(*((re::Session **)this + 380), v10, v9, v72 + 1);
          }
LABEL_106:
          BOOL v44 = 0;
LABEL_107:
          if (v158 == v160 || v44) {
            goto LABEL_145;
          }
          continue;
        }
        uint64_t v97 = *re::networkLogObjects((re *)v71);
        if (!os_log_type_enabled(v97, OS_LOG_TYPE_ERROR)) {
          goto LABEL_145;
        }
        re::Transport::connectionAddress(v155, a2, (re::DynamicString *)v171);
        int v98 = &v171[9];
        if (v171[8]) {
          int v98 = *(uint8_t **)&v171[16];
        }
LABEL_232:
        *(_DWORD *)v166 = 136315138;
        *(void *)&v166[4] = v98;
        _os_log_error_impl(&dword_228C70000, v97, OS_LOG_TYPE_ERROR, "No hop specified in route request from %s", v166, 0xCu);
        if (*(void *)v171 && (v171[8] & 1) != 0) {
          (*(void (**)(void))(**(void **)v171 + 40))();
        }
LABEL_145:
        uint64_t v5 = v162;
LABEL_146:
        re::PacketPool::free(*((re::PacketPool **)this + 338), v5);
LABEL_223:
        if (re::Transport::receive((uint64_t)v155, a2, 0, (uint64_t *)&v162)) {
          goto LABEL_6;
        }
        return;
      default:
        uint64_t v95 = *re::networkLogObjects((re *)v7);
        BOOL v43 = os_log_type_enabled(v95, OS_LOG_TYPE_ERROR);
        if (v43)
        {
          *(_DWORD *)unint64_t v171 = 67109120;
          *(_DWORD *)&v171[4] = v8;
          _os_log_error_impl(&dword_228C70000, v95, OS_LOG_TYPE_ERROR, "Received unrecognized message type: %d", v171, 8u);
        }
        unsigned int v41 = 9;
        goto LABEL_181;
    }
  }
}

void re::Session::beforeFrameUpdate(re::Session *this)
{
  uint64_t v108 = *MEMORY[0x263EF8340];
  if (*((_DWORD *)this + 816) == 3) {
    return;
  }
  uint64_t v1 = this;
  re::Session::stateEvent((BOOL)this, 2);
  (*(void (**)(void))(**((void **)v1 + 940) + 48))(*((void *)v1 + 940));
  (*(void (**)(void))(**((void **)v1 + 928) + 64))(*((void *)v1 + 928));
  uint64_t v2 = (re::PacketPool **)((char *)v1 + 2320);
  re::Transport::flushNetworkEvents((re::Session *)((char *)v1 + 2320));
  if (*((void *)v1 + 299))
  {
    re::TransportCommandsQueued::update((re::Session *)((char *)v1 + 7528));
    uint64_t v3 = (re *)(*(uint64_t (**)(void))(**((void **)v1 + 330) + 24))(*((void *)v1 + 330));
    if (*((_DWORD *)v1 + 758) != 1)
    {
      uint64_t v4 = *re::networkLogObjects(v3);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *((_DWORD *)v1 + 758);
        *(_DWORD *)sockaddr buf = 134218240;
        *(void *)&uint8_t buf[4] = v1;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v5;
        _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Stopping Session (%p) with error:%d after flushing transport events", buf, 0x12u);
      }
      re::Session::stopSession((uint64_t)v1, *((_DWORD *)v1 + 758));
    }
  }
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v81, 6032, (uint64_t)v1);
  uint64_t v6 = *((void *)v1 + 405);
  unint64_t v76 = (re::Session *)((char *)v1 + 2320);
  if (!v6) {
    goto LABEL_110;
  }
  uint64_t v7 = (unint64_t *)*((void *)v1 + 407);
  int v71 = &v7[v6];
  unint64_t v75 = (void *)((char *)v1 + 472);
  while (1)
  {
    int v73 = v7;
    unint64_t v8 = *v7;
    uint64_t v9 = *((void *)v1 + 287);
    if (v9)
    {
      unint64_t v10 = (uint64_t *)*((void *)v1 + 289);
      uint64_t v11 = 8 * v9;
      while (1)
      {
        uint64_t v12 = *v10;
        if (*(void *)(*v10 + 32) == v8) {
          break;
        }
        ++v10;
        v11 -= 8;
        if (!v11) {
          goto LABEL_14;
        }
      }
      id v16 = (id)(v12 + 8);
      re::Session::processIncomingMessages(v1, v8);
    }
    else
    {
      uint64_t v13 = *((void *)v1 + 395);
      if (!v13) {
        goto LABEL_24;
      }
LABEL_14:
      int v14 = (void *)*((void *)v1 + 397);
      uint64_t v15 = 80 * v13;
      while (*v14 != v8)
      {
        v14 += 10;
        v15 -= 80;
        if (!v15) {
          goto LABEL_24;
        }
      }
      re::Session::processIncomingMessages(v1, *v7);
      uint64_t v17 = *((void *)v1 + 287);
      if (v17)
      {
        unint64_t v18 = (uint64_t *)*((void *)v1 + 289);
        uint64_t v19 = 8 * v17;
        while (1)
        {
          uint64_t v12 = *v18;
          if (*(void *)(*v18 + 32) == v8) {
            break;
          }
          ++v18;
          v19 -= 8;
          if (!v19) {
            goto LABEL_24;
          }
        }
        id v60 = (id)(v12 + 8);
      }
      else
      {
LABEL_24:
        uint64_t v12 = 0;
      }
    }
    if (*((_DWORD *)v1 + 816) == 3) {
      goto LABEL_107;
    }
    if (v12) {
      break;
    }
LABEL_103:
    if (++v7 == v71) {
      goto LABEL_109;
    }
  }
  __int16 v20 = (_DWORD *)re::DataArray<re::Connection>::tryGet((uint64_t)v1 + 2440, *(void *)(v12 + 32));
  if (!v20 || *v20 != 1)
  {
LABEL_101:
    if (*((_DWORD *)v1 + 816) == 3) {
      goto LABEL_108;
    }

    goto LABEL_103;
  }
  int v90 = 0;
  uint64_t v72 = v12 + 49;
  uint64_t v21 = 3;
  uint64_t v74 = v12;
  while (!re::Transport::receive((uint64_t)v2, *(void *)(v12 + 32), v21, (uint64_t *)&v90))
  {
LABEL_99:
    if (++v21 == 10)
    {
      uint64_t v7 = v73;
      goto LABEL_101;
    }
  }
  uint64_t v22 = (char *)v1 + 88 * v21;
  uint64_t v23 = (_anonymous_namespace_ *)(v22 + 560);
  uint64_t v77 = (int *)(v22 + 640);
  uint64_t v78 = v21;
  int v79 = v22 + 632;
  unsigned __int16 v80 = (unint64_t *)(v22 + 616);
  while (2)
  {
    int v24 = *((_DWORD *)v90 + 6);
    uint64_t v85 = *((void *)v90 + 2);
    int v86 = v24;
    char v87 = 0;
    uint64_t v88 = 0;
    uint64_t v89 = 0;
    RoutingHeader = re::Session::readRoutingHeader((re::Session *)v82, (re::BitReader *)&v85);
    if (!v82[0])
    {
      unsigned int v54 = *re::networkLogObjects((re *)RoutingHeader);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        uint64_t v58 = v72;
        if (*(void *)(v12 + 48)) {
          uint64_t v58 = *(void *)(v12 + 56);
        }
        *(_DWORD *)sockaddr buf = 136315138;
        *(void *)&uint8_t buf[4] = v58;
        _os_log_error_impl(&dword_228C70000, v54, OS_LOG_TYPE_ERROR, "Received corrupt message from '%s'. No routing header. Disconnecting.", buf, 0xCu);
      }
      re::PacketPool::free(*((re::PacketPool **)v1 + 338), v90);
LABEL_91:
      if (!re::Transport::receive((uint64_t)v2, *(void *)(v12 + 32), v21, (uint64_t *)&v90)) {
        goto LABEL_99;
      }
      continue;
    }
    break;
  }
  uint64_t v27 = v83;
  uint64_t v26 = v84;
  if (v26 != re::Session::peerID(v1))
  {
    Route = re::RoutingTable::getRoute(*((re::RoutingTable **)v1 + 380), v26, (uint64_t)buf);
    if (buf[0])
    {
      int v90 = (re::Packet *)PacketUtils::move(v90, v2, *(re::PacketPool ***)&buf[8], v56);
      uint64_t v21 = v78;
      re::Transport::send(*(uint64_t *)&buf[8], *(unint64_t *)&buf[16], (unint64_t)v90, v78, 0, 0, *(_DWORD *)(v12 + 72));
    }
    else
    {
      uint64_t v57 = *re::networkLogObjects((re *)Route);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        uint64_t v59 = v72;
        if (*(void *)(v12 + 48)) {
          uint64_t v59 = *(void *)(v12 + 56);
        }
        *(_DWORD *)uint64_t v96 = 136315650;
        *(void *)&v96[4] = v59;
        *(_WORD *)&v96[12] = 2048;
        *(void *)&v96[14] = v27;
        *(_WORD *)&v96[22] = 2048;
        *(void *)&v96[24] = v26;
        _os_log_error_impl(&dword_228C70000, v57, OS_LOG_TYPE_ERROR, "Received message with unknown route from '%s'. No route exists %llu->%llu.", v96, 0x20u);
      }
      re::PacketPool::free(*((re::PacketPool **)v1 + 338), v90);
      re::Session::sendRouteFail(*((re::Session **)v1 + 380), v26, v27, 1u);
      uint64_t v21 = v78;
    }
    goto LABEL_91;
  }
  if (v87) {
    uint64_t v28 = 0;
  }
  else {
    uint64_t v28 = v85 + v88;
  }
  int v29 = v86 - v88;
  char v91 = v78;
  uint64_t v93 = v28;
  uint64_t v94 = v27;
  int v92 = v86 - v88;
  int v30 = (*v77)++;
  if (*((void *)v23 + 2))
  {
    unint64_t v31 = 0;
    do
    {
      if ((*(unsigned int (**)(re::Session *))(*((void *)v23 + 4) + 32 * v31 + 24))(v1) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v23, v31);
      }
      else {
        ++v31;
      }
    }
    while (v31 < *((void *)v23 + 2));
    int v30 = *v77 - 1;
  }
  *uint64_t v77 = v30;
  if (v30 || (unint64_t v32 = *v80) == 0)
  {
LABEL_54:
    uint64_t v21 = v78;
    uint64_t v2 = (re::PacketPool **)((char *)v1 + 2320);
    if (v78 == 3)
    {
      uint64_t v93 = v28;
      uint64_t v94 = v27;
      int v92 = v29;
      int v38 = *((_DWORD *)v1 + 138);
      *((_DWORD *)v1 + 138) = v38 + 1;
      if (*((void *)v1 + 61))
      {
        unint64_t v39 = 0;
        do
        {
          if ((*(unsigned int (**)(re::Session *))(*((void *)v1 + 63) + 32 * v39 + 24))(v1) == 1) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v75, v39);
          }
          else {
            ++v39;
          }
        }
        while (v39 < *((void *)v1 + 61));
        int v38 = *((_DWORD *)v1 + 138) - 1;
      }
      *((_DWORD *)v1 + 138) = v38;
      if (!v38)
      {
        unint64_t v40 = *((void *)v1 + 66);
        if (v40)
        {
          uint64_t v41 = 0;
          unint64_t v42 = 0;
          while (1)
          {
            unint64_t v43 = *((void *)v1 + 66);
            if (v43 <= v42) {
              break;
            }
            uint64_t v44 = *((void *)v1 + 68) + v41;
            *(_OWORD *)uint64_t v96 = *(_OWORD *)v44;
            *(_OWORD *)&v96[16] = *(_OWORD *)(v44 + 16);
            *(void *)&v96[32] = *(void *)(v44 + 32);
            if (v96[0])
            {
              uint64_t v45 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf((uint64_t)buf, *((void *)v1 + 61), *((char **)v1 + 63), &v96[8]);
              if (!buf[0])
              {
                unint64_t v46 = *((void *)v1 + 60);
                unint64_t v47 = *((void *)v1 + 61);
                if (v47 >= v46)
                {
                  unint64_t v48 = v47 + 1;
                  if (v46 < v47 + 1)
                  {
                    if (*v75)
                    {
                      uint64_t v49 = 2 * v46;
                      BOOL v50 = v46 == 0;
                      unint64_t v51 = 8;
                      if (!v50) {
                        unint64_t v51 = v49;
                      }
                      if (v51 <= v48) {
                        unint64_t v52 = v48;
                      }
                      else {
                        unint64_t v52 = v51;
                      }
                      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(v75, v52);
                    }
                    else
                    {
                      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(v75, v48);
                      ++*((_DWORD *)v1 + 124);
                    }
                  }
                  unint64_t v47 = *((void *)v1 + 61);
                }
                BOOL v53 = (_OWORD *)(*((void *)v1 + 63) + 32 * v47);
                _OWORD *v53 = *(_OWORD *)&v96[8];
                v53[1] = *(_OWORD *)&v96[24];
                ++*((void *)v1 + 61);
                ++*((_DWORD *)v1 + 124);
              }
            }
            else
            {
              re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf((uint64_t)buf, *((void *)v1 + 61), *((char **)v1 + 63), &v96[8]);
              if (buf[0]) {
                re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v75, *(unint64_t *)&buf[8]);
              }
            }
            ++v42;
            v41 += 40;
            if (v40 == v42) {
              goto LABEL_83;
            }
          }
          uint64_t v95 = 0;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v105 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v97 = 136315906;
          *(void *)&v97[4] = "operator[]";
          __int16 v98 = 1024;
          int v99 = 789;
          __int16 v100 = 2048;
          unint64_t v101 = v42;
          __int16 v102 = 2048;
          unint64_t v103 = v43;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_126:
          *(void *)uint64_t v97 = 0;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v105 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v96 = 136315906;
          *(void *)&v96[4] = "operator[]";
          *(_WORD *)&v96[12] = 1024;
          *(_DWORD *)&v96[14] = 789;
          *(_WORD *)&v96[18] = 2048;
          *(void *)&v96[20] = v40;
          *(_WORD *)&v96[28] = 2048;
          *(void *)&v96[30] = v42;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
LABEL_83:
      uint64_t v21 = 3;
    }
    re::PacketPool::free(*((re::PacketPool **)v1 + 338), v90);
    uint64_t v12 = v74;
    goto LABEL_91;
  }
  uint64_t v12 = 0;
  unint64_t v33 = 0;
  while (1)
  {
    unint64_t v34 = *v80;
    if (*v80 <= v33) {
      break;
    }
    uint64_t v35 = *v79 + v12;
    uint64_t v36 = *(void *)(v35 + 32);
    long long v37 = *(_OWORD *)(v35 + 16);
    *(_OWORD *)uint64_t v96 = *(_OWORD *)v35;
    *(_OWORD *)&v96[16] = v37;
    *(void *)&v96[32] = v36;
    if (v96[0])
    {
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v23, &v96[8], (uint64_t)buf);
      if (!buf[0]) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v23, (uint64_t)&v96[8]);
      }
    }
    else
    {
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v23, &v96[8], (uint64_t)buf);
      if (buf[0]) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v23, *(unint64_t *)&buf[8]);
      }
    }
    ++v33;
    v12 += 40;
    if (v32 == v33) {
      goto LABEL_54;
    }
  }
  uint64_t v95 = 0;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v105 = 0u;
  memset(buf, 0, sizeof(buf));
  uint64_t v1 = (re::Session *)&_os_log_internal;
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  *(_DWORD *)uint64_t v97 = 136315906;
  *(void *)&v97[4] = "operator[]";
  __int16 v98 = 1024;
  int v99 = 789;
  __int16 v100 = 2048;
  unint64_t v101 = v33;
  __int16 v102 = 2048;
  unint64_t v103 = v34;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_107:
  if (v12) {
LABEL_108:
  }

LABEL_109:
  *((void *)v1 + 405) = 0;
  ++*((_DWORD *)v1 + 812);
LABEL_110:
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v81);
  uint64_t v61 = (re *)(*(uint64_t (**)(void))(**((void **)v1 + 282) + 32))(*((void *)v1 + 282));
  uint64_t v62 = *((void *)v1 + 395);
  if (v62)
  {
    uint64_t v63 = v61;
    unint64_t v40 = v62 - 1;
    for (uint64_t i = 80 * v62; ; i -= 80)
    {
      unint64_t v42 = *((void *)v1 + 395);
      if (v42 <= v40) {
        break;
      }
      unint64_t v65 = *((unsigned int *)v1 + 543);
      if (v65)
      {
        uint64_t v66 = *((void *)v1 + 397) + i;
        if ((unint64_t)v63 - *(void *)(v66 - 48) >= v65)
        {
          id v67 = *re::networkLogObjects(v61);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            re::Transport::connectionAddress(v76, *(void *)(v66 - 80), (re::DynamicString *)buf);
            if (buf[8]) {
              unint64_t v69 = *(uint8_t **)&buf[16];
            }
            else {
              unint64_t v69 = &buf[9];
            }
            int v70 = *((_DWORD *)v1 + 543);
            *(_DWORD *)uint64_t v96 = 136315394;
            *(void *)&v96[4] = v69;
            *(_WORD *)&v96[12] = 1024;
            *(_DWORD *)&v96[14] = v70;
            _os_log_error_impl(&dword_228C70000, v67, OS_LOG_TYPE_ERROR, "Connection '%s' did not do handshake for %d ms. Disconnecting.", v96, 0x12u);
            if (*(void *)buf)
            {
              if (buf[8]) {
                (*(void (**)(void, void))(**(void **)buf + 40))(*(void *)buf, *(void *)&buf[16]);
              }
            }
          }
          unint64_t v68 = *(void *)(v66 - 80);
          re::DynamicArray<re::Session::BacklogItem>::removeAt((uint64_t)v1 + 3144, v40);
          re::Transport::disconnect(v76, v68, 0);
        }
      }
      if (--v40 == -1) {
        return;
      }
    }
    goto LABEL_126;
  }
}

void re::Session::stateEvent(BOOL a1, uint64_t a2)
{
  uint64_t v5 = a1;
  uint64_t v114 = *MEMORY[0x263EF8340];
  if (a2 != 2)
  {
    uint64_t v6 = *re::networkLogObjects((re *)a1);
    a1 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      *(_DWORD *)sockaddr buf = 136315394;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v8;
      _os_log_impl(&dword_228C70000, v6, OS_LOG_TYPE_DEFAULT, "Session: handling event '%s' in state '%s'", buf, 0x16u);
    }
  }
  int v9 = *(_DWORD *)(v5 + 3264);
  switch(v9)
  {
    case 0:
      return;
    case 1:
      switch((int)a2)
      {
        case 0:
          *(void *)(v5 + 3288) = (*(uint64_t (**)(void))(**(void **)(v5 + 2256) + 32))(*(void *)(v5 + 2256));
          return;
        case 1:
        case 3:
          return;
        case 2:
          uint64_t v26 = (re *)(*(uint64_t (**)(void))(**(void **)(v5 + 2256) + 32))(*(void *)(v5 + 2256));
          unint64_t v27 = *(unsigned int *)(v5 + 2168);
          if (!v27 || (unint64_t)v26 - *(void *)(v5 + 3288) < v27)
          {
            if (*(_DWORD *)(v5 + 3032) == 1)
            {
              uint64_t v28 = re::Session::peerID((re::Session *)v5);
              re::Session::assignLocalPeerID((re::Session *)v5, v28);
              uint64_t v29 = v5;
              uint64_t v30 = 2;
            }
            else
            {
              uint64_t v29 = v5;
              uint64_t v30 = 3;
            }
            re::Session::stateSet(v29, v30);
            return;
          }
          unint64_t v14 = *re::networkLogObjects(v26);
          if (os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_ERROR)) {
            goto LABEL_134;
          }
          break;
        default:
          goto LABEL_142;
      }
      goto LABEL_131;
    case 2:
      switch((int)a2)
      {
        case 0:
          re::Session::stateEvent(v5, 3);
          re::Event<re::Session>::raise(v5 + 120, v5);
          return;
        case 1:
        case 5:
          return;
        case 2:
          unint64_t v31 = (re *)(*(uint64_t (**)(void))(**(void **)(v5 + 2256) + 32))(*(void *)(v5 + 2256));
          uint64_t v32 = *(void *)(v5 + 3200);
          if (!v32) {
            return;
          }
          uint64_t v11 = v31;
          uint64_t v95 = (re::Transport *)(v5 + 2320);
          unint64_t v14 = v32 - 1;
          for (uint64_t i = 32 * v32; ; i -= 32)
          {
            unint64_t v13 = *(void *)(v5 + 3200);
            if (v13 <= v14) {
              break;
            }
            uint64_t v34 = *(void *)(v5 + 3216);
            unint64_t v35 = *(unsigned int *)(v5 + 2172);
            if (v35 && (unint64_t)v11 - *(void *)(v34 + i - 32) >= v35
              || ((uint64_t v36 = v34 + i,
                   unint64_t v37 = *(void *)(v34 + i - 8),
                   LODWORD(v38) = *(_DWORD *)(v5 + 2240),
                   v38 <= 1)
                ? (unint64_t v38 = 1)
                : (unint64_t v38 = v38),
                  v37 >= v38))
            {
              unint64_t v31 = (re *)re::DynamicArray<re::Session::SendHandshakeInProgressEntry>::removeAt(v5 + 3184, v14);
            }
            else if (*(_DWORD *)(v5 + 3264) == 2 {
                   && (unint64_t)v11 - *(void *)(v34 + i - 24) >= *(void *)(v5 + 3296))
            }
            {
              *(void *)(v36 - 8) = v37 + 1;
              *(void *)(v34 + i - 24) = v11;
              unint64_t v39 = *re::networkLogObjects(v31);
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
              {
                re::Transport::connectionAddress(v95, *(void *)(v34 + i - 16), (re::DynamicString *)buf);
                unint64_t v55 = &buf[9];
                if (buf[8]) {
                  unint64_t v55 = *(uint8_t **)&buf[16];
                }
                uint64_t v56 = *(void *)(v36 - 8);
                *(_DWORD *)__int16 v102 = 136315394;
                *(void *)&v102[4] = v55;
                *(_WORD *)&v102[12] = 2048;
                *(void *)&v102[14] = v56;
                if (*(void *)buf && (buf[8] & 1) != 0) {
                  (*(void (**)(void))(**(void **)buf + 40))();
                }
              }
              unint64_t v40 = *(re::Transport **)(v34 + i - 16);
              re::Session::localParticipant(buf, v5);
              uint64_t v41 = *(void *)(*(void *)buf + 128);
              uint64_t v96 = v40;
              if (v41) {
                unint64_t v42 = *(const void **)(*(void *)buf + 144);
              }
              else {
                unint64_t v42 = 0;
              }

              unint64_t v43 = re::PacketPool::allocate(*(re::PacketPool **)(v5 + 2704), (v41 + 67));
              re::Packet::offsetBy((uint64_t)v43, 3);
              uint64_t v44 = *((void *)v43 + 1);
              *(unsigned char *)(v44 + 2) = 0;
              *(_WORD *)uint64_t v44 = 0;
              uint64_t v45 = *((void *)v43 + 2);
              int v46 = *((_DWORD *)v43 + 7);
              *(void *)sockaddr buf = &unk_26DD35FA8;
              *(void *)&uint8_t buf[8] = v45;
              *(_DWORD *)&uint8_t buf[16] = v46;
              buf[20] = 0;
              *(void *)&unsigned char buf[24] = 0;
              *(void *)&long long v111 = 0;
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 0, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 0, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 0, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 0, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, 1u, 8u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, *(_DWORD *)(v5 + 2152), 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, *(_DWORD *)(v5 + 2156), 0x20u);
              unsigned int v47 = *(_DWORD *)(v5 + 2164);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, *(_DWORD *)(v5 + 2160), 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v47, 0x20u);
              uint64_t v48 = re::Session::peerID((re::Session *)v5);
              unsigned int v49 = HIDWORD(v48);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v48, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v49, 0x20u);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, *(_DWORD *)(v5 + 3280), 0x20u);
              uint64_t v50 = *(void *)(v5 + 2208);
              if (v50)
              {
                unint64_t v51 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v50 + 64))(v50);
                uint64_t v53 = v52;
              }
              else
              {
                unint64_t v51 = 0;
                uint64_t v53 = 0;
              }
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v53, 0x20u);
              re::BitWriter::writeData((re::BitWriter *)buf, v51, v53);
              re::BitWriter::writeUInt32Bits((uint64_t)buf, v41, 0x20u);
              re::BitWriter::writeData((re::BitWriter *)buf, v42, v41);
              int v54 = *(_DWORD *)&buf[24];
              if (*(_DWORD *)&buf[28]) {
                int v54 = *(_DWORD *)&buf[24] + 1;
              }
              *((_DWORD *)v43 + 6) = v54;
              unint64_t v31 = (re *)re::Transport::send((uint64_t)v95, (unint64_t)v96, (unint64_t)v43, 0, 0, 0, 0);
            }
            if (--v14 == -1) {
              return;
            }
          }
          goto LABEL_138;
        case 3:
          unint64_t v14 = *(void *)(v5 + 3160);
          if (!v14) {
            return;
          }
          uint64_t v57 = v5 + 3144;
          uint64_t v97 = (re::Transport *)(v5 + 2320);
          uint64_t v2 = (re *)&v102[8];
          break;
        case 4:
          uint64_t v91 = *(void *)(v5 + 7424);
          uint64_t v92 = re::Session::peerID((re::Session *)v5);
          uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v91 + 80))(v91, v92, v5 + 2280);
          *(void *)(v5 + 3136) = v93;
          re::Session::onLeaderChange((re::Session *)v5, v93);
          return;
        default:
          goto LABEL_143;
      }
      break;
    case 3:
      if (a2 == 2) {
        return;
      }
      if (a2)
      {
LABEL_141:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Invalid event %d in state '%s'", "!\"Unreachable code\"", "stateFinished", 1417, a2, "Finished");
        _os_crash();
        __break(1u);
LABEL_142:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Invalid event %d in state '%s'", "!\"Unreachable code\"", "stateInit", 1391, a2, "Init");
        _os_crash();
        __break(1u);
LABEL_143:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Invalid event %d in state '%s'", "!\"Unreachable code\"", "stateActive", 1459, a2, "Active");
        _os_crash();
        __break(1u);
        JUMPOUT(0x228CA8900);
      }
      uint64_t v10 = *(void *)(v5 + 2296);
      if (!v10) {
        goto LABEL_22;
      }
      uint64_t v11 = (re *)(v5 + 2280);
      uint64_t v12 = (re *)(v5 + 2320);
      unint64_t v13 = v5 + 384;
      unint64_t v14 = v10 - 1;
      do
      {
        unint64_t v15 = *(void *)(v5 + 2296);
        if (v15 <= v14)
        {
          *(void *)unint64_t v103 = 0;
          long long v112 = 0u;
          long long v113 = 0u;
          long long v111 = 0u;
          memset(buf, 0, sizeof(buf));
          uint64_t v5 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int16 v102 = 136315906;
          *(void *)&v102[4] = "operator[]";
          *(_WORD *)&v102[12] = 1024;
          *(_DWORD *)&v102[14] = 789;
          *(_WORD *)&v102[18] = 2048;
          *(void *)&v102[20] = v14;
          *(_WORD *)&v102[28] = 2048;
          *(void *)&v102[30] = v15;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_134:
          int v94 = *(_DWORD *)(v5 + 2168);
          *(_DWORD *)sockaddr buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v94;
          _os_log_error_impl(&dword_228C70000, (os_log_t)v14, OS_LOG_TYPE_ERROR, "Failed to initialize session in %d ms. Session will be terminated.", buf, 8u);
LABEL_131:
          re::Session::stopSession(v5, 2);
          return;
        }
        unint64_t v16 = *(void *)(*(void *)(*(void *)(v5 + 2312) + 8 * v14) + 32);
        if (v16)
        {
          re::Transport::disconnect((re::Transport *)(v5 + 2320), v16, 1);
          unint64_t v17 = *(void *)(v5 + 2296);
          if (v17 <= v14)
          {
            *(void *)unint64_t v103 = 0;
            long long v112 = 0u;
            long long v113 = 0u;
            long long v111 = 0u;
            memset(buf, 0, sizeof(buf));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)__int16 v102 = 136315906;
            *(void *)&v102[4] = "operator[]";
            *(_WORD *)&v102[12] = 1024;
            *(_DWORD *)&v102[14] = 789;
            *(_WORD *)&v102[18] = 2048;
            *(void *)&v102[20] = v14;
            *(_WORD *)&v102[28] = 2048;
            *(void *)&v102[30] = v17;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_136;
          }
          uint64_t v18 = *(void *)(*(void *)(v5 + 2312) + 8 * v14);
          uint64_t v101 = v18;
          if (v18) {
            id v19 = (id)(v18 + 8);
          }
          re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::raise(v5 + 384, v5);
          if (v101)
          {

            uint64_t v101 = 0;
          }
          re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt(v5 + 2280, v14);
        }
        --v14;
      }
      while (v14 != -1);
LABEL_22:
      unint64_t v14 = v5 + 208;
      int v20 = *(_DWORD *)(v5 + 288);
      *(_DWORD *)(v5 + 288) = v20 + 1;
      if (*(void *)(v5 + 224))
      {
        unint64_t v21 = 0;
        do
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)(v5 + 240) + 32 * v21 + 24))(v5) == 1) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v5 + 208), v21);
          }
          else {
            ++v21;
          }
        }
        while (v21 < *(void *)(v5 + 224));
        int v20 = *(_DWORD *)(v5 + 288) - 1;
      }
      *(_DWORD *)(v5 + 288) = v20;
      if (!v20)
      {
        unint64_t v13 = *(void *)(v5 + 264);
        if (v13)
        {
          uint64_t v22 = 0;
          uint64_t v12 = 0;
          uint64_t v11 = (re *)&v102[8];
          do
          {
            uint64_t v2 = *(re **)(v5 + 264);
            if (v2 <= v12) {
              goto LABEL_137;
            }
            uint64_t v23 = *(void *)(v5 + 280) + v22;
            uint64_t v24 = *(void *)(v23 + 32);
            long long v25 = *(_OWORD *)(v23 + 16);
            *(_OWORD *)__int16 v102 = *(_OWORD *)v23;
            *(_OWORD *)&v102[16] = v25;
            *(void *)&v102[32] = v24;
            if (v102[0])
            {
              re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v5 + 208, &v102[8], (uint64_t)buf);
              if (!buf[0]) {
                re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)(v5 + 208), (uint64_t)&v102[8]);
              }
            }
            else
            {
              re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v5 + 208, &v102[8], (uint64_t)buf);
              if (buf[0]) {
                re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v5 + 208), *(unint64_t *)&buf[8]);
              }
            }
            uint64_t v12 = (re *)((char *)v12 + 1);
            v22 += 40;
          }
          while ((re *)v13 != v12);
        }
      }
      return;
    default:
      _os_crash();
      __break(1u);
      goto LABEL_141;
  }
  while (1)
  {
    --v14;
    uint64_t v11 = *(re **)(v5 + 3160);
    if ((unint64_t)v11 <= v14) {
      goto LABEL_139;
    }
    uint64_t v58 = *(void *)(v5 + 3176);
    uint64_t v59 = (uint64_t *)(v58 + 80 * v14);
    id v60 = v59 + 1;
    uint64_t v61 = v59 + 2;
    if (v59[1] && v59[2] != 0) {
      break;
    }
LABEL_125:
    if (!v14) {
      return;
    }
  }
  uint64_t v63 = *re::networkLogObjects((re *)a1);
  BOOL v64 = os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT);
  if (v64)
  {
    int v65 = *(_DWORD *)(v58 + 80 * v14 + 24);
    *(_DWORD *)sockaddr buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v65;
    _os_log_impl(&dword_228C70000, v63, OS_LOG_TYPE_DEFAULT, "Remote peer ready with capabilities 0x%x", buf, 8u);
  }
  if (*v60)
  {
    uint64_t v66 = *(void *)(v5 + 2296);
    if (v66)
    {
      id v67 = *(uint64_t **)(v5 + 2312);
      uint64_t v68 = 8 * v66;
      while (1)
      {
        uint64_t v69 = *v67;
        if (*(void *)(*v67 + 24) == *v60) {
          break;
        }
        ++v67;
        v68 -= 8;
        if (!v68) {
          goto LABEL_87;
        }
      }
      unsigned __int16 v80 = (void *)(v69 + 8);
      id v81 = (id)(v69 + 8);
      int v82 = v80;
    }
    else
    {
LABEL_87:
      if (re::internal::enableSignposts(0, 0)) {
        kdebug_trace();
      }
      int v70 = re::Transport::connectionAddress(v97, *v59, (re::DynamicString *)buf);
      uint64_t v71 = v58 + 80 * v14;
      uint64_t v72 = *(char **)(v71 + 72);
      size_t v73 = *(void *)(v71 + 56);
      uint64_t v74 = re::globalAllocators(v70);
      uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v74[2] + 32))(v74[2], 160, 8);
      *(void *)__int16 v102 = re::SessionParticipant::SessionParticipant(v75, *v60, *v59, (const re::DynamicString *)buf, *(_DWORD *)(v71 + 24), v72, v73);
      re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::add((_anonymous_namespace_ *)(v5 + 2280), v102);
      if (*(void *)v102) {

      }
      if (*(void *)buf && (buf[8] & 1) != 0) {
        (*(void (**)(void, void))(**(void **)buf + 40))(*(void *)buf, *(void *)&buf[16]);
      }
      uint64_t v76 = *(void *)(*(void *)(v5 + 2312) + 8 * *(void *)(v5 + 2296) - 8);
      uint64_t v77 = *v61;
      if (*v61)
      {
        id v78 = (id)(v77 + 8);
        re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v76 + 152), v77);
      }
      else
      {
        uint64_t v83 = *(void *)(v76 + 152);
        if (v83)
        {

          *(void *)(v76 + 152) = 0;
        }
      }
      *(void *)&long long v99 = v5 + 2320;
      *((void *)&v99 + 1) = *v59;
      int v100 = 1;
      re::RoutingTable::addRoute(*(void *)(v5 + 3040), *v60, &v99);
      (*(void (**)(void, uint64_t))(**(void **)(v5 + 7424) + 88))(*(void *)(v5 + 7424), *v60);
      re::Session::stateEvent(v5, 5);
      uint64_t v84 = *(void *)(*(void *)(v5 + 2312) + 8 * *(void *)(v5 + 2296) - 8);
      uint64_t v98 = v84;
      if (v84) {
        id v85 = (id)(v84 + 8);
      }
      int v86 = *(_DWORD *)(v5 + 376);
      *(_DWORD *)(v5 + 376) = v86 + 1;
      uint64_t v57 = v5 + 3144;
      if (*(void *)(v5 + 312))
      {
        unint64_t v87 = 0;
        do
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)(v5 + 328) + 32 * v87 + 24))(v5) == 1) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v5 + 296), v87);
          }
          else {
            ++v87;
          }
        }
        while (v87 < *(void *)(v5 + 312));
        int v86 = *(_DWORD *)(v5 + 376) - 1;
      }
      *(_DWORD *)(v5 + 376) = v86;
      if (!v86)
      {
        uint64_t v12 = *(re **)(v5 + 352);
        if (v12)
        {
          unint64_t v13 = 0;
          uint64_t v11 = 0;
          while (1)
          {
            unint64_t v3 = *(void *)(v5 + 352);
            if (v3 <= (unint64_t)v11) {
              break;
            }
            unint64_t v88 = *(void *)(v5 + 368) + v13;
            uint64_t v89 = *(void *)(v88 + 32);
            long long v90 = *(_OWORD *)(v88 + 16);
            *(_OWORD *)__int16 v102 = *(_OWORD *)v88;
            *(_OWORD *)&v102[16] = v90;
            *(void *)&v102[32] = v89;
            if (v102[0])
            {
              re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v5 + 296, &v102[8], (uint64_t)buf);
              if (!buf[0]) {
                re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)(v5 + 296), (uint64_t)&v102[8]);
              }
            }
            else
            {
              re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(v5 + 296, &v102[8], (uint64_t)buf);
              if (buf[0]) {
                re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(v5 + 296), *(unint64_t *)&buf[8]);
              }
            }
            uint64_t v11 = (re *)((char *)v11 + 1);
            v13 += 40;
            if (v12 == v11) {
              goto LABEL_121;
            }
          }
LABEL_136:
          uint64_t v101 = 0;
          long long v112 = 0u;
          long long v113 = 0u;
          long long v111 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v103 = 136315906;
          *(void *)&v103[4] = "operator[]";
          __int16 v104 = 1024;
          int v105 = 789;
          __int16 v106 = 2048;
          long long v107 = v11;
          __int16 v108 = 2048;
          long long v109 = (unsigned char *)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_137:
          *(void *)&long long v99 = 0;
          long long v112 = 0u;
          long long v113 = 0u;
          long long v111 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v103 = 136315906;
          *(void *)&v103[4] = "operator[]";
          __int16 v104 = 1024;
          int v105 = 789;
          __int16 v106 = 2048;
          long long v107 = v12;
          __int16 v108 = 2048;
          long long v109 = v2;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_138:
          *(void *)unint64_t v103 = 0;
          long long v112 = 0u;
          long long v113 = 0u;
          long long v111 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int16 v102 = 136315906;
          *(void *)&v102[4] = "operator[]";
          *(_WORD *)&v102[12] = 1024;
          *(_DWORD *)&v102[14] = 789;
          *(_WORD *)&v102[18] = 2048;
          *(void *)&v102[20] = v14;
          *(_WORD *)&v102[28] = 2048;
          *(void *)&v102[30] = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_139:
          *(void *)unint64_t v103 = 0;
          long long v112 = 0u;
          long long v113 = 0u;
          long long v111 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int16 v102 = 136315906;
          *(void *)&v102[4] = "operator[]";
          *(_WORD *)&v102[12] = 1024;
          *(_DWORD *)&v102[14] = 789;
          *(_WORD *)&v102[18] = 2048;
          *(void *)&v102[20] = v14;
          *(_WORD *)&v102[28] = 2048;
          *(void *)&v102[30] = v11;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
LABEL_121:
      if (!v98) {
        goto LABEL_124;
      }
      int v82 = (void *)(v98 + 8);
    }
  }
  else
  {
    int v79 = *re::networkLogObjects((re *)v64);
    if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      _os_log_error_impl(&dword_228C70000, v79, OS_LOG_TYPE_ERROR, "Invalid peerID", buf, 2u);
    }
    re::Transport::disconnect(v97, *v59, 0);
  }
LABEL_124:
  re::DynamicArray<re::Session::BacklogItem>::removeAt(v57, v14);
  goto LABEL_125;
}

void re::Session::afterFrameUpdate(re::Session *this)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  if (*((_DWORD *)this + 816) == 3) {
    return;
  }
  uint64_t v2 = (re::Session *)((char *)this + 2320);
  re::Transport::hostStats((re::Session *)((char *)this + 2320), (uint64_t)buf);
  uint64_t v5 = *((void *)this + 287);
  if (v5)
  {
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    uint64_t v8 = *((void *)this + 289);
    uint64_t v9 = 8 * v5;
    float v10 = 0.0;
    do
    {
      re::Transport::connectionStats(v2, *(void *)(*(void *)v8 + 32), (uint64_t)&v54);
      if ((_BYTE)v54)
      {
        v7 += v55;
        float v10 = v10 + *((float *)&v55 + 1);
        ++v6;
      }
      v8 += 8;
      v9 -= 8;
    }
    while (v9);
  }
  else
  {
    unsigned int v7 = 0;
    unsigned int v6 = 0;
    float v10 = 0.0;
  }
  v3.i32[0] = 0;
  v4.i8[0] = buf[0];
  float v11 = v10 / (float)v6;
  int8x16_t v53 = vbicq_s8(*(int8x16_t *)&buf[3], vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(v4, v3), 0));
  *((void *)this + 927) = v53.i64[0];
  v12.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v13 = *((void *)this + 926);
  if (v13 - *((void *)this + 925) == 128) {
    *((void *)this + 925) = v13 - 127;
  }
  unint64_t v14 = (int8x16_t *)((char *)this + 32 * (v13 & 0x7F));
  *((void *)this + 926) = v13 + 1;
  v14[206].i32[2] = v7 / v6;
  *(float *)&v14[206].i32[3] = v11;
  v14[207] = v53;
  *(std::chrono::steady_clock::time_point *)v14[208].i8 = v12;
  unint64_t v15 = (void *)*((void *)this + 940);
  unint64_t v17 = v15[11];
  unint64_t v16 = v15[12];
  unint64_t v19 = v15[13];
  unint64_t v18 = v15[14];
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  uint64_t v20 = re::internal::enableSignposts(0, 0);
  if (v20) {
    uint64_t v20 = kdebug_trace();
  }
  uint64_t isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v20);
  if (isStatisticCollectionEnabled)
  {
    uint64_t isStatisticCollectionEnabled = re::profilerThreadContext((re *)isStatisticCollectionEnabled);
    uint64_t v22 = *(int64x2_t **)(isStatisticCollectionEnabled + 152);
    if (v22)
    {
      unint64_t v23 = v22[164].u64[0];
      if (v23 >= v17) {
        unint64_t v23 = v17;
      }
      v22[164].i64[0] = v23;
      unint64_t v24 = v22[164].u64[1];
      if (v24 <= v17) {
        unint64_t v24 = v17;
      }
      v22[164].i64[1] = v24;
      int64x2_t v25 = vdupq_n_s64(1uLL);
      v25.i64[0] = v17;
      v22[165] = vaddq_s64(v22[165], v25);
      *(unsigned char *)(isStatisticCollectionEnabled + 184) = 0;
    }
  }
  uint64_t v26 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
  if (v26)
  {
    uint64_t v26 = re::profilerThreadContext((re *)v26);
    unint64_t v27 = *(int64x2_t **)(v26 + 152);
    if (v27)
    {
      unint64_t v28 = v27[168].u64[0];
      if (v28 >= v19) {
        unint64_t v28 = v19;
      }
      v27[168].i64[0] = v28;
      unint64_t v29 = v27[168].u64[1];
      if (v29 <= v19) {
        unint64_t v29 = v19;
      }
      v27[168].i64[1] = v29;
      int64x2_t v30 = vdupq_n_s64(1uLL);
      v30.i64[0] = v19;
      v27[169] = vaddq_s64(v27[169], v30);
      *(unsigned char *)(v26 + 184) = 0;
    }
  }
  uint64_t v31 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v26);
  if (v31)
  {
    uint64_t v31 = re::profilerThreadContext((re *)v31);
    uint64_t v32 = *(int64x2_t **)(v31 + 152);
    if (v32)
    {
      unint64_t v33 = v32[172].u64[0];
      if (v33 >= v16) {
        unint64_t v33 = v16;
      }
      v32[172].i64[0] = v33;
      unint64_t v34 = v32[172].u64[1];
      if (v34 <= v16) {
        unint64_t v34 = v16;
      }
      v32[172].i64[1] = v34;
      int64x2_t v35 = vdupq_n_s64(1uLL);
      v35.i64[0] = v16;
      v32[173] = vaddq_s64(v32[173], v35);
      *(unsigned char *)(v31 + 184) = 0;
    }
  }
  uint64_t v36 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v31);
  if (v36)
  {
    uint64_t v37 = re::profilerThreadContext(v36);
    unint64_t v38 = *(int64x2_t **)(v37 + 152);
    if (v38)
    {
      unint64_t v39 = v38[176].u64[0];
      if (v39 >= v18) {
        unint64_t v39 = v18;
      }
      v38[176].i64[0] = v39;
      unint64_t v40 = v38[176].u64[1];
      if (v40 <= v18) {
        unint64_t v40 = v18;
      }
      v38[176].i64[1] = v40;
      int64x2_t v41 = vdupq_n_s64(1uLL);
      v41.i64[0] = v18;
      v38[177] = vaddq_s64(v38[177], v41);
      *(unsigned char *)(v37 + 184) = 0;
    }
  }
  re::Transport::flushOutgoingData(v2);
  uint64_t v42 = (*(uint64_t (**)(void))(**((void **)this + 282) + 32))(*((void *)this + 282));
  uint64_t v43 = *((void *)this + 383);
  uint64_t v44 = v43 + 1;
  uint64_t v45 = 40 * v43;
  do
  {
    if (!--v44) {
      return;
    }
    unint64_t v46 = v42 - *(void *)(*((void *)this + 385) + v45 - 16);
    v45 -= 40;
  }
  while (v46 >> 4 < 0x753);
  uint64_t v47 = 0;
  unint64_t v48 = 0;
  unint64_t v49 = v44 - 1;
  do
  {
    unint64_t v50 = *((void *)this + 383);
    if (v50 <= v48)
    {
      long long v64 = 0u;
      long long v65 = 0u;
      long long v63 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v54 = 136315906;
      unint64_t v55 = "operator[]";
      __int16 v56 = 1024;
      int v57 = 789;
      __int16 v58 = 2048;
      unint64_t v59 = v48;
      __int16 v60 = 2048;
      unint64_t v61 = v50;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_57:
      long long v64 = 0u;
      long long v65 = 0u;
      long long v63 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v54 = 136315906;
      unint64_t v55 = "removeManyStableAt";
      __int16 v56 = 1024;
      int v57 = 986;
      __int16 v58 = 2048;
      unint64_t v59 = v44 - 1;
      __int16 v60 = 2048;
      unint64_t v61 = v48;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::PacketPool::free(*((re::PacketPool **)this + 338), *(re::Packet **)(*((void *)this + 385) + v47));
    ++v48;
    v47 += 40;
  }
  while (v44 != v48);
  unint64_t v48 = *((void *)this + 383);
  if (v49 >= v48) {
    goto LABEL_57;
  }
  if (v48 != v44 && v49 < v48 - 1)
  {
    unint64_t v51 = (re *)memmove(*((void **)this + 385), (const void *)(*((void *)this + 385) + v45 + 40), 40 * v48 - v45 - 47);
    unint64_t v48 = *((void *)this + 383);
  }
  *((void *)this + 383) = v48 - v44;
  ++*((_DWORD *)this + 768);
  uint64_t v52 = *re::networkLogObjects(v51);
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    buf[0] = 134217984;
    *(void *)&buf[1] = v44;
    _os_log_impl(&dword_228C70000, v52, OS_LOG_TYPE_DEFAULT, "Removing %zu Pending Messages due to timeout.", (uint8_t *)buf, 0xCu);
  }
}

uint64_t *re::Session::readRoutingHeader(re::Session *this, re::BitReader *a2)
{
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  re::BitReader::readUInt64(a2, &v8);
  uint64_t result = re::BitReader::readUInt64(a2, &v7);
  if (*((unsigned char *)a2 + 12))
  {
    char v5 = 0;
  }
  else
  {
    unint64_t v6 = v7;
    *((void *)this + 1) = v8;
    *((void *)this + 2) = v6;
    char v5 = 1;
  }
  *(unsigned char *)this = v5;
  return result;
}

uint64_t re::Session::sendData(uint64_t a1, unint64_t a2, const void *a3, uint64_t a4, unsigned int a5, int a6, int a7)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (!*(void *)(a1 + 2392))
  {
    unint64_t v29 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)sockaddr buf = 134218240;
      *(void *)&uint8_t buf[4] = a4;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = a5;
      _os_log_impl(&dword_228C70000, v29, OS_LOG_TYPE_DEFAULT, "Session: attempting to send %zu bytes on channel %d when not initialized. Data discarded.", buf, 0x12u);
    }
    return 14;
  }
  unint64_t v14 = re::PacketPool::allocate(*(re::PacketPool **)(a1 + 2704), (a4 + 67));
  re::Packet::offsetBy((uint64_t)v14, 3);
  uint64_t v15 = *((void *)v14 + 1);
  *(unsigned char *)(v15 + 2) = 0;
  *(_WORD *)uint64_t v15 = 0;
  uint64_t v16 = *((void *)v14 + 2);
  int v17 = *((_DWORD *)v14 + 7);
  *(void *)sockaddr buf = &unk_26DD35FA8;
  *(void *)&_DWORD buf[8] = v16;
  *(_DWORD *)&uint8_t buf[16] = v17;
  char v54 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v18 = re::Session::peerID((re::Session *)a1);
  unsigned int v19 = HIDWORD(v18);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, v18, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, v19, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a2, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a2), 0x20u);
  re::BitWriter::writeData((re::BitWriter *)buf, a3, a4);
  int v20 = v55;
  if (HIDWORD(v55)) {
    int v20 = v55 + 1;
  }
  *((_DWORD *)v14 + 6) = v20;
  Route = re::RoutingTable::getRoute(*(re::RoutingTable **)(a1 + 3040), a2, (uint64_t)v46);
  if (v46[0])
  {
    uint64_t v22 = *((void *)v47 + 75);
    if (v22)
    {
      uint64_t v23 = *(void *)(v22 + 2296);
      if (!v23) {
        return 8;
      }
      unint64_t v24 = (re::PacketPool **)(a1 + 2320);
      int64x2_t v25 = *(uint64_t **)(v22 + 2312);
      uint64_t v26 = 8 * v23;
      while (1)
      {
        uint64_t v27 = *v25;
        if (*(void *)(*v25 + 32) == v48) {
          break;
        }
        ++v25;
        v26 -= 8;
        if (!v26) {
          return 8;
        }
      }
      id v42 = (id)(v27 + 8);
      uint64_t v44 = PacketUtils::move((PacketUtils *)v14, v24, (re::PacketPool **)v47, v43);
      re::Transport::send((uint64_t)v47, v48, (unint64_t)v44, a5, a7, a6, *(_DWORD *)(v27 + 72));

      return 1;
    }
    return 14;
  }
  int64x2_t v30 = *re::networkLogObjects((re *)Route);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v31 = re::Session::peerID((re::Session *)a1);
    *(_DWORD *)unint64_t v49 = 134218240;
    uint64_t v50 = v31;
    __int16 v51 = 2048;
    unint64_t v52 = a2;
    _os_log_impl(&dword_228C70000, v30, OS_LOG_TYPE_DEFAULT, "No route exists for userData from %llu to %llu. Will try to discover route.", v49, 0x16u);
  }
  uint64_t v32 = (*(uint64_t (**)(void))(**(void **)(a1 + 2256) + 32))(*(void *)(a1 + 2256));
  unint64_t v33 = re::Session::peerID((re::Session *)a1);
  re::Session::broadcastRouteRequest(a1, 0, v33, a2, 1u);
  unint64_t v35 = *(void *)(a1 + 3064);
  unint64_t v36 = *(void *)(a1 + 3056);
  if (v35 >= v36)
  {
    unint64_t v37 = v35 + 1;
    if (v36 < v35 + 1)
    {
      if (*(void *)(a1 + 3048))
      {
        uint64_t v38 = 2 * v36;
        BOOL v39 = v36 == 0;
        unint64_t v40 = 8;
        if (!v39) {
          unint64_t v40 = v38;
        }
        if (v40 <= v37) {
          unint64_t v41 = v37;
        }
        else {
          unint64_t v41 = v40;
        }
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity((void *)(a1 + 3048), v41);
      }
      else
      {
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity((void *)(a1 + 3048), v37);
        ++*(_DWORD *)(a1 + 3072);
      }
    }
    unint64_t v35 = *(void *)(a1 + 3064);
  }
  uint64_t v45 = *(void *)(a1 + 3080) + 40 * v35;
  *(void *)uint64_t v45 = v14;
  *(void *)(v45 + 8) = a2;
  *(unsigned char *)(v45 + 16) = a5;
  *(void *)(v45 + 24) = v32;
  *(unsigned char *)(v45 + 32) = a6;
  ++*(void *)(a1 + 3064);
  ++*(_DWORD *)(a1 + 3072);
  return 1;
}

void re::Session::broadcastRouteRequest(BOOL this, uint64_t a2, unint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t v8 = this;
  unint64_t v9 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
  unint64_t v10 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (a4 ^ (a4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a4 ^ (a4 >> 30))) >> 27));
  unint64_t v11 = ((v10 ^ (v10 >> 31)) + ((v9 ^ (v9 >> 31)) << 6) + ((v9 ^ (v9 >> 31)) >> 2) - 0x61C8864680B583E9) ^ v9 ^ (v9 >> 31);
  unint64_t v12 = *(unsigned int *)(this + 3112);
  if (v12)
  {
    uint64_t v13 = *(unsigned int *)(*(void *)(this + 3096) + 4 * (v11 % v12));
    if (v13 != 0x7FFFFFFF)
    {
      uint64_t v48 = *(void *)(this + 3104);
      uint64_t v49 = v48 + 32 * v13;
      uint64_t v51 = *(void *)(v49 + 16);
      uint64_t v50 = *(void *)(v49 + 24);
      if (v51 == a3 && v50 == a4) {
        return;
      }
      while (1)
      {
        uint64_t v13 = *(_DWORD *)(v48 + 32 * v13 + 8) & 0x7FFFFFFF;
        if (v13 == 0x7FFFFFFF) {
          break;
        }
        uint64_t v53 = v48 + 32 * v13;
        uint64_t v55 = *(void *)(v53 + 16);
        uint64_t v54 = *(void *)(v53 + 24);
        if (v55 == a3 && v54 == a4) {
          return;
        }
      }
    }
  }
  uint64_t v14 = *(void *)(this + 3040);
  uint64_t v15 = *(void *)(v14 + 48);
  if (!v15) {
    goto LABEL_25;
  }
  unint64_t v57 = v11;
  uint64_t v58 = this;
  uint64_t v16 = *(void *)(v14 + 64);
  uint64_t v17 = v16 + 40 * v15;
  uint64_t v18 = (char *)(this + 2320);
  *(void *)unint64_t v59 = HIDWORD(a4);
  do
  {
    if (*(_DWORD *)(v16 + 24) > 1u) {
      goto LABEL_23;
    }
    uint64_t v20 = *(void *)(v16 + 8);
    unint64_t v19 = *(void *)(v16 + 16);
    if ((char *)v20 == v18 && v19 == a2) {
      goto LABEL_23;
    }
    uint64_t v22 = *(void *)(v20 + 600);
    if (!v22)
    {
      int64x2_t v30 = *re::networkLogObjects((re *)this);
      this = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
      if (!this) {
        goto LABEL_23;
      }
      *(_WORD *)sockaddr buf = 0;
      unint64_t v28 = v30;
      unint64_t v29 = "sendRouteRequest: missing session for transport!";
      goto LABEL_19;
    }
    uint64_t v23 = *(void *)(v22 + 2296);
    if (!v23)
    {
LABEL_15:
      uint64_t v27 = *re::networkLogObjects((re *)this);
      this = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
      if (!this) {
        goto LABEL_23;
      }
      *(_WORD *)sockaddr buf = 0;
      unint64_t v28 = v27;
      unint64_t v29 = "sendRouteRequest: missing participant for connection!";
LABEL_19:
      _os_log_error_impl(&dword_228C70000, v28, OS_LOG_TYPE_ERROR, v29, buf, 2u);
      goto LABEL_23;
    }
    unint64_t v24 = *(uint64_t **)(v22 + 2312);
    uint64_t v25 = 8 * v23;
    while (1)
    {
      uint64_t v26 = *v24;
      if (*(void *)(*v24 + 32) == v19) {
        break;
      }
      ++v24;
      v25 -= 8;
      if (!v25) {
        goto LABEL_15;
      }
    }
    id v31 = (id)(v26 + 8);
    uint64_t v32 = re::PacketPool::allocate(*(re::PacketPool **)(v20 + 384), 67);
    re::Packet::offsetBy((uint64_t)v32, 3);
    uint64_t v33 = *((void *)v32 + 1);
    *(unsigned char *)(v33 + 2) = 0;
    *(_WORD *)uint64_t v33 = 0;
    uint64_t v34 = *((void *)v32 + 2);
    int v35 = *((_DWORD *)v32 + 7);
    *(void *)sockaddr buf = &unk_26DD35FA8;
    *(void *)&_DWORD buf[8] = v34;
    int v62 = v35;
    char v63 = 0;
    uint64_t v64 = 0;
    uint64_t v65 = 0;
    re::BitWriter::writeUInt32Bits((uint64_t)buf, a3, 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a3), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, a4, 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, v59[0], 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, 4u, 8u);
    re::BitWriter::writeUInt32Bits((uint64_t)buf, a5, 0x20u);
    int v36 = v64;
    if (HIDWORD(v64)) {
      int v36 = v64 + 1;
    }
    *((_DWORD *)v32 + 6) = v36;
    re::Transport::send(v20, v19, (unint64_t)v32, 0, 0, 0, *(_DWORD *)(v26 + 72));

LABEL_23:
    v16 += 40;
  }
  while (v16 != v17);
  unint64_t v11 = v57;
  uint64_t v8 = v58;
  LODWORD(v12) = *(_DWORD *)(v58 + 3112);
LABEL_25:
  *(void *)sockaddr buf = a3;
  *(void *)&_DWORD buf[8] = a4;
  if (!v12)
  {
    LODWORD(v37) = 0;
    goto LABEL_50;
  }
  unint64_t v37 = v11 % v12;
  uint64_t v38 = *(unsigned int *)(*(void *)(v8 + 3096) + 4 * v37);
  if (v38 == 0x7FFFFFFF) {
    goto LABEL_50;
  }
  uint64_t v39 = *(void *)(v8 + 3104);
  uint64_t v40 = v39 + 32 * v38;
  uint64_t v42 = *(void *)(v40 + 16);
  uint64_t v41 = *(void *)(v40 + 24);
  if (v42 == a3 && v41 == a4)
  {
LABEL_37:
    *(_OWORD *)(v39 + 32 * v38 + 16) = *(_OWORD *)buf;
  }
  else
  {
    while (1)
    {
      uint64_t v38 = *(_DWORD *)(v39 + 32 * v38 + 8) & 0x7FFFFFFF;
      if (v38 == 0x7FFFFFFF) {
        break;
      }
      uint64_t v44 = v39 + 32 * v38;
      uint64_t v46 = *(void *)(v44 + 16);
      uint64_t v45 = *(void *)(v44 + 24);
      if (v46 == a3 && v45 == a4) {
        goto LABEL_37;
      }
    }
LABEL_50:
    re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::addAsMove(v8 + 3088, v37, v11, (__n128 *)buf);
  }
  ++*(_DWORD *)(v8 + 3128);
}

void re::Session::sendRouteResponse(re::Session *this, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  Route = re::RoutingTable::getRoute(this, a3, (uint64_t)v24);
  if (!v24[0])
  {
    uint64_t v15 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)sockaddr buf = 134218496;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = a3;
    __int16 v28 = 1024;
    LODWORD(v29) = a4;
    uint64_t v14 = "Failed to send routing response. src=%llu, dst-%llu, hop=%d";
    uint64_t v16 = v15;
    uint32_t v17 = 28;
    goto LABEL_14;
  }
  uint64_t v8 = *(void *)(v25 + 600);
  if (!v8)
  {
    uint64_t v13 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)sockaddr buf = 0;
    uint64_t v14 = "sendRouteResponse: missing session for transport!";
    goto LABEL_13;
  }
  uint64_t v9 = *(void *)(v8 + 2296);
  if (!v9)
  {
LABEL_7:
    uint64_t v13 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)sockaddr buf = 0;
    uint64_t v14 = "sendRouteResponse: missing participant for connection!";
LABEL_13:
    uint64_t v16 = v13;
    uint32_t v17 = 2;
LABEL_14:
    _os_log_error_impl(&dword_228C70000, v16, OS_LOG_TYPE_ERROR, v14, buf, v17);
    return;
  }
  unint64_t v10 = *(uint64_t **)(v8 + 2312);
  uint64_t v11 = 8 * v9;
  while (1)
  {
    uint64_t v12 = *v10;
    if (*(void *)(*v10 + 32) == v26) {
      break;
    }
    ++v10;
    v11 -= 8;
    if (!v11) {
      goto LABEL_7;
    }
  }
  id v18 = (id)(v12 + 8);
  unint64_t v19 = re::PacketPool::allocate(*(re::PacketPool **)(v25 + 384), 67);
  re::Packet::offsetBy((uint64_t)v19, 3);
  uint64_t v20 = *((void *)v19 + 1);
  *(unsigned char *)(v20 + 2) = 0;
  *(_WORD *)uint64_t v20 = 0;
  uint64_t v21 = *((void *)v19 + 2);
  int v22 = *((_DWORD *)v19 + 7);
  *(void *)sockaddr buf = &unk_26DD35FA8;
  *(void *)&_DWORD buf[8] = v21;
  *(_DWORD *)&uint8_t buf[16] = v22;
  unsigned char buf[20] = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a2, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a2), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a3, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a3), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, 5u, 8u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a4, 0x20u);
  int v23 = v29;
  if (HIDWORD(v29)) {
    int v23 = v29 + 1;
  }
  *((_DWORD *)v19 + 6) = v23;
  re::Transport::send(v25, v26, (unint64_t)v19, 0, 0, 0, *(_DWORD *)(v12 + 72));
}

unint64_t re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::remove(uint64_t a1, void *a2)
{
  unint64_t result = re::Hash<re::Pair<unsigned long long,unsigned long long,true>>::operator()((uint64_t)&v22, a2);
  unint64_t v5 = *(unsigned int *)(a1 + 24);
  if (v5)
  {
    unint64_t v6 = result % v5;
    uint64_t v7 = *(void *)(a1 + 8);
    uint64_t v8 = *(unsigned int *)(v7 + 4 * (result % v5));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *(void *)(a1 + 16);
      uint64_t v10 = a2[1];
      uint64_t v11 = v9 + 32 * v8;
      if (*(void *)(v11 + 16) == *a2 && *(void *)(v11 + 24) == v10)
      {
        *(_DWORD *)(v7 + 4 * v6) = *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
LABEL_15:
        uint64_t v16 = *(void *)(a1 + 16);
        uint64_t v17 = v16 + 32 * v8;
        int v20 = *(_DWORD *)(v17 + 8);
        unint64_t v19 = (int *)(v17 + 8);
        int v18 = v20;
        if (v20 < 0)
        {
          *unint64_t v19 = v18 & 0x7FFFFFFF;
          uint64_t v16 = *(void *)(a1 + 16);
          int v18 = *(_DWORD *)(v16 + 32 * v8 + 8);
        }
        int v21 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v16 + 32 * v8 + 8) = *(_DWORD *)(a1 + 36) | v18 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v8;
        *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v21 + 1;
      }
      else
      {
        while (1)
        {
          unsigned int v13 = v8;
          uint64_t v8 = *(_DWORD *)(v9 + 32 * v8 + 8) & 0x7FFFFFFF;
          if (v8 == 0x7FFFFFFF) {
            break;
          }
          uint64_t v14 = v9 + 32 * v8;
          if (*(void *)(v14 + 16) == *a2 && *(void *)(v14 + 24) == v10)
          {
            *(_DWORD *)(v9 + 32 * v13 + 8) = *(_DWORD *)(v9 + 32 * v13 + 8) & 0x80000000 | *(_DWORD *)(v14 + 8) & 0x7FFFFFFF;
            goto LABEL_15;
          }
        }
      }
    }
  }
  return result;
}

void *re::DynamicArray<re::Session::PendingMessage>::removeStableAt(void *result, unint64_t a2)
{
  unint64_t v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  int8x16_t v3 = result;
  uint64_t v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    unint64_t result = (void *)(result[4] + 40 * a2);
    uint64_t v5 = 40 * v2 - (40 * a2 + 40);
    if (v5)
    {
      unint64_t result = memmove(result, result + 5, v5 - 7);
      uint64_t v4 = v3[2] - 1;
    }
  }
  _OWORD v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void re::Session::sendRouteFail(re::Session *this, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  Route = re::RoutingTable::getRoute(this, a3, (uint64_t)v24);
  if (!v24[0])
  {
    uint64_t v15 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)sockaddr buf = 134218496;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = a3;
    __int16 v28 = 1024;
    LODWORD(v29) = a4;
    uint64_t v14 = "Failed to notify peer about failed route. src=%llu, dst-%llu, hop=%d";
    uint64_t v16 = v15;
    uint32_t v17 = 28;
    goto LABEL_14;
  }
  uint64_t v8 = *(void *)(v25 + 600);
  if (!v8)
  {
    unsigned int v13 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)sockaddr buf = 0;
    uint64_t v14 = "sendRouteFail: missing session for transport!";
    goto LABEL_13;
  }
  uint64_t v9 = *(void *)(v8 + 2296);
  if (!v9)
  {
LABEL_7:
    unsigned int v13 = *re::networkLogObjects((re *)Route);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)sockaddr buf = 0;
    uint64_t v14 = "sendRouteFail: missing participant for connection!";
LABEL_13:
    uint64_t v16 = v13;
    uint32_t v17 = 2;
LABEL_14:
    _os_log_error_impl(&dword_228C70000, v16, OS_LOG_TYPE_ERROR, v14, buf, v17);
    return;
  }
  uint64_t v10 = *(uint64_t **)(v8 + 2312);
  uint64_t v11 = 8 * v9;
  while (1)
  {
    uint64_t v12 = *v10;
    if (*(void *)(*v10 + 32) == v26) {
      break;
    }
    ++v10;
    v11 -= 8;
    if (!v11) {
      goto LABEL_7;
    }
  }
  id v18 = (id)(v12 + 8);
  unint64_t v19 = re::PacketPool::allocate(*(re::PacketPool **)(v25 + 384), 67);
  re::Packet::offsetBy((uint64_t)v19, 3);
  uint64_t v20 = *((void *)v19 + 1);
  *(unsigned char *)(v20 + 2) = 0;
  *(_WORD *)uint64_t v20 = 0;
  uint64_t v21 = *((void *)v19 + 2);
  int v22 = *((_DWORD *)v19 + 7);
  *(void *)sockaddr buf = &unk_26DD35FA8;
  *(void *)&_DWORD buf[8] = v21;
  *(_DWORD *)&uint8_t buf[16] = v22;
  unsigned char buf[20] = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a2, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a2), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a3, 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, HIDWORD(a3), 0x20u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, 6u, 8u);
  re::BitWriter::writeUInt32Bits((uint64_t)buf, a4, 0x20u);
  int v23 = v29;
  if (HIDWORD(v29)) {
    int v23 = v29 + 1;
  }
  *((_DWORD *)v19 + 6) = v23;
  re::Transport::send(v25, v26, (unint64_t)v19, 0, 0, 0, *(_DWORD *)(v12 + 72));
}

void re::Event<re::Session,unsigned long long>::raise(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      uint64_t v7 = 0;
      for (unint64_t i = 0; i != v6; ++i)
      {
        unint64_t v9 = *(void *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v15 = 136315906;
          uint64_t v16 = "operator[]";
          __int16 v17 = 1024;
          int v18 = 789;
          __int16 v19 = 2048;
          unint64_t v20 = i;
          __int16 v21 = 2048;
          unint64_t v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = *(void *)(a1 + 72) + v7;
        uint64_t v11 = *(void *)(v10 + 32);
        long long v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        uint64_t v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, *((unint64_t *)&v23[0] + 1));
          }
        }
        v7 += 40;
      }
    }
  }
}

BOOL re::Session::isLocalPeer(re::Session *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 380);
  if (v2) {
    return *(void *)(v2 + 24) == a2;
  }
  uint64_t v4 = *re::networkLogObjects(this);
  BOOL result = os_log_type_enabled(v4, OS_LOG_TYPE_INFO);
  if (result)
  {
    *(_WORD *)unint64_t v5 = 0;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_INFO, "Routing table is nil", v5, 2u);
    return 0;
  }
  return result;
}

uint64_t re::Session::hasPeerID(re::Session *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 287);
  if (!v2) {
    return 0;
  }
  int v3 = (uint64_t *)*((void *)this + 289);
  uint64_t v4 = 8 * v2;
  while (1)
  {
    uint64_t v5 = *v3;
    if (*(void *)(*v3 + 24) == a2) {
      break;
    }
    ++v3;
    v4 -= 8;
    if (!v4) {
      return 0;
    }
  }
  uint64_t v7 = (void *)(v5 + 8);
  id v8 = (id)(v5 + 8);

  return 1;
}

uint64_t re::DynamicArray<re::Session::SendHandshakeInProgressEntry>::removeAt(uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(void *)(result + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v3 = v2 - 1;
  if (v2 - 1 > a2)
  {
    uint64_t v4 = *(void *)(result + 32);
    uint64_t v5 = v4 + 32 * v2;
    uint64_t v6 = (_OWORD *)(v4 + 32 * a2);
    long long v7 = *(_OWORD *)(v5 - 16);
    *uint64_t v6 = *(_OWORD *)(v5 - 32);
    v6[1] = v7;
    uint64_t v3 = *(void *)(result + 16) - 1;
  }
  *(void *)(result + 16) = v3;
  ++*(_DWORD *)(result + 24);
  return result;
}

uint64_t re::Session::removePendingPeerHelloForConnection(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(void *)(this + 3200);
  if (v2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = (uint64_t *)(*(void *)(this + 3216) + 16);
    while (1)
    {
      uint64_t v5 = *v4;
      v4 += 4;
      if (v5 == a2) {
        break;
      }
      if (v2 == ++v3) {
        return this;
      }
    }
    return re::DynamicArray<re::Session::SendHandshakeInProgressEntry>::removeAt(this + 3184, v3);
  }
  return this;
}

_anonymous_namespace_ *re::Session::onConnected(re::Session *this, uint64_t a2)
{
  re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 1792, (uint64_t)this);
  if (!re::Session::findBacklogItemWithConnectionHandle(this, a2, 0))
  {
    uint64_t v21 = 0;
    v14[1] = 0;
    uint64_t v15 = 0;
    int v16 = 0;
    uint64_t v17 = 0;
    long long v19 = 0u;
    int v20 = 0;
    re::DynamicArray<unsigned char>::setCapacity(&v18, 0);
    ++v20;
    v14[0] = a2;
    uint64_t v17 = (*(uint64_t (**)(void))(**((void **)this + 282) + 32))(*((void *)this + 282));
    re::DynamicArray<re::Session::BacklogItem>::add((uint64_t)this + 3144, (uint64_t)v14);
    if (v18)
    {
      if (v21) {
        (*(void (**)(void))(*v18 + 40))();
      }
      uint64_t v21 = 0;
      long long v19 = 0uLL;
      int v18 = 0;
      ++v20;
    }
    if (v15) {
  }
    }
  BOOL result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**((void **)this + 282) + 32))(*((void *)this + 282));
  uint64_t v5 = result;
  unint64_t v6 = *((void *)this + 400);
  unint64_t v7 = *((void *)this + 399);
  if (v6 >= v7)
  {
    unint64_t v8 = v6 + 1;
    if (v7 < v6 + 1)
    {
      if (*((void *)this + 398))
      {
        uint64_t v9 = 2 * v7;
        BOOL v10 = v7 == 0;
        unint64_t v11 = 8;
        if (!v10) {
          unint64_t v11 = v9;
        }
        if (v11 <= v8) {
          unint64_t v12 = v8;
        }
        else {
          unint64_t v12 = v11;
        }
        BOOL result = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)this + 398, v12);
      }
      else
      {
        BOOL result = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)this + 398, v8);
        ++*((_DWORD *)this + 802);
      }
    }
    unint64_t v6 = *((void *)this + 400);
  }
  unsigned int v13 = (_anonymous_namespace_ **)(*((void *)this + 402) + 32 * v6);
  NSObject *v13 = v5;
  v13[1] = 0;
  _OWORD v13[2] = (_anonymous_namespace_ *)a2;
  v13[3] = 0;
  ++*((void *)this + 400);
  ++*((_DWORD *)this + 802);
  return result;
}

uint64_t re::Session::findBacklogItemWithConnectionHandle(re::Session *this, uint64_t a2, unint64_t *a3)
{
  v9[5] = *MEMORY[0x263EF8340];
  uint64_t v6 = re::globalAllocators(this)[2];
  v9[0] = &unk_26DD35790;
  v9[1] = a2;
  unint64_t v9[3] = v6;
  unsigned char v9[4] = v9;
  uint64_t BacklogItem = re::Session::findBacklogItem((uint64_t)this, (uint64_t)v9, a3);
  re::FunctionBase<24ul,BOOL ()(re::Session::BacklogItem const&)>::destroyCallable((uint64_t)v9);
  return BacklogItem;
}

uint64_t re::DynamicArray<re::Session::BacklogItem>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v6)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::Session::BacklogItem>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::Session::BacklogItem>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = v11 + 80 * v5;
  *(_OWORD *)uint64_t v12 = *(_OWORD *)a2;
  uint64_t v13 = *(void *)(a2 + 16);
  *(void *)(v12 + 16) = v13;
  if (v13) {
    id v14 = (id)(v13 + 8);
  }
  uint64_t v15 = v11 + 80 * v5;
  *(_OWORD *)(v15 + 24) = *(_OWORD *)(a2 + 24);
  uint64_t result = re::DynamicArray<unsigned char>::DynamicArray(v15 + 40, (uint64_t *)(a2 + 40));
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

_anonymous_namespace_ *non-virtual thunk to're::Session::onConnected(re::Session *this, uint64_t a2)
{
  return re::Session::onConnected((re::Session *)((char *)this - 24), a2);
}

void re::Session::onDisconnected(uint64_t **this, uint64_t a2)
{
  re::Event<re::Session,unsigned long long>::raise((uint64_t)(this + 235), (uint64_t)this);
  unint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t BacklogItemWithConnectionHandle = re::Session::findBacklogItemWithConnectionHandle((re::Session *)this, a2, &v15);
  if (BacklogItemWithConnectionHandle)
  {
    re::SharedPtr<re::SyncObject>::reset(&v16, *(void *)(BacklogItemWithConnectionHandle + 16));
    re::DynamicArray<re::Session::BacklogItem>::removeAt((uint64_t)(this + 393), v15);
  }
  unint64_t v5 = this[287];
  if (v5)
  {
    unint64_t v6 = this[289];
    uint64_t v7 = 8 * (void)v5;
    while (1)
    {
      uint64_t v8 = *v6;
      if (*(void *)(*v6 + 32) == a2) {
        break;
      }
      ++v6;
      v7 -= 8;
      if (!v7) {
        goto LABEL_9;
      }
    }
    id v9 = (id)(v8 + 8);
    re::SharedPtr<re::SyncObject>::reset(&v16, *(void *)(v8 + 152));
    uint64_t v14 = v8;
    id v10 = (id)(v8 + 8);
    re::Session::removeParticipant((uint64_t)this, &v14);
  }
LABEL_9:
  uint64_t v11 = this[276];
  if (v11)
  {
    if (v16)
    {
      uint64_t v13 = v16;
      id v12 = (id)(v16 + 8);
      (*(void (**)(uint64_t *, uint64_t *))(*v11 + 80))(v11, &v13);
      if (v13)
      {

        uint64_t v13 = 0;
      }
    }
  }
  re::Session::removePendingPeerHelloForConnection((uint64_t)this, a2);
  if (v16) {
}
  }

void re::DynamicArray<re::Session::BacklogItem>::removeAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = v4 + 80 * v2;
    uint64_t v6 = v4 + 80 * a2;
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(v5 - 80);
    uint64_t v7 = *(void *)(v6 + 16);
    *(void *)(v6 + 16) = *(void *)(v5 - 64);
    *(void *)(v5 - 64) = v7;
    *(_OWORD *)(v6 + 24) = *(_OWORD *)(v5 - 56);
    re::DynamicArray<unsigned char>::operator=(v6 + 40, v5 - 40);
    unint64_t v2 = *(void *)(a1 + 16);
  }
  uint64_t v8 = *(void *)(a1 + 32) + 80 * v2;
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v8 - 40);
  uint64_t v9 = *(void *)(v8 - 64);
  if (v9)
  {

    *(void *)(v8 - 64) = 0;
  }
  --*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::Session::removeParticipant(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(*a2 + 24);
  uint64_t v5 = a1 + 384;
  uint64_t v17 = *a2;
  id v6 = (id)(*a2 + 8);
  re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::raise(v5, a1);
  if (v17) {

  }
  re::RoutingTable::removeRoutesForConnection(*(re::RoutingTable **)(a1 + 3040), (re::Transport *)(a1 + 2320), *(void *)(*a2 + 32));
  uint64_t v7 = *(void *)(a1 + 2312);
  uint64_t v8 = *(void *)(a1 + 2296);
  if (v8)
  {
    uint64_t v9 = 8 * v8;
    id v10 = *(void **)(a1 + 2312);
    while (*v10 != *a2)
    {
      ++v10;
      v9 -= 8;
      if (!v9)
      {
        id v10 = (void *)(v7 + 8 * v8);
        break;
      }
    }
  }
  else
  {
    id v10 = *(void **)(a1 + 2312);
  }
  unint64_t v11 = ((uint64_t)v10 - v7) >> 3;
  if (v11 != v8) {
    re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt(a1 + 2280, v11);
  }
  uint64_t v12 = *(void *)(a1 + 3064);
  if (v12)
  {
    unint64_t v13 = v12 - 1;
    uint64_t v14 = 40 * v12;
    do
    {
      if (*(void *)(a1 + 3064) <= v13)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v15 = *(void *)(a1 + 3080) + v14;
      if (*(void *)(v15 - 32) == v4)
      {
        re::PacketPool::free(*(re::PacketPool **)(a1 + 2704), *(re::Packet **)(v15 - 40));
        re::DynamicArray<re::Session::PendingMessage>::removeStableAt((void *)(a1 + 3048), v13);
      }
      --v13;
      v14 -= 40;
    }
    while (v13 != -1);
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  re::Session::stateEvent(a1, 5);
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 7424) + 96))(*(void *)(a1 + 7424), v4);
}

void non-virtual thunk to're::Session::onDisconnected(uint64_t **this, uint64_t a2)
{
}

uint64_t re::Session::onError(uint64_t this, uint64_t a2, int a3)
{
  if ((a3 & 0xFFFFFFFB) == 0)
  {
    uint64_t v5 = this;
    uint64_t v6 = *(void *)(this + 3160);
    if (v6)
    {
      unint64_t v7 = 0;
      uint64_t v8 = *(uint64_t **)(this + 3176);
      while (1)
      {
        uint64_t v9 = *v8;
        v8 += 10;
        if (v9 == a2) {
          break;
        }
        if (v6 == ++v7) {
          goto LABEL_8;
        }
      }
      re::DynamicArray<re::Session::BacklogItem>::removeAt(this + 3144, v7);
    }
LABEL_8:
    return re::Session::removePendingPeerHelloForConnection(v5, a2);
  }
  return this;
}

uint64_t non-virtual thunk to're::Session::onError(uint64_t a1, uint64_t a2, int a3)
{
  return re::Session::onError(a1 - 24, a2, a3);
}

_anonymous_namespace_ *re::Session::onReceive(_anonymous_namespace_ *result, uint64_t a2, int a3)
{
  if (a3 != 1)
  {
    uint64_t v4 = result;
    uint64_t v5 = *((void *)result + 407);
    unint64_t v6 = *((void *)result + 405);
    if (v6)
    {
      uint64_t v7 = 8 * v6;
      uint64_t v8 = (void *)*((void *)result + 407);
      while (*v8 != a2)
      {
        ++v8;
        v7 -= 8;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      unint64_t v9 = *((void *)result + 404);
      if (v6 >= v9)
      {
        unint64_t v10 = v6 + 1;
        if (v9 < v6 + 1)
        {
          if (*((void *)result + 403))
          {
            unint64_t v11 = 2 * v9;
            if (!v9) {
              unint64_t v11 = 8;
            }
            if (v11 <= v10) {
              unint64_t v12 = v10;
            }
            else {
              unint64_t v12 = v11;
            }
            uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::Allocator const*>::setCapacity((void *)result + 403, v12);
          }
          else
          {
            uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::Allocator const*>::setCapacity((void *)v4 + 403, v10);
            ++*((_DWORD *)v4 + 812);
          }
        }
        unint64_t v6 = *((void *)v4 + 405);
        uint64_t v5 = *((void *)v4 + 407);
      }
      *(void *)(v5 + 8 * v6) = a2;
      *((void *)v4 + 405) = v6 + 1;
      ++*((_DWORD *)v4 + 812);
    }
  }
  return result;
}

_anonymous_namespace_ *non-virtual thunk to're::Session::onReceive(uint64_t a1, uint64_t a2, int a3)
{
  return re::Session::onReceive((_anonymous_namespace_ *)(a1 - 24), a2, a3);
}

void re::Session::onDataArrived(re::Session *this)
{
}

void non-virtual thunk to're::Session::onDataArrived(re::Session *this)
{
}

void re::Session::onConnectionPaused(re::Session *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 287);
  if (v2)
  {
    uint64_t v4 = (uint64_t *)*((void *)this + 289);
    uint64_t v5 = 8 * v2;
    while (1)
    {
      uint64_t v6 = *v4;
      if (*(void *)(*v4 + 32) == a2) {
        break;
      }
      ++v4;
      v5 -= 8;
      if (!v5) {
        return;
      }
    }
    id v7 = (id)(v6 + 8);
    re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 1968, (uint64_t)this);
  }
}

void non-virtual thunk to're::Session::onConnectionPaused(re::Session *this, uint64_t a2)
{
}

void re::Session::onConnectionResumed(re::Session *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 287);
  if (v2)
  {
    uint64_t v4 = (uint64_t *)*((void *)this + 289);
    uint64_t v5 = 8 * v2;
    while (1)
    {
      uint64_t v6 = *v4;
      if (*(void *)(*v4 + 32) == a2) {
        break;
      }
      ++v4;
      v5 -= 8;
      if (!v5) {
        return;
      }
    }
    id v7 = (id)(v6 + 8);
    re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 2056, (uint64_t)this);
  }
}

void non-virtual thunk to're::Session::onConnectionResumed(re::Session *this, uint64_t a2)
{
}

uint64_t re::Session::findBacklogItem(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 3160);
  if (!v3) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 3176);
  uint64_t v8 = -v7;
  uint64_t v9 = 80 * v3;
  while (!(*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 32) + 16))(*(void *)(a2 + 32), v7))
  {
    v7 += 80;
    v8 -= 80;
    v9 -= 80;
    if (!v9) {
      return 0;
    }
  }
  if (a3) {
    *a3 = 0xCCCCCCCCCCCCCCCDLL * ((-v8 - *(void *)(a1 + 3176)) >> 4);
  }
  return v7;
}

void re::Session::findParticipantWithIdentity(void *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *a2;
  uint64_t v7 = v5;
  if (v5) {
    id v6 = (id)(v5 + 8);
  }
  re::Session::findParticipant<re::Session::findParticipantWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&)::{lambda(re::SessionParticipant const*)#1}>(a1, &v7, a3);
  if (v7) {
}
  }

void re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::raise(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      uint64_t v7 = 0;
      for (unint64_t i = 0; i != v6; ++i)
      {
        unint64_t v9 = *(void *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v15 = 136315906;
          uint64_t v16 = "operator[]";
          __int16 v17 = 1024;
          int v18 = 789;
          __int16 v19 = 2048;
          unint64_t v20 = i;
          __int16 v21 = 2048;
          unint64_t v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = *(void *)(a1 + 72) + v7;
        uint64_t v11 = *(void *)(v10 + 32);
        long long v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        uint64_t v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, *((unint64_t *)&v23[0] + 1));
          }
        }
        v7 += 40;
      }
    }
  }
}

void re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = v5 + 8 * v2;
    uint64_t v7 = *(void *)(v5 + 8 * a2);
    *(void *)(v5 + 8 * a2) = *(void *)(v6 - 8);
    *(void *)(v6 - 8) = v7;
  }
  uint64_t v8 = *(void *)(a1 + 32) + 8 * v2;
  uint64_t v9 = *(void *)(v8 - 8);
  if (v9)
  {

    *(void *)(v8 - 8) = 0;
    uint64_t v4 = *(void *)(a1 + 16) - 1;
  }
  *(void *)(a1 + 16) = v4;
  ++*(_DWORD *)(a1 + 24);
}

void re::Session::onLeaderChange(re::Session *this, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v4 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 134218240;
    uint64_t v6 = a2;
    __int16 v7 = 2048;
    uint64_t v8 = re::Session::peerID(this);
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Picked session leader %llu (localPeerID=%llu)", (uint8_t *)&v5, 0x16u);
  }
  re::Event<re::Session,unsigned long long>::raise((uint64_t)this + 1704, (uint64_t)this);
}

void re::DynamicArray<unsigned char>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<unsigned char>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2 && (uint64_t)(a2 - v4) >= 1) {
      bzero((void *)(*(void *)(a1 + 32) + v4), a2 - v4);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 16))
  {
    unint64_t v4 = 0;
    uint64_t v5 = a1 + 40;
    do
    {
      uint64_t v6 = (long long *)(*(void *)(a1 + 32) + 32 * v4);
      if (*(void *)v6 == a2)
      {
        if (!*(_DWORD *)(a1 + 80))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v4);
          continue;
        }
        v8[0] = 0;
        long long v7 = v6[1];
        long long v9 = *v6;
        long long v10 = v7;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v5, (uint64_t)v8);
      }
      ++v4;
    }
    while (v4 < *(void *)(a1 + 16));
  }
}

float re::Session::averagedStatsAggregated@<S0>(re::Session *this@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v3 = *((void *)this + 926);
  uint64_t v4 = *((void *)this + 925);
  unint64_t v5 = v3 - v4;
  if ((unint64_t)(v3 - v4) >= 2)
  {
    uint64_t v6 = (char *)this + 32 * ((v3 - 1) & 0x7F) + 3304;
    long long v7 = (char *)this + 32 * (*((void *)this + 925) & 0x7FLL) + 3304;
    a3 = (float)((float)((*((void *)v6 + 3) - *((void *)v7 + 3)) / 1000000) / 1000.0);
    if (a3 > 0.0001)
    {
      int32x4_t v8 = vsubq_s32(*(int32x4_t *)(v6 + 8), *(int32x4_t *)(v7 + 8));
      v9.i64[0] = v8.u32[0];
      v9.i64[1] = v8.u32[1];
      float64x2_t v10 = vcvtq_f64_u64(v9);
      v9.i64[0] = v8.u32[2];
      v9.i64[1] = v8.u32[3];
      float64x2_t v11 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a3, 0);
      *(float32x4_t *)(a2 + 8) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v10, v11)), vdivq_f64(vcvtq_f64_u64(v9), v11));
      float v12 = 0.0;
      if (v3 != v4)
      {
        float v13 = 0.0;
        do
        {
          uint64_t v14 = (float *)((char *)this + 32 * (v4 & 0x7F) + 3304);
          float v13 = v13 + v14[1];
          float v12 = v12 + (float)*(unsigned int *)v14;
          ++v4;
        }
        while (v3 != v4);
        *(float *)(a2 + 4) = v13;
      }
      *(float *)&a3 = v12 / (float)v5;
      *(_DWORD *)a2 = LODWORD(a3);
    }
  }
  return *(float *)&a3;
}

void re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::~Callable()
{
}

BOOL re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::operator()(uint64_t a1, void *a2)
{
  return *a2 == *(void *)(a1 + 8);
}

void *re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD35790;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD35790;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Session::findBacklogItemWithConnectionHandle(unsigned long long,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::size()
{
  return 16;
}

uint64_t (***re::FunctionBase<24ul,BOOL ()(re::Session::BacklogItem const&)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void *re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD357F8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD357F8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16));
    *(_DWORD *)int32x4_t v8 = 136315138;
    *(void *)&unsigned char v8[4] = v4;
    _os_log_impl(&dword_228C70000, v3, OS_LOG_TYPE_DEFAULT, "Discovered new peer: %s", v8, 0xCu);
  }
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)int32x4_t v8 = v5;
  if (v5)
  {
    uint64_t v6 = (void *)(v5 + 8);
    id v7 = (id)(v5 + 8);
    re::Session::addIdentity(v2, (uint64_t *)v8);
  }
  else
  {
    re::Session::addIdentity(v2, (uint64_t *)v8);
  }
}

void *re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *a2 = &unk_26DD357F8;
  a2[1] = v4;
  a2[2] = v3;
  if (v3) {
    id v5 = (id)(v3 + 8);
  }
  return a2;
}

uint64_t re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD357F8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Session::discoveryViewDidJoin(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::size()
{
  return 24;
}

uint64_t (***re::FunctionBase<24ul,void ()(void)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void *re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD35850;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD35850;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::operator()(re *a1)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v2 = (void *)*((void *)a1 + 1);
  uint64_t v3 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (*(uint64_t (**)(void))(**((void **)a1 + 2) + 32))(*((void *)a1 + 2));
    *(_DWORD *)sockaddr buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl(&dword_228C70000, v3, OS_LOG_TYPE_DEFAULT, "Lost peer: %s", buf, 0xCu);
  }
  uint64_t v5 = *((void *)a1 + 2);
  uint64_t v23 = v5;
  if (v5)
  {
    id v6 = (id)(v5 + 8);
    unint64_t v31 = 0;
    uint64_t v34 = re::globalAllocators((re *)(id)(v5 + 8))[2];
    int v35 = 0;
    *(void *)sockaddr buf = &unk_26DD358A8;
    *(void *)&_DWORD buf[8] = v5;
    id v7 = (id)(v5 + 8);
    int v35 = buf;
    uint64_t BacklogItem = (unint64_t *)re::Session::findBacklogItem((uint64_t)v2, (uint64_t)buf, &v31);
    re::FunctionBase<24ul,BOOL ()(re::Session::BacklogItem const&)>::destroyCallable((uint64_t)buf);

    if (BacklogItem)
    {
      unint64_t v9 = *BacklogItem;
      re::DynamicArray<re::Session::BacklogItem>::removeAt((uint64_t)(v2 + 393), v31);
      if (v9)
      {
        float64x2_t v11 = *re::networkLogObjects(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          re::Transport::connectionAddress((re::Transport *)(v2 + 290), v9, (re::DynamicString *)&v27);
          if (v28) {
            float v12 = v30;
          }
          else {
            float v12 = v29;
          }
          uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
          (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v5 + 40))(&v24, v5);
          if (v25) {
            uint64_t v14 = *(unsigned char **)&v26[7];
          }
          else {
            uint64_t v14 = v26;
          }
          *(_DWORD *)sockaddr buf = 136315650;
          *(void *)&uint8_t buf[4] = v12;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v13;
          __int16 v33 = 2080;
          uint64_t v34 = (uint64_t)v14;
          _os_log_impl(&dword_228C70000, v11, OS_LOG_TYPE_DEFAULT, "Dropping pending connection %s. because its identity '%s (%s)' left.", buf, 0x20u);
          if (v24 && (v25 & 1) != 0) {
            (*(void (**)(void))(*(void *)v24 + 40))();
          }
          if (v27 && (v28 & 1) != 0) {
            (*(void (**)(void))(*(void *)v27 + 40))();
          }
        }
        re::Transport::disconnect((re::Transport *)(v2 + 290), v9, 1);
        re::Session::removePendingPeerHelloForConnection((uint64_t)v2, v9);
      }
    }
    re::Session::findParticipantWithIdentity(v2, &v23, &v24);
    if (v24)
    {
      uint64_t v16 = *re::networkLogObjects(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = (*(unsigned char *)(v24 + 48) & 1) != 0 ? *(void *)(v24 + 56) : v24 + 49;
        uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 32))(v23);
        (*(void (**)(uint64_t *__return_ptr))(*(void *)v23 + 40))(&v27);
        __int16 v19 = (v28 & 1) != 0 ? v30 : v29;
        *(_DWORD *)sockaddr buf = 136315650;
        *(void *)&uint8_t buf[4] = v17;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v18;
        __int16 v33 = 2080;
        uint64_t v34 = (uint64_t)v19;
        _os_log_impl(&dword_228C70000, v16, OS_LOG_TYPE_DEFAULT, "Deleting participant '%s' for identity '%s (%s)'.", buf, 0x20u);
        if (v27)
        {
          if (v28) {
            (*(void (**)(void))(*(void *)v27 + 40))();
          }
        }
      }
      unint64_t v20 = *(void *)(v24 + 32);
      *(void *)sockaddr buf = v24;
      __int16 v21 = (void *)(v24 + 8);
      id v22 = (id)(v24 + 8);
      re::Session::removeParticipant((uint64_t)v2, (uint64_t *)buf);

      re::Transport::disconnect((re::Transport *)(v2 + 290), v20, 1);
      re::Session::removePendingPeerHelloForConnection((uint64_t)v2, v20);
      if (v24) {
    }
      }
    if (v23) {
  }
    }
}

void *re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *a2 = &unk_26DD35850;
  a2[1] = v4;
  a2[2] = v3;
  if (v3) {
    id v5 = (id)(v3 + 8);
  }
  return a2;
}

uint64_t re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD35850;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Session::discoveryViewDidLeave(re::DiscoveryView *,re::SharedPtr<re::DiscoveryIdentity>)::$_0,void ()(void)>::size()
{
  return 24;
}

void *re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::~Callable(void *a1)
{
  *a1 = &unk_26DD358A8;
  uint64_t v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::~Callable(void *a1)
{
  *a1 = &unk_26DD358A8;
  uint64_t v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

BOOL re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16) == *(void *)(a1 + 8);
}

void *re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_26DD358A8;
  a2[1] = v3;
  if (v3) {
    id v4 = (id)(v3 + 8);
  }
  return a2;
}

void *re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_26DD358A8;
  a2[1] = v3;
  if (v3) {
    id v4 = (id)(v3 + 8);
  }
  return a2;
}

uint64_t re::internal::Callable<re::Session::findBacklogItemWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&,unsigned long *)::{lambda(re::Session::BacklogItem const&)#1},BOOL ()(re::Session::BacklogItem const&)>::size()
{
  return 16;
}

void *re::Session::findParticipant<re::Session::findParticipantWithIdentity(re::SharedPtr<re::DiscoveryIdentity> const&)::{lambda(re::SessionParticipant const*)#1}>@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = result[287];
  if (v3)
  {
    id v4 = (uint64_t *)result[289];
    uint64_t v5 = 8 * v3;
    while (1)
    {
      uint64_t v6 = *v4;
      if (*(void *)(*v4 + 152) == *a2) {
        break;
      }
      ++v4;
      v5 -= 8;
      if (!v5) {
        goto LABEL_5;
      }
    }
    *a3 = v6;
    return (id)(v6 + 8);
  }
  else
  {
LABEL_5:
    *a3 = 0;
  }
  return result;
}

uint64_t re::Event<re::Session>::~Event(uint64_t a1)
{
  if (*(void *)a1) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(a1);
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    if (*(void *)(a1 + 72)) {
      (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    }
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
    ++*(_DWORD *)(a1 + 64);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(a1);
  return a1;
}

double re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::addSubscription(_anonymous_namespace_ *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)a1, (void *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (*((_DWORD *)a1 + 20))
    {
      v6[0] = 1;
      long long v5 = *(_OWORD *)(a2 + 16);
      long long v7 = *(_OWORD *)a2;
      long long v8 = v5;
      *(void *)&double result = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)a1 + 40, (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(void *)&double result = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(a1, a2).n128_u64[0];
    }
  }
  return result;
}

__n128 re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v11 = *(void *)(a1 + 32) + 40 * v5;
  __n128 result = *(__n128 *)a2;
  long long v13 = *(_OWORD *)(a2 + 16);
  *(void *)(v11 + 32) = *(void *)(a2 + 32);
  *(__n128 *)uint64_t v11 = result;
  *(_OWORD *)(v11 + 16) = v13;
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::createSubscription<re::Session>(re::Session *,REEventHandlerResult (re::Session::*)(re::DiscoveryView*,re::SharedPtr<re::DiscoveryIdentity>))::{lambda(re::DiscoveryView*,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription const&,re::SharedPtr<re::DiscoveryIdentity>&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t *a3)
{
  unint64_t v5 = (uint64_t (*)(void *, uint64_t, uint64_t *))a2[1];
  uint64_t v4 = a2[2];
  unint64_t v6 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    unint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t *))(*v6 + v5);
  }
  uint64_t v7 = *a3;
  uint64_t v11 = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  uint64_t v9 = v5(v6, a1, &v11);
  if (v11) {

  }
  return v9;
}

re::RoutingTable *re::make::shared::object<re::RoutingTable>@<X0>(re *a1@<X0>, re::RoutingTable **a2@<X8>)
{
  uint64_t v3 = re::globalAllocators(a1);
  uint64_t v4 = (re::RoutingTable *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 128, 8);
  __n128 result = re::RoutingTable::RoutingTable(v4);
  *a2 = result;
  return result;
}

uint64_t re::DynamicArray<re::Event<re::Session,unsigned long long,re::SessionError>::Subscription>::indexOf(uint64_t result, uint64_t a2, char *a3, void *a4)
{
  uint64_t v4 = a3;
  if (a2)
  {
    uint64_t v5 = 32 * a2;
    uint64_t v4 = a3;
    while (*(void *)v4 != *a4 || *((void *)v4 + 1) != a4[1] || *((void *)v4 + 2) != a4[2])
    {
      v4 += 32;
      v5 -= 32;
      if (!v5)
      {
        uint64_t v4 = &a3[32 * a2];
        break;
      }
    }
  }
  uint64_t v7 = (v4 - a3) >> 5;
  if (v7 == a2)
  {
    char v8 = 0;
  }
  else
  {
    *(void *)(result + 8) = v7;
    char v8 = 1;
  }
  *(unsigned char *)__n128 result = v8;
  return result;
}

__n128 re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, __n128 *a4)
{
  uint64_t v7 = *(unsigned int *)(a1 + 36);
  if (v7 == 0x7FFFFFFF)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 32);
    int v8 = v7;
    if (v7 == *(_DWORD *)(a1 + 24))
    {
      int v9 = *(_DWORD *)(a1 + 28);
      signed int v10 = 2 * v9;
      uint64_t v11 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v10) {
          BOOL v12 = v7 == v10;
        }
        else {
          BOOL v12 = 1;
        }
        if (!v12 && (v9 & 0x80000000) == 0)
        {
          memset(v24, 0, 36);
          *(void *)&v24[36] = 0x7FFFFFFFLL;
          re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::init((uint64_t)v24, v11, v10);
          long long v13 = *(_OWORD *)v24;
          *(_OWORD *)uint64_t v24 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v13;
          uint64_t v14 = *(void *)&v24[16];
          uint64_t v15 = *(void *)(a1 + 16);
          *(void *)&v24[16] = v15;
          *(void *)(a1 + 16) = v14;
          long long v17 = *(_OWORD *)&v24[24];
          *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
          unsigned int v16 = *(_DWORD *)&v24[32];
          *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v17;
          uint64_t v18 = v16;
          if (v16)
          {
            uint64_t v19 = v15 + 16;
            do
            {
              if ((*(_DWORD *)(v19 - 8) & 0x80000000) != 0) {
                re::HashSetBase<re::Pair<unsigned long long,unsigned long long,true>,re::Pair<unsigned long long,unsigned long long,true>,re::internal::ValueAsKey<re::Pair<unsigned long long,unsigned long long,true>>,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::addAsMove(a1, *(void *)(v19 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v19 - 16), v19);
              }
              v19 += 32;
              --v18;
            }
            while (v18);
          }
          re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v24);
        }
      }
      else
      {
        if (v10) {
          signed int v22 = v10;
        }
        else {
          signed int v22 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    uint64_t v20 = *(void *)(a1 + 16);
    int v21 = *(_DWORD *)(v20 + 32 * v7 + 8);
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 16);
    int v21 = *(_DWORD *)(v20 + 32 * v7 + 8);
    *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v20 + 32 * v7 + 8) = v21 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v7 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v7 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v7) = a3;
  __n128 result = *a4;
  *(__n128 *)(*(void *)(a1 + 16) + 32 * v7 + 16) = *a4;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v7;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

void *re::DynamicArray<re::Session::BacklogItem>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::Session::BacklogItem>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x50uLL))
        {
          uint64_t v2 = 80 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = 0;
        uint64_t v11 = 80 * v9;
        do
        {
          BOOL v12 = &v7[v10 / 8];
          uint64_t v13 = v8 + v10;
          *(_OWORD *)BOOL v12 = *(_OWORD *)(v8 + v10);
          void v12[2] = *(void *)(v8 + v10 + 16);
          *(void *)(v13 + 16) = 0;
          *(_OWORD *)(v12 + 3) = *(_OWORD *)(v8 + v10 + 24);
          v12[9] = 0;
          v12[6] = 0;
          v12[7] = 0;
          _OWORD v12[5] = 0;
          *((_DWORD *)v12 + 16) = 0;
          uint64_t v14 = (void *)(v8 + v10 + 40);
          uint64_t v15 = *(void *)(v8 + v10 + 48);
          _OWORD v12[5] = *v14;
          void *v14 = 0;
          v12[6] = v15;
          *(void *)(v13 + 48) = 0;
          uint64_t v16 = v7[v10 / 8 + 7];
          v12[7] = *(void *)(v8 + v10 + 56);
          *(void *)(v13 + 56) = v16;
          uint64_t v17 = v7[v10 / 8 + 9];
          v12[9] = *(void *)(v8 + v10 + 72);
          *(void *)(v13 + 72) = v17;
          *(_DWORD *)(v13 + 64) = *(_DWORD *)(v8 + v10 + 64) + 1;
          *((_DWORD *)v12 + 16) = LODWORD(v7[v10 / 8 + 8]) + 1;
          re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v14);
          uint64_t v18 = *(void *)(v8 + v10 + 16);
          if (v18)
          {

            *(void *)(v13 + 16) = 0;
          }
          v10 += 80;
        }
        while (v11 != v10);
        uint64_t v8 = v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

void re::StaticPacketBitWriter::~StaticPacketBitWriter(re::StaticPacketBitWriter *this)
{
  if (*((void *)this + 6))
  {
    (*(void (**)(void))(**((void **)this + 5) + 40))(*((void *)this + 5));
    *((void *)this + 6) = 0;
  }
}

{
  uint64_t vars8;

  if (*((void *)this + 6))
  {
    (*(void (**)(void))(**((void **)this + 5) + 40))(*((void *)this + 5));
    *((void *)this + 6) = 0;
  }
  JUMPOUT(0x22A6A9430);
}

uint64_t re::StaticPacketBitWriter::grow(uint64_t this)
{
  if (!*(void *)(this + 48))
  {
    uint64_t v1 = this;
    this = (*(uint64_t (**)(void, void))(**(void **)(this + 40) + 32))(*(void *)(this + 40), *(unsigned int *)(this + 56));
    *(void *)(v1 + 48) = this;
    *(void *)(v1 + 8) = *(void *)(this + 16);
    *(_DWORD *)(v1 + 16) = *(_DWORD *)(v1 + 56);
  }
  return this;
}

void re::SyncSnapshotDump::log(NSObject *a1, char *a2, uint64_t *a3, uint64_t a4, const char *a5)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  uint64_t v5 = *a3;
  if (*a3)
  {
    id v10 = (id)(v5 + 8);
    uint64_t v11 = *(void *)(v5 + 80);
    uint64_t v12 = *(void *)(*(void *)(v5 + 88) + 16);
    uint64_t v13 = *(void *)(v12 + 48);
    uint64_t v14 = *(void *)(v12 + 56);
    uint64_t v15 = v12 + 49;
    if (v13) {
      uint64_t v16 = v14;
    }
    else {
      uint64_t v16 = v15;
    }
    BOOL v17 = os_log_type_enabled(a1, OS_LOG_TYPE_DEBUG);
    if (v11)
    {
      if (v17)
      {
        uint64_t v18 = *(void *)(v5 + 24);
        int v19 = *(unsigned __int16 *)(v5 + 176);
        uint64_t v20 = *(const char **)(v11 + 24);
        char v21 = *((unsigned char *)a3 + 16);
        signed int v22 = "(new)";
        if ((v21 & 1) == 0) {
          signed int v22 = (const char *)&unk_228CE091E;
        }
        uint64_t v23 = "(data)";
        char v24 = *a2;
        if ((a3[2] & 8) == 0) {
          uint64_t v23 = (const char *)&unk_228CE091E;
        }
        int v25 = a2[28];
        unint64_t v26 = "(destroyed)";
        uint64_t v27 = *((void *)a2 + 1);
        if ((a3[2] & 2) == 0) {
          unint64_t v26 = (const char *)&unk_228CE091E;
        }
        int v50 = 136318210;
        if ((v21 & 4) != 0) {
          char v28 = "(ownerChange)";
        }
        else {
          char v28 = (const char *)&unk_228CE091E;
        }
        uint64_t v51 = v16;
        __int16 v52 = 2048;
        uint64_t v53 = v18;
        if (a5) {
          uint64_t v29 = a5;
        }
        else {
          uint64_t v29 = "Commit";
        }
        __int16 v54 = 1024;
        int v55 = v19;
        if (v24) {
          uint64_t v30 = "(Atomic)";
        }
        else {
          uint64_t v30 = (const char *)&unk_228CE091E;
        }
        __int16 v56 = 2048;
        unint64_t v57 = v20;
        __int16 v58 = 2080;
        if ((v24 & 2) != 0) {
          unint64_t v31 = "(Held)";
        }
        else {
          unint64_t v31 = (const char *)&unk_228CE091E;
        }
        unint64_t v59 = v22;
        uint64_t v32 = "(Fwd)";
        __int16 v60 = 2080;
        if (!v25) {
          uint64_t v32 = (const char *)&unk_228CE091E;
        }
        unint64_t v61 = v23;
        __int16 v62 = 2080;
        char v63 = v26;
        __int16 v64 = 2080;
        uint64_t v65 = v28;
        __int16 v66 = 2080;
        id v67 = v29;
        __int16 v68 = 2080;
        uint64_t v69 = v30;
        __int16 v70 = 2080;
        uint64_t v71 = v31;
        __int16 v72 = 2080;
        size_t v73 = v32;
        __int16 v74 = 2048;
        uint64_t v75 = v27;
        __int16 v33 = "\t%s Id=%llu(v#%u) Parent=%llu %s%s%s%s \t%s %s%s%s Peer=%llu";
        uint64_t v34 = a1;
        uint32_t v35 = 128;
LABEL_50:
        _os_log_debug_impl(&dword_228C70000, v34, OS_LOG_TYPE_DEBUG, v33, (uint8_t *)&v50, v35);
      }
    }
    else if (v17)
    {
      uint64_t v36 = *(void *)(v5 + 24);
      int v37 = *(unsigned __int16 *)(v5 + 176);
      char v38 = *((unsigned char *)a3 + 16);
      uint64_t v39 = "(new)";
      uint64_t v40 = (const char *)&unk_228CE091E;
      if ((v38 & 1) == 0) {
        uint64_t v39 = (const char *)&unk_228CE091E;
      }
      char v41 = *a2;
      uint64_t v42 = "(data)";
      int v43 = a2[28];
      if ((a3[2] & 8) == 0) {
        uint64_t v42 = (const char *)&unk_228CE091E;
      }
      uint64_t v44 = (const char *)*((void *)a2 + 1);
      uint64_t v45 = "(destroyed)";
      if ((a3[2] & 2) == 0) {
        uint64_t v45 = (const char *)&unk_228CE091E;
      }
      int v50 = 136317954;
      uint64_t v46 = "(ownerChange)";
      uint64_t v51 = v16;
      __int16 v52 = 2048;
      if ((v38 & 4) == 0) {
        uint64_t v46 = (const char *)&unk_228CE091E;
      }
      uint64_t v53 = v36;
      uint64_t v47 = "Commit";
      __int16 v54 = 1024;
      if (a5) {
        uint64_t v47 = a5;
      }
      int v55 = v37;
      __int16 v56 = 2080;
      unint64_t v57 = v39;
      if (v41) {
        uint64_t v48 = "(Atomic)";
      }
      else {
        uint64_t v48 = (const char *)&unk_228CE091E;
      }
      __int16 v58 = 2080;
      unint64_t v59 = v42;
      if ((v41 & 2) != 0) {
        uint64_t v49 = "(Held)";
      }
      else {
        uint64_t v49 = (const char *)&unk_228CE091E;
      }
      __int16 v60 = 2080;
      unint64_t v61 = v45;
      if (v43) {
        uint64_t v40 = "(Fwd)";
      }
      __int16 v62 = 2080;
      char v63 = v46;
      __int16 v64 = 2080;
      uint64_t v65 = v47;
      __int16 v66 = 2080;
      id v67 = v48;
      __int16 v68 = 2080;
      uint64_t v69 = v49;
      __int16 v70 = 2080;
      uint64_t v71 = v40;
      __int16 v72 = 2048;
      size_t v73 = v44;
      __int16 v33 = "\t%s Id=%llu(v#%u) %s%s%s%s \t%s %s%s%s Peer=%llu";
      uint64_t v34 = a1;
      uint32_t v35 = 118;
      goto LABEL_50;
    }
  }
}

uint64_t re::SyncSnapshotDump::log(NSObject *a1, uint64_t a2, const char *a3)
{
  re::DynamicArray<re::internal::SyncSnapshotEntry>::DynamicArray((uint64_t)v10, (uint64_t *)(a2 + 32));
  if (v11)
  {
    for (unint64_t i = 0; i < v11; ++i)
    {
      uint64_t v7 = (uint64_t *)re::SyncSnapshot::readAt((re::SyncSnapshot *)v10, i);
      re::SyncSnapshotDump::log(a1, (char *)a2, v7, v8, a3);
    }
  }
  return re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v10);
}

uint64_t re::SyncSelectiveAckedUnicast::SyncSelectiveAckedUnicast(uint64_t a1, id *a2, id *a3, uint64_t a4, uint64_t a5, uint64_t a6, id *a7, char a8, char a9, char a10, int a11)
{
  uint64_t v77 = a4;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)a1 = &unk_26DD35950;
  *(void *)(v19 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  objc_copyWeak((id *)(v19 + 24), a2);
  *(_OWORD *)(a1 + 32) = 0u;
  __int16 v74 = (id *)(a1 + 32);
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 64) = 0;
  re::make::shared::object<re::SyncObjectShortIDManagerImpl>(v20, (re::SyncObjectShortIDManagerImpl **)&to);
  *(void *)(a1 + 72) = to;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 80) = a5;
  *(void *)(a1 + 88) = a6;
  objc_copyWeak((id *)(a1 + 96), a7);
  *(unsigned char *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = a8;
  *(unsigned char *)(a1 + 105) = a9;
  *(void *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = a5;
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 148) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 168) = 0;
  *(void *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(void *)(a1 + 228) = 0x7FFFFFFFLL;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 2re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  signed int v22 = re::globalAllocators(v21);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22[2] + 32))(v22[2], 208, 8);
  id to = 0;
  objc_copyWeak(&to, a3);
  re::UnreliableAckedUnicastStream::UnreliableAckedUnicastStream(v23, &to, a4, 1, 4, 0);
  objc_destroyWeak(&to);
  if (*a3) {
    char v24 = (re::Transport *)((char *)*a3 - 8);
  }
  else {
    char v24 = 0;
  }
  id WeakRetained = (char *)objc_loadWeakRetained(a2);
  if (WeakRetained) {
    unint64_t v26 = WeakRetained - 8;
  }
  else {
    unint64_t v26 = 0;
  }
  (*(void (**)(id *__return_ptr, char *))(*(void *)v26 + 32))(&to, v26);
  BOOL v27 = re::Transport::registerStream(v24, (re::TransportStream *)v23, 4uLL, a4);
  if (to)
  {

    id to = 0;
  }

  if (v27)
  {
    uint64_t v28 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = v23;
    uint64_t v23 = v28;
  }
  LODWORD(location) = 0;
  char v76 = 1;
  unsigned int v75 = 5;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},decltype(nullptr)>((re *)&to, a3, &v77, (int *)&location, &v76, &v75);
  uint64_t v29 = (char *)to;
  if (*a3) {
    uint64_t v30 = (re::Transport *)((char *)*a3 - 8);
  }
  else {
    uint64_t v30 = 0;
  }
  uint64_t v31 = v77;
  uint64_t v32 = (char *)objc_loadWeakRetained(a2);
  if (v32) {
    __int16 v33 = v32 - 8;
  }
  else {
    __int16 v33 = 0;
  }
  (*(void (**)(id *__return_ptr, char *))(*(void *)v33 + 32))(&to, v33);
  BOOL v34 = re::Transport::registerStream(v30, (re::TransportStream *)v29, 5uLL, v31);
  if (to)
  {

    id to = 0;
  }

  if (v34)
  {
    uint64_t v36 = *(char **)(a1 + 48);
    *(void *)(a1 + 48) = v29;
    uint64_t v29 = v36;
  }
  if (a10)
  {
    re::make::shared::object<re::SyncAckedStateBuffer>(v35, (uint64_t *)&to);
    int v37 = (char *)*v74;
    id *v74 = to;
    id to = v37;
    if (v37) {

    }
    LODWORD(location) = 0;
    char v76 = 1;
    unsigned int v75 = 3;
    re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},decltype(nullptr)>((re *)&to, a3, &v77, (int *)&location, &v76, &v75);
    char v38 = (char *)to;
    if (*a3) {
      uint64_t v39 = (re::Transport *)((char *)*a3 - 8);
    }
    else {
      uint64_t v39 = 0;
    }
    uint64_t v40 = v77;
    char v41 = (char *)objc_loadWeakRetained(a2);
    if (v41) {
      uint64_t v42 = v41 - 8;
    }
    else {
      uint64_t v42 = 0;
    }
    (*(void (**)(id *__return_ptr, char *))(*(void *)v42 + 32))(&to, v42);
    BOOL v43 = re::Transport::registerStream(v39, (re::TransportStream *)v38, 3uLL, v40);
    if (to)
    {

      id to = 0;
    }

    if (v43)
    {
      uint64_t v45 = re::globalAllocators(v44);
      uint64_t v46 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v45[2] + 32))(v45[2], 32, 8);
      ArcSharedObject::ArcSharedObject(v46, 0);
      *((void *)v46 + 3) = v38;
      *(void *)uint64_t v46 = &unk_26DD35A90;
      if (v38)
      {
        uint64_t v47 = v38 + 8;
        id v48 = v47;
      }
      char v38 = *(char **)(a1 + 40);
      *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v46;
    }
    if (v38) {
  }
    }
  LODWORD(location) = 0;
  char v76 = 1;
  unsigned int v75 = 2;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},decltype(nullptr)>((re *)&to, a3, &v77, (int *)&location, &v76, &v75);
  uint64_t v49 = (char *)to;
  if (*a3) {
    int v50 = (re::Transport *)((char *)*a3 - 8);
  }
  else {
    int v50 = 0;
  }
  uint64_t v51 = v77;
  __int16 v52 = (char *)objc_loadWeakRetained(a2);
  if (v52) {
    uint64_t v53 = v52 - 8;
  }
  else {
    uint64_t v53 = 0;
  }
  (*(void (**)(id *__return_ptr, char *))(*(void *)v53 + 32))(&to, v53);
  BOOL v54 = re::Transport::registerStream(v50, (re::TransportStream *)v49, 2uLL, v51);
  if (to)
  {

    id to = 0;
  }

  if (v54)
  {
    __int16 v56 = re::globalAllocators(v55);
    unint64_t v57 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v56[2] + 32))(v56[2], 32, 8);
    id to = v49;
    int v55 = re::MessageStreamer<re::SyncOwnershipRequest>::MessageStreamer(v57, (uint64_t *)&to);
    if (to) {

    }
    uint64_t v58 = *(void *)(a1 + 64);
    *(void *)(a1 + 64) = v57;
    if (v58) {

    }
    uint64_t v49 = 0;
  }
  uint64_t v59 = *(void *)(a1 + 72);
  uint64_t v60 = *(void *)(a1 + 32);
  if (*a3) {
    uint64_t v61 = (uint64_t)*a3 - 8;
  }
  else {
    uint64_t v61 = 0;
  }
  uint64_t v62 = *(void *)(v61 + 568);
  char v63 = re::globalAllocators(v55);
  uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v63[2] + 32))(v63[2], 312, 8);
  if (v59) {
    uint64_t v65 = (void *)(v59 + 8);
  }
  else {
    uint64_t v65 = 0;
  }
  objc_initWeak(&to, v65);
  if (v60) {
    __int16 v66 = (void *)(v60 + 8);
  }
  else {
    __int16 v66 = 0;
  }
  objc_initWeak(&location, v66);
  re::SyncSendBuffer::SyncSendBuffer(v64, &to, &location, v62);
  objc_destroyWeak(&location);
  id location = 0;
  objc_destroyWeak(&to);
  uint64_t v67 = *(void *)(a1 + 280);
  *(void *)(a1 + 280) = v64;
  if (v67)
  {

    uint64_t v64 = *(void *)(a1 + 280);
  }
  *(void *)(v64 + 216) = *(void *)(a1 + 80);
  *(_DWORD *)(v64 + re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 304) = a11;
  id to = 0;
  uint64_t v68 = v77;
  if (*a3) {
    uint64_t v69 = (uint64_t)*a3 - 8;
  }
  else {
    uint64_t v69 = 0;
  }
  if (re::Transport::receive(v69, v77, 1u, (uint64_t *)&to))
  {
    do
    {
      if (*a3) {
        __int16 v70 = (re::Transport *)((char *)*a3 - 8);
      }
      else {
        __int16 v70 = 0;
      }
      if (re::Transport::dispatchPacketToStream(v70, (re::Packet *)to, v68))
      {
        if (*a3) {
          uint64_t v71 = (uint64_t)*a3 - 8;
        }
        else {
          uint64_t v71 = 0;
        }
        re::PacketPool::free(*(re::PacketPool **)(v71 + 384), (re::Packet *)to);
      }
      if (*a3) {
        uint64_t v72 = (uint64_t)*a3 - 8;
      }
      else {
        uint64_t v72 = 0;
      }
    }
    while (re::Transport::receive(v72, v68, 1u, (uint64_t *)&to));
  }
  if (v49) {

  }
  if (v29) {
  if (v23)
  }

  return a1;
}

void re::SyncSelectiveAckedUnicast::send(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v97 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 48) && (uint64_t v6 = *(void *)(a1 + 56)) != 0 && *(void *)(a1 + 72))
  {
    *(void *)(a1 + 112) = 0;
    uint64_t v11 = *(void *)(v6 + 32);
    if (v11) {
      uint64_t v12 = v11 - 8;
    }
    else {
      uint64_t v12 = 0;
    }
    unsigned int v13 = *(_DWORD *)(v12 + 512);
    if (v13 >= 0x10000) {
      unsigned int v13 = 0x10000;
    }
    int v47 = 0;
    char v48 = 0;
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    uint64_t v45 = &unk_26DD35910;
    uint64_t v46 = 0;
    uint64_t v51 = v6;
    uint64_t v52 = 0;
    unsigned int v53 = v13;
    uint64_t v44 = 0;
    v41[1] = 0;
    uint64_t v42 = 0;
    v41[0] = 0;
    int v43 = 0;
    __int16 v14 = *(_WORD *)(a1 + 104);
    uint64_t v55 = a4;
    uint64_t v58 = *(void *)(a4 + 56);
    uint64_t v62 = 0;
    long long v59 = 0u;
    long long v60 = 0u;
    int v61 = 0;
    uint64_t v65 = v58;
    uint64_t v69 = 0;
    long long v66 = 0u;
    long long v67 = 0u;
    int v68 = 0;
    uint64_t v72 = v58;
    uint64_t v76 = 0;
    long long v73 = 0u;
    long long v74 = 0u;
    int v75 = 0;
    uint64_t v79 = v58;
    uint64_t v83 = 0;
    int v82 = 0;
    long long v80 = 0u;
    long long v81 = 0u;
    char v84 = 0;
    uint64_t v85 = v58;
    uint64_t v86 = 0;
    int v87 = 0;
    char v88 = 0;
    uint64_t v93 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    int v92 = 0;
    uint64_t v91 = 0;
    *(_WORD *)sockaddr buf = v14;
    char v57 = 1;
    int v56 = 1;
    char v64 = 0;
    int v63 = 2;
    char v78 = 0;
    int v77 = 2;
    char v71 = 0;
    int v70 = 0;
    re::SyncCommitBuilder::begin((re::SyncCommitBuilder *)buf);
    uint64_t v15 = *(unsigned int *)(a4 + 96);
    if (v15)
    {
      uint64_t v16 = 0;
      BOOL v17 = (int *)(*(void *)(a4 + 80) + 8);
      while (1)
      {
        int v18 = *v17;
        v17 += 8;
        if (v18 < 0) {
          break;
        }
        if (v15 == ++v16)
        {
          LODWORD(v16) = *(_DWORD *)(a4 + 96);
          break;
        }
      }
    }
    else
    {
      LODWORD(v16) = 0;
    }
    if (v15 != v16)
    {
      uint64_t v23 = v16;
      do
      {
        uint64_t v24 = *(void *)(a4 + 80) + 32 * v23;
        int v25 = (re::SyncObject **)(v24 + 16);
        int v26 = *(_DWORD *)(v24 + 24);
        if (re::SyncCommitBuilder::shouldForward(buf, (uint64_t *)(v24 + 16)))
        {
          if (v26) {
            re::SyncCommitBuilder::buildViewRemoval((uint64_t)buf, v25);
          }
          else {
            re::SyncCommitBuilder::buildViewAdd((uint64_t)buf, v25);
          }
        }
        if (*(_DWORD *)(a4 + 96) <= (v16 + 1)) {
          int v27 = v16 + 1;
        }
        else {
          int v27 = *(_DWORD *)(a4 + 96);
        }
        while (1)
        {
          uint64_t v23 = (v16 + 1);
          if (v27 - 1 == v16) {
            break;
          }
          LODWORD(v16) = v16 + 1;
          int v28 = v23;
          if ((*(_DWORD *)(*(void *)(a4 + 80) + 32 * v23 + 8) & 0x80000000) != 0) {
            goto LABEL_34;
          }
        }
        int v28 = v27;
LABEL_34:
        LODWORD(v16) = v28;
      }
      while (v15 != v28);
    }
    uint64_t v29 = a2[1];
    if (v29)
    {
      uint64_t v30 = *a2;
      uint64_t v31 = 72 * v29;
      do
      {
        re::SyncCommitBuilder::buildUpdate((uint64_t)buf, v30);
        v30 += 72;
        v31 -= 72;
      }
      while (v31);
    }
    re::SyncCommitBuilder::buildOwnershipChanges((uint64_t)buf, *(re::SyncObject ***)a3, *(void *)(a3 + 8));
    re::SyncCommitBuilder::end(buf, (_anonymous_namespace_ *)v41);
    re::SyncCommitBuilder::~SyncCommitBuilder((re::SyncCommitBuilder *)buf);
    __int16 v33 = v44;
    if (v42)
    {
      uint64_t v34 = 72 * v42;
      do
      {
        re::SyncSelectiveAckedUnicast::sendCommit((void *)a1, v33, (uint64_t)&v45, a5);
        v33 += 72;
        v34 -= 72;
      }
      while (v34);
      __int16 v33 = v44;
      uint64_t v35 = v42;
    }
    else
    {
      uint64_t v35 = 0;
    }
    uint64_t v36 = *(void *)(a1 + 280);
    int v37 = (unsigned __int16 *)(*(void *)(a1 + 56) + 152);
    uint64_t v95 = re::globalAllocators(v32)[2];
    char v38 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v95 + 32))(v95, 32, 0);
    *char v38 = &unk_26DD359E0;
    v38[1] = a1;
    v38[2] = &v45;
    v38[3] = a5;
    uint64_t v96 = v38;
    re::SyncSendBuffer::resend(v36, (uint64_t)v33, v35, v37, (uint64_t)v94);
    if (v96)
    {
      (**(void (***)(unsigned char *))v96)(v96);
      if (v96 != v94) {
        (*(void (**)(uint64_t))(*(void *)v95 + 40))(v95);
      }
      uint64_t v96 = 0;
    }
    int v39 = v49;
    if (HIDWORD(v49)) {
      int v39 = v49 + 1;
    }
    if (v39)
    {
      uint64_t v40 = *(void *)(a1 + 56);
      *(_DWORD *)(v52 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v39;
      uint64_t v49 = 0;
      uint64_t v50 = 0;
      uint64_t v46 = 0;
      int v47 = 0;
      uint64_t v52 = 0;
      (*(void (**)(uint64_t))(*(void *)v40 + 48))(v40);
    }
    re::UnreliableAckedUnicastStream::update(*(re::UnreliableAckedUnicastStream **)(a1 + 56));
    re::DynamicArray<re::SyncCommit>::deinit((uint64_t)v41);
    if (v52) {
      (*(void (**)(uint64_t))(*(void *)v51 + 40))(v51);
    }
  }
  else
  {
    id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 24));
    if (WeakRetained) {
      uint64_t v20 = WeakRetained - 8;
    }
    else {
      uint64_t v20 = 0;
    }
    char v21 = v20 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v20 + 32))(buf);
    signed int v22 = *(NSObject **)(*(void *)buf + 3272);

    *(void *)sockaddr buf = 0;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      _os_log_error_impl(&dword_228C70000, v22, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to send.", buf, 2u);
    }
  }
}

void re::SyncSelectiveAckedUnicast::sendCommit(void *a1, char *a2, uint64_t a3, uint64_t a4)
{
  if (*a2 < 0) {
    uint64_t v8 = "ReSendCommit";
  }
  else {
    uint64_t v8 = "SendCommit";
  }
  re::SyncCommitDump::log((re *)a2, 1, v8);
  if (*a2)
  {
    re::SyncSelectiveAckedUnicast::sendCommitReliable(a1, (uint64_t)a2, a4);
  }
  else
  {
    uint64_t v9 = a1[4];
    v19[0] = a1[9];
    v19[1] = v9;
    char v20 = 1;
    if (*((void *)a2 + 6))
    {
      unint64_t v10 = 0;
      do
      {
        uint64_t v11 = re::SyncPacker::packCommit(v19, (unsigned __int8 *)a2, (re::BitWriter *)a3, a4, v10);
        uint64_t v13 = a1[14] + v11;
        a1[14] = v13;
        if (v13)
        {
          uint64_t v14 = v11;
          re::SyncSendBuffer::objectsSent(a1[35], *((void *)a2 + 8) + 24 * v10, v11, *(unsigned __int16 *)(a1[7] + 192));
          v10 += v14;
          if (v10 < *((void *)a2 + 6))
          {
            uint64_t v15 = a1[7];
            int v16 = *(_DWORD *)(a3 + 24);
            if (*(_DWORD *)(a3 + 28)) {
              ++v16;
            }
            *(_DWORD *)(*(void *)(a3 + 48) + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v16;
            *(void *)(a3 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
            *(void *)(a3 + 32) = 0;
            *(void *)(a3 + 8) = 0;
            *(_DWORD *)(a3 + 16) = 0;
            *(void *)(a3 + 48) = 0;
            (*(void (**)(uint64_t))(*(void *)v15 + 48))(v15);
            a1[14] = 0;
          }
        }
        else
        {
          unint64_t v17 = *((void *)a2 + 6);
          if (v17 <= v10)
          {
            re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size_t size = %zu", "index < size()", "operator[]", 251, v10, v17);
            _os_crash();
            __break(1u);
            return;
          }
          uint64_t v18 = *((void *)a2 + 8);
          uint64_t v30 = 0;
          memset(v28, 0, sizeof(v28));
          int v29 = 0;
          re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v28, (uint64_t *)(v18 + 24 * v10));
          uint64_t v27 = 0;
          memset(v25, 0, sizeof(v25));
          int v26 = 0;
          long long v22 = *(_OWORD *)(a2 + 8);
          int v23 = *((_DWORD *)a2 + 6);
          v21[0] = *a2;
          char v24 = a2[28];
          re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v25, v28);
          re::SyncSelectiveAckedUnicast::sendCommitReliable(a1, (uint64_t)v21, a4);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v25);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v28);
          ++v10;
        }
      }
      while (v10 < *((void *)a2 + 6));
    }
  }
}

uint64_t re::SyncSelectiveAckedUnicast::sendCommitReliable(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[6] + 24;
  int v16 = 0;
  char v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v14 = &unk_26DD352E8;
  uint64_t v15 = 0;
  uint64_t v20 = v5;
  uint64_t v21 = 0;
  v12[0] = a1[9];
  v12[1] = 0;
  char v13 = 0;
  uint64_t result = re::SyncPacker::packCommit(v12, (unsigned __int8 *)a2, (re::BitWriter *)&v14, a3, 0);
  uint64_t v7 = *(void *)(a2 + 48);
  if (v7)
  {
    uint64_t v8 = *(re::SyncObject ***)(a2 + 64);
    uint64_t v9 = 24 * v7;
    do
    {
      uint64_t result = re::SyncSendBuffer::addAck(a1[35], v8);
      v8 += 3;
      v9 -= 24;
    }
    while (v9);
  }
  int v10 = v18;
  if (HIDWORD(v18)) {
    int v10 = v18 + 1;
  }
  if (v10)
  {
    uint64_t v11 = a1[6];
    *(_DWORD *)(v21 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v10;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v15 = 0;
    int v16 = 0;
    uint64_t v21 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 48))(v11);
  }
  if (v21) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v20 + 24))(v20);
  }
  return result;
}

uint64_t re::SyncSelectiveAckedUnicast::receive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v96 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void **)(a1 + 48);
  if (!v5 || !*(void *)(a1 + 56) || !*(void *)(a1 + 72))
  {
    id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 24));
    if (WeakRetained) {
      char v13 = WeakRetained - 8;
    }
    else {
      char v13 = 0;
    }
    uint64_t v14 = v13 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v13 + 32))(buf);
    uint64_t v15 = *(NSObject **)(*(void *)buf + 3272);

    *(void *)sockaddr buf = 0;
    uint64_t result = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)sockaddr buf = 0;
      _os_log_error_impl(&dword_228C70000, v15, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to receive.", buf, 2u);
      return 0;
    }
    return result;
  }
  uint64_t result = re::SyncSelectiveAckedUnicast::receiveFromStream(a1, v5, a2);
  if (!result) {
    return result;
  }
  uint64_t result = re::SyncSelectiveAckedUnicast::receiveFromStream(a1, *(void **)(a1 + 56), a2);
  if (!result) {
    return result;
  }
  buf[0] = 0;
  uint64_t v82 = 0;
  v79[1] = 0;
  uint64_t v80 = 0;
  v79[0] = 0;
  int v81 = 0;
  uint64_t v77 = *(void *)(a1 + 80);
  v78[0] = 0;
  *(void *)((char *)v78 + 5) = 0;
  uint64_t v8 = *(unsigned int *)(a1 + 224);
  if (v8)
  {
    uint64_t v9 = 0;
    int v10 = (int *)(*(void *)(a1 + 208) + 8);
    while (1)
    {
      int v11 = *v10;
      v10 += 18;
      if (v11 < 0) {
        break;
      }
      if (v8 == ++v9)
      {
        LODWORD(v9) = *(_DWORD *)(a1 + 224);
        break;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  uint64_t v73 = a2;
  uint64_t v74 = a3;
  if (v8 != v9)
  {
    BOOL v75 = 0;
    uint64_t v52 = v9;
    while (1)
    {
      uint64_t v53 = *(void *)(a1 + 208);
      uint64_t v54 = v53 + 72 * v52;
      uint64_t v56 = *(void *)(v54 + 32);
      uint64_t v55 = (uint64_t *)(v54 + 32);
      char v57 = (re::SyncObject **)(v55 - 2);
      if (v56)
      {
        uint64_t v58 = v53 + 72 * v52;
        if ((*(unsigned char *)(v58 + 56) & 2) != 0) {
          goto LABEL_88;
        }
        long long v59 = (char *)objc_loadWeakRetained((id *)(a1 + 96));
        long long v60 = v59;
        if (v59) {
          int v61 = (re::SyncObjectStore *)(v59 - 8);
        }
        else {
          int v61 = 0;
        }
        re::SyncObjectStore::findObject(v61, *(v55 - 1), *v55, (re::SyncObjectTypedStore ***)&v85);
        if (v60) {

        }
        uint64_t v62 = v85;
        if (v85)
        {
          if (*((void *)*v57 + 10))
          {
            int v63 = (char *)objc_loadWeakRetained((id *)(a1 + 24));
            if (v63) {
              char v64 = v63 - 8;
            }
            else {
              char v64 = 0;
            }
            uint64_t v65 = v64 + 8;
            (*(void (**)(unsigned char *__return_ptr))(*(void *)v64 + 32))(v91);
            long long v66 = *(NSObject **)(*(void *)v91 + 3272);

            *(void *)uint64_t v91 = 0;
            BOOL v67 = os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT);
            uint64_t v62 = v85;
            if (v67)
            {
              uint64_t v68 = *((void *)*v57 + 3);
              uint64_t v69 = *(void *)(*((void *)*v57 + 10) + 24);
              uint64_t v70 = *((void *)v85 + 3);
              *(_DWORD *)uint64_t v91 = 134218496;
              *(void *)&v91[4] = v68;
              __int16 v92 = 2048;
              uint64_t v93 = v69;
              __int16 v94 = 2048;
              uint64_t v95 = v70;
              _os_log_impl(&dword_228C70000, v66, OS_LOG_TYPE_DEFAULT, "Parent already bound for object: %llu, current parent: %llu, attempted new parent: %llu", v91, 0x20u);
            }
          }
          else
          {
            re::SyncObject::bindWithParent(*v57, v85);
          }
          re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v79, v58 + 40);
          re::DynamicArray<re::SharedPtr<re::SyncObject>>::add((void *)(a1 + 240), (uint64_t *)v57);
          if (v62) {
        }
          }
      }
      else if (*(unsigned char *)(v53 + 72 * v52 + 64) || (*(unsigned char *)(v53 + 72 * v52 + 56) & 1) == 0)
      {
        BOOL v75 = (*(unsigned __int8 *)(v53 + 72 * v52 + 64) | v75) != 0;
        re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v79, v53 + 72 * v52 + 40);
LABEL_88:
        re::DynamicArray<re::SharedPtr<re::SyncObject>>::add((void *)(a1 + 240), v55 - 2);
      }
      if (*(_DWORD *)(a1 + 224) <= (v9 + 1)) {
        int v71 = v9 + 1;
      }
      else {
        int v71 = *(_DWORD *)(a1 + 224);
      }
      while (1)
      {
        uint64_t v52 = (v9 + 1);
        if (v71 - 1 == v9) {
          break;
        }
        LODWORD(v9) = v9 + 1;
        int v72 = v52;
        if ((*(_DWORD *)(*(void *)(a1 + 208) + 72 * v52 + 8) & 0x80000000) != 0) {
          goto LABEL_96;
        }
      }
      int v72 = v71;
LABEL_96:
      LODWORD(v9) = v72;
      if (v8 == v72) {
        goto LABEL_20;
      }
    }
  }
  BOOL v75 = 0;
LABEL_20:
  uint64_t v16 = *(void *)(a1 + 256);
  if (v16)
  {
    char v17 = *(uint64_t **)(a1 + 272);
    uint64_t v18 = &v17[v16];
    do
    {
      if (*(void *)(a1 + 192))
      {
        uint64_t v19 = *v17;
        unint64_t v20 = 0xBF58476D1CE4E5B9 * (*v17 ^ ((unint64_t)*v17 >> 30));
        unint64_t v21 = ((0x94D049BB133111EBLL * (v20 ^ (v20 >> 27))) ^ ((0x94D049BB133111EBLL * (v20 ^ (v20 >> 27))) >> 31))
            % *(unsigned int *)(a1 + 216);
        uint64_t v22 = *(void *)(a1 + 200);
        uint64_t v23 = *(unsigned int *)(v22 + 4 * v21);
        if (v23 != 0x7FFFFFFF)
        {
          uint64_t v24 = *(void *)(a1 + 208);
          if (*(void *)(v24 + 72 * v23 + 16) == v19)
          {
            *(_DWORD *)(v22 + 4 * v21) = *(_DWORD *)(v24 + 72 * v23 + 8) & 0x7FFFFFFF;
LABEL_29:
            re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::EntryWithHash::free(*(void *)(a1 + 208) + 72 * v23);
            *(_DWORD *)(*(void *)(a1 + 208) + 72 * v23 + 8) = *(_DWORD *)(*(void *)(a1 + 208) + 72 * v23 + 8) & 0x80000000 | *(_DWORD *)(a1 + 228);
            --*(_DWORD *)(a1 + 220);
            int v26 = *(_DWORD *)(a1 + 232) + 1;
            *(_DWORD *)(a1 + 228) = v23;
            *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 232) = v26;
          }
          else
          {
            while (1)
            {
              uint64_t v25 = v23;
              uint64_t v23 = *(_DWORD *)(v24 + 72 * v23 + 8) & 0x7FFFFFFF;
              if (v23 == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(v24 + 72 * v23 + 16) == v19)
              {
                *(_DWORD *)(v24 + 72 * v25 + 8) = *(_DWORD *)(v24 + 72 * v25 + 8) & 0x80000000 | *(_DWORD *)(v24 + 72 * v23 + 8) & 0x7FFFFFFF;
                goto LABEL_29;
              }
            }
          }
        }
      }
      ++v17;
    }
    while (v17 != v18);
  }
  if (v80 != 0 && v75) {
    buf[0] |= 1u;
  }
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::clear(a1 + 240);
  uint64_t v27 = *(void *)(a1 + 40);
  if (v27)
  {
    uint64_t v28 = *(void *)(a1 + 40);
    uint64_t v29 = (*(uint64_t (**)(void))(**(void **)(v27 + 24) + 56))(*(void *)(v27 + 24));
    if (v29)
    {
      uint64_t v30 = v29;
      while (1)
      {
        int v31 = *(_DWORD *)(v30 + 24);
        uint64_t v85 = *(re::SyncObject **)(v30 + 16);
        int v86 = v31;
        char v87 = 0;
        uint64_t v88 = 0;
        uint64_t v89 = 0;
        if (v31) {
          break;
        }
LABEL_68:
        (*(void (**)(void, uint64_t))(**(void **)(v28 + 24) + 40))(*(void *)(v28 + 24), v30);
        uint64_t v30 = (*(uint64_t (**)(void))(**(void **)(v28 + 24) + 56))(*(void *)(v28 + 24));
        if (!v30) {
          goto LABEL_69;
        }
      }
      while (1)
      {
        unint64_t v83 = 0;
        uint64_t v84 = 0;
        re::BitReader::readUInt64((re::BitReader *)&v85, &v83);
        re::BitReader::readUInt64((re::BitReader *)&v85, (unint64_t *)&v84);
        if (v87) {
          break;
        }
        uint64_t v32 = (char *)objc_loadWeakRetained((id *)(a1 + 96));
        __int16 v33 = v32;
        if (v32) {
          uint64_t v34 = (re::SyncObjectStore *)(v32 - 8);
        }
        else {
          uint64_t v34 = 0;
        }
        re::SyncObjectStore::findObject(v34, v83, v84, &v90);
        if (v33) {

        }
        uint64_t v35 = v90;
        if (v90)
        {
          while (!*(unsigned char *)(*((void *)v35[11] + 2) + 74))
          {
            uint64_t v35 = (re::SyncObjectTypedStore **)v35[10];
            if (!v35) {
              goto LABEL_57;
            }
          }
          int v43 = v35[12];
          if (v43)
          {
            uint64_t v44 = *((void *)v43 + 13);
            if (v44)
            {
              uint64_t v45 = *((void *)v43 + 15);
              uint64_t v46 = 8 * v44;
              while (*(void *)(*(void *)v45 + 56) != *(void *)(a1 + 80))
              {
                v45 += 8;
                v46 -= 8;
                if (!v46) {
                  goto LABEL_57;
                }
              }
              re::SyncSendBuffer::resetAcks(*(void *)(a1 + 280), (uint64_t *)&v90);
              goto LABEL_63;
            }
          }
LABEL_57:
          int v47 = (char *)objc_loadWeakRetained((id *)(a1 + 24));
          if (v47) {
            char v48 = v47 - 8;
          }
          else {
            char v48 = 0;
          }
          uint64_t v49 = v48 + 8;
          (*(void (**)(unsigned char *__return_ptr))(*(void *)v48 + 32))(v91);
          uint64_t v50 = *(NSObject **)(*(void *)v91 + 3272);

          *(void *)uint64_t v91 = 0;
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v51 = *(void *)(a1 + 80);
            *(_DWORD *)uint64_t v91 = 134218496;
            *(void *)&v91[4] = v83;
            __int16 v92 = 2048;
            uint64_t v93 = v84;
            __int16 v94 = 2048;
            uint64_t v95 = v51;
            uint64_t v40 = v50;
            char v41 = "Received history reset request for object {%llu, %llu}.But the object is not viewed by peer %llu.";
            uint32_t v42 = 32;
            goto LABEL_62;
          }
        }
        else
        {
          uint64_t v36 = (char *)objc_loadWeakRetained((id *)(a1 + 24));
          if (v36) {
            int v37 = v36 - 8;
          }
          else {
            int v37 = 0;
          }
          char v38 = v37 + 8;
          (*(void (**)(unsigned char *__return_ptr))(*(void *)v37 + 32))(v91);
          int v39 = *(NSObject **)(*(void *)v91 + 3272);

          *(void *)uint64_t v91 = 0;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v91 = 134218240;
            *(void *)&v91[4] = v83;
            __int16 v92 = 2048;
            uint64_t v93 = v84;
            uint64_t v40 = v39;
            char v41 = "Received history reset request for object {%llu, %llu}.But the object does not exist.";
            uint32_t v42 = 22;
LABEL_62:
            _os_log_impl(&dword_228C70000, v40, OS_LOG_TYPE_DEFAULT, v41, v91, v42);
          }
        }
LABEL_63:
        if (v90) {

        }
        HIDWORD(v88) = 0;
        uint64_t v89 = 0;
        if (v86 == v88) {
          goto LABEL_68;
        }
      }
    }
  }
LABEL_69:
  (*(void (**)(uint64_t, uint8_t *, uint64_t))(v74 + 16))(v74, buf, v73);
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v79);
  return 1;
}

uint64_t re::SyncSelectiveAckedUnicast::receiveFromStream(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (!*(void *)(a1 + 48) || !*(void *)(a1 + 56) || (uint64_t v4 = *(void *)(a1 + 72)) == 0)
  {
    id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 24));
    if (WeakRetained) {
      int v43 = WeakRetained - 8;
    }
    else {
      int v43 = 0;
    }
    uint64_t v44 = v43 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v43 + 32))(buf);
    uint64_t v45 = *(NSObject **)(*(void *)buf + 3272);

    *(void *)sockaddr buf = 0;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      _os_log_error_impl(&dword_228C70000, v45, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to receive.", buf, 2u);
    }
    return 0;
  }
  uint64_t v6 = (char *)objc_loadWeakRetained((id *)(a1 + 96));
  __int16 v7 = *(_WORD *)(a1 + 104);
  uint64_t v8 = v6 - 8;
  if (!v6) {
    uint64_t v8 = 0;
  }
  *(void *)sockaddr buf = v4;
  uint64_t v68 = v8;
  long long v69 = *(_OWORD *)(a1 + 80);
  long long v70 = 0u;
  long long v71 = 0u;
  int v72 = 0;
  uint64_t v73 = 0x7FFFFFFFLL;
  char v78 = 0;
  uint64_t v75 = 0;
  uint64_t v76 = 0;
  uint64_t v74 = 0;
  int v77 = 0;
  __int16 v79 = v7;
  if (v6) {

  }
  uint64_t v9 = (*(uint64_t (**)(void *))(*a2 + 56))(a2);
  if (!v9) {
    goto LABEL_45;
  }
  int v11 = (re *)(a1 + 120);
  uint64_t v57 = a1 + 152;
  int v61 = (void *)(a1 + 192);
LABEL_10:
  uint64_t v56 = v9;
  int v12 = *(_DWORD *)(v9 + 24);
  uint64_t v62 = *(void *)(v9 + 16);
  int v63 = v12;
  char v64 = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  if (!v12) {
    goto LABEL_43;
  }
  unsigned __int16 v55 = v10;
  int v13 = 2;
  while (1)
  {
    int v14 = re::SyncUnpacker::unpackCommit((_anonymous_namespace_ *)buf, (uint64_t)&v62, (uint64_t)v11, a3);
    if (v14 < v13) {
      int v13 = v14;
    }
    if (!v13) {
      break;
    }
    int v59 = v13;
    re::SyncCommitDump::log(v11, 1, "RecvCommit");
    uint64_t v15 = *(void *)(a1 + 168);
    if (v15)
    {
      char v16 = *(unsigned char *)(a1 + 120) & 1;
      uint64_t v17 = *(void *)(a1 + 184);
      uint64_t v60 = v17 + 24 * v15;
      do
      {
        unint64_t v18 = *(void *)v17;
        long long v19 = 0uLL;
        if ((void)v70)
        {
          unint64_t v20 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v18 ^ (v18 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v18 ^ (v18 >> 30))) >> 27));
          uint64_t v21 = *(unsigned int *)(*((void *)&v70 + 1) + 4 * ((v20 ^ (v20 >> 31)) % DWORD2(v71)));
          if (v21 != 0x7FFFFFFF)
          {
            while (*(void *)(v71 + 40 * v21 + 16) != v18)
            {
              LODWORD(v21) = *(_DWORD *)(v71 + 40 * v21 + 8) & 0x7FFFFFFF;
              if (v21 == 0x7FFFFFFF) {
                goto LABEL_23;
              }
            }
            long long v19 = *(_OWORD *)(v71 + 40 * v21 + 24);
          }
        }
LABEL_23:
        long long v80 = v19;
        int v81 = (char *)v18;
        if (v18)
        {
          id v22 = (id)(v18 + 8);
          unint64_t v23 = *(void *)v17;
        }
        else
        {
          unint64_t v23 = 0;
        }
        uint64_t v82 = *(void *)(v17 + 8);
        LOBYTE(v83) = *(unsigned char *)(v17 + 16);
        LOBYTE(v84) = v16;
        unint64_t v24 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) >> 27));
        unint64_t v25 = v24 ^ (v24 >> 31);
        if (*v61)
        {
          unint64_t v26 = v25 % *(unsigned int *)(a1 + 216);
          uint64_t v27 = *(unsigned int *)(*(void *)(a1 + 200) + 4 * v26);
          if (v27 != 0x7FFFFFFF)
          {
            uint64_t v28 = *(void *)(a1 + 208);
            while (*(void *)(v28 + 72 * v27 + 16) != v23)
            {
              LODWORD(v27) = *(_DWORD *)(v28 + 72 * v27 + 8) & 0x7FFFFFFF;
              if (v27 == 0x7FFFFFFF) {
                goto LABEL_33;
              }
            }
            uint64_t v30 = v28 + 72 * v27 + 24;
            if (!v18) {
              goto LABEL_35;
            }
LABEL_34:

            goto LABEL_35;
          }
        }
        else
        {
          LODWORD(v26) = 0;
        }
LABEL_33:
        unsigned int v29 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove((uint64_t)v61, v26, v25, (uint64_t *)v17, (uint64_t)&v80);
        ++*(_DWORD *)(a1 + 232);
        uint64_t v30 = *(void *)(a1 + 208) + 72 * v29 + 24;
        unint64_t v18 = (unint64_t)v81;
        if (v81) {
          goto LABEL_34;
        }
LABEL_35:
        *(unsigned char *)(v30 + 40) |= v16;
        unsigned int v31 = *(unsigned __int8 *)(v30 + 32);
        int v32 = *(unsigned char *)(v17 + 16) & 1 | v31;
        *(unsigned char *)(v30 + 32) = v32;
        unsigned int v33 = v32 & 0xFFFFFFFD | (2 * (((*(unsigned __int8 *)(v17 + 16) | v31) >> 1) & 1));
        *(unsigned char *)(v30 + 32) = v33;
        LOBYTE(v33) = v33 & 0xFB | (4 * (((*(unsigned __int8 *)(v17 + 16) | v31) & 4) != 0));
        *(unsigned char *)(v30 + 32) = v33;
        *(unsigned char *)(v30 + 32) = v33 & 0xF7 | (*(unsigned char *)(v17 + 16) | v31) & 8;
        if ((*(unsigned char *)(v17 + 16) & 8) != 0) {
          *(void *)(v30 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(void *)(v17 + 8);
        }
        v17 += 24;
      }
      while (v17 != v60);
    }
    re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(v57);
    int v11 = (re *)(a1 + 120);
    int v13 = v59;
    if (v63 == v65)
    {
      unsigned __int16 v10 = v55;
      if (v59 == 2) {
LABEL_43:
      }
        (*(void (**)(void *, void))(*a2 + 64))(a2, v10);
      (*(void (**)(void *, uint64_t))(*a2 + 40))(a2, v56);
      uint64_t v9 = (*(uint64_t (**)(void *))(*a2 + 56))(a2);
      if (!v9)
      {
LABEL_45:
        uint64_t v34 = *(void *)(a1 + 40);
        if (v34)
        {
          uint64_t v35 = v78;
          uint64_t v36 = *(void *)(v34 + 24) + 24;
          LODWORD(v81) = 0;
          BYTE4(v81) = 0;
          uint64_t v82 = 0;
          uint64_t v83 = 0;
          *(void *)&long long v80 = &unk_26DD352E8;
          *((void *)&v80 + 1) = 0;
          uint64_t v84 = v36;
          uint64_t v85 = 0;
          if (v76)
          {
            uint64_t v37 = 16 * v76;
            do
            {
              re::SyncHistoryResetRequest::write(v35, (re::BitWriter *)&v80);
              re::BitWriter::alignToByte(&v80);
              uint64_t v35 = (re::SyncHistoryResetRequest *)((char *)v35 + 16);
              v37 -= 16;
            }
            while (v37);
            int v38 = v82;
            uint64_t v39 = v85;
            if (HIDWORD(v82)) {
              int v38 = v82 + 1;
            }
            if (v38)
            {
              uint64_t v40 = *(void *)(v34 + 24);
              *(_DWORD *)(v85 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v38;
              uint64_t v82 = 0;
              uint64_t v83 = 0;
              *((void *)&v80 + 1) = 0;
              LODWORD(v81) = 0;
              uint64_t v85 = 0;
              (*(void (**)(uint64_t))(*(void *)v40 + 48))(v40);
              uint64_t v39 = v85;
            }
            if (v39) {
              (*(void (**)(uint64_t))(*(void *)v84 + 24))(v84);
            }
          }
        }
        uint64_t v41 = 1;
        goto LABEL_73;
      }
      goto LABEL_10;
    }
  }
  uint64_t v46 = a2[4];
  if (v46) {
    int v47 = (re::Transport *)(v46 - 8);
  }
  else {
    int v47 = 0;
  }
  re::Transport::connectionAddress(v47, a2[5], (re::DynamicString *)&v80);
  char v48 = (char *)objc_loadWeakRetained((id *)(a1 + 24));
  if (v48) {
    uint64_t v49 = v48 - 8;
  }
  else {
    uint64_t v49 = 0;
  }
  uint64_t v50 = v49 + 8;
  (*(void (**)(unsigned char *__return_ptr))(*(void *)v49 + 32))(v86);
  uint64_t v51 = *(NSObject **)(*(void *)v86 + 3272);

  *(void *)int v86 = 0;
  if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
  {
    uint64_t v53 = *(void *)(a1 + 80);
    if (BYTE8(v80)) {
      uint64_t v54 = v81;
    }
    else {
      uint64_t v54 = (char *)&v80 + 9;
    }
    *(_DWORD *)int v86 = 134218242;
    *(void *)&v86[4] = v53;
    __int16 v87 = 2082;
    uint64_t v88 = v54;
    _os_log_error_impl(&dword_228C70000, v51, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s)", v86, 0x16u);
  }
  re::DynamicArray<re::internal::SyncSnapshotEntry>::clear(v57);
  (*(void (**)(void *, uint64_t))(*a2 + 40))(a2, v56);
  if (void)v80 && (BYTE8(v80)) {
    (*(void (**)(void))(*(void *)v80 + 40))();
  }
  uint64_t v41 = 0;
LABEL_73:
  if (v74)
  {
    if (v78) {
      (*(void (**)(void))(*(void *)v74 + 40))();
    }
    char v78 = 0;
    uint64_t v75 = 0;
    uint64_t v76 = 0;
    uint64_t v74 = 0;
    ++v77;
  }
  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)&v70);
  return v41;
}

_DWORD *re::SyncSelectiveAckedUnicast::sendOwnershipRequests(uint64_t a1, uint64_t a2)
{
  return re::MessageStreamer<re::SyncOwnershipRequest>::send(*(_DWORD **)(a1 + 64), *(re::SyncOwnershipRequest **)a2, *(void *)(a2 + 8));
}

_DWORD *re::MessageStreamer<re::SyncOwnershipRequest>::send(_DWORD *result, re::SyncOwnershipRequest *this, uint64_t a3)
{
  uint64_t v3 = *((void *)result + 3) + 24;
  int v12 = 0;
  char v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  unsigned __int16 v10 = &unk_26DD352E8;
  uint64_t v11 = 0;
  uint64_t v16 = v3;
  uint64_t v17 = 0;
  if (a3)
  {
    uint64_t v5 = result;
    uint64_t v6 = 80 * a3;
    do
    {
      re::SyncOwnershipRequest::write(this, (re::BitWriter *)&v10);
      uint64_t result = re::BitWriter::alignToByte(&v10);
      this = (re::SyncOwnershipRequest *)((char *)this + 80);
      v6 -= 80;
    }
    while (v6);
    int v7 = v14;
    uint64_t v8 = v17;
    if (HIDWORD(v14)) {
      int v7 = v14 + 1;
    }
    if (v7)
    {
      uint64_t v9 = *((void *)v5 + 3);
      *(_DWORD *)(v17 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v7;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      uint64_t v11 = 0;
      int v12 = 0;
      uint64_t v17 = 0;
      uint64_t result = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
      uint64_t v8 = v17;
    }
    if (v8) {
      return (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v16 + 24))(v16);
    }
  }
  return result;
}

uint64_t re::SyncSelectiveAckedUnicast::receiveOwnershipRequests(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 64);
  uint64_t v11 = *(void *)(a2 + 24);
  int v12 = 0;
  if (v10 != (unsigned char *)a2)
  {
    re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable((uint64_t)v10);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v11 == *(void *)(a2 + 24))
    {
      uint64_t v5 = a2;
      if (v4 != a2)
      {
        int v12 = *(unsigned char **)(a2 + 32);
        *(void *)(a2 + 32) = 0;
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v5 = *(void *)(a2 + 32);
      if (!v4) {
        goto LABEL_13;
      }
    }
    unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
    if (v6 >= 0x19)
    {
      if (v11) {
        int v7 = (unsigned char *)(*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v11 + 32))(v11, v6, 0);
      }
      else {
        int v7 = 0;
      }
    }
    else
    {
      int v7 = v10;
    }
    int v12 = v7;
    (*(void (**)(void))(**(void **)(a2 + 32) + 32))(*(void *)(a2 + 32));
    re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable(a2);
  }
LABEL_13:
  uint64_t v8 = re::MessageStreamer<re::SyncOwnershipRequest>::receive<re::Function<void ()(re::SyncOwnershipRequest const&)>>(v2, (uint64_t)v10);
  re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable((uint64_t)v10);
  return v8;
}

uint64_t re::MessageStreamer<re::SyncOwnershipRequest>::receive<re::Function<void ()(re::SyncOwnershipRequest const&)>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 56))(*(void *)(a1 + 24));
  if (!v4) {
    return 1;
  }
  uint64_t v5 = v4;
  while (1)
  {
    int v6 = *(_DWORD *)(v5 + 24);
    uint64_t v17 = *(void *)(v5 + 16);
    int v18 = v6;
    char v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    if (v6) {
      break;
    }
LABEL_10:
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v5);
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 56))(*(void *)(a1 + 24));
    if (!v5) {
      return 1;
    }
  }
  while (1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    int v13 = 0;
    uint64_t v12 = 0;
    v8[0] = 0;
    v8[1] = 0;
    char v9 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = 0;
    if (!re::SyncOwnershipRequest::read((re::SyncOwnershipRequest *)v8, (re::BitReader *)&v17) || v19) {
      break;
    }
    (*(void (**)(void, void *))(**(void **)(a2 + 32) + 16))(*(void *)(a2 + 32), v8);
    HIDWORD(v20) = 0;
    uint64_t v21 = 0;
    if (v10)
    {
      if (v14) {
        (*(void (**)(void))(*(void *)v10 + 40))();
      }
    }
    if (v18 == v20) {
      goto LABEL_10;
    }
  }
  if (v10 && v14) {
    (*(void (**)(void))(*(void *)v10 + 40))();
  }
  return 0;
}

void re::SyncSelectiveAckedUnicast::~SyncSelectiveAckedUnicast(re::SyncSelectiveAckedUnicast *this)
{
  re::SyncSelectiveAckedUnicast::~SyncSelectiveAckedUnicast(this);
  JUMPOUT(0x22A6A9430);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  uint64_t v2 = *((void *)this + 35);
  if (v2)
  {

    *((void *)this + 35) = 0;
  }
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 240);
  re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 24);
  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 152);
  objc_destroyWeak((id *)this + 12);
  *((void *)this + 12) = 0;
  uint64_t v3 = *((void *)this + 9);
  if (v3)
  {

    *((void *)this + 9) = 0;
  }
  uint64_t v4 = *((void *)this + 8);
  if (v4)
  {

    *((void *)this + 8) = 0;
  }
  uint64_t v5 = *((void *)this + 7);
  if (v5)
  {

    *((void *)this + 7) = 0;
  }
  int v6 = *((void *)this + 6);
  if (v6)
  {

    *((void *)this + 6) = 0;
  }
  int v7 = *((void *)this + 5);
  if (v7)
  {

    *((void *)this + 5) = 0;
  }
  uint64_t v8 = *((void *)this + 4);
  if (v8)
  {

    *((void *)this + 4) = 0;
  }
  objc_destroyWeak((id *)this + 3);
  *((void *)this + 3) = 0;
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

void re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::~Callable()
{
}

void re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::operator()(uint64_t a1, char *a2)
{
}

uint64_t re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD359E0;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD359E0;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::SyncSelectiveAckedUnicast::send(re::Slice<re::SyncCommit> const&,re::Slice<re::SharedPtr<re::SyncObject>> const&,re::SyncObjectViewer *,re::SyncObjectWriteContext &)::$_0,void ()(re::SyncCommit const&)>::size()
{
  return 32;
}

double re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 72;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(a1 + 8) = v1 & 0x7FFFFFFF;
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {

      *(void *)(a1 + 16) = 0;
    }
    uint64_t v4 = *(void *)(a1 + 40);
    if (v4)
    {

      *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
    }
  }
}

re::SyncObjectShortIDManagerImpl *re::make::shared::object<re::SyncObjectShortIDManagerImpl>@<X0>(re *a1@<X0>, re::SyncObjectShortIDManagerImpl **a2@<X8>)
{
  uint64_t v3 = re::globalAllocators(a1);
  uint64_t v4 = (re::SyncObjectShortIDManagerImpl *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 232, 8);
  double result = re::SyncObjectShortIDManagerImpl::SyncObjectShortIDManagerImpl(v4);
  *a2 = result;
  return result;
}

void re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},decltype(nullptr)>(re *a1, id *a2, uint64_t *a3, int *a4, char *a5, unsigned int *a6)
{
  uint64_t v12 = re::globalAllocators(a1);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12[2] + 32))(v12[2], 112, 8);
  id to = 0;
  objc_copyWeak(&to, a2);
  re::UnicastStream::UnicastStream(v13, &to, *a3, *a4, *a5, *a6, 0);
  *(void *)a1 = v13;
  objc_destroyWeak(&to);
}

double re::make::shared::object<re::SyncAckedStateBuffer>@<D0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = re::globalAllocators(a1);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 72, 8);
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(void *)(v4 + 64) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(void *)uint64_t v4 = &unk_26DD35A48;
  *(_OWORD *)(v4 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0u;
  *(_OWORD *)(v4 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0u;
  *(_DWORD *)(v4 + 56) = 0;
  *(void *)&double result = 0x7FFFFFFFLL;
  *(void *)(v4 + 60) = 0x7FFFFFFFLL;
  *a2 = v4;
  return result;
}

void re::SyncAckedStateBuffer::~SyncAckedStateBuffer(re::SyncAckedStateBuffer *this)
{
  *(void *)this = &unk_26DD35A48;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 3);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD35A48;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 3);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

void *re::MessageStreamer<re::SyncHistoryResetRequest>::~MessageStreamer(void *a1)
{
  *a1 = &unk_26DD35A90;
  uint64_t v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  *a1 = &unk_26DD34510;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::MessageStreamer<re::SyncHistoryResetRequest>::~MessageStreamer(void *a1)
{
  *a1 = &unk_26DD35A90;
  uint64_t v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  *a1 = &unk_26DD34510;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x22A6A9430);
}

_anonymous_namespace_ *re::MessageStreamer<re::SyncOwnershipRequest>::MessageStreamer(_anonymous_namespace_ *a1, uint64_t *a2)
{
  ArcSharedObject::ArcSharedObject(a1, 0);
  *(void *)a1 = &unk_26DD35AD8;
  uint64_t v4 = *a2;
  *((void *)a1 + 3) = *a2;
  if (v4) {
    id v5 = (id)(v4 + 8);
  }
  return a1;
}

void *re::MessageStreamer<re::SyncOwnershipRequest>::~MessageStreamer(void *a1)
{
  *a1 = &unk_26DD35AD8;
  uint64_t v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  *a1 = &unk_26DD34510;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::MessageStreamer<re::SyncOwnershipRequest>::~MessageStreamer(void *a1)
{
  *a1 = &unk_26DD35AD8;
  uint64_t v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  *a1 = &unk_26DD34510;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v31, 0, 36);
          *(void *)&v31[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v31, v13, v12);
          long long v15 = *(_OWORD *)v31;
          *(_OWORD *)unsigned int v31 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v31[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v31[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v31[24];
          *(_OWORD *)&v31[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v31[32];
          *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            uint64_t v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0) {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(void *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v21 - 16), v21, v21 + 8);
              }
              v21 += 72;
              --v20;
            }
            while (v20);
          }
          re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v31);
        }
      }
      else
      {
        if (v12) {
          signed int v24 = 2 * v11;
        }
        else {
          signed int v24 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 72 * v9 + 8);
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 72 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 72 * v9 + 8) = v23 | 0x80000000;
  uint64_t v25 = a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 72 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 72 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 72 * v9) = a3;
  uint64_t v26 = *a4;
  *(void *)(*(void *)(a1 + 16) + 72 * v9 + 16) = *a4;
  if (v26) {
    id v27 = (id)(v26 + 8);
  }
  uint64_t v28 = *(void *)(a1 + 16) + 72 * v9;
  *(_OWORD *)(v28 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(_OWORD *)a5;
  *(void *)(v28 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = 0;
  uint64_t v29 = *(void *)(a5 + 24);
  *(unsigned char *)(v28 + 56) = *(unsigned char *)(a5 + 32);
  *(void *)(v28 + 48) = v29;
  *(unsigned char *)(v28 + 64) = *(unsigned char *)(a5 + 40);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v25) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncSelectiveAckedUnicast::BacklogEntry,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  id v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      id v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 72 * v10, 16);
  if (v12)
  {
    BOOL v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::SyncReliableOrderedUnicast::SyncReliableOrderedUnicast(uint64_t a1, id *a2, re *a3, unint64_t a4, uint64_t a5, uint64_t a6, id *a7, char a8, char a9, char a10)
{
  unint64_t v52 = a4;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)a1 = &unk_26DD35B20;
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  uint64_t v17 = (uint64_t *)(a1 + 24);
  *(void *)(v18 + 32) = 0;
  objc_copyWeak((id *)(v18 + 32), a2);
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  long long v19 = (re::SyncObjectShortIDManagerImpl **)(a1 + 40);
  *(void *)(a1 + 48) = 0;
  re::make::shared::object<re::SyncObjectShortIDManagerImpl>(v20, &v53);
  *(void *)(a1 + 56) = v53;
  *(void *)(a1 + 64) = a5;
  *(void *)(a1 + 72) = a6;
  *(void *)(a1 + 80) = 0;
  objc_copyWeak((id *)(a1 + 80), a7);
  *(unsigned char *)(a1 + 88) = a8;
  *(unsigned char *)(a1 + 89) = a9;
  *(_WORD *)(a1 + 90) = 0;
  *(unsigned char *)(a1 + 92) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 128) = 0;
  *(void *)(a1 + 132) = 0x7FFFFFFFLL;
  *(void *)(a1 + 144) = 0x8000000000000000;
  int v51 = 0;
  char v50 = 1;
  unsigned int v49 = 1;
  v47[0] = MEMORY[0x263EF8330];
  v47[1] = 0x40000000;
  v47[2] = ___ZN2re26SyncReliableOrderedUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbbb_block_invoke;
  v47[3] = &__block_descriptor_tmp_4;
  v47[4] = a1;
  char v48 = v47;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},void({block_pointer})(unsigned long long)>(a3, (uint64_t *)&v52, &v51, &v50, &v49, (const void **)&v48, (uint64_t *)&v53);
  uint64_t v21 = v53;
  if (*(void *)a3) {
    uint64_t v22 = (re::Transport *)(*(void *)a3 - 8);
  }
  else {
    uint64_t v22 = 0;
  }
  unint64_t v23 = v52;
  id WeakRetained = (char *)objc_loadWeakRetained(a2);
  if (WeakRetained) {
    uint64_t v25 = WeakRetained - 8;
  }
  else {
    uint64_t v25 = 0;
  }
  (*(void (**)(re::SyncObjectShortIDManagerImpl **__return_ptr, char *))(*(void *)v25 + 32))(&v53, v25);
  BOOL v26 = re::Transport::registerStream(v22, v21, 1uLL, v23);
  if (v53)
  {

    uint64_t v53 = 0;
  }

  if (v26)
  {
    uint64_t v28 = *v19;
    *long long v19 = v21;
    uint64_t v21 = v28;
  }
  if (a10)
  {
    re::make::shared::object<re::SyncAckedStateBuffer>(v27, (uint64_t *)&v53);
    uint64_t v29 = *v17;
    *uint64_t v17 = (uint64_t)v53;
    uint64_t v53 = (re::SyncObjectShortIDManagerImpl *)v29;
    if (v29) {
  }
    }
  int v51 = 0;
  char v50 = 1;
  unsigned int v49 = 2;
  v46[0] = MEMORY[0x263EF8330];
  v46[1] = 0x40000000;
  v46[2] = ___ZN2re26SyncReliableOrderedUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbbb_block_invoke_2;
  v46[3] = &__block_descriptor_tmp_1;
  v46[4] = a1;
  char v48 = v46;
  re::make::shared::object<re::UnicastStream,re::ArcWeakPtr<re::Transport> &,unsigned long long &,re::DeliveryMethod,BOOL,re::SyncStreamID::{unnamed type#1},void({block_pointer})(unsigned long long)>(a3, (uint64_t *)&v52, &v51, &v50, &v49, (const void **)&v48, (uint64_t *)&v53);
  uint64_t v30 = v53;
  if (*(void *)a3) {
    unsigned int v31 = (re::Transport *)(*(void *)a3 - 8);
  }
  else {
    unsigned int v31 = 0;
  }
  unint64_t v32 = v52;
  unsigned int v33 = (char *)objc_loadWeakRetained(a2);
  if (v33) {
    uint64_t v34 = v33 - 8;
  }
  else {
    uint64_t v34 = 0;
  }
  (*(void (**)(re::SyncObjectShortIDManagerImpl **__return_ptr, char *))(*(void *)v34 + 32))(&v53, v34);
  BOOL v35 = re::Transport::registerStream(v31, v30, 2uLL, v32);
  if (v53)
  {

    uint64_t v53 = 0;
  }

  if (v35)
  {
    uint64_t v37 = re::globalAllocators(v36);
    int v38 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v37[2] + 32))(v37[2], 32, 8);
    uint64_t v53 = v30;
    if (v30) {
      uint64_t v39 = (char *)v30 + 8;
    }
    re::MessageStreamer<re::SyncOwnershipRequest>::MessageStreamer(v38, (uint64_t *)&v53);
    if (v53) {

    }
    uint64_t v40 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = v38;
    if (v40) {
  }
    }
  uint64_t v53 = 0;
  if (*(void *)a3) {
    uint64_t v41 = *(void *)a3 - 8;
  }
  else {
    uint64_t v41 = 0;
  }
  if (re::Transport::receive(v41, v52, 1u, (uint64_t *)&v53))
  {
    do
    {
      if (*(void *)a3) {
        uint32_t v42 = (re::Transport *)(*(void *)a3 - 8);
      }
      else {
        uint32_t v42 = 0;
      }
      if (re::Transport::dispatchPacketToStream(v42, v53, v52))
      {
        if (*(void *)a3) {
          uint64_t v43 = *(void *)a3 - 8;
        }
        else {
          uint64_t v43 = 0;
        }
        re::PacketPool::free(*(re::PacketPool **)(v43 + 384), v53);
      }
      if (*(void *)a3) {
        uint64_t v44 = *(void *)a3 - 8;
      }
      else {
        uint64_t v44 = 0;
      }
    }
    while (re::Transport::receive(v44, v52, 1u, (uint64_t *)&v53));
  }
  if (v30) {

  }
  if (v21) {
  return a1;
  }
}

uint64_t ___ZN2re26SyncReliableOrderedUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbbb_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 91) = 1;
  return result;
}

uint64_t ___ZN2re26SyncReliableOrderedUnicastC2ENS_10ArcWeakPtrINS_11SyncSessionEEENS1_INS_9TransportEEEyyyNS1_INS_15SyncObjectStoreEEEbbb_block_invoke_2(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 92) = 1;
  return result;
}

void re::SyncReliableOrderedUnicast::send(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v185 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 40) && *(void *)(a1 + 56))
  {
    *(void *)char v179 = 0;
    unint64_t v176 = 0;
    unint64_t v177 = 0;
    uint64_t v175 = 0;
    int v178 = 0;
    uint64_t v8 = *(re::SyncObject ***)a3;
    uint64_t v7 = *(void *)(a3 + 8);
    *(void *)&long long v168 = 0;
    memset(v167, 0, 28);
    uint64_t v9 = *(void *)(a4 + 56);
    if (v7)
    {
      uint64_t v10 = &v8[v7];
      do
      {
        uint64_t v11 = *v8;
        if (*v8)
        {
          while (!*(unsigned char *)(*(void *)(*((void *)v11 + 11) + 16) + 74))
          {
            uint64_t v11 = (re::SyncObject *)*((void *)v11 + 10);
            if (!v11) {
              goto LABEL_35;
            }
          }
          uint64_t v12 = *((void *)v11 + 12);
          if (v12)
          {
            uint64_t v13 = *(void **)(v12 + 120);
            uint64_t v14 = *(void *)(v12 + 104);
            if (v14)
            {
              uint64_t v15 = 8 * v14;
              uint64_t v16 = v13;
              while (*v16 != a4)
              {
                ++v16;
                v15 -= 8;
                if (!v15)
                {
                  uint64_t v16 = &v13[v14];
                  break;
                }
              }
            }
            else
            {
              uint64_t v16 = v13;
            }
            if (v14 != v16 - v13)
            {
              id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
              if (WeakRetained) {
                uint64_t v18 = WeakRetained - 8;
              }
              else {
                uint64_t v18 = 0;
              }
              long long v19 = v18 + 8;
              (*(void (**)(uint8_t *__return_ptr))(*(void *)v18 + 32))(buf);
              uint64_t v20 = *(NSObject **)(*(void *)buf + 3272);

              *(void *)sockaddr buf = 0;
              if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
              {
                uint64_t v21 = *((void *)*v8 + 3);
                *(_DWORD *)sockaddr buf = 134217984;
                *(void *)&uint8_t buf[4] = v21;
                _os_log_impl(&dword_228C70000, v20, OS_LOG_TYPE_INFO, "[Ownership] Adding ownership changes for: %llu", buf, 0xCu);
              }
              BOOL v22 = re::SyncObject::takeOverLatestState(*v8);
              if (v22)
              {
                if (v177)
                {
                  uint64_t v23 = *(void *)v179 + 72 * v177 - 72;
                }
                else
                {
                  buf[0] = 0;
                  *(void *)&uint8_t buf[8] = v9;
                  *(void *)&uint8_t buf[16] = 0;
                  *(_DWORD *)&unsigned char buf[24] = 0;
                  buf[28] = 0;
                  *(void *)&long long v184 = 0;
                  *(void *)&long long v183 = 0;
                  long long v182 = 0uLL;
                  DWORD2(v183) = 0;
                  re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v175, (uint64_t)buf);
                  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v182);
                  uint64_t v31 = *(void *)v179 + 72 * v177;
                  *(unsigned char *)(v31 - 72) = 1;
                  uint64_t v23 = v31 - 72;
                }
                *(void *)sockaddr buf = *v8;
                if (*(void *)buf)
                {
                  id v32 = (id)(*(void *)buf + 8);
                  unsigned int v33 = *v8;
                }
                else
                {
                  unsigned int v33 = 0;
                }
                *(void *)&uint8_t buf[8] = re::SyncObject::latestStateHandle(v33);
                buf[16] &= 0xF0u;
                re::DynamicArray<re::internal::SyncSnapshotEntry>::add((void *)(v23 + 32), (uint64_t)buf);
                if (*(void *)buf) {
              }
                }
              else
              {
                signed int v24 = *re::networkLogObjects((re *)v22);
                if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v25 = *((void *)*v8 + 3);
                  BOOL v26 = *(void **)(*((void *)*v8 + 11) + 16);
                  uint64_t v27 = v26[4];
                  uint64_t v28 = v26[6];
                  uint64_t v29 = (char *)v26[7];
                  uint64_t v30 = (char *)v26 + 49;
                  if (v28) {
                    uint64_t v30 = v29;
                  }
                  *(_DWORD *)sockaddr buf = 134218498;
                  *(void *)&uint8_t buf[4] = v25;
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&buf[14] = v27;
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  *(void *)&unsigned char buf[24] = v30;
                  _os_log_error_impl(&dword_228C70000, v24, OS_LOG_TYPE_ERROR, "Sync object without snapshot while packing ownership broadcasts (id: %llu, type: %llu[%s]).", buf, 0x20u);
                }
              }
            }
          }
        }
LABEL_35:
        ++v8;
      }
      while (v8 != v10);
    }
    uint64_t v34 = *(unsigned int *)(a4 + 96);
    if (v34)
    {
      uint64_t v35 = 0;
      uint64_t v36 = (int *)(*(void *)(a4 + 80) + 8);
      while (1)
      {
        int v37 = *v36;
        v36 += 8;
        if (v37 < 0) {
          break;
        }
        if (v34 == ++v35)
        {
          LODWORD(v35) = *(_DWORD *)(a4 + 96);
          break;
        }
      }
    }
    else
    {
      LODWORD(v35) = 0;
    }
    if (v34 != v35)
    {
      uint64_t v42 = v35;
      do
      {
        uint64_t v43 = *(void *)(a4 + 80) + 32 * v42;
        uint64_t v46 = *(void *)(v43 + 16);
        uint64_t v45 = v43 + 16;
        uint64_t v44 = v46;
        uint64_t v47 = *(void *)(v46 + 80);
        uint64_t v48 = v46;
        if (v47)
        {
          uint64_t v49 = v44;
          do
          {
            uint64_t v48 = v49;
            uint64_t v49 = v47;
            if (*(unsigned char *)(*(void *)(*(void *)(v48 + 88) + 16) + 73)) {
              break;
            }
            uint64_t v47 = *(void *)(v47 + 80);
            uint64_t v48 = v49;
          }
          while (v47);
        }
        if (*(unsigned char *)(v48 + 170) || *(unsigned char *)(a1 + 88) || *(unsigned char *)(a1 + 89))
        {
          if (*(_DWORD *)(v45 + 8))
          {
            *(void *)sockaddr buf = v44;
            re::DynamicArray<re::Allocator const*>::add(v167, buf);
          }
          else
          {
            if (v177)
            {
              uint64_t v50 = *(void *)v179 + 72 * v177 - 72;
            }
            else
            {
              buf[0] = 0;
              *(void *)&uint8_t buf[8] = v9;
              *(void *)&uint8_t buf[16] = 0;
              *(_DWORD *)&unsigned char buf[24] = 0;
              buf[28] = 0;
              *(void *)&long long v184 = 0;
              *(void *)&long long v183 = 0;
              long long v182 = 0uLL;
              DWORD2(v183) = 0;
              re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v175, (uint64_t)buf);
              re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v182);
              uint64_t v51 = *(void *)v179 + 72 * v177;
              *(unsigned char *)(v51 - 72) = 1;
              uint64_t v50 = v51 - 72;
            }
            addToViewRecursive((re::SyncObject **)v45, v50, *(void *)(a4 + 56));
          }
        }
        if (*(_DWORD *)(a4 + 96) <= (v35 + 1)) {
          int v52 = v35 + 1;
        }
        else {
          int v52 = *(_DWORD *)(a4 + 96);
        }
        while (1)
        {
          uint64_t v42 = (v35 + 1);
          if (v52 - 1 == v35) {
            break;
          }
          LODWORD(v35) = v35 + 1;
          int v53 = v42;
          if ((*(_DWORD *)(*(void *)(a4 + 80) + 32 * v42 + 8) & 0x80000000) != 0) {
            goto LABEL_69;
          }
        }
        int v53 = v52;
LABEL_69:
        LODWORD(v35) = v53;
      }
      while (v34 != v53);
    }
    if (*(void *)&v167[1])
    {
      uint64_t v54 = (uint64_t *)v168;
      uint64_t v55 = 8 * *(void *)&v167[1];
      do
      {
        uint64_t v56 = *v54;
        *(void *)uint64_t v180 = v56;
        if (v56) {
          id v57 = (id)(v56 + 8);
        }
        if (v177)
        {
          uint64_t v58 = *(void *)v179 + 72 * v177 - 72;
        }
        else
        {
          buf[0] = 0;
          *(void *)&uint8_t buf[8] = v9;
          *(void *)&uint8_t buf[16] = 0;
          *(_DWORD *)&unsigned char buf[24] = 0;
          buf[28] = 0;
          *(void *)&long long v184 = 0;
          *(void *)&long long v183 = 0;
          long long v182 = 0uLL;
          DWORD2(v183) = 0;
          re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v175, (uint64_t)buf);
          re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v182);
          uint64_t v59 = *(void *)v179 + 72 * v177;
          *(unsigned char *)(v59 - 72) = 1;
          uint64_t v58 = v59 - 72;
        }
        removeFromViewRecursive((re::SyncObject **)v180, v58, *(void *)(a4 + 56));
        if (*(void *)v180) {

        }
        ++v54;
        v55 -= 8;
      }
      while (v55);
    }
    *(void *)&v180[32] = 0;
    memset(v180, 0, 28);
    uint64_t v60 = a2[1];
    if (v60)
    {
      uint64_t v61 = *a2;
      uint64_t v62 = *a2 + 72 * v60;
      do
      {
        if (*(unsigned char *)(v61 + 28)) {
          BOOL v63 = *(void *)(v61 + 8) == *(void *)(a4 + 56);
        }
        else {
          BOOL v63 = 0;
        }
        if (!v63)
        {
          if (*(unsigned char *)(v61 + 28))
          {
            uint64_t v64 = *(void *)(v61 + 48);
            if (v64)
            {
              uint64_t v65 = *(uint64_t **)(v61 + 64);
              uint64_t v66 = &v65[3 * v64];
              do
              {
                uint64_t v67 = *v65;
                uint64_t v68 = *(void *)(*v65 + 80);
                if (v68)
                {
                  do
                  {
                    uint64_t v69 = v67;
                    uint64_t v67 = v68;
                    if (*(unsigned char *)(*(void *)(*(void *)(v69 + 88) + 16) + 73)) {
                      break;
                    }
                    uint64_t v68 = *(void *)(v68 + 80);
                    uint64_t v69 = v67;
                  }
                  while (v68);
                }
                else
                {
                  uint64_t v69 = *v65;
                }
                if ((*(unsigned char *)(v69 + 170) || *(unsigned char *)(a1 + 88) || *(unsigned char *)(a1 + 89))
                  && entryIsAddable((re::SyncObject **)v65, (re::SyncObjectViewer *)a4))
                {
                  if (v177)
                  {
                    uint64_t v70 = *(void *)v179 + 72 * v177 - 72;
                  }
                  else
                  {
                    buf[0] = 0;
                    *(void *)&uint8_t buf[8] = v9;
                    *(void *)&uint8_t buf[16] = 0;
                    *(_DWORD *)&unsigned char buf[24] = 0;
                    buf[28] = 0;
                    *(void *)&long long v184 = 0;
                    *(void *)&long long v183 = 0;
                    long long v182 = 0uLL;
                    DWORD2(v183) = 0;
                    re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v175, (uint64_t)buf);
                    re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v182);
                    uint64_t v71 = *(void *)v179 + 72 * v177;
                    *(unsigned char *)(v71 - 72) = 1;
                    uint64_t v70 = v71 - 72;
                  }
                  re::DynamicArray<re::internal::SyncSnapshotEntry>::add((void *)(v70 + 32), v65);
                }
                v65 += 3;
              }
              while (v65 != v66);
            }
          }
          else
          {
            *(void *)sockaddr buf = v61;
            re::DynamicArray<re::Allocator const*>::add(v180, buf);
          }
        }
        v61 += 72;
      }
      while (v61 != v62);
      if (*(void *)&v180[16])
      {
        uint64_t v72 = *(void *)&v180[32];
        uint64_t v73 = *(void *)&v180[32] + 8 * *(void *)&v180[16];
        do
        {
          uint64_t v74 = *(void *)(*(void *)v72 + 48);
          if (v74)
          {
            uint64_t v75 = *(uint64_t **)(*(void *)v72 + 64);
            uint64_t v76 = &v75[3 * v74];
            do
            {
              uint64_t v77 = *v75;
              uint64_t v78 = *(void *)(*v75 + 80);
              if (v78)
              {
                do
                {
                  uint64_t v79 = v77;
                  uint64_t v77 = v78;
                  if (*(unsigned char *)(*(void *)(*(void *)(v79 + 88) + 16) + 73)) {
                    break;
                  }
                  uint64_t v78 = *(void *)(v78 + 80);
                  uint64_t v79 = v77;
                }
                while (v78);
              }
              else
              {
                uint64_t v79 = *v75;
              }
              if ((*(unsigned char *)(v79 + 170) || *(unsigned char *)(a1 + 88) || *(unsigned char *)(a1 + 89))
                && entryIsAddable((re::SyncObject **)v75, (re::SyncObjectViewer *)a4))
              {
                if (v177)
                {
                  uint64_t v80 = *(void *)v179 + 72 * v177 - 72;
                }
                else
                {
                  buf[0] = 0;
                  *(void *)&uint8_t buf[8] = v9;
                  *(void *)&uint8_t buf[16] = 0;
                  *(_DWORD *)&unsigned char buf[24] = 0;
                  buf[28] = 0;
                  *(void *)&long long v184 = 0;
                  *(void *)&long long v183 = 0;
                  long long v182 = 0uLL;
                  DWORD2(v183) = 0;
                  re::DynamicArray<re::SyncCommit>::add((_anonymous_namespace_ *)&v175, (uint64_t)buf);
                  re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v182);
                  uint64_t v81 = *(void *)v179 + 72 * v177;
                  *(unsigned char *)(v81 - 72) = 1;
                  uint64_t v80 = v81 - 72;
                }
                re::DynamicArray<re::internal::SyncSnapshotEntry>::add((void *)(v80 + 32), v75);
              }
              v75 += 3;
            }
            while (v75 != v76);
          }
          v72 += 8;
        }
        while (v72 != v73);
      }
    }
    if (*(void *)v180 && *(void *)&v180[32]) {
      (*(void (**)(void))(**(void **)v180 + 40))();
    }
    if (*(void *)&v167[0] && (void)v168) {
      (*(void (**)(void))(**(void **)&v167[0] + 40))();
    }
    re::SyncCommitDump::log(*(re **)v179, v177, "SendCommit");
    if (*(unsigned char *)(a1 + 90))
    {
      if (v177)
      {
        uint64_t v82 = *(re **)v179;
        uint64_t v83 = *(void *)v179 + 72 * v177;
        char v84 = 1;
        do
        {
          uint64_t v85 = *((void *)v82 + 6);
          if (v85)
          {
            uint64_t v86 = 24 * v85;
            __int16 v87 = (unsigned char *)(*((void *)v82 + 8) + 16);
            do
            {
              uint64_t v88 = (uint64_t *)(v87 - 16);
              if ((*v87 & 2) != 0)
              {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(a1 + 96, v88, v87);
              }
              else
              {
                uint64_t v89 = (unsigned char *)re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(a1 + 96, v88, v87);
                if ((*v89 & 2) != 0) {
                  *uint64_t v89 = *v87;
                }
              }
              v87 += 24;
              v86 -= 24;
            }
            while (v86);
            char v84 = 0;
          }
          uint64_t v82 = (re *)((char *)v82 + 72);
        }
        while (v82 != (re *)v83);
      }
      else
      {
        char v84 = 1;
      }
      if (std::chrono::steady_clock::now().__d_.__rep_ >= *(void *)(a1 + 144) && (v84 & 1) == 0)
      {
        v94.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        *(void *)(a1 + 144) = v94.__d_.__rep_ + 5000000000;
        LODWORD(v182) = 0;
        memset(buf, 0, sizeof(buf));
        *(void *)((char *)&v182 + 4) = 0x7FFFFFFFLL;
        if (v177)
        {
          uint64_t v95 = *(re **)v179;
          uint64_t v96 = *(void *)v179 + 72 * v177;
          do
          {
            uint64_t v97 = *((void *)v95 + 6);
            if (v97)
            {
              uint64_t v98 = (uint64_t *)*((void *)v95 + 8);
              uint64_t v99 = 24 * v97;
              do
              {
                uint64_t v100 = *v98;
                v98 += 3;
                v94.__d_.__rep_ = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)buf, (re::DynamicString *)(*(void *)(*(void *)(v100 + 88) + 16) + 40));
                v99 -= 24;
              }
              while (v99);
            }
            uint64_t v95 = (re *)((char *)v95 + 72);
          }
          while (v95 != (re *)v96);
        }
        memset((char *)v167 + 8, 0, 24);
        re::DynamicString::setCapacity(v167, 0);
        int v101 = v182;
        if (v182)
        {
          uint64_t v102 = 0;
          unint64_t v103 = (int *)(*(void *)&buf[16] + 8);
          while (1)
          {
            int v104 = *v103;
            v103 += 12;
            if (v104 < 0) {
              break;
            }
            if (v182 == ++v102)
            {
              LODWORD(v102) = v182;
              break;
            }
          }
        }
        else
        {
          LODWORD(v102) = 0;
        }
        if (v182 != v102)
        {
          uint64_t v105 = v102;
          uint64_t v106 = *(void *)&buf[16];
          do
          {
            uint64_t v107 = v106 + 48 * v105;
            unint64_t v108 = *(void *)(v107 + 24);
            long long v109 = *(const char **)(v107 + 32);
            uint64_t v110 = (const char *)(v107 + 25);
            BOOL v111 = (v108 & 1) == 0;
            if (v108) {
              long long v112 = v109;
            }
            else {
              long long v112 = v110;
            }
            size_t v113 = v108 >> 1;
            size_t v114 = v108 >> 1;
            if (v111) {
              size_t v115 = v114;
            }
            else {
              size_t v115 = v113;
            }
            re::DynamicString::append((re::DynamicString *)v167, v112, v115);
            re::DynamicString::append((re::DynamicString *)v167, " ", 1uLL);
            uint64_t v106 = *(void *)&buf[16];
            if (v182 <= (int)v102 + 1) {
              int v116 = v102 + 1;
            }
            else {
              int v116 = v182;
            }
            int v117 = v102;
            while (1)
            {
              uint64_t v105 = (v117 + 1);
              if (v116 - 1 == v117) {
                break;
              }
              ++v117;
              LODWORD(v102) = v105;
              if ((*(_DWORD *)(*(void *)&buf[16] + 48 * v105 + 8) & 0x80000000) != 0) {
                goto LABEL_181;
              }
            }
            LODWORD(v102) = v116;
LABEL_181:
            ;
          }
          while (v101 != v102);
        }
        uint64_t v118 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
        if (v118) {
          uint64_t v119 = v118 - 8;
        }
        else {
          uint64_t v119 = 0;
        }
        int v120 = v119 + 8;
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v119 + 32))(v180);
        unint64_t v121 = *(NSObject **)(*(void *)v180 + 3272);

        *(void *)uint64_t v180 = 0;
        if (os_log_type_enabled(v121, OS_LOG_TYPE_INFO))
        {
          uint64_t v122 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
          if (v122) {
            uint64_t v123 = v122 - 8;
          }
          else {
            uint64_t v123 = 0;
          }
          (*(void (**)(re::Session **__return_ptr, char *))(*(void *)v123 + 32))(&v174, v123);
          uint64_t v124 = re::Session::peerID(v174);
          uint64_t v125 = *(void *)(a1 + 40);
          uint64_t v126 = *(void *)(v125 + 32);
          if (v126) {
            unint64_t v127 = (re::Transport *)(v126 - 8);
          }
          else {
            unint64_t v127 = 0;
          }
          re::Transport::connectionAddress(v127, *(void *)(v125 + 40), (re::DynamicString *)&v171);
          if (v172) {
            unint64_t v128 = *(unsigned char **)&v173[7];
          }
          else {
            unint64_t v128 = v173;
          }
          if (BYTE8(v167[0])) {
            unint64_t v129 = *(char **)&v167[1];
          }
          else {
            unint64_t v129 = (char *)v167 + 9;
          }
          *(_DWORD *)uint64_t v180 = 134218498;
          *(void *)&v180[4] = v124;
          *(_WORD *)&v180[12] = 2080;
          *(void *)&v180[14] = v128;
          *(_WORD *)&v180[22] = 2080;
          *(void *)&v180[24] = v129;
          _os_log_impl(&dword_228C70000, v121, OS_LOG_TYPE_INFO, "Sending sync data on paused connection to %llx ('%s'): %s", v180, 0x20u);
          if (v171 && (v172 & 1) != 0) {
            (*(void (**)(void))(*(void *)v171 + 40))();
          }
          if (v174)
          {

            long long v174 = 0;
          }
        }
        if (*(void *)&v167[0])
        {
          if (BYTE8(v167[0])) {
            (*(void (**)(void))(**(void **)&v167[0] + 40))();
          }
        }
        re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)buf);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 124))
      {
        uint64_t v90 = *(unsigned int *)(a4 + 96);
        if (v90)
        {
          uint64_t v91 = 0;
          __int16 v92 = (int *)(*(void *)(a4 + 80) + 8);
          while (1)
          {
            int v93 = *v92;
            v92 += 8;
            if (v93 < 0) {
              break;
            }
            if (v90 == ++v91)
            {
              LODWORD(v91) = *(_DWORD *)(a4 + 96);
              break;
            }
          }
        }
        else
        {
          LODWORD(v91) = 0;
        }
        if (v90 != v91)
        {
          uint64_t v130 = v91;
          do
          {
            re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(a1 + 96, (uint64_t *)(*(void *)(a4 + 80) + 32 * v130 + 16));
            if (*(_DWORD *)(a4 + 96) <= (v91 + 1)) {
              int v131 = v91 + 1;
            }
            else {
              int v131 = *(_DWORD *)(a4 + 96);
            }
            int v132 = v91;
            while (1)
            {
              uint64_t v130 = (v132 + 1);
              if (v131 - 1 == v132) {
                break;
              }
              ++v132;
              LODWORD(v91) = v130;
              if ((*(_DWORD *)(*(void *)(a4 + 80) + 32 * v130 + 8) & 0x80000000) != 0) {
                goto LABEL_219;
              }
            }
            LODWORD(v91) = v131;
LABEL_219:
            ;
          }
          while (v90 != v91);
        }
        uint64_t v170 = 0;
        long long v168 = 0u;
        long long v169 = 0u;
        memset(v167, 0, sizeof(v167));
        LOBYTE(v167[0]) = 1;
        uint64_t v133 = *(unsigned int *)(a1 + 128);
        if (v133)
        {
          uint64_t v134 = 0;
          uint64_t v135 = (int *)(*(void *)(a1 + 112) + 8);
          while (1)
          {
            int v136 = *v135;
            v135 += 8;
            if (v136 < 0) {
              break;
            }
            if (v133 == ++v134)
            {
              LODWORD(v134) = *(_DWORD *)(a1 + 128);
              break;
            }
          }
        }
        else
        {
          LODWORD(v134) = 0;
        }
        if (v133 != v134)
        {
          uint64_t v137 = v134;
          do
          {
            uint64_t v138 = *(void *)(a1 + 112) + 32 * v137;
            uint64_t v141 = *(void *)(v138 + 16);
            uint64_t v140 = v138 + 16;
            uint64_t v139 = v141;
            *(void *)sockaddr buf = v141;
            if (v141) {
              id v142 = (id)(v139 + 8);
            }
            *(void *)&uint8_t buf[8] = re::SyncObject::latestStateHandle(*(re::SyncObject **)v140);
            uint8_t buf[16] = *(unsigned char *)(v140 + 8);
            re::DynamicArray<re::internal::SyncSnapshotEntry>::add(&v168, (uint64_t)buf);
            if (*(void *)buf) {

            }
            if (*(_DWORD *)(a1 + 128) <= (v134 + 1)) {
              int v143 = v134 + 1;
            }
            else {
              int v143 = *(_DWORD *)(a1 + 128);
            }
            while (1)
            {
              uint64_t v137 = (v134 + 1);
              if (v143 - 1 == v134) {
                break;
              }
              LODWORD(v134) = v134 + 1;
              int v144 = v137;
              if ((*(_DWORD *)(*(void *)(a1 + 112) + 32 * v137 + 8) & 0x80000000) != 0) {
                goto LABEL_239;
              }
            }
            int v144 = v143;
LABEL_239:
            LODWORD(v134) = v144;
          }
          while (v133 != v144);
        }
        re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::clear(a1 + 96);
        unint64_t v145 = v177;
        if (v177 == -1)
        {
          uint64_t v171 = 0;
          long long v183 = 0u;
          long long v184 = 0u;
          long long v182 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v180 = 136315906;
          *(void *)&v180[4] = "insert";
          *(_WORD *)&v180[12] = 1024;
          *(_DWORD *)&v180[14] = 887;
          *(_WORD *)&v180[18] = 2048;
          *(void *)&v180[20] = 0;
          *(_WORD *)&v180[28] = 2048;
          *(void *)&v180[30] = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        if (v177 >= v176)
        {
          re::DynamicArray<re::SyncCommit>::growCapacity(&v175, v177 + 1);
          unint64_t v145 = v177;
        }
        uint64_t v146 = *(re **)v179;
        uint64_t v147 = (_OWORD *)(*(void *)v179 + 72 * v145);
        if (v145)
        {
          re::SyncCommit::SyncCommit((uint64_t)v147, *(void *)v179 + 72 * v145 - 72);
          int v148 = *(re **)v179;
          if (*(void *)v179 + 72 * v177 - 72 != *(void *)v179)
          {
            uint64_t v149 = 72 * v177;
            do
            {
              uint64_t v150 = (char *)v148 + v149;
              *(_OWORD *)(v150 - 72) = *(_OWORD *)((char *)v148 + v149 - 144);
              *(_OWORD *)(v150 - 59) = *(_OWORD *)((char *)v148 + v149 - 131);
              re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v148 + v149 - 40, (uint64_t *)((char *)v148 + v149 - 112));
              v149 -= 72;
            }
            while (v149 != 72);
            int v148 = *(re **)v179;
          }
          long long v151 = v167[0];
          *(_OWORD *)((char *)v148 + 13) = *(_OWORD *)((char *)v167 + 13);
          *(_OWORD *)int v148 = v151;
          re::DynamicArray<re::internal::SyncSnapshotEntry>::operator=((uint64_t)v148 + 32, (uint64_t *)&v168);
        }
        else
        {
          long long v152 = v167[0];
          *(_OWORD *)((char *)v147 + 13) = *(_OWORD *)((char *)v167 + 13);
          *uint64_t v147 = v152;
          *((void *)v146 + 8) = 0;
          *((void *)v146 + 5) = 0;
          *((void *)v146 + 6) = 0;
          *((void *)v146 + 4) = 0;
          *((_DWORD *)v146 + 14) = 0;
          *((_OWORD *)v146 + 2) = v168;
          *((void *)v146 + 6) = v169;
          long long v168 = 0uLL;
          *(void *)&long long v169 = 0;
          *((void *)v146 + 8) = v170;
          uint64_t v170 = 0;
          ++DWORD2(v169);
          ++*((_DWORD *)v146 + 14);
        }
        ++v177;
        ++v178;
        re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)&v168);
      }
      uint64_t v153 = *(void *)(a1 + 40) + 24;
      *(_DWORD *)&uint8_t buf[16] = 0;
      unsigned char buf[20] = 0;
      *(void *)&unsigned char buf[24] = 0;
      *(void *)&long long v182 = 0;
      *(void *)sockaddr buf = &unk_26DD352E8;
      *(void *)&uint8_t buf[8] = 0;
      *((void *)&v182 + 1) = v153;
      *(void *)&long long v183 = 0;
      uint64_t v154 = *(void *)(a1 + 24);
      *(void *)&v167[0] = *(void *)(a1 + 56);
      *((void *)&v167[0] + 1) = v154;
      LOBYTE(v167[1]) = 0;
      if (v177)
      {
        v155 = *(re **)v179;
        uint64_t v156 = 72 * v177;
        do
        {
          re::SyncPacker::packCommit(v167, (unsigned __int8 *)v155, (re::BitWriter *)buf, a5, 0);
          v155 = (re *)((char *)v155 + 72);
          v156 -= 72;
        }
        while (v156);
        int v157 = *(_DWORD *)&buf[24];
        if (*(_DWORD *)&buf[28]) {
          int v157 = *(_DWORD *)&buf[24] + 1;
        }
        if (v157)
        {
          uint64_t v158 = *(void *)(a1 + 40);
          *(_DWORD *)(v183 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v157;
          *(void *)&unsigned char buf[24] = 0;
          *(void *)&long long v182 = 0;
          *(void *)&uint8_t buf[8] = 0;
          *(_DWORD *)&uint8_t buf[16] = 0;
          *(void *)&long long v183 = 0;
          (*(void (**)(uint64_t))(*(void *)v158 + 48))(v158);
        }
      }
      if (*(void *)(a1 + 24) && v177)
      {
        BOOL v159 = *(re **)v179;
        uint64_t v160 = *(void *)v179 + 72 * v177;
        do
        {
          uint64_t v161 = *((void *)v159 + 6);
          if (v161)
          {
            uint64_t v162 = *((void *)v159 + 8);
            uint64_t v163 = 24 * v161;
            do
            {
              uint64_t v164 = *(void *)(a1 + 24);
              if ((*(unsigned char *)(v162 + 16) & 2) != 0) {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v164 + 24, (uint64_t *)v162);
              }
              else {
                re::SyncAckedStateBuffer::addAcked(v164, (uint64_t *)v162, *(void *)(v162 + 8), *(unsigned __int16 *)(*(void *)v162 + 176));
              }
              v162 += 24;
              v163 -= 24;
            }
            while (v163);
          }
          BOOL v159 = (re *)((char *)v159 + 72);
        }
        while (v159 != (re *)v160);
      }
      if ((void)v183) {
        (*(void (**)(void))(**((void **)&v182 + 1) + 24))(*((void *)&v182 + 1));
      }
    }
    re::DynamicArray<re::SyncCommit>::deinit((uint64_t)&v175);
  }
  else
  {
    int v38 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
    if (v38) {
      uint64_t v39 = v38 - 8;
    }
    else {
      uint64_t v39 = 0;
    }
    uint64_t v40 = v39 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v39 + 32))(buf);
    uint64_t v41 = *(NSObject **)(*(void *)buf + 3272);

    *(void *)sockaddr buf = 0;
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      _os_log_error_impl(&dword_228C70000, v41, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to send.", buf, 2u);
    }
  }
}

BOOL re::SyncReliableOrderedUnicast::receive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4 && *(void *)(a1 + 56))
  {
    if (*(unsigned char *)(a1 + 91))
    {
      *(unsigned char *)(a1 + 91) = 0;
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 56))(v4);
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v58 = a2;
        while (1)
        {
          uint64_t v57 = v7;
          int v8 = *(_DWORD *)(v7 + 24);
          uint64_t v81 = *(void *)(v7 + 16);
          int v82 = v8;
          char v83 = 0;
          uint64_t v84 = 0;
          uint64_t v85 = 0;
          while (v82 != v84)
          {
            uint64_t v9 = *(void *)(a1 + 56);
            id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 80));
            __int16 v11 = *(_WORD *)(a1 + 88);
            uint64_t v12 = WeakRetained - 8;
            if (!WeakRetained) {
              uint64_t v12 = 0;
            }
            *(void *)uint64_t v68 = v9;
            uint64_t v69 = v12;
            long long v70 = *(_OWORD *)(a1 + 64);
            long long v71 = 0u;
            long long v72 = 0u;
            unsigned int v73 = 0;
            uint64_t v74 = 0x7FFFFFFFLL;
            uint64_t v79 = 0;
            uint64_t v76 = 0;
            uint64_t v77 = 0;
            uint64_t v75 = 0;
            int v78 = 0;
            __int16 v80 = v11;
            if (WeakRetained) {

            }
            v61[0] = 0;
            uint64_t v67 = 0;
            v64[1] = 0;
            uint64_t v65 = 0;
            v64[0] = 0;
            int v66 = 0;
            uint64_t v62 = 0;
            v63[0] = 0;
            *(void *)((char *)v63 + 5) = 0;
            int v60 = re::SyncUnpacker::unpackCommit((_anonymous_namespace_ *)v68, (uint64_t)&v81, (uint64_t)v61, a2);
            if (!v60)
            {
              uint64_t v17 = *(void *)(a1 + 40);
              uint64_t v18 = *(void *)(v17 + 32);
              if (v18) {
                long long v19 = (re::Transport *)(v18 - 8);
              }
              else {
                long long v19 = 0;
              }
              re::Transport::connectionAddress(v19, *(void *)(v17 + 40), (re::DynamicString *)buf);
              uint64_t v20 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
              if (v20) {
                uint64_t v21 = v20 - 8;
              }
              else {
                uint64_t v21 = 0;
              }
              BOOL v22 = v21 + 8;
              (*(void (**)(unsigned char *__return_ptr))(*(void *)v21 + 32))(v86);
              uint64_t v23 = *(NSObject **)(*(void *)v86 + 3272);

              *(void *)uint64_t v86 = 0;
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
              {
                uint64_t v50 = *(void *)(a1 + 64);
                uint64_t v51 = &buf[9];
                if (buf[8]) {
                  uint64_t v51 = *(unsigned char **)&buf[16];
                }
                *(_DWORD *)uint64_t v86 = 134218242;
                *(void *)&v86[4] = v50;
                __int16 v87 = 2082;
                uint64_t v88 = v51;
                _os_log_error_impl(&dword_228C70000, v23, OS_LOG_TYPE_ERROR, "Failed to parse incoming packet. Will drop peer.(peerID=%llu, address=%{public}s)", v86, 0x16u);
              }
              (*(void (**)(void, uint64_t))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), v57);
              if (*(void *)buf && (buf[8] & 1) != 0) {
                (*(void (**)(void))(**(void **)buf + 40))();
              }
              goto LABEL_41;
            }
            unsigned int v13 = v73;
            if (v73)
            {
              uint64_t v14 = 0;
              uint64_t v15 = (int *)(v72 + 8);
              while (1)
              {
                int v16 = *v15;
                v15 += 10;
                if (v16 < 0) {
                  break;
                }
                if (v73 == ++v14)
                {
                  LODWORD(v14) = v73;
                  break;
                }
              }
            }
            else
            {
              LODWORD(v14) = 0;
            }
            if (v73 != v14)
            {
              uint64_t v29 = v14;
              uint64_t v30 = v72;
              while (1)
              {
                uint64_t v31 = v30 + 40 * v29;
                uint64_t v32 = *(void *)(v31 + 24);
                uint64_t v33 = *(void *)(v31 + 32);
                uint64_t v34 = (char *)objc_loadWeakRetained((id *)(a1 + 80));
                uint64_t v35 = v34;
                if (v34) {
                  uint64_t v36 = (re::SyncObjectStore *)(v34 - 8);
                }
                else {
                  uint64_t v36 = 0;
                }
                re::SyncObjectStore::findObject(v36, v32, v33, (re::SyncObjectTypedStore ***)v86);
                if (v35) {

                }
                int v37 = (re::SyncObject **)(v31 + 16);
                uint64_t v38 = *(void *)v86;
                if (*(void *)v86) {
                  break;
                }
                id v41 = objc_loadWeakRetained((id *)(a1 + 80));
                if (v41)
                {
                  uint64_t v42 = v41;
                  uint64_t v43 = (char *)objc_loadWeakRetained((id *)(a1 + 80));
                  uint64_t v44 = v43 - 8;
                  if (!v43) {
                    uint64_t v44 = 0;
                  }
                  uint64_t v45 = *(void *)(*(void *)(*((void *)*v37 + 11) + 16) + 32);
                  *(void *)sockaddr buf = *((void *)*v37 + 3);
                  *(void *)&uint8_t buf[8] = v45;
                  *(void *)&uint8_t buf[16] = 0;
                  BOOL v46 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)(v44 + 600), (uint64_t *)buf);
                  if (v43) {

                  }
                  if (!v46)
                  {
                    uint64_t v48 = *re::networkLogObjects(v47);
                    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v49 = *((void *)*v37 + 3);
                      *(_DWORD *)sockaddr buf = 134218240;
                      *(void *)&uint8_t buf[4] = v49;
                      *(_WORD *)&unsigned char buf[12] = 2048;
                      *(void *)&buf[14] = v33;
                      _os_log_error_impl(&dword_228C70000, v48, OS_LOG_TYPE_ERROR, "BindFailure: Object %llu with parent %llu", buf, 0x16u);
                    }
                  }
                  uint64_t v38 = *(void *)v86;
                  if (*(void *)v86) {
                    goto LABEL_55;
                  }
                }
LABEL_56:
                uint64_t v30 = v72;
                if (v73 <= (int)v14 + 1) {
                  unsigned int v39 = v14 + 1;
                }
                else {
                  unsigned int v39 = v73;
                }
                while (1)
                {
                  uint64_t v29 = (v14 + 1);
                  if (v39 - 1 == v14) {
                    break;
                  }
                  LODWORD(v14) = v14 + 1;
                  unsigned int v40 = v29;
                  if ((*(_DWORD *)(v72 + 40 * v29 + 8) & 0x80000000) != 0) {
                    goto LABEL_63;
                  }
                }
                unsigned int v40 = v39;
LABEL_63:
                LODWORD(v14) = v40;
                if (v13 == v40) {
                  goto LABEL_30;
                }
              }
              re::SyncObject::bindWithParent(*v37, *(re::SyncObject **)v86);
LABEL_55:

              goto LABEL_56;
            }
LABEL_30:
            if (v65)
            {
              signed int v24 = (unsigned char *)(v67 + 16);
              uint64_t v25 = 24 * v65;
              do
              {
                uint64_t v26 = *((void *)v24 - 2);
                if ((*v24 & 2) != 0 || (*(unsigned char *)(v26 + 128) & 4) != 0) {
                  (*(void (**)(void, void, void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), *(void *)(v26 + 24), *(void *)(*(void *)(*(void *)(v26 + 88) + 16) + 32));
                }
                v24 += 24;
                v25 -= 24;
              }
              while (v25);
            }
            if (*(void *)(a1 + 24) && v65)
            {
              uint64_t v27 = (uint64_t *)v67;
              uint64_t v28 = 24 * v65;
              do
              {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(*(void *)(a1 + 24) + 24, v27);
                v27 += 3;
                v28 -= 24;
              }
              while (v28);
            }
            re::SyncCommitDump::log((re *)v61, 1, "RecvCommit");
            a2 = v58;
            (*(void (**)(uint64_t, char *, uint64_t))(a3 + 16))(a3, v61, v58);
LABEL_41:
            re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)v64);
            if (v75)
            {
              if (v79) {
                (*(void (**)(void))(*(void *)v75 + 40))();
              }
              uint64_t v79 = 0;
              uint64_t v76 = 0;
              uint64_t v77 = 0;
              uint64_t v75 = 0;
              ++v78;
            }
            re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)&v71);
            if (!v60) {
              return 0;
            }
          }
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), v57);
          uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 56))(*(void *)(a1 + 40));
          BOOL result = 1;
          if (!v7) {
            return result;
          }
        }
      }
    }
    return 1;
  }
  else
  {
    int v53 = (char *)objc_loadWeakRetained((id *)(a1 + 32));
    if (v53) {
      uint64_t v54 = v53 - 8;
    }
    else {
      uint64_t v54 = 0;
    }
    uint64_t v55 = v54 + 8;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v54 + 32))(v68);
    uint64_t v56 = *(NSObject **)(*(void *)v68 + 3272);

    *(void *)uint64_t v68 = 0;
    BOOL result = os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)uint64_t v68 = 0;
      _os_log_error_impl(&dword_228C70000, v56, OS_LOG_TYPE_ERROR, "Transport is destroyed but trying to receive.", v68, 2u);
      return 0;
    }
  }
  return result;
}

_DWORD *re::SyncReliableOrderedUnicast::sendOwnershipRequests(uint64_t a1, uint64_t a2)
{
  return re::MessageStreamer<re::SyncOwnershipRequest>::send(*(_DWORD **)(a1 + 48), *(re::SyncOwnershipRequest **)a2, *(void *)(a2 + 8));
}

uint64_t re::SyncReliableOrderedUnicast::receiveOwnershipRequests(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 92)) {
    return 1;
  }
  *(unsigned char *)(a1 + 92) = 0;
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v10 = *(void *)(a2 + 24);
  __int16 v11 = 0;
  if (v9 != (unsigned char *)a2)
  {
    re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable((uint64_t)v9);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      if (v5 >= 0x19)
      {
        if (v10) {
          uint64_t v6 = (unsigned char *)(*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v10 + 32))(v10, v5, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      else
      {
        uint64_t v6 = v9;
      }
      __int16 v11 = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  uint64_t v7 = re::MessageStreamer<re::SyncOwnershipRequest>::receive<re::Function<void ()(re::SyncOwnershipRequest const&)>>(v3, (uint64_t)v9);
  re::FunctionBase<24ul,void ()(re::SyncOwnershipRequest const&)>::destroyCallable((uint64_t)v9);
  return v7;
}

uint64_t re::SyncReliableOrderedUnicast::pause(uint64_t this)
{
  *(unsigned char *)(this + 90) = 1;
  return this;
}

uint64_t re::SyncReliableOrderedUnicast::resume(uint64_t this)
{
  *(unsigned char *)(this + 90) = 0;
  return this;
}

void re::SyncReliableOrderedUnicast::~SyncReliableOrderedUnicast(re::SyncReliableOrderedUnicast *this)
{
  re::SyncReliableOrderedUnicast::~SyncReliableOrderedUnicast(this);
  JUMPOUT(0x22A6A9430);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 12);
  objc_destroyWeak((id *)this + 10);
  *((void *)this + 10) = 0;
  uint64_t v2 = *((void *)this + 7);
  if (v2)
  {

    *((void *)this + 7) = 0;
  }
  uint64_t v3 = *((void *)this + 6);
  if (v3)
  {

    *((void *)this + 6) = 0;
  }
  uint64_t v4 = *((void *)this + 5);
  if (v4)
  {

    *((void *)this + 5) = 0;
  }
  objc_destroyWeak((id *)this + 4);
  *((void *)this + 4) = 0;
  unint64_t v5 = *((void *)this + 3);
  if (v5)
  {

    *((void *)this + 3) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

uint64_t RESyncParticipantListCount(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t RESyncParticipantListAtIndex(uint64_t result, unint64_t a2)
{
  if (result)
  {
    unint64_t v2 = *(void *)(result + 16);
    if (v2 >= a2)
    {
      if (v2 <= a2)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      return *(void *)(*(void *)(result + 32) + 8 * a2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t RESyncNetSessionCreate(void *a1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v4 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)uint64_t v6 = 136315394;
    *(void *)&v6[4] = "RESyncNetSessionCreate";
    __int16 v7 = 2080;
    int v8 = "configuration != __null";
    unint64_t v5 = "%s: Invalid parameter not satisfying %s.";
LABEL_15:
    _os_log_error_impl(&dword_228C70000, v4, OS_LOG_TYPE_ERROR, v5, v6, 0x16u);
    return 0;
  }
  int v1 = (long long *)(a1 + 3);
  if (!a1[3])
  {
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)uint64_t v6 = 136315394;
    *(void *)&v6[4] = "RESyncNetSessionCreate";
    __int16 v7 = 2080;
    int v8 = "Use RESyncNetSessionConfigurationSetTransportQueue() to configure transport queue.";
    unint64_t v5 = "%s: %s";
    goto LABEL_15;
  }
  if (!a1[11])
  {
    uint64_t v4 = *re::networkLogObjects((re *)a1);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)uint64_t v6 = 136315394;
    *(void *)&v6[4] = "RESyncNetSessionCreate";
    __int16 v7 = 2080;
    int v8 = "Use RESyncNetSessionConfigurationSetDiscoveryView() to configure discovery view.";
    unint64_t v5 = "%s: %s";
    goto LABEL_15;
  }
  re::make::shared::object<re::Session>((re *)a1, v6);
  BOOL v2 = re::Session::init(*(uint64_t *)v6, v1);
  uint64_t result = *(void *)v6;
  if (!v2 && *(void *)v6)
  {

    return 0;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetTransportQueue(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionShutdown(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 32))();
}

BOOL RESyncNetSessionIsInitialized(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 2272) != 0;
  }
  return result;
}

BOOL RESyncNetSessionIsActive(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 3264) == 2;
  }
  return result;
}

re::Session *RESyncNetSessionPeerID(re::Session *result)
{
  if (result) {
    return (re::Session *)re::Session::peerID(result);
  }
  return result;
}

uint64_t RESyncNetSessionLeader(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = a1[392];
  if (!v1) {
    return 0;
  }
  uint64_t v2 = a1[287];
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (uint64_t *)a1[289];
  uint64_t v4 = 8 * v2;
  while (1)
  {
    uint64_t v5 = *v3;
    if (*(void *)(*v3 + 24) == v1) {
      break;
    }
    ++v3;
    v4 -= 8;
    if (!v4) {
      return 0;
    }
  }
  id v7 = (id)(v5 + 8);

  return v5;
}

uint64_t RESyncNetSessionGetDiscoveryView(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 2208);
  if (v1)
  {
    id v2 = (id)(v1 + 8);
  }
  return v1;
}

double RESyncNetSessionObserverCreate(re *a1)
{
  uint64_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 144, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)uint64_t v2 = &unk_26DD35B98;
  *(_OWORD *)(v2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0u;
  *(_OWORD *)(v2 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 100) = 0u;
  *(void *)&double result = 0x7FFFFFFFLL;
  *(void *)(v2 + 116) = 0x7FFFFFFFLL;
  *(void *)(v2 + 128) = 0;
  *(void *)(v2 + 136) = 0;
  return result;
}

double RESyncNetSessionAddObserver(_DWORD *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (a1 && a2)
  {
    uint64_t v16 = a2;
    *((void *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 30, (uint64_t)&v16);
    uint64_t v16 = a2;
    *((void *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 52, (uint64_t)&v16);
    uint64_t v16 = a2;
    *((void *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 74, (uint64_t)&v16);
    uint64_t v16 = a2;
    *((void *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 96, (uint64_t)&v16);
    uint64_t v16 = a2;
    *((void *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 426, (uint64_t)&v16);
    uint64_t v4 = *(unsigned int *)(a2 + 112);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = (int *)(*(void *)(a2 + 96) + 8);
      while (1)
      {
        int v7 = *v6;
        v6 += 6;
        if (v7 < 0) {
          break;
        }
        if (v4 == ++v5)
        {
          LODWORD(v5) = *(_DWORD *)(a2 + 112);
          break;
        }
      }
    }
    else
    {
      LODWORD(v5) = 0;
    }
    if (v4 != v5)
    {
      uint64_t v8 = v5;
      do
      {
        uint64_t v9 = *(unsigned __int8 *)(*(void *)(a2 + 96) + 24 * v8 + 12);
        *(void *)&long long v14 = a2;
        *(void *)&long long v15 = 0;
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)&a1[22 * v9 + 140], &v14, (uint64_t)&v16);
        if (!(_BYTE)v16)
        {
          if (a1[22 * v9 + 160])
          {
            LOBYTE(v16) = 1;
            long long v17 = v14;
            long long v18 = v15;
            re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)&a1[22 * v9 + 150], (uint64_t)&v16);
          }
          else
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)&a1[22 * v9 + 140], (uint64_t)&v14);
          }
        }
        unsigned int v10 = *(_DWORD *)(a2 + 112);
        if (v10 <= (int)v5 + 1) {
          int v11 = v5 + 1;
        }
        else {
          int v11 = *(_DWORD *)(a2 + 112);
        }
        while (1)
        {
          uint64_t v8 = (v5 + 1);
          if (v11 - 1 == v5) {
            break;
          }
          LODWORD(v5) = v5 + 1;
          int v12 = v8;
          if ((*(_DWORD *)(*(void *)(a2 + 96) + 24 * v8 + 8) & 0x80000000) != 0) {
            goto LABEL_22;
          }
        }
        int v12 = v11;
LABEL_22:
        LODWORD(v5) = v12;
      }
      while (v10 != v12);
    }
    uint64_t v16 = a2;
    *((void *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 448, (uint64_t)&v16);
    uint64_t v16 = a2;
    *((void *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 470, (uint64_t)&v16);
    uint64_t v16 = a2;
    *((void *)&v17 + 1) = 0;
    re::Event<re::Session>::addSubscription(a1 + 492, (uint64_t)&v16);
    uint64_t v16 = a2;
    *((void *)&v17 + 1) = 0;
    return re::Event<re::Session>::addSubscription(a1 + 514, (uint64_t)&v16);
  }
  return result;
}

void RESyncNetSessionRemoveObserver(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (!a1 || !a2) {
    return;
  }
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 2056, a2);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 1968, a2);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 1880, a2);
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 1792, a2);
  uint64_t v4 = *(unsigned int *)(a2 + 112);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (int *)(*(void *)(a2 + 96) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 6;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a2 + 112);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 == v5) {
    goto LABEL_28;
  }
  uint64_t v8 = v5;
  do
  {
    unsigned int v9 = *(unsigned __int8 *)(*(void *)(a2 + 96) + 24 * v8 + 12);
    uint64_t v10 = a1 + 88 * v9;
    if (!*(void *)(v10 + 576)) {
      goto LABEL_20;
    }
    unint64_t v11 = 0;
    int v12 = (void *)(v10 + 560);
    uint64_t v13 = a1 + 88 * v9;
    long long v14 = (_DWORD *)(v13 + 640);
    uint64_t v15 = v13 + 600;
    do
    {
      uint64_t v16 = v12[4] + 32 * v11;
      if (*(void *)v16 != a2) {
        goto LABEL_16;
      }
      if (*v14)
      {
        v31[0] = 0;
        long long v32 = *(_OWORD *)v16;
        long long v33 = *(_OWORD *)(v16 + 16);
        re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v15, (uint64_t)v31);
LABEL_16:
        ++v11;
        continue;
      }
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v12, v11);
    }
    while (v11 < v12[2]);
    LODWORD(v4) = *(_DWORD *)(a2 + 112);
LABEL_20:
    if (v4 <= (int)v5 + 1) {
      int v17 = v5 + 1;
    }
    else {
      int v17 = v4;
    }
    while (1)
    {
      uint64_t v8 = (v5 + 1);
      if (v17 - 1 == v5) {
        break;
      }
      LODWORD(v5) = v5 + 1;
      int v18 = v8;
      if ((*(_DWORD *)(*(void *)(a2 + 96) + 24 * v8 + 8) & 0x80000000) != 0) {
        goto LABEL_27;
      }
    }
    int v18 = v17;
LABEL_27:
    LODWORD(v5) = v18;
  }
  while (v4 != v18);
LABEL_28:
  if (*(void *)(a1 + 400))
  {
    unint64_t v19 = 0;
    do
    {
      uint64_t v20 = (long long *)(*(void *)(a1 + 416) + 32 * v19);
      if (*(void *)v20 == a2)
      {
        if (!*(_DWORD *)(a1 + 464))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(a1 + 384), v19);
          continue;
        }
        v31[0] = 0;
        long long v21 = v20[1];
        long long v32 = *v20;
        long long v33 = v21;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 424), (uint64_t)v31);
      }
      ++v19;
    }
    while (v19 < *(void *)(a1 + 400));
  }
  if (*(void *)(a1 + 312))
  {
    unint64_t v22 = 0;
    do
    {
      uint64_t v23 = (long long *)(*(void *)(a1 + 328) + 32 * v22);
      if (*(void *)v23 == a2)
      {
        if (!*(_DWORD *)(a1 + 376))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(a1 + 296), v22);
          continue;
        }
        v31[0] = 0;
        long long v24 = v23[1];
        long long v32 = *v23;
        long long v33 = v24;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 336), (uint64_t)v31);
      }
      ++v22;
    }
    while (v22 < *(void *)(a1 + 312));
  }
  if (*(void *)(a1 + 224))
  {
    unint64_t v25 = 0;
    do
    {
      uint64_t v26 = (long long *)(*(void *)(a1 + 240) + 32 * v25);
      if (*(void *)v26 == a2)
      {
        if (!*(_DWORD *)(a1 + 288))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(a1 + 208), v25);
          continue;
        }
        v31[0] = 0;
        long long v27 = v26[1];
        long long v32 = *v26;
        long long v33 = v27;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 248), (uint64_t)v31);
      }
      ++v25;
    }
    while (v25 < *(void *)(a1 + 224));
  }
  if (*(void *)(a1 + 136))
  {
    unint64_t v28 = 0;
    do
    {
      uint64_t v29 = (long long *)(*(void *)(a1 + 152) + 32 * v28);
      if (*(void *)v29 == a2)
      {
        if (!*(_DWORD *)(a1 + 200))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(a1 + 120), v28);
          continue;
        }
        v31[0] = 0;
        long long v30 = v29[1];
        long long v32 = *v29;
        long long v33 = v30;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 160), (uint64_t)v31);
      }
      ++v28;
    }
    while (v28 < *(void *)(a1 + 136));
  }
  re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(a1 + 1704, a2);
}

void *RESyncNetSessionObserverOnStart(uint64_t a1, const void *a2)
{
  _Block_release(*(const void **)(a1 + 24));
  double result = _Block_copy(a2);
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = result;
  return result;
}

void *RESyncNetSessionObserverOnStop(uint64_t a1, const void *a2)
{
  _Block_release(*(const void **)(a1 + 32));
  double result = _Block_copy(a2);
  *(void *)(a1 + 32) = result;
  return result;
}

void *RESyncNetSessionObserverOnParticipantJoin(uint64_t a1, const void *a2)
{
  _Block_release(*(const void **)(a1 + 40));
  double result = _Block_copy(a2);
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = result;
  return result;
}

void *RESyncNetSessionObserverOnParticipantLeave(uint64_t a1, const void *a2)
{
  _Block_release(*(const void **)(a1 + 48));
  double result = _Block_copy(a2);
  *(void *)(a1 + 48) = result;
  return result;
}

void RESyncNetSessionObserverOnReceiveUserData(uint64_t a1, const void *a2)
{
}

void anonymous namespace'::SessionObserverProxy::setOnReceiveData(uint64_t a1, const void *a2, unsigned int a3)
{
  char v15 = a3;
  uint64_t v6 = (void *)(a1 + 80);
  int v7 = (const void **)re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::tryGet(a1 + 80, a3);
  if (v7) {
    _Block_release(*v7);
  }
  uint64_t v8 = _Block_copy(a2);
  long long v14 = v8;
  unint64_t v9 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * a3) ^ ((0xBF58476D1CE4E5B9 * a3) >> 27));
  unint64_t v10 = v9 ^ (v9 >> 31);
  if (!*v6)
  {
    LODWORD(v11) = 0;
    goto LABEL_10;
  }
  unint64_t v11 = v10 % *(unsigned int *)(a1 + 104);
  uint64_t v12 = *(unsigned int *)(*(void *)(a1 + 88) + 4 * v11);
  if (v12 == 0x7FFFFFFF)
  {
LABEL_10:
    re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::addAsMove((uint64_t)v6, v11, v10, &v15, &v14);
    goto LABEL_11;
  }
  uint64_t v13 = *(void *)(a1 + 96);
  while (*(unsigned __int8 *)(v13 + 24 * v12 + 12) != a3)
  {
    LODWORD(v12) = *(_DWORD *)(v13 + 24 * v12 + 8) & 0x7FFFFFFF;
    if (v12 == 0x7FFFFFFF) {
      goto LABEL_10;
    }
  }
  *(void *)(v13 + 24 * v12 + 16) = v8;
LABEL_11:
  ++*(_DWORD *)(a1 + 120);
}

void RESyncNetSessionObserverOnReceiveData(uint64_t a1, unsigned int a2, const void *a3)
{
}

void *RESyncNetSessionObserverOnLeaderChanged(uint64_t a1, const void *a2)
{
  _Block_release(*(const void **)(a1 + 56));
  double result = _Block_copy(a2);
  *(void *)(a1 + 56) = result;
  return result;
}

void *RESyncNetSessionObserverOnConnectionConnected(uint64_t a1, const void *a2)
{
  _Block_release(*(const void **)(a1 + 64));
  double result = _Block_copy(a2);
  *(void *)(a1 + 64) = result;
  return result;
}

void *RESyncNetSessionObserverOnConnectionDisconnected(uint64_t a1, const void *a2)
{
  _Block_release(*(const void **)(a1 + 72));
  double result = _Block_copy(a2);
  *(void *)(a1 + 72) = result;
  return result;
}

void *RESyncNetSessionObserverOnPeerDidPause(uint64_t a1, const void *a2)
{
  _Block_release(*(const void **)(a1 + 128));
  double result = _Block_copy(a2);
  *(void *)(a1 + 128) = result;
  return result;
}

void *RESyncNetSessionObserverOnPeerDidResume(uint64_t a1, const void *a2)
{
  _Block_release(*(const void **)(a1 + 136));
  double result = _Block_copy(a2);
  *(void *)(a1 + 136) = result;
  return result;
}

uint64_t RESyncNetSessionParticipantsCount(uint64_t result)
{
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 40))(result);
    return v1;
  }
  return result;
}

uint64_t RESyncNetSessionGetParticipantAtIndex(uint64_t result, unint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
    if (v4 <= a2)
    {
      re::internal::assertLog((re::internal *)6, v4, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size_t size = %zu", "index < size()", "operator[]", 251, a2, v4);
      double result = _os_crash();
      __break(1u);
    }
    else
    {
      return *(void *)(v3 + 8 * a2);
    }
  }
  return result;
}

uint64_t RESyncNetSessionGetParticipantWithIdentity(void *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    uint64_t v6 = a2;
    id v4 = (id)(a2 + 8);
    re::Session::findParticipantWithIdentity(a1, &v6, &v7);
    uint64_t v2 = v7;
    if (v7)
    {

      uint64_t v7 = 0;
    }
    if (v6) {
  }
    }
  return v2;
}

uint64_t RESyncNetSessionGetParticipantWithPeerID(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 2296);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(uint64_t **)(a1 + 2312);
  uint64_t v4 = 8 * v2;
  while (1)
  {
    uint64_t v5 = *v3;
    if (*(void *)(*v3 + 24) == a2) {
      break;
    }
    ++v3;
    v4 -= 8;
    if (!v4) {
      return 0;
    }
  }
  id v7 = (id)(v5 + 8);

  return v5;
}

void RESyncNetSessionDropParticipant(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2) {
      re::Transport::disconnect((re::Transport *)(a1 + 2320), *(void *)(a2 + 32), 1);
    }
  }
}

uint64_t (***RESyncNetSessionSetDisconnectTimeout(uint64_t (***result)(void), int a2))(void)
{
  if (result) {
    return re::Transport::setDisconnectTimeout((re::Transport *)(result + 290), a2);
  }
  return result;
}

uint64_t RESyncNetSessionGetIsLocalPeer(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

BOOL RESyncNetSessionGetIsLocal(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 2219) != 0;
  }
  return result;
}

uint64_t RESyncNetSessionSetIsLocal(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 2219) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionSendData(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)result + 64))(result, a2, a3, a4, a5, 1, 0);
  }
  return result;
}

uint64_t RESyncNetSessionSendDataUnreliableUnordered(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)result + 64))(result, a2, a3, a4, a5, 1, 2);
  }
  return result;
}

uint64_t RESyncNetSessionIncomingUpdate(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t RESyncNetSessionOutgoingUpdate(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 56))();
  }
  return result;
}

uint64_t RESyncNetSessionLastStatsAggregated@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  if (result)
  {
    uint64_t v2 = result + 32 * ((*(_DWORD *)(result + 7408) - 1) & 0x7F);
    int v3 = *(_DWORD *)(v2 + 3308);
    *(_DWORD *)a2 = *(_DWORD *)(v2 + 3304);
    *(_DWORD *)(a2 + 4) = v3;
    *(_OWORD *)(a2 + 8) = *(_OWORD *)(v2 + 3312);
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  return result;
}

void RESyncNetSessionAveragedStatsAggregated(re::Session *a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  if (a1)
  {
    long long v4 = 0uLL;
    uint64_t v5 = 0;
    re::Session::averagedStatsAggregated(a1, (uint64_t)&v4, a3);
    *(_OWORD *)a2 = v4;
    *(void *)(a2 + 16) = v5;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
}

re *RESyncNetSessionCopyLocalAddresses(re *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *((void *)a1 + 304);
  uint64_t v2 = *((void *)a1 + 302);
  int v3 = re::globalAllocators(a1);
  long long v4 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v3[2] + 32))(v3[2], 8 * v2, 0);
  uint64_t v5 = v4;
  if (v2)
  {
    uint64_t v6 = 0;
    id v7 = (char **)(v1 + 16);
    do
    {
      if (*(unsigned char *)(v7 - 1)) {
        uint64_t v8 = *v7;
      }
      else {
        uint64_t v8 = (char *)v7 - 7;
      }
      *((void *)v4 + v6++) = v8;
      v7 += 4;
    }
    while (v2 != v6);
    unint64_t v9 = RESyncAddressListCreate(v4, v2);
    unint64_t v10 = v9;
    goto LABEL_11;
  }
  unint64_t v9 = RESyncAddressListCreate(v4, 0);
  unint64_t v10 = v9;
  if (v5)
  {
LABEL_11:
    unint64_t v11 = re::globalAllocators(v9);
    (*(void (**)(uint64_t, re *))(*(void *)v11[2] + 40))(v11[2], v5);
  }
  return v10;
}

uint64_t RESyncParticipantGetIdentity(uint64_t result)
{
  if (result) {
    return *(void *)(result + 152);
  }
  return result;
}

uint64_t RESyncParticipantGetPeerID(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t RESyncParticipantGetUserContext@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  if (result)
  {
    *(_DWORD *)a2 = 0;
    uint64_t v2 = *(void *)(result + 128);
    if (v2) {
      uint64_t v3 = *(void *)(result + 144);
    }
    else {
      uint64_t v3 = 0;
    }
    *(void *)(a2 + 8) = v3;
    *(void *)(a2 + 16) = v2;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  return result;
}

uint64_t RESyncParticipantGetAddress(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 48)) {
      return *(void *)(result + 56);
    }
    else {
      result += 49;
    }
  }
  return result;
}

uint64_t RESyncParticipantHasForceAuthorityCapability(uint64_t result)
{
  if (result) {
    return (*(unsigned __int8 *)(result + 72) >> 1) & 1;
  }
  return result;
}

BOOL RESyncParticipantHasCapability(BOOL result, int a2)
{
  if (result) {
    return (a2 & ~*(_DWORD *)(result + 72)) == 0;
  }
  return result;
}

uint64_t RESyncLeaderElectionCreateLowestPeerID(re *a1)
{
  re::make::shared::object<re::LeaderElectionLowestPeerID>(a1, &v2);
  return v2;
}

double RESyncNetSessionConfigurationCreate(re *a1)
{
  uint64_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 152, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  *(void *)(v2 + 144) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)uint64_t v2 = &unk_26DD35BE0;
  *(void *)(v2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = MEMORY[0x263EF83A0];
  *(void *)(v2 + 32) = 0x7B61A86B3;
  *(void *)(v2 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  *(void *)(v2 + 48) = 0x61A800000000;
  *(void *)(v2 + 56) = 0;
  *(unsigned char *)(v2 + 64) = 0;
  *(void *)(v2 + 80) = 0;
  *(void *)(v2 + 88) = 0;
  *(void *)(v2 + 72) = 0;
  *(_DWORD *)(v2 + 96) = 0;
  *(_DWORD *)(v2 + 100) = 16777473;
  *(void *)&double result = 500;
  *(void *)(v2 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 500;
  *(_DWORD *)(v2 + 112) = 10485760;
  *(_WORD *)(v2 + 116) = 257;
  *(_DWORD *)(v2 + 120) = 10;
  *(void *)(v2 + 128) = 0;
  *(void *)(v2 + 136) = 0;
  *(_DWORD *)(v2 + 144) = 0;
  return result;
}

uint64_t RESyncNetSessionConfigurationSetIsLeader(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 64) = a2;
  }
  return result;
}

void RESyncNetSessionSetLeader(re::Session *this, uint64_t a2)
{
  if (this)
  {
    *((void *)this + 392) = a2;
    re::Session::onLeaderChange(this, a2);
  }
}

void RESyncNetSessionConfigurationSetAllowLeaderMigration(re *a1, char a2)
{
  if (a1)
  {
    if (a2)
    {
      re::make::shared::object<re::LeaderElectionLowestPeerID>(a1, &v4);
      uint64_t v3 = v4;
      RESyncNetSessionConfigurationSetLeaderElection(a1, v4);
      if (v3) {
    }
      }
    else
    {
      RESyncNetSessionConfigurationSetLeaderElection(a1, 0);
    }
  }
}

void RESyncNetSessionConfigurationSetLeaderElection(re *a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = a2;
    if (a2)
    {
      id v4 = (id)(a2 + 8);
    }
    else
    {
      uint64_t v5 = re::globalAllocators(a1);
      uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 40, 8);
      *(_OWORD *)uint64_t v2 = 0u;
      *(_OWORD *)(v2 + 16) = 0u;
      *(void *)(v2 + 32) = 0;
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
      *(void *)uint64_t v2 = &unk_26DD34718;
    }
    uint64_t v6 = *((void *)a1 + 7);
    *((void *)a1 + 7) = v2;
    if (v6)
    {
    }
  }
}

void RESyncNetSessionConfigurationSetLeaderElectionPolicy(re *a1, int a2)
{
  if (a1)
  {
    if (a2 == 1)
    {
      re::make::shared::object<re::LeaderElectionLowestPeerID>(a1, &v4);
      uint64_t v3 = v4;
      RESyncNetSessionConfigurationSetLeaderElection(a1, v4);
      if (v3) {
    }
      }
    else
    {
      RESyncNetSessionConfigurationSetLeaderElection(a1, 0);
    }
  }
}

uint64_t RESyncNetSessionConfigurationSetUserContext(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(a2 + 16);
    *(void *)(result + 72) = *(void *)(a2 + 8);
    *(void *)(result + 80) = v2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetAllowTimeSync(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 97) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetAuthorityPolicy(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 96) = a2;
  }
  return result;
}

void RESyncNetSessionConfigurationSetDiscoveryView(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2) {
      id v4 = (id)(a2 + 8);
    }
    uint64_t v5 = *(void *)(a1 + 88);
    *(void *)(a1 + 88) = a2;
    if (v5)
    {
    }
  }
}

uint64_t RESyncNetSessionConfigurationSetIsPrivileged(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 98) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetUnreliableSyncEnabled(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 103) = a2 ^ 1;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetUnreliableResendTimeout(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetCompressionMethod(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 116) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetSyncDeltaCompression(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 117) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetInitTimeOutMs(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 48) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetHandshakeTimeOutMs(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 52) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetMaxHelloPacketsSendCount(uint64_t result, unsigned int a2)
{
  if (result)
  {
    if (a2 <= 1) {
      int v2 = 1;
    }
    else {
      int v2 = a2;
    }
    *(_DWORD *)(result + 120) = v2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetShutdownOnVersionMismatch(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 102) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetMaxUnreliablePacketSize(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 108) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetIsLocal(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 99) = a2;
  }
  return result;
}

uint64_t RESyncNetSessionConfigurationSetTransportIsThrottled(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 100) = a2;
  }
  return result;
}

void RESyncNetSessionConfigurationSetTransportIsFragmented(uint64_t a1, char a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(unsigned char *)(a1 + 101) = a2;
  }
  else
  {
    int v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      id v4 = "RESyncNetSessionConfigurationSetTransportIsFragmented";
      __int16 v5 = 2080;
      uint64_t v6 = "configuration != __null";
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncNetSessionPublishBandwidthEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (!a1)
  {
LABEL_23:
    char v15 = *re::networkLogObjects((re *)a1);
    uint64_t v13 = 16;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)sockaddr buf = 136315394;
      *(void *)&uint8_t buf[4] = "RESyncNetSessionPublishBandwidthEvent";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "session != __null";
LABEL_27:
      _os_log_error_impl(&dword_228C70000, v15, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
      return v13;
    }
    return v13;
  }
  if (a2)
  {
    uint64_t v2 = a1;
    int v3 = (_anonymous_namespace_ *)(a1 + 7432);
    int v4 = *(_DWORD *)(a1 + 7512);
    *(_DWORD *)(a1 + 7512) = v4 + 1;
    if (*(void *)(a1 + 7448))
    {
      unint64_t v5 = 0;
      do
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)(v2 + 7464) + 32 * v5 + 24))(v2) == 1) {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v3, v5);
        }
        else {
          ++v5;
        }
      }
      while (v5 < *(void *)(v2 + 7448));
      int v4 = *(_DWORD *)(v2 + 7512) - 1;
    }
    *(_DWORD *)(v2 + 7512) = v4;
    if (v4) {
      return 1;
    }
    uint64_t v6 = *(void *)(v2 + 7488);
    if (!v6) {
      return 1;
    }
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    while (1)
    {
      unint64_t v9 = *(void *)(v2 + 7488);
      if (v9 <= v8) {
        break;
      }
      uint64_t v10 = *(void *)(v2 + 7504) + v7;
      uint64_t v11 = *(void *)(v10 + 32);
      long long v12 = *(_OWORD *)(v10 + 16);
      v16[0] = *(_OWORD *)v10;
      v16[1] = v12;
      uint64_t v17 = v11;
      if (LOBYTE(v16[0]))
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, (void *)v16 + 1, (uint64_t)buf);
        if (!buf[0]) {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v3, (uint64_t)v16 + 8);
        }
      }
      else
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, (void *)v16 + 1, (uint64_t)buf);
        if (buf[0]) {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v3, *(unint64_t *)&buf[8]);
        }
      }
      ++v8;
      v7 += 40;
      if (v6 == v8) {
        return 1;
      }
    }
    long long v28 = 0u;
    long long v29 = 0u;
    long long v27 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v18 = 136315906;
    unint64_t v19 = "operator[]";
    __int16 v20 = 1024;
    int v21 = 789;
    __int16 v22 = 2048;
    unint64_t v23 = v8;
    __int16 v24 = 2048;
    unint64_t v25 = v9;
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
    goto LABEL_23;
  }
  char v15 = *re::networkLogObjects((re *)a1);
  uint64_t v13 = 16;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)sockaddr buf = 136315394;
    *(void *)&uint8_t buf[4] = "RESyncNetSessionPublishBandwidthEvent";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "bwEvent != __null";
    goto LABEL_27;
  }
  return v13;
}

uint64_t RESyncNetSessionSetCapabilitiesIsLeader(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 3280) = *(_DWORD *)(result + 3280) & 0xFFFFFFFE | a2;
  }
  return result;
}

uint64_t anonymous namespace'::SessionObserverProxy::didStart(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t, re::Session *))(v2 + 16))(v2, a2);
  }
  return 0;
}

uint64_t anonymous namespace'::SessionObserverProxy::didStop(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    (*(void (**)(void))(v1 + 16))();
  }
  return 0;
}

uint64_t anonymous namespace'::SessionObserverProxy::didJoin(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3) {
    (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, a2, *a3);
  }
  return 0;
}

uint64_t anonymous namespace'::SessionObserverProxy::didLeave(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3) {
    (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, a2, *a3);
  }
  return 0;
}

uint64_t anonymous namespace'::SessionObserverProxy::didChangeLeader(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t, re::Session *))(v2 + 16))(v2, a2);
  }
  return 0;
}

uint64_t anonymous namespace'::SessionObserverProxy::didReceiveCustomData(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v3 = re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::tryGet(a1 + 80, a3);
  if (v3) {
    (*(void (**)(void))(*(void *)v3 + 16))();
  }
  return 0;
}

uint64_t anonymous namespace'::SessionObserverProxy::didConnectConnection(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2, uint64_t a3)
{
  if (*((void *)this + 8))
  {
    re::Transport::connectionAddress((re::Session *)((char *)a2 + 2320), a3, (re::DynamicString *)&v7);
    if (v8) {
      unint64_t v5 = *(unsigned char **)&v9[7];
    }
    else {
      unint64_t v5 = v9;
    }
    (*(void (**)(void, re::Session *, unsigned char *))(*((void *)this + 8) + 16))(*((void *)this + 8), a2, v5);
    if (v7 && (v8 & 1) != 0) {
      (*(void (**)(void))(*(void *)v7 + 40))();
    }
  }
  return 0;
}

uint64_t anonymous namespace'::SessionObserverProxy::didDisconnectConnection(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2, uint64_t a3)
{
  if (*((void *)this + 9))
  {
    re::Transport::connectionAddress((re::Session *)((char *)a2 + 2320), a3, (re::DynamicString *)&v7);
    if (v8) {
      unint64_t v5 = *(unsigned char **)&v9[7];
    }
    else {
      unint64_t v5 = v9;
    }
    (*(void (**)(void, re::Session *, unsigned char *))(*((void *)this + 9) + 16))(*((void *)this + 9), a2, v5);
    if (v7 && (v8 & 1) != 0) {
      (*(void (**)(void))(*(void *)v7 + 40))();
    }
  }
  return 0;
}

uint64_t anonymous namespace'::SessionObserverProxy::peerDidPause(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2)
{
  uint64_t v2 = *((void *)this + 16);
  if (v2) {
    (*(void (**)(uint64_t, re::Session *))(v2 + 16))(v2, a2);
  }
  return 0;
}

uint64_t anonymous namespace'::SessionObserverProxy::peerDidResume(_anonymous_namespace_::SessionObserverProxy *this, re::Session *a2)
{
  uint64_t v2 = *((void *)this + 17);
  if (v2) {
    (*(void (**)(uint64_t, re::Session *))(v2 + 16))(v2, a2);
  }
  return 0;
}

uint64_t re::Event<re::Session>::createSubscription<anonymous namespace'::SessionObserverProxy>(anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (anonymous namespace'::SessionObserverProxy::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  unint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

uint64_t re::Event<re::Session,re::SessionError>::createSubscription<anonymous namespace'::SessionObserverProxy>(anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (anonymous namespace'::SessionObserverProxy::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke(uint64_t a1, void *a2, unsigned int *a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::createSubscription<anonymous namespace'::SessionObserverProxy>(anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (anonymous namespace'::SessionObserverProxy::*)(re::Session*,re::SharedPtr<re::SessionParticipant>))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = (uint64_t (*)(void *, uint64_t, uint64_t *))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t *))(*v6 + v5);
  }
  uint64_t v7 = *a3;
  uint64_t v11 = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  uint64_t v9 = v5(v6, a1, &v11);
  if (v11) {

  }
  return v9;
}

uint64_t re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::createSubscription<anonymous namespace'::SessionObserverProxy>(anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (anonymous namespace'::SessionObserverProxy::*)(re::Session*,re::SharedPtr<re::SessionParticipant>,re::ParticipantError))::{lambda(re::Session*,re::Event<re::Session,re::SharedPtr<re::SessionParticipant>,re::ParticipantError>::Subscription const&,re::SharedPtr<re::SessionParticipant>&&,re::ParticipantError&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v7 = (uint64_t (*)(void *, uint64_t, uint64_t *, void))a2[1];
  uint64_t v6 = a2[2];
  id v8 = (void *)(*a2 + (v6 >> 1));
  if (v6) {
    uint64_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t *, void))(*v8 + v7);
  }
  uint64_t v9 = *a3;
  uint64_t v13 = v9;
  if (v9) {
    id v10 = (id)(v9 + 8);
  }
  uint64_t v11 = v7(v8, a1, &v13, *a4);
  if (v13) {

  }
  return v11;
}

uint64_t re::Event<re::Session,unsigned long long>::createSubscription<anonymous namespace'::SessionObserverProxy>(anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (anonymous namespace'::SessionObserverProxy::*)(re::Session*,unsigned long long))::{lambda(re::Session*,re::Event<re::Session,unsigned long long>::Subscription const&,unsigned long long &&)#1}::__invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

uint64_t re::Event<re::Session,re::ChannelId,unsigned long long,void const*,unsigned int>::createSubscription<anonymous namespace'::SessionObserverProxy>(anonymous namespace'::SessionObserverProxy *,REEventHandlerResult (anonymous namespace'::SessionObserverProxy::*)(re::Session*,re::ChannelId,unsigned long long,void const*,unsigned int))::{lambda(re::Session*,re::Event<re::Session,re::ChannelId,unsigned long long,void const*,unsigned int>::Subscription const&,re::ChannelId&&,unsigned long long &&,void const*&&,unsigned int &&)#1}::__invoke(uint64_t a1, void *a2, unsigned __int8 *a3, void *a4, void *a5, unsigned int *a6)
{
  uint64_t v7 = (uint64_t (*)(void *, uint64_t, void, void, void, void))a2[1];
  uint64_t v8 = a2[2];
  uint64_t v9 = (void *)(*a2 + (v8 >> 1));
  if (v8) {
    uint64_t v7 = *(uint64_t (**)(void *, uint64_t, void, void, void, void))(*v9 + v7);
  }
  return v7(v9, a1, *a3, *a4, *a5, *a6);
}

uint64_t re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::tryGet(uint64_t a1, unsigned __int8 a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * a2) ^ ((0xBF58476D1CE4E5B9 * a2) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(unsigned __int8 *)(v5 + 24 * v3 + 12) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 24 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(unsigned __int8 *)(v5 + 24 * v3 + 12) == a2) {
        return v5 + 24 * v3 + 16;
      }
    }
    return 0;
  }
  return v5 + 24 * v3 + 16;
}

void re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, unsigned char *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v25, 0, 36);
          *(void *)&v25[36] = 0x7FFFFFFFLL;
          re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::init((uint64_t)v25, v13, v12);
          long long v15 = *(_OWORD *)v25;
          *(_OWORD *)unint64_t v25 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v25[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v25[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v25[24];
          *(_OWORD *)&unsigned char v25[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v25[32];
          *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            uint64_t v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0) {
                re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::addAsMove(a1, *(void *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v21 - 16), v21 - 4, v21);
              }
              v21 += 24;
              --v20;
            }
            while (v20);
          }
          re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)v25);
        }
      }
      else
      {
        if (v12) {
          signed int v24 = 2 * v11;
        }
        else {
          signed int v24 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 24 * v9 + 8);
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 24 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 24 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v9) = a3;
  *(unsigned char *)(*(void *)(a1 + 16) + 24 * v9 + 12) = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v9 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

void re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    BOOL v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

re::Session *re::make::shared::object<re::Session>@<X0>(re *a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = re::globalAllocators(a1);
  unint64_t v4 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 7656, 8);
  bzero(v4, 0x1DE8uLL);
  double result = re::Session::Session((re::Session *)v4);
  *a2 = v4;
  return result;
}

re::Session *re::Session::Session(re::Session *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD35668;
  *((void *)this + 3) = &unk_26DD35700;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_DWORD *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 15) = 0;
  *((_DWORD *)this + 36) = 0;
  *((void *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *((_DWORD *)this + 50) = 0;
  *((_DWORD *)this + 46) = 0;
  *(_OWORD *)((char *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  *((_DWORD *)this + 58) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 35) = 0;
  *((_DWORD *)this + 72) = 0;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_DWORD *)this + 68) = 0;
  *((void *)this + 37) = 0;
  *((void *)this + 38) = 0;
  *((_DWORD *)this + 80) = 0;
  *((void *)this + 39) = 0;
  *((void *)this + 46) = 0;
  *((_DWORD *)this + 94) = 0;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((_DWORD *)this + 90) = 0;
  *((void *)this + 48) = 0;
  *((void *)this + 49) = 0;
  *((_DWORD *)this + 102) = 0;
  *((void *)this + 50) = 0;
  *((void *)this + 57) = 0;
  *((_DWORD *)this + 116) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((void *)this + 59) = 0;
  *((void *)this + 60) = 0;
  *((_DWORD *)this + 1re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *((void *)this + 61) = 0;
  *((void *)this + 68) = 0;
  *((_DWORD *)this + 138) = 0;
  *((_DWORD *)this + 134) = 0;
  unint64_t v2 = (char *)this + 1440;
  uint64_t v3 = 560;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  do
  {
    unint64_t v4 = (char *)this + v3;
    *(void *)unint64_t v4 = 0;
    *((void *)v4 + 1) = 0;
    *((_DWORD *)v4 + 6) = 0;
    *((void *)v4 + 2) = 0;
    *((void *)v4 + 9) = 0;
    *((_DWORD *)v4 + 20) = 0;
    *((_OWORD *)v4 + 2) = 0uLL;
    *((_OWORD *)v4 + 3) = 0uLL;
    v3 += 88;
    *((_DWORD *)v4 + 16) = 0;
  }
  while (v4 + 88 != v2);
  *((_DWORD *)this + 366) = 0;
  *((void *)this + 182) = 0;
  *(_OWORD *)unint64_t v2 = 0u;
  *((void *)this + 189) = 0;
  *((_DWORD *)this + 380) = 0;
  *((_OWORD *)this + 92) = 0u;
  *((_OWORD *)this + 93) = 0u;
  *((_DWORD *)this + 376) = 0;
  *((void *)this + 191) = 0;
  *((_OWORD *)this + 96) = 0u;
  *((_DWORD *)this + 388) = 0;
  *((void *)this + 200) = 0;
  *((_DWORD *)this + 402) = 0;
  *((_DWORD *)this + 398) = 0;
  *(_OWORD *)((char *)this + 1560) = 0u;
  *(_OWORD *)((char *)this + 1576) = 0u;
  *((_OWORD *)this + 101) = 0u;
  *((_DWORD *)this + 410) = 0;
  *((void *)this + 204) = 0;
  *((void *)this + 211) = 0;
  *((_DWORD *)this + 4re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *((_OWORD *)this + 103) = 0u;
  *((_OWORD *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0u;
  *((_DWORD *)this + 420) = 0;
  *((void *)this + 215) = 0;
  *((_DWORD *)this + 432) = 0;
  *(_OWORD *)((char *)this + 1704) = 0u;
  *((void *)this + 222) = 0;
  *((_DWORD *)this + 446) = 0;
  *(_OWORD *)((char *)this + 1736) = 0u;
  *(_OWORD *)((char *)this + 1752) = 0u;
  *((_DWORD *)this + 442) = 0;
  *((void *)this + 226) = 0;
  *((_DWORD *)this + 454) = 0;
  *((_OWORD *)this + 112) = 0u;
  *((void *)this + 233) = 0;
  *((_DWORD *)this + 468) = 0;
  *((_DWORD *)this + 464) = 0;
  *((_OWORD *)this + 115) = 0u;
  *((_OWORD *)this + 114) = 0u;
  *(_OWORD *)((char *)this + 1880) = 0u;
  *((_DWORD *)this + 476) = 0;
  *((void *)this + 237) = 0;
  *((void *)this + 244) = 0;
  *((_DWORD *)this + 490) = 0;
  *(_OWORD *)((char *)this + 1912) = 0u;
  *(_OWORD *)((char *)this + 1928) = 0u;
  *((_DWORD *)this + 486) = 0;
  *((_OWORD *)this + 123) = 0u;
  *((_DWORD *)this + 498) = 0;
  *((void *)this + 248) = 0;
  *((void *)this + 255) = 0;
  *((_DWORD *)this + 512) = 0;
  *((_OWORD *)this + 125) = 0u;
  *((_OWORD *)this + 126) = 0u;
  *((_DWORD *)this + 508) = 0;
  *((_DWORD *)this + 520) = 0;
  *((void *)this + 259) = 0;
  *(_OWORD *)((char *)this + 2056) = 0u;
  *((void *)this + 266) = 0;
  *((_DWORD *)this + 534) = 0;
  *(_OWORD *)((char *)this + 2088) = 0u;
  *(_OWORD *)((char *)this + 2re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0u;
  *((_DWORD *)this + 530) = 0;
  *((void *)this + 268) = MEMORY[0x263EF83A0];
  *((void *)this + 269) = 0x7B61A86B3;
  *((void *)this + 270) = 0;
  *((void *)this + 271) = 0x61A800000000;
  *((void *)this + 272) = 0;
  *((unsigned char *)this + 2184) = 0;
  *((void *)this + 276) = 0;
  *((_DWORD *)this + 554) = 0;
  *((_OWORD *)this + 137) = 0u;
  *((_DWORD *)this + 555) = 16777473;
  *((void *)this + 278) = 500;
  *((_DWORD *)this + 558) = 10485760;
  *((_WORD *)this + 1118) = 257;
  *((_DWORD *)this + 560) = 10;
  *((_DWORD *)this + 566) = 0;
  *(_OWORD *)((char *)this + 2248) = 0u;
  *((unsigned char *)this + 2272) = 0;
  *((void *)this + 289) = 0;
  *((_DWORD *)this + 576) = 0;
  *((void *)this + 287) = 0;
  *(_OWORD *)((char *)this + 2280) = 0u;
  re::Transport::Transport((re::Session *)((char *)this + 2320));
  *((_DWORD *)this + 758) = 1;
  *((_OWORD *)this + 190) = 0u;
  *((_OWORD *)this + 191) = 0u;
  *((_DWORD *)this + 768) = 0;
  *(_OWORD *)((char *)this + 3080) = 0u;
  *(_OWORD *)((char *)this + 3096) = 0u;
  *(_OWORD *)((char *)this + 3108) = 0u;
  *(void *)((char *)this + 31re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0x7FFFFFFFLL;
  *((void *)this + 407) = 0;
  *((_DWORD *)this + 816) = 0;
  *((void *)this + 409) = 0;
  *((_DWORD *)this + 820) = 0;
  *((void *)this + 411) = 0;
  *((_OWORD *)this + 196) = 0u;
  *((_OWORD *)this + 197) = 0u;
  *((_DWORD *)this + 792) = 0;
  *((_DWORD *)this + 802) = 0;
  *(_OWORD *)((char *)this + 3176) = 0u;
  *(_OWORD *)((char *)this + 3192) = 0u;
  *((_DWORD *)this + 812) = 0;
  *((_OWORD *)this + 202) = 0u;
  *((_OWORD *)this + 201) = 0u;
  *((void *)this + 412) = 500;
  *((void *)this + 938) = 0;
  *((_DWORD *)this + 1878) = 0;
  *(_OWORD *)((char *)this + 7464) = 0u;
  *(_OWORD *)((char *)this + 7480) = 0u;
  *((_DWORD *)this + 1874) = 0;
  *((void *)this + 9re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  bzero((char *)this + 3304, 0x103CuLL);
  *((void *)this + 941) = &unk_26DD35DB0;
  *((void *)this + 942) = 0x100000000;
  uint64_t v5 = -96;
  do
  {
    unint64_t v6 = (char *)this + v5;
    *((void *)v6 + 960) = 0;
    uint64_t v7 = (_OWORD *)((char *)this + v5 + 7640);
    *((_DWORD *)v6 + 1918) = 0;
    *uint64_t v7 = 0uLL;
    v7[1] = 0uLL;
    v5 += 48;
  }
  while (v5);
  *((_DWORD *)this + 1910) = 0;
  *((unsigned char *)this + 7648) = 0;
  return this;
}

void anonymous namespace'::SessionObserverProxy::~SessionObserverProxy(_anonymous_namespace_::SessionObserverProxy *this)
{
  *(void *)this = &unk_26DD35B98;
  _Block_release(*((const void **)this + 3));
  _Block_release(*((const void **)this + 4));
  _Block_release(*((const void **)this + 5));
  _Block_release(*((const void **)this + 6));
  _Block_release(*((const void **)this + 7));
  _Block_release(*((const void **)this + 16));
  _Block_release(*((const void **)this + 17));
  uint64_t v2 = *((unsigned int *)this + 28);
  if (v2)
  {
    uint64_t v3 = 0;
    unint64_t v4 = (int *)(*((void *)this + 12) + 8);
    while (1)
    {
      int v5 = *v4;
      v4 += 6;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 28);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v2 != v3)
  {
    uint64_t v6 = v3;
    do
    {
      _Block_release(*(const void **)(*((void *)this + 12) + 24 * v6 + 16));
      unsigned int v7 = *((_DWORD *)this + 28);
      if (v7 <= (int)v3 + 1) {
        int v8 = v3 + 1;
      }
      else {
        int v8 = *((_DWORD *)this + 28);
      }
      int v9 = v3;
      while (1)
      {
        uint64_t v6 = (v9 + 1);
        if (v8 - 1 == v9) {
          break;
        }
        ++v9;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((void *)this + 12) + 24 * v6 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v3) = v8;
LABEL_17:
      ;
    }
    while (v7 != v3);
  }
  _Block_release(*((const void **)this + 8));
  _Block_release(*((const void **)this + 9));
  re::HashSetBase<re::SyncViewer *,re::SyncViewer *,re::internal::ValueAsKey<re::SyncViewer *>,re::Hash<re::SyncViewer *>,re::EqualTo<re::SyncViewer *>,true,false>::deinit((uint64_t *)this + 10);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  JUMPOUT(0x22A6A9430);
}

void RESyncNetSessionConfig::~RESyncNetSessionConfig(RESyncNetSessionConfig *this)
{
  *(void *)this = &unk_26DD35BE0;
  uint64_t v2 = *((void *)this + 17);
  if (v2)
  {

    *((void *)this + 17) = 0;
  }
  uint64_t v3 = *((void *)this + 16);
  if (v3)
  {

    *((void *)this + 16) = 0;
  }
  uint64_t v4 = *((void *)this + 11);
  if (v4)
  {

    *((void *)this + 11) = 0;
  }
  uint64_t v5 = *((void *)this + 7);
  if (v5)
  {

    *((void *)this + 7) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t vars8;

  *(void *)this = &unk_26DD35BE0;
  uint64_t v2 = *((void *)this + 17);
  if (v2)
  {

    *((void *)this + 17) = 0;
  }
  uint64_t v3 = *((void *)this + 16);
  if (v3)
  {

    *((void *)this + 16) = 0;
  }
  uint64_t v4 = *((void *)this + 11);
  if (v4)
  {

    *((void *)this + 11) = 0;
  }
  uint64_t v5 = *((void *)this + 7);
  if (v5)
  {

    *((void *)this + 7) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::SyncObjectTypedStore::SyncObjectTypedStore(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = &unk_26DD35C28;
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = *a2;
  *a2 = 0;
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a3;
  *(void *)(a1 + 32) = a4;
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 104) && *(void *)(v5 + 120)) {
    uint64_t v6 = re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize((re::NetworkFeatureFlags *)a1);
  }
  else {
    uint64_t v6 = 1;
  }
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v6;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 108) = 0u;
  *(void *)(a1 + 1re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0x7FFFFFFFLL;
  return a1;
}

void re::SyncObjectTypedStore::~SyncObjectTypedStore(re::SyncObjectTypedStore *this)
{
  *(void *)this = &unk_26DD35C28;
  if (*((unsigned char *)this + 8)) {
    *((unsigned char *)this + 8) = 0;
  }
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 11);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 48);
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {

    *((void *)this + 2) = 0;
  }
}

{
  uint64_t vars8;

  re::SyncObjectTypedStore::~SyncObjectTypedStore(this);
  JUMPOUT(0x22A6A9430);
}

void *re::SyncObjectTypedStore::createWithGuid@<X0>(re::SyncObjectTypedStore *this@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = (re::Allocator *)*((void *)this + 3);
  unsigned int v7 = (re::Allocator *)*((void *)this + 4);
  unint64_t v8 = *((void *)this + 5);
  int v9 = (re::SyncObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v6 + 32))(v6, 224, 8);
  uint64_t v10 = re::SyncObject::SyncObject(v9, v6, a2, v7, v8);
  *a3 = (uint64_t)v10;
  uint64_t v11 = *((void *)v10 + 3);
  uint64_t v13 = *((void *)this + 8);
  uint64_t v14 = v11;
  re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add((uint64_t)this + 88, &v14, &v13);
  double result = re::DynamicArray<re::SharedPtr<re::SyncObject>>::add((void *)this + 6, a3);
  *(void *)(*a3 + 88) = this;
  return result;
}

unint64_t *re::SyncObjectTypedStore::findObjectWithGuid(re::SyncObjectTypedStore *this, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  v6[0] = a2;
  double result = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 88, v6);
  if (result)
  {
    unint64_t v4 = *result;
    unint64_t v5 = *((void *)this + 8);
    if (v5 <= *result)
    {
      v6[1] = 0;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v15 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v7 = 136315906;
      unint64_t v8 = "operator[]";
      __int16 v9 = 1024;
      int v10 = 797;
      __int16 v11 = 2048;
      unint64_t v12 = v4;
      __int16 v13 = 2048;
      unint64_t v14 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return *(unint64_t **)(*((void *)this + 10) + 8 * v4);
  }
  return result;
}

void re::SyncObjectTypedStore::removeObject(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 88;
  *(void *)&v18[0] = *(void *)(*(void *)a2 + 24);
  unint64_t v5 = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 88, (uint64_t *)v18);
  if (v5)
  {
    unint64_t v6 = *(void *)(a1 + 64);
    unint64_t v7 = *v5;
    if (v6 <= *v5)
    {
      memset(v18, 0, sizeof(v18));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v10 = *(void *)(a1 + 80);
    uint64_t v8 = v10 + 8 * v6;
    uint64_t v9 = *(void *)(v8 - 8);
    *(void *)(v8 - 8) = 0;
    *(void *)(v8 - 8) = *(void *)(v10 + 8 * v7);
    *(void *)(v10 + 8 * v7) = v9;
    LODWORD(v10) = 0x7FFFFFFF;
    if (*(void *)(a1 + 88))
    {
      unint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8 * v7) + 24);
      unint64_t v12 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) >> 27));
      uint64_t v13 = *(unsigned int *)(*(void *)(a1 + 96) + 4 * ((v12 ^ (v12 >> 31)) % *(unsigned int *)(a1 + 112)));
      if (v13 != 0x7FFFFFFF)
      {
        uint64_t v14 = *(void *)(a1 + 104);
        LODWORD(v10) = v13;
        if (*(void *)(v14 + 32 * v13 + 16) != v11)
        {
          uint64_t v10 = v13;
          while (1)
          {
            uint64_t v10 = *(_DWORD *)(v14 + 32 * v10 + 8) & 0x7FFFFFFF;
            if (v10 == 0x7FFFFFFF) {
              break;
            }
            if (*(void *)(v14 + 32 * v10 + 16) == v11) {
              goto LABEL_11;
            }
          }
          LODWORD(v10) = 0x7FFFFFFF;
        }
      }
    }
LABEL_11:
    *(void *)(*(void *)(a1 + 104) + 32 * v10 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v7;
    *(void *)&v18[0] = *(void *)(*(void *)a2 + 24);
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(v4, (uint64_t *)v18);
    uint64_t v15 = *(void *)(a1 + 64);
    uint64_t v16 = *(void *)(a1 + 80) + 8 * v15;
    uint64_t v17 = *(void *)(v16 - 8);
    if (v17)
    {

      *(void *)(v16 - 8) = 0;
      uint64_t v15 = *(void *)(a1 + 64);
    }
    *(void *)(a1 + 64) = v15 - 1;
    ++*(_DWORD *)(a1 + 72);
  }
}

re::SyncObjectStore *re::SyncObjectStore::SyncObjectStore(re::SyncObjectStore *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD35C48;
  uint64_t v4 = (_anonymous_namespace_ *)re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(v3);
  unint64_t v5 = 96 * v4;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *((void *)this + 67) = 0x7FFFFFFF00000000;
  *((_DWORD *)this + 136) = 0;
  *((void *)this + 69) = 0x20000000ALL;
  *((void *)this + 70) = 0;
  *((void *)this + 72) = 0;
  *((void *)this + 71) = 0;
  *((_DWORD *)this + 146) = 0;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *(_OWORD *)((char *)this + 620) = 0u;
  *(void *)((char *)this + 636) = 0x7FFFFFFFLL;
  return this;
}

void re::SyncObjectStore::~SyncObjectStore(re::SyncObjectStore *this)
{
  *(void *)this = &unk_26DD35C48;
  uint64_t v2 = *((unsigned int *)this + 134);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (int *)(*((void *)this + 65) + 8);
    while (1)
    {
      int v5 = *v4;
      v4 += 8;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 134);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  unsigned int v6 = *((_DWORD *)this + 134);
  if (v2 != v3)
  {
    uint64_t v7 = v3;
    do
    {
      re::internal::destroyPersistent<re::SyncObjectTypedStore>(*(re **)(*((void *)this + 65) + 32 * v7 + 24));
      unsigned int v6 = *((_DWORD *)this + 134);
      if (v6 <= (int)v3 + 1) {
        int v8 = v3 + 1;
      }
      else {
        int v8 = *((_DWORD *)this + 134);
      }
      int v9 = v3;
      while (1)
      {
        uint64_t v7 = (v9 + 1);
        if (v8 - 1 == v9) {
          break;
        }
        ++v9;
        LODWORD(v3) = v7;
        if ((*(_DWORD *)(*((void *)this + 65) + 32 * v7 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v3) = v8;
LABEL_17:
      ;
    }
    while (v2 != v3);
  }
  if (*((_DWORD *)this + 133))
  {
    uint64_t v10 = *((unsigned int *)this + 132);
    if (v10)
    {
      memset_pattern16(*((void **)this + 64), &unk_228CDE530, 4 * v10);
      unsigned int v6 = *((_DWORD *)this + 134);
    }
    if (v6)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 32 * v6;
      do
      {
        uint64_t v13 = *((void *)this + 65) + v11;
        int v14 = *(_DWORD *)(v13 + 8);
        if (v14 < 0) {
          *(_DWORD *)(v13 + 8) = v14 & 0x7FFFFFFF;
        }
        v11 += 32;
      }
      while (v12 != v11);
    }
    *((_DWORD *)this + 135) = 0x7FFFFFFF;
    *(void *)((char *)this + 532) = 0;
    ++*((_DWORD *)this + 136);
  }
  re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::clear((uint64_t)this + 600);
  *((void *)this + 72) = 0;
  ++*((_DWORD *)this + 146);
  re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::clear((uint64_t)this + 600);
  *((void *)this + 72) = 0;
  ++*((_DWORD *)this + 146);
  double v15 = re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)this + 75);
  uint64_t v16 = *((void *)this + 70);
  if (v16)
  {
    if (*((void *)this + 74)) {
      (*(void (**)(uint64_t, double))(*(void *)v16 + 40))(v16, v15);
    }
    *((void *)this + 74) = 0;
    *((void *)this + 71) = 0;
    *((void *)this + 72) = 0;
    *((void *)this + 70) = 0;
    ++*((_DWORD *)this + 146);
  }
  re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 63);
  re::PoolAllocator::~PoolAllocator((re::SyncObjectStore *)((char *)this + 264));
  re::PoolAllocator::~PoolAllocator((re::SyncObjectStore *)((char *)this + 24));
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::SyncObjectStore::~SyncObjectStore(this);
  JUMPOUT(0x22A6A9430);
}

re *re::internal::destroyPersistent<re::SyncObjectTypedStore>(re *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = re::globalAllocators(result)[2];
    (**(void (***)(re *))v1)(v1);
    uint64_t v3 = *(uint64_t (**)(uint64_t, re *))(*(void *)v2 + 40);
    return (re *)v3(v2, v1);
  }
  return result;
}

void re::SyncObjectTombstoneInfo::update(re::SyncObjectTombstoneInfo *this)
{
  double Current = CFAbsoluteTimeGetCurrent();
  unint64_t v4 = *((void *)this + 3);
  if (v4)
  {
    double v5 = Current;
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    uint64_t v8 = 0;
    do
    {
      uint64_t v9 = *((void *)this + 5);
      LODWORD(v3) = *(_DWORD *)this;
      double v3 = (double)*(unint64_t *)&v3;
      if (v5 - *(double *)(v9 + v6) < v3) {
        break;
      }
      uint64_t v10 = v9 + v6;
      unsigned int v11 = *(unsigned __int16 *)(v10 + 8);
      if (*((_DWORD *)this + 1) <= v11)
      {
        re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::remove((uint64_t)this + 48, (uint64_t *)(v10 + 16));
        ++v8;
        unint64_t v4 = *((void *)this + 3);
      }
      else
      {
        *(_WORD *)(v10 + 8) = v11 + 1;
      }
      ++v7;
      v6 += 40;
    }
    while (v7 < v4);
    if (v8)
    {
      re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::removeManyStableAt((void *)this + 1, 0, v8);
    }
  }
}

void re::SyncObjectStore::addType(re::SyncObjectStore *this, const re::SyncObjectTypeInfo *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  unint64_t v4 = (char *)this + 504;
  BOOL v5 = re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)this + 504, *((void *)a2 + 4));
  if (!v5)
  {
    uint64_t v6 = re::globalAllocators((re *)v5);
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[2] + 32))(v6[2], 144, 8);
    uint64_t v8 = re::SyncObjectTypeInfo::SyncObjectTypeInfo((re::SyncObjectTypeInfo *)v7, a2);
    uint64_t v9 = (uint64_t *)((char *)v8 + 32);
    uint64_t v10 = re::globalAllocators(v8);
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 136, 8);
    uint64_t v17 = v7;
    if (v7) {
      id v12 = (id)(v7 + 8);
    }
    re::SyncObjectTypedStore::SyncObjectTypedStore(v11, &v17, (uint64_t)this + 24, (uint64_t)this + 264);
    *(void *)sockaddr buf = v11;
    uint64_t v13 = (re *)re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v4, v9, buf);
    if (v17) {

    }
    int v14 = *re::networkLogObjects(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      if (*(unsigned char *)(v7 + 48)) {
        uint64_t v15 = *(void *)(v7 + 56);
      }
      else {
        uint64_t v15 = v7 + 49;
      }
      uint64_t v16 = *v9;
      *(_DWORD *)sockaddr buf = 136380931;
      *(void *)&uint8_t buf[4] = v15;
      __int16 v19 = 2048;
      uint64_t v20 = v16;
      _os_log_impl(&dword_228C70000, v14, OS_LOG_TYPE_INFO, "Registered sync object type %{private}s:%llu", buf, 0x16u);
      goto LABEL_13;
    }
    if (v7) {
LABEL_13:
    }
  }
}

BOOL re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 32 * v3 + 16) == a2) {
    return 1;
  }
  do
  {
    uint64_t v3 = *(_DWORD *)(v5 + 32 * v3 + 8) & 0x7FFFFFFF;
    BOOL result = v3 != 0x7FFFFFFF;
  }
  while (v3 != 0x7FFFFFFF && *(void *)(v5 + 32 * v3 + 16) != a2);
  return result;
}

uint64_t re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(uint64_t result, uint64_t *a2, void *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(void *)result)
  {
    unint64_t v9 = v8 % *(unsigned int *)(result + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(result + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(result + 16);
      if (*(void *)(v11 + 32 * v10 + 16) == v6) {
        return result;
      }
      while (1)
      {
        uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v11 + 32 * v10 + 16) == v6) {
          return result;
        }
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  BOOL result = re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

void re::SyncObjectStore::addType(re::SyncObjectStore *this, re::SyncObjectTypeInfo *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (a2)
  {
    unint64_t v4 = (char *)this + 504;
    uint64_t v5 = (uint64_t *)((char *)a2 + 32);
    if (!re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)this + 504, *((void *)a2 + 4)))
    {
      uint64_t v6 = re::globalAllocators((re *)(char *)a2 + 8);
      uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[2] + 32))(v6[2], 136, 8);
      uint64_t v13 = a2;
      unint64_t v8 = (char *)a2 + 8;
      re::SyncObjectTypedStore::SyncObjectTypedStore(v7, &v13, (uint64_t)this + 24, (uint64_t)this + 264);
      *(void *)sockaddr buf = v7;
      unint64_t v9 = (re *)re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v4, v5, buf);
      if (v13) {

      }
      uint64_t v10 = *re::networkLogObjects(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        if (*((unsigned char *)a2 + 48)) {
          uint64_t v11 = (char *)*((void *)a2 + 7);
        }
        else {
          uint64_t v11 = (char *)a2 + 49;
        }
        uint64_t v12 = *v5;
        *(_DWORD *)sockaddr buf = 136380931;
        *(void *)&uint8_t buf[4] = v11;
        __int16 v15 = 2048;
        uint64_t v16 = v12;
        _os_log_impl(&dword_228C70000, v10, OS_LOG_TYPE_INFO, "Registered sync object type %{private}s:%llu", buf, 0x16u);
      }
    }
  }
}

void *re::SyncObjectStore::create@<X0>(re::SyncObjectStore *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = a3;
  LODWORD(a3) = 0x7FFFFFFF;
  if (*((void *)this + 63))
  {
    unint64_t v4 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    uint64_t v5 = (uint64_t *)*(unsigned int *)(*((void *)this + 64) + 4 * ((v4 ^ (v4 >> 31)) % *((unsigned int *)this + 132)));
    if (v5 != 0x7FFFFFFF)
    {
      uint64_t v6 = *((void *)this + 65);
      LODWORD(a3) = v5;
      if (*(void *)(v6 + 32 * (void)v5 + 16) != a2)
      {
        a3 = v5;
        while (1)
        {
          a3 = (uint64_t *)(*(_DWORD *)(v6 + 32 * (void)a3 + 8) & 0x7FFFFFFF);
          if (a3 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v6 + 32 * (void)a3 + 16) == a2) {
            goto LABEL_9;
          }
        }
        LODWORD(a3) = 0x7FFFFFFF;
      }
    }
  }
LABEL_9:
  uint64_t v7 = *(re::SyncObjectTypedStore **)(*((void *)this + 65) + 32 * a3 + 24);
  uuid_generate_random((unsigned __int8 *)v10);
  uint64_t v8 = (v10[1] + (v10[0] << 6) + (v10[0] >> 2) - 0x61C8864680B583E9) ^ v10[0];
  return re::SyncObjectTypedStore::createWithGuid(v7, v8, v3);
}

unint64_t re::SyncObjectStore::createIncomingObject@<X0>(re::SyncObjectStore *this@<X0>, const re::SyncOwnershipInfo *a2@<X3>, unint64_t a3@<X1>, uint64_t a4@<X2>, uint64_t *a5@<X8>)
{
  uint64_t v6 = a5;
  LODWORD(a5) = 0x7FFFFFFF;
  if (*((void *)this + 63))
  {
    unint64_t v7 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ (a3 >> 30))) >> 27));
    uint64_t v8 = (uint64_t *)*(unsigned int *)(*((void *)this + 64) + 4 * ((v7 ^ (v7 >> 31)) % *((unsigned int *)this + 132)));
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v9 = *((void *)this + 65);
      LODWORD(a5) = v8;
      if (*(void *)(v9 + 32 * (void)v8 + 16) != a3)
      {
        a5 = v8;
        while (1)
        {
          a5 = (uint64_t *)(*(_DWORD *)(v9 + 32 * (void)a5 + 8) & 0x7FFFFFFF);
          if (a5 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v9 + 32 * (void)a5 + 16) == a3) {
            goto LABEL_9;
          }
        }
        LODWORD(a5) = 0x7FFFFFFF;
      }
    }
  }
LABEL_9:
  re::SyncObjectTypedStore::createWithGuid(*(re::SyncObjectTypedStore **)(*((void *)this + 65) + 32 * a5 + 24), a4, v6);
  uint64_t v10 = *v6;
  int v11 = *((_DWORD *)a2 + 8);
  long long v12 = *((_OWORD *)a2 + 1);
  *(_OWORD *)(v10 + 136) = *(_OWORD *)a2;
  *(_DWORD *)(v10 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 168) = v11;
  *(_OWORD *)(v10 + 152) = v12;
  uint64_t v13 = *((void *)a2 + 3);
  return re::SyncObject::addState((re::SyncObject *)v10, 0, v13);
}

re::SyncObjectTypedStore **re::SyncObjectStore::findObject@<X0>(re::SyncObjectStore *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, re::SyncObjectTypedStore ***a4@<X8>)
{
  uint64_t v7 = a2;
  BOOL result = (re::SyncObjectTypedStore **)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 504, &v7);
  if (result)
  {
    BOOL result = (re::SyncObjectTypedStore **)re::SyncObjectTypedStore::findObjectWithGuid(*result, a3);
    *a4 = result;
    if (result) {
      return result + 1;
    }
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

double re::SyncObjectStore::removeObject(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unsigned int v5 = 0x7FFFFFFF;
  if (!*(void *)(a1 + 504)
    || (unint64_t v6 = *(void *)(*(void *)(*(void *)(v4 + 88) + 16) + 32),
        unint64_t v7 = 0x94D049BB133111EBLL
           * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27)),
        uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 512) + 4 * ((v7 ^ (v7 >> 31)) % *(unsigned int *)(a1 + 528))),
        v8 == 0x7FFFFFFF)
    || (v9 = *(void *)(a1 + 520), unsigned int v5 = v8, *(void *)(v9 + 32 * v8 + 16) == v6))
  {
    uint64_t v10 = *(void *)(*(void *)(a1 + 520) + 32 * v5 + 24);
    uint64_t v19 = *a2;
LABEL_5:
    int v11 = (void *)(v4 + 8);
    id v12 = (id)(v4 + 8);
    re::SyncObjectTypedStore::removeObject(v10, (uint64_t)&v19);

    goto LABEL_6;
  }
  while (1)
  {
    uint64_t v8 = *(_DWORD *)(v9 + 32 * v8 + 8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      break;
    }
    if (*(void *)(v9 + 32 * v8 + 16) == v6) {
      goto LABEL_13;
    }
  }
  uint64_t v8 = 0x7FFFFFFFLL;
LABEL_13:
  uint64_t v10 = *(void *)(v9 + 32 * v8 + 24);
  uint64_t v19 = *a2;
  if (v4) {
    goto LABEL_5;
  }
  re::SyncObjectTypedStore::removeObject(v10, (uint64_t)&v19);
LABEL_6:
  unint64_t v13 = *(void *)(*a2 + 24);
  unint64_t v14 = *(void *)(*a2 + 80);
  unint64_t v17 = *(void *)(*(void *)(*(void *)(*a2 + 88) + 16) + 32);
  unint64_t v18 = v13;
  if (v14) {
    unint64_t v14 = *(void *)(v14 + 24);
  }
  unint64_t v16 = v14;
  return re::SyncObjectTombstoneInfo::addEntry((re::SyncObjectTombstoneInfo *)(a1 + 552), &v18, &v17, &v16);
}

double re::SyncObjectTombstoneInfo::addEntry(re::SyncObjectTombstoneInfo *this, const unint64_t *a2, const unint64_t *a3, const unint64_t *a4)
{
  uint64_t v5 = *a3;
  *(void *)&long long v11 = *a2;
  *((void *)&v11 + 1) = v5;
  uint64_t v12 = *a4;
  re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::add((uint64_t)this + 48, (uint64_t *)&v11);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  __int16 v8 = 0;
  long long v9 = v11;
  uint64_t v10 = v12;
  *(void *)&double result = re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((re::SyncObjectTombstoneInfo *)((char *)this + 8), (uint64_t)&Current).n128_u64[0];
  return result;
}

void *re::SyncObjectStore::types@<X0>(void *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = this;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  unint64_t v4 = *((unsigned int *)this + 133);
  if (v4) {
    this = re::DynamicArray<re::Allocator const*>::setCapacity((void *)a2, v4);
  }
  uint64_t v5 = *((unsigned int *)v2 + 134);
  if (v5)
  {
    uint64_t v6 = 0;
    unint64_t v7 = (int *)(v2[65] + 8);
    while (1)
    {
      int v8 = *v7;
      v7 += 8;
      if (v8 < 0) {
        break;
      }
      if (v5 == ++v6)
      {
        LODWORD(v6) = *((_DWORD *)v2 + 134);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if (v5 != v6)
  {
    uint64_t v9 = v6;
    do
    {
      this = re::DynamicArray<re::Allocator const*>::add((void *)a2, (void *)(v2[65] + 32 * v9 + 24));
      if (*((_DWORD *)v2 + 134) <= (v6 + 1)) {
        int v10 = v6 + 1;
      }
      else {
        int v10 = *((_DWORD *)v2 + 134);
      }
      int v11 = v6;
      while (1)
      {
        uint64_t v9 = (v11 + 1);
        if (v10 - 1 == v11) {
          break;
        }
        ++v11;
        LODWORD(v6) = v9;
        if ((*(_DWORD *)(v2[65] + 32 * v9 + 8) & 0x80000000) != 0) {
          goto LABEL_19;
        }
      }
      LODWORD(v6) = v10;
LABEL_19:
      ;
    }
    while (v5 != v6);
  }
  return this;
}

void re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_228CDE530, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 40 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 40;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v8;
  }
}

uint64_t re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = (v5 + (*a2 << 6) + ((unint64_t)*a2 >> 2) - 0x61C8864680B583E9) ^ *a2;
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (v7)
  {
    unint64_t v8 = v6 % v7;
    uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
    if (v9 != 0x7FFFFFFF)
    {
      uint64_t v10 = *(void *)(a1 + 16);
      uint64_t v11 = v10 + 40 * v9;
      uint64_t v13 = *(void *)(v11 + 16);
      uint64_t v12 = *(void *)(v11 + 24);
      if (v13 == v4 && v12 == v5)
      {
LABEL_13:
        uint64_t v19 = v10 + 40 * v9;
        return v19 + 16;
      }
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v10 + 40 * v9 + 8) & 0x7FFFFFFF;
        if (v9 == 0x7FFFFFFF) {
          break;
        }
        uint64_t v15 = v10 + 40 * v9;
        uint64_t v17 = *(void *)(v15 + 16);
        uint64_t v16 = *(void *)(v15 + 24);
        if (v17 == v4 && v16 == v5) {
          goto LABEL_13;
        }
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  uint64_t v20 = *(unsigned int *)(a1 + 36);
  if (v20 == 0x7FFFFFFF)
  {
    uint64_t v20 = *(unsigned int *)(a1 + 32);
    int v21 = v20;
    if (v20 == v7)
    {
      re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v8) = v6 % *(unsigned int *)(a1 + 24);
      int v21 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v21 + 1;
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 40 * v20 + 8);
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 40 * v20 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 40 * v20 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 40 * v20 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v20 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * v8);
  *(void *)(*(void *)(a1 + 16) + 40 * v20) = v6;
  uint64_t v24 = *(void *)(a1 + 16) + 40 * v20;
  long long v25 = *(_OWORD *)a2;
  *(void *)(v24 + 32) = a2[2];
  *(_OWORD *)(v24 + 16) = v25;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v8) = v20;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
  uint64_t v19 = *(void *)(a1 + 16) + 40 * v20;
  return v19 + 16;
}

uint64_t re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = ((v4 + (*a2 << 6) + ((unint64_t)*a2 >> 2) - 0x61C8864680B583E9) ^ *a2) % v2;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = v9 + 40 * v7;
  uint64_t v12 = *(void *)(v10 + 16);
  uint64_t v11 = *(void *)(v10 + 24);
  if (v12 != v3 || v11 != v4)
  {
    while (1)
    {
      unsigned int v14 = v7;
      LODWORD(v7) = *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
      if (v7 == 0x7FFFFFFF) {
        return 0;
      }
      uint64_t v15 = v9 + 40 * v7;
      uint64_t v17 = *(void *)(v15 + 16);
      uint64_t v16 = *(void *)(v15 + 24);
      if (v17 == v3 && v16 == v4)
      {
        *(_DWORD *)(v9 + 40 * v14 + 8) = *(_DWORD *)(v9 + 40 * v14 + 8) & 0x80000000 | *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_16;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
LABEL_16:
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v20 = v19 + 40 * v7;
  int v23 = *(_DWORD *)(v20 + 8);
  uint64_t v22 = (int *)(v20 + 8);
  int v21 = v23;
  if (v23 < 0)
  {
    *uint64_t v22 = v21 & 0x7FFFFFFF;
    uint64_t v19 = *(void *)(a1 + 16);
    int v21 = *(_DWORD *)(v19 + 40 * v7 + 8);
  }
  int v24 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v19 + 40 * v7 + 8) = *(_DWORD *)(a1 + 36) | v21 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v24 + 1;
  return 1;
}

void *re::DynamicArray<re::SyncObjectTombstoneInfo::LogEntry>::removeManyStableAt(void *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = result;
    unint64_t v5 = a2 + a3 - 1;
    unint64_t v6 = result[2];
    if (v5 >= v6)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v5 < v6 - 1)
    {
      uint64_t v7 = result[4];
      double result = (void *)(v7 + 40 * a2);
      unint64_t v8 = &result[5 * a3];
      uint64_t v9 = (unsigned char *)(v7 + 40 * v6);
      if (v9 != (unsigned char *)v8)
      {
        double result = memmove(result, v8, v9 - (unsigned char *)v8);
        unint64_t v6 = v4[2];
      }
    }
    void v4[2] = v6 - a3;
    ++*((_DWORD *)v4 + 6);
  }
  return result;
}

BOOL re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4 * (((v4 + (*a2 << 6) + ((unint64_t)*a2 >> 2) - 0x61C8864680B583E9) ^ *a2) % v2));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = v7 + 40 * v5;
  uint64_t v10 = *(void *)(v8 + 16);
  uint64_t v9 = *(void *)(v8 + 24);
  if (v10 == v3 && v9 == v4) {
    return 1;
  }
  do
  {
    LODWORD(v5) = *(_DWORD *)(v7 + 40 * v5 + 8) & 0x7FFFFFFF;
    BOOL result = v5 != 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF) {
      break;
    }
    uint64_t v12 = v7 + 40 * v5;
    uint64_t v14 = *(void *)(v12 + 16);
    uint64_t v13 = *(void *)(v12 + 24);
  }
  while (v14 != v3 || v13 != v4);
  return result;
}

uint64_t re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v26, 0, 36);
          *(void *)&v26[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v26, v13, v12);
          long long v15 = *(_OWORD *)v26;
          *(_OWORD *)uint64_t v26 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v26[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v26[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v26[24];
          *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v26[32];
          *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v19;
          uint64_t v20 = v18;
          if (v18)
          {
            uint64_t v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0) {
                re::HashTable<unsigned long long,re::SyncObjectTypedStore *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v21 - 16), v21, v21 + 8);
              }
              v21 += 32;
              --v20;
            }
            while (v20);
          }
          re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v26);
        }
      }
      else
      {
        if (v12) {
          signed int v24 = 2 * v11;
        }
        else {
          signed int v24 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 16);
    int v23 = *(_DWORD *)(v22 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 32 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v24, 0, 36);
      *(void *)&v24[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::init((uint64_t)v24, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v24;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v24[8];
      *(_OWORD *)signed int v24 = v5;
      *(void *)&v24[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v24[24];
      *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v24[32];
      *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = (long long *)(v6 + 16);
        do
        {
          if ((*((_DWORD *)v13 - 2) & 0x80000000) != 0)
          {
            unint64_t v14 = *((void *)v13 - 2);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 40 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 40 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 40 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 40 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 40 * v17) = v14;
            uint64_t v21 = *(void *)(a1 + 16) + 40 * v17;
            long long v22 = *v13;
            *(void *)(v21 + 32) = *((void *)v13 + 2);
            *(_OWORD *)(v21 + 16) = v22;
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          uint64_t v13 = (long long *)((char *)v13 + 40);
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::Pair<unsigned long long,unsigned long long,true>,unsigned int,re::Hash<re::Pair<unsigned long long,unsigned long long,true>>,re::EqualTo<re::Pair<unsigned long long,unsigned long long,true>>,true,false>::deinit((uint64_t *)v24);
    }
  }
  else
  {
    if (a2) {
      signed int v23 = a2;
    }
    else {
      signed int v23 = 3;
    }
  }
}

void re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    long long v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unsigned int v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    unint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

uint64_t RESyncBiasedVLQWrite(re::BitWriter *a1, uint64_t a2)
{
  uint64_t v3 = 0;
  return re::BiasedVLQ::write((re::BiasedVLQ *)&v3, a1, a2);
}

uint64_t RESyncBiasedVLQRead(re::BitReader *a1, uint64_t *a2)
{
  uint64_t v3 = 0;
  return re::BiasedVLQ::read((re::BiasedVLQ *)&v3, a1, a2);
}

_anonymous_namespace_ *re::DynamicArray<re::SharedPtr<anonymous namespace'::MCProtocolHandle>>::add(_anonymous_namespace_ *result, void *a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = *((void *)result + 2);
  unint64_t v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(void *)result)
    {
      uint64_t v9 = 2 * v4;
      BOOL v10 = v4 == 0;
      unint64_t v11 = 8;
      if (!v10) {
        unint64_t v11 = v9;
      }
      if (v11 <= v6) {
        unint64_t v12 = v6;
      }
      else {
        unint64_t v12 = v11;
      }
      BOOL result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(result, v12);
    }
    else
    {
      BOOL result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(v3, v6);
      ++*((_DWORD *)v3 + 6);
    }
  }
  uint64_t v8 = *((void *)v3 + 2);
  *(void *)(*((void *)v3 + 4) + 8 * v8) = *a2;
  *a2 = 0;
  *((void *)v3 + 2) = v8 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void anonymous namespace'::MCProtocolHandle::make(_anonymous_namespace_::MCProtocolHandle *this, MCPeerID *a2)
{
  unint64_t v5 = a2;
  uint64_t v3 = re::globalAllocators((re *)v5);
  unint64_t v4 = (void **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 1800, 8);
  bzero(v4, 0x708uLL);
  re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v4);
  *unint64_t v4 = &unk_26DD35D68;
  v4[221] = 0;
  *((unsigned char *)v4 + 1776) = 0;
  v4[223] = (void *)250000000;
  v4[224] = 0;
  *(void *)this = v4;
  re::ObjCObject::operator=(v4 + 221, v5);
}

void anonymous namespace'::MCProtocolHandle::onHandshake(uint64_t a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  qmemcpy(v25, "com.apple.rekit.hello.ack", sizeof(v25));
  id v3 = a2;
  char v24 = -2;
  unint64_t v4 = [MEMORY[0x263EFF8F8] dataWithBytesNoCopy:&v23 length:34 freeWhenDone:0];
  id v22 = *(id *)(a1 + 1768);
  unint64_t v5 = (void *)MEMORY[0x263EFF8C0];
  id v6 = v22;
  long long v7 = [v5 arrayWithObjects:&v22 count:1];
  id v17 = 0;
  char v8 = [v3 sendData:v4 toPeers:v7 withMode:0 error:&v17];

  id v9 = v17;
  if ((v8 & 1) == 0)
  {
    unint64_t v11 = *re::networkLogObjects(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      unint64_t v12 = v11;
      id v13 = [v9 description];
      uint64_t v14 = [v13 UTF8String];
      id v15 = [v9 description];
      uint64_t v16 = [v15 UTF8String];
      *(_DWORD *)sockaddr buf = 136315394;
      uint64_t v19 = v14;
      __int16 v20 = 2080;
      uint64_t v21 = v16;
      _os_log_error_impl(&dword_228C70000, v12, OS_LOG_TYPE_ERROR, "MPC: Error sending handshake ack: %s, reason: %s", buf, 0x16u);
    }
  }
}

uint64_t *re::DynamicArray<re::SharedPtr<anonymous namespace'::MCProtocolHandle>>::~DynamicArray(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = a1[4];
    if (v3)
    {
      uint64_t v4 = a1[2];
      if (v4)
      {
        uint64_t v5 = 8 * v4;
        do
        {
          if (*(void *)v3)
          {

            *(void *)uint64_t v3 = 0;
          }
          v3 += 8;
          v5 -= 8;
        }
        while (v5);
        uint64_t v2 = *a1;
        uint64_t v3 = a1[4];
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, v3);
    }
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    ++*((_DWORD *)a1 + 6);
  }
  return a1;
}

uint64_t re::MultipeerProtocolLayer::MultipeerProtocolLayer(uint64_t a1, id *a2)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(void *)a1 = &unk_26DD35CA0;
  uint64_t v4 = (_anonymous_namespace_ *)*a2;
  *(void *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0;
  re::DynamicString::setCapacity((void *)(a1 + 48), 0);
  return a1;
}

void re::MultipeerProtocolLayer::~MultipeerProtocolLayer(void **this)
{
  re::ObjCObject::operator=(this + 4, 0);
  re::ObjCObject::operator=(this + 5, 0);
  re::DynamicString::deinit((re::DynamicString *)(this + 6));

  *this = &unk_26DD34510;
  objc_destructInstance(this + 1);
}

{
  uint64_t vars8;

  re::MultipeerProtocolLayer::~MultipeerProtocolLayer(this);
  JUMPOUT(0x22A6A9430);
}

void **re::MultipeerProtocolLayer::deinit(void **this)
{
  re::ObjCObject::operator=(this + 4, 0);
  return re::ObjCObject::operator=(this + 5, 0);
}

uint64_t re::MultipeerProtocolLayer::init(id *a1)
{
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  uint64_t v2 = [a1[4] myPeerID];
  +[REMultipeerHelper makeAddressFromPeerID:v2];
  re::DynamicString::operator=((re::DynamicString *)(a1 + 6), (re::DynamicString *)&v4);
  if (v4 && (v5 & 1) != 0) {
    (*(void (**)(void))(*(void *)v4 + 40))();
  }
  re::ObjCObject::operator=(a1 + 5, 0);

  return 1;
}

void re::MultipeerProtocolLayer::open(id *this@<X0>, const re::Address *a2@<X1>, void *a3@<X8>)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  id v6 = this[5];
  long long v7 = [v6 handlesLock];
  [v7 lock];

  if (!v6)
  {
LABEL_24:
    *(void *)&long long v34 = 0;
    long long v32 = 0u;
    long long v33 = 0u;
    goto LABEL_18;
  }
  [v6 handles];
  uint64_t v8 = v33;
  if (v8)
  {
    unint64_t v9 = 0;
    while (1)
    {
      [v6 handles];
      unint64_t v10 = v21;
      if (v21 <= v9) {
        break;
      }
      uint64_t v3 = *(void *)(v22 + 8 * v9);
      if (v3) {
        id v11 = (id)(v3 + 8);
      }
      +[REMultipeerHelper makeAddressFromPeerID:*(void *)(v3 + 1768)];
      char v12 = BYTE8(v32);
      if (BYTE8(v32)) {
        id v13 = (const char *)v33;
      }
      else {
        id v13 = (char *)&v32 + 9;
      }
      if (*((void *)a2 + 1)) {
        uint64_t v14 = (const char *)*((void *)a2 + 2);
      }
      else {
        uint64_t v14 = (char *)a2 + 9;
      }
      if (!strcmp(v13, v14)) {
        goto LABEL_19;
      }
      if (void)v32 && (v12) {
        (*(void (**)(void))(*(void *)v32 + 40))();
      }

      ++v9;
      [v6 handles];
      unint64_t v15 = v33;
      if (v9 >= v15) {
        goto LABEL_18;
      }
    }
    uint64_t v23 = 0;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v32 = 0u;
    id v6 = (id)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v24 = 136315906;
    long long v25 = "operator[]";
    __int16 v26 = 1024;
    int v27 = 789;
    __int16 v28 = 2048;
    unint64_t v29 = v9;
    __int16 v30 = 2048;
    unint64_t v31 = v10;
    LODWORD(v19) = 38;
    int v18 = &v24;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_24;
  }
LABEL_18:
  objc_msgSend(v6, "handlesLock", v18, v19);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  [v6 unlock];

  re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) Unknown new connection requested.", "!\"Unreachable code\"", "open", 414);
  _os_crash();
  __break(1u);
LABEL_19:
  id v17 = [v6 handlesLock];
  [v17 unlock];

  *a3 = v3;
  if (void)v32 && (BYTE8(v32)) {
    (*(void (**)(void))(*(void *)v32 + 40))();
  }
}

void re::MultipeerProtocolLayer::close(id *a1, uint64_t a2, int a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  id v6 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)sockaddr buf = 134218240;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    _os_log_impl(&dword_228C70000, v6, OS_LOG_TYPE_DEFAULT, "MPC: Closing peer handle=%p force=%d", buf, 0x12u);
  }
  id v7 = a1[5];
  uint64_t v8 = [v7 handlesLock];
  [v8 lock];

  if (!v7)
  {
    *(void *)&long long v38 = 0;
    memset(buf, 0, sizeof(buf));
    goto LABEL_23;
  }
  [v7 handles];
  uint64_t v9 = *(void *)&buf[16];
  if (v9)
  {
    unint64_t v10 = 0;
    uint64_t v11 = -8;
    while (1)
    {
      [v7 handles];
      unint64_t v12 = v25;
      if (v25 <= v10) {
        break;
      }
      uint64_t v13 = *(void *)(v27 + 8 * v10);
      if (v13)
      {
        id v14 = (id)(v13 + 8);
        if (v13 == a2) {
          goto LABEL_14;
        }
      }
      else
      {
        if (!a2)
        {
LABEL_14:
          uint64_t v16 = *(void **)(a2 + 1768);
          *(void *)(a2 + 1768) = 0;

          [v7 handles];
          unint64_t v12 = v25;
          if (v25 > v10)
          {
            unint64_t v17 = v25 - 1;
            if (v25 - 1 > v10 && v11 + 8 * v25)
            {
              int v18 = (void *)(v27 - v11);
              uint64_t v19 = *(void *)(v27 + 8 * v10);
              uint64_t v20 = v11 + 8 * v25;
              do
              {
                *(v18 - 1) = *v18;
                *v18++ = v19;
                v20 -= 8;
              }
              while (v20);
            }
            uint64_t v21 = v27 + 8 * v12;
            uint64_t v22 = *(void *)(v21 - 8);
            if (v22)
            {

              *(void *)(v21 - 8) = 0;
              unint64_t v17 = v25 - 1;
            }
            unint64_t v25 = v17;
            ++v26;
            if (v13) {

            }
            goto LABEL_23;
          }
LABEL_25:
          uint64_t v28 = 0;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v38 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v29 = 136315906;
          __int16 v30 = "removeStableAt";
          __int16 v31 = 1024;
          int v32 = 969;
          __int16 v33 = 2048;
          unint64_t v34 = v10;
          __int16 v35 = 2048;
          unint64_t v36 = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
      ++v10;
      [v7 handles];
      unint64_t v15 = *(void *)&buf[16];
      v11 -= 8;
      if (v10 >= v15) {
        goto LABEL_23;
      }
    }
    uint64_t v28 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v38 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v29 = 136315906;
    __int16 v30 = "operator[]";
    __int16 v31 = 1024;
    int v32 = 789;
    __int16 v33 = 2048;
    unint64_t v34 = v10;
    __int16 v35 = 2048;
    unint64_t v36 = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_25;
  }
LABEL_23:
  uint64_t v23 = [v7 handlesLock];
  [v23 unlock];
}

void re::MultipeerProtocolLayer::disconnect(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v6 = *re::networkLogObjects((re *)a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unint64_t v12 = 134218240;
    *(void *)&v12[4] = a2;
    __int16 v13 = 1024;
    LODWORD(v14) = a3;
    _os_log_impl(&dword_228C70000, v6, OS_LOG_TYPE_DEFAULT, "MPC: Disconnecting peer handle=%p force=%d", v12, 0x12u);
  }
  id v7 = *(id *)(a1 + 40);
  uint64_t v8 = [v7 handlesLock];
  [v8 lock];

  uint64_t v9 = *(void **)(a2 + 1768);
  if (v9)
  {
    if (*(void *)(a1 + 24))
    {
      id v10 = v9;
      +[REMultipeerHelper makeAddressFromPeerID:v10];
      (*(void (**)(void, uint64_t, uint64_t, unsigned char *))(**(void **)(a1 + 24) + 8))(*(void *)(a1 + 24), a1, a2, v12);

      if (*(void *)v12 && (v12[8] & 1) != 0) {
        (*(void (**)(void))(**(void **)v12 + 40))();
      }
      uint64_t v9 = *(void **)(a2 + 1768);
    }
    *(void *)(a2 + 1768) = 0;
  }
  uint64_t v11 = [v7 handlesLock];
  [v11 unlock];
}

void re::MultipeerProtocolLayer::send(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  v33[1] = *(id *)MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v29, 6078, a1);
  if (*(unsigned char *)(a2 + 1776) && *(void *)(a2 + 1768))
  {
    id v6 = *(id *)(a1 + 32);
    uint64_t v7 = *(void *)a3;
    if (*(void *)a3 != *((void *)a3 + 1))
    {
      do
      {
        unint64_t v8 = atomic_load(*(unint64_t **)(v7 + 8));
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(*(void *)a3 + 16), memory_order_acquire);
        if (v8)
        {
          unint64_t v10 = explicit + 1;
          do
          {
            if (!--v10) {
              break;
            }
            char v11 = a3[16];
            size_t v12 = *(unsigned int *)(v8 + 24) + 9;
            __int16 v13 = (unint64_t *)malloc_type_malloc(v12, 0xFA76ED1CuLL);
            *((unsigned char *)v13 + 8) = v11;
            memcpy((char *)v13 + 9, *(const void **)(v8 + 16), *(unsigned int *)(v8 + 24));
            uint64_t v14 = [MEMORY[0x263EFF8F8] dataWithBytesNoCopy:v13 length:v12];
            BOOL v15 = *(_DWORD *)(v8 + 32) == 2;
            v33[0] = *(id *)(a2 + 1768);
            uint64_t v16 = (void *)MEMORY[0x263EFF8C0];
            id v17 = v33[0];
            int v18 = [v16 arrayWithObjects:v33 count:1];
            id v30 = 0;
            char v19 = [v6 sendData:v14 toPeers:v18 withMode:v15 error:&v30];
            id v20 = v30;

            if ((v19 & 1) == 0)
            {
              uint64_t v22 = *re::networkLogObjects(v21);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                unint64_t v25 = v22;
                id v26 = [v20 description];
                uint64_t v27 = [v26 UTF8String];
                *(_DWORD *)sockaddr buf = 136315138;
                uint64_t v32 = v27;
                _os_log_error_impl(&dword_228C70000, v25, OS_LOG_TYPE_ERROR, "MPC: Error sending packet: %s.", buf, 0xCu);
              }
              uint64_t v23 = *(void *)(a1 + 24);
              if (v23)
              {
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v23 + 16))(v23, a1, a2, 2);

                goto LABEL_15;
              }
            }

            int v24 = (re::PacketPool **)re::PacketQueue::dequeue(*(re::PacketQueue **)a3);
            re::PacketPool::free(v24[7], (re::Packet *)v24);
            unint64_t v8 = atomic_load(*(unint64_t **)(*(void *)a3 + 8));
          }
          while (v8);
        }
        uint64_t v28 = *((void *)a3 + 1);
        uint64_t v7 = *(void *)a3 + 40;
        *(void *)a3 = v7;
        ++a3[16];
      }
      while (v7 != v28);
    }
LABEL_15:
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v29);
}

void re::MultipeerProtocolLayer::update(id *this)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v32, 6022, (uint64_t)this);
  id v2 = this[5];
  id v3 = this[4];
  uint64_t v4 = [v2 handlesLock];
  [v4 lock];

  uint64_t v27 = v2;
  if (v2)
  {
    [v2 handles];
    if ((void)v30)
    {
      char v5 = v31;
      uint64_t v6 = 8 * v30;
      do
      {
        uint64_t v7 = *v5;
        if (*v5) {
          id v8 = (id)(v7 + 8);
        }
        if (*(void *)(v7 + 1768))
        {
          id v9 = v3;
          if (!*(unsigned char *)(v7 + 1776))
          {
            v10.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
            if (v10.__d_.__rep_ >= *(void *)(v7 + 1792))
            {
              std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = v10.__d_.__rep_;
              qmemcpy(v41, "com.apple.rekit.hello", sizeof(v41));
              id v12 = v9;
              char v40 = -1;
              uint64_t v13 = [MEMORY[0x263EFF8F8] dataWithBytesNoCopy:&v39 length:30 freeWhenDone:0];
              id v38 = *(id *)(v7 + 1768);
              uint64_t v14 = (void *)MEMORY[0x263EFF8C0];
              id v15 = v38;
              uint64_t v16 = [v14 arrayWithObjects:&v38 count:1];
              id v33 = 0;
              uint64_t v28 = (void *)v13;
              LOBYTE(v13) = [v12 sendData:v13 toPeers:v16 withMode:0 error:&v33];

              id v17 = v33;
              if ((v13 & 1) == 0)
              {
                char v19 = *re::networkLogObjects(v18);
                if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                {
                  os_log_t log = v19;
                  id v21 = [v17 description];
                  uint64_t v22 = [v21 UTF8String];
                  id v23 = [v17 description];
                  uint64_t v24 = [v23 UTF8String];
                  *(_DWORD *)sockaddr buf = 136315394;
                  uint64_t v35 = v22;
                  __int16 v36 = 2080;
                  uint64_t v37 = v24;
                  _os_log_error_impl(&dword_228C70000, log, OS_LOG_TYPE_ERROR, "MPC: Error sending handshake: %s, reason: %s", buf, 0x16u);
                }
              }

              uint64_t v20 = 2 * *(void *)(v7 + 1784);
              if (v20 >= 8000000000) {
                uint64_t v20 = 8000000000;
              }
              *(void *)(v7 + 1784) = v20;
              *(void *)(v7 + 1792) = v20 + rep;
            }
          }
        }
        ++v5;
        v6 -= 8;
      }
      while (v6);
    }
  }
  else
  {
    __int16 v31 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
  }
  unint64_t v25 = [v27 handlesLock];
  [v25 unlock];

  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v32);
}

void re::MultipeerProtocolLayer::wait(re::MultipeerProtocolLayer *this, uint64_t a2)
{
}

void re::MultipeerProtocolLayer::wakeup(re::MultipeerProtocolLayer *this, uint64_t a2)
{
}

void re::MultipeerProtocolLayer::setListener(re::MultipeerProtocolLayer *this, ProtocolLayerListener *a2)
{
  if (a2)
  {
    *((void *)this + 3) = a2;
    id v3 = [[MCSessionHandler alloc] initWithSession:*((void *)this + 4) protocolLayer:this];
    re::ObjCObject::operator=((void **)this + 5, v3);
  }
}

uint64_t re::MultipeerProtocolLayer::localAddresses(re::MultipeerProtocolLayer *this, re::Address *a2, uint64_t a3)
{
  if (a3) {
    re::DynamicString::operator=(a2, (re::MultipeerProtocolLayer *)((char *)this + 48));
  }
  return 1;
}

uint64_t re::MultipeerProtocolLayer::hostStats()
{
  return 0;
}

uint64_t re::MultipeerProtocolLayer::preferredThreadMode(re::MultipeerProtocolLayer *this)
{
  return 2;
}

uint64_t re::MultipeerProtocolLayer::drainsPacketSink(re::MultipeerProtocolLayer *this)
{
  return 1;
}

uint64_t re::ProtocolLayer::preferredPacketSize(re::ProtocolLayer *this)
{
  return 1200;
}

void anonymous namespace'::MCProtocolHandle::~MCProtocolHandle(id *this)
{
  *this = &unk_26DD35D68;

  re::ProtocolHandle::~ProtocolHandle((re::ProtocolHandle *)this);
}

{
  uint64_t vars8;

  *this = &unk_26DD35D68;

  re::ProtocolHandle::~ProtocolHandle((re::ProtocolHandle *)this);
  JUMPOUT(0x22A6A9430);
}

BOOL anonymous namespace'::readSignatureUnsafe(_anonymous_namespace_ *this, char *a2, uint64_t a3)
{
  uint64_t v9[2] = *MEMORY[0x263EF8340];
  if ((unint64_t)(a2 - 9) >= 0x40) {
    int v5 = 64;
  }
  else {
    int v5 = a2 - 9;
  }
  MurmurHash3_x64_128((uint64_t)this + 9, v5, 0, v9);
  unint64_t v6 = (v9[1] + (v9[0] << 6) + (v9[0] >> 2) - 0x61C8864680B583E9) ^ v9[0];
  unint64_t v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a3 ^ 0x149153915)) ^ ((0xBF58476D1CE4E5B9 * (a3 ^ 0x149153915)) >> 27));
  return *(void *)this == (((v7 ^ (v7 >> 31)) + (v6 << 6) + (v6 >> 2) - 0x61C8864680B583E9) ^ v6);
}

unint64_t *anonymous namespace'::writeSignatureUnsafe(unint64_t *this, unint64_t a2, uint64_t a3, unint64_t a4)
{
  int v5 = this;
  uint64_t v9[2] = *MEMORY[0x263EF8340];
  if (a4 >= 0x40) {
    unint64_t v6 = 64;
  }
  else {
    unint64_t v6 = a4;
  }
  if (v6)
  {
    this = (unint64_t *)MurmurHash3_x64_128(a3, v6, 0, v9);
    unint64_t v7 = (v9[1] - 0x61C8864680B583E9 + (v9[0] << 6) + (v9[0] >> 2)) ^ v9[0];
  }
  else
  {
    unint64_t v7 = 0;
  }
  unint64_t v8 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ 0x149153915)) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ 0x149153915)) >> 27));
  *int v5 = ((v8 ^ (v8 >> 31)) - 0x61C8864680B583E9 + (v7 << 6) + (v7 >> 2)) ^ v7;
  return this;
}

void re::DynamicArray<re::SharedPtr<anonymous namespace'::MCProtocolHandle>>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  unint64_t v5 = a1[2];
  if (v4 >= v5)
  {
    re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(a1, *(void *)(a2 + 16));
    uint64_t v14 = *(uint64_t **)(a2 + 32);
    uint64_t v15 = a1[2];
    uint64_t v16 = (uint64_t *)a1[4];
    if (v15)
    {
      uint64_t v17 = 8 * v15;
      do
      {
        uint64_t v18 = *v14;
        uint64_t v19 = *v16;
        if (*v16 != *v14)
        {
          if (v18)
          {
            id v20 = (id)(v18 + 8);
            uint64_t v19 = *v16;
          }
          if (v19) {

          }
          uint64_t *v16 = v18;
        }
        ++v14;
        ++v16;
        v17 -= 8;
      }
      while (v17);
      uint64_t v16 = (uint64_t *)a1[4];
      uint64_t v15 = a1[2];
      uint64_t v14 = *(uint64_t **)(a2 + 32);
    }
    if (v15 != v4)
    {
      id v21 = &v14[v15];
      uint64_t v22 = &v16[v15];
      uint64_t v23 = 8 * v4 - 8 * v15;
      do
      {
        uint64_t v24 = *v21;
        *uint64_t v22 = *v21;
        if (v24) {
          id v25 = (id)(v24 + 8);
        }
        ++v21;
        ++v22;
        v23 -= 8;
      }
      while (v23);
    }
  }
  else
  {
    unint64_t v6 = (uint64_t *)a1[4];
    if (v4)
    {
      unint64_t v7 = *(uint64_t **)(a2 + 32);
      uint64_t v8 = 8 * v4;
      do
      {
        uint64_t v9 = *v7;
        uint64_t v10 = *v6;
        if (*v6 != *v7)
        {
          if (v9)
          {
            id v11 = (id)(v9 + 8);
            uint64_t v10 = *v6;
          }
          if (v10) {

          }
          *unint64_t v6 = v9;
        }
        ++v7;
        ++v6;
        v8 -= 8;
      }
      while (v8);
      unint64_t v6 = (uint64_t *)a1[4];
      unint64_t v5 = a1[2];
    }
    if (v4 != v5)
    {
      id v12 = &v6[v4];
      uint64_t v13 = 8 * v5 - 8 * v4;
      do
      {
        if (*v12)
        {

          *id v12 = 0;
        }
        ++v12;
        v13 -= 8;
      }
      while (v13);
    }
  }
  a1[2] = v4;
}

void re::TransportCommandsQueued::~TransportCommandsQueued(re::TransportCommandsQueued *this)
{
  *(void *)this = &unk_26DD35DB0;
  for (uint64_t i = 64; i != -32; i -= 48)
    re::Queue<re::Function<void ()(void)>>::deinit((uint64_t *)((char *)this + i));
}

{
  uint64_t i;
  uint64_t vars8;

  *(void *)this = &unk_26DD35DB0;
  for (uint64_t i = 64; i != -32; i -= 48)
    re::Queue<re::Function<void ()(void)>>::deinit((uint64_t *)((char *)this + i));
  JUMPOUT(0x22A6A9430);
}

void re::TransportCommandsQueued::async(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 120)) {
    re::network::EventQueue<re::Function<void ()(void)>>::push((os_unfair_lock_s *)(a1 + 8), a2);
  }
}

void re::network::EventQueue<re::Function<void ()(void)>>::push(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v4 = a1 + 26;
  os_unfair_lock_lock(a1 + 26);
  re::Queue<re::Function<void ()(void)>>::enqueue((_anonymous_namespace_ *)&a1[12 * a1[1]._os_unfair_lock_opaque + 2], a2);
  os_unfair_lock_unlock(v4);
}

uint64_t (***re::TransportCommandsQueued::update(re::TransportCommandsQueued *this))(void)
{
  id v2 = (os_unfair_lock_s *)((char *)this + 112);
  os_unfair_lock_lock((os_unfair_lock_t)this + 28);
  *((int32x2_t *)this + 1) = vrev64_s32(*(int32x2_t *)((char *)this + 8));
  os_unfair_lock_unlock(v2);
  unsigned int v3 = *((_DWORD *)this + 2);
  uint64_t v4 = *((void *)this + 6 * v3 + 4);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (char *)this + 48 * v3;
    unint64_t v7 = v6 + 40;
    uint64_t v8 = v6 + 24;
    uint64_t v9 = v6 + 56;
    do
    {
      uint64_t v10 = *(void *)(*v9 + 40 * ((unint64_t)(v5 + *v7) % *v8) + 32);
      (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
      ++v5;
    }
    while (v4 != v5);
    unsigned int v3 = *((_DWORD *)this + 2);
  }
  return re::Queue<re::Function<void ()(void)>>::clear((uint64_t (***)(void))this + 6 * v3 + 2);
}

uint64_t (***re::Queue<re::Function<void ()(void)>>::clear(uint64_t (***result)(void)))(void)
{
  uint64_t v1 = result;
  if (result[2])
  {
    unint64_t v2 = 0;
    do
      BOOL result = re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&v1[5][5
                                                                                   * (((unint64_t)v1[3] + v2++)
                                                                                    % (unint64_t)v1[1])]);
    while (v2 < (unint64_t)v1[2]);
  }
  void v1[2] = 0;
  ++*((_DWORD *)v1 + 8);
  return result;
}

uint64_t re::TransportCommandsQueued::finish(re::TransportCommandsQueued *this)
{
  *((unsigned char *)this + 120) = 1;
  return (*(uint64_t (**)(void))(*(void *)this + 24))();
}

void re::TransportCommandsThreadedProtocol::TransportCommandsThreadedProtocol(re::TransportCommandsThreadedProtocol *this, re::ProtocolLayer *a2)
{
  *(void *)this = &unk_26DD35DE8;
  *((void *)this + 1) = a2;
  if (a2) {
    unsigned int v3 = (char *)a2 + 8;
  }
  uint64_t v4 = 0;
  *((void *)this + 2) = 0x100000000;
  do
  {
    uint64_t v5 = (char *)this + v4;
    *((void *)v5 + 8) = 0;
    *(_OWORD *)(v5 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0uLL;
    *(_OWORD *)(v5 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0uLL;
    *((_DWORD *)v5 + 14) = 0;
    v4 += 48;
  }
  while (v4 != 96);
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 17) = 0;
  atomic_store(1u, (unsigned __int8 *)this + 128);
  operator new();
}

void re::TransportCommandsThreadedProtocol::threadLoop(int32x2_t *this)
{
  unint64_t v2 = (os_unfair_lock_s *)&this[15];
  while (1)
  {
    os_unfair_lock_lock(v2);
    this[2] = vrev64_s32(this[2]);
    os_unfair_lock_unlock(v2);
    unsigned __int32 v3 = this[2].u32[0];
    int32x2_t v4 = this[6 * v3 + 5];
    if (v4)
    {
      uint64_t v5 = 0;
      unint64_t v6 = &this[6 * v3];
      unint64_t v7 = v6 + 6;
      uint64_t v8 = v6 + 4;
      uint64_t v9 = v6 + 8;
      do
      {
        uint64_t v10 = *(void *)(*(void *)v9 + 40 * ((unint64_t)(v5 + *(void *)v7) % *(void *)v8) + 32);
        (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
        ++v5;
      }
      while (*(void *)&v4 != v5);
      unsigned __int32 v3 = this[2].u32[0];
    }
    re::Queue<re::Function<void ()(void)>>::clear(&this[6 * v3 + 3]);
    unsigned __int8 v11 = atomic_load((unsigned __int8 *)&this[16]);
    if ((v11 & 1) == 0) {
      break;
    }
    (*(void (**)(void))(**(void **)&this[1] + 96))(*(void *)&this[1]);
  }
  os_unfair_lock_lock(v2);
  this[2] = vrev64_s32(this[2]);
  os_unfair_lock_unlock(v2);
  int32x2_t v12 = this[6 * this[2].u32[0] + 5];
  if (v12)
  {
    uint64_t v13 = 0;
    uint64_t v14 = &this[6 * this[2].u32[0]];
    uint64_t v15 = v14 + 6;
    uint64_t v16 = v14 + 4;
    uint64_t v17 = v14 + 8;
    do
    {
      uint64_t v18 = *(void *)(*(void *)v17 + 40 * ((unint64_t)(v13 + *(void *)v15) % *(void *)v16) + 32);
      (*(void (**)(uint64_t))(*(void *)v18 + 16))(v18);
      ++v13;
    }
    while (*(void *)&v12 != v13);
    uint64_t v19 = &this[6 * this[2].u32[0] + 3];
    re::Queue<re::Function<void ()(void)>>::clear(v19);
  }
}

void re::TransportCommandsThreadedProtocol::~TransportCommandsThreadedProtocol(std::thread *this)
{
  this->__t_ = (std::__libcpp_thread_t)&unk_26DD35DE8;
  std::thread::~thread(this + 17);
  for (uint64_t i = 9; i != -3; i -= 6)
    re::Queue<re::Function<void ()(void)>>::deinit((uint64_t *)&this[i]);
  std::__libcpp_thread_t t = this[1].__t_;
  if (t)
  {

    this[1].__t_ = 0;
  }
}

{
  uint64_t vars8;

  re::TransportCommandsThreadedProtocol::~TransportCommandsThreadedProtocol(this);
  JUMPOUT(0x22A6A9430);
}

void re::TransportCommandsThreadedProtocol::async(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(a1 + 128));
  if (v2) {
    re::network::EventQueue<re::Function<void ()(void)>>::push((os_unfair_lock_s *)(a1 + 16), a2);
  }
}

void re::TransportCommandsThreadedProtocol::finish(re::TransportCommandsThreadedProtocol *this)
{
  atomic_store(0, (unsigned __int8 *)this + 128);
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 104))(v2);
  }
  std::thread::join((std::thread *)this + 17);
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {

    *((void *)this + 1) = 0;
  }
}

uint64_t re::TransportCommandsThreadedProtocol::update(re::TransportCommandsThreadedProtocol *this)
{
  uint64_t result = *((void *)this + 1);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 104))();
  }
  return result;
}

re::TransportCommandsDispatch *re::TransportCommandsDispatch::TransportCommandsDispatch(re::TransportCommandsDispatch *this)
{
  *(void *)this = &unk_26DD35E20;
  *((unsigned char *)this + 8) = 0;
  *((void *)this + 2) = 0;
  uint64_t v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v3 = dispatch_queue_attr_make_with_qos_class(v2, QOS_CLASS_USER_INTERACTIVE, 0);
  int32x2_t v4 = dispatch_queue_create("com.apple.re.networking.network", v3);
  uint64_t v5 = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  unint64_t v6 = *((void *)this + 2);
  *((void *)this + 2) = v5;
  if (v6) {
    dispatch_release(v6);
  }
  dispatch_release(v5);
  return this;
}

void re::TransportCommandsDispatch::async(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 8))
  {
    int32x2_t v4 = re::globalAllocators((re *)a1);
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 40, 8);
    v5[3] = *(void *)(a2 + 24);
    v5[4] = 0;
    re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v5, a2);
    unint64_t v6 = *(NSObject **)(a1 + 16);
    dispatch_async_f(v6, v5, (dispatch_function_t)re::TransportCommandsDispatch::async(re::Function<void ()(void)> &&)::$_0::__invoke);
  }
}

void re::TransportCommandsDispatch::finish(re::TransportCommandsDispatch *this)
{
  *((unsigned char *)this + 8) = 1;
  dispatch_async_and_wait(*((dispatch_queue_t *)this + 2), &__block_literal_global_1);
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2)
  {
    dispatch_release(v2);
  }
}

void re::TransportCommandsDispatch::~TransportCommandsDispatch(re::TransportCommandsDispatch *this)
{
  *(void *)this = &unk_26DD35E20;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    dispatch_release(v1);
  }
}

{
  NSObject *v1;
  uint64_t vars8;

  *(void *)this = &unk_26DD35E20;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    dispatch_release(v1);
  }
  JUMPOUT(0x22A6A9430);
}

double re::Queue<re::Function<void ()(void)>>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = a1[5];
    if (v3)
    {
      if (a1[2])
      {
        uint64_t v4 = 0;
        do
        {
          re::FunctionBase<24ul,void ()(void)>::destroyCallable(a1[5] + 40 * ((v4 + a1[3]) % (unint64_t)a1[1]));
          ++v4;
        }
        while (v4 != a1[2]);
        uint64_t v2 = *a1;
        uint64_t v3 = a1[5];
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, v3);
    }
    a1[5] = 0;
    double result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_DWORD *)a1 + 8) = 0;
  }
  return result;
}

uint64_t re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(void)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (*(void *)(a1 + 24) == *(void *)(a2 + 24))
    {
      uint64_t v5 = a2;
      if (v4 != a2)
      {
        *(void *)(a1 + 32) = v4;
        *(void *)(a2 + 32) = 0;
        return a1;
      }
    }
    else
    {
      uint64_t v5 = *(void *)(a2 + 32);
      if (!v4) {
        return a1;
      }
    }
    unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
    uint64_t v7 = a1;
    if (v6 >= 0x19)
    {
      unint64_t v8 = v6;
      uint64_t v9 = *(void *)(a1 + 24);
      if (v9) {
        uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v9 + 32))(v9, v8, 0);
      }
      else {
        uint64_t v7 = 0;
      }
    }
    *(void *)(a1 + 32) = v7;
    (*(void (**)(void))(**(void **)(a2 + 32) + 32))(*(void *)(a2 + 32));
    re::FunctionBase<24ul,void ()(void)>::destroyCallable(a2);
  }
  return a1;
}

uint64_t re::TransportCommandsDispatch::async(re::Function<void ()(void)> &&)::$_0::__invoke(uint64_t a1)
{
  uint64_t v2 = (re *)(*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32));
  uint64_t v3 = re::globalAllocators(v2)[2];
  re::FunctionBase<24ul,void ()(void)>::destroyCallable(a1);
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 40);
  return v4(v3, a1);
}

uint64_t re::Queue<re::Function<void ()(void)>>::enqueue(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v5 = *((void *)this + 1);
  uint64_t v4 = *((void *)this + 2);
  if (v4 + 1 >= v5)
  {
    re::Queue<re::Function<void ()(void)>>::growCapacity(this, v4 + 1);
    unint64_t v5 = *((void *)this + 1);
    uint64_t v4 = *((void *)this + 2);
  }
  uint64_t v6 = *((void *)this + 5) + 40 * ((*((void *)this + 3) + v4) % v5);
  *(void *)(v6 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(void *)(a2 + 24);
  *(void *)(v6 + 32) = 0;
  uint64_t result = re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(v6, a2);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 8);
  return result;
}

void *re::Queue<re::Function<void ()(void)>>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::Queue<re::Function<void ()(void)>>::setCapacity(this, a2);
    }
    else
    {
      this = re::Queue<re::Function<void ()(void)>>::setCapacity(v4, v3);
      void v4[2] = 0;
      v4[3] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
  }
  return this;
}

void *re::Queue<re::Function<void ()(void)>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    BOOL v6 = result + 2;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::Queue<re::Function<void ()(void)>>::setCapacity(v5, a2);
        *BOOL v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            unint64_t v8 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v8 = 0;
      if (!v3)
      {
LABEL_18:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      if (v5[2])
      {
        uint64_t v9 = 0;
        uint64_t v10 = v5[3];
        do
        {
          uint64_t v11 = v5[5] + 40 * ((unint64_t)(v9 + v5[3]) % v5[1]);
          uint64_t v12 = (uint64_t)&v8[5 * v10];
          *(void *)(v12 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(void *)(v11 + 24);
          *(void *)(v12 + 32) = 0;
          re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(v12, v11);
          re::FunctionBase<24ul,void ()(void)>::destroyCallable(v11);
          if (v10 + 1 < a2) {
            ++v10;
          }
          else {
            uint64_t v10 = 0;
          }
          ++v9;
        }
        while (v9 != v5[2]);
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[5]);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::TransportCommandsThreadedProtocol::*)(void),re::TransportCommandsThreadedProtocol*>>(uint64_t *a1)
{
  unint64_t v8 = a1;
  uint64_t v2 = std::__thread_local_data();
  uint64_t v3 = (const void *)*a1;
  *a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  uint64_t v4 = a1[2];
  uint64_t v5 = (void (*)(void *))a1[1];
  BOOL v6 = (void *)(a1[3] + (v4 >> 1));
  if (v4) {
    uint64_t v5 = *(void (**)(void *))(*v6 + v5);
  }
  v5(v6);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::TransportCommandsThreadedProtocol::*)(void),re::TransportCommandsThreadedProtocol*>>::reset[abi:nn180100](&v8);
  return 0;
}

uint64_t **std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::TransportCommandsThreadedProtocol::*)(void),re::TransportCommandsThreadedProtocol*>>::reset[abi:nn180100](uint64_t **result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *v1;
    uint64_t *v1 = 0;
    if (v2)
    {
      uint64_t v3 = MEMORY[0x22A6A9310]();
      MEMORY[0x22A6A9430](v3, 0x20C4093837F09);
    }
    JUMPOUT(0x22A6A9430);
  }
  return result;
}

re::SyncObject *re::SyncObject::SyncObject(re::SyncObject *this, re::Allocator *a2, uint64_t a3, re::Allocator *a4, unint64_t a5)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  void v10[2] = a2;
  v10[3] = a3;
  *uint64_t v10 = &unk_26DD35ED0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = this;
  *((void *)this + 17) = 0;
  *((_WORD *)this + 72) = 0;
  *((unsigned char *)this + 152) = 0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0x10000;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((unsigned char *)this + 128) = 0;
  *((_WORD *)this + 88) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *((_DWORD *)this + 52) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  re::FixedArray<re::SyncObjectState>::init<>((uint64_t)(v10 + 5), (uint64_t)a4, a5);
  return this;
}

void re::SyncObject::~SyncObject(re::SyncObject *this)
{
  *(void *)this = &unk_26DD35ED0;
  re::SyncObject::unbindFromParent(this);
  uint64_t v2 = *((void *)this + 25);
  if (v2)
  {
    uint64_t v3 = (uint64_t *)*((void *)this + 27);
    uint64_t v4 = 8 * v2;
    do
    {
      uint64_t v5 = *v3++;
      *(void *)(v5 + 80) = 0;
      v4 -= 8;
    }
    while (v4);
  }
  uint64_t v6 = *((void *)this + 14);
  *((void *)this + 25) = 0;
  ++*((_DWORD *)this + 52);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 15);
    if (v7) {
      (*(void (**)(void))(v7 + 16))();
    }
  }
  _Block_release(*((const void **)this + 15));
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  uint64_t v8 = *((void *)this + 23);
  if (v8)
  {
    if (*((void *)this + 27)) {
      (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
    }
    *((void *)this + 27) = 0;
    *((void *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
    *((void *)this + 25) = 0;
    *((void *)this + 23) = 0;
    ++*((_DWORD *)this + 52);
  }
  uint64_t v10 = (char *)this + 96;
  uint64_t v9 = *((void *)this + 12);
  if (v9)
  {
    re::SyncView::removeObject(v9, (uint64_t)this + 96);
    if (*(void *)v10)
    {

      *(void *)uint64_t v10 = 0;
    }
  }
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  re::FixedArray<re::SyncObjectState>::deinit((void *)this + 5);
  re::FixedArray<re::SyncObjectState>::deinit((void *)this + 5);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::SyncObject::~SyncObject(this);
  JUMPOUT(0x22A6A9430);
}

void *re::SyncObject::unbindFromParent(void *this)
{
  uint64_t v1 = (void *)this[10];
  if (v1)
  {
    this[10] = 0;
    uint64_t v2 = v1[25];
    if (v2)
    {
      unint64_t v3 = 0;
      while (*(void **)(v1[27] + 8 * v3) != this)
      {
        if (v2 == ++v3) {
          return this;
        }
      }
      return re::DynamicArray<re::Allocator const*>::removeStableAt(v1 + 23, v3);
    }
  }
  return this;
}

unint64_t re::SyncObject::latestStateHandle(re::SyncObject *this)
{
  uint64_t v1 = *((void *)this + 9);
  if (*((void *)this + 8) == v1) {
    return -1;
  }
  unint64_t v3 = *((void *)this + 6);
  if (v3 <= ((v3 - 1) & (v1 - 1)))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return (v3 - 1) & (v1 - 1) | ((unint64_t)*(unsigned int *)(*((void *)this + 7)
                                                                                        + 96 * ((v3 - 1) & (v1 - 1))
                                                                                        + 80) << 32);
}

unint64_t re::SyncObject::addState(re::SyncObject *this, __int16 a2, uint64_t a3)
{
  uint64_t v3 = *((void *)this + 9);
  uint64_t v4 = v3 - *((void *)this + 8);
  unint64_t v5 = *((void *)this + 6);
  uint64_t v6 = v3 + 1;
  if (v4 == v5) {
    *((void *)this + 8) = v6 - v4;
  }
  *((void *)this + 9) = v6;
  unint64_t v7 = (v5 - 1) & v3;
  if (v5 <= v7)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t result = *((void *)this + 7) + 96 * v7;
  *(void *)(result + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(void *)(result + 32) = 0;
  *(_WORD *)(result + 84) = a2;
  *(void *)(result + 88) = a3;
  ++*(_DWORD *)(result + 80);
  return result;
}

BOOL re::SyncObject::takeOverLatestState(re::SyncObject *this)
{
  uint64_t v1 = *((void *)this + 8);
  uint64_t v2 = *((void *)this + 9);
  if (v2 != v1)
  {
    unint64_t v3 = *((void *)this + 6);
    unint64_t v4 = v3 - 1;
    unint64_t v5 = (v3 - 1) & (v2 - 1);
    if (v3 <= v5)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      uint64_t v6 = v2 + 1;
      if (v2 - v1 == v3) {
        *((void *)this + 8) = v6 - v3;
      }
      uint64_t v7 = *((void *)this + 7);
      *((void *)this + 9) = v6;
      unint64_t v8 = v4 & v2;
      if (v3 > (v4 & v2))
      {
        uint64_t v9 = v7 + 96 * v5;
        long long v10 = *(_OWORD *)(v9 + 8);
        uint64_t v11 = v7 + 96 * v8;
        *(_OWORD *)(v11 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(_OWORD *)(v9 + 24);
        *(_OWORD *)(v11 + 8) = v10;
        re::DynamicArray<unsigned char>::operator=(v11 + 40, (uint64_t *)(v9 + 40));
        *(_OWORD *)(v11 + 80) = *(_OWORD *)(v7 + 96 * v5 + 80);
        *(_WORD *)(v11 + 84) = 0;
        *(void *)(v11 + 88) = 0;
        ++*(_DWORD *)(v11 + 80);
        return v2 != v1;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return v2 != v1;
}

uint64_t re::SyncObject::findBaseline(re::SyncObject *this, int a2, uint64_t a3)
{
  uint64_t v4 = *((void *)this + 8);
  uint64_t v3 = *((void *)this + 9);
  if (v3 == v4) {
    return 0;
  }
  unint64_t v5 = *((void *)this + 6);
  unint64_t v6 = v5 - 1;
  while (1)
  {
    uint64_t v7 = --v3 & v6;
    if (v5 <= (v3 & v6))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v8 = *((void *)this + 7);
    if (*(unsigned __int16 *)(v8 + 96 * v7 + 84) == a2 && *(void *)(v8 + 96 * v7 + 88) == a3) {
      break;
    }
    if (v4 == v3) {
      return 0;
    }
  }
  return v8 + 96 * v7;
}

__n128 re::SyncObject::bindWithParent(re::SyncObject *this, re::SyncObject *a2)
{
  if (*((re::SyncObject **)this + 10) != a2)
  {
    *((void *)this + 10) = a2;
    uint64_t v4 = (char *)this + 8;
    unint64_t v5 = (char *)this + 8;
    uint64_t v11 = this;
    re::DynamicArray<re::Allocator const*>::add((void *)a2 + 23, &v11);

    unint64_t v6 = (re::SyncObject *)*((void *)this + 10);
    uint64_t v7 = this;
    if (v6)
    {
      uint64_t v8 = this;
      do
      {
        uint64_t v7 = v8;
        uint64_t v8 = v6;
        if (*(unsigned char *)(*(void *)(*((void *)v7 + 11) + 16) + 73)) {
          break;
        }
        unint64_t v6 = (re::SyncObject *)*((void *)v6 + 10);
        uint64_t v7 = v8;
      }
      while (v6);
    }
    __n128 result = *(__n128 *)((char *)v7 + 136);
    long long v10 = *(_OWORD *)((char *)v7 + 152);
    *((_DWORD *)this + 42) = *((_DWORD *)v7 + 42);
    *(_OWORD *)((char *)this + 152) = v10;
    *(__n128 *)((char *)this + 136) = result;
  }
  return result;
}

unint64_t re::SyncObject::getLatestState(re::SyncObject *this)
{
  uint64_t v1 = *((void *)this + 9);
  if (*((void *)this + 8) == v1) {
    return 0;
  }
  unint64_t v3 = *((void *)this + 6);
  unint64_t v4 = (v3 - 1) & (v1 - 1);
  if (v3 <= v4)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *((void *)this + 7) + 96 * v4;
}

unint64_t re::SyncObject::getOldestState(re::SyncObject *this)
{
  uint64_t v1 = *((void *)this + 8);
  if (v1 == *((void *)this + 9)) {
    return 0;
  }
  unint64_t v3 = *((void *)this + 6);
  unint64_t v4 = (v3 - 1) & v1;
  if (v3 <= v4)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *((void *)this + 7) + 96 * v4;
}

uint64_t re::SyncObject::getState(re::SyncObject *this, uint64_t a2)
{
  unint64_t v2 = *((void *)this + 6);
  if (v2 <= a2) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 8);
  uint64_t v4 = *((void *)this + 9);
  unint64_t v5 = v4 - v3;
  if (v4 == v3) {
    return 0;
  }
  uint64_t v7 = *((void *)this + 7);
  if (v5 >= v2) {
    goto LABEL_12;
  }
  uint64_t v8 = v3 & (v2 - 1);
  if (v2 <= v8)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_16:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v9 = (v4 - 1) & (v2 - 1);
  if (v2 <= v9) {
    goto LABEL_16;
  }
  uint64_t result = 0;
  if (v8 > v9) {
    uint64_t v10 = -(uint64_t)v2;
  }
  else {
    uint64_t v10 = 0;
  }
  if (-1431655765 * ((96 * (unint64_t)a2 - (96 * v8 + 96 * v10)) >> 5) < v5)
  {
LABEL_12:
    if (*(_DWORD *)(v7 + 96 * a2 + 80) == HIDWORD(a2)) {
      return v7 + 96 * a2;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t re::SyncObject::fromPeerID(re::SyncObject *this)
{
  uint64_t v1 = *((void *)this + 9);
  if (*((void *)this + 8) == v1) {
    return 0;
  }
  unint64_t v3 = *((void *)this + 6);
  unint64_t v4 = (v3 - 1) & (v1 - 1);
  if (v3 <= v4)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*((void *)this + 7) + 96 * v4 + 88);
}

uint64_t re::SyncObject::handOff(re::SyncObject *this, uint64_t a2)
{
  unint64_t v2 = (re::SyncObject *)*((void *)this + 10);
  unint64_t v3 = this;
  if (v2)
  {
    unint64_t v4 = this;
    do
    {
      unint64_t v3 = v4;
      unint64_t v4 = v2;
      if (*(unsigned char *)(*(void *)(*((void *)v3 + 11) + 16) + 73)) {
        break;
      }
      unint64_t v2 = (re::SyncObject *)*((void *)v2 + 10);
      unint64_t v3 = v4;
    }
    while (v2);
  }
  if (*((void *)v3 + 20) || !*((void *)this + 20) && *((void *)this + 17)) {
    return 0;
  }
  __int16 v6 = *((_WORD *)this + 84) + 1;
  *((void *)this + 17) = a2;
  *((_WORD *)this + 72) = v6;
  return 1;
}

BOOL re::SyncObject::isStateDataChanged(re::SyncObject *this, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *((void *)this + 9);
  while (*((void *)this + 8) != v3)
  {
    --v3;
    unint64_t v4 = *((void *)this + 6);
    unint64_t v5 = (v4 - 1) & v3;
    if (v4 <= v5)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v6 = *((void *)this + 7);
    if (*(void *)(v6 + 96 * v5 + 88) == a3)
    {
      unsigned int v7 = *(unsigned __int16 *)(v6 + 96 * v5 + 84);
      if (v7 >= a2 && v7 - a2 < 0x8000) {
        return 0;
      }
      if (v7 < a2) {
        return a2 - v7 < 0x8000;
      }
      return 1;
    }
  }
  return 1;
}

BOOL re::SyncObject::shouldAcceptUpdate(re::SyncObject *this, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = (re::SyncObject *)*((void *)this + 10);
  if (v3)
  {
    do
    {
      unint64_t v4 = this;
      this = v3;
      if (*(unsigned char *)(*(void *)(*((void *)v4 + 11) + 16) + 73)) {
        break;
      }
      uint64_t v3 = (re::SyncObject *)*((void *)v3 + 10);
      unint64_t v4 = this;
    }
    while (v3);
  }
  else
  {
    unint64_t v4 = this;
  }
  uint64_t v5 = *((void *)v4 + 20);
  unsigned int v6 = *((unsigned __int16 *)v4 + 84);
  if (v5 == a2)
  {
    if (v6 > a3 || a3 - v6 >= 0x8000) {
      return v6 > a3 && ((v6 - a3) & 0xFFFF8000) != 0;
    }
    else {
      return 1;
    }
  }
  else if (v6 < a3 || v6 - a3 >= 0x8000)
  {
    return v6 >= a3 || a3 - v6 < 0x8000;
  }
  else
  {
    return 0;
  }
}

void re::SyncObject::setViewDirectly(re::SyncObject *this, re::SyncView *a2)
{
  if (!a2 || (*((unsigned char *)this + 128) & 4) == 0)
  {
    uint64_t v3 = (uint64_t *)((char *)this + 96);
    unint64_t v2 = (re::SyncView *)*((void *)this + 12);
    if (v2 != a2)
    {
      if (a2) {
        re::SyncView::transferObject((uint64_t)a2, v3);
      }
      else {
        re::SyncView::removeObject((uint64_t)v2, (uint64_t)v3);
      }
    }
  }
}

void *re::SyncObject::setUserData(uint64_t a1, uint64_t a2, const void *a3)
{
  if (*(void *)(a1 + 112))
  {
    uint64_t v6 = *(void *)(a1 + 120);
    if (v6) {
      (*(void (**)(void))(v6 + 16))();
    }
  }
  _Block_release(*(const void **)(a1 + 120));
  *(void *)(a1 + 112) = a2;
  uint64_t result = _Block_copy(a3);
  *(void *)(a1 + 120) = result;
  return result;
}

void *re::FixedArray<re::SyncObjectState>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = 96 * v2;
      uint64_t v5 = result[2] + 40;
      do
      {
        re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit(v5);
        v5 += 96;
        v4 -= 96;
      }
      while (v4);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

uint64_t re::FixedArray<re::SyncObjectState>::init<>(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  if (!a3) {
    return result;
  }
  if (a3 >= 0x2AAAAAAAAAAAAABLL)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size_t size = %zu, count = %zu", "!overflow", "init", 324, 96, a3);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  uint64_t v4 = result;
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 96 * a3, 8);
  *(void *)(v4 + 16) = result;
  if (!result)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v6 = a3 - 1;
  if (a3 != 1)
  {
    uint64_t v7 = result;
    do
    {
      *(_OWORD *)(result + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0uLL;
      *(_OWORD *)(result + 56) = 0uLL;
      *(_OWORD *)(result + 72) = 0uLL;
      *(_OWORD *)(result + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0uLL;
      *(_OWORD *)(result + 8) = 0uLL;
      *(void *)uint64_t result = &unk_26DD35FD0;
      *(void *)(result + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
      *(void *)(result + 48) = 0;
      *(void *)(result + 56) = 0;
      *(_DWORD *)(result + 64) = 0;
      *(_WORD *)(result + 84) = 0;
      *(void *)(result + 88) = 0;
      result += 96;
      v7 += 96;
      --v6;
    }
    while (v6);
  }
  *(_OWORD *)(result + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0u;
  *(_OWORD *)(result + 8) = 0u;
  *(void *)uint64_t result = &unk_26DD35FD0;
  *(void *)(result + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(_DWORD *)(result + 64) = 0;
  *(_WORD *)(result + 84) = 0;
  *(void *)(result + 88) = 0;
  return result;
}

double RESyncCreateSyncObjectReadContext(re *a1)
{
  uint64_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 80, 8);
  double result = 0.0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_DWORD *)(v2 + 68) = 0x7FFFFFFF;
  return result;
}

re *RESyncDestroySyncObjectReadContext(re *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = re::globalAllocators(result)[2];
    v3.n128_f64[0] = re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v1 + 4);
    uint64_t v4 = *(uint64_t (**)(uint64_t, re *, __n128))(*(void *)v2 + 40);
    return (re *)v4(v2, v1, v3);
  }
  return result;
}

uint64_t RESyncGetSyncObjectReadContextRequiredSize()
{
  return 80;
}

uint64_t RESyncCreateSyncObjectReadContextNoAlloc(uint64_t result, unint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (!result)
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v3 = 136315394;
    uint64_t v4 = "RESyncCreateSyncObjectReadContextNoAlloc";
    __int16 v5 = 2080;
    unint64_t v6 = "bytes != __null";
LABEL_10:
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    return 0;
  }
  if (a2 <= 0x4F)
  {
    uint64_t v2 = *re::networkLogObjects((re *)result);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v3 = 136315394;
    uint64_t v4 = "RESyncCreateSyncObjectReadContextNoAlloc";
    __int16 v5 = 2080;
    unint64_t v6 = "size >= sizeof(SyncObjectReadContext)";
    goto LABEL_10;
  }
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)double result = 0u;
  *(_DWORD *)(result + 68) = 0x7FFFFFFF;
  return result;
}

void RESyncDestroySyncObjectReadContextNoDealloc(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = (uint64_t *)(a1 + 32);
    re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v1);
  }
  else
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      uint64_t v4 = "RESyncDestroySyncObjectReadContextNoDealloc";
      __int16 v5 = 2080;
      unint64_t v6 = "context != __null";
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

BOOL RESyncAddSyncObjectReadContextEntry(re *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v10 = (const char *)a3;
  uint64_t v11 = a2;
  if (!a1)
  {
    uint64_t v9 = *re::networkLogObjects(0);
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)sockaddr buf = 136315394;
    uint64_t v13 = "RESyncAddSyncObjectReadContextEntry";
    __int16 v14 = 2080;
    uint64_t v15 = "context != __null";
    unint64_t v6 = "%s: Invalid parameter not satisfying %s.";
    goto LABEL_13;
  }
  if (!a2)
  {
    uint64_t v9 = *re::networkLogObjects(a1);
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)sockaddr buf = 136315394;
    uint64_t v13 = "RESyncAddSyncObjectReadContextEntry";
    __int16 v14 = 2080;
    uint64_t v15 = "entry != __null";
    unint64_t v6 = "%s: Invalid parameter not satisfying %s.";
LABEL_13:
    uint64_t v7 = v9;
    uint32_t v8 = 22;
    goto LABEL_6;
  }
  int v3 = (re *)re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<void *&>((uint64_t)a1 + 32, (uint64_t *)&v10, &v11);
  if (*(void *)v3 == v11) {
    return 1;
  }
  uint64_t v4 = *re::networkLogObjects(v3);
  BOOL result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)sockaddr buf = 134217984;
    uint64_t v13 = v10;
    unint64_t v6 = "RESyncAddSyncObjectReadContextEntry: Failed to add entry using id=%llu, possible duplicate!";
    uint64_t v7 = v4;
    uint32_t v8 = 12;
LABEL_6:
    _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, v6, buf, v8);
    return 0;
  }
  return result;
}

uint64_t RESyncGetSyncObjectReadContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t v6 = (const char *)a2;
  if (a1)
  {
    uint64_t v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 32, (uint64_t *)&v6);
    if (v2) {
      return *(void *)v2;
    }
    uint64_t v4 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)sockaddr buf = 134217984;
      uint32_t v8 = v6;
      _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_INFO, "RESyncGetSyncObjectReadContextEntry: Couldn't find entry with id=%llu.", buf, 0xCu);
    }
  }
  else
  {
    __int16 v5 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)sockaddr buf = 136315394;
      uint32_t v8 = "RESyncGetSyncObjectReadContextEntry";
      __int16 v9 = 2080;
      uint64_t v10 = "context != __null";
      _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    }
  }
  return 0;
}

BOOL RESyncRemoveSyncObjectReadContextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v7 = (const char *)a2;
  if (a1)
  {
    uint64_t v2 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a1 + 32, (uint64_t *)&v7);
    if (v2) {
      return 1;
    }
    uint64_t v4 = *re::networkLogObjects((re *)v2);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (v5)
    {
      *(_DWORD *)sockaddr buf = 134217984;
      __int16 v9 = v7;
      _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "RESyncRemoveSyncObjectReadContextEntry: Couldn't find entry with id=%llu.", buf, 0xCu);
      return 0;
    }
  }
  else
  {
    unint64_t v6 = *re::networkLogObjects(0);
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_DWORD *)sockaddr buf = 136315394;
      __int16 v9 = "RESyncRemoveSyncObjectReadContextEntry";
      __int16 v10 = 2080;
      uint64_t v11 = "context != __null";
      _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
      return 0;
    }
  }
  return result;
}

uint64_t RESyncObjectReadContextGetSession(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)a1;
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    uint64_t v4 = "RESyncObjectReadContextGetSession";
    __int16 v5 = 2080;
    unint64_t v6 = "context != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncObjectReadContextGetSourcePeerID(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 8);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    uint64_t v4 = "RESyncObjectReadContextGetSourcePeerID";
    __int16 v5 = 2080;
    unint64_t v6 = "context != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncObjectReadContextGetSyncableGuid(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 16);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    uint64_t v4 = "RESyncObjectReadContextGetSyncableGuid";
    __int16 v5 = 2080;
    unint64_t v6 = "context != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

BOOL RESyncObjectReadContextSupportsProtocolLevelAlmond(uint64_t a1)
{
  return RESyncObjectReadContextSupportsProtocolLevel(a1, 8);
}

BOOL RESyncObjectReadContextSupportsProtocolLevel(uint64_t a1, int a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a1) {
    return (a2 & ~*(_DWORD *)(a1 + 24)) == 0;
  }
  int v3 = *re::networkLogObjects(0);
  BOOL result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v4 = 136315394;
    __int16 v5 = "RESyncObjectReadContextSupportsProtocolLevel";
    __int16 v6 = 2080;
    uint64_t v7 = "context != __null";
    _os_log_error_impl(&dword_228C70000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v4, 0x16u);
    return 0;
  }
  return result;
}

BOOL RESyncObjectReadContextSupportsProtocolLevelPistachio(uint64_t a1)
{
  return RESyncObjectReadContextSupportsProtocolLevel(a1, 16);
}

BOOL RESyncObjectReadContextSupportsProtocolLevelWalnut(uint64_t a1)
{
  return RESyncObjectReadContextSupportsProtocolLevel(a1, 32);
}

BOOL RESyncObjectReadContextIsLocalSession(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    (*(void (**)(unsigned char *__return_ptr))(**(void **)a1 + 32))(v4);
    BOOL v1 = *(unsigned char *)(*(void *)v4 + 2219) != 0;
  }
  else
  {
    int v3 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v4 = 136315394;
      *(void *)&void v4[4] = "RESyncObjectReadContextIsLocalSession";
      __int16 v5 = 2080;
      __int16 v6 = "context != __null";
      _os_log_error_impl(&dword_228C70000, v3, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", v4, 0x16u);
    }
    return 0;
  }
  return v1;
}

double re::Packet::swap(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  LODWORD(v3) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v3;
  double result = *(double *)(a2 + 28);
  uint64_t v5 = *(void *)(a1 + 28);
  *(double *)(a1 + 28) = result;
  *(void *)(a2 + 28) = v5;
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v6;
  uint64_t v7 = *(void *)(a1 + 40);
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v7;
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v8;
  return result;
}

void re::PacketPool::free(re::PacketPool *this, re::Packet *a2)
{
  uint64_t v4 = *((void *)a2 + 1);
  int v5 = *((_DWORD *)a2 + 7) + *((_DWORD *)a2 + 4) - v4;
  *((void *)a2 + 2) = v4;
  *((_DWORD *)a2 + 6) = 0;
  *((_DWORD *)a2 + 7) = v5;
  uint64_t v6 = (os_unfair_lock_s *)((char *)this + 128);
  os_unfair_lock_lock((os_unfair_lock_t)this + 32);
  unsigned int v7 = *((_DWORD *)a2 + 7);
  if (v7 <= *((_DWORD *)this + 38) && (unsigned int v8 = *((_DWORD *)this + 35) + v7, v8 <= *((_DWORD *)this + 39)))
  {
    uint64_t v13 = *((void *)this + 14);
    *((void *)this + 14) = a2;
    *((void *)a2 + 6) = v13;
    LODWORD(v13) = *((_DWORD *)this + 36) + 1;
    *((_DWORD *)this + 35) = v8;
    *((_DWORD *)this + 36) = v13;
  }
  else
  {
    int32x2_t v9 = *(int32x2_t *)((char *)this + 132);
    LODWORD(v10) = vsub_s32(v9, (int32x2_t)(v7 | 0xFFFFFFFF00000000)).u32[0];
    HIDWORD(v10) = vadd_s32(v9, (int32x2_t)-1).i32[1];
    *(void *)((char *)this + 132) = v10;
    uint64_t v11 = (re *)(*(uint64_t (**)(void, void))(**((void **)this + 3) + 40))(*((void *)this + 3), *((void *)a2 + 1));
    uint64_t v12 = re::globalAllocators(v11);
    (*(void (**)(uint64_t, re::Packet *))(*(void *)v12[2] + 40))(v12[2], a2);
  }
  os_unfair_lock_unlock(v6);
}

re::PacketQueue *re::PacketQueue::PacketQueue(re::PacketQueue *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  uint64_t v2 = re::globalAllocators(this);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 64, 64);
  *(_OWORD *)uint64_t v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_DWORD *)(v3 + 32) = 0;
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 56) = 0;
  *(void *)(v3 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  *(void *)this = v3;
  *((void *)this + 1) = v3;
  atomic_store(0, (unsigned int *)this + 6);
  atomic_store(0, (unint64_t *)this + 2);
  atomic_store(0, (unint64_t *)this + 4);
  return this;
}

void re::PacketQueue::~PacketQueue(re::PacketQueue *this)
{
  uint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    uint64_t v3 = re::globalAllocators(this);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3[2] + 40))(v3[2], v2);
  }
  *(void *)this = 0;
  *((void *)this + 1) = 0;
}

uint64_t re::PacketQueue::dequeue(re::PacketQueue *this)
{
  uint64_t explicit = atomic_load_explicit(*((atomic_ullong *volatile *)this + 1), memory_order_acquire);
  if (!explicit) {
    return 0;
  }
  re::Packet::swap(*((void *)this + 1), explicit);
  uint64_t result = *((void *)this + 1);
  *((void *)this + 1) = explicit;
  atomic_fetch_add_explicit((atomic_uint *volatile)this + 6, -*(_DWORD *)(result + 24), memory_order_release);
  atomic_fetch_add_explicit((atomic_ullong *volatile)this + 4, -(uint64_t)*(unsigned int *)(result + 28), memory_order_release);
  atomic_fetch_add_explicit((atomic_ullong *volatile)this + 2, 0xFFFFFFFFFFFFFFFFLL, memory_order_release);
  atomic_store(0, (unint64_t *)result);
  return result;
}

uint64_t re::InlineString<32ul>::assignf(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *a1 = 0;
  return re::InlineString<32ul>::vappendf(a1, "PacketPool%s", &a9);
}

void re::PacketPool::~PacketPool(re::PacketPool *this)
{
  *(void *)this = &unk_26DD35F18;
  for (uint64_t i = *((void *)this + 14); i; uint64_t i = *((void *)this + 14))
  {
    *((void *)this + 14) = *(void *)(i + 48);
    *(void *)(i + 48) = 0;
    v3.i32[1] = -1;
    v3.i32[0] = *(_DWORD *)(i + 28);
    int32x2_t v4 = *(int32x2_t *)((char *)this + 140);
    v3.i32[0] = vsub_s32(v4, v3).u32[0];
    v3.i32[1] = vadd_s32(v4, (int32x2_t)-1).i32[1];
    *(int32x2_t *)((char *)this + 1re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v3;
    int v5 = (re *)(*(uint64_t (**)(void, void))(**((void **)this + 3) + 40))(*((void *)this + 3), *(void *)(i + 8));
    uint64_t v6 = re::globalAllocators(v5);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6[2] + 40))(v6[2], i);
  }
  uint64_t v7 = *((void *)this + 3);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  *((void *)this + 3) = 0;
  *((void *)this + 20) = 0;
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::PacketPool::~PacketPool(this);
  JUMPOUT(0x22A6A9420);
}

void re::PacketPool::make(re::PacketPool *this@<X0>, re::MallocZoneAllocator *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v7 = re::globalAllocators(this);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[2] + 32))(v7[2], 256, 64);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v8, 0);
  *(void *)(v8 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(void *)uint64_t v8 = &unk_26DD35F18;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_DWORD *)(v8 + 96) = 0;
  *(_OWORD *)(v8 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 132) = 0u;
  *(void *)(v8 + 148) = 0x10000000002000;
  *(_DWORD *)(v8 + 156) = 0x1000000;
  *(_OWORD *)(v8 + 176) = 0u;
  uint64_t v17 = &unk_228CE091E;
  *(void *)(v8 + 192) = 0;
  if (a2) {
    LOBYTE(v17) = (_BYTE)a2;
  }
  *(_OWORD *)(v9 + 160) = 0uLL;
  re::InlineString<32ul>::assignf((unint64_t *)(v9 + 160), v10, v11, v12, v13, v14, v15, v16, (char)v17);
  if (!this) {
    operator new();
  }
  *(void *)(v8 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = this;
  re::Defaults::intValue((re::Defaults *)"network.packetpool.minPacketSize", v18, (uint64_t)v24);
  if (v24[0]) {
    id v20 = v25;
  }
  else {
    id v20 = (_DWORD *)(v8 + 148);
  }
  *(_DWORD *)(v8 + 148) = *v20;
  re::Defaults::intValue((re::Defaults *)"network.packetpool.maxFreePacketSize", v19, (uint64_t)v24);
  if (v24[0]) {
    uint64_t v22 = v25;
  }
  else {
    uint64_t v22 = (_DWORD *)(v8 + 152);
  }
  *(_DWORD *)(v8 + 152) = *v22;
  re::Defaults::intValue((re::Defaults *)"network.packetpool.maxFreePacketPoolMemory", v21, (uint64_t)v24);
  uint64_t v23 = (_DWORD *)(v8 + 156);
  if (v24[0]) {
    uint64_t v23 = v25;
  }
  *(_DWORD *)(v8 + 156) = *v23;
  *a3 = v8;
}

void re::PacketPool::emitAriadneSignpost(os_unfair_lock_s *this)
{
  BOOL v1 = this + 32;
  os_unfair_lock_lock(this + 32);
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  os_unfair_lock_unlock(v1);
}

char *re::PacketPool::allocate(re::PacketPool *this, uint64_t a2)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  int32x2_t v4 = (os_unfair_lock_s *)((char *)this + 128);
  os_unfair_lock_lock((os_unfair_lock_t)this + 32);
  uint64_t v6 = (char *)this + 64;
  while (1)
  {
    uint64_t v7 = v6;
    uint64_t v6 = (char *)*((void *)v6 + 6);
    if (!v6) {
      break;
    }
    LODWORD(v8) = *((_DWORD *)v6 + 7);
    if (v8 >= a2)
    {
      *((void *)v7 + 6) = *((void *)v6 + 6);
      *((void *)v6 + 6) = 0;
      int32x2_t v9 = *(int32x2_t *)((char *)this + 140);
      LODWORD(v10) = vsub_s32(v9, (int32x2_t)(v8 | 0xFFFFFFFF00000000)).u32[0];
      HIDWORD(v10) = vadd_s32(v9, (int32x2_t)-1).i32[1];
      *(void *)((char *)this + 1re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = v10;
      goto LABEL_10;
    }
  }
  unsigned int v11 = *((_DWORD *)this + 37);
  if (v11 <= a2) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = v11;
  }
  uint64_t v12 = (re *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)this + 3) + 32))(*((void *)this + 3), v8, 0);
  if (!v12)
  {
    re::internal::assertLog((re::internal *)0xA, v13, "assertion failure: '%s' (%s:line %i) [Network] Failed to allocate packet buffer of size %u(%u), totalCount=%d, totalBytes=%u, availableCount=%d, availableBytes=%u", "false", "allocate", 188, v8, a2, *((unsigned int *)this + 34), *((unsigned int *)this + 33), *((unsigned int *)this + 36), *((unsigned int *)this + 35));
    uint64_t result = (char *)_os_crash();
    __break(1u);
    return result;
  }
  uint64_t v14 = v12;
  uint64_t v15 = re::globalAllocators(v12);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15[2] + 32))(v15[2], 64, 64);
  uint64_t v6 = (char *)v5;
  *(void *)uint64_t v5 = 0;
  *(void *)(v5 + 8) = v14;
  *(void *)(v5 + 16) = v14;
  *(_DWORD *)(v5 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(_DWORD *)(v5 + 28) = v8;
  *(_DWORD *)(v5 + 32) = 0;
  *(void *)(v5 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 40) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 56) = this;
  *(int32x2_t *)((char *)this + 132) = vadd_s32(*(int32x2_t *)((char *)this + 132), (int32x2_t)(v8 | 0x100000000));
LABEL_10:
  if (v8 > *((_DWORD *)this + 38))
  {
    uint64_t v16 = *re::networkLogObjects((re *)v5);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *((_DWORD *)v6 + 7);
      int v19 = *((_DWORD *)this + 33);
      int v18 = *((_DWORD *)this + 34);
      int v21 = *((_DWORD *)this + 35);
      int v20 = *((_DWORD *)this + 36);
      *(_DWORD *)sockaddr buf = 67110144;
      int v24 = v17;
      __int16 v25 = 1024;
      int v26 = v18;
      __int16 v27 = 1024;
      int v28 = v19;
      __int16 v29 = 1024;
      int v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      _os_log_impl(&dword_228C70000, v16, OS_LOG_TYPE_DEFAULT, "Large packet buffer allocated: %u, totalCount=%d, totalBytes=%u, availableCount=%d, availableBytes=%u", buf, 0x20u);
    }
  }
  os_unfair_lock_unlock(v4);
  return v6;
}

uint64_t re::SessionParticipant::SessionParticipant(uint64_t a1, uint64_t a2, int a3, char *a4, size_t a5)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a2;
  *(void *)a1 = &unk_26DD35F60;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 64) = 0;
  unsigned int v11 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)(a1 + 40), 0);
  *(_DWORD *)(a1 + 72) = a3;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  re::DynamicString::setCapacity((void *)(a1 + 80), 0);
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  if (a4 && a5 && a5 <= 0x400000) {
    re::DynamicArray<unsigned char>::copy((void *)(a1 + 112), 0, a4, a5);
  }
  return a1;
}

uint64_t re::SessionParticipant::SessionParticipant(uint64_t a1, uint64_t a2, uint64_t a3, const re::DynamicString *a4, int a5, char *a6, size_t a7)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a2;
  *(void *)a1 = &unk_26DD35F60;
  *(void *)(a1 + 32) = a3;
  uint64_t v14 = re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), a4);
  *(_DWORD *)(a1 + 72) = a5;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  re::DynamicString::setCapacity((void *)(a1 + 80), 0);
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  if (a6 && a7 && a7 <= 0x400000) {
    re::DynamicArray<unsigned char>::copy((void *)(a1 + 112), 0, a6, a7);
  }
  return a1;
}

void re::SessionParticipant::~SessionParticipant(re::SessionParticipant *this)
{
  *(void *)this = &unk_26DD35F60;
  uint64_t v2 = *((void *)this + 19);
  if (v2)
  {

    *((void *)this + 19) = 0;
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 112);
  re::DynamicString::deinit((re::SessionParticipant *)((char *)this + 80));
  re::DynamicString::deinit((re::SessionParticipant *)((char *)this + 40));
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_26DD35F60;
  uint64_t v2 = *((void *)this + 19);
  if (v2)
  {

    *((void *)this + 19) = 0;
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 112);
  re::DynamicString::deinit((re::SessionParticipant *)((char *)this + 80));
  re::DynamicString::deinit((re::SessionParticipant *)((char *)this + 40));
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

BOOL re::BitWriter::rollbackTo(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a2;
  *(void *)(a1 + 32) = 0;
  if (HIDWORD(a2)) {
    unsigned int v2 = a2 + 1;
  }
  else {
    unsigned int v2 = a2;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  *(unsigned char *)(a1 + 20) = v2 > v3;
  if (HIDWORD(a2) && v2 <= v3) {
    *(void *)(a1 + 32) = (0xFFuLL >> (8 - BYTE4(a2))) & *(unsigned __int8 *)(*(void *)(a1 + 8) + a2);
  }
  return v2 <= v3;
}

uint64_t re::BitWriter::writeUInt32Bits(uint64_t this, unsigned int a2, unsigned int a3)
{
  if (!*(unsigned char *)(this + 20))
  {
    uint64_t v5 = this;
    unsigned int v6 = *(_DWORD *)(this + 16);
    unsigned int v7 = *(_DWORD *)(this + 24);
    int v8 = *(_DWORD *)(this + 28);
    unsigned int v9 = 8 * (v6 - v7) - v8;
    BOOL v10 = a3 >= v9;
    unsigned int v11 = a3 - v9;
    if (v11 != 0
      && v10
      && (this = (*(uint64_t (**)(uint64_t, void))(*(void *)this + 16))(this, (v11 >> 3) + 1),
          unsigned int v6 = *(_DWORD *)(v5 + 16),
          unsigned int v7 = *(_DWORD *)(v5 + 24),
          int v8 = *(_DWORD *)(v5 + 28),
          8 * (v6 - v7) - v8 < a3))
    {
      *(_DWORD *)(v5 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v6;
      *(_DWORD *)(v5 + 28) = 0;
      *(unsigned char *)(v5 + 20) = 1;
    }
    else
    {
      unint64_t v12 = ((unint64_t)a2 << v8) | *(void *)(v5 + 32);
      *(void *)(v5 + 32) = v12;
      unsigned int v13 = v8 + a3;
      *(_DWORD *)(v5 + 28) = v13;
      if (v13 >= 8)
      {
        do
        {
          uint64_t v14 = *(void *)(v5 + 8);
          uint64_t v15 = *(unsigned int *)(v5 + 24);
          *(_DWORD *)(v5 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v15 + 1;
          *(unsigned char *)(v14 + v15) = v12;
          unint64_t v12 = *(void *)(v5 + 32) >> 8;
          *(void *)(v5 + 32) = v12;
          unsigned int v13 = *(_DWORD *)(v5 + 28) - 8;
          *(_DWORD *)(v5 + 28) = v13;
        }
        while (v13 > 7);
        unsigned int v7 = *(_DWORD *)(v5 + 24);
        unsigned int v6 = *(_DWORD *)(v5 + 16);
      }
      if (v7 < v6) {
        *(unsigned char *)(*(void *)(v5 + 8) + v7) = (-1 << v13) & *(unsigned char *)(*(void *)(v5 + 8) + v7) | v12 & ~(-1 << v13);
      }
    }
  }
  return this;
}

uint64_t re::BitWriter::writeUInt64Bits(re::BitWriter *this, unint64_t a2, unsigned int a3)
{
  unsigned int v3 = a3;
  unint64_t v4 = a2;
  uint64_t v5 = this;
  if (a3 >= 0x21)
  {
    re::BitWriter::writeUInt32Bits((uint64_t)this, a2, 0x20u);
    a2 = HIDWORD(v4);
    a3 = v3 - 32;
    this = v5;
  }
  return re::BitWriter::writeUInt32Bits((uint64_t)this, a2, a3);
}

uint64_t re::BitWriter::writeUInt32At(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if ((a2 + 4) > *(_DWORD *)(a1 + 16))
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Marker is out of bounds", "marker.byteOffset + 4 <= m_dataSize", "writeUInt32At", 84);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 24);
    re::BitWriter::rollbackTo(a1, a2);
    re::BitWriter::writeUInt32Bits(a1, a3, 0x20u);
    return re::BitWriter::rollbackTo(a1, v5);
  }
  return result;
}

uint64_t re::BitWriter::writeData(re::BitWriter *this, const void *a2, uint64_t a3)
{
  unsigned int v3 = a3;
  if (!a2 && a3)
  {
    re::internal::assertLog((re::internal *)5, 0, "assertion failure: '%s' (%s:line %i) data==null, dataSize==%u", "!(data == nullptr && dataSize > 0)", "writeData", 117, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    if (re::BitWriter::bytesLeft(this, (uint64_t)a2) < a3)
    {
      int v7 = re::BitWriter::bytesLeft(this, v6);
      (*(void (**)(re::BitWriter *, void))(*(void *)this + 16))(this, v3 - v7);
      if (re::BitWriter::bytesLeft(this, v8) < v3)
      {
        *((_DWORD *)this + 6) = *((_DWORD *)this + 4);
        *((_DWORD *)this + 7) = 0;
        *((unsigned char *)this + 20) = 1;
        return *((unsigned char *)this + 20) == 0;
      }
    }
    re::BitWriter::alignToByte(this);
    uint64_t v10 = *((void *)this + 1);
    if (v10)
    {
      if (a2)
      {
        if (v3)
        {
          memcpy((void *)(v10 + *((unsigned int *)this + 6)), a2, v3);
          *((_DWORD *)this + 6) += v3;
          *((void *)this + 4) = 0;
        }
      }
      return *((unsigned char *)this + 20) == 0;
    }
  }
  re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) memcpy destination data is null", "m_data != nullptr", "operator()", 120);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::BitWriter::bytesLeft(re::BitWriter *this, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)this + 4);
  unsigned int v3 = *((_DWORD *)this + 6);
  BOOL v4 = v2 >= v3;
  unsigned int v5 = v2 - v3;
  if (v4)
  {
    int v6 = *((_DWORD *)this + 7);
    if (v5 != 0 && v4)
    {
      if (v6) {
        int v6 = -1;
      }
      else {
        int v6 = 0;
      }
    }
    else if (v6)
    {
      goto LABEL_10;
    }
    return v5 + v6;
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Writer is in inconsistent state", "m_dataSize >= m_byteOffset", "bytesLeft", 171);
  _os_crash();
  __break(1u);
LABEL_10:
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Writer is in inconsistent state", "m_byteOffset < m_dataSize || m_bitOffset == 0", "bytesLeft", 172);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

_DWORD *re::BitWriter::alignToByte(_DWORD *this)
{
  BOOL v1 = this;
  int v2 = this[6];
  int v3 = this[7];
  unsigned int v4 = 8 - v3;
  if (8 * (this[4] - v2) != 8
    && 8 - v3 >= (8 * (this[4] - v2) - v3)
    && (this = (_DWORD *)(*(uint64_t (**)(_DWORD *, void))(*(void *)this + 16))(this, ((8 - 8 * (this[4] - v2)) >> 3) + 1), v5 = v1[4], int v2 = v1[6], v3 = v1[7], 8 * (v5 - v2) - v3 < v4))
  {
    v1[6] = v5;
    v1[7] = 0;
    *((unsigned char *)v1 + 20) = 1;
  }
  else
  {
    if (v3) {
      ++v2;
    }
    v1[6] = v2;
    v1[7] = 0;
    *((void *)v1 + 4) = 0;
  }
  return this;
}

void *re::BitWriter::copyDataTo(re::BitWriter *this, void *__dst, size_t a3)
{
  LODWORD(v3) = *((_DWORD *)this + 6);
  if (*((_DWORD *)this + 7)) {
    size_t v3 = (v3 + 1);
  }
  else {
    size_t v3 = v3;
  }
  if (v3 < a3)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)__dst, "assertion failure: '%s' (%s:line %i) ", "bytesToCopy <= size()", "copyDataTo", 204);
    uint64_t result = (void *)_os_crash();
    __break(1u);
  }
  else
  {
    unsigned int v4 = (const void *)*((void *)this + 1);
    return memcpy(__dst, v4, a3);
  }
  return result;
}

void re::DynamicBitWriter::grow(re::DynamicBitWriter *this, unsigned int a2)
{
  size_t v3 = (char *)this + 40;
  uint64_t v4 = *((void *)this + 7);
  unint64_t v5 = v4 + a2;
  unint64_t v6 = 2 * v4;
  if (v6 <= v5) {
    unint64_t v7 = v5;
  }
  else {
    unint64_t v7 = v6;
  }
  re::DynamicArray<unsigned char>::resize((uint64_t)v3, v7);
  *((void *)this + 1) = *((void *)this + 9);
  *((_DWORD *)this + 4) = *((void *)this + 7);
}

uint64_t re::BackedBitWriter::grow(uint64_t this, int a2)
{
  int v2 = *(uint64_t (**)(void, void))(this + 40);
  if (v2)
  {
    uint64_t v3 = this;
    int v4 = *(_DWORD *)(this + 16) + a2;
    this = v2(*(void *)(this + 48), *(void *)(this + 8));
    *(void *)(v3 + 8) = this;
    *(_DWORD *)(v3 + 16) = v4;
  }
  return this;
}

void re::BitWriter::~BitWriter(re::BitWriter *this)
{
}

void re::DynamicBitWriter::~DynamicBitWriter(re::DynamicBitWriter *this)
{
}

{
  uint64_t vars8;

  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40);
  JUMPOUT(0x22A6A9430);
}

void re::BackedBitWriter::~BackedBitWriter(re::BackedBitWriter *this)
{
}

double re::NetworkSyncManager::NetworkSyncManager(re::NetworkSyncManager *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD36060;
  *((void *)this + 29) = 0;
  *((_DWORD *)this + 60) = 0;
  double result = 0.0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_DWORD *)this + 56) = 0;
  *((_OWORD *)this + 16) = 0u;
  *((_DWORD *)this + 68) = 0;
  *((void *)this + 31) = 0;
  *((void *)this + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  *((_DWORD *)this + 82) = 0;
  *((_DWORD *)this + 78) = 0;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((void *)this + 42) = 0;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((_DWORD *)this + 90) = 0;
  *((void *)this + 51) = 0;
  *((_DWORD *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0;
  *((_DWORD *)this + 100) = 0;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0u;
  *((void *)this + 55) = 0;
  *((_DWORD *)this + 112) = 0;
  *(_OWORD *)((char *)this + 4re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0u;
  *((void *)this + 62) = 0;
  *((_DWORD *)this + 126) = 0;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((_DWORD *)this + 122) = 0;
  *((void *)this + 66) = 0;
  *((_DWORD *)this + 134) = 0;
  *((_OWORD *)this + 32) = 0u;
  *((void *)this + 73) = 0;
  *((_DWORD *)this + 148) = 0;
  *((_DWORD *)this + 144) = 0;
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_DWORD *)this + 156) = 0;
  *((void *)this + 77) = 0;
  *(_OWORD *)((char *)this + 600) = 0u;
  *((void *)this + 84) = 0;
  *((_DWORD *)this + 170) = 0;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *((_DWORD *)this + 166) = 0;
  *((_OWORD *)this + 43) = 0u;
  *((_DWORD *)this + 178) = 0;
  *((void *)this + 88) = 0;
  *((void *)this + 95) = 0;
  *((_DWORD *)this + 192) = 0;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((_DWORD *)this + 188) = 0;
  *(_OWORD *)((char *)this + 776) = 0u;
  *((_DWORD *)this + 200) = 0;
  *((void *)this + 99) = 0;
  *((void *)this + 106) = 0;
  *((_DWORD *)this + 214) = 0;
  *((_DWORD *)this + 210) = 0;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 8re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0u;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 22) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 32) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 46) = 0;
  *(_OWORD *)((char *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  return result;
}

void re::NetworkSyncManager::~NetworkSyncManager(re::NetworkSyncManager *this)
{
  *(void *)this = &unk_26DD36060;
  if (*((unsigned char *)this + 48))
  {
    re::NetworkSyncManager::stopSync(this);
    re::NetworkSyncManager::removeDeferredSessions(this);
    uint64_t v2 = *((void *)this + 19);
    if (v2)
    {

      *((void *)this + 19) = 0;
    }
    if (*((void *)this + 53)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 424);
    }
    if (*((void *)this + 42)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 336);
    }
    if (*((void *)this + 97)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 776);
    }
    if (*((void *)this + 86)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 688);
    }
    if (*((void *)this + 75)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 600);
    }
    if (*((void *)this + 64)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 512);
    }
    if (*((void *)this + 31)) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 248);
    }
    uint64_t v3 = (re::NetworkSyncManager *)((char *)this + 160);
    if (*((void *)this + 20)) {
      uint64_t v3 = (re *)re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v3);
    }
    *((unsigned char *)this + 48) = 0;
    int v4 = *re::networkLogObjects(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: uninitialized", v16, 2u);
    }
  }
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 97);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 86);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 75);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 64);
  if (*((void *)this + 53)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 424);
  }
  uint64_t v5 = *((void *)this + 58);
  if (v5)
  {
    if (*((void *)this + 62)) {
      (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
    }
    *((void *)this + 62) = 0;
    *((void *)this + 59) = 0;
    *((void *)this + 60) = 0;
    *((void *)this + 58) = 0;
    ++*((_DWORD *)this + 122);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 424);
  if (*((void *)this + 42)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 336);
  }
  uint64_t v6 = *((void *)this + 47);
  if (v6)
  {
    if (*((void *)this + 51)) {
      (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
    }
    *((void *)this + 51) = 0;
    *((void *)this + 48) = 0;
    *((void *)this + 49) = 0;
    *((void *)this + 47) = 0;
    ++*((_DWORD *)this + 100);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 336);
  re::Event<re::Session>::~Event((uint64_t)this + 248);
  re::Event<re::Session>::~Event((uint64_t)this + 160);
  uint64_t v7 = *((void *)this + 19);
  if (v7)
  {

    *((void *)this + 19) = 0;
  }
  uint64_t v8 = *((void *)this + 18);
  if (v8)
  {

    *((void *)this + 18) = 0;
  }
  uint64_t v9 = *((void *)this + 13);
  if (v9)
  {
    if (*((void *)this + 17)) {
      (*(void (**)(uint64_t))(*(void *)v9 + 40))(v9);
    }
    *((void *)this + 17) = 0;
    *((void *)this + 14) = 0;
    *((void *)this + 15) = 0;
    *((void *)this + 13) = 0;
    ++*((_DWORD *)this + 32);
  }
  uint64_t v10 = *((void *)this + 8);
  if (v10)
  {
    uint64_t v11 = *((void *)this + 12);
    if (v11)
    {
      uint64_t v12 = *((void *)this + 10);
      if (v12)
      {
        uint64_t v13 = 8 * v12;
        do
        {
          if (*(void *)v11)
          {

            *(void *)uint64_t v11 = 0;
          }
          v11 += 8;
          v13 -= 8;
        }
        while (v13);
        uint64_t v10 = *((void *)this + 8);
        uint64_t v11 = *((void *)this + 12);
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 40))(v10, v11);
    }
    *((void *)this + 12) = 0;
    *((void *)this + 9) = 0;
    *((void *)this + 10) = 0;
    *((void *)this + 8) = 0;
    ++*((_DWORD *)this + 22);
  }
  uint64_t v14 = *((void *)this + 7);
  if (v14)
  {

    *((void *)this + 7) = 0;
  }
  uint64_t v15 = *((void *)this + 4);
  if (v15)
  {

    *((void *)this + 4) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::NetworkSyncManager::~NetworkSyncManager(this);
  JUMPOUT(0x22A6A9430);
}

void re::NetworkSyncManager::init(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v5;
  uint64_t v6 = (void *)(a1 + 32);
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 32), v4);
  *(void *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = a2[2];
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 160), 0);
  ++*(_DWORD *)(a1 + 184);
  uint64_t v9 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 248), 0);
  ++*(_DWORD *)(a1 + 272);
  uint64_t v10 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 512), 0);
  ++*(_DWORD *)(a1 + 536);
  uint64_t v11 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 600), 0);
  ++*(_DWORD *)(a1 + 624);
  uint64_t v12 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 688), 0);
  ++*(_DWORD *)(a1 + 712);
  uint64_t v13 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 776), 0);
  ++*(_DWORD *)(a1 + 800);
  uint64_t v14 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 336), 0);
  ++*(_DWORD *)(a1 + 360);
  uint64_t v15 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 424), 0);
  ++*(_DWORD *)(a1 + 448);
  uint64_t v16 = re::make::shared::object<re::RoutingTable>(v15, &v26);
  uint64_t v17 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = v26;
  int v26 = (re::RoutingTable *)v17;
  if (v17) {

  }
  int v18 = re::globalAllocators(v16);
  int v19 = (re::SyncViewManager *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18[2] + 32))(v18[2], 208, 8);
  int v20 = re::SyncViewManager::SyncViewManager(v19);
  uint64_t v21 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = v20;
  if (v21) {

  }
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 56), a2[1]);
  uint64_t v23 = *(void *)(a1 + 32);
  if (v23)
  {

    *uint64_t v6 = 0;
  }
  *(unsigned char *)(a1 + 48) = 1;
  int v24 = *re::networkLogObjects(v22);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int16 v25 = 0;
    _os_log_impl(&dword_228C70000, v24, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: initialized", v25, 2u);
  }
}

void re::NetworkSyncManager::removeDeferredSessions(re::NetworkSyncManager *this)
{
  for (uint64_t i = *((void *)this + 15); i; uint64_t i = *((void *)this + 15))
    re::NetworkSyncManager::removeSession(this, *(re::Session **)(*((void *)this + 17) + 8 * i - 8));
}

uint64_t re::NetworkSyncManager::startSyncWithSession(re *a1, re::Session **a2)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)a1 + 48))
  {
    id v38 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      uint64_t v35 = "NetworkSyncManager: Not initialized.";
      __int16 v36 = v38;
      uint32_t v37 = 2;
      goto LABEL_61;
    }
    return 0;
  }
  if (!*a2 || !*((unsigned char *)*a2 + 2272))
  {
    uint64_t v33 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      unint64_t v34 = *a2;
      *(_DWORD *)sockaddr buf = 134217984;
      *(void *)&uint8_t buf[4] = v34;
      uint64_t v35 = "NetworkSyncManager: Invalid session object (%p).";
LABEL_35:
      __int16 v36 = v33;
      uint32_t v37 = 12;
LABEL_61:
      _os_log_error_impl(&dword_228C70000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
    }
    return 0;
  }
  uint64_t v3 = a1;
  uint64_t v4 = *((void *)a1 + 10);
  if (v4)
  {
    uint64_t v5 = *((void *)a1 + 12);
    uint64_t v6 = 8 * v4;
    while (1)
    {
      a1 = (re *)(*(void *(**)(uint8_t *__return_ptr))(**(void **)v5 + 32))(buf);
      uint64_t v7 = *a2;
      uint64_t v8 = *(re::Session **)buf;
      if (*(void *)buf) {

      }
      if (v8 == v7) {
        break;
      }
      v5 += 8;
      v6 -= 8;
      if (!v6) {
        goto LABEL_10;
      }
    }
    uint64_t v33 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    uint64_t v48 = *a2;
    *(_DWORD *)sockaddr buf = 134217984;
    *(void *)&uint8_t buf[4] = v48;
    uint64_t v35 = "NetworkSyncManager: Session already used to sync (%p).";
    goto LABEL_35;
  }
LABEL_10:
  uint64_t v9 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *a2;
    *(_DWORD *)sockaddr buf = 134217984;
    *(void *)&uint8_t buf[4] = v10;
    _os_log_impl(&dword_228C70000, v9, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: Starting sync with session (%p).", buf, 0xCu);
  }
  uint64_t v11 = *a2;
  uint64_t v12 = *((void *)v3 + 18);
  uint64_t v52 = v12;
  if (v12) {
    id v13 = (id)(v12 + 8);
  }
  re::Session::setRoutingTable(v11, &v52);
  if (v52)
  {

    uint64_t v52 = 0;
  }
  uint64_t v14 = *a2;
  uint64_t v15 = (_DWORD *)((char *)*a2 + 1616);
  *(void *)sockaddr buf = v3;
  *(void *)&uint8_t buf[8] = re::NetworkSyncManager::sessionDataDidArrive;
  unint64_t v54 = 0;
  uint64_t v55 = re::Event<re::Session>::createSubscription<re::NetworkSyncManager>(re::NetworkSyncManager *,REEventHandlerResult (re::NetworkSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke;
  re::Event<re::Session>::addSubscription(v15, (uint64_t)buf);
  *(void *)sockaddr buf = v3;
  *(void *)&uint8_t buf[8] = re::NetworkSyncManager::sessionDidStop;
  unint64_t v54 = 0;
  uint64_t v55 = re::Event<re::Session,re::SessionError>::createSubscription<re::NetworkSyncManager>(re::NetworkSyncManager *,REEventHandlerResult (re::NetworkSyncManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke;
  re::Event<re::Session>::addSubscription((_DWORD *)v14 + 52, (uint64_t)buf);
  uint64_t v17 = (re *)re::NetworkFeatureFlags::enableSharedAppSpecialization(v16);
  int v18 = *a2;
  if (v17 && *((unsigned char *)v18 + 2219))
  {
    int v19 = re::globalAllocators(v17);
    int v20 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v19[2] + 32))(v19[2], 552, 8);
    bzero(v20, 0x228uLL);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)v20, 0);
    v20[3] = 0;
    v20[4] = 0;
    v20[5] = 0;
    *((_DWORD *)v20 + 12) = 0;
    unsigned char v20[12] = 0;
    *((_DWORD *)v20 + 26) = 0;
    *(_OWORD *)(v20 + 7) = 0u;
    *(_OWORD *)(v20 + 9) = 0u;
    *((_DWORD *)v20 + 22) = 0;
    v20[15] = 0;
    v20[16] = 0;
    v20[14] = 0;
    *((_DWORD *)v20 + 34) = 0;
    v20[23] = 0;
    *((_DWORD *)v20 + 48) = 0;
    *((_OWORD *)v20 + 9) = 0u;
    *((_OWORD *)v20 + 10) = 0u;
    *((_DWORD *)v20 + 44) = 0;
    v20[25] = 0;
    v20[26] = 0;
    *((_DWORD *)v20 + 56) = 0;
    v20[27] = 0;
    v20[34] = 0;
    *((_DWORD *)v20 + 70) = 0;
    *(_OWORD *)(v20 + 29) = 0u;
    *(_OWORD *)(v20 + 31) = 0u;
    *((_DWORD *)v20 + 66) = 0;
    v20[37] = 0;
    v20[38] = 0;
    *((_DWORD *)v20 + 78) = 0;
    v20[36] = 0;
    v20[45] = 0;
    *((_DWORD *)v20 + 92) = 0;
    *((_OWORD *)v20 + 20) = 0u;
    *((_OWORD *)v20 + 21) = 0u;
    *((_DWORD *)v20 + 88) = 0;
    *int v20 = &unk_26DD34E58;
    v20[47] = 0;
    v20[48] = 30;
    v20[49] = 0xFFFFFFFF00010000;
    *((unsigned char *)v20 + 400) = 0;
    *(_OWORD *)(v20 + 51) = 0u;
    *(_OWORD *)(v20 + 53) = 0u;
    *((_DWORD *)v20 + 110) = 500;
    *((unsigned char *)v20 + 448) = 0;
    v20[58] = 0;
    v20[59] = 0;
    *((_DWORD *)v20 + 120) = 0;
    v20[57] = 0;
    v20[68] = 0;
    *((_DWORD *)v20 + 134) = 0;
    *(_OWORD *)(v20 + 63) = 0u;
    *(_OWORD *)(v20 + 65) = 0u;
    *(_OWORD *)(v20 + 61) = 0u;
    *(_OWORD *)sockaddr buf = xmmword_228CDF5E0;
    unint64_t v54 = 0xFFFFFFFF00010000;
    uint64_t v22 = *a2;
    LOBYTE(v55) = *((unsigned char *)*a2 + 2216);
    uint64_t v56 = v22;
    uint64_t v23 = (char *)v22 + 8;
    uint64_t v24 = *((void *)v3 + 7);
    uint64_t v57 = v24;
    if (v24) {
      id v25 = (id)(v24 + 8);
    }
    uint64_t v26 = *((void *)v3 + 19);
    uint64_t v58 = v26;
    if (v26) {
      id v27 = (id)(v26 + 8);
    }
    uint64_t v59 = v3;
    int v28 = *a2;
    int v60 = *((_DWORD *)*a2 + 556);
    int v29 = *((_DWORD *)v28 + 557);
    if (v29)
    {
      LODWORD(v54) = v29;
      HIDWORD(v54) = v29;
    }
    re::SharedAppSyncManager::init((uint64_t)v20, (long long *)buf);
    uint64_t v51 = v20;
    int v30 = v20 + 1;
    uint64_t v31 = (*(uint64_t (**)(re *, void **))(*(void *)v3 + 96))(v3, &v51);
    if (v51)
    {

      uint64_t v51 = 0;
    }
    if (v58)
    {

      uint64_t v58 = 0;
    }
    if (v57)
    {

      uint64_t v57 = 0;
    }
    if (v56) {

    }
    int v32 = v20 + 1;
    goto LABEL_57;
  }
  *(_OWORD *)sockaddr buf = xmmword_228CDF5E0;
  unint64_t v54 = 0xFFFFFFFF00010000;
  LOBYTE(v55) = *((unsigned char *)v18 + 2216);
  uint64_t v56 = v18;
  char v40 = (char *)v18 + 8;
  uint64_t v41 = *((void *)v3 + 7);
  uint64_t v57 = v41;
  if (v41) {
    id v42 = (id)(v41 + 8);
  }
  uint64_t v43 = *((void *)v3 + 19);
  uint64_t v58 = v43;
  if (v43) {
    id v44 = (id)(v43 + 8);
  }
  uint64_t v59 = v3;
  uint64_t v45 = *a2;
  LOBYTE(v60) = *((unsigned char *)*a2 + 2223);
  int v61 = *((_DWORD *)v45 + 556);
  char v62 = *((unsigned char *)v45 + 2237);
  int v46 = *((_DWORD *)v45 + 557);
  if (v46)
  {
    LODWORD(v54) = v46;
    HIDWORD(v54) = v46;
  }
  re::make::shared::object<re::SyncObjectManager,re::SyncObjectManager::Config &>((re *)buf, &v50);
  uint64_t v49 = v50;
  if (v50) {
    id v47 = (id)(v50 + 8);
  }
  uint64_t v31 = (*(uint64_t (**)(re *, uint64_t *))(*(void *)v3 + 96))(v3, &v49);
  if (v49)
  {

    uint64_t v49 = 0;
  }
  if (v50) {

  }
  if (v58)
  {

    uint64_t v58 = 0;
  }
  if (v57)
  {

    uint64_t v57 = 0;
  }
  if (v56)
  {
    int v32 = (char *)v56 + 8;
LABEL_57:
  }
  return v31;
}

void re::NetworkSyncManager::createSessionAndStartSync(re *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = a1;
  long long v6 = *(_OWORD *)(a2 + 16);
  long long v18 = *(_OWORD *)a2;
  long long v19 = v6;
  uint64_t v7 = *(void *)(a2 + 32);
  uint64_t v20 = v7;
  if (v7) {
    a1 = (re *)(id)(v7 + 8);
  }
  long long v21 = *(_OWORD *)(a2 + 40);
  uint64_t v8 = *(void *)(a2 + 64);
  uint64_t v22 = *(void *)(a2 + 56);
  uint64_t v23 = v8;
  if (v8) {
    a1 = (re *)(id)(v8 + 8);
  }
  v24[0] = *(_OWORD *)(a2 + 72);
  *(_OWORD *)((char *)v24 + 12) = *(_OWORD *)(a2 + 84);
  uint64_t v9 = *(void *)(a2 + 104);
  uint64_t v25 = v9;
  if (v9) {
    a1 = (re *)(id)(v9 + 8);
  }
  uint64_t v10 = *(void *)(a2 + 112);
  uint64_t v26 = v10;
  if (v10) {
    a1 = (re *)(id)(v10 + 8);
  }
  int v27 = *(_DWORD *)(a2 + 120);
  uint64_t v11 = *((void *)v4 + 3);
  *(void *)&long long v18 = *((void *)v4 + 5);
  *(void *)&long long v19 = v11;
  re::make::shared::object<re::Session>(a1, &v17);
  BOOL v12 = re::Session::init(v17, &v18);
  if (v12)
  {
    uint64_t v15 = v17;
    if (v17) {
      id v13 = (id)(v17 + 8);
    }
    (*(void (**)(re *, uint64_t *))(*(void *)v4 + 88))(v4, &v15);
    if (v15)
    {

      uint64_t v15 = 0;
    }
    *a3 = v17;
  }
  else
  {
    uint64_t v14 = *re::networkLogObjects((re *)v12);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      _os_log_error_impl(&dword_228C70000, v14, OS_LOG_TYPE_ERROR, "Failed to init session with provided config.", buf, 2u);
    }
    *a3 = 0;
    if (v17) {
  }
    }
  if (v26)
  {

    uint64_t v26 = 0;
  }
  if (v25)
  {

    uint64_t v25 = 0;
  }
  if (v23)
  {

    uint64_t v23 = 0;
  }
  if (v20) {
}
  }

uint64_t re::NetworkSyncManager::startSync(uint64_t a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v4 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)*a2 + 64))();
  unint64_t v6 = *(void *)(a1 + 72);
  unint64_t v5 = *(void *)(a1 + 80);
  if (v5 >= v6)
  {
    unint64_t v7 = v5 + 1;
    if (v6 < v5 + 1)
    {
      if (*(void *)(a1 + 64))
      {
        unint64_t v8 = 2 * v6;
        if (!v6) {
          unint64_t v8 = 8;
        }
        if (v8 <= v7) {
          unint64_t v9 = v7;
        }
        else {
          unint64_t v9 = v8;
        }
        re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity((void *)(a1 + 64), v9);
      }
      else
      {
        re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity((void *)(a1 + 64), v7);
        ++*(_DWORD *)(a1 + 88);
      }
    }
    unint64_t v5 = *(void *)(a1 + 80);
  }
  uint64_t v10 = *a2;
  *(void *)(*(void *)(a1 + 96) + 8 * v5) = *a2;
  if (v10)
  {
    id v11 = (id)(v10 + 8);
    unint64_t v5 = *(void *)(a1 + 80);
  }
  *(void *)(a1 + 80) = v5 + 1;
  ++*(_DWORD *)(a1 + 88);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 32))(&v19);
  re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::raise(a1 + 160, a1);
  if (v19)
  {

    uint64_t v19 = 0;
  }
  id v13 = *re::networkLogObjects(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 32))(&v18);
    uint64_t v14 = v18;
    (*(void (**)(re::Session **__return_ptr))(*(void *)*a2 + 32))(&v17);
    uint64_t v15 = re::Session::peerID(v17);
    *(_DWORD *)sockaddr buf = 134218240;
    uint64_t v21 = v14;
    __int16 v22 = 2048;
    uint64_t v23 = v15;
    _os_log_impl(&dword_228C70000, v13, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: Added new session: %p (peerID=%llu)", buf, 0x16u);
    if (v17) {

    }
    if (v18) {
  }
    }
  return 1;
}

void re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::raise(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      uint64_t v7 = 0;
      for (unint64_t i = 0; i != v6; ++i)
      {
        unint64_t v9 = *(void *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v15 = 136315906;
          uint64_t v16 = "operator[]";
          __int16 v17 = 1024;
          int v18 = 789;
          __int16 v19 = 2048;
          unint64_t v20 = i;
          __int16 v21 = 2048;
          unint64_t v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = *(void *)(a1 + 72) + v7;
        uint64_t v11 = *(void *)(v10 + 32);
        long long v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        uint64_t v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (LOBYTE(v23[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a1, *((unint64_t *)&v23[0] + 1));
          }
        }
        v7 += 40;
      }
    }
  }
}

void re::NetworkSyncManager::beforeFrameUpdate(re::RoutingTable **this)
{
  re::RoutingTable::update(this[18]);
  uint64_t v2 = this[7];
  if (v2) {
    re::SyncObjectTombstoneInfo::update((re::RoutingTable *)((char *)v2 + 552));
  }
  int v3 = this[10];
  if (v3)
  {
    uint64_t v4 = this[12];
    uint64_t v5 = 8 * (void)v3;
    do
    {
      (*(void (**)(uint64_t *__return_ptr))(**(void **)v4 + 32))(&v6);
      (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
      if (v6) {

      }
      uint64_t v4 = (re::RoutingTable *)((char *)v4 + 8);
      v5 -= 8;
    }
    while (v5);
  }
}

void re::NetworkSyncManager::afterFrameUpdate(re::NetworkSyncManager *this)
{
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 12);
    uint64_t v4 = 8 * v2;
    do
    {
      (*(void (**)(uint64_t *__return_ptr))(**(void **)v3 + 32))(&v5);
      (*(void (**)(uint64_t))(*(void *)v5 + 56))(v5);
      if (v5) {

      }
      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
  re::NetworkSyncManager::removeDeferredSessions(this);
}

uint64_t re::NetworkSyncManager::sessionDataDidArrive(re::NetworkSyncManager *this, re::Session *a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v3 = (re::NetworkSyncManager *)((char *)this + 336);
  int v4 = *((_DWORD *)this + 104);
  *((_DWORD *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = v4 + 1;
  if (*((void *)this + 44))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(re::NetworkSyncManager *))(*((void *)this + 46) + 32 * v5 + 24))(this) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v3, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *((void *)this + 44));
    int v4 = *((_DWORD *)this + 104) - 1;
  }
  *((_DWORD *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = v4;
  if (!v4)
  {
    uint64_t v6 = *((void *)this + 49);
    if (v6)
    {
      uint64_t v7 = 0;
      for (unint64_t i = 0; i != v6; ++i)
      {
        unint64_t v9 = *((void *)this + 49);
        if (v9 <= i)
        {
          memset(v24, 0, sizeof(v24));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v16 = 136315906;
          __int16 v17 = "operator[]";
          __int16 v18 = 1024;
          int v19 = 789;
          __int16 v20 = 2048;
          unint64_t v21 = i;
          __int16 v22 = 2048;
          unint64_t v23 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = *((void *)this + 51) + v7;
        uint64_t v11 = *(void *)(v10 + 32);
        long long v12 = *(_OWORD *)(v10 + 16);
        v14[0] = *(_OWORD *)v10;
        v14[1] = v12;
        uint64_t v15 = v11;
        if (LOBYTE(v14[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, (void *)v14 + 1, (uint64_t)v24);
          if (!LOBYTE(v24[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v3, (uint64_t)v14 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, (void *)v14 + 1, (uint64_t)v24);
          if (LOBYTE(v24[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v3, *((unint64_t *)&v24[0] + 1));
          }
        }
        v7 += 40;
      }
    }
  }
  return 0;
}

uint64_t re::NetworkSyncManager::sessionDidStop(re *a1, re::Session *a2, int a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v6 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 134218240;
    unint64_t v9 = a2;
    __int16 v10 = 1024;
    int v11 = a3;
    _os_log_impl(&dword_228C70000, v6, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: session stopped (%p) with error: %d.", (uint8_t *)&v8, 0x12u);
  }
  re::NetworkSyncManager::removeSessionDeferred(a1, a2);
  return 1;
}

void re::NetworkSyncManager::removeSessionDeferred(re::NetworkSyncManager *this, re::Session *a2)
{
  uint64_t v3 = this;
  uint64_t v15 = *MEMORY[0x263EF8340];
  int v4 = (re::Session **)*((void *)this + 17);
  unint64_t v5 = *((void *)this + 15);
  uint64_t v6 = v4;
  if (v5)
  {
    uint64_t v7 = 8 * v5;
    uint64_t v6 = (re::Session **)*((void *)this + 17);
    while (*v6 != a2)
    {
      ++v6;
      v7 -= 8;
      if (!v7)
      {
        uint64_t v6 = &v4[v5];
        break;
      }
    }
  }
  if (v5 == v6 - v4)
  {
    unint64_t v8 = *((void *)this + 14);
    if (v5 >= v8)
    {
      unint64_t v9 = v5 + 1;
      if (v8 < v5 + 1)
      {
        if (*((void *)this + 13))
        {
          unint64_t v10 = 2 * v8;
          if (!v8) {
            unint64_t v10 = 8;
          }
          if (v10 <= v9) {
            unint64_t v11 = v9;
          }
          else {
            unint64_t v11 = v10;
          }
          this = (re::NetworkSyncManager *)re::DynamicArray<re::Allocator const*>::setCapacity((void *)this + 13, v11);
        }
        else
        {
          this = (re::NetworkSyncManager *)re::DynamicArray<re::Allocator const*>::setCapacity((void *)v3 + 13, v9);
          ++*((_DWORD *)v3 + 32);
        }
      }
      unint64_t v5 = *((void *)v3 + 15);
      int v4 = (re::Session **)*((void *)v3 + 17);
    }
    v4[v5] = a2;
    *((void *)v3 + 15) = v5 + 1;
    ++*((_DWORD *)v3 + 32);
    uint64_t v12 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 134217984;
      uint64_t v14 = a2;
      _os_log_impl(&dword_228C70000, v12, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: session scheduled (%p) for removal.", (uint8_t *)&v13, 0xCu);
    }
  }
}

void re::NetworkSyncManager::requestOwnership(re *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v6 = *a2;
  if (!*a2)
  {
    uint64_t v14 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)sockaddr buf = 0;
    uint64_t v15 = "Requesting ownership for invalid object. Request is ignored.";
    int v16 = v14;
    uint32_t v17 = 2;
LABEL_28:
    _os_log_impl(&dword_228C70000, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
    return;
  }
  uint64_t v12 = *(void *)(v6 + 80);
  if (v12)
  {
    do
    {
      uint64_t v13 = v6;
      uint64_t v6 = v12;
      if (*(unsigned char *)(*(void *)(*(void *)(v13 + 88) + 16) + 73)) {
        break;
      }
      uint64_t v12 = *(void *)(v12 + 80);
      uint64_t v13 = v6;
    }
    while (v12);
  }
  else
  {
    uint64_t v13 = *a2;
  }
  if (!*(void *)(v13 + 160))
  {
    int v28 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v29 = *(void *)(*a2 + 24);
    *(_DWORD *)sockaddr buf = 134217984;
    *(void *)&uint8_t buf[4] = v29;
    uint64_t v15 = "Requesting ownership for already owned object '%llu'. Request is ignored.";
    int v16 = v28;
    uint32_t v17 = 12;
    goto LABEL_28;
  }
  uint64_t v18 = *((void *)a1 + 10);
  if (v18)
  {
    int v19 = (uint64_t *)*((void *)a1 + 12);
    __int16 v20 = &v19[v18];
    do
    {
      (*(void (**)(unsigned char *__return_ptr))(*(void *)*v19 + 32))(buf);
      uint64_t v21 = *a2;
      uint64_t v22 = *(void *)(*a2 + 80);
      if (v22)
      {
        do
        {
          uint64_t v23 = v21;
          uint64_t v21 = v22;
          if (*(unsigned char *)(*(void *)(*(void *)(v23 + 88) + 16) + 73)) {
            break;
          }
          uint64_t v22 = *(void *)(v22 + 80);
          uint64_t v23 = v21;
        }
        while (v22);
      }
      else
      {
        uint64_t v23 = *a2;
      }
      int hasPeerID = re::Session::hasPeerID(*(re::Session **)buf, *(void *)(v23 + 160));
      if (*(void *)buf) {

      }
      if (hasPeerID)
      {
        uint64_t v25 = *v19;
        uint64_t v26 = *a2;
        uint64_t v30 = v26;
        if (v26) {
          id v27 = (id)(v26 + 8);
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, double))(*(void *)v25 + 104))(v25, &v30, a3, a4, a5, a6);
        if (v30)
        {

          uint64_t v30 = 0;
        }
      }
      ++v19;
    }
    while (v19 != v20);
  }
}

double re::NetworkSyncManager::adjustTimeForSender(re::NetworkSyncManager *this, double a2, uint64_t a3)
{
  uint64_t v4 = *((void *)this + 10);
  if (v4)
  {
    uint64_t v6 = (void *)*((void *)this + 12);
    uint64_t v7 = 8 * v4;
    while (1)
    {
      (*(void (**)(re::Session **__return_ptr))(*(void *)*v6 + 32))(&v10);
      int hasPeerID = re::Session::hasPeerID(v10, a3);
      if (v10) {

      }
      if (hasPeerID) {
        break;
      }
      ++v6;
      v7 -= 8;
      if (!v7) {
        return a2;
      }
    }
    return (*(double (**)(void, uint64_t, double))(*(void *)*v6 + 112))(*v6, a3, a2);
  }
  return a2;
}

void re::NetworkSyncManager::removeSession(re::NetworkSyncManager *this, re::Session *a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 12);
  uint64_t v5 = *((void *)this + 10);
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    uint64_t v7 = v4 + 8 * v5;
    while (1)
    {
      (*(void (**)(uint8_t *__return_ptr))(**(void **)v4 + 32))(buf);
      unint64_t v8 = *(re::Session **)buf;
      if (*(void *)buf) {

      }
      if (v8 == a2) {
        break;
      }
      v4 += 8;
      v6 -= 8;
      if (!v6)
      {
        uint64_t v4 = v7;
        break;
      }
    }
    uint64_t v9 = v4;
    uint64_t v4 = *((void *)this + 12);
    uint64_t v5 = *((void *)this + 10);
  }
  else
  {
    uint64_t v9 = *((void *)this + 12);
  }
  if (v9 != v4 + 8 * v5)
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)v9 + 32))(&v29);
    re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::raise((uint64_t)this + 248, (uint64_t)this);
    if (v29)
    {

      uint64_t v29 = 0;
    }
    if (*((unsigned char *)a2 + 2272))
    {
      if (*((void *)a2 + 204))
      {
        unint64_t v11 = 0;
        do
        {
          uint64_t v12 = (_OWORD *)(*((void *)a2 + 206) + 32 * v11);
          if (*(re::NetworkSyncManager **)v12 == this)
          {
            if (!*((_DWORD *)a2 + 424))
            {
              unint64_t v10 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a2 + 202, v11);
              continue;
            }
            buf[0] = 0;
            long long v13 = v12[1];
            *(_OWORD *)&uint8_t buf[8] = *v12;
            *(_OWORD *)&unsigned char buf[24] = v13;
            re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((re::Session *)((char *)a2 + 1656), (uint64_t)buf);
          }
          ++v11;
        }
        while (v11 < *((void *)a2 + 204));
      }
      if (*((void *)a2 + 28))
      {
        unint64_t v14 = 0;
        do
        {
          uint64_t v15 = (_OWORD *)(*((void *)a2 + 30) + 32 * v14);
          if (*(re::NetworkSyncManager **)v15 == this)
          {
            if (!*((_DWORD *)a2 + 72))
            {
              unint64_t v10 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)a2 + 26, v14);
              continue;
            }
            buf[0] = 0;
            long long v16 = v15[1];
            *(_OWORD *)&uint8_t buf[8] = *v15;
            *(_OWORD *)&unsigned char buf[24] = v16;
            re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((re::Session *)((char *)a2 + 248), (uint64_t)buf);
          }
          ++v14;
        }
        while (v14 < *((void *)a2 + 28));
      }
    }
    uint64_t v17 = *((void *)this + 12);
    unint64_t v18 = (v9 - v17) >> 3;
    int v19 = (re::Session *)*((void *)this + 10);
    if ((unint64_t)v19 <= v18)
    {
      uint64_t v30 = 0;
      long long v40 = 0u;
      long long v41 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v31 = 136315906;
      uint64_t v32 = "removeAt";
      __int16 v33 = 1024;
      int v34 = 931;
      __int16 v35 = 2048;
      __int16 v36 = (re::Session *)v18;
      __int16 v37 = 2048;
      id v38 = v19;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_51;
    }
    uint64_t v20 = (uint64_t)v19 - 1;
    if ((unint64_t)v19 - 1 > v18)
    {
      uint64_t v21 = *(void *)(v17 + 8 * v18);
      uint64_t v22 = v17 + 8 * (void)v19;
      *(void *)(v17 + 8 * v18) = *(void *)(v22 - 8);
      *(void *)(v22 - 8) = v21;
      uint64_t v17 = *((void *)this + 12);
    }
    uint64_t v23 = v17 + 8 * (void)v19;
    uint64_t v24 = *(void *)(v23 - 8);
    if (v24)
    {

      *(void *)(v23 - 8) = 0;
      uint64_t v20 = *((void *)this + 10) - 1;
    }
    *((void *)this + 10) = v20;
    ++*((_DWORD *)this + 22);
    uint64_t v25 = *re::networkLogObjects(v10);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)sockaddr buf = 134217984;
      *(void *)&uint8_t buf[4] = a2;
      _os_log_impl(&dword_228C70000, v25, OS_LOG_TYPE_DEFAULT, "NetworkSyncManager: session removed (%p).", buf, 0xCu);
    }
  }
  uint64_t v26 = (re::Session **)*((void *)this + 17);
  int v19 = (re::Session *)*((void *)this + 15);
  id v27 = v26;
  if (v19)
  {
    uint64_t v28 = 8 * (void)v19;
    id v27 = (re::Session **)*((void *)this + 17);
    while (*v27 != a2)
    {
      ++v27;
      v28 -= 8;
      if (!v28)
      {
        id v27 = &v26[(void)v19];
        break;
      }
    }
  }
  a2 = (re::Session *)(v27 - v26);
  if (a2 != v19)
  {
    if (v19 > a2)
    {
      if ((re::Session *)((char *)v19 - 1) > a2) {
        v26[(void)a2] = v26[(void)v19 - 1];
      }
      *((void *)this + 15) = (char *)v19 - 1;
      ++*((_DWORD *)this + 32);
      return;
    }
LABEL_51:
    uint64_t v30 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v31 = 136315906;
    uint64_t v32 = "removeAt";
    __int16 v33 = 1024;
    int v34 = 931;
    __int16 v35 = 2048;
    __int16 v36 = a2;
    __int16 v37 = 2048;
    id v38 = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::NetworkSyncManager::stopSyncWithSession(re::NetworkSyncManager *a1, re::Session **a2)
{
  uint64_t v2 = *a2;
  if (v2)
  {
    re::NetworkSyncManager::removeSessionDeferred(a1, v2);
  }
  else
  {
    uint64_t v3 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_error_impl(&dword_228C70000, v3, OS_LOG_TYPE_ERROR, "Invalid session object passed to stopSyncWithSession", v4, 2u);
    }
  }
}

void re::NetworkSyncManager::stopSync(re::NetworkSyncManager *this)
{
  uint64_t v1 = *((void *)this + 10);
  if (v1)
  {
    uint64_t v3 = *((void *)this + 12);
    uint64_t v4 = 8 * v1;
    do
    {
      (*(void (**)(re::Session **__return_ptr))(**(void **)v3 + 32))(&v5);
      re::NetworkSyncManager::removeSessionDeferred(this, v5);
      if (v5) {

      }
      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
}

uint64_t re::NetworkSyncManager::sessions(re::NetworkSyncManager *this)
{
  return *((void *)this + 12);
}

uint64_t re::NetworkSyncManager::didAddSession(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 160;
}

uint64_t re::NetworkSyncManager::willRemoveSession(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 248;
}

uint64_t re::NetworkSyncManager::didReceiveOwnershipRequest(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 512;
}

uint64_t re::NetworkSyncManager::didReceiveOwnershipResponse(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 600;
}

uint64_t re::NetworkSyncManager::didReceiveOwnershipHandoff(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 688;
}

uint64_t re::NetworkSyncManager::didReceiveOwnershipChange(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 776;
}

uint64_t re::NetworkSyncManager::transferReportSendEvent(re::NetworkSyncManager *this)
{
  return (uint64_t)this + 424;
}

uint64_t re::NetworkSyncManager::localPeerID(re::NetworkSyncManager *this)
{
  uint64_t v1 = *((void *)this + 18);
  if (v1) {
    return *(void *)(v1 + 24);
  }
  else {
    return 0;
  }
}

unint64_t *re::NetworkSyncManager::getRoute@<X0>(re::NetworkSyncManager *this@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  double result = (unint64_t *)*((void *)this + 18);
  if (result) {
    return re::RoutingTable::getRoute((re::RoutingTable *)result, a2, (uint64_t)a3);
  }
  *a3 = 0;
  return result;
}

uint64_t re::NetworkSyncManager::store(re::NetworkSyncManager *this)
{
  return *((void *)this + 7);
}

uint64_t re::NetworkSyncManager::viewManager(re::NetworkSyncManager *this)
{
  return *((void *)this + 19);
}

uint64_t re::make::shared::object<re::SyncObjectManager,re::SyncObjectManager::Config &>@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4 = re::globalAllocators(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 664, 8);
  uint64_t result = re::SyncObjectManager::SyncObjectManager(v5, (long long *)a1);
  *a2 = result;
  return result;
}

uint64_t re::Event<re::Session>::createSubscription<re::NetworkSyncManager>(re::NetworkSyncManager *,REEventHandlerResult (re::NetworkSyncManager::*)(re::Session*))::{lambda(re::Session*,re::Event<re::Session>::Subscription const&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

uint64_t re::Event<re::Session,re::SessionError>::createSubscription<re::NetworkSyncManager>(re::NetworkSyncManager *,REEventHandlerResult (re::NetworkSyncManager::*)(re::Session*,re::SessionError))::{lambda(re::Session*,re::Event<re::Session,re::SessionError>::Subscription const&,re::SessionError&&)#1}::__invoke(uint64_t a1, void *a2, unsigned int *a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

uint64_t re::SyncAckedStateBuffer::addAcked(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v7 = a1 + 24;
  uint64_t result = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::tryGet(a1 + 24, a2);
  if (result)
  {
    unsigned int v9 = *(unsigned __int16 *)(result + 8);
    if (v9 <= a4 && a4 - v9 < 0x8000 || v9 > a4 && v9 - a4 >= 0x8000)
    {
      *(void *)uint64_t result = a3;
      *(_WORD *)(result + 8) = a4;
    }
  }
  else
  {
    *(void *)&long long v10 = a3;
    WORD4(v10) = a4;
    return re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v7, a2, &v10);
  }
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(v6 + 40 * v4 + 16) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 40 * v4 + 8) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v6 + 40 * v4 + 16) == v2) {
        return v6 + 40 * v4 + 24;
      }
    }
    return 0;
  }
  return v6 + 40 * v4 + 24;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(uint64_t a1, uint64_t *a2, _OWORD *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 40 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 40 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 40 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 40 * v10;
  return v12 + 24;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (*(void *)(v9 + 40 * v7 + 16) != v3)
  {
    while (1)
    {
      unsigned int v10 = v7;
      int v11 = *(_DWORD *)(v9 + 40 * v7 + 8);
      uint64_t v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        return 0;
      }
      if (*(void *)(v9 + 40 * v7 + 16) == v3)
      {
        *(_DWORD *)(v9 + 40 * v10 + 8) = *(_DWORD *)(v9 + 40 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 40 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v13 = v12 + 40 * v7;
  int v16 = *(_DWORD *)(v13 + 8);
  unint64_t v14 = (int *)(v13 + 8);
  int v15 = v16;
  if (v16 < 0)
  {
    int *v14 = v15 & 0x7FFFFFFF;
    uint64_t v17 = v12 + 40 * v7;
    uint64_t v20 = *(void *)(v17 + 16);
    int v19 = (void *)(v17 + 16);
    uint64_t v18 = v20;
    if (v20)
    {

      *int v19 = 0;
    }
  }
  uint64_t v21 = *(void *)(a1 + 16) + 40 * v7;
  int v22 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = v22 + 1;
  return 1;
}

uint64_t *re::SyncAckedStateBuffer::getLatestAckedState(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (uint64_t *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::tryGet(a1 + 24, a2);
  if (result) {
    return (uint64_t *)re::SyncObject::getState((re::SyncObject *)*a2, *result);
  }
  return result;
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, _OWORD *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v30, 0, 36);
          *(void *)&v30[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v30, v13, v12);
          long long v15 = *(_OWORD *)v30;
          *(_OWORD *)uint64_t v30 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v30[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v30[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v30[24];
          *(_OWORD *)&v30[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v30[32];
          *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v19;
          unint64_t v20 = v18;
          if (v18)
          {
            unint64_t v21 = 0;
            uint64_t v22 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v22 - 8) & 0x80000000) != 0) {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncAckedStateBuffer::AckData,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(void *)(v22 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v22 - 16), v22, v22 + 8);
              }
              ++v21;
              v22 += 40;
            }
            while (v21 < v20);
          }
          re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v30);
        }
      }
      else
      {
        if (v12) {
          signed int v25 = 2 * v11;
        }
        else {
          signed int v25 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 40 * v9 + 8);
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 40 * v9 + 8) = v24 | 0x80000000;
  uint64_t v26 = a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 40 * v9) = a3;
  uint64_t v27 = *a4;
  *(void *)(*(void *)(a1 + 16) + 40 * v9 + 16) = *a4;
  if (v27) {
    id v28 = (id)(v27 + 8);
  }
  *(_OWORD *)(*(void *)(a1 + 16) + 40 * v9 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v26) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::SyncObjectViewer::objectEnteredView(re *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void **)(a2 + 8);
  unint64_t v4 = (void *)v3[10];
  unint64_t v5 = v3;
  if (v4)
  {
    uint64_t v6 = *(void **)(a2 + 8);
    do
    {
      unint64_t v5 = v6;
      uint64_t v6 = v4;
      if (*(unsigned char *)(*(void *)(v5[11] + 16) + 73)) {
        break;
      }
      unint64_t v4 = (void *)v4[10];
      unint64_t v5 = v6;
    }
    while (v4);
  }
  if (*((unsigned char *)v5 + 170) && (uint64_t v7 = *re::networkLogObjects(a1), os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)))
  {
    uint64_t v14 = *((void *)a1 + 7);
    uint64_t v15 = *(void *)(v3[11] + 16);
    uint64_t v16 = *(void *)(v15 + 48);
    uint64_t v17 = *(void *)(v15 + 56);
    uint64_t v18 = v15 + 49;
    if (v16) {
      uint64_t v18 = v17;
    }
    uint64_t v19 = v3[3];
    *(_DWORD *)sockaddr buf = 134218498;
    *(void *)&uint8_t buf[4] = v14;
    __int16 v22 = 2080;
    uint64_t v23 = v18;
    __int16 v24 = 2048;
    uint64_t v25 = v19;
    _os_log_debug_impl(&dword_228C70000, v7, OS_LOG_TYPE_DEBUG, "Peer %llu became aware of %s Guid=%llu", buf, 0x20u);
    uint64_t v8 = (uint64_t)a1 + 64;
    *(void *)sockaddr buf = v3;
    BOOL v9 = v3 == 0;
  }
  else
  {
    uint64_t v8 = (uint64_t)a1 + 64;
    *(void *)sockaddr buf = v3;
    if (!v3)
    {
      int v20 = 0;
      signed int v12 = (_DWORD *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v8, (uint64_t *)buf, &v20);
      goto LABEL_13;
    }
    BOOL v9 = 0;
  }
  int v10 = v3 + 1;
  int v11 = v3 + 1;
  int v20 = 0;
  signed int v12 = (_DWORD *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v8, (uint64_t *)buf, &v20);
  if (!v9)
  {

    if (*v12)
    {
      id v13 = v10;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v8, (unint64_t)v3);
    }
    return;
  }
LABEL_13:
  if (*v12) {
    re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v8, (unint64_t)v3);
  }
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 32 * v10;
  return v12 + 24;
}

void re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(uint64_t a1, unint64_t a2)
{
  if (*(void *)a1)
  {
    unint64_t v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    unint64_t v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24);
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(unsigned int *)(v5 + 4 * v4);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a1 + 16);
      uint64_t v8 = v7 + 32 * v6;
      if (*(void *)(v8 + 16) == a2)
      {
        *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v8 + 8) & 0x7FFFFFFF;
LABEL_8:
        uint64_t v12 = *(void *)(a1 + 16) + 32 * v6;
        int v13 = *(_DWORD *)(v12 + 8);
        if (v13 < 0)
        {
          *(_DWORD *)(v12 + 8) = v13 & 0x7FFFFFFF;
          uint64_t v16 = *(void *)(v12 + 16);
          uint64_t v15 = (void *)(v12 + 16);
          uint64_t v14 = v16;
          if (v16)
          {

            void *v15 = 0;
          }
        }
        int v17 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(*(void *)(a1 + 16) + 32 * v6 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v6 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v6;
        *(_DWORD *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = v17 + 1;
      }
      else
      {
        while (1)
        {
          unsigned int v9 = v6;
          int v10 = *(_DWORD *)(v7 + 32 * v6 + 8);
          uint64_t v6 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF) {
            break;
          }
          uint64_t v11 = v7 + 32 * v6;
          if (*(void *)(v11 + 16) == a2)
          {
            *(_DWORD *)(v7 + 32 * v9 + 8) = *(_DWORD *)(v7 + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

void re::SyncObjectViewer::objectExitedView(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  unint64_t v3 = *(void **)(a2 + 8);
  unint64_t v4 = v3 + 1;
  uint64_t v5 = (re *)[v3 + 1 retainCount];
  if ((int)v5 <= 0)
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "object->retainCount() > 0", "objectExitedView", 38);
    _os_crash();
    __break(1u);
  }
  uint64_t v7 = (void *)v3[10];
  uint64_t v8 = v3;
  if (v7)
  {
    unsigned int v9 = v3;
    do
    {
      uint64_t v8 = v9;
      unsigned int v9 = v7;
      if (*(unsigned char *)(*(void *)(v8[11] + 16) + 73)) {
        break;
      }
      uint64_t v7 = (void *)v7[10];
      uint64_t v8 = v9;
    }
    while (v7);
  }
  if (*((unsigned char *)v8 + 170)
    && (int v10 = *re::networkLogObjects(v5), os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)))
  {
    uint64_t v16 = *(void *)(a1 + 56);
    uint64_t v17 = *(void *)(v3[11] + 16);
    uint64_t v18 = *(void *)(v17 + 48);
    uint64_t v19 = *(void *)(v17 + 56);
    uint64_t v20 = v17 + 49;
    if (v18) {
      uint64_t v20 = v19;
    }
    uint64_t v21 = v3[3];
    *(_DWORD *)sockaddr buf = 134218498;
    *(void *)&uint8_t buf[4] = v16;
    __int16 v24 = 2080;
    uint64_t v25 = v20;
    __int16 v26 = 2048;
    uint64_t v27 = v21;
    _os_log_debug_impl(&dword_228C70000, v10, OS_LOG_TYPE_DEBUG, "Peer %llu lost awareness of %s Guid=%llu", buf, 0x20u);
    uint64_t v11 = a1 + 64;
    *(void *)sockaddr buf = v3;
    BOOL v12 = v3 == 0;
  }
  else
  {
    uint64_t v11 = a1 + 64;
    *(void *)sockaddr buf = v3;
    if (!v3)
    {
      int v22 = 1;
      uint64_t v14 = (_DWORD *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v11, (uint64_t *)buf, &v22);
      goto LABEL_14;
    }
    BOOL v12 = 0;
  }
  id v13 = v4;
  int v22 = 1;
  uint64_t v14 = (_DWORD *)re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::add(v11, (uint64_t *)buf, &v22);
  if (!v12)
  {

    if (*v14 != 1)
    {
      id v15 = v4;
      re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v11, (unint64_t)v3);
    }
    return;
  }
LABEL_14:
  if (*v14 != 1) {
    re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::remove(v11, (unint64_t)v3);
  }
}

void re::SyncObjectViewer::~SyncObjectViewer(re::SyncObjectViewer *this)
{
  *(void *)this = &unk_26DD36158;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 8);
  re::SyncViewer::~SyncViewer((re::SyncView ***)this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD36158;
  re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)this + 8);
  re::SyncViewer::~SyncViewer((re::SyncView ***)this);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, _DWORD *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v31, 0, 36);
          *(void *)&v31[36] = 0x7FFFFFFFLL;
          re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::init((uint64_t)v31, v13, v12);
          long long v15 = *(_OWORD *)v31;
          *(_OWORD *)int v31 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v31[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v31[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v31[24];
          *(_OWORD *)&v31[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v31[32];
          *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v19;
          unint64_t v20 = v18;
          if (v18)
          {
            unint64_t v21 = 0;
            uint64_t v22 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v22 - 8) & 0x80000000) != 0) {
                re::HashTable<re::SharedPtr<re::SyncObject>,re::SyncObjectViewer::Op,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addAsMove(a1, *(void *)(v22 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v22 - 16), v22, v22 + 8);
              }
              ++v21;
              v22 += 32;
            }
            while (v21 < v20);
          }
          re::HashTable<re::SharedPtr<re::SyncObject>,re::internal::SyncSnapshotEvents,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::deinit((uint64_t *)v31);
        }
      }
      else
      {
        if (v12) {
          signed int v25 = 2 * v11;
        }
        else {
          signed int v25 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 32 * v9 + 8) = v24 | 0x80000000;
  uint64_t v26 = a2;
  uint64_t v27 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v27 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  uint64_t v28 = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  if (v28)
  {
    id v29 = (id)(v28 + 8);
    uint64_t v27 = *(void *)(a1 + 8);
  }
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *a5;
  *(_DWORD *)(v27 + 4 * v26) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t RESyncWriteContextDataWriter(void *a1)
{
  *(unsigned char *)(*a1 + 16) |= 8u;
  return a1[1];
}

void *RESyncWriteContextMarkDestroyed(void *result)
{
  *(unsigned char *)(*result + 16) |= 2u;
  *(unsigned char *)(*(void *)*result + 128) |= 4u;
  uint64_t v1 = result[1];
  *(_WORD *)(v1 + 84) = 0;
  *(void *)(v1 + 88) = 0;
  ++*(_DWORD *)(v1 + 80);
  return result;
}

uint64_t re::SyncPacker::packCommit(void *a1, unsigned __int8 *a2, re::BitWriter *this, uint64_t a4, unint64_t a5)
{
  uint64_t v170 = *MEMORY[0x263EF8340];
  if ((*(unsigned char *)(a4 + 32) & 0x20) != 0)
  {
    uint64_t v6 = a4;
    re::BitWriter::alignToByte(this);
    long long v15 = (_anonymous_namespace_ *)re::BitWriter::bytesLeft(this, v14);
    LODWORD(v16) = *((_DWORD *)this + 6);
    if (*((_DWORD *)this + 7)) {
      uint64_t v16 = (v16 + 1);
    }
    else {
      uint64_t v16 = v16;
    }
    id v142 = this;
    int v143 = v16;
    int v144 = 0;
    *(void *)uint64_t v156 = *((void *)this + 1) + v16;
    *(_DWORD *)&v156[8] = 0;
    *(_DWORD *)int v157 = v15;
    *(void *)&v157[4] = &v142;
    uint64_t v158 = re::SyncPacker::packCommit(re::SyncCommit const&,re::BitWriter &,re::SyncObjectWriteContext const&,unsigned long)::$_0::__invoke;
    unint64_t v160 = 0;
    uint64_t v161 = 0;
    uint64_t v162 = 0;
    re::DynamicString::setCapacity(&v159, 0);
    int v163 = 6;
    uint64_t v164 = 0;
    int v144 = v156;
    if (*((void *)a2 + 6) < 0xFFFFFFFFuLL)
    {
      int v5 = *(_DWORD *)&v156[8];
      re::snapshot::EncoderOPACK::beginObject((unsigned int *)v156);
      re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>((re::snapshot::EncoderOPACK *)v156, a2);
      if ((*a2 & 2) != 0) {
        re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned long long>((re::snapshot::EncoderOPACK *)v156, (uint64_t *)a2 + 2);
      }
      re::snapshot::EncoderOPACK::endObject((unsigned int *)v156);
      re::snapshot::EncoderOPACK::beginObject((unsigned int *)v156);
      uint64_t v18 = *(unsigned int *)&v156[8];
      if (*(_DWORD *)&v156[8] < *(_DWORD *)v157)
      {
LABEL_14:
        if (*((void *)a2 + 6) <= a5)
        {
          uint64_t v19 = 0;
          unsigned int v136 = 0;
          goto LABEL_170;
        }
        unsigned int v136 = 0;
        uint64_t v19 = 0;
        while (1)
        {
          uint64_t v20 = *((void *)a2 + 8);
          unint64_t v21 = (uint64_t *)(v20 + 24 * a5);
          uint64_t v22 = *v21;
          uint64_t v23 = *(void *)(*(void *)(*v21 + 88) + 16);
          uint64_t v24 = *(void *)(v23 + 128);
          if (v24)
          {
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(v24 + 16))(v24, v6))
            {
              ++v136;
              goto LABEL_82;
            }
            uint64_t v22 = *v21;
            uint64_t v23 = *(void *)(*(void *)(*v21 + 88) + 16);
          }
          int v25 = *(_DWORD *)&v156[8];
          unsigned int v26 = (*(uint64_t (**)(void, void, void))(*(void *)*a1 + 32))(*a1, *(void *)(v22 + 24), *(void *)(v23 + 32));
          re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v156, v26);
          uint64_t v27 = a1[1];
          int v138 = v25;
          if (!v27
            || ((uint64_t v28 = *(void *)(*(void *)(v22 + 88) + 16),
                 uint64_t v29 = *(void *)(v28 + 104),
                 uint64_t v30 = *(void *)(v28 + 120),
                 v29)
              ? (BOOL v31 = v30 == 0)
              : (BOOL v31 = 1),
                v31 || (*(unsigned char *)(v20 + 24 * a5 + 16) & 1) != 0))
          {
            unsigned __int16 v34 = 0;
            LatestAckedState = 0;
          }
          else
          {
            LatestAckedState = re::SyncAckedStateBuffer::getLatestAckedState(v27, (uint64_t *)(v20 + 24 * a5));
            unsigned __int16 v34 = v33;
          }
          unsigned __int8 v35 = LatestAckedState == 0;
          unsigned __int8 v145 = LatestAckedState == 0;
          if ((*(unsigned char *)(v20 + 24 * a5 + 16) & 2) != 0)
          {
            v35 |= 4u;
            unsigned __int8 v145 = v35;
          }
          __int16 v36 = *(void **)(v22 + 80);
          __int16 v37 = (void *)v22;
          if (v36)
          {
            id v38 = (void *)v22;
            do
            {
              __int16 v37 = v38;
              id v38 = v36;
              if (*(unsigned char *)(*(void *)(v37[11] + 16) + 73)) {
                break;
              }
              __int16 v36 = (void *)v36[10];
              __int16 v37 = v38;
            }
            while (v36);
          }
          if (!v37[20] && v37[17]) {
            unsigned __int8 v145 = v35 | 0x10;
          }
          re::snapshot::EncoderOPACK::beginObject((unsigned int *)v156);
          re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,unsigned char>((re::snapshot::EncoderOPACK *)v156, &v145);
          *(_WORD *)sockaddr buf = *(_WORD *)(v22 + 176);
          re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<2,unsigned short>((re::snapshot::EncoderOPACK *)v156, (unsigned __int16 *)buf);
          uint64_t v39 = *(void *)(v22 + 80);
          uint64_t v40 = v22;
          if (v39)
          {
            uint64_t v41 = v22;
            do
            {
              uint64_t v40 = v41;
              uint64_t v41 = v39;
              if (*(unsigned char *)(*(void *)(*(void *)(v40 + 88) + 16) + 73)) {
                break;
              }
              uint64_t v39 = *(void *)(v39 + 80);
              uint64_t v40 = v41;
            }
            while (v39);
          }
          re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<3,re::SyncOwnershipInfo>((re::snapshot::EncoderOPACK *)v156, v40 + 136);
          if ((v145 & 5) != 0)
          {
            uint64_t v42 = *(void *)(v22 + 24);
            uint64_t v43 = *(unsigned int *)&v156[8];
            if (*(_DWORD *)&v156[8] >= *(_DWORD *)v157)
            {
              re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v156, 5);
            }
            else
            {
              ++*(_DWORD *)&v156[8];
              *(unsigned char *)(*(void *)v156 + v43) = 13;
            }
            re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v156, v42);
            *(void *)sockaddr buf = *(void *)(*(void *)(*(void *)(v22 + 88) + 16) + 32);
            re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<6,unsigned long long>((re::snapshot::EncoderOPACK *)v156, (uint64_t *)buf);
          }
          if (LatestAckedState)
          {
            uint64_t v44 = *(unsigned int *)&v156[8];
            if (*(_DWORD *)&v156[8] >= *(_DWORD *)v157)
            {
              re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v156, 7);
            }
            else
            {
              ++*(_DWORD *)&v156[8];
              *(unsigned char *)(*(void *)v156 + v44) = 15;
            }
            re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v156, v34);
          }
          if (v145)
          {
            uint64_t v45 = *(void *)(v22 + 80);
            if (v45)
            {
              int v46 = (void *)(v45 + 8);
              id v47 = (id)(v45 + 8);

              uint64_t v48 = *(void *)(v22 + 80);
              if (v48) {
                id v49 = (id)(v48 + 8);
              }
              *(void *)sockaddr buf = *(void *)(*(void *)(*(void *)(v48 + 88) + 16) + 32);
              re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<8,unsigned long long>((re::snapshot::EncoderOPACK *)v156, (uint64_t *)buf);

              uint64_t v50 = *(void *)(v22 + 80);
              if (v50) {
                id v51 = (id)(v50 + 8);
              }
              *(void *)sockaddr buf = *(void *)(v50 + 24);
              re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<9,unsigned long long>((re::snapshot::EncoderOPACK *)v156, (uint64_t *)buf);
            }
          }
          uint64_t v52 = *(unsigned int *)&v156[8];
          if (*(_DWORD *)&v156[8] >= *(_DWORD *)v157)
          {
            re::snapshot::EncoderOPACK::writeInteger((unsigned int *)v156, 11);
          }
          else
          {
            ++*(_DWORD *)&v156[8];
            *(unsigned char *)(*(void *)v156 + v52) = 19;
          }
          unint64_t LatestState = re::SyncObject::getLatestState((re::SyncObject *)v22);
          if (LatestState)
          {
            uint64_t v54 = *(void *)(*(void *)(v22 + 88) + 16);
            int v55 = *(_DWORD *)(LatestState + 24);
            if (*(_DWORD *)(LatestState + 28)) {
              ++v55;
            }
            uint64_t v146 = *(void *)(LatestState + 8);
            int v147 = v55;
            char v148 = 0;
            uint64_t v149 = 0;
            uint64_t v150 = 0;
            int v56 = *(_DWORD *)&v156[8];
            re::snapshot::EncoderOPACK::beginData((unsigned int *)v156, 0, 0xFFFFFFFFuLL);
            uint64_t v57 = *(unsigned int *)&v156[8];
            *(void *)&uint8_t buf[8] = *(void *)v156 + *(unsigned int *)&v156[8];
            *(_DWORD *)&uint8_t buf[16] = *(_DWORD *)v157 - *(_DWORD *)&v156[8];
            unsigned char buf[20] = 0;
            v166 = 0;
            uint64_t v167 = 0;
            *(void *)sockaddr buf = &unk_26DD361A8;
            uint64_t v168 = *(unsigned int *)&v156[8];
            long long v169 = v156;
            if (LatestAckedState)
            {
              int v58 = *((_DWORD *)LatestAckedState + 6);
              if (*((_DWORD *)LatestAckedState + 7)) {
                ++v58;
              }
              *(void *)long long v151 = LatestAckedState[1];
              int v152 = v58;
              char v153 = 0;
              uint64_t v154 = 0;
              uint64_t v155 = 0;
              uint64_t v6 = a4;
              (*(void (**)(void))(*(void *)(v54 + 120) + 16))();
            }
            else
            {
              uint64_t v6 = a4;
              (*(void (**)(void))(*(void *)(v54 + 112) + 16))();
            }
            re::BitWriter::alignToByte(buf);
            int v66 = v166 + v168;
            if (HIDWORD(v166)) {
              ++v66;
            }
            *((_DWORD *)v169 + 2) = v66;
            uint64_t v67 = *(unsigned int *)&v156[8];
            *(_DWORD *)&v156[8] = v56;
            re::snapshot::EncoderOPACK::beginData((unsigned int *)v156, v67 - v57, 0xFFFFFFFFuLL);
            *(_DWORD *)&v156[8] = v67;
          }
          else
          {
            uint64_t v59 = *re::networkLogObjects(0);
            uint64_t v6 = a4;
            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            {
              uint64_t v60 = *(void *)(v22 + 24);
              int v61 = *(void **)(*(void *)(v22 + 88) + 16);
              uint64_t v62 = v61[4];
              uint64_t v63 = v61[6];
              uint64_t v64 = (char *)v61[7];
              uint64_t v65 = (char *)v61 + 49;
              if (v63) {
                uint64_t v65 = v64;
              }
              *(_DWORD *)sockaddr buf = 134218498;
              *(void *)&uint8_t buf[4] = v60;
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v62;
              *(_WORD *)&unsigned char buf[22] = 2080;
              v166 = v65;
              _os_log_error_impl(&dword_228C70000, v59, OS_LOG_TYPE_ERROR, "Could not find latest state for object (id: %llu, type: %llu[%s]).", buf, 0x20u);
            }
          }
          uint64_t v68 = re::snapshot::EncoderOPACK::endObject((unsigned int *)v156);
          if (v160) {
            unint64_t v69 = v160 >> 1;
          }
          else {
            unint64_t v69 = v160 >> 1;
          }
          if (v69)
          {
            int v129 = *((unsigned __int8 *)a1 + 16);
            uint64_t v130 = *re::networkLogObjects((re *)v68);
            if (v129)
            {
              if (os_log_type_enabled(v130, OS_LOG_TYPE_DEBUG))
              {
                if (v160) {
                  int v131 = v161;
                }
                else {
                  int v131 = (char *)&v160 + 1;
                }
                *(_DWORD *)sockaddr buf = 136315138;
                *(void *)&uint8_t buf[4] = v131;
                _os_log_debug_impl(&dword_228C70000, v130, OS_LOG_TYPE_DEBUG, "Error writing OPACK object data: %s", buf, 0xCu);
              }
            }
            else if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
            {
              if (v160) {
                uint64_t v133 = v161;
              }
              else {
                uint64_t v133 = (char *)&v160 + 1;
              }
              *(_DWORD *)sockaddr buf = 136315138;
              *(void *)&uint8_t buf[4] = v133;
              _os_log_error_impl(&dword_228C70000, v130, OS_LOG_TYPE_ERROR, "Error writing OPACK object data: %s", buf, 0xCu);
            }
LABEL_169:
            *(_DWORD *)&v156[8] = v138;
LABEL_170:
            re::snapshot::EncoderOPACK::endObject((unsigned int *)v156);
            uint64_t v13 = v19 + v136;
            int v5 = *(_DWORD *)&v156[8];
LABEL_171:
            re::BitWriter::rollbackTo((uint64_t)this, (v5 + v143));
            if (v159 && (v160 & 1) != 0) {
              (*(void (**)(void))(*v159 + 40))();
            }
            return v13;
          }
          if (*(_DWORD *)&v156[8] >= *(_DWORD *)v157
            && !re::snapshot::Encoder::grow((re::snapshot::Encoder *)v156, *(unsigned int *)&v156[8] + 1))
          {
            goto LABEL_169;
          }
          ++v19;
          uint64_t v70 = *(void *)v6;
          if (*(void *)v6)
          {
            (*(void (**)(unsigned char *__return_ptr))(**(void **)(v6 + 8) + 32))(buf);
            if (*(void *)buf) {

            }
            uint64_t v71 = (*(uint64_t (**)(uint64_t))(*(void *)v70 + 80))(v70);
            uint64_t v6 = a4;
            re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::raise(v71, v70);
          }
LABEL_82:
          if (++a5 >= *((void *)a2 + 6)) {
            goto LABEL_170;
          }
        }
      }
LABEL_181:
      if ((re::snapshot::Encoder::grow((re::snapshot::Encoder *)v156, v18 + 1) & 1) == 0)
      {
        uint64_t v13 = 0;
        *(_DWORD *)&v156[8] = v5;
        goto LABEL_171;
      }
      goto LABEL_14;
    }
LABEL_180:
    re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) ", "commit.snapshot.size() < ~uint32_t()", "writeCommit", 123);
    _os_crash();
    __break(1u);
    goto LABEL_181;
  }
  if (*((void *)a2 + 6) >= 0xFFFFFFFFuLL)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "commit.snapshot.size() < ~uint32_t()", "writeCommit", 189);
    _os_crash();
    __break(1u);
    goto LABEL_180;
  }
  uint64_t v10 = *((void *)this + 3);
  re::BitWriter::writeUInt32Bits((uint64_t)this, *a2, 8u);
  if ((*a2 & 2) != 0)
  {
    unsigned int v11 = *((_DWORD *)a2 + 5);
    re::BitWriter::writeUInt32Bits((uint64_t)this, *((_DWORD *)a2 + 4), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, v11, 0x20u);
  }
  uint64_t v12 = *((void *)this + 3);
  re::BitWriter::writeUInt32Bits((uint64_t)this, 0, 0x20u);
  if (*((unsigned char *)this + 20))
  {
    re::BitWriter::rollbackTo((uint64_t)this, v10);
    return 0;
  }
  uint64_t v134 = v12;
  if (*((void *)a2 + 6) <= a5)
  {
    int v135 = 0;
    unsigned int v72 = 0;
    goto LABEL_167;
  }
  unsigned int v72 = 0;
  int v135 = 0;
  while (1)
  {
    uint64_t v73 = *((void *)a2 + 8);
    uint64_t v74 = (uint64_t *)(v73 + 24 * a5);
    uint64_t v75 = *v74;
    uint64_t v76 = *(void *)(*(void *)(*(void *)(*v74 + 88) + 16) + 128);
    if (!v76) {
      break;
    }
    if ((*(unsigned int (**)(uint64_t, uint64_t))(v76 + 16))(v76, a4))
    {
      uint64_t v75 = *v74;
      break;
    }
    ++v135;
LABEL_157:
    if (++a5 >= *((void *)a2 + 6)) {
      goto LABEL_167;
    }
  }
  uint64_t v77 = a1[1];
  unsigned int v139 = v72;
  uint64_t v137 = *((void *)this + 3);
  if (!v77
    || ((uint64_t v78 = *(void *)(*(void *)(v75 + 88) + 16), v79 = *(void *)(v78 + 104),
                                                          uint64_t v80 = *(void *)(v78 + 120),
                                                          v79)
      ? (BOOL v81 = v80 == 0)
      : (BOOL v81 = 1),
        v81 || (*(unsigned char *)(v73 + 24 * a5 + 16) & 1) != 0))
  {
    unsigned __int16 v84 = 0;
    int v82 = 0;
  }
  else
  {
    int v82 = re::SyncAckedStateBuffer::getLatestAckedState(v77, (uint64_t *)(v73 + 24 * a5));
    unsigned __int16 v84 = v83;
  }
  uint64_t v85 = *(void **)(v75 + 80);
  uint64_t v86 = (void *)v75;
  if (v85)
  {
    __int16 v87 = (void *)v75;
    do
    {
      uint64_t v86 = v87;
      __int16 v87 = v85;
      if (*(unsigned char *)(*(void *)(v86[11] + 16) + 73)) {
        break;
      }
      uint64_t v85 = (void *)v85[10];
      uint64_t v86 = v87;
    }
    while (v85);
  }
  unsigned int v88 = (v82 == 0) | (2 * *(unsigned char *)(v73 + 24 * a5 + 16)) & 5;
  if (!v86[20] && v86[17]) {
    v88 |= 0x10u;
  }
  re::BitWriter::alignToByte(this);
  re::BitWriter::writeUInt32Bits((uint64_t)this, v88, 8u);
  re::BitWriter::writeUInt32Bits((uint64_t)this, *(unsigned __int16 *)(v75 + 176), 0x10u);
  uint64_t v89 = *(void *)(v75 + 80);
  uint64_t v90 = v75;
  if (v89)
  {
    uint64_t v91 = v75;
    do
    {
      uint64_t v90 = v91;
      uint64_t v91 = v89;
      if (*(unsigned char *)(*(void *)(*(void *)(v90 + 88) + 16) + 73)) {
        break;
      }
      uint64_t v89 = *(void *)(v89 + 80);
      uint64_t v90 = v91;
    }
    while (v89);
  }
  re::SyncOwnershipInfo::write((re::SyncOwnershipInfo *)(v90 + 136), this, 1);
  unsigned int v92 = (*(uint64_t (**)(void, void, void))(*(void *)*a1 + 32))(*a1, *(void *)(v75 + 24), *(void *)(*(void *)(*(void *)(v75 + 88) + 16) + 32));
  *(void *)uint64_t v156 = 0;
  re::BiasedVLQ::write((re::BiasedVLQ *)v156, this, v92);
  if ((v88 & 5) != 0)
  {
    unsigned int v93 = *(_DWORD *)(v75 + 28);
    re::BitWriter::writeUInt32Bits((uint64_t)this, *(_DWORD *)(v75 + 24), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, v93, 0x20u);
    uint64_t v94 = *(void *)(*(void *)(v75 + 88) + 16);
    unsigned int v95 = *(_DWORD *)(v94 + 36);
    re::BitWriter::writeUInt32Bits((uint64_t)this, *(_DWORD *)(v94 + 32), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, v95, 0x20u);
  }
  if (v82) {
    re::BitWriter::writeUInt32Bits((uint64_t)this, v84, 0x10u);
  }
  if (v88)
  {
    uint64_t v96 = *(void *)(v75 + 80);
    if (v96)
    {
      uint64_t v97 = (void *)(v96 + 8);
      id v98 = (id)(v96 + 8);

      uint64_t v99 = *(void *)(v75 + 80);
      if (v99) {
        id v100 = (id)(v99 + 8);
      }
      uint64_t v101 = *(void *)(*(void *)(*(void *)(v99 + 88) + 16) + 32);

      uint64_t v102 = *(void *)(v75 + 80);
      if (v102) {
        id v103 = (id)(v102 + 8);
      }
      uint64_t v104 = *(void *)(v102 + 24);
    }
    else
    {
      uint64_t v101 = 0;
      uint64_t v104 = 0;
    }
    re::BitWriter::writeUInt32Bits((uint64_t)this, v101, 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, HIDWORD(v101), 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, v104, 0x20u);
    re::BitWriter::writeUInt32Bits((uint64_t)this, HIDWORD(v104), 0x20u);
  }
  if (!*((unsigned char *)this + 20))
  {
    unint64_t v105 = re::SyncObject::getLatestState((re::SyncObject *)v75);
    if (v105)
    {
      uint64_t v106 = *(void *)(*(void *)(v75 + 88) + 16);
      int v107 = *(_DWORD *)(v105 + 24);
      if (*(_DWORD *)(v105 + 28)) {
        ++v107;
      }
      *(void *)sockaddr buf = *(void *)(v105 + 8);
      *(_DWORD *)&uint8_t buf[8] = v107;
      unsigned char buf[12] = 0;
      *(void *)&uint8_t buf[16] = 0;
      v166 = 0;
      uint64_t v108 = *((void *)this + 3);
      re::BitWriter::writeUInt32Bits((uint64_t)this, 0, 8u);
      uint64_t v109 = *((void *)this + 3);
      if (v82)
      {
        int v110 = *((_DWORD *)v82 + 6);
        if (*((_DWORD *)v82 + 7)) {
          ++v110;
        }
        *(void *)uint64_t v156 = v82[1];
        *(_DWORD *)&v156[8] = v110;
        v157[0] = 0;
        *(void *)&v157[4] = 0;
        uint64_t v158 = 0;
        (*(void (**)(void))(*(void *)(v106 + 120) + 16))();
      }
      else
      {
        (*(void (**)(void))(*(void *)(v106 + 112) + 16))();
      }
      re::BitWriter::alignToByte(this);
      unint64_t v118 = *((void *)this + 3);
      uint64_t v119 = (v118 - v109);
      if (v119 >= 0x80)
      {
        int v120 = 0;
        unint64_t v121 = (v118 - v109);
        do
        {
          int v122 = v120;
          unint64_t v123 = v121 >> 14;
          v121 >>= 7;
          ++v120;
        }
        while (v123);
        if (HIDWORD(v118)) {
          LODWORD(v118) = v118 + 1;
        }
        *(void *)uint64_t v156 = *((void *)this + 1);
        *(_DWORD *)&v156[8] = v118;
        v157[0] = 0;
        *(void *)&v157[4] = 0;
        uint64_t v158 = 0;
        re::BitReader::seekTo((uint64_t)v156, v109);
        int v124 = ~v122;
        do
        {
          v151[0] = 0;
          re::BitReader::readUInt32Bits((uint64_t *)v156, 8u, v151);
          re::BitWriter::writeUInt32Bits((uint64_t)this, LOBYTE(v151[0]), 8u);
        }
        while (!__CFADD__(v124++, 1));
      }
      if (!*((unsigned char *)this + 20))
      {
        uint64_t v126 = *((void *)this + 3);
        re::BitWriter::rollbackTo((uint64_t)this, v108);
        *(void *)uint64_t v156 = 0;
        re::BiasedVLQ::write((re::BiasedVLQ *)v156, this, v119);
        re::BitWriter::rollbackTo((uint64_t)this, v126);
      }
    }
    else
    {
      BOOL v111 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
      {
        uint64_t v112 = *(void *)(v75 + 24);
        size_t v113 = *(void **)(*(void *)(v75 + 88) + 16);
        uint64_t v114 = v113[4];
        uint64_t v115 = v113[6];
        int v116 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v113[7];
        int v117 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))((char *)v113 + 49);
        if (v115) {
          int v117 = v116;
        }
        *(_DWORD *)uint64_t v156 = 134218498;
        *(void *)&v156[4] = v112;
        *(_WORD *)int v157 = 2048;
        *(void *)&v157[2] = v114;
        *(_WORD *)&v157[10] = 2080;
        uint64_t v158 = v117;
        _os_log_error_impl(&dword_228C70000, v111, OS_LOG_TYPE_ERROR, "Could not find latest state for object (id: %llu, type: %llu[%s]).", v156, 0x20u);
      }
    }
    if (!*((unsigned char *)this + 20))
    {
      uint64_t v127 = *(void *)a4;
      if (*(void *)a4)
      {
        (*(void (**)(unsigned char *__return_ptr))(**(void **)(a4 + 8) + 32))(v156);
        if (*(void *)v156) {

        }
        uint64_t v128 = (*(uint64_t (**)(uint64_t))(*(void *)v127 + 80))(v127);
        re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::raise(v128, v127);
      }
      unsigned int v72 = v139 + 1;
      goto LABEL_157;
    }
  }
  re::BitWriter::rollbackTo((uint64_t)this, v137);
  unsigned int v72 = v139;
LABEL_167:
  re::BitWriter::writeUInt32At((uint64_t)this, v134, v72);
  return v72 + v135;
}

uint64_t re::SyncPacker::packCommit(re::SyncCommit const&,re::BitWriter &,re::SyncObjectWriteContext const&,unsigned long)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(re::BitWriter **)a1;
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  re::BitWriter::rollbackTo(*(void *)a1, (*(_DWORD *)(*(void *)(a1 + 16) + 8) + v5));
  (*(void (**)(re::BitWriter *, uint64_t))(*(void *)v4 + 16))(v4, a3);
  re::BitWriter::bytesLeft(v4, v6);
  return *((void *)v4 + 1) + v5;
}

void anonymous namespace'::SnapshotBitWriter::~SnapshotBitWriter(_anonymous_namespace_::SnapshotBitWriter *this)
{
}

unsigned int *anonymous namespace'::SnapshotBitWriter::grow(_anonymous_namespace_::SnapshotBitWriter *this, unsigned int a2)
{
  uint64_t result = (unsigned int *)*((void *)this + 6);
  uint64_t v4 = result[2];
  unint64_t v5 = result[3];
  unint64_t v6 = v4 + a2;
  if (v6 <= v5) {
    goto LABEL_2;
  }
  uint64_t result = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)result, v6);
  if (result)
  {
    uint64_t result = (unsigned int *)*((void *)this + 6);
    LODWORD(v4) = result[2];
    LODWORD(v5) = result[3];
LABEL_2:
    *((void *)this + 1) = *(void *)result + *((void *)this + 5);
    *((_DWORD *)this + 4) = v5 - v4;
  }
  return result;
}

double RESyncViewCreate(re *a1)
{
  uint64_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (re::SyncView *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 136, 8);
  return re::SyncView::SyncView(v2);
}

void RESyncViewSetUserData(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(void *)(a1 + 128) = a2;
  }
  else
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      uint64_t v4 = "RESyncViewSetUserData";
      __int16 v5 = 2080;
      unint64_t v6 = "view != __null";
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncViewGetUserData(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 128);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    uint64_t v4 = "RESyncViewGetUserData";
    __int16 v5 = 2080;
    unint64_t v6 = "view != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

uint64_t RESyncViewGetObjectCount(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(unsigned int *)(a1 + 68);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    uint64_t v4 = "RESyncViewGetObjectCount";
    __int16 v5 = 2080;
    unint64_t v6 = "view != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncViewSetOwnerPeerID(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(void *)(a1 + 32) = a2;
  }
  else
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      uint64_t v4 = "RESyncViewSetOwnerPeerID";
      __int16 v5 = 2080;
      unint64_t v6 = "view != __null";
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncViewGetOwnerPeerID(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 32);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    uint64_t v4 = "RESyncViewGetOwnerPeerID";
    __int16 v5 = 2080;
    unint64_t v6 = "view != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncViewSetFromPeerID(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a2;
  }
  else
  {
    uint64_t v2 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136315394;
      uint64_t v4 = "RESyncViewSetFromPeerID";
      __int16 v5 = 2080;
      unint64_t v6 = "view != __null";
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
    }
  }
}

uint64_t RESyncViewGetFromPeerID(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1) {
    return *(void *)(a1 + 24);
  }
  uint64_t v2 = *re::networkLogObjects(0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315394;
    uint64_t v4 = "RESyncViewGetFromPeerID";
    __int16 v5 = 2080;
    unint64_t v6 = "view != __null";
    _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v3, 0x16u);
  }
  return 0;
}

void RESyncViewEnumerateObjects(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    unsigned int v11 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v12 = 136315394;
    uint64_t v13 = "RESyncViewEnumerateObjects";
    __int16 v14 = 2080;
    long long v15 = "view != __null";
    goto LABEL_25;
  }
  if (!a2)
  {
    unsigned int v11 = *re::networkLogObjects((re *)a1);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v12 = 136315394;
    uint64_t v13 = "RESyncViewEnumerateObjects";
    __int16 v14 = 2080;
    long long v15 = "cb != __null";
LABEL_25:
    _os_log_error_impl(&dword_228C70000, v11, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v12, 0x16u);
    return;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 72);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (int *)(*(void *)(a1 + 56) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 6;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a1 + 72);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    do
    {
      if (!(*(unsigned int (**)(uint64_t, void))(a2 + 16))(a2, *(void *)(*(void *)(*(void *)(a1 + 56) + 24 * v8 + 16) + 8)))break; {
      int v9 = *(_DWORD *)(a1 + 72) <= (v5 + 1) ? v5 + 1 : *(_DWORD *)(a1 + 72);
      }
      while (1)
      {
        uint64_t v8 = (v5 + 1);
        if (v9 - 1 == v5) {
          break;
        }
        LODWORD(v5) = v5 + 1;
        int v10 = v8;
        if ((*(_DWORD *)(*(void *)(a1 + 56) + 24 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_19;
        }
      }
      int v10 = v9;
LABEL_19:
      LODWORD(v5) = v10;
    }
    while (v4 != v10);
  }
}

uint64_t re::LeaderElectionLowestPeerID::setSession(uint64_t this, re::Session *a2)
{
  *(void *)(this + 32) = a2;
  return this;
}

uint64_t re::LeaderElectionLowestPeerID::setup(re::LeaderElectionLowestPeerID *this, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(re::LeaderElectionLowestPeerID *))(*(void *)this + 72))(this);
  if (result) {
    *(void *)(*((void *)this + 4) + 3136) = a2;
  }
  return result;
}

uint64_t re::LeaderElectionLowestPeerID::processCapabilities(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 32);
  if (*(unsigned char *)(v1 + 2184)) {
    *(_DWORD *)(v1 + 3280) |= 1u;
  }
  return this;
}

unint64_t re::LeaderElectionLowestPeerID::handleMigration(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 16);
  if (!v3) {
    goto LABEL_7;
  }
  uint64_t v4 = *(uint64_t **)(a3 + 32);
  uint64_t v5 = 8 * v3;
  unint64_t v6 = a2;
  do
  {
    uint64_t v7 = *v4++;
    unint64_t v8 = *(void *)(v7 + 24);
    if (v6 >= v8) {
      unint64_t v6 = v8;
    }
    v5 -= 8;
  }
  while (v5);
  if (v6 == a2)
  {
LABEL_7:
    *(_DWORD *)(*(void *)(a1 + 32) + 3280) |= 1u;
    return a2;
  }
  return v6;
}

void re::LeaderElectionLowestPeerID::removePeer(re::LeaderElectionLowestPeerID *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (*(void *)(v2 + 3136) == a2) {
    re::Session::stateEvent(v2, 4);
  }
}

uint64_t re::LeaderElectionLowestPeerID::isLeader(re::LeaderElectionLowestPeerID *this)
{
  return *(_DWORD *)(*((void *)this + 4) + 3280) & 1;
}

uint64_t re::LeaderElectionLowestPeerID::processPeerHelloSetLeader(uint64_t this, uint64_t a2)
{
  *(void *)(*(void *)(this + 32) + 3136) = a2;
  return this;
}

void re::LeaderElectionLowestPeerID::~LeaderElectionLowestPeerID(re::LeaderElectionLowestPeerID *this)
{
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

re::Transport *re::Transport::Transport(re::Transport *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD36288;
  *((void *)this + 3) = &unk_26DD362F0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 0;
  *(void *)((char *)this + 172) = 0x1FFFFFFFFLL;
  *((_DWORD *)this + 46) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((_DWORD *)this + 54) = 0;
  *((void *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *((_DWORD *)this + 64) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 292) = 0u;
  *(void *)((char *)this + 308) = 0x7FFFFFFFLL;
  *((unsigned char *)this + 3re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  *((_DWORD *)this + 92) = 0;
  *((void *)this + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  *((void *)this + 41) = 0;
  *((unsigned char *)this + 336) = 0;
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((unsigned char *)this + 392) = 1;
  *((void *)this + 51) = 0;
  *((void *)this + 52) = 0;
  *((_DWORD *)this + 106) = 0;
  *((void *)this + 50) = 0;
  *((_DWORD *)this + 116) = 0;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((void *)this + 63) = 0;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  re::DynamicString::setCapacity((void *)this + 60, 0);
  *((void *)this + 64) = 0;
  *((void *)this + 70) = 0;
  *((void *)this + 72) = 0;
  *((void *)this + 71) = 0;
  *((_WORD *)this + 292) = 257;
  *(_OWORD *)((char *)this + 600) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  re::PacketPool::make(0, 0, &v5);
  uint64_t v3 = *((void *)this + 48);
  *((void *)this + 48) = v5;
  if (v3) {

  }
  return this;
}

void re::Transport::~Transport(re::Transport *this)
{
  *(void *)this = &unk_26DD36288;
  *((void *)this + 3) = &unk_26DD362F0;
  if (*((void *)this + 9)) {
    re::Transport::deinit(this);
  }
  uint64_t v2 = *((void *)this + 72);
  if (v2)
  {

    *((void *)this + 72) = 0;
  }
  uint64_t v3 = *((void *)this + 71);
  if (v3)
  {

    *((void *)this + 71) = 0;
  }
  uint64_t v4 = *((void *)this + 70);
  if (v4)
  {

    *((void *)this + 70) = 0;
  }
  re::DynamicString::deinit((re::Transport *)((char *)this + 480));
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 440);
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 400);
  uint64_t v5 = *((void *)this + 48);
  if (v5)
  {

    *((void *)this + 48) = 0;
  }
  unint64_t v6 = *((void *)this + 47);
  if (v6) {
    dispatch_release(v6);
  }
  re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::deinit((uint64_t *)this + 34);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 232);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 192);
  re::DataArray<re::Connection>::deinit((uint64_t)this + 120);
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 120);
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)this + 80);
  uint64_t v7 = *((void *)this + 9);
  if (v7)
  {

    *((void *)this + 9) = 0;
  }
  uint64_t v8 = *((void *)this + 4);
  if (v8)
  {
    int v9 = (id *)*((void *)this + 8);
    if (v9)
    {
      uint64_t v10 = *((void *)this + 6);
      if (v10)
      {
        uint64_t v11 = 8 * v10;
        do
        {
          objc_destroyWeak(v9);
          *v9++ = 0;
          v11 -= 8;
        }
        while (v11);
        uint64_t v8 = *((void *)this + 4);
        int v9 = (id *)*((void *)this + 8);
      }
      (*(void (**)(uint64_t, id *))(*(void *)v8 + 40))(v8, v9);
    }
    *((void *)this + 8) = 0;
    *((void *)this + 5) = 0;
    *((void *)this + 6) = 0;
    *((void *)this + 4) = 0;
    ++*((_DWORD *)this + 14);
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::Transport::~Transport(this);
  JUMPOUT(0x22A6A9430);
}

double re::Transport::deinit(re::Transport *this)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  atomic_store(0, (unsigned __int8 *)this + 336);
  uint64_t v2 = *((void *)this + 72);
  if (v2)
  {

    *((void *)this + 72) = 0;
  }
  dispatch_queue_set_specific(*((dispatch_queue_t *)this + 47), this, 0, 0);
  uint64_t v3 = (re *)re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::DataArrayIterator((uint64_t)&v23, (uint64_t)this + 120);
  unint64_t v21 = v23;
  uint64_t v22 = v24;
  if ((re::Transport *)((char *)this + 120) != v23
    || (unsigned __int16)v24 != 0xFFFFLL
    || (v24 & 0xFFFF0000) != 4294901760)
  {
    do
    {
      uint64_t v6 = *((void *)this + 70);
      if (v6)
      {
        unint64_t v7 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)&v21);
        (*(void (**)(uint64_t, re::Transport *, unint64_t))(*(void *)v6 + 40))(v6, this, v7);
      }
      if (*(_DWORD *)re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v21) == 1)
      {
        uint64_t v8 = *((void *)this + 76);
        unint64_t v9 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)&v21);
        (*(void (**)(uint64_t, unint64_t))(*(void *)v8 + 8))(v8, v9);
        uint64_t v10 = (re *)re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v21);
        uint64_t v11 = *((void *)v10 + 5);
        if (v11)
        {
          id v12 = (id)(v11 + 8);
          uint64_t v10 = (re *)(id)(v11 + 8);
        }
        uint64_t v13 = re::globalAllocators(v10)[2];
        uint64_t v25 = v11;
        uint64_t v26 = v13;
        uint64_t v23 = (re::Transport *)&unk_26DD36380;
        uint64_t v24 = this;
        uint64_t v27 = &v23;
        (*(void (**)(void, re::Transport **))(**((void **)this + 41) + 16))(*((void *)this + 41), &v23);
        re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&v23);
        if (v11) {
      }
        }
      if (*(void *)(re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v21)
                     + 40))
      {
        uint64_t v14 = *(void *)(re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v21)
                        + 40);
        if (v14) {
          id v15 = (id)(v14 + 8);
        }
        os_unfair_lock_lock((os_unfair_lock_t)(v14 + 1764));
        *(void *)(v14 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
        os_unfair_lock_unlock((os_unfair_lock_t)(v14 + 1764));
        uint64_t v16 = re::globalAllocators((re *)(id)(v14 + 8))[2];
        uint64_t v25 = v14;
        uint64_t v26 = v16;
        uint64_t v23 = (re::Transport *)&unk_26DD363D8;
        uint64_t v24 = this;
        uint64_t v27 = &v23;
        (*(void (**)(void, re::Transport **))(**((void **)this + 41) + 16))(*((void *)this + 41), &v23);
        re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&v23);
      }
      uint64_t v3 = (re *)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v21);
    }
    while (v21 != (re::Transport *)((char *)this + 120) || (unsigned __int16)v22 != 0xFFFF || WORD1(v22) != 0xFFFF);
  }
  uint64_t v26 = re::globalAllocators(v3)[2];
  uint64_t v27 = &v23;
  uint64_t v23 = (re::Transport *)&unk_26DD36430;
  uint64_t v24 = this;
  (*(void (**)(void, re::Transport **))(**((void **)this + 41) + 16))(*((void *)this + 41), &v23);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&v23);
  (*(void (**)(void))(**((void **)this + 41) + 32))(*((void *)this + 41));
  (*(void (**)(void))(**((void **)this + 40) + 32))(*((void *)this + 40));
  re::DataArray<re::Connection>::deinit((uint64_t)this + 120);
  re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::deinit((uint64_t *)this + 34);
  re::internal::destroyPersistent<re::TransportCommands>(*((re **)this + 41));
  *((void *)this + 41) = 0;
  re::internal::destroyPersistent<re::TransportCommands>(*((re **)this + 40));
  *((void *)this + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  uint64_t v17 = *((void *)this + 9);
  if (v17)
  {

    *((void *)this + 9) = 0;
  }
  uint64_t v18 = *((void *)this + 47);
  *((void *)this + 47) = 0;
  if (v18) {
    dispatch_release(v18);
  }
  uint64_t v19 = *((void *)this + 48);
  if (v19)
  {

    *((void *)this + 48) = 0;
  }
  double result = 0.0;
  *(_OWORD *)((char *)this + 600) = 0u;
  return result;
}

BOOL re::Transport::init(uint64_t a1, uint64_t *a2)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 600) = a2[12];
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 72);
  if (v5 != *a2)
  {
    if (v4)
    {
      id v6 = (id)(v4 + 8);
      uint64_t v5 = *(void *)(a1 + 72);
    }
    if (v5) {

    }
    *(void *)(a1 + 72) = v4;
  }
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 568), a2[4]);
  uint64_t v7 = a2[12];
  if (v7) {
    uint64_t v8 = v7 + 24;
  }
  else {
    uint64_t v8 = 0;
  }
  *(void *)(a1 + 608) = v8;
  unint64_t v9 = a2[1];
  if (v9) {
    dispatch_retain((dispatch_object_t)a2[1]);
  }
  uint64_t v10 = (NSObject **)(a1 + 376);
  uint64_t v11 = *(NSObject **)(a1 + 376);
  *(void *)(a1 + 376) = v9;
  if (v11)
  {
    dispatch_release(v11);
    unint64_t v9 = *v10;
  }
  dispatch_queue_set_specific(v9, (const void *)a1, (void *)a1, 0);
  if (!*(void *)(a1 + 376))
  {
    uint64_t v13 = *re::networkLogObjects(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      _os_log_error_impl(&dword_228C70000, v13, OS_LOG_TYPE_ERROR, "Invalid transport queue. Should be the same dispatch_queue that transport api will be called on.", buf, 2u);
    }
  }
  *(_OWORD *)sockaddr buf = *(_OWORD *)v10;
  uint64_t v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint8_t *))(**(void **)(a1 + 72) + 32))(*(void *)(a1 + 72), buf);
  if (v14)
  {
    re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity((void *)(a1 + 120), 0);
    ++*(_DWORD *)(a1 + 144);
    *(_DWORD *)(a1 + 164) = 64;
    id v15 = re::DataArray<re::Connection>::allocBlock((void *)(a1 + 120));
    re::Defaults::intValue((re::Defaults *)"network.transport.compressionMethod", v16, (uint64_t)v63);
    if (v63[0]) {
      uint64_t v17 = &v64;
    }
    else {
      uint64_t v17 = (int *)(a2 + 2);
    }
    *(unsigned char *)(a1 + 392) = *(unsigned char *)v17;
    unint64_t v18 = (*(uint64_t (**)(void, void, void))(**(void **)(a1 + 72) + 120))(*(void *)(a1 + 72), 0, 0);
    unint64_t v19 = v18;
    unint64_t v20 = *(void *)(a1 + 96);
    if (v20 >= v18)
    {
      if (v20 <= v18)
      {
LABEL_35:
        uint64_t v28 = (re *)(*(uint64_t (**)(void, void, unint64_t))(**(void **)(a1 + 72) + 120))(*(void *)(a1 + 72), *(void *)(a1 + 112), v19);
        atomic_store(1u, (unsigned __int8 *)(a1 + 336));
        uint64_t v29 = re::globalAllocators(v28);
        uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v29[2] + 32))(v29[2], 128, 8);
        uint64_t v31 = 0;
        *(void *)uint64_t v30 = &unk_26DD35DB0;
        *(void *)(v30 + 8) = 0x100000000;
        do
        {
          uint64_t v32 = v30 + v31;
          *(void *)(v32 + 56) = 0;
          *(_OWORD *)(v32 + 16) = 0uLL;
          *(_OWORD *)(v32 + 32) = 0uLL;
          *(_DWORD *)(v32 + 48) = 0;
          v31 += 48;
        }
        while (v31 != 96);
        *(_DWORD *)(v30 + 112) = 0;
        *(unsigned char *)(v30 + 120) = 0;
        *(void *)(a1 + 320) = v30;
        unsigned __int16 v33 = (re *)(*(uint64_t (**)(void))(**(void **)(a1 + 72) + 152))(*(void *)(a1 + 72));
        if (v33)
        {
          if (v33 == 2)
          {
            __int16 v37 = re::globalAllocators(v33);
            __int16 v36 = (re::TransportCommandsDispatch *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v37[2] + 32))(v37[2], 128, 8);
            uint64_t v38 = 0;
            *(void *)__int16 v36 = &unk_26DD35DB0;
            *((void *)v36 + 1) = 0x100000000;
            do
            {
              uint64_t v39 = (char *)v36 + v38;
              *((void *)v39 + 7) = 0;
              *((_OWORD *)v39 + 1) = 0uLL;
              *((_OWORD *)v39 + 2) = 0uLL;
              *((_DWORD *)v39 + 12) = 0;
              v38 += 48;
            }
            while (v38 != 96);
            *((_DWORD *)v36 + 28) = 0;
            *((unsigned char *)v36 + 120) = 0;
LABEL_47:
            *(void *)(a1 + 328) = v36;
            uint64_t v43 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 72) + 112))(*(void *)(a1 + 72), a1 + 24);
            *(void *)&uint8_t buf[8] = 0;
            int v66 = 0;
            uint64_t v67 = 0;
            re::DynamicString::setCapacity(buf, 0);
            if ((*(uint64_t (**)(void, uint8_t *, uint64_t))(**(void **)(a1 + 72) + 120))(*(void *)(a1 + 72), buf, 1))
            {
              if (buf[8]) {
                uint64_t v44 = v66;
              }
              else {
                uint64_t v44 = (const char *)&buf[9];
              }
            }
            else
            {
              uint64_t v44 = "n/a";
            }
            size_t v45 = strlen(v44);
            *(void *)uint64_t v68 = v44;
            size_t v69 = v45;
            re::DynamicString::operator=((re::DynamicString *)(a1 + 480), (uint64_t)v68);
            re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 560), a2[3]);
            long long v46 = *(_OWORD *)(a2 + 5);
            long long v47 = *(_OWORD *)(a2 + 7);
            *(void *)(a1 + 552) = a2[9];
            *(_OWORD *)(a1 + 520) = v46;
            *(_OWORD *)(a1 + 536) = v47;
            uint64_t v48 = (re *)(*(uint64_t (**)(void))(**(void **)(a1 + 72) + 144))(*(void *)(a1 + 72));
            *(_DWORD *)(a1 + 512) = v48;
            id v49 = *re::networkLogObjects(v48);
            BOOL v50 = os_log_type_enabled(v49, OS_LOG_TYPE_INFO);
            if (v50)
            {
              int v51 = *(_DWORD *)(a1 + 512);
              *(_DWORD *)uint64_t v68 = 67109120;
              *(_DWORD *)&v68[4] = v51;
              _os_log_impl(&dword_228C70000, v49, OS_LOG_TYPE_INFO, "Transport preferred packet size: %d", v68, 8u);
            }
            unsigned int v52 = *(_DWORD *)(a1 + 512);
            BOOL v25 = v52 > 0x14;
            if (v52 > 0x14)
            {
              *(_DWORD *)(a1 + 516) = v52 - 3;
              re::SharedPtr<re::SyncObject>::reset((uint64_t *)(a1 + 576), a2[10]);
              *(unsigned char *)(a1 + 584) = *((unsigned char *)a2 + 88);
              uint64_t v54 = *re::networkLogObjects(v53);
              BOOL v55 = os_log_type_enabled(v54, OS_LOG_TYPE_INFO);
              if (v55)
              {
                int v56 = *(unsigned __int8 *)(a1 + 584);
                *(_DWORD *)uint64_t v68 = 67109120;
                *(_DWORD *)&v68[4] = v56;
                _os_log_impl(&dword_228C70000, v54, OS_LOG_TYPE_INFO, "Transport throttling enabled: %d", v68, 8u);
              }
              *(unsigned char *)(a1 + 585) = *((unsigned char *)a2 + 89);
              uint64_t v57 = *re::networkLogObjects((re *)v55);
              if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
              {
                int v58 = *(unsigned __int8 *)(a1 + 585);
                *(_DWORD *)uint64_t v68 = 67109120;
                *(_DWORD *)&v68[4] = v58;
                _os_log_impl(&dword_228C70000, v57, OS_LOG_TYPE_INFO, "Transport message fragmentation enabled: %d", v68, 8u);
              }
            }
            else
            {
              uint64_t v59 = *re::networkLogObjects((re *)v50);
              if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
              {
                int v62 = *(_DWORD *)(a1 + 512);
                *(_DWORD *)uint64_t v68 = 67109120;
                *(_DWORD *)&v68[4] = v62;
                _os_log_error_impl(&dword_228C70000, v59, OS_LOG_TYPE_ERROR, "Invalid preferred packet size for transport: %u", v68, 8u);
              }
            }
            if (*(void *)buf && (buf[8] & 1) != 0) {
              (*(void (**)(void))(**(void **)buf + 40))();
            }
            return v25;
          }
          if (v33 == 1)
          {
            unsigned __int16 v34 = re::globalAllocators(v33);
            unsigned __int8 v35 = (re::TransportCommandsDispatch *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v34[2] + 32))(v34[2], 24, 8);
            __int16 v36 = re::TransportCommandsDispatch::TransportCommandsDispatch(v35);
            goto LABEL_47;
          }
          uint64_t v40 = *re::networkLogObjects(v33);
          unsigned __int16 v33 = (re *)os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
          if (v33)
          {
            *(_WORD *)sockaddr buf = 0;
            _os_log_impl(&dword_228C70000, v40, OS_LOG_TYPE_DEFAULT, "Unknown thread mode. Defaulting to ThreadWaitAndWake", buf, 2u);
          }
        }
        uint64_t v41 = re::globalAllocators(v33);
        uint64_t v42 = (re::TransportCommandsThreadedProtocol *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v41[2] + 32))(v41[2], 144, 8);
        re::TransportCommandsThreadedProtocol::TransportCommandsThreadedProtocol(v42, *(re::ProtocolLayer **)(a1 + 72));
      }
      uint64_t v26 = 32 * v18;
      unint64_t v27 = v18;
      do
      {
        re::DynamicString::deinit((re::DynamicString *)(*(void *)(a1 + 112) + v26));
        ++v27;
        v26 += 32;
      }
      while (v27 < *(void *)(a1 + 96));
    }
    else
    {
      if (*(void *)(a1 + 88) < v18)
      {
        unint64_t v18 = (unint64_t)re::DynamicArray<re::Address>::setCapacity((void *)(a1 + 80), v18);
        unint64_t v20 = *(void *)(a1 + 96);
      }
      unint64_t v21 = v19 - v20;
      if (v19 > v20)
      {
        uint64_t v22 = 32 * v20;
        do
        {
          uint64_t v23 = *(void *)(a1 + 112) + v22;
          *(_OWORD *)uint64_t v23 = 0u;
          *(_OWORD *)(v23 + 16) = 0u;
          unint64_t v18 = (unint64_t)re::DynamicString::setCapacity((void *)v23, 0);
          v22 += 32;
          --v21;
        }
        while (v21);
      }
    }
    *(void *)(a1 + 96) = v19;
    ++*(_DWORD *)(a1 + 104);
    goto LABEL_35;
  }
  uint64_t v24 = *(void *)(a1 + 72);
  if (v24)
  {

    *(void *)(a1 + 72) = 0;
  }
  return 0;
}

re *re::internal::destroyPersistent<re::TransportCommands>(re *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = re::globalAllocators(result)[2];
    (**(void (***)(re *))v1)(v1);
    uint64_t v3 = *(uint64_t (**)(uint64_t, re *))(*(void *)v2 + 40);
    return (re *)v3(v2, v1);
  }
  return result;
}

uint64_t re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*(unsigned __int16 *a1)
{
  unint64_t v1 = a1[5];
  if (*(void *)(*(void *)a1 + 16) <= v1)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(*(void *)a1 + 32) + 16 * v1) + 136 * a1[4];
}

uint64_t re::DataArray<re::Connection>::deinit(uint64_t result)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(result + 44))
  {
    unint64_t v1 = (void *)result;
    re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::DataArrayIterator((uint64_t)&v13, result);
    if ((void *)v13 != v1 || WORD4(v13) != 0xFFFFLL || (DWORD2(v13) & 0xFFFF0000) != 4294901760)
    {
      do
      {
        unint64_t v4 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)&v13);
        re::DataArray<re::Connection>::destroy((uint64_t)v1, v4);
        re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v13);
      }
      while ((void *)v13 != v1 || WORD4(v13) != 0xFFFF || WORD5(v13) != 0xFFFF);
    }
    unint64_t v7 = v1[2];
    unint64_t v8 = v7 - 1;
    if (v7 != 1)
    {
      uint64_t v9 = 16 * v7 - 16;
      do
      {
        if (v7 <= v8)
        {
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_30:
          long long v16 = 0u;
          long long v17 = 0u;
          long long v14 = 0u;
          long long v15 = 0u;
          long long v13 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = (void *)(v1[4] + v9);
        (*(void (**)(void, void))(*(void *)*v1 + 40))(*v1, *v10);
        (*(void (**)(void, void))(*(void *)*v1 + 40))(*v1, v10[1]);
        unint64_t v11 = v1[2];
        if (v11 <= v8) {
          goto LABEL_30;
        }
        unint64_t v7 = v11 - 1;
        if (v11 - 1 > v8)
        {
          *(_OWORD *)(v1[4] + v9) = *(_OWORD *)(v1[4] + 16 * v11 - 16);
          unint64_t v7 = v1[2] - 1;
        }
        void v1[2] = v7;
        ++*((_DWORD *)v1 + 6);
        v9 -= 16;
        --v8;
      }
      while (v8);
      v1[6] = 0xFFFFFFFF00000000;
      if (v7) {
        goto LABEL_27;
      }
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v13 = 0u;
      unint64_t v1 = (void *)&_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v1[6] = 0xFFFFFFFF00000000;
LABEL_27:
    id v12 = (void *)v1[4];
    (*(void (**)(void, void))(*(void *)*v1 + 40))(*v1, *v12);
    (*(void (**)(void, void))(*(void *)*v1 + 40))(*v1, v12[1]);
    double result = re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v1);
    *((_DWORD *)v1 + 11) = 0;
  }
  return result;
}

double re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v5);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v5) = v7 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v6 + v5 + 8));
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        ++v4;
        v5 += 56;
      }
      while (v4 < v3);
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

unint64_t re::Transport::flushNetworkEvents(re::Transport *this)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 41);
  uint64_t v3 = re::globalAllocators(this)[2];
  *(void *)sockaddr buf = &unk_26DD36488;
  BOOL v50 = this;
  uint64_t v52 = v3;
  int v53 = buf;
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v2 + 16))(v2, buf);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)buf);
  unint64_t result = (*(uint64_t (**)(void))(**((void **)this + 41) + 24))(*((void *)this + 41));
  if (*((unsigned char *)this + 585))
  {
    unint64_t result = (*(uint64_t (**)(void))(**((void **)this + 71) + 32))(*((void *)this + 71));
    if (result - *((void *)this + 74) >= 0x3E8)
    {
      unint64_t v5 = result;
      unint64_t result = re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::DataArrayIterator((uint64_t)buf, (uint64_t)this + 120);
      long long v47 = *(re::Transport **)buf;
      uint64_t v48 = v50;
      if ((re::Transport *)((char *)this + 120) != *(re::Transport **)buf
        || (unsigned __int16)v50 != 0xFFFFLL
        || (v50 & 0xFFFF0000) != 0xFFFF0000)
      {
        do
        {
          uint64_t v6 = (re *)re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v47);
          uint64_t v7 = *((void *)v6 + 5);
          if (v7)
          {
            uint64_t v8 = 0;
            uint64_t v45 = *((void *)v6 + 5);
            do
            {
              uint64_t v9 = v7 + 48 * v8;
              uint64_t v10 = *(unsigned int *)(v9 + 464);
              if (v10)
              {
                uint64_t v11 = 0;
                id v12 = (int *)(*(void *)(v7 + 48 * v8 + 448) + 8);
                while (1)
                {
                  int v13 = *v12;
                  v12 += 20;
                  if (v13 < 0) {
                    break;
                  }
                  if (v10 == ++v11)
                  {
                    uint64_t v11 = *(unsigned int *)(v9 + 464);
                    break;
                  }
                }
              }
              else
              {
                uint64_t v11 = 0;
              }
              uint64_t v46 = v8;
              if (v10 <= v11
                || (uint64_t v14 = *(void *)(v7 + 48 * v8 + 448),
                    (*(_DWORD *)(v14 + 80 * v11 + 8) & 0x80000000) != 0))
              {
LABEL_19:
                if (v10 != v11)
                {
                  uint64_t v44 = (_DWORD *)(v9 + 464);
                  uint64_t v17 = v11;
                  uint64_t v18 = (uint64_t *)(v45 + 48 * v8 + 448);
                  do
                  {
                    uint64_t v19 = v17;
                    uint64_t v20 = *v18;
                    unsigned int v21 = *(unsigned __int16 *)(*v18 + 80 * v17 + 12);
                    if (v10 <= (int)v11 + 1) {
                      int v22 = v11 + 1;
                    }
                    else {
                      int v22 = v10;
                    }
                    int v23 = v11;
                    while (1)
                    {
                      uint64_t v17 = (v23 + 1);
                      if (v22 - 1 == v23) {
                        break;
                      }
                      ++v23;
                      LODWORD(v11) = v17;
                      if ((*(_DWORD *)(v20 + 80 * v17 + 8) & 0x80000000) != 0) {
                        goto LABEL_29;
                      }
                    }
                    LODWORD(v11) = v22;
LABEL_29:
                    unint64_t v24 = *(void *)(v20 + 80 * v19 + 72);
                    if (v24) {
                      BOOL v25 = v24 >= v5;
                    }
                    else {
                      BOOL v25 = 1;
                    }
                    if (!v25)
                    {
                      uint64_t v26 = *re::networkLogObjects(v6);
                      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                      {
                        int v27 = *(_DWORD *)(v20 + 80 * v19 + 64);
                        *(_DWORD *)sockaddr buf = 67109632;
                        *(_DWORD *)&uint8_t buf[4] = v21;
                        LOWORD(v50) = 1024;
                        *(_DWORD *)((char *)&v50 + 2) = v46;
                        HIWORD(v50) = 1024;
                        int v51 = v27;
                        _os_log_impl(&dword_228C70000, v26, OS_LOG_TYPE_DEFAULT, "Message %u on channel %u timed-out waiting for fragment %u.", buf, 0x14u);
                      }
                      uint64_t v6 = (re *)re::Transport::discardPacketFragments(v45, v46, v21);
                      LODWORD(v10) = *v44;
                    }
                  }
                  while (v10 != v11);
                }
              }
              else
              {
                long long v15 = (int *)(v14 + 80 * v11 + 88);
                while (v10 - 1 != v11)
                {
                  int v16 = *v15;
                  v15 += 20;
                  LODWORD(v11) = v11 + 1;
                  if (v16 < 0) {
                    goto LABEL_19;
                  }
                }
              }
              uint64_t v7 = v45;
              uint64_t v8 = v46 + 1;
            }
            while (v46 != 9);
          }
          unint64_t result = (unint64_t)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v47);
        }
        while (v47 != (re::Transport *)((char *)this + 120) || (unsigned __int16)v48 != 0xFFFF || WORD1(v48) != 0xFFFF);
      }
      *((void *)this + 74) = v5;
    }
  }
  if (*((void *)this + 70))
  {
    unint64_t result = re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::DataArrayIterator((uint64_t)buf, (uint64_t)this + 120);
    if ((re::Transport *)((char *)this + 120) != *(re::Transport **)buf
      || (unsigned __int16)v50 != 0xFFFFLL
      || (v50 & 0xFFFF0000) != 0xFFFF0000)
    {
      do
      {
        uint64_t v30 = *(void *)(re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)buf)
                        + 40);
        if (v30)
        {
          unsigned __int8 v31 = 0;
          do
          {
            uint64_t v32 = *((void *)this + 70);
            unint64_t v33 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)buf);
            unsigned int v34 = v31;
            uint64_t v35 = (*(uint64_t (**)(uint64_t, re::Transport *, unint64_t, void))(*(void *)v32 + 64))(v32, this, v33, v31);
            if (v36)
            {
              __int16 v37 = (uint8_t *)v35;
              size_t v38 = v36;
              do
              {
                re::Transport::onReceiveData((uint64_t)this, v30, v31, v37, v38);
                uint64_t v39 = *((void *)this + 70);
                unint64_t v40 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::handle((unsigned __int16 *)buf);
                __int16 v37 = (uint8_t *)(*(uint64_t (**)(uint64_t, re::Transport *, unint64_t, void))(*(void *)v39 + 64))(v39, this, v40, v31);
                size_t v38 = v41;
              }
              while (v41);
            }
            ++v31;
          }
          while (v34 < 9);
        }
        unint64_t result = (unint64_t)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(buf);
      }
      while (*(re::Transport **)buf != (re::Transport *)((char *)this + 120)
           || (unsigned __int16)v50 != 0xFFFF
           || WORD1(v50) != 0xFFFF);
    }
  }
  return result;
}

uint64_t re::Transport::onReceiveData(uint64_t a1, uint64_t a2, uint64_t a3, uint8_t *a4, size_t a5)
{
  uint64_t v6 = a1;
  uint64_t v121 = *MEMORY[0x263EF8340];
  src_buffer = a4;
  src_size_t size = a5;
  __int16 v100 = 0;
  unsigned __int8 v101 = 1;
  unsigned __int8 v102 = a3;
  __int16 v103 = 0;
  if (a5)
  {
    PacketHeaderFromBuffer = re::Transport::readPacketHeaderFromBuffer(a1, (uint64_t)a4, a3, (uint64_t)&v100);
    uint64_t v8 = v102;
    if (v102 >= 0xBuLL)
    {
      uint64_t v9 = *re::networkLogObjects((re *)PacketHeaderFromBuffer);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)sockaddr buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v8;
        _os_log_error_impl(&dword_228C70000, v9, OS_LOG_TYPE_ERROR, "Transport cannot receive on invalid channel id: %hhu", buf, 8u);
      }
      uint64_t result = re::internal::enableSignposts(0, 0);
      if (result) {
        return kdebug_trace();
      }
      return result;
    }
    src_buffer = (uint8_t *)re::Slice<unsigned char>::range(&src_buffer, 3uLL, src_size);
    src_size_t size = v11;
  }
  else
  {
    uint64_t v8 = a3;
  }
  uint64_t v12 = re::internal::enableHighFrequencyNetworkTracing(0, 0);
  if (v12)
  {
    uint64_t v13 = *(void *)(v6 + 600);
    if (v13)
    {
      uint64_t v14 = *(void *)(v13 + 2296);
      if (v14)
      {
        long long v15 = *(uint64_t **)(v13 + 2312);
        uint64_t v16 = 8 * v14;
        while (1)
        {
          uint64_t v17 = *v15;
          if (*(void *)(*v15 + 32) == *(void *)(a2 + 24)) {
            break;
          }
          ++v15;
          v16 -= 8;
          if (!v16) {
            goto LABEL_15;
          }
        }
        id v69 = (id)(v17 + 8);
      }
    }
LABEL_15:
    uint64_t v12 = re::internal::enableSignposts(0, 0);
    if (v12)
    {
      uint64_t v12 = re::internal::enableHighFrequencyNetworkTracing(0, 0);
      if (v12) {
        uint64_t v12 = kdebug_trace();
      }
    }
  }
  uint64_t v97 = 0;
  uint64_t v98 = 0;
  uint64_t v99 = 0;
  uint64_t v18 = src_size;
  if (!HIBYTE(v100)) {
    goto LABEL_61;
  }
  if (src_size <= 9)
  {
    uint64_t v19 = *re::networkLogObjects((re *)v12);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
LABEL_46:
      memset(buf, 0, 24);
      goto LABEL_47;
    }
    *(_DWORD *)sockaddr buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v8;
    uint64_t v20 = "Discarding fragment with invalid size (channel=%u)";
LABEL_22:
    _os_log_impl(&dword_228C70000, v19, OS_LOG_TYPE_INFO, v20, buf, 8u);
    goto LABEL_46;
  }
  unsigned int v21 = src_buffer;
  int v22 = v101;
  uint64_t v108 = 0;
  *(void *)sockaddr buf = src_buffer;
  *(_DWORD *)&uint8_t buf[8] = src_size;
  unsigned char buf[12] = 0;
  *(_OWORD *)&uint8_t buf[16] = 0uLL;
  *(_DWORD *)int v110 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)buf, 0x10u, (unsigned int *)v110);
  unsigned __int16 v23 = *(_WORD *)v110;
  LOWORD(v106) = *(_WORD *)v110;
  *(_DWORD *)int v110 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)buf, 0x20u, (unsigned int *)v110);
  unint64_t v24 = *(unsigned int *)v110;
  HIDWORD(v106) = *(_DWORD *)v110;
  *(_DWORD *)int v110 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)buf, 0x20u, (unsigned int *)v110);
  uint64_t v25 = *(unsigned int *)v110;
  int v107 = *(_DWORD *)v110;
  uint64_t v109 = 0;
  *(void *)int v110 = 0;
  uint64_t v26 = (re *)re::BiasedVLQ::read((re::BiasedVLQ *)&v109, (re::BitReader *)buf, (uint64_t *)v110);
  if (!v26
    || (unsigned int v27 = *(_DWORD *)v110,
        LODWORD(v108) = *(_DWORD *)v110,
        uint64_t v109 = 0,
        uint64_t v26 = (re *)re::BiasedVLQ::read((re::BiasedVLQ *)&v109, (re::BitReader *)buf, (uint64_t *)v110),
        (v26 & 1) == 0))
  {
    uint64_t v42 = *re::networkLogObjects(v26);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)sockaddr buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v8;
      _os_log_impl(&dword_228C70000, v42, OS_LOG_TYPE_INFO, "Discarding fragment with unreadable header (channel=%u)", buf, 8u);
    }
    goto LABEL_46;
  }
  HIDWORD(v108) = *(_DWORD *)v110;
  if (!v25)
  {
    uint64_t v70 = *re::networkLogObjects(v26);
    BOOL v71 = os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
    if (!v71) {
      goto LABEL_97;
    }
    *(void *)sockaddr buf = 67110144;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = 1;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&uint8_t buf[16] = -1;
    *(_WORD *)&unsigned char buf[20] = 1024;
    *(_DWORD *)&unsigned char buf[22] = v23;
    *(_WORD *)&buf[26] = 1024;
    *(_DWORD *)&buf[28] = v24;
    unsigned int v72 = "Fragment count is not within range %u [%u, %u]. Fragment %u, %u will be discarded.";
    uint64_t v73 = v70;
    uint32_t v74 = 32;
LABEL_96:
    _os_log_error_impl(&dword_228C70000, v73, OS_LOG_TYPE_ERROR, v72, buf, v74);
    goto LABEL_97;
  }
  if (v24 >= v25)
  {
    uint64_t v18 = *re::networkLogObjects(v26);
    BOOL v71 = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!v71) {
      goto LABEL_97;
    }
    *(_DWORD *)sockaddr buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v24;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v25;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&uint8_t buf[16] = v23;
    *(_WORD *)&unsigned char buf[20] = 1024;
    *(_DWORD *)&unsigned char buf[22] = v24;
    unsigned int v72 = "Fragment index is out of bounds [%u, %u]. Fragment %u, %u will be discarded.";
    uint64_t v73 = v18;
    uint32_t v74 = 26;
    goto LABEL_96;
  }
  if (!v27)
  {
    uint64_t v75 = *re::networkLogObjects(v26);
    BOOL v71 = os_log_type_enabled(v75, OS_LOG_TYPE_ERROR);
    if (v71)
    {
      *(_DWORD *)sockaddr buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v23;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v24;
      unsigned int v72 = "Big packet size is not set. Fragment %u, %u will be discarded.";
      uint64_t v73 = v75;
      uint32_t v74 = 14;
      goto LABEL_96;
    }
LABEL_97:
    uint64_t v19 = *re::networkLogObjects((re *)v71);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO)) {
      goto LABEL_46;
    }
    *(_DWORD *)sockaddr buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v8;
    uint64_t v20 = "Discarding fragment with invalid header values (channel=%u)";
    goto LABEL_22;
  }
  int v28 = 11;
  if (v27 >= 0x80)
  {
    unint64_t v29 = v27;
    do
    {
      unint64_t v30 = v29 >> 14;
      v29 >>= 7;
      ++v28;
    }
    while (v30);
  }
  int v31 = 1;
  if (*(_DWORD *)v110 >= 0x80u)
  {
    unint64_t v32 = *(unsigned int *)v110;
    do
    {
      ++v31;
      unint64_t v33 = v32 >> 14;
      v32 >>= 7;
    }
    while (v33);
  }
  unint64_t v34 = (v31 + v28);
  if ((unint64_t)v18 <= v34)
  {
    uint64_t v19 = *re::networkLogObjects(v26);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_INFO)) {
      goto LABEL_46;
    }
    *(_DWORD *)sockaddr buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v8;
    uint64_t v20 = "Discarding fragment with empty payload (channel=%u)";
    goto LABEL_22;
  }
  size_t v93 = (size_t)v18 - v34;
  uint64_t v94 = *(unsigned int *)v110;
  unint64_t v95 = v34;
  uint64_t v18 = (a2 + 48 * v8 + 432);
  uint64_t v96 = v23;
  uint64_t v35 = re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::tryGet((uint64_t)v18, v23);
  if (!v35)
  {
    long long v118 = 0u;
    long long v119 = 0u;
    memset(buf, 0, sizeof(buf));
    unint64_t v36 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v96) ^ ((0xBF58476D1CE4E5B9 * v96) >> 27));
    unint64_t v37 = v36 ^ (v36 >> 31);
    if (v18->isa)
    {
      uint64_t v38 = a2 + 48 * v8;
      unint64_t v39 = v37 % *(unsigned int *)(v38 + 456);
      uint64_t v40 = *(unsigned int *)(*(void *)(v38 + 440) + 4 * v39);
      if (v40 != 0x7FFFFFFF)
      {
        uint64_t v41 = *(void *)(a2 + 48 * v8 + 448);
        if (*(unsigned __int16 *)(v41 + 80 * v40 + 12) == v96)
        {
LABEL_43:
          uint64_t v35 = v41 + 80 * v40 + 16;
LABEL_105:
          uint64_t v78 = *(_anonymous_namespace_ **)buf;
          if (*(void *)buf && *(void *)&buf[8]) {
            uint64_t v78 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(**(void **)buf + 40))(*(void *)buf, *(void *)&buf[16]);
          }
          *(void *)(v35 + 32) = v25;
          *(void *)(v35 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = v80;
          if (!v80)
          {
            re::internal::assertLog((re::internal *)4, v81, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
            uint64_t result = _os_crash();
            __break(1u);
            return result;
          }
          uint64_t v18 = v80;
          size_t v82 = v25 - 1;
          if (v82)
          {
            bzero(v80, v82);
            uint64_t v18 = ((char *)v18 + v82);
          }
          LOBYTE(v18->isa) = 0;
          *(_DWORD *)(v35 + 48) = 0;
          goto LABEL_112;
        }
        while (1)
        {
          LODWORD(vre::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = *(_DWORD *)(v41 + 80 * v40 + 8) & 0x7FFFFFFF;
          if (v40 == 0x7FFFFFFF) {
            break;
          }
          if (*(unsigned __int16 *)(v41 + 80 * v40 + 12) == v96) {
            goto LABEL_43;
          }
        }
      }
    }
    else
    {
      LODWORD(v39) = 0;
    }
    unsigned int v76 = re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsMove((uint64_t)v18, v39, v37, &v106, (uint64_t)buf);
    uint64_t v77 = a2 + 48 * v8;
    ++*(_DWORD *)(v77 + 472);
    uint64_t v35 = *(void *)(v77 + 448) + 80 * v76 + 16;
    if (*(void *)&buf[24] && (void)v118) {
      (*(void (**)(void, void))(**(void **)&buf[24] + 40))(*(void *)&buf[24], *((void *)&v118 + 1));
    }
    goto LABEL_105;
  }
LABEL_112:
  unint64_t v83 = v95;
  if (!v22)
  {
    uint64_t v84 = (*(uint64_t (**)(void))(**(void **)(v6 + 568) + 32))(*(void *)(v6 + 568));
    unint64_t v83 = v95;
    *(void *)(v35 + 56) = v84 + 1000;
  }
  memcpy((void *)(*(void *)(v35 + 16) + v94), &v21[v83], v93);
  unint64_t v85 = *(void *)(v35 + 32);
  if (v85 <= v24)
  {
    uint64_t v109 = 0;
    long long v119 = 0u;
    long long v120 = 0u;
    long long v118 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v110 = 136315906;
    *(void *)&v110[4] = "operator[]";
    __int16 v111 = 1024;
    int v112 = 468;
    __int16 v113 = 2048;
    uint64_t v114 = v24;
    __int16 v115 = 2048;
    unint64_t v116 = v85;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v86 = *(void *)(v35 + 40);
  *(unsigned char *)(v86 + vre::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 1;
  unint64_t v87 = *(unsigned int *)(v35 + 48);
  if (v85 > v87)
  {
    unsigned int v88 = v87 + 1;
    while (*(unsigned char *)(v86 + v87))
    {
      *(_DWORD *)(v35 + 48) = v88;
      unint64_t v87 = v88;
      if (v85 <= v88++) {
        goto LABEL_119;
      }
    }
    goto LABEL_46;
  }
LABEL_119:
  *(_OWORD *)sockaddr buf = *(_OWORD *)v35;
  uint64_t v90 = *(void *)(v35 + 16);
  *(void *)(v35 + 8) = 0;
  *(void *)(v35 + 16) = 0;
  *(void *)uint64_t v35 = 0;
  *(void *)&uint8_t buf[16] = v90;
  re::Transport::discardPacketFragments(a2, v8, v96);
LABEL_47:
  re::FixedArray<unsigned char>::operator=(&v97, (uint64_t *)buf);
  uint64_t v44 = *(void *)buf;
  if (*(void *)buf) {
    BOOL v45 = *(void *)&buf[8] == 0;
  }
  else {
    BOOL v45 = 1;
  }
  if (!v45) {
    uint64_t v44 = (*(uint64_t (**)(void, void))(**(void **)buf + 40))(*(void *)buf, *(void *)&buf[16]);
  }
  if (!v98) {
    goto LABEL_85;
  }
  uint64_t v46 = re::Transport::readPacketHeaderFromBuffer(v44, v99, v43, (uint64_t)&v100);
  uint64_t v8 = v102;
  if (v102 < 0xBuLL)
  {
    uint64_t v49 = v98;
    BOOL v50 = (char *)(v98 + 1);
    if ((unint64_t)(v98 + 1) <= 3)
    {
      uint64_t v106 = 0;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v118 = 0u;
      memset(buf, 0, sizeof(buf));
      uint64_t v6 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int v110 = 136315906;
      *(void *)&v110[4] = "slice";
      __int16 v111 = 1024;
      int v112 = 502;
      __int16 v113 = 2048;
      uint64_t v114 = 3;
      __int16 v115 = 2048;
      unint64_t v116 = (unint64_t)v50;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      uint64_t v18 = (v98 - 3);
      if ((unint64_t)(v98 - 3) < 0xFFFFFFFFFFFFFFFDLL)
      {
        src_buffer = (uint8_t *)(v99 + 3);
        src_size_t size = v98 - 3;
LABEL_61:
        if ((_BYTE)v100 && (unint64_t)v18 > 3)
        {
          int v51 = (re *)*(unsigned int *)src_buffer;
          uint64_t v52 = (uint8_t *)re::Slice<unsigned char>::range(&src_buffer, 4uLL, (unint64_t)v18);
          src_buffer = v52;
          src_size_t size = v53;
          if (v51 > 0x8000000)
          {
            uint64_t v65 = *re::networkLogObjects((re *)v52);
            if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)sockaddr buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = v51;
              *(_WORD *)&uint8_t buf[8] = 2048;
              *(void *)&buf[10] = 0x8000000;
              _os_log_error_impl(&dword_228C70000, v65, OS_LOG_TYPE_ERROR, "Inbound message decompressedLen(%u) exceeds kMaxSupportedMessageSize (%zu), message may be corrupted.", buf, 0x12u);
            }
            goto LABEL_85;
          }
          BOOL v50 = re::PacketPool::allocate(*(re::PacketPool **)(v6 + 384), (v51 + 3));
          re::Packet::offsetBy((uint64_t)v50, 3);
          uint64_t v54 = *((void *)v50 + 1);
          *(unsigned char *)(v54 + 2) = 0;
          *(_WORD *)uint64_t v54 = 0;
          re::Transport::writePacketHeader((uint64_t)v50, (unsigned __int8 *)&v100, 8);
          size_t v56 = compression_decode_scratch_buffer_size(v55);
          if (*(void *)(v6 + 448) < v56) {
            re::DynamicArray<unsigned char>::resize(v6 + 440, v56);
          }
          uint64_t v57 = (re *)compression_decode_buffer(*((uint8_t **)v50 + 2), *((unsigned int *)v50 + 7), src_buffer, src_size, *(void **)(v6 + 472), v55);
          if (v57 != v51)
          {
            int v58 = v57;
            uint64_t v59 = *re::networkLogObjects(v57);
            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)sockaddr buf = 134218240;
              *(void *)&uint8_t buf[4] = v58;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v51;
              _os_log_error_impl(&dword_228C70000, v59, OS_LOG_TYPE_ERROR, "Inbound message decompressed length (%zu) is not the expected length (%u), message discarded!", buf, 0x12u);
            }
            re::PacketPool::free(*(re::PacketPool **)(v6 + 384), (re::Packet *)v50);
            goto LABEL_85;
          }
        }
        else
        {
          BOOL v50 = re::PacketPool::allocate(*(re::PacketPool **)(v6 + 384), (v18 + 3));
          re::Packet::offsetBy((uint64_t)v50, 3);
          uint64_t v60 = *((void *)v50 + 1);
          *(unsigned char *)(v60 + 2) = 0;
          *(_WORD *)uint64_t v60 = 0;
          re::Transport::writePacketHeader((uint64_t)v50, (unsigned __int8 *)&v100, 8);
          memcpy(*((void **)v50 + 2), src_buffer, src_size);
          LODWORD(v51) = src_size;
        }
        *((_DWORD *)v50 + 6) = v51;
        os_unfair_lock_lock((os_unfair_lock_t)(a2 + 1764));
        uint64_t v61 = *(void *)(a2 + 24);
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 1764));
        if (!v61)
        {
          int v66 = *re::networkLogObjects(v62);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)sockaddr buf = 0;
            _os_log_debug_impl(&dword_228C70000, v66, OS_LOG_TYPE_DEBUG, "Received data for unbound connection object.", buf, 2u);
          }
          goto LABEL_83;
        }
        if (v8 != 1)
        {
          unsigned int v64 = v8;
          goto LABEL_81;
        }
        int v63 = re::Transport::dispatchPacketToStream((re::Transport *)v6, (re::Packet *)v50, *(void *)(a2 + 24));
        if (!v63)
        {
LABEL_82:
          (*(void (**)(void, void, uint64_t, void, void))(**(void **)(v6 + 608) + 24))(*(void *)(v6 + 608), *(void *)(a2 + 24), v8, *((void *)v50 + 2), *((unsigned int *)v50 + 6));
          goto LABEL_83;
        }
        if (v63 == 2)
        {
          unsigned int v64 = 1;
LABEL_81:
          uint64_t v67 = a2 + 40 * v64;
          atomic_fetch_add_explicit((atomic_uint *volatile)(v67 + 1336), *((_DWORD *)v50 + 6), memory_order_release);
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v67 + 1344), *((unsigned int *)v50 + 7), memory_order_release);
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v67 + 1328), 1uLL, memory_order_release);
          atomic_store((unint64_t)v50, *(unint64_t **)(v67 + 1312));
          *(void *)(v67 + 1312) = v50;
          goto LABEL_82;
        }
LABEL_122:
        re::PacketPool::free(*(re::PacketPool **)(v6 + 384), (re::Packet *)v50);
LABEL_83:
        uint64_t v68 = *(void *)(v6 + 576);
        if (v68) {
          (*(void (**)(uint64_t, size_t))(*(void *)v68 + 40))(v68, src_size);
        }
        goto LABEL_85;
      }
    }
    re::internal::assertLog((re::internal *)7, v47, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size_t size = %zu", "!overflow", "slice", 508, 3, v18, v49);
    _os_crash();
    __break(1u);
    re::internal::assertLog((re::internal *)7, v91, "assertion failure: '%s' (%s:line %i) Invalid count. index = %zu, count = %zu, array size_t size = %zu", "endIndexExclusive <= m_size", "slice", 512, 3, v18, v92);
    _os_crash();
    __break(1u);
    goto LABEL_122;
  }
  uint64_t v48 = *re::networkLogObjects((re *)v46);
  if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)sockaddr buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v8;
    _os_log_error_impl(&dword_228C70000, v48, OS_LOG_TYPE_ERROR, "Transport cannot receive on invalid channel id: %hhu", buf, 8u);
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
LABEL_85:
  uint64_t result = v97;
  if (v97 && v98) {
    return (*(uint64_t (**)(void))(*(void *)v97 + 40))();
  }
  return result;
}

void re::Transport::flushOutgoingData(re::Transport *this)
{
  unint64_t v1 = this;
  v4[5] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 584)) {
    this = (re::Transport *)re::Transport::queueThrottledPacketsForSend(this);
  }
  uint64_t v2 = *((void *)v1 + 41);
  uint64_t v3 = re::globalAllocators(this)[2];
  v4[0] = &unk_26DD364E0;
  v4[1] = v1;
  v4[3] = v3;
  void v4[4] = v4;
  (*(void (**)(uint64_t, void *))(*(void *)v2 + 16))(v2, v4);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v4);
  (*(void (**)(void))(**((void **)v1 + 41) + 24))(*((void *)v1 + 41));
  re::PacketPool::emitAriadneSignpost(*((os_unfair_lock_s **)v1 + 48));
}

uint64_t re::Transport::queueThrottledPacketsForSend(re::Transport *this)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  uint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 71) + 32))(*((void *)this + 71));
  unsigned int v4 = v2 - *((_DWORD *)this + 176);
  *((void *)this + 88) = v2;
  if (v4 <= 0x3E8)
  {
    uint64_t v5 = *((unsigned int *)this + 174);
    if (v5 >= 0x14)
    {
      re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) ", "m_index < kHistorySize", "measure", 1985);
      _os_crash();
      __break(1u);
    }
    *((_DWORD *)this + 175) = *((_DWORD *)this + 175) + v4 - *((_DWORD *)this + v5 + 154);
    *((_DWORD *)this + v5 + 154) = v4;
    int v6 = *((_DWORD *)this + 174);
    if ((v6 + 1) <= 0x13) {
      int v7 = v6 + 1;
    }
    else {
      int v7 = 0;
    }
    *((_DWORD *)this + 174) = v7;
  }
  unsigned int v8 = *((_DWORD *)this + 175);
  if (v8 < 0x14) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = v8 / 0x14;
  }
  uint64_t v10 = *((void *)this + 72);
  if (v10) {
    unint64_t v11 = *(void *)(v10 + 80) * v9 / 0x3E8uLL;
  }
  else {
    unint64_t v11 = -1;
  }
  uint64_t v12 = (char *)this + 120;
  uint64_t result = re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::DataArrayIterator((uint64_t)buf, (uint64_t)this + 120);
  int v62 = *(char **)buf;
  uint64_t v63 = *(void *)&buf[8];
  if ((re::Transport *)((char *)this + 120) == *(re::Transport **)buf
    && *(unsigned __int16 *)&buf[8] == 0xFFFFLL
    && (*(_DWORD *)&buf[8] & 0xFFFF0000) == 0xFFFF0000)
  {
    return result;
  }
  uint64_t v14 = 0;
  do
  {
    uint64_t v15 = re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v62);
    if (*(void *)(v15 + 96))
    {
      ++v14;
      *(_DWORD *)(v15 + 112) = 1023;
    }
    uint64_t result = (uint64_t)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v62);
  }
  while (v62 != v12 || (unsigned __int16)v63 != 0xFFFF || WORD1(v63) != 0xFFFF);
  if (!v14 || !v11) {
    return result;
  }
  do
  {
    uint64_t result = re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::DataArrayIterator((uint64_t)buf, (uint64_t)v12);
    int v62 = *(char **)buf;
    uint64_t v63 = *(void *)&buf[8];
    if (v12 == *(char **)buf
      && *(unsigned __int16 *)&buf[8] == 0xFFFFLL
      && (*(_DWORD *)&buf[8] & 0xFFFF0000) == 4294901760)
    {
      continue;
    }
    while (2)
    {
      uint64_t v20 = (re::NetworkFeatureFlags *)re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::operator*((unsigned __int16 *)&v62);
      if (!*((_DWORD *)v20 + 28)) {
        goto LABEL_65;
      }
      uint64_t v21 = (uint64_t)v20;
      uint64_t v22 = re::NetworkFeatureFlags::enableTransportLog(v20);
      if (v22)
      {
        unsigned __int16 v23 = *re::networkLogObjects((re *)v22);
        uint64_t v22 = os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG);
        if (v22)
        {
          uint64_t v53 = *(void *)(v21 + 24);
          if ((*(unsigned char *)(v21 + 16) & 1) == 0) {
            uint64_t v53 = v21 + 17;
          }
          uint64_t v54 = *((void *)this + 72);
          if (v54) {
            int v55 = *(_DWORD *)(v54 + 72);
          }
          else {
            int v55 = -1;
          }
          *(_DWORD *)sockaddr buf = 136315906;
          *(void *)&uint8_t buf[4] = v53;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v55;
          __int16 v65 = 1024;
          int v66 = v9;
          __int16 v67 = 2048;
          unint64_t v68 = v11;
          _os_log_debug_impl(&dword_228C70000, v23, OS_LOG_TYPE_DEBUG, "Trying to send packet for connection: %s, total available bandwidth: %d bps, time slice: %d ms, slice bandwidth: %llu bits\n", buf, 0x22u);
        }
      }
      uint64_t v24 = *(void *)(v21 + 96);
      if (v24) {
        BOOL v25 = v11 == 0;
      }
      else {
        BOOL v25 = 1;
      }
      if (v25) {
        goto LABEL_57;
      }
      uint64_t v61 = v14;
      uint64_t v26 = (uint64_t)v12;
      if (!*(_DWORD *)(v21 + 116))
      {
        uint64_t v47 = *((void *)this + 75);
        if (v47)
        {
          uint64_t v22 = re::DataArray<re::Connection>::handle(v26, v21);
          uint64_t v48 = *(void *)(v47 + 2296);
          if (v48)
          {
            uint64_t v49 = *(uint64_t **)(v47 + 2312);
            uint64_t v50 = 8 * v48;
            while (1)
            {
              uint64_t v51 = *v49;
              if (*(void *)(*v49 + 32) == v22) {
                break;
              }
              ++v49;
              v50 -= 8;
              if (!v50) {
                goto LABEL_44;
              }
            }
            id v52 = (id)(v51 + 8);
            *(_DWORD *)(v21 + 116) = *(_DWORD *)(v51 + 72);
          }
        }
      }
LABEL_44:
      unint64_t v27 = *(unsigned __int8 *)(v21 + 108);
      int v28 = *(_DWORD *)(v21 + 112);
      unsigned int v29 = v27 + 1;
      uint64_t v30 = 40 * v27;
      unsigned int v31 = *(unsigned __int8 *)(v21 + 108);
      unsigned int v32 = v31;
      while (1)
      {
        int v33 = 1 << (v32 % 0xA);
        if ((v33 & v28) != 0) {
          break;
        }
LABEL_48:
        ++v32;
        ++v29;
        v30 += 40;
        ++v27;
        if (v32 >= v31 + 10) {
          goto LABEL_56;
        }
      }
      uint64_t v34 = *(void *)(v21 + 40);
      if (!atomic_load(*(unint64_t **)(v34 + v30 - 400 * (v27 / 0xA) + 40)))
      {
        int v28 = *(_DWORD *)(v21 + 112) & (v33 ^ 0x3FF);
        *(_DWORD *)(v21 + 112) = v28;
        unsigned int v31 = *(unsigned __int8 *)(v21 + 108);
        goto LABEL_48;
      }
      unsigned int v60 = v32 % 0xA;
      unint64_t v36 = (re::NetworkFeatureFlags *)re::PacketQueue::dequeue((re::PacketQueue *)(v34 + v30 - 400 * (v27 / 0xA) + 32));
      unint64_t v37 = (unint64_t)v36;
      --*(void *)(v21 + 96);
      unint64_t v38 = (8 * *((_DWORD *)v36 + 6));
      BOOL v39 = v11 >= v38;
      unint64_t v40 = v11 - v38;
      if (v39) {
        unint64_t v11 = v40;
      }
      else {
        unint64_t v11 = 0;
      }
      uint64_t v41 = (re *)re::NetworkFeatureFlags::enableTransportLog(v36);
      if (v41)
      {
        os_log_t log = *re::networkLogObjects(v41);
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          if (*(void *)(v21 + 16)) {
            uint64_t v57 = *(void *)(v21 + 24);
          }
          else {
            uint64_t v57 = v21 + 17;
          }
          int v58 = *(_DWORD *)(v37 + 24);
          *(_DWORD *)sockaddr buf = 136315650;
          *(void *)&uint8_t buf[4] = v57;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v60;
          __int16 v65 = 1024;
          int v66 = v58;
        }
      }
      uint64_t v22 = re::Transport::queuePacketForProtocol((uint64_t)this, v37, v21, v60);
      *(unsigned char *)(v21 + 108) = v29 % 0xA;
LABEL_56:
      uint64_t v24 = *(void *)(v21 + 96);
      uint64_t v12 = (char *)v26;
      uint64_t v14 = v61;
LABEL_57:
      if (v24) {
        BOOL v42 = *(_DWORD *)(v21 + 112) == 0;
      }
      else {
        BOOL v42 = 1;
      }
      if (v42)
      {
        uint64_t v43 = (re *)re::NetworkFeatureFlags::enableTransportLog((re::NetworkFeatureFlags *)v22);
        if (v43)
        {
          uint64_t v44 = *re::networkLogObjects(v43);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
          {
            if (*(void *)(v21 + 16)) {
              uint64_t v56 = *(void *)(v21 + 24);
            }
            else {
              uint64_t v56 = v21 + 17;
            }
            *(_DWORD *)sockaddr buf = 136315138;
            *(void *)&uint8_t buf[4] = v56;
            _os_log_debug_impl(&dword_228C70000, v44, OS_LOG_TYPE_DEBUG, "No more send channels for connection: %s", buf, 0xCu);
          }
        }
        --v14;
        *(_DWORD *)(v21 + 112) = 0;
      }
LABEL_65:
      uint64_t result = (uint64_t)re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment(&v62);
      if (v62 != v12 || (unsigned __int16)v63 != 0xFFFF || WORD1(v63) != 0xFFFF) {
        continue;
      }
      break;
    }
  }
  while (v14 && v11);
  return result;
}

unint64_t re::Transport::connect(re::Transport *this, const re::Address *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v4 = re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::tryGet((uint64_t)this + 272, a2);
  if (v4) {
    return *(void *)v4;
  }
  unint64_t Connection = re::Transport::createConnection(this, a2);
  int v7 = re::DynamicString::DynamicString((re::DynamicString *)&v10, a2);
  unint64_t v12 = Connection;
  uint64_t v8 = re::globalAllocators(v7)[2];
  uint64_t v14 = v8;
  uint64_t v15 = 0;
  if (v8) {
    uint64_t v9 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v8 + 32))(v8, 56, 0);
  }
  else {
    uint64_t v9 = 0;
  }
  *uint64_t v9 = &unk_26DD36538;
  v9[1] = this;
  re::DynamicString::DynamicString((re::DynamicString *)(v9 + 2), (const re::DynamicString *)&v10);
  void v9[6] = v12;
  uint64_t v15 = v9;
  (*(void (**)(void, unsigned char *))(**((void **)this + 41) + 16))(*((void *)this + 41), v13);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v13);
  if (v10 && (v11 & 1) != 0) {
    (*(void (**)(void))(*(void *)v10 + 40))();
  }
  return Connection;
}

uint64_t re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::tryGet(uint64_t a1, re::Address *this)
{
  size_t v4 = re::Address::hash(this);
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==((uint64_t)this, v6 + 56 * v5 + 16))
  {
    uint64_t v5 = *(_DWORD *)(v6 + 56 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v6 + 56 * v5 + 48;
}

unint64_t re::Transport::createConnection(re::Transport *this, const re::Address *a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  size_t v4 = *re::networkLogObjects(this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 488)) {
      uint64_t v6 = (char *)*((void *)this + 62);
    }
    else {
      uint64_t v6 = (char *)this + 489;
    }
    if (*((void *)a2 + 1)) {
      int v7 = (char *)*((void *)a2 + 2);
    }
    else {
      int v7 = (char *)a2 + 9;
    }
    *(_DWORD *)sockaddr buf = 136315394;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v7;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Create connection(%s->%s)", buf, 0x16u);
  }
  int v8 = *((_DWORD *)this + 44);
  if ((v8 + 1) >> 24) {
    int v9 = 1;
  }
  else {
    int v9 = v8 + 1;
  }
  *((_DWORD *)this + 44) = v9;
  uint64_t v10 = *((unsigned __int16 *)this + 86);
  unint64_t v11 = *((unsigned __int16 *)this + 87);
  if (v10 != 0xFFFF || v11 != 0xFFFF)
  {
    if (*((void *)this + 17) > v11)
    {
      uint64_t v13 = (void *)(*((void *)this + 19) + 16 * v11);
      *(_DWORD *)(v13[1] + 4 * v10) = v9;
      uint64_t v14 = *v13 + 136 * v10;
      *((_DWORD *)this + 43) = *(_DWORD *)v14;
      goto LABEL_23;
    }
    long long v33 = 0u;
    long long v34 = 0u;
    long long v32 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_40;
  }
  if (*((_DWORD *)this + 42) >= *((_DWORD *)this + 41)) {
    re::DataArray<re::Connection>::allocBlock((void *)this + 15);
  }
  uint64_t v15 = *((void *)this + 17);
  unint64_t v11 = (unsigned __int16)(v15 - 1);
  if (!v15)
  {
LABEL_40:
    uint64_t v29 = 0;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v32 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v30) = 136315906;
    *(void *)((char *)&v30 + 4) = "operator[]";
    WORD6(v30) = 1024;
    HIWORD(v30) = 789;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_41:
    re::internal::assertLog((re::internal *)5, v5, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v10, v29, v30);
    _os_crash();
    __break(1u);
  }
  uint64_t v10 = *((unsigned int *)this + 42);
  if (v10 >= 0x10000) {
    goto LABEL_41;
  }
  uint64_t v16 = (void *)(*((void *)this + 19) + 16 * v11);
  *((_DWORD *)this + 42) = v10 + 1;
  *(_DWORD *)(v16[1] + 4 * v10) = *((_DWORD *)this + 44);
  uint64_t v14 = *v16 + 136 * v10;
LABEL_23:
  ++*((_DWORD *)this + 40);
  *(_DWORD *)uint64_t v14 = 0;
  re::DynamicString::DynamicString((re::DynamicString *)(v14 + 8), a2);
  *(_OWORD *)(v14 + 68) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  *(_OWORD *)(v14 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0u;
  *(void *)(v14 + 84) = 0x7FFFFFFFLL;
  *(void *)(v14 + 96) = 0;
  *(_DWORD *)(v14 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0;
  *(unsigned char *)(v14 + 108) = 0;
  *(void *)(v14 + 112) = 0;
  *(unsigned char *)(v14 + 120) = 0;
  *(void *)(v14 + 128) = 0x8000000000000000;
  unint64_t v17 = (v11 << 16) | ((unint64_t)(*((_DWORD *)this + 44) & 0xFFFFFF) << 32) | v10;
  size_t v18 = re::Address::hash(a2);
  size_t v19 = v18;
  if (!*((void *)this + 34))
  {
    LODWORD(v20) = 0;
    goto LABEL_30;
  }
  unint64_t v20 = v18 % *((unsigned int *)this + 74);
  uint64_t v21 = *(unsigned int *)(*((void *)this + 35) + 4 * v20);
  if (v21 == 0x7FFFFFFF)
  {
LABEL_30:
    uint64_t v23 = *((unsigned int *)this + 77);
    if (v23 == 0x7FFFFFFF)
    {
      uint64_t v23 = *((unsigned int *)this + 76);
      int v24 = v23;
      if (v23 == *((_DWORD *)this + 74))
      {
        re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::setCapacity((uint64_t)this + 272, 2 * *((_DWORD *)this + 75));
        LODWORD(v20) = v19 % *((unsigned int *)this + 74);
        int v24 = *((_DWORD *)this + 76);
      }
      *((_DWORD *)this + 76) = v24 + 1;
      uint64_t v25 = *((void *)this + 36);
      int v26 = *(_DWORD *)(v25 + 56 * v23 + 8);
    }
    else
    {
      uint64_t v25 = *((void *)this + 36);
      int v26 = *(_DWORD *)(v25 + 56 * v23 + 8);
      *((_DWORD *)this + 77) = v26 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v25 + 56 * v23 + 8) = v26 | 0x80000000;
    *(_DWORD *)(*((void *)this + 36) + 56 * v23 + 8) = *(_DWORD *)(*((void *)this + 36) + 56 * v23 + 8) & 0x80000000 | *(_DWORD *)(*((void *)this + 35) + 4 * v20);
    *(void *)(*((void *)this + 36) + 56 * v23) = v19;
    re::DynamicString::DynamicString((re::DynamicString *)(*((void *)this + 36) + 56 * v23 + 16), a2);
    *(void *)(*((void *)this + 36) + 56 * v23 + 48) = v17;
    *(_DWORD *)(*((void *)this + 35) + 4 * v20) = v23;
    ++*((_DWORD *)this + 75);
    ++*((_DWORD *)this + 78);
    goto LABEL_36;
  }
  uint64_t v22 = *((void *)this + 36);
  while (!re::DynamicString::operator==((uint64_t)a2, v22 + 56 * v21 + 16))
  {
    uint64_t v21 = *(_DWORD *)(v22 + 56 * v21 + 8) & 0x7FFFFFFF;
    if (v21 == 0x7FFFFFFF) {
      goto LABEL_30;
    }
  }
LABEL_36:
  uint64_t v27 = *((void *)this + 70);
  if (v27) {
    (*(void (**)(uint64_t, re::Transport *, unint64_t))(*(void *)v27 + 32))(v27, this, v17);
  }
  return v17;
}

void re::Transport::disconnect(re::Transport *this, unint64_t a2, int a3)
{
  uint64_t v6 = (_anonymous_namespace_ *)re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  if (v6)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    re::DynamicString::setCapacity(&v9, 0);
    int v8 = 1;
    int v13 = a3;
    re::Transport::connectionStateEvent((uint64_t)this, a2, &v8);
    if (v9)
    {
      if (v10) {
        (*(void (**)(void))(*v9 + 40))();
      }
    }
  }
  else
  {
    int v7 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v8) = 0;
      _os_log_debug_impl(&dword_228C70000, v7, OS_LOG_TYPE_DEBUG, "Attempt to disconnect connection that does not exist. This can happen if connection broke right before this request.", (uint8_t *)&v8, 2u);
    }
  }
}

uint64_t re::DataArray<re::Connection>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (unsigned int v3 = *(_DWORD *)(a1 + 44)) : (unsigned int v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((uint64_t v4 = *(void *)(a1 + 32),
          (int v5 = *(_DWORD *)(*(void *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (BOOL v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (BOOL v6 = 0),
         v6)))
  {
    return *(void *)(v4 + 16 * WORD1(a2)) + 136 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

void re::Transport::connectionStateEvent(uint64_t a1, unint64_t a2, int *a3)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v6 = a1 + 120;
  int v7 = (re *)re::DataArray<re::Connection>::get(a1 + 120, a2);
  int v8 = *(_DWORD *)v7;
  if (*(_DWORD *)v7 != 2)
  {
    if (v8 != 1)
    {
      if (v8) {
        return;
      }
      switch(*a3)
      {
        case 0:
          re::Transport::connectionSetState(a1, a2, 1);
          int v9 = ***(void (****)(void))(a1 + 608);
          v9();
          return;
        case 1:
          re::Transport::connectionSetState(a1, a2, 2);
          return;
        case 2:
          goto LABEL_21;
        case 3:
          goto LABEL_20;
        default:
          uint64_t v21 = *re::networkLogObjects(v7);
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          int v26 = *a3;
          LODWORD(v30) = 67109120;
          HIDWORD(v30) = v26;
          uint64_t v23 = "Unexpected event: %d in 'Pending' state.";
          break;
      }
LABEL_32:
      _os_log_impl(&dword_228C70000, v21, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v30, 8u);
      return;
    }
    uint64_t v16 = (re *)re::DataArray<re::Connection>::get(v6, a2);
    int v17 = *a3;
    if (*a3 == 3)
    {
      uint64_t v16 = (re *)(*(uint64_t (**)(void, unint64_t, void))(**(void **)(a1 + 608) + 16))(*(void *)(a1 + 608), a2, *((unsigned __int8 *)a3 + 40));
    }
    else if (v17 != 2)
    {
      if (v17 != 1)
      {
        uint64_t v21 = *re::networkLogObjects(v16);
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v25 = *a3;
        LODWORD(v30) = 67109120;
        HIDWORD(v30) = v25;
        uint64_t v23 = "Unexpected event: %d in 'Active' state.";
        goto LABEL_32;
      }
      uint64_t v18 = *((void *)v16 + 5);
      if (v18)
      {
        id v19 = (id)(v18 + 8);
        int v20 = a3[11];
        uint64_t v16 = (re *)(id)(v18 + 8);
      }
      else
      {
        int v20 = a3[11];
      }
      uint64_t v33 = re::globalAllocators(v16)[2];
      uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v33 + 32))(v33, 32, 0);
      *(void *)uint64_t v27 = &unk_26DD365E8;
      *(void *)(v27 + 8) = a1;
      *(void *)(v27 + 16) = v18;
      *(unsigned char *)(v27 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v20 != 0;
      long long v34 = (void **)v27;
      (*(void (**)(void, void **))(**(void **)(a1 + 328) + 16))(*(void *)(a1 + 328), &v30);
      re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&v30);
      re::Transport::connectionSetState(a1, a2, 2);
      uint64_t v29 = re::globalAllocators(v28)[2];
      unint64_t v32 = a2;
      uint64_t v33 = v29;
      long long v30 = &unk_26DD36640;
      uint64_t v31 = a1;
      long long v34 = &v30;
      (*(void (**)(void, void **))(**(void **)(a1 + 320) + 16))(*(void *)(a1 + 320), &v30);
      re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&v30);
      if (v18)
      {
        uint64_t v15 = (void *)(v18 + 8);
        goto LABEL_39;
      }
      return;
    }
    uint64_t v24 = re::globalAllocators(v16)[2];
    unint64_t v32 = a2;
    uint64_t v33 = v24;
    long long v30 = &unk_26DD36698;
    uint64_t v31 = a1;
    long long v34 = &v30;
    (*(void (**)(void, void **))(**(void **)(a1 + 320) + 16))(*(void *)(a1 + 320), &v30);
    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&v30);
    return;
  }
  int v10 = *a3;
  if (*a3 == 3)
  {
LABEL_20:
    (*(void (**)(void, unint64_t, void))(**(void **)(a1 + 608) + 16))(*(void *)(a1 + 608), a2, *((unsigned __int8 *)a3 + 40));
    goto LABEL_21;
  }
  if (v10 == 2)
  {
LABEL_21:
    re::Transport::destroyConnection((re::Transport *)a1, a2);
    return;
  }
  if (v10)
  {
    uint64_t v21 = *re::networkLogObjects(v7);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v22 = *a3;
    LODWORD(v30) = 67109120;
    HIDWORD(v30) = v22;
    uint64_t v23 = "Unexpected event: %d in 'Closing' state.";
    goto LABEL_32;
  }
  uint64_t v11 = (re *)re::DataArray<re::Connection>::get(v6, a2);
  unint64_t v12 = *((void *)v11 + 5);
  if (v12)
  {
    id v13 = (id)(v12 + 8);
    uint64_t v11 = (re *)(id)(v12 + 8);
  }
  uint64_t v14 = re::globalAllocators(v11)[2];
  unint64_t v32 = v12;
  uint64_t v33 = v14;
  long long v30 = &unk_26DD366F0;
  uint64_t v31 = a1;
  long long v34 = &v30;
  (*(void (**)(void, void **))(**(void **)(a1 + 328) + 16))(*(void *)(a1 + 328), &v30);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&v30);
  if (v12)
  {
    uint64_t v15 = (void *)(v12 + 8);
LABEL_39:
  }
}

unint64_t re::DataArray<re::Connection>::handle(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    int v3 = 0;
    uint64_t v4 = 0;
    int v5 = (void *)(*(void *)(a1 + 32) + 8);
    while (v4 != 0x10000)
    {
      uint64_t v6 = a2 - *(v5 - 1);
      if (v6 >= -135)
      {
        unint64_t v7 = 0xF0F0F0F0F0F0F0F1 * (v6 >> 3);
        if (v7 < *(unsigned int *)(a1 + 44)) {
          goto LABEL_8;
        }
      }
      ++v4;
      v5 += 2;
      v3 += 0x10000;
      if (v2 == v4) {
        goto LABEL_7;
      }
    }
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) blockIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 692, 0x10000);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_7:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) element isn't in data array", "!\"Unreachable code\"", "handle", 707);
    _os_crash();
    __break(1u);
LABEL_8:
    if (v7 < 0x10000) {
      return v3 & 0xFFFF0000 | ((unint64_t)(*(_DWORD *)(*v5 + 4 * v7) & 0xFFFFFF) << 32) | v7;
    }
  }
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) arrayIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 700, v7);
  unint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::Transport::queuePacketForProtocol(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = a4;
  uint64_t v8 = a4;
  uint64_t v45 = *MEMORY[0x263EF8340];
  unint64_t v9 = re::DataArray<re::Connection>::handle(a1 + 120, a3);
  unsigned int v10 = *(_DWORD *)(a3 + 104) + 1;
  *(_DWORD *)(a3 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = v10;
  uint64_t v11 = *(void *)(a2 + 8) + 1;
  *(void *)sockaddr buf = &unk_26DD35FA8;
  *(void *)&uint8_t buf[8] = v11;
  *(_DWORD *)&uint8_t buf[16] = 4;
  unsigned char buf[20] = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)buf, v10, 0x10u);
  unint64_t v12 = *(uint64_t **)(a1 + 560);
  if (v12)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, unint64_t, uint64_t, void, unint64_t))(*v12 + 48))(v12, a1, v9, v8, *(unsigned int *)(a2 + 32), a2);
    if (!result) {
      return result;
    }
    a2 = result;
    *(void *)sockaddr buf = *(void *)(result + 8) + 1;
    *(_DWORD *)&uint8_t buf[8] = 4;
    unsigned char buf[12] = 0;
    *(void *)&uint8_t buf[16] = 0;
    uint64_t v43 = 0;
    unsigned int v41 = 0;
    unint64_t v12 = re::BitReader::readUInt32Bits((uint64_t *)buf, 0x20u, &v41);
  }
  unint64_t v14 = *(void *)(a3 + 16);
  if (v14) {
    unint64_t v15 = v14 >> 1;
  }
  else {
    unint64_t v15 = v14 >> 1;
  }
  if (v4 <= 9 && v15)
  {
    uint64_t v16 = *(void *)(a1 + 576);
    if (v16)
    {
      int v17 = (re *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v16 + 32))(v16, a2);
      if (v17)
      {
        if (v17 == 1)
        {
          uint64_t v18 = *re::networkLogObjects(v17);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
          {
            if (*(void *)(a3 + 16)) {
              uint64_t v19 = *(void *)(a3 + 24);
            }
            else {
              uint64_t v19 = a3 + 17;
            }
            *(_DWORD *)sockaddr buf = 136315394;
            *(void *)&uint8_t buf[4] = v19;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v8;
            _os_log_impl(&dword_228C70000, v18, OS_LOG_TYPE_INFO, "Stats filter triggered event for {destination: %s, channel: %u}", buf, 0x12u);
          }
          goto LABEL_18;
        }
        int v20 = *re::networkLogObjects(v17);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          if (*(void *)(a3 + 16)) {
            uint64_t v37 = *(void *)(a3 + 24);
          }
          else {
            uint64_t v37 = a3 + 17;
          }
          *(_DWORD *)sockaddr buf = 136315394;
          *(void *)&uint8_t buf[4] = v37;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v8;
          unint64_t v38 = "Stats filter returned error for {destination: %s, channel: %u}";
LABEL_57:
          _os_log_error_impl(&dword_228C70000, v20, OS_LOG_TYPE_ERROR, v38, buf, 0x12u);
        }
      }
    }
  }
  else
  {
    int v20 = *re::networkLogObjects((re *)v12);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      if (*(void *)(a3 + 16)) {
        uint64_t v40 = *(void *)(a3 + 24);
      }
      else {
        uint64_t v40 = a3 + 17;
      }
      *(_DWORD *)sockaddr buf = 136315394;
      *(void *)&uint8_t buf[4] = v40;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      unint64_t v38 = "Cannot collect stats for invalid connection {address: %s, channel: %d}";
      goto LABEL_57;
    }
  }
LABEL_18:
  if (*(unsigned char *)(a1 + 584))
  {
    unsigned int v21 = *(_DWORD *)(a3 + 116);
    BOOL v22 = v21 == 0;
    int v23 = (v21 >> 4) & 1;
    if (v22) {
      int v23 = 1;
    }
    if (v23) {
      LODWORD(v8) = 0;
    }
    else {
      LODWORD(v8) = v4;
    }
  }
  uint64_t v25 = *(void *)(a3 + 40);
  uint64_t v24 = a3 + 40;
  uint64_t v26 = v25 + 40 * v8;
  atomic_fetch_add_explicit((atomic_uint *volatile)(v26 + 936), *(_DWORD *)(a2 + 24), memory_order_release);
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 944), *(unsigned int *)(a2 + 28), memory_order_release);
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 928), 1uLL, memory_order_release);
  atomic_store(a2, *(unint64_t **)(v26 + 912));
  *(void *)(v26 + 912) = a2;
  ++*(_DWORD *)(*(void *)v24 + 1712);
  if (!*(unsigned char *)(v24 + 80))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 184));
    uint64_t v27 = *(void *)(a1 + 224);
    uint64_t v28 = *(void *)(a1 + 208);
    if (v28)
    {
      uint64_t v29 = 8 * v28;
      long long v30 = *(void **)(a1 + 224);
      while (*v30 != *(void *)v24)
      {
        ++v30;
        v29 -= 8;
        if (!v29)
        {
          long long v30 = (void *)(v27 + 8 * v28);
          break;
        }
      }
    }
    else
    {
      long long v30 = *(void **)(a1 + 224);
    }
    if (v28 == ((uint64_t)v30 - v27) >> 3) {
      re::DynamicArray<re::SharedPtr<re::ProtocolHandle>>::add((_anonymous_namespace_ *)(a1 + 192), (uint64_t *)v24);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 184));
  }
  uint64_t result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
  if (result)
  {
    uint64_t v31 = *(re::Session **)(a1 + 600);
    if (v31)
    {
      re::Session::peerID(v31);
      uint64_t v32 = *(void *)(a1 + 600);
      uint64_t v33 = *(void *)(v32 + 2296);
      if (v33)
      {
        long long v34 = *(uint64_t **)(v32 + 2312);
        uint64_t v35 = 8 * v33;
        while (1)
        {
          uint64_t v36 = *v34;
          if (*(void *)(*v34 + 32) == v9) {
            break;
          }
          ++v34;
          v35 -= 8;
          if (!v35) {
            goto LABEL_49;
          }
        }
        id v39 = (id)(v36 + 8);
      }
    }
LABEL_49:
    uint64_t result = re::internal::enableSignposts(0, 0);
    if (result)
    {
      uint64_t result = re::internal::enableHighFrequencyNetworkTracing(0, 0);
      if (result) {
        return kdebug_trace();
      }
    }
  }
  return result;
}

void re::Transport::cleanupPendingQueues(re::PacketPool **a1, uint64_t a2)
{
  if (a2)
  {
    for (uint64_t i = 0; i != 10; ++i)
    {
      uint64_t v5 = re::PacketQueue::dequeue((re::PacketQueue *)(a2 + 40 * i + 32));
      if (v5)
      {
        uint64_t v6 = (re::Packet *)v5;
        do
        {
          re::PacketPool::free(a1[48], v6);
          uint64_t v6 = (re::Packet *)re::PacketQueue::dequeue((re::PacketQueue *)(a2 + 40 * i + 32));
        }
        while (v6);
      }
      uint64_t v7 = re::PacketQueue::dequeue((re::PacketQueue *)(a2 + 40 * i + 912));
      if (v7)
      {
        uint64_t v8 = (re::Packet *)v7;
        do
        {
          re::PacketPool::free(a1[48], v8);
          uint64_t v8 = (re::Packet *)re::PacketQueue::dequeue((re::PacketQueue *)(a2 + 40 * i + 912));
        }
        while (v8);
      }
      uint64_t v9 = re::PacketQueue::dequeue((re::PacketQueue *)(a2 + 40 * i + 1312));
      if (v9)
      {
        unsigned int v10 = (re::Packet *)v9;
        do
        {
          re::PacketPool::free(a1[48], v10);
          unsigned int v10 = (re::Packet *)re::PacketQueue::dequeue((re::PacketQueue *)(a2 + 40 * i + 1312));
        }
        while (v10);
      }
    }
  }
  else
  {
    uint64_t v11 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v12 = 0;
      _os_log_error_impl(&dword_228C70000, v11, OS_LOG_TYPE_ERROR, "Cannot cleanup pending queues for invalid handle: nil", v12, 2u);
    }
  }
}

uint64_t re::Transport::writePacketHeader(uint64_t a1, unsigned __int8 *a2, char a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  *(unsigned char *)(v5 + 2) = 0;
  *(_WORD *)uint64_t v5 = 0;
  uint64_t v6 = *(void *)(a1 + 8);
  v8[0] = &unk_26DD35FA8;
  v8[1] = v6;
  int v9 = 3;
  char v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  re::BitWriter::writeUInt32Bits((uint64_t)v8, *a2, 1u);
  uint64_t result = re::BitWriter::writeUInt32Bits((uint64_t)v8, a2[1], 1u);
  if ((a3 & 8) != 0)
  {
    re::BitWriter::writeUInt32Bits((uint64_t)v8, a2[2], 1u);
    re::BitWriter::writeUInt32Bits((uint64_t)v8, 0, 1u);
    re::BitWriter::writeUInt32Bits((uint64_t)v8, a2[3] + 1, 4u);
    return re::BitWriter::writeUInt32Bits((uint64_t)v8, *((unsigned __int16 *)a2 + 2), 0x10u);
  }
  return result;
}

uint64_t *re::Transport::readPacketHeaderFromBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a2;
  int v8 = 3;
  char v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  re::BitReader::readUInt32Bits(&v7, 1u, &v12);
  *(unsigned char *)a4 = v12 != 0;
  unsigned int v12 = 0;
  re::BitReader::readUInt32Bits(&v7, 1u, &v12);
  *(unsigned char *)(a4 + 1) = v12 != 0;
  unsigned int v12 = 0;
  re::BitReader::readUInt32Bits(&v7, 1u, &v12);
  *(unsigned char *)(a4 + 2) = v12 != 0;
  re::BitReader::readUInt32Bits(&v7, 1u, &v12);
  unsigned int v6 = 0;
  re::BitReader::readUInt32Bits(&v7, 4u, &v6);
  if (v6) {
    *(unsigned char *)(a4 + 3) = v6 - 1;
  }
  unsigned int v12 = 0;
  uint64_t result = re::BitReader::readUInt32Bits(&v7, 0x10u, &v12);
  *(_WORD *)(a4 + 4) = v12;
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::SharedPtr<re::ProtocolHandle>>::add(_anonymous_namespace_ *result, uint64_t *a2)
{
  int v3 = result;
  unint64_t v5 = *((void *)result + 1);
  unint64_t v4 = *((void *)result + 2);
  if (v4 >= v5)
  {
    unint64_t v6 = v4 + 1;
    if (v5 < v4 + 1)
    {
      if (*(void *)result)
      {
        unint64_t v7 = 2 * v5;
        if (!v5) {
          unint64_t v7 = 8;
        }
        if (v7 <= v6) {
          unint64_t v8 = v6;
        }
        else {
          unint64_t v8 = v7;
        }
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(result, v8);
      }
      else
      {
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::SyncObject>>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    unint64_t v4 = *((void *)v3 + 2);
  }
  uint64_t v9 = *a2;
  *(void *)(*((void *)v3 + 4) + 8 * v4) = *a2;
  if (v9)
  {
    uint64_t result = (_anonymous_namespace_ *)(id)(v9 + 8);
    unint64_t v4 = *((void *)v3 + 2);
  }
  *((void *)v3 + 2) = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::Transport::send(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, int a5, int a6, char a7)
{
  unint64_t v7 = a3;
  uint64_t v76 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a3 + 24) >> 27)
  {
    uint64_t v9 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v23 = *(_DWORD *)(v7 + 24);
      *(_DWORD *)sockaddr buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v23;
      *(_WORD *)&uint8_t buf[8] = 2048;
      *(void *)&buf[10] = 0x8000000;
      _os_log_error_impl(&dword_228C70000, v9, OS_LOG_TYPE_ERROR, "Outbound message length (%u) exceeds kMaxSupportedMessageSize (%zu), message will be discarded.", buf, 0x12u);
    }
    re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
    return 4;
  }
  if (a4 >= 0xA)
  {
    uint64_t v11 = *re::networkLogObjects((re *)a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      _os_log_error_impl(&dword_228C70000, v11, OS_LOG_TYPE_ERROR, "Attempt to send data to an invalid channel", buf, 2u);
    }
    re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
    return 1;
  }
  uint64_t v16 = (re *)re::DataArray<re::Connection>::tryGet(a1 + 120, a2);
  if (v16)
  {
    uint64_t v17 = (uint64_t)v16;
    if (*(_DWORD *)v16 == 1)
    {
      if (*((unsigned char *)v16 + 120))
      {
        v18.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        if (v18.__d_.__rep_ >= *(void *)(v17 + 128))
        {
          uint64_t v19 = *re::networkLogObjects((re *)v18.__d_.__rep_);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v17 + 16)) {
              uint64_t v20 = *(void *)(v17 + 24);
            }
            else {
              uint64_t v20 = v17 + 17;
            }
            *(_DWORD *)sockaddr buf = 136315394;
            *(void *)&uint8_t buf[4] = v20;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = a4;
            _os_log_impl(&dword_228C70000, v19, OS_LOG_TYPE_DEFAULT, "Sending data on paused connection '%s', channel %d", buf, 0x12u);
          }
          v18.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
          *(void *)(v17 + 128) = v18.__d_.__rep_ + 2000000000;
        }
        if (atomic_load_explicit((atomic_ullong *volatile)(*(void *)(v17 + 40) + 944), memory_order_acquire) >= 0x20000001)
        {
          uint64_t v24 = *re::networkLogObjects((re *)v18.__d_.__rep_);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            if (*(unsigned char *)(v17 + 16)) {
              uint64_t v63 = *(void *)(v17 + 24);
            }
            else {
              uint64_t v63 = v17 + 17;
            }
            unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(*(void *)(v17 + 40) + 944), memory_order_acquire);
            *(_DWORD *)sockaddr buf = 136315394;
            *(void *)&uint8_t buf[4] = v63;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = explicit;
            _os_log_error_impl(&dword_228C70000, v24, OS_LOG_TYPE_ERROR, "Send queue on connection '%s' has overflowed (%zu bytes), disconnecting", buf, 0x16u);
          }
          (*(void (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 608) + 16))(*(void *)(a1 + 608), a2, 4);
          re::Transport::disconnect((re::Transport *)a1, a2, 1);
        }
        if (atomic_load_explicit((atomic_ullong *volatile)(*(void *)(v17 + 40) + 944), memory_order_acquire) >= 0x8000001)
        {
          uint64_t v25 = *re::networkLogObjects((re *)v18.__d_.__rep_);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v17 + 16)) {
              uint64_t v26 = *(void *)(v17 + 24);
            }
            else {
              uint64_t v26 = v17 + 17;
            }
            unint64_t v27 = atomic_load_explicit((atomic_ullong *volatile)(*(void *)(v17 + 40) + 944), memory_order_acquire);
            *(_DWORD *)sockaddr buf = 136315394;
            *(void *)&uint8_t buf[4] = v26;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v27;
            _os_log_impl(&dword_228C70000, v25, OS_LOG_TYPE_DEFAULT, "Send queue on connection '%s' is very large (%zu bytes)", buf, 0x16u);
          }
          (*(void (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 608) + 16))(*(void *)(a1 + 608), a2, 3);
        }
      }
      if (*(unsigned char *)(v17 + 16)) {
        uint64_t v28 = *(void *)(v17 + 24);
      }
      else {
        uint64_t v28 = v17 + 17;
      }
      uint64_t v29 = *(unsigned __int8 *)(a1 + 392);
      if (v29 != 4 && a6)
      {
        uint64_t v31 = re::PacketPool::allocate(*(re::PacketPool **)(a1 + 384), (*(_DWORD *)(v7 + 28) + 3));
        re::Packet::offsetBy((uint64_t)v31, 3);
        uint64_t v32 = *((void *)v31 + 1);
        *(unsigned char *)(v32 + 2) = 0;
        *(_WORD *)uint64_t v32 = 0;
        size_t v33 = compression_encode_scratch_buffer_size(v30);
        if (*(void *)(a1 + 408) < v33) {
          re::DynamicArray<unsigned char>::resize(a1 + 400, v33);
        }
        size_t v34 = *(unsigned int *)(v7 + 24);
        if (v34 <= 4) {
          size_t v35 = 0;
        }
        else {
          size_t v35 = v34 - 4;
        }
        size_t v36 = compression_encode_buffer((uint8_t *)(*((void *)v31 + 2) + 4), v35, *(const uint8_t **)(v7 + 16), v34, *(void **)(a1 + 432), v30);
        if (v36)
        {
          int v37 = v36;
          uint64_t v39 = *((void *)v31 + 1);
          unint64_t v38 = (_DWORD *)*((void *)v31 + 2);
          *((_DWORD *)v31 + 7) += v38 - v39;
          *unint64_t v38 = *(_DWORD *)(v7 + 24);
          *((void *)v31 + 2) = v39;
          char v70 = 1;
          *(_WORD *)sockaddr buf = 1;
          buf[2] = a5 == 0;
          buf[3] = a4;
          *(_WORD *)&uint8_t buf[4] = 0;
          re::Transport::writePacketHeader((uint64_t)v31, buf, a7);
          *((_DWORD *)v31 + 6) = v37 + 7;
          re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
          unint64_t v7 = (unint64_t)v31;
          goto LABEL_48;
        }
        re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v31);
      }
      *(_DWORD *)(v7 + 28) += 3;
      *(void *)(v7 + 16) = *(void *)(v7 + 8);
      *(_WORD *)sockaddr buf = 0;
      buf[2] = a5 == 0;
      buf[3] = a4;
      *(_WORD *)&uint8_t buf[4] = 0;
      re::Transport::writePacketHeader(v7, buf, a7);
      char v70 = 0;
      *(_DWORD *)(v7 + 24) += 3;
LABEL_48:
      *(_DWORD *)(v7 + 32) = a5;
      if (*(unsigned char *)(a1 + 585))
      {
        unsigned int v68 = (unsigned __int16)re::Transport::generateNextPacketSeqNumber(void)::packetSeqNumber;
        char v69 = a7;
        ++re::Transport::generateNextPacketSeqNumber(void)::packetSeqNumber;
        unsigned int v40 = *(_DWORD *)(v7 + 24);
        int v41 = 2;
        if (v40 >= 0x80)
        {
          unint64_t v42 = *(unsigned int *)(v7 + 24);
          do
          {
            unint64_t v43 = v42 >> 14;
            v42 >>= 7;
            v41 += 2;
          }
          while (v43);
        }
        if (v40)
        {
          unsigned int v44 = 0;
          unsigned int v45 = 0;
          unsigned int v66 = *(_DWORD *)(a1 + 512) - v41 - 13;
          unsigned int v65 = (v40 + v66 - 1) / v66;
          uint64_t v67 = v17;
          do
          {
            unint64_t v46 = *(unsigned int *)(v7 + 24);
            int v47 = 1;
            if (v46 >= 0x80)
            {
              do
              {
                ++v47;
                unint64_t v48 = v46 >> 14;
                v46 >>= 7;
              }
              while (v48);
            }
            int v49 = 1;
            if (v44 >= 0x80)
            {
              unint64_t v50 = v44;
              do
              {
                ++v49;
                unint64_t v51 = v50 >> 14;
                v50 >>= 7;
              }
              while (v51);
            }
            if (v40 >= v66) {
              uint64_t v52 = v66;
            }
            else {
              uint64_t v52 = v40;
            }
            int v53 = v52 + v47 + v49;
            int v54 = v53 + 10;
            unsigned int v55 = v53 + 13;
            uint64_t v56 = re::PacketPool::allocate(*(re::PacketPool **)(a1 + 384), (v53 + 13));
            re::Packet::offsetBy((uint64_t)v56, 3);
            uint64_t v57 = *((void *)v56 + 1);
            *(unsigned char *)(v57 + 2) = 0;
            *(_WORD *)uint64_t v57 = 0;
            uint64_t v58 = *((void *)v56 + 2);
            *(void *)sockaddr buf = &unk_26DD35FA8;
            *(void *)&uint8_t buf[8] = v58;
            *(_DWORD *)&uint8_t buf[16] = v54;
            unsigned char buf[20] = 0;
            uint64_t v74 = 0;
            uint64_t v75 = 0;
            re::BitWriter::writeUInt32Bits((uint64_t)buf, v68, 0x10u);
            re::BitWriter::writeUInt32Bits((uint64_t)buf, v45, 0x20u);
            re::BitWriter::writeUInt32Bits((uint64_t)buf, v65, 0x20u);
            uint64_t v72 = 0;
            re::BiasedVLQ::write((re::BiasedVLQ *)&v72, (re::BitWriter *)buf, *(unsigned int *)(v7 + 24));
            uint64_t v72 = 0;
            re::BiasedVLQ::write((re::BiasedVLQ *)&v72, (re::BitWriter *)buf, v44);
            re::BitWriter::writeData((re::BitWriter *)buf, (const void *)(*(void *)(v7 + 8) + v44), v52);
            *((_DWORD *)v56 + 7) += 3;
            *((void *)v56 + 2) = *((void *)v56 + 1);
            *((_DWORD *)v56 + 8) = *(_DWORD *)(v7 + 32);
            LOBYTE(v72) = v70;
            BYTE1(v72) = 1;
            BYTE2(v72) = *(_DWORD *)(v7 + 32) == 0;
            BYTE3(v72) = a4;
            WORD2(v72) = 0;
            re::Transport::writePacketHeader((uint64_t)v56, (unsigned __int8 *)&v72, v69);
            *((_DWORD *)v56 + 6) = v55;
            if (*(unsigned char *)(a1 + 584))
            {
              uint64_t v59 = v67;
              uint64_t v60 = *(void *)(v67 + 40) + 40 * a4;
              atomic_fetch_add_explicit((atomic_uint *volatile)(v60 + 56), v55, memory_order_release);
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v60 + 64), *((unsigned int *)v56 + 7), memory_order_release);
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v60 + 48), 1uLL, memory_order_release);
              atomic_store((unint64_t)v56, *(unint64_t **)(v60 + 32));
              *(void *)(v60 + 32) = v56;
              ++*(void *)(v59 + 96);
            }
            else
            {
              re::Transport::queuePacketForProtocol(a1, (unint64_t)v56, v67, a4);
            }
            v44 += v52;
            ++v45;
            v40 -= v52;
          }
          while (v40);
        }
        re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
      }
      else
      {
        if (*(unsigned char *)(a1 + 584))
        {
          uint64_t result = 0;
          uint64_t v61 = *(void *)(v17 + 40) + 40 * a4;
          atomic_fetch_add_explicit((atomic_uint *volatile)(v61 + 56), *(_DWORD *)(v7 + 24), memory_order_release);
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v61 + 64), *(unsigned int *)(v7 + 28), memory_order_release);
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v61 + 48), 1uLL, memory_order_release);
          atomic_store(v7, *(unint64_t **)(v61 + 32));
          *(void *)(v61 + 32) = v7;
          ++*(void *)(v17 + 96);
          return result;
        }
        re::Transport::queuePacketForProtocol(a1, v7, v17, a4);
      }
      return 0;
    }
    BOOL v22 = *re::networkLogObjects(v16);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      if (*(unsigned char *)(v17 + 16)) {
        uint64_t v62 = *(void *)(v17 + 24);
      }
      else {
        uint64_t v62 = v17 + 17;
      }
      *(_DWORD *)sockaddr buf = 136315138;
      *(void *)&uint8_t buf[4] = v62;
      _os_log_error_impl(&dword_228C70000, v22, OS_LOG_TYPE_ERROR, "Attempt to send data to connection '%s' that is disconnected", buf, 0xCu);
    }
    re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
    return 3;
  }
  else
  {
    unsigned int v21 = *re::networkLogObjects(0);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)sockaddr buf = 0;
      _os_log_error_impl(&dword_228C70000, v21, OS_LOG_TYPE_ERROR, "Attempt to send data to connection that does not exist", buf, 2u);
    }
    re::PacketPool::free(*(re::PacketPool **)(a1 + 384), (re::Packet *)v7);
    return 2;
  }
}

double anonymous namespace'::logDebugConnectionStatsForHandle(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  v6.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
  unint64_t v8 = v6.__d_.__rep_ - *(void *)(a1 + 1720);
  if (v8 >= 0x1389)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1760));
    int v9 = *(_DWORD *)(a1 + 1744);
    int v10 = *(_DWORD *)(a1 + 1748);
    int v11 = *(_DWORD *)(a1 + 1752);
    int v12 = *(_DWORD *)(a1 + 1756);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 1760));
    unint64_t v14 = *re::networkLogObjects(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *(_DWORD *)(a1 + 1712);
      uint64_t v16 = "onReceive";
      int v17 = *(_DWORD *)(a1 + 1716);
      if (a3) {
        uint64_t v16 = "onSend";
      }
      int v18 = 136317186;
      uint64_t v19 = a2;
      __int16 v20 = 1024;
      int v21 = v15;
      __int16 v22 = 1024;
      int v23 = v17;
      __int16 v24 = 1024;
      int v25 = v12;
      __int16 v26 = 1024;
      int v27 = v10;
      __int16 v28 = 1024;
      int v29 = v11;
      __int16 v30 = 1024;
      int v31 = v9;
      __int16 v32 = 2048;
      unint64_t v33 = v8;
      __int16 v34 = 2080;
      size_t v35 = v16;
      _os_log_impl(&dword_228C70000, v14, OS_LOG_TYPE_DEFAULT, "Connection Stats: address=%s, outbound=%d, inbound=%d, ProtocolConnectionStats: send=%u(%u bytes), recv=%u(%u bytes) <period=%llu ms, %s>", (uint8_t *)&v18, 0x44u);
    }
    double result = 0.0;
    *(void *)(a1 + 1712) = 0;
    *(std::chrono::steady_clock::time_point *)(a1 + 1720) = v6;
  }
  return result;
}

BOOL re::Transport::receive(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a3 >= 0xA)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid channel", "channel < kChannelIdMaxChannels", "receive", 1058);
    _os_crash();
    __break(1u);
  }
  std::chrono::steady_clock::time_point v6 = (re *)re::DataArray<re::Connection>::tryGet(a1 + 120, a2);
  if (!v6)
  {
    int v10 = *re::networkLogObjects(0);
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)sockaddr buf = 0;
    int v11 = "Attempt to receive data from connection that does not exist";
    int v12 = v10;
    uint32_t v13 = 2;
LABEL_13:
    _os_log_error_impl(&dword_228C70000, v12, OS_LOG_TYPE_ERROR, v11, buf, v13);
    return 0;
  }
  unint64_t v7 = v6;
  if (*(_DWORD *)v6 == 1)
  {
    uint64_t v8 = re::PacketQueue::dequeue((re::PacketQueue *)(*((void *)v6 + 5) + 40 * a3 + 1312));
    *a4 = v8;
    return v8 != 0;
  }
  unint64_t v14 = *re::networkLogObjects(v6);
  BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  if (result)
  {
    if (*((unsigned char *)v7 + 16)) {
      int v15 = (char *)*((void *)v7 + 3);
    }
    else {
      int v15 = (char *)v7 + 17;
    }
    *(_DWORD *)sockaddr buf = 136315138;
    int v17 = v15;
    int v11 = "Attempt to receive data from connection '%s' that is disconnected";
    int v12 = v14;
    uint32_t v13 = 12;
    goto LABEL_13;
  }
  return result;
}

re::DynamicString *re::Transport::connectionAddress@<X0>(re::Transport *this@<X0>, uint64_t a2@<X1>, re::DynamicString *a3@<X8>)
{
  uint64_t v4 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  if (v4)
  {
    return re::DynamicString::DynamicString(a3, (const re::DynamicString *)(v4 + 8));
  }
  else
  {
    *((void *)a3 + 1) = 0;
    *((void *)a3 + 2) = 0;
    *((void *)a3 + 3) = 0;
    return (re::DynamicString *)re::DynamicString::setCapacity(a3, 0);
  }
}

void re::Transport::connectionStats(re::Transport *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  if (v4 && (uint64_t v5 = *(void *)(v4 + 40)) != 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 1760));
    *(_OWORD *)(a3 + 4) = *(_OWORD *)(v5 + 1736);
    *(void *)(a3 + 20) = *(void *)(v5 + 1752);
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 1760));
    char v6 = 1;
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)a3 = v6;
}

void re::Transport::hostStats(re::Transport *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 368);
  os_unfair_lock_lock((os_unfair_lock_t)this + 92);
  int v5 = *((unsigned __int8 *)this + 340);
  *(unsigned char *)a2 = v5;
  if (v5)
  {
    *(void *)(a2 + 20) = *((void *)this + 45);
    *(_OWORD *)(a2 + 4) = *(_OWORD *)((char *)this + 344);
  }
  os_unfair_lock_unlock(v4);
}

void re::Transport::connectionSetState(uint64_t a1, int a2, int a3)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  int v5 = (re *)re::DataArray<re::Connection>::get(a1 + 120, a2);
  char v6 = *re::networkLogObjects(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 488)) {
      uint64_t v7 = *(void *)(a1 + 496);
    }
    else {
      uint64_t v7 = a1 + 489;
    }
    uint64_t v8 = (char *)*((void *)v5 + 3);
    int v9 = s_debugStateNames[*(int *)v5];
    int v10 = s_debugStateNames[a3];
    if ((*((void *)v5 + 2) & 1) == 0) {
      uint64_t v8 = (char *)v5 + 17;
    }
    int v11 = 136315906;
    uint64_t v12 = v7;
    __int16 v13 = 2080;
    unint64_t v14 = v8;
    __int16 v15 = 2080;
    uint64_t v16 = v9;
    __int16 v17 = 2080;
    uint64_t v18 = v10;
    _os_log_impl(&dword_228C70000, v6, OS_LOG_TYPE_DEFAULT, "Connection(%s->%s) state changed %s->%s", (uint8_t *)&v11, 0x2Au);
  }
  *(_DWORD *)int v5 = a3;
}

uint64_t re::DataArray<re::Connection>::get(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 32) + 16 * HIWORD(a2)) + 136 * (unsigned __int16)a2;
}

void re::Transport::destroyConnection(re::Transport *this, unint64_t a2)
{
  v34[3] = *MEMORY[0x263EF8340];
  uint64_t v4 = (char *)this + 120;
  int v5 = (char *)re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  char v6 = *re::networkLogObjects((re *)v5);
  if (v5)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (*((unsigned char *)this + 488)) {
        uint64_t v7 = (char *)*((void *)this + 62);
      }
      else {
        uint64_t v7 = (char *)this + 489;
      }
      if (v5[16]) {
        uint64_t v8 = (char *)*((void *)v5 + 3);
      }
      else {
        uint64_t v8 = v5 + 17;
      }
      int v9 = s_debugStateNames[*(int *)v5];
      uint64_t v10 = *((void *)v5 + 5);
      *(_DWORD *)__int16 v32 = 136315906;
      *(void *)&v32[4] = v7;
      *(_WORD *)&v32[12] = 2080;
      *(void *)&v32[14] = v8;
      *(_WORD *)&v32[22] = 2080;
      uint64_t v33 = (uint64_t)v9;
      LOWORD(v34[0]) = 2048;
      *(void *)((char *)v34 + 2) = v10;
      _os_log_impl(&dword_228C70000, v6, OS_LOG_TYPE_DEFAULT, "Destroy connection (%s->%s) (%s) bound to protocol handle %p", v32, 0x2Au);
    }
    uint64_t v11 = *((void *)this + 70);
    if (v11) {
      (*(void (**)(uint64_t, re::Transport *, unint64_t))(*(void *)v11 + 40))(v11, this, a2);
    }
    uint64_t v12 = *((void *)v5 + 5);
    if (v12)
    {
      id v13 = (id)(v12 + 8);
      os_unfair_lock_lock((os_unfair_lock_t)(v12 + 1764));
      *(void *)(v12 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 1764));
      uint64_t v14 = re::globalAllocators((re *)(id)(v12 + 8))[2];
      *(void *)&unsigned char v32[16] = v12;
      uint64_t v33 = v14;
      *(void *)__int16 v32 = &unk_26DD369B0;
      *(void *)&v32[8] = this;
      v34[0] = v32;
      (*(void (**)(void, unsigned char *))(**((void **)this + 41) + 16))(*((void *)this + 41), v32);
      re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v32);
    }
    size_t v15 = re::Address::hash((re::Address *)(v5 + 8));
    if (*((void *)this + 34))
    {
      unint64_t v16 = v15 % *((unsigned int *)this + 74);
      uint64_t v17 = *((void *)this + 35);
      uint64_t v18 = *(unsigned int *)(v17 + 4 * v16);
      if (v18 != 0x7FFFFFFF)
      {
        uint64_t v19 = *((void *)this + 36);
        if (re::DynamicString::operator==((uint64_t)(v5 + 8), v19 + 56 * v18 + 16))
        {
          *(_DWORD *)(v17 + 4 * v16) = *(_DWORD *)(v19 + 56 * v18 + 8) & 0x7FFFFFFF;
LABEL_23:
          uint64_t v22 = *((void *)this + 36);
          uint64_t v23 = v22 + 56 * v18;
          int v26 = *(_DWORD *)(v23 + 8);
          int v25 = (int *)(v23 + 8);
          int v24 = v26;
          if (v26 < 0)
          {
            *int v25 = v24 & 0x7FFFFFFF;
            re::DynamicString::deinit((re::DynamicString *)(v22 + 56 * v18 + 16));
            uint64_t v22 = *((void *)this + 36);
            int v24 = *(_DWORD *)(v22 + 56 * v18 + 8);
          }
          *(_DWORD *)(v22 + 56 * v18 + 8) = *((_DWORD *)this + 77) | v24 & 0x80000000;
          *((_DWORD *)this + 77) = v18;
          --*((_DWORD *)this + 75);
          ++*((_DWORD *)this + 78);
        }
        else
        {
          while (1)
          {
            unsigned int v20 = v18;
            int v21 = *(_DWORD *)(v19 + 56 * v18 + 8);
            uint64_t v18 = v21 & 0x7FFFFFFF;
            if ((v21 & 0x7FFFFFFF) == 0x7FFFFFFF) {
              break;
            }
            if (re::DynamicString::operator==((uint64_t)(v5 + 8), v19 + 56 * v18 + 16))
            {
              *(_DWORD *)(v19 + 56 * v20 + 8) = *(_DWORD *)(v19 + 56 * v20 + 8) & 0x80000000 | *(_DWORD *)(v19 + 56 * v18 + 8) & 0x7FFFFFFF;
              goto LABEL_23;
            }
          }
        }
      }
    }
    while (*((_DWORD *)v5 + 19))
    {
      uint64_t v27 = *((unsigned int *)v5 + 20);
      uint64_t v28 = *((void *)v5 + 8);
      uint64_t v29 = 0;
      if (v27)
      {
        __int16 v30 = (int *)(v28 + 8);
        while (1)
        {
          int v31 = *v30;
          v30 += 8;
          if (v31 < 0) {
            break;
          }
          if (v27 == ++v29)
          {
            LODWORD(v29) = *((_DWORD *)v5 + 20);
            break;
          }
        }
      }
      re::Transport::removeStream(this, a2, *(void *)(v28 + 32 * v29 + 16));
    }
    re::DataArray<re::Connection>::destroy((uint64_t)v4, a2);
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int16 v32 = 134217984;
    *(void *)&v32[4] = a2;
    _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "Trying to destroy invalid connection handle (%llu).", v32, 0xCu);
  }
}

void re::Transport::onConnected(re *a1, uint64_t a2, uint64_t a3, const re::DynamicString *a4)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v7 = (void *)(a3 + 8);
    id v8 = (id)(a3 + 8);
    *(void *)&long long v13 = a1;
    re::DynamicString::DynamicString((re::DynamicString *)((char *)&v13 + 8), a4);
    uint64_t v15 = a3;
    uint64_t v9 = re::globalAllocators((re *)v7)[2];
    uint64_t v17 = v9;
    uint64_t v18 = 0;
    if (v9) {
      uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v9 + 32))(v9, 56, 0);
    }
    else {
      uint64_t v10 = 0;
    }
    *uint64_t v10 = &unk_26DD36748;
    v10[1] = v13;
    re::DynamicString::DynamicString((re::DynamicString *)(v10 + 2), (const re::DynamicString *)((char *)&v13 + 8));
    void v10[6] = v15;
    uint64_t v15 = 0;
    uint64_t v18 = v10;
    (*(void (**)(void *, unsigned char *))(**((void **)a1 + 40) + 16))(*((void **)a1 + 40), v16);
    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v16);
    if (v15)
    {

      uint64_t v15 = 0;
    }
    if (*((void *)&v13 + 1))
    {
      if (v14) {
        (*(void (**)(void))(**((void **)&v13 + 1) + 40))();
      }
    }
  }
  else
  {
    uint64_t v11 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      if (*((void *)a4 + 1)) {
        uint64_t v12 = (char *)*((void *)a4 + 2);
      }
      else {
        uint64_t v12 = (char *)a4 + 9;
      }
      LODWORD(v13) = 136315138;
      *(void *)((char *)&v13 + 4) = v12;
      _os_log_error_impl(&dword_228C70000, v11, OS_LOG_TYPE_ERROR, "onConnected: Invalid handle provided for '%s'!", (uint8_t *)&v13, 0xCu);
    }
  }
}

void non-virtual thunk to're::Transport::onConnected(uint64_t a1, uint64_t a2, uint64_t a3, const re::DynamicString *a4)
{
}

void re::Transport::onDisconnected(re *a1, uint64_t a2, uint64_t a3, const re::DynamicString *a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v7 = (void *)(a3 + 8);
    id v8 = *re::networkLogObjects((re *)(id)(a3 + 8));
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      if (*((void *)a4 + 1)) {
        uint64_t v15 = (char *)*((void *)a4 + 2);
      }
      else {
        uint64_t v15 = (char *)a4 + 9;
      }
      LODWORD(v16) = 136315138;
      *(void *)((char *)&v16 + 4) = v15;
      _os_log_debug_impl(&dword_228C70000, v8, OS_LOG_TYPE_DEBUG, "queueTransportCommand '%s' OnDisconnected", (uint8_t *)&v16, 0xCu);
    }
    *(void *)&long long v16 = a1;
    *((void *)&v16 + 1) = a3;
    id v9 = v7;
    uint64_t v10 = re::DynamicString::DynamicString((re::DynamicString *)v17, a4);
    uint64_t v11 = re::globalAllocators(v10)[2];
    uint64_t v19 = v11;
    uint64_t v20 = 0;
    if (v11) {
      uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v11 + 32))(v11, 56, 0);
    }
    else {
      uint64_t v12 = 0;
    }
    *(void *)uint64_t v12 = &unk_26DD367A0;
    *(_OWORD *)(v12 + 8) = v16;
    *((void *)&v16 + 1) = 0;
    re::DynamicString::DynamicString((re::DynamicString *)(v12 + 24), (const re::DynamicString *)v17);
    uint64_t v20 = v12;
    (*(void (**)(void *, unsigned char *))(**((void **)a1 + 40) + 16))(*((void **)a1 + 40), v18);
    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v18);
    if (v17[0])
    {
      if (v17[1]) {
        (*(void (**)(void))(*(void *)v17[0] + 40))();
      }
      memset(v17, 0, sizeof(v17));
    }
    if (*((void *)&v16 + 1)) {
  }
    }
  else
  {
    long long v13 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      if (*((void *)a4 + 1)) {
        char v14 = (char *)*((void *)a4 + 2);
      }
      else {
        char v14 = (char *)a4 + 9;
      }
      LODWORD(v16) = 136315138;
      *(void *)((char *)&v16 + 4) = v14;
      _os_log_error_impl(&dword_228C70000, v13, OS_LOG_TYPE_ERROR, "onDisconnected: Invalid handle provided for '%s'!", (uint8_t *)&v16, 0xCu);
    }
  }
}

void non-virtual thunk to're::Transport::onDisconnected(uint64_t a1, uint64_t a2, uint64_t a3, const re::DynamicString *a4)
{
}

void re::Transport::onError(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t v7 = (void *)(a3 + 8);
    id v8 = (id)(a3 + 8);
    uint64_t v11 = re::globalAllocators((re *)v7)[2];
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v11 + 32))(v11, 32, 0);
    *(void *)uint64_t v9 = &unk_26DD367F8;
    *(void *)(v9 + 8) = a1;
    *(void *)(v9 + 16) = a3;
    *(unsigned char *)(v9 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a4;
    uint64_t v12 = v9;
    (*(void (**)(void, unsigned char *))(**(void **)(a1 + 320) + 16))(*(void *)(a1 + 320), v10);
    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v10);
  }
}

void non-virtual thunk to're::Transport::onError(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
}

void re::Transport::onUnresponsive(re *a1, uint64_t a2, uint64_t a3)
{
  v9[5] = *MEMORY[0x263EF8340];
  if (a3)
  {
    int v5 = (void *)(a3 + 8);
    id v6 = (id)(a3 + 8);
    uint64_t v7 = re::globalAllocators((re *)v5)[2];
    uint64_t v9[2] = a3;
    unint64_t v9[3] = v7;
    v9[0] = &unk_26DD36850;
    v9[1] = a1;
    unsigned char v9[4] = v9;
    (*(void (**)(void *, void *))(**((void **)a1 + 40) + 16))(*((void **)a1 + 40), v9);
    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v9);
  }
  else
  {
    id v8 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9[0]) = 0;
      _os_log_error_impl(&dword_228C70000, v8, OS_LOG_TYPE_ERROR, "onUnresponsive: Invalid handle!", (uint8_t *)v9, 2u);
    }
  }
}

void non-virtual thunk to're::Transport::onUnresponsive(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void re::Transport::onResponsive(re *a1, uint64_t a2, uint64_t a3)
{
  v9[5] = *MEMORY[0x263EF8340];
  if (a3)
  {
    int v5 = (void *)(a3 + 8);
    id v6 = (id)(a3 + 8);
    uint64_t v7 = re::globalAllocators((re *)v5)[2];
    uint64_t v9[2] = a3;
    unint64_t v9[3] = v7;
    v9[0] = &unk_26DD368A8;
    v9[1] = a1;
    unsigned char v9[4] = v9;
    (*(void (**)(void *, void *))(**((void **)a1 + 40) + 16))(*((void **)a1 + 40), v9);
    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v9);
  }
  else
  {
    id v8 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9[0]) = 0;
      _os_log_error_impl(&dword_228C70000, v8, OS_LOG_TYPE_ERROR, "onResponsive: Invalid handle!", (uint8_t *)v9, 2u);
    }
  }
}

void non-virtual thunk to're::Transport::onResponsive(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void re::Transport::onReceiveAsync(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const void *a5, uint64_t a6)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  unsigned __int8 v6 = atomic_load((unsigned __int8 *)(a1 + 336));
  if (v6)
  {
    uint64_t v13 = (re *)re::DataArray<re::Connection>::tryGet(a1 + 120, *(void *)(a3 + 24));
    if (v13)
    {
      if (a4 < 0xA)
      {
        uint64_t v15 = re::PacketPool::allocate(*(re::PacketPool **)(a1 + 384), a6);
        *((_DWORD *)v15 + 6) = a6;
        memcpy(*((void **)v15 + 2), a5, a6);
        id v16 = (id)(a3 + 8);
        uint64_t v22 = re::globalAllocators((re *)(id)(a3 + 8))[2];
        uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v22 + 32))(v22, 48, 0);
        *(void *)uint64_t v17 = &unk_26DD36900;
        *(void *)(v17 + 8) = a1;
        *(void *)(v17 + 16) = a2;
        *(void *)(v17 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a3;
        *(unsigned char *)(v17 + 32) = a4;
        *(void *)(v17 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = v15;
        uint64_t v23 = v17;
        (*(void (**)(void, uint8_t *))(**(void **)(a1 + 320) + 16))(*(void *)(a1 + 320), buf);
        re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)buf);
        uint64_t v18 = *(NSObject **)(a1 + 376);
        v19[0] = MEMORY[0x263EF8330];
        v19[1] = 0x40000000;
        void v19[2] = ___ZN2re9Transport14onReceiveAsyncEPNS_13ProtocolLayerEPNS_14ProtocolHandleENS_9ChannelIdEPKvj_block_invoke;
        v19[3] = &__block_descriptor_tmp_6;
        v19[4] = a1;
        _OWORD v19[5] = v18;
        dispatch_async(v18, v19);
      }
      else
      {
        char v14 = *re::networkLogObjects(v13);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)sockaddr buf = 67109120;
          unsigned int v21 = a4;
          _os_log_error_impl(&dword_228C70000, v14, OS_LOG_TYPE_ERROR, "Transport cannot receive on invalid channel id: %hhu", buf, 8u);
        }
        if (re::internal::enableSignposts(0, 0)) {
          kdebug_trace();
        }
      }
    }
  }
}

void *___ZN2re9Transport14onReceiveAsyncEPNS_13ProtocolLayerEPNS_14ProtocolHandleENS_9ChannelIdEPKvj_block_invoke(uint64_t a1)
{
  BOOL result = dispatch_queue_get_specific(*(dispatch_queue_t *)(a1 + 40), *(const void **)(a1 + 32));
  if (result)
  {
    BOOL result = (void *)result[76];
    if (result)
    {
      uint64_t v2 = *(uint64_t (**)(void))(*result + 48);
      return (void *)v2();
    }
  }
  return result;
}

void non-virtual thunk to're::Transport::onReceiveAsync(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const void *a5, uint64_t a6)
{
}

uint64_t re::Transport::onReceive(re *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint8_t *a5, unsigned int a6)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (a4 < 0xA)
  {
    ++*(_DWORD *)(a3 + 1716);
    uint64_t v13 = re::DataArray<re::Connection>::tryGet((uint64_t)a1 + 120, *(void *)(a3 + 24));
    if (v13)
    {
      if (*(unsigned char *)(v13 + 16)) {
        char v14 = *(const char **)(v13 + 24);
      }
      else {
        char v14 = (const char *)(v13 + 17);
      }
    }
    else
    {
      char v14 = "N/A";
    }
    size_t v16 = a6;
    uint64_t v17 = *((void *)a1 + 70);
    if (v17)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, re *, void, uint64_t, uint8_t *, void, double))(*(void *)v17 + 56))(v17, a1, *(void *)(a3 + 24), a4, a5, a6, v15);
      if (!v18) {
        return result;
      }
      a5 = (uint8_t *)result;
      size_t v16 = v18;
    }
    return re::Transport::onReceiveData((uint64_t)a1, a3, a4, a5, v16);
  }
  else
  {
    id v8 = *re::networkLogObjects(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v19[0] = 67109120;
      v19[1] = a4;
      _os_log_error_impl(&dword_228C70000, v8, OS_LOG_TYPE_ERROR, "Transport cannot receive on invalid channel id: %hhu", (uint8_t *)v19, 8u);
    }
    uint64_t result = re::internal::enableSignposts(0, 0);
    if (result) {
      return kdebug_trace();
    }
  }
  return result;
}

uint64_t non-virtual thunk to're::Transport::onReceive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint8_t *a5, unsigned int a6)
{
  return re::Transport::onReceive((re *)(a1 - 24), a2, a3, a4, a5, a6);
}

uint64_t *re::FixedArray<unsigned char>::operator=(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    uint64_t v2 = *result;
    uint64_t v3 = *a2;
    if (*result) {
      BOOL v4 = v2 == v3;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4)
    {
      *uint64_t result = v3;
      *a2 = v2;
      uint64_t v5 = result[1];
      uint64_t v6 = result[2];
      uint64_t v7 = a2[2];
      result[1] = a2[1];
      result[2] = v7;
      a2[1] = v5;
      a2[2] = v6;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      uint64_t result = (uint64_t *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::Transport::dispatchPacketToStream(re::Transport *this, re::Packet *a2, uint64_t a3)
{
  uint64_t v5 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a3);
  if (!v5) {
    return 1;
  }
  if (!*(_DWORD *)(v5 + 76)) {
    return 2;
  }
  uint64_t v6 = v5 + 48;
  uint64_t v7 = *((void *)a2 + 2);
  int v17 = *((_DWORD *)a2 + 6);
  char v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v15 = 0xFFFFFFFFLL;
  uint64_t v16 = v7;
  uint64_t v14 = 0;
  re::BiasedVLQ::read((re::BiasedVLQ *)&v14, (re::BitReader *)&v16, &v15);
  uint64_t v14 = v15;
  id v8 = (void *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v6, &v14);
  if (!v8) {
    return 3;
  }
  if (*v8 >= *((void *)this + 6) || v18 != 0) {
    return 3;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(*((void *)this + 8) + 8 * *v8));
  if (!WeakRetained) {
    return 3;
  }
  id v11 = WeakRetained;

  if (HIDWORD(v19)) {
    uint64_t v12 = (v19 + 1);
  }
  else {
    uint64_t v12 = v19;
  }
  re::Packet::offsetBy((uint64_t)a2, v12);
  atomic_fetch_add_explicit((atomic_uint *volatile)v11 + 20, *((_DWORD *)a2 + 6), memory_order_release);
  atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 11, *((unsigned int *)a2 + 7), memory_order_release);
  atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 9, 1uLL, memory_order_release);
  atomic_store((unint64_t)a2, *((unint64_t **)v11 + 7));
  *((void *)v11 + 7) = a2;
  uint64_t result = *((void *)v11 + 12);
  if (result)
  {
    (*(void (**)(uint64_t, void))(result + 16))(result, *((void *)v11 + 5));
    return 0;
  }
  return result;
}

uint64_t re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::tryGet(uint64_t a1, unsigned __int16 a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * a2) ^ ((0xBF58476D1CE4E5B9 * a2) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(unsigned __int16 *)(v5 + 80 * v3 + 12) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 80 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(unsigned __int16 *)(v5 + 80 * v3 + 12) == a2) {
        return v5 + 80 * v3 + 16;
      }
    }
    return 0;
  }
  return v5 + 80 * v3 + 16;
}

uint64_t re::Transport::discardPacketFragments(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = (void *)(a1 + 48 * a2 + 432);
  uint64_t result = re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::tryGet((uint64_t)v6, a3);
  if (result)
  {
    if (*v6)
    {
      unint64_t v8 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * a3) ^ ((0xBF58476D1CE4E5B9 * a3) >> 27));
      uint64_t v9 = a1 + 48 * a2;
      unint64_t v10 = (v8 ^ (v8 >> 31)) % *(unsigned int *)(v9 + 456);
      uint64_t v11 = *(void *)(v9 + 440);
      uint64_t v12 = *(unsigned int *)(v11 + 4 * v10);
      if (v12 != 0x7FFFFFFF)
      {
        uint64_t v13 = a1 + 48 * a2;
        uint64_t v14 = *(void *)(v13 + 448);
        if (*(unsigned __int16 *)(v14 + 80 * v12 + 12) == a3)
        {
          *(_DWORD *)(v11 + 4 * v10) = *(_DWORD *)(v14 + 80 * v12 + 8) & 0x7FFFFFFF;
LABEL_9:
          int v17 = (void *)(v13 + 448);
          uint64_t result = re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::EntryWithHash::free(*(void *)(v13 + 448) + 80 * v12);
          char v18 = (_DWORD *)(a1 + 48 * a2);
          *(_DWORD *)(*v17 + 80 * v12 + 8) = *(_DWORD *)(*v17 + 80 * v12 + 8) & 0x80000000 | v18[117];
          v18[117] = v12;
          --v18[115];
          ++v18[118];
        }
        else
        {
          while (1)
          {
            unsigned int v15 = v12;
            int v16 = *(_DWORD *)(v14 + 80 * v12 + 8);
            uint64_t v12 = v16 & 0x7FFFFFFF;
            if ((v16 & 0x7FFFFFFF) == 0x7FFFFFFF) {
              break;
            }
            if (*(unsigned __int16 *)(v14 + 80 * v12 + 12) == a3)
            {
              *(_DWORD *)(v14 + 80 * v15 + 8) = *(_DWORD *)(v14 + 80 * v15 + 8) & 0x80000000 | *(_DWORD *)(v14 + 80 * v12 + 8) & 0x7FFFFFFF;
              goto LABEL_9;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t (***re::Transport::setDisconnectTimeout(re::Transport *this, int a2))(void)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v4 = re::globalAllocators(this)[2];
  v6[0] = &unk_26DD36958;
  v6[1] = this;
  int v7 = a2;
  uint64_t v8 = v4;
  uint64_t v9 = v6;
  (*(void (**)(void, void *))(**((void **)this + 41) + 16))(*((void *)this + 41), v6);
  return re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v6);
}

void re::Transport::removeStream(re::Transport *this, uint64_t a2, uint64_t a3)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  v37[0] = a3;
  uint64_t v4 = (char *)this + 120;
  uint64_t v5 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a2);
  if (!v5)
  {
    uint64_t v27 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(to[0]) = 0;
    uint64_t v28 = "Failed to remove unicast stream. Invalid connection handle.";
    uint64_t v29 = v27;
    uint32_t v30 = 2;
    goto LABEL_30;
  }
  uint64_t v6 = v5;
  unint64_t v7 = v5 + 48;
  uint64_t v8 = (unint64_t *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v5 + 48, v37);
  if (!v8)
  {
    int v31 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if (*(unsigned char *)(v6 + 16)) {
      uint64_t v32 = *(void *)(v6 + 24);
    }
    else {
      uint64_t v32 = v6 + 17;
    }
    LODWORD(to[0]) = 136315394;
    *(void *)((char *)to + 4) = v32;
    WORD6(to[0]) = 2048;
    *(void *)((char *)to + 14) = v37[0];
    uint64_t v28 = "Connection %s does not have stream %llu.";
    uint64_t v29 = v31;
    uint32_t v30 = 22;
LABEL_30:
    _os_log_error_impl(&dword_228C70000, v29, OS_LOG_TYPE_ERROR, v28, (uint8_t *)to, v30);
    return;
  }
  unint64_t v10 = (unint64_t)v8;
  unint64_t v11 = *((void *)this + 6);
  if (*v8 >= v11)
  {
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) ", "*index < m_streams.size()", "removeStream", 1921);
    _os_crash();
    __break(1u);
LABEL_32:
    v37[1] = 0;
    memset(to, 0, sizeof(to));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v38 = 136315906;
    uint64_t v39 = "operator[]";
    __int16 v40 = 1024;
    int v41 = 789;
    __int16 v42 = 2048;
    unint64_t v43 = v10;
    __int16 v44 = 2048;
    unint64_t v45 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v12 = *(void *)(*((void *)this + 8) + 8 * v11 - 8);
  if (v12) {
    uint64_t v13 = v12 - 8;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = re::DataArray<re::Connection>::tryGet((uint64_t)v4, *(void *)(v13 + 40));
  if (v14)
  {
    uint64_t v15 = v14;
    uint64_t v18 = *(void *)(v14 + 48);
    uint64_t v16 = v14 + 48;
    uint64_t v17 = v18;
    uint64_t v19 = *(void *)(*((void *)this + 8) + 8 * *((void *)this + 6) - 8);
    if (v19) {
      uint64_t v20 = v19 - 8;
    }
    else {
      uint64_t v20 = 0;
    }
    unint64_t v21 = *(void *)(v20 + 48);
    *(void *)&to[0] = v21;
    unint64_t v22 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v21 ^ (v21 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v21 ^ (v21 >> 30))) >> 27));
    unint64_t v23 = v22 ^ (v22 >> 31);
    if (v17)
    {
      unint64_t v24 = v23 % *(unsigned int *)(v15 + 72);
      uint64_t v25 = *(unsigned int *)(*(void *)(v15 + 56) + 4 * v24);
      if (v25 != 0x7FFFFFFF)
      {
        uint64_t v26 = *(void *)(v15 + 64);
        if (*(void *)(v26 + 32 * v25 + 16) == v21)
        {
LABEL_16:
          *(void *)(v26 + 32 * v25 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(void *)v10;
LABEL_24:
          ++*(_DWORD *)(v15 + 88);
          goto LABEL_25;
        }
        while (1)
        {
          uint64_t v25 = *(_DWORD *)(v26 + 32 * v25 + 8) & 0x7FFFFFFF;
          if (v25 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v26 + 32 * v25 + 16) == v21) {
            goto LABEL_16;
          }
        }
      }
    }
    else
    {
      LODWORD(vre::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
    }
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<unsigned long &>(v16, v24, v23, to, (void *)v10);
    goto LABEL_24;
  }
LABEL_25:
  re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(v7, v37);
  unint64_t v7 = *((void *)this + 6);
  unint64_t v10 = *(void *)v10;
  if (v7 <= v10) {
    goto LABEL_32;
  }
  uint64_t v33 = *((void *)this + 8);
  __int16 v34 = (id *)(v33 + 8 * v7 - 8);
  size_t v35 = (id *)(v33 + 8 * v10);
  *(void *)&to[0] = 0;
  objc_moveWeak((id *)to, v34);
  re::ArcWeakPtr<re::TransportStream>::operator=(v34, v35);
  re::ArcWeakPtr<re::TransportStream>::operator=(v35, (id *)to);
  objc_destroyWeak((id *)to);
  uint64_t v36 = *((void *)this + 8) + 8 * *((void *)this + 6);
  objc_destroyWeak((id *)(v36 - 8));
  *(void *)(v36 - 8) = 0;
  --*((void *)this + 6);
  ++*((_DWORD *)this + 14);
}

void re::DataArray<re::Connection>::destroy(uint64_t a1, unint64_t a2)
{
  int v2 = a2;
  unint64_t v4 = a2 >> 16;
  uint64_t v5 = re::DataArray<re::Connection>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (v5)
  {
    uint64_t v6 = v5;
    re::HashTable<unsigned long long,void *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)(v5 + 48));
    uint64_t v7 = *(void *)(v6 + 40);
    if (v7)
    {

      *(void *)(v6 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
    }
    re::DynamicString::deinit((re::DynamicString *)(v6 + 8));
    if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *(_DWORD *)uint64_t v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
}

char *re::Transport::createMultiplexedPacket(re::PacketPool **this, uint64_t a2, int a3)
{
  unint64_t v4 = re::PacketPool::allocate(this[48], (a3 + 19));
  re::Packet::offsetBy((uint64_t)v4, 3);
  uint64_t v5 = *((void *)v4 + 1);
  *(unsigned char *)(v5 + 2) = 0;
  *(_WORD *)uint64_t v5 = 0;
  uint64_t v6 = *((void *)v4 + 2);
  int v7 = *((_DWORD *)v4 + 7);
  v11[0] = &unk_26DD35FA8;
  v11[1] = v6;
  int v12 = v7;
  char v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v10 = 0;
  re::BiasedVLQ::write((re::BiasedVLQ *)&v10, (re::BitWriter *)v11, a2);
  if (HIDWORD(v14)) {
    uint64_t v8 = (v14 + 1);
  }
  else {
    uint64_t v8 = v14;
  }
  re::Packet::offsetBy((uint64_t)v4, v8);
  return v4;
}

uint64_t re::Packet::offsetTo(uint64_t this, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(this + 28);
  if (v2 < a2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "capacity() >= offset", "offsetTo", 125);
    this = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v3 = *(void *)(this + 8);
    int v4 = *(_DWORD *)(this + 16) - v3 - a2;
    *(void *)(this + 16) = v3 + a2;
    *(_DWORD *)(this + 24) += v4;
    *(_DWORD *)(this + 28) = v4 + v2;
  }
  return this;
}

BOOL re::Transport::registerStream(re::Transport *this, re::TransportStream *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  unint64_t v32 = a3;
  uint64_t v6 = re::DataArray<re::Connection>::tryGet((uint64_t)this + 120, a4);
  if (!v6)
  {
    uint64_t v15 = *re::networkLogObjects(0);
    BOOL result = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)sockaddr buf = 0;
    int v12 = "Failed to register unicast stream. Invalid connection handle.";
    char v13 = v15;
    uint32_t v14 = 2;
    goto LABEL_7;
  }
  uint64_t v7 = v6;
  uint64_t v8 = (void *)(v6 + 48);
  uint64_t v9 = (re *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v6 + 48, (uint64_t *)&v32);
  if (v9)
  {
    uint64_t v10 = *re::networkLogObjects(v9);
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)sockaddr buf = 134217984;
    *(void *)&uint8_t buf[4] = v32;
    int v12 = "Failed to register unicast stream. Stream %llu already exists.";
    char v13 = v10;
    uint32_t v14 = 12;
LABEL_7:
    _os_log_error_impl(&dword_228C70000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    return 0;
  }
  *(void *)sockaddr buf = *((void *)this + 6);
  if (a2) {
    uint64_t v16 = (char *)a2 + 8;
  }
  else {
    uint64_t v16 = 0;
  }
  inited = (_anonymous_namespace_ *)objc_initWeak(&v31, v16);
  unint64_t v18 = *((void *)this + 5);
  unint64_t v19 = *((void *)this + 6);
  if (v19 >= v18)
  {
    unint64_t v20 = v19 + 1;
    if (v18 < v19 + 1)
    {
      if (*((void *)this + 4))
      {
        uint64_t v21 = 2 * v18;
        BOOL v22 = v18 == 0;
        unint64_t v23 = 8;
        if (!v22) {
          unint64_t v23 = v21;
        }
        if (v23 <= v20) {
          unint64_t v24 = v20;
        }
        else {
          unint64_t v24 = v23;
        }
        re::DynamicArray<re::ArcWeakPtr<re::TransportStream>>::setCapacity((void *)this + 4, v24);
      }
      else
      {
        re::DynamicArray<re::ArcWeakPtr<re::TransportStream>>::setCapacity((void *)this + 4, v20);
        ++*((_DWORD *)this + 14);
      }
    }
    unint64_t v19 = *((void *)this + 6);
  }
  uint64_t v25 = (id *)(*((void *)this + 8) + 8 * v19);
  *uint64_t v25 = 0;
  objc_moveWeak(v25, &v31);
  ++*((void *)this + 6);
  ++*((_DWORD *)this + 14);
  objc_destroyWeak(&v31);
  unint64_t v26 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) >> 27));
  unint64_t v27 = v26 ^ (v26 >> 31);
  if (!*v8)
  {
    LODWORD(v28) = 0;
    goto LABEL_29;
  }
  unint64_t v28 = v27 % *(unsigned int *)(v7 + 72);
  uint64_t v29 = *(unsigned int *)(*(void *)(v7 + 56) + 4 * v28);
  if (v29 == 0x7FFFFFFF)
  {
LABEL_29:
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<unsigned long &>((uint64_t)v8, v28, v27, &v32, buf);
    ++*(_DWORD *)(v7 + 88);
    return 1;
  }
  uint64_t v30 = *(void *)(v7 + 64);
  if (*(void *)(v30 + 32 * v29 + 16) != v32)
  {
    while (1)
    {
      uint64_t v29 = *(_DWORD *)(v30 + 32 * v29 + 8) & 0x7FFFFFFF;
      if (v29 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v30 + 32 * v29 + 16) == v32) {
        return 1;
      }
    }
    goto LABEL_29;
  }
  return 1;
}

void *re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36380;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36380;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 72) + 64))(*(void *)(*(void *)(a1 + 8) + 72), *(void *)(a1 + 16), 1);
}

void *re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *a2 = &unk_26DD36380;
  a2[1] = v4;
  a2[2] = v3;
  if (v3) {
    id v5 = (id)(v3 + 8);
  }
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36380;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_0,void ()(void)>::size()
{
  return 24;
}

void *re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD363D8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD363D8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  (*(void (**)(void, void, uint64_t))(**(void **)(v2 + 72) + 56))(*(void *)(v2 + 72), *(void *)(a1 + 16), 1);
  uint64_t v3 = *(void *)(a1 + 16);
  re::Transport::cleanupPendingQueues((re::PacketPool **)v2, v3);
}

void *re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *a2 = &unk_26DD363D8;
  a2[1] = v4;
  a2[2] = v3;
  if (v3) {
    id v5 = (id)(v3 + 8);
  }
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD363D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_1,void ()(void)>::size()
{
  return 24;
}

void re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  (*(void (**)(void))(**(void **)(v1 + 72) + 40))(*(void *)(v1 + 72));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 72) + 112);
  return v2();
}

void *re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD36430;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD36430;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::deinit(void)::$_2,void ()(void)>::size()
{
  return 16;
}

void re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 72) + 88))();
}

void *re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD36488;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD36488;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::flushNetworkEvents(void)::$_0,void ()(void)>::size()
{
  return 16;
}

void re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::~Callable()
{
}

void re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if ((*(unsigned int (**)(void))(**(void **)(v1 + 72) + 72))(*(void *)(v1 + 72)))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v1 + 184));
    uint64_t v2 = *(void *)(v1 + 208);
    if (v2)
    {
      uint64_t v3 = *(void *)(v1 + 192);
      uint64_t v4 = *(void *)(v1 + 224);
      *(void *)(v1 + 192) = *(void *)(v1 + 232);
      uint64_t v5 = *(void *)(v1 + 200);
      *(_OWORD *)(v1 + 200) = *(_OWORD *)(v1 + 240);
      *(void *)(v1 + 2re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = v5;
      *(void *)(v1 + 248) = v2;
      *(void *)(v1 + 2re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(void *)(v1 + 264);
      *(void *)(v1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 232) = v3;
      *(void *)(v1 + 264) = v4;
      ++*(_DWORD *)(v1 + 256);
      ++*(_DWORD *)(v1 + 216);
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 184));
      uint64_t v6 = *(void *)(v1 + 248);
      if (v6)
      {
        uint64_t v7 = *(uint64_t **)(v1 + 264);
        uint64_t v8 = &v7[v6];
        do
        {
          uint64_t v9 = *v7 + 1312;
          *(void *)&long long v20 = *v7 + 912;
          *((void *)&v20 + 1) = v9;
          LOBYTE(v21) = 0;
          (*(void (**)(void))(**(void **)(v1 + 72) + 80))(*(void *)(v1 + 72));
          uint64_t v11 = *((void *)&v20 + 1);
          uint64_t v10 = v20;
          while (v10 != v11)
          {
            if (atomic_load(*(unint64_t **)(v10 + 8)))
            {
              os_unfair_lock_lock((os_unfair_lock_t)(v1 + 184));
              uint64_t v13 = *(void *)(v1 + 224);
              uint64_t v14 = *(void *)(v1 + 208);
              if (v14)
              {
                uint64_t v15 = 8 * v14;
                uint64_t v16 = *(void **)(v1 + 224);
                while (*v16 != *v7)
                {
                  ++v16;
                  v15 -= 8;
                  if (!v15)
                  {
                    uint64_t v16 = (void *)(v13 + 8 * v14);
                    break;
                  }
                }
              }
              else
              {
                uint64_t v16 = *(void **)(v1 + 224);
              }
              if (v14 == ((uint64_t)v16 - v13) >> 3) {
                re::DynamicArray<re::SharedPtr<re::ProtocolHandle>>::add((_anonymous_namespace_ *)(v1 + 192), v7);
              }
              os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 184));
              break;
            }
            uint64_t v11 = *((void *)&v20 + 1);
            uint64_t v10 = v20 + 40;
            *(void *)&long long v20 = v20 + 40;
            LOBYTE(v21) = v21 + 1;
          }
          ++v7;
        }
        while (v7 != v8);
        uint64_t v17 = *(void *)(v1 + 248);
        uint64_t v18 = *(void *)(v1 + 264);
        *(void *)(v1 + 248) = 0;
        if (v17)
        {
          uint64_t v19 = 8 * v17;
          do
          {
            if (*(void *)v18)
            {

              *(void *)uint64_t v18 = 0;
            }
            v18 += 8;
            v19 -= 8;
          }
          while (v19);
        }
      }
      else
      {
        *(void *)(v1 + 248) = 0;
      }
      ++*(_DWORD *)(v1 + 256);
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 184));
    }
  }
  (*(void (**)(void))(**(void **)(v1 + 72) + 88))(*(void *)(v1 + 72));
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 368));
  if ((*(unsigned int (**)(void, long long *))(**(void **)(v1 + 72) + 128))(*(void *)(v1 + 72), &v20))
  {
    if (!*(unsigned char *)(v1 + 340)) {
      *(unsigned char *)(v1 + 3re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 1;
    }
    *(_OWORD *)(v1 + 344) = v20;
    *(void *)(v1 + 360) = v21;
  }
  else if (*(unsigned char *)(v1 + 340))
  {
    *(unsigned char *)(v1 + 3re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 368));
}

void *re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD364E0;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26DD364E0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::flushOutgoingData(void)::$_0,void ()(void)>::size()
{
  return 16;
}

void *re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36538;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 2));
  return a1;
}

void re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36538;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 2));
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = (re *)(*(void *(**)(os_unfair_lock_s **__return_ptr))(**(void **)(v2 + 72) + 48))(&v11);
  uint64_t v4 = v11;
  if (v11)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    os_unfair_lock_lock(v11 + 441);
    *(void *)&v4[6]._uint64_t os_unfair_lock_opaque = v5;
    os_unfair_lock_unlock(v4 + 441);
  }
  else
  {
    uint64_t v6 = *re::networkLogObjects(v3);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (v7)
    {
      if (*(unsigned char *)(a1 + 24)) {
        uint64_t v10 = *(void *)(a1 + 32);
      }
      else {
        uint64_t v10 = a1 + 25;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v10;
      _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "Failed to connect to %s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v8 = *(void *)(a1 + 48);
    uint64_t v9 = re::globalAllocators((re *)v7)[2];
    uint64_t v13 = v8;
    uint64_t v14 = v9;
    *(void *)&long long buf = &unk_26DD36590;
    *((void *)&buf + 1) = v2;
    p_long long buf = &buf;
    (*(void (**)(void, long long *))(**(void **)(v2 + 320) + 16))(*(void *)(v2 + 320), &buf);
    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&buf);
  }
  if (v11) {
}
  }

void *re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::cloneInto(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  *a2 = &unk_26DD36538;
  a2[1] = v4;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 2));
  a2[6] = a1[6];
  return a2;
}

void *re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::moveInto(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  *a2 = &unk_26DD36538;
  a2[1] = v4;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 2));
  a2[6] = a1[6];
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connect(re::Address const&)::$_0,void ()(void)>::size()
{
  return 56;
}

void re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::~Callable()
{
}

_anonymous_namespace_ *re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::operator()(_anonymous_namespace_ *result)
{
  uint64_t v1 = *((void *)result + 1);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if (v2)
  {
    uint64_t v3 = result;
    BOOL result = (_anonymous_namespace_ *)re::DataArray<re::Connection>::tryGet(v1 + 120, *((void *)result + 2));
    if (result)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      re::DynamicString::setCapacity(&v5, 0);
      int v10 = 0;
      int v4 = 3;
      char v9 = 2;
      re::Transport::connectionStateEvent(v1, *((void *)v3 + 2), &v4);
      BOOL result = (_anonymous_namespace_ *)v5;
      if (v5)
      {
        if (v6) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*v5 + 40))();
        }
      }
    }
  }
  return result;
}

uint64_t re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36590;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36590;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connect(re::Address const&)::$_0::operator() const(void)::{lambda(void)#1},void ()(void)>::size()
{
  return 24;
}

void *re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD365E8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD365E8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 8) + 72) + 64))(*(void *)(*(void *)(a1 + 8) + 72), *(void *)(a1 + 16), *(unsigned __int8 *)(a1 + 24));
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)a2 = &unk_26DD365E8;
  *(void *)(a2 + 8) = v5;
  *(void *)(a2 + 16) = v4;
  if (v4) {
    id v6 = (id)(v4 + 8);
  }
  *(unsigned char *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(unsigned char *)(a1 + 24);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD365E8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(unsigned char *)(a1 + 24);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::size()
{
  return 32;
}

void re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 608);
    if (v3) {
      return (*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 8))(v3, *(void *)(result + 16));
    }
  }
  return result;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36640;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36640;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_1,void ()(void)>::size()
{
  return 24;
}

void re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::~Callable()
{
}

void re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if (v2)
  {
    (*(void (**)(void, void))(**(void **)(v1 + 608) + 8))(*(void *)(v1 + 608), *(void *)(a1 + 16));
    unint64_t v4 = *(void *)(a1 + 16);
    re::Transport::destroyConnection((re::Transport *)v1, v4);
  }
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36698;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36698;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateActive(unsigned long long,re::ConnectionEvent const&)::$_2,void ()(void)>::size()
{
  return 24;
}

void *re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD366F0;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD366F0;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

uint64_t re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 72) + 64))(*(void *)(*(void *)(a1 + 8) + 72), *(void *)(a1 + 16), 1);
}

void *re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *a2 = &unk_26DD366F0;
  a2[1] = v4;
  a2[2] = v3;
  if (v3) {
    id v5 = (id)(v3 + 8);
  }
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD366F0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::connectionStateClosing(unsigned long long,re::ConnectionEvent const&)::$_0,void ()(void)>::size()
{
  return 24;
}

void *re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36748;
  uint64_t v2 = a1[6];
  if (v2)
  {

    a1[6] = 0;
  }
  re::DynamicString::deinit((re::DynamicString *)(a1 + 2));
  return a1;
}

void re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36748;
  uint64_t v2 = a1[6];
  if (v2)
  {

    a1[6] = 0;
  }
  re::DynamicString::deinit((re::DynamicString *)(a1 + 2));
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(unsigned __int8 **)(a1 + 8);
  unsigned __int8 v2 = atomic_load(v1 + 336);
  if ((v2 & 1) == 0) {
    return;
  }
  uint64_t v4 = (re::DynamicString *)(a1 + 16);
  id v5 = (uint64_t *)re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::tryGet((uint64_t)(v1 + 272), (re::Address *)(a1 + 16));
  if (v5)
  {
    unint64_t Connection = *v5;
    uint64_t v7 = re::DataArray<re::Connection>::tryGet((uint64_t)(v1 + 120), *v5);
    if (!v7)
    {
      uint64_t v8 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        if (*(unsigned char *)(a1 + 24)) {
          uint64_t v9 = *(void *)(a1 + 32);
        }
        else {
          uint64_t v9 = a1 + 25;
        }
        int v12 = 136315138;
        *(void *)uint64_t v13 = v9;
        _os_log_fault_impl(&dword_228C70000, v8, OS_LOG_TYPE_FAULT, "Connection '%s' found in m_addrToConnections but missing from m_connections!", (uint8_t *)&v12, 0xCu);
      }
      return;
    }
  }
  else
  {
    unint64_t Connection = re::Transport::createConnection((re::Transport *)v1, (const re::Address *)(a1 + 16));
    uint64_t v7 = re::DataArray<re::Connection>::get((uint64_t)(v1 + 120), Connection);
  }
  re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v7 + 40), *(void *)(a1 + 48));
  uint64_t v10 = *(void *)(a1 + 48);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 1764));
  *(void *)(v10 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = Connection;
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 1764));
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  re::DynamicString::setCapacity(&v13[4], 0);
  int v17 = 0;
  int v12 = 0;
  re::DynamicString::operator=((re::DynamicString *)&v13[4], v4);
  re::Transport::connectionStateEvent((uint64_t)v1, Connection, &v12);
  if (*(void *)&v13[4] && (v14 & 1) != 0) {
    (*(void (**)(void))(**(void **)&v13[4] + 40))(*(void *)&v13[4]);
  }
}

void *re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::cloneInto(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  *a2 = &unk_26DD36748;
  a2[1] = v4;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 2));
  uint64_t v5 = a1[6];
  a2[6] = v5;
  if (v5) {
    id v6 = (id)(v5 + 8);
  }
  return a2;
}

void *re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::moveInto(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  *a2 = &unk_26DD36748;
  a2[1] = v4;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 2));
  a2[6] = a1[6];
  a1[6] = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onConnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::size()
{
  return 56;
}

void *re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD367A0;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 3));
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD367A0;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 3));
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 8);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if (v2)
  {
    unint64_t v4 = *(void *)(*(void *)(a1 + 16) + 24);
    uint64_t v5 = re::DataArray<re::Connection>::tryGet(v1 + 120, v4);
    if (v5)
    {
      re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v5 + 40), *(void *)(a1 + 16));
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      re::DynamicString::setCapacity(&v10[4], 0);
      int v14 = 0;
      int v9 = 2;
      re::Transport::connectionStateEvent(v1, v4, &v9);
      if (*(void *)&v10[4])
      {
        if (v11) {
          (*(void (**)(void))(**(void **)&v10[4] + 40))();
        }
      }
    }
    else
    {
      uint64_t v7 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(a1 + 32)) {
          uint64_t v8 = *(void *)(a1 + 40);
        }
        else {
          uint64_t v8 = a1 + 33;
        }
        int v9 = 136315138;
        *(void *)uint64_t v10 = v8;
        _os_log_impl(&dword_228C70000, v7, OS_LOG_TYPE_DEFAULT, "Connection for address '%s' is already destroyed.Check logs for prior connection errors.", (uint8_t *)&v9, 0xCu);
      }
    }
  }
}

void *re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::cloneInto(void *a1, void *a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  *a2 = &unk_26DD367A0;
  a2[1] = v5;
  a2[2] = v4;
  if (v4) {
    id v6 = (id)(v4 + 8);
  }
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 3), (const re::DynamicString *)(a1 + 3));
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD367A0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 24), (const re::DynamicString *)(a1 + 24));
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onDisconnected(re::ProtocolLayer *,re::ProtocolHandle *,re::Address const&)::$_0,void ()(void)>::size()
{
  return 56;
}

void *re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD367F8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD367F8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if (v2)
  {
    unint64_t v4 = *(void *)(*(void *)(a1 + 16) + 24);
    uint64_t v5 = re::DataArray<re::Connection>::tryGet(v1 + 120, v4);
    if (v5)
    {
      re::SharedPtr<re::SyncObject>::reset((uint64_t *)(v5 + 40), *(void *)(a1 + 16));
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      re::DynamicString::setCapacity(&v9, 0);
      int v14 = 0;
      int v8 = 3;
      char v13 = *(unsigned char *)(a1 + 24);
      re::Transport::connectionStateEvent(v1, v4, &v8);
      if (v9)
      {
        if (v10) {
          (*(void (**)(void))(*v9 + 40))();
        }
      }
    }
    else
    {
      uint64_t v7 = *re::networkLogObjects(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v8) = 0;
        _os_log_debug_impl(&dword_228C70000, v7, OS_LOG_TYPE_DEBUG, "Connection was destroyed before error event.", (uint8_t *)&v8, 2u);
      }
    }
  }
}

uint64_t re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)a2 = &unk_26DD367F8;
  *(void *)(a2 + 8) = v5;
  *(void *)(a2 + 16) = v4;
  if (v4) {
    id v6 = (id)(v4 + 8);
  }
  *(unsigned char *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(unsigned char *)(a1 + 24);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD367F8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(unsigned char *)(a1 + 24);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onError(re::ProtocolLayer *,re::ProtocolHandle *,re::TransportError)::$_0,void ()(void)>::size()
{
  return 32;
}

void *re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36850;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36850;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

uint64_t re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if (v2)
  {
    BOOL result = re::DataArray<re::Connection>::tryGet(v1 + 120, *(void *)(*(void *)(result + 16) + 24));
    if (result)
    {
      if (!*(unsigned char *)(result + 120))
      {
        *(unsigned char *)(result + 120) = 1;
        uint64_t v3 = *(uint64_t (**)(void))(**(void **)(v1 + 608) + 32);
        return v3();
      }
    }
  }
  return result;
}

void *re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *a2 = &unk_26DD36850;
  a2[1] = v4;
  a2[2] = v3;
  if (v3) {
    id v5 = (id)(v3 + 8);
  }
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36850;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onUnresponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::size()
{
  return 24;
}

void *re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD368A8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD368A8;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

uint64_t re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 336));
  if (v2)
  {
    BOOL result = re::DataArray<re::Connection>::tryGet(v1 + 120, *(void *)(*(void *)(result + 16) + 24));
    if (result)
    {
      if (*(unsigned char *)(result + 120))
      {
        *(unsigned char *)(result + 120) = 0;
        *(void *)(result + 128) = 0x8000000000000000;
        uint64_t v3 = *(uint64_t (**)(void))(**(void **)(v1 + 608) + 40);
        return v3();
      }
    }
  }
  return result;
}

void *re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *a2 = &unk_26DD368A8;
  a2[1] = v4;
  a2[2] = v3;
  if (v3) {
    id v5 = (id)(v3 + 8);
  }
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD368A8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onResponsive(re::ProtocolLayer *,re::ProtocolHandle *)::$_0,void ()(void)>::size()
{
  return 24;
}

void *re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36900;
  uint64_t v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD36900;
  uint64_t v2 = a1[3];
  if (v2)
  {

    a1[3] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v2 + 336));
  if ((v3 & 1) != 0 && re::DataArray<re::Connection>::tryGet(v2 + 120, *(void *)(*(void *)(a1 + 24) + 24))) {
    (*(void (**)(uint64_t, void, void, void, void, void))(*(void *)v2 + 64))(v2, *(void *)(a1 + 16), *(void *)(a1 + 24), *(unsigned __int8 *)(a1 + 32), *(void *)(*(void *)(a1 + 40) + 16), *(unsigned int *)(*(void *)(a1 + 40) + 24));
  }
  uint64_t v4 = *(re::Packet **)(a1 + 40);
  id v5 = *(re::PacketPool **)(v2 + 384);
  re::PacketPool::free(v5, v4);
}

uint64_t re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36900;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 24);
  *(void *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v4;
  if (v4) {
    id v5 = (id)(v4 + 8);
  }
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36900;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(void *)(a1 + 24);
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::onReceiveAsync(re::ProtocolLayer *,re::ProtocolHandle *,re::ChannelId,void const*,unsigned int)::$_0,void ()(void)>::size()
{
  return 48;
}

void re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 72) + 136))(*(void *)(*(void *)(a1 + 8) + 72), *(unsigned int *)(a1 + 16));
}

uint64_t re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36958;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD36958;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Transport::setDisconnectTimeout(unsigned int)::$_0,void ()(void)>::size()
{
  return 24;
}

void *re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD369B0;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26DD369B0;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x22A6A9430);
}

void re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  (*(void (**)(void, void, uint64_t))(**(void **)(v2 + 72) + 56))(*(void *)(v2 + 72), *(void *)(a1 + 16), 1);
  uint64_t v3 = *(void *)(a1 + 16);
  re::Transport::cleanupPendingQueues((re::PacketPool **)v2, v3);
}

void *re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *a2 = &unk_26DD369B0;
  a2[1] = v4;
  a2[2] = v3;
  if (v3) {
    id v5 = (id)(v3 + 8);
  }
  return a2;
}

uint64_t re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26DD369B0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::Transport::destroyConnection(unsigned long long)::$_0,void ()(void)>::size()
{
  return 24;
}

_anonymous_namespace_ *re::DataArray<re::Connection>::allocBlock(void *a1)
{
  uint64_t v3 = 136 * *((unsigned int *)a1 + 11);
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(void *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v6 = v4;
  uint64_t v1 = 4 * *((unsigned int *)a1 + 11);
  BOOL result = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(void *)(*a1 + 8));
    BOOL result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  int v9 = result;
  unint64_t v11 = a1[1];
  unint64_t v10 = a1[2];
  if (v10 >= v11)
  {
    unint64_t v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        unint64_t v13 = 2 * v11;
        if (!v11) {
          unint64_t v13 = 8;
        }
        if (v13 <= v12) {
          unint64_t v14 = v12;
        }
        else {
          unint64_t v14 = v13;
        }
        BOOL result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(a1, v14);
      }
      else
      {
        BOOL result = (_anonymous_namespace_ *)re::DynamicArray<re::PoolAllocator::PoolFreeList>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    unint64_t v10 = a1[2];
  }
  uint64_t v15 = (uint64_t *)(a1[4] + 16 * v10);
  uint64_t *v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

void re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  unint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    unint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::DataArray<re::Connection>::DataArrayIterator<re::Connection,re::Connection&>::DataArrayIterator(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  if (*(_DWORD *)(a2 + 40))
  {
    *(_DWORD *)(a1 + 8) = 0;
    if (!*(void *)(a2 + 16))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (!**(_DWORD **)(*(void *)(a2 + 32) + 8)) {
      re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::increment((_WORD *)a1);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) = -1;
  }
  return a1;
}

uint64_t re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v30, 0, 36);
          *(void *)&v30[36] = 0x7FFFFFFFLL;
          re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::init((uint64_t)v30, v13, v12);
          long long v15 = *(_OWORD *)v30;
          *(_OWORD *)uint64_t v30 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v30[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v30[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v30[24];
          *(_OWORD *)&v30[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v30[32];
          *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v19;
          unint64_t v20 = v18;
          if (v18)
          {
            unint64_t v21 = 0;
            uint64_t v22 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v22 - 8) & 0x80000000) != 0) {
                re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsMove(a1, *(void *)(v22 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v22 - 16), v22 - 4, v22);
              }
              ++v21;
              v22 += 80;
            }
            while (v21 < v20);
          }
          re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit((uint64_t *)v30);
        }
      }
      else
      {
        if (v12) {
          signed int v25 = 2 * v11;
        }
        else {
          signed int v25 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 80 * v9 + 8);
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 80 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 80 * v9 + 8) = v24 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 80 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 80 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 80 * v9) = a3;
  *(_WORD *)(*(void *)(a1 + 16) + 80 * v9 + 12) = *a4;
  uint64_t v26 = *(void *)(a1 + 16) + 80 * v9;
  *(void *)(v26 + 16) = 0;
  *(void *)(v26 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(void *)(v26 + 32) = 0;
  *(void *)(v26 + 16) = *(void *)a5;
  *(void *)a5 = 0;
  *(void *)(v26 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *(void *)(a5 + 8);
  *(void *)(a5 + 8) = 0;
  uint64_t v27 = *(void *)(v26 + 32);
  *(void *)(v26 + 32) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = v27;
  *(void *)(v26 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  *(void *)(v26 + 48) = 0;
  *(void *)(v26 + 56) = 0;
  *(void *)(v26 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = *(void *)(a5 + 24);
  *(void *)(a5 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(void *)(v26 + 48) = *(void *)(a5 + 32);
  *(void *)(a5 + 32) = 0;
  uint64_t v28 = *(void *)(v26 + 56);
  *(void *)(v26 + 56) = *(void *)(a5 + 40);
  *(void *)(a5 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = v28;
  *(_OWORD *)(v26 + 64) = *(_OWORD *)(a5 + 48);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned short,re::PendingPacketFragments,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 80 * v10, 16);
  if (v12)
  {
    BOOL v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_228CDE530, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v10;
    *(_DWORD *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::FixedArray<unsigned char>::init<>(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (a3)
  {
    uint64_t v5 = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3, 1);
    a1[2] = v5;
    if (v5)
    {
      uint64_t v7 = v5;
      size_t v8 = a3 - 1;
      if (v8)
      {
        bzero(v5, v8);
        v7 += v8;
      }
      *uint64_t v7 = 0;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
  }
}

void re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v21, 0, 36);
      *(void *)&v21[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::init((uint64_t)v21, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v21;
      uint64_t v6 = *(unint64_t **)(a1 + 16);
      long long v7 = *(_OWORD *)&v21[8];
      *(_OWORD *)unint64_t v21 = v5;
      *(void *)&v21[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v21[24];
      *(_OWORD *)&v21[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v21[32];
      *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        do
        {
          if ((v6[1] & 0x80000000) != 0)
          {
            unint64_t v13 = *v6;
            unint64_t v14 = *(unsigned int *)(a1 + 24);
            unint64_t v15 = *v6 % v14;
            uint64_t v16 = *(unsigned int *)(a1 + 36);
            if (v16 == 0x7FFFFFFF)
            {
              uint64_t v16 = *(unsigned int *)(a1 + 32);
              int v17 = v16;
              if (v16 == v14)
              {
                re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v15 = v13 % *(unsigned int *)(a1 + 24);
                int v17 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v17 + 1;
              uint64_t v18 = *(void *)(a1 + 16);
              int v19 = *(_DWORD *)(v18 + 56 * v16 + 8);
            }
            else
            {
              uint64_t v18 = *(void *)(a1 + 16);
              int v19 = *(_DWORD *)(v18 + 56 * v16 + 8);
              *(_DWORD *)(a1 + 36) = v19 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v18 + 56 * v16 + 8) = v19 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 56 * v16 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v16 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v15);
            *(void *)(*(void *)(a1 + 16) + 56 * v16) = v13;
            re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v16 + 16), (const re::DynamicString *)(v6 + 2));
            *(void *)(*(void *)(a1 + 16) + 56 * v16 + 48) = v6[6];
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v15) = v16;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v6 += 7;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::Address,unsigned long long,re::Address::Hasher,re::EqualTo<re::Address>,true,false>::deinit((uint64_t *)v21);
    }
  }
  else
  {
    if (a2) {
      signed int v20 = a2;
    }
    else {
      signed int v20 = 3;
    }
  }
}

void *re::DynamicArray<re::ArcWeakPtr<re::TransportStream>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    long long v5 = result;
    if (result[2] <= a2)
    {
      BOOL result = (void *)*result;
      if (!*v5)
      {
        BOOL result = (void *)re::DynamicArray<re::ArcWeakPtr<re::TransportStream>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 8 * a2;
          BOOL result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            long long v7 = (id *)result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        BOOL result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      long long v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      unsigned int v8 = (id *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 8 * v9;
        int v11 = v7;
        uint64_t v12 = v7;
        do
        {
          *v12++ = 0;
          objc_moveWeak(v11, v8);
          objc_destroyWeak(v8);
          *v8++ = 0;
          int v11 = v12;
          v10 -= 8;
        }
        while (v10);
        unsigned int v8 = (id *)v5[4];
      }
      BOOL result = (void *)(*(uint64_t (**)(void, id *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<unsigned long &>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

id *re::ArcWeakPtr<re::TransportStream>::operator=(id *location, id *a2)
{
  if (a2 != location)
  {
    objc_destroyWeak(location);
    *id location = 0;
    objc_moveWeak(location, a2);
  }
  return location;
}

uint64_t re::BitReader::seekTo(uint64_t result, uint64_t a2)
{
  if (!*(unsigned char *)(result + 12))
  {
    if (HIDWORD(a2)) {
      unsigned int v2 = a2 + 1;
    }
    else {
      unsigned int v2 = a2;
    }
    unsigned int v3 = *(_DWORD *)(result + 8);
    if (v2 <= v3)
    {
      return re::BitReader::applyMarker(result, a2);
    }
    else
    {
      *(_DWORD *)(result + 16) = v3;
      *(_DWORD *)(result + 20) = 0;
      *(unsigned char *)(result + 12) = 1;
    }
  }
  return result;
}

uint64_t re::BitReader::applyMarker(uint64_t result, uint64_t a2)
{
  if (HIDWORD(a2))
  {
    *(_DWORD *)(result + 16) = a2 + 1;
    *(_DWORD *)(result + 20) = 8 - HIDWORD(a2);
    *(void *)(result + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
    if (HIDWORD(a2) != 8) {
      *(void *)(result + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = (unint64_t)*(unsigned __int8 *)(*(void *)result + a2) >> SBYTE4(a2);
    }
  }
  else
  {
    *(_DWORD *)(result + 16) = a2;
    *(_DWORD *)(result + 20) = 0;
    *(void *)(result + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  }
  return result;
}

uint64_t *re::BitReader::readUInt32Bits(uint64_t *this, unsigned int a2, unsigned int *a3)
{
  *a3 = 0;
  if (!*((unsigned char *)this + 12))
  {
    int v3 = *((_DWORD *)this + 2);
    unsigned int v5 = *((_DWORD *)this + 4);
    unsigned int v4 = *((_DWORD *)this + 5);
    if (v4 + 8 * (v3 - v5) >= a2)
    {
      if (v4 >= a2)
      {
        unint64_t v8 = this[3];
      }
      else
      {
        uint64_t v7 = *this;
        unint64_t v8 = this[3];
        do
        {
          *((_DWORD *)this + 4) = v5 + 1;
          v8 |= (unint64_t)*(unsigned __int8 *)(v7 + v5) << v4;
          this[3] = v8;
          v4 += 8;
          *((_DWORD *)this + 5) = v4;
          ++v5;
        }
        while (v4 < a2);
      }
      *a3 = v8 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a2);
      this[3] = v8 >> a2;
      unsigned int v6 = *((_DWORD *)this + 5) - a2;
    }
    else
    {
      unsigned int v6 = 0;
      *((unsigned char *)this + 12) = 1;
      *((_DWORD *)this + 4) = v3;
    }
    *((_DWORD *)this + 5) = v6;
  }
  return this;
}

uint64_t *re::BitReader::readUInt64Bits(re::BitReader *this, unsigned int a2, unint64_t *a3)
{
  if (a2 < 0x21)
  {
    unsigned int v8 = 0;
    BOOL result = re::BitReader::readUInt32Bits((uint64_t *)this, a2, &v8);
    unint64_t v7 = v8;
  }
  else
  {
    *(void *)uint64_t v9 = 0;
    re::BitReader::readUInt32Bits((uint64_t *)this, 0x20u, &v9[1]);
    BOOL result = re::BitReader::readUInt32Bits((uint64_t *)this, a2 - 32, v9);
    unint64_t v7 = v9[1] | ((unint64_t)v9[0] << 32);
  }
  *a3 = v7;
  return result;
}

uint64_t *re::BitReader::readUInt64(re::BitReader *this, unint64_t *a2)
{
  *(void *)unsigned int v5 = 0;
  re::BitReader::readUInt32Bits((uint64_t *)this, 0x20u, &v5[1]);
  BOOL result = re::BitReader::readUInt32Bits((uint64_t *)this, 0x20u, v5);
  *a2 = v5[1] | ((unint64_t)v5[0] << 32);
  return result;
}

uint64_t RESyncableGetTypeId(uint64_t result)
{
  if (result) {
    return *(void *)(*(void *)(*(void *)(result + 88) + 16) + 32);
  }
  return result;
}

uint64_t RESyncableGetTypeInfo(uint64_t result)
{
  if (result) {
    return *(void *)(*(void *)(result + 88) + 16);
  }
  return result;
}

uint64_t RESyncableReadState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0;
  if (a1 && a3)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 88) + 16);
    uint64_t v7 = *(void *)(a3 + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 8);
      if (*(_DWORD *)(v7 + 28)) {
        LODWORD(v7) = *(_DWORD *)(v7 + 24) + 1;
      }
      else {
        LODWORD(v7) = *(_DWORD *)(v7 + 24);
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
    uint64_t v9 = v8;
    int v10 = v7;
    char v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    return (*(uint64_t (**)(void, uint64_t *, uint64_t, uint64_t))(*(void *)(v6 + 80) + 16))(*(void *)(v6 + 80), &v9, a2, a4);
  }
  return result;
}

uint64_t RESyncableIsDestroyed(uint64_t result)
{
  if (result) {
    return (*(unsigned __int8 *)(result + 128) >> 2) & 1;
  }
  return result;
}

uint64_t RESyncableGetGuid(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t RESyncableGetParent(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

uint64_t RESyncableGetChildCount(uint64_t result)
{
  if (result) {
    return *(void *)(result + 200);
  }
  return result;
}

uint64_t RESyncableGetChild(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(void *)(result + 200) <= a2) {
      return 0;
    }
    else {
      return *(void *)(*(void *)(result + 216) + 8 * a2);
    }
  }
  return result;
}

void *RESyncableSetUserData(void *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    if (a2 && a3)
    {
      v4[0] = MEMORY[0x263EF8330];
      v4[1] = 0x40000000;
      void v4[2] = __RESyncableSetUserData_block_invoke;
      v4[3] = &unk_264854A28;
      void v4[4] = a3;
      return re::SyncObject::setUserData((uint64_t)result, a2, v4);
    }
    else
    {
      return re::SyncObject::setUserData((uint64_t)result, a2, 0);
    }
  }
  return result;
}

uint64_t __RESyncableSetUserData_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t RESyncableGetUserData(uint64_t result)
{
  if (result) {
    return *(void *)(result + 112);
  }
  return result;
}

uint64_t RESyncableIsAuthoritative(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 80);
    if (v1)
    {
      do
      {
        uint64_t v2 = result;
        uint64_t result = v1;
        if (*(unsigned char *)(*(void *)(*(void *)(v2 + 88) + 16) + 73)) {
          break;
        }
        uint64_t v1 = *(void *)(v1 + 80);
        uint64_t v2 = result;
      }
      while (v1);
    }
    else
    {
      uint64_t v2 = result;
    }
    return *(unsigned char *)(v2 + 170) != 0;
  }
  return result;
}

BOOL RESyncableSetLocked(uint64_t a1, char a2)
{
  if (a1 && !*(void *)(a1 + 160) && !*(void *)(a1 + 136)) {
    *(unsigned char *)(a1 + 152) = a2;
  }
  return a1 != 0;
}

uint64_t RESyncableIsLocked(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 80);
    if (v1)
    {
      do
      {
        uint64_t v2 = result;
        uint64_t result = v1;
        if (*(unsigned char *)(*(void *)(*(void *)(v2 + 88) + 16) + 73)) {
          break;
        }
        uint64_t v1 = *(void *)(v1 + 80);
        uint64_t v2 = result;
      }
      while (v1);
    }
    else
    {
      uint64_t v2 = result;
    }
    return *(unsigned char *)(v2 + 152) != 0;
  }
  return result;
}

BOOL RESyncableSetMigrateWhenAbandoned(uint64_t a1, char a2)
{
  if (a1) {
    *(unsigned char *)(a1 + 171) = a2;
  }
  return a1 != 0;
}

uint64_t RESyncableIsMigrateWhenAbandoned(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 80);
    if (v1)
    {
      do
      {
        uint64_t v2 = result;
        uint64_t result = v1;
        if (*(unsigned char *)(*(void *)(*(void *)(v2 + 88) + 16) + 73)) {
          break;
        }
        uint64_t v1 = *(void *)(v1 + 80);
        uint64_t v2 = result;
      }
      while (v1);
    }
    else
    {
      uint64_t v2 = result;
    }
    return *(unsigned char *)(v2 + 171) != 0;
  }
  return result;
}

uint64_t RESyncableGetOwnerPeerID(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 80);
    if (v1)
    {
      do
      {
        uint64_t v2 = result;
        uint64_t result = v1;
        if (*(unsigned char *)(*(void *)(*(void *)(v2 + 88) + 16) + 73)) {
          break;
        }
        uint64_t v1 = *(void *)(v1 + 80);
        uint64_t v2 = result;
      }
      while (v1);
    }
    else
    {
      uint64_t v2 = result;
    }
    return *(void *)(v2 + 160);
  }
  return result;
}

re::SyncObject *RESyncableGetFromPeerID(re::SyncObject *result)
{
  if (result) {
    return (re::SyncObject *)re::SyncObject::fromPeerID(result);
  }
  return result;
}

BOOL RESyncableIsOpaque(BOOL result)
{
  if (result) {
    return *(unsigned char *)(*(void *)(*(void *)(result + 88) + 16) + 72) != 0;
  }
  return result;
}

re::SyncObject *RESyncableHandoffOwnership(re::SyncObject *this, uint64_t a2)
{
  if (this) {
    return (re::SyncObject *)re::SyncObject::handOff(this, a2);
  }
  return this;
}

uint64_t RESyncableHasOwnership(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 80);
    if (v1)
    {
      do
      {
        uint64_t v2 = result;
        uint64_t result = v1;
        if (*(unsigned char *)(*(void *)(*(void *)(v2 + 88) + 16) + 73)) {
          break;
        }
        uint64_t v1 = *(void *)(v1 + 80);
        uint64_t v2 = result;
      }
      while (v1);
    }
    else
    {
      uint64_t v2 = result;
    }
    return *(void *)(v2 + 160) == 0;
  }
  return result;
}

uint64_t RESyncableSetDirectView(uint64_t result, re::SyncView *a2)
{
  if (result)
  {
    if (*(unsigned char *)(*(void *)(*(void *)(result + 88) + 16) + 74))
    {
      re::SyncObject::setViewDirectly((re::SyncObject *)result, a2);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t RESyncableGetDirectView(uint64_t result)
{
  if (result) {
    return *(void *)(result + 96);
  }
  return result;
}

void *RESyncableGetHierarchicalView(void *result)
{
  if (result)
  {
    while (!*(unsigned char *)(*(void *)(result[11] + 16) + 74))
    {
      uint64_t result = (void *)result[10];
      if (!result) {
        return result;
      }
    }
    return (void *)result[12];
  }
  return result;
}

uint64_t RESyncReadContextGetSyncable(uint64_t **a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = **a1;
  if (v1)
  {
    id v2 = (id)(v1 + 8);
  }
  return v1;
}

uint64_t RESyncableSetHoldID(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 32) = a2;
  }
  return result;
}

uint64_t RESyncableGetHoldID(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

BOOL re::MultipeerDiscoveryView::init(id *this, ObjCObject a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)a2.var0;
  if (*(void *)a2.var0)
  {
    unsigned int v5 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(this + 3, 0);
    ++*((_DWORD *)this + 12);
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity(this + 14, 0);
    ++*((_DWORD *)this + 34);
    id v6 = *(id *)a2.var0;
    uint64_t v7 = [v6 myPeerID];
    uint64_t v8 = re::globalAllocators(v7);
    uint64_t v9 = (MCIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 72, 8);
    MCIdentity::MCIdentity(v9, (MCPeerID *)v7, 1);
    *(void *)long long buf = v10;
    re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add(this + 26, buf);
    if (*(void *)buf)
    {

      *(void *)long long buf = 0;
    }

    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    char v11 = [v6 connectedPeers];
    uint64_t v12 = [v11 countByEnumeratingWithState:&v21 objects:v26 count:16];
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = *(void *)v22;
      do
      {
        for (uint64_t i = 0; i != v13; ++i)
        {
          if (*(void *)v22 != v14) {
            objc_enumerationMutation(v11);
          }
          *(void *)long long buf = *(void *)(*((void *)&v21 + 1) + 8 * i);
          char v18 = 0;
          re::make::shared::object<MCIdentity,MCPeerID * const {__strong}&,BOOL>((re *)&v19, (MCPeerID **)buf, &v18);
          uint64_t v20 = v19;
          re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add(this + 26, &v20);
          if (v20) {
        }
          }
        uint64_t v13 = [v11 countByEnumeratingWithState:&v21 objects:v26 count:16];
      }
      while (v13);
    }

    re::ObjCObject::operator=(this + 25, (id *)a2.var0);
  }
  else
  {
    uint64_t v16 = *re::networkLogObjects((re *)this);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_228C70000, v16, OS_LOG_TYPE_ERROR, "Invalid MCSession.", buf, 2u);
    }
  }
  return v2 != 0;
}

void *re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add(void *this, void *a2)
{
  uint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::SharedPtr<re::SyncObject>>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  *(void *)(v3[4] + 8 * v4) = *a2;
  *a2 = 0;
  _OWORD v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

uint64_t re::MultipeerDiscoveryView::didJoinEvent(re::MultipeerDiscoveryView *this)
{
  return (uint64_t)this + 24;
}

uint64_t re::MultipeerDiscoveryView::didLeaveEvent(re::MultipeerDiscoveryView *this)
{
  return (uint64_t)this + 112;
}

uint64_t re::MultipeerDiscoveryView::identitiesCount(re::MultipeerDiscoveryView *this)
{
  return *((void *)this + 28);
}

void *re::MultipeerDiscoveryView::identityAtIndex@<X0>(void *this@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (this[28] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v3 = *(void *)(this[30] + 8 * a2);
  *a3 = v3;
  if (v3)
  {
    return (id)(v3 + 8);
  }
  return this;
}

id re::MultipeerDiscoveryView::multipeerIdAtIndex@<X0>(re::MultipeerDiscoveryView *this@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (*((void *)this + 28) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  id result = *(id *)(*(void *)(*((void *)this + 30) + 8 * a2) + 24);
  *a3 = result;
  return result;
}

void re::MultipeerDiscoveryView::requestIdentity(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  id v4 = *(id *)(a1 + 200);
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id v14 = v4;
  unsigned int v5 = [v4 connectedPeers];
  uint64_t v6 = [v5 countByEnumeratingWithState:&v20 objects:v25 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v21;
    do
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v21 != v8) {
          objc_enumerationMutation(v5);
        }
        long long v24 = *(MCPeerID **)(*((void *)&v20 + 1) + 8 * i);
        +[REMultipeerHelper makeAddressFromPeerID:](REMultipeerHelper, "makeAddressFromPeerID:");
        if (re::DynamicString::operator==(a2, (uint64_t)&v18))
        {
          char v16 = 0;
          re::make::shared::object<MCIdentity,MCPeerID * const {__strong}&,BOOL>((re *)&v17, &v24, &v16);
          uint64_t v10 = v17;
          unint64_t v11 = *(void *)(a1 + 224);
          if (v11 >= *(void *)(a1 + 216))
          {
            re::DynamicArray<re::SharedPtr<re::SyncObject>>::growCapacity((void *)(a1 + 208), v11 + 1);
            unint64_t v11 = *(void *)(a1 + 224);
          }
          *(void *)(*(void *)(a1 + 240) + 8 * v11) = v10;
          if (v10)
          {
            id v12 = (id)(v10 + 8);
            ++*(void *)(a1 + 224);
            ++*(_DWORD *)(a1 + 232);
            uint64_t v15 = v10;
            id v13 = (id)(v10 + 8);
          }
          else
          {
            *(void *)(a1 + 2re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v11 + 1;
            ++*(_DWORD *)(a1 + 232);
            uint64_t v15 = 0;
          }
          re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(a1 + 24, a1);
          if (v15) {

          }
          if (v10) {
        }
          }
        if (v18 && (v19 & 1) != 0) {
          (*(void (**)(void))(*(void *)v18 + 40))();
        }
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v20 objects:v25 count:16];
    }
    while (v7);
  }
}

BOOL re::MultipeerDiscoveryView::removeIdentity(uint64_t a1, void *a2)
{
  BOOL v4 = re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::remove(a1 + 208, a2);
  if (v4)
  {
    uint64_t v7 = *a2;
    if (*a2) {
      id v5 = (id)(*a2 + 8);
    }
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(a1 + 112, a1);
    if (v7) {
  }
    }
  return v4;
}

BOOL re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::remove(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    id v5 = *(void **)(a1 + 32);
    while (*v5 != *a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        id v5 = (void *)(v2 + 8 * v3);
        break;
      }
    }
  }
  else
  {
    id v5 = *(void **)(a1 + 32);
  }
  uint64_t v6 = (uint64_t)v5 - v2;
  uint64_t v7 = v6 >> 3;
  if (v6 >> 3 != v3) {
    re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt(a1, v6 >> 3);
  }
  return v7 != v3;
}

void re::MultipeerDiscoveryView::createProtocolLayer(id *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4 = re::globalAllocators((re *)this);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 80, 8);
  id v6 = this[25];
  re::MultipeerProtocolLayer::MultipeerProtocolLayer(v5, &v6);

  *a2 = v5;
}

void re::MultipeerDiscoveryView::~MultipeerDiscoveryView(id *this)
{
  *this = &unk_26DD36A08;
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)(this + 26));

  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event(this + 14);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event(this + 3);
  *this = &unk_26DD34510;
  objc_destructInstance(this + 1);
}

{
  uint64_t vars8;

  *this = &unk_26DD36A08;
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)(this + 26));

  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event(this + 14);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event(this + 3);
  *this = &unk_26DD34510;
  objc_destructInstance(this + 1);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::MultipeerDiscoveryView::authData(re::MultipeerDiscoveryView *this)
{
  return 0;
}

void MCIdentity::MCIdentity(MCIdentity *this, MCPeerID *a2, char a3)
{
  uint64_t v5 = a2;
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD36A90;
  *(_OWORD *)((char *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0u;
  *(_OWORD *)((char *)this + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0u;
  *((void *)this + 7) = 0;
  re::DynamicString::setCapacity((void *)this + 4, 0);
  *((unsigned char *)this + 64) = 0;
  uint64_t v7 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v5;
  uint64_t v8 = v5;

  +[REMultipeerHelper makeAddressFromPeerID:v8];
  re::DynamicString::operator=((MCIdentity *)((char *)this + 32), (re::DynamicString *)&v9);
  if (v9 && (v10 & 1) != 0) {
    (*(void (**)(void))(*(void *)v9 + 40))();
  }
  *((unsigned char *)this + 64) = a3;
}

void MCIdentity::~MCIdentity(id *this)
{
  *this = &unk_26DD36A90;
  re::DynamicString::deinit((re::DynamicString *)(this + 4));

  *this = &unk_26DD34510;
  objc_destructInstance(this + 1);
}

{
  uint64_t vars8;

  *this = &unk_26DD36A90;
  re::DynamicString::deinit((re::DynamicString *)(this + 4));

  *this = &unk_26DD34510;
  objc_destructInstance(this + 1);
  JUMPOUT(0x22A6A9430);
}

uint64_t MCIdentity::displayName(id *this)
{
  id v1 = [this[3] displayName];
  uint64_t v2 = [v1 UTF8String];

  return v2;
}

re::DynamicString *MCIdentity::address@<X0>(MCIdentity *this@<X0>, re::DynamicString *a2@<X8>)
{
  return re::DynamicString::DynamicString(a2, (MCIdentity *)((char *)this + 32));
}

uint64_t MCIdentity::isLocal(MCIdentity *this)
{
  return *((unsigned __int8 *)this + 64);
}

void re::make::shared::object<MCIdentity,MCPeerID * const {__strong}&,BOOL>(re *a1, MCPeerID **a2, char *a3)
{
  id v6 = re::globalAllocators(a1);
  uint64_t v7 = (MCIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[2] + 32))(v6[2], 72, 8);
  MCIdentity::MCIdentity(v7, *a2, *a3);
  *(void *)a1 = v8;
}

uint64_t re::TcpProtocolLayer::TcpProtocolLayer(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26DD36AF0;
  *(_DWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = -1;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 68) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 116) = 0x7FFFFFFFLL;
  *(_DWORD *)(a1 + 128) = *(_DWORD *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 136), (const re::DynamicString *)(a2 + 8));
  *(_WORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 168) = *(_WORD *)(a2 + 40);
  *(_DWORD *)(a1 + 176) = 10;
  *(_WORD *)(a1 + 180) = 0;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = -1;
  *(void *)(a1 + 200) = 0;
  return a1;
}

void re::TcpProtocolLayer::~TcpProtocolLayer(re::TcpProtocolLayer *this)
{
  *(void *)this = &unk_26DD36AF0;
  if (*((_DWORD *)this + 6) != -1) {
    re::TcpProtocolLayer::deinit(this);
  }
  re::DynamicString::deinit((re::TcpProtocolLayer *)((char *)this + 136));
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 10);
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 4);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::TcpProtocolLayer::~TcpProtocolLayer(this);
  JUMPOUT(0x22A6A9430);
}

BOOL re::TcpProtocolLayer::init(uint64_t a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 200) = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 180) = 0;
  *(_DWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = kqueue();
  if (*(unsigned char *)(a1 + 144)) {
    uint64_t v3 = *(re::IP **)(a1 + 152);
  }
  else {
    uint64_t v3 = (re::IP *)(a1 + 145);
  }
  uint64_t v4 = (re *)re::IP::makeFromString(v3, (uint64_t)v57);
  if (!v57[0])
  {
    uint64_t v5 = *re::networkLogObjects(v4);
    BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if (*(unsigned char *)(a1 + 144)) {
      uint64_t v8 = *(void *)(a1 + 152);
    }
    else {
      uint64_t v8 = a1 + 145;
    }
    v56.ai_flags = 136315138;
    *(void *)&v56.ai_family = v8;
    long long v21 = "An error occurred while trying to create an Tcp server host. Invalid bind address: %s";
    goto LABEL_47;
  }
  if (v57[8])
  {
    uint64_t v5 = *re::networkLogObjects(v4);
    BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    if (*(unsigned char *)(a1 + 144)) {
      uint64_t v7 = *(void *)(a1 + 152);
    }
    else {
      uint64_t v7 = a1 + 145;
    }
    v56.ai_flags = 136315138;
    *(void *)&v56.ai_family = v7;
    long long v21 = "An error occurred while trying to create an Tcp server host. Tcp only supports IPv4. IPv6 requested. (%s)";
LABEL_47:
    p_changelisstd::__libcpp_thread_t t = (uint8_t *)&v56;
    long long v23 = v5;
LABEL_48:
    uint32_t v24 = 12;
    goto LABEL_49;
  }
  memset(&v56.ai_addrlen, 0, 32);
  v56.ai_flags = 0;
  *(void *)&v56.ai_family = 0x100000002;
  v56.ai_protocol = 6;
  __int16 v55 = 0;
  *(void *)__str = 0;
  snprintf(__str, 0xAuLL, "%i", *(unsigned __int16 *)(a1 + 168));
  int v49 = 0;
  if (*(unsigned char *)(a1 + 144)) {
    uint64_t v9 = *(const char **)(a1 + 152);
  }
  else {
    uint64_t v9 = (const char *)(a1 + 145);
  }
  char v10 = (re *)getaddrinfo(v9, __str, &v56, &v49);
  if (v10)
  {
    int v11 = (int)v10;
    id v12 = *re::networkLogObjects(v10);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v36 = gai_strerror(v11);
      LODWORD(changelist.ident) = 136315138;
      *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)v36;
      _os_log_error_impl(&dword_228C70000, v12, OS_LOG_TYPE_ERROR, "getaddrinfo failed: %s", (uint8_t *)&changelist, 0xCu);
    }
    freeaddrinfo(v49);
    return 0;
  }
  int v13 = socket(v49->ai_family, v49->ai_socktype, v49->ai_protocol);
  *(_DWORD *)(a1 + 192) = v13;
  int v48 = 1;
  setsockopt(v13, 0xFFFF, 4, &v48, 4u);
  int v14 = bind(*(_DWORD *)(a1 + 192), v49->ai_addr, v49->ai_addrlen);
  freeaddrinfo(v49);
  int v49 = 0;
  if (v14 < 0)
  {
    uint64_t v17 = *re::networkLogObjects(v15);
    BOOL result = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v18 = gai_strerror(v14);
    char v19 = __error();
    long long v20 = strerror(*v19);
    LODWORD(changelist.ident) = 136315650;
    *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)__str;
    LOWORD(changelist.fflags) = 2080;
    *(void *)((char *)&changelist.fflags + 2) = v18;
    HIWORD(changelist.data) = 2080;
    changelist.udata = (uint64_t)v20;
    long long v21 = "bind on port %s failed: %s errno = %s";
    p_changelisstd::__libcpp_thread_t t = (uint8_t *)&changelist;
    long long v23 = v17;
    uint32_t v24 = 32;
    goto LABEL_49;
  }
  socklen_t v47 = 16;
  char v16 = (re *)getsockname(*(_DWORD *)(a1 + 192), &v53, &v47);
  if ((v16 & 0x80000000) != 0)
  {
    int v25 = (int)v16;
    uint64_t v26 = *re::networkLogObjects(v16);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      __int16 v40 = __error();
      int v41 = strerror(*v40);
      __int16 v42 = gai_strerror(v25);
      LODWORD(changelist.ident) = 136315394;
      *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)v41;
      LOWORD(changelist.fflags) = 2080;
      *(void *)((char *)&changelist.fflags + 2) = v42;
      _os_log_error_impl(&dword_228C70000, v26, OS_LOG_TYPE_ERROR, "getsockname: %s : %s", (uint8_t *)&changelist, 0x16u);
    }
  }
  else
  {
    *(_WORD *)(a1 + 180) = bswap32(*(unsigned __int16 *)v53.sa_data) >> 16;
  }
  uint64_t v27 = (re *)fcntl(*(_DWORD *)(a1 + 192), 3, 0);
  int v28 = (int)v27;
  if ((v27 & 0x80000000) != 0)
  {
    uint64_t v29 = *re::networkLogObjects(v27);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      unint64_t v43 = __error();
      __int16 v44 = strerror(*v43);
      LODWORD(changelist.ident) = 136315138;
      *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)v44;
      _os_log_error_impl(&dword_228C70000, v29, OS_LOG_TYPE_ERROR, "Could not get server socket flags: %s\n", (uint8_t *)&changelist, 0xCu);
    }
  }
  uint64_t v30 = (re *)fcntl(*(_DWORD *)(a1 + 192), 4, v28 | 4u);
  if ((v30 & 0x80000000) != 0)
  {
    id v31 = *re::networkLogObjects(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      unint64_t v45 = __error();
      unint64_t v46 = strerror(*v45);
      LODWORD(changelist.ident) = 136315138;
      *(uint64_t *)((char *)&changelist.ident + 4) = (uint64_t)v46;
      _os_log_error_impl(&dword_228C70000, v31, OS_LOG_TYPE_ERROR, "Could set server socket to be non blocking: %s\n", (uint8_t *)&changelist, 0xCu);
    }
  }
  changelist.idenstd::__libcpp_thread_t t = *(int *)(a1 + 192);
  *(_DWORD *)&changelist.filter = 0x1FFFF;
  memset(&changelist.fflags, 0, 36);
  unint64_t v32 = (re *)kevent64(*(_DWORD *)(a1 + 24), &changelist, 1, 0, 0, 0, 0);
  if (v32 == -1)
  {
    size_t v35 = *re::networkLogObjects(v32);
    BOOL result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v50) = 0;
    long long v21 = "kevent failed";
LABEL_42:
    p_changelisstd::__libcpp_thread_t t = (uint8_t *)&v50;
    long long v23 = v35;
    uint32_t v24 = 2;
LABEL_49:
    _os_log_error_impl(&dword_228C70000, v23, OS_LOG_TYPE_ERROR, v21, p_changelist, v24);
    return 0;
  }
  changelist.idenstd::__libcpp_thread_t t = 0;
  *(_DWORD *)&changelist.filter = 393206;
  memset(&changelist.fflags, 0, 36);
  uint64_t v33 = (re *)kevent64(*(_DWORD *)(a1 + 24), &changelist, 1, 0, 0, 0, 0);
  if (v33 == -1)
  {
    size_t v35 = *re::networkLogObjects(v33);
    BOOL result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(v50) = 0;
    long long v21 = "kevent failed";
    goto LABEL_42;
  }
  uint64_t v34 = (re *)listen(*(_DWORD *)(a1 + 192), *(_DWORD *)(a1 + 128));
  if ((v34 & 0x80000000) != 0)
  {
    int v37 = (int)v34;
    int v38 = *re::networkLogObjects(v34);
    BOOL result = os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
    if (result)
    {
      uint64_t v39 = gai_strerror(v37);
      int v50 = 136315138;
      unint64_t v51 = v39;
      long long v21 = "listen failed: %s";
      p_changelisstd::__libcpp_thread_t t = (uint8_t *)&v50;
      long long v23 = v38;
      goto LABEL_48;
    }
  }
  else
  {
    if (re::internal::enableSignposts(0, 0)) {
      kdebug_trace();
    }
    return 1;
  }
  return result;
}

uint64_t re::TcpProtocolLayer::deinit(re::TcpProtocolLayer *this)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((unsigned int *)this + 28);
  uint64_t v30 = (char *)this + 80;
  uint64_t v3 = 0;
  if (v2)
  {
    uint64_t v4 = (int *)(*((void *)this + 12) + 8);
    while (1)
    {
      int v5 = *v4;
      v4 += 6;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 28);
        break;
      }
    }
  }
  if (v2 != v3)
  {
    uint64_t v6 = v3;
    do
    {
      uint64_t v7 = *((void *)this + 12) + 24 * v6;
      uint64_t v8 = *(void *)(v7 + 16);
      if (v8) {
        id v9 = (id)(v8 + 8);
      }
      uint64_t v10 = *((void *)this + 23);
      if (v10) {
        (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, uint64_t))(*(void *)v10 + 8))(v10, this, v8, v8 + 1776);
      }
      int v11 = (re *)close(*(_DWORD *)(v7 + 12));
      id v12 = *re::networkLogObjects(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315650;
        unint64_t v32 = "deinit";
        __int16 v33 = 1024;
        int v34 = 230;
        __int16 v35 = 2048;
        uint64_t v36 = v8;
        _os_log_impl(&dword_228C70000, v12, OS_LOG_TYPE_DEFAULT, "%s:%u queueing close on handle %p", buf, 0x1Cu);
      }
      (*(void (**)(re::TcpProtocolLayer *, uint64_t, uint64_t))(*(void *)this + 56))(this, v8, 1);
      if (v8) {

      }
      if (*((_DWORD *)this + 28) <= (v3 + 1)) {
        int v13 = v3 + 1;
      }
      else {
        int v13 = *((_DWORD *)this + 28);
      }
      while (1)
      {
        uint64_t v6 = (v3 + 1);
        if (v13 - 1 == v3) {
          break;
        }
        LODWORD(v3) = v3 + 1;
        int v14 = v6;
        if ((*(_DWORD *)(*((void *)this + 12) + 24 * v6 + 8) & 0x80000000) != 0) {
          goto LABEL_23;
        }
      }
      int v14 = v13;
LABEL_23:
      LODWORD(v3) = v14;
    }
    while (v2 != v14);
  }
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear((uint64_t)v30);
  uint64_t v15 = *((unsigned int *)this + 16);
  if (v15)
  {
    uint64_t v16 = 0;
    uint64_t v17 = (int *)(*((void *)this + 6) + 8);
    while (1)
    {
      int v18 = *v17;
      v17 += 6;
      if (v18 < 0) {
        break;
      }
      if (v15 == ++v16)
      {
        LODWORD(v16) = *((_DWORD *)this + 16);
        break;
      }
    }
  }
  else
  {
    LODWORD(v16) = 0;
  }
  if (v15 != v16)
  {
    uint64_t v19 = v16;
    do
    {
      uint64_t v20 = *(void *)(*((void *)this + 6) + 24 * v19 + 16);
      if (v20)
      {
        id v21 = (id)(v20 + 8);
        id v22 = (id)(v20 + 8);
      }
      uint64_t v23 = *((void *)this + 23);
      if (v23) {
        (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, uint64_t))(*(void *)v23 + 8))(v23, this, v20, v20 + 1776);
      }
      uint32_t v24 = (re *)close(*(_DWORD *)(v20 + 1772));
      int v25 = *re::networkLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315650;
        unint64_t v32 = "deinit";
        __int16 v33 = 1024;
        int v34 = 242;
        __int16 v35 = 2048;
        uint64_t v36 = v20;
        _os_log_impl(&dword_228C70000, v25, OS_LOG_TYPE_DEFAULT, "%s:%u queueing close on handle %p", buf, 0x1Cu);
      }
      (*(void (**)(re::TcpProtocolLayer *, uint64_t, uint64_t))(*(void *)this + 56))(this, v20, 1);
      uint64_t v26 = (void *)(v20 + 8);

      if (*((_DWORD *)this + 16) <= (v16 + 1)) {
        int v27 = v16 + 1;
      }
      else {
        int v27 = *((_DWORD *)this + 16);
      }
      while (1)
      {
        uint64_t v19 = (v16 + 1);
        if (v27 - 1 == v16) {
          break;
        }
        LODWORD(v16) = v16 + 1;
        int v28 = v19;
        if ((*(_DWORD *)(*((void *)this + 6) + 24 * v19 + 8) & 0x80000000) != 0) {
          goto LABEL_45;
        }
      }
      int v28 = v27;
LABEL_45:
      LODWORD(v16) = v28;
    }
    while (v15 != v28);
  }
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear((uint64_t)this + 32);
  close(*((_DWORD *)this + 48));
  shutdown(*((_DWORD *)this + 48), 2);
  uint64_t result = close(*((_DWORD *)this + 6));
  *((_DWORD *)this + 6) = -1;
  *((_WORD *)this + 90) = 0;
  *((_DWORD *)this + 48) = -1;
  return result;
}

void re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_228CDE530, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          uint64_t v8 = *(void *)(v6 + 16);
          if (v8)
          {

            *(void *)(v6 + 16) = 0;
            unint64_t v3 = *(unsigned int *)(a1 + 32);
          }
        }
        v4 += 24;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = v9;
  }
}

uint64_t re::TcpProtocolLayer::open@<X0>(re::TcpProtocolLayer *this@<X0>, const re::Address *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t result = (*(uint64_t (**)(re::TcpProtocolLayer *))(*(void *)this + 160))(this);
  int v15 = result;
  if ((result & 0x80000000) != 0)
  {
    *a3 = 0;
  }
  else
  {
    uint32_t v7 = result;
    uint64_t v8 = *re::networkLogObjects((re *)result);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      if (*((void *)a2 + 1)) {
        int v9 = (char *)*((void *)a2 + 2);
      }
      else {
        int v9 = (char *)a2 + 9;
      }
      int v10 = *((unsigned __int16 *)this + 90);
      LODWORD(buf.ident) = 136315650;
      *(uint64_t *)((char *)&buf.ident + 4) = (uint64_t)v9;
      LOWORD(buf.fflags) = 1024;
      *(uint32_t *)((char *)&buf.fflags + 2) = v7;
      WORD1(buf.data) = 1024;
      HIDWORD(buf.data) = v10;
      _os_log_impl(&dword_228C70000, v8, OS_LOG_TYPE_INFO, "[ConDebug] Connecting to %s with socket %i from port %i", (uint8_t *)&buf, 0x18u);
    }
    int v16 = 1;
    LODWORD(buf.ident) = v7;
    re::make::shared::object<re::TcpProtocolHandle,int &,re::TcpConnectionStatus &,re::Address const&>((re *)&v14, &buf, &v16, a2);
    uint64_t v11 = v14;
    buf.idenstd::__libcpp_thread_t t = v14;
    if (v14) {
      id v12 = (id)(v14 + 8);
    }
    re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::add((uint64_t)this + 32, (uint64_t *)&buf);
    if (buf.ident) {

    }
    re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>((uint64_t)this + 80, &v15, (uint64_t *)&v14);
    buf.idenstd::__libcpp_thread_t t = v7;
    *(_OWORD *)&buf.filter = 0x5FFFEuLL;
    buf.udata = v11;
    buf.ext[0] = 0;
    buf.ext[1] = 0;
    uint64_t result = kevent64(*((_DWORD *)this + 6), &buf, 1, 0, 0, 0, 0);
    if (result == -1)
    {
      re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "open", 275);
      uint64_t result = _os_crash();
      __break(1u);
    }
    else
    {
      *a3 = v11;
    }
  }
  return result;
}

uint64_t re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::addAsMove(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

void re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>(uint64_t a1, int *a2, uint64_t *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  unint64_t v9 = *(void *)a1;
  if (*(void *)a1)
  {
    unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v19 = *(void *)(a1 + 16);
      if (*(_DWORD *)(v19 + 24 * v10 + 12) == v6) {
        return;
      }
      while (1)
      {
        LODWORD(v10) = *(_DWORD *)(v19 + 24 * v10 + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v19 + 24 * v10 + 12) == v6) {
          return;
        }
      }
    }
  }
  uint64_t v11 = *(unsigned int *)(a1 + 36);
  if (v11 == 0x7FFFFFFF)
  {
    uint64_t v11 = *(unsigned int *)(a1 + 32);
    int v12 = v11;
    if (v11 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v9) = v8 % *(unsigned int *)(a1 + 24);
      int v12 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v12 + 1;
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
  }
  else
  {
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
    *(_DWORD *)(a1 + 36) = v14 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v13 + 24 * v11 + 8) = v14 | 0x80000000;
  uint64_t v15 = v9;
  uint64_t v16 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 8) & 0x80000000 | *(_DWORD *)(v16 + 4 * v9);
  *(void *)(*(void *)(a1 + 16) + 24 * v11) = v8;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v11 + 12) = *a2;
  uint64_t v17 = *a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v11 + 16) = *a3;
  if (v17)
  {
    id v18 = (id)(v17 + 8);
    uint64_t v16 = *(void *)(a1 + 8);
  }
  *(_DWORD *)(v16 + 4 * v15) = v11;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
}

void re::TcpProtocolLayer::setSocketOptions(re::TcpProtocolLayer *this)
{
  int v1 = (int)this;
  uint64_t v13 = *MEMORY[0x263EF8340];
  int v10 = 1;
  uint64_t v2 = (re *)setsockopt((int)this, 6, 1, &v10, 4u);
  if ((v2 & 0x80000000) != 0)
  {
    unint64_t v3 = *re::networkLogObjects(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      unint64_t v6 = __error();
      unint64_t v7 = strerror(*v6);
      *(_DWORD *)kevent64_s buf = 136315138;
      int v12 = v7;
      _os_log_error_impl(&dword_228C70000, v3, OS_LOG_TYPE_ERROR, "Could not set TCP_NODELAY %s\n", buf, 0xCu);
    }
  }
  int v10 = 1;
  uint64_t v4 = (re *)setsockopt(v1, 0xFFFF, 4130, &v10, 4u);
  if ((v4 & 0x80000000) != 0)
  {
    unint64_t v5 = *re::networkLogObjects(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      unint64_t v8 = __error();
      unint64_t v9 = strerror(*v8);
      *(_DWORD *)kevent64_s buf = 136315138;
      int v12 = v9;
      _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "Could not set SO_NOSIGPIPE %s\n", buf, 0xCu);
    }
  }
}

uint64_t re::TcpProtocolLayer::connectToAddress(re::TcpProtocolLayer *this, const re::Address *a2)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  IPPortPair = (re *)re::Address::getIPPortPair(a2, (uint64_t)v41);
  if (v41[0])
  {
    memset(&v40.ai_addrlen, 0, 32);
    v40.ai_flags = 0;
    *(void *)&v40.ai_family = 0x100000002;
    v40.ai_protocol = 6;
    __int16 v39 = 0;
    *(void *)__str = 0;
    snprintf(__str, 0xAuLL, "%i", v42[12]);
    __int16 v33 = 0;
    re::IP::generateString((re::IP *)v42, (re::DynamicString *)buf);
    if (buf[8]) {
      uint64_t v4 = *(const char **)&v36[2];
    }
    else {
      uint64_t v4 = &buf[9];
    }
    unint64_t v5 = (re::TcpProtocolLayer *)getaddrinfo(v4, __str, &v40, &v33);
    unint64_t v6 = *(re **)buf;
    if (*(void *)buf && (buf[8] & 1) != 0) {
      unint64_t v6 = (re *)(*(uint64_t (**)(void))(**(void **)buf + 40))();
    }
    if (v5)
    {
      unint64_t v7 = *re::networkLogObjects(v6);
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
LABEL_10:
        freeaddrinfo(v33);
        return (uint64_t)v5;
      }
      uint64_t v23 = gai_strerror((int)v5);
      *(_DWORD *)kevent64_s buf = 136315138;
      *(void *)&uint8_t buf[4] = v23;
      uint64_t v20 = "getaddrinfo failed: %s";
      id v21 = v7;
      uint32_t v22 = 12;
LABEL_28:
      _os_log_error_impl(&dword_228C70000, v21, OS_LOG_TYPE_ERROR, v20, buf, v22);
      goto LABEL_10;
    }
    int v10 = (re *)socket(v33->ai_family, v33->ai_socktype, v33->ai_protocol);
    unint64_t v5 = v10;
    if ((v10 & 0x80000000) != 0)
    {
      uint64_t v19 = *re::networkLogObjects(v10);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_10;
      }
      *(_DWORD *)kevent64_s buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v5;
      uint64_t v20 = "Opening socket failed with %i";
      id v21 = v19;
      uint32_t v22 = 8;
      goto LABEL_28;
    }
    uint64_t v11 = (re *)fcntl((int)v10, 3, 0);
    int v12 = (int)v11;
    if ((v11 & 0x80000000) != 0)
    {
      uint64_t v13 = *re::networkLogObjects(v11);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        int v25 = __error();
        uint64_t v26 = strerror(*v25);
        *(_DWORD *)kevent64_s buf = 136315138;
        *(void *)&uint8_t buf[4] = v26;
        _os_log_error_impl(&dword_228C70000, v13, OS_LOG_TYPE_ERROR, "Could not get socket flags: %s\n", buf, 0xCu);
      }
    }
    int v14 = (re *)fcntl((int)v5, 4, v12 | 4u);
    if ((v14 & 0x80000000) != 0)
    {
      uint64_t v15 = *re::networkLogObjects(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        int v27 = __error();
        int v28 = strerror(*v27);
        *(_DWORD *)kevent64_s buf = 136315138;
        *(void *)&uint8_t buf[4] = v28;
        _os_log_error_impl(&dword_228C70000, v15, OS_LOG_TYPE_ERROR, "Could not set socket to be non blocking: %s\n", buf, 0xCu);
      }
    }
    re::TcpProtocolLayer::setSocketOptions(v5);
    uint64_t v16 = connect((int)v5, v33->ai_addr, v33->ai_addrlen);
    freeaddrinfo(v33);
    if ((v16 & 0x80000000) != 0)
    {
      uint64_t v17 = __error();
      if (*v17 != 36)
      {
        id v18 = *re::networkLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          if (*((void *)a2 + 1)) {
            uint64_t v29 = (char *)*((void *)a2 + 2);
          }
          else {
            uint64_t v29 = (char *)a2 + 9;
          }
          uint64_t v30 = gai_strerror(v16);
          id v31 = __error();
          unint64_t v32 = strerror(*v31);
          *(_DWORD *)kevent64_s buf = 136315650;
          *(void *)&uint8_t buf[4] = v29;
          __int16 v35 = 2080;
          *(void *)uint64_t v36 = v30;
          *(_WORD *)&v36[8] = 2080;
          uint64_t v37 = v32;
          _os_log_error_impl(&dword_228C70000, v18, OS_LOG_TYPE_ERROR, "Failed to connect to %s : %s errno = %s", buf, 0x20u);
        }
        return v16;
      }
    }
  }
  else
  {
    unint64_t v8 = *re::networkLogObjects(IPPortPair);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if (*((void *)a2 + 1)) {
        uint32_t v24 = (char *)*((void *)a2 + 2);
      }
      else {
        uint32_t v24 = (char *)a2 + 9;
      }
      v40.ai_flags = 136315138;
      *(void *)&v40.ai_family = v24;
      _os_log_error_impl(&dword_228C70000, v8, OS_LOG_TYPE_ERROR, "Expected ip:port address: %s", (uint8_t *)&v40, 0xCu);
    }
    return 0xFFFFFFFFLL;
  }
  return (uint64_t)v5;
}

void re::TcpProtocolLayer::close(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v4 = *re::networkLogObjects((re *)a1);
  unint64_t v5 = (re *)os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    int v6 = *(unsigned __int16 *)(a1 + 180);
    *(_DWORD *)uint64_t v16 = 134218240;
    *(void *)&v16[4] = a2;
    __int16 v17 = 1024;
    int v18 = v6;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "[ConDebug] Closing peer handle(%p) on port %i", v16, 0x12u);
  }
  if (a2) {
    unint64_t v5 = (re *)(id)(a2 + 8);
  }
  if (*(void *)(a2 + 1808))
  {
    unint64_t v7 = *re::networkLogObjects(v5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a2 + 1808);
      *(_DWORD *)uint64_t v16 = 134217984;
      *(void *)&v16[4] = v8;
      _os_log_impl(&dword_228C70000, v7, OS_LOG_TYPE_DEFAULT, "Packet %p freed", v16, 0xCu);
    }
    re::PacketPool::free(*(re::PacketPool **)(a1 + 200), *(re::Packet **)(a2 + 1808));
    *(void *)(a2 + 1808) = 0;
  }
  unint64_t v9 = *(re::Packet **)(a2 + 1840);
  if (v9)
  {
    re::PacketPool::free(*(re::PacketPool **)(a1 + 200), v9);
    *(void *)(a2 + 18re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  }
  int v10 = *re::networkLogObjects(v5);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = *(unsigned __int16 *)(a1 + 180);
    int v12 = *(_DWORD *)(a2 + 1772);
    *(_DWORD *)uint64_t v16 = 134218496;
    *(void *)&v16[4] = a2;
    __int16 v17 = 1024;
    int v18 = v11;
    __int16 v19 = 1024;
    int v20 = v12;
    _os_log_impl(&dword_228C70000, v10, OS_LOG_TYPE_DEFAULT, "Closed peer handle(%p) on port %i socket %i", v16, 0x18u);
  }
  (*(void (**)(uint64_t, void))(*(void *)a1 + 176))(a1, *(unsigned int *)(a2 + 1772));
  uint64_t v13 = (void *)(a2 + 8);
  id v14 = (id)(a2 + 8);
  *(_DWORD *)uint64_t v16 = *(_DWORD *)(a2 + 1772);
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::remove(a1 + 80, (int *)v16);
  *(void *)uint64_t v16 = a2;
  id v15 = (id)(a2 + 8);
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove(a1 + 32, (uint64_t *)v16);
  if (*(void *)v16) {
}
  }

uint64_t re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::remove(uint64_t a1, int *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v3 = *a2;
  unint64_t v4 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v3 ^ (v3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v3 ^ (v3 >> 30))) >> 27));
  unint64_t v5 = (v4 ^ (v4 >> 31)) % *(unsigned int *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v9 + 24 * v7 + 12) != v3)
  {
    while (1)
    {
      unsigned int v10 = v7;
      int v11 = *(_DWORD *)(v9 + 24 * v7 + 8);
      uint64_t v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        return 0;
      }
      if (*(_DWORD *)(v9 + 24 * v7 + 12) == v3)
      {
        *(_DWORD *)(v9 + 24 * v10 + 8) = *(_DWORD *)(v9 + 24 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v13 = v12 + 24 * v7;
  int v16 = *(_DWORD *)(v13 + 8);
  id v14 = (int *)(v13 + 8);
  int v15 = v16;
  if (v16 < 0)
  {
    int *v14 = v15 & 0x7FFFFFFF;
    uint64_t v17 = v12 + 24 * v7;
    uint64_t v20 = *(void *)(v17 + 16);
    __int16 v19 = (void *)(v17 + 16);
    uint64_t v18 = v20;
    if (v20)
    {

      *__int16 v19 = 0;
    }
  }
  uint64_t v21 = *(void *)(a1 + 16) + 24 * v7;
  int v22 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = v22 + 1;
  return 1;
}

void re::TcpProtocolLayer::disconnect(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 1768) != 4)
  {
    *(_DWORD *)(a2 + 1768) = 3;
    if (a3)
    {
      changelist.idenstd::__libcpp_thread_t t = *(int *)(a2 + 1772);
      *(_DWORD *)&changelist.filter = 196607;
      memset(&changelist.fflags, 0, 36);
      if (kevent64(*(_DWORD *)(a1 + 24), &changelist, 1, 0, 0, 0, 0) == -1)
      {
        __error();
        uint64_t v9 = __error();
        re::internal::assertLog((re::internal *)5, v10, "assertion failure: '%s' (%s:line %i) kevent failed %d", "!\"Unreachable code\"", "disconnect", 455, *v9);
        _os_crash();
        __break(1u);
      }
      else
      {
        close(*(_DWORD *)(a2 + 1772));
        uint64_t v5 = *(void *)(a1 + 184);
        if (v5) {
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v5 + 8))(v5, a1, a2, a2 + 1776);
        }
      }
    }
    else
    {
      uint64_t v6 = *re::networkLogObjects((re *)a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = *(_DWORD *)(a2 + 1772);
        int v8 = *(unsigned __int16 *)(a1 + 180);
        LODWORD(changelist.ident) = 67109632;
        HIDWORD(changelist.ident) = v7;
        changelist.filter = 2048;
        *(void *)&changelist.flags = a2;
        WORD1(changelist.data) = 1024;
        HIDWORD(changelist.data) = v8;
        _os_log_impl(&dword_228C70000, v6, OS_LOG_TYPE_DEFAULT, "[ConDebug] disconnecting peer(%i) handle(%p) on port %i", (uint8_t *)&changelist, 0x18u);
      }
    }
  }
}

void re::TcpProtocolLayer::getAddressFromSocket(re::TcpProtocolLayer *this@<X0>, int *a2@<X2>, int a3@<W1>, re::DynamicString *a4@<X8>)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  *((void *)a4 + 1) = 0;
  *((void *)a4 + 2) = 0;
  *((void *)a4 + 3) = 0;
  re::DynamicString::setCapacity(a4, 0);
  socklen_t v17 = 128;
  int v8 = (re *)getpeername(a3, &v18, &v17);
  *a2 = (int)v8;
  if ((v8 & 0x80000000) != 0)
  {
    uint64_t v9 = *re::networkLogObjects(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = gai_strerror(*a2);
      int v11 = __error();
      uint64_t v12 = strerror(*v11);
      *(_DWORD *)kevent64_s buf = 136315394;
      uint64_t v20 = v10;
      LOWORD(v21[0]) = 2080;
      *(void *)((char *)v21 + 2) = v12;
      _os_log_error_impl(&dword_228C70000, v9, OS_LOG_TYPE_ERROR, "getpeername failed: %s errno = %s", buf, 0x16u);
    }
  }
  else if (v18.sa_family == 2)
  {
    memset(v21, 0, sizeof(v21));
    buf[0] = 0;
    HIDWORD(v20) = *(_DWORD *)&v18.sa_data[2];
    __int16 v22 = bswap32(*(unsigned __int16 *)v18.sa_data) >> 16;
    re::Address::makeFromIPAndPort((unsigned __int16 *)buf, (re::DynamicString *)&v15);
    re::DynamicString::operator=(a4, (re::DynamicString *)&v15);
    if (v15)
    {
      if (v16) {
        (*(void (**)(void))(*(void *)v15 + 40))();
      }
    }
  }
  else
  {
    uint64_t v13 = re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet((uint64_t)this + 80, a3);
    if (v13)
    {
      re::DynamicString::operator=(a4, (re::DynamicString *)(*(void *)v13 + 1776));
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) IPv6 not supported yet", "!\"Unreachable code\"", "getAddressFromSocket", 486);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet(uint64_t a1, int a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v5 + 24 * v3 + 12) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 24 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(_DWORD *)(v5 + 24 * v3 + 12) == a2) {
        return v5 + 24 * v3 + 16;
      }
    }
    return 0;
  }
  return v5 + 24 * v3 + 16;
}

void re::TcpProtocolLayer::sendPacketParts(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a1 + 1772);
  unint64_t v5 = *(void *)(a1 + 1824);
  if (v5 > 7)
  {
LABEL_4:
    ssize_t v7 = send(v4, (const void *)(*(void *)(a2 + 16) + v5 - 8), *(unsigned int *)(a2 + 24) - (v5 - 8), 0);
    if ((v7 & 0x8000000000000000) == 0)
    {
      *(void *)(a1 + 1824) += v7;
      return;
    }
    int v8 = __error();
    if (*v8 != 35)
    {
      uint64_t v9 = *re::networkLogObjects((re *)v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_12;
      }
    }
    return;
  }
  ssize_t v6 = send(*(_DWORD *)(a1 + 1772), (const void *)(a1 + 5 * v5 + 1816), 8uLL, 0);
  if ((v6 & 0x8000000000000000) == 0)
  {
    unint64_t v5 = *(void *)(a1 + 1824) + v6;
    *(void *)(a1 + 18re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v5;
    if (v5 < 8) {
      return;
    }
    goto LABEL_4;
  }
  uint64_t v10 = __error();
  if (*v10 != 35)
  {
    uint64_t v9 = *re::networkLogObjects((re *)v10);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
LABEL_12:
      int v11 = __error();
      uint64_t v12 = strerror(*v11);
      v13[0] = 67109378;
      v13[1] = v4;
      __int16 v14 = 2080;
      uint64_t v15 = v12;
      _os_log_error_impl(&dword_228C70000, v9, OS_LOG_TYPE_ERROR, "send to %i failed: errno = %s", (uint8_t *)v13, 0x12u);
    }
  }
}

uint64_t re::TcpProtocolLayer::connectionAdded(re::TcpProtocolLayer *this, re::TcpProtocolLayer *a2)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  int v33 = 0;
  int v34 = (int)a2;
  int v4 = (re *)(*(void *(**)(uint64_t *__return_ptr))(*(void *)this + 168))(&v29);
  if (v33 < 0)
  {
    uint64_t v13 = *re::networkLogObjects(v4);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      int v25 = __error();
      uint64_t v26 = strerror(*v25);
      int v27 = gai_strerror(v33);
      LODWORD(buf.ident) = 67109634;
      HIDWORD(buf.ident) = a2;
      buf.filter = 2080;
      *(void *)&buf.flags = v26;
      WORD1(buf.data) = 2080;
      *(int64_t *)((char *)&buf.data + 4) = (int64_t)v27;
      _os_log_error_impl(&dword_228C70000, v13, OS_LOG_TYPE_ERROR, "getpeername to %i failed: errno = %s, error = %s", (uint8_t *)&buf, 0x1Cu);
    }
    re::TcpProtocolLayer::connectionError(this, (int)a2);
    goto LABEL_35;
  }
  re::TcpProtocolLayer::setSocketOptions(a2);
  re::TcpProtocolLayer::setupKeepAlive(this, (int)a2);
  if (*((void *)this + 10))
  {
    uint64_t v5 = (int)a2;
    unint64_t v6 = 0xBF58476D1CE4E5B9 * ((int)a2 ^ ((unint64_t)(int)a2 >> 30));
    uint64_t v7 = *(unsigned int *)(*((void *)this + 11)
                         + 4
                         * (((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31))
                          % *((unsigned int *)this + 26)));
    if (v7 != 0x7FFFFFFF)
    {
      uint64_t v14 = *((void *)this + 12);
      int v15 = *(_DWORD *)(v14 + 24 * v7 + 12);
      if (v15 == a2)
      {
LABEL_14:
        idenstd::__libcpp_thread_t t = *(void *)(v14 + 24 * v7 + 16);
        if (ident)
        {
          id v16 = (id)(ident + 8);
          buf.idenstd::__libcpp_thread_t t = ident;
          id v17 = (id)(ident + 8);
        }
        else
        {
          buf.idenstd::__libcpp_thread_t t = 0;
        }
        uint64_t v28 = ident;
        __int16 v19 = (re *)re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove((uint64_t)this + 32, (uint64_t *)&buf);
        if (buf.ident) {

        }
        *(_DWORD *)(ident + 1768) = 2;
        uint64_t v20 = *re::networkLogObjects(v19);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
        {
          uint32_t v21 = *((unsigned __int16 *)this + 90);
          if (v30) {
            __int16 v22 = v32;
          }
          else {
            __int16 v22 = v31;
          }
          LODWORD(buf.ident) = 134218754;
          *(uint64_t *)((char *)&buf.ident + 4) = ident;
          LOWORD(buf.fflags) = 1024;
          *(uint32_t *)((char *)&buf.fflags + 2) = v21;
          WORD1(buf.data) = 1024;
          HIDWORD(buf.data) = a2;
          LOWORD(buf.udata) = 2080;
          *(uint64_t *)((char *)&buf.udata + 2) = (uint64_t)v22;
          _os_log_impl(&dword_228C70000, v20, OS_LOG_TYPE_INFO, "[ConDebug] %p Outgoing connection complete on port(%i) socket(%i) from %s", (uint8_t *)&buf, 0x22u);
        }
        (***((void (****)(void, re::TcpProtocolLayer *, uint64_t, uint64_t *))this + 23))(*((void *)this + 23), this, ident, &v29);
        goto LABEL_32;
      }
      uint64_t v18 = v7;
      while (1)
      {
        LODWORD(v18) = *(_DWORD *)(v14 + 24 * v18 + 8) & 0x7FFFFFFF;
        if (v18 == 0x7FFFFFFF) {
          break;
        }
        if (*(_DWORD *)(v14 + 24 * v18 + 12) == a2)
        {
          if (v15 != a2)
          {
            while (1)
            {
              LODWORD(v7) = *(_DWORD *)(v14 + 24 * v7 + 8) & 0x7FFFFFFF;
              if (v7 == 0x7FFFFFFF) {
                break;
              }
              if (*(_DWORD *)(v14 + 24 * v7 + 12) == a2) {
                goto LABEL_14;
              }
            }
            LODWORD(v7) = 0x7FFFFFFF;
          }
          goto LABEL_14;
        }
      }
    }
  }
  LODWORD(v28) = a2;
  int v35 = 2;
  int v8 = re::make::shared::object<re::TcpProtocolHandle,int &,re::TcpConnectionStatus &,re::Address const&>((re *)&buf, &v28, &v35, (const re::DynamicString *)&v29);
  idenstd::__libcpp_thread_t t = buf.ident;
  uint64_t v28 = buf.ident;
  uint64_t v10 = *re::networkLogObjects(v8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint32_t v11 = *((unsigned __int16 *)this + 90);
    if (v30) {
      uint64_t v12 = v32;
    }
    else {
      uint64_t v12 = v31;
    }
    LODWORD(buf.ident) = 134218754;
    *(uint64_t *)((char *)&buf.ident + 4) = ident;
    LOWORD(buf.fflags) = 1024;
    *(uint32_t *)((char *)&buf.fflags + 2) = v11;
    WORD1(buf.data) = 1024;
    HIDWORD(buf.data) = a2;
    LOWORD(buf.udata) = 2080;
    *(uint64_t *)((char *)&buf.udata + 2) = (uint64_t)v12;
    _os_log_impl(&dword_228C70000, v10, OS_LOG_TYPE_INFO, "[ConDebug] %p Incoming connection complete  on port(%i) socket(%i) from %s", (uint8_t *)&buf, 0x22u);
  }
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>((uint64_t)this + 80, &v34, (uint64_t *)&v28);
  (***((void (****)(void, re::TcpProtocolLayer *, uint64_t, uint64_t *))this + 23))(*((void *)this + 23), this, ident, &v29);
  uint64_t v5 = (int)a2;
LABEL_32:
  buf.idenstd::__libcpp_thread_t t = v5;
  *(_OWORD *)&buf.filter = 0x5FFFFuLL;
  buf.udata = ident;
  buf.ext[0] = 0;
  buf.ext[1] = 0;
  if (kevent64(*((_DWORD *)this + 6), &buf, 1, 0, 0, 0, 0) == -1)
  {
    re::internal::assertLog((re::internal *)4, v23, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "connectionAdded", 569);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  if (ident) {

  }
LABEL_35:
  uint64_t result = v29;
  if (v29)
  {
    if (v30) {
      return (*(uint64_t (**)(void))(*(void *)v29 + 40))();
    }
  }
  return result;
}

uint64_t re::TcpProtocolLayer::connectionError(re::TcpProtocolLayer *this, int a2)
{
  uint64_t v4 = re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet((uint64_t)this + 80, a2);
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    uint64_t v6 = *((void *)this + 23);
    if (v6) {
      (*(void (**)(uint64_t, re::TcpProtocolLayer *, void, uint64_t))(*(void *)v6 + 16))(v6, this, *v5, 2);
    }
    *(_DWORD *)(*v5 + 1768) = 5;
  }
  return shutdown(a2, 2);
}

void re::TcpProtocolLayer::setupKeepAlive(re::TcpProtocolLayer *this, int a2)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (*((_DWORD *)this + 44))
  {
    int v27 = 1;
    uint64_t v4 = (re *)setsockopt(a2, 0xFFFF, 8, &v27, 4u);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v5 = *re::networkLogObjects(v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        id v16 = __error();
        id v17 = strerror(*v16);
        *(_DWORD *)kevent64_s buf = 136315138;
        uint64_t v29 = v17;
        _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "Could not set SO_KEEPALIVE %s\n", buf, 0xCu);
      }
    }
    int v26 = *((_DWORD *)this + 44);
    uint64_t v6 = (re *)setsockopt(a2, 6, 16, &v26, 4u);
    if ((v6 & 0x80000000) != 0)
    {
      uint64_t v7 = *re::networkLogObjects(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v18 = __error();
        __int16 v19 = strerror(*v18);
        *(_DWORD *)kevent64_s buf = 136315138;
        uint64_t v29 = v19;
        _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "Could not set TCP_KEEPALIVE %s\n", buf, 0xCu);
      }
    }
    int v25 = 5;
    int v8 = (re *)setsockopt(a2, 6, 257, &v25, 4u);
    if ((v8 & 0x80000000) != 0)
    {
      uint64_t v9 = *re::networkLogObjects(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = __error();
        uint32_t v21 = strerror(*v20);
        *(_DWORD *)kevent64_s buf = 136315138;
        uint64_t v29 = v21;
        _os_log_error_impl(&dword_228C70000, v9, OS_LOG_TYPE_ERROR, "Could not set TCP_KEEPINTVL %s\n", buf, 0xCu);
      }
    }
    int v24 = 4;
    uint64_t v10 = (re *)setsockopt(a2, 6, 258, &v24, 4u);
    if ((v10 & 0x80000000) != 0)
    {
      uint32_t v11 = *re::networkLogObjects(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v12 = __error();
        uint64_t v13 = strerror(*v12);
        *(_DWORD *)kevent64_s buf = 136315138;
        uint64_t v29 = v13;
        uint64_t v14 = "Could not set TCP_KEEPCNT %s\n";
LABEL_18:
        _os_log_error_impl(&dword_228C70000, v11, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
      }
    }
  }
  else
  {
    int v27 = 0;
    int v15 = (re *)setsockopt(a2, 0xFFFF, 8, &v27, 4u);
    if ((v15 & 0x80000000) != 0)
    {
      uint32_t v11 = *re::networkLogObjects(v15);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        __int16 v22 = __error();
        uint64_t v23 = strerror(*v22);
        *(_DWORD *)kevent64_s buf = 136315138;
        uint64_t v29 = v23;
        uint64_t v14 = "Could not set SO_KEEPALIVE %s\n";
        goto LABEL_18;
      }
    }
  }
}

void re::TcpProtocolLayer::update(re::TcpProtocolLayer *this)
{
  uint64_t v115 = *MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v110, 6022, (uint64_t)this);
  timeout.tv_sec = 0;
  timeout.tv_nsec = 0;
  uint64_t v2 = kevent64(*((_DWORD *)this + 6), 0, 0, eventlist, 32, 0, &timeout);
  if ((int)v2 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v103 = v2;
    do
    {
      uint64_t v5 = &eventlist[v4];
      idenstd::__libcpp_thread_t t = (re::TcpProtocolLayer *)v5->ident;
      uint64_t udata = v5->udata;
      if (udata) {
        uint64_t v2 = (uint64_t)(id)(udata + 8);
      }
      int filter = (unsigned __int16)eventlist[v4].filter;
      if (filter == 65526)
      {
        changelist.idenstd::__libcpp_thread_t t = (int)ident;
        *(_DWORD *)&changelist.int filter = 2686966;
        memset(&changelist.fflags, 0, 36);
        uint64_t v2 = kevent64(*((_DWORD *)this + 6), &changelist, 1, 0, 0, 0, 0);
        if (v2 == -1)
        {
          re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "update", 589);
          _os_crash();
          __break(1u);
LABEL_140:
          re::internal::assertLog((re::internal *)4, v102, "assertion failure: '%s' (%s:line %i) Accept", "!\"Unreachable code\"", "update", 597);
          _os_crash();
          __break(1u);
LABEL_141:
          re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Unknown event", "!\"Unreachable code\"", "update", 639);
          _os_crash();
          __break(1u);
LABEL_142:
          re::internal::assertLog((re::internal *)4, v56, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "update", 666);
          _os_crash();
          __break(1u);
LABEL_143:
          re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) kevent failed", "!\"Unreachable code\"", "update", 631);
          _os_crash();
          __break(1u);
LABEL_144:
          re::internal::assertLog((re::internal *)4, v45, "assertion failure: '%s' (%s:line %i) Invalid Connection status", "!\"Unreachable code\"", "update", 679);
          _os_crash();
          __break(1u);
        }
      }
      else
      {
        if (*((_DWORD *)this + 48) == ident)
        {
          socklen_t v108 = 128;
          uint64_t v9 = (re::TcpProtocolLayer *)accept((int)ident, (sockaddr *)&changelist, &v108);
          if (v9 == -1) {
            goto LABEL_140;
          }
          uint64_t v10 = v9;
          *(_DWORD *)&v114[16] = 0;
          *(void *)&v114[8] = 0;
          buf[0] = 0;
          *(_DWORD *)&v114[4] = HIDWORD(changelist.ident);
          *(_WORD *)&v114[20] = bswap32(WORD1(changelist.ident)) >> 16;
          uint32_t v11 = (re *)re::Address::makeFromIPAndPort((unsigned __int16 *)buf, (re::DynamicString *)v105);
          uint64_t v12 = *re::networkLogObjects(v11);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
          {
            uint64_t v13 = v107;
            if (v106) {
              uint64_t v13 = *(unsigned char **)&v107[7];
            }
            int v14 = *((unsigned __int16 *)this + 90);
            *(_DWORD *)kevent64_s buf = 136315650;
            *(void *)uint64_t v114 = v13;
            *(_WORD *)&v114[8] = 1024;
            *(_DWORD *)&v114[10] = v14;
            *(_WORD *)&v114[14] = 1024;
            *(_DWORD *)&v114[16] = v10;
            _os_log_impl(&dword_228C70000, v12, OS_LOG_TYPE_INFO, "[ConDebug] Accepting connection(%s) on port(%i) socket(%i)", buf, 0x18u);
          }
          re::TcpProtocolLayer::connectionAdded(this, v10);
          uint64_t v2 = *(void *)v105;
          if (*(void *)v105 && (v106 & 1) != 0) {
            uint64_t v2 = (*(uint64_t (**)(void))(**(void **)v105 + 40))();
          }
        }
        else if (filter == 65534)
        {
          if (*(_DWORD *)(udata + 1768) == 1)
          {
            v105[0] = 0;
            socklen_t v108 = 4;
            int v25 = (re *)getsockopt((int)ident, 0xFFFF, 4103, v105, &v108);
            if ((v25 & 0x80000000) != 0)
            {
              int v37 = (int)v25;
              int v38 = *re::networkLogObjects(v25);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              {
                uint64_t v77 = __error();
                uint64_t v78 = strerror(*v77);
                uint64_t v79 = gai_strerror(v37);
                LODWORD(changelist.ident) = 67109634;
                HIDWORD(changelist.ident) = ident;
                changelist.int filter = 2080;
                *(void *)&changelist.flags = v78;
                WORD1(changelist.data) = 2080;
                *(int64_t *)((char *)&changelist.data + 4) = (int64_t)v79;
                _os_log_error_impl(&dword_228C70000, v38, OS_LOG_TYPE_ERROR, "getsockopt to %i failed: errno = %s error =%s", (uint8_t *)&changelist, 0x1Cu);
              }
              re::TcpProtocolLayer::connectionError(this, (int)ident);
            }
            else if (v105[0])
            {
              int v26 = *re::networkLogObjects(v25);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                int v27 = __error();
                uint64_t v28 = strerror(*v27);
                uint64_t v29 = gai_strerror(v105[0]);
                LODWORD(changelist.ident) = 67109634;
                HIDWORD(changelist.ident) = ident;
                changelist.int filter = 2080;
                *(void *)&changelist.flags = v28;
                WORD1(changelist.data) = 2080;
                *(int64_t *)((char *)&changelist.data + 4) = (int64_t)v29;
                _os_log_error_impl(&dword_228C70000, v26, OS_LOG_TYPE_ERROR, "getsockopt to %i failed: errno = %s error =%s", (uint8_t *)&changelist, 0x1Cu);
              }
            }
            else
            {
              uint64_t v72 = (re *)(*(void *(**)(kevent64_s *__return_ptr, re::TcpProtocolLayer *, re::TcpProtocolLayer *, int *))(*(void *)this + 168))(&changelist, this, ident, v105);
              int v73 = v105[0];
              uint64_t v74 = *re::networkLogObjects(v72);
              if (v73 < 0)
              {
                if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                {
                  unint64_t v85 = __error();
                  uint64_t v86 = strerror(*v85);
                  unint64_t v87 = gai_strerror(v105[0]);
                  *(_DWORD *)kevent64_s buf = 67109634;
                  *(_DWORD *)uint64_t v114 = ident;
                  *(_WORD *)&v114[4] = 2080;
                  *(void *)&v114[6] = v86;
                  *(_WORD *)&v114[14] = 2080;
                  *(void *)&v114[16] = v87;
                  _os_log_error_impl(&dword_228C70000, v74, OS_LOG_TYPE_ERROR, "getAddressFromSocket to %i failed: errno = %s, error = %s", buf, 0x1Cu);
                }
                re::TcpProtocolLayer::connectionError(this, (int)ident);
              }
              else
              {
                if (os_log_type_enabled(v74, OS_LOG_TYPE_INFO))
                {
                  int v75 = *((unsigned __int16 *)this + 90);
                  data = (char *)&changelist.filter + 1;
                  if (changelist.filter) {
                    data = (char *)changelist.data;
                  }
                  *(_DWORD *)kevent64_s buf = 67109634;
                  *(_DWORD *)uint64_t v114 = v75;
                  *(_WORD *)&v114[4] = 1024;
                  *(_DWORD *)&v114[6] = ident;
                  *(_WORD *)&v114[10] = 2080;
                  *(void *)&v114[12] = data;
                  _os_log_impl(&dword_228C70000, v74, OS_LOG_TYPE_INFO, "[ConDebug] Server accepted connection on port(%i) socket(%i) from %s", buf, 0x18u);
                }
                re::TcpProtocolLayer::connectionAdded(this, ident);
              }
              if (changelist.ident && (changelist.filter & 1) != 0) {
                (*(void (**)(void))(*(void *)changelist.ident + 40))();
              }
            }
            changelist.idenstd::__libcpp_thread_t t = (int)ident;
            *(_DWORD *)&changelist.int filter = 720894;
            memset(&changelist.fflags, 0, 36);
            uint64_t v2 = kevent64(*((_DWORD *)this + 6), &changelist, 1, 0, 0, 0, 0);
            if (v2 == -1) {
              goto LABEL_143;
            }
          }
        }
        else
        {
          if (filter != 0xFFFF) {
            goto LABEL_141;
          }
          int v15 = (unsigned __int8 *)(udata + 1848);
          unint64_t v16 = *(void *)(udata + 1856);
          while (1)
          {
            int v17 = *(_DWORD *)(udata + 1772);
            if (v16 <= 7)
            {
              uint64_t v2 = recv(*(_DWORD *)(udata + 1772), &v15[v16], 8 - v16, 0);
              int v18 = v2;
              if (v2 < 0)
              {
                uint64_t v2 = (uint64_t)__error();
                if (*(_DWORD *)v2 == 35) {
                  goto LABEL_50;
                }
                __int16 v39 = *re::networkLogObjects((re *)v2);
                if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                {
                  size_t v82 = strerror(v18);
                  unint64_t v83 = __error();
                  uint64_t v84 = strerror(*v83);
                  LODWORD(changelist.ident) = 67109634;
                  HIDWORD(changelist.ident) = v17;
                  changelist.int filter = 2080;
                  *(void *)&changelist.flags = v82;
                  WORD1(changelist.data) = 2080;
                  *(int64_t *)((char *)&changelist.data + 4) = (int64_t)v84;
                  int v34 = v39;
                  int v35 = "recv %i failed: errno = %s %s";
                  uint32_t v36 = 28;
LABEL_106:
                  _os_log_error_impl(&dword_228C70000, v34, OS_LOG_TYPE_ERROR, v35, (uint8_t *)&changelist, v36);
                }
LABEL_49:
                uint64_t v2 = re::TcpProtocolLayer::connectionError(this, v17);
                goto LABEL_50;
              }
              unint64_t v16 = *(void *)(udata + 1856) + v2;
              *(void *)(udata + 1856) = v16;
              if (v16 < 8) {
                goto LABEL_50;
              }
            }
            if (*v15 >= 0xAu) {
              break;
            }
            __int16 v19 = *(char **)(udata + 1840);
            uint64_t v20 = *(unsigned int *)(udata + 1852);
            if (!v19)
            {
              __int16 v19 = re::PacketPool::allocate(*((re::PacketPool **)this + 25), v20);
              *(void *)(udata + 18re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = v19;
              *((_DWORD *)v19 + 6) = *(_DWORD *)(udata + 1852);
              unint64_t v16 = *(void *)(udata + 1856);
              LODWORD(v20) = *(_DWORD *)(udata + 1852);
            }
            uint64_t v2 = recv(v17, (void *)(*((void *)v19 + 2) + v16 - 8), v20 - v16 + 8, 0);
            if (v2 < 0)
            {
              uint64_t v2 = (uint64_t)__error();
              if (*(_DWORD *)v2 == 35) {
                goto LABEL_50;
              }
              id v31 = *re::networkLogObjects((re *)v2);
              if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
              {
                unint64_t v32 = __error();
                int v33 = strerror(*v32);
                LODWORD(changelist.ident) = 67109378;
                HIDWORD(changelist.ident) = v17;
                changelist.int filter = 2080;
                *(void *)&changelist.flags = v33;
                int v34 = v31;
                int v35 = "recv %i failed: errno = %s";
                uint32_t v36 = 18;
                goto LABEL_106;
              }
              goto LABEL_49;
            }
            uint64_t v21 = *(void *)(udata + 1856) + v2;
            *(void *)(udata + 1856) = v21;
            uint64_t v3 = *(void *)(udata + 1840);
            if (*(unsigned int *)(v3 + 24) + 8 != v21) {
              goto LABEL_50;
            }
            uint64_t v22 = *((void *)this + 23);
            if (v22)
            {
              (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, void, void))(*(void *)v22 + 24))(v22, this, udata, *(unsigned __int8 *)(udata + 1848), *(void *)(v3 + 16));
              uint64_t v3 = *(void *)(udata + 1840);
            }
            int v23 = _MergedGlobals++;
            *(_DWORD *)(udata + 1864) = v23;
            re::PacketPool::free(*((re::PacketPool **)this + 25), (re::Packet *)v3);
            unint64_t v16 = 0;
            *(void *)(udata + 18re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
            *(unsigned char *)(udata + 1848) = 10;
            *(_DWORD *)(udata + 1860) = 0;
            *(void *)(udata + 1852) = 0;
            int v24 = dword_2682A3E3C++;
            *(_DWORD *)(udata + 1864) = v24;
          }
          uint64_t v30 = *((void *)this + 23);
          if (v30) {
            (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, void))(*(void *)v30 + 16))(v30, this, udata, 0);
          }
          *(_DWORD *)(udata + 1768) = 5;
          uint64_t v2 = shutdown(v17, 2);
        }
LABEL_50:
        if ((__int16)eventlist[v4].flags < 0)
        {
          addrinfo v40 = &eventlist[v4];
          uint32_t fflags = v40->fflags;
          p_uint32_t fflags = (int *)&v40->fflags;
          uint64_t v43 = *re::networkLogObjects((re *)v2);
          BOOL v44 = os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
          if (fflags)
          {
            if (v44)
            {
              int v46 = *((unsigned __int16 *)this + 90);
              int v47 = *p_fflags;
              int v48 = strerror(*p_fflags);
              int v49 = __error();
              int v50 = strerror(*v49);
              LODWORD(changelist.ident) = 67110146;
              HIDWORD(changelist.ident) = v46;
              changelist.int filter = 1024;
              *(_DWORD *)&changelist.flags = ident;
              HIWORD(changelist.fflags) = 1024;
              LODWORD(changelist.data) = v47;
              WORD2(changelist.data) = 2080;
              *(int64_t *)((char *)&changelist.data + 6) = (int64_t)v48;
              HIWORD(changelist.udata) = 2080;
              changelist.ext[0] = (uint64_t)v50;
              unint64_t v51 = v43;
              uint64_t v52 = "[ConDebug] Connection Closed on port(%i) socket(%i) reason %i:%s %s";
              uint32_t v53 = 40;
              goto LABEL_60;
            }
          }
          else if (v44)
          {
            int v54 = *((unsigned __int16 *)this + 90);
            LODWORD(changelist.ident) = 67109376;
            HIDWORD(changelist.ident) = v54;
            changelist.int filter = 1024;
            *(_DWORD *)&changelist.flags = ident;
            unint64_t v51 = v43;
            uint64_t v52 = "[ConDebug] Connection Closed on port(%i) socket(%i)";
            uint32_t v53 = 14;
LABEL_60:
            _os_log_impl(&dword_228C70000, v51, OS_LOG_TYPE_DEFAULT, v52, (uint8_t *)&changelist, v53);
          }
          if (!udata)
          {
            uint64_t v63 = *re::networkLogObjects((re *)v44);
            uint64_t v2 = os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT);
            if (v2)
            {
              LODWORD(changelist.ident) = 67109120;
              HIDWORD(changelist.ident) = ident;
              _os_log_impl(&dword_228C70000, v63, OS_LOG_TYPE_DEFAULT, "Unknown connection closed %i", (uint8_t *)&changelist, 8u);
            }
            goto LABEL_53;
          }
          unsigned int v55 = *(_DWORD *)(udata + 1768);
          if (v55 > 5) {
            goto LABEL_98;
          }
          if (((1 << v55) & 0x2C) == 0)
          {
            if (v55 != 1) {
              goto LABEL_144;
            }
            changelist.idenstd::__libcpp_thread_t t = (int)ident;
            *(_DWORD *)&changelist.int filter = 720894;
            memset(&changelist.fflags, 0, 36);
            unsigned int v68 = (re *)kevent64(*((_DWORD *)this + 6), &changelist, 1, 0, 0, 0, 0);
            if (v68 == -1)
            {
              char v69 = *re::networkLogObjects(v68);
              if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
              {
                uint64_t v80 = __error();
                uint64_t v81 = strerror(*v80);
                *(_DWORD *)kevent64_s buf = 136315138;
                *(void *)uint64_t v114 = v81;
                _os_log_error_impl(&dword_228C70000, v69, OS_LOG_TYPE_ERROR, "kevent failed: %s", buf, 0xCu);
              }
            }
            re::TcpProtocolLayer::connectionError(this, (int)ident);
            goto LABEL_98;
          }
          changelist.idenstd::__libcpp_thread_t t = (int)ident;
          *(_DWORD *)&changelist.int filter = 196607;
          memset(&changelist.fflags, 0, 36);
          if (kevent64(*((_DWORD *)this + 6), &changelist, 1, 0, 0, 0, 0) == -1) {
            goto LABEL_142;
          }
          uint64_t v57 = *((void *)this + 23);
          uint64_t v58 = *((void *)this + 10);
          if (v57)
          {
            if (v58)
            {
              unint64_t v59 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * ((int)ident ^ ((unint64_t)(int)ident >> 30))) ^ ((0xBF58476D1CE4E5B9 * ((int)ident ^ ((unint64_t)(int)ident >> 30))) >> 27));
              unint64_t v60 = (v59 ^ (v59 >> 31)) % *((unsigned int *)this + 26);
              uint64_t v61 = *((void *)this + 12);
              uint64_t v62 = *(unsigned int *)(*((void *)this + 11) + 4 * v60);
              if (v62 != 0x7FFFFFFF)
              {
                while (*(_DWORD *)(v61 + 24 * v62 + 12) != ident)
                {
                  uint64_t v62 = *(_DWORD *)(v61 + 24 * v62 + 8) & 0x7FFFFFFF;
                  if (v62 == 0x7FFFFFFF) {
                    goto LABEL_84;
                  }
                }
LABEL_85:
                uint64_t v70 = *(void *)(v61 + 24 * v62 + 16);
                if (v70)
                {
                  id v71 = (id)(v70 + 8);
                  uint64_t v57 = *((void *)this + 23);
                }
                (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, uint64_t))(*(void *)v57 + 8))(v57, this, v70, v70 + 1776);
                *(_DWORD *)(udata + 1768) = 3;
                if (v70) {

                }
LABEL_98:
                *(_DWORD *)(udata + 1768) = 4;
LABEL_52:

                goto LABEL_53;
              }
            }
            else
            {
              uint64_t v61 = *((void *)this + 12);
            }
LABEL_84:
            LODWORD(v62) = 0x7FFFFFFF;
            goto LABEL_85;
          }
          if (v58)
          {
            unint64_t v64 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * ((int)ident ^ ((unint64_t)(int)ident >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                                                  * ((int)ident ^ ((unint64_t)(int)ident >> 30))) >> 27));
            unint64_t v65 = (v64 ^ (v64 >> 31)) % *((unsigned int *)this + 26);
            uint64_t v66 = *((void *)this + 12);
            uint64_t v67 = *(unsigned int *)(*((void *)this + 11) + 4 * v65);
            if (v67 != 0x7FFFFFFF)
            {
              while (*(_DWORD *)(v66 + 24 * v67 + 12) != ident)
              {
                uint64_t v67 = *(_DWORD *)(v66 + 24 * v67 + 8) & 0x7FFFFFFF;
                if (v67 == 0x7FFFFFFF) {
                  goto LABEL_96;
                }
              }
              goto LABEL_97;
            }
          }
          else
          {
            uint64_t v66 = *((void *)this + 12);
          }
LABEL_96:
          LODWORD(v67) = 0x7FFFFFFF;
LABEL_97:
          (*(void (**)(re::TcpProtocolLayer *, void, void))(*(void *)this + 56))(this, *(void *)(v66 + 24 * v67 + 16), 0);
          goto LABEL_98;
        }
      }
      if (udata) {
        goto LABEL_52;
      }
LABEL_53:
      ++v4;
    }
    while (v4 != v103);
  }
  uint64_t v88 = *((unsigned int *)this + 28);
  if (v88)
  {
    uint64_t v89 = 0;
    uint64_t v90 = (int *)(*((void *)this + 12) + 8);
    while (1)
    {
      int v91 = *v90;
      v90 += 6;
      if (v91 < 0) {
        break;
      }
      if (v88 == ++v89)
      {
        LODWORD(v89) = *((_DWORD *)this + 28);
        break;
      }
    }
  }
  else
  {
    LODWORD(v89) = 0;
  }
  if (v88 != v89)
  {
    uint64_t v92 = v89;
    int v104 = *((_DWORD *)this + 28);
    while (1)
    {
      uint64_t v93 = *(void *)(*((void *)this + 12) + 24 * v92 + 16);
      if (v93) {
        id v94 = (id)(v93 + 8);
      }
      unint64_t v95 = *(unsigned int **)(v93 + 1808);
      if (!v95) {
        goto LABEL_120;
      }
      re::TcpProtocolLayer::sendPacketParts(v93, *(void *)(v93 + 1808));
      if (v95[6] + 8 == *(void *)(v93 + 1824)) {
        break;
      }
LABEL_131:

      if (*((_DWORD *)this + 28) <= (v89 + 1)) {
        int v100 = v89 + 1;
      }
      else {
        int v100 = *((_DWORD *)this + 28);
      }
      while (1)
      {
        uint64_t v92 = (v89 + 1);
        if (v100 - 1 == v89) {
          break;
        }
        LODWORD(v89) = v89 + 1;
        int v101 = v92;
        if ((*(_DWORD *)(*((void *)this + 12) + 24 * v92 + 8) & 0x80000000) != 0) {
          goto LABEL_138;
        }
      }
      int v101 = v100;
LABEL_138:
      LODWORD(v89) = v101;
      if (v88 == v101) {
        goto LABEL_139;
      }
    }
    *(void *)(v93 + 1808) = 0;
    *(unsigned char *)(v93 + 1816) = 10;
    *(void *)(v93 + 1828) = 0;
    *(void *)(v93 + 1820) = 0;
    re::PacketPool::free(*((re::PacketPool **)this + 25), (re::Packet *)v95);
LABEL_120:
    uint64_t v96 = 0;
    while (1)
    {
      uint64_t v97 = re::PacketQueue::dequeue((re::PacketQueue *)(v93 + 40 * v96 + 912));
      if (v97) {
        break;
      }
LABEL_125:
      if (++v96 == 10)
      {
        LODWORD(v88) = v104;
        if (!*(void *)(v93 + 1808) && *(_DWORD *)(v93 + 1768) == 3)
        {
          close(*(_DWORD *)(v93 + 1772));
          uint64_t v99 = *((void *)this + 23);
          if (v99) {
            (*(void (**)(uint64_t, re::TcpProtocolLayer *, uint64_t, uint64_t))(*(void *)v99 + 8))(v99, this, v93, v93 + 1776);
          }
        }
        goto LABEL_131;
      }
    }
    uint64_t v88 = v97;
    while (1)
    {
      *(unsigned char *)(v93 + 1816) = v96;
      *(_DWORD *)(v93 + 1820) = *(_DWORD *)(v88 + 24);
      int v98 = re::TcpProtocolLayer::update(void)::debug--;
      *(_DWORD *)(v93 + 1832) = v98;
      re::TcpProtocolLayer::sendPacketParts(v93, v88);
      if (*(unsigned int *)(v88 + 24) + 8 != *(void *)(v93 + 1824)) {
        break;
      }
      *(unsigned char *)(v93 + 1816) = 10;
      *(void *)(v93 + 1820) = 0;
      *(void *)(v93 + 1828) = 0;
      re::PacketPool::free(*((re::PacketPool **)this + 25), (re::Packet *)v88);
      uint64_t v88 = re::PacketQueue::dequeue((re::PacketQueue *)(v93 + 40 * v96 + 912));
      if (!v88) {
        goto LABEL_125;
      }
    }
    *(void *)(v93 + 1808) = v88;
    LODWORD(v88) = v104;
    goto LABEL_131;
  }
LABEL_139:
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v110);
}

void re::TcpProtocolLayer::wait(re::TcpProtocolLayer *this)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  int v1 = (re *)kevent64(*((_DWORD *)this + 6), 0, 0, &v5, 1, 0, 0);
  if (v1 == -1)
  {
    uint64_t v2 = *re::networkLogObjects(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = __error();
      uint64_t v4 = strerror(*v3);
      *(_DWORD *)kevent64_s buf = 136315138;
      uint64_t v7 = v4;
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "kevent failed %s", buf, 0xCu);
    }
  }
}

void re::TcpProtocolLayer::wakeup(re::TcpProtocolLayer *this)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  v5.idenstd::__libcpp_thread_t t = 0;
  *(void *)&v5.int filter = 0x10000000004FFF6;
  memset(&v5.data, 0, 32);
  int v1 = (re *)kevent64(*((_DWORD *)this + 6), &v5, 1, 0, 0, 0, 0);
  if (v1 == -1)
  {
    uint64_t v2 = *re::networkLogObjects(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = __error();
      uint64_t v4 = strerror(*v3);
      *(_DWORD *)kevent64_s buf = 136315138;
      uint64_t v7 = v4;
      _os_log_error_impl(&dword_228C70000, v2, OS_LOG_TYPE_ERROR, "kevent failed %s", buf, 0xCu);
    }
  }
}

uint64_t re::TcpProtocolLayer::setListener(uint64_t this, ProtocolLayerListener *a2)
{
  *(void *)(this + 184) = a2;
  return this;
}

unint64_t re::TcpProtocolLayer::localAddresses(re::TcpProtocolLayer *this, re::Address *a2, unint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (*((void *)this + 18)) {
    uint64_t v6 = (re::IP *)*((void *)this + 19);
  }
  else {
    uint64_t v6 = (re::TcpProtocolLayer *)((char *)this + 145);
  }
  if (!strcmp((const char *)v6, "0.0.0.0"))
  {
    v27[0] = 0;
    uint64_t v8 = (re *)getifaddrs(v27);
    if ((v8 & 0x80000000) != 0)
    {
      int v18 = *re::networkLogObjects(v8);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = *__error();
        *(_DWORD *)kevent64_s buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v19;
        _os_log_impl(&dword_228C70000, v18, OS_LOG_TYPE_DEFAULT, "TcpProtocolLayer: Unable to list network adapters(errno=%d).", buf, 8u);
      }
      return 0;
    }
    else
    {
      uint64_t v10 = v27[0];
      if (v27[0])
      {
        unint64_t v7 = 0;
        do
        {
          ifa_addr = v10->ifa_addr;
          if (ifa_addr)
          {
            unsigned int ifa_flags = v10->ifa_flags;
            if ((ifa_flags & 1) != 0 && ifa_addr->sa_family == 2)
            {
              int v13 = *(_DWORD *)&ifa_addr->sa_data[2];
              ifa_addr = (sockaddr *)((char *)ifa_addr + 4);
              int v12 = v13;
              if ((unsigned __int16)v13 != 65193 && ((ifa_flags & 8) == 0 || v12 == 16777343))
              {
                int v14 = (re::Address *)inet_ntop(2, ifa_addr, v21, 0x11u);
                if (v14)
                {
                  if (v7 < a3)
                  {
                    re::Address::makeFromIPAndPort(v14, (const char *)*((unsigned __int16 *)this + 90), (re::DynamicString *)buf);
                    re::DynamicString::operator=((re::Address *)((char *)a2 + 32 * v7), (re::DynamicString *)buf);
                    if (*(void *)buf)
                    {
                      if (v25) {
                        (*(void (**)(void))(**(void **)buf + 40))();
                      }
                    }
                  }
                  ++v7;
                }
                else
                {
                  int v15 = *re::networkLogObjects(0);
                  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                  {
                    int v16 = *__error();
                    *(_DWORD *)kevent64_s buf = 67109120;
                    *(_DWORD *)&uint8_t buf[4] = v16;
                    _os_log_impl(&dword_228C70000, v15, OS_LOG_TYPE_DEFAULT, "TcpProtocolLayer: Failed to get string representation of ip(errno=%d).", buf, 8u);
                  }
                }
              }
            }
          }
          uint64_t v10 = v10->ifa_next;
        }
        while (v10);
        int v17 = v27[0];
      }
      else
      {
        int v17 = 0;
        unint64_t v7 = 0;
      }
      MEMORY[0x22A6A9750](v17, ifa_addr);
    }
  }
  else
  {
    re::IP::makeFromString(v6, (uint64_t)buf);
    *(_OWORD *)int v27 = v25;
    uint64_t v28 = v26;
    if (a3)
    {
      *(_OWORD *)uint64_t v21 = *(_OWORD *)v27;
      uint64_t v22 = v28;
      __int16 v23 = *((_WORD *)this + 90);
      re::Address::makeFromIPAndPort((unsigned __int16 *)v21, (re::DynamicString *)buf);
      re::DynamicString::operator=(a2, (re::DynamicString *)buf);
      if (*(void *)buf)
      {
        if (v25) {
          (*(void (**)(void))(**(void **)buf + 40))();
        }
      }
    }
    return 1;
  }
  return v7;
}

uint64_t re::TcpProtocolLayer::hostStats()
{
  return 0;
}

uint64_t re::TcpProtocolLayer::preferredPacketSize(re::TcpProtocolLayer *this)
{
  return 0x10000;
}

void re::TcpProtocolLayer::setDisconnectTimeout(re::TcpProtocolLayer *this, unsigned int a2)
{
  if (a2 <= 0x3E8) {
    unsigned int v3 = 1000;
  }
  else {
    unsigned int v3 = a2;
  }
  *((_DWORD *)this + 44) = v3 / 0x3E8;
  uint64_t v4 = *((unsigned int *)this + 28);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (int *)(*((void *)this + 12) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 6;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)this + 28);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    do
    {
      re::TcpProtocolLayer::setupKeepAlive(this, *(_DWORD *)(*((void *)this + 12) + 24 * v8 + 12));
      unsigned int v9 = *((_DWORD *)this + 28);
      if (v9 <= (int)v5 + 1) {
        int v10 = v5 + 1;
      }
      else {
        int v10 = *((_DWORD *)this + 28);
      }
      int v11 = v5;
      while (1)
      {
        uint64_t v8 = (v11 + 1);
        if (v10 - 1 == v11) {
          break;
        }
        ++v11;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(*((void *)this + 12) + 24 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_20;
        }
      }
      LODWORD(v5) = v10;
LABEL_20:
      ;
    }
    while (v9 != v5);
  }
}

uint64_t re::ProtocolLayer::preferredThreadMode(re::ProtocolLayer *this)
{
  return 0;
}

re::DynamicString *re::make::shared::object<re::TcpProtocolHandle,int &,re::TcpConnectionStatus &,re::Address const&>(re *a1, _DWORD *a2, _DWORD *a3, const re::DynamicString *a4)
{
  uint64_t v8 = re::globalAllocators(a1);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 1872, 8);
  LODWORD(a2) = *a2;
  LODWORD(a3) = *a3;
  int v10 = re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v9);
  *(void *)int v10 = &unk_26DD36BD0;
  *((_DWORD *)v10 + 442) = a3;
  *((_DWORD *)v10 + 443) = a2;
  uint64_t result = re::DynamicString::DynamicString((re::ProtocolHandle *)((char *)v10 + 1776), a4);
  *(void *)(v9 + 1808) = 0;
  *(unsigned char *)(v9 + 1816) = 10;
  *(void *)(v9 + 1828) = 0;
  *(void *)(v9 + 1820) = 0;
  *(void *)(v9 + 18re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  *(unsigned char *)(v9 + 1848) = 10;
  *(void *)(v9 + 1860) = 0;
  *(void *)(v9 + 1852) = 0;
  *(void *)a1 = v9;
  return result;
}

void re::TcpProtocolHandle::~TcpProtocolHandle(re::TcpProtocolHandle *this)
{
  *(void *)this = &unk_26DD36BD0;
  re::DynamicString::deinit((re::TcpProtocolHandle *)((char *)this + 1776));
  re::ProtocolHandle::~ProtocolHandle(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD36BD0;
  re::DynamicString::deinit((re::TcpProtocolHandle *)((char *)this + 1776));
  re::ProtocolHandle::~ProtocolHandle(this);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  uint64_t v12 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *a5 = 0;
  *(_DWORD *)(v12 + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&unsigned char v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::ChannelId,void({block_pointer})(RESyncNetSession *,unsigned long long,void const*,unsigned int),re::Hash<re::ChannelId>,re::EqualTo<re::ChannelId>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&unsigned char v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (_DWORD *)(*(void *)&v13[16] + v10 + 12), (void *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 24 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v9 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v9) = a3;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v9 + 12) = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v9 + 16) = *a5;
  *a5 = 0;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

double RESyncCustomLeaderElectionCreate(re *a1)
{
  int v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 112, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)uint64_t v2 = &unk_26DD36C18;
  double result = 0.0;
  *(_OWORD *)(v2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0u;
  *(_OWORD *)(v2 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(void *)(v2 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0;
  return result;
}

const void **RESyncCustomLeaderElectionDeinit(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[3]);
    double result = (const void **)_Block_copy(a2);
    unint64_t v3[3] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionInit(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[4]);
    double result = (const void **)_Block_copy(a2);
    v3[4] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionDestroy(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[5]);
    double result = (const void **)_Block_copy(a2);
    v3[5] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionProcessCapabilities(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[6]);
    double result = (const void **)_Block_copy(a2);
    v3[6] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionProcessPeerHelloSetLeader(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[7]);
    double result = (const void **)_Block_copy(a2);
    v3[7] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionRunLoop(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[8]);
    double result = (const void **)_Block_copy(a2);
    v3[8] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionIsLeader(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[9]);
    double result = (const void **)_Block_copy(a2);
    v3[9] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionHandleMigration(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[10]);
    double result = (const void **)_Block_copy(a2);
    v3[10] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionAddPeer(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[11]);
    double result = (const void **)_Block_copy(a2);
    v3[11] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionRemovePeer(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[12]);
    double result = (const void **)_Block_copy(a2);
    v3[12] = result;
  }
  return result;
}

const void **RESyncCustomLeaderElectionSetSession(const void **result, const void *a2)
{
  if (result)
  {
    unsigned int v3 = result;
    _Block_release(result[13]);
    double result = (const void **)_Block_copy(a2);
    v3[13] = result;
  }
  return result;
}

void *RESyncLeaderElectionCreateCustom(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = a1 + 1;
  unsigned int v3 = a1 + 1;
  if (a1[3] && a1[4] && a1[6] && a1[8] && a1[9] && a1[10] && a1[11] && a1[12] && a1[13])
  {
    uint64_t v4 = re::globalAllocators(v3);
    long long v5 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 40, 8);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)v5, 0);
    *long long v5 = &unk_26DD36C60;
    v5[4] = a1;
    id v6 = v2;

    unsigned int v7 = v5 + 1;
  }
  else
  {
    long long v5 = 0;
  }

  return v5;
}

void anonymous namespace'::CustomLeaderElectionImpl::~CustomLeaderElectionImpl(const void **this)
{
  *this = &unk_26DD36C18;
  _Block_release(this[13]);
  _Block_release(this[12]);
  _Block_release(this[11]);
  _Block_release(this[10]);
  _Block_release(this[9]);
  _Block_release(this[8]);
  _Block_release(this[7]);
  _Block_release(this[6]);
  _Block_release(this[5]);
  _Block_release(this[4]);
  _Block_release(this[3]);
  *this = &unk_26DD34510;
  objc_destructInstance(this + 1);
}

{
  uint64_t vars8;

  JUMPOUT(0x22A6A9430);
}

void anonymous namespace'::CustomLeaderElection::~CustomLeaderElection(_anonymous_namespace_::CustomLeaderElection *this)
{
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = *(void *)(v2 + 40);
  if (!v3 || ((*(void (**)(void))(v3 + 16))(), (uint64_t v2 = *((void *)this + 4)) != 0))
  {

    *((void *)this + 4) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  JUMPOUT(0x22A6A9430);
}

uint64_t anonymous namespace'::CustomLeaderElection::deinit(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 4) + 24) + 16))();
}

uint64_t anonymous namespace'::CustomLeaderElection::setup(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 4) + 32) + 16))();
}

uint64_t anonymous namespace'::CustomLeaderElection::processCapabilities(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 4) + 48) + 16))();
}

uint64_t anonymous namespace'::CustomLeaderElection::processPeerHelloSetLeader(_anonymous_namespace_::CustomLeaderElection *this)
{
  uint64_t result = *(void *)(*((void *)this + 4) + 56);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

uint64_t anonymous namespace'::CustomLeaderElection::runLoop(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 4) + 64) + 16))();
}

uint64_t anonymous namespace'::CustomLeaderElection::isLeader(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 4) + 72) + 16))();
}

uint64_t anonymous namespace'::CustomLeaderElection::handleMigration(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 80) + 16))();
}

uint64_t anonymous namespace'::CustomLeaderElection::addPeer(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 4) + 88) + 16))();
}

uint64_t anonymous namespace'::CustomLeaderElection::removePeer(_anonymous_namespace_::CustomLeaderElection *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 4) + 96) + 16))();
}

uint64_t anonymous namespace'::CustomLeaderElection::setSession(_anonymous_namespace_::CustomLeaderElection *this, re::Session *a2)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 4) + 104) + 16))();
}

uint64_t RESyncBitWriterGetRequiredSize()
{
  return 40;
}

uint64_t RESyncBitWriterConstructNoAlloc(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = 0;
  if (a1 && a2 >= 0x28)
  {
    *(void *)a1 = &unk_26DD35FA8;
    *(void *)(a1 + 8) = a3;
    *(_DWORD *)(a1 + 16) = a4;
    *(unsigned char *)(a1 + 20) = 0;
    *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
    *(void *)(a1 + 32) = 0;
    return a1;
  }
  return v4;
}

uint64_t RESyncBitWriterConstructNoAllocWithStartingBitMarker(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2 >= 0x28)
    {
      *(void *)a1 = &unk_26DD35FA8;
      *(void *)(a1 + 8) = a3;
      *(_DWORD *)(a1 + 16) = a4;
      *(unsigned char *)(a1 + 20) = 0;
      *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
      *(void *)(a1 + 32) = 0;
      re::BitWriter::rollbackTo(a1, a5);
      return a1;
    }
  }
  return result;
}

uint64_t RESyncBitWriterBackedRequiredSize()
{
  return 56;
}

uint64_t RESyncBitWriterConstructBackedNoAlloc(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = 0;
  if (a1 && a2 >= 0x38)
  {
    *(_DWORD *)(a1 + 16) = a4;
    *(unsigned char *)(a1 + 20) = 0;
    *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)a1 = &unk_26DD35FF8;
    *(void *)(a1 + 8) = a3;
    uint64_t v6 = a1;
    *(void *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = a6;
    *(void *)(a1 + 48) = a5;
  }
  return v6;
}

uint64_t RESyncBitWriterDestructNoDealloc(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t RESyncBitWriterWriteUInt8(uint64_t a1, unsigned int a2)
{
  return re::BitWriter::writeUInt32Bits(a1, a2, 8u);
}

uint64_t RESyncBitWriterWriteUInt16(uint64_t a1, unsigned int a2)
{
  return re::BitWriter::writeUInt32Bits(a1, a2, 0x10u);
}

uint64_t RESyncBitWriterWriteUInt32(uint64_t a1, unsigned int a2)
{
  return re::BitWriter::writeUInt32Bits(a1, a2, 0x20u);
}

uint64_t RESyncBitWriterWriteUInt64(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = HIDWORD(a2);
  re::BitWriter::writeUInt32Bits(a1, a2, 0x20u);
  return re::BitWriter::writeUInt32Bits(a1, v2, 0x20u);
}

uint64_t RESyncBitWriterWriteBool(uint64_t a1, unsigned int a2)
{
  return re::BitWriter::writeUInt32Bits(a1, a2, 1u);
}

uint64_t RESyncBitWriterWriteFloat(uint64_t a1, float a2)
{
  return re::BitWriter::writeUInt32Bits(a1, LODWORD(a2), 0x20u);
}

uint64_t RESyncBitWriterWitePeerID(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = HIDWORD(a2);
  re::BitWriter::writeUInt32Bits(a1, a2, 0x20u);
  return re::BitWriter::writeUInt32Bits(a1, v2, 0x20u);
}

uint64_t RESyncBitWriterMakeMarker(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t RESyncBitWriterClear(uint64_t result)
{
  *(void *)(result + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(void *)(result + 32) = 0;
  return result;
}

uint64_t RESyncBitWriterIsOverflow(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 20);
}

uint64_t RESyncBitWriterData(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t RESyncBitWriterSize(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 28)) {
    return v1 + 1;
  }
  else {
    return v1;
  }
}

uint64_t RESyncBitWriterBitsLeft(_DWORD *a1)
{
  return (8 * (a1[4] - a1[6]) - a1[7]);
}

uint64_t RESyncBitWriterOpenBuffer(uint64_t a1, void *a2)
{
  re::BitWriter::alignToByte((_DWORD *)a1);
  LODWORD(v5) = *(_DWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 28)) {
    uint64_t v5 = (v5 + 1);
  }
  else {
    uint64_t v5 = v5;
  }
  uint64_t v6 = *(void *)(a1 + 8) + v5;
  *a2 = re::BitWriter::bytesLeft((re::BitWriter *)a1, v4);
  return v6;
}

uint64_t RESyncBitWriterGrowBuffer(re::BitWriter *a1, int a2, _DWORD *a3)
{
  (*(void (**)(re::BitWriter *, void))(*(void *)a1 + 16))(a1, (a2 - *((_DWORD *)a1 + 2) + *a3));
  LODWORD(v6) = *((_DWORD *)a1 + 6);
  if (*((_DWORD *)a1 + 7)) {
    uint64_t v6 = (v6 + 1);
  }
  else {
    uint64_t v6 = v6;
  }
  uint64_t v7 = *((void *)a1 + 1) + v6;
  *(void *)a3 = re::BitWriter::bytesLeft(a1, v5);
  return v7;
}

BOOL RESyncBitWriterCloseBuffer(uint64_t a1, int a2, int a3)
{
  return re::BitWriter::rollbackTo(a1, (a2 + a3 - *(_DWORD *)(a1 + 8)));
}

uint64_t re::SyncCommitDump::log(NSObject *a1, uint64_t a2, const char *a3)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t result = os_log_type_enabled(a1, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    float v7 = *(float *)(a2 + 24);
    long long v8 = "Commit";
    if (a3) {
      long long v8 = a3;
    }
    if (v7 <= 0.0)
    {
      int v18 = "(Atomic)";
      int v19 = *(unsigned __int8 *)(a2 + 28);
      if ((*(unsigned char *)a2 & 1) == 0) {
        int v18 = (const char *)&unk_228CE091E;
      }
      uint64_t v20 = *(void *)(a2 + 8);
      BOOL v12 = (*(unsigned char *)a2 & 2) == 0;
      int v23 = 136316162;
      uint64_t v21 = "(Held)";
      if (v12) {
        uint64_t v21 = (const char *)&unk_228CE091E;
      }
      int v24 = v8;
      __int16 v25 = 2080;
      uint64_t v26 = v18;
      if (v19) {
        uint64_t v22 = "(Fwd)";
      }
      else {
        uint64_t v22 = (const char *)&unk_228CE091E;
      }
      __int16 v27 = 2080;
      uint64_t v28 = v21;
      __int16 v29 = 2080;
      uint64_t v30 = v22;
      __int16 v31 = 2048;
      uint64_t v32 = v20;
      int v15 = "%s %s%s%s Peer=%llu";
      int v16 = a1;
      uint32_t v17 = 52;
    }
    else
    {
      uint64_t v9 = "(Atomic)";
      int v10 = *(unsigned __int8 *)(a2 + 28);
      if ((*(unsigned char *)a2 & 1) == 0) {
        uint64_t v9 = (const char *)&unk_228CE091E;
      }
      uint64_t v11 = *(void *)(a2 + 8);
      BOOL v12 = (*(unsigned char *)a2 & 2) == 0;
      int v23 = 136316418;
      uint64_t v13 = "(Held)";
      if (v12) {
        uint64_t v13 = (const char *)&unk_228CE091E;
      }
      int v24 = v8;
      __int16 v25 = 2080;
      uint64_t v26 = v9;
      if (v10) {
        int v14 = "(Fwd)";
      }
      else {
        int v14 = (const char *)&unk_228CE091E;
      }
      __int16 v27 = 2080;
      uint64_t v28 = v13;
      __int16 v29 = 2080;
      uint64_t v30 = v14;
      __int16 v31 = 2048;
      uint64_t v32 = v11;
      __int16 v33 = 2048;
      double v34 = v7;
      int v15 = "%s %s%s%s Peer=%llu TTL=%0.2f";
      int v16 = a1;
      uint32_t v17 = 62;
    }
    _os_log_debug_impl(&dword_228C70000, v16, OS_LOG_TYPE_DEBUG, v15, (uint8_t *)&v23, v17);
    return re::SyncSnapshotDump::log(a1, a2, a3);
  }
  return result;
}

uint64_t re::SyncCommitDump::log(re *a1, uint64_t a2, const char *a3)
{
  uint64_t v5 = (uint64_t)a1;
  uint64_t v6 = (re::NetworkFeatureFlags *)re::networkLogObjects(a1);
  float v7 = *(NSObject **)v6;
  uint64_t result = re::NetworkFeatureFlags::enableSyncCommitLog(v6);
  if (result && a2)
  {
    uint64_t v9 = 72 * a2;
    do
    {
      uint64_t result = re::SyncCommitDump::log(v7, v5, a3);
      v5 += 72;
      v9 -= 72;
    }
    while (v9);
  }
  return result;
}

uint64_t re::BiasedVLQ::write(re::BiasedVLQ *this, re::BitWriter *a2, uint64_t a3)
{
  unint64_t v4 = *(void *)this + a3;
  if (v4 < 0x80)
  {
    unint64_t v5 = *(void *)this + a3;
  }
  else
  {
    do
    {
      re::BitWriter::writeUInt32Bits((uint64_t)a2, v4 & 0x7F | 0x80, 8u);
      unint64_t v5 = v4 >> 7;
      unint64_t v6 = v4 >> 14;
      v4 >>= 7;
    }
    while (v6);
  }
  re::BitWriter::writeUInt32Bits((uint64_t)a2, v5, 8u);
  return 1;
}

uint64_t re::BiasedVLQ::read(re::BiasedVLQ *this, re::BitReader *a2, uint64_t *a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  do
  {
    unsigned int v9 = 0;
    re::BitReader::readUInt32Bits((uint64_t *)a2, 8u, &v9);
    v7 |= (unint64_t)(v9 & 0x7F) << v6;
    v6 += 7;
  }
  while ((v9 & 0x80) != 0);
  *a3 = v7 - *(void *)this;
  return 1;
}

uint64_t re::SyncSnapshot::writeObject(void *a1, re::SyncObject **a2)
{
  re::SyncObject::addState(*a2, 0, 0);
  unint64_t v4 = *a2;
  v10[0] = v4;
  if (v4)
  {
    unint64_t v5 = (char *)v4 + 8;
    uint64_t v6 = *a2;
  }
  else
  {
    uint64_t v6 = 0;
  }
  v10[1] = re::SyncObject::latestStateHandle(v6);
  char v11 = 0;
  re::DynamicArray<re::internal::SyncSnapshotEntry>::add(a1, (uint64_t)v10);
  if (v10[0]) {

  }
  uint64_t v7 = a1[4] + 24 * a1[2];
  uint64_t v9 = *(void *)(v7 - 24);
  uint64_t result = v7 - 24;
  ++*(_WORD *)(v9 + 176);
  return result;
}

void *re::DynamicArray<re::internal::SyncSnapshotEntry>::add(void *this, uint64_t a2)
{
  uint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::internal::SyncSnapshotEntry>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  uint64_t v5 = v3[4] + 24 * v4;
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v6 = *(void *)(a2 + 8);
  *(unsigned char *)(v5 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(v5 + 8) = v6;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

BOOL re::SyncSnapshot::writeDestroyedObject(void *a1, re::SyncObject **a2)
{
  *((unsigned char *)*a2 + 128) |= 4u;
  unint64_t v4 = *a2;
  *((_WORD *)v4 + 88) = *((_WORD *)*a2 + 88) + 1;
  unint64_t LatestState = re::SyncObject::getLatestState(v4);
  if (LatestState)
  {
    uint64_t v6 = *a2;
    v16[0] = v6;
    if (v6)
    {
      uint64_t v7 = (char *)v6 + 8;
      long long v8 = *a2;
    }
    else
    {
      long long v8 = 0;
    }
    v16[1] = re::SyncObject::latestStateHandle(v8);
    char v17 = 2;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::add(a1, (uint64_t)v16);
    if (v16[0]) {

    }
    *(_WORD *)(LatestState + 84) = 0;
    *(void *)(LatestState + 88) = 0;
    ++*(_DWORD *)(LatestState + 80);
  }
  else
  {
    uint64_t v9 = *a2;
    int v10 = (re::SyncObject *)*((void *)*a2 + 10);
    char v11 = *a2;
    if (v10)
    {
      BOOL v12 = *a2;
      do
      {
        char v11 = v12;
        BOOL v12 = v10;
        if (*(unsigned char *)(*(void *)(*((void *)v11 + 11) + 16) + 73)) {
          break;
        }
        int v10 = (re::SyncObject *)*((void *)v10 + 10);
        char v11 = v12;
      }
      while (v10);
    }
    if (*((unsigned char *)v11 + 170))
    {
      uint64_t v13 = *((void *)v9 + 11);
      int v18 = *a2;
      int v14 = (char *)v9 + 8;
      re::SyncObjectTypedStore::removeObject(v13, (uint64_t)&v18);
      if (v18) {
    }
      }
  }
  return LatestState != 0;
}

BOOL re::SyncSnapshot::addToView(void *a1, re::SyncObject **a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  unint64_t v4 = re::SyncObject::latestStateHandle(*a2);
  if (v4 == -1)
  {
    uint64_t v7 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *((void *)*a2 + 3);
      int v10 = *(void **)(*((void *)*a2 + 11) + 16);
      uint64_t v11 = v10[4];
      uint64_t v12 = v10[6];
      uint64_t v13 = (char *)v10[7];
      int v14 = (char *)v10 + 49;
      if (v12) {
        int v14 = v13;
      }
      *(_DWORD *)int v15 = 134218498;
      *(void *)&unsigned char v15[4] = v9;
      *(_WORD *)&v15[12] = 2048;
      *(void *)&v15[14] = v11;
      __int16 v16 = 2080;
      char v17 = v14;
      _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "Sync object without snapshot while adding to view (id: %llu, type: %llu[%s]).", v15, 0x20u);
    }
  }
  else
  {
    uint64_t v5 = *a2;
    *(void *)int v15 = v5;
    if (v5) {
      uint64_t v6 = (char *)v5 + 8;
    }
    *(void *)&v15[8] = v4;
    v15[16] = 1;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::add(a1, (uint64_t)v15);
    if (*(void *)v15) {
  }
    }
  return v4 != -1;
}

BOOL re::SyncSnapshot::removeFromView(void *a1, re::SyncObject **a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  unint64_t v4 = re::SyncObject::latestStateHandle(*a2);
  if (v4 == -1)
  {
    uint64_t v7 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *((void *)*a2 + 3);
      int v10 = *(void **)(*((void *)*a2 + 11) + 16);
      uint64_t v11 = v10[4];
      uint64_t v12 = v10[6];
      uint64_t v13 = (char *)v10[7];
      int v14 = (char *)v10 + 49;
      if (v12) {
        int v14 = v13;
      }
      *(_DWORD *)int v15 = 134218498;
      *(void *)&unsigned char v15[4] = v9;
      *(_WORD *)&v15[12] = 2048;
      *(void *)&v15[14] = v11;
      __int16 v16 = 2080;
      char v17 = v14;
      _os_log_error_impl(&dword_228C70000, v7, OS_LOG_TYPE_ERROR, "Sync object without snapshot while removing from view (id: %llu, type: %llu[%s]).", v15, 0x20u);
    }
  }
  else
  {
    uint64_t v5 = *a2;
    *(void *)int v15 = v5;
    if (v5) {
      uint64_t v6 = (char *)v5 + 8;
    }
    *(void *)&v15[8] = v4;
    v15[16] = 2;
    re::DynamicArray<re::internal::SyncSnapshotEntry>::add(a1, (uint64_t)v15);
    if (*(void *)v15) {
  }
    }
  return v4 != -1;
}

uint64_t re::SyncSnapshot::readAt(re::SyncSnapshot *this, unint64_t a2)
{
  if (*((void *)this + 2) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = *((void *)this + 4) + 24 * a2;
  if (!re::SyncObject::getState(*(re::SyncObject **)v2, *(void *)(v2 + 8))) {
    re::SyncObject::getOldestState(*(re::SyncObject **)v2);
  }
  return v2;
}

re::DebugProtocolLayer *re::DebugProtocolLayer::DebugProtocolLayer(re::DebugProtocolLayer *this)
{
  *((void *)this + 3) = 0;
  *(void *)this = &unk_26DD36D00;
  *((_DWORD *)this + 8) = 0;
  *(_OWORD *)((char *)this + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 68) = 0u;
  *(void *)((char *)this + 84) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 0;
  *(void *)((char *)this + 132) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 1ArcSharedObject::ArcSharedObject(this, 0) = 0u;
  *((void *)this + 22) = 0;
  *((void *)this + 18) = dispatch_semaphore_create(0);
  *((void *)this + 19) = dispatch_semaphore_create(0);
  return this;
}

void re::DebugProtocolLayer::~DebugProtocolLayer(re::DebugProtocolLayer *this)
{
  *(void *)this = &unk_26DD36D00;
  dispatch_release(*((dispatch_object_t *)this + 18));
  *((void *)this + 18) = 0;
  dispatch_release(*((dispatch_object_t *)this + 19));
  *((void *)this + 19) = 0;
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 12);
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::deinit((uint64_t *)this + 6);
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {

    *((void *)this + 5) = 0;
  }
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::DebugProtocolLayer::~DebugProtocolLayer(this);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::DebugProtocolLayer::init(re::_anonymous_namespace_ *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    a1 = (re::_anonymous_namespace_ *)(id)(v4 + 8);
  }
  uint64_t v5 = *((void *)v3 + 5);
  *((void *)v3 + 5) = v4;
  if (v5) {

  }
  std::recursive_mutex::lock(&stru_2682A47F0);
  int v6 = qword_2682A47E8;
  LODWORD(qword_2682A47E8) = qword_2682A47E8 + 1;
  *((_DWORD *)v3 + 8) = v6;
  unint64_t v7 = qword_2682A47C8;
  if (qword_2682A47C8)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)qword_2682A47C8);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v2 = v6;
      if (qword_2682A47C8 <= (unint64_t)v6) {
        unint64_t v2 = v6 % (unint64_t)qword_2682A47C8;
      }
    }
    else
    {
      unint64_t v2 = (qword_2682A47C8 - 1) & v6;
    }
    uint64_t v9 = *(uint64_t ***)(qword_2682A47C0 + 8 * v2);
    if (v9)
    {
      for (unint64_t i = *v9; i; unint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (*((_DWORD *)i + 4) == v6) {
            goto LABEL_78;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= qword_2682A47C8) {
              v11 %= (unint64_t)qword_2682A47C8;
            }
          }
          else
          {
            v11 &= qword_2682A47C8 - 1;
          }
          if (v11 != v2) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = operator new(0x20uLL);
  *uint64_t v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = v6;
  v12[3] = v3;
  float v13 = (float)(unint64_t)(qword_2682A47D8 + 1);
  if (!v7 || (float)(*(float *)&dword_2682A47E0 * (float)v7) < v13)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v13 / *(float *)&dword_2682A47E0);
    if (v15 <= v16) {
      int8x8_t prime = (int8x8_t)v16;
    }
    else {
      int8x8_t prime = (int8x8_t)v15;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = qword_2682A47C8;
    }
    if (*(void *)&prime > v7) {
      goto LABEL_34;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v24 = vcvtps_u32_f32((float)(unint64_t)qword_2682A47D8 / *(float *)&dword_2682A47E0);
      if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = qword_2682A47C8;
      }
      else
      {
        if (prime)
        {
LABEL_34:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * *(void *)&prime);
          int v19 = (void *)qword_2682A47C0;
          qword_2682A47C0 = (uint64_t)v18;
          if (v19) {
            operator delete(v19);
          }
          uint64_t v20 = 0;
          qword_2682A47C8 = (uint64_t)prime;
          do
            *(void *)(qword_2682A47C0 + 8 * v20++) = 0;
          while (*(void *)&prime != v20);
          uint64_t v21 = (void **)qword_2682A47D0;
          if (qword_2682A47D0)
          {
            unint64_t v22 = *(void *)(qword_2682A47D0 + 8);
            uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(void *)&prime) {
                v22 %= *(void *)&prime;
              }
            }
            else
            {
              v22 &= *(void *)&prime - 1;
            }
            *(void *)(qword_2682A47C0 + 8 * v22) = &qword_2682A47D0;
            for (j = *v21; j; unint64_t v22 = v28)
            {
              unint64_t v28 = j[1];
              if (v23.u32[0] > 1uLL)
              {
                if (v28 >= *(void *)&prime) {
                  v28 %= *(void *)&prime;
                }
              }
              else
              {
                v28 &= *(void *)&prime - 1;
              }
              if (v28 != v22)
              {
                if (!*(void *)(qword_2682A47C0 + 8 * v28))
                {
                  *(void *)(qword_2682A47C0 + 8 * v28) = v21;
                  goto LABEL_59;
                }
                *uint64_t v21 = (void *)*j;
                *uint64_t j = **(void **)(qword_2682A47C0 + 8 * v28);
                **(void **)(qword_2682A47C0 + 8 * v28) = j;
                uint64_t j = v21;
              }
              unint64_t v28 = v22;
LABEL_59:
              uint64_t v21 = (void **)j;
              uint64_t j = (void *)*j;
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_63;
        }
        double v34 = (void *)qword_2682A47C0;
        qword_2682A47C0 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        qword_2682A47C8 = 0;
      }
    }
LABEL_63:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v2 = v6 % v7;
      }
      else {
        unint64_t v2 = v6;
      }
    }
    else
    {
      unint64_t v2 = (v7 - 1) & v6;
    }
  }
  uint64_t v29 = qword_2682A47C0;
  uint64_t v30 = *(void **)(qword_2682A47C0 + 8 * v2);
  if (v30)
  {
    *uint64_t v12 = *v30;
LABEL_76:
    *uint64_t v30 = v12;
    goto LABEL_77;
  }
  uint64_t v31 = qword_2682A47D0;
  *uint64_t v12 = qword_2682A47D0;
  qword_2682A47D0 = (uint64_t)v12;
  *(void *)(v29 + 8 * v2) = &qword_2682A47D0;
  if (v31)
  {
    unint64_t v32 = *(void *)(v31 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    uint64_t v30 = (void *)(qword_2682A47C0 + 8 * v32);
    goto LABEL_76;
  }
LABEL_77:
  ++qword_2682A47D8;
LABEL_78:
  std::recursive_mutex::unlock(&stru_2682A47F0);
  return 1;
}

void re::anonymous namespace'::interconnect(re::_anonymous_namespace_ *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_1, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_1))
  {
    *(_OWORD *)&qword_2682A47D0 = 0u;
    *(_OWORD *)&qword_2682A47C0 = 0u;
    dword_2682A47E0 = 1065353216;
    qword_2682A47E8 = 0x100000001;
    MEMORY[0x22A6A9340](&unk_2682A47F0);
    __cxa_guard_release(&_MergedGlobals_1);
  }
}

void re::DebugProtocolLayer::deinit(re::DebugProtocolLayer *this)
{
  std::recursive_mutex::lock(&stru_2682A47F0);
  uint64_t v3 = *((unsigned int *)this + 20);
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (int *)(*((void *)this + 8) + 8);
    while (1)
    {
      int v6 = *v5;
      v5 += 6;
      if (v6 < 0) {
        break;
      }
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 20);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if (v3 != v4)
  {
    uint64_t v7 = v4;
    do
    {
      uint64_t v8 = *(void *)(*((void *)this + 8) + 24 * v7 + 16);
      if (v8) {
        unint64_t v2 = (re::_anonymous_namespace_ *)(id)(v8 + 8);
      }
      re::DebugProtocolInterconnect::sendDisconnect((re::DebugProtocolInterconnect *)*(unsigned int *)(v8 + 1776), *(_DWORD *)(v8 + 1784));

      if (*((_DWORD *)this + 20) <= (v4 + 1)) {
        int v9 = v4 + 1;
      }
      else {
        int v9 = *((_DWORD *)this + 20);
      }
      while (1)
      {
        uint64_t v7 = (v4 + 1);
        if (v9 - 1 == v4) {
          break;
        }
        LODWORD(v4) = v4 + 1;
        int v10 = v7;
        if ((*(_DWORD *)(*((void *)this + 8) + 24 * v7 + 8) & 0x80000000) != 0) {
          goto LABEL_18;
        }
      }
      int v10 = v9;
LABEL_18:
      LODWORD(v4) = v10;
    }
    while (v3 != v10);
  }
  while (*((_DWORD *)this + 31))
  {
    uint64_t v11 = *((unsigned int *)this + 32);
    uint64_t v12 = *((void *)this + 14);
    uint64_t v13 = 0;
    if (v11)
    {
      BOOL v14 = (int *)(v12 + 8);
      while (1)
      {
        int v15 = *v14;
        v14 += 6;
        if (v15 < 0) {
          break;
        }
        if (v11 == ++v13)
        {
          LODWORD(v13) = *((_DWORD *)this + 32);
          break;
        }
      }
    }
    re::DebugProtocolLayer::withlock_close(this, *(_DWORD **)(v12 + 24 * v13 + 16));
  }
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear((uint64_t)this + 48);
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::clear((uint64_t)this + 96);
  uint64_t v17 = *((void *)this + 5);
  if (v17)
  {

    *((void *)this + 5) = 0;
  }
  std::recursive_mutex::lock(&stru_2682A47F0);
  unint64_t v18 = qword_2682A47C8;
  if (!qword_2682A47C8) {
    goto LABEL_74;
  }
  unint64_t v19 = *((int *)this + 8);
  uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)qword_2682A47C8);
  v20.i16[0] = vaddlv_u8(v20);
  if (v20.u32[0] > 1uLL)
  {
    unint64_t v21 = *((int *)this + 8);
    if (qword_2682A47C8 <= v19) {
      unint64_t v21 = v19 % qword_2682A47C8;
    }
  }
  else
  {
    unint64_t v21 = (qword_2682A47C8 - 1) & v19;
  }
  unint64_t v22 = *(void ***)(qword_2682A47C0 + 8 * v21);
  if (!v22) {
    goto LABEL_74;
  }
  uint8x8_t v23 = (uint64_t *)*v22;
  if (!*v22) {
    goto LABEL_74;
  }
  uint64_t v24 = qword_2682A47C8 - 1;
  while (1)
  {
    unint64_t v25 = v23[1];
    if (v25 == v19) {
      break;
    }
    if (v20.u32[0] > 1uLL)
    {
      if (v25 >= qword_2682A47C8) {
        v25 %= (unint64_t)qword_2682A47C8;
      }
    }
    else
    {
      v25 &= v24;
    }
    if (v25 != v21) {
      goto LABEL_74;
    }
LABEL_44:
    uint8x8_t v23 = (uint64_t *)*v23;
    if (!v23) {
      goto LABEL_74;
    }
  }
  if (*((_DWORD *)v23 + 4) != v19) {
    goto LABEL_44;
  }
  uint64_t v26 = *v23;
  if (v20.u32[0] > 1uLL)
  {
    if (qword_2682A47C8 <= v19) {
      v19 %= (unint64_t)qword_2682A47C8;
    }
  }
  else
  {
    v19 &= v24;
  }
  __int16 v27 = *(uint64_t **)(qword_2682A47C0 + 8 * v19);
  do
  {
    unint64_t v28 = v27;
    __int16 v27 = (uint64_t *)*v27;
  }
  while (v27 != v23);
  if (v28 == &qword_2682A47D0) {
    goto LABEL_63;
  }
  unint64_t v29 = v28[1];
  if (v20.u32[0] > 1uLL)
  {
    if (v29 >= qword_2682A47C8) {
      v29 %= (unint64_t)qword_2682A47C8;
    }
  }
  else
  {
    v29 &= v24;
  }
  if (v29 == v19)
  {
LABEL_65:
    if (v26)
    {
      unint64_t v30 = *(void *)(v26 + 8);
      goto LABEL_67;
    }
  }
  else
  {
LABEL_63:
    if (!v26) {
      goto LABEL_64;
    }
    unint64_t v30 = *(void *)(v26 + 8);
    if (v20.u32[0] > 1uLL)
    {
      unint64_t v31 = *(void *)(v26 + 8);
      if (v30 >= qword_2682A47C8) {
        unint64_t v31 = v30 % qword_2682A47C8;
      }
    }
    else
    {
      unint64_t v31 = v30 & v24;
    }
    if (v31 != v19)
    {
LABEL_64:
      *(void *)(qword_2682A47C0 + 8 * v19) = 0;
      uint64_t v26 = *v23;
      goto LABEL_65;
    }
LABEL_67:
    if (v20.u32[0] > 1uLL)
    {
      if (v30 >= v18) {
        v30 %= v18;
      }
    }
    else
    {
      v30 &= v24;
    }
    if (v30 != v19)
    {
      *(void *)(qword_2682A47C0 + 8 * v3ArcSharedObject::ArcSharedObject(this, 0) = v28;
      uint64_t v26 = *v23;
    }
  }
  *unint64_t v28 = v26;
  *uint8x8_t v23 = 0;
  --qword_2682A47D8;
  operator delete(v23);
LABEL_74:
  *((_DWORD *)this + 8) = 0;
  std::recursive_mutex::unlock(&stru_2682A47F0);
  std::recursive_mutex::unlock(&stru_2682A47F0);
}

void re::DebugProtocolInterconnect::sendDisconnect(re::DebugProtocolInterconnect *this, int a2)
{
  int v3 = (int)this;
  uint64_t v17 = *MEMORY[0x263EF8340];
  std::recursive_mutex::lock(&stru_2682A47F0);
  uint64_t v4 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v3);
  if (v4)
  {
    uint64_t v5 = v4[3];
    if (v5)
    {
      int v6 = (re *)re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet(v5 + 96, a2);
      if (v6)
      {
        uint64_t v7 = *(_DWORD **)v6;
        if (*(void *)v6)
        {
          uint64_t v8 = *re::networkLogObjects(v6);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            int v9 = *(_DWORD *)(v5 + 32);
            int v10 = v7[444];
            LODWORD(v12) = 67109632;
            HIDWORD(v12) = v9;
            __int16 v13 = 1024;
            int v14 = v10;
            __int16 v15 = 1024;
            LODWORD(v16) = a2;
            _os_log_impl(&dword_228C70000, v8, OS_LOG_TYPE_DEFAULT, "[DebugLayer disconnected] local=%d remote=%d connection=%d", (uint8_t *)&v12, 0x14u);
          }
          v7[447] = 3;
          uint64_t v11 = *(void *)(v5 + 24);
          if (v11)
          {
            (*(void (**)(uint64_t, uint64_t, _DWORD *, uint64_t *))(*(void *)v11 + 8))(v11, v5, v7, &v12);
            if (v12)
            {
              if (v13) {
                (*(void (**)(void))(*(void *)v12 + 40))();
              }
            }
          }
        }
      }
    }
  }
  std::recursive_mutex::unlock(&stru_2682A47F0);
}

void re::DebugProtocolLayer::withlock_close(re *a1, _DWORD *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v4 = *re::networkLogObjects(a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *((_DWORD *)a1 + 8);
    int v6 = a2[444];
    int v7 = a2[446];
    LODWORD(v9) = 67109632;
    HIDWORD(v9) = v5;
    __int16 v10 = 1024;
    int v11 = v6;
    __int16 v12 = 1024;
    int v13 = v7;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "[DebugLayer close] local=%d remote=%d connection=%d", (uint8_t *)&v9, 0x14u);
  }
  a2[447] = 3;
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::remove((uint64_t)a1 + 96, a2 + 446);
  uint64_t v8 = a2 + 2;
  int v9 = a2;
  re::HashSetBase<re::SharedPtr<re::SyncView>,re::SharedPtr<re::SyncView>,re::internal::ValueAsKey<re::SharedPtr<re::SyncView>>,re::Hash<re::SharedPtr<re::SyncView>>,re::EqualTo<re::SharedPtr<re::SyncView>>,true,false>::remove((uint64_t)a1 + 48, (uint64_t *)&v9);
  if (v9) {
}
  }

void re::DebugProtocolLayer::send(re::_anonymous_namespace_ *a1, int *a2, uint64_t a3)
{
  std::recursive_mutex::lock(&stru_2682A47F0);
  uint64_t v7 = *(void *)a3;
  uint64_t v8 = *(void *)(a3 + 8);
  while (v7 != v8)
  {
    uint64_t v9 = atomic_load(*(unint64_t **)(v7 + 8));
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(*(void *)a3 + 16), memory_order_acquire);
    if (v9)
    {
      unint64_t v11 = explicit + 1;
      do
      {
        if (!--v11) {
          break;
        }
        uint64_t v12 = *(unsigned __int8 *)(a3 + 16);
        int v13 = a2[444];
        if (v13 == -1) {
          re::DebugProtocolInterconnect::broadcastPacket(a2[442], v12, v9);
        }
        else {
          re::DebugProtocolInterconnect::sendPacket(a2[444], a2[446], v12, v9);
        }
        *((_DWORD *)a1 + 43) += *(_DWORD *)(v9 + 24);
        ++*((_DWORD *)a1 + 45);
        uint64_t v14 = (re::PacketPool **)re::PacketQueue::dequeue(*(re::PacketQueue **)a3);
        re::PacketPool::free(v14[7], (re::Packet *)v14);
        uint64_t v9 = atomic_load(*(unint64_t **)(*(void *)a3 + 8));
      }
      while (v9);
    }
    uint64_t v8 = *(void *)(a3 + 8);
    uint64_t v7 = *(void *)a3 + 40;
    *(void *)a3 = v7;
    ++*(unsigned char *)(a3 + 16);
  }
  std::recursive_mutex::unlock(&stru_2682A47F0);
}

intptr_t re::DebugProtocolLayer::update(dispatch_semaphore_t *this)
{
  return dispatch_semaphore_signal(this[19]);
}

void re::DebugProtocolInterconnect::broadcastPacket(int a1, uint64_t a2, uint64_t a3)
{
  std::recursive_mutex::lock(&stru_2682A47F0);
  int v6 = (void *)qword_2682A47D0;
  if (qword_2682A47D0)
  {
    do
    {
      uint64_t v7 = v6[3];
      if (*(_DWORD *)(v7 + 32) != a1)
      {
        uint64_t v8 = *(unsigned int *)(v7 + 80);
        if (v8)
        {
          uint64_t v9 = 0;
          __int16 v10 = (int *)(*(void *)(v7 + 64) + 8);
          while (1)
          {
            int v11 = *v10;
            v10 += 6;
            if (v11 < 0) {
              break;
            }
            if (v8 == ++v9)
            {
              LODWORD(v9) = *(_DWORD *)(v7 + 80);
              break;
            }
          }
        }
        else
        {
          LODWORD(v9) = 0;
        }
        if (v8 != v9)
        {
          uint64_t v12 = v9;
          do
          {
            int v13 = *(_DWORD **)(*(void *)(v7 + 64) + 24 * v12 + 16);
            if (v13) {
              uint64_t v14 = v13 + 2;
            }
            if (v13[444] == a1) {
              re::DebugProtocolLayer::withlock_receive(v7, v13[446], a2, *(void *)(a3 + 16), *(_DWORD *)(a3 + 24));
            }

            if (*(_DWORD *)(v7 + 80) <= (v9 + 1)) {
              int v15 = v9 + 1;
            }
            else {
              int v15 = *(_DWORD *)(v7 + 80);
            }
            while (1)
            {
              uint64_t v12 = (v9 + 1);
              if (v15 - 1 == v9) {
                break;
              }
              LODWORD(v9) = v9 + 1;
              int v16 = v12;
              if ((*(_DWORD *)(*(void *)(v7 + 64) + 24 * v12 + 8) & 0x80000000) != 0) {
                goto LABEL_22;
              }
            }
            int v16 = v15;
LABEL_22:
            LODWORD(v9) = v16;
          }
          while (v8 != v16);
        }
      }
      int v6 = (void *)*v6;
    }
    while (v6);
  }
  std::recursive_mutex::unlock(&stru_2682A47F0);
}

void re::DebugProtocolInterconnect::sendPacket(int a1, int a2, uint64_t a3, uint64_t a4)
{
  std::recursive_mutex::lock(&stru_2682A47F0);
  uint64_t v8 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(a1);
  if (v8)
  {
    uint64_t v9 = v8[3];
    if (v9) {
      re::DebugProtocolLayer::withlock_receive(v9, a2, a3, *(void *)(a4 + 16), *(_DWORD *)(a4 + 24));
    }
  }
  std::recursive_mutex::unlock(&stru_2682A47F0);
}

intptr_t re::DebugProtocolLayer::wait(dispatch_semaphore_t *this)
{
  return dispatch_semaphore_wait(this[18], 0xFFFFFFFFFFFFFFFFLL);
}

intptr_t re::DebugProtocolLayer::wakeup(dispatch_semaphore_t *this)
{
  dispatch_semaphore_signal(this[18]);
  unint64_t v2 = this[19];
  return dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
}

uint64_t re::DebugProtocolLayer::setListener(uint64_t this, ProtocolLayerListener *a2)
{
  *(void *)(this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a2;
  return this;
}

uint64_t re::DebugProtocolLayer::localAddresses(re::DebugProtocolLayer *this, re::Address *a2, uint64_t a3)
{
  if (a3)
  {
    re::DynamicString::operator=(a2, (re::DynamicString *)&v5);
    if (v5)
    {
      if (v6) {
        (*(void (**)(void))(*(void *)v5 + 40))();
      }
    }
  }
  return 1;
}

uint64_t re::anonymous namespace'::formatAddress(re::_anonymous_namespace_ *this, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    re::DynamicString::format((re::DynamicString *)"debug://%d/%d", (re::DynamicString *)&v5, a2, a3);
    goto LABEL_5;
  }
  if (a2 != -1)
  {
    re::DynamicString::format((re::DynamicString *)"debug://%d", (re::DynamicString *)&v5, a2);
LABEL_5:
    re::DynamicString::DynamicString(this, (const re::DynamicString *)&v5);
    uint64_t result = v5;
    if (v5)
    {
      if (v6) {
        return (*(uint64_t (**)(void))(*(void *)v5 + 40))();
      }
    }
    return result;
  }
  return re::DebugProtocolLayer::broadcastAddress(this);
}

uint64_t re::DebugProtocolLayer::hostStats(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a1 + 160);
  *(void *)(a2 + 16) = *(void *)(a1 + 176);
  *(_OWORD *)a2 = v2;
  return 1;
}

void re::DebugProtocolLayer::open(re::DebugProtocolLayer *this@<X0>, const re::Address *a2@<X1>, void *a3@<X8>)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  std::recursive_mutex::lock(&stru_2682A47F0);
  uint64_t v42 = 0;
  re::DebugProtocolLayer::broadcastAddress((re::DebugProtocolLayer *)buf);
  char v7 = v46;
  char v6 = v49;
  if (v46) {
    uint64_t v8 = v49;
  }
  else {
    uint64_t v8 = (char *)&v46 + 1;
  }
  if (*((void *)a2 + 1)) {
    uint64_t v9 = (const char *)*((void *)a2 + 2);
  }
  else {
    uint64_t v9 = (char *)a2 + 9;
  }
  __int16 v10 = (re::_anonymous_namespace_ *)strcmp(v8, v9);
  int v11 = (int)v10;
  if (v7)
  {
    __int16 v10 = *(re::_anonymous_namespace_ **)buf;
    if (*(void *)buf) {
      __int16 v10 = (re::_anonymous_namespace_ *)(*(uint64_t (**)(void, const char *))(**(void **)buf + 40))(*(void *)buf, v6);
    }
  }
  if (v11)
  {
    if (*((void *)a2 + 1)) {
      uint64_t v12 = (const char *)*((void *)a2 + 2);
    }
    else {
      uint64_t v12 = (char *)a2 + 9;
    }
    __int16 v10 = (re::_anonymous_namespace_ *)sscanf(v12, "debug://%d/%d", (char *)&v42 + 4, &v42);
    if ((int)v10 < 1)
    {
      *a3 = 0;
      goto LABEL_50;
    }
  }
  else
  {
    HIDWORD(v42) = -1;
  }
  int v13 = HIDWORD(qword_2682A47E8)++;
  re::make::shared::object<re::DebugProtocolHandle>((re *)&v41);
  uint64_t v14 = v41;
  v41[442] = *((_DWORD *)this + 8);
  v14[443] = v13;
  v14[444] = HIDWORD(v42);
  v14[445] = 0;
  v14[446] = v13;
  v14[447] = 1;
  *(void *)kevent64_s buf = v14;
  int v15 = v14 + 2;
  re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::add((uint64_t)this + 48, (uint64_t *)buf);
  if (*(void *)buf) {

  }
  re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>((uint64_t)this + 96, v14 + 446, (uint64_t *)&v41);
  uint64_t v17 = *re::networkLogObjects(v16);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (v18)
  {
    int v19 = *((_DWORD *)this + 8);
    *(_DWORD *)kevent64_s buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v19;
    __int16 v46 = 1024;
    int v47 = HIDWORD(v42);
    __int16 v48 = 1024;
    LODWORD(v49) = v13;
    _os_log_impl(&dword_228C70000, v17, OS_LOG_TYPE_DEFAULT, "[DebugLayer connect] local=%d remote=%d connection=%d", buf, 0x14u);
  }
  int v20 = HIDWORD(v42);
  int v21 = *((_DWORD *)this + 8);
  std::recursive_mutex::lock(&stru_2682A47F0);
  if (v20 == -1)
  {
    addrinfo v40 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v21);
    if (v40) {
      addrinfo v40 = (uint64_t *)v40[3];
    }
    re::DebugProtocolLayer::withlock_connected((re::DebugProtocolLayer *)v40, v13);
  }
  else
  {
    unint64_t v22 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v20);
    if (v22 && (uint64_t v23 = v22[3]) != 0)
    {
      int v44 = v13;
      uint64_t v24 = *re::networkLogObjects((re *)v22);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = *(_DWORD *)(v23 + 32);
        *(_DWORD *)kevent64_s buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v25;
        __int16 v46 = 1024;
        int v47 = v21;
        __int16 v48 = 1024;
        LODWORD(v49) = v13;
        _os_log_impl(&dword_228C70000, v24, OS_LOG_TYPE_DEFAULT, "[DebugLayer accepted] local=%d remote=%d connection=%d", buf, 0x14u);
      }
      re::make::shared::object<re::DebugProtocolHandle>((re *)&v43);
      uint64_t v26 = v43;
      v43[442] = *(_DWORD *)(v23 + 32);
      v26[443] = 0;
      v26[444] = v21;
      v26[445] = v13;
      v26[446] = v13;
      v26[447] = 2;
      *(void *)kevent64_s buf = v26;
      __int16 v27 = v26 + 2;
      re::HashSetBase<re::SharedPtr<re::ProtocolHandle>,re::SharedPtr<re::ProtocolHandle>,re::internal::ValueAsKey<re::SharedPtr<re::ProtocolHandle>>,re::Hash<re::SharedPtr<re::ProtocolHandle>>,re::EqualTo<re::SharedPtr<re::ProtocolHandle>>,true,false>::add(v23 + 48, (uint64_t *)buf);
      if (*(void *)buf) {

      }
      re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::addNew<re::SharedPtr<re::TcpProtocolHandle> &>(v23 + 96, &v44, (uint64_t *)&v43);
      unint64_t v29 = *(void (****)(void, uint64_t, _DWORD *, uint8_t *))(v23 + 24);
      if (v29)
      {
        (**v29)(v29, v23, v26, buf);
        unint64_t v28 = *(re::_anonymous_namespace_ **)buf;
        if (*(void *)buf)
        {
          if (v46) {
            unint64_t v28 = (re::_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)buf + 40))();
          }
        }
      }
      std::recursive_mutex::lock(&stru_2682A47F0);
      unint64_t v30 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v21);
      if (v30)
      {
        unint64_t v31 = (re::DebugProtocolLayer *)v30[3];
        if (v31) {
          re::DebugProtocolLayer::withlock_connected(v31, v13);
        }
      }
      std::recursive_mutex::unlock(&stru_2682A47F0);
    }
    else
    {
      unint64_t v32 = std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(v21);
      if (v32)
      {
        uint64_t v33 = v32[3];
        if (v33)
        {
          double v34 = (re *)re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet(v33 + 96, v13);
          if (v34)
          {
            uint64_t v35 = *(void *)v34;
            if (*(void *)v34)
            {
              uint32_t v36 = *re::networkLogObjects(v34);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
              {
                int v37 = *(_DWORD *)(v33 + 32);
                int v38 = *(_DWORD *)(v35 + 1776);
                *(_DWORD *)kevent64_s buf = 67109632;
                *(_DWORD *)&uint8_t buf[4] = v37;
                __int16 v46 = 1024;
                int v47 = v38;
                __int16 v48 = 1024;
                LODWORD(v49) = v13;
                _os_log_impl(&dword_228C70000, v36, OS_LOG_TYPE_DEFAULT, "[DebugLayer error] local=%d remote=%d connection=%d", buf, 0x14u);
              }
              if ((*(_DWORD *)(v35 + 1788) - 1) <= 2)
              {
                uint64_t v39 = *(void *)(v33 + 24);
                if (v39) {
                  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v39 + 16))(v39, v33, v35, 2);
                }
                *(_DWORD *)(v35 + 1788) = 4;
              }
            }
          }
        }
      }
    }
  }
  std::recursive_mutex::unlock(&stru_2682A47F0);
  *a3 = v14;
LABEL_50:
  std::recursive_mutex::unlock(&stru_2682A47F0);
}

void re::DebugProtocolLayer::close(re::_anonymous_namespace_ *a1, _DWORD *a2)
{
  std::recursive_mutex::lock(&stru_2682A47F0);
  re::DebugProtocolLayer::withlock_close(a1, a2);
  std::recursive_mutex::unlock(&stru_2682A47F0);
}

void re::DebugProtocolLayer::disconnect(uint64_t a1, _DWORD *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  std::recursive_mutex::lock(&stru_2682A47F0);
  uint64_t v5 = *re::networkLogObjects(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(a1 + 32);
    int v7 = a2[444];
    int v8 = a2[446];
    LODWORD(v14) = 67109632;
    HIDWORD(v14) = v6;
    __int16 v15 = 1024;
    int v16 = v7;
    __int16 v17 = 1024;
    LODWORD(v18) = v8;
    _os_log_impl(&dword_228C70000, v5, OS_LOG_TYPE_DEFAULT, "[DebugLayer disconnect] local=%d remote=%d connection=%d", (uint8_t *)&v14, 0x14u);
  }
  if (a2[447] != 3)
  {
    uint64_t v9 = 0;
    a2[447] = 3;
    do
    {
      __int16 v10 = (re::_anonymous_namespace_ *)re::PacketQueue::dequeue((re::PacketQueue *)&a2[10 * v9 + 228]);
      if (v10)
      {
        int v11 = v10;
        do
        {
          int v12 = a2[444];
          if (v12 == -1) {
            re::DebugProtocolInterconnect::broadcastPacket(a2[442], v9, (uint64_t)v11);
          }
          else {
            re::DebugProtocolInterconnect::sendPacket(a2[444], a2[446], v9, (uint64_t)v11);
          }
          *(_DWORD *)(a1 + 172) += *((_DWORD *)v11 + 6);
          ++*(_DWORD *)(a1 + 180);
          re::PacketPool::free(*(re::PacketPool **)(a1 + 40), v11);
          __int16 v10 = (re::_anonymous_namespace_ *)re::PacketQueue::dequeue((re::PacketQueue *)&a2[10 * v9 + 228]);
          int v11 = v10;
        }
        while (v10);
      }
      ++v9;
    }
    while (v9 != 10);
    re::DebugProtocolInterconnect::sendDisconnect((re::DebugProtocolInterconnect *)a2[444], a2[446]);
    uint64_t v13 = *(void *)(a1 + 24);
    if (v13)
    {
      (*(void (**)(uint64_t, uint64_t, _DWORD *, uint64_t *))(*(void *)v13 + 8))(v13, a1, a2, &v14);
      if (v14)
      {
        if (v15) {
          (*(void (**)(void))(*(void *)v14 + 40))();
        }
      }
    }
  }
  std::recursive_mutex::unlock(&stru_2682A47F0);
}

void re::DebugProtocolLayer::withlock_connected(re::DebugProtocolLayer *this, int a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v4 = (re *)re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet((uint64_t)this + 96, a2);
  if (v4)
  {
    uint64_t v5 = *(_DWORD **)v4;
    if (*(void *)v4)
    {
      int v6 = *re::networkLogObjects(v4);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = *((_DWORD *)this + 8);
        int v8 = v5[444];
        LODWORD(v1ArcSharedObject::ArcSharedObject(this, 0) = 67109632;
        HIDWORD(v1ArcSharedObject::ArcSharedObject(this, 0) = v7;
        __int16 v11 = 1024;
        int v12 = v8;
        __int16 v13 = 1024;
        LODWORD(v14) = a2;
        _os_log_impl(&dword_228C70000, v6, OS_LOG_TYPE_DEFAULT, "[DebugLayer connected] local=%d remote=%d connection=%d", (uint8_t *)&v10, 0x14u);
      }
      if (v5[447] == 1)
      {
        v5[447] = 2;
        uint64_t v9 = (void (***)(void, re::DebugProtocolLayer *, _DWORD *, uint64_t *))*((void *)this + 3);
        if (v9)
        {
          (**v9)(v9, this, v5, &v10);
          if (v10)
          {
            if (v11) {
              (*(void (**)(void))(*(void *)v10 + 40))();
            }
          }
        }
      }
    }
  }
}

uint64_t re::DebugProtocolLayer::withlock_receive(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t result = re::HashTable<int,re::SharedPtr<re::ProtocolHandle>,re::Hash<int>,re::EqualTo<int>,true,false>::tryGet(a1 + 96, a2);
  if (result)
  {
    if (*(void *)result)
    {
      *(_DWORD *)(a1 + 168) += a5;
      ++*(_DWORD *)(a1 + 176);
      uint64_t result = *(void *)(a1 + 24);
      if (result)
      {
        int v8 = *(uint64_t (**)(void))(*(void *)result + 24);
        return v8();
      }
    }
  }
  return result;
}

uint64_t re::DebugProtocolLayer::preferredThreadMode(re::DebugProtocolLayer *this)
{
  return 2;
}

uint64_t re::DebugProtocolLayer::broadcastAddress(re::DebugProtocolLayer *this)
{
  re::DynamicString::DynamicString(this, (const re::DynamicString *)&v3);
  uint64_t result = v3;
  if (v3)
  {
    if (v4) {
      return (*(uint64_t (**)(void))(*(void *)v3 + 40))();
    }
  }
  return result;
}

uint64_t re::DebugProtocolLayer::drainsPacketSink(re::DebugProtocolLayer *this)
{
  return 1;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

uint64_t *std::__hash_table<std::__hash_value_type<int,re::DebugProtocolLayer *>,std::__unordered_map_hasher<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,re::DebugProtocolLayer *>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,re::DebugProtocolLayer *>>>::find<int>(int a1)
{
  if (!qword_2682A47C8) {
    return 0;
  }
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)qword_2682A47C8);
  v1.i16[0] = vaddlv_u8(v1);
  if (v1.u32[0] > 1uLL)
  {
    unint64_t v2 = a1;
    if (qword_2682A47C8 <= (unint64_t)a1) {
      unint64_t v2 = a1 % (unint64_t)qword_2682A47C8;
    }
  }
  else
  {
    unint64_t v2 = (qword_2682A47C8 - 1) & a1;
  }
  unint64_t i = *(uint64_t **)(qword_2682A47C0 + 8 * v2);
  if (i)
  {
    for (unint64_t i = (uint64_t *)*i; i; unint64_t i = (uint64_t *)*i)
    {
      unint64_t v4 = i[1];
      if (v4 == a1)
      {
        if (*((_DWORD *)i + 4) == a1) {
          return i;
        }
      }
      else
      {
        if (v1.u32[0] > 1uLL)
        {
          if (v4 >= qword_2682A47C8) {
            v4 %= (unint64_t)qword_2682A47C8;
          }
        }
        else
        {
          v4 &= qword_2682A47C8 - 1;
        }
        if (v4 != v2) {
          return 0;
        }
      }
    }
  }
  return i;
}

re::ProtocolHandle *re::make::shared::object<re::DebugProtocolHandle>(re *a1)
{
  unint64_t v2 = re::globalAllocators(a1);
  uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 1792, 8);
  bzero(v3, 0x700uLL);
  uint64_t result = re::ProtocolHandle::ProtocolHandle((re::ProtocolHandle *)v3);
  *uint64_t v3 = &unk_26DD36DC8;
  v3[221] = 0;
  v3[223] = 0;
  v3[222] = 0;
  *(void *)a1 = v3;
  return result;
}

void re::DebugProtocolHandle::~DebugProtocolHandle(re::DebugProtocolHandle *this)
{
  re::ProtocolHandle::~ProtocolHandle(this);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::SharedAppSyncUnpacker::unpackCommit(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(unsigned int *)(a2 + 16);
  if (*(unsigned char *)(a2 + 12)) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = *(void *)a2 + v8;
  }
  uint64_t v10 = (*(_DWORD *)(a2 + 8) - v8);
  v14[0] = v9;
  v14[1] = v10;
  int v17 = -1;
  char v18 = 0;
  uint64_t v19 = 0;
  uint64_t v21 = 0;
  uint64_t v15 = v9;
  uint64_t v16 = v9 + v10;
  uint64_t result = re::SharedAppSyncUnpacker::parseCommit((uint64_t)a1, (re::snapshot::DecoderOPACK *)v14, a3, a4);
  if (!*(unsigned char *)(a2 + 12))
  {
    int v12 = v15 - LODWORD(v14[0]);
    *(void *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
    unsigned int v13 = *(_DWORD *)(a2 + 16) + v12;
    *(void *)(a2 + 16) = v13;
    if (v13 > *(_DWORD *)(a2 + 8)) {
      *(unsigned char *)(a2 + 12) = 1;
    }
  }
  return result;
}

uint64_t re::SharedAppSyncUnpacker::parseCommit(uint64_t a1, re::snapshot::DecoderOPACK *this, uint64_t a3, uint64_t a4)
{
  uint64_t v95 = *MEMORY[0x263EF8340];
  uint64_t v8 = (re *)re::snapshot::DecoderOPACK::beginObject(this, 0);
  if ((v8 & 1) == 0)
  {
    id v71 = *re::networkLogObjects(v8);
    uint64_t result = os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)kevent64_s buf = 0;
      int v73 = "Commit doesn't begin with an object header";
      goto LABEL_105;
    }
    return result;
  }
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>((uint64_t)this, (unsigned char *)a3);
  re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned long long>((uint64_t)this, (void *)(a3 + 16));
  re::snapshot::DecoderOPACK::endObject((uint64_t *)this, 0);
  *(void *)(a3 + 8) = *(void *)(a1 + 8);
  unint64_t v78 = 0;
  uint64_t v9 = (re *)re::snapshot::DecoderOPACK::beginDictionary(this, &v78);
  if (v9)
  {
    uint64_t v77 = (_anonymous_namespace_ *)(a3 + 32);
    while (1)
    {
      while (1)
      {
        while (1)
        {
          do
          {
            if (re::snapshot::DecoderOPACK::endDictionary(this, &v78)) {
              return 2;
            }
            uint64_t Integer = re::snapshot::DecoderOPACK::readInteger(this, 0);
            if (!Integer)
            {
              uint64_t v74 = *re::networkLogObjects(0);
              uint64_t shouldAcceptUpdate = os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
              if (!shouldAcceptUpdate) {
                goto LABEL_103;
              }
              *(_WORD *)kevent64_s buf = 0;
              int v75 = "Expected valid guid";
              goto LABEL_108;
            }
            uint64_t v11 = Integer;
            uint64_t v90 = (re::SyncOpaqueTypeInfo *)-1;
            int v12 = (re *)re::snapshot::DecoderOPACK::beginObject(this, 0);
            if ((v12 & 1) == 0)
            {
              uint64_t v74 = *re::networkLogObjects(v12);
              uint64_t shouldAcceptUpdate = os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
              if (!shouldAcceptUpdate) {
                goto LABEL_103;
              }
              *(_WORD *)kevent64_s buf = 0;
              int v75 = "Expected object header";
              goto LABEL_108;
            }
            char v89 = 0;
            re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,unsigned char>((uint64_t)this, &v89);
            unsigned __int16 v88 = 0;
            re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<2,unsigned short>((uint64_t)this, &v88);
            *(void *)&long long v85 = 0;
            WORD4(v85) = 0;
            LOBYTE(v86[0]) = 0;
            v86[1] = 0;
            *(_DWORD *)unint64_t v87 = 0x10000;
            re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<3,re::SyncOwnershipInfo>((uint64_t)this, (uint64_t)&v85);
            unint64_t v13 = v86[1];
            if (!v86[1])
            {
              unint64_t v13 = *(void *)(a1 + 8);
              v86[1] = v13;
            }
            if (v13 == *(void *)(a1 + 16))
            {
              BOOL v14 = 1;
            }
            else if (*(unsigned char *)(a1 + 72))
            {
              BOOL v14 = v13 == *(void *)(a4 + 8);
            }
            else
            {
              BOOL v14 = 0;
            }
            LOBYTE(v87[1]) = v14;
            char v15 = v89;
            re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<6,unsigned long long>((uint64_t)this, &v90);
            long long v84 = 0xFFFFFFFFFFFFFFFFLL;
            if (v15)
            {
              re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<8,unsigned long long>((uint64_t)this, &v84);
              re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<9,unsigned long long>((uint64_t)this, (void *)&v84 + 1);
            }
            uint64_t v82 = 0;
            uint64_t v83 = 0;
            uint64_t v16 = (re *)re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<11,re::Slice<unsigned char>>((uint64_t)this, &v82);
            if (*((void *)this + 3) == *((void *)this + 2))
            {
              uint64_t v74 = *re::networkLogObjects(v16);
              uint64_t shouldAcceptUpdate = os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
              if (!shouldAcceptUpdate) {
                goto LABEL_103;
              }
              *(_WORD *)kevent64_s buf = 0;
              int v75 = "Failed to unpack sync object.";
LABEL_108:
              _os_log_error_impl(&dword_228C70000, v74, OS_LOG_TYPE_ERROR, v75, buf, 2u);
LABEL_103:
              id v71 = *re::networkLogObjects((re *)shouldAcceptUpdate);
              uint64_t result = os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
              if (result)
              {
                *(_WORD *)kevent64_s buf = 0;
                int v73 = "Failure reading object in commit";
LABEL_105:
                _os_log_error_impl(&dword_228C70000, v71, OS_LOG_TYPE_ERROR, v73, buf, 2u);
                return 0;
              }
              return result;
            }
            re::snapshot::DecoderOPACK::endObject((uint64_t *)this, 0);
            int v17 = *(re::SyncObjectStore **)a1;
            *(void *)kevent64_s buf = v90;
            char v18 = (re *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)v17 + 504, (uint64_t *)buf);
            if (!v18 || (uint64_t v19 = *(void *)(*(void *)v18 + 16)) == 0)
            {
              int v20 = *re::networkLogObjects(v18);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)kevent64_s buf = 134217984;
                *(void *)&uint8_t buf[4] = v90;
                _os_log_impl(&dword_228C70000, v20, OS_LOG_TYPE_DEFAULT, "Unknown object typeID=%llu. Assuming opaque type.", buf, 0xCu);
              }
              uint64_t v21 = *(re::SyncObjectStore **)a1;
              re::SyncOpaqueTypeInfo::make(v90, (uint64_t)buf);
              re::SyncObjectStore::addType(v21, (const re::SyncObjectTypeInfo *)buf);
              re::SyncObjectTypeInfo::~SyncObjectTypeInfo((re::SyncObjectTypeInfo *)buf);
              unint64_t v22 = *(re::SyncObjectStore **)a1;
              *(void *)kevent64_s buf = v90;
              uint64_t v23 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)v22 + 504, (uint64_t *)buf);
              if (v23) {
                uint64_t v19 = *(void *)(*(void *)v23 + 16);
              }
              else {
                uint64_t v19 = 0;
              }
            }
            uint64_t v24 = *(void *)(v19 + 136);
          }
          while (v24 && !(*(unsigned int (**)(uint64_t, uint64_t))(v24 + 16))(v24, a4));
          uint64_t Object = re::SyncObjectStore::findObject(*(re::SyncObjectStore **)a1, (uint64_t)v90, v11, (re::SyncObjectTypedStore ***)&v81);
          uint64_t v26 = v81;
          __int16 v27 = v81;
          if (!v81) {
            break;
          }
LABEL_27:
          uint64_t shouldAcceptUpdate = re::SyncObject::shouldAcceptUpdate(v27, v86[1], v87[0]);
          if (*(unsigned char *)(a1 + 73) || shouldAcceptUpdate)
          {
            if (shouldAcceptUpdate
              && (uint64_t v34 = *(void *)(a1 + 16),
                  unsigned int v35 = *((unsigned __int16 *)v27 + 84),
                  long long v36 = *(_OWORD *)v86,
                  *(_OWORD *)((char *)v27 + 136) = v85,
                  *(_OWORD *)((char *)v27 + 152) = v36,
                  *((_DWORD *)v27 + 42) = *(_DWORD *)v87,
                  *(unsigned char *)(*(void *)(*((void *)v27 + 11) + 16) + 73))
              && (v35 < v87[0] || ((void)v85 == v34 ? (BOOL v37 = (void)v85 == 0) : (BOOL v37 = 1), !v37)))
            {
              char v38 = 4;
            }
            else
            {
              char v38 = 0;
            }
            BOOL isStateDataChanged = re::SyncObject::isStateDataChanged(v27, v88, *(void *)(a1 + 8));
            if (isStateDataChanged)
            {
              unsigned __int16 v40 = v88;
              char v76 = v38;
              uint64_t v41 = v82;
              uint64_t v42 = a4;
              uint64_t v43 = v83;
              int v44 = (re::BitWriter *)re::SyncObject::addState(v27, v88, *(void *)(a1 + 8));
              *((_WORD *)v27 + 88) = v40;
              uint64_t v45 = (const void *)v41;
              char v38 = v76;
              uint64_t v46 = v43;
              a4 = v42;
              re::BitWriter::writeData(v44, v45, v46);
            }
            unint64_t v47 = re::SyncObject::latestStateHandle(v27);
            if (v47 == -1)
            {
              unsigned int v55 = *re::networkLogObjects((re *)0xFFFFFFFFFFFFFFFFLL);
              uint64_t shouldAcceptUpdate = os_log_type_enabled(v55, OS_LOG_TYPE_ERROR);
              if (shouldAcceptUpdate)
              {
                uint64_t v65 = *((void *)v27 + 3);
                uint64_t v66 = *(void **)(*((void *)v27 + 11) + 16);
                uint64_t v67 = v66[4];
                uint64_t v68 = v66[6];
                char v69 = (re::SyncOpaqueTypeInfo *)v66[7];
                uint64_t v70 = (re::SyncOpaqueTypeInfo *)((char *)v66 + 49);
                if (v68) {
                  uint64_t v70 = v69;
                }
                *(_DWORD *)kevent64_s buf = 134218498;
                *(void *)&uint8_t buf[4] = v65;
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v67;
                *(_WORD *)&unsigned char buf[22] = 2080;
                uint64_t v92 = v70;
                _os_log_error_impl(&dword_228C70000, v55, OS_LOG_TYPE_ERROR, "Sync object without snapshot while parsing object (id: %llu, type: %llu[%s]).", buf, 0x20u);
                int v29 = 0;
LABEL_82:

                goto LABEL_83;
              }
              int v29 = 0;
            }
            else
            {
              unint64_t v48 = v47;
              BOOL v49 = v26 == 0;
              memset(buf, 0, 17);
              re::SharedPtr<re::SyncObject>::reset((uint64_t *)buf, (uint64_t)v27);
              *(void *)&uint8_t buf[8] = v48;
              if (isStateDataChanged) {
                char v50 = 8;
              }
              else {
                char v50 = 0;
              }
              char v51 = v38 | v49 | v50 | buf[16] & 0xF2;
              uint8_t buf[16] = v51;
              if ((v15 & 4) != 0)
              {
                *((unsigned char *)v27 + 128) |= 4u;
                uint8_t buf[16] = v51 | 2;
              }
              uint64_t shouldAcceptUpdate = (uint64_t)re::DynamicArray<re::internal::SyncSnapshotEntry>::add(v77, (uint64_t)buf);
              if (*((void *)&v84 + 1) && !*((void *)v27 + 10))
              {
                re::SyncObjectStore::findObject(*(re::SyncObjectStore **)a1, (uint64_t)v90, *((uint64_t *)&v84 + 1), (re::SyncObjectTypedStore ***)&v80);
                uint64_t v52 = v80;
                if (v80)
                {
                  re::SyncObject::bindWithParent(v27, v80);
                }
                else
                {
                  long long v79 = v84;
                  uint64_t shouldAcceptUpdate = re::HashTable<re::SharedPtr<re::SyncObject>,re::Pair<unsigned long long,unsigned long long,true>,re::Hash<re::SharedPtr<re::SyncObject>>,re::EqualTo<re::SharedPtr<re::SyncObject>>,true,false>::addOrReplace(a1 + 24, (uint64_t *)&v81, &v79);
                }
              }
              if (*(void *)buf) {

              }
              int v29 = 2;
              __int16 v27 = v81;
            }
          }
          else
          {
            int v29 = 2;
          }
          if (v27) {
            goto LABEL_82;
          }
LABEL_83:
          if (!v29) {
            goto LABEL_103;
          }
        }
        if ((v15 & 4) != 0) {
          break;
        }
        unint64_t v30 = *(re::SyncObjectStore **)a1;
        *(void *)kevent64_s buf = v11;
        *(void *)&uint8_t buf[8] = v90;
        *(void *)&uint8_t buf[16] = 0;
        BOOL v31 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)v30 + 600, (uint64_t *)buf);
        if (v31)
        {
          unint64_t v32 = *re::networkLogObjects((re *)v31);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            if (*(unsigned char *)(v19 + 48)) {
              uint64_t v33 = *(void *)(v19 + 56);
            }
            else {
              uint64_t v33 = v19 + 49;
            }
            *(_DWORD *)kevent64_s buf = 134218498;
            *(void *)&uint8_t buf[4] = v11;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v33;
            *(_WORD *)&unsigned char buf[22] = 2048;
            uint64_t v92 = v90;
            unint64_t v60 = v32;
            uint64_t v61 = "Discarding incoming object already tombstoned, guid=%llu, type=%s(%llu)";
LABEL_73:
            uint32_t v64 = 32;
            goto LABEL_74;
          }
        }
        else
        {
          uint64_t v56 = *(re::SyncObjectStore **)a1;
          *(void *)kevent64_s buf = *((void *)&v84 + 1);
          *(void *)&uint8_t buf[8] = v84;
          *(void *)&uint8_t buf[16] = 0;
          BOOL v57 = re::HashSetBase<re::SyncObjectTombstone,re::SyncObjectTombstone,re::internal::ValueAsKey<re::SyncObjectTombstone>,re::Hash<re::SyncObjectTombstone>,re::EqualTo<re::SyncObjectTombstone>,true,false>::containsKey((uint64_t)v56 + 600, (uint64_t *)buf);
          if (v57)
          {
            uint64_t v58 = *re::networkLogObjects((re *)v57);
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
            {
              if (*(unsigned char *)(v19 + 48)) {
                uint64_t v59 = *(void *)(v19 + 56);
              }
              else {
                uint64_t v59 = v19 + 49;
              }
              *(_DWORD *)kevent64_s buf = 134218754;
              *(void *)&uint8_t buf[4] = v11;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v59;
              *(_WORD *)&unsigned char buf[22] = 2048;
              uint64_t v92 = v90;
              __int16 v93 = 2048;
              uint64_t v94 = *((void *)&v84 + 1);
              unint64_t v60 = v58;
              uint64_t v61 = "Discarding incoming object with parent already tombstoned, guid=%llu, type=%s(%llu), parentGuid=%llu";
              uint32_t v64 = 42;
LABEL_74:
              _os_log_impl(&dword_228C70000, v60, OS_LOG_TYPE_DEFAULT, v61, buf, v64);
            }
          }
          else
          {
            if (v15)
            {
              re::SyncObjectStore::createIncomingObject(*(re::SyncObjectStore **)a1, (const re::SyncOwnershipInfo *)&v85, (unint64_t)v90, v11, (uint64_t *)buf);
              __int16 v27 = *(re::SyncObject **)buf;
              uint64_t v81 = *(re::SyncObject **)buf;
              goto LABEL_27;
            }
            uint64_t v62 = *re::networkLogObjects((re *)v57);
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
            {
              if (*(unsigned char *)(v19 + 48)) {
                uint64_t v63 = *(void *)(v19 + 56);
              }
              else {
                uint64_t v63 = v19 + 49;
              }
              *(_DWORD *)kevent64_s buf = 134218498;
              *(void *)&uint8_t buf[4] = v11;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v63;
              *(_WORD *)&unsigned char buf[22] = 2048;
              uint64_t v92 = v90;
              _os_log_impl(&dword_228C70000, v62, OS_LOG_TYPE_DEFAULT, "Got object delta update but missing object for it.(guid=%llu, type=%s(%llu))", buf, 0x20u);
            }
          }
        }
      }
      uint32_t v53 = *re::networkLogObjects((re *)Object);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(v19 + 48)) {
          uint64_t v54 = *(void *)(v19 + 56);
        }
        else {
          uint64_t v54 = v19 + 49;
        }
        *(_DWORD *)kevent64_s buf = 134218498;
        *(void *)&uint8_t buf[4] = v11;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v54;
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v92 = v90;
        unint64_t v60 = v53;
        uint64_t v61 = "Discarding incoming object already in destroyed state, guid=%llu, type=%s(%llu)";
        goto LABEL_73;
      }
    }
  }
  id v71 = *re::networkLogObjects(v9);
  uint64_t result = os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)kevent64_s buf = 0;
    int v73 = "Expected dictionary of entries";
    goto LABEL_105;
  }
  return result;
}

double RESyncServiceObserverCreate(re *a1)
{
  uint8x8_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 80, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)uint64_t v2 = &unk_26DD36E10;
  double result = 0.0;
  *(_OWORD *)(v2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0u;
  *(_OWORD *)(v2 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(void *)(v2 + 72) = 0;
  return result;
}

double RESyncServiceAddObserver(_DWORD *a1, uint64_t a2, double result)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (a1 && a2)
  {
    uint64_t v5 = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)a1 + 32))(a1);
    uint64_t v18 = a2;
    *(void *)&long long v19 = re::ServiceObserverProxy::didAdd;
    *((void *)&v19 + 1) = 0;
    *(void *)&long long v20 = re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke;
    double v6 = re::Event<re::Session>::addSubscription(v5, (uint64_t)&v18);
    int v7 = (_DWORD *)(*(uint64_t (**)(_DWORD *, double))(*(void *)a1 + 40))(a1, v6);
    uint64_t v18 = a2;
    *(void *)&long long v19 = re::ServiceObserverProxy::willRemove;
    *((void *)&v19 + 1) = 0;
    *(void *)&long long v20 = re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke;
    double v8 = re::Event<re::Session>::addSubscription(v7, (uint64_t)&v18);
    uint64_t v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(_DWORD *, double))(*(void *)a1 + 48))(a1, v8);
    *(void *)&long long v16 = a2;
    *((void *)&v16 + 1) = re::ServiceObserverProxy::didReceiveOwnershipRequest;
    *(void *)&long long v17 = 0;
    *((void *)&v17 + 1) = re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&,void const*&&,unsigned long &&,BOOL &)#1}::__invoke;
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v9, &v16, (uint64_t)&v18);
    if (!(_BYTE)v18)
    {
      if (*((_DWORD *)v9 + 20))
      {
        LOBYTE(v18) = 1;
        long long v19 = v16;
        long long v20 = v17;
        __n128 v10 = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)v9 + 40, (uint64_t)&v18);
      }
      else
      {
        __n128 v10 = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v9, (uint64_t)&v16);
      }
    }
    uint64_t v11 = (_anonymous_namespace_ *)(*(uint64_t (**)(_DWORD *, __n128))(*(void *)a1 + 56))(a1, v10);
    *(void *)&long long v16 = a2;
    *((void *)&v16 + 1) = re::ServiceObserverProxy::didReceiveOwnershipResponse;
    *(void *)&long long v17 = 0;
    *((void *)&v17 + 1) = re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&,re::OwnershipResponseResult&&)#1}::__invoke;
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v11, &v16, (uint64_t)&v18);
    if (!(_BYTE)v18)
    {
      if (*((_DWORD *)v11 + 20))
      {
        LOBYTE(v18) = 1;
        long long v19 = v16;
        long long v20 = v17;
        __n128 v12 = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)v11 + 40, (uint64_t)&v18);
      }
      else
      {
        __n128 v12 = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v11, (uint64_t)&v16);
      }
    }
    unint64_t v13 = (_anonymous_namespace_ *)(*(uint64_t (**)(_DWORD *, __n128))(*(void *)a1 + 64))(a1, v12);
    uint64_t v18 = a2;
    *(void *)&long long v19 = re::ServiceObserverProxy::didReceiveOwnershipHandoff;
    *((void *)&v19 + 1) = 0;
    *(void *)&long long v20 = re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&)#1}::__invoke;
    double v14 = re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::addSubscription(v13, (uint64_t)&v18);
    char v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(_DWORD *, double))(*(void *)a1 + 72))(a1, v14);
    uint64_t v18 = a2;
    *(void *)&long long v19 = re::ServiceObserverProxy::didReceiveOwnershipChange;
    *((void *)&v19 + 1) = 0;
    *(void *)&long long v20 = re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&)#1}::__invoke;
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::addSubscription(v15, (uint64_t)&v18);
    *(void *)&long long v16 = a2;
    *((void *)&v16 + 1) = re::ServiceObserverProxy::dataDidArrive;
    *(void *)&long long v17 = 0;
    *((void *)&v17 + 1) = re::Event<re::NetworkSyncService>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService>::Subscription const&)#1}::__invoke;
    re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)(a1 + 84), &v16, (uint64_t)&v18);
    if (!(_BYTE)v18)
    {
      if (a1[104])
      {
        LOBYTE(v18) = 1;
        long long v19 = v16;
        long long v20 = v17;
        *(void *)&double result = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)(a1 + 94), (uint64_t)&v18).n128_u64[0];
      }
      else
      {
        *(void *)&double result = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)(a1 + 84), (uint64_t)&v16).n128_u64[0];
      }
    }
  }
  return result;
}

uint64_t re::ServiceObserverProxy::didAdd(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    (*(void (**)(uint64_t, void))(v3 + 16))(v3, *a3);
  }
  return 0;
}

uint64_t re::ServiceObserverProxy::willRemove(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    (*(void (**)(uint64_t, void))(v3 + 16))(v3, *a3);
  }
  return 0;
}

uint64_t re::ServiceObserverProxy::didReceiveOwnershipRequest(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3) {
    (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, a2, *a3);
  }
  return 0;
}

uint64_t re::ServiceObserverProxy::didReceiveOwnershipResponse(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3) {
    (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, a2, *a3);
  }
  return 0;
}

uint64_t re::ServiceObserverProxy::didReceiveOwnershipHandoff(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3) {
    (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, a2, *a3);
  }
  return 0;
}

uint64_t re::ServiceObserverProxy::didReceiveOwnershipChange(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3) {
    (*(void (**)(uint64_t, uint64_t, void))(v3 + 16))(v3, a2, *a3);
  }
  return 0;
}

uint64_t re::ServiceObserverProxy::dataDidArrive(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (v1) {
    (*(void (**)(void))(v1 + 16))();
  }
  return 0;
}

void RESyncServiceRemoveObserver(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (a1 && a2)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v4, a2);
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v5, a2);
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(v6, a2);
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::unsubscribe<re::Session>(v7, a2);
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
    if (*(void *)(v8 + 16))
    {
      uint64_t v9 = v8;
      unint64_t v10 = 0;
      uint64_t v11 = v8 + 40;
      do
      {
        __n128 v12 = (long long *)(*(void *)(v9 + 32) + 32 * v10);
        if (*(void *)v12 == a2)
        {
          if (!*(_DWORD *)(v9 + 80))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)v9, v10);
            continue;
          }
          v23[0] = 0;
          long long v13 = v12[1];
          long long v24 = *v12;
          long long v25 = v13;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v11, (uint64_t)v23);
        }
        ++v10;
      }
      while (v10 < *(void *)(v9 + 16));
    }
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
    if (*(void *)(v14 + 16))
    {
      uint64_t v15 = v14;
      unint64_t v16 = 0;
      uint64_t v17 = v14 + 40;
      do
      {
        uint64_t v18 = (long long *)(*(void *)(v15 + 32) + 32 * v16);
        if (*(void *)v18 == a2)
        {
          if (!*(_DWORD *)(v15 + 80))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)v15, v16);
            continue;
          }
          v23[0] = 0;
          long long v19 = v18[1];
          long long v24 = *v18;
          long long v25 = v19;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v17, (uint64_t)v23);
        }
        ++v16;
      }
      while (v16 < *(void *)(v15 + 16));
    }
    if (*(void *)(a1 + 352))
    {
      unint64_t v20 = 0;
      do
      {
        uint64_t v21 = (long long *)(*(void *)(a1 + 368) + 32 * v20);
        if (*(void *)v21 == a2)
        {
          if (!*(_DWORD *)(a1 + 416))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)(a1 + 336), v20);
            continue;
          }
          v23[0] = 0;
          long long v22 = v21[1];
          long long v24 = *v21;
          long long v25 = v22;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(a1 + 376, (uint64_t)v23);
        }
        ++v20;
      }
      while (v20 < *(void *)(a1 + 352));
    }
  }
}

void *RESyncServiceObserverOnSessionDidAdd(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = result;
  return result;
}

void *RESyncServiceObserverOnSessionWillRemove(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 32);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 32) = result;
  return result;
}

void *RESyncServiceObserverOnSessionDidReceiveOwnershipRequest(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = result;
  return result;
}

void *RESyncServiceObserverOnSessionDidReceiveOwnershipResponse(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 48) = result;
  return result;
}

void RESyncServiceObserverOnSessionDidReceiveOwnershipHandoff(re *a1, const void *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    uint64_t v7 = "RESyncServiceObserverOnSessionDidReceiveOwnershipHandoff";
    __int16 v8 = 2080;
    uint64_t v9 = "observer != __null";
    goto LABEL_10;
  }
  if (!a2)
  {
    uint64_t v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    uint64_t v7 = "RESyncServiceObserverOnSessionDidReceiveOwnershipHandoff";
    __int16 v8 = 2080;
    uint64_t v9 = "sessionDidReceiveOwnershipHandoff != __null";
LABEL_10:
    _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return;
  }
  uint64_t v4 = (const void *)*((void *)a1 + 7);
  if (v4 != a2)
  {
    _Block_release(v4);
    *((void *)a1 + 7) = _Block_copy(a2);
  }
}

void RESyncServiceObserverOnSessionDidReceiveOwnershipChange(re *a1, const void *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    uint64_t v7 = "RESyncServiceObserverOnSessionDidReceiveOwnershipChange";
    __int16 v8 = 2080;
    uint64_t v9 = "observer != __null";
    goto LABEL_10;
  }
  if (!a2)
  {
    uint64_t v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v6 = 136315394;
    uint64_t v7 = "RESyncServiceObserverOnSessionDidReceiveOwnershipChange";
    __int16 v8 = 2080;
    uint64_t v9 = "sessionDidReceiveOwnershipChange != __null";
LABEL_10:
    _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", (uint8_t *)&v6, 0x16u);
    return;
  }
  uint64_t v4 = (const void *)*((void *)a1 + 8);
  if (v4 != a2)
  {
    _Block_release(v4);
    *((void *)a1 + 8) = _Block_copy(a2);
  }
}

void *RESyncServiceObserverOnDataArrive(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 72);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + 72) = result;
  return result;
}

void RESyncTransferReportObserverCreate(re *a1)
{
  uint64_t v1 = re::globalAllocators(a1);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[2] + 32))(v1[2], 32, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)(v2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(void *)uint64_t v2 = &unk_26DD36E58;
}

double RESyncServiceAddTransferReportObserver(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      uint64_t v3 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 80))(a1);
      *(void *)&long long v5 = a2;
      *((void *)&v5 + 1) = re::TransferReportObserverProxy::onTransferReportSend;
      *(void *)&long long v6 = 0;
      *((void *)&v6 + 1) = re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::createSubscription<re::TransferReportObserverProxy>(re::TransferReportObserverProxy *,REEventHandlerResult (re::TransferReportObserverProxy::*)(re::NetworkSyncService*,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::Subscription const&,re::Session *&&,unsigned long long &&,re::Session *&&,re::Session *&&,re::Session *&&,unsigned int &&)#1}::__invoke;
      re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v3, &v5, (uint64_t)v7);
      if (!v7[0])
      {
        if (*((_DWORD *)v3 + 20))
        {
          v7[0] = 1;
          long long v8 = v5;
          long long v9 = v6;
          *(void *)&double result = re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add((uint64_t)v3 + 40, (uint64_t)v7).n128_u64[0];
        }
        else
        {
          *(void *)&double result = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v3, (uint64_t)&v5).n128_u64[0];
        }
      }
    }
  }
  return result;
}

uint64_t re::TransferReportObserverProxy::onTransferReportSend(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    (*(void (**)(void))(v1 + 16))();
  }
  return 0;
}

void RESyncServiceRemoveTransferReportObserver(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (a1 && a2)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 80))(a1);
    if (*(void *)(v3 + 16))
    {
      uint64_t v4 = v3;
      unint64_t v5 = 0;
      uint64_t v6 = v3 + 40;
      do
      {
        uint64_t v7 = (long long *)(*(void *)(v4 + 32) + 32 * v5);
        if (*(void *)v7 == a2)
        {
          if (!*(_DWORD *)(v4 + 80))
          {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt((void *)v4, v5);
            continue;
          }
          v10[0] = 0;
          long long v8 = v7[1];
          long long v11 = *v7;
          long long v12 = v8;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::Subscription,true>>::add(v6, (uint64_t)v10);
        }
        ++v5;
      }
      while (v5 < *(void *)(v4 + 16));
    }
    long long v9 = *(const void **)(a2 + 24);
    if (v9)
    {
      _Block_release(v9);
      *(void *)(a2 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
    }
  }
}

void *RESyncTransferReportObserverOnTransferReportSend(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4) {
    _Block_release(v4);
  }
  double result = _Block_copy(aBlock);
  *(void *)(a1 + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = result;
  return result;
}

uint64_t RESyncServiceStartSyncWithSession(re *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v6 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)kevent64_s buf = 136315394;
    long long v9 = "RESyncServiceStartSyncWithSession";
    __int16 v10 = 2080;
    long long v11 = "service != __null";
LABEL_11:
    _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return 0;
  }
  if (!a2)
  {
    uint64_t v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)kevent64_s buf = 136315394;
    long long v9 = "RESyncServiceStartSyncWithSession";
    __int16 v10 = 2080;
    long long v11 = "session != __null";
    goto LABEL_11;
  }
  uint64_t v7 = a2;
  id v3 = (id)(a2 + 8);
  uint64_t v4 = (*(uint64_t (**)(re *, uint64_t *))(*(void *)a1 + 88))(a1, &v7);
  if (v7) {

  }
  return v4;
}

uint64_t RESyncServiceCreateSessionAndStartSync(re *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    unint64_t v5 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)uint64_t v6 = 136315394;
    *(void *)&v6[4] = "RESyncServiceCreateSessionAndStartSync";
    __int16 v7 = 2080;
    long long v8 = "service != nullptr";
LABEL_11:
    _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", v6, 0x16u);
    return 0;
  }
  if (!a2)
  {
    unint64_t v5 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)uint64_t v6 = 136315394;
    *(void *)&v6[4] = "RESyncServiceCreateSessionAndStartSync";
    __int16 v7 = 2080;
    long long v8 = "configuration != nullptr";
    goto LABEL_11;
  }
  (*(void (**)(unsigned char *__return_ptr))(*(void *)a1 + 104))(v6);
  uint64_t v2 = *(void *)v6;
  id v3 = (id)(*(void *)v6 + 8);
  if (*(void *)v6) {

  }
  return v2;
}

uint64_t RESyncServiceCreateSyncSession(re *a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v13 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)kevent64_s buf = 136315394;
    *(void *)&uint8_t buf[4] = "RESyncServiceCreateSyncSession";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "service != __null";
LABEL_20:
    _os_log_error_impl(&dword_228C70000, v13, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return 0;
  }
  if (!a2)
  {
    uint64_t v13 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)kevent64_s buf = 136315394;
    *(void *)&uint8_t buf[4] = "RESyncServiceCreateSyncSession";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "session != __null";
    goto LABEL_20;
  }
  uint64_t v4 = (void *)(a2 + 8);
  id v5 = (id)(a2 + 8);
  *(_OWORD *)kevent64_s buf = xmmword_228CDF5E0;
  *(void *)&uint8_t buf[16] = 0xFFFFFFFF00010000;
  char v16 = 0;
  uint64_t v17 = a2;
  id v6 = v4;
  uint64_t v7 = (*(uint64_t (**)(re *))(*(void *)a1 + 152))(a1);
  uint64_t v18 = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  uint64_t v9 = (*(uint64_t (**)(re *))(*(void *)a1 + 160))(a1);
  uint64_t v19 = v9;
  if (v9) {
    id v10 = (id)(v9 + 8);
  }
  unint64_t v20 = a1;
  char v21 = *(unsigned char *)(a2 + 2223);
  int v22 = *(_DWORD *)(a2 + 2224);
  char v23 = *(unsigned char *)(a2 + 2237);
  re::make::shared::object<re::SyncObjectManager,re::SyncObjectManager::Config &>((re *)buf, &v14);
  uint64_t v11 = v14;
  if (v19)
  {

    uint64_t v19 = 0;
  }
  if (v18)
  {

    uint64_t v18 = 0;
  }
  if (v17) {

  }
  return v11;
}

uint64_t RESyncServiceStartSync(re *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    id v6 = *re::networkLogObjects(0);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)kevent64_s buf = 136315394;
    uint64_t v9 = "RESyncServiceStartSync";
    __int16 v10 = 2080;
    uint64_t v11 = "service != __null";
LABEL_11:
    _os_log_error_impl(&dword_228C70000, v6, OS_LOG_TYPE_ERROR, "%s: Invalid parameter not satisfying %s.", buf, 0x16u);
    return 0;
  }
  if (!a2)
  {
    id v6 = *re::networkLogObjects(a1);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)kevent64_s buf = 136315394;
    uint64_t v9 = "RESyncServiceStartSync";
    __int16 v10 = 2080;
    uint64_t v11 = "session != __null";
    goto LABEL_11;
  }
  uint64_t v7 = a2;
  id v3 = (id)(a2 + 8);
  uint64_t v4 = (*(uint64_t (**)(re *, uint64_t *))(*(void *)a1 + 96))(a1, &v7);
  if (v7) {

  }
  return v4;
}

void RESyncServiceStopSyncWithSession(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (a2) {
    id v3 = (id)(a2 + 8);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 112))(a1, &v4);
  if (v4) {
}
  }

uint64_t RESyncServiceStopSync(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 120))();
}

uint64_t RESyncServiceGetSyncSession(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 128))(a1);
    if (v5)
    {
      uint64_t v6 = v5;
      unint64_t v7 = 0;
      while (1)
      {
        uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 128))(a1);
        if (v9 <= v7)
        {
          re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size_t size = %zu", "index < size()", "operator[]", 251, v7, v9);
          _os_crash();
          __break(1u);
          goto LABEL_15;
        }
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(v8 + 8 * v7) + 32))(&v13);
        uint64_t v10 = v13;
        if (v13) {

        }
        if (v10 == a2) {
          break;
        }
        if (v6 == ++v7) {
          return 0;
        }
      }
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 128))(a1);
      if (v12 > v7) {
        return *(void *)(v11 + 8 * v7);
      }
LABEL_15:
      re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size_t size = %zu", "index < size()", "operator[]", 251, v7, v12);
      uint64_t result = _os_crash();
      __break(1u);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *RESyncServiceConfigCreateNoAlloc(void *a1, unint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && a2 >= 0x18)
  {
    *a1 = 0;
    a1[1] = 0;
    uint64_t v2 = a1;
    a1[2] = 0;
  }
  return v2;
}

void *RESyncServiceConfigCreateDefaultNoAlloc(void *a1, unint64_t a2)
{
  uint64_t result = 0;
  if (a1 && a2 >= 0x18)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    re::make::shared::object<re::SyncObjectStore>((re *)&v5);
    uint64_t v4 = v5;
    if (!v5) {
      return 0;
    }
    re::SharedPtr<re::SyncObject>::reset(a1 + 1, v5);

    return a1;
  }
  return result;
}

void RESyncServiceConfigDestruct(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {

      *(void *)(a1 + 8) = 0;
    }
  }
}

uint64_t RESyncServiceConfigGetSize()
{
  return 24;
}

void *RESyncServiceConfigSetSchemaHash(void *result, uint64_t a2)
{
  if (result) {
    *uint64_t result = a2;
  }
  return result;
}

uint64_t RESyncServiceConfigSetDispatchQueue(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2) {
      *(void *)(result + 16) = a2;
    }
  }
  return result;
}

uint64_t RESyncCreateSyncService(uint64_t *a1)
{
  re::make::shared::object<re::NetworkSyncManager>((re *)&v4);
  uint64_t v2 = v4;
  if (a1 && v4)
  {
    re::NetworkSyncManager::init(v4, a1);
  }
  else if (v4)
  {

    return 0;
  }
  return v2;
}

uint64_t RESyncServiceRemoveSyncable(uint64_t a1, void *a2)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 152))(a1);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v8 = a2;
      unint64_t v7 = a2 + 1;
      re::SyncObjectStore::removeObject(v6, (uint64_t *)&v8);

      re::SyncObject::unbindFromParent(a2);
      return 0;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t RESyncServiceCreateWithDefaultConfig()
{
  re::make::shared::object<re::NetworkSyncManager>((re *)&v7);
  uint64_t v0 = v7;
  if (v7)
  {
    re::make::shared::object<re::SyncObjectStore>((re *)&v6);
    uint64_t v1 = v6;
    if (v6)
    {
      uint64_t v4 = 0;
      v5[0] = 0;
      v5[1] = MEMORY[0x263EF83A0];
      re::SharedPtr<re::SyncObject>::reset(v5, v6);
      re::NetworkSyncManager::init(v0, &v4);
      if (v5[0]) {
    }
      }
    else
    {
      uint64_t v2 = (void *)(v0 + 8);

      return 0;
    }
  }
  return v0;
}

uint64_t RESyncServiceRegisterTypeInfo(uint64_t a1, re::SyncObjectTypeInfo *a2)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 152))(a1);
    if (v5)
    {
      uint64_t v6 = (re::SyncObjectStore *)v5;
      uint64_t v8 = *((void *)a2 + 4);
      uint64_t v7 = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v5 + 504, &v8);
      if (v7 && *(void *)(*(void *)v7 + 16))
      {
        return 3;
      }
      else
      {
        re::SyncObjectStore::addType(v6, a2);
        return 0;
      }
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t RESyncServiceGetTypeInfo(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
    uint64_t v4 = a2;
    uint64_t result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v3 + 504, &v4);
    if (result)
    {
      if (*(void *)result) {
        return *(void *)(*(void *)result + 16);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t RESyncServiceGetSessionCount(uint64_t result)
{
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 128))(result);
    return v1;
  }
  return result;
}

uint64_t RESyncServiceGetSession(uint64_t result, unint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    (*(void (**)(uint64_t))(*(void *)result + 128))(result);
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 128))(v3);
    if (v5 <= a2)
    {
      re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size_t size = %zu", "index < size()", "operator[]", 251, a2, v5);
      uint64_t result = _os_crash();
      __break(1u);
    }
    else
    {
      return *(void *)(v4 + 8 * a2);
    }
  }
  return result;
}

uint64_t RESyncServiceCreateSyncableWithTypeInfo(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2 || !(*(uint64_t (**)(uint64_t))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  unint64_t v4 = *(void *)(a2 + 32);
  return RESyncServiceCreateSyncableWithTypeId(a1, v4);
}

uint64_t RESyncServiceCreateSyncableWithTypeId(uint64_t result, unint64_t a2)
{
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
    if (result)
    {
      uint64_t v3 = (re::SyncObjectStore *)result;
      unint64_t v4 = a2;
      uint64_t result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(result + 504, (uint64_t *)&v4);
      if (result)
      {
        if (*(void *)(*(void *)result + 16))
        {
          re::SyncObjectStore::create(v3, a2, (uint64_t *)&v4);
          return v4;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t RESyncServiceCreateIncomingSyncable(uint64_t result, unint64_t a2, uint64_t a3)
{
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
    if (result)
    {
      unint64_t v5 = (re::SyncObjectStore *)result;
      unint64_t v6 = a2;
      uint64_t result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(result + 504, (uint64_t *)&v6);
      if (result)
      {
        if (*(void *)(*(void *)result + 16))
        {
          unint64_t v6 = 0;
          __int16 v7 = 0;
          char v8 = 0;
          int v10 = 0x10000;
          uint64_t v9 = a3;
          uuid_generate_random(out);
          re::SyncObjectStore::createIncomingObject(v5, (const re::SyncOwnershipInfo *)&v6, a2, (*(void *)&out[8] + (*(void *)out << 6) + (*(void *)out >> 2) - 0x61C8864680B583E9) ^ *(void *)out, (uint64_t *)out);
          return *(void *)out;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t RESyncServiceRequestOwnership(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  if (result)
  {
    uint64_t v10 = result;
    uint64_t v11 = *(void *)(a2 + 80);
    uint64_t v12 = a2;
    if (v11)
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v12 = v13;
        uint64_t v13 = v11;
        if (*(unsigned char *)(*(void *)(*(void *)(v12 + 88) + 16) + 73)) {
          break;
        }
        uint64_t v11 = *(void *)(v11 + 80);
        uint64_t v12 = v13;
      }
      while (v11);
    }
    if (*(void *)(v12 + 160))
    {
      uint64_t v15 = a2;
      if (a2) {
        id v14 = (id)(a2 + 8);
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, double))(*(void *)v10 + 136))(v10, &v15, a3, a4, a5, a6);
      if (v15) {

      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t RESyncServiceAfterFrameUpdate(re::NetworkSyncManager *a1)
{
  if (!a1) {
    return 1;
  }
  re::NetworkSyncManager::afterFrameUpdate(a1);
  return 0;
}

uint64_t RESyncServiceBeforeFrameUpdate(re::RoutingTable **a1)
{
  if (!a1) {
    return 1;
  }
  re::NetworkSyncManager::beforeFrameUpdate(a1);
  return 0;
}

void RESyncServiceAddView(uint64_t a1, re::SyncView *a2)
{
  if (a1 && a2)
  {
    uint64_t v3 = (re::SyncViewManager *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 160))(a1);
    re::SyncViewManager::addView(v3, a2);
  }
}

void RESyncServiceRemoveView(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160))(a1);
    re::SyncViewManager::removeView(v3, a2);
  }
}

re::SyncObjectTypedStore **RESyncServiceFindSyncableWithGuid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  unint64_t v5 = (re::SyncObjectStore *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 152))(a1);
  if (!v5) {
    return 0;
  }
  re::SyncObjectStore::findObject(v5, a2, a3, &v8);
  unint64_t v6 = v8;
  if (v8) {

  }
  return v6;
}

void *RESyncServiceGetObjectCountForType(void *result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result[7];
    uint64_t v3 = a2;
    uint64_t result = (void *)re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v2 + 504, &v3);
    if (result)
    {
      if (*result) {
        return *(void **)(*result + 64);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t RESyncServiceGetLocalPeerId(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 168))();
  }
  return result;
}

void re::ServiceObserverProxy::~ServiceObserverProxy(const void **this)
{
  re::ServiceObserverProxy::~ServiceObserverProxy(this);
  JUMPOUT(0x22A6A9430);
}

{
  *this = &unk_26DD36E10;
  _Block_release(this[3]);
  _Block_release(this[4]);
  _Block_release(this[5]);
  _Block_release(this[6]);
  _Block_release(this[7]);
  _Block_release(this[8]);
  _Block_release(this[9]);
  *this = &unk_26DD34510;
  objc_destructInstance(this + 1);
}

uint64_t re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*,re::SharedPtr<re::Session>))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::SharedPtr<re::Session>>::Subscription const&,re::SharedPtr<re::Session>&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t *a3)
{
  unint64_t v5 = (uint64_t (*)(void *, uint64_t, uint64_t *))a2[1];
  uint64_t v4 = a2[2];
  unint64_t v6 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    unint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t *))(*v6 + v5);
  }
  uint64_t v7 = *a3;
  uint64_t v11 = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  uint64_t v9 = v5(v6, a1, &v11);
  if (v11) {

  }
  return v9;
}

uint64_t re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,void const*,unsigned long,BOOL &>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&,void const*&&,unsigned long &&,BOOL &)#1}::__invoke(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  uint64_t v7 = (uint64_t (*)(void *, uint64_t, uint64_t, void, void, void))a2[1];
  uint64_t v8 = a2[2];
  uint64_t v9 = (void *)(*a2 + (v8 >> 1));
  if (v8) {
    uint64_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t, void, void, void))(*v9 + v7);
  }
  return v7(v9, a1, a3, *a4, *a5, *a6);
}

uint64_t re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long,re::OwnershipResponseResult>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&,re::OwnershipResponseResult&&)#1}::__invoke(uint64_t a1, void *a2, uint64_t a3, void *a4, unsigned __int8 *a5)
{
  unint64_t v6 = (uint64_t (*)(void *, uint64_t, uint64_t, void, void))a2[1];
  uint64_t v7 = a2[2];
  uint64_t v8 = (void *)(*a2 + (v7 >> 1));
  if (v7) {
    unint64_t v6 = *(uint64_t (**)(void *, uint64_t, uint64_t, void, void))(*v8 + v6);
  }
  return v6(v8, a1, a3, *a4, *a5);
}

uint64_t re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::SyncSession*,re::SharedPtr<re::SyncObject> const&,unsigned long long))::{lambda(re::SyncSession*,re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::Subscription const&,re::SharedPtr<re::SyncObject> const&,unsigned long long &&)#1}::__invoke(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  unint64_t v5 = (uint64_t (*)(void *, uint64_t, uint64_t, void))a2[1];
  uint64_t v6 = a2[2];
  uint64_t v7 = (void *)(*a2 + (v6 >> 1));
  if (v6) {
    unint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t, void))(*v7 + v5);
  }
  return v5(v7, a1, a3, *a4);
}

uint64_t re::Event<re::NetworkSyncService>::createSubscription<re::ServiceObserverProxy>(re::ServiceObserverProxy *,REEventHandlerResult (re::ServiceObserverProxy::*)(re::NetworkSyncService*))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService>::Subscription const&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  unint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

void re::TransferReportObserverProxy::~TransferReportObserverProxy(re::TransferReportObserverProxy *this)
{
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::createSubscription<re::TransferReportObserverProxy>(re::TransferReportObserverProxy *,REEventHandlerResult (re::TransferReportObserverProxy::*)(re::NetworkSyncService*,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int))::{lambda(re::NetworkSyncService*,re::Event<re::NetworkSyncService,re::Session *,unsigned long long,unsigned long long,unsigned long long,unsigned long long,unsigned int>::Subscription const&,re::Session *&&,unsigned long long &&,re::Session *&&,re::Session *&&,re::Session *&&,unsigned int &&)#1}::__invoke(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, unsigned int *a8)
{
  uint64_t v9 = (uint64_t (*)(void *, uint64_t, void, void, void, void, void, void))a2[1];
  uint64_t v10 = a2[2];
  uint64_t v11 = (void *)(*a2 + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t, void, void, void, void, void, void))(*v11 + v9);
  }
  return v9(v11, a1, *a3, *a4, *a5, *a6, *a7, *a8);
}

re::SyncObjectStore *re::make::shared::object<re::SyncObjectStore>(re *a1)
{
  uint64_t v2 = re::globalAllocators(a1);
  uint64_t v3 = (re::SyncObjectStore *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 648, 8);
  uint64_t result = re::SyncObjectStore::SyncObjectStore(v3);
  *(void *)a1 = result;
  return result;
}

void re::make::shared::object<re::NetworkSyncManager>(re *a1)
{
  uint64_t v2 = re::globalAllocators(a1);
  uint64_t v3 = (re::NetworkSyncManager *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 864, 8);
  re::NetworkSyncManager::NetworkSyncManager(v3);
  *(void *)a1 = v4;
}

uint64_t re::DebugDiscoveryView::DebugDiscoveryView(uint64_t a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)a1 = &unk_26DD36EA0;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 24), (const re::DynamicString *)a2);
  long long v4 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 56) = v4;
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = *(void *)(a2 + 80);
  *(void *)(a1 + 112) = 0;
  unint64_t v5 = (_anonymous_namespace_ *)re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::operator=<24ul>(a1 + 80, a2 + 56);
  *(void *)(a1 + 12ArcSharedObject::ArcSharedObject(this, 0) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 232) = 0;
  *(_DWORD *)(a1 + 2re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 2re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 32ArcSharedObject::ArcSharedObject(this, 0) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(_OWORD *)(a1 + 28ArcSharedObject::ArcSharedObject(this, 0) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  uint64_t v6 = (_anonymous_namespace_ *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 160), 0);
  ++*(_DWORD *)(a1 + 184);
  uint64_t v7 = (re *)re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)(a1 + 248), 0);
  ++*(_DWORD *)(a1 + 272);
  uint64_t v8 = re::globalAllocators(v7);
  uint64_t v9 = (re::DebugDiscoveryIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 64, 8);
  char v16 = re::DebugDiscoveryIdentity::DebugDiscoveryIdentity(v9, 1, (const re::Address *)(a1 + 24));
  re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add((void *)(a1 + 120), &v16);
  if (v16) {

  }
  if (*(void *)(a1 + 64))
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      char v14 = 0;
      re::make::shared::object<re::DebugDiscoveryIdentity,BOOL,re::Address const&>((re *)&v14, (const re::Address *)(*(void *)(a1 + 56) + v10), &v15);
      uint64_t v12 = v15;
      uint64_t v15 = 0;
      char v16 = v12;
      re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add((void *)(a1 + 120), &v16);
      if (v16)
      {

        char v16 = 0;
      }
      if (v15) {

      }
      ++v11;
      v10 += 32;
    }
    while (v11 < *(void *)(a1 + 64));
  }
  return a1;
}

void re::DebugDiscoveryView::~DebugDiscoveryView(re::DebugDiscoveryView *this)
{
  *(void *)this = &unk_26DD36EA0;
  uint64_t v2 = *((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v2)
  {
    uint64_t v3 = *((void *)this + 19);
    uint64_t v4 = 8 * v2;
    do
    {
      if (*(void *)v3)
      {

        *(void *)uint64_t v3 = 0;
      }
      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
  uint64_t v5 = *((void *)this + 31);
  ++*((_DWORD *)this + 36);
  if (v5) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 248);
  }
  if (*((void *)this + 20)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 160);
  }
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 31);
  re::Event<re::SyncSession,re::SharedPtr<re::SyncObject> const&,unsigned long long>::~Event((void *)this + 20);
  re::DynamicArray<re::SharedPtr<re::SyncObject>>::deinit((uint64_t)this + 120);
  re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::destroyCallable((uint64_t)this + 80);
  re::DynamicString::deinit((re::DebugDiscoveryView *)((char *)this + 24));
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::DebugDiscoveryView::~DebugDiscoveryView(this);
  JUMPOUT(0x22A6A9430);
}

void re::DebugDiscoveryView::requestIdentity(void *a1, const re::Address *a2)
{
  uint64_t v4 = a1[17];
  if (v4)
  {
    uint64_t v5 = (uint64_t *)a1[19];
    uint64_t v6 = 8 * v4;
    while (1)
    {
      uint64_t v7 = *v5;
      if (*v5) {
        id v8 = (id)(v7 + 8);
      }
      (*(void (**)(re::DebugDiscoveryIdentity **__return_ptr, uint64_t))(*(void *)v7 + 40))(&v16, v7);
      BOOL v9 = re::DynamicString::operator==((uint64_t)a2, (uint64_t)&v16);
      if (v16 && (v17 & 1) != 0) {
        (*(void (**)(void))(*(void *)v16 + 40))();
      }

      if (v9) {
        break;
      }
      ++v5;
      v6 -= 8;
      if (!v6) {
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_10:
    char v14 = 0;
    re::make::shared::object<re::DebugDiscoveryIdentity,BOOL,re::Address const&>((re *)&v14, a2, &v15);
    uint64_t v10 = v15;
    uint64_t v15 = 0;
    char v16 = v10;
    re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add(a1 + 15, &v16);
    if (v16)
    {

      char v16 = 0;
    }
    if (v15) {

    }
    uint64_t v11 = *(void *)(a1[19] + 8 * a1[17] - 8);
    uint64_t v13 = v11;
    if (v11) {
      id v12 = (id)(v11 + 8);
    }
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise((uint64_t)(a1 + 20), (uint64_t)a1);
    if (v13) {
  }
    }
}

BOOL re::DebugDiscoveryView::removeIdentity(uint64_t a1, void *a2)
{
  BOOL v4 = re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::remove(a1 + 120, a2);
  if (v4)
  {
    uint64_t v7 = *a2;
    if (*a2) {
      id v5 = (id)(*a2 + 8);
    }
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise(a1 + 248, a1);
    if (v7) {
  }
    }
  return v4;
}

void re::DebugDiscoveryView::addIdentityWithAddress(re::DebugDiscoveryView *this, const re::Address *a2)
{
  uint64_t v4 = *((void *)this + 17);
  if (v4)
  {
    id v5 = (uint64_t *)*((void *)this + 19);
    uint64_t v6 = 8 * v4;
    while (1)
    {
      uint64_t v7 = *v5;
      if (*v5) {
        id v8 = (id)(v7 + 8);
      }
      (*(void (**)(re::DebugDiscoveryIdentity **__return_ptr, uint64_t))(*(void *)v7 + 40))(&v16, v7);
      BOOL v9 = re::DynamicString::operator==((uint64_t)a2, (uint64_t)&v16);
      if (v16 && (v17 & 1) != 0) {
        (*(void (**)(void))(*(void *)v16 + 40))();
      }

      if (v9) {
        break;
      }
      ++v5;
      v6 -= 8;
      if (!v6) {
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_10:
    char v14 = 0;
    re::make::shared::object<re::DebugDiscoveryIdentity,BOOL,re::Address const&>((re *)&v14, a2, &v15);
    uint64_t v10 = v15;
    uint64_t v15 = 0;
    char v16 = v10;
    re::DynamicArray<re::SharedPtr<re::DiscoveryIdentity>>::add((void *)this + 15, &v16);
    if (v16)
    {

      char v16 = 0;
    }
    if (v15) {

    }
    uint64_t v11 = *(void *)(*((void *)this + 19) + 8 * *((void *)this + 17) - 8);
    uint64_t v13 = v11;
    if (v11) {
      id v12 = (id)(v11 + 8);
    }
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise((uint64_t)this + 160, (uint64_t)this);
    if (v13) {
  }
    }
}

void re::DebugDiscoveryView::removeIdentityWithAddress(re::DebugDiscoveryView *this, const re::Address *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*((void *)this + 17))
  {
    unint64_t v4 = 0;
    while (1)
    {
      (*(void (**)(_OWORD *__return_ptr))(**(void **)(*((void *)this + 19) + 8 * v4) + 40))(v11);
      BOOL v5 = re::DynamicString::operator==((uint64_t)a2, (uint64_t)v11);
      if (*(void *)&v11[0] && (BYTE8(v11[0]) & 1) != 0) {
        (*(void (**)(void))(**(void **)&v11[0] + 40))();
      }
      unint64_t v6 = *((void *)this + 17);
      if (v5) {
        break;
      }
      if (++v4 >= v6) {
        return;
      }
    }
    if (v6 <= v4)
    {
      memset(v11, 0, sizeof(v11));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v7 = *(void *)(*((void *)this + 19) + 8 * v4);
    if (v7)
    {
      id v8 = (id)(v7 + 8);
      re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt((uint64_t)this + 120, v4);
      uint64_t v10 = v7;
      id v9 = (id)(v7 + 8);
    }
    else
    {
      re::DynamicArray<re::SharedPtr<re::SessionParticipant>>::removeAt((uint64_t)this + 120, v4);
      uint64_t v10 = 0;
    }
    re::Event<re::DiscoveryView,re::SharedPtr<re::DiscoveryIdentity>>::raise((uint64_t)this + 248, (uint64_t)this);
    if (v10) {

    }
    if (v7) {
  }
    }
}

re::DebugProtocolLayer *re::DebugDiscoveryView::createProtocolLayer@<X0>(re::DebugDiscoveryView *this@<X0>, uint64_t a2@<X1>, re::DebugProtocolLayer **a3@<X8>)
{
  uint64_t v5 = *((void *)this + 14);
  if (v5)
  {
    unint64_t v6 = *(uint64_t (**)(void))(*(void *)v5 + 16);
    return (re::DebugProtocolLayer *)v6();
  }
  int v8 = *((_DWORD *)this + 18);
  if (v8 == 4)
  {
    LOBYTE(v16) = 1;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v18 = 0;
    uint64_t v13 = (re *)re::DynamicString::setCapacity(&v17, 0);
    __int16 v21 = 0;
    int v22 = 0;
    uint64_t v23 = 0;
    char v14 = re::globalAllocators(v13);
    uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14[2] + 32))(v14[2], 224, 8);
    uint64_t v12 = re::NWProtocolLayer::NWProtocolLayer(v15, (uint64_t)&v16);
LABEL_10:
    *a3 = (re::DebugProtocolLayer *)v12;
    uint64_t result = (re::DebugProtocolLayer *)v17;
    if (v17 && (v18 & 1) != 0) {
      return (re::DebugProtocolLayer *)(*(uint64_t (**)(void))(*v17 + 40))();
    }
    return result;
  }
  if (v8 != 3)
  {
    if (v8 != 2)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Not implemented", "!\"Unreachable code\"", "createProtocolLayer", 109);
      uint64_t result = (re::DebugProtocolLayer *)_os_crash();
      __break(1u);
      return result;
    }
    int v16 = 128;
    __int16 v21 = 0;
    uint64_t v10 = re::globalAllocators(v9);
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 208, 8);
    uint64_t v12 = re::TcpProtocolLayer::TcpProtocolLayer(v11, (uint64_t)&v16);
    goto LABEL_10;
  }
  return re::make::shared::object<re::DebugProtocolLayer>(0, a3);
}

uint64_t re::DebugDiscoveryView::createWithAddresses@<X0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  v16[5] = *MEMORY[0x263EF8340];
  re::DynamicString::DynamicString((re::DynamicString *)&v11, (const re::DynamicString *)&v9);
  if (v9 && (v10 & 1) != 0) {
    (*(void (**)(void))(*(void *)v9 + 40))();
  }
  uint64_t v13 = a1;
  uint64_t v14 = a2;
  int v15 = 2;
  v16[3] = *(void *)(a3 + 24);
  v16[4] = 0;
  re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::operator=<24ul>((uint64_t)v16, a3);
  re::make::shared::object<re::DebugDiscoveryView,re::DebugDiscoveryView::Config &>((re *)&v11, a4);
  re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::destroyCallable((uint64_t)v16);
  uint64_t result = v11;
  if (v11)
  {
    if (v12) {
      return (*(uint64_t (**)(void))(*(void *)v11 + 40))();
    }
  }
  return result;
}

uint64_t re::DebugDiscoveryView::didJoinEvent(re::DebugDiscoveryView *this)
{
  return (uint64_t)this + 160;
}

uint64_t re::DebugDiscoveryView::didLeaveEvent(re::DebugDiscoveryView *this)
{
  return (uint64_t)this + 248;
}

uint64_t re::DebugDiscoveryView::identitiesCount(re::DebugDiscoveryView *this)
{
  return *((void *)this + 17);
}

void *re::DebugDiscoveryView::identityAtIndex@<X0>(void *this@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (this[17] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v3 = *(void *)(this[19] + 8 * a2);
  *a3 = v3;
  if (v3)
  {
    return (id)(v3 + 8);
  }
  return this;
}

uint64_t re::DebugDiscoveryView::authData(re::DebugDiscoveryView *this)
{
  return 0;
}

uint64_t re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,re::SharedPtr<re::ProtocolLayer> ()(void)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

re::DebugDiscoveryIdentity *re::DebugDiscoveryIdentity::DebugDiscoveryIdentity(re::DebugDiscoveryIdentity *this, char a2, const re::Address *a3)
{
  *(void *)this = &unk_26DD36F28;
  *((unsigned char *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = a2;
  re::DynamicString::DynamicString((re::DebugDiscoveryIdentity *)((char *)this + 32), a3);
  return this;
}

void re::DebugDiscoveryIdentity::~DebugDiscoveryIdentity(re::DebugDiscoveryIdentity *this)
{
  *(void *)this = &unk_26DD36F28;
  re::DynamicString::deinit((re::DebugDiscoveryIdentity *)((char *)this + 32));
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26DD36F28;
  re::DynamicString::deinit((re::DebugDiscoveryIdentity *)((char *)this + 32));
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x22A6A9430);
}

uint64_t re::DebugDiscoveryIdentity::displayName(re::DebugDiscoveryIdentity *this)
{
  if (*((unsigned char *)this + 40)) {
    return *((void *)this + 6);
  }
  else {
    return (uint64_t)this + 41;
  }
}

re::DynamicString *re::DebugDiscoveryIdentity::address@<X0>(re::DebugDiscoveryIdentity *this@<X0>, re::DynamicString *a2@<X8>)
{
  return re::DynamicString::DynamicString(a2, (re::DebugDiscoveryIdentity *)((char *)this + 32));
}

uint64_t re::DebugDiscoveryIdentity::isLocal(re::DebugDiscoveryIdentity *this)
{
  return *((unsigned __int8 *)this + 24);
}

re::DebugDiscoveryIdentity *re::make::shared::object<re::DebugDiscoveryIdentity,BOOL,re::Address const&>@<X0>(re *a1@<X0>, const re::Address *a2@<X1>, re::DebugDiscoveryIdentity **a3@<X8>)
{
  uint64_t v6 = re::globalAllocators(a1);
  unint64_t v7 = (re::DebugDiscoveryIdentity *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[2] + 32))(v6[2], 64, 8);
  uint64_t result = re::DebugDiscoveryIdentity::DebugDiscoveryIdentity(v7, *(unsigned char *)a1, a2);
  *a3 = result;
  return result;
}

uint64_t re::make::shared::object<re::DebugDiscoveryView,re::DebugDiscoveryView::Config &>@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4 = re::globalAllocators(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 336, 8);
  uint64_t result = re::DebugDiscoveryView::DebugDiscoveryView(v5, (uint64_t)a1);
  *a2 = result;
  return result;
}

uint64_t re::NetworkFeatureFlags::enableTransportLog(re::NetworkFeatureFlags *this)
{
  uint64_t v1 = &re::StackScratchAllocator::s_rootsWithPersistentBlocks[56];
  {
    uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    if (v3)
    {
      re::NetworkFeatureFlags::enableTransportLog(void)::enable = re::NetworkFeatureFlags::enableTransportLog(void)::$_0::operator()(v3, v4);
      uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    }
  }
  return *((unsigned __int8 *)v1 + 1856);
}

BOOL re::NetworkFeatureFlags::enableTransportLog(void)::$_0::operator()(uint64_t a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  re::Defaults::BOOLValue((re::Defaults *)"network.transport.enableLog", a2, (char *)v6);
  if (LOBYTE(v6[0])) {
    unsigned __int8 v3 = BYTE1(v6[0]);
  }
  else {
    unsigned __int8 v3 = 0;
  }
  uint64_t v4 = *re::networkLogObjects(v2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v3;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Transport log enabled: %d", (uint8_t *)v6, 8u);
  }
  return v3 != 0;
}

uint64_t re::NetworkFeatureFlags::overrideTransportThrottling(uint64_t this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2682A4838, memory_order_acquire) & 1) == 0)
  {
    unsigned int v3 = this;
    int v2 = __cxa_guard_acquire(&qword_2682A4838);
    LODWORD(this) = v3;
    if (v2)
    {
      re::NetworkFeatureFlags::overrideTransportThrottling(BOOL)::$_0::operator()(v3, v1);
      __cxa_atexit((void (*)(void *))re::Optional<BOOL>::~Optional, &_MergedGlobals_2, &dword_228C70000);
      __cxa_guard_release(&qword_2682A4838);
      LODWORD(this) = v3;
    }
  }
  if (_MergedGlobals_2) {
    return byte_2682A4831 != 0;
  }
  else {
    return this;
  }
}

void re::NetworkFeatureFlags::overrideTransportThrottling(BOOL)::$_0::operator()(uint64_t a1, const char *a2)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  re::Defaults::BOOLValue((re::Defaults *)"network.transport.enableThrottling", a2, &_MergedGlobals_2);
  if (_MergedGlobals_2)
  {
    unsigned int v3 = *re::networkLogObjects(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109120;
      v4[1] = byte_2682A4831;
      _os_log_impl(&dword_228C70000, v3, OS_LOG_TYPE_DEFAULT, "Transport throttling override enabled: %d", (uint8_t *)v4, 8u);
    }
  }
}

uint64_t re::NetworkFeatureFlags::overrideMessageFragmentation(uint64_t this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2682A4840, memory_order_acquire) & 1) == 0)
  {
    unsigned int v3 = this;
    int v2 = __cxa_guard_acquire(&qword_2682A4840);
    LODWORD(this) = v3;
    if (v2)
    {
      re::NetworkFeatureFlags::overrideMessageFragmentation(BOOL)::$_0::operator()(v3, v1);
      __cxa_atexit((void (*)(void *))re::Optional<BOOL>::~Optional, &byte_2682A4832, &dword_228C70000);
      __cxa_guard_release(&qword_2682A4840);
      LODWORD(this) = v3;
    }
  }
  if (byte_2682A4832) {
    return byte_2682A4833 != 0;
  }
  else {
    return this;
  }
}

void re::NetworkFeatureFlags::overrideMessageFragmentation(BOOL)::$_0::operator()(uint64_t a1, const char *a2)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  re::Defaults::BOOLValue((re::Defaults *)"network.transport.enableMessageFragmentation", a2, &byte_2682A4832);
  if (byte_2682A4832)
  {
    unsigned int v3 = *re::networkLogObjects(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109120;
      v4[1] = byte_2682A4833;
      _os_log_impl(&dword_228C70000, v3, OS_LOG_TYPE_DEFAULT, "Transport message fragmentation override enabled: %d", (uint8_t *)v4, 8u);
    }
  }
}

uint64_t re::NetworkFeatureFlags::enableSyncCommitLog(re::NetworkFeatureFlags *this)
{
  uint64_t v1 = &re::StackScratchAllocator::s_rootsWithPersistentBlocks[56];
  {
    uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    if (v3)
    {
      re::NetworkFeatureFlags::enableSyncCommitLog(void)::enable = re::NetworkFeatureFlags::enableSyncCommitLog(void)::$_0::operator()(v3, v4);
      uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    }
  }
  return *((unsigned __int8 *)v1 + 1872);
}

BOOL re::NetworkFeatureFlags::enableSyncCommitLog(void)::$_0::operator()(uint64_t a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  re::Defaults::BOOLValue((re::Defaults *)"network.syncCommit.enableLog", a2, (char *)v6);
  if (LOBYTE(v6[0])) {
    unsigned __int8 v3 = BYTE1(v6[0]);
  }
  else {
    unsigned __int8 v3 = 0;
  }
  uint64_t v4 = *re::networkLogObjects(v2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v3;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "SyncCommit log enabled: %d", (uint8_t *)v6, 8u);
  }
  return v3 != 0;
}

uint64_t re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(re::NetworkFeatureFlags *this)
{
  uint64_t v1 = &re::StackScratchAllocator::s_rootsWithPersistentBlocks[56];
  {
    uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    if (v3)
    {
      re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(void)::size_t size = re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(void)::$_0::operator()(v3, v4);
      uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    }
  }
  return *((unsigned int *)v1 + 472);
}

uint64_t re::NetworkFeatureFlags::syncObjectStateHistoryBufferSize(void)::$_0::operator()(uint64_t a1, const char *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  re::Defaults::uintValue((re::Defaults *)"network.syncObjectStateHistoryBufferSize", a2, (uint64_t)&v6);
  if ((_BYTE)v6) {
    uint64_t v3 = v7;
  }
  else {
    uint64_t v3 = 16;
  }
  uint64_t v4 = *re::networkLogObjects(v2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 67109120;
    unsigned int v7 = v3;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "syncObjectStateHistoryBufferSize is: %u", (uint8_t *)&v6, 8u);
  }
  return v3;
}

uint64_t re::NetworkFeatureFlags::enableSharedAppSpecialization(re::NetworkFeatureFlags *this)
{
  uint64_t v1 = &re::StackScratchAllocator::s_rootsWithPersistentBlocks[56];
  {
    uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    if (v3)
    {
      re::NetworkFeatureFlags::enableSharedAppSpecialization(void)::enable = re::NetworkFeatureFlags::enableSharedAppSpecialization(void)::$_0::operator()(v3, v4);
      uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    }
  }
  return *((unsigned __int8 *)v1 + 1904);
}

BOOL re::NetworkFeatureFlags::enableSharedAppSpecialization(void)::$_0::operator()(uint64_t a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  re::Defaults::BOOLValue((re::Defaults *)"network.sharedAppSpecialization", a2, (char *)v6);
  if (LOBYTE(v6[0])) {
    unsigned __int8 v3 = BYTE1(v6[0]);
  }
  else {
    unsigned __int8 v3 = 1;
  }
  uint64_t v4 = *re::networkLogObjects(v2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v3;
    _os_log_impl(&dword_228C70000, v4, OS_LOG_TYPE_DEFAULT, "Shared App Specialization enabled: %d", (uint8_t *)v6, 8u);
  }
  return v3 != 0;
}

id RESyncRetain(uint64_t a1)
{
  return (id)(a1 + 8);
}

void RESyncRelease(uint64_t a1)
{
}

uint64_t RESyncGetRetainCount(uint64_t a1)
{
  return [(id)(a1 + 8) retainCount];
}

re::SyncObjectTypeInfo *re::SyncObjectTypeInfo::SyncObjectTypeInfo(re::SyncObjectTypeInfo *this, const re::SyncObjectTypeInfo *a2)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26DD36F88;
  *((unsigned char *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = *((unsigned char *)a2 + 24);
  *((void *)this + 4) = *((void *)a2 + 4);
  re::DynamicString::DynamicString((re::SyncObjectTypeInfo *)((char *)this + 40), (const re::SyncObjectTypeInfo *)((char *)a2 + 40));
  __int16 v4 = *((_WORD *)a2 + 36);
  char v5 = *((unsigned char *)a2 + 74);
  *((_OWORD *)this + 5) = 0u;
  *((_WORD *)this + 36) = v4;
  *((unsigned char *)this + 74) = v5;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  int v6 = (const void *)*((void *)a2 + 10);
  if (v6) {
    *((void *)this + 1ArcSharedObject::ArcSharedObject(this, 0) = _Block_copy(v6);
  }
  uint64_t v7 = (const void *)*((void *)a2 + 11);
  if (v7) {
    *((void *)this + 11) = _Block_copy(v7);
  }
  uint64_t v8 = (const void *)*((void *)a2 + 12);
  if (v8) {
    *((void *)this + 12) = _Block_copy(v8);
  }
  uint64_t v9 = (const void *)*((void *)a2 + 13);
  if (v9) {
    *((void *)this + 13) = _Block_copy(v9);
  }
  char v10 = (const void *)*((void *)a2 + 14);
  if (v10) {
    *((void *)this + 14) = _Block_copy(v10);
  }
  uint64_t v11 = (const void *)*((void *)a2 + 15);
  if (v11) {
    *((void *)this + 15) = _Block_copy(v11);
  }
  char v12 = (const void *)*((void *)a2 + 16);
  if (v12) {
    *((void *)this + 16) = _Block_copy(v12);
  }
  uint64_t v13 = (const void *)*((void *)a2 + 17);
  if (v13) {
    *((void *)this + 17) = _Block_copy(v13);
  }
  return this;
}

void re::SyncObjectTypeInfo::~SyncObjectTypeInfo(re::SyncObjectTypeInfo *this)
{
  *(void *)this = &unk_26DD36F88;
  int v2 = (const void *)*((void *)this + 10);
  if (v2)
  {
    _Block_release(v2);
    *((void *)this + 1ArcSharedObject::ArcSharedObject(this, 0) = 0;
  }
  unsigned __int8 v3 = (const void *)*((void *)this + 11);
  if (v3)
  {
    _Block_release(v3);
    *((void *)this + 11) = 0;
  }
  __int16 v4 = (const void *)*((void *)this + 12);
  if (v4)
  {
    _Block_release(v4);
    *((void *)this + 12) = 0;
  }
  char v5 = (const void *)*((void *)this + 13);
  if (v5)
  {
    _Block_release(v5);
    *((void *)this + 13) = 0;
  }
  int v6 = (const void *)*((void *)this + 14);
  if (v6)
  {
    _Block_release(v6);
    *((void *)this + 14) = 0;
  }
  uint64_t v7 = (const void *)*((void *)this + 15);
  if (v7)
  {
    _Block_release(v7);
    *((void *)this + 15) = 0;
  }
  uint64_t v8 = (const void *)*((void *)this + 16);
  if (v8)
  {
    _Block_release(v8);
    *((void *)this + 16) = 0;
  }
  uint64_t v9 = (const void *)*((void *)this + 17);
  if (v9)
  {
    _Block_release(v9);
    *((void *)this + 17) = 0;
  }
  re::DynamicString::deinit((re::SyncObjectTypeInfo *)((char *)this + 40));
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::SyncObjectTypeInfo::~SyncObjectTypeInfo(this);
  JUMPOUT(0x22A6A9430);
}

void *re::SyncObjectTypeInfo::setReadSnapshotCb(uint64_t a1, void *aBlock)
{
  __int16 v4 = *(const void **)(a1 + 80);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = _Block_copy(aBlock);
  *(void *)(a1 + 8ArcSharedObject::ArcSharedObject(this, 0) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setWriteSnapshotCb(uint64_t a1, void *aBlock)
{
  __int16 v4 = *(const void **)(a1 + 88);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = _Block_copy(aBlock);
  *(void *)(a1 + 88) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setReadPayloadCb(uint64_t a1, void *aBlock)
{
  __int16 v4 = *(const void **)(a1 + 96);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = _Block_copy(aBlock);
  *(void *)(a1 + 96) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setReadPayloadDeltaCb(uint64_t a1, void *aBlock)
{
  __int16 v4 = *(const void **)(a1 + 104);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = _Block_copy(aBlock);
  *(void *)(a1 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setWritePayloadCb(uint64_t a1, void *aBlock)
{
  __int16 v4 = *(const void **)(a1 + 112);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = _Block_copy(aBlock);
  *(void *)(a1 + 112) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setWritePayloadDeltaCb(uint64_t a1, void *aBlock)
{
  __int16 v4 = *(const void **)(a1 + 120);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = _Block_copy(aBlock);
  *(void *)(a1 + 12ArcSharedObject::ArcSharedObject(this, 0) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setShouldPackCb(uint64_t a1, void *aBlock)
{
  __int16 v4 = *(const void **)(a1 + 128);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = _Block_copy(aBlock);
  *(void *)(a1 + 128) = result;
  return result;
}

void *re::SyncObjectTypeInfo::setShouldUnpackCb(uint64_t a1, void *aBlock)
{
  __int16 v4 = *(const void **)(a1 + 136);
  if (v4) {
    _Block_release(v4);
  }
  uint64_t result = _Block_copy(aBlock);
  *(void *)(a1 + 136) = result;
  return result;
}

uint64_t RESyncReadContextIsNew(uint64_t a1)
{
  return *(unsigned char *)(*(void *)a1 + 16) & 1;
}

uint64_t RESyncReadContextIsDataChanged(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(void *)a1 + 16) >> 3) & 1;
}

uint64_t RESyncReadContextIsDestroyed(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(void *)a1 + 16) >> 1) & 1;
}

uint64_t RESyncReadContextIsChangedOwner(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(void *)a1 + 16) >> 2) & 1;
}

uint64_t RESyncReadContextGetStateData(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return *(void *)(v1 + 8);
  }
  else {
    return 0;
  }
}

uint64_t RESyncReadContextGetStateSize(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 0;
  }
  unsigned int v2 = *(_DWORD *)(v1 + 24);
  if (*(_DWORD *)(v1 + 28)) {
    return v2 + 1;
  }
  else {
    return v2;
  }
}

uint64_t re::PacketStatsFilter::init(uint64_t a1, _OWORD *a2)
{
  uint64_t v2 = a1;
  uint64_t v13 = *MEMORY[0x263EF8340];
  long long v3 = a2[1];
  *(_OWORD *)(a1 + re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 40) = *a2;
  *(_OWORD *)(a1 + 56) = v3;
  __int16 v4 = *(_DWORD **)(a1 + 40);
  if (v4)
  {
    *(void *)&long long v8 = a1;
    *((void *)&v8 + 1) = re::PacketStatsFilter::handleBandwithEvent;
    *(void *)&long long v9 = 0;
    *((void *)&v9 + 1) = re::Event<re::Session,re::BandwidthEventData const&>::createSubscription<re::PacketStatsFilter>(re::PacketStatsFilter *,REEventHandlerResult (re::PacketStatsFilter::*)(re::Session*,re::BandwidthEventData const&))::{lambda(re::Session*,re::Event<re::Session,re::BandwidthEventData const&>::Subscription const&,re::BandwidthEventData const&)#1}::__invoke;
    a1 = re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v4, &v8, (uint64_t)v10);
    if (!v10[0])
    {
      if (v4[20])
      {
        v10[0] = 1;
        long long v11 = v8;
        long long v12 = v9;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::Session>::Subscription,true>>::add((_anonymous_namespace_ *)(v4 + 10), (uint64_t)v10);
      }
      else
      {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add((_anonymous_namespace_ *)v4, (uint64_t)&v8);
      }
    }
  }
  uint64_t v5 = *(void *)(v2 + 48);
  *(void *)(v2 + 72) = 0;
  *(void *)(v2 + 8ArcSharedObject::ArcSharedObject(this, 0) = v5;
  *(_OWORD *)(v2 + 12ArcSharedObject::ArcSharedObject(this, 0) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 168) = 0u;
  *(_OWORD *)(v2 + 184) = 0u;
  uint64_t v6 = v2 + 224;
  re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::setCapacity((void *)v6, 0);
  ++*(_DWORD *)(v6 + 24);
  *(unsigned char *)(v6 - 20ArcSharedObject::ArcSharedObject(this, 0) = 1;
  return 1;
}

uint64_t re::PacketStatsFilter::handleBandwithEvent(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

void re::PacketStatsFilter::~PacketStatsFilter(re::PacketStatsFilter *this)
{
  *(void *)this = &unk_26DD36FD0;
  re::PacketStatsFilter::deInit(this);
  if (*((void *)this + 28)) {
    re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 224);
  }
  uint64_t v2 = *((void *)this + 33);
  if (v2)
  {
    if (*((void *)this + 37)) {
      (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    }
    *((void *)this + 37) = 0;
    *((void *)this + 34) = 0;
    *((void *)this + 35) = 0;
    *((void *)this + 33) = 0;
    ++*((_DWORD *)this + 72);
  }
  re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)this + 224);
  *(void *)this = &unk_26DD34510;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::PacketStatsFilter::~PacketStatsFilter(this);
  JUMPOUT(0x22A6A9430);
}

void re::PacketStatsFilter::deInit(re::PacketStatsFilter *this)
{
  if (*((unsigned char *)this + 24))
  {
    uint64_t v3 = *((void *)this + 28);
    uint64_t v2 = (char *)this + 224;
    if (v3) {
      re::DynamicArray<re::internal::PerFrameAllocatorChunk *>::deinit((uint64_t)v2);
    }
    uint64_t v4 = *((void *)this + 5);
    if (v4) {
      re::Event<re::Session,unsigned long long>::unsubscribe<re::SyncObjectManager>(v4, (uint64_t)this);
    }
    *((unsigned char *)this + re::Event<re::Session>::raise((uint64_t)this + 1592, (uint64_t)this - 24) = 0;
  }
}

double re::PacketStatsFilter::update(re::PacketStatsFilter *this)
{
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else {
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v3 = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
  }
  if (*((void *)this + 26) + 100 < v3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 54);
    re::PacketStatsFilter::pruneStaleBandwidthUsages(this);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 54);
  }
  double result = 0.0;
  *(_OWORD *)((char *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  return result;
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep re::PacketStatsFilter::pruneStaleBandwidthUsages(re::PacketStatsFilter *this)
{
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else {
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
  }
  unsigned int v4 = 0;
  uint64_t v5 = *((void *)this + 26);
  do
  {
    if (v5 + 100 >= result) {
      break;
    }
    uint64_t v6 = (unint64_t *)((char *)this + 72);
    unint64_t v7 = *((void *)this + 9);
    int v8 = *((_DWORD *)this + 50);
    if ((v8 + 1) <= 9) {
      int v9 = v8 + 1;
    }
    else {
      int v9 = 0;
    }
    *((_DWORD *)this + 5ArcSharedObject::ArcSharedObject(this, 0) = v9;
    char v10 = &v6[v9];
    unint64_t v11 = v10[6];
    BOOL v12 = v7 >= v11;
    unint64_t v13 = v7 - v11;
    if (!v12) {
      unint64_t v13 = 0;
    }
    *uint64_t v6 = v13;
    void v10[6] = 0;
    uint64_t v5 = result;
    if (v4 <= 8) {
      uint64_t v5 = *((void *)this + 26) + 100;
    }
    *((void *)this + 26) = v5;
    ++v4;
  }
  while (v4 != 10);
  return result;
}

int64x2_t re::PacketStatsFilter::updateChannelBandwidthUsages(re::PacketStatsFilter *a1, uint64_t a2)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v3 = (int64x2_t *)a1;
  uint64_t v4 = (8 * *(_DWORD *)(a2 + 24));
  re::PacketStatsFilter::pruneStaleBandwidthUsages(a1);
  uint64_t v5 = v3[4].i64[1];
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v3 = (int64x2_t *)((char *)v3 + 72);
  v3->i64[0] = v5 + v4;
  uint64_t v6 = &v3->i8[8 * v3[8].u32[0]];
  *((void *)v6 + 6) += v4;
  int64x2_t v7 = vdupq_n_s64(1uLL);
  v7.i64[0] = *(unsigned int *)(a2 + 24);
  int64x2_t result = vaddq_s64(v3[1], v7);
  v3[1] = result;
  return result;
}

void re::PacketStatsFilter::raiseCongestionEvent(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v2 = (_anonymous_namespace_ *)(a1 + 224);
  int v3 = *(_DWORD *)(a1 + 304);
  *(_DWORD *)(a1 + re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 304) = v3 + 1;
  if (*(void *)(a1 + 240))
  {
    unint64_t v4 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 256) + 32 * v4 + 24))(a1) == 1) {
        re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStableAt(v2, v4);
      }
      else {
        ++v4;
      }
    }
    while (v4 < *(void *)(a1 + 240));
    int v3 = *(_DWORD *)(a1 + 304) - 1;
  }
  *(_DWORD *)(a1 + re::DynamicArray<re::internal::SyncSnapshotEntry>::deinit((uint64_t)this + 304) = v3;
  if (!v3)
  {
    uint64_t v5 = *(void *)(a1 + 280);
    if (v5)
    {
      uint64_t v6 = 0;
      for (unint64_t i = 0; i != v5; ++i)
      {
        unint64_t v8 = *(void *)(a1 + 280);
        if (v8 <= i)
        {
          memset(v22, 0, sizeof(v22));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v14 = 136315906;
          int v15 = "operator[]";
          __int16 v16 = 1024;
          int v17 = 789;
          __int16 v18 = 2048;
          unint64_t v19 = i;
          __int16 v20 = 2048;
          unint64_t v21 = v8;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v9 = *(void *)(a1 + 296) + v6;
        uint64_t v10 = *(void *)(v9 + 32);
        long long v11 = *(_OWORD *)(v9 + 16);
        v12[0] = *(_OWORD *)v9;
        v12[1] = v11;
        uint64_t v13 = v10;
        if (LOBYTE(v12[0]))
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::indexOf((uint64_t)v2, (void *)v12 + 1, (uint64_t)v22);
          if (!LOBYTE(v22[0])) {
            re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::add(v2, (uint64_t)v12 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SyncViewManager,re::SyncView *>::Subscription>::removeStable(v2, (void *)v12 + 1);
        }
        v6 += 40;
      }
    }
  }
}

uint64_t re::PacketStatsFilter::handle(re::PacketStatsFilter *this, const re::Packet *a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  int v2 = *((_DWORD *)a2 + 6);
  if (v2)
  {
    uint64_t v5 = (8 * v2);
    uint64_t v6 = *((void *)this + 8);
    if (v6) {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 32))(v6);
    }
    else {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
    }
    uint64_t v10 = *((void *)this + 4);
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v11 = *((unsigned int *)this + 14);
    os_unfair_lock_lock((os_unfair_lock_t)this + 54);
    if ((unint64_t)(*((void *)this + 9) + v5) <= *((void *)this + 10) || v7 - v10 <= v11)
    {
      re::PacketStatsFilter::updateChannelBandwidthUsages(this, (uint64_t)a2);
      uint64_t v9 = 0;
    }
    else
    {
      int v14 = *re::networkLogObjects(v12);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        uint64_t v16 = *((void *)this + 10);
        uint64_t v17 = *((void *)this + 9) + v5;
        *(_DWORD *)int v22 = 134218240;
        *(void *)&v22[4] = v17;
        *(_WORD *)&v22[12] = 2048;
        *(void *)&v22[14] = v16;
        _os_log_impl(&dword_228C70000, v14, OS_LOG_TYPE_INFO, "Max bandwidth exceeded. Current bandwidth: %llu bps, Max bandwidth: %llu bps", v22, 0x16u);
      }
      uint64_t v18 = *((void *)this + 8);
      if (v18) {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v19 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 32))(v18);
      }
      else {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v19 = std::chrono::steady_clock::now().__d_.__rep_ / 1000000;
      }
      uint64_t v20 = *((unsigned int *)a2 + 6);
      *(void *)int v22 = v19;
      *(void *)&v22[8] = v20;
      *(_OWORD *)&v22[16] = *(_OWORD *)((char *)this + 72);
      (*(void (**)(re::PacketStatsFilter *, unsigned char *))(*(void *)this + 64))(this, v22);
      *((void *)this + 4) = v7;
      re::PacketStatsFilter::updateChannelBandwidthUsages(this, (uint64_t)a2);
      uint64_t v9 = 1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 54);
  }
  else
  {
    unint64_t v8 = *re::networkLogObjects(this);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v22 = 0;
      _os_log_error_impl(&dword_228C70000, v8, OS_LOG_TYPE_ERROR, "Invalid packet data size: 0", v22, 2u);
    }
    return 3;
  }
  return v9;
}

uint64_t re::PacketStatsFilter::handleBandwithEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a3 + 8))
  {
    uint64_t v5 = (os_unfair_lock_s *)(a1 + 216);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 216));
    *(void *)(a1 + 8ArcSharedObject::ArcSharedObject(this, 0) = *(void *)(a3 + 16);
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = *re::networkLogObjects(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      uint64_t v8 = *(void *)(a1 + 80);
      int v10 = 134217984;
      uint64_t v11 = v8;
      _os_log_impl(&dword_228C70000, v7, OS_LOG_TYPE_INFO, "Max bandwidth changed: %llu bps", (uint8_t *)&v10, 0xCu);
    }
    os_unfair_lock_unlock(v5);
  }
  return 0;
}

int64x2_t re::PacketStatsFilter::handleReceiveStats(re::PacketStatsFilter *this, uint64_t a2)
{
  int64x2_t v2 = vdupq_n_s64(1uLL);
  v2.i64[0] = a2;
  int64x2_t result = vaddq_s64(*(int64x2_t *)((char *)this + 104), v2);
  *(int64x2_t *)((char *)this + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = result;
  return result;
}

uint64_t re::Event<re::Session,re::BandwidthEventData const&>::createSubscription<re::PacketStatsFilter>(re::PacketStatsFilter *,REEventHandlerResult (re::PacketStatsFilter::*)(re::Session*,re::BandwidthEventData const&))::{lambda(re::Session*,re::Event<re::Session,re::BandwidthEventData const&>::Subscription const&,re::BandwidthEventData const&)#1}::__invoke(uint64_t a1, void *a2)
{
  int v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    int v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

uint64_t *re::foundationSerializationLogObjects(re *this)
{
  {
    re::foundationSerializationLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Serialization");
  }
  return &re::foundationSerializationLogObjects(void)::logObjects;
}

uint64_t re::snapshot::Encoder::error(re::snapshot::Encoder *this, const char *__format, ...)
{
  va_start(va, __format);
  int v3 = (re::snapshot::Encoder *)((char *)this + 32);
  unint64_t v4 = *((void *)this + 5);
  if (v4) {
    unint64_t v5 = v4 >> 1;
  }
  else {
    unint64_t v5 = v4 >> 1;
  }
  if (v5) {
    re::DynamicString::append((re::snapshot::Encoder *)((char *)this + 32), "\n", 1uLL);
  }
  return re::DynamicString::vappendf(v3, __format, va);
}

unsigned int *re::snapshot::EncoderOPACK::operator<<(unsigned int *this, int a2)
{
  int64x2_t v2 = this;
  if (a2) {
    char v3 = 1;
  }
  else {
    char v3 = 2;
  }
  uint64_t v4 = this[2];
  if (v4 < this[3]) {
    goto LABEL_5;
  }
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v4 + 1);
  if (this)
  {
    LODWORD(v4) = v2[2];
LABEL_5:
    uint64_t v5 = *(void *)v2;
    _OWORD v2[2] = v4 + 1;
    *(unsigned char *)(v5 + v4) = v3;
  }
  return this;
}

uint64_t *re::snapshot::Decoder::error(const char **this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  re::DynamicString::setCapacity(&v10, 0);
  uint64_t v4 = (re *)re::DynamicString::vassignf((re::DynamicString *)&v10, a2, va);
  uint64_t v5 = *re::foundationSerializationLogObjects(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = this[7];
    if (!v7) {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = "<unknown>";
    }
    int v8 = *((_DWORD *)this + 8);
    if (v11) {
      uint64_t v9 = v12;
    }
    else {
      uint64_t v9 = (char *)&v11 + 1;
    }
    *(_DWORD *)kevent64_s buf = 136315650;
    int v15 = v7;
    __int16 v16 = 1024;
    int v17 = v8;
    __int16 v18 = 2080;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v19 = v9;
    _os_log_error_impl(&dword_228C70000, v5, OS_LOG_TYPE_ERROR, "Snapshot reader (%s:%d): %s", buf, 0x1Cu);
  }
  this[2] = this[3];
  *((unsigned char *)this + 36) = 1;
  int64x2_t result = v10;
  if (v10)
  {
    if (v11) {
      return (uint64_t *)(*(uint64_t (**)(void))(*v10 + 40))();
    }
  }
  return result;
}

uint64_t *re::snapshot::DecoderOPACK::operator>>(uint64_t *result, unsigned char *a2)
{
  int64x2_t v2 = (unsigned __int8 *)result[2];
  if ((unint64_t)v2 >= result[3])
  {
    int v3 = 0;
  }
  else
  {
    result[2] = (uint64_t)(v2 + 1);
    int v3 = *v2;
    if (v3 == 1)
    {
      *a2 = 1;
      return result;
    }
    if (v3 == 2)
    {
      *a2 = 0;
      return result;
    }
  }
  return re::snapshot::Decoder::error((const char **)result, "expected BOOL, found tag %x", v3);
}

uint64_t re::snapshot::DecoderOPACK::beginData(re::snapshot::DecoderOPACK *this, unint64_t *a2, int a3)
{
  uint64_t v4 = (unsigned __int8 *)*((void *)this + 2);
  unint64_t v3 = *((void *)this + 3);
  if ((unint64_t)v4 >= v3)
  {
    if (a3)
    {
LABEL_7:
      uint64_t v9 = 0;
      *((void *)this + 2) = v4 - 1;
    }
    else
    {
LABEL_28:
      re::snapshot::Decoder::error((const char **)this, "expected data, found tag %x");
      return 0;
    }
  }
  else
  {
    uint64_t v6 = v4 + 1;
    *((void *)this + 2) = v4 + 1;
    int v7 = *v4;
    switch(*v4)
    {
      case 0x91u:
        if ((unsigned __int8 *)v3 != v6)
        {
          unint64_t v8 = v4[1];
          uint64_t v6 = v4 + 2;
          goto LABEL_14;
        }
        re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 1uLL, 0);
        goto LABEL_23;
      case 0x92u:
        unint64_t v10 = v3 - (void)v6;
        if (v10 > 1)
        {
          unint64_t v8 = *(unsigned __int16 *)(v4 + 1);
          uint64_t v6 = v4 + 3;
          goto LABEL_14;
        }
        uint64_t v11 = 2;
        goto LABEL_22;
      case 0x93u:
        unint64_t v10 = v3 - (void)v6;
        if (v10 > 3)
        {
          unint64_t v8 = *(unsigned int *)(v4 + 1);
          uint64_t v6 = v4 + 5;
          goto LABEL_14;
        }
        uint64_t v11 = 4;
        goto LABEL_22;
      case 0x94u:
        unint64_t v10 = v3 - (void)v6;
        if (v10 > 7)
        {
          unint64_t v8 = *(void *)(v4 + 1);
          uint64_t v6 = v4 + 9;
LABEL_14:
          *((void *)this + 2) = v6;
          goto LABEL_15;
        }
        uint64_t v11 = 8;
LABEL_22:
        re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", v11, v10);
LABEL_23:
        *a2 = 0;
        goto LABEL_24;
      default:
        if ((v7 + 111) <= 0xDEu)
        {
          ++v4;
          if (!a3) {
            goto LABEL_28;
          }
          goto LABEL_7;
        }
        unint64_t v8 = (v7 - 112);
LABEL_15:
        *a2 = v8;
        if (v3 - (unint64_t)v6 < v8)
        {
          re::snapshot::Decoder::error((const char **)this, "overrun in data: size_t size = %zu, only %zu bytes left");
          return 0;
        }
LABEL_24:
        uint64_t v9 = 1;
        break;
    }
  }
  return v9;
}

uint64_t re::snapshot::DecoderOPACK::beginDictionary(re::snapshot::DecoderOPACK *this, unint64_t *a2)
{
  int64x2_t v2 = (unsigned __int8 *)*((void *)this + 2);
  unint64_t v3 = *((void *)this + 3);
  if ((unint64_t)v2 >= v3) {
    goto LABEL_8;
  }
  uint64_t v4 = v2 + 1;
  *((void *)this + 2) = v2 + 1;
  int v5 = *v2;
  if ((v5 + 32) > 0xEu)
  {
    if (v5 == 239)
    {
      *a2 = -1;
      return 1;
    }
LABEL_8:
    re::snapshot::Decoder::error((const char **)this, "expected dictionary, found tag %x");
    return 0;
  }
  unint64_t v6 = (v5 - 224);
  *a2 = v6;
  if (v3 - (unint64_t)v4 >= v6) {
    return 1;
  }
  re::snapshot::Decoder::error((const char **)this, "overrun in beginDictionary: %zu items, only %zu bytes remaining");
  return 0;
}

BOOL re::snapshot::DecoderOPACK::endDictionary(re::snapshot::DecoderOPACK *this, unint64_t *a2)
{
  int64x2_t v2 = (unsigned char *)*((void *)this + 2);
  unint64_t v3 = *a2;
  if ((unint64_t)v2 >= *((void *)this + 3))
  {
    if (v3) {
      re::snapshot::Decoder::error((const char **)this, "reached end of buffer but expected more dictionary entries");
    }
  }
  else
  {
    if (v3 <= 0xE)
    {
      *a2 = v3 - 1;
      return v3 == 0;
    }
    if (*v2 != 3) {
      return 0;
    }
    *((void *)this + 2) = v2 + 1;
  }
  return 1;
}

uint64_t re::snapshot::DecoderOPACK::beginObject(re::snapshot::DecoderOPACK *this, const char **a2)
{
  unint64_t v3 = (unsigned __int8 *)*((void *)this + 2);
  unint64_t v4 = *((void *)this + 3);
  if ((unint64_t)v3 >= v4)
  {
    int v6 = 0;
    goto LABEL_13;
  }
  int v5 = v3 + 1;
  *((void *)this + 2) = v3 + 1;
  int v6 = *v3;
  if (v6 != 239)
  {
LABEL_13:
    re::snapshot::Decoder::error((const char **)this, "expected object, found tag %x", v6);
    return 0;
  }
  if ((unint64_t)v5 >= v4 || (int v8 = *v5, v8 == 3))
  {
    int Integer = 0x7FFFFFFF;
  }
  else if ((v8 - 7) > 0x28)
  {
    int Integer = re::snapshot::DecoderOPACK::readInteger(this, 0x7FFFFFFFLL);
  }
  else
  {
    *((void *)this + 2) = v3 + 2;
    int Integer = v8 - 8;
  }
  *((_DWORD *)this + 8) = Integer;
  if (a2)
  {
    unint64_t v10 = (const char *)*((void *)this + 7);
    *((void *)this + 7) = *a2;
    *a2 = v10;
  }
  return 1;
}

uint64_t *re::snapshot::DecoderOPACK::endObject(uint64_t *this, const char *a2)
{
  unint64_t v3 = this;
  unint64_t v4 = (unsigned __int8 *)this[2];
  for (unint64_t i = this[3]; (unint64_t)v4 < i; unint64_t i = v3[3])
  {
    _OWORD v3[2] = (uint64_t)(v4 + 1);
    int v6 = *v4;
    if (v6 == 3) {
      break;
    }
    this = re::snapshot::DecoderOPACK::skip(v3, v6);
    unint64_t v4 = (unsigned __int8 *)v3[2];
  }
  v3[7] = (uint64_t)a2;
  return this;
}

unsigned int *re::snapshot::EncoderOPACK::writeInteger(unsigned int *this, uint64_t a2)
{
  if (a2 != (int)a2)
  {
    uint64_t v3 = this[2];
    if (v3 + 9 > (unint64_t)this[3])
    {
      int v5 = this;
      uint64_t v6 = a2;
      this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v3 + 9);
      if (!this) {
        return this;
      }
      this = v5;
      a2 = v6;
      uint64_t v3 = v5[2];
    }
    uint64_t v4 = *(void *)this;
    this[2] = v3 + 1;
    *(unsigned char *)(v4 + v3) = 51;
    *(void *)(*(void *)this + this[2]) = a2;
    this[2] += 8;
    return this;
  }
  return re::snapshot::EncoderOPACK::writeInteger(this, a2);
}

unsigned int *re::snapshot::EncoderOPACK::beginData(unsigned int *this, unint64_t a2, unint64_t a3)
{
  uint64_t v4 = this;
  if (a3 > 0x20)
  {
    if (a3 > 0xFF)
    {
      unint64_t v12 = this[3];
      if (a3 >> 16)
      {
        uint64_t v16 = this[2];
        if (HIDWORD(a3))
        {
          if (v16 + 9 > v12)
          {
            this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v16 + 9);
            if (!this) {
              return this;
            }
            uint64_t v16 = v4[2];
          }
          uint64_t v20 = *(void *)v4;
          _DWORD v4[2] = v16 + 1;
          *(unsigned char *)(v20 + v16) = -108;
          *(void *)(*(void *)v4 + v4[2]) = a2;
          int v11 = v4[2] + 8;
LABEL_19:
          _DWORD v4[2] = v11;
          return this;
        }
        unint64_t v17 = v16 + 5;
        if (v16 + 5 <= v12)
        {
LABEL_15:
          if (HIDWORD(a2))
          {
            re::internal::assertLog((re::internal *)5, v17, "assertion failure: '%s' (%s:line %i) count %zu exceeds uint32_t capacity", "!overflow", "beginData", 163, a2);
            this = (unsigned int *)_os_crash();
            __break(1u);
            return this;
          }
          uint64_t v18 = *(void *)v4;
          uint64_t v19 = v4[2];
          _DWORD v4[2] = v19 + 1;
          *(unsigned char *)(v18 + v19) = -109;
          *(_DWORD *)(*(void *)v4 + v4[2]) = a2;
          int v11 = v4[2] + 4;
          goto LABEL_19;
        }
LABEL_30:
        this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)v4, v17);
        if (!this) {
          return this;
        }
        goto LABEL_15;
      }
      unint64_t v13 = this[2] + 3;
      if (v13 <= v12)
      {
LABEL_11:
        if (a2 < 0x10000)
        {
          uint64_t v14 = *(void *)v4;
          uint64_t v15 = v4[2];
          _DWORD v4[2] = v15 + 1;
          *(unsigned char *)(v14 + v15) = -110;
          *(_WORD *)(*(void *)v4 + v4[2]) = a2;
          int v11 = v4[2] + 2;
          goto LABEL_19;
        }
        re::internal::assertLog((re::internal *)5, v13, "assertion failure: '%s' (%s:line %i) count %zu exceeds uint16_t capacity", "!overflow", "beginData", 155, a2);
        _os_crash();
        __break(1u);
        goto LABEL_30;
      }
    }
    else
    {
      unint64_t v8 = this[2] + 2;
      if (v8 > this[3])
      {
        this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v8);
        if (!this) {
          return this;
        }
      }
      if (a2 < 0x100)
      {
        uint64_t v9 = *(void *)v4;
        uint64_t v10 = v4[2];
        _DWORD v4[2] = v10 + 1;
        *(unsigned char *)(v9 + v1ArcSharedObject::ArcSharedObject(this, 0) = -111;
        *(unsigned char *)(*(void *)v4 + v4[2]) = a2;
        int v11 = v4[2] + 1;
        goto LABEL_19;
      }
      re::internal::assertLog((re::internal *)5, v8, "assertion failure: '%s' (%s:line %i) count %zu exceeds uint8_t capacity", "!overflow", "beginData", 147, a2);
      _os_crash();
      __break(1u);
    }
    this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)v4, v13);
    if (!this) {
      return this;
    }
    goto LABEL_11;
  }
  unint64_t v5 = a2 + 112;
  if (a2 + 112 >= 0x100)
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) tag %zu exceeds uint8_t capacity", "!overflow", "beginData", 141, v5);
    _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v6 = this[2];
    if (v6 < this[3])
    {
LABEL_4:
      uint64_t v7 = *(void *)v4;
      _DWORD v4[2] = v6 + 1;
      *(unsigned char *)(v7 + v6) = v5;
      return this;
    }
  }
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)v4, v6 + 1);
  if (this)
  {
    LODWORD(v6) = v4[2];
    goto LABEL_4;
  }
  return this;
}

unsigned int *re::snapshot::EncoderOPACK::writeInteger(unsigned int *this, int a2)
{
  char v2 = a2;
  uint64_t v3 = this;
  if ((a2 + 1) > 0x28)
  {
    uint64_t v6 = this[2];
    if (v6 + 2 > (unint64_t)this[3])
    {
      this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v6 + 2);
      if (!this) {
        return this;
      }
      uint64_t v6 = v3[2];
    }
    uint64_t v7 = *(void *)v3;
    _OWORD v3[2] = v6 + 1;
    *(unsigned char *)(v7 + v6) = 48;
    *(unsigned char *)(*(void *)v3 + v3[2]++) = v2;
    return this;
  }
  uint64_t v4 = this[2];
  if (v4 < this[3])
  {
LABEL_3:
    uint64_t v5 = *(void *)v3;
    _OWORD v3[2] = v4 + 1;
    *(unsigned char *)(v5 + v4) = v2 + 8;
    return this;
  }
  this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v4 + 1);
  if (this)
  {
    LODWORD(v4) = v3[2];
    goto LABEL_3;
  }
  return this;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  __int16 v6;

  if (a2 != (char)a2)
  {
    uint64_t v3 = this[2];
    if (v3 + 3 > (unint64_t)this[3])
    {
      uint64_t v6 = a2;
      uint64_t v5 = this;
      this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v3 + 3);
      if (!this) {
        return this;
      }
      this = v5;
      uint64_t v3 = v5[2];
      LOWORD(a2) = v6;
    }
    uint64_t v4 = *(void *)this;
    this[2] = v3 + 1;
    *(unsigned char *)(v4 + v3) = 49;
    *(_WORD *)(*(void *)this + this[2]) = a2;
    this[2] += 2;
    return this;
  }
  a2 = (char)a2;
  return re::snapshot::EncoderOPACK::writeInteger(this, a2);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  int v6;

  if (a2 != (__int16)a2)
  {
    uint64_t v3 = this[2];
    if (v3 + 5 > (unint64_t)this[3])
    {
      uint64_t v6 = a2;
      uint64_t v5 = this;
      this = (unsigned int *)re::snapshot::Encoder::grow((re::snapshot::Encoder *)this, v3 + 5);
      if (!this) {
        return this;
      }
      this = v5;
      uint64_t v3 = v5[2];
      a2 = v6;
    }
    uint64_t v4 = *(void *)this;
    this[2] = v3 + 1;
    *(unsigned char *)(v4 + v3) = 50;
    *(_DWORD *)(*(void *)this + this[2]) = a2;
    this[2] += 4;
    return this;
  }
  return re::snapshot::EncoderOPACK::writeInteger(this, (__int16)a2);
}

uint64_t *re::snapshot::DecoderOPACK::skip(uint64_t *result, int a2)
{
  char v2 = result;
  if (a2 <= 96)
  {
    switch(a2)
    {
      case '0':
        uint64_t v3 = result[2] + 1;
        goto LABEL_48;
      case '1':
        uint64_t v3 = result[2] + 2;
        goto LABEL_48;
      case '2':
      case '5':
        uint64_t v3 = result[2] + 4;
        goto LABEL_48;
      case '3':
      case '6':
        uint64_t v3 = result[2] + 8;
        goto LABEL_48;
      case '4':
        goto LABEL_35;
      default:
        if ((a2 - 1) < 2 || a2 == 4) {
          return result;
        }
LABEL_35:
        if ((a2 - 7) < 0x29) {
          return result;
        }
        uint64_t v25 = (a2 - 64);
        if (v25 <= 0x20 || (uint64_t v25 = (a2 - 112), v25 <= 0x20))
        {
          uint64_t v3 = result[2] + v25;
          goto LABEL_48;
        }
        if ((a2 + 48) > 0xEu)
        {
          if ((a2 + 32) > 0xEu)
          {
            int64x2_t result = re::snapshot::Decoder::error((const char **)result, "unexpected tag while skipping: %x", a2);
          }
          else if (a2 >= 0xE1)
          {
            int v30 = a2 - 223;
            do
            {
              BOOL v31 = (unsigned __int8 *)v2[2];
              if ((unint64_t)v31 >= v2[3])
              {
                uint64_t v32 = 0;
              }
              else
              {
                _OWORD v2[2] = (uint64_t)(v31 + 1);
                uint64_t v32 = *v31;
              }
              re::snapshot::DecoderOPACK::skip(v2, v32);
              uint64_t v33 = (unsigned __int8 *)v2[2];
              if ((unint64_t)v33 >= v2[3])
              {
                uint64_t v34 = 0;
              }
              else
              {
                _OWORD v2[2] = (uint64_t)(v33 + 1);
                uint64_t v34 = *v33;
              }
              int64x2_t result = (uint64_t *)re::snapshot::DecoderOPACK::skip(v2, v34);
              --v30;
            }
            while (v30 > 1);
          }
        }
        else if (a2 >= 0xD1)
        {
          int v27 = a2 - 207;
          do
          {
            unint64_t v28 = (unsigned __int8 *)v2[2];
            if ((unint64_t)v28 >= v2[3])
            {
              uint64_t v29 = 0;
            }
            else
            {
              _OWORD v2[2] = (uint64_t)(v28 + 1);
              uint64_t v29 = *v28;
            }
            int64x2_t result = (uint64_t *)re::snapshot::DecoderOPACK::skip(v2, v29);
            --v27;
          }
          while (v27 > 1);
        }
        break;
    }
  }
  else if (a2 <= 144)
  {
    switch(a2)
    {
      case 'a':
LABEL_7:
        uint64_t v4 = (unsigned __int8 *)result[2];
        uint64_t v5 = (unsigned __int8 *)result[3];
        if (v5 != v4)
        {
          unsigned int v8 = *v4;
          uint64_t v6 = v4 + 1;
          unint64_t v7 = v8;
          goto LABEL_30;
        }
        int64x2_t result = re::snapshot::Decoder::error((const char **)result, "overrun: attempted to read %zu bytes, only %zu remaining", 1uLL, 0);
        goto LABEL_46;
      case 'b':
LABEL_26:
        uint64_t v16 = (unsigned __int8 *)result[2];
        uint64_t v5 = (unsigned __int8 *)result[3];
        uint64_t v17 = v5 - v16;
        if ((unint64_t)(v5 - v16) > 1)
        {
          unsigned int v18 = *(unsigned __int16 *)v16;
          uint64_t v6 = v16 + 2;
          unint64_t v7 = v18;
          goto LABEL_30;
        }
        uint64_t v26 = 2;
        goto LABEL_44;
      case 'c':
LABEL_28:
        uint64_t v19 = (unsigned __int8 *)result[2];
        uint64_t v5 = (unsigned __int8 *)result[3];
        uint64_t v17 = v5 - v19;
        if ((unint64_t)(v5 - v19) <= 3)
        {
          uint64_t v26 = 4;
          goto LABEL_44;
        }
        unsigned int v20 = *(_DWORD *)v19;
        uint64_t v6 = v19 + 4;
        unint64_t v7 = v20;
LABEL_30:
        result[2] = (uint64_t)v6;
        unint64_t v21 = v5 - v6;
        if (v21 >= v7) {
          goto LABEL_47;
        }
        goto LABEL_34;
      case 'd':
LABEL_32:
        int v22 = (void *)result[2];
        uint64_t v23 = result[3];
        uint64_t v17 = v23 - (void)v22;
        if ((unint64_t)(v23 - (void)v22) <= 7)
        {
          uint64_t v26 = 8;
LABEL_44:
          int64x2_t result = re::snapshot::Decoder::error((const char **)result, "overrun: attempted to read %zu bytes, only %zu remaining", v26, v17);
LABEL_46:
          unint64_t v7 = 0;
          uint64_t v6 = (unsigned __int8 *)v2[2];
        }
        else
        {
          unint64_t v24 = *v22;
          uint64_t v6 = (unsigned __int8 *)(v22 + 1);
          unint64_t v7 = v24;
          result[2] = (uint64_t)v6;
          unint64_t v21 = v23 - (void)v6;
          if (v24 > v21)
          {
LABEL_34:
            int64x2_t result = re::snapshot::Decoder::error((const char **)result, "invalid size when skipping string or data: %zu, only %zu remaining", v7, v21);
            uint64_t v6 = (unsigned __int8 *)v2[2];
            unint64_t v7 = v2[3] - (void)v6;
          }
        }
LABEL_47:
        uint64_t v3 = (uint64_t)&v6[v7];
        break;
      default:
        goto LABEL_35;
    }
LABEL_48:
    _OWORD v2[2] = v3;
  }
  else
  {
    switch(a2)
    {
      case 145:
        goto LABEL_7;
      case 146:
        goto LABEL_26;
      case 147:
        goto LABEL_28;
      case 148:
        goto LABEL_32;
      default:
        if (a2 != 223 && a2 != 239) {
          goto LABEL_35;
        }
        uint64_t v10 = (unsigned __int8 *)result[2];
        unint64_t v9 = result[3];
        if ((unint64_t)v10 >= v9)
        {
          int v11 = 0;
        }
        else
        {
          result[2] = (uint64_t)(v10 + 1);
          int v11 = *v10++;
        }
        if ((unint64_t)v10 < v9 && v11 != 3)
        {
          do
          {
            int64x2_t result = (uint64_t *)re::snapshot::DecoderOPACK::skip(v2, v11);
            unint64_t v12 = (unsigned __int8 *)v2[2];
            unint64_t v13 = v2[3];
            if ((unint64_t)v12 >= v13) {
              break;
            }
            uint64_t v14 = v12 + 1;
            _OWORD v2[2] = (uint64_t)(v12 + 1);
            int v11 = *v12;
          }
          while ((unint64_t)v14 < v13 && v11 != 3);
        }
        break;
    }
  }
  return result;
}

uint64_t re::snapshot::DecoderOPACK::readInteger(re::snapshot::DecoderOPACK *this, uint64_t a2)
{
  uint64_t v3 = (unsigned __int8 *)*((void *)this + 2);
  unint64_t v4 = *((void *)this + 3);
  if ((unint64_t)v3 >= v4)
  {
LABEL_18:
    re::snapshot::Decoder::error((const char **)this, "expected integer, found tag %x");
  }
  else
  {
    uint64_t v5 = v3 + 1;
    *((void *)this + 2) = v3 + 1;
    int v6 = *v3;
    switch(*v3)
    {
      case '0':
        if ((unint64_t)v5 < v4)
        {
          *((void *)this + 2) = v3 + 2;
          a2 = (char)v3[1];
        }
        break;
      case '1':
        unint64_t v7 = v4 - (void)v5;
        if (v7 <= 1)
        {
          re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 2uLL, v7);
        }
        else
        {
          LOWORD(a2) = *(_WORD *)(v3 + 1);
          *((void *)this + 2) = v3 + 3;
        }
        a2 = (__int16)a2;
        break;
      case '2':
        unint64_t v8 = v4 - (void)v5;
        if (v8 <= 3)
        {
          re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 4uLL, v8);
        }
        else
        {
          LODWORD(a2) = *(_DWORD *)(v3 + 1);
          *((void *)this + 2) = v3 + 5;
        }
        a2 = (int)a2;
        break;
      case '3':
        if (v4 - (unint64_t)v5 <= 7)
        {
          re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining");
        }
        else
        {
          a2 = *(void *)(v3 + 1);
          *((void *)this + 2) = v3 + 9;
        }
        break;
      default:
        if ((v6 - 7) > 0x28) {
          goto LABEL_18;
        }
        a2 = (char)(v6 - 8);
        break;
    }
  }
  return a2;
}

uint64_t re::profilerThreadContext(re *this)
{
  if ((*(unsigned char *)v2 & 1) == 0)
  {
    re::ProfilerThreadContext::ProfilerThreadContext(v2);
    unint64_t v4 = (void *)re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
    _tlv_atexit((void (__cdecl *)(void *))re::ProfilerThreadContext::~ProfilerThreadContext, v4);
  }
  return re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
}

void re::ProfilerThreadContext::~ProfilerThreadContext(re::ProfilerThreadContext *this)
{
  char v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 12);
  if (v3)
  {
    *((void *)this + 13) = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 9);
  if (v4)
  {
    *((void *)this + 1ArcSharedObject::ArcSharedObject(this, 0) = v4;
    operator delete(v4);
  }
}

void re::ProfilerThreadContext::ProfilerThreadContext(re::ProfilerThreadContext *this)
{
  uint64_t v1 = re::profilerThreadContext(void)::context;
  uint64_t v2 = re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
  *(unsigned char *)uint64_t v2 = 0;
  *(void *)(v2 + 64) = atomic_fetch_add(&re::ProfilerThreadContext::s_threadId, 1uLL);
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 104) = 0u;
  *(_OWORD *)(v2 + 12ArcSharedObject::ArcSharedObject(this, 0) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + re::DynamicArray<re::SyncCommit>::deinit((uint64_t)this + 168) = 0u;
  *(unsigned char *)(v2 + 184) = 0;
  uint64_t v3 = pthread_self();
  if (pthread_getname_np(v3, (char *)v2, 0x40uLL)) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = *(unsigned char *)v2 == 0;
  }
  if (v4)
  {
    pthread_t v16 = pthread_self();
    uint64_t v5 = (char *)v1(&re::profilerThreadContext(void)::context);
    snprintf(v5, 0x40uLL, "Thread %p", v16);
  }
  uint64_t v6 = v1(&re::profilerThreadContext(void)::context);
  *(void *)(v6 + 176) = 0;
  *(_OWORD *)(v6 + 144) = 0u;
  *(_OWORD *)(v6 + 16ArcSharedObject::ArcSharedObject(this, 0) = 0u;
  unint64_t v7 = *(void *)(v6 + 96);
  if (*(void *)(v6 + 112) - v7 <= 0x1F)
  {
    unint64_t v8 = *(char **)(v1(&re::profilerThreadContext(void)::context) + 104);
    unint64_t v9 = operator new(0x20uLL);
    if (v8 != (char *)v7)
    {
      uint64_t v10 = &v8[~v7];
      do
      {
        char v11 = *--v8;
        (v10--)[(void)v9] = v11;
      }
      while (v8 != (char *)v7);
    }
    unint64_t v12 = (void *)v1(&re::profilerThreadContext(void)::context);
    unsigned char v12[12] = v14;
    v12[13] = v13;
    v12[14] = v15;
    if (v7)
    {
      operator delete((void *)v7);
    }
  }
}

uint64_t re::ProfilerConfig::isStatisticCollectionEnabled(re::ProfilerConfig *this)
{
  uint64_t v1 = &re::StackScratchAllocator::s_rootsWithPersistentBlocks[56];
  {
    uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    if (v3)
    {
      re::Defaults::BOOLValue((re::Defaults *)"profiler.statisticcollection.enable", v4, v6);
      char v5 = v6[1];
      if (!v6[0]) {
        char v5 = 1;
      }
      re::ProfilerConfig::isStatisticCollectionEnabled(void)::enabled = v5;
      uint64_t v1 = re::StackScratchAllocator::s_rootsWithPersistentBlocks + 448;
    }
  }
  return *((unsigned __int8 *)v1 + 1936);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x270EE4278]();
  return result;
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x270ED7CD8](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

std::__thread_struct *__cdecl std::__thread_struct::__thread_struct(std::__thread_struct *this)
{
  return (std::__thread_struct *)MEMORY[0x270F98898](this);
}

void std::__thread_struct::~__thread_struct(std::__thread_struct *this)
{
}

void std::recursive_mutex::lock(std::recursive_mutex *this)
{
}

void std::recursive_mutex::unlock(std::recursive_mutex *this)
{
}

std::recursive_mutex *__cdecl std::recursive_mutex::recursive_mutex(std::recursive_mutex *this)
{
  return (std::recursive_mutex *)MEMORY[0x270F98900](this);
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
}

std::__thread_specific_ptr<std::__thread_struct> *std::__thread_local_data(void)
{
  return (std::__thread_specific_ptr<std::__thread_struct> *)MEMORY[0x270F989F8]();
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x270F98C18]();
}

void std::thread::join(std::thread *this)
{
}

void std::thread::~thread(std::thread *this)
{
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete(void *__p, std::align_val_t a2)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x270ED7DA0](lpfunc, obj, lpdso_handle);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

int *__error(void)
{
  return (int *)MEMORY[0x270ED7DC0]();
}

uint64_t _os_crash()
{
  return MEMORY[0x270ED8060]();
}

uint64_t _os_crash_msg()
{
  return MEMORY[0x270ED8068]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x270ED80B0]();
}

void _tlv_atexit(void (__cdecl *termFunc)(void *), void *objAddr)
{
}

void abort(void)
{
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x270ED8478](*(void *)&a1, a2, a3);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x270ED8758](*(void *)&a1, a2, *(void *)&a3);
}

void bzero(void *a1, size_t a2)
{
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  return MEMORY[0x270F9A400](cls, name, imp, types);
}

int close(int a1)
{
  return MEMORY[0x270ED8F18](*(void *)&a1);
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x270F98F48](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(void *)&algorithm);
}

size_t compression_decode_scratch_buffer_size(compression_algorithm algorithm)
{
  return MEMORY[0x270F98F50](*(void *)&algorithm);
}

size_t compression_encode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x270F98F58](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(void *)&algorithm);
}

size_t compression_encode_scratch_buffer_size(compression_algorithm algorithm)
{
  return MEMORY[0x270F98F60](*(void *)&algorithm);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x270ED8F58](*(void *)&a1, a2, *(void *)&a3);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  return MEMORY[0x270ED92B8](data, applier);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x270ED92D0](buffer, size, queue, destructor);
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return MEMORY[0x270ED9300](data);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9448](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9458](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x270ED9468](label, attr, target);
}

void *__cdecl dispatch_queue_get_specific(dispatch_queue_t queue, const void *key)
{
  return (void *)MEMORY[0x270ED9480](queue, key);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x270ED94B8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x270ED94C8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x270ED94D0](dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x270ED98D0](*(void *)&a1, *(void *)&a2);
}

void free(void *a1)
{
}

void freeaddrinfo(addrinfo *a1)
{
}

void freeifaddrs(ifaddrs *a1)
{
}

const char *__cdecl gai_strerror(int a1)
{
  return (const char *)MEMORY[0x270ED9B90](*(void *)&a1);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return MEMORY[0x270ED9B98](a1, a2, a3, a4);
}

int getifaddrs(ifaddrs **a1)
{
  return MEMORY[0x270ED9C68](a1);
}

int getpeername(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x270ED9CD0](*(void *)&a1, a2, a3);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x270ED9D88](*(void *)&a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return MEMORY[0x270ED9D90](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, a5);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x270ED9EC0](*(void *)&a1, a2, a3, *(void *)&a4);
}

int inet_pton(int a1, const char *a2, void *a3)
{
  return MEMORY[0x270ED9EC8](*(void *)&a1, a2, a3);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x270ED9F50]();
}

int kevent64(int kq, const kevent64_s *changelist, int nchanges, kevent64_s *eventlist, int nevents, unsigned int flags, const timespec *timeout)
{
  return MEMORY[0x270ED9F68](*(void *)&kq, changelist, *(void *)&nchanges, eventlist, *(void *)&nevents, *(void *)&flags, timeout);
}

int kqueue(void)
{
  return MEMORY[0x270ED9F90]();
}

int listen(int a1, int a2)
{
  return MEMORY[0x270EDA078](*(void *)&a1, *(void *)&a2);
}

malloc_zone_t *__cdecl malloc_create_zone(vm_size_t start_size, unsigned int flags)
{
  return (malloc_zone_t *)MEMORY[0x270EDA330](start_size, *(void *)&flags);
}

void malloc_destroy_zone(malloc_zone_t *zone)
{
}

void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
{
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x270EDA398](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA3C0](zone, alignment, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

void nw_connection_batch(nw_connection_t connection, dispatch_block_t batch_block)
{
}

void nw_connection_cancel(nw_connection_t connection)
{
}

nw_endpoint_t nw_connection_copy_endpoint(nw_connection_t connection)
{
  return (nw_endpoint_t)MEMORY[0x270EF7B80](connection);
}

nw_connection_t nw_connection_create(nw_endpoint_t endpoint, nw_parameters_t parameters)
{
  return (nw_connection_t)MEMORY[0x270EF7BA8](endpoint, parameters);
}

nw_data_transfer_report_t nw_connection_create_new_data_transfer_report(nw_connection_t connection)
{
  return (nw_data_transfer_report_t)MEMORY[0x270EF7BB8](connection);
}

uint64_t nw_connection_create_with_connected_socket_and_parameters()
{
  return MEMORY[0x270EF7BC8]();
}

void nw_connection_force_cancel(nw_connection_t connection)
{
}

void nw_connection_receive_message(nw_connection_t connection, nw_connection_receive_completion_t completion)
{
}

void nw_connection_send(nw_connection_t connection, dispatch_data_t content, nw_content_context_t context, BOOL is_complete, nw_connection_send_completion_t completion)
{
}

void nw_connection_set_queue(nw_connection_t connection, dispatch_queue_t queue)
{
}

void nw_connection_set_state_changed_handler(nw_connection_t connection, nw_connection_state_changed_handler_t handler)
{
}

void nw_connection_start(nw_connection_t connection)
{
}

uint64_t nw_connection_state_to_string()
{
  return MEMORY[0x270EF7D30]();
}

nw_protocol_metadata_t nw_content_context_copy_protocol_metadata(nw_content_context_t context, nw_protocol_definition_t protocol)
{
  return (nw_protocol_metadata_t)MEMORY[0x270EF7D40](context, protocol);
}

nw_content_context_t nw_content_context_create(const char *context_identifier)
{
  return (nw_content_context_t)MEMORY[0x270EF7D50](context_identifier);
}

BOOL nw_content_context_get_is_final(nw_content_context_t context)
{
  return MEMORY[0x270EF7D68](context);
}

void nw_content_context_set_metadata_for_protocol(nw_content_context_t context, nw_protocol_metadata_t protocol_metadata)
{
}

uint64_t nw_context_create()
{
  return MEMORY[0x270EF7DE0]();
}

uint64_t nw_context_set_isolate_protocol_stack()
{
  return MEMORY[0x270EF7E00]();
}

uint64_t nw_context_set_scheduling_mode()
{
  return MEMORY[0x270EF7E10]();
}

void nw_data_transfer_report_collect(nw_data_transfer_report_t report, dispatch_queue_t queue, nw_data_transfer_report_collect_block_t collect_block)
{
}

uint64_t nw_data_transfer_report_get_received_ip_packet_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x270EF7E20](report, *(void *)&path_index);
}

uint64_t nw_data_transfer_report_get_received_transport_byte_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x270EF7E28](report, *(void *)&path_index);
}

uint64_t nw_data_transfer_report_get_sent_ip_packet_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x270EF7E30](report, *(void *)&path_index);
}

uint64_t nw_data_transfer_report_get_sent_transport_byte_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x270EF7E38](report, *(void *)&path_index);
}

uint64_t nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  return MEMORY[0x270EF7E40](report, *(void *)&path_index);
}

uint64_t nw_endpoint_create_host_with_numeric_port()
{
  return MEMORY[0x270EF7EB8]();
}

uint64_t nw_endpoint_get_description()
{
  return MEMORY[0x270EF7F10]();
}

const char *__cdecl nw_endpoint_get_hostname(nw_endpoint_t endpoint)
{
  return (const char *)MEMORY[0x270EF7F30](endpoint);
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  return MEMORY[0x270EF7F48](endpoint);
}

int nw_error_get_error_code(nw_error_t error)
{
  return MEMORY[0x270EF7FD0](error);
}

nw_error_domain_t nw_error_get_error_domain(nw_error_t error)
{
  return MEMORY[0x270EF7FD8](error);
}

nw_protocol_definition_t nw_framer_create_definition(const char *identifier, uint32_t flags, nw_framer_start_handler_t start_handler)
{
  return (nw_protocol_definition_t)MEMORY[0x270EF8120](identifier, *(void *)&flags, start_handler);
}

nw_protocol_options_t nw_framer_create_options(nw_protocol_definition_t framer_definition)
{
  return (nw_protocol_options_t)MEMORY[0x270EF8130](framer_definition);
}

BOOL nw_framer_deliver_input_no_copy(nw_framer_t framer, size_t input_length, nw_framer_message_t message, BOOL is_complete)
{
  return MEMORY[0x270EF8150](framer, input_length, message, is_complete);
}

BOOL nw_framer_message_access_value(nw_framer_message_t message, const char *key, void *access_value)
{
  return MEMORY[0x270EF8168](message, key, access_value);
}

nw_framer_message_t nw_framer_message_create(nw_framer_t framer)
{
  return (nw_framer_message_t)MEMORY[0x270EF8170](framer);
}

void nw_framer_message_set_value(nw_framer_message_t message, const char *key, void *value, nw_framer_message_dispose_value_t dispose_value)
{
}

BOOL nw_framer_parse_input(nw_framer_t framer, size_t minimum_incomplete_length, size_t maximum_length, uint8_t *temp_buffer, nw_framer_parse_completion_t parse)
{
  return MEMORY[0x270EF8190](framer, minimum_incomplete_length, maximum_length, temp_buffer, parse);
}

nw_framer_message_t nw_framer_protocol_create_message(nw_protocol_definition_t definition)
{
  return (nw_framer_message_t)MEMORY[0x270EF81A0](definition);
}

void nw_framer_set_input_handler(nw_framer_t framer, nw_framer_input_handler_t input_handler)
{
}

void nw_framer_set_output_handler(nw_framer_t framer, nw_framer_output_handler_t output_handler)
{
}

void nw_framer_write_output(nw_framer_t framer, const uint8_t *output_buffer, size_t output_length)
{
}

BOOL nw_framer_write_output_no_copy(nw_framer_t framer, size_t output_length)
{
  return MEMORY[0x270EF81D8](framer, output_length);
}

void nw_listener_cancel(nw_listener_t listener)
{
}

nw_listener_t nw_listener_create(nw_parameters_t parameters)
{
  return (nw_listener_t)MEMORY[0x270EF8410](parameters);
}

nw_listener_t nw_listener_create_with_port(const char *port, nw_parameters_t parameters)
{
  return (nw_listener_t)MEMORY[0x270EF8420](port, parameters);
}

uint16_t nw_listener_get_port(nw_listener_t listener)
{
  return MEMORY[0x270EF8428](listener);
}

void nw_listener_set_new_connection_handler(nw_listener_t listener, nw_listener_new_connection_handler_t handler)
{
}

void nw_listener_set_queue(nw_listener_t listener, dispatch_queue_t queue)
{
}

void nw_listener_set_state_changed_handler(nw_listener_t listener, nw_listener_state_changed_handler_t handler)
{
}

void nw_listener_start(nw_listener_t listener)
{
}

nw_parameters_t nw_parameters_copy(nw_parameters_t parameters)
{
  return (nw_parameters_t)MEMORY[0x270EF84D8](parameters);
}

nw_protocol_stack_t nw_parameters_copy_default_protocol_stack(nw_parameters_t parameters)
{
  return (nw_protocol_stack_t)MEMORY[0x270EF84F8](parameters);
}

nw_parameters_t nw_parameters_create(void)
{
  return (nw_parameters_t)MEMORY[0x270EF8518]();
}

uint64_t nw_parameters_set_context()
{
  return MEMORY[0x270EF8610]();
}

void nw_parameters_set_local_endpoint(nw_parameters_t parameters, nw_endpoint_t local_endpoint)
{
}

uint64_t nw_parameters_set_no_delay()
{
  return MEMORY[0x270EF86B8]();
}

void nw_parameters_set_reuse_local_address(nw_parameters_t parameters, BOOL reuse_local_address)
{
}

BOOL nw_protocol_metadata_is_framer_message(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x270EF8F30](metadata);
}

void nw_protocol_stack_prepend_application_protocol(nw_protocol_stack_t stack, nw_protocol_options_t protocol)
{
}

void nw_protocol_stack_set_transport_protocol(nw_protocol_stack_t stack, nw_protocol_options_t protocol)
{
}

nw_protocol_options_t nw_tcp_create_options(void)
{
  return (nw_protocol_options_t)MEMORY[0x270EF94D8]();
}

void nw_tcp_options_set_enable_keepalive(nw_protocol_options_t options, BOOL enable_keepalive)
{
}

void nw_tcp_options_set_keepalive_count(nw_protocol_options_t options, uint32_t keepalive_count)
{
}

void nw_tcp_options_set_keepalive_idle_time(nw_protocol_options_t options, uint32_t keepalive_idle_time)
{
}

void nw_tcp_options_set_keepalive_interval(nw_protocol_options_t options, uint32_t keepalive_interval)
{
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x270F9A550](superclass, name, extraBytes);
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

id objc_constructInstance(Class cls, void *bytes)
{
  return (id)MEMORY[0x270F9A5B8](cls, bytes);
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void *__cdecl objc_destructInstance(id obj)
{
  return (void *)MEMORY[0x270F9A600](obj);
}

void objc_enumerationMutation(id obj)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x270F9A658](name);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x270F9A688](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x270F9A6B0](location);
}

void objc_moveWeak(id *to, id *from)
{
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

void objc_registerClassPair(Class cls)
{
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A890](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x270F9A898](a1);
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x270F9A9F8](location, obj);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

uint64_t os_log_with_args()
{
  return MEMORY[0x270EDA9E0]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x270EDAEA0](a1, a2, a3, a4);
}

int pthread_getname_np(pthread_t a1, char *a2, size_t a3)
{
  return MEMORY[0x270EDAEE0](a1, a2, a3);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x270EDB010]();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x270EDB048](a1, a2);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return MEMORY[0x270EDB190](*(void *)&a1, a2, a3, *(void *)&a4);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x270EDB3B0](*(void *)&a1, a2, a3, *(void *)&a4);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x270EDB440](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, *(void *)&a5);
}

int shutdown(int a1, int a2)
{
  return MEMORY[0x270EDB480](*(void *)&a1, *(void *)&a2);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x270EDB520](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x270EDB560](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x270EDB5C0](__dst, __src);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x270EDB5D8](*(void *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x270EDB638](__s1, __s2, __n);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB6D8](__str, __endptr, *(void *)&__base);
}

void uuid_generate_random(uuid_t out)
{
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x270EDBB18](__str, __size, __format, a4);
}