void sub_100002308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_100002324(void *a1, uint64_t a2)
{
  if (a2)
  {
    *(void *)(*(void *)(a1[6] + 8) + 24) = a2;
    objc_msgSend(*(id *)(a1[4] + 8), "log:format:", 7, @"%s Failed to download asset with result %ld", "-[Haywire findRemoteAsset]_block_invoke", a2);
  }
  v3 = a1[5];
  return dispatch_semaphore_signal(v3);
}

intptr_t sub_100002588(uint64_t a1, uint64_t a2)
{
  v4 = *(void **)(*(void *)(a1 + 32) + 8);
  [+[NSDate date] timeIntervalSinceReferenceDate];
  objc_msgSend(v4, "log:format:", 7, @"[%f] query complete", v5, "-[Haywire _findAsset:]_block_invoke");
  if (a2) {
    [*(id *)(a1 + 32) setError:a2];
  }
  v6 = *(NSObject **)(a1 + 40);
  return dispatch_semaphore_signal(v6);
}

NSError *sub_10000261C(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v10 = [objc_alloc((Class)NSString) initWithFormat:a2 arguments:&a9];
  id v17 = +[NSMutableDictionary dictionary];
  if (v10)
  {
    AMRLog(3, @"%@", v11, v12, v13, v14, v15, v16, (char)v10);
    [v17 setObject:v10 forKey:NSLocalizedDescriptionKey];
  }
  return +[NSError errorWithDomain:@"HaywireErrorDomain" code:a1 userInfo:v17];
}

CFTypeRef sub_1000029B0(const __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMRLog(7, @"%s", a3, a4, a5, a6, a7, a8, (char)"CFDictionaryRef createBootstrapOptionsDictionary(NSString *, NSString *, NSString *, uint32_t, uint32_t)");
  CFTypeRef v27 = 0;
  CFPropertyListRef v13 = CFPreferencesCopyAppValue(@"RestoreBootArgs", kCFPreferencesCurrentApplication);
  uint64_t v14 = v13;
  if (v13) {
    uint64_t v15 = v13;
  }
  else {
    uint64_t v15 = (const void *)a3;
  }
  CFPropertyListRef v16 = CFPreferencesCopyAppValue(@"DeviceTreeFile", kCFPreferencesCurrentApplication);
  CFPropertyListRef v17 = CFPreferencesCopyAppValue(@"BootImageFile", kCFPreferencesCurrentApplication);
  CFPropertyListRef v18 = CFPreferencesCopyAppValue(@"RestoreKernelCacheFile", kCFPreferencesCurrentApplication);
  int v19 = AMRAuthInstallCreateOptionsForBootstrapDevice(a1, a2, a4, a5, v15, (uint64_t)v16, (uint64_t)v17, (uint64_t)v18, &v27);
  if (v19) {
    AMRLog(5, @"AMRAuthInstallCreateOptionsForBootstrapDevice failed %d\n", v20, v21, v22, v23, v24, v25, v19);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v14) {
    CFRelease(v14);
  }
  return v27;
}

void sub_100002B04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100002DE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

id sub_100003300(id result, void *a2)
{
  if (a2) {
    return [a2 dfuDeviceConnected:result];
  }
  return result;
}

id sub_100003314(id result, void *a2)
{
  if (a2) {
    return [a2 recoveryDeviceConnected:result];
  }
  return result;
}

id sub_100003328(id result, void *a2)
{
  if (a2) {
    return [a2 dfuDeviceDisconnected:result];
  }
  return result;
}

id sub_10000333C(id result, void *a2)
{
  if (a2) {
    return [a2 recoveryDeviceDisconnected:result];
  }
  return result;
}

void sub_100003350(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    [a2 deviceError:a1];
  }
  else
  {
    AMRLog(3, @"error %d processing device (updater is nil)\n", a1, a4, a5, a6, a7, a8, a1);
  }
}

id sub_100003558(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!*(void *)(v4 + 32))
  {
    [*(id *)(v4 + 8) log:3, @"%s error: _maxRemoteBuildNumber=%@ _maxLocalBuildNumber=%@", "-[Haywire findFirmwareWithOptions:remote:]_block_invoke", 0, *(void *)(v4 + 24) format];
    uint64_t v8 = 0;
    if (!a2) {
      goto LABEL_13;
    }
    goto LABEL_10;
  }
  uint64_t v5 = *(void **)(v4 + 24);
  if (v5)
  {
    id v6 = objc_msgSend(v5, "compare:options:");
    uint64_t v4 = *(void *)(a1 + 32);
    v7 = *(void **)(v4 + 8);
    if (v6 != (id)-1)
    {
      uint64_t v8 = 0;
      v9 = "No";
      goto LABEL_9;
    }
  }
  else
  {
    v7 = *(void **)(v4 + 8);
  }
  v9 = "Yes";
  uint64_t v8 = 1;
LABEL_9:
  [v7 log:5, @"%s updateAvailable (%s) (%@) (%@)", "-[Haywire findFirmwareWithOptions:remote:]_block_invoke", v9, *(void *)(v4 + 24), *(void *)(v4 + 32) format];
  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 16), "setValue:forKey:", objc_msgSend(*(id *)(a1 + 32), "getUpdateRequired"), @"UpdateRequired");
  if (!a2)
  {
LABEL_13:
    uint64_t v11 = 1;
    goto LABEL_15;
  }
LABEL_10:
  id v10 = [a2 domain];
  if ([v10 isEqualToString:ASErrorDomain] && objc_msgSend(a2, "code") == (id)21)
  {
    a2 = 0;
    goto LABEL_13;
  }
  [*(id *)(*(void *)(a1 + 32) + 8) log:3, @"%s failed: %@", "-[Haywire findFirmwareWithOptions:remote:]_block_invoke", a2 format];
  uint64_t v11 = 0;
LABEL_15:
  [*(id *)(*(void *)(a1 + 32) + 8) didFind:v11 info:*(void *)(*(void *)(a1 + 32) + 16) updateAvailable:v8 needsDownload:1 error:a2];
  uint64_t v12 = *(void **)(a1 + 32);
  return [v12 cleanupAssets];
}

id sub_1000038A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "log:format:", 5, @"%s calling didDownload", "-[Haywire downloadFirmwareWithOptions:]_block_invoke");
  uint64_t v5 = *(void *)(a1 + 32);
  id v6 = *(void **)(v5 + 8);
  uint64_t v7 = *(void *)(v5 + 16);
  return [v6 didDownload:1 info:v7 error:a3];
}

id sub_100004010(int8x16_t *a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100004098;
  v3[3] = &unk_10009CFD8;
  int8x16_t v1 = a1[2];
  int8x16_t v4 = vextq_s8(v1, v1, 8uLL);
  __int8 v6 = a1[3].i8[8];
  uint64_t v5 = a1[3].i64[0];
  return [(id)v1.i64[0] queryMetaDataWithError:v3];
}

void sub_100004098(uint64_t a1, uint64_t a2, uint64_t a3)
{
  objc_msgSend(*(id *)(a1 + 32), "queryComplete:remote:error:completion:", objc_msgSend(*(id *)(a1 + 40), "results"), *(unsigned __int8 *)(a1 + 56), a3, *(void *)(a1 + 48));
  int8x16_t v4 = *(void **)(a1 + 40);
}

void sub_1000040F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  objc_msgSend(*(id *)(a1 + 32), "queryComplete:remote:error:completion:", objc_msgSend(*(id *)(a1 + 40), "results"), *(unsigned __int8 *)(a1 + 56), a3, *(void *)(a1 + 48));
  int8x16_t v4 = *(void **)(a1 + 40);
}

id sub_1000043A8(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) filterAsset:a2 osBuild:*(void *)(a1 + 40) osVersion:*(void *)(a1 + 48)];
}

id sub_100004B10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 8);
  if (!a3) {
    return [v5 log:5, @"%s: purged asset: %@.", "-[Haywire cleanupAssets]_block_invoke", v4 format];
  }
  [v5 log:5, @"%s: failed to purge asset %@: %@.", "-[Haywire cleanupAssets]_block_invoke", v4, a3 format];
  uint64_t v7 = *(void **)(a1 + 32);
  return [v7 setError:a3];
}

int main(int argc, const char **argv, const char **envp)
{
  return 0;
}

double DERImg4DecodeFindInSequence(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v7 = 0;
  long long v8 = 0uLL;
  while (!DERDecodeSeqNext(a1, &v7))
  {
    if (v7 == a2)
    {
      double result = *(double *)&v8;
      *a3 = v8;
      return result;
    }
  }
  return result;
}

double DERImg4DecodeContentFindItemWithTag(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  v6[0] = 0;
  v6[1] = 0;
  if (!DERDecodeSeqContentInit(a1, v6)) {
    return DERImg4DecodeFindInSequence(v6, a2, a3);
  }
  return result;
}

uint64_t DERImg4DecodeTagCompare(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 < 4) {
    return 0xFFFFFFFFLL;
  }
  if (v2 != 4) {
    return 1;
  }
  unsigned int v5 = 0;
  if (DERParseInteger((char **)a1, &v5)) {
    return 4294967294;
  }
  if (v5 < a2) {
    return 0xFFFFFFFFLL;
  }
  return v5 > a2;
}

uint64_t DERImg4Decode(void *a1, unint64_t a2)
{
  uint64_t result = 6;
  if (a1)
  {
    if (a2)
    {
      unint64_t v6 = 0;
      unint64_t v7 = 0;
      uint64_t v8 = 0;
      uint64_t result = DERDecodeItem((uint64_t)a1, &v6);
      if (!result)
      {
        if (v6 == 0x2000000000000010)
        {
          uint64_t v5 = a1[1];
          if (__CFADD__(*a1, v5) || __CFADD__(v7, v8))
          {
            __break(0x5513u);
          }
          else if (*a1 + v5 == v7 + v8)
          {
            uint64_t result = DERParseSequenceContentToObject(&v7, 4u, (uint64_t)&DERImg4ItemSpecs, a2, 0x40uLL, 0);
            if (!result) {
              return 2 * (DERImg4DecodeTagCompare(a2, 0x494D4734u) != 0);
            }
          }
          else
          {
            return 7;
          }
        }
        else
        {
          return 2;
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodePayloadCompression(unint64_t *a1, char **a2)
{
  unsigned int v5 = 2;
  uint64_t result = 6;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = DERParseSequenceContentToObject(a1, 2u, (uint64_t)&DERImg4CompressionItemSpecs, (unint64_t)a2, 0x20uLL, 0);
      if (!result)
      {
        uint64_t result = DERParseInteger(a2, &v5);
        if (!result)
        {
          if (v5 <= 1) {
            return 0;
          }
          else {
            return 6;
          }
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodePayloadWithProperties(uint64_t a1, unint64_t a2)
{
  uint64_t result = 6;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = DERParseSequenceToObject(a1, 7u, (uint64_t)&DERImg4PayloadWithPropertiesItemSpecs, a2, 0xA0uLL, 0);
      if (!result)
      {
        if (DERImg4DecodeTagCompare(a2, 0x494D3450u))
        {
          return 2;
        }
        else if (!*(void *)(a2 + 80) {
               || (long long v7 = 0u,
        }
                   long long v8 = 0u,
                   uint64_t result = DERImg4DecodePayloadCompression((unint64_t *)(a2 + 80), (char **)&v7),
                   !result))
        {
          uint64_t v6 = *(void *)(a2 + 96);
          uint64_t v5 = a2 + 96;
          if (!v6) {
            return 0;
          }
          long long v7 = 0u;
          long long v8 = 0u;
          uint64_t result = DERImg4DecodePayloadProperties(v5, (unint64_t)&v7);
          if (!result) {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodePayloadProperties(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (!a2) {
      return 6;
    }
    if (*(void *)result && *(void *)(result + 8))
    {
      uint64_t result = DERParseSequenceToObject(result, 2u, (uint64_t)&DERImg4PayloadPropertiesItemSpecs, a2, 0x20uLL, 0);
      if (result) {
        return result;
      }
      if (DERImg4DecodeTagCompare(a2, 0x50415950u)) {
        return 2;
      }
    }
    return 0;
  }
  return result;
}

uint64_t DERImg4DecodePayload(uint64_t a1, unint64_t a2)
{
  uint64_t result = 6;
  if (a1 && a2)
  {
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    uint64_t result = DERImg4DecodePayloadWithProperties(a1, (unint64_t)&v11);
    if (result)
    {
      uint64_t result = DERParseSequenceToObject(a1, 6u, (uint64_t)&DERImg4PayloadItemSpecs, a2, 0x90uLL, 0);
      if (!result)
      {
        if (DERImg4DecodeTagCompare(a2, 0x494D3450u))
        {
          return 2;
        }
        else
        {
          uint64_t v6 = *(void *)(a2 + 80);
          uint64_t v5 = (unint64_t *)(a2 + 80);
          if (!v6) {
            return 0;
          }
          memset(v10, 0, sizeof(v10));
          uint64_t result = DERImg4DecodePayloadCompression(v5, (char **)v10);
          if (!result) {
            return 0;
          }
        }
      }
    }
    else
    {
      long long v7 = v12;
      *(_OWORD *)a2 = v11;
      *(_OWORD *)(a2 + 16) = v7;
      long long v8 = v14;
      *(_OWORD *)(a2 + 32) = v13;
      *(_OWORD *)(a2 + 48) = v8;
      long long v9 = v16;
      *(_OWORD *)(a2 + 64) = v15;
      *(_OWORD *)(a2 + 80) = v9;
    }
  }
  return result;
}

uint64_t DERImg4DecodeManifest(void *a1, unint64_t a2)
{
  return sub_100005180(a1, 5uLL, (uint64_t)&DERImg4ManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t sub_100005180(void *a1, unint64_t a2, uint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t result = 6;
  if (a1 && a4)
  {
    if (!*a1 || !a1[1]) {
      return 0;
    }
    if (a2 >= 0x10000)
    {
      __break(0x5507u);
      return result;
    }
    uint64_t result = DERParseSequenceToObject((uint64_t)a1, (unsigned __int16)a2, a3, a4, 0xC0uLL, 0);
    if (!result)
    {
      if (DERImg4DecodeTagCompare(a4, a5)) {
        return 2;
      }
      unsigned int v9 = 0;
      uint64_t result = DERParseInteger((char **)(a4 + 16), &v9);
      if (result) {
        return result;
      }
      if (v9 > 2) {
        return 2;
      }
      return 0;
    }
  }
  return result;
}

uint64_t DERImg4DecodeRestoreInfo(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (!a2) {
      return 6;
    }
    if (*(void *)result && *(void *)(result + 8))
    {
      uint64_t result = DERParseSequenceToObject(result, 2u, (uint64_t)&DERImg4RestoreInfoItemSpecs, a2, 0x20uLL, 0);
      if (result) {
        return result;
      }
      if (DERImg4DecodeTagCompare(a2, 0x494D3452u)) {
        return 2;
      }
    }
    return 0;
  }
  return result;
}

uint64_t DERImg4DecodeProperty(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 6;
  if (a1)
  {
    if (a3)
    {
      unint64_t v14 = 0;
      long long v15 = 0uLL;
      long long v13 = 0uLL;
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      unsigned int v8 = 0;
      uint64_t result = DERDecodeSeqInit((uint64_t)a1, &v9, &v10);
      if (!result)
      {
        if (v9 != 0x2000000000000010) {
          return 2;
        }
        uint64_t result = DERDecodeSeqNext(&v10, &v14);
        if (result) {
          return result;
        }
        if (v14 != 22) {
          return 2;
        }
        uint64_t result = DERParseInteger((char **)&v15, &v8);
        if (result) {
          return result;
        }
        if ((v8 | 0xE000000000000000) != a2) {
          return 2;
        }
        *(_OWORD *)a3 = v15;
        uint64_t result = DERDecodeSeqNext(&v10, &v12);
        if (result) {
          return result;
        }
        *(void *)(a3 + 40) = v12;
        *(_OWORD *)(a3 + 24) = v13;
        uint64_t result = DERDecodeSeqNext(&v10, &v12);
        if (result != 1) {
          return 2;
        }
        uint64_t v7 = a1[1];
        if (__CFADD__(*a1, v7))
        {
          __break(0x5513u);
        }
        else if (v11 == *a1 + v7)
        {
          return 0;
        }
        else
        {
          return 7;
        }
      }
    }
  }
  return result;
}

uint64_t Img4DecodeParseLengthFromBufferWithTag(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  v16[0] = 0;
  v16[1] = 0;
  v14[1] = 0;
  unint64_t v15 = 0;
  uint64_t result = 0xFFFFFFFFLL;
  unint64_t v13 = 0;
  v14[0] = 0;
  if (a1)
  {
    if (a4)
    {
      v17[0] = a1;
      v17[1] = a2;
      uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v17, &v15, &v12);
      if (!result)
      {
        if (v12)
        {
          if (v15 != 0x2000000000000010) {
            return 2;
          }
          uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v16, &v13, &v11);
          if (result) {
            return result;
          }
          if (v11)
          {
            uint64_t result = DERImg4DecodeTagCompare((uint64_t)v14, a3);
            if (!result)
            {
              uint64_t v8 = v16[0] - a1;
              if (v12 >= ~(v16[0] - a1)) {
                return 7;
              }
              BOOL v9 = __CFADD__(v12, v8);
              uint64_t v10 = v12 + v8;
              if (v9)
              {
                __break(0x5500u);
              }
              else
              {
                uint64_t result = 0;
                *a4 = v10;
              }
              return result;
            }
            return 2;
          }
        }
        return 3;
      }
    }
  }
  return result;
}

void Img4DecodeGetPayloadVersionPropertyString(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a3 && a4)
  {
    uint64_t v14 = 0;
    v15[0] = 0;
    v15[1] = 0;
    memset(v13, 0, sizeof(v13));
    long long v12 = 0uLL;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    if (DERDecodeItem(a1, (unint64_t *)&v14)
      || DERImg4DecodeProperty(v15, v14, (uint64_t)v13)
      || (DERImg4DecodeContentFindItemWithTag((unint64_t *)&v13[1] + 1, a2, &v12), v7)
      || DERImg4DecodeProperty(&v12, a2, (uint64_t)&v9))
    {
      uint64_t v8 = 0;
      *a3 = 0;
    }
    else
    {
      uint64_t v8 = v11;
      *a3 = *((void *)&v10 + 1);
    }
    *a4 = v8;
  }
}

double Img4DecodeInit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (a3)
    {
      v9[0] = a1;
      v9[1] = a2;
      long long v7 = 0u;
      long long v8 = 0u;
      long long v5 = 0u;
      long long v6 = 0u;
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      *(_OWORD *)(a3 + 32) = 0u;
      *(_OWORD *)(a3 + 48) = 0u;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 80) = 0u;
      *(_OWORD *)(a3 + 96) = 0u;
      *(_OWORD *)(a3 + 112) = 0u;
      *(_OWORD *)(a3 + 128) = 0u;
      *(_OWORD *)(a3 + 144) = 0u;
      *(_OWORD *)(a3 + 160) = 0u;
      *(_OWORD *)(a3 + 176) = 0u;
      *(_OWORD *)(a3 + 192) = 0u;
      *(_OWORD *)(a3 + 208) = 0u;
      *(_OWORD *)(a3 + 224) = 0u;
      *(_OWORD *)(a3 + 240) = 0u;
      *(_OWORD *)(a3 + 256) = 0u;
      *(_OWORD *)(a3 + 272) = 0u;
      *(_OWORD *)(a3 + 288) = 0u;
      *(_OWORD *)(a3 + 304) = 0u;
      *(_OWORD *)(a3 + 320) = 0u;
      *(_OWORD *)(a3 + 336) = 0u;
      *(_OWORD *)(a3 + 352) = 0u;
      *(_OWORD *)(a3 + 368) = 0u;
      *(_OWORD *)(a3 + 384) = 0u;
      *(_OWORD *)(a3 + 400) = 0u;
      *(_OWORD *)(a3 + 416) = 0u;
      *(_OWORD *)(a3 + 432) = 0u;
      *(void *)(a3 + 448) = 0;
      if (!DERImg4Decode(v9, (unint64_t)&v5)
        && !DERImg4DecodePayload((uint64_t)&v6, a3 + 88)
        && !DERImg4DecodeManifest(&v7, a3 + 232)
        && !DERImg4DecodeRestoreInfo((uint64_t)&v8, a3 + 424))
      {
        *(_OWORD *)(a3 + 8) = v6;
        double result = *(double *)&v7;
        *(_OWORD *)(a3 + 24) = v7;
      }
    }
  }
  return result;
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3;
  }
  uint64_t v4 = *(unsigned char **)result;
  if (*(void *)result == -1) {
    goto LABEL_68;
  }
  long long v5 = &v4[v3];
  long long v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    long long v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_69;
      }
      uint64_t v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15) {
            unint64_t v17 = *v12;
          }
          else {
            unint64_t v17 = v7 - 1;
          }
          BOOL v10 = v5 >= v14;
          unint64_t v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3) {
              return 0;
            }
LABEL_34:
            double result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3;
      }
      if (v14 >= v5 || v14 < v4) {
        goto LABEL_69;
      }
      if (!*v14) {
        return 3;
      }
      unint64_t v15 = 0;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (unsigned char *)-1)
      {
        if (v14 >= v5) {
          goto LABEL_69;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_70;
        }
        unsigned int v24 = *v14++;
        unint64_t v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!v19)
        {
          if (a3) {
            BOOL v25 = 0;
          }
          else {
            BOOL v25 = v15 > v22;
          }
          char v26 = v25;
          double result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0) {
            return result;
          }
          if (v15 >= v22) {
            unint64_t v27 = v22;
          }
          else {
            unint64_t v27 = v15;
          }
          BOOL v10 = (unint64_t)v5 >= v23;
          v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28) {
            goto LABEL_69;
          }
          a2[1] = v23;
          a2[2] = v27;
          if (a3) {
            goto LABEL_34;
          }
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3;
  }
  unint64_t v8 = 0;
  double result = 3;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 == (unsigned __int8 *)-1) {
      goto LABEL_68;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_69;
    }
    long long v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3;
      }
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  if (a1[1] != (unsigned __int8 *)1) {
    return 3;
  }
  int v2 = **a1;
  if (v2 != 255 && v2 != 0) {
    return 3;
  }
  uint64_t result = 0;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = DERParseInteger64(a1, &v4);
  if (!result)
  {
    if (HIDWORD(v4))
    {
      return 7;
    }
    else
    {
      uint64_t result = 0;
      *a2 = v4;
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return 3;
  }
  unint64_t v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0) {
    return 3;
  }
  if (**a1)
  {
    if (v2 > 8) {
      return 7;
    }
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0) {
      return 3;
    }
    if (v2 > 9) {
      return 7;
    }
  }
LABEL_10:
  unint64_t v5 = 0;
  do
  {
    unsigned int v6 = *v3++;
    unint64_t v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

uint64_t DERDecodeSeqInit(uint64_t a1, void *a2, void *a3)
{
  memset(v8, 170, sizeof(v8));
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!result)
  {
    unint64_t v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        unint64_t v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          uint64_t result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    unint64_t v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  v10[0] = 0;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1;
  }
  v10[0] = *a1;
  v10[1] = v3 - v2;
  uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!result)
  {
    unint64_t v8 = a2[1];
    unint64_t v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      unint64_t v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        uint64_t result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  memset(v12, 170, sizeof(v12));
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!result)
  {
    if (v12[0] == 0x2000000000000010) {
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    }
    else {
      return 2;
    }
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v32 = 0;
  if (a6)
  {
    if (a6 > a5) {
      goto LABEL_59;
    }
    bzero((void *)a4, a6);
  }
  unint64_t v10 = *a1;
  unint64_t v11 = a1[1];
  if (__CFADD__(*a1, v11)) {
    goto LABEL_58;
  }
  unint64_t v12 = v10 + v11;
  if (v10 > v12) {
LABEL_59:
  }
    __break(0x5519u);
  unint64_t v32 = *a1;
  unint64_t v33 = v12;
  if (a2)
  {
    unsigned __int16 v13 = 0;
    v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      unint64_t v15 = v32;
      unint64_t v14 = v33;
      uint64_t result = DERDecodeSeqNext(&v32, v31);
      if (result) {
        break;
      }
      if (a2 <= v13) {
        return 2;
      }
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3) {
          goto LABEL_58;
        }
        unsigned __int16 v17 = v13;
        __int16 v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(void *)(a3 + 24 * v13 + 8)) {
          break;
        }
        uint64_t result = 2;
        if (v18)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1)) {
            continue;
          }
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        unint64_t v19 = *(void *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5) {
          return 7;
        }
        if (v19 > ~a4) {
          goto LABEL_58;
        }
        uint64_t v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4) {
          goto LABEL_59;
        }
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((void *)v21 + 1) <= v14 - v15)
            {
              *(void *)uint64_t v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29) {
            goto LABEL_59;
          }
          uint64_t v23 = *((void *)v21 + 1);
          unint64_t v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15) {
            goto LABEL_59;
          }
          *(void *)uint64_t v21 = v15;
          *((void *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          unint64_t v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            unint64_t v10 = v31[1] + v31[2];
            unint64_t v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        unint64_t v10 = v32;
        unint64_t v12 = v33;
        goto LABEL_47;
      }
    }
    if (result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        BOOL v25 = (__int16 *)(a3 + 24 * v13 + 16);
        unint64_t v26 = a2 - (unint64_t)v13;
        uint64_t result = 0;
        while (1)
        {
          __int16 v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0) {
            break;
          }
          if (!--v26) {
            return result;
          }
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12) {
      return 0;
    }
    else {
      return 3;
    }
  }
  return result;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

uint64_t AMAuthInstallCreate(const __CFAllocator *a1)
{
  pthread_once(&stru_1000B82E0, (void (*)(void))sub_100006E30);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable || (CFURLRef cf = CFURLCreateWithString(a1, @"https://gs.apple.com:443/", 0)) == 0)
  {
    uint64_t v11 = 0;
    CFURLRef cf = 0;
LABEL_21:
    CFURLRef v19 = 0;
LABEL_23:
    CFURLRef v18 = 0;
LABEL_25:
    CFMutableDictionaryRef v17 = 0;
    CFMutableDictionaryRef v2 = 0;
LABEL_26:
    CFMutableDictionaryRef v3 = 0;
LABEL_27:
    CFMutableDictionaryRef v4 = 0;
LABEL_28:
    CFMutableDictionaryRef v5 = 0;
LABEL_29:
    CFMutableDictionaryRef v6 = 0;
LABEL_30:
    CFMutableDictionaryRef v7 = 0;
LABEL_31:
    CFMutableDictionaryRef v8 = 0;
LABEL_32:
    CFMutableDictionaryRef v9 = 0;
    goto LABEL_18;
  }
  CFURLRef v19 = CFURLCreateWithString(a1, @"http://vega-dr.apple.com:8080/vegads/fuser", 0);
  if (!v19)
  {
    uint64_t v11 = 0;
    goto LABEL_21;
  }
  CFURLRef v18 = CFURLCreateWithString(a1, @"http://treecko-dr.apple.com:8080/TREECKO/controller", 0);
  if (!v18)
  {
    uint64_t v11 = 0;
    goto LABEL_23;
  }
  CFMutableDictionaryRef v17 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v17)
  {
    uint64_t v11 = 0;
    goto LABEL_25;
  }
  CFMutableDictionaryRef v2 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v2)
  {
    uint64_t v11 = 0;
    goto LABEL_26;
  }
  CFMutableDictionaryRef v3 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v3)
  {
    uint64_t v11 = 0;
    goto LABEL_27;
  }
  CFMutableDictionaryRef v4 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v4)
  {
    uint64_t v11 = 0;
    goto LABEL_28;
  }
  CFMutableDictionaryRef v5 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v5)
  {
    uint64_t v11 = 0;
    goto LABEL_29;
  }
  CFMutableDictionaryRef v6 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v6)
  {
    uint64_t v11 = 0;
    goto LABEL_30;
  }
  CFMutableDictionaryRef v7 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v7)
  {
    uint64_t v11 = 0;
    goto LABEL_31;
  }
  CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v8)
  {
    uint64_t v11 = 0;
    goto LABEL_32;
  }
  CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v9)
  {
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v11 = Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 496) = 0u;
      *(_OWORD *)(Instance + 512) = 0u;
      *(_OWORD *)(Instance + 464) = 0u;
      *(_OWORD *)(Instance + 480) = 0u;
      *(_OWORD *)(Instance + 432) = 0u;
      *(_OWORD *)(Instance + 448) = 0u;
      *(_OWORD *)(Instance + 400) = 0u;
      *(_OWORD *)(Instance + 416) = 0u;
      *(_OWORD *)(Instance + 368) = 0u;
      *(_OWORD *)(Instance + 384) = 0u;
      *(_OWORD *)(Instance + 336) = 0u;
      *(_OWORD *)(Instance + 352) = 0u;
      *(_OWORD *)(Instance + 304) = 0u;
      *(_OWORD *)(Instance + 320) = 0u;
      *(_OWORD *)(Instance + 272) = 0u;
      *(_OWORD *)(Instance + 288) = 0u;
      *(_OWORD *)(Instance + 240) = 0u;
      *(_OWORD *)(Instance + 256) = 0u;
      *(_OWORD *)(Instance + 208) = 0u;
      *(_OWORD *)(Instance + 224) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 192) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(unsigned char *)(Instance + 520) = 0;
      *(_WORD *)(Instance + 57) = 257;
      *(void *)(Instance + 72) = CFRetain(cf);
      *(_DWORD *)(v11 + 80) = 3;
      *(void *)(v11 + 352) = CFRetain(Mutable);
      *(void *)(v11 + 376) = CFRetain(v17);
      *(void *)(v11 + 384) = CFRetain(v2);
      *(void *)(v11 + 416) = CFRetain(v3);
      *(void *)(v11 + 160) = CFRetain(v19);
      *(void *)(v11 + 296) = CFRetain(v18);
      *(void *)(v11 + 88) = @"ApImg4Ticket";
      *(void *)(v11 + 200) = CFRetain(v4);
      *(void *)(v11 + 208) = CFRetain(v5);
      *(void *)(v11 + 216) = CFRetain(v6);
      unint64_t v12 = calloc(1uLL, 0x30uLL);
      *(void *)(v11 + 128) = v12;
      if (v12)
      {
        CFTypeRef v13 = CFRetain(v7);
        uint64_t v14 = *(void *)(v11 + 128);
        *(void *)uint64_t v14 = v13;
        *(void *)(v14 + 40) = 0;
        *(_OWORD *)(v14 + 24) = 0u;
        *(_OWORD *)(v14 + 8) = 0u;
        *(void *)(v11 + 496) = 0;
        *(unsigned char *)(v11 + 504) = 0;
        *(void *)(v11 + 440) = sub_100006534;
        *(void *)(v11 + 448) = sub_10000653C;
        *(void *)(v11 + 456) = CFRetain(v8);
        *(void *)(v11 + 464) = CFRetain(v9);
        *(void *)(v11 + 488) = 0;
        *(void *)(v11 + 512) = 0;
        *(void *)(v11 + 360) = AMAuthInstallLockCreate();
      }
      else
      {
        sub_1000063E8(v11);
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
LABEL_18:
  SafeRelease(Mutable);
  SafeRelease(cf);
  SafeRelease(v19);
  SafeRelease(v18);
  SafeRelease(v17);
  SafeRelease(v2);
  SafeRelease(v3);
  SafeRelease(0);
  SafeRelease(v4);
  SafeRelease(v5);
  SafeRelease(v6);
  SafeRelease(v7);
  SafeRelease(v8);
  SafeRelease(v9);
  return v11;
}

double sub_1000063E8(uint64_t a1)
{
  if (!a1) {
    sub_100071CA8();
  }
  if (!*(unsigned char *)(a1 + 520))
  {
    *(unsigned char *)(a1 + 520) = 1;
    AMAuthInstallApFinalize(a1);
    AMAuthInstallBasebandFinalize(a1, v2, v3, v4, v5, v6, v7, v8);
    AMAuthInstallBundleFinalize(a1);
    SafeRelease(*(CFTypeRef *)(a1 + 120));
    SafeRelease(*(CFTypeRef *)(a1 + 376));
    SafeRelease(*(CFTypeRef *)(a1 + 384));
    SafeRelease(*(CFTypeRef *)(a1 + 416));
    SafeRelease(*(CFTypeRef *)(a1 + 336));
    SafeRelease(*(CFTypeRef *)(a1 + 96));
    SafeRelease(*(CFTypeRef *)(a1 + 72));
    SafeRelease(*(CFTypeRef *)(a1 + 88));
    SafeRelease(*(CFTypeRef *)(a1 + 64));
    SafeRelease(*(CFTypeRef *)(a1 + 352));
    SafeRelease(*(CFTypeRef *)(a1 + 296));
    SafeRelease(*(CFTypeRef *)(a1 + 312));
    SafeRelease(*(CFTypeRef *)(a1 + 320));
    SafeRelease(*(CFTypeRef *)(a1 + 424));
    SafeRelease(*(CFTypeRef *)(a1 + 456));
    SafeRelease(*(CFTypeRef *)(a1 + 464));
    SafeRelease(*(CFTypeRef *)(a1 + 472));
    SafeRelease(*(CFTypeRef *)(a1 + 480));
    SafeRelease(*(CFTypeRef *)(a1 + 496));
    SafeRelease(*(CFTypeRef *)(a1 + 40));
    SafeRelease(*(CFTypeRef *)(a1 + 512));
    SafeRelease(*(CFTypeRef *)(a1 + 360));
    SafeRelease(*(CFTypeRef *)(a1 + 488));
    double result = 0.0;
    *(_OWORD *)(a1 + 496) = 0u;
    *(_OWORD *)(a1 + 512) = 0u;
    *(_OWORD *)(a1 + 464) = 0u;
    *(_OWORD *)(a1 + 480) = 0u;
    *(_OWORD *)(a1 + 432) = 0u;
    *(_OWORD *)(a1 + 448) = 0u;
    *(_OWORD *)(a1 + 400) = 0u;
    *(_OWORD *)(a1 + 416) = 0u;
    *(_OWORD *)(a1 + 368) = 0u;
    *(_OWORD *)(a1 + 384) = 0u;
    *(_OWORD *)(a1 + 336) = 0u;
    *(_OWORD *)(a1 + 352) = 0u;
    *(_OWORD *)(a1 + 304) = 0u;
    *(_OWORD *)(a1 + 320) = 0u;
    *(_OWORD *)(a1 + 272) = 0u;
    *(_OWORD *)(a1 + 288) = 0u;
    *(_OWORD *)(a1 + 240) = 0u;
    *(_OWORD *)(a1 + 256) = 0u;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
  }
  return result;
}

uint64_t sub_100006534()
{
  return 1;
}

uint64_t sub_10000653C()
{
  return 1;
}

uint64_t AMAuthInstallBasebandPersonalizationEnabled(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 58);
  }
  return result;
}

uint64_t AMAuthInstallBasebandEnablePersonalization(uint64_t a1, char a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 58) = a2;
  return result;
}

uint64_t AMAuthInstallApPersonalizationEnabled(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 57);
  }
  return result;
}

uint64_t AMAuthInstallApEnablePersonalization(uint64_t a1, char a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 57) = a2;
  return result;
}

CFStringRef AMAuthInstallGetLocalizedStatusString(CFDictionaryRef *cf, int a2)
{
  int valuePtr = a2;
  if (a2 > 98)
  {
    switch(a2)
    {
      case 3500:
        CFStringRef Value = @"The signing server returned an internal error";
        break;
      case 3501:
        CFStringRef Value = @"You must authorize with the signing server before making this request";
        break;
      case 3502:
      case 3505:
      case 3506:
        goto LABEL_34;
      case 3503:
        CFStringRef Value = @"You are not authorized to make this request. Please check your device or credentials";
        break;
      case 3504:
        CFStringRef Value = @"The signing server could not find the resource requested";
        break;
      case 3507:
        CFStringRef Value = @"You must authorize with a proxy server before making this request";
        break;
      default:
        if (a2 == 99)
        {
          CFStringRef Value = @"Generic";
        }
        else if (a2 == 3194)
        {
          CFStringRef Value = @"Declined to authorize this image on this device for this user.";
        }
        else
        {
LABEL_34:
          CFStringRef Value = &stru_10009EF88;
          if (cf)
          {
            if ((a2 - 3100) <= 0x383)
            {
              CFAllocatorRef v4 = CFGetAllocator(cf);
              CFNumberRef v5 = CFNumberCreate(v4, kCFNumberIntType, &valuePtr);
              if (v5)
              {
                CFNumberRef v6 = v5;
                CFStringRef Value = (const __CFString *)CFDictionaryGetValue(cf[44], v5);
                CFRelease(v6);
                if (!Value) {
                  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallGetLocalizedStatusString", (uint64_t)"no cached text for tss error code %d", v7, v8, v9, v10, v11, valuePtr);
                }
              }
            }
          }
        }
        break;
    }
  }
  else
  {
    CFStringRef Value = @"No error";
    switch(a2)
    {
      case 0:
        return Value;
      case 1:
        CFStringRef Value = @"Bad parameter";
        break;
      case 2:
        CFStringRef Value = @"Allocation error";
        break;
      case 3:
        CFStringRef Value = @"Conversion error";
        break;
      case 4:
        CFStringRef Value = @"File error";
        break;
      case 5:
        CFStringRef Value = @"Hash error";
        break;
      case 6:
        CFStringRef Value = @"Crypto error";
        break;
      case 7:
        CFStringRef Value = @"Bad build identity";
        break;
      case 8:
        CFStringRef Value = @"Entry not found";
        break;
      case 9:
        CFStringRef Value = @"Invalid img3 object";
        break;
      case 10:
        CFStringRef Value = @"Invalid bbfw object";
        break;
      case 11:
        CFStringRef Value = @"Server not reachable";
        break;
      case 12:
        CFStringRef Value = @"Server timed out";
        break;
      case 13:
        CFStringRef Value = @"Unimplemented";
        break;
      case 14:
        CFStringRef Value = @"Internal error";
        break;
      case 15:
        CFStringRef Value = @"Invalid bbfw file";
        break;
      case 16:
        CFStringRef Value = @"Network error";
        break;
      case 17:
        CFStringRef Value = @"Bad response";
        break;
      case 18:
        CFStringRef Value = @"Fusing failed";
        break;
      case 19:
        CFStringRef Value = @"Baseband provisioning failed";
        break;
      case 20:
        CFStringRef Value = @"AppleConnect not found";
        break;
      case 21:
        CFStringRef Value = @"AppleConnect user canceled";
        break;
      case 22:
        CFStringRef Value = @"AppleConnect bad credentials";
        break;
      default:
        goto LABEL_34;
    }
  }
  return Value;
}

uint64_t AMAuthInstallSetSigningServerURL(uint64_t a1, const void *a2)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    CFNumberRef v5 = *(const void **)(a1 + 72);
    if (v5 == a2)
    {
      return 0;
    }
    else
    {
      SafeRelease(v5);
      CFTypeRef v6 = CFRetain(a2);
      uint64_t result = 0;
      *(void *)(a1 + 72) = v6;
    }
  }
  return result;
}

uint64_t AMAuthInstallSetFusingServerURL(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    uint64_t v11 = *(const void **)(a1 + 160);
    if (v11 != a2)
    {
      SafeRelease(v11);
      *(void *)(a1 + 160) = CFRetain(a2);
    }
    AMAuthInstallLog(6, (uint64_t)"AMAuthInstallSetFusingServerURL", (uint64_t)"fusing server: %@", a4, a5, a6, a7, a8, (char)a2);
    return 0;
  }
  return result;
}

uint64_t AMAuthInstallSetLocale(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 1;
  }
  CFAllocatorRef v4 = *(const void **)(a1 + 64);
  if (v4 == a2) {
    return 0;
  }
  SafeRelease(v4);
  CFTypeRef v5 = SafeRetain(a2);
  uint64_t result = 0;
  *(void *)(a1 + 64) = v5;
  return result;
}

uint64_t AMAuthInstallSetDebugFlags(uint64_t a1, int a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 344) = a2;
  return result;
}

uint64_t AMAuthInstallSetUUID(uint64_t a1, const void *a2)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    CFTypeRef v5 = *(const void **)(a1 + 96);
    if (v5 == a2)
    {
      return 0;
    }
    else
    {
      SafeRelease(v5);
      CFTypeRef v6 = CFRetain(a2);
      uint64_t result = 0;
      *(void *)(a1 + 96) = v6;
    }
  }
  return result;
}

void AMAuthInstallApplyRequestEntries(const __CFString *a1, const __CFDictionary *a2, void *a3)
{
  if (CFEqual(a1, @"@ApImg4Ticket"))
  {
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(a2))
    {
      uint64_t v7 = (void (__cdecl *)(const void *, const void *, void *))sub_100006BB8;
LABEL_7:
      CFDictionaryApplyFunction(a2, v7, a3);
      return;
    }
  }
  if (CFEqual(a1, @"@BBTicket"))
  {
    CFTypeID v8 = CFDictionaryGetTypeID();
    if (v8 == CFGetTypeID(a2))
    {
      uint64_t v7 = (void (__cdecl *)(const void *, const void *, void *))sub_100006BD4;
      goto LABEL_7;
    }
  }
  if (CFStringHasPrefix(a1, @"Ap"))
  {
    uint64_t v9 = @"ApRequestEntries";
LABEL_14:
    AMAuthInstallSetRequestEntry(a3, v9, a1, a2);
    return;
  }
  if (CFStringHasPrefix(a1, @"Bb"))
  {
    uint64_t v9 = @"BbRequestEntries";
    goto LABEL_14;
  }
  if (CFStringHasPrefix(a1, @"FDR"))
  {
    AMAuthInstallSetFDRRequestEntry(a3, a1, a2);
  }
}

uint64_t sub_100006BB8(const void *a1, const void *a2, CFTypeRef cf)
{
  return AMAuthInstallSetRequestEntry(cf, @"ApRequestEntries", a1, a2);
}

uint64_t sub_100006BD4(const void *a1, const void *a2, CFTypeRef cf)
{
  return AMAuthInstallSetRequestEntry(cf, @"BbRequestEntries", a1, a2);
}

uint64_t AMAuthInstallSetApRequestEntry(const void *a1, const void *a2, const void *a3)
{
  return AMAuthInstallSetRequestEntry(a1, @"ApRequestEntries", a2, a3);
}

uint64_t AMAuthInstallSetBbRequestEntry(const void *a1, const void *a2, const void *a3)
{
  return AMAuthInstallSetRequestEntry(a1, @"BbRequestEntries", a2, a3);
}

uint64_t AMAuthInstallSetFDRRequestEntry(const void *a1, const void *a2, const void *a3)
{
  uint64_t v6 = AMAuthInstallSetRequestEntry(a1, @"ApRequestEntries", a2, a3);
  if (v6)
  {
    uint64_t v12 = v6;
    uint64_t v14 = "failed to set FDR entry in Ap request";
LABEL_6:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSetFDRRequestEntry", (uint64_t)v14, v7, v8, v9, v10, v11, v15);
    return v12;
  }
  uint64_t v12 = AMAuthInstallSetRequestEntry(a1, @"BbRequestEntries", a2, a3);
  if (v12)
  {
    uint64_t v14 = "failed to set FDR entry in Bb request";
    goto LABEL_6;
  }
  return v12;
}

uint64_t AMAuthInstallSetRequestEntry(CFTypeRef cf, void *key, const void *a3, const void *a4)
{
  CFMutableDictionaryRef Mutable = 0;
  uint64_t v5 = 1;
  if (cf && key && a3 && a4)
  {
    CFDictionaryRef v10 = (const __CFDictionary *)*((void *)cf + 53);
    if (v10
      || (CFAllocatorRef v11 = CFGetAllocator(cf),
          CFDictionaryRef v10 = CFDictionaryCreateMutable(v11, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks),
          (*((void *)cf + 53) = v10) != 0))
    {
      CFStringRef Value = (__CFDictionary *)CFDictionaryGetValue(v10, key);
      if (Value)
      {
        CFMutableDictionaryRef Mutable = Value;
        CFRetain(Value);
LABEL_11:
        CFDictionarySetValue(Mutable, a3, a4);
        uint64_t v5 = 0;
        goto LABEL_12;
      }
      CFAllocatorRef v13 = CFGetAllocator(cf);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v13, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 53), key, Mutable);
        goto LABEL_11;
      }
    }
    else
    {
      CFMutableDictionaryRef Mutable = 0;
    }
    uint64_t v5 = 2;
  }
LABEL_12:
  SafeRelease(Mutable);
  return v5;
}

uint64_t AMAuthInstallSetObjectRequestEntry(const void *a1, const void *a2, const void *a3)
{
  return AMAuthInstallSetRequestEntry(a1, @"ObjectRequestEntries", a2, a3);
}

uint64_t AMAuthInstallSetRecoveryOSVariant(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 1;
  }
  SafeRelease(*(CFTypeRef *)(a1 + 496));
  CFTypeRef v4 = SafeRetain(a2);
  uint64_t result = 0;
  *(void *)(a1 + 496) = v4;
  return result;
}

uint64_t AMAuthInstallSetMacOSVariantIsPresent(uint64_t a1, char a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 504) = a2;
  return result;
}

uint64_t sub_100006E30()
{
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1000B8C70 = result;
  return result;
}

CFStringRef sub_100006E58(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1) {
    sub_100071CD4();
  }
  CFTypeRef v4 = AMAuthInstallApCopyDescription(a1);
  uint64_t v5 = AMAuthInstallBasebandCopyDescription(a1);
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v7 = *(void *)(a1 + 72);
  if (*(void *)(a1 + 64)) {
    CFStringRef v8 = *(const __CFString **)(a1 + 64);
  }
  else {
    CFStringRef v8 = @"default";
  }
  if (*(unsigned char *)(a1 + 56)) {
    CFStringRef v9 = @"YES";
  }
  else {
    CFStringRef v9 = @"NO";
  }
  if (*(void *)(a1 + 104)) {
    CFStringRef v10 = @"YES";
  }
  else {
    CFStringRef v10 = @"NO";
  }
  CFStringRef LibraryVersionString = AMAuthInstallSupportGetLibraryVersionString();
  uint64_t PlatformInfoString = AMAuthInstallPlatformGetPlatformInfoString();
  CFStringRef v13 = CFStringCreateWithFormat(v6, a2, @"<AMAuthInstall %p>{ap=%@, bp=%@, UserAuth=%@, iTunes=%@, server=\"%@\", locale=%@, version=\"%@\", platform=%@}", a1, v4, v5, v10, v9, v7, v8, LibraryVersionString, PlatformInfoString);
  SafeRelease(v4);
  SafeRelease(v5);
  return v13;
}

CFStringRef sub_100006F54(uint64_t a1)
{
  return sub_100006E58(a1, 0);
}

uint64_t AMAuthInstallApServerRequestAddRequiredTagsWithRecoveryOS(void *a1, __CFDictionary *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1;
  if (!a1 || !a2) {
    return v8;
  }
  int v10 = a4;
  uint64_t v13 = a1[2];
  if (v13)
  {
    if (*(unsigned char *)(v13 + 96))
    {
      if (a4) {
        uint64_t v14 = AMAuthInstallApImg4ServerRequestAddRequiredTagsWithRecoveryOS(a1, a2, a3, 1);
      }
      else {
        uint64_t v14 = AMAuthInstallApImg4ServerRequestAddRequiredTags(a1, a2, a3);
      }
      uint64_t v8 = v14;
      if (v14)
      {
        long long v20 = "failed to add Ap Img4 tags";
LABEL_14:
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApServerRequestAddRequiredTagsWithRecoveryOS", (uint64_t)v20, v15, v16, v17, v18, v19, v22);
        return v8;
      }
      return v8;
    }
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApIsImg4", (uint64_t)"%s: apParameters is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApIsImg4");
  }
  uint64_t v8 = AMAuthInstallApImg3ServerRequestAddRequiredTags(a1, a2, a3, v10);
  if (v8)
  {
    long long v20 = "failed to add Ap Img3 tags";
    goto LABEL_14;
  }
  return v8;
}

uint64_t AMAuthInstallApIsImg4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApIsImg4", (uint64_t)"%s: amai is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApIsImg4");
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  if (!v8)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApIsImg4", (uint64_t)"%s: apParameters is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApIsImg4");
    return 0;
  }
  return *(unsigned __int8 *)(v8 + 96);
}

uint64_t AMAuthInstallApServerRequestAddRequiredTags(void *a1, __CFDictionary *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return AMAuthInstallApServerRequestAddRequiredTagsWithRecoveryOS(a1, a2, a3, 0, a5, a6, a7, a8);
}

uint64_t AMAuthInstallApSupportsLocalSigning(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11)
    {
      if (*(unsigned char *)(v11 + 96))
      {
        char v12 = AMAuthInstallApImg4SupportsLocalSigning(a1);
LABEL_8:
        char v13 = v12;
        uint64_t result = 0;
        *a2 = v13;
        return result;
      }
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApIsImg4", (uint64_t)"%s: apParameters is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApIsImg4");
    }
    char v12 = AMAuthInstallApImg3SupportsLocalSigning();
    goto LABEL_8;
  }
  return result;
}

uint64_t AMAuthInstallApSupportsGlobalSigning(uint64_t a1, BOOL *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11)
    {
      if (*(unsigned char *)(v11 + 96))
      {
        BOOL v12 = AMAuthInstallApImg4SupportsGlobalSigning(a1);
        uint64_t result = 0;
        *a2 = v12;
        return result;
      }
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApIsImg4", (uint64_t)"%s: apParameters is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApIsImg4");
    }
    return 13;
  }
  return result;
}

uint64_t AMAuthInstallApSetParameters(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v2 = 1;
  if (a1 && theDict)
  {
    if (!*(void *)(a1 + 16))
    {
      uint64_t v5 = calloc(1uLL, 0xC8uLL);
      *(void *)(a1 + 16) = v5;
      if (!v5) {
        return 2;
      }
      v5[4] = 1;
    }
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ECID");
    if (Value)
    {
      CFNumberRef v7 = Value;
      CFTypeID v8 = CFGetTypeID(Value);
      if (v8 == CFNumberGetTypeID() && !CFNumberGetValue(v7, kCFNumberSInt64Type, *(void **)(a1 + 16)))
      {
        char v124 = (char)v7;
        v123 = "failed to convert ECID %@";
        goto LABEL_121;
      }
    }
    CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ApChipID");
    if (v14)
    {
      CFNumberRef v15 = v14;
      CFTypeID v16 = CFGetTypeID(v14);
      if (v16 == CFNumberGetTypeID()
        && !CFNumberGetValue(v15, kCFNumberSInt32Type, (void *)(*(void *)(a1 + 16) + 8)))
      {
        char v124 = (char)v15;
        v123 = "failed to convert chip ID %@";
        goto LABEL_121;
      }
    }
    CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ApBoardID");
    if (v17)
    {
      CFNumberRef v18 = v17;
      CFTypeID v19 = CFGetTypeID(v17);
      if (v19 == CFNumberGetTypeID()
        && !CFNumberGetValue(v18, kCFNumberSInt32Type, (void *)(*(void *)(a1 + 16) + 12)))
      {
        char v124 = (char)v18;
        v123 = "failed to convert board ID %@";
        goto LABEL_121;
      }
    }
    long long v20 = CFDictionaryGetValue(theDict, @"ApSikaFuse");
    if (v20)
    {
      uint64_t v21 = v20;
      CFTypeID v22 = CFGetTypeID(v20);
      if (v22 == CFNumberGetTypeID())
      {
        AMSupportSafeRelease();
        *(void *)(*(void *)(a1 + 16) + 160) = CFRetain(v21);
      }
    }
    uint64_t v23 = CFDictionaryGetValue(theDict, @"UIDMode");
    if (v23)
    {
      unint64_t v24 = v23;
      CFTypeID v25 = CFGetTypeID(v23);
      if (v25 == CFBooleanGetTypeID())
      {
        AMSupportSafeRelease();
        *(void *)(*(void *)(a1 + 16) + 168) = CFRetain(v24);
      }
    }
    unint64_t v26 = CFDictionaryGetValue(theDict, @"RequiresUIDMode");
    if (v26)
    {
      __int16 v27 = v26;
      CFTypeID v28 = CFGetTypeID(v26);
      if (v28 == CFBooleanGetTypeID())
      {
        AMSupportSafeRelease();
        *(void *)(*(void *)(a1 + 16) + 176) = CFRetain(v27);
      }
    }
    v29 = CFDictionaryGetValue(theDict, @"Ap,EphemeralDataMode");
    if (v29)
    {
      v30 = v29;
      CFTypeID v31 = CFGetTypeID(v29);
      if (v31 == CFBooleanGetTypeID())
      {
        AMSupportSafeRelease();
        *(void *)(*(void *)(a1 + 16) + 184) = CFRetain(v30);
      }
    }
    unint64_t v32 = CFDictionaryGetValue(theDict, @"Ap,DisablePlatformOnlyCode");
    if (v32)
    {
      unint64_t v33 = v32;
      CFTypeID v34 = CFGetTypeID(v32);
      if (v34 == CFBooleanGetTypeID())
      {
        AMSupportSafeRelease();
        *(void *)(*(void *)(a1 + 16) + 192) = CFRetain(v33);
      }
    }
    CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ApSecurityDomain");
    if (v35)
    {
      CFNumberRef v36 = v35;
      CFTypeID v37 = CFGetTypeID(v35);
      if (v37 == CFNumberGetTypeID()
        && !CFNumberGetValue(v36, kCFNumberSInt32Type, (void *)(*(void *)(a1 + 16) + 16)))
      {
        char v124 = (char)v36;
        v123 = "failed to convert security domain %@";
        goto LABEL_121;
      }
    }
    CFBooleanRef v38 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApProductionMode");
    if (v38)
    {
      CFBooleanRef v39 = v38;
      CFTypeID v40 = CFGetTypeID(v38);
      if (v40 == CFBooleanGetTypeID()) {
        *(unsigned char *)(*(void *)(a1 + 16) + 20) = CFBooleanGetValue(v39);
      }
    }
    CFBooleanRef v41 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApSupportsImg4");
    if (v41)
    {
      CFBooleanRef v42 = v41;
      CFTypeID v43 = CFGetTypeID(v41);
      if (v43 == CFBooleanGetTypeID()) {
        *(unsigned char *)(*(void *)(a1 + 16) + 96) = CFBooleanGetValue(v42);
      }
    }
    CFStringRef v44 = (const __CFString *)CFDictionaryGetValue(theDict, @"ApImg4DigestType");
    if (v44 && (CFStringRef v45 = v44, v46 = CFGetTypeID(v44), v46 == CFStringGetTypeID()))
    {
      if (CFStringCompare(v45, @"sha1", 1uLL) == kCFCompareEqualTo)
      {
        *(_DWORD *)(*(void *)(a1 + 16) + 112) = 1;
LABEL_47:
        v54 = CFDictionaryGetValue(theDict, @"ApNonce");
        if (v54)
        {
          v55 = v54;
          CFTypeID v56 = CFGetTypeID(v54);
          if (v56 == CFDataGetTypeID()) {
            *(void *)(*(void *)(a1 + 16) + 24) = CFRetain(v55);
          }
        }
        v57 = CFDictionaryGetValue(theDict, @"SepNonce");
        if (v57)
        {
          v58 = v57;
          CFTypeID v59 = CFGetTypeID(v57);
          if (v59 == CFDataGetTypeID())
          {
            uint64_t v60 = AMAuthInstallApImg4SetSepNonce(a1, v58);
            if (v60) {
              return v60;
            }
          }
        }
        v61 = CFDictionaryGetValue(theDict, @"ApNonceSlotID");
        if (v61)
        {
          v62 = v61;
          CFTypeID v63 = CFGetTypeID(v61);
          if (v63 == CFNumberGetTypeID()) {
            AMAuthInstallApImg4SetApNonceSlotID(a1, v62);
          }
        }
        v64 = CFDictionaryGetValue(theDict, @"SepNonceSlotID");
        if (v64)
        {
          v65 = v64;
          CFTypeID v66 = CFGetTypeID(v64);
          if (v66 == CFNumberGetTypeID()) {
            AMAuthInstallApImg4SetSepNonceSlotID(a1, v65);
          }
        }
        v67 = CFDictionaryGetValue(theDict, @"Ap,SoftwareNonceForUpdateFreshness");
        if (v67)
        {
          v68 = v67;
          CFTypeID v69 = CFGetTypeID(v67);
          if (v69 == CFDataGetTypeID()) {
            *(void *)(*(void *)(a1 + 16) + 40) = CFRetain(v68);
          }
        }
        CFBooleanRef v70 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApSecurityMode");
        if (v70)
        {
          CFBooleanRef v71 = v70;
          CFTypeID v72 = CFGetTypeID(v70);
          if (v72 == CFBooleanGetTypeID()) {
            *(unsigned char *)(*(void *)(a1 + 16) + 72) = CFBooleanGetValue(v71);
          }
        }
        CFBooleanRef v73 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApInRomDFU");
        if (v73)
        {
          CFBooleanRef v74 = v73;
          CFTypeID v75 = CFGetTypeID(v73);
          if (v75 == CFBooleanGetTypeID()) {
            *(unsigned char *)(*(void *)(a1 + 16) + 80) = CFBooleanGetValue(v74);
          }
        }
        CFBooleanRef v76 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApEffectiveSecurityMode");
        if (v76)
        {
          CFBooleanRef v77 = v76;
          CFTypeID v78 = CFGetTypeID(v76);
          if (v78 == CFBooleanGetTypeID()) {
            *(unsigned char *)(*(void *)(a1 + 16) + 82) = CFBooleanGetValue(v77);
          }
        }
        CFBooleanRef v79 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApEffectiveProductionMode");
        if (v79)
        {
          CFBooleanRef v80 = v79;
          CFTypeID v81 = CFGetTypeID(v79);
          if (v81 == CFBooleanGetTypeID()) {
            *(unsigned char *)(*(void *)(a1 + 16) + 81) = CFBooleanGetValue(v80);
          }
        }
        v82 = CFDictionaryGetValue(theDict, @"DemotionPolicy");
        if (v82 && (v83 = v82, CFTypeID v84 = CFGetTypeID(v82), v84 == CFStringGetTypeID())) {
          CFStringRef v85 = (const __CFString *)CFRetain(v83);
        }
        else {
          CFStringRef v85 = &stru_10009EF88;
        }
        *(void *)(*(void *)(a1 + 16) + 88) = v85;
        v86 = CFDictionaryGetValue(theDict, @"HardwareModel");
        if (v86)
        {
          v87 = v86;
          CFTypeID v88 = CFGetTypeID(v86);
          if (v88 == CFStringGetTypeID()) {
            *(void *)(*(void *)(a1 + 16) + 104) = CFRetain(v87);
          }
        }
        CFBooleanRef v89 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApX86");
        if (v89)
        {
          CFBooleanRef v90 = v89;
          CFTypeID v91 = CFGetTypeID(v89);
          if (v91 == CFBooleanGetTypeID()) {
            *(unsigned char *)(*(void *)(a1 + 16) + 116) = CFBooleanGetValue(v90);
          }
        }
        CFBooleanRef v92 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"UseGlobalSigning");
        if (v92)
        {
          CFBooleanRef v93 = v92;
          CFTypeID v94 = CFGetTypeID(v92);
          if (v94 == CFBooleanGetTypeID()) {
            *(unsigned char *)(*(void *)(a1 + 16) + 79) = CFBooleanGetValue(v93);
          }
        }
        CFBooleanRef v95 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"Ap,InternalUseOnlySW");
        if (v95)
        {
          CFBooleanRef v96 = v95;
          CFTypeID v97 = CFGetTypeID(v95);
          if (v97 == CFBooleanGetTypeID()) {
            *(unsigned char *)(*(void *)(a1 + 16) + 75) = CFBooleanGetValue(v96);
          }
        }
        CFBooleanRef v98 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"NoDefaultRequestRules");
        if (v98)
        {
          CFBooleanRef v99 = v98;
          CFTypeID v100 = CFGetTypeID(v98);
          if (v100 == CFBooleanGetTypeID()) {
            *(unsigned char *)(*(void *)(a1 + 16) + 152) = CFBooleanGetValue(v99);
          }
        }
        CFStringRef v101 = (const __CFString *)CFDictionaryGetValue(theDict, @"TagPrefix");
        if (!v101 || (CFStringRef v102 = v101, v103 = CFGetTypeID(v101), v103 != CFStringGetTypeID()))
        {
LABEL_99:
          v108 = CFDictionaryGetValue(theDict, @"APTagOverrides");
          if (v108)
          {
            v115 = v108;
            CFTypeID v116 = CFGetTypeID(v108);
            if (v116 == CFDictionaryGetTypeID())
            {
              SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 136));
              CFDictionaryRef v117 = (const __CFDictionary *)CFRetain(v115);
              *(void *)(*(void *)(a1 + 16) + 136) = v117;
              CFStringRef v118 = (const __CFString *)CFDictionaryGetValue(v117, @"@ApImg4Ticket");
              if (v118)
              {
                CFStringRef v119 = v118;
                if (CFStringGetLength(v118) >= 3 && CFStringGetCharacterAtIndex(v119, 0) == 64)
                {
                  SafeRelease(*(CFTypeRef *)(a1 + 88));
                  CFAllocatorRef v120 = CFGetAllocator((CFTypeRef)a1);
                  v125.length = CFStringGetLength(v119) - 1;
                  v125.location = 1;
                  *(void *)(a1 + 88) = CFStringCreateWithSubstring(v120, v119, v125);
                }
              }
            }
          }
          uint64_t v121 = *(void *)(a1 + 16);
          if (!v121)
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApIsImg4", (uint64_t)"%s: apParameters is NULL", v110, v111, v112, v113, v114, (char)"AMAuthInstallApIsImg4");
            return 0;
          }
          if (!*(unsigned char *)(v121 + 96)) {
            return 0;
          }
          uint64_t v60 = AMAuthInstallApImg4SetParameters(a1, theDict, v109, v110, v111, v112, v113, v114);
          if (!v60) {
            return 0;
          }
          return v60;
        }
        SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 144));
        CFStringGetLength(v102);
        CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, v102);
        *(void *)(*(void *)(a1 + 16) + 144) = MutableCopy;
        if (MutableCopy)
        {
          if (CFStringHasSuffix(v102, @","))
          {
            v105 = *(__CFString **)(*(void *)(a1 + 16) + 144);
            CFIndex Length = CFStringGetLength(v105);
            CFStringPad(v105, 0, Length - 1, 0);
          }
          SafeRelease(*(CFTypeRef *)(a1 + 88));
          CFAllocatorRef v107 = CFGetAllocator((CFTypeRef)a1);
          *(void *)(a1 + 88) = CFStringCreateWithFormat(v107, 0, @"%@,Ticket", *(void *)(*(void *)(a1 + 16) + 144));
          goto LABEL_99;
        }
        char v124 = (char)v102;
        v123 = "failed to convert TagPrefix %@";
LABEL_121:
        uint64_t v2 = 3;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApSetParameters", (uint64_t)v123, v9, v10, v11, v12, v13, v124);
        return v2;
      }
      if (CFStringCompare(v45, @"sha2-256", 1uLL))
      {
        if (CFStringCompare(v45, @"sha2-384", 1uLL))
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApSetParameters", (uint64_t)"unsupported digest type %@", v47, v48, v49, v50, v51, (char)v45);
          goto LABEL_47;
        }
        uint64_t v52 = *(void *)(a1 + 16);
        int v53 = 384;
      }
      else
      {
        uint64_t v52 = *(void *)(a1 + 16);
        int v53 = 256;
      }
    }
    else
    {
      uint64_t v52 = *(void *)(a1 + 16);
      int v53 = 1;
    }
    *(_DWORD *)(v52 + 112) = v53;
    goto LABEL_47;
  }
  return v2;
}

uint64_t AMAuthInstallApImg4SetApNonceSlotID(uint64_t a1, CFTypeRef cf)
{
  if (!a1) {
    return 1;
  }
  if (!*(void *)(a1 + 16)) {
    return 1;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFNumberGetTypeID()) {
    return 1;
  }
  CFRetain(cf);
  SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 32));
  uint64_t result = 0;
  *(void *)(*(void *)(a1 + 16) + 32) = cf;
  return result;
}

uint64_t AMAuthInstallApCopyParameters(const void **cf, CFTypeRef *a2)
{
  if (!cf)
  {
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v4 = 1;
    goto LABEL_47;
  }
  CFMutableDictionaryRef Mutable = 0;
  uint64_t v4 = 1;
  if (a2 && cf[2])
  {
    CFAllocatorRef v6 = CFGetAllocator(cf);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Mutable)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApCopyParameters", (uint64_t)"failed to allocate parameters dict", v7, v8, v9, v10, v11, v47);
      uint64_t v4 = 2;
      goto LABEL_47;
    }
    CFAllocatorRef v12 = CFGetAllocator(cf);
    CFNumberRef v13 = CFNumberCreate(v12, kCFNumberSInt64Type, cf[2]);
    if (v13)
    {
      CFNumberRef v19 = v13;
      CFDictionarySetValue(Mutable, @"ECID", v13);
      CFRelease(v19);
      CFAllocatorRef v20 = CFGetAllocator(cf);
      CFNumberRef v21 = CFNumberCreate(v20, kCFNumberSInt32Type, (char *)cf[2] + 8);
      if (v21)
      {
        CFNumberRef v22 = v21;
        CFDictionarySetValue(Mutable, @"ApChipID", v21);
        CFRelease(v22);
        CFAllocatorRef v23 = CFGetAllocator(cf);
        CFNumberRef v24 = CFNumberCreate(v23, kCFNumberSInt32Type, (char *)cf[2] + 12);
        if (v24)
        {
          CFNumberRef v25 = v24;
          CFDictionarySetValue(Mutable, @"ApBoardID", v24);
          CFRelease(v25);
          CFAllocatorRef v26 = CFGetAllocator(cf);
          CFNumberRef v27 = CFNumberCreate(v26, kCFNumberSInt32Type, (char *)cf[2] + 16);
          if (v27)
          {
            CFNumberRef v28 = v27;
            CFDictionarySetValue(Mutable, @"ApSecurityDomain", v27);
            CFRelease(v28);
            if (*((unsigned char *)cf[2] + 20)) {
              CFBooleanRef v29 = kCFBooleanTrue;
            }
            else {
              CFBooleanRef v29 = kCFBooleanFalse;
            }
            CFDictionarySetValue(Mutable, @"ApProductionMode", v29);
            if (*((unsigned char *)cf[2] + 96)) {
              CFBooleanRef v30 = kCFBooleanTrue;
            }
            else {
              CFBooleanRef v30 = kCFBooleanFalse;
            }
            CFDictionarySetValue(Mutable, @"ApSupportsImg4", v30);
            CFTypeID v31 = cf[2];
            unint64_t v32 = (const void *)v31[3];
            if (v32)
            {
              CFDictionarySetValue(Mutable, @"ApNonce", v32);
              CFTypeID v31 = cf[2];
            }
            unint64_t v33 = (const void *)v31[6];
            if (v33)
            {
              CFDictionarySetValue(Mutable, @"SepNonce", v33);
              CFTypeID v31 = cf[2];
            }
            CFTypeID v34 = (const void *)v31[5];
            if (v34)
            {
              CFDictionarySetValue(Mutable, @"Ap,SoftwareNonceForUpdateFreshness", v34);
              CFTypeID v31 = cf[2];
            }
            if (*((unsigned char *)v31 + 72)) {
              CFBooleanRef v35 = kCFBooleanTrue;
            }
            else {
              CFBooleanRef v35 = kCFBooleanFalse;
            }
            CFDictionarySetValue(Mutable, @"ApSecurityMode", v35);
            if (*((unsigned char *)cf[2] + 80)) {
              CFBooleanRef v36 = kCFBooleanTrue;
            }
            else {
              CFBooleanRef v36 = kCFBooleanFalse;
            }
            CFDictionarySetValue(Mutable, @"ApInRomDFU", v36);
            if (*((unsigned char *)cf[2] + 82)) {
              CFBooleanRef v37 = kCFBooleanTrue;
            }
            else {
              CFBooleanRef v37 = kCFBooleanFalse;
            }
            CFDictionarySetValue(Mutable, @"ApEffectiveSecurityMode", v37);
            if (*((unsigned char *)cf[2] + 81)) {
              CFBooleanRef v38 = kCFBooleanTrue;
            }
            else {
              CFBooleanRef v38 = kCFBooleanFalse;
            }
            CFDictionarySetValue(Mutable, @"ApEffectiveProductionMode", v38);
            if (*((unsigned char *)cf[2] + 75)) {
              CFBooleanRef v39 = kCFBooleanTrue;
            }
            else {
              CFBooleanRef v39 = kCFBooleanFalse;
            }
            CFDictionarySetValue(Mutable, @"Ap,InternalUseOnlySW", v39);
            CFTypeID v40 = cf[2];
            CFBooleanRef v41 = (const void *)v40[23];
            if (v41)
            {
              CFDictionarySetValue(Mutable, @"Ap,EphemeralDataMode", v41);
              CFTypeID v40 = cf[2];
            }
            CFBooleanRef v42 = (const void *)v40[24];
            if (v42)
            {
              CFDictionarySetValue(Mutable, @"Ap,DisablePlatformOnlyCode", v42);
              CFTypeID v40 = cf[2];
            }
            if (*((unsigned char *)v40 + 116))
            {
              CFDictionarySetValue(Mutable, @"ApX86", kCFBooleanTrue);
              CFTypeID v40 = cf[2];
            }
            CFTypeID v43 = (const void *)v40[11];
            if (v43)
            {
              CFDictionarySetValue(Mutable, @"DemotionPolicy", v43);
              CFTypeID v40 = cf[2];
            }
            CFStringRef v44 = (const void *)v40[13];
            if (v44) {
              CFDictionarySetValue(Mutable, @"HardwareModel", v44);
            }
            uint64_t v4 = 0;
            *a2 = CFRetain(Mutable);
            goto LABEL_47;
          }
          CFTypeID v46 = "failed to convert securityDomain";
        }
        else
        {
          CFTypeID v46 = "failed to convert boardID";
        }
      }
      else
      {
        CFTypeID v46 = "failed to convert chipID";
      }
    }
    else
    {
      CFTypeID v46 = "failed to convert ecid";
    }
    uint64_t v4 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApCopyParameters", (uint64_t)v46, v14, v15, v16, v17, v18, v47);
  }
LABEL_47:
  SafeRelease(Mutable);
  return v4;
}

__CFString *AMAuthInstallApCopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 64);
  CFStringAppend(Mutable, @"(");
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4)
  {
    uint64_t v5 = "YES";
    if (*(unsigned char *)(a1 + 57)) {
      CFAllocatorRef v6 = "YES";
    }
    else {
      CFAllocatorRef v6 = "NO";
    }
    if (*(unsigned char *)(v4 + 20)) {
      uint64_t v7 = "YES";
    }
    else {
      uint64_t v7 = "NO";
    }
    if (*(unsigned char *)(v4 + 81)) {
      uint64_t v8 = "YES";
    }
    else {
      uint64_t v8 = "NO";
    }
    if (*(unsigned char *)(v4 + 72)) {
      uint64_t v9 = "YES";
    }
    else {
      uint64_t v9 = "NO";
    }
    if (*(unsigned char *)(v4 + 82)) {
      uint64_t v10 = "YES";
    }
    else {
      uint64_t v10 = "NO";
    }
    if (*(unsigned char *)(v4 + 96)) {
      uint64_t v11 = "YES";
    }
    else {
      uint64_t v11 = "NO";
    }
    if (*(void *)(v4 + 120)) {
      CFAllocatorRef v12 = "YES";
    }
    else {
      CFAllocatorRef v12 = "NO";
    }
    if (!*(void *)(v4 + 128)) {
      uint64_t v5 = "NO";
    }
    CFStringAppendFormat(Mutable, 0, @"personalize=%s %@ ecid=0x%llx, chipid=0x%x, boardid=0x%x, secDom=%d, isProduction=%s, EPRO=%s, isSecure=%s, ESEC=%s, img4=%s, demotionPolicy=%@, managedBaaCert=%s, slowRollBaaCert=%s, dpoc=%@", v6, *(void *)(v4 + 104), *(void *)v4, *(unsigned int *)(v4 + 8), *(unsigned int *)(v4 + 12), *(unsigned int *)(v4 + 16), v7, v8, v9, v10, v11, *(void *)(v4 + 88), v12, v5, *(void *)(v4 + 192));
    uint64_t v13 = *(void *)(a1 + 16);
    if (*(void *)(v13 + 24))
    {
      CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v15 = _CopyHexStringFromData(v14, *(CFDataRef *)(*(void *)(a1 + 16) + 24));
      CFStringAppendFormat(Mutable, 0, @", nonce=0x%@", v15);
      CFRelease(v15);
      uint64_t v13 = *(void *)(a1 + 16);
    }
    if (*(void *)(v13 + 48))
    {
      CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v17 = _CopyHexStringFromData(v16, *(CFDataRef *)(*(void *)(a1 + 16) + 48));
      CFStringAppendFormat(Mutable, 0, @", sepNonce=0x%@", v17);
      CFRelease(v17);
    }
  }
  CFStringAppend(Mutable, @""));
  return Mutable;
}

void AMAuthInstallApFinalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    SafeRelease(*(CFTypeRef *)(v2 + 24));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 32));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 48));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 56));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 88));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 104));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 120));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 128));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 136));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 160));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 168));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 176));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 184));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 192));
    SafeFree(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
  }
  SafeRelease(*(CFTypeRef *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
}

uint64_t AMAuthInstallEnableManagedRequest(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    return AMAuthInstallHttpRequestManagedBaaCertificate(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallEnableManagedRequest", (uint64_t)"amai is NULL", a4, a5, a6, a7, a8, v8);
    return 1;
  }
}

uint64_t AMAuthInstallEnableAlternateUpdateRequest(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    return AMAuthInstallHttpRequestAlternateUpdateBaaCertificate(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallEnableAlternateUpdateRequest", (uint64_t)"amai is NULL", a4, a5, a6, a7, a8, v8);
    return 1;
  }
}

uint64_t AMAuthInstallApEnableLocalPolicyHactivation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 505) = 1;
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApEnableLocalPolicyHactivation", (uint64_t)"amai is NULL", a4, a5, a6, a7, a8, vars0);
    return 1;
  }
  return result;
}

uint64_t AMAuthInstallApEnableRelaxedImageVerification(uint64_t a1, char a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(v2 + 64) = a2;
  return result;
}

uint64_t AMAuthInstallApRemoveInfoDict(const __CFAllocator *a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  CFDictionaryRef v3 = 0;
  uint64_t v4 = 1;
  if (theDict)
  {
    CFAllocatorRef v6 = 0;
    uint64_t v7 = 0;
    if (a3)
    {
      CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(a1, 0, theDict);
      CFDictionaryRef v3 = MutableCopy;
      if (MutableCopy)
      {
        CFIndex Count = CFDictionaryGetCount(MutableCopy);
        CFAllocatorRef v6 = (const void **)malloc(8 * Count);
        uint64_t v10 = (const void **)malloc(8 * Count);
        uint64_t v7 = v10;
        uint64_t v4 = 2;
        if (v6 && v10)
        {
          CFDictionaryGetKeysAndValues(v3, v6, v10);
          if (Count < 1)
          {
LABEL_14:
            uint64_t v4 = 0;
            *a3 = CFRetain(v3);
          }
          else
          {
            uint64_t v11 = 0;
            while (v6[v11])
            {
              CFAllocatorRef v12 = v7[v11];
              if (!v12) {
                break;
              }
              CFTypeID v13 = CFGetTypeID(v12);
              if (v13 == CFDictionaryGetTypeID() && CFDictionaryGetValue((CFDictionaryRef)v7[v11], @"Info")) {
                CFDictionaryRemoveValue((CFMutableDictionaryRef)v7[v11], @"Info");
              }
              if (Count == ++v11) {
                goto LABEL_14;
              }
            }
            uint64_t v4 = 1;
          }
        }
      }
      else
      {
        CFAllocatorRef v6 = 0;
        uint64_t v7 = 0;
        uint64_t v4 = 2;
      }
    }
  }
  else
  {
    CFAllocatorRef v6 = 0;
    uint64_t v7 = 0;
  }
  SafeRelease(v3);
  SafeFree(v6);
  SafeFree(v7);
  return v4;
}

CFIndex AMAuthInstallApCreateMeasurementsWithTag(void *cf, const __CFURL *a2, const __CFString *a3, int a4, char a5, int a6, CFTypeRef *a7)
{
  uint64_t v22 = 0;
  if (!cf)
  {
    CFIndex Code = 1;
    goto LABEL_16;
  }
  CFIndex Code = 1;
  if (a7)
  {
    if (a2)
    {
      uint64_t v10 = cf[2];
      if (v10)
      {
        if (a6 == 2)
        {
          CFAllocatorRef v16 = CFGetAllocator(cf);
          uint64_t MeasurementsWithTag = AMAuthInstallApFtabCreateMeasurementsWithTag(v16, (uint64_t)a2, a3, a4, a7);
        }
        else
        {
          if (a6 == 1)
          {
            CFAllocatorRef v13 = CFGetAllocator(cf);
            uint64_t v14 = AMAuthInstallSupportCopyTagAndFileURL(v13, a2, 0, (CFTypeRef *)&v22);
            if (v14)
            {
              CFIndex Code = v14;
            }
            else
            {
              uint64_t v15 = AMAuthInstallApMeasureBinary(v22, 0x100000, a4);
              *a7 = v15;
              if (v15) {
                CFIndex Code = 0;
              }
              else {
                CFIndex Code = CFErrorGetCode(0);
              }
            }
            goto LABEL_16;
          }
          int v19 = *(unsigned __int8 *)(v10 + 96);
          CFAllocatorRef v20 = CFGetAllocator(cf);
          if (v19) {
            uint64_t MeasurementsWithTag = AMAuthInstallApImg4CreateMeasurementsWithTag(v20, a2, a3, a4, a7);
          }
          else {
            uint64_t MeasurementsWithTag = AMAuthInstallApImg3CreateMeasurementsFromURL(v20, a2, a7, a5);
          }
        }
        CFIndex Code = MeasurementsWithTag;
      }
    }
  }
LABEL_16:
  AMSupportSafeRelease();
  return Code;
}

__CFDictionary *AMAuthInstallApMeasureBinary(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1)
  {
    AMSupportCreateErrorInternal();
    return 0;
  }
  uint64_t Digest = AMAuthInstallApCreateDigest(a1, a2, a3);
  if (!Digest) {
    return 0;
  }
  uint64_t v4 = (const void *)Digest;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFAllocatorRef v6 = Mutable;
  if (Mutable) {
    CFDictionarySetValue(Mutable, @"Digest", v4);
  }
  else {
    AMSupportCreateErrorInternal();
  }
  CFRelease(v4);
  return v6;
}

uint64_t AMAuthInstallApCreateDigest(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && (a3 == 1 || a3 == 384 || a3 == 256))
  {
    return _AMSupportCreateDigest();
  }
  else
  {
    AMSupportCreateErrorInternal();
    return 0;
  }
}

uint64_t AMAuthInstallApCreatePersonalizedResponse(uint64_t a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  int v6 = CFDictionaryContainsKey(theDict, @"Ap,LocalPolicy");
  CFAllocatorRef v13 = 0;
  __int16 v63 = 0;
  CFTypeRef v61 = 0;
  value = 0;
  uint64_t v14 = 1;
  if (a1 && theDict && a3)
  {
    int v15 = v6;
    if (AMAuthInstallApSupportsLocalSigning(a1, (unsigned char *)&v63 + 1, v7, v8, v9, v10, v11, v12)) {
      goto LABEL_30;
    }
    uint64_t v22 = AMAuthInstallApSupportsGlobalSigning(a1, (BOOL *)&v63, v16, v17, v18, v19, v20, v21);
    if (v22 != 13)
    {
      uint64_t v14 = v22;
      if (v22) {
        goto LABEL_30;
      }
    }
    uint64_t v28 = *(void *)(a1 + 16);
    if (v28)
    {
      BOOL v29 = *(unsigned char *)(v28 + 78) != 0;
      if (HIBYTE(v63) && *(unsigned char *)(v28 + 78))
      {
        AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)"Forcing server signing\n", v23, v24, v25, v26, v27, LocalizedStatusString);
        LOBYTE(v29) = 1;
        goto LABEL_16;
      }
    }
    else
    {
      BOOL v29 = 0;
    }
    if (HIBYTE(v63) && !v29)
    {
      CFBooleanRef v30 = (unsigned char *)(a1 + 505);
      if (!*(unsigned char *)(a1 + 505)) {
        goto LABEL_20;
      }
      goto LABEL_19;
    }
LABEL_16:
    if (!v15 || !*(unsigned char *)(a1 + 505))
    {
      if ((_BYTE)v63) {
        char v39 = v29;
      }
      else {
        char v39 = 1;
      }
      if ((v39 & 1) == 0)
      {
        uint64_t v48 = (void *)CFRetain(*(CFTypeRef *)(a1 + 40));
        value = v48;
        if (v48)
        {
          uint64_t v49 = v48;
          CFAllocatorRef v50 = CFGetAllocator((CFTypeRef)a1);
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v50, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFAllocatorRef v13 = Mutable;
          if (Mutable)
          {
            CFDictionaryAddValue(Mutable, *(const void **)(a1 + 88), v49);
            *a3 = CFRetain(v13);
            AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)"Using global signing", v52, v53, v54, v55, v56, LocalizedStatusString);
            uint64_t v14 = 0;
            goto LABEL_31;
          }
          goto LABEL_46;
        }
        v58 = "global ticketData is NULL";
LABEL_45:
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)v58, v32, v33, v34, v35, v36, LocalizedStatusString);
        CFAllocatorRef v13 = 0;
        goto LABEL_46;
      }
      CFAllocatorRef v40 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v41 = AMAuthInstallApRemoveInfoDict(v40, theDict, &v61);
      if (v41)
      {
        uint64_t v14 = v41;
        CFTypeID v59 = "could not remove info dicts from request";
      }
      else
      {
        uint64_t v14 = AMAuthInstallRequestSendSync(a1, v61, a3);
        if (!v14) {
          goto LABEL_30;
        }
        char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v14);
        CFTypeID v59 = "server request error: %@";
      }
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)v59, v42, v43, v44, v45, v46, LocalizedStatusString);
      goto LABEL_30;
    }
    CFBooleanRef v30 = (unsigned char *)(a1 + 505);
    uint64_t v28 = *(void *)(a1 + 16);
LABEL_19:
    *(_DWORD *)(v28 + 68) = 1;
    *(_DWORD *)(v28 + 112) = 384;
LABEL_20:
    uint64_t SignedManifest = AMAuthInstallApImg4LocalCreateSignedManifest((void *)a1, theDict, 0, 0, 0, (CFTypeRef *)&value, v26, v27);
    if (!SignedManifest)
    {
      if (value)
      {
        CFAllocatorRef v37 = CFGetAllocator((CFTypeRef)a1);
        CFBooleanRef v38 = CFDictionaryCreateMutable(v37, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFAllocatorRef v13 = v38;
        if (v38)
        {
          CFDictionaryAddValue(v38, *(const void **)(a1 + 88), value);
          uint64_t v14 = 0;
          *a3 = CFRetain(v13);
          goto LABEL_31;
        }
LABEL_46:
        uint64_t v14 = 2;
        goto LABEL_31;
      }
      v58 = "ticketData is NULL";
      goto LABEL_45;
    }
    uint64_t v14 = SignedManifest;
    if (*v30) {
      v57 = "hacktivated";
    }
    else {
      v57 = "local";
    }
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)"failed to create a %s Img4 ticket", v32, v33, v34, v35, v36, (char)v57);
LABEL_30:
    CFAllocatorRef v13 = 0;
  }
LABEL_31:
  SafeRelease(v13);
  SafeRelease(value);
  SafeRelease(v61);
  return v14;
}

CFStringRef AMAuthInstallApCopyImageTag(const __CFAllocator *a1, CFURLRef anURL)
{
  CFDataRef theData = 0;
  CFStringRef v13 = 0;
  CFTypeRef cf = 0;
  if (anURL)
  {
    CFStringRef v13 = 0;
    CFStringRef v3 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
    if (v3)
    {
      if (!AMAuthInstallApImg4CreateRequestTagFromFileURL(a1, v3, @"=", &v13, (CFURLRef *)&cf)
        && !AMAuthInstallSupportCreateDataFromFileURL(a1, (CFTypeRef *)&theData, cf))
      {
        if (AMAuthInstallApImg3IsImg3Payload(theData))
        {
          SafeRelease(v13);
          if (AMAuthInstallApImg3CopyRequestTag((int)a1, theData, &v13)) {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApCopyImageTag", (uint64_t)"failed to copy img3 tag", v4, v5, v6, v7, v8, v10);
          }
        }
      }
    }
  }
  else
  {
    CFStringRef v3 = 0;
  }
  SafeRelease(theData);
  SafeRelease(v3);
  SafeRelease(cf);
  return v13;
}

uint64_t AMAuthInstallApCopyDeviceEntryFromDeviceMap(void *cf, const __CFData *a2, CFDictionaryRef *a3)
{
  if (a2)
  {
    uint64_t v5 = sub_100008E04(cf, a2, a3);
    goto LABEL_10;
  }
  if (getenv("PLATFORM_DIR"))
  {
    CFAllocatorRef v6 = CFGetAllocator(cf);
    CFStringRef v7 = CFStringCreateWithFormat(v6, 0, @"%s/%@");
    if (!v7) {
      goto LABEL_12;
    }
    CFAllocatorRef v8 = CFGetAllocator(cf);
    CFURLRef v9 = CFURLCreateWithFileSystemPath(v8, v7, kCFURLPOSIXPathStyle, 0);
    if (!v9) {
      goto LABEL_12;
    }
    AMSupportFileURLExists();
    CFRelease(v9);
  }
  CFAllocatorRef v10 = CFGetAllocator(cf);
  CFURLRef v11 = CFURLCreateWithFileSystemPath(v10, @"/usr/local/standalone/firmware/device_map.plist", kCFURLPOSIXPathStyle, 0);
  char v12 = (char)v11;
  if (!v11)
  {
LABEL_12:
    uint64_t v5 = 2;
    goto LABEL_10;
  }
  CFGetAllocator(cf);
  uint64_t DataFromFileURL = AMSupportCreateDataFromFileURL();
  if (DataFromFileURL)
  {
    uint64_t v5 = DataFromFileURL;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApCopyDeviceEntryFromDeviceMap", (uint64_t)"Failed to read devicemap from %@", v14, v15, v16, v17, v18, v12);
  }
  else
  {
    uint64_t v5 = sub_100008E04(cf, 0, a3);
  }
LABEL_10:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v5;
}

uint64_t sub_100008E04(void *cf, const __CFData *a2, CFDictionaryRef *a3)
{
  CFDictionaryRef v3 = 0;
  CFStringRef v4 = @"SecurityDomain";
  CFErrorRef error = 0;
  CFStringRef v5 = @"BoardID";
  uint64_t v6 = 1;
  CFStringRef v7 = @"ChipID";
  if (!cf || !a2)
  {
    CFAllocatorRef v10 = 0;
    CFURLRef v11 = 0;
    goto LABEL_22;
  }
  CFAllocatorRef v10 = 0;
  CFURLRef v11 = 0;
  if (a3)
  {
    if (!*(void *)(cf[2] + 144)) {
      goto LABEL_8;
    }
    uint64_t v36 = *(void *)(cf[2] + 144);
    CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@,%@");
    if (v7)
    {
      uint64_t v36 = *(void *)(cf[2] + 144);
      CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@,%@");
      if (v5)
      {
        uint64_t v36 = *(void *)(cf[2] + 144);
        CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@,%@");
        if (v4)
        {
LABEL_8:
          CFAllocatorRef v18 = CFGetAllocator(cf);
          CFDictionaryRef v19 = (const __CFDictionary *)CFPropertyListCreateWithData(v18, a2, 0, 0, &error);
          CFDictionaryRef v3 = v19;
          if (!v19)
          {
            uint64_t v6 = 3;
            AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApCopyDeviceEntryFromProvidedDeviceMap", (uint64_t)"failed to create dictionary from device_map (Not plist/xml data?): %@", v20, v21, v22, v23, v24, (char)error);
            CFAllocatorRef v10 = 0;
            CFURLRef v11 = 0;
            goto LABEL_22;
          }
          CFIndex Count = CFDictionaryGetCount(v19);
          uint64_t v26 = (const void **)malloc(8 * Count);
          if (!v26)
          {
            CFAllocatorRef v10 = 0;
            CFURLRef v11 = 0;
            uint64_t v6 = 2;
            goto LABEL_22;
          }
          uint64_t v27 = v26;
          CFURLRef v11 = (const void **)malloc(8 * Count);
          if (!v11)
          {
            uint64_t v6 = 2;
            CFAllocatorRef v10 = v27;
            goto LABEL_22;
          }
          uint64_t v28 = a3;
          CFAllocatorRef v37 = v27;
          CFDictionaryGetKeysAndValues(v3, v27, v11);
          if (Count >= 1)
          {
            uint64_t v29 = 0;
            while (1)
            {
              CFDictionaryRef v30 = (const __CFDictionary *)v11[v29];
              if (AMAuthInstallSupportCompareStringToInt32(v30, v7, *(_DWORD *)(cf[2] + 8)))
              {
                if (AMAuthInstallSupportCompareStringToInt32(v30, v5, *(_DWORD *)(cf[2] + 12))
                  && AMAuthInstallSupportCompareStringToInt32(v30, v4, *(_DWORD *)(cf[2] + 16)))
                {
                  break;
                }
              }
              if (Count == ++v29) {
                goto LABEL_20;
              }
            }
            CFTypeID TypeID = CFDictionaryGetTypeID();
            if (TypeID != CFGetTypeID(v30))
            {
              uint64_t v6 = 14;
              goto LABEL_21;
            }
            CFAllocatorRef v32 = CFGetAllocator(cf);
            CFDictionaryRef Copy = CFDictionaryCreateCopy(v32, v30);
            CFDictionaryRef *v28 = Copy;
            if (!Copy)
            {
              uint64_t v6 = 0;
              goto LABEL_21;
            }
          }
LABEL_20:
          uint64_t v6 = 8 * (*v28 == 0);
LABEL_21:
          CFAllocatorRef v10 = v37;
          goto LABEL_22;
        }
        uint64_t v35 = "failed secdomKey allocation";
      }
      else
      {
        uint64_t v35 = "failed boardKey allocation";
      }
    }
    else
    {
      uint64_t v35 = "failed chipKey allocation";
    }
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApCopyDeviceEntryFromProvidedDeviceMap", (uint64_t)v35, v13, v14, v15, v16, v17, v36);
    CFDictionaryRef v3 = 0;
    CFAllocatorRef v10 = 0;
    CFURLRef v11 = 0;
    uint64_t v6 = 99;
  }
LABEL_22:
  SafeRelease(v3);
  SafeFree(v10);
  SafeFree(v11);
  SafeRelease(error);
  SafeRelease(v7);
  SafeRelease(v5);
  SafeRelease(v4);
  return v6;
}

uint64_t AMAuthInstallApApplyRequestRules(void *a1, const __CFData *a2, const __CFURL *a3, __CFDictionary *a4)
{
  CFDictionaryRef theDict = 0;
  CFStringRef v4 = 0;
  uint64_t v5 = 1;
  if (a1 && a3)
  {
    CFStringRef v7 = 0;
    CFAllocatorRef v8 = 0;
    if (a4)
    {
      uint64_t v10 = AMAuthInstallApCopyDeviceEntryFromDeviceMap(a1, a2, &theDict);
      if (v10)
      {
        uint64_t v5 = v10;
        CFStringRef v4 = 0;
        CFStringRef v7 = 0;
        CFAllocatorRef v8 = 0;
      }
      else
      {
        CFAllocatorRef v11 = CFGetAllocator(a1);
        CFStringRef v4 = AMAuthInstallApCopyImageTag(v11, a3);
        if (v4)
        {
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"Manifest");
          if (Value)
          {
            CFDictionaryRef v18 = Value;
            int64_t Count = CFDictionaryGetCount(Value);
            CFStringRef v7 = (const void **)calloc(8uLL, Count);
            uint64_t v20 = (const void **)calloc(8uLL, Count);
            CFAllocatorRef v8 = v20;
            uint64_t v5 = 2;
            if (v7 && v20)
            {
              uint64_t v38 = (uint64_t)a1;
              char v39 = v7;
              CFDictionaryGetKeysAndValues(v18, v7, v20);
              if (Count < 1)
              {
LABEL_21:
                AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApApplyRequestRules", (uint64_t)"failed to find RestoreRequestRules property", v21, v22, v23, v24, v25, v38);
                uint64_t v5 = 8;
              }
              else
              {
                uint64_t v26 = 0;
                while (1)
                {
                  CFDictionaryRef v27 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v8[v26], v4);
                  if (v27)
                  {
                    CFDictionaryRef v28 = v27;
                    uint64_t v29 = CFDictionaryGetValue(v27, @"RequiresPartialDigest");
                    if (v29)
                    {
                      CFDictionaryRef v30 = v29;
                      CFTypeID TypeID = CFBooleanGetTypeID();
                      if (TypeID == CFGetTypeID(v30) && !CFBooleanGetValue((CFBooleanRef)v30)) {
                        CFDictionaryRemoveValue(a4, @"PartialDigest");
                      }
                    }
                    CFAllocatorRef v32 = CFDictionaryGetValue(v28, @"Trusted");
                    if (v32)
                    {
                      uint64_t v33 = v32;
                      CFTypeID v34 = CFBooleanGetTypeID();
                      if (v34 == CFGetTypeID(v33)) {
                        CFDictionarySetValue(a4, @"Trusted", v33);
                      }
                    }
                    CFArrayRef v35 = (const __CFArray *)CFDictionaryGetValue(v28, @"RestoreRequestRules");
                    if (v35) {
                      break;
                    }
                  }
                  if (Count == ++v26) {
                    goto LABEL_21;
                  }
                }
                uint64_t v5 = AMAuthInstallBundleProcessRules(v38, v35, a4);
              }
              CFStringRef v7 = v39;
            }
          }
          else
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApApplyRequestRules", (uint64_t)"failed to find manifest entry", v13, v14, v15, v16, v17, v37);
            CFStringRef v7 = 0;
            CFAllocatorRef v8 = 0;
            uint64_t v5 = 8;
          }
        }
        else
        {
          CFStringRef v7 = 0;
          CFAllocatorRef v8 = 0;
          uint64_t v5 = 3;
        }
      }
    }
  }
  else
  {
    CFStringRef v7 = 0;
    CFAllocatorRef v8 = 0;
  }
  SafeRelease(theDict);
  SafeRelease(v4);
  SafeFree(v7);
  SafeFree(v8);
  return v5;
}

uint64_t AMAuthInstallApExtractZippedDeviceMap(const __CFData *a1, void *a2)
{
  CFURLRef url = 0;
  CFTypeRef v36 = 0;
  CFAllocatorRef Default = CFAllocatorGetDefault();
  uint64_t v5 = AMAuthInstallPlatformCopyURLToNewTempDirectory(Default, "device-map-XXXX", &url);
  if (v5)
  {
    uint64_t v32 = v5;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApExtractZippedDeviceMap", (uint64_t)"failed to create temp dir", v6, v7, v8, v9, v10, v34);
    CFURLRef v12 = 0;
  }
  else
  {
    CFAllocatorRef v11 = CFAllocatorGetDefault();
    CFURLRef v12 = CFURLCreateCopyAppendingPathComponent(v11, url, @"device_map", 0);
    if (v12)
    {
      CFAllocatorRef v13 = CFAllocatorGetDefault();
      uint64_t v14 = AMAuthInstallSupportWriteDataToFileURL(v13, a1, v12, 1);
      if (v14)
      {
        uint64_t v32 = v14;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApExtractZippedDeviceMap", (uint64_t)"failed to write data to %@", v15, v16, v17, v18, v19, (char)v12);
      }
      else
      {
        uint64_t v20 = BbfwReaderOpen(v12);
        if (v20)
        {
          uint64_t v26 = (uint64_t)v20;
          uint64_t v32 = BbfwReaderCopyFileData((uint64_t)v20, &v36);
          if (v32) {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApExtractZippedDeviceMap", (uint64_t)"failed to copy data from %@", v27, v28, v29, v30, v31, (char)v12);
          }
          else {
            *a2 = v36;
          }
          BbfwReaderClose(v26);
        }
        else
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApExtractZippedDeviceMap", (uint64_t)"failed to unzip file", v21, v22, v23, v24, v25, v34);
          uint64_t v32 = 4;
        }
      }
    }
    else
    {
      uint64_t v32 = 2;
    }
  }
  SafeRelease(v12);
  SafeRelease(url);
  return v32;
}

uint64_t AMAuthInstallApCreateImagePropertiesWithDeviceMapZipped(void *a1, const __CFURL *a2, const __CFData *cf, int a4, int a5, CFDictionaryRef *a6)
{
  CFMutableDictionaryRef v6 = 0;
  CFDataRef v41 = 0;
  CFMutableDictionaryRef theDict = 0;
  uint64_t v7 = 1;
  if (a1 && a2 && a6)
  {
    if (cf && a4)
    {
      uint64_t v12 = AMAuthInstallApExtractZippedDeviceMap(cf, &v41);
      if (v12)
      {
        uint64_t v7 = v12;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApCreateImagePropertiesWithDeviceMapZipped", (uint64_t)"failed to extract zipped device map", v13, v14, v15, v16, v17, v39);
        CFMutableDictionaryRef v6 = 0;
        goto LABEL_24;
      }
    }
    else if (cf && (a4 & 1) == 0)
    {
      CFDataRef v41 = (const __CFData *)CFRetain(cf);
    }
    CFIndex MeasurementsWithTag = AMAuthInstallApCreateMeasurementsWithTag(a1, a2, 0, *(_DWORD *)(a1[2] + 112), 0, a5, (CFTypeRef *)&theDict);
    CFMutableDictionaryRef v6 = theDict;
    if (MeasurementsWithTag)
    {
      uint64_t v7 = MeasurementsWithTag;
    }
    else if (theDict)
    {
      if (AMAuthInstallApApplyRequestRules(a1, v41, a2, theDict))
      {
        AMAuthInstallLog(4, (uint64_t)"AMAuthInstallApCreateImagePropertiesWithDeviceMapZipped", (uint64_t)"WARNING: Could not retrieve image properties from devicemap.", v19, v20, v21, v22, v23, v39);
        if (!*(unsigned char *)(a1[2] + 152))
        {
          CFDictionarySetValue(theDict, @"Trusted", kCFBooleanTrue);
          if (*(unsigned char *)(a1[2] + 20)) {
            CFBooleanRef v29 = kCFBooleanTrue;
          }
          else {
            CFBooleanRef v29 = kCFBooleanFalse;
          }
          CFDictionarySetValue(theDict, @"EPRO", v29);
          if (*(unsigned char *)(a1[2] + 72)) {
            CFBooleanRef v30 = kCFBooleanTrue;
          }
          else {
            CFBooleanRef v30 = kCFBooleanFalse;
          }
          CFDictionarySetValue(theDict, @"ESEC", v30);
          AMAuthInstallLog(4, (uint64_t)"AMAuthInstallApCreateImagePropertiesWithDeviceMapZipped", (uint64_t)"WARNING: Consider setting alternate device_map, ie in a device-specific SDK path.  Setting default RestoreRequestRules to: %@", v31, v32, v33, v34, v35, (char)theDict);
        }
        AMAuthInstallLog(4, (uint64_t)"AMAuthInstallApCreateImagePropertiesWithDeviceMapZipped", (uint64_t)"WARNING: Note: This default behavior may change in the future into a hard error.", v24, v25, v26, v27, v28, v40);
      }
      CFAllocatorRef v36 = CFGetAllocator(a1);
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v36, theDict);
      *a6 = Copy;
      uint64_t v7 = 2 * (Copy == 0);
      CFMutableDictionaryRef v6 = theDict;
    }
    else
    {
      uint64_t v7 = 14;
    }
  }
LABEL_24:
  SafeRelease(v6);
  SafeRelease(v41);
  return v7;
}

uint64_t AMAuthInstallApCreateImagePropertiesWithDeviceMap(void *a1, const __CFURL *a2, const __CFData *a3, CFDictionaryRef *a4)
{
  return AMAuthInstallApCreateImagePropertiesWithDeviceMapZipped(a1, a2, a3, 1, 0, a4);
}

uint64_t AMAuthInstallApFtabCreateMeasurementsWithTag(const __CFAllocator *a1, uint64_t a2, CFStringRef theString, int a4, CFTypeRef *a5)
{
  value = 0;
  uint64_t v5 = 1;
  if (a2 && theString && a5)
  {
    uint64_t v54 = 0;
    if (CFStringGetLength(theString) == 4)
    {
      CFDataRef v16 = (const __CFData *)sub_100009BCC((uint64_t)a1, a2, (uint64_t)&v54, v11, v12, v13, v14, v15);
      CFDataRef v22 = v16;
      if (v16)
      {
        CFIndex Length = CFDataGetLength(v16);
        BytePtr = CFDataGetBytePtr(v22);
        if (CFStringGetCString(theString, buffer, 5, 0x8000100u))
        {
          if (*(_DWORD *)(v54 + 40))
          {
            uint64_t v25 = 0;
            unint64_t v26 = 0;
            while (1)
            {
              AMAuthInstallLog(7, (uint64_t)"AMAuthInstallApFtabCopyDataForTag", (uint64_t)"Payload %2d: [%.4s], %7u bytes.", v17, v18, v19, v20, v21, v26);
              uint64_t v27 = v54 + v25;
              if (*(_DWORD *)(v54 + v25 + 48) == *(_DWORD *)buffer) {
                break;
              }
              ++v26;
              v25 += 16;
              if (v26 >= *(unsigned int *)(v54 + 40)) {
                goto LABEL_11;
              }
            }
            uint64_t v34 = *(unsigned int *)(v27 + 52);
            CFIndex v33 = *(unsigned int *)(v27 + 56);
            if (Length < (v33 + v34))
            {
              CFAllocatorRef v50 = "Encoded payload is larger than data.";
            }
            else
            {
              CFDataRef v35 = CFDataCreate(a1, &BytePtr[v34], v33);
              if (v35)
              {
                CFDataRef v36 = v35;
                AMSupportSafeRelease();
                AMAuthInstallCryptoCreateDigestForDataType(a1, v36, (CFTypeRef *)&value, a4);
                if (value)
                {
                  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  uint64_t v48 = Mutable;
                  if (Mutable)
                  {
                    CFDictionarySetValue(Mutable, @"Digest", value);
                    uint64_t v5 = 0;
                    *a5 = CFRetain(v48);
                    goto LABEL_18;
                  }
                  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApFtabCreateMeasurementsWithTag", (uint64_t)"failed to create mutable dict measurementDict", v43, v44, v45, v46, v47, v51);
                }
                else
                {
                  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApFtabCreateMeasurementsWithTag", (uint64_t)"created digest is NULL", v37, v38, v39, v40, v41, v51);
                }
                uint64_t v5 = 2;
                goto LABEL_18;
              }
              CFAllocatorRef v50 = "payload is NULL";
            }
            goto LABEL_25;
          }
LABEL_11:
          uint64_t v5 = 8;
LABEL_12:
          AMSupportSafeRelease();
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApFtabCreateMeasurementsWithTag", (uint64_t)"AMAuthInstallApFtabCopyDataForTag returned %d", v28, v29, v30, v31, v32, v5);
          goto LABEL_18;
        }
        CFAllocatorRef v50 = "CFStringGetCString failed.";
      }
      else
      {
        CFAllocatorRef v50 = "ftabData is NULL";
      }
LABEL_25:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApFtabCopyDataForTag", (uint64_t)v50, v17, v18, v19, v20, v21, v51);
      uint64_t v5 = 99;
      goto LABEL_12;
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApFtabCopyDataForTag", (uint64_t)"payloadTag is not 4 bytes", v11, v12, v13, v14, v15, v51);
    uint64_t v5 = 1;
    goto LABEL_12;
  }
LABEL_18:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v5;
}

uint64_t AMAuthInstallApFtabStitchTicketData(const void **a1, uint64_t a2, const __CFURL *a3, const __CFDictionary *a4)
{
  uint64_t v45 = 0;
  CFAllocatorRef v8 = CFGetAllocator(a1);
  uint64_t v9 = 1;
  if (a2 && a3 && a4)
  {
    CFAllocatorRef v10 = v8;
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a4, a1[11]);
    if (Value)
    {
      CFDataRef v17 = Value;
      CFIndex Length = CFDataGetLength(Value);
      if (Length > 0)
      {
        CFIndex v24 = Length;
        CFDataRef v25 = (const __CFData *)sub_100009BCC((uint64_t)v10, a2, (uint64_t)&v45, v19, v20, v21, v22, v23);
        uint64_t v31 = v25;
        if (v25)
        {
          int v32 = CFDataGetLength(v25);
          BytePtr = CFDataGetBytePtr(v17);
          CFDataAppendBytes(v31, BytePtr, v24);
          uint64_t v34 = v45;
          *(_DWORD *)(v45 + 16) = v32;
          *(_DWORD *)(v34 + 20) = v24;
          int v35 = CFDataGetLength(v31);
          CFDataIncreaseLength(v31, -v35 & 0xFFFLL);
          uint64_t v36 = AMAuthInstallSupportWriteDataToFileURL(v10, v31, a3, 1);
          if (v36)
          {
            uint64_t v43 = v36;
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApFtabStitchTicketData", (uint64_t)"%s: Failed to copy FTAB file to personalized bundle.", v37, v38, v39, v40, v41, (char)"AMAuthInstallApFtabStitchTicketData");
            uint64_t v9 = v43;
          }
          else
          {
            uint64_t v9 = 0;
          }
        }
        else
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApFtabStitchTicketData", (uint64_t)"ftabData is NULL", v26, v27, v28, v29, v30, v44);
          uint64_t v9 = 99;
        }
        goto LABEL_9;
      }
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApFtabStitchTicketData", (uint64_t)"%s: responseDict has an empty ticket.", v19, v20, v21, v22, v23, (char)"AMAuthInstallApFtabStitchTicketData");
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApFtabStitchTicketData", (uint64_t)"%s: responseDict doesn't contain a %@ ticket.", v12, v13, v14, v15, v16, (char)"AMAuthInstallApFtabStitchTicketData");
    }
    uint64_t v9 = 17;
  }
LABEL_9:
  AMSupportSafeRelease();
  return v9;
}

uint64_t sub_100009BCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    CFAllocatorRef v10 = "fileURL is NULL";
    goto LABEL_8;
  }
  if (!a3)
  {
    CFAllocatorRef v10 = "outFtab is NULL";
    goto LABEL_8;
  }
  int DataFromFileURL = AMSupportCreateDataFromFileURL();
  if (!DataFromFileURL)
  {
    CFAllocatorRef v10 = "fileData is NULL";
LABEL_8:
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApFtabCopyFtabFromFile", (uint64_t)v10, a4, a5, a6, a7, a8, v11);
    goto LABEL_9;
  }
  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApFtabCopyFtabFromFile", (uint64_t)"AMSupportCreateDataFromFileURL returned %d", a4, a5, a6, a7, a8, DataFromFileURL);
LABEL_9:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return 0;
}

uint64_t AMAuthInstallApImg3SupportsLocalSigning()
{
  return 0;
}

uint64_t image3SHA1Generate(const void *a1, CC_LONG a2, unsigned __int8 *a3)
{
  memset(&v7, 0, sizeof(v7));
  CC_SHA1_Init(&v7);
  CC_SHA1_Update(&v7, a1, a2);
  return CC_SHA1_Final(a3, &v7);
}

uint64_t image3PKISignHash(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  return 0;
}

int8x16_t image3SHA1Partial(const void *a1, CC_LONG a2, int8x16_t *a3)
{
  memset(&v7, 0, sizeof(v7));
  CC_SHA1_Init(&v7);
  CC_SHA1_Update(&v7, a1, a2);
  int8x16_t result = vrev32q_s8(*(int8x16_t *)&v7.h0);
  *a3 = result;
  a3[1].i32[0] = bswap32(v7.h4);
  return result;
}

uint64_t AMAuthInstallApImg3CreateServerRequestDictionary(void *a1, const void *a2, const void *a3, int a4, CFTypeRef *a5)
{
  uint64_t v5 = 0;
  uint64_t v6 = 1;
  if (a1 && a2 && a3 && a5)
  {
    CFAllocatorRef v12 = CFGetAllocator(a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v12, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v5 = Mutable;
    if (Mutable)
    {
      CFDictionarySetValue(Mutable, a2, a3);
      uint64_t v6 = AMAuthInstallApServerRequestAddRequiredTags(a1, v5, a4, v14, v15, v16, v17, v18);
      if (!v6) {
        *a5 = CFRetain(v5);
      }
    }
    else
    {
      uint64_t v6 = 2;
    }
  }
  SafeRelease(v5);
  return v6;
}

uint64_t AMAuthInstallApImg3ServerRequestAddRequiredTags(void *a1, __CFDictionary *a2, int a3, int a4)
{
  CFMutableDictionaryRef v24 = a2;
  if (!a1) {
    return 1;
  }
  CFIndex v5 = 1;
  if (a2)
  {
    uint64_t v7 = a1[2];
    if (v7)
    {
      if (*(void *)v7)
      {
        _CFDictionarySetInteger64(a2, @"ApECID", *(void *)v7);
        uint64_t v7 = a1[2];
      }
      _CFDictionarySetInteger32(a2, @"ApChipID", *(_DWORD *)(v7 + 8));
      _CFDictionarySetInteger32(a2, @"ApBoardID", *(_DWORD *)(a1[2] + 12));
      uint64_t v10 = a1[2];
      if (!*(unsigned char *)(v10 + 116))
      {
        _CFDictionarySetBoolean(a2, @"ApProductionMode", *(unsigned __int8 *)(v10 + 20));
        uint64_t v10 = a1[2];
      }
      _CFDictionarySetInteger32(a2, @"ApSecurityDomain", *(_DWORD *)(v10 + 16));
      if (a3)
      {
        CFDictionarySetValue(a2, @"@APTicket", kCFBooleanTrue);
        uint64_t v11 = a1[2];
        CFAllocatorRef v12 = *(const void **)(v11 + 24);
        if (v12 && !*(unsigned char *)(v11 + 116))
        {
          CFDictionarySetValue(a2, @"ApNonce", v12);
          uint64_t v11 = a1[2];
        }
        if (*(unsigned char *)(v11 + 64)) {
          CFDictionarySetValue(a2, @"ApRelaxedImageVerification", kCFBooleanTrue);
        }
      }
      CFIndex v5 = 0;
      if (!a4)
      {
        CFDictionaryRef v13 = (const __CFDictionary *)a1[53];
        if (v13)
        {
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v13, @"ApRequestEntries");
          if (Value)
          {
            CFDictionaryRef v15 = Value;
            int v16 = CFGetAllocator(a1);
            CFIndex v5 = AMAuthInstallSupportApplyDictionaryOverrides(v16, v15, &v24, 0);
            if (v5) {
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg3ServerRequestAddRequiredTags", (uint64_t)"failed to set Ap entitlements", v17, v18, v19, v20, v21, v23);
            }
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return v5;
}

uint64_t AMAuthInstallApImg3CreatePersonalizedData(const void *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4, CFTypeRef *a5)
{
  memset(length, 0, sizeof(length));
  CFAllocatorRef v10 = AMAuthInstallSupportCopyAllocator();
  BytePtr = (UInt8 *)CFDataGetBytePtr(a2);
  LODWORD(a2) = CFDataGetLength(a2);
  CFAllocatorRef v12 = (UInt8 *)CFDataGetBytePtr(a4);
  CFDictionaryRef v13 = CFDataGetBytePtr(a3);
  CFIndex v14 = CFDataGetLength(a3);
  if (tss_stitch_img3(BytePtr, (int)a2, v12, v13, v14, &length[1], length, v15))
  {
    CFDataRef v16 = 0;
    uint64_t v17 = 9;
  }
  else
  {
    CFAllocatorRef v18 = CFGetAllocator(a1);
    CFDataRef v19 = CFDataCreateWithBytesNoCopy(v18, *(const UInt8 **)&length[1], length[0], v10);
    CFDataRef v16 = v19;
    if (v19)
    {
      uint64_t v17 = 0;
      *a5 = CFRetain(v19);
    }
    else
    {
      free(*(void **)&length[1]);
      uint64_t v17 = 2;
    }
  }
  SafeRelease(v16);
  SafeRelease(v10);
  return v17;
}

uint64_t AMAuthInstallApImg3PersonalizeWithEntryName(void *a1, const __CFURL *a2, const __CFURL *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return AMAuthInstallApImg3PersonalizeImg3WithEntryNameAndOptions(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t AMAuthInstallApImg3PersonalizeImg3WithEntryNameAndOptions(void *a1, const __CFURL *a2, const __CFURL *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6, char a7)
{
  *(void *)CFIndex v14 = 0;
  if (a1)
  {
    CFDataRef v8 = 0;
    uint64_t v9 = 1;
    if (a3 && a2 && a1[2])
    {
      uint64_t v11 = AMAuthInstallApImg3CopyPersonalizedData(a1, a2, a4, a5, a6, (CFTypeRef *)v14, a7 & 1);
      if (v11)
      {
        uint64_t v9 = v11;
        CFDataRef v8 = *(const __CFData **)v14;
      }
      else
      {
        CFAllocatorRef v12 = CFGetAllocator(a1);
        CFDataRef v8 = *(const __CFData **)v14;
        uint64_t v9 = AMAuthInstallSupportWriteDataToFileURL(v12, *(const __CFData **)v14, a3, 1);
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
    uint64_t v9 = 1;
  }
  SafeRelease(v8);
  return v9;
}

uint64_t AMAuthInstallApImg3CreateMeasurementsFromURL(const __CFAllocator *a1, const __CFURL *a2, CFTypeRef *a3, char a4)
{
  CFDataRef v4 = 0;
  CFDataRef theData = 0;
  uint64_t v5 = 1;
  if (!a2)
  {
    CFDataRef v7 = 0;
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_11;
  }
  CFDataRef v7 = 0;
  CFMutableDictionaryRef Mutable = 0;
  if (a3)
  {
    uint64_t DataFromFileURL = AMAuthInstallPlatformCreateDataFromFileURL(a1, (CFTypeRef *)&theData, a2);
    if (DataFromFileURL)
    {
      uint64_t v5 = DataFromFileURL;
      CFDataRef v4 = 0;
      CFDataRef v7 = 0;
      CFMutableDictionaryRef Mutable = 0;
      goto LABEL_11;
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
      int Length = CFDataGetLength(theData);
      if (tss_get_partial_hash(BytePtr, Length, 64, (uint64_t)bytes, v14, v15, v16, v17))
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg3CreateMeasurementsFromURL", (uint64_t)"failed to compute partial digest for img3 object", v18, v19, v20, v21, v22, (char)theData);
        CFDataRef v4 = 0;
        CFDataRef v7 = 0;
LABEL_8:
        uint64_t v5 = 5;
        goto LABEL_11;
      }
      CFDataRef v7 = CFDataCreate(a1, bytes, 28);
      if (v7)
      {
        CFDictionarySetValue(Mutable, @"PartialDigest", v7);
        if (a4)
        {
          CFDataRef v4 = 0;
LABEL_15:
          uint64_t v5 = 0;
          *a3 = CFRetain(Mutable);
          goto LABEL_11;
        }
        CFMutableDictionaryRef v24 = CFDataGetBytePtr(theData);
        int v25 = CFDataGetLength(theData);
        if (tss_get_hash((uint64_t)v24, v25, (uint64_t)v37, v26, v27, v28, v29, v30))
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg3CreateMeasurementsFromURL", (uint64_t)"failed to compute digest for img3 object", v31, v32, v33, v34, v35, (char)theData);
          CFDataRef v4 = 0;
          goto LABEL_8;
        }
        CFDataRef v4 = CFDataCreate(a1, v37, 20);
        if (v4)
        {
          CFDictionarySetValue(Mutable, @"Digest", v4);
          goto LABEL_15;
        }
      }
      else
      {
        CFDataRef v4 = 0;
      }
    }
    else
    {
      CFDataRef v4 = 0;
      CFDataRef v7 = 0;
    }
    uint64_t v5 = 2;
  }
LABEL_11:
  SafeRelease(theData);
  SafeRelease(v4);
  SafeRelease(v7);
  SafeRelease(Mutable);
  return v5;
}

uint64_t AMAuthInstallApImg3CopyPersonalizedData(void *a1, const __CFURL *a2, CFStringRef a3, const void *a4, const __CFDictionary *a5, CFTypeRef *a6, char a7)
{
  CFTypeRef v10 = a4;
  CFTypeRef v36 = 0;
  CFDictionaryRef theDict = a5;
  CFTypeRef v34 = 0;
  CFDataRef v35 = 0;
  SafeRetain(a4);
  SafeRetain(a5);
  if (!a1 || !a1[2])
  {
    uint64_t v15 = 1;
    goto LABEL_26;
  }
  if (v10)
  {
    if (a3) {
      goto LABEL_11;
    }
  }
  else
  {
    CFTypeRef v33 = 0;
    CFAllocatorRef v16 = CFGetAllocator(a1);
    uint64_t v17 = AMAuthInstallApImg3CreateMeasurementsFromURL(v16, a2, &v33, a7);
    if (v17)
    {
      uint64_t v15 = v17;
      CFTypeRef v10 = 0;
      goto LABEL_26;
    }
    CFTypeRef v10 = v33;
    if (a3)
    {
LABEL_11:
      if (!a5)
      {
        uint64_t DataFromFileURL = AMAuthInstallApImg3CreateServerRequestDictionary(a1, a3, v10, 0, &v36);
        if (DataFromFileURL) {
          goto LABEL_20;
        }
        uint64_t DataFromFileURL = AMAuthInstallRequestSendSync((uint64_t)a1, v36, (CFTypeRef *)&theDict);
        if (DataFromFileURL) {
          goto LABEL_20;
        }
      }
      CFAllocatorRef v18 = CFGetAllocator(a1);
      uint64_t DataFromFileURL = AMAuthInstallPlatformCreateDataFromFileURL(v18, (CFTypeRef *)&v35, a2);
      if (DataFromFileURL) {
        goto LABEL_20;
      }
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, a3);
      if (Value)
      {
        CFDictionaryRef v26 = Value;
        CFDataRef v27 = (const __CFData *)CFDictionaryGetValue(Value, @"Blob");
        if (v27)
        {
          CFDataRef v28 = v27;
          CFDataRef v29 = (const __CFData *)CFDictionaryGetValue(v26, @"PartialDigest");
          if (v29)
          {
            uint64_t v30 = &v34;
            uint64_t DataFromFileURL = AMAuthInstallApImg3CreatePersonalizedData(a1, v35, v28, v29, &v34);
            if (!DataFromFileURL) {
              goto LABEL_25;
            }
LABEL_20:
            uint64_t v15 = DataFromFileURL;
            goto LABEL_26;
          }
          uint64_t v31 = "response missing partial digest for \"%@\"";
        }
        else
        {
          uint64_t v31 = "response missing personalization data for \"%@\"";
        }
      }
      else
      {
        uint64_t v31 = "response missing entry \"%@\"";
      }
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg3CopyPersonalizedData", (uint64_t)v31, v21, v22, v23, v24, v25, (char)a3);
      uint64_t v30 = (CFTypeRef *)&v35;
LABEL_25:
      uint64_t v15 = 0;
      *a6 = CFRetain(*v30);
      goto LABEL_26;
    }
  }
  CFAllocatorRef v14 = CFGetAllocator(a1);
  a3 = AMAuthInstallApCopyImageTag(v14, a2);
  if (a3) {
    goto LABEL_11;
  }
  uint64_t v15 = 0;
LABEL_26:
  SafeRelease(v36);
  SafeRelease(v10);
  SafeRelease(theDict);
  SafeRelease(v35);
  SafeRelease(v34);
  return v15;
}

uint64_t AMAuthInstallApImg3PersonalizeFile(void *a1, const __CFURL *a2, const __CFURL *a3, const void *a4)
{
  return AMAuthInstallApImg3PersonalizeImg3WithEntryNameAndOptions(a1, a2, a3, 0, a4, 0, 0);
}

CFDataRef AMAuthInstallApImg3IsImg3Payload(const __CFData *result)
{
  if (result)
  {
    BytePtr = (UInt8 *)CFDataGetBytePtr(result);
    return (const __CFData *)(tss_image_is_img3(BytePtr) == 0);
  }
  return result;
}

uint64_t AMAuthInstallApImg3IsFinalized(const __CFAllocator *a1, CFTypeRef cf, BOOL *a3)
{
  CFDataRef theData = 0;
  uint64_t DataFromFileURL = AMAuthInstallSupportCreateDataFromFileURL(a1, (CFTypeRef *)&theData, cf);
  if (!DataFromFileURL)
  {
    BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
    *a3 = tss_image_is_finalized(BytePtr, v6, v7, v8, v9, v10, v11, v12) == 0;
  }
  SafeRelease(theData);
  return DataFromFileURL;
}

uint64_t AMAuthInstallApImg3Finalize(const __CFAllocator *a1, CFTypeRef cf, const __CFURL *a3)
{
  CFIndex v21 = 0;
  uint64_t v22 = 0;
  CFDataRef theData = 0;
  uint64_t v20 = 0;
  uint64_t DataFromFileURL = AMAuthInstallSupportCreateDataFromFileURL(a1, (CFTypeRef *)&theData, cf);
  if (DataFromFileURL)
  {
    uint64_t v16 = DataFromFileURL;
    CFDataRef v12 = 0;
    CFDataRef v15 = 0;
  }
  else
  {
    CFDataRef MutableCopy = CFDataCreateMutableCopy(a1, 0, theData);
    CFDataRef v12 = MutableCopy;
    if (MutableCopy)
    {
      BytePtr = (UInt8 *)CFDataGetBytePtr(MutableCopy);
      CFIndex Length = CFDataGetLength(v12);
      if (image3InstantiateFromBuffer(&v20, BytePtr, Length, 1))
      {
        CFDataRef v15 = 0;
        uint64_t v16 = 9;
        uint64_t v17 = "%s: invalid image 3 object";
LABEL_10:
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg3Finalize", (uint64_t)v17, v6, v7, v8, v9, v10, (char)"AMAuthInstallApImg3Finalize");
        goto LABEL_11;
      }
      if (image3Finalize(v20, (char **)&v22, &v21, 1, 0))
      {
        CFDataRef v15 = 0;
        uint64_t v16 = 14;
        uint64_t v17 = "%s: failed to finalize image";
        goto LABEL_10;
      }
      CFDataRef v15 = CFDataCreate(a1, v22, v21);
      if (v15)
      {
        uint64_t v16 = AMAuthInstallSupportWriteDataToFileURL(a1, v15, a3, 1);
        if (!v16) {
          goto LABEL_11;
        }
        uint64_t v17 = "%s: failed to write finalized image3";
        goto LABEL_10;
      }
      uint64_t v16 = 0;
    }
    else
    {
      CFDataRef v15 = 0;
      uint64_t v16 = 2;
    }
  }
LABEL_11:
  if (v20) {
    image3Discard(&v20);
  }
  if (v16) {
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallApImg3Finalize", (uint64_t)"%s: %@", v6, v7, v8, v9, v10, (char)"AMAuthInstallApImg3Finalize");
  }
  SafeRelease(theData);
  SafeRelease(v12);
  SafeRelease(v15);
  return v16;
}

uint64_t AMAuthInstallApImg3CopyBuildString(const __CFAllocator *a1, CFTypeRef cf, CFStringRef *a3)
{
  CFDataRef theData = 0;
  uint64_t v27 = 0;
  __s = 0;
  uint64_t DataFromFileURL = AMAuthInstallSupportCreateDataFromFileURL(a1, (CFTypeRef *)&theData, cf);
  if (DataFromFileURL)
  {
    uint64_t v22 = DataFromFileURL;
    goto LABEL_20;
  }
  BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  if (image3InstantiateFromBuffer(&v27, BytePtr, Length, 0))
  {
    uint64_t v22 = 9;
    uint64_t v24 = "%s: invalid image 3 object";
    goto LABEL_19;
  }
  if (image3GetTagString(v27, 1447383635, &__s, 0))
  {
    uint64_t v22 = 9;
    uint64_t v24 = "%s: failed to get tag";
    goto LABEL_19;
  }
  CFAllocatorRef v18 = __s;
  if (!strchr(__s, 126))
  {
    size_t v19 = strlen(v18);
    if (v19 + 1 < 2)
    {
      uint64_t v22 = 99;
      uint64_t v24 = "$s: failed to get tag buffer length";
    }
    else
    {
      uint64_t v20 = (char *)realloc(v18, v19 + 2);
      __s = v20;
      if (v20)
      {
        *(_WORD *)&v20[strlen(v20)] = 126;
        CFAllocatorRef v18 = __s;
        goto LABEL_8;
      }
      uint64_t v22 = 2;
      uint64_t v24 = "$s: failed to realloc tag buffer";
    }
LABEL_19:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg3CopyBuildString", (uint64_t)v24, v13, v14, v15, v16, v17, (char)"AMAuthInstallApImg3CopyBuildString");
    goto LABEL_20;
  }
LABEL_8:
  CFStringRef v21 = CFStringCreateWithCString(a1, v18, 0x8000100u);
  *a3 = v21;
  if (v21)
  {
    uint64_t v22 = 0;
    goto LABEL_10;
  }
  uint64_t v22 = 2;
LABEL_20:
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallApImg3CopyBuildString", (uint64_t)"%s: %@", v6, v7, v8, v9, v10, (char)"AMAuthInstallApImg3CopyBuildString");
LABEL_10:
  if (v27) {
    image3Discard(&v27);
  }
  SafeRelease(theData);
  SafeFree(__s);
  return v22;
}

uint64_t AMAuthInstallApImg3CopyRequestTag(int a1, CFDataRef theData, void *a3)
{
  uint64_t v31 = 0;
  uint64_t v29 = 0;
  uint64_t v3 = 1;
  if (!theData || !a3) {
    goto LABEL_16;
  }
  BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  if (image3InstantiateFromBuffer(&v29, BytePtr, Length, 0))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg3CopyRequestTag", (uint64_t)"%s: invalid image 3 object", v8, v9, v10, v11, v12, (char)"AMAuthInstallApImg3CopyRequestTag");
  }
  else
  {
    if (!image3GetTagSignedNumber(v29, 1415139397, &v31, 0))
    {
      uint64_t v18 = 0;
      uint64_t v30 = bswap32(v31);
      uint64_t v31 = v30;
      do
      {
        if (CFStringGetCString(off_10009D1A8[v18 + 1], buffer, 5, 0x8000100u))
        {
          if (v30 == *(_DWORD *)buffer && BYTE4(v30) == v28)
          {
            CFTypeRef v26 = CFRetain(off_10009D1A8[v18]);
            *a3 = v26;
            if (v26) {
              goto LABEL_13;
            }
            goto LABEL_18;
          }
        }
        v18 += 2;
      }
      while (v18 != 56);
      if (*a3)
      {
LABEL_13:
        uint64_t v3 = 0;
        goto LABEL_14;
      }
LABEL_18:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg3CopyRequestTag", (uint64_t)"failed to find entry for %@", v19, v20, v21, v22, v23, 0);
      uint64_t v3 = 8;
      goto LABEL_14;
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg3CopyRequestTag", (uint64_t)"%s: failed to get tag", v13, v14, v15, v16, v17, (char)"AMAuthInstallApImg3CopyRequestTag");
  }
  uint64_t v3 = 9;
LABEL_14:
  if (v29) {
    image3Discard(&v29);
  }
LABEL_16:
  SafeRelease(0);
  return v3;
}

CFStringRef AMAuthInstallApImg4GetTypeForEntryName(CFStringRef theString1)
{
  uint64_t v2 = 0;
  while (CFStringCompare(theString1, off_10009D380[v2], 0))
  {
    v2 += 2;
    if (v2 == 200)
    {
      uint64_t v3 = 0;
      goto LABEL_6;
    }
  }
  uint64_t v3 = off_10009D380[v2 + 1];
LABEL_6:
  if (v3) {
    return v3;
  }
  else {
    return theString1;
  }
}

CFStringRef AMAuthInstallApImg4GetEntryNameForType(CFStringRef theString1)
{
  uint64_t v2 = 0;
  while (CFStringCompare(theString1, off_10009D380[v2 + 1], 0))
  {
    v2 += 2;
    if (v2 == 200)
    {
      CFStringRef result = 0;
      goto LABEL_6;
    }
  }
  CFStringRef result = (CFStringRef)CFRetain(off_10009D380[v2]);
LABEL_6:
  if (!result) {
    return theString1;
  }
  return result;
}

uint64_t AMAuthInstallApImg4CreateRequestTagFromFileURL(const __CFAllocator *a1, CFStringRef theString, CFStringRef stringToFind, CFStringRef *a4, CFURLRef *a5)
{
  CFStringRef v5 = 0;
  CFTypeRef cf = 0;
  uint64_t v6 = 1;
  if (!theString || !stringToFind || !a4)
  {
    CFStringRef v9 = 0;
    goto LABEL_16;
  }
  CFStringRef v9 = 0;
  if (a5)
  {
    CFIndex location = CFStringFind(theString, stringToFind, 0).location;
    if (location == -1)
    {
      CFURLRef v17 = CFURLCreateWithFileSystemPath(a1, theString, kCFURLPOSIXPathStyle, 0);
      *a5 = v17;
      if (v17)
      {
        uint64_t v18 = AMAuthInstallSupportCreateDataFromFileURL(a1, &cf, v17);
        if (v18)
        {
          uint64_t v6 = v18;
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateRequestTagFromFileURL", (uint64_t)"failed to create file from %@", v20, v21, v22, v23, v24, (char)theString);
          CFStringRef v5 = 0;
        }
        else
        {
          CFStringRef v25 = AMAuthInstallApImg4CopyPayloadType(a1, cf, v19, v20, v21, v22, v23, v24);
          CFStringRef v5 = v25;
          if (v25)
          {
            CFStringRef EntryNameForType = AMAuthInstallApImg4GetEntryNameForType(v25);
            *a4 = EntryNameForType;
            if (!EntryNameForType)
            {
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateRequestTagFromFileURL", (uint64_t)"entry not found for %@", v32, v33, v34, v35, v36, (char)v5);
              CFStringRef v9 = 0;
              uint64_t v6 = 8;
              goto LABEL_16;
            }
            CFRetain(EntryNameForType);
            CFStringRef v9 = 0;
LABEL_15:
            uint64_t v6 = 0;
            goto LABEL_16;
          }
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateRequestTagFromFileURL", (uint64_t)"failed to get payload type from %@", v26, v27, v28, v29, v30, (char)theString);
        }
        CFStringRef v9 = 0;
        goto LABEL_16;
      }
      CFStringRef v5 = 0;
      CFStringRef v9 = 0;
    }
    else
    {
      CFIndex v13 = location;
      CFIndex v14 = location + 1;
      v39.length = CFStringGetLength(theString) - (location + 1);
      v39.CFIndex location = v14;
      CFStringRef v9 = CFStringCreateWithSubstring(a1, theString, v39);
      if (v9)
      {
        CFURLRef v15 = CFURLCreateWithFileSystemPath(a1, v9, kCFURLPOSIXPathStyle, 0);
        *a5 = v15;
        if (v15)
        {
          v40.CFIndex location = 0;
          v40.length = v13;
          CFStringRef v16 = CFStringCreateWithSubstring(a1, theString, v40);
          CFStringRef v5 = 0;
          *a4 = v16;
          if (!v16) {
            goto LABEL_20;
          }
          goto LABEL_15;
        }
      }
      CFStringRef v5 = 0;
    }
LABEL_20:
    uint64_t v6 = 2;
  }
LABEL_16:
  SafeRelease(cf);
  SafeRelease(v5);
  SafeRelease(0);
  SafeRelease(v9);
  return v6;
}

CFStringRef AMAuthInstallApImg4CopyPayloadType(const __CFAllocator *a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v16 = 0;
  if (!cf)
  {
    CFIndex v13 = "inputData is NULL";
LABEL_15:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CopyPayloadType", (uint64_t)v13, a4, a5, a6, a7, a8, v14);
    return 0;
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != CFDataGetTypeID())
  {
    CFIndex v13 = "inputData is not of type CFDataRef";
    goto LABEL_15;
  }
  int v18 = 0;
  uint64_t v19 = 0;
  memset(numBytes, 0, sizeof(numBytes));
  uint64_t Length = CFDataGetLength((CFDataRef)cf);
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr((CFDataRef)cf);
  if (DERDecoderInitialize((uint64_t)&Length + 4, BytePtr, (unsigned int *)&Length, Length))
  {
    CFIndex v13 = "DERDecoderInitialize top level failed";
    goto LABEL_15;
  }
  if (DERDecoderGetDataWithTag((uint64_t)&Length + 4, 0, 0x10u, 1, &numBytes[1], numBytes, &v16))
  {
    CFIndex v13 = "could not find im4p top level sequence";
    goto LABEL_15;
  }
  if (DERDecoderInitialize((uint64_t)&Length + 4, *(unsigned __int8 **)&numBytes[1], numBytes, numBytes[0]))
  {
    CFIndex v13 = "DERDecoderInitialize sequence failed";
    goto LABEL_15;
  }
  int v16 = 1;
  if (DERDecoderGetDataWithTag((uint64_t)&Length + 4, 0, 0x16u, 0, &numBytes[1], numBytes, &v16))
  {
    CFIndex v13 = "could not find im4p payload type";
    goto LABEL_15;
  }
  return CFStringCreateWithBytes(a1, *(const UInt8 **)&numBytes[1], numBytes[0], 0x8000100u, 0);
}

CFDataRef AMAuthInstallApImg4IsImg4Payload(const __CFAllocator *a1, CFDataRef theData)
{
  CFDataRef v2 = theData;
  v10[0] = 0;
  v10[1] = 0;
  uint64_t v9 = 0;
  memset(numBytes, 0, sizeof(numBytes));
  if (!theData) {
    goto LABEL_13;
  }
  HIDWORD(v9) = CFDataGetLength(theData);
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v2);
  if (DERDecoderInitialize((uint64_t)v10, BytePtr, (unsigned int *)&v9 + 1, HIDWORD(v9))
    || DERDecoderGetDataWithTag((uint64_t)v10, 0, 0x10u, 1, &numBytes[1], numBytes, (int *)&v9)
    || DERDecoderInitialize((uint64_t)v10, *(unsigned __int8 **)&numBytes[1], numBytes, numBytes[0])
    || (LODWORD(v9) = 0,
        DERDecoderGetDataWithTag((uint64_t)v10, 0, 0x16u, 0, &numBytes[1], numBytes, (int *)&v9)))
  {
    CFDataRef v2 = 0;
LABEL_13:
    CFStringRef v6 = 0;
    goto LABEL_11;
  }
  CFStringRef v5 = CFStringCreateWithBytes(a1, *(const UInt8 **)&numBytes[1], numBytes[0], 0x8000100u, 0);
  CFStringRef v6 = v5;
  CFDataRef v2 = (const __CFData *)(v5
                       && (CFEqual(v5, @"IMG4")
                        || CFEqual(v6, @"IM4P")));
LABEL_11:
  SafeRelease(v6);
  return v2;
}

uint64_t AMAuthInstallApImg4CopyPayload(const __CFAllocator *a1, CFTypeRef cf, CFTypeRef *a3)
{
  CFTypeRef cfa = 0;
  uint64_t v3 = 1;
  if (cf && a3)
  {
    uint64_t v6 = AMAuthInstallSupportCreateDataFromFileURL(a1, &cfa, cf);
    if (v6)
    {
      uint64_t v3 = v6;
    }
    else if (AMAuthInstallApImg4IsImg4Payload(a1, (CFDataRef)cfa))
    {
      uint64_t v3 = 0;
      *a3 = CFRetain(cfa);
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CopyPayload", (uint64_t)"object is not a valid img4/im4p type", v7, v8, v9, v10, v11, v13);
      uint64_t v3 = 23;
    }
  }
  SafeRelease(cfa);
  return v3;
}

uint64_t AMAuthInstallApImg4CopyPayloadVersionProperty(const __CFAllocator *a1, const void *a2, int a3, uint64_t *a4)
{
  CFIndex Length = 0;
  CFDataRef theData = 0;
  CFIndex v37 = 0;
  BytePtr = 0;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  uint64_t v35 = 0;
  MutableBytePtr = 0;
  uint64_t v34 = 0;
  if (!a2 || !a4)
  {
    CFDataRef v16 = 0;
    CFDataRef v14 = 0;
    CFDataRef v31 = 0;
    CFDataRef v32 = 0;
    uint64_t v23 = 1;
    if (!a4) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  uint64_t v7 = AMAuthInstallApImg4CopyPayload(a1, a2, (CFTypeRef *)&theData);
  if (v7)
  {
    uint64_t v23 = v7;
    CFDataRef v16 = 0;
    CFDataRef v14 = 0;
    goto LABEL_10;
  }
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  int v8 = DERImg4DecodePayload((uint64_t)&BytePtr, (unint64_t)&v41);
  if (v8)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CopyPayloadVersionProperty", (uint64_t)"failed to decode img4 payload, error:%d", v9, v10, v11, v12, v13, v8);
    CFDataRef v16 = 0;
    CFDataRef v14 = 0;
    goto LABEL_24;
  }
  CFDataRef v14 = (const __CFData *)AMSupportCopyDataFromAsciiEncodedHex();
  if (!v14)
  {
    CFDataRef v16 = 0;
    uint64_t v23 = 3;
    goto LABEL_10;
  }
  CFDataRef MutableCopy = CFDataCreateMutableCopy(a1, 0, v14);
  CFDataRef v16 = MutableCopy;
  if (!MutableCopy) {
    goto LABEL_19;
  }
  unsigned int v17 = 1952607602;
  MutableBytePtr = CFDataGetMutableBytePtr(MutableCopy);
  CFIndex v37 = CFDataGetLength(v16);
  if (a3 == 1)
  {
    unsigned int v17 = 1952607603;
    goto LABEL_12;
  }
  if (a3 == 2)
  {
LABEL_12:
    Img4DecodeGetPayloadVersionPropertyString((uint64_t)&MutableBytePtr, v17 | 0xE000000000000000, &v35, &v34);
    if (!v30)
    {
      uint64_t v24 = AMSupportCopyDataFromAsciiEncodedHex();
      if (v24)
      {
        uint64_t v23 = 0;
        goto LABEL_15;
      }
LABEL_19:
      uint64_t v23 = 2;
      goto LABEL_10;
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CopyPayloadVersionProperty", (uint64_t)"failed to parse version property: %d, error:%d", v25, v26, v27, v28, v29, v17);
LABEL_24:
    uint64_t v23 = 23;
    goto LABEL_10;
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CopyPayloadVersionProperty", (uint64_t)"unsupported property type: %d\n", v18, v19, v20, v21, v22, a3);
  uint64_t v23 = 1;
LABEL_10:
  uint64_t v24 = 0;
LABEL_15:
  *a4 = v24;
  CFDataRef v31 = v16;
  CFDataRef v32 = v14;
LABEL_16:
  SafeRelease(v31);
  SafeRelease(v32);
  SafeRelease(theData);
  return v23;
}

uint64_t AMAuthInstallApImg4CreateMeasurementsWithTag(const __CFAllocator *a1, CFURLRef anURL, const __CFString *a3, int a4, CFTypeRef *a5)
{
  value = 0;
  CFTypeRef cf = 0;
  CFStringRef v101 = 0;
  CFDataRef v102 = 0;
  uint64_t v5 = 1;
  if (!anURL || !a5) {
    goto LABEL_69;
  }
  CFStringRef v10 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
  CFStringRef v11 = v10;
  if (!v10) {
    goto LABEL_78;
  }
  if (CFStringFind(v10, @"=", 0).location != -1)
  {
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v11, @"=");
    CFArrayRef v13 = ArrayBySeparatingStrings;
    if (!ArrayBySeparatingStrings) {
      goto LABEL_78;
    }
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
    CFStringRef v15 = ValueAtIndex;
    if (ValueAtIndex)
    {
      if (!a3)
      {
        CFStringRef TypeForEntryName = AMAuthInstallApImg4GetTypeForEntryName(ValueAtIndex);
        if (!TypeForEntryName) {
          goto LABEL_76;
        }
        a3 = TypeForEntryName;
        if (CFEqual(TypeForEntryName, v15)
          && CFStringCompare(a3, @"ftap", 0)
          && CFStringCompare(a3, @"rfta", 0)
          && CFStringCompare(a3, @"ftsp", 0)
          && CFStringCompare(a3, @"rfts", 0))
        {
          a3 = 0;
        }
      }
      CFStringRef v17 = (const __CFString *)CFArrayGetValueAtIndex(v13, 1);
      if (v17)
      {
        uint64_t v18 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v17, kCFURLPOSIXPathStyle, 0);
        if (!v18) {
          goto LABEL_78;
        }
        if (a3)
        {
LABEL_13:
          CFStringGetCString(a3, buffer, 32, 0x8000100u);
          uint64_t v19 = AMAuthInstallSupportCreateDataFromFileURL(a1, &cf, v18);
          if (v19)
          {
            uint64_t v5 = v19;
            goto LABEL_69;
          }
          uint64_t v20 = AMAuthInstallApImg4ReCreatePayloadWithProperties(buffer, 0, (CFDataRef)cf, 0, 0, 0, 0, &v102);
          if (v20)
          {
            uint64_t v5 = v20;
            CFBooleanRef v98 = "failed to create im4p with override tag";
          }
          else
          {
            AMSupportSafeRelease();
            CFTypeRef cf = 0;
            if (AMAuthInstallCryptoCreateDigestForDataType(a1, v102, (CFTypeRef *)&value, a4) != 1)
            {
              CFStringRef v26 = (const __CFString *)AMSupportSafeRetain();
              AMSupportSafeRelease();
              CFDataRef v102 = 0;
              goto LABEL_23;
            }
            uint64_t v5 = 1;
            CFBooleanRef v98 = "Unsupported digestType";
          }
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateMeasurementsWithTag", (uint64_t)v98, v21, v22, v23, v24, v25, v99);
          goto LABEL_69;
        }
        goto LABEL_18;
      }
    }
LABEL_76:
    uint64_t v5 = 8;
    goto LABEL_69;
  }
  uint64_t v18 = CFRetain(anURL);
  if (a3) {
    goto LABEL_13;
  }
LABEL_18:
  if (AMAuthInstallSupportCreateDataFromFileURL(a1, &cf, v18)) {
    CFStringRef v26 = 0;
  }
  else {
    CFStringRef v26 = AMAuthInstallApImg4CopyPayloadType(a1, cf, v32, v33, v34, v35, v36, v37);
  }
  AMAuthInstallCryptoCreateDigestForDataType(a1, (const __CFData *)cf, (CFTypeRef *)&value, a4);
  if (value)
  {
    AMSupportSafeRelease();
    CFTypeRef cf = 0;
LABEL_23:
    if (value)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      long long v49 = Mutable;
      if (Mutable)
      {
        CFDictionarySetValue(Mutable, @"Digest", value);
        if (!v26)
        {
LABEL_68:
          uint64_t v5 = 0;
          *a5 = CFRetain(v49);
          goto LABEL_69;
        }
        if (CFStringCompare(v26, @"sepi", 0))
        {
          if (CFStringCompare(v26, @"rsep", 0)) {
            goto LABEL_34;
          }
          int v50 = AMAuthInstallApImg4CopyPayloadVersionProperty(a1, v18, 2, (uint64_t *)&v101);
          if (v50)
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateMeasurementsWithTag", (uint64_t)"could not get tbmr property, status:%d\n", v51, v52, v53, v54, v55, v50);
            goto LABEL_34;
          }
        }
        else
        {
          int v56 = AMAuthInstallApImg4CopyPayloadVersionProperty(a1, v18, 1, (uint64_t *)&v101);
          if (v56)
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateMeasurementsWithTag", (uint64_t)"could not get tbms property, status:%d\n", v57, v58, v59, v60, v61, v56);
            goto LABEL_34;
          }
        }
        CFDictionarySetValue(v49, @"TBMDigests", v101);
LABEL_34:
        CFIndex v110 = 0;
        CFDataRef theData = 0;
        v108 = 0;
        BytePtr = 0;
        long long v120 = 0u;
        long long v121 = 0u;
        long long v118 = 0u;
        long long v119 = 0u;
        long long v116 = 0u;
        long long v117 = 0u;
        long long v114 = 0u;
        long long v115 = 0u;
        *(_OWORD *)buffer = 0u;
        long long v113 = 0u;
        if (!v18)
        {
          CFDataRef v69 = 0;
          uint64_t v5 = 1;
          goto LABEL_67;
        }
        uint64_t v62 = AMAuthInstallApImg4CopyPayload(a1, v18, (CFTypeRef *)&theData);
        if (v62)
        {
          uint64_t v5 = v62;
          goto LABEL_39;
        }
        BytePtr = CFDataGetBytePtr(theData);
        CFIndex v110 = CFDataGetLength(theData);
        *(_OWORD *)buffer = 0u;
        long long v113 = 0u;
        long long v114 = 0u;
        long long v115 = 0u;
        long long v116 = 0u;
        long long v117 = 0u;
        long long v118 = 0u;
        long long v119 = 0u;
        long long v120 = 0u;
        long long v121 = 0u;
        int v63 = DERImg4DecodePayloadWithProperties((uint64_t)&BytePtr, (unint64_t)buffer);
        if (v63)
        {
          AMAuthInstallLog(7, (uint64_t)"AMAuthInstallCopyPayloadPropertiesToMeasurementDictionary", (uint64_t)"failed to decode img4 payload with properties (error=%d), assuming no properties", v64, v65, v66, v67, v68, v63);
LABEL_38:
          uint64_t v5 = 0;
LABEL_39:
          CFDataRef v69 = 0;
          goto LABEL_67;
        }
        if (!(void)v118) {
          goto LABEL_38;
        }
        *(_OWORD *)bytes = 0u;
        *(_OWORD *)length = 0u;
        long long v105 = 0u;
        if (CFStringCompare(v26, @"sepi", 0))
        {
          if (CFStringCompare(v26, @"rsep", 0)) {
            goto LABEL_57;
          }
          if (sub_10000F188((unint64_t *)&BytePtr, 0xE000000074626D72, (unint64_t)&v105)
            || (CFTypeID v75 = bytes[1]) == 0)
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallCopyPayloadPropertiesToMeasurementDictionary", (uint64_t)"could not get tbmr payload property, status:%d\n", v70, v71, v72, v73, v74, 23);
            goto LABEL_57;
          }
        }
        else if (sub_10000F188((unint64_t *)&BytePtr, 0xE000000074626D73, (unint64_t)&v105)|| (CFTypeID v75 = bytes[1]) == 0)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallCopyPayloadPropertiesToMeasurementDictionary", (uint64_t)"could not get tbms payload property, status:%d\n", v76, v77, v78, v79, v80, 23);
          goto LABEL_57;
        }
        CFDataRef v81 = CFDataCreate(a1, v75, length[0]);
        if (!v81) {
          goto LABEL_85;
        }
        CFDataRef v82 = v81;
        CFDictionarySetValue(v49, @"TBMDigests", v81);
        SafeRelease(v82);
LABEL_57:
        if (!sub_10000F188((unint64_t *)&BytePtr, 0xE00000006D6D6170, (unint64_t)&v105)
          && bytes[1])
        {
          CFDataRef v83 = CFDataCreate(a1, bytes[1], length[0]);
          if (!v83) {
            goto LABEL_85;
          }
          CFDataRef v84 = v83;
          CFDictionarySetValue(v49, @"MemoryMap", v83);
          SafeRelease(v84);
        }
        if (sub_10000F188((unint64_t *)&BytePtr, 0xE000000072646467, (unint64_t)&v105)
          || !bytes[1])
        {
          goto LABEL_65;
        }
        CFDataRef v85 = CFDataCreate(a1, bytes[1], length[0]);
        if (v85)
        {
          CFDataRef v86 = v85;
          CFDictionarySetValue(v49, @"RawDataDigest", v85);
          SafeRelease(v86);
LABEL_65:
          CFDataRef v69 = CFDataCreate(a1, (const UInt8 *)v118, *((CFIndex *)&v118 + 1));
          AMAuthInstallCryptoCreateDigestForDataType(a1, v69, (CFTypeRef *)&v108, a4);
          if (v108)
          {
            CFDictionarySetValue(v49, @"ObjectPayloadPropertyDigest", v108);
            uint64_t v5 = 0;
            goto LABEL_67;
          }
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallCopyPayloadPropertiesToMeasurementDictionary", (uint64_t)"created digest is NULL", v87, v88, v89, v90, v91, v99);
          goto LABEL_87;
        }
LABEL_85:
        CFDataRef v69 = 0;
LABEL_87:
        uint64_t v5 = 2;
LABEL_67:
        SafeRelease(v108);
        SafeRelease(v69);
        SafeRelease(0);
        SafeRelease(theData);
        if (v5)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateMeasurementsWithTag", (uint64_t)"failed to copy payload properties to measurement dictionary.", v92, v93, v94, v95, v96, v99);
          goto LABEL_69;
        }
        goto LABEL_68;
      }
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateMeasurementsWithTag", (uint64_t)"failed to create mutable dict measurementDict", v44, v45, v46, v47, v48, v99);
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateMeasurementsWithTag", (uint64_t)"created digest is NULL", v27, v28, v29, v30, v31, v99);
    }
LABEL_78:
    uint64_t v5 = 2;
    goto LABEL_69;
  }
  uint64_t v5 = 3;
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateMeasurementsWithTag", (uint64_t)"failed to create digest for %@ with error %d", v38, v39, v40, v41, v42, (char)v18);
LABEL_69:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v5;
}

uint64_t AMAuthInstallApImg4CreateServerRequestDictionary(void *a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  uint64_t v3 = 1;
  if (a1 && a2 && a3)
  {
    CFAllocatorRef v7 = CFGetAllocator(a1);
    CFTypeRef cf = CFDictionaryCreateMutable(v7, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (cf)
    {
      int v8 = CFGetAllocator(a1);
      CFIndex v9 = AMAuthInstallSupportApplyDictionaryOverrides(v8, a2, (CFMutableDictionaryRef *)&cf, 0);
      if (v9)
      {
        uint64_t v3 = v9;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateServerRequestDictionary", (uint64_t)"failed to apply measurements override", v10, v11, v12, v13, v14, v16);
      }
      else
      {
        uint64_t v3 = AMAuthInstallApImg4ServerRequestAddRequiredTagsWithRecoveryOS(a1, (__CFDictionary *)cf, 1, 0);
        if (!v3) {
          *a3 = CFRetain(cf);
        }
      }
    }
    else
    {
      uint64_t v3 = 2;
    }
  }
  SafeRelease(cf);
  return v3;
}

uint64_t AMAuthInstallApImg4ServerRequestAddRequiredTags(void *a1, __CFDictionary *a2, int a3)
{
  return AMAuthInstallApImg4ServerRequestAddRequiredTagsWithRecoveryOS(a1, a2, a3, 0);
}

uint64_t AMAuthInstallApImg4SetSepNonce(uint64_t a1, CFTypeRef cf)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 1;
  if (cf && *(void *)(a1 + 16))
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFDataGetTypeID() && CFDataGetLength((CFDataRef)cf) == 20)
    {
      SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 48));
      CFTypeRef v6 = CFRetain(cf);
      uint64_t result = 0;
      *(void *)(*(void *)(a1 + 16) + 48) = v6;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t AMAuthInstallApImg4SetSepNonceSlotID(uint64_t a1, CFTypeRef cf)
{
  if (!a1) {
    return 1;
  }
  if (!*(void *)(a1 + 16)) {
    return 1;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFNumberGetTypeID()) {
    return 1;
  }
  CFRetain(cf);
  SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 56));
  uint64_t result = 0;
  *(void *)(*(void *)(a1 + 16) + 56) = cf;
  return result;
}

uint64_t AMAuthInstallApImg4ServerRequestAddUIDMode(uint64_t a1, CFDictionaryRef theDict)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 1;
  if (theDict)
  {
    uint64_t v5 = *(void *)(a1 + 16);
    if (v5)
    {
      CFBooleanRef v6 = *(CFBooleanRef *)(v5 + 168);
      if (CFDictionaryContainsKey(theDict, @"UniqueBuildID")
        || CFDictionaryContainsKey(theDict, @"UID_MODE"))
      {
        return 0;
      }
      if (v6) {
        BOOL v7 = v6 == kCFBooleanFalse;
      }
      else {
        BOOL v7 = 1;
      }
      if (!v7
        || *(const CFBooleanRef *)(*(void *)(a1 + 16) + 176) == kCFBooleanTrue
        || (uint64_t result = CFDictionaryContainsKey(theDict, @"SepNonce"), !kCFBooleanTrue)
        || result)
      {
        if (v6) {
          CFBooleanRef v8 = v6;
        }
        else {
          CFBooleanRef v8 = kCFBooleanFalse;
        }
        CFDictionarySetValue(theDict, @"UID_MODE", v8);
        return 0;
      }
    }
  }
  return result;
}

uint64_t AMAuthInstallApImg4ServerRequestAddRequiredTagsWithRecoveryOS(void *a1, __CFDictionary *a2, int a3, int a4)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 1;
  if (a2)
  {
    uint64_t v7 = a1[2];
    if (v7)
    {
      int v10 = *(unsigned __int8 *)(v7 + 116);
      int v11 = *(unsigned __int8 *)(v7 + 72);
      uint64_t v12 = &kAMAuthInstallTagX86SecurityMode;
      if (!v10) {
        uint64_t v12 = &kAMAuthInstallTagApSecurityMode;
      }
      _CFDictionarySetBoolean(a2, *v12, v11);
      uint64_t v13 = a1[2];
      if (*(unsigned char *)(v13 + 74))
      {
        if (*(unsigned char *)(v13 + 116)) {
          uint64_t v14 = &kAMAuthInstallTagX86AllowMixAndMatch;
        }
        else {
          uint64_t v14 = &kAMAuthInstallTagApAllowMixAndMatch;
        }
        CFDictionarySetValue(a2, *v14, kCFBooleanTrue);
      }
      CFStringRef v15 = (unsigned __int8 *)a1[2];
      if (v15[75])
      {
        CFDictionarySetValue(a2, @"Ap,InternalUseOnlySW", kCFBooleanTrue);
        CFStringRef v15 = (unsigned __int8 *)a1[2];
      }
      if (v15[116])
      {
        _CFDictionarySetBoolean(a2, @"x86,ProductionMode", v15[20]);
        if (*(unsigned char *)(a1[2] + 79)) {
          _CFDictionarySetInteger32(a2, @"x86,UseGlobalSigning", 1);
        }
        if (!a3) {
          goto LABEL_39;
        }
        char v16 = *(const void **)(a1[2] + 24);
        if (v16) {
          CFDictionarySetValue(a2, @"x86,Nonce", v16);
        }
        CFDictionarySetValue(a2, @"@x86,Ticket", kCFBooleanTrue);
      }
      else
      {
        if (v15[79]) {
          _CFDictionarySetInteger32(a2, @"Ap,UseGlobalSigning", 1);
        }
        if (!a3) {
          goto LABEL_39;
        }
      }
      uint64_t v17 = a1[2];
      if (!*(unsigned char *)(v17 + 116))
      {
        CFDictionarySetValue(a2, @"@ApImg4Ticket", kCFBooleanTrue);
        uint64_t v17 = a1[2];
      }
      uint64_t v18 = *(const void **)(v17 + 24);
      if (v18)
      {
        CFDictionarySetValue(a2, @"ApNonce", v18);
        uint64_t v17 = a1[2];
      }
      uint64_t v19 = *(const void **)(v17 + 48);
      if (v19)
      {
        CFDictionarySetValue(a2, @"SepNonce", v19);
        uint64_t v17 = a1[2];
      }
      uint64_t v20 = *(const void **)(v17 + 40);
      if (v20)
      {
        CFDictionarySetValue(a2, @"Ap,SoftwareNonceForUpdateFreshness", v20);
        uint64_t v17 = a1[2];
      }
      uint64_t v21 = *(const void **)(v17 + 120);
      if (v21)
      {
        CFDictionarySetValue(a2, @"@BCert", v21);
        CFDictionarySetValue(a2, @"@Managed", kCFBooleanTrue);
        uint64_t v17 = a1[2];
      }
      uint64_t v22 = *(const void **)(v17 + 128);
      if (v22)
      {
        CFDictionarySetValue(a2, @"@BCert", v22);
        CFDictionarySetValue(a2, @"@AlternateSU", kCFBooleanTrue);
        uint64_t v17 = a1[2];
      }
      uint64_t v23 = *(const void **)(v17 + 160);
      if (v23)
      {
        CFDictionarySetValue(a2, @"Ap,SikaFuse", v23);
        uint64_t v17 = a1[2];
      }
      uint64_t v24 = *(const void **)(v17 + 192);
      if (v24) {
        CFDictionarySetValue(a2, @"Ap,DisablePlatformOnlyCode", v24);
      }
LABEL_39:
      uint64_t result = AMAuthInstallApImg3ServerRequestAddRequiredTags(a1, a2, 0, a4);
      if (!result)
      {
        return AMAuthInstallApImg4ServerRequestAddUIDMode((uint64_t)a1, a2);
      }
    }
  }
  return result;
}

uint64_t AMAuthInstallApImg4Stitch(uint64_t a1, const __CFURL *a2, const __CFURL *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v59, 0, sizeof(v59));
  uint64_t v58 = 0;
  unsigned int v57 = 0;
  *(void *)&__nitems[1] = 0;
  __nitems[0] = 0;
  if (!a2)
  {
    uint64_t v46 = "srcFileURL is NULL";
LABEL_37:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4Stitch", (uint64_t)v46, a4, a5, a6, a7, a8, v55);
    uint64_t v9 = 1;
    goto LABEL_27;
  }
  if (!a3)
  {
    uint64_t v46 = "dstFileURL is NULL";
    goto LABEL_37;
  }
  uint64_t v9 = a4;
  char v10 = (char)a2;
  int v11 = AMAuthInstallPlatformOpenFileStreamWithURL(a2, "rb");
  if (v11)
  {
    uint64_t v12 = v11;
    fseek(v11, 0, 2);
    int v13 = ftell(v12);
    rewind(v12);
    if (!v13)
    {
      uint64_t v53 = "failed to get src file size";
LABEL_41:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4Stitch", (uint64_t)v53, v14, v15, v16, v17, v18, v55);
      uint64_t v9 = 4;
LABEL_48:
      long long v43 = v12;
      goto LABEL_26;
    }
    if (v9)
    {
      unsigned int Length = CFDataGetLength((CFDataRef)v9);
      if (Img4EncodeManifestHeader(Length, &v59[1], v59))
      {
        uint64_t v45 = "failed to encode manifest header";
        goto LABEL_47;
      }
      if (!Img4EncodeIMG4Tag((uint64_t)&v58))
      {
        int v25 = CFDataGetLength((CFDataRef)v9);
        goto LABEL_10;
      }
    }
    else
    {
      int v25 = Img4EncodeIMG4Tag((uint64_t)&v58);
      if (!v25)
      {
LABEL_10:
        if (!Img4EncodeImg4Header(v25 + v13 + v57 + v59[0], &__nitems[1], __nitems))
        {
          CFStringRef v26 = AMAuthInstallPlatformOpenFileStreamWithURL(a3, "wb");
          if (v26)
          {
            uint64_t v27 = v26;
            size_t v28 = fwrite(*(const void **)&__nitems[1], 1uLL, __nitems[0], v26);
            if (v28 == __nitems[0])
            {
              size_t v29 = fwrite(v58, 1uLL, v57, v27);
              if (v29 == v57)
              {
                uint64_t v30 = malloc(0x100000uLL);
                if (!v30)
                {
                  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4Stitch", (uint64_t)"failed to allocate chunk buffer", v31, v32, v33, v34, v35, v55);
                  uint64_t v9 = 2;
                  goto LABEL_25;
                }
                uint64_t v36 = v30;
                uint64_t v37 = "failed to stitch payload to file: %s";
                while (feof(v12) != -1)
                {
                  size_t v38 = fread(v36, 1uLL, 0x100000uLL, v12);
                  if (!v38) {
                    break;
                  }
                  if (fwrite(v36, 1uLL, v38, v27) != v38) {
                    goto LABEL_19;
                  }
                }
                if (!v9) {
                  goto LABEL_24;
                }
                size_t v39 = fwrite(*(const void **)&v59[1], 1uLL, v59[0], v27);
                if (v39 == v59[0])
                {
                  BytePtr = CFDataGetBytePtr((CFDataRef)v9);
                  size_t v41 = CFDataGetLength((CFDataRef)v9);
                  size_t v42 = fwrite(BytePtr, 1uLL, v41, v27);
                  if (v42 == CFDataGetLength((CFDataRef)v9))
                  {
                    uint64_t v9 = 0;
LABEL_24:
                    free(v36);
LABEL_25:
                    fclose(v12);
                    long long v43 = v27;
LABEL_26:
                    fclose(v43);
                    goto LABEL_27;
                  }
                  uint64_t v37 = "failed to stitch manifest to file: %s";
                }
                else
                {
                  uint64_t v37 = "failed to stitch manifest header to file: %s";
                }
LABEL_19:
                sub_100071D00((uint64_t)v37);
                uint64_t v9 = 4;
                goto LABEL_24;
              }
              sub_100071D58();
            }
            else
            {
              sub_100071DA8();
            }
            uint64_t v9 = 4;
            goto LABEL_25;
          }
          uint64_t v54 = __error();
          strerror(*v54);
          char v55 = (char)a3;
          uint64_t v53 = "failed to open file %@, error=%s";
          goto LABEL_41;
        }
      }
    }
    uint64_t v45 = "failed to encode IMG4 string";
LABEL_47:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4Stitch", (uint64_t)v45, v20, v21, v22, v23, v24, v55);
    uint64_t v9 = 14;
    goto LABEL_48;
  }
  uint64_t v47 = __error();
  strerror(*v47);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4Stitch", (uint64_t)"failed to open file %@, error=%s", v48, v49, v50, v51, v52, v10);
  uint64_t v9 = 4;
LABEL_27:
  if (*(void *)&v59[1]) {
    free(*(void **)&v59[1]);
  }
  if (v58) {
    free(v58);
  }
  if (*(void *)&__nitems[1]) {
    free(*(void **)&__nitems[1]);
  }
  return v9;
}

uint64_t AMAuthInstallApImg4StitchData(const void **cf, CFStringRef theString, const __CFURL *a3, const __CFURL *a4, CFDictionaryRef theDict, int a6)
{
  CFDataRef Value = 0;
  CFDataRef v45 = 0;
  CFDataRef theData = 0;
  uint64_t v7 = 1;
  if (!a3 || !a4) {
    goto LABEL_15;
  }
  if (a6)
  {
    CFDataRef Value = 0;
  }
  else
  {
    if (!theDict) {
      goto LABEL_14;
    }
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, cf[11]);
    if (!Value)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4StitchData", (uint64_t)"%s: could not find ticket %@ data in response.", v12, v13, v14, v15, v16, (char)"AMAuthInstallApImg4StitchData");
      uint64_t v7 = 8;
      goto LABEL_15;
    }
  }
  if (!theString)
  {
    CFAllocatorRef v37 = CFGetAllocator(cf);
    uint64_t v7 = AMAuthInstallApImg4Stitch((uint64_t)v37, a3, a4, (uint64_t)Value, v38, v39, v40, v41);
    if (v7)
    {
      long long v43 = "failed to stitch img4 file";
      goto LABEL_21;
    }
LABEL_14:
    CFDataRef Value = 0;
    goto LABEL_15;
  }
  CFStringGetCString(theString, buffer, 5, 0x8000100u);
  CFAllocatorRef v17 = CFGetAllocator(cf);
  uint64_t DataFromFileURL = AMAuthInstallSupportCreateDataFromFileURL(v17, (CFTypeRef *)&theData, a3);
  if (DataFromFileURL)
  {
    uint64_t v7 = DataFromFileURL;
    goto LABEL_14;
  }
  uint64_t v19 = AMAuthInstallApImg4ReCreatePayloadWithProperties(buffer, 0, theData, 0, 0, 0, 0, &v45);
  if (v19)
  {
    uint64_t v7 = v19;
    long long v43 = "failed to recreate";
LABEL_21:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4StitchData", (uint64_t)v43, v20, v21, v22, v23, v24, v44);
    goto LABEL_14;
  }
  SafeRelease(theData);
  CFDataRef theData = 0;
  CFAllocatorRef v25 = CFGetAllocator(cf);
  CFDataRef Value = AMAuthInstallApImg4CreateStitchTicket(v25, v45, Value);
  if (Value)
  {
    CFAllocatorRef v31 = CFGetAllocator(cf);
    uint64_t v7 = AMAuthInstallSupportWriteDataToFileURL(v31, Value, a4, 1);
    if (v7) {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4StitchData", (uint64_t)"failed to write stitched data to %@", v32, v33, v34, v35, v36, (char)a4);
    }
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4StitchData", (uint64_t)"failed to stitch ticket to %@", v26, v27, v28, v29, v30, (char)a4);
    uint64_t v7 = 99;
  }
LABEL_15:
  SafeRelease(Value);
  SafeRelease(theData);
  SafeRelease(v45);
  return v7;
}

CFDataRef AMAuthInstallApImg4CreateStitchTicket(const __CFAllocator *a1, const __CFData *a2, const __CFData *a3)
{
  if (!a2)
  {
    a3 = 0;
    uint64_t v12 = 0;
    goto LABEL_17;
  }
  if (!DEREncoderCreate()) {
    goto LABEL_23;
  }
  if (CFStringGetCString(@"IMG4", buffer, 256, 0x8000100u))
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreateStitchTicket", (uint64_t)"failed to add %@ string", v6, v7, v8, v9, v10, (char)@"IMG4");
      goto LABEL_23;
    }
  }
  if (DEREncoderCreateEncodedBuffer())
  {
LABEL_23:
    a3 = 0;
    uint64_t v12 = 0;
    goto LABEL_17;
  }
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, 0);
  uint64_t v12 = Mutable;
  if (!Mutable)
  {
    a3 = 0;
    goto LABEL_17;
  }
  CFDataAppendBytes(Mutable, 0, 0);
  BytePtr = CFDataGetBytePtr(a2);
  CFIndex Length = CFDataGetLength(a2);
  CFDataAppendBytes(v12, BytePtr, Length);
  if (a3)
  {
    if (!DEREncoderCreate()
      || (CFDataGetBytePtr(a3), CFDataGetLength(a3), DEREncoderAddData())
      || DEREncoderCreateEncodedBuffer())
    {
      a3 = 0;
    }
    else
    {
      CFDataRef v15 = CFDataCreate(a1, 0, 0);
      a3 = v15;
      if (v15)
      {
        uint64_t v16 = CFDataGetBytePtr(v15);
        CFIndex v17 = CFDataGetLength(a3);
        CFDataAppendBytes(v12, v16, v17);
        goto LABEL_13;
      }
    }
LABEL_17:
    SafeRelease(0);
    CFDataRef v18 = 0;
    goto LABEL_18;
  }
LABEL_13:
  if (!DEREncoderCreate()) {
    goto LABEL_17;
  }
  CFDataGetBytePtr(v12);
  CFDataGetLength(v12);
  if (DEREncoderAddDataNoCopy()) {
    goto LABEL_17;
  }
  if (DEREncoderCreateEncodedBuffer()) {
    goto LABEL_17;
  }
  CFDataRef v18 = CFDataCreateWithBytesNoCopy(a1, 0, 0, kCFAllocatorMalloc);
  if (!v18) {
    goto LABEL_17;
  }
LABEL_18:
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  SafeFree(0);
  SafeFree(0);
  SafeRelease(v12);
  SafeRelease(a3);
  return v18;
}

uint64_t AMAuthInstallApImg4StitchTicketData(const void **a1, const __CFString *a2, const __CFURL *a3, const __CFURL *a4, const __CFDictionary *a5)
{
  return AMAuthInstallApImg4StitchData(a1, a2, a3, a4, a5, 0);
}

uint64_t AMAuthInstallApImg4StitchRestoreInfoWithAMAI(const __CFString *a1, const void *a2, const __CFDictionary *a3, const __CFDictionary *a4, uint64_t a5)
{
  CFMutableDictionaryRef Mutable = 0;
  *(void *)long long v43 = 0;
  *(void *)char v44 = 0;
  uint64_t v6 = 1;
  if (a2)
  {
    CFStringRef v8 = 0;
    if (a3)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (a1)
      {
        for (uint64_t i = 0; i != 72; i += 24)
        {
          CFStringRef v13 = *(__CFString **)((char *)&off_10009D9C0 + i);
          if (!v13) {
            sub_100071DF8();
          }
          if (CFEqual(v13, a1))
          {
            uint64_t v14 = *(uint64_t *)((char *)&off_10009D9C0 + i + 16);
            if (!*(void *)v14) {
              sub_100071E24();
            }
            CFDataRef v15 = *(uint64_t (**)(uint64_t, const __CFDictionary *))(v14 + 8);
            if (!v15) {
              sub_100071E50();
            }
            uint64_t v16 = (const void *)v15(a5, a3);
            if (v16)
            {
              CFIndex v17 = v16;
              CFDictionarySetValue(Mutable, *(const void **)v14, v16);
              CFRelease(v17);
            }
          }
        }
      }
      if (Mutable)
      {
        if (a4) {
          CFDictionaryApplyFunction(a4, (CFDictionaryApplierFunction)sub_10000CFBC, Mutable);
        }
        if (a1
          && (CFStringRef EntryNameForType = AMAuthInstallApImg4GetEntryNameForType(a1), CFStringCompare(a1, EntryNameForType, 0)))
        {
          char v41 = (char)EntryNameForType;
          CFStringRef v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-TBM");
          if (v8)
          {
            CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a3, v8);
            if (Value)
            {
              CFDictionaryRef v20 = Value;
              uint64_t v21 = CFDictionaryGetValue(Value, @"ucon");
              uint64_t v22 = CFDictionaryGetValue(v20, @"ucer");
              if (v21) {
                CFDictionaryAddValue(Mutable, @"ucon", v21);
              }
              if (v22) {
                CFDictionaryAddValue(Mutable, @"ucer", v22);
              }
            }
          }
        }
        else
        {
          CFStringRef v8 = 0;
        }
        if (CFDictionaryGetCount(Mutable))
        {
          uint64_t DataFromFileURL = AMAuthInstallSupportCreateDataFromFileURL(0, (CFTypeRef *)v44, a2);
          if (DataFromFileURL)
          {
            uint64_t v6 = DataFromFileURL;
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4StitchRestoreInfoWithAMAI", (uint64_t)"failed to read data from %@", v24, v25, v26, v27, v28, (char)a2);
          }
          else
          {
            uint64_t v29 = AMAuthInstallApImg4EncodeRestoreInfo(*(const __CFData **)v44, Mutable, (CFDataRef *)v43);
            if (v29)
            {
              uint64_t v6 = v29;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4StitchRestoreInfoWithAMAI", (uint64_t)"failed to encode restore info", v30, v31, v32, v33, v34, v41);
            }
            else
            {
              uint64_t v6 = AMAuthInstallSupportWriteDataToFileURL(0, *(const __CFData **)v43, (const __CFURL *)a2, 1);
              if (v6) {
                AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4StitchRestoreInfoWithAMAI", (uint64_t)"failed to write stitched data to %@", v35, v36, v37, v38, v39, (char)a2);
              }
            }
          }
        }
        else
        {
          uint64_t v6 = 0;
        }
      }
      else
      {
        CFStringRef v8 = 0;
        uint64_t v6 = 2;
      }
    }
  }
  else
  {
    CFStringRef v8 = 0;
  }
  SafeRelease(Mutable);
  SafeRelease(*(CFTypeRef *)v44);
  SafeRelease(*(CFTypeRef *)v43);
  SafeRelease(v8);
  return v6;
}

void sub_10000CFBC(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t AMAuthInstallApImg4EncodeRestoreInfo(const __CFData *a1, CFDictionaryRef theDict, CFDataRef *a3)
{
  v37[0] = 0;
  v37[1] = 0;
  unsigned int v36 = 0;
  int v35 = 0;
  uint64_t v33 = 0;
  bytes = 0;
  CFIndex v31 = 0;
  CFIndex length = 0;
  uint64_t v29 = 0;
  CFMutableDictionaryRef v30 = 0;
  if (!a1 || !theDict || (CFIndex Count = CFDictionaryGetCount(theDict), !a3) || Count < 1)
  {
    CFMutableDictionaryRef Mutable = 0;
    if (!a3)
    {
      uint64_t v21 = 3;
      uint64_t v24 = 0;
      goto LABEL_20;
    }
    uint64_t v24 = 0;
    goto LABEL_31;
  }
  unsigned int v36 = CFDataGetLength(a1);
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(a1);
  if (DERDecoderInitialize((uint64_t)v37, BytePtr, &v36, v36))
  {
    uint64_t v27 = "DERDecoderInitialize top level failed";
LABEL_30:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreInfo", (uint64_t)v27, v8, v9, v10, v11, v12, v28);
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v24 = 0;
    goto LABEL_31;
  }
  if (DERDecoderGetDataWithTag((uint64_t)v37, 0, 0x10u, 1, &bytes, (_DWORD *)&length + 1, &v35))
  {
    uint64_t v27 = "could not find im4p top level sequence";
    goto LABEL_30;
  }
  if (DERDecoderInitialize((uint64_t)v37, bytes, (unsigned int *)&length + 1, HIDWORD(length)))
  {
    uint64_t v27 = "DERDecoderInitialize sequence failed";
    goto LABEL_30;
  }
  int v35 = 3;
  int EncodingWithTag = DERDecoderGetEncodingWithTag((uint64_t)v37, 2u, 1u, 1, &v33, &length, &v35);
  if (!EncodingWithTag)
  {
    HIDWORD(length) -= length;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFMutableDictionaryRef v30 = Mutable;
    if (AMAuthInstallApImg4DecodeRestoreInfo(a1, &v30))
    {
      uint64_t v15 = AMAuthInstallApImg4EncodeRestoreDict(theDict, (uint64_t)&v29, (uint64_t)&v31 + 4);
      if (!v15) {
        goto LABEL_15;
      }
      uint64_t v21 = v15;
      uint64_t v22 = "AMAuthInstallApImg4EncodeRestoreDict legacy failed";
    }
    else
    {
      AMSupportCreateMergedDictionary();
      uint64_t v21 = 0;
      uint64_t v22 = "failed to create merged restore Info dictionary";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreInfo", (uint64_t)v22, v16, v17, v18, v19, v20, v28);
    uint64_t v24 = 0;
    goto LABEL_20;
  }
  if (AMAuthInstallApImg4EncodeRestoreDict(theDict, (uint64_t)&v29, (uint64_t)&v31 + 4))
  {
    uint64_t v27 = "AMAuthInstallApImg4EncodeRestoreDict failed";
    goto LABEL_30;
  }
  CFMutableDictionaryRef Mutable = 0;
LABEL_15:
  uint64_t v23 = CFDataCreateMutable(0, 0);
  uint64_t v24 = v23;
  if (!v23
    || (CFDataAppendBytes(v23, bytes, HIDWORD(length)), CFDataAppendBytes(v24, v29, HIDWORD(v31)), !DEREncoderCreate()))
  {
    if (!EncodingWithTag)
    {
      uint64_t v21 = 2;
      goto LABEL_20;
    }
LABEL_31:
    *a3 = 0;
    uint64_t v21 = 3;
    goto LABEL_20;
  }
  CFDataGetBytePtr(v24);
  CFDataGetLength(v24);
  if (DEREncoderAddData() || DEREncoderCreateEncodedBuffer()) {
    goto LABEL_31;
  }
  CFDataRef v25 = CFDataCreate(0, 0, v31);
  *a3 = v25;
  uint64_t v21 = 2 * (v25 == 0);
LABEL_20:
  SafeRelease(Mutable);
  SafeFree(v29);
  SafeFree(0);
  SafeRelease(v24);
  DEREncoderDestroy();
  return v21;
}

uint64_t AMAuthInstallApImg4PersonalizeFile(uint64_t a1, CFURLRef anURL, const __CFURL *a3, const void *a4)
{
  CFURLRef anURLa = 0;
  key = 0;
  CFDictionaryRef v55 = 0;
  value = 0;
  CFDictionaryRef theDict = 0;
  if (!a1)
  {
    CFStringRef v5 = 0;
    CFStringRef TypeForEntryName = 0;
    uint64_t PersonalizedResponse = 1;
    goto LABEL_24;
  }
  CFStringRef v5 = 0;
  uint64_t PersonalizedResponse = 1;
  if (!a3 || !anURL)
  {
    CFStringRef TypeForEntryName = 0;
    goto LABEL_24;
  }
  CFStringRef TypeForEntryName = 0;
  if (*(void *)(a1 + 16))
  {
    CFStringRef v5 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
    if (!v5)
    {
      CFStringRef TypeForEntryName = 0;
      goto LABEL_30;
    }
    CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v11 = AMAuthInstallApImg4CreateRequestTagFromFileURL(v10, v5, @"=", (CFStringRef *)&key, &anURLa);
    if (v11)
    {
      uint64_t PersonalizedResponse = v11;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4PersonalizeFile", (uint64_t)"could not get request tag from path %@", v12, v13, v14, v15, v16, (char)v5);
    }
    else
    {
      CFStringRef TypeForEntryName = 0;
      uint64_t PersonalizedResponse = 14;
      if (!key || !anURLa) {
        goto LABEL_24;
      }
      if (a4)
      {
        value = (void *)CFRetain(a4);
        goto LABEL_13;
      }
      CFStringRef TypeForEntryName = AMAuthInstallApImg4GetTypeForEntryName((CFStringRef)key);
      if (!TypeForEntryName) {
        goto LABEL_34;
      }
      CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)a1);
      uint64_t MeasurementsWithTag = AMAuthInstallApImg4CreateMeasurementsWithTag(v17, anURLa, TypeForEntryName, *(_DWORD *)(*(void *)(a1 + 16) + 112), (CFTypeRef *)&value);
      if (!MeasurementsWithTag)
      {
LABEL_13:
        CFAllocatorRef v24 = CFGetAllocator((CFTypeRef)a1);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v24, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFStringRef TypeForEntryName = (const __CFString *)Mutable;
        if (Mutable)
        {
          CFDictionaryAddValue(Mutable, key, value);
          uint64_t ServerRequestDictionary = AMAuthInstallApImg4CreateServerRequestDictionary((void *)a1, (const __CFDictionary *)TypeForEntryName, (CFTypeRef *)&v55);
          if (ServerRequestDictionary)
          {
            uint64_t PersonalizedResponse = ServerRequestDictionary;
            uint64_t v52 = "failed to create request dict";
            goto LABEL_37;
          }
          uint64_t PersonalizedResponse = AMAuthInstallApCreatePersonalizedResponse(a1, v55, (CFTypeRef *)&theDict);
          if (PersonalizedResponse || !theDict)
          {
            uint64_t v52 = "failed to create response dict";
            goto LABEL_37;
          }
          if (CFDictionaryGetValue(theDict, *(const void **)(a1 + 88)))
          {
            CFStringRef v42 = AMAuthInstallApImg4GetTypeForEntryName((CFStringRef)key);
            if (v42)
            {
              CFStringRef v43 = v42;
              if (CFStringCompare(v42, (CFStringRef)key, 0)) {
                CFStringRef v44 = v43;
              }
              else {
                CFStringRef v44 = 0;
              }
              uint64_t v45 = AMAuthInstallApImg4StitchData((const void **)a1, v44, anURLa, a3, theDict, 0);
              if (v45)
              {
                uint64_t PersonalizedResponse = v45;
                AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4PersonalizeFile", (uint64_t)"failed to stitch ticket to %@", v46, v47, v48, v49, v50, (char)a3);
                goto LABEL_24;
              }
              uint64_t PersonalizedResponse = AMAuthInstallApImg4StitchRestoreInfoWithAMAI(v44, a3, theDict, 0, a1);
              if (!PersonalizedResponse) {
                goto LABEL_24;
              }
              char v53 = (char)a3;
              uint64_t v52 = "failed to stitch restore info to %@";
LABEL_37:
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4PersonalizeFile", (uint64_t)v52, v32, v33, v34, v35, v36, v53);
              goto LABEL_24;
            }
          }
          else
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4PersonalizeFile", (uint64_t)"Ap ticket not found in response", v37, v38, v39, v40, v41, v53);
          }
LABEL_34:
          uint64_t PersonalizedResponse = 8;
          goto LABEL_24;
        }
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4PersonalizeFile", (uint64_t)"failed to create mutable dict measurementDict", v26, v27, v28, v29, v30, v53);
LABEL_30:
        uint64_t PersonalizedResponse = 2;
        goto LABEL_24;
      }
      uint64_t PersonalizedResponse = MeasurementsWithTag;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4PersonalizeFile", (uint64_t)"could not measure %@", v19, v20, v21, v22, v23, (char)v5);
    }
    CFStringRef TypeForEntryName = 0;
  }
LABEL_24:
  SafeRelease(v5);
  SafeRelease(key);
  SafeRelease(anURLa);
  SafeRelease(value);
  SafeRelease(TypeForEntryName);
  SafeRelease(v55);
  SafeRelease(theDict);
  return PersonalizedResponse;
}

uint64_t AMAuthInstallApImg4ForceServerSigning(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t result = 1;
  if (v1)
  {
    *(unsigned char *)(v1 + 78) = 1;
    return 0;
  }
  return result;
}

BOOL AMAuthInstallApImg4SupportsLocalSigning(uint64_t a1)
{
  BOOL result = 0;
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 16);
    if (v1)
    {
      if (*(unsigned char *)(v1 + 76)) {
        return 1;
      }
    }
  }
  return result;
}

BOOL AMAuthInstallApImg4SupportsGlobalSigning(uint64_t a1)
{
  return a1 && *(void *)(a1 + 40);
}

uint64_t AMAuthInstallApImg4SetParameters(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  if (!*(void *)(a1 + 16))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4SetParameters", (uint64_t)"%s: make sure to call AMAuthInstallApSetParameters first", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4SetParameters");
    return 1;
  }
  if (!theDict) {
    return 1;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ApCertificateEpoch");
  if (Value)
  {
    CFNumberRef v11 = Value;
    CFTypeID v12 = CFGetTypeID(Value);
    if (v12 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      if (CFNumberGetValue(v11, kCFNumberIntType, &valuePtr)) {
        *(_DWORD *)(*(void *)(a1 + 16) + 68) = valuePtr;
      }
    }
  }
  CFBooleanRef v13 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApLeafCertStatus");
  if (v13)
  {
    CFBooleanRef v14 = v13;
    CFTypeID v15 = CFGetTypeID(v13);
    if (v15 == CFBooleanGetTypeID()) {
      *(unsigned char *)(*(void *)(a1 + 16) + 73) = CFBooleanGetValue(v14);
    }
  }
  CFBooleanRef v16 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApAllowMixAndMatch");
  if (v16)
  {
    CFBooleanRef v17 = v16;
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 == CFBooleanGetTypeID()) {
      *(unsigned char *)(*(void *)(a1 + 16) + 74) = CFBooleanGetValue(v17);
    }
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, @"SepNonce");
  if (result)
  {
    uint64_t v20 = (const void *)result;
    CFTypeID v21 = CFGetTypeID((CFTypeRef)result);
    if (v21 == CFDataGetTypeID())
    {
      SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 48));
      CFTypeRef v22 = CFRetain(v20);
      uint64_t result = 0;
      *(void *)(*(void *)(a1 + 16) + 48) = v22;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t AMAuthInstallApImg4GetTagAsInteger(CFStringRef theString)
{
  unsigned int v4 = 0;
  if (!theString) {
    return 0xFFFFFFFFLL;
  }
  for (CFIndex i = 0; i != 4; ++i)
  {
    if (i == CFStringGetLength(theString)) {
      break;
    }
    *((unsigned char *)&v4 + i) = CFStringGetCharacterAtIndex(theString, i);
  }
  return bswap32(v4);
}

uint64_t AMAuthInstallApImg4AddInteger32Property(uint64_t a1, const __CFString *a2, const __CFNumber *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int valuePtr = 0;
  if (!a1 || !a2 || !a3 || !DEREncoderCreate()) {
    goto LABEL_18;
  }
  int CString = CFStringGetCString(a2, buffer, 256, 0x8000100u);
  if (CString)
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v29 = (char)a2;
      uint64_t v28 = "failed to add %@ string";
      goto LABEL_17;
    }
  }
  if (!CFNumberGetValue(a3, kCFNumberSInt32Type, &valuePtr))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger32Property", (uint64_t)"%s: invalid datatype", v16, v17, v18, v19, v20, (char)"AMAuthInstallApImg4AddInteger32Property");
    if (CString)
    {
      uint64_t v26 = 1;
      goto LABEL_11;
    }
LABEL_18:
    uint64_t v26 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger32Property", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddInteger32Property");
    goto LABEL_11;
  }
  if (DEREncoderAddUInt32())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger32Property", (uint64_t)"failed to add %@ value", v21, v22, v23, v24, v25, (char)a2);
    goto LABEL_18;
  }
  AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder())
  {
    uint64_t v28 = "failed to sequence tag";
LABEL_17:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger32Property", (uint64_t)v28, v11, v12, v13, v14, v15, v29);
    goto LABEL_18;
  }
  uint64_t v26 = 0;
LABEL_11:
  DEREncoderDestroy();
  return v26;
}

uint64_t AMAuthInstallApImg4AddInteger64Property(uint64_t a1, const __CFString *a2, const __CFNumber *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t valuePtr = 0;
  if (!a1 || !a2 || !a3 || !DEREncoderCreate()) {
    goto LABEL_18;
  }
  int CString = CFStringGetCString(a2, buffer, 256, 0x8000100u);
  if (CString)
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v29 = (char)a2;
      uint64_t v28 = "failed to add %@ string";
      goto LABEL_17;
    }
  }
  if (!CFNumberGetValue(a3, kCFNumberSInt64Type, &valuePtr))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger64Property", (uint64_t)"%s: invalid datatype", v16, v17, v18, v19, v20, (char)"AMAuthInstallApImg4AddInteger64Property");
    if (CString)
    {
      uint64_t v26 = 1;
      goto LABEL_11;
    }
LABEL_18:
    uint64_t v26 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger64Property", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddInteger64Property");
    goto LABEL_11;
  }
  if (DEREncoderAddUInt64())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger64Property", (uint64_t)"failed to add %@ value", v21, v22, v23, v24, v25, (char)a2);
    goto LABEL_18;
  }
  AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder())
  {
    uint64_t v28 = "failed to sequence tag";
LABEL_17:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger64Property", (uint64_t)v28, v11, v12, v13, v14, v15, v29);
    goto LABEL_18;
  }
  uint64_t v26 = 0;
LABEL_11:
  DEREncoderDestroy();
  return v26;
}

uint64_t AMAuthInstallApImg4AddBooleanProperty(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || !DEREncoderCreate()) {
    goto LABEL_14;
  }
  if (CFStringGetCString(a2, buffer, 256, 0x8000100u))
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v22 = (char)a2;
      uint64_t v21 = "failed to add %@ string";
      goto LABEL_13;
    }
  }
  if (DEREncoderAddData())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddBooleanProperty", (uint64_t)"%s: failed to add data", v14, v15, v16, v17, v18, (char)"AMAuthInstallApImg4AddBooleanProperty");
LABEL_14:
    uint64_t v19 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddBooleanProperty", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddBooleanProperty");
    goto LABEL_9;
  }
  AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder())
  {
    uint64_t v21 = "failed to sequence tag";
LABEL_13:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddBooleanProperty", (uint64_t)v21, v9, v10, v11, v12, v13, v22);
    goto LABEL_14;
  }
  uint64_t v19 = 0;
LABEL_9:
  DEREncoderDestroy();
  return v19;
}

uint64_t AMAuthInstallApImg4AddDataProperty(uint64_t a1, const __CFString *a2, const __CFData *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || !a3 || !DEREncoderCreate()) {
    goto LABEL_15;
  }
  if (CFStringGetCString(a2, buffer, 256, 0x8000100u))
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v23 = (char)a2;
      char v22 = "failed to add %@ string";
      goto LABEL_14;
    }
  }
  CFDataGetBytePtr(a3);
  CFDataGetLength(a3);
  if (DEREncoderAddData())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDataProperty", (uint64_t)"failed to add %@ data", v15, v16, v17, v18, v19, (char)a2);
LABEL_15:
    uint64_t v20 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDataProperty", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddDataProperty");
    goto LABEL_10;
  }
  AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder())
  {
    char v22 = "failed to sequence tag";
LABEL_14:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDataProperty", (uint64_t)v22, v10, v11, v12, v13, v14, v23);
    goto LABEL_15;
  }
  uint64_t v20 = 0;
LABEL_10:
  DEREncoderDestroy();
  return v20;
}

uint64_t AMAuthInstallApImg4AddDictionaryProperty(uint64_t a1, uint64_t a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || !a3 || !DEREncoderCreate()) {
    goto LABEL_15;
  }
  if (CFStringGetCString(a3, buffer, 256, 0x8000100u))
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v17 = (char)a3;
      uint64_t v16 = "failed to add %@ string";
      goto LABEL_14;
    }
  }
  if (DEREncoderAddSetFromEncoder())
  {
    uint64_t v16 = "failed to add set";
LABEL_14:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDictionaryProperty", (uint64_t)v16, v9, v10, v11, v12, v13, v17);
LABEL_15:
    uint64_t v14 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDictionaryProperty", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddDictionaryProperty");
    goto LABEL_10;
  }
  AMAuthInstallApImg4GetTagAsInteger(a3);
  if (DEREncoderAddPrivateFromEncoder())
  {
    uint64_t v16 = "failed to add private";
    goto LABEL_14;
  }
  uint64_t v14 = 0;
LABEL_10:
  DEREncoderDestroy();
  return v14;
}

uint64_t AMAuthInstallApImg4DecodeRestoreInfo(const __CFData *a1, CFMutableDictionaryRef *a2)
{
  if (!a1 || !*a2) {
    return 1;
  }
  uint64_t v32 = 0;
  long long v31 = 0u;
  memset(v30, 0, sizeof(v30));
  v29[0] = 0;
  v29[1] = 0;
  v28[0] = 0;
  v28[1] = 0;
  unint64_t v27 = 0;
  BytePtr = CFDataGetBytePtr(a1);
  unsigned int Length = CFDataGetLength(a1);
  Img4DecodeInit((uint64_t)BytePtr, Length, (uint64_t)v30);
  if (v11)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4DecodeRestoreInfo", (uint64_t)"Img4DecodeInit img4 decode failed.", v6, v7, v8, v9, v10, v20);
  }
  else
  {
    if (!DERDecodeSeqContentInit((unint64_t *)&v31 + 1, v29))
    {
      while (1)
      {
        do
        {
          while (1)
          {
            int v12 = DERDecodeSeqNext(v29, &v27);
            if (!v12) {
              break;
            }
            if (v12 == 1) {
              return 0;
            }
          }
          unint64_t v25 = 0;
          v26[0] = 0;
          v26[1] = 0;
          v24[0] = 0;
          v24[1] = 0;
          uint64_t v21 = 0;
          char v22 = 0;
          CFIndex v23 = 0;
        }
        while (DERDecodeItem((uint64_t)v28, &v25)
             || DERDecodeSeqContentInit(v26, v24)
             || DERDecodeSeqNext(v24, (unint64_t *)&v21)
             || v21 != 22);
        CFStringRef v13 = CFStringCreateWithBytes(kCFAllocatorDefault, v22, v23, 0x8000100u, 0);
        if (v13)
        {
          if (!DERDecodeSeqNext(v24, (unint64_t *)&v21)) {
            break;
          }
        }
LABEL_35:
        SafeRelease(v13);
      }
      if (v21 > 3)
      {
        if (v21 == 4)
        {
          uint64_t v16 = CFDataCreate(kCFAllocatorDefault, v22, v23);
        }
        else
        {
          if (v21 != 22) {
            goto LABEL_35;
          }
          uint64_t v16 = CFStringCreateWithBytes(kCFAllocatorDefault, v22, v23, 0x8000100u, 0);
        }
        uint64_t v18 = v16;
        if (v16) {
          CFDictionarySetValue(*a2, v13, v16);
        }
        char v17 = v18;
        goto LABEL_34;
      }
      if (v21 == 1)
      {
        LOBYTE(v20) = 0;
        if (DERParseBoolean(&v22, (BOOL *)&v20)) {
          return 23;
        }
        if ((_BYTE)v20) {
          CFBooleanRef v15 = kCFBooleanFalse;
        }
        else {
          CFBooleanRef v15 = kCFBooleanTrue;
        }
        if (!v15) {
          goto LABEL_29;
        }
      }
      else
      {
        if (v21 != 2) {
          goto LABEL_35;
        }
        unint64_t v20 = 0;
        if (DERParseInteger64((char **)&v22, &v20)) {
          return 23;
        }
        CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &v20);
        if (!v14) {
          goto LABEL_29;
        }
        CFBooleanRef v15 = v14;
      }
      CFDictionarySetValue(*a2, v13, v15);
LABEL_29:
      char v17 = 0;
LABEL_34:
      SafeRelease(v17);
      goto LABEL_35;
    }
    AMSupportLogInternal();
  }
  return 99;
}

uint64_t AMAuthInstallApImg4EncodeRestoreDict(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  if (!a1 || !a2)
  {
    unsigned int v4 = 0;
    goto LABEL_41;
  }
  unsigned int v4 = 0;
  if (!a3) {
    goto LABEL_41;
  }
  uint64_t v6 = DEREncoderCreate();
  if (!v6)
  {
    uint64_t v3 = 0;
    unsigned int v4 = 0;
    goto LABEL_41;
  }
  unsigned int Count = CFDictionaryGetCount(a1);
  size_t v8 = 8 * Count;
  uint64_t v3 = (const void **)malloc(v8);
  uint64_t v9 = (const void **)malloc(v8);
  unsigned int v4 = v9;
  if (!v3 || !v9) {
    goto LABEL_41;
  }
  CFDictionaryGetKeysAndValues(a1, v3, v9);
  if (Count)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 8 * Count;
    char v17 = "%s: unexpected restore property type";
    while (1)
    {
      CFStringRef v18 = (const __CFString *)v3[v15 / 8];
      if (!v18 || (CFTypeID v19 = CFGetTypeID(v3[v15 / 8]), v19 != CFStringGetTypeID()))
      {
        uint64_t v60 = "invalid overridesKey";
        goto LABEL_40;
      }
      unint64_t v20 = v4[v15 / 8];
      if (!v20) {
        break;
      }
      CFTypeID v21 = CFGetTypeID(v20);
      if (v21 == CFDataGetTypeID())
      {
        if (AMAuthInstallApImg4AddDataProperty(v6, v18, (const __CFData *)v4[v15 / 8], v22, v23, v24, v25, v26))goto LABEL_39; {
      }
        }
      else
      {
        CFTypeID v27 = CFGetTypeID(v4[v15 / 8]);
        CFTypeID TypeID = CFBooleanGetTypeID();
        CFBooleanRef v29 = (const __CFBoolean *)v4[v15 / 8];
        if (v27 == TypeID)
        {
          uint64_t Value = CFBooleanGetValue(v29);
          if (AMAuthInstallApImg4AddBooleanProperty(v6, v18, Value, v31, v32, v33, v34, v35)) {
            goto LABEL_39;
          }
        }
        else
        {
          CFTypeID v36 = CFGetTypeID(v29);
          if (v36 != CFNumberGetTypeID()) {
            goto LABEL_38;
          }
          CFNumberRef v42 = (const __CFNumber *)v4[v15 / 8];
          if (CFNumberGetType(v42) == kCFNumberSInt32Type)
          {
            if (AMAuthInstallApImg4AddInteger32Property(v6, v18, v42, v43, v44, v45, v46, v47)) {
              goto LABEL_39;
            }
          }
          else
          {
            if (CFNumberGetType(v42) != kCFNumberSInt64Type)
            {
              char v17 = "%s: unexpected integer type";
LABEL_38:
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreDict", (uint64_t)v17, v37, v38, v39, v40, v41, (char)"AMAuthInstallApImg4EncodeRestoreDict");
LABEL_39:
              uint64_t v60 = "failed to encode restore property";
              goto LABEL_40;
            }
            if (AMAuthInstallApImg4AddInteger64Property(v6, (const __CFString *)v3[v15 / 8], v42, v37, v38, v39, v40, v41))goto LABEL_39; {
          }
            }
        }
      }
      v15 += 8;
      if (v16 == v15) {
        goto LABEL_25;
      }
    }
    uint64_t v60 = "invalid overridesValue";
LABEL_40:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreDict", (uint64_t)v60, v10, v11, v12, v13, v14, (char)v62);
    goto LABEL_41;
  }
LABEL_25:
  if (!DEREncoderCreate())
  {
LABEL_41:
    uint64_t v58 = 3;
    goto LABEL_36;
  }
  if (CFStringGetCString(@"IM4R", buffer, 256, 0x8000100u))
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      CFStringRef v62 = @"IM4M";
      uint64_t v61 = "failed to add %@ string";
      goto LABEL_52;
    }
  }
  if (DEREncoderAddSetFromEncoder())
  {
    uint64_t v61 = "failed to encode restore info properties as set";
LABEL_52:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreDict", (uint64_t)v61, v48, v49, v50, v51, v52, (char)v62);
    goto LABEL_41;
  }
  if (!DEREncoderCreate())
  {
LABEL_48:
    uint64_t v58 = 2;
    goto LABEL_36;
  }
  if (DEREncoderAddSequenceFromEncoder())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreDict", (uint64_t)"failed to encode restore info sequence", v53, v54, v55, v56, v57, (char)v62);
    goto LABEL_41;
  }
  if (DEREncoderCreateEncodedBuffer()) {
    goto LABEL_41;
  }
  if (!DEREncoderCreate()) {
    goto LABEL_48;
  }
  if (DEREncoderAddData() || DEREncoderCreateEncodedBuffer()) {
    goto LABEL_41;
  }
  uint64_t v58 = 0;
LABEL_36:
  SafeFree(v3);
  SafeFree(v4);
  SafeFree(0);
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  return v58;
}

uint64_t AMAuthInstallApImg4CopyURLAddingExtension(const __CFAllocator *a1, CFURLRef url, CFTypeRef *a3)
{
  CFStringRef v3 = 0;
  uint64_t v4 = 1;
  if (!url)
  {
    CFURLRef v6 = 0;
    CFURLRef v7 = 0;
    goto LABEL_6;
  }
  CFURLRef v6 = 0;
  CFURLRef v7 = 0;
  if (a3)
  {
    CFStringRef v3 = CFURLCopyPathExtension(url);
    CFURLRef v6 = CFURLCreateCopyDeletingPathExtension(a1, url);
    if (v6)
    {
      CFURLRef v10 = CFURLCreateCopyAppendingPathExtension(a1, v6, @"img4");
      CFURLRef v7 = v10;
      if (v10)
      {
        uint64_t v4 = 0;
        *a3 = CFRetain(v10);
        goto LABEL_6;
      }
    }
    else
    {
      CFURLRef v7 = 0;
    }
    uint64_t v4 = 2;
  }
LABEL_6:
  SafeRelease(v3);
  SafeRelease(v6);
  SafeRelease(v7);
  return v4;
}

uint64_t AMAuthInstallApImg4ReCreatePayloadWithProperties(const char *a1, const char *a2, CFDataRef theData, const __CFData *a4, const __CFData *a5, const __CFData *a6, const __CFData *a7, CFDataRef *a8)
{
  uint64_t v9 = 0;
  BytePtr = 0;
  CFIndex v48 = 0;
  uint64_t PayloadWithProperties = 1;
  CFDataRef v11 = 0;
  CFDataRef v12 = 0;
  CFDataRef v13 = 0;
  CFDataRef v14 = 0;
  CFDataRef v15 = 0;
  if (theData && a8)
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex v48 = CFDataGetLength(theData);
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    *(_OWORD *)CFIndex length = 0u;
    *(_OWORD *)uint64_t v58 = 0u;
    *(_OWORD *)uint64_t v59 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    int v23 = DERImg4DecodePayload((uint64_t)&BytePtr, (unint64_t)&v54);
    if (v23)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4ReCreatePayloadWithProperties", (uint64_t)"failed to decode img4 payload, error:%d", v24, v25, v26, v27, v28, v23);
      uint64_t v9 = 0;
      CFDataRef v11 = 0;
      CFDataRef v12 = 0;
      CFDataRef v13 = 0;
      CFDataRef v14 = 0;
      CFDataRef v15 = 0;
      uint64_t PayloadWithProperties = 99;
      goto LABEL_39;
    }
    if (a1) {
      CFBooleanRef v29 = strdup(a1);
    }
    else {
      CFBooleanRef v29 = strndup((const char *)v55, *((size_t *)&v55 + 1));
    }
    uint64_t v9 = v29;
    if (!v29
      || (!a2 ? (v30 = *((void *)&v56 + 1), uint64_t v31 = (const UInt8 *)v56) : (v30 = strlen(a2), uint64_t v31 = (const UInt8 *)a2),
          (CFDataRef v32 = CFDataCreate(0, v31, v30)) == 0))
    {
      CFDataRef v11 = 0;
      CFDataRef v12 = 0;
      CFDataRef v13 = 0;
      CFDataRef v14 = 0;
      CFDataRef v15 = 0;
      uint64_t PayloadWithProperties = 2;
      goto LABEL_39;
    }
    if (a4)
    {
      CFDataRef Copy = CFDataCreateCopy(0, a4);
    }
    else
    {
      if (!length[0]) {
        goto LABEL_43;
      }
      CFDataRef Copy = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)length[0], length[1], kCFAllocatorNull);
    }
    CFDataRef v34 = Copy;
    if (Copy)
    {
      if (a5)
      {
        CFDataRef v35 = CFDataCreateCopy(0, a5);
      }
      else
      {
        if (!v58[0])
        {
          CFDataRef v13 = 0;
          if (a6)
          {
LABEL_23:
            CFDataRef v36 = CFDataCreateCopy(0, a6);
LABEL_27:
            CFDataRef v14 = v36;
            if (v36)
            {
              if (a7)
              {
LABEL_29:
                CFDataRef v37 = CFDataCreateCopy(0, a7);
                goto LABEL_30;
              }
LABEL_33:
              long long v52 = 0u;
              long long v53 = 0u;
              *(_OWORD *)uint64_t v50 = 0u;
              long long v51 = 0u;
              memset(v49, 0, sizeof(v49));
              int v38 = DERImg4DecodePayloadWithProperties((uint64_t)&BytePtr, (unint64_t)v49);
              if (v38)
              {
                AMAuthInstallLog(7, (uint64_t)"AMAuthInstallApImg4ReCreatePayloadWithProperties", (uint64_t)"failed to decode img4 payload with properties (error=%d), assuming no properties", v39, v40, v41, v42, v43, v38);
              }
              else if (v50[0])
              {
                CFDataRef v37 = CFDataCreate(0, (const UInt8 *)v50[0], v50[1]);
LABEL_30:
                CFDataRef v15 = v37;
                if (!v37) {
                  goto LABEL_47;
                }
LABEL_36:
                uint64_t v44 = (const char *)CFDataGetBytePtr(v32);
                uint64_t PayloadWithProperties = AMAuthInstallApImg4CreatePayloadWithProperties(v9, v44, v34, v13, v14, v15, a8);
LABEL_37:
                CFDataRef v12 = v34;
LABEL_38:
                CFDataRef v11 = v32;
                goto LABEL_39;
              }
              CFDataRef v15 = 0;
              goto LABEL_36;
            }
LABEL_46:
            CFDataRef v15 = 0;
LABEL_47:
            uint64_t PayloadWithProperties = 2;
            goto LABEL_37;
          }
LABEL_25:
          if (!v59[0])
          {
            CFDataRef v14 = 0;
            if (a7) {
              goto LABEL_29;
            }
            goto LABEL_33;
          }
          CFDataRef v36 = CFDataCreate(0, (const UInt8 *)v59[0], v59[1]);
          goto LABEL_27;
        }
        CFDataRef v35 = CFDataCreate(0, (const UInt8 *)v58[0], v58[1]);
      }
      CFDataRef v13 = v35;
      if (!v35)
      {
        CFDataRef v14 = 0;
        goto LABEL_46;
      }
      if (a6) {
        goto LABEL_23;
      }
      goto LABEL_25;
    }
LABEL_43:
    CFDataRef v12 = 0;
    CFDataRef v13 = 0;
    CFDataRef v14 = 0;
    CFDataRef v15 = 0;
    uint64_t PayloadWithProperties = 2;
    goto LABEL_38;
  }
LABEL_39:
  uint64_t v45 = PayloadWithProperties;
  SafeFree(v9);
  SafeRelease(v11);
  SafeRelease(v12);
  SafeRelease(v13);
  SafeRelease(v14);
  SafeRelease(v15);
  return v45;
}

uint64_t AMAuthInstallApImg4CreatePayloadWithProperties(const char *a1, const char *a2, const __CFData *a3, const __CFData *a4, const __CFData *a5, const __CFData *a6, CFDataRef *a7)
{
  uint64_t v7 = 1;
  if (a1 && a2 && a3 && a7 && strlen(a1) == 4)
  {
    if (!DEREncoderCreate() || !DEREncoderCreate()) {
      goto LABEL_34;
    }
    if (DEREncoderAddData())
    {
      unint64_t v20 = "failed to add payload tag to DER file";
    }
    else if (DEREncoderAddData())
    {
      unint64_t v20 = "failed to add payload type to DER file";
    }
    else
    {
      strlen(a2);
      if (DEREncoderAddData())
      {
        unint64_t v20 = "failed to add payload version to DER file";
      }
      else
      {
        CFDataGetBytePtr(a3);
        CFDataGetLength(a3);
        if (!DEREncoderAddDataNoCopy())
        {
          if (a4)
          {
            CFDataGetBytePtr(a4);
            CFDataGetLength(a4);
            if (DEREncoderAddData())
            {
              unint64_t v20 = "failed to add payloadKeybag to DER file";
              goto LABEL_33;
            }
          }
          if (a5)
          {
            CFDataGetBytePtr(a5);
            CFDataGetLength(a5);
            if (DEREncoderAddData())
            {
              unint64_t v20 = "failed to add payloadCompression to DER file";
              goto LABEL_33;
            }
          }
          if (!a6 || (CFDataGetBytePtr(a6), CFDataGetLength(a6), !DEREncoderAddData()))
          {
            if (DEREncoderAddDataFromEncoderNoCopy())
            {
              unint64_t v20 = "failed to add payload to sequence";
            }
            else
            {
              if (!DEREncoderCreateEncodedBuffer())
              {
                uint64_t v7 = 0;
                *a7 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, 0, 0, kCFAllocatorMalloc);
                goto LABEL_21;
              }
              unint64_t v20 = "failed to create DER encoded buffer: sequenceEncoder";
            }
            goto LABEL_33;
          }
        }
        unint64_t v20 = "failed to add payload data to DER file";
      }
    }
LABEL_33:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4CreatePayloadWithProperties", (uint64_t)v20, v14, v15, v16, v17, v18, 0);
LABEL_34:
    uint64_t v7 = 2;
  }
LABEL_21:
  DEREncoderDestroy();
  DEREncoderDestroy();
  return v7;
}

uint64_t AMAuthInstallApImg4CreatePayload(const char *a1, const char *a2, const __CFData *a3, const __CFData *a4, const __CFData *a5, CFDataRef *a6)
{
  return AMAuthInstallApImg4CreatePayloadWithProperties(a1, a2, a3, a4, a5, 0, a6);
}

uint64_t AMAuthInstallApImg4ValidImage(const __CFURL *a1)
{
  CFURLRef v1 = a1;
  uint64_t v18 = 0;
  if (!a1)
  {
    AMSupportCreateErrorInternal();
LABEL_14:
    uint64_t v15 = 0;
    goto LABEL_17;
  }
  CFDataRef v2 = AMAuthInstallPlatformOpenFileStreamWithURL(a1, "rb");
  if (!v2)
  {
    uint64_t v16 = __error();
    strerror(*v16);
    AMSupportCreateErrorInternal();
    CFURLRef v1 = 0;
    goto LABEL_14;
  }
  CFStringRef v3 = v2;
  CFURLRef v4 = (const __CFURL *)malloc(0x20uLL);
  CFURLRef v1 = v4;
  if (v4)
  {
    size_t v5 = fread(v4, 1uLL, 0x20uLL, v3);
    uint64_t v11 = v5;
    if (v5 != 32) {
      AMAuthInstallLog(4, (uint64_t)"AMAuthInstallApImg4ValidImage", (uint64_t)"Read %ld bytes out of expected %ld", v6, v7, v8, v9, v10, v5);
    }
    int v12 = Img4DecodeParseLengthFromBufferWithTag((uint64_t)v1, v11, 0x494D3450u, &v18);
    int v13 = Img4DecodeParseLengthFromBufferWithTag((uint64_t)v1, v11, 0x494D4734u, &v18);
    if (v12) {
      BOOL v14 = v13 == 0;
    }
    else {
      BOOL v14 = 1;
    }
    uint64_t v15 = v14;
  }
  else
  {
    AMSupportCreateErrorInternal();
    uint64_t v15 = 0;
  }
  fclose(v3);
LABEL_17:
  SafeFree(v1);
  return v15;
}

uint64_t sub_10000F188(unint64_t *a1, uint64_t a2, unint64_t a3)
{
  long long v13 = 0uLL;
  long long v12 = 0uLL;
  long long v11 = 0uLL;
  long long v10 = 0uLL;
  uint64_t v5 = sub_10000F330(a1, 0x2000000000000010, &v13);
  if (v5) {
    return v5;
  }
  uint64_t v5 = sub_10000F330((unint64_t *)&v13, 0xA000000000000000, &v12);
  if (v5) {
    return v5;
  }
  uint64_t v5 = sub_10000F330((unint64_t *)&v12, 0x2000000000000010, &v11);
  if (v5) {
    return v5;
  }
  uint64_t v5 = sub_10000F330((unint64_t *)&v11, 0x2000000000000011, &v10);
  if (v5) {
    return v5;
  }
  long long v15 = 0uLL;
  unsigned int v14 = 0;
  uint64_t v6 = sub_10000F330((unint64_t *)&v10, a2, &v15);
  if (v6)
  {
    uint64_t v8 = v6;
LABEL_14:
    AMSupportLogInternal();
    return v8;
  }
  long long v16 = xmmword_100079700;
  __int16 v17 = 0;
  long long v18 = xmmword_100079710;
  __int16 v19 = 0;
  uint64_t v7 = DERParseSequence((uint64_t)&v15, 2u, (uint64_t)&v16, a3, 0);
  if (v7)
  {
    uint64_t v8 = v7;
    goto LABEL_14;
  }
  uint64_t v5 = DERParseInteger((char **)a3, &v14);
  if (v5) {
    return v5;
  }
  if ((v14 | 0xE000000000000000) != a2) {
    return 2;
  }
  uint64_t v8 = 0;
  *(void *)(a3 + 16) = a2 | 0xE000000000000000;
  *(void *)(a3 + 40) = 4;
  return v8;
}

uint64_t sub_10000F330(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  *(_OWORD *)uint64_t v8 = 0uLL;
  uint64_t v5 = DERDecodeSeqContentInit(a1, v8);
  if (v5)
  {
    uint64_t v6 = (uint64_t)v5;
    AMSupportLogInternal();
  }
  else
  {
    long long v11 = *(_OWORD *)v8;
    unint64_t v9 = 0;
    long long v10 = 0uLL;
    while (1)
    {
      uint64_t v6 = DERDecodeSeqNext((unint64_t *)&v11, &v9);
      if (v6) {
        break;
      }
      if (v9 == a2)
      {
        *a3 = v10;
        return v6;
      }
    }
  }
  return v6;
}

CFTypeRef sub_10000F3D0(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 16)) != 0 && (v2 = *(const void **)(v1 + 56)) != 0) {
    return CFRetain(v2);
  }
  else {
    return 0;
  }
}

CFTypeRef sub_10000F3F0(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 16)) != 0 && (v2 = *(const void **)(v1 + 32)) != 0) {
    return CFRetain(v2);
  }
  else {
    return 0;
  }
}

uint64_t AMAuthInstallApImg4LocalCreateManifestBody(uint64_t a1, CFTypeRef a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || !a3)
  {
    uint64_t v165 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)"%s DER operation failed", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4LocalCreateManifestBody");
    if (!a3)
    {
      CFNumberRef v18 = 0;
      goto LABEL_68;
    }
    CFNumberRef v18 = 0;
LABEL_85:
    SafeRelease(*a3);
    uint64_t v165 = 3;
    goto LABEL_68;
  }
  AMAuthInstallDebugWriteObject((char *)a1, a2, @"tss-request", 2);
  uint64_t v16 = DEREncoderCreate();
  if (!v16)
  {
    CFNumberRef v18 = 0;
    goto LABEL_84;
  }
  CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)a1);
  CFNumberRef v18 = CFNumberCreate(v17, kCFNumberIntType, (const void *)(*(void *)(a1 + 16) + 68));
  if (!v18) {
    goto LABEL_84;
  }
  if (AMAuthInstallApImg4AddInteger32Property(v16, @"CEPO", v18, v11, v12, v13, v14, v15)) {
    goto LABEL_84;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApChipID");
  if (Value)
  {
    CFNumberRef v20 = Value;
    CFTypeID v21 = CFGetTypeID(Value);
    if (v21 == CFNumberGetTypeID())
    {
      if (AMAuthInstallApImg4AddInteger32Property(v16, @"CHIP", v20, v22, v23, v24, v25, v26)) {
        goto LABEL_84;
      }
    }
  }
  CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApBoardID");
  if (v27)
  {
    CFNumberRef v28 = v27;
    CFTypeID v29 = CFGetTypeID(v27);
    if (v29 == CFNumberGetTypeID())
    {
      if (AMAuthInstallApImg4AddInteger32Property(v16, @"BORD", v28, v30, v31, v32, v33, v34)) {
        goto LABEL_84;
      }
    }
  }
  CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApECID");
  if (v35 && (CFNumberRef v36 = v35, v37 = CFGetTypeID(v35), v37 == CFNumberGetTypeID()))
  {
    if (AMAuthInstallApImg4AddInteger64Property(v16, @"ECID", v36, v38, v39, v40, v41, v42))
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)"failed to add ApEcid", v43, v44, v45, v46, v47, v168);
      goto LABEL_84;
    }
    char v48 = 1;
  }
  else
  {
    char v48 = 0;
  }
  CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApSecurityDomain");
  if (v49)
  {
    CFNumberRef v50 = v49;
    CFTypeID v51 = CFGetTypeID(v49);
    if (v51 == CFNumberGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddInteger32Property(v16, @"SDOM", v50, v52, v53, v54, v55, v56);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFBooleanRef v58 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApProductionMode");
  uint64_t v66 = 0;
  if (v58)
  {
    CFBooleanRef v64 = v58;
    CFTypeID v65 = CFGetTypeID(v58);
    if (v65 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v64)) {
        uint64_t v66 = 1;
      }
    }
  }
  uint64_t v57 = AMAuthInstallApImg4AddBooleanProperty(v16, @"CPRO", v66, v59, v60, v61, v62, v63);
  if (v57) {
    goto LABEL_69;
  }
  CFBooleanRef v67 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApSecurityMode");
  uint64_t v75 = 0;
  if (v67)
  {
    CFBooleanRef v73 = v67;
    CFTypeID v74 = CFGetTypeID(v67);
    if (v74 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v73)) {
        uint64_t v75 = 1;
      }
    }
  }
  uint64_t v57 = AMAuthInstallApImg4AddBooleanProperty(v16, @"CSEC", v75, v68, v69, v70, v71, v72);
  if (v57) {
    goto LABEL_69;
  }
  CFDataRef v76 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApLocalNonceHash");
  if (v76)
  {
    CFDataRef v77 = v76;
    CFTypeID v78 = CFGetTypeID(v76);
    if (v78 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"LNCH", v77, v79, v80, v81, v82, v83);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFDataRef v84 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApNonce");
  if (v84)
  {
    CFDataRef v85 = v84;
    CFTypeID v86 = CFGetTypeID(v84);
    if (v86 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"BNCH", v85, v87, v88, v89, v90, v91);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFDataRef v92 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"SepNonce");
  if (v92)
  {
    CFDataRef v93 = v92;
    CFTypeID v94 = CFGetTypeID(v92);
    if (v94 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"snon", v93, v95, v96, v97, v98, v99);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFBooleanRef v100 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApAllowMixAndMatch");
  if (v100)
  {
    CFBooleanRef v101 = v100;
    CFTypeID v102 = CFGetTypeID(v100);
    if (v102 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v101))
      {
        uint64_t v57 = AMAuthInstallApImg4AddBooleanProperty(v16, @"AMNM", 1, v103, v104, v105, v106, v107);
        if (v57) {
          goto LABEL_69;
        }
      }
    }
  }
  CFDataRef v108 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"Ap,NextStageIM4MHash");
  if (v108)
  {
    CFDataRef v109 = v108;
    CFTypeID v110 = CFGetTypeID(v108);
    if (v110 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"nsih", v109, v111, v112, v113, v114, v115);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFDataRef v116 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"Ap,RecoveryOSPolicyNonceHash");
  if (v116)
  {
    CFDataRef v117 = v116;
    CFTypeID v118 = CFGetTypeID(v116);
    if (v118 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"ronh", v117, v119, v120, v121, v122, v123);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFDataRef v124 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"Ap,VolumeUUID");
  if (v124)
  {
    CFDataRef v125 = v124;
    CFTypeID v126 = CFGetTypeID(v124);
    if (v126 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"vuid", v125, v127, v128, v129, v130, v131);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFBooleanRef v132 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, @"Ap,LocalBoot");
  if (v132)
  {
    CFBooleanRef v133 = v132;
    CFTypeID v134 = CFGetTypeID(v132);
    if (v134 == CFBooleanGetTypeID())
    {
      uint64_t v135 = CFBooleanGetValue(v133);
      uint64_t v57 = AMAuthInstallApImg4AddBooleanProperty(v16, @"lobo", v135, v136, v137, v138, v139, v140);
      if (v57)
      {
LABEL_69:
        uint64_t v165 = v57;
        goto LABEL_79;
      }
    }
  }
  uint64_t v141 = DEREncoderCreate();
  if (!v141) {
    goto LABEL_74;
  }
  uint64_t v142 = AMAuthInstallApImg4AddDictionaryProperty(v16, v141, @"MANP", v11, v12, v13, v14, v15);
  if (v142)
  {
    uint64_t v165 = v142;
    goto LABEL_79;
  }
  CFAllocatorRef v143 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v149 = AMAuthInstallApImg4LocalAddImages(v143, (CFDictionaryRef)a2, v141, v144, v145, v146, v147, v148);
  if (v149)
  {
    uint64_t v165 = v149;
    v167 = "failed to add img objects to the manifest body";
LABEL_78:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)v167, v150, v151, v152, v153, v154, v168);
    goto LABEL_79;
  }
  uint64_t v155 = DEREncoderCreate();
  if (!v155)
  {
LABEL_74:
    uint64_t v165 = 2;
    goto LABEL_79;
  }
  uint64_t v156 = AMAuthInstallApImg4AddDictionaryProperty(v141, v155, @"MANB", v11, v12, v13, v14, v15);
  if (v156)
  {
    uint64_t v165 = v156;
    v167 = "failed to create the signed section";
    goto LABEL_78;
  }
  if (!DEREncoderCreate()) {
    goto LABEL_74;
  }
  uint64_t v157 = DEREncoderAddSetFromEncoder();
  if (v157)
  {
    uint64_t v165 = v157;
LABEL_79:
    if (v48) {
      goto LABEL_68;
    }
    goto LABEL_84;
  }
  if (DEREncoderCreateEncodedBuffer())
  {
LABEL_84:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)"%s DER operation failed", v11, v12, v13, v14, v15, (char)"AMAuthInstallApImg4LocalCreateManifestBody");
    goto LABEL_85;
  }
  CFAllocatorRef v158 = CFGetAllocator((CFTypeRef)a1);
  CFDataRef v159 = CFDataCreate(v158, 0, 0);
  *a3 = v159;
  if (v159)
  {
    uint64_t v165 = 0;
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)"failed to create manifest data", v160, v161, v162, v163, v164, v168);
    uint64_t v165 = 2;
  }
LABEL_68:
  SafeFree(0);
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  SafeRelease(v18);
  return v165;
}

uint64_t AMAuthInstallApImg4LocalAddImages(const __CFAllocator *a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!theDict)
  {
    CFNumberRef v35 = "requestDict cannot be NULL";
LABEL_23:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImages", (uint64_t)v35, a4, a5, a6, a7, a8, v36);
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    CFArrayRef Mutable = 0;
LABEL_24:
    uint64_t v33 = 1;
    goto LABEL_18;
  }
  if (!a3)
  {
    CFNumberRef v35 = "dstEncoder cannot be NULL";
    goto LABEL_23;
  }
  CFIndex Count = CFDictionaryGetCount(theDict);
  uint64_t v12 = (const void **)malloc(8 * Count);
  uint64_t v13 = (const void **)malloc(8 * Count);
  CFDictionaryGetKeysAndValues(theDict, v12, v13);
  CFArrayRef Mutable = CFArrayCreateMutable(a1, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    uint64_t v33 = 2;
    goto LABEL_18;
  }
  if (Count >= 1)
  {
    uint64_t v15 = 0;
    do
    {
      CFStringRef v16 = (const __CFString *)v12[v15];
      if (!v16) {
        goto LABEL_24;
      }
      CFAllocatorRef v17 = v13[v15];
      CFTypeID v18 = CFGetTypeID(v12[v15]);
      if (v18 != CFStringGetTypeID() || v17 == 0) {
        goto LABEL_24;
      }
      CFTypeID v20 = CFGetTypeID(v17);
      if (v20 == CFDictionaryGetTypeID())
      {
        if (CFDictionaryGetValue((CFDictionaryRef)v17, @"Digest"))
        {
          v37.CFIndex length = CFArrayGetCount(Mutable);
          v37.CFIndex location = 0;
          if (CFArrayGetFirstIndexOfValue(Mutable, v37, v16) == -1)
          {
            CFArrayAppendValue(Mutable, v16);
            CFStringRef TypeForEntryName = AMAuthInstallApImg4GetTypeForEntryName(v16);
            if (!TypeForEntryName)
            {
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImages", (uint64_t)"did not find a matching tag for requestTag %@", v22, v23, v24, v25, v26, (char)v16);
              goto LABEL_24;
            }
            uint64_t v27 = AMAuthInstallApImg4LocalAddImageProperties((uint64_t)TypeForEntryName, a3, TypeForEntryName, (const __CFDictionary *)v17, v23, v24, v25, v26);
            if (v27)
            {
              uint64_t v33 = v27;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImages", (uint64_t)"failed to add %@ image to the ticket body", v28, v29, v30, v31, v32, (char)v16);
              goto LABEL_18;
            }
          }
        }
      }
    }
    while (Count != ++v15);
  }
  uint64_t v33 = 0;
LABEL_18:
  SafeFree(v12);
  SafeFree(v13);
  SafeRelease(Mutable);
  return v33;
}

CFDataRef AMAuthInstallApImg4LocalCreateEncodedTag(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedTag", (uint64_t)"%s: tagStr is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4LocalCreateEncodedTag");
    goto LABEL_8;
  }
  char v8 = (char)a1;
  if (!CFStringGetCString(a1, &length[4], 256, 0x8000100u))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedTag", (uint64_t)"%s: cannot convert tagStr", v9, v10, v11, v12, v13, (char)"AMAuthInstallApImg4LocalCreateEncodedTag");
    goto LABEL_8;
  }
  if (!DEREncoderCreate())
  {
LABEL_8:
    SafeRelease(0);
    CFDataRef v24 = 0;
    goto LABEL_9;
  }
  strlen(&length[4]);
  if (DEREncoderAddData())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedTag", (uint64_t)"failed to add %@ string", v14, v15, v16, v17, v18, v8);
    goto LABEL_8;
  }
  if (DEREncoderCreateEncodedBuffer())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedTag", (uint64_t)"%s: failed to create buffer", v19, v20, v21, v22, v23, (char)"AMAuthInstallApImg4LocalCreateEncodedTag");
    goto LABEL_8;
  }
  CFDataRef v24 = CFDataCreate(0, 0, 0);
LABEL_9:
  SafeFree(0);
  DEREncoderDestroy();
  return v24;
}

CFDataRef AMAuthInstallApImg4LocalCreateEncodedVersion()
{
  if (!DEREncoderCreate()) {
    goto LABEL_9;
  }
  if (DEREncoderAddUInt32())
  {
    uint64_t v7 = "failed to add manifest version";
LABEL_8:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedVersion", (uint64_t)v7, v0, v1, v2, v3, v4, (char)v8);
LABEL_9:
    SafeRelease(0);
    CFDataRef v5 = 0;
    goto LABEL_5;
  }
  if (DEREncoderCreateEncodedBuffer())
  {
    char v8 = "AMAuthInstallApImg4LocalCreateEncodedVersion";
    uint64_t v7 = "%s: failed to create buffer";
    goto LABEL_8;
  }
  CFDataRef v5 = CFDataCreate(0, 0, 0);
LABEL_5:
  SafeFree(0);
  DEREncoderDestroy();
  return v5;
}

CFDataRef AMAuthInstallApImg4LocalCreateEncodedData(const __CFData *a1)
{
  if (!DEREncoderCreate()) {
    goto LABEL_8;
  }
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  if (DEREncoderAddData())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedData", (uint64_t)"%s: failed to encode data", v2, v3, v4, v5, v6, (char)"AMAuthInstallApImg4LocalCreateEncodedData");
LABEL_8:
    SafeRelease(0);
    CFDataRef v12 = 0;
    goto LABEL_5;
  }
  if (DEREncoderCreateEncodedBuffer())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedData", (uint64_t)"%s: failed to create buffer", v7, v8, v9, v10, v11, (char)"AMAuthInstallApImg4LocalCreateEncodedData");
    goto LABEL_8;
  }
  CFDataRef v12 = CFDataCreate(0, 0, 0);
LABEL_5:
  SafeFree(0);
  DEREncoderDestroy();
  return v12;
}

uint64_t _AMAuthInstallApImg4LocalCreateSignedManifest(void *a1, const void *a2, const void *a3, const void *a4, const void *a5, CFTypeRef *a6, uint64_t a7, uint64_t a8)
{
  LODWORD(length) = 0;
  CFTypeRef v90 = 0;
  CFDataRef theData = 0;
  CFDataRef v89 = 0;
  if (!a1 || !a2 || !a6)
  {
    uint64_t v48 = 3;
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to create DER file", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
    CFDataRef v58 = 0;
    CFDataRef v39 = 0;
    CFDataRef v30 = 0;
    CFArrayRef Mutable = 0;
    if (!a6) {
      goto LABEL_26;
    }
    goto LABEL_43;
  }
  int v10 = a7;
  CFAllocatorRef v15 = CFGetAllocator(a1);
  CFArrayRef Mutable = CFDataCreateMutable(v15, 0);
  if (!Mutable)
  {
    CFDataRef v30 = 0;
LABEL_48:
    CFDataRef v39 = 0;
    goto LABEL_41;
  }
  CFDataRef EncodedTag = AMAuthInstallApImg4LocalCreateEncodedTag(@"IM4M", v16, v17, v18, v19, v20, v21, v22);
  CFDataRef v30 = EncodedTag;
  if (!EncodedTag)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to encode tag", v25, v26, v27, v28, v29, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
    goto LABEL_48;
  }
  BytePtr = CFDataGetBytePtr(EncodedTag);
  CFIndex v32 = CFDataGetLength(v30);
  CFDataAppendBytes(Mutable, BytePtr, v32);
  CFDataRef EncodedVersion = AMAuthInstallApImg4LocalCreateEncodedVersion();
  CFDataRef v39 = EncodedVersion;
  if (!EncodedVersion)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to encode version", v34, v35, v36, v37, v38, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
    goto LABEL_41;
  }
  uint64_t v40 = CFDataGetBytePtr(EncodedVersion);
  CFIndex v41 = CFDataGetLength(v39);
  CFDataAppendBytes(Mutable, v40, v41);
  if (a3)
  {
    CFDataRef v47 = (const __CFData *)CFRetain(a3);
    CFDataRef theData = v47;
    uint64_t v48 = 99;
    if (v47) {
      goto LABEL_9;
    }
LABEL_13:
    uint64_t v59 = "manifest not found";
LABEL_40:
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)v59, v18, v19, v20, v21, v22, v87);
    goto LABEL_41;
  }
  if (AMAuthInstallApImg4LocalCreateManifestBody((uint64_t)a1, a2, (CFTypeRef *)&theData, v42, v43, v44, v45, v46))
  {
    uint64_t v59 = "failed to create unsigned manifest";
    goto LABEL_40;
  }
  uint64_t v48 = 0;
  CFDataRef v47 = theData;
  if (!theData) {
    goto LABEL_13;
  }
LABEL_9:
  CFNumberRef v49 = CFDataGetBytePtr(v47);
  CFIndex v50 = CFDataGetLength(theData);
  CFDataAppendBytes(Mutable, v49, v50);
  if (!v10)
  {
    if (!AMAuthInstallApImg4LocalRegisterKeys((uint64_t)a1, v51, v52, v53, v54, v55, v56, v57))
    {
      if (a4)
      {
        CFTypeRef v60 = CFRetain(a4);
        CFTypeRef v90 = v60;
        if (v60)
        {
          CFDataRef EncodedData = AMAuthInstallApImg4LocalCreateEncodedData((const __CFData *)v60);
          CFDataRef v58 = EncodedData;
          if (EncodedData)
          {
            CFBooleanRef v67 = CFDataGetBytePtr(EncodedData);
            CFIndex v68 = CFDataGetLength(v58);
            CFDataAppendBytes(Mutable, v67, v68);
            if (a5)
            {
              CFDataRef v69 = (const __CFData *)CFRetain(a5);
              CFDataRef v89 = v69;
              if (v69)
              {
LABEL_20:
                uint64_t v75 = CFDataGetBytePtr(v69);
                CFIndex v76 = CFDataGetLength(v89);
                CFDataAppendBytes(Mutable, v75, v76);
                uint64_t v48 = 0;
                goto LABEL_21;
              }
            }
            else
            {
              if (AMAuthInstallApImg4LocalCreateEncodedCertificateChain((uint64_t)a1, (CFTypeRef *)&v89))
              {
                CFTypeID v86 = "failed to add certificate";
                goto LABEL_53;
              }
              CFDataRef v69 = v89;
              if (v89) {
                goto LABEL_20;
              }
            }
            CFTypeID v86 = "certificate not found";
LABEL_53:
            AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)v86, v70, v71, v72, v73, v74, v87);
            goto LABEL_42;
          }
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to encode signature", v62, v63, v64, v65, v66, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
LABEL_42:
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to create DER file", v18, v19, v20, v21, v22, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
LABEL_43:
          SafeRelease(*a6);
          *a6 = 0;
          uint64_t v48 = 3;
          goto LABEL_26;
        }
        goto LABEL_38;
      }
      int v85 = *(_DWORD *)(a1[2] + 112);
      if (v85 == 384)
      {
        CFDataGetBytePtr(theData);
        CFDataGetLength(theData);
        if (AMAuthInstallCryptoCreateRsaSignature_SHA384()) {
          goto LABEL_41;
        }
        goto LABEL_38;
      }
      if (v85 != 256)
      {
        if (v85 != 1)
        {
          int v87 = *(_DWORD *)(a1[2] + 112);
          uint64_t v59 = "Unsupported digest type: %d";
          goto LABEL_40;
        }
        CFDataGetBytePtr(theData);
        CFDataGetLength(theData);
        if (AMAuthInstallCryptoCreateRsaSignature()) {
          goto LABEL_41;
        }
        goto LABEL_38;
      }
      CFDataGetBytePtr(theData);
      CFDataGetLength(theData);
      if (!AMAuthInstallCryptoCreateRsaSignature_SHA256())
      {
LABEL_38:
        uint64_t v59 = "signature not found";
        goto LABEL_40;
      }
    }
LABEL_41:
    CFDataRef v58 = 0;
    goto LABEL_42;
  }
  CFDataRef v58 = 0;
LABEL_21:
  if (!DEREncoderCreate()) {
    goto LABEL_42;
  }
  CFDataGetBytePtr(Mutable);
  CFDataGetLength(Mutable);
  if (DEREncoderAddData() || DEREncoderCreateEncodedBuffer()) {
    goto LABEL_42;
  }
  CFAllocatorRef v77 = CFGetAllocator(a1);
  CFDataRef v78 = CFDataCreate(v77, 0, length);
  *a6 = v78;
  if (!v78)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"failed to create manifest data", v79, v80, v81, v82, v83, v87);
    uint64_t v48 = 2;
  }
LABEL_26:
  SafeRelease(Mutable);
  SafeRelease(v30);
  SafeRelease(v39);
  SafeRelease(theData);
  SafeRelease(v90);
  SafeRelease(v58);
  SafeRelease(v89);
  SafeFree(0);
  DEREncoderDestroy();
  return v48;
}

uint64_t AMAuthInstallApImg4LocalRegisterKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v8 + 20))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalRegisterKeys", (uint64_t)"local signing is not available for production fused devices.", a4, a5, a6, a7, a8, v26);
    return 14;
  }
  if (!*(void *)(a1 + 392))
  {
    if (*(unsigned char *)(v8 + 72) || *(_DWORD *)(v8 + 16))
    {
      if (*(unsigned char *)(v8 + 73))
      {
        int v10 = *(_DWORD *)(v8 + 8);
        if (v10 == 32784)
        {
          CFStringRef v11 = @"ap.ticket.insec.rsa4k.key.private";
        }
        else
        {
          if (v10 != 35168)
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalRegisterKeys", (uint64_t)"unrecognized chipid: 0x%08X", a4, a5, a6, a7, a8, v10);
            return 1;
          }
          CFStringRef v11 = @"ap.ticket.insec.rsa1k.key.private";
        }
      }
      else
      {
        CFStringRef v11 = @"ap.ticket.dev.key.private";
        if (*(unsigned char *)(a1 + 505)) {
          CFStringRef v11 = @"ap.ticket.localpolicy.hacktivation.key.private";
        }
      }
    }
    else
    {
      CFStringRef v11 = @"ap.ticket.unfused.key.private";
    }
    *(void *)(a1 + 392) = v11;
  }
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 376), @"ap.ticket.dev.key.private")) {
    return 0;
  }
  int v28 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  int v27 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  int v12 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v13 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v14 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v15 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  int v16 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v17 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  int v18 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v19 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v20 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  uint64_t result = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  if ((!v28 || !v27 || !v15 || !v17 || !result) && (!v12 || !v13 || !v14 || !v16 || !v18 || !v19 || !v20))
  {
    AMAuthInstallLog(6, (uint64_t)"AMAuthInstallApImg4LocalRegisterKeys", (uint64_t)"ap local signing keys available", v21, v22, v23, v24, v25, v26);
    return 0;
  }
  return result;
}

uint64_t AMAuthInstallApImg4LocalCreateEncodedCertificateChain(uint64_t a1, CFTypeRef *a2)
{
  if (!a1 || !a2)
  {
    CFArrayRef Mutable = 0;
    uint64_t v12 = 1;
    if (!a2) {
      goto LABEL_18;
    }
    goto LABEL_6;
  }
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  CFArrayRef Mutable = CFDataCreateMutable(v4, 0);
  if (!Mutable)
  {
    uint64_t v12 = 2;
    goto LABEL_6;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  if (!*(unsigned char *)(v11 + 20))
  {
    if (!*(void *)(a1 + 400))
    {
      if (*(unsigned char *)(a1 + 505))
      {
        CFStringRef v13 = @"ap.ticket.localpolicy.hacktivation.leaf.cert";
      }
      else if (*(unsigned char *)(v11 + 72) || *(_DWORD *)(v11 + 16))
      {
        if (*(unsigned char *)(v11 + 73))
        {
          int v24 = *(_DWORD *)(v11 + 8);
          switch(v24)
          {
            case 32770:
              CFStringRef v13 = @"ap.ticket.8002.insec.cert";
              break;
            case 35168:
              if (!*(void *)(a1 + 408)) {
                *(void *)(a1 + 408) = @"ap.ticket.ca.cert";
              }
              uint64_t CertData = AMAuthInstallCryptoGetCertData();
              if (CertData) {
                goto LABEL_45;
              }
              BytePtr = CFDataGetBytePtr(0);
              CFIndex Length = CFDataGetLength(0);
              CFDataAppendBytes(Mutable, BytePtr, Length);
              CFStringRef v13 = @"ap.ticket.8960.insec.cert";
              break;
            case 32784:
              CFStringRef v13 = @"ap.ticket.8010.insec.cert";
              break;
            default:
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain", (uint64_t)"unrecognized chipid: 0x%08X", v5, v6, v7, v8, v9, v24);
              goto LABEL_38;
          }
        }
        else
        {
          CFStringRef v13 = @"ap.ticket.8960.dev.cert";
        }
      }
      else
      {
        CFStringRef v13 = @"ap.ticket.8960.unfused.cert";
      }
      *(void *)(a1 + 400) = v13;
    }
    if (!*(unsigned char *)(a1 + 505))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      if (!*(unsigned char *)(v14 + 77))
      {
        int v25 = *(_DWORD *)(v14 + 8);
        if (v25 != 32770 && v25 != 35168 && v25 != 32784)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain", (uint64_t)"chipid: 0x%08X unsupported for img4 local signing", v5, v6, v7, v8, v9, v25);
LABEL_38:
          uint64_t v12 = 1;
          goto LABEL_6;
        }
      }
    }
    uint64_t CertData = AMAuthInstallCryptoGetCertData();
    if (!CertData)
    {
      int v16 = CFDataGetBytePtr(0);
      CFIndex v17 = CFDataGetLength(0);
      CFDataAppendBytes(Mutable, v16, v17);
      if (DEREncoderCreate())
      {
        CFDataGetBytePtr(Mutable);
        CFDataGetLength(Mutable);
        if (DEREncoderAddData())
        {
          uint64_t v12 = 3;
          goto LABEL_6;
        }
        if (!DEREncoderCreateEncodedBuffer())
        {
          uint64_t v12 = 0;
          *a2 = CFDataCreate(0, 0, 0);
          goto LABEL_18;
        }
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain", (uint64_t)"%s: failed to create buffer", v18, v19, v20, v21, v22, (char)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain");
      }
      uint64_t v12 = 0;
      goto LABEL_18;
    }
LABEL_45:
    uint64_t v12 = CertData;
    goto LABEL_6;
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain", (uint64_t)"local signing is not available for production fused devices.", v5, v6, v7, v8, v9, v28);
  uint64_t v12 = 14;
LABEL_6:
  SafeRelease(*a2);
LABEL_18:
  SafeRelease(Mutable);
  SafeFree(0);
  DEREncoderDestroy();
  return v12;
}

uint64_t AMAuthInstallApImg4LocalCreateSignedManifest(void *a1, const void *a2, const void *a3, const void *a4, const void *a5, CFTypeRef *a6, uint64_t a7, uint64_t a8)
{
  return _AMAuthInstallApImg4LocalCreateSignedManifest(a1, a2, a3, a4, a5, a6, 0, a8);
}

uint64_t AMAuthInstallApImg4LocalAddImageProperties(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFDictionary *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    uint64_t v104 = "toEncoder cannot be NULL";
LABEL_28:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)v104, (uint64_t)a4, a5, a6, a7, a8, v105);
    uint64_t v25 = 1;
    goto LABEL_24;
  }
  if (!a3)
  {
    uint64_t v104 = "imageTag cannot be NULL";
    goto LABEL_28;
  }
  if (!a4)
  {
    uint64_t v104 = "requestDict cannot be NULL";
    goto LABEL_28;
  }
  uint64_t v11 = DEREncoderCreate();
  if (!v11)
  {
    uint64_t v25 = 2;
    goto LABEL_24;
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a4, @"Digest");
  if (Value)
  {
    CFDataRef v13 = Value;
    if (CFDataGetLength(Value) < 1)
    {
      AMAuthInstallLog(6, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"'%@' has zero length digest - skipping digest", v14, v15, v16, v17, v18, (char)a3);
    }
    else
    {
      uint64_t v19 = AMAuthInstallApImg4AddDataProperty(v11, @"DGST", v13, v14, v15, v16, v17, v18);
      if (v19)
      {
        uint64_t v25 = v19;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add Digest property for '%@'", v20, v21, v22, v23, v24, (char)a3);
        goto LABEL_24;
      }
    }
  }
  CFBooleanRef v26 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"Trusted");
  if (v26
    && (uint64_t v27 = CFBooleanGetValue(v26),
        uint64_t v33 = AMAuthInstallApImg4AddBooleanProperty(v11, @"EKEY", v27, v28, v29, v30, v31, v32),
        v33))
  {
    uint64_t v25 = v33;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add EKEY property for '%@'", v34, v35, v36, v37, v38, (char)a3);
  }
  else
  {
    CFBooleanRef v39 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"DPRO");
    if (v39
      && (uint64_t v40 = CFBooleanGetValue(v39),
          uint64_t v46 = AMAuthInstallApImg4AddBooleanProperty(v11, @"DPRO", v40, v41, v42, v43, v44, v45),
          v46))
    {
      uint64_t v25 = v46;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add DPRO property for '%@'", v47, v48, v49, v50, v51, (char)a3);
    }
    else
    {
      CFBooleanRef v52 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"DSEC");
      if (v52
        && (uint64_t v53 = CFBooleanGetValue(v52),
            uint64_t v59 = AMAuthInstallApImg4AddBooleanProperty(v11, @"DSEC", v53, v54, v55, v56, v57, v58),
            v59))
      {
        uint64_t v25 = v59;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add DSEC property for '%@'", v60, v61, v62, v63, v64, (char)a3);
      }
      else
      {
        CFBooleanRef v65 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"ESEC");
        if (v65
          && (uint64_t v66 = CFBooleanGetValue(v65),
              uint64_t v72 = AMAuthInstallApImg4AddBooleanProperty(v11, @"ESEC", v66, v67, v68, v69, v70, v71),
              v72))
        {
          uint64_t v25 = v72;
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add ESEC property for '%@'", v73, v74, v75, v76, v77, (char)a3);
        }
        else
        {
          CFBooleanRef v78 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"EPRO");
          if (v78
            && (uint64_t v79 = CFBooleanGetValue(v78),
                uint64_t v85 = AMAuthInstallApImg4AddBooleanProperty(v11, @"EPRO", v79, v80, v81, v82, v83, v84),
                v85))
          {
            uint64_t v25 = v85;
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add EPRO property for '%@'", v86, v87, v88, v89, v90, (char)a3);
          }
          else
          {
            CFDataRef v91 = (const __CFData *)CFDictionaryGetValue(a4, @"TBMDigests");
            if (v91
              && (uint64_t v97 = AMAuthInstallApImg4AddDataProperty(v11, @"tbms", v91, v92, v93, v94, v95, v96), v97))
            {
              uint64_t v25 = v97;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add %@ property for '%@'", v92, v93, v94, v95, v96, (char)@"tbms");
            }
            else
            {
              uint64_t v25 = AMAuthInstallApImg4AddDictionaryProperty(v11, a2, a3, v92, v93, v94, v95, v96);
              if (v25) {
                AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"AMAuthInstallApImg4LocalAddDictionaryProperty failed for '%@'", v98, v99, v100, v101, v102, (char)a3);
              }
            }
          }
        }
      }
    }
  }
LABEL_24:
  DEREncoderDestroy();
  return v25;
}

uint64_t AMAuthInstallBasebandServerRequestAddRequiredTags(uint64_t a1, __CFDictionary *a2, const void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef theDict = a2;
  if (!a1)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"%s: amai is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallBasebandServerRequestAddRequiredTags");
LABEL_40:
    int v10 = 0;
    goto LABEL_41;
  }
  uint64_t v9 = *(void *)(a1 + 48);
  if (!v9)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"%s: amai->bbParameters is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallBasebandServerRequestAddRequiredTags");
    goto LABEL_40;
  }
  if (!*(void *)(v9 + 16))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"%s: amai->bbParameters->snum is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallBasebandServerRequestAddRequiredTags");
    goto LABEL_40;
  }
  int v10 = a2;
  if (!a2)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"%s: requestDict is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallBasebandServerRequestAddRequiredTags");
LABEL_41:
    a3 = 0;
LABEL_42:
    uint64_t v40 = 1;
    goto LABEL_31;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v10))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"%s: requestDict mistyped", v13, v14, v15, v16, v17, (char)"AMAuthInstallBasebandServerRequestAddRequiredTags");
    goto LABEL_40;
  }
  if (!a3)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"%s: bbfwURL is NULL", v13, v14, v15, v16, v17, (char)"AMAuthInstallBasebandServerRequestAddRequiredTags");
    int v10 = 0;
    goto LABEL_42;
  }
  CFIndex v18 = AMAuthInstallBasebandApplyTssOverrides((const void *)a1, (__CFDictionary *)v10, a3, v13, v14, v15, v16, v17);
  if (v18)
  {
    uint64_t v40 = v18;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"%s: failed to apply tss overrides", v19, v20, v21, v22, v23, (char)"AMAuthInstallBasebandServerRequestAddRequiredTags");
LABEL_46:
    int v10 = 0;
    a3 = 0;
    goto LABEL_31;
  }
  CFDictionarySetValue((CFMutableDictionaryRef)v10, @"BbSNUM", *(const void **)(*(void *)(a1 + 48) + 16));
  _CFDictionarySetInteger32((__CFDictionary *)v10, @"BbChipID", *(_DWORD *)(*(void *)(a1 + 48) + 4));
  _CFDictionarySetInteger32((__CFDictionary *)v10, @"BbGoldCertId", *(_DWORD *)(*(void *)(a1 + 48) + 8));
  uint64_t v24 = *(const void **)(*(void *)(a1 + 48) + 24);
  if (v24)
  {
    CFDictionarySetValue((CFMutableDictionaryRef)v10, @"BbNonce", v24);
    CFDictionarySetValue((CFMutableDictionaryRef)v10, @"@BBTicket", kCFBooleanTrue);
  }
  uint64_t v25 = *(const void **)(a1 + 136);
  if (v25) {
    CFDictionarySetValue((CFMutableDictionaryRef)v10, @"BbVendorData", v25);
  }
  CFBooleanRef v26 = *(const void **)(a1 + 144);
  if (v26) {
    CFDictionarySetValue((CFMutableDictionaryRef)v10, @"BbAntennaType", v26);
  }
  uint64_t v27 = *(const void **)(a1 + 152);
  if (v27) {
    CFDictionarySetValue((CFMutableDictionaryRef)v10, @"BbBehavior", v27);
  }
  CFDictionaryRef v28 = *(const __CFDictionary **)(a1 + 424);
  if (v28)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v28, @"BbRequestEntries");
    if (Value)
    {
      CFDictionaryRef v30 = Value;
      int v31 = CFGetAllocator((CFTypeRef)a1);
      CFIndex v32 = AMAuthInstallSupportApplyDictionaryOverrides(v31, v30, &theDict, 0);
      if (v32)
      {
        uint64_t v40 = v32;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"failed to set Bb entitlements", v33, v34, v35, v36, v37, v55);
        goto LABEL_46;
      }
    }
  }
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 200));
  int v10 = malloc(8 * Count);
  CFBooleanRef v39 = (const void **)malloc(8 * Count);
  a3 = v39;
  uint64_t v40 = 2;
  if (v10 && v39)
  {
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 200), (const void **)v10, v39);
    if (Count < 1)
    {
LABEL_27:
      BOOL v56 = 0;
      if (!AMAuthInstallVinylIsLegacyChipId((CFTypeRef)a1, &v56)
        && v56
        && (uint64_t TagForKeyHashName = AMAuthInstallBasebandVinylAddMeasurementTags(a1, theDict), TagForKeyHashName))
      {
LABEL_32:
        uint64_t v40 = TagForKeyHashName;
      }
      else
      {
        uint64_t v40 = 0;
      }
    }
    else
    {
      uint64_t v46 = 0;
      while (1)
      {
        key = 0;
        CFStringRef v47 = (const __CFString *)*((void *)v10 + v46);
        if (!v47)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"invalid HashKeysBuffer array", v41, v42, v43, v44, v45, v55);
          uint64_t v40 = 99;
          goto LABEL_31;
        }
        uint64_t TagForKeyHashName = AMAuthInstallBasebandGetTagForKeyHashName(a1, v47, (__CFString **)&key, v41, v42, v43, v44, v45);
        if (TagForKeyHashName) {
          goto LABEL_32;
        }
        if (!key) {
          break;
        }
        CFDictionarySetValue(theDict, key, a3[v46++]);
        if (Count == v46) {
          goto LABEL_27;
        }
      }
      uint64_t v40 = 3;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandServerRequestAddRequiredTags", (uint64_t)"keyHashTag not found for %@", v49, v50, v51, v52, v53, *((void *)v10 + v46));
    }
  }
LABEL_31:
  SafeFree(v10);
  SafeFree(a3);
  return v40;
}

CFIndex AMAuthInstallBasebandApplyTssOverrides(const void *a1, __CFDictionary *a2, CFTypeRef cf, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDataRef data = 0;
  CFMutableDictionaryRef v46 = a2;
  CFErrorRef error = 0;
  if (!a1)
  {
    uint64_t v41 = "NULL amai passed to AMAuthInstallBasebandApplyTssOverrides";
LABEL_15:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandApplyTssOverrides", (uint64_t)v41, a4, a5, a6, a7, a8, v43);
    uint64_t v15 = 0;
    CFDictionaryRef v17 = 0;
    CFIndex v16 = 1;
    goto LABEL_11;
  }
  if (!a2)
  {
    uint64_t v41 = "NULL requestDict passed to AMAuthInstallBasebandApplyTssOverrides";
    goto LABEL_15;
  }
  if (!cf)
  {
    uint64_t v41 = "NULL bbfw passed to AMAuthInstallBasebandApplyTssOverrides";
    goto LABEL_15;
  }
  uint64_t v9 = BbfwReaderOpen(cf);
  uint64_t v15 = (uint64_t)v9;
  if (!v9)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandApplyTssOverrides", (uint64_t)"failed to open bbfw archive for reading", v10, v11, v12, v13, v14, v43);
    CFDictionaryRef v17 = 0;
    CFIndex v16 = 4;
    goto LABEL_11;
  }
  if (!BbfwReaderFindAndCopyFileData((uint64_t)v9, @"Options.plist", (CFTypeRef *)&data))
  {
    CFAllocatorRef v18 = CFGetAllocator(a1);
    CFDictionaryRef v19 = (const __CFDictionary *)CFPropertyListCreateWithData(v18, data, 0, 0, &error);
    CFDictionaryRef v17 = v19;
    if (v19)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v19, @"TssOverrides");
      if (Value)
      {
        CFDictionaryRef v31 = Value;
        int v32 = CFGetAllocator(a1);
        CFIndex v33 = AMAuthInstallSupportApplyDictionaryOverrides(v32, v31, &v46, @"Bb");
        if (v33)
        {
          CFIndex v16 = v33;
          uint64_t v42 = "failed to set Bb entitlements";
        }
        else
        {
          int v39 = CFGetAllocator(a1);
          CFIndex v16 = AMAuthInstallSupportApplyDictionaryOverrides(v39, v31, &v46, @"FDR");
          if (!v16) {
            goto LABEL_11;
          }
          uint64_t v42 = "failed to set FDR entitlements";
        }
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandApplyTssOverrides", (uint64_t)v42, v34, v35, v36, v37, v38, v43);
        goto LABEL_11;
      }
      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallBasebandApplyTssOverrides", (uint64_t)"TssOverrides not found in Options.plist", v26, v27, v28, v29, v30, v43);
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandApplyTssOverrides", (uint64_t)"failed to create CFDictionary from Options.plist %@", v20, v21, v22, v23, v24, (char)error);
    }
    CFIndex v16 = 0;
    goto LABEL_11;
  }
  CFIndex v16 = 0;
  CFDictionaryRef v17 = 0;
LABEL_11:
  SafeRelease(v17);
  SafeRelease(data);
  SafeRelease(error);
  BbfwReaderClose(v15);
  return v16;
}

CFComparisonResult AMAuthInstallBasebandGetTagForKeyHashName(uint64_t a1, CFStringRef theString2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v14 = "amai is NULL";
LABEL_22:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandGetTagForKeyHashName", (uint64_t)v14, a4, a5, a6, a7, a8, v15);
    return 1;
  }
  if (!theString2)
  {
    uint64_t v14 = "keyHashName is NULL";
    goto LABEL_22;
  }
  if (!a3)
  {
    uint64_t v14 = "outKeyTag is NULL";
    goto LABEL_22;
  }
  if (CFStringCompare(@"BbProvisioningManifestKeyHash", theString2, 0))
  {
    CFComparisonResult result = CFStringCompare(@"BbActivationManifestKeyHash", theString2, 0);
    if (result)
    {
      CFComparisonResult result = CFStringCompare(@"BbCalibrationManifestKeyHash", theString2, 0);
      if (result)
      {
        CFComparisonResult result = CFStringCompare(@"BbFactoryActivationManifestKeyHash", theString2, 0);
        if (result)
        {
          CFComparisonResult result = CFStringCompare(@"BbFDRSecurityKeyHash", theString2, 0);
          if (result) {
            return 8;
          }
          uint64_t v13 = &kAMAuthInstallTagBbFDRSecurityKeyHash;
        }
        else
        {
          uint64_t v13 = &kAMAuthInstallTagBbFactoryActivationKeyHash;
        }
      }
      else
      {
        uint64_t v13 = &kAMAuthInstallTagBbCalibrationKeyHash;
      }
    }
    else
    {
      uint64_t v13 = &kAMAuthInstallTagBbActivationKeyHash;
    }
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 48);
    if (v12 && *(_DWORD *)(v12 + 4) != 80)
    {
      CFComparisonResult result = kCFCompareEqualTo;
      uint64_t v13 = &kAMAuthInstallTagBbProvisioningKeyHash;
    }
    else
    {
      CFComparisonResult result = kCFCompareEqualTo;
      uint64_t v13 = &kAMAuthInstallTagBbSKeyId;
    }
  }
  *a3 = *v13;
  return result;
}

uint64_t AMAuthInstallBasebandCreateServerRequestDictionary(void *a1, const void *a2, const __CFDictionary *a3, CFTypeRef *a4, const void **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCreateServerRequestDictionary", (uint64_t)"%s: measurementDict is NULL", (uint64_t)a4, (uint64_t)a5, a6, a7, a8, (char)"AMAuthInstallBasebandCreateServerRequestDictionary");
LABEL_16:
    char v15 = 0;
    uint64_t v27 = 1;
    goto LABEL_12;
  }
  if (!a4)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCreateServerRequestDictionary", (uint64_t)"%s: outRequestDict is NULL", 0, (uint64_t)a5, a6, a7, a8, (char)"AMAuthInstallBasebandCreateServerRequestDictionary");
    goto LABEL_16;
  }
  if (!a5)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCreateServerRequestDictionary", (uint64_t)"%s: bbfwURL is NULL", (uint64_t)a4, 0, a6, a7, a8, (char)"AMAuthInstallBasebandCreateServerRequestDictionary");
    goto LABEL_16;
  }
  CFAllocatorRef v13 = CFGetAllocator(a1);
  if (a3) {
    CFDataRef MutableCopy = CFDictionaryCreateMutableCopy(v13, 0, a3);
  }
  else {
    CFDataRef MutableCopy = CFDictionaryCreateMutable(v13, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  char v15 = MutableCopy;
  if (MutableCopy)
  {
    CFDictionarySetValue(MutableCopy, @"BasebandFirmware", a2);
    uint64_t v21 = AMAuthInstallBasebandServerRequestAddRequiredTags((uint64_t)a1, v15, a5, v16, v17, v18, v19, v20);
    if (v21)
    {
      uint64_t v27 = v21;
    }
    else
    {
      if (a1[2]) {
        AMAuthInstallApServerRequestAddRequiredTags(a1, v15, 0, v22, v23, v24, v25, v26);
      }
      uint64_t v27 = 0;
      *a4 = CFRetain(v15);
    }
  }
  else
  {
    uint64_t v27 = 2;
  }
LABEL_12:
  SafeRelease(v15);
  return v27;
}

uint64_t AMAuthInstallBasebandCopyAllPersonalizedComponents(void *a1, void *a2, const void *a3, __CFDictionary *a4, const __CFDictionary *a5, const __CFDictionary *a6, CFTypeRef *a7)
{
  uint64_t v10 = a4;
  CFDictionaryRef v99 = 0;
  CFDictionaryRef theDict = a5;
  CFTypeRef v98 = 0;
  SafeRetain(a4);
  SafeRetain(a5);
  if (!a1 || !a1[6])
  {
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_157;
  }
  CFAllocatorRef v14 = CFGetAllocator(a1);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v14, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    uint64_t v56 = 2;
    goto LABEL_136;
  }
  int v23 = *(_DWORD *)(a1[6] + 4);
  if (v23 > 1700064)
  {
    if (v23 > 5898464)
    {
      if (v23 <= 8343776)
      {
        if (v23 == 5898465)
        {
          uint64_t v24 = AMAuthInstallBasebandN94FuseIfNecessary(a1, a2, Mutable);
          if (v24) {
            goto LABEL_158;
          }
        }
        else if (v23 == 7278817 || v23 == 7282913)
        {
          uint64_t v24 = AMAuthInstallBasebandN41FuseIfNecessary(a1, a2, Mutable);
          if (v24) {
            goto LABEL_158;
          }
        }
        goto LABEL_41;
      }
      if (v23 == 8343777 || v23 == 9572577) {
        goto LABEL_40;
      }
      int v30 = 9781473;
      goto LABEL_39;
    }
    if (v23 > 2814176)
    {
      if (v23 != 2814177)
      {
        if (v23 == 4587745)
        {
          uint64_t v24 = AMAuthInstallBasebandJ2FuseIfNecessary(a1, a2, Mutable);
          if (v24) {
            goto LABEL_158;
          }
        }
        else if (v23 == 5243105)
        {
          uint64_t v24 = AMAuthInstallBasebandN92FuseIfNecessary(a1, a2, Mutable);
          if (v24) {
            goto LABEL_158;
          }
        }
        goto LABEL_41;
      }
      goto LABEL_35;
    }
    if (v23 != 1700065)
    {
      int v29 = 2089185;
LABEL_34:
      if (v23 != v29) {
        goto LABEL_41;
      }
      goto LABEL_35;
    }
    goto LABEL_35;
  }
  if (v23 <= 241888)
  {
    unsigned int v25 = v23 - 94;
    BOOL v26 = v25 > 0xA;
    int v27 = (1 << v25) & 0x685;
    if (!v26 && v27 != 0)
    {
      uint64_t v24 = AMAuthInstallBasebandRembrandtFuseIfNecessary();
      if (v24) {
        goto LABEL_158;
      }
    }
    goto LABEL_41;
  }
  if (v23 > 938208)
  {
    if (v23 != 938209 && v23 != 1327329)
    {
      int v29 = 1515745;
      goto LABEL_34;
    }
LABEL_35:
    uint64_t v24 = AMAuthInstallBasebandMAV20FuseIfNecessary(a1, a2, Mutable);
    if (v24) {
      goto LABEL_158;
    }
    goto LABEL_41;
  }
  if (v23 != 241889)
  {
    int v30 = 520417;
LABEL_39:
    if (v23 != v30) {
      goto LABEL_41;
    }
  }
LABEL_40:
  uint64_t v24 = AMAuthInstallBasebandMAV10FuseIfNecessary(a1, a2, Mutable);
  if (v24) {
    goto LABEL_158;
  }
LABEL_41:
  uint64_t v31 = a1[6];
  if (!*(void *)(v31 + 16))
  {
LABEL_135:
    uint64_t v56 = 0;
    *a7 = CFRetain(Mutable);
    goto LABEL_136;
  }
  if (v10)
  {
LABEL_43:
    if (*(_DWORD *)(v31 + 4) == 104)
    {
      int IsICE19BBGoldCertIDECDSA = AMAuthInstallIsICE19BBGoldCertIDECDSA(*(_DWORD *)(v31 + 8), v15, v16, v17, v18, v19, v20, v21);
      CFIndex v33 = &kAMAuthInstallTagBbPsiPartialDigest;
      if (IsICE19BBGoldCertIDECDSA)
      {
        CFIndex v33 = &kAMAuthInstallTagBbPsi2PartialDigest;
        uint64_t v34 = &kAMAuthInstallTagBbRestorePsi2PartialDigest;
      }
      else
      {
        uint64_t v34 = &kAMAuthInstallTagBbRestorePsiPartialDigest;
      }
      CFDictionaryRemoveValue(v10, *v33);
      CFDictionaryRemoveValue(v10, *v34);
    }
LABEL_48:
    CFDictionaryRef v35 = theDict;
    if (theDict)
    {
LABEL_49:
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v35, @"BBTicket");
      if (Value)
      {
        CFDataRef v42 = Value;
        BytePtr = CFDataGetBytePtr(Value);
        CFIndex Length = CFDataGetLength(v42);
        AMAuthInstallLogDumpMemory(8, (uint64_t)"AMAuthInstallBasebandCopyAllPersonalizedComponents", (char)"BBTicket:", (uint64_t)BytePtr, Length, v45, v46, v47);
      }
LABEL_51:
      int v48 = *(_DWORD *)(a1[6] + 4);
      if (v48 > 1700064)
      {
        if (v48 <= 5898464)
        {
          if (v48 <= 2814176)
          {
            if (v48 != 1700065)
            {
              int v78 = 2089185;
LABEL_107:
              if (v48 != v78) {
                goto LABEL_137;
              }
LABEL_108:
              uint64_t v49 = AMAuthInstallBasebandMAV22StitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
              goto LABEL_124;
            }
LABEL_109:
            uint64_t v49 = AMAuthInstallBasebandMAV21StitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
            goto LABEL_124;
          }
          if (v48 == 2814177) {
            goto LABEL_108;
          }
          if (v48 != 4587745)
          {
            if (v48 == 5243105)
            {
              uint64_t v49 = AMAuthInstallBasebandN92StitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
              goto LABEL_124;
            }
            goto LABEL_137;
          }
          uint64_t v49 = AMAuthInstallBasebandJ2StitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
LABEL_124:
          uint64_t v56 = v49;
          if (!v49)
          {
            uint64_t v86 = a1[6];
            if (*(void *)(v86 + 24))
            {
              if (*(_DWORD *)(v86 + 4) != 80)
              {
                uint64_t v87 = CFDictionaryGetValue(theDict, @"BBTicket");
                if (v87) {
                  CFDictionaryAddValue(Mutable, @"bbticket.der", v87);
                }
              }
            }
            CFDictionaryRef v88 = (const __CFDictionary *)CFRetain(theDict);
            CFDictionaryRef v99 = v88;
            if (a3 && *(void *)(a1[6] + 160))
            {
              uint64_t v89 = AMAuthInstallVinylPersonalizeFirmware(a1, a3, 0, &v99, a6, v52, v53, v54);
              if (v89)
              {
                uint64_t v56 = v89;
                uint64_t v94 = "failed to personalize vinyl fw";
                goto LABEL_139;
              }
              CFDictionaryRef v88 = v99;
            }
            uint64_t v90 = AMAuthInstallBasebandVinylStitchFirmware(a1, a2, a3, v88, Mutable, v52, v53, v54);
            if (v90)
            {
              uint64_t v56 = v90;
              uint64_t v94 = "failed to stitch vinyl fw";
            }
            else
            {
              uint64_t v92 = AMAuthInstallProvisioningProvisionIfNecessary((uint64_t)a1, Mutable, v91, v50, v51, v52, v53, v54);
              if (!v92) {
                goto LABEL_135;
              }
              uint64_t v56 = v92;
              uint64_t v94 = "AMAuthInstallProvisioningProvisionIfNecessary failed";
            }
LABEL_139:
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCopyAllPersonalizedComponents", (uint64_t)v94, v50, v51, v52, v53, v54, v95);
            goto LABEL_136;
          }
LABEL_138:
          uint64_t v94 = "failed to stitch bbfw";
          goto LABEL_139;
        }
        if (v48 <= 8343776)
        {
          if (v48 != 5898465)
          {
            if (v48 == 7278817 || v48 == 7282913)
            {
              uint64_t v49 = AMAuthInstallBasebandN41StitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
              goto LABEL_124;
            }
            goto LABEL_137;
          }
          uint64_t v49 = AMAuthInstallBasebandN94StitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
          goto LABEL_124;
        }
        if (v48 != 8343777 && v48 != 9572577)
        {
          int v84 = 9781473;
          goto LABEL_103;
        }
      }
      else
      {
        if (v48 <= 241888)
        {
          if ((v48 - 80) <= 0x18)
          {
            if (((1 << (v48 - 80)) & 0x1A14000) != 0)
            {
              uint64_t v49 = AMAuthInstallBasebandRembrandtStitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
              goto LABEL_124;
            }
            if (v48 == 80)
            {
              uint64_t v49 = AMAuthInstallBasebandICE3StitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
              goto LABEL_124;
            }
          }
LABEL_137:
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCopyAllPersonalizedComponents", (uint64_t)"chipID: 0x%x is not supported", v37, v38, v39, v40, v41, *(_DWORD *)(a1[6] + 4));
          uint64_t v56 = 13;
          goto LABEL_138;
        }
        if (v48 > 938208)
        {
          if (v48 != 938209)
          {
            if (v48 != 1327329)
            {
              int v78 = 1515745;
              goto LABEL_107;
            }
            goto LABEL_109;
          }
          uint64_t v49 = AMAuthInstallBasebandMAV20StitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
          goto LABEL_124;
        }
        if (v48 != 241889)
        {
          int v84 = 520417;
LABEL_103:
          if (v48 != v84) {
            goto LABEL_137;
          }
        }
      }
      uint64_t v49 = AMAuthInstallBasebandMAV10StitchFirmware((uint64_t)a1, a2, (uint64_t)theDict, Mutable);
      goto LABEL_124;
    }
    LOBYTE(v97) = 0;
    if (!AMAuthInstallBasebandLocalSigningEnabled((uint64_t)a1, &v97, v16, v17, v18, v19, v20, v21))
    {
      uint64_t v24 = AMAuthInstallBasebandCreateServerRequestDictionary(a1, v10, a6, &v98, (const void **)a2, v57, v58, v59);
      if (v24) {
        goto LABEL_158;
      }
      if ((_BYTE)v97)
      {
        AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandCopyAllPersonalizedComponents", (uint64_t)"this certid specifies local signing", v61, v62, v63, v64, v65, v95);
        int v71 = *(_DWORD *)(a1[6] + 4);
        if (v71 <= 1700064)
        {
          if (v71 <= 241888)
          {
            if ((v71 - 94) <= 0xA && ((1 << (v71 - 94)) & 0x685) != 0)
            {
              uint64_t v72 = AMAuthInstallBasebandRembrandtHandleLocalSigningRequest(a1, v98, &theDict);
              goto LABEL_149;
            }
            goto LABEL_155;
          }
          if (v71 <= 938208)
          {
            if (v71 == 241889) {
              goto LABEL_148;
            }
            int v85 = 520417;
          }
          else
          {
            if (v71 == 938209 || v71 == 1327329) {
              goto LABEL_148;
            }
            int v85 = 1515745;
          }
        }
        else
        {
          if (v71 > 5898464)
          {
            if (v71 <= 8343776)
            {
              if (v71 != 5898465)
              {
                if (v71 == 7278817 || v71 == 7282913)
                {
                  uint64_t v72 = AMAuthInstallBasebandN41HandleLocalSigningRequest(a1, v98, &theDict);
                  goto LABEL_149;
                }
                goto LABEL_155;
              }
              uint64_t v72 = AMAuthInstallBasebandN94HandleLocalSigningRequest(a1, v98, &theDict);
LABEL_149:
              uint64_t v56 = v72;
              if (v72) {
                goto LABEL_136;
              }
              uint64_t v24 = AMAuthInstallBasebandVinylLocalHandleRequest((uint64_t)a1, (uint64_t)v98, (uint64_t)&theDict, v73, v74, v75, v76, v77);
              if (!v24)
              {
                CFDictionaryRef v35 = theDict;
                if (!theDict) {
                  goto LABEL_51;
                }
                goto LABEL_49;
              }
LABEL_158:
              uint64_t v56 = v24;
              goto LABEL_136;
            }
            if (v71 != 8343777 && v71 != 9572577)
            {
              int v85 = 9781473;
              goto LABEL_147;
            }
LABEL_148:
            uint64_t v72 = AMAuthInstallBasebandMAV10HandleLocalSigningRequest(a1, v98, &theDict);
            goto LABEL_149;
          }
          if (v71 > 2814176)
          {
            if (v71 != 2814177)
            {
              if (v71 == 4587745)
              {
                uint64_t v72 = AMAuthInstallBasebandJ2HandleLocalSigningRequest(a1, v98, &theDict);
                goto LABEL_149;
              }
              if (v71 == 5243105)
              {
                uint64_t v72 = AMAuthInstallBasebandN92HandleLocalSigningRequest(a1, v98, &theDict);
                goto LABEL_149;
              }
              goto LABEL_155;
            }
            goto LABEL_148;
          }
          if (v71 == 1700065) {
            goto LABEL_148;
          }
          int v85 = 2089185;
        }
LABEL_147:
        if (v71 == v85) {
          goto LABEL_148;
        }
LABEL_155:
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCopyAllPersonalizedComponents", (uint64_t)"chipID: 0x%x is not supported", v66, v67, v68, v69, v70, *(_DWORD *)(a1[6] + 4));
LABEL_89:
        uint64_t v56 = 14;
        goto LABEL_136;
      }
      char v96 = 0;
      if (!AMAuthInstallBasebandSupportsServerSigning((uint64_t)a1, &v96, v60, v61, v62, v63, v64, v65))
      {
        if (v96 != 1)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCopyAllPersonalizedComponents", (uint64_t)"This chipid/certid does not support local or server personalization.", v79, v80, v81, v82, v83, v95);
          uint64_t v56 = 13;
          goto LABEL_136;
        }
        uint64_t v24 = AMAuthInstallRequestSendSync((uint64_t)a1, v98, (CFTypeRef *)&theDict);
        if (v24) {
          goto LABEL_158;
        }
        CFDictionaryRef v35 = theDict;
        if (theDict) {
          goto LABEL_49;
        }
        goto LABEL_89;
      }
    }
LABEL_157:
    uint64_t v56 = 1;
    goto LABEL_136;
  }
  uint64_t v97 = 0;
  uint64_t Measurements = AMAuthInstallBasebandCreateMeasurements(a1, a2, a3, (CFTypeRef *)&v97);
  if (!Measurements)
  {
    uint64_t v10 = v97;
    uint64_t v31 = a1[6];
    if (!v31) {
      goto LABEL_48;
    }
    goto LABEL_43;
  }
  uint64_t v56 = Measurements;
  uint64_t v10 = 0;
LABEL_136:
  SafeRelease(v10);
  SafeRelease(v99);
  SafeRelease(theDict);
  SafeRelease(v98);
  SafeRelease(Mutable);
  SafeRelease(0);
  return v56;
}

uint64_t AMAuthInstallBasebandCreateMeasurements(void *a1, const void *a2, const void *a3, CFTypeRef *a4)
{
  int v45 = 0;
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(v8, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryRef v46 = Mutable;
  uint64_t v15 = a1[6];
  if (v15 && (int v16 = *(_DWORD *)(v15 + 4)) != 0)
  {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallBasebandCreateMeasurements", (uint64_t)"Using set ChipID 0x%08X to measure", v9, v10, v11, v12, v13, *(_DWORD *)(v15 + 4));
  }
  else
  {
    if (AMAuthInstallBasebandReadChipIDFromBbfw(a2, &v45))
    {
      if (AMAuthInstallBasebandICE3FirmwareSupported(a2))
      {
        int v16 = 80;
        AMAuthInstallLog(5, (uint64_t)"AMAuthInstallBasebandCreateMeasurements", (uint64_t)"Using detected ICE3 ChipID 0x%08X to measure", v27, v28, v29, v30, v31, 80);
      }
      else
      {
        int v16 = 5243105;
        AMAuthInstallLog(5, (uint64_t)"AMAuthInstallBasebandCreateMeasurements", (uint64_t)"Using default ChipID 0x%08X to measure", v27, v28, v29, v30, v31, 225);
      }
    }
    else
    {
      int v16 = v45;
      if (!v45)
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCreateMeasurements", (uint64_t)"chipid 0 read from Info.plist!", v22, v23, v24, v25, v26, v43);
        uint64_t v40 = 14;
        goto LABEL_59;
      }
      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallBasebandCreateMeasurements", (uint64_t)"Using ChipID 0x%08X from Info.plist to measure", v22, v23, v24, v25, v26, v45);
    }
    int v32 = calloc(1uLL, 0xB0uLL);
    if (!v32)
    {
      a1[6] = 0;
      uint64_t v40 = 2;
      goto LABEL_59;
    }
    v32[9] = 0u;
    v32[10] = 0u;
    v32[7] = 0u;
    v32[8] = 0u;
    v32[5] = 0u;
    v32[6] = 0u;
    v32[3] = 0u;
    v32[4] = 0u;
    v32[1] = 0u;
    v32[2] = 0u;
    *int v32 = 0u;
    a1[6] = v32;
    *((_DWORD *)v32 + 1) = v16;
  }
  if (v16 <= 1700064)
  {
    if (v16 <= 241888)
    {
      if ((v16 - 80) <= 0x18)
      {
        if (((1 << (v16 - 80)) & 0x1A14000) != 0)
        {
          uint64_t v33 = AMAuthInstallBasebandRembrandtMeasureFirmware((uint64_t)a1, a2, (uint64_t)Mutable);
          goto LABEL_51;
        }
        if (v16 == 80)
        {
          uint64_t v33 = AMAuthInstallBasebandICE3MeasureFirmware((uint64_t)a1, a2, (uint64_t)Mutable);
          goto LABEL_51;
        }
      }
LABEL_64:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCreateMeasurements", (uint64_t)"unrecognized chipid: 0x%08X", v17, v18, v19, v20, v21, v16);
      uint64_t v40 = 13;
      goto LABEL_59;
    }
    if (v16 > 938208)
    {
      BOOL v34 = v16 == 938209 || v16 == 1327329;
      int v35 = 1515745;
LABEL_45:
      if (!v34 && v16 != v35) {
        goto LABEL_64;
      }
LABEL_50:
      uint64_t v33 = AMAuthInstallBasebandMAV20MeasureFirmware((uint64_t)a1, a2, (uint64_t)Mutable);
      goto LABEL_51;
    }
    BOOL v36 = v16 == 241889;
    int v37 = 520417;
LABEL_38:
    if (v36 || v16 == v37)
    {
      uint64_t v33 = AMAuthInstallBasebandMAV10MeasureFirmware((uint64_t)a1, a2, (uint64_t)Mutable);
      goto LABEL_51;
    }
    goto LABEL_64;
  }
  if (v16 <= 5898464)
  {
    if (v16 <= 2814176)
    {
      BOOL v34 = v16 == 1700065;
      int v35 = 2089185;
      goto LABEL_45;
    }
    if (v16 == 2814177) {
      goto LABEL_50;
    }
    if (v16 != 4587745)
    {
      if (v16 == 5243105)
      {
        uint64_t v33 = AMAuthInstallBasebandN92MeasureFirmware((uint64_t)a1, a2, (uint64_t)Mutable);
        goto LABEL_51;
      }
      goto LABEL_64;
    }
    uint64_t v33 = AMAuthInstallBasebandJ2MeasureFirmware((uint64_t)a1, a2, (uint64_t)Mutable);
  }
  else
  {
    if (v16 > 8343776)
    {
      BOOL v36 = v16 == 8343777 || v16 == 9572577;
      int v37 = 9781473;
      goto LABEL_38;
    }
    if (v16 != 5898465)
    {
      if (v16 == 7278817 || v16 == 7282913)
      {
        uint64_t v33 = AMAuthInstallBasebandN41MeasureFirmware((uint64_t)a1, a2, (uint64_t)Mutable);
        goto LABEL_51;
      }
      goto LABEL_64;
    }
    uint64_t v33 = AMAuthInstallBasebandN94MeasureFirmware((uint64_t)a1, a2, (uint64_t)Mutable);
  }
LABEL_51:
  uint64_t v40 = v33;
  if (!v33)
  {
    BOOL v44 = 0;
    if (a3)
    {
      if (!AMAuthInstallVinylIsLegacyChipId(a1, &v44) && v44)
      {
        uint64_t Measurements = AMAuthInstallVinylCreateMeasurements(a1, a3, &v46, 0);
        CFDictionaryRef Mutable = v46;
        if (Measurements) {
          goto LABEL_56;
        }
      }
    }
    else
    {
      uint64_t Measurements = AMAuthInstallBasebandVinylCreateMeasurements((uint64_t)a1, a2, Mutable);
      if (Measurements)
      {
LABEL_56:
        uint64_t v40 = Measurements;
        goto LABEL_59;
      }
    }
    uint64_t v40 = 0;
    *a4 = CFRetain(Mutable);
    CFDictionaryRef Mutable = v46;
  }
LABEL_59:
  SafeRelease(Mutable);
  return v40;
}

uint64_t AMAuthInstallBasebandLocalSigningEnabled(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 1;
  if (a2 && *(void *)(a1 + 48))
  {
    __int16 v26 = 0;
    if (AMAuthInstallBasebandSupportsServerSigning(a1, (unsigned char *)&v26 + 1, a3, a4, a5, a6, a7, a8))
    {
      uint64_t v24 = "failed to query is server signing is supported.";
    }
    else
    {
      BooleanCFDataRef Value = AMAuthInstallPreferencesGetBooleanValue(@"AuthInstallEnableLocalSigning", 0, 0);
      if (HIBYTE(v26) && BooleanValue != 1)
      {
        char v23 = 0;
LABEL_10:
        uint64_t result = 0;
        *a2 = v23;
        return result;
      }
      if (!AMAuthInstallBasebandSupportsLocalSigning(a1, &v26, v17, v18, v19, v20, v21, v22))
      {
        char v23 = v26;
        goto LABEL_10;
      }
      uint64_t v24 = "failed to query is local signing is supported.";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandLocalSigningEnabled", (uint64_t)v24, v11, v12, v13, v14, v15, v25);
    return 1;
  }
  return result;
}

uint64_t AMAuthInstallBasebandSupportsServerSigning(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1;
  if (a1 && a2)
  {
    uint64_t v10 = *(void *)(a1 + 48);
    if (!v10)
    {
LABEL_50:
      char v12 = 0;
      goto LABEL_51;
    }
    int v11 = *(_DWORD *)(v10 + 4);
    if (v11 > 1700064)
    {
      if (v11 <= 5898464)
      {
        if (v11 > 2814176)
        {
          if (v11 != 2814177)
          {
            if (v11 == 4587745)
            {
              char v12 = AMAuthInstallBasebandJ2SupportsServerSigning();
              goto LABEL_51;
            }
            if (v11 == 5243105)
            {
              char v12 = AMAuthInstallBasebandN92SupportsServerSigning();
              goto LABEL_51;
            }
            goto LABEL_49;
          }
          goto LABEL_43;
        }
        BOOL v14 = v11 == 1700065;
        int v15 = 2089185;
LABEL_38:
        if (!v14 && v11 != v15)
        {
LABEL_49:
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandSupportsServerSigning", (uint64_t)"chipID: 0x%x is not supported for server signing", a4, a5, a6, a7, a8, v11);
          goto LABEL_50;
        }
LABEL_43:
        char v12 = AMAuthInstallBasebandMAV21SupportsServerSigning();
        goto LABEL_51;
      }
      if (v11 <= 8343776)
      {
        if (v11 == 5898465)
        {
          char v12 = AMAuthInstallBasebandN94SupportsServerSigning();
          goto LABEL_51;
        }
        if (v11 == 7278817 || v11 == 7282913)
        {
          char v12 = AMAuthInstallBasebandN41SupportsServerSigning();
          goto LABEL_51;
        }
        goto LABEL_49;
      }
      BOOL v16 = v11 == 8343777 || v11 == 9572577;
      int v17 = 9781473;
    }
    else
    {
      if (v11 <= 241888)
      {
        if ((v11 - 80) <= 0x18)
        {
          if (((1 << (v11 - 80)) & 0x1A14000) != 0)
          {
            char v12 = AMAuthInstallBasebandRembrandtSupportsServerSigning(a1);
LABEL_51:
            uint64_t v8 = 0;
            *a2 = v12;
            return v8;
          }
          if (v11 == 80)
          {
            char v12 = AMAuthInstallBasebandICE3SupportsServerSigning();
            goto LABEL_51;
          }
        }
        goto LABEL_49;
      }
      if (v11 > 938208)
      {
        if (v11 == 938209)
        {
          char v12 = AMAuthInstallBasebandMAV20SupportsServerSigning();
          goto LABEL_51;
        }
        BOOL v14 = v11 == 1327329;
        int v15 = 1515745;
        goto LABEL_38;
      }
      BOOL v16 = v11 == 241889;
      int v17 = 520417;
    }
    if (v16 || v11 == v17)
    {
      char v12 = AMAuthInstallBasebandMAV10SupportsServerSigning();
      goto LABEL_51;
    }
    goto LABEL_49;
  }
  return v8;
}

uint64_t AMAuthInstallBasebandCopyAllComponents(const void *a1, const void *a2, CFTypeRef *a3)
{
  uint64_t v3 = 0;
  v24[0] = 0;
  v24[1] = 0;
  uint64_t v4 = 1;
  CFMutableDictionaryRef v25 = 0;
  if (a1 && a2 && a3)
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v8, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v3 = Mutable;
    if (Mutable)
    {
      v24[0] = a1;
      CFMutableDictionaryRef v25 = Mutable;
      uint64_t v10 = BbfwReaderStart(a2, (uint64_t (*)(uint64_t, CFStringRef, void *))sub_100012A5C, (uint64_t)v24);
      if (v10)
      {
        uint64_t v4 = v10;
      }
      else
      {
        uint64_t v17 = AMAuthInstallProvisioningProvisionIfNecessary((uint64_t)a1, v3, v11, v12, v13, v14, v15, v16);
        uint64_t v4 = v17;
        if (v17) {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCopyAllComponents", (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary failed: %d", v18, v19, v20, v21, v22, v17);
        }
        else {
          *a3 = CFRetain(v3);
        }
      }
    }
    else
    {
      uint64_t v4 = 2;
    }
  }
  SafeRelease(v3);
  return v4;
}

uint64_t sub_100012A5C(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = *(__CFDictionary **)(a1 + 16);
  value = 0;
  int v5 = BbfwReaderCopyFileData(a3, (CFTypeRef *)&value);
  if (v5)
  {
    AMAuthInstallGetLocalizedStatusString(0, v5);
    AMAuthInstallLog(3, (uint64_t)"_AddFirmware", (uint64_t)"failed to extract bbfw item \"%@\": %@; continuing anyway",
      v11,
      v12,
      v13,
      v14,
      v15,
      (char)a2);
  }
  else if (value)
  {
    CFDictionarySetValue(v4, a2, value);
  }
  else
  {
    AMAuthInstallLog(4, (uint64_t)"_AddFirmware", (uint64_t)"failed to add \"%@\"; ignoring it",
      v6,
      v7,
      v8,
      v9,
      v10,
      (char)a2);
  }
  SafeRelease(value);
  return 1;
}

CFIndex AMAuthInstallBasebandCopyFirmware(const void *a1, const void *a2, const void *a3)
{
  CFDictionaryRef v14 = 0;
  uint64_t v4 = AMAuthInstallBasebandCopyAllComponents(a1, a2, (CFTypeRef *)&v14);
  if (v4)
  {
    CFIndex v10 = v4;
    uint64_t v12 = "AMAuthInstallBasebandCopyAllComponents failed";
LABEL_6:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCopyFirmware", (uint64_t)v12, v5, v6, v7, v8, v9, v13);
    goto LABEL_3;
  }
  CFIndex v10 = AMAuthInstallBasebandWriteFilesToBbfw(0, a3, v14);
  if (v10)
  {
    uint64_t v12 = "AMAuthInstallBasebandWriteFilesToBbfw failed";
    goto LABEL_6;
  }
LABEL_3:
  SafeRelease(v14);
  return v10;
}

CFIndex AMAuthInstallBasebandWriteFilesToBbfw(int a1, CFTypeRef cf, const __CFDictionary *a3)
{
  context = 0;
  uint64_t v12 = BbfwWriterCreate(cf);
  if (!v12) {
    return 4;
  }
  CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)sub_100012FFC, &context);
  BbfwWriterFinalize((uint64_t)v12);
  if (!context) {
    return 0;
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandWriteFilesToBbfw", (uint64_t)"Error writing bbfw zip: %@", v4, v5, v6, v7, v8, (char)context);
  CFIndex Code = CFErrorGetCode(context);
  CFRelease(context);
  return Code;
}

void _AMAuthInstallBasebandParametersFinalize(CFTypeRef *a1)
{
  if (a1)
  {
    SafeRelease(a1[2]);
    SafeRelease(a1[3]);
    SafeRelease(a1[4]);
    SafeRelease(a1[5]);
    SafeRelease(a1[8]);
    SafeRelease(a1[9]);
    SafeRelease(a1[13]);
    SafeRelease(a1[14]);
    SafeRelease(a1[15]);
    SafeRelease(a1[16]);
    SafeRelease(a1[17]);
    SafeRelease(a1[18]);
    SafeRelease(a1[19]);
    SafeRelease(a1[21]);
    free(a1);
  }
}

unint64_t AMAuthInstallBasebandPersonalizationRequired(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = *(void *)(result + 48);
    if (v8)
    {
      unsigned int v9 = *(_DWORD *)(v8 + 96);
      BOOL v10 = v9 > 3 || v9 == 1;
      return !v10 && *(void *)(v8 + 16) || *(void *)(result + 168) || *(void *)(result + 176) != 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandPersonalizationRequired", (uint64_t)"failed to get fusing status", a4, a5, a6, a7, a8, vars0);
      return 0;
    }
  }
  return result;
}

uint64_t AMAuthInstallBasebandGetKeyHash(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a3)
    {
      CFDataRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 200), a2);
      uint64_t result = 0;
      *a3 = Value;
      return result;
    }
    uint64_t v11 = "outKeyHash is NULL";
  }
  else
  {
    uint64_t v11 = "amai is NULL";
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandGetKeyHash", (uint64_t)v11, a4, a5, a6, a7, a8, v12);
  return 1;
}

uint64_t AMAuthInstallBasebandSetKeyHash(uint64_t a1, const void *a2, CFDataRef theData)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 1;
  if (theData && a2 && *(void *)(a1 + 216))
  {
    if (CFDataGetLength(theData) == 20
      || CFDataGetLength(theData) == 32
      || CFDataGetLength(theData) == 48
      || !CFDataGetLength(theData))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 216), a2, theData);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 200), a2, theData);
      return 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandSetKeyHash", (uint64_t)"Invalid hash length", v7, v8, v9, v10, v11, v12);
      return 99;
    }
  }
  return result;
}

__CFString *AMAuthInstallBasebandCopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 256);
  CFStringAppend(Mutable, @"(");
  if (*(unsigned char *)(a1 + 58)) {
    uint64_t v4 = "YES";
  }
  else {
    uint64_t v4 = "NO";
  }
  CFStringAppendFormat(Mutable, 0, @"personalize=%s", v4);
  if (*(void *)(a1 + 48))
  {
    CFStringAppendFormat(Mutable, 0, @", ");
    if (*(void *)(*(void *)(a1 + 48) + 16))
    {
      CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v6 = _CopyHexStringFromData(v5, *(CFDataRef *)(*(void *)(a1 + 48) + 16));
      if (v6)
      {
        uint64_t v7 = v6;
        CFStringAppendFormat(Mutable, 0, @"snum=0x%@, ", v6);
        CFRelease(v7);
      }
    }
    CFStringAppendFormat(Mutable, 0, @"chipid=0x%x, certid=0x%x", *(unsigned int *)(*(void *)(a1 + 48) + 4), *(unsigned int *)(*(void *)(a1 + 48) + 8));
    if (*(void *)(*(void *)(a1 + 48) + 24))
    {
      CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v9 = _CopyHexStringFromData(v8, *(CFDataRef *)(*(void *)(a1 + 48) + 24));
      if (v9)
      {
        uint64_t v10 = v9;
        CFStringAppendFormat(Mutable, 0, @", nonce=0x%@", v9);
        CFRelease(v10);
      }
    }
  }
  CFStringAppend(Mutable, @""));
  return Mutable;
}

void sub_100012FFC(CFStringRef theString, const __CFData *a2, CFErrorRef *a3)
{
  if (!*a3)
  {
    uint64_t v5 = BbfwWriterAddFile((uint64_t)a3[1], theString, a2);
    if (v5)
    {
      uint64_t v6 = v5;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFAllocatorRef v8 = Mutable;
        CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"BbfwWriterAddFile failed to add file: %@. Error code: %d", theString, v6);
        if (v9)
        {
          CFStringRef v10 = v9;
          CFDictionarySetValue(v8, kCFErrorDescriptionKey, v9);
          CFRelease(v10);
        }
        *a3 = CFErrorCreate(kCFAllocatorDefault, @"AuthInstallErrorDomain", v6, v8);
        AMAuthInstallLog(3, (uint64_t)"_AddToArchive", (uint64_t)"failed to archive \"%@\"", v11, v12, v13, v14, v15, (char)theString);
        CFRelease(v8);
      }
      else
      {
        *a3 = CFErrorCreate(kCFAllocatorDefault, @"AuthInstallErrorDomain", v6, 0);
        AMAuthInstallLog(3, (uint64_t)"_AddToArchive", (uint64_t)"failed to archive \"%@\"", v16, v17, v18, v19, v20, (char)theString);
      }
    }
  }
}

uint64_t AMAuthInstallBasebandPersonalizeFirmwareInternal(void *a1, void *a2, const void *a3, const void *a4, __CFDictionary *a5, const __CFDictionary *a6, const __CFDictionary *a7)
{
  CFDictionaryRef v12 = 0;
  if (a1)
  {
    CFDictionaryRef v8 = 0;
    uint64_t v9 = 1;
    if (a4 && a2 && a1[6])
    {
      uint64_t v10 = AMAuthInstallBasebandCopyAllPersonalizedComponents(a1, a2, a3, a5, a6, a7, (CFTypeRef *)&v12);
      CFDictionaryRef v8 = v12;
      if (!v10) {
        uint64_t v10 = AMAuthInstallBasebandWriteFilesToBbfw(0, a4, v12);
      }
      uint64_t v9 = v10;
    }
  }
  else
  {
    CFDictionaryRef v8 = 0;
    uint64_t v9 = 1;
  }
  SafeRelease(v8);
  SafeRelease(0);
  return v9;
}

uint64_t AMAuthInstallBasebandReadChipIDFromBbfw(const void *a1, _DWORD *a2)
{
  CFDataRef data = 0;
  int v25 = 0;
  CFErrorRef error = 0;
  if (!a1)
  {
    uint64_t v9 = 0;
    CFDictionaryRef v17 = 0;
    uint64_t v20 = 1;
    goto LABEL_9;
  }
  uint64_t v3 = BbfwReaderOpen(a1);
  uint64_t v9 = (uint64_t)v3;
  if (!v3)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandReadChipIDFromBbfw", (uint64_t)"failed to open bbfw archive for reading", v4, v5, v6, v7, v8, (char)v23);
    CFDictionaryRef v17 = 0;
    uint64_t v20 = 4;
    goto LABEL_9;
  }
  uint64_t v10 = BbfwReaderFindAndCopyFileData((uint64_t)v3, @"Info.plist", (CFTypeRef *)&data);
  if (v10)
  {
    uint64_t v20 = v10;
    CFDictionaryRef v17 = 0;
    goto LABEL_9;
  }
  CFDictionaryRef v11 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, 0, &error);
  CFDictionaryRef v17 = v11;
  if (!v11)
  {
    CFStringRef v23 = @"Info.plist";
    uint64_t v22 = "failed to parse %@: %@";
LABEL_17:
    uint64_t v20 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandReadChipIDFromBbfw", (uint64_t)v22, v12, v13, v14, v15, v16, (char)v23);
    goto LABEL_9;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v11, @"com.apple.EmbeddedSoftwareRestore.Baseband.ChipId");
  if (!Value)
  {
    CFStringRef v23 = @"Info.plist";
    uint64_t v22 = "failed to find ChipId in %@";
    goto LABEL_17;
  }
  char v19 = (char)Value;
  if (!_CFStringToUInt32(Value, &v25))
  {
    LOBYTE(v23) = v19;
    uint64_t v22 = "failed to convert ChipId(%@) to int";
    goto LABEL_17;
  }
  if (!v25)
  {
    uint64_t v22 = "ChipId is 0 (invalid)";
    goto LABEL_17;
  }
  uint64_t v20 = 0;
  *a2 = v25;
LABEL_9:
  BbfwReaderClose(v9);
  SafeRelease(data);
  SafeRelease(v17);
  SafeRelease(error);
  return v20;
}

uint64_t AMAuthInstallBasebandReadVersionFromBbfw(CFDataRef data, const void *a2, CFTypeRef *a3)
{
  CFDictionaryRef v3 = 0;
  int valuePtr = 0;
  CFErrorRef error = 0;
  uint64_t v4 = 1;
  if (!data || !a2)
  {
    uint64_t v7 = 0;
    goto LABEL_10;
  }
  uint64_t v7 = 0;
  if (a3)
  {
    CFDictionaryRef v8 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, 0, &error);
    CFDictionaryRef v3 = v8;
    if (v8)
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v8, a2);
      uint64_t v7 = Value;
      if (!Value)
      {
        uint64_t v4 = 3;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandReadVersionFromBbfw", (uint64_t)"failed to find VersionStr in %@", v15, v16, v17, v18, v19, (char)@"Info.plist");
        goto LABEL_10;
      }
      if (_CFStringToUInt32(Value, &valuePtr))
      {
        if (valuePtr)
        {
          CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
          uint64_t v7 = v20;
          if (v20)
          {
            uint64_t v4 = 0;
            *a3 = CFRetain(v20);
          }
          else
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandReadVersionFromBbfw", (uint64_t)"Failed to create versionNumber", v21, v22, v23, v24, v25, (char)v28);
            uint64_t v4 = 2;
          }
          goto LABEL_10;
        }
        uint64_t v27 = "Version is 0 (invalid)";
      }
      else
      {
        LOBYTE(v28) = (_BYTE)v7;
        uint64_t v27 = "failed to convert VersionStr(%@) to int";
      }
    }
    else
    {
      CFStringRef v28 = @"Info.plist";
      uint64_t v27 = "failed to parse %@: %@";
    }
    uint64_t v4 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandReadVersionFromBbfw", (uint64_t)v27, v9, v10, v11, v12, v13, (char)v28);
    uint64_t v7 = 0;
  }
LABEL_10:
  SafeRelease(v7);
  SafeRelease(v3);
  SafeRelease(error);
  return v4;
}

uint64_t AMAuthInstallBasebandLocalSetSigningParameters(void *cf, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  if (cf)
  {
    if (a2 && a3 && a4 || (uint64_t v12 = 1, !a2) && !a3 && !a4 && !a5 && !a6)
    {
      uint64_t v13 = (void *)*((void *)cf + 46);
      if (v13)
      {
        AMAuthInstallReleaseRsaKeyData(*v13);
        SafeRelease(*(CFTypeRef *)(*((void *)cf + 46) + 8));
        SafeRelease(*(CFTypeRef *)(*((void *)cf + 46) + 16));
        SafeRelease(*(CFTypeRef *)(*((void *)cf + 46) + 24));
        SafeRelease(*(CFTypeRef *)(*((void *)cf + 46) + 32));
        free(*((void **)cf + 46));
        *((void *)cf + 46) = 0;
      }
      if (a2)
      {
        CFGetAllocator(cf);
        uint64_t v14 = AMAuthInstallCopyRsaKeyDataForKey();
        if (v14)
        {
          uint64_t v12 = v14;
          char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)cf, v14);
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandLocalSetSigningParameters", (uint64_t)"bad local signing key: %@", v16, v17, v18, v19, v20, LocalizedStatusString);
        }
        else
        {
          uint64_t v21 = calloc(1uLL, 0x28uLL);
          *((void *)cf + 46) = v21;
          if (v21)
          {
            **((void **)cf + 46) = CFRetain(0);
            *(void *)(*((void *)cf + 46) + 8) = CFRetain(a3);
            *(void *)(*((void *)cf + 46) + 16) = CFRetain(a4);
            *(void *)(*((void *)cf + 46) + 32) = CFRetain(a6);
            uint64_t v12 = 0;
            *(void *)(*((void *)cf + 46) + 24) = SafeRetain(a5);
          }
          else
          {
            uint64_t v12 = 2;
          }
        }
      }
      else
      {
        uint64_t v12 = 0;
      }
    }
  }
  else
  {
    uint64_t v12 = 1;
  }
  SafeRelease(0);
  SafeRelease(0);
  return v12;
}

void AMAuthInstallBasebandFinalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 176))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandFinalize", (uint64_t)"*********************************", a4, a5, a6, a7, a8, v20);
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandFinalize", (uint64_t)"* unacknowledged fusing program *", v9, v10, v11, v12, v13, v21);
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandFinalize", (uint64_t)"*********************************", v14, v15, v16, v17, v18, v22);
  }
  _AMAuthInstallBasebandParametersFinalize(*(CFTypeRef **)(a1 + 48));
  AMAuthInstallBasebandLocalSetSigningParameters((void *)a1, 0, 0, 0, 0, 0);
  SafeRelease(*(CFTypeRef *)(a1 + 160));
  SafeRelease(*(CFTypeRef *)(a1 + 168));
  SafeRelease(*(CFTypeRef *)(a1 + 176));
  SafeRelease(*(CFTypeRef *)(a1 + 192));
  SafeRelease(*(CFTypeRef *)(a1 + 200));
  SafeRelease(*(CFTypeRef *)(a1 + 208));
  SafeRelease(*(CFTypeRef *)(a1 + 216));
  SafeRelease(*(CFTypeRef *)(a1 + 136));
  SafeRelease(*(CFTypeRef *)(a1 + 240));
  SafeRelease(*(CFTypeRef *)(a1 + 264));
  SafeRelease(*(CFTypeRef *)(a1 + 248));
  SafeRelease(*(CFTypeRef *)(a1 + 232));
  SafeRelease(*(CFTypeRef *)(a1 + 272));
  uint64_t v19 = *(const void **)(a1 + 280);
  SafeRelease(v19);
}

uint64_t AMAuthInstallBasebandCopyNextComponentName(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  uint64_t v8 = *(void *)(a1 + 48);
  if (!v8)
  {
    *a2 = 0;
    return 99;
  }
  int v9 = *(_DWORD *)(v8 + 4);
  if (v9 <= 1700064)
  {
    if (v9 <= 241888)
    {
      if ((v9 - 80) <= 0x18)
      {
        if (((1 << (v9 - 80)) & 0x1A14000) != 0)
        {
          return AMAuthInstallBasebandRembrandtCopyNextComponentName();
        }
        if (v9 == 80)
        {
          return AMAuthInstallBasebandICE3CopyNextComponentName(a1, a2, a3, a4, a5, a6, a7, a8);
        }
      }
      goto LABEL_60;
    }
    if (v9 <= 938208)
    {
      BOOL v12 = v9 == 241889;
      int v13 = 520417;
    }
    else
    {
      BOOL v12 = v9 == 938209 || v9 == 1327329;
      int v13 = 1515745;
    }
LABEL_42:
    if (!v12 && v9 != v13) {
      goto LABEL_60;
    }
    goto LABEL_47;
  }
  if (v9 <= 5898464)
  {
    if (v9 <= 2814176)
    {
      BOOL v12 = v9 == 1700065;
      int v13 = 2089185;
      goto LABEL_42;
    }
    switch(v9)
    {
      case 2814177:
LABEL_47:
        return AMAuthInstallBasebandMAV10CopyNextComponentName();
      case 4587745:
        return AMAuthInstallBasebandJ2CopyNextComponentName();
      case 5243105:
        return AMAuthInstallBasebandN92CopyNextComponentName();
      default:
LABEL_60:
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandCopyNextComponentName", (uint64_t)"chipID: 0x%x is not supported", a4, a5, a6, a7, a8, v9);
        return 99;
    }
  }
  else
  {
    if (v9 > 8343776)
    {
      BOOL v12 = v9 == 8343777 || v9 == 9572577;
      int v13 = 9781473;
      goto LABEL_42;
    }
    if (v9 == 5898465)
    {
      return AMAuthInstallBasebandN94CopyNextComponentName();
    }
    else
    {
      if (v9 != 7278817 && v9 != 7282913) {
        goto LABEL_60;
      }
      return AMAuthInstallBasebandN41CopyNextComponentName();
    }
  }
}

uint64_t AMAuthInstallBasebandSupportsLocalSigning(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1;
  if (a1 && a2)
  {
    uint64_t v10 = *(void *)(a1 + 48);
    if (!v10)
    {
LABEL_51:
      char v13 = 0;
      goto LABEL_52;
    }
    int v11 = *(_DWORD *)(v10 + 4);
    if (v11 <= 1700064)
    {
      if (v11 <= 241888)
      {
        if ((v11 - 94) > 0xA || ((1 << (v11 - 94)) & 0x685) == 0) {
          goto LABEL_50;
        }
        char v13 = AMAuthInstallBasebandRembrandtSupportsLocalSigning();
        goto LABEL_52;
      }
      if (v11 <= 938208)
      {
        BOOL v17 = v11 == 241889;
        int v18 = 520417;
        goto LABEL_42;
      }
      BOOL v15 = v11 == 938209 || v11 == 1327329;
      int v16 = 1515745;
    }
    else
    {
      if (v11 > 5898464)
      {
        if (v11 <= 8343776)
        {
          if (v11 == 5898465)
          {
            char v13 = AMAuthInstallBasebandN94SupportsLocalSigning();
          }
          else
          {
            if (v11 != 7278817 && v11 != 7282913) {
              goto LABEL_50;
            }
            char v13 = AMAuthInstallBasebandN41SupportsLocalSigning(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
          }
          goto LABEL_52;
        }
        BOOL v17 = v11 == 8343777 || v11 == 9572577;
        int v18 = 9781473;
LABEL_42:
        if (!v17 && v11 != v18) {
          goto LABEL_50;
        }
        char v13 = AMAuthInstallBasebandMAV10SupportsLocalSigning();
        goto LABEL_52;
      }
      if (v11 > 2814176)
      {
        if (v11 != 2814177)
        {
          if (v11 == 4587745)
          {
            char v13 = AMAuthInstallBasebandJ2SupportsLocalSigning();
          }
          else
          {
            if (v11 != 5243105)
            {
LABEL_50:
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandSupportsLocalSigning", (uint64_t)"chipID: 0x%x is not supported for local signing", a4, a5, a6, a7, a8, v11);
              goto LABEL_51;
            }
            char v13 = AMAuthInstallBasebandN92SupportsLocalSigning();
          }
LABEL_52:
          uint64_t v8 = 0;
          *a2 = v13;
          return v8;
        }
LABEL_40:
        char v13 = AMAuthInstallBasebandMAV20SupportsLocalSigning();
        goto LABEL_52;
      }
      BOOL v15 = v11 == 1700065;
      int v16 = 2089185;
    }
    if (!v15 && v11 != v16) {
      goto LABEL_50;
    }
    goto LABEL_40;
  }
  return v8;
}

uint64_t AMAuthInstallBasebandSetKeyHashInternal(uint64_t a1, const void *a2, CFDataRef theData)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 1;
  if (theData && a2 && *(void *)(a1 + 200))
  {
    if (CFDataGetLength(theData) == 20
      || CFDataGetLength(theData) == 32
      || CFDataGetLength(theData) == 48
      || !CFDataGetLength(theData))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 200), a2, theData);
      return 0;
    }
    else
    {
      char Length = CFDataGetLength(theData);
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandSetKeyHashInternal", (uint64_t)"Invalid hash length %d", v8, v9, v10, v11, v12, Length);
      return 99;
    }
  }
  return result;
}

uint64_t AMAuthInstallBasebandMeasureFirmwareFromBbfw(int a1, uint64_t a2, const __CFString *a3, uint64_t (*a4)(uint64_t, CFTypeRef, uint64_t), uint64_t a5, uint64_t a6)
{
  char v8 = (char)a3;
  CFTypeRef v25 = 0;
  int v11 = BbfwReaderFindAndCopyFileData(a5, a3, &v25);
  if (!a1 && v11)
  {
    AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandMeasureFirmwareFromBbfw", (uint64_t)"%@ absent; but ignoring",
      v12,
      v13,
      v14,
      v15,
      v16,
      v8);
LABEL_8:
    uint64_t v23 = 1;
    goto LABEL_9;
  }
  if (!v11)
  {
    int v17 = a4(a2, v25, a6);
    if (!v17) {
      goto LABEL_8;
    }
    AMAuthInstallGetLocalizedStatusString(0, v17);
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandMeasureFirmwareFromBbfw", (uint64_t)"failed to measure \"%@\": %@;",
      v18,
      v19,
      v20,
      v21,
      v22,
      v8);
  }
  uint64_t v23 = 0;
LABEL_9:
  SafeRelease(v25);
  return v23;
}

uint64_t AMAuthInstallBasebandStitchCopyFile(uint64_t a1, CFTypeRef cf, uint64_t a3, void *a4)
{
  if (!a1) {
    return 1;
  }
  CFTypeRef v5 = CFRetain(cf);
  uint64_t result = 0;
  *a4 = v5;
  return result;
}

uint64_t AMAuthInstallBasebandStitchFirmwareFromBbfw(uint64_t a1, const __CFString *a2, uint64_t (*a3)(uint64_t, CFTypeRef, uint64_t, void **), uint64_t a4, uint64_t a5, __CFDictionary *a6)
{
  value = 0;
  CFTypeRef v25 = 0;
  if (!BbfwReaderFindAndCopyFileData(a4, a2, &v25))
  {
    int v11 = a3(a1, v25, a5, &value);
    if (v11)
    {
      AMAuthInstallGetLocalizedStatusString(0, v11);
      AMAuthInstallLog(4, (uint64_t)"AMAuthInstallBasebandStitchFirmwareFromBbfw", (uint64_t)"failed to stitch \"%@\": %@; continuing anyway",
        v17,
        v18,
        v19,
        v20,
        v21,
        (char)a2);
    }
    else
    {
      if (value)
      {
        CFDictionarySetValue(a6, a2, value);
        uint64_t v22 = 1;
        goto LABEL_7;
      }
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandStitchFirmwareFromBbfw", (uint64_t)"stitch function returned NULL for \"%@\"; continuing anyway",
        v12,
        v13,
        v14,
        v15,
        v16,
        (char)a2);
    }
  }
  uint64_t v22 = 0;
LABEL_7:
  SafeRelease(v25);
  SafeRelease(value);
  return v22;
}

uint64_t AMAuthInstallBasebandLocalProvisionDevice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1;
  if (!a1) {
    return v8;
  }
  if (!a2) {
    return v8;
  }
  uint64_t v9 = *(void *)(a1 + 48);
  if (!v9) {
    return v8;
  }
  int v10 = *(_DWORD *)(v9 + 4);
  if (v10 <= 1700064)
  {
    if (v10 <= 241888)
    {
      if ((v10 - 94) > 0xA || ((1 << (v10 - 94)) & 0x685) == 0) {
        goto LABEL_64;
      }
      return AMAuthInstallBasebandRembrandtLocalProvisionDevice();
    }
    if (v10 <= 938208)
    {
      BOOL v16 = v10 == 241889;
      int v17 = 520417;
      goto LABEL_50;
    }
    BOOL v14 = v10 == 938209 || v10 == 1327329;
    int v15 = 1515745;
    goto LABEL_41;
  }
  if (v10 > 5898464)
  {
    if (v10 <= 8343776)
    {
      if (v10 == 5898465)
      {
        return AMAuthInstallBasebandN94LocalProvisionDevice();
      }
      else
      {
        if (v10 != 7278817 && v10 != 7282913) {
          goto LABEL_64;
        }
        return AMAuthInstallBasebandN41LocalProvisionDevice();
      }
    }
    BOOL v16 = v10 == 8343777 || v10 == 9572577;
    int v17 = 9781473;
LABEL_50:
    if (!v16 && v10 != v17) {
      goto LABEL_64;
    }
    return AMAuthInstallBasebandMAV10LocalProvisionDevice();
  }
  if (v10 <= 2814176)
  {
    BOOL v14 = v10 == 1700065;
    int v15 = 2089185;
LABEL_41:
    if (!v14 && v10 != v15) {
      goto LABEL_64;
    }
    goto LABEL_46;
  }
  switch(v10)
  {
    case 2814177:
LABEL_46:
      return AMAuthInstallBasebandMAV20LocalProvisionDevice();
    case 4587745:
      return AMAuthInstallBasebandJ2LocalProvisionDevice();
    case 5243105:
      return AMAuthInstallBasebandN92LocalProvisionDevice(a1);
    default:
LABEL_64:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandLocalProvisionDevice", (uint64_t)"chipID: 0x%x is not supported for local provisioning", a4, a5, a6, a7, a8, v10);
      return 13;
  }
}

uint64_t AMAuthInstallBasebandSetAntennaType(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 1;
  }
  SafeRelease(*(CFTypeRef *)(a1 + 144));
  CFTypeRef v4 = SafeRetain(a2);
  uint64_t result = 0;
  *(void *)(a1 + 144) = v4;
  return result;
}

uint64_t AMAuthInstallBasebandSetBehavior(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 1;
  }
  SafeRelease(*(CFTypeRef *)(a1 + 152));
  CFTypeRef v4 = SafeRetain(a2);
  uint64_t result = 0;
  *(void *)(a1 + 152) = v4;
  return result;
}

uint64_t AMAuthInstallBasebandIsFused(uint64_t a1, unsigned char *a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2) {
    return 1;
  }
  uint64_t result = 0;
  uint64_t v4 = *(void *)(v2 + 16);
  unsigned int v5 = (*(_DWORD *)(v2 + 96) < 4u) & (0xDu >> (*(_DWORD *)(v2 + 96) & 0xF));
  if (!v4) {
    LOBYTE(v5) = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t AMAuthInstallBasebandGetVersion(uint64_t a1, CFDataRef data, __CFDictionary *a3, const void *a4, const void *a5)
{
  value = 0;
  uint64_t result = 1;
  if (a1 && data && a3 && a4)
  {
    if (AMAuthInstallBasebandReadVersionFromBbfw(data, a4, (CFTypeRef *)&value) || !value)
    {
      return 14;
    }
    else
    {
      CFDictionarySetValue(a3, a5, value);
      return 0;
    }
  }
  return result;
}

uint64_t AMAuthInstallBasebandGetRestoreSbl1Version(uint64_t a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallBasebandGetVersion(a1, a2, a3, @"com.apple.EmbeddedSoftwareRestore.Baseband.RestoreSBLVersion", @"RestoreSBL1-Version");
}

uint64_t AMAuthInstallBasebandGetSbl1Version(uint64_t a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallBasebandGetVersion(a1, a2, a3, @"com.apple.EmbeddedSoftwareRestore.Baseband.SBLVersion", @"SBL1-Version");
}

uint64_t AMAuthInstallBasebandICE3MeasureRamPsi(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  CFDataRef theData = 0;
  value = 0;
  CFStringRef v28 = 0;
  CFAllocatorRef v6 = CFGetAllocator(a1);
  uint64_t v7 = FlsParserCreate(v6);
  uint64_t v8 = (PRGSequencer **)v7;
  if (v7)
  {
    uint64_t v9 = FlsParserReadFromData(v7, a2);
    if (v9
      || (uint64_t v9 = FlsParserCopyRamPsi(v8, &theData), v9)
      || (CFAllocatorRef v10 = CFGetAllocator(a1),
          BytePtr = CFDataGetBytePtr(theData),
          CFIndex Length = CFDataGetLength(theData),
          uint64_t v9 = sub_1000144E0(v10, (uint64_t)BytePtr, Length, (CFDataRef *)&v28, (CFStringRef *)&value, v13, v14, v15),
          v9))
    {
      uint64_t v26 = v9;
    }
    else
    {
      AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureRamPsi", (uint64_t)"Version = %@", v16, v17, v18, v19, v20, (char)value);
      CFDictionarySetValue(a3, @"RamPSI-Version", value);
      AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureRamPsi", (uint64_t)"Partialuint64_t Digest = %@", v21, v22, v23, v24, v25, (char)v28);
      CFDictionarySetValue(a3, @"RamPSI-PartialDigest", v28);
      uint64_t v26 = 0;
    }
  }
  else
  {
    uint64_t v26 = 2;
  }
  SafeRelease(v8);
  SafeRelease(value);
  SafeRelease(theData);
  SafeRelease(v28);
  return v26;
}

uint64_t sub_1000144E0(const __CFAllocator *a1, uint64_t a2, unint64_t a3, CFDataRef *a4, CFStringRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a4) {
    sub_100071E7C();
  }
  if (!a5) {
    sub_100071EA8();
  }
  int8x16_t v23 = 0uLL;
  int v24 = 0;
  if (a3 < 0x50 || *(_DWORD *)(a2 + 4) != 1430808940 || (uint64_t v9 = *(unsigned int *)(a2 + 12), (v9 + 1) <= 1))
  {
    CFAllocatorRef v10 = "PSI Image does not contain recognizable PSI header";
LABEL_7:
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallCopyPsiMeasurementAndVersion", (uint64_t)v10, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v20);
    return 10;
  }
  if ((*(unsigned char *)(a2 + 10) & 1) == 0)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallCopyPsiMeasurementAndVersion", (uint64_t)"missing SN indicator", (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v20);
    return 1;
  }
  CC_LONG v12 = *(_DWORD *)(a2 + 20);
  if ((v12 & 0x3F) != 0)
  {
    CFAllocatorRef v10 = "GPuK is not properly aligned for partial digest";
    goto LABEL_7;
  }
  *(_DWORD *)bytes = *(_DWORD *)(a2 + 40) - v12;
  CC_LONG v22 = v12;
  *(void *)&double v15 = sub_100016080((const void *)a2, v12, &v23).u64[0];
  CFStringRef v16 = CFStringCreateWithFormat(a1, 0, @"0x%08x", v15, v9);
  if (v16)
  {
    CFStringRef v17 = v16;
    CFDataRef v18 = CFDataCreate(a1, bytes, 28);
    if (v18)
    {
      CFDataRef v19 = v18;
      uint64_t result = 0;
      *a5 = v17;
      *a4 = v19;
      return result;
    }
    CFRelease(v17);
  }
  return 2;
}

uint64_t AMAuthInstallBasebandICE3StitchRamPsi(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  CFTypeRef v17 = 0;
  CFTypeRef v18 = 0;
  CFTypeRef cf = 0;
  CFAllocatorRef v8 = CFGetAllocator(a1);
  uint64_t v9 = FlsParserCreate(v8);
  CFAllocatorRef v10 = (PRGSequencer **)v9;
  if (v9)
  {
    uint64_t v11 = FlsParserReadFromData(v9, a2);
    if (v11 || (uint64_t v11 = FlsParserCopyRamPsi(v10, (CFDataRef *)&v18), v11))
    {
      uint64_t v14 = v11;
      CFDataRef v13 = 0;
    }
    else
    {
      AMAuthInstallDebugWriteObject((char *)a1, v18, @"RamPSI-Original", 1);
      uint64_t v12 = sub_1000147B0((char *)a1, v18, a3, @"RamPSI-Blob", &v17);
      CFDataRef v13 = (const __CFData *)v17;
      if (v12
        || (AMAuthInstallDebugWriteObject((char *)a1, v17, @"RamPSI-Personalized", 1),
            uint64_t v12 = FlsParserReplaceRamPsi((uint64_t)v10, v13),
            v12))
      {
        uint64_t v14 = v12;
      }
      else
      {
        uint64_t v14 = FlsParserCopyAsData(v10, &cf);
        if (!v14) {
          *a4 = CFRetain(cf);
        }
      }
    }
  }
  else
  {
    CFDataRef v13 = 0;
    uint64_t v14 = 2;
  }
  SafeRelease(v10);
  SafeRelease(v18);
  SafeRelease(v13);
  SafeRelease(cf);
  return v14;
}

uint64_t sub_1000147B0(char *a1, const void *a2, CFDictionaryRef theDict, const void *a4, CFTypeRef *a5)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"BasebandFirmware");
  if (!Value)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBasebandStitchICE3Psi", (uint64_t)"response missing \"%@\"", v10, v11, v12, v13, v14, (char)@"BasebandFirmware");
LABEL_8:
    int v24 = 0;
    uint64_t v29 = 8;
    goto LABEL_5;
  }
  CFDataRef v15 = (const __CFData *)CFDictionaryGetValue(Value, a4);
  if (!v15)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBasebandStitchICE3Psi", (uint64_t)"response missing \"%@\"", v16, v17, v18, v19, v20, (char)a4);
    goto LABEL_8;
  }
  CFDataRef v21 = v15;
  AMAuthInstallDebugWriteObject(a1, a2, (uint64_t)a4, 1);
  CFAllocatorRef v22 = CFGetAllocator(a1);
  CFDataRef MutableCopy = CFDataCreateMutableCopy(v22, 0, (CFDataRef)a2);
  int v24 = MutableCopy;
  if (MutableCopy)
  {
    CFIndex Length = CFDataGetLength(MutableCopy);
    CFIndex v26 = CFDataGetLength(v21);
    CFDataSetLength(v24, Length - v26);
    BytePtr = CFDataGetBytePtr(v21);
    CFIndex v28 = CFDataGetLength(v21);
    CFDataAppendBytes(v24, BytePtr, v28);
    uint64_t v29 = 0;
    *a5 = CFRetain(v24);
  }
  else
  {
    uint64_t v29 = 2;
  }
LABEL_5:
  SafeRelease(v24);
  return v29;
}

uint64_t AMAuthInstallBasebandICE3MeasureEbl(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  CFDataRef v21 = 0;
  CFDataRef theData = 0;
  CFAllocatorRef v6 = CFGetAllocator(a1);
  uint64_t v7 = FlsParserCreate(v6);
  CFAllocatorRef v8 = (PRGSequencer **)v7;
  if (v7)
  {
    uint64_t v9 = FlsParserReadFromData(v7, a2);
    if (v9 || (uint64_t v9 = FlsParserCopyEbl(v8, &theData), v9))
    {
      uint64_t v18 = v9;
      CFDataRef v19 = 0;
    }
    else
    {
      CFAllocatorRef v10 = CFGetAllocator(a1);
      BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
      CC_LONG Length = CFDataGetLength(theData);
      uint64_t v18 = sub_100014A04(v10, BytePtr, Length, &v21);
      CFDataRef v19 = v21;
      if (!v18)
      {
        AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureEbl", (uint64_t)"uint64_t Digest = %@", v13, v14, v15, v16, v17, (char)v21);
        CFDictionarySetValue(a3, @"EBL-Digest", v19);
      }
    }
  }
  else
  {
    CFDataRef v19 = 0;
    uint64_t v18 = 2;
  }
  SafeRelease(v8);
  SafeRelease(theData);
  SafeRelease(v19);
  return v18;
}

uint64_t sub_100014A04(const __CFAllocator *a1, void *data, CC_LONG len, CFDataRef *a4)
{
  CC_SHA1(data, len, md);
  CFDataRef v6 = CFDataCreate(a1, md, 20);
  if (!v6) {
    return 2;
  }
  CFDataRef v7 = v6;
  uint64_t result = 0;
  *a4 = v7;
  return result;
}

uint64_t AMAuthInstallBasebandICE3StitchEbl(uint64_t a1, const __CFData *a2, CFDictionaryRef theDict, CFTypeRef *a4)
{
  CFTypeRef cf = 0;
  CFDataRef theData = 0;
  CFDictionaryRef Value = (void *)CFDictionaryGetValue(theDict, @"BBTicket");
  if (!Value)
  {
    CFAllocatorRef v10 = 0;
    uint64_t v18 = 8;
    goto LABEL_12;
  }
  if (!*(void *)(*(void *)(a1 + 48) + 24))
  {
    uint64_t v18 = 0;
    CFAllocatorRef v10 = 0;
LABEL_11:
    CFDictionaryRef Value = 0;
    goto LABEL_12;
  }
  AMAuthInstallDebugWriteObject((char *)a1, Value, @"BB-Ticket", 1);
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v9 = FlsParserCreate(v8);
  CFAllocatorRef v10 = (PRGSequencer **)v9;
  if (!v9)
  {
    CFDictionaryRef Value = 0;
    goto LABEL_16;
  }
  uint64_t v11 = FlsParserReadFromData(v9, a2);
  if (v11 || (uint64_t v11 = FlsParserCopyEbl(v10, &theData), v11))
  {
    uint64_t v18 = v11;
    goto LABEL_11;
  }
  CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)a1);
  CFDataRef MutableCopy = CFDataCreateMutableCopy(v12, 0, (CFDataRef)Value);
  CFDictionaryRef Value = MutableCopy;
  if (!MutableCopy)
  {
LABEL_16:
    uint64_t v18 = 2;
    goto LABEL_12;
  }
  int Length = CFDataGetLength(MutableCopy);
  CFDataAppendBytes((CFMutableDataRef)Value, byte_10007CAEF, -Length & 3);
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex v16 = CFDataGetLength(theData);
  CFDataAppendBytes((CFMutableDataRef)Value, BytePtr, v16);
  AMAuthInstallDebugWriteObject((char *)a1, Value, @"EBL-Personalized", 1);
  uint64_t v17 = FlsParserReplaceEbl((uint64_t)v10, (const __CFData *)Value);
  if (v17)
  {
    uint64_t v18 = v17;
  }
  else
  {
    uint64_t v18 = FlsParserCopyAsData(v10, &cf);
    if (!v18) {
      *a4 = CFRetain(cf);
    }
  }
LABEL_12:
  SafeRelease(v10);
  SafeRelease(theData);
  SafeRelease(cf);
  SafeRelease(Value);
  return v18;
}

uint64_t AMAuthInstallBasebandICE3MeasureFlashPsi(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  CFDataRef theData = 0;
  value = 0;
  uint64_t v39 = 0;
  CFDataRef v40 = 0;
  CFDataRef v38 = 0;
  CFAllocatorRef v6 = CFGetAllocator(a1);
  uint64_t v7 = FlsParserCreate(v6);
  CFAllocatorRef v8 = (PRGSequencer **)v7;
  if (v7)
  {
    uint64_t v9 = FlsParserReadFromData(v7, a2);
    if (v9
      || (uint64_t v9 = FlsParserCopyFlashPsi(v8, (CFTypeRef *)&theData, (CFTypeRef *)&v40), v9)
      || (CFAllocatorRef v10 = CFGetAllocator(a1),
          uint64_t v11 = CFDataGetBytePtr(theData),
          CFIndex v12 = CFDataGetLength(theData),
          uint64_t v9 = sub_1000144E0(v10, (uint64_t)v11, v12, (CFDataRef *)&v39, (CFStringRef *)&value, v13, v14, v15),
          v9))
    {
      uint64_t v36 = v9;
      CFDataRef v30 = 0;
    }
    else
    {
      CFAllocatorRef v16 = CFGetAllocator(a1);
      BytePtr = (UInt8 *)CFDataGetBytePtr(v40);
      CC_LONG Length = CFDataGetLength(v40);
      uint64_t v19 = sub_100014A04(v16, BytePtr, Length, &v38);
      if (v19)
      {
        uint64_t v36 = v19;
        CFDataRef v30 = v38;
      }
      else
      {
        AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureFlashPsi", (uint64_t)"Version = %@", v20, v21, v22, v23, v24, (char)value);
        CFDictionarySetValue(a3, @"FlashPSI-Version", value);
        AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureFlashPsi", (uint64_t)"Partialuint64_t Digest = %@", v25, v26, v27, v28, v29, (char)v39);
        CFDictionarySetValue(a3, @"FlashPSI-PartialDigest", v39);
        CFDataRef v30 = v38;
        AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureFlashPsi", (uint64_t)"SecPack uint64_t Digest = %@", v31, v32, v33, v34, v35, (char)v38);
        CFDictionarySetValue(a3, @"FlashPSI-SecPackDigest", v30);
        uint64_t v36 = 0;
      }
    }
  }
  else
  {
    CFDataRef v30 = 0;
    uint64_t v36 = 2;
  }
  SafeRelease(v8);
  SafeRelease(value);
  SafeRelease(theData);
  SafeRelease(v40);
  SafeRelease(v39);
  SafeRelease(v30);
  return v36;
}

uint64_t AMAuthInstallBasebandICE3StitchFlashPsi(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  CFTypeRef v17 = 0;
  CFTypeRef v18 = 0;
  CFTypeRef cf = 0;
  if (*(void *)(a1[6] + 24))
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    uint64_t v9 = FlsParserCreate(v8);
    CFAllocatorRef v10 = (PRGSequencer **)v9;
    if (v9)
    {
      uint64_t v11 = FlsParserReadFromData(v9, a2);
      if (v11 || (uint64_t v11 = FlsParserCopyFlashPsi(v10, &v18, 0), v11))
      {
        uint64_t v14 = v11;
        CFDataRef v13 = 0;
      }
      else
      {
        AMAuthInstallDebugWriteObject((char *)a1, v18, @"FlashPsi-Original", 1);
        uint64_t v12 = sub_1000147B0((char *)a1, v18, a3, @"FlashPSI-Blob", &v17);
        CFDataRef v13 = (const __CFData *)v17;
        if (v12
          || (AMAuthInstallDebugWriteObject((char *)a1, v17, @"FlashPsi-Personalized", 1),
              uint64_t v12 = FlsParserReplaceFlashPsi((uint64_t)v10, v13),
              v12))
        {
          uint64_t v14 = v12;
        }
        else
        {
          uint64_t v14 = FlsParserCopyAsData(v10, &cf);
          if (!v14) {
            *a4 = CFRetain(cf);
          }
        }
      }
    }
    else
    {
      CFDataRef v13 = 0;
      uint64_t v14 = 2;
    }
  }
  else
  {
    CFDataRef v13 = 0;
    uint64_t v14 = 0;
    CFAllocatorRef v10 = 0;
  }
  SafeRelease(v10);
  SafeRelease(v18);
  SafeRelease(v13);
  SafeRelease(cf);
  return v14;
}

uint64_t AMAuthInstallBasebandICE3MeasureModemStack(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  CFDataRef v36 = 0;
  CFDataRef theData = 0;
  CFDataRef v34 = 0;
  CFDataRef v35 = 0;
  CFAllocatorRef v6 = CFGetAllocator(a1);
  uint64_t v7 = FlsParserCreate(v6);
  CFAllocatorRef v8 = (PRGSequencer **)v7;
  if (!v7)
  {
    CFDataRef v32 = 0;
    CFDataRef v19 = 0;
    CFStringRef v22 = 0;
LABEL_14:
    uint64_t v31 = 2;
    goto LABEL_8;
  }
  uint64_t v9 = FlsParserReadFromData(v7, a2);
  if (v9 || (uint64_t v9 = FlsParserCopyModemStack(v8, (CFTypeRef *)&theData, (CFTypeRef *)&v36), v9))
  {
    uint64_t v31 = v9;
    CFDataRef v32 = 0;
    CFDataRef v19 = 0;
LABEL_12:
    CFStringRef v22 = 0;
    goto LABEL_8;
  }
  CFAllocatorRef v10 = CFGetAllocator(a1);
  BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
  CC_LONG Length = CFDataGetLength(theData);
  uint64_t v13 = sub_100014A04(v10, BytePtr, Length, &v35);
  CFDataRef v19 = v35;
  if (v13)
  {
    uint64_t v31 = v13;
    CFDataRef v32 = 0;
    goto LABEL_12;
  }
  AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureModemStack", (uint64_t)"uint64_t Digest = %@", v14, v15, v16, v17, v18, (char)v35);
  CFDictionarySetValue(a3, @"ModemStack-Digest", v19);
  CFAllocatorRef v20 = CFGetAllocator(a1);
  CFIndex v21 = CFDataGetLength(theData);
  CFStringRef v22 = CFStringCreateWithFormat(v20, 0, @"0x%08lx", v21);
  if (!v22)
  {
    CFDataRef v32 = 0;
    goto LABEL_14;
  }
  CFDictionarySetValue(a3, @"ModemStack-Length", v22);
  CFAllocatorRef v23 = CFGetAllocator(a1);
  uint64_t v24 = (UInt8 *)CFDataGetBytePtr(v36);
  CC_LONG v25 = CFDataGetLength(v36);
  uint64_t v31 = sub_100014A04(v23, v24, v25, &v34);
  CFDataRef v32 = v34;
  if (!v31)
  {
    AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureModemStack", (uint64_t)"SecPack uint64_t Digest = %@", v26, v27, v28, v29, v30, (char)v34);
    CFDictionarySetValue(a3, @"ModemStack-SecPackDigest", v32);
  }
LABEL_8:
  SafeRelease(v8);
  SafeRelease(theData);
  SafeRelease(v36);
  SafeRelease(v19);
  SafeRelease(v32);
  SafeRelease(v22);
  return v31;
}

uint64_t AMAuthInstallBasebandICE3StitchModemStack(uint64_t a1, CFTypeRef cf, uint64_t a3, CFTypeRef *a4)
{
  if (*(void *)(*(void *)(a1 + 48) + 24)) {
    *a4 = CFRetain(cf);
  }
  return 0;
}

unint64_t AMAuthInstallBasebandICE3MeasureWorld(const void *a1, CFDataRef theData, __CFDictionary *a3)
{
  BytePtr = CFDataGetBytePtr(theData);
  unint64_t result = CFDataGetLength(theData);
  memset(v95, 0, sizeof(v95));
  memset(v94, 0, sizeof(v94));
  if (!result) {
    return result;
  }
  CC_LONG v13 = 0;
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unsigned int v18 = 0;
  unint64_t v19 = 0;
  CFTypeRef cf = 0;
  value = 0;
  while (2)
  {
    CFAllocatorRef v20 = (unsigned int *)&BytePtr[v19];
    switch(*(_DWORD *)&BytePtr[v19])
    {
      case 0xC:
        uint64_t v21 = v20[2];
        if (v21 > 4) {
          goto LABEL_34;
        }
        uint64_t v22 = v20[7];
        CFAllocatorRef v23 = &v95[v21];
        *CFAllocatorRef v23 = &BytePtr[v20[9]];
        v23[1] = v22;
        goto LABEL_11;
      case 0xF:
        uint64_t v21 = v20[2];
        if (v21 > 4)
        {
LABEL_34:
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"UID value of %ld exceeds maximum array bound of %d\n", v8, v9, v10, v11, v12, v21);
          return 10;
        }
        uint64_t v24 = &v94[v21];
        *uint64_t v24 = v20 + 131;
        v24[1] = 1536;
LABEL_11:
        v19 += v20[1];
        if (v19 < result) {
          continue;
        }
        CFDataRef v91 = 0;
        if (!v16) {
          goto LABEL_15;
        }
        CFAllocatorRef v25 = CFGetAllocator(a1);
        unint64_t result = sub_1000144E0(v25, v16, v15, (CFDataRef *)&cf, (CFStringRef *)&value, v26, v27, v28);
        if (result) {
          return result;
        }
        AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"RamPSI Version: %@", v29, v30, v31, v32, v33, (char)value);
        CFDictionarySetValue(a3, @"RamPSI-Version", value);
        CFRelease(value);
        AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"RamPSI PartialDigest: %@", v34, v35, v36, v37, v38, (char)cf);
        CFDictionarySetValue(a3, @"RamPSI-PartialDigest", cf);
        CFRelease(cf);
LABEL_15:
        if (!v14)
        {
LABEL_18:
          if (!v18) {
            return 0;
          }
          uint64_t v46 = v18;
          for (CFIndex i = v17 + 4; ; i += 36)
          {
            uint64_t v48 = *(i - 1);
            uint64_t v49 = *(void **)&v95[v48];
            if (!v49 || (uint64_t v50 = *(void **)&v94[v48]) == 0)
            {
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"one or more elements are missing for TOC with UID = %lx\n", v8, v9, v10, v11, v12, *(i - 1));
              return 10;
            }
            if (*i == 4) {
              break;
            }
            if (*i == 2)
            {
              CFAllocatorRef v51 = CFGetAllocator(a1);
              unint64_t result = sub_1000144E0(v51, (uint64_t)v49, *((void *)&v95[v48] + 1), (CFDataRef *)&cf, (CFStringRef *)&value, v52, v53, v54);
              if (result) {
                return result;
              }
              AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"FlashPSI Version: %@", v55, v56, v57, v58, v59, (char)value);
              CFDictionarySetValue(a3, @"FlashPSI-Version", value);
              CFRelease(value);
              AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"FlashPSI PartialDigest: %@", v60, v61, v62, v63, v64, (char)cf);
              CFDictionarySetValue(a3, @"FlashPSI-PartialDigest", cf);
              CFRelease(cf);
              CFAllocatorRef v65 = CFGetAllocator(a1);
              unint64_t result = sub_100014A04(v65, v50, *((void *)&v94[v48] + 1), &v91);
              if (result) {
                return result;
              }
              CFDataRef v71 = v91;
              AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"FlashPSI SecPack Digest: %@", v66, v67, v68, v69, v70, (char)v91);
              uint64_t v72 = a3;
              CFStringRef v73 = @"FlashPSI-SecPackDigest";
LABEL_31:
              CFDictionarySetValue(v72, v73, v71);
              CFRelease(v71);
            }
            unint64_t result = 0;
            if (!--v46) {
              return result;
            }
          }
          CFAllocatorRef v74 = CFGetAllocator(a1);
          uint64_t v75 = *((void *)&v95[v48] + 1);
          unint64_t result = sub_100014A04(v74, v49, v75, &v91);
          if (result) {
            return result;
          }
          CFDataRef v81 = v91;
          AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"Modem Stack Digest: %@", v76, v77, v78, v79, v80, (char)v91);
          CFDictionarySetValue(a3, @"ModemStack-Digest", v81);
          CFRelease(v81);
          CFAllocatorRef v82 = CFGetAllocator(a1);
          CFStringRef v83 = CFStringCreateWithFormat(v82, 0, @"0x%08lx", v75);
          if (!v83) {
            return 2;
          }
          CFStringRef v84 = v83;
          CFDictionarySetValue(a3, @"ModemStack-Length", v83);
          CFRelease(v84);
          CFAllocatorRef v85 = CFGetAllocator(a1);
          unint64_t result = sub_100014A04(v85, v50, *((void *)&v94[v48] + 1), &v91);
          if (result) {
            return result;
          }
          CFDataRef v71 = v91;
          AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"Modem Stack SecPack Digest: %@", v86, v87, v88, v89, v90, (char)v91);
          uint64_t v72 = a3;
          CFStringRef v73 = @"ModemStack-SecPackDigest";
          goto LABEL_31;
        }
        CFAllocatorRef v39 = CFGetAllocator(a1);
        unint64_t result = sub_100014A04(v39, v14, v13, &v91);
        if (!result)
        {
          CFDataRef v45 = v91;
          AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandICE3MeasureWorld", (uint64_t)"EBL Digest: %@", v40, v41, v42, v43, v44, (char)v91);
          CFDictionarySetValue(a3, @"EBL-Digest", v45);
          CFRelease(v45);
          goto LABEL_18;
        }
        return result;
      case 0x10:
        unsigned int v18 = v20[3];
        uint64_t v17 = &BytePtr[v20[5]];
        goto LABEL_11;
      case 0x12:
        uint64_t v16 = (uint64_t)&BytePtr[v20[7]];
        unint64_t v15 = v20[5];
        goto LABEL_11;
      case 0x13:
        uint64_t v14 = (UInt8 *)&BytePtr[v20[7]];
        CC_LONG v13 = v20[5];
        goto LABEL_11;
      default:
        goto LABEL_11;
    }
  }
}

uint64_t AMAuthInstallBasebandCreatePersonalizedPsiData(const void *a1, const __CFData *a2, const __CFData *a3, __CFData **a4)
{
  CFAllocatorRef v7 = CFGetAllocator(a1);
  CFDataRef MutableCopy = CFDataCreateMutableCopy(v7, 0, a2);
  uint64_t v9 = MutableCopy;
  if (MutableCopy)
  {
    CFIndex Length = CFDataGetLength(MutableCopy);
    CFIndex v11 = CFDataGetLength(a3);
    CFDataSetLength(v9, Length - v11);
    BytePtr = CFDataGetBytePtr(a3);
    CFIndex v13 = CFDataGetLength(a3);
    CFDataAppendBytes(v9, BytePtr, v13);
    uint64_t v14 = 0;
    if (a4)
    {
      *a4 = v9;
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v14 = 2;
  }
  SafeRelease(v9);
  return v14;
}

uint64_t AMAuthInstallBasebandCreatePersonalizedTicketPlusEblData(CFTypeRef cf, const __CFData *a2, const __CFData *a3, __CFData **a4)
{
  uint64_t result = 1;
  if (a2 && a3 && a4)
  {
    CFAllocatorRef v9 = CFGetAllocator(cf);
    CFDataRef MutableCopy = CFDataCreateMutableCopy(v9, 0, a3);
    if (MutableCopy)
    {
      CFIndex v11 = MutableCopy;
      int Length = CFDataGetLength(MutableCopy);
      CFDataAppendBytes(v11, byte_10007CAF3, -Length & 3);
      BytePtr = CFDataGetBytePtr(a2);
      CFIndex v14 = CFDataGetLength(a2);
      CFDataAppendBytes(v11, BytePtr, v14);
      uint64_t result = 0;
      *a4 = v11;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t AMAuthInstallBasebandICE3StitchWorld(void *cf, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  CFTypeRef v29 = 0;
  CFTypeRef v30 = 0;
  CFTypeRef v27 = 0;
  CFDataRef v28 = 0;
  CFTypeRef v25 = 0;
  CFTypeRef v26 = 0;
  CFTypeRef cfa = 0;
  if (!cf || !cf[6])
  {
    uint64_t v10 = 0;
    uint64_t v12 = 1;
    goto LABEL_8;
  }
  CFAllocatorRef v8 = CFGetAllocator(cf);
  uint64_t v9 = FlsParserCreate(v8);
  uint64_t v10 = (PRGSequencer **)v9;
  if (!v9) {
    goto LABEL_33;
  }
  uint64_t PersonalizedPsiData = FlsParserReadFromData(v9, a2);
  if (!PersonalizedPsiData)
  {
    uint64_t PersonalizedPsiData = FlsParserCopyRamPsi(v10, (CFDataRef *)&v30);
    if (!PersonalizedPsiData)
    {
      if (!*(void *)(cf[6] + 24)
        || (uint64_t PersonalizedPsiData = FlsParserCopyFlashPsi(v10, &v29, 0), !PersonalizedPsiData)
        && (uint64_t PersonalizedPsiData = FlsParserCopyEbl(v10, &v28), !PersonalizedPsiData))
      {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a3, @"BasebandFirmware");
        uint64_t v12 = (uint64_t)Value;
        if (!Value)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandICE3StitchWorld", (uint64_t)"server response doesn't contain personalization data", v15, v16, v17, v18, v19, v23);
          goto LABEL_8;
        }
        CFDataRef v20 = (const __CFData *)CFDictionaryGetValue(Value, @"RamPSI-Blob");
        CFDataRef v21 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v12, @"FlashPSI-Blob");
        CFDataRef v22 = (const __CFData *)CFDictionaryGetValue(a3, @"BBTicket");
        if (v30 && v20)
        {
          uint64_t PersonalizedPsiData = AMAuthInstallBasebandCreatePersonalizedPsiData(cf, (const __CFData *)v30, v20, (__CFData **)&v27);
          if (PersonalizedPsiData) {
            goto LABEL_6;
          }
          AMAuthInstallDebugWriteObject((char *)cf, v30, @"rampsi-original", 1);
          AMAuthInstallDebugWriteObject((char *)cf, v20, @"rampsi-stitch", 1);
          AMAuthInstallDebugWriteObject((char *)cf, v27, @"rampsi-personalized", 1);
        }
        if (!v29 || !v21) {
          goto LABEL_21;
        }
        uint64_t PersonalizedPsiData = AMAuthInstallBasebandCreatePersonalizedPsiData(cf, (const __CFData *)v29, v21, (__CFData **)&v26);
        if (!PersonalizedPsiData)
        {
          AMAuthInstallDebugWriteObject((char *)cf, v29, @"flashpsi-original", 1);
          AMAuthInstallDebugWriteObject((char *)cf, v21, @"flashpsi-stitch", 1);
          AMAuthInstallDebugWriteObject((char *)cf, v26, @"flashpsi-personalized", 1);
LABEL_21:
          if (!v28 || !v22)
          {
LABEL_25:
            if (v27) {
              FlsParserReplaceRamPsi((uint64_t)v10, (const __CFData *)v27);
            }
            if (v26) {
              FlsParserReplaceFlashPsi((uint64_t)v10, (const __CFData *)v26);
            }
            if (v25) {
              FlsParserReplaceEbl((uint64_t)v10, (const __CFData *)v25);
            }
            FlsParserCopyAsData(v10, &cfa);
            if (cfa)
            {
              uint64_t v12 = 0;
              *a4 = CFRetain(cfa);
              goto LABEL_8;
            }
LABEL_33:
            uint64_t v12 = 2;
            goto LABEL_8;
          }
          uint64_t PersonalizedPsiData = AMAuthInstallBasebandCreatePersonalizedTicketPlusEblData(cf, v28, v22, (__CFData **)&v25);
          if (!PersonalizedPsiData)
          {
            AMAuthInstallDebugWriteObject((char *)cf, v25, @"ticket-plus-ebl", 1);
            goto LABEL_25;
          }
        }
      }
    }
  }
LABEL_6:
  uint64_t v12 = PersonalizedPsiData;
LABEL_8:
  SafeRelease(v10);
  SafeRelease(v30);
  SafeRelease(v29);
  SafeRelease(v28);
  SafeRelease(v27);
  SafeRelease(v26);
  SafeRelease(v25);
  SafeRelease(cfa);
  return v12;
}

uint64_t AMAuthInstallBasebandICE3CopyNextComponentName(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  uint64_t v8 = *(void *)(a1 + 48);
  if (!v8) {
    return 1;
  }
  if (*(_DWORD *)(v8 + 4) != 80)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandICE3CopyNextComponentName", (uint64_t)"unsupported chipID: 0x%08x", a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 4));
    return 1;
  }
  if (!*(void *)(v8 + 16))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandICE3CopyNextComponentName", (uint64_t)"missing snum", a4, a5, a6, a7, a8, v13);
    return 1;
  }
  if (*(void *)(v8 + 24)) {
    CFStringRef v10 = @"stack.bbfw";
  }
  else {
    CFStringRef v10 = @"boot.bbfw";
  }
  CFTypeRef v11 = CFRetain(v10);
  uint64_t result = 0;
  *a2 = v11;
  return result;
}

uint64_t AMAuthInstallBasebandICE3StitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    uint64_t v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"psi_ram.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandICE3StitchRamPsi, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"ebl.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandICE3StitchEbl, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"psi_flash.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandICE3StitchFlashPsi, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"stack.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandICE3StitchModemStack, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"world.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandICE3StitchWorld, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Options.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
      uint64_t v5 = 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandICE3StitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v9, v10, v11, v12, v13, v15);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

uint64_t AMAuthInstallBasebandICE3MeasureFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  CFDictionaryRef v3 = 0;
  uint64_t v4 = 1;
  if (a1 && cf && a3)
  {
    CFDictionaryRef v3 = BbfwReaderOpen(cf);
    if (!v3)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandICE3MeasureFirmware", (uint64_t)"failed to open bbfw archive for reading", v7, v8, v9, v10, v11, v19);
      uint64_t v4 = 4;
      goto LABEL_10;
    }
    if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"psi_ram.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallBasebandICE3MeasureRamPsi, (uint64_t)v3, a3))
    {
      if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"ebl.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallBasebandICE3MeasureEbl, (uint64_t)v3, a3))
      {
        if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"psi_flash.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallBasebandICE3MeasureFlashPsi, (uint64_t)v3, a3))
        {
          if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"stack.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallBasebandICE3MeasureModemStack, (uint64_t)v3, a3))
          {
            AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"world.fls", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallBasebandICE3MeasureWorld, (uint64_t)v3, a3);
            uint64_t v4 = 0;
            goto LABEL_10;
          }
          uint64_t v18 = "failed to measure: stack.fls";
        }
        else
        {
          uint64_t v18 = "failed to measure: psi_flash.fls";
        }
      }
      else
      {
        uint64_t v18 = "failed to measure: ebl.fls";
      }
    }
    else
    {
      uint64_t v18 = "failed to measure: psi_ram.fls";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandICE3MeasureFirmware", (uint64_t)v18, v12, v13, v14, v15, v16, v19);
    uint64_t v4 = 15;
  }
LABEL_10:
  BbfwReaderClose((uint64_t)v3);
  return v4;
}

BOOL AMAuthInstallBasebandICE3FirmwareSupported(const void *a1)
{
  if (!a1)
  {
    uint64_t v7 = 0;
LABEL_7:
    BOOL v8 = 0;
    goto LABEL_4;
  }
  uint64_t v1 = BbfwReaderOpen(a1);
  uint64_t v7 = (uint64_t)v1;
  if (!v1)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandICE3FirmwareSupported", (uint64_t)"failed to open bbfw archive for reading", v2, v3, v4, v5, v6, v10);
    goto LABEL_7;
  }
  BOOL v8 = BbfwReaderFindFile((uint64_t)v1, @"psi_ram.fls") == 0;
LABEL_4:
  BbfwReaderClose(v7);
  return v8;
}

uint64_t AMAuthInstallBasebandICE3SupportsServerSigning()
{
  return 1;
}

int8x16_t sub_100016080(const void *a1, CC_LONG a2, int8x16_t *a3)
{
  memset(&v7, 0, sizeof(v7));
  CC_SHA1_Init(&v7);
  CC_SHA1_Update(&v7, a1, a2);
  int8x16_t result = vrev32q_s8(*(int8x16_t *)&v7.h0);
  *a3 = result;
  a3[1].i32[0] = bswap32(v7.h4);
  return result;
}

uint64_t AMAuthInstallBasebandJ2StitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    uint64_t v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"ENPRG.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchENandprog, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"dbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchDbl, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"osbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"amss.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"dsp1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"dsp2.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"partition.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchPartitionTable, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Options.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
      uint64_t v5 = 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandJ2StitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v9, v10, v11, v12, v13, v15);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

uint64_t AMAuthInstallBasebandJ2MeasureFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 1;
  if (a1 && cf && a3)
  {
    uint64_t v3 = BbfwReaderOpen(cf);
    if (v3)
    {
      if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"ENPRG.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureENandprog, (uint64_t)v3, a3))
      {
        if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"dbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureDbl, (uint64_t)v3, a3))
        {
          if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"osbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureOsbl, (uint64_t)v3, a3))
          {
            if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"amss.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureAmss, (uint64_t)v3, a3))
            {
              if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"dsp1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureDsp1, (uint64_t)v3, a3))
              {
                if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"dsp2.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureDsp2, (uint64_t)v3, a3))
                {
                  if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"partition.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasurePartitionTable, (uint64_t)v3, a3))
                  {
                    uint64_t v4 = 0;
                    goto LABEL_13;
                  }
                  uint64_t v4 = 15;
                  uint64_t v13 = "failed to measure: partition.mbn";
                }
                else
                {
                  uint64_t v4 = 15;
                  uint64_t v13 = "failed to measure: dsp2.mbn";
                }
              }
              else
              {
                uint64_t v4 = 15;
                uint64_t v13 = "failed to measure: dsp1.mbn";
              }
            }
            else
            {
              uint64_t v4 = 15;
              uint64_t v13 = "failed to measure: amss.mbn";
            }
          }
          else
          {
            uint64_t v4 = 15;
            uint64_t v13 = "failed to measure: osbl.mbn";
          }
        }
        else
        {
          uint64_t v4 = 15;
          uint64_t v13 = "failed to measure: dbl.mbn";
        }
      }
      else
      {
        uint64_t v4 = 15;
        uint64_t v13 = "failed to measure: ENPRG.mbn";
      }
    }
    else
    {
      uint64_t v4 = 4;
      uint64_t v13 = "failed to open bbfw archive for reading";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandJ2MeasureFirmware", (uint64_t)v13, v7, v8, v9, v10, v11, v14);
  }
LABEL_13:
  BbfwReaderClose((uint64_t)v3);
  return v4;
}

uint64_t AMAuthInstallBasebandJ2SupportsServerSigning()
{
  return 1;
}

uint64_t AMAuthInstallBasebandMAV10StitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    uint64_t v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"sbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restoresbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchRestoreSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"acdb.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"apps.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"dsp3.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"mba.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"qdsp6sw.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"rpm.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"tz.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"wdt.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"bbcfg.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Options.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
      uint64_t v5 = 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandMAV10StitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v9, v10, v11, v12, v13, v15);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

uint64_t AMAuthInstallBasebandMAV10MeasureFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 1;
  if (a1 && cf && a3)
  {
    uint64_t v3 = BbfwReaderOpen(cf);
    if (!v3)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandMAV10MeasureFirmware", (uint64_t)"failed to open bbfw archive for reading", v7, v8, v9, v10, v11, v27);
      uint64_t v4 = 4;
      goto LABEL_35;
    }
    if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"acdb.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureAcdb, (uint64_t)v3, a3))AMAuthInstallLog(4, (uint64_t)"AMAuthInstallBasebandMAV10MeasureFirmware", (uint64_t)"missing acdb or failed to measure image", v12, v13, v14, v15, v16, v27); {
    if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"apps.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureApps, (uint64_t)v3, a3))goto LABEL_36;
    }
    int v17 = *(_DWORD *)(*(void *)(a1 + 48) + 4);
    if (v17 != 241889
      && v17 != 520417
      && v17 != 9781473
      && !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"dsp3.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureDsp3, (uint64_t)v3, a3))
    {
      goto LABEL_36;
    }
    if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"mba.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureMba, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"qdsp6sw.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureQdsp6, (uint64_t)v3, a3))
    {
      goto LABEL_36;
    }
    int v18 = *(_DWORD *)(*(void *)(a1 + 48) + 4);
    if (v18 == 241889 || v18 == 9781473 || v18 == 520417)
    {
      if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"restoresbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureRestoreSbl1Elf, (uint64_t)v3, a3))goto LABEL_36; {
      CFStringRef v19 = @"Info.plist";
      }
      CFDataRef v20 = (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallBasebandGetRestoreSbl1Version;
    }
    else
    {
      CFStringRef v19 = @"restoresbl1.mbn";
      CFDataRef v20 = (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureRestoreSbl1;
    }
    if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, v19, v20, (uint64_t)v3, a3)
      || !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"rpm.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureRpmElf, (uint64_t)v3, a3))
    {
      goto LABEL_36;
    }
    int v21 = *(_DWORD *)(*(void *)(a1 + 48) + 4);
    if (v21 == 241889 || v21 == 9781473 || v21 == 520417)
    {
      if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"sbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureSbl1Elf, (uint64_t)v3, a3))goto LABEL_36; {
      CFStringRef v22 = @"Info.plist";
      }
      char v23 = (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallBasebandGetSbl1Version;
    }
    else
    {
      CFStringRef v22 = @"sbl1.mbn";
      char v23 = (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureSbl1;
    }
    if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, v22, v23, (uint64_t)v3, a3)
      && AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"tz.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureTz, (uint64_t)v3, a3))
    {
      int v24 = *(_DWORD *)(*(void *)(a1 + 48) + 4);
      CFTypeRef v25 = (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureWdt;
      if (v24 != 8343777)
      {
        if (v24 != 9572577)
        {
LABEL_34:
          AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"bbcfg.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureBBCFG, (uint64_t)v3, a3);
          uint64_t v4 = 0;
          goto LABEL_35;
        }
        CFTypeRef v25 = (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureWdtElf;
      }
      if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"wdt.mbn", v25, (uint64_t)v3, a3)) {
        goto LABEL_34;
      }
    }
LABEL_36:
    uint64_t v4 = 15;
  }
LABEL_35:
  BbfwReaderClose((uint64_t)v3);
  return v4;
}

uint64_t AMAuthInstallBasebandMAV10SupportsServerSigning()
{
  return 1;
}

uint64_t AMAuthInstallBasebandMAV20StitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    uint64_t v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"acdb.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"aop.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"apdp.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"apps.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"bbcfg.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"devcfg.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"hyp.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"qdsp6sw.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"sec.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restoresbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchRestoreSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"sbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"multi_image.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchMisc, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"multi_image_qti.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"tz.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Info.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
      uint64_t v5 = 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandMAV20StitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v9, v10, v11, v12, v13, v15);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

uint64_t AMAuthInstallBasebandMAV20MeasureFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 1;
  if (a1 && cf && a3)
  {
    uint64_t v3 = BbfwReaderOpen(cf);
    if (v3)
    {
      if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"acdb.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureAcdb, (uint64_t)v3, a3))AMAuthInstallLog(4, (uint64_t)"AMAuthInstallBasebandMAV20MeasureFirmware", (uint64_t)"missing acdb or failed to measure image", v12, v13, v14, v15, v16, v18); {
      if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"restoresbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureMav20RestoreSbl1Elf, (uint64_t)v3, a3)&& AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"Info.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallBasebandGetRestoreSbl1Version, (uint64_t)v3, a3)&& AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"sbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureMav20Sbl1Elf, (uint64_t)v3,
      }
                           a3)
        && AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"multi_image.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureMav20MiscElf, (uint64_t)v3, a3)&& AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"Info.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallBasebandGetSbl1Version, (uint64_t)v3, a3))
      {
        AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"bbcfg.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureBBCFG, (uint64_t)v3, a3);
        uint64_t v4 = 0;
      }
      else
      {
        uint64_t v4 = 15;
      }
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandMAV20MeasureFirmware", (uint64_t)"failed to open bbfw archive for reading", v7, v8, v9, v10, v11, v18);
      uint64_t v4 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v3);
  return v4;
}

uint64_t AMAuthInstallBasebandMAV20SupportsServerSigning()
{
  return 1;
}

uint64_t AMAuthInstallBasebandMAV21StitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    uint64_t v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"acdb.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"aop.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"apdp.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"apps.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"bbcfg.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"devcfg.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"hyp.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"qdsp6sw.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"sec.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restoresbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchRestoreSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"sbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"multi_image.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchMisc, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"multi_image_qti.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"tz.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Info.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"xbl_cfg.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      uint64_t v5 = 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandMAV21StitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v9, v10, v11, v12, v13, v15);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

uint64_t AMAuthInstallBasebandMAV21SupportsServerSigning()
{
  return 1;
}

uint64_t AMAuthInstallBasebandN41StitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    uint64_t v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"sbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"sbl2.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"rpm.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"apps.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"dsp1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"dsp2.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"dsp3.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restoresbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchRestoreSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Options.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
      uint64_t v5 = 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandN41StitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v9, v10, v11, v12, v13, v15);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

uint64_t AMAuthInstallBasebandN41MeasureFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 1;
  if (a1 && cf && a3)
  {
    uint64_t v3 = BbfwReaderOpen(cf);
    if (v3)
    {
      if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"sbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureSbl1, (uint64_t)v3, a3)&& AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"sbl2.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureSbl2, (uint64_t)v3, a3)&& AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"rpm.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureRPM, (uint64_t)v3,
                           a3)
        && AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"apps.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureApps, (uint64_t)v3, a3)&& AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"dsp1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureDsp1, (uint64_t)v3, a3)&& AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"dsp2.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureDsp2, (uint64_t)v3,
                           a3))
      {
        uint64_t v4 = 15;
        if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"dsp3.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureDsp3, (uint64_t)v3, a3))
        {
          if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"restoresbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureRestoreSbl1, (uint64_t)v3, a3))uint64_t v4 = 0; {
          else
          }
            uint64_t v4 = 15;
        }
      }
      else
      {
        uint64_t v4 = 15;
      }
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandN41MeasureFirmware", (uint64_t)"failed to open bbfw archive for reading", v7, v8, v9, v10, v11, v13);
      uint64_t v4 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v3);
  return v4;
}

uint64_t AMAuthInstallBasebandN41SupportsLocalSigning(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(int **)(a1 + 48);
  int v9 = *v8;
  int v10 = v8[2];
  BOOL v11 = v9 == 3 && v10 == 398790697;
  uint64_t v12 = v11;
  if (v11)
  {
    char v13 = "local signing is enabled";
  }
  else
  {
    char v15 = v9;
    char v13 = "local signing is disabled. vendorID=%d certID=%d";
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandN41SupportsLocalSigning", (uint64_t)v13, a4, a5, a6, a7, a8, v15);
  return v12;
}

uint64_t AMAuthInstallBasebandN41SupportsServerSigning()
{
  return 1;
}

uint64_t AMAuthInstallBasebandN92StitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    uint64_t v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"ENPRG.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchENandprog, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"dbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchDbl, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"osbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"amss.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"partition.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchPartitionTable, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Options.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
      uint64_t v5 = 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandN92StitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v9, v10, v11, v12, v13, v15);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

uint64_t AMAuthInstallBasebandN92MeasureFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 1;
  if (a1 && cf && a3)
  {
    uint64_t v3 = BbfwReaderOpen(cf);
    if (v3)
    {
      if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"ENPRG.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureENandprog, (uint64_t)v3, a3))
      {
        if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"dbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureDbl, (uint64_t)v3, a3))
        {
          if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"osbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureOsbl, (uint64_t)v3, a3))
          {
            if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"amss.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureAmss, (uint64_t)v3, a3))
            {
              if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"partition.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasurePartitionTable, (uint64_t)v3, a3))
              {
                uint64_t v4 = 0;
                goto LABEL_11;
              }
              uint64_t v4 = 15;
              uint64_t v13 = "failed to measure: partition.mbn";
            }
            else
            {
              uint64_t v4 = 15;
              uint64_t v13 = "failed to measure: amss.mbn";
            }
          }
          else
          {
            uint64_t v4 = 15;
            uint64_t v13 = "failed to measure: osbl.mbn";
          }
        }
        else
        {
          uint64_t v4 = 15;
          uint64_t v13 = "failed to measure: dbl.mbn";
        }
      }
      else
      {
        uint64_t v4 = 15;
        uint64_t v13 = "failed to measure: ENPRG.mbn";
      }
    }
    else
    {
      uint64_t v4 = 4;
      uint64_t v13 = "failed to open bbfw archive for reading";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandN92MeasureFirmware", (uint64_t)v13, v7, v8, v9, v10, v11, v14);
  }
LABEL_11:
  BbfwReaderClose((uint64_t)v3);
  return v4;
}

uint64_t AMAuthInstallBasebandN92SupportsServerSigning()
{
  return 1;
}

uint64_t AMAuthInstallBasebandN92LocalProvisionDevice(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  AMAuthInstallMonetLocalSetProvisioningManifestInfo();
  *(unsigned char *)(a1 + 256) = 0;
  return AMAuthInstallMonetLocalProvisionDevice();
}

uint64_t AMAuthInstallBasebandN94StitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    uint64_t v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"dbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchEDbl, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restoredbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchRestoreDbl, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"osbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"amss.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Options.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
      uint64_t v5 = 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandN94StitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v9, v10, v11, v12, v13, v15);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

uint64_t AMAuthInstallBasebandN94MeasureFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 1;
  if (a1 && cf && a3)
  {
    uint64_t v3 = BbfwReaderOpen(cf);
    if (v3)
    {
      if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"dbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureEDbl, (uint64_t)v3, a3))
      {
        if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"restoredbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureRestoreDbl, (uint64_t)v3, a3))
        {
          if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"osbl.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureOsbl, (uint64_t)v3, a3))
          {
            if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"amss.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallMonetMeasureAmss, (uint64_t)v3, a3))
            {
              uint64_t v4 = 0;
              goto LABEL_10;
            }
            uint64_t v4 = 15;
            uint64_t v13 = "failed to measure: amss.mbn";
          }
          else
          {
            uint64_t v4 = 15;
            uint64_t v13 = "failed to measure: osbl.mbn";
          }
        }
        else
        {
          uint64_t v4 = 15;
          uint64_t v13 = "failed to measure: restoredbl.mbn";
        }
      }
      else
      {
        uint64_t v4 = 15;
        uint64_t v13 = "failed to measure: dbl.mbn";
      }
    }
    else
    {
      uint64_t v4 = 4;
      uint64_t v13 = "failed to open bbfw archive for reading";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandN94MeasureFirmware", (uint64_t)v13, v7, v8, v9, v10, v11, v14);
  }
LABEL_10:
  BbfwReaderClose((uint64_t)v3);
  return v4;
}

uint64_t AMAuthInstallBasebandN94SupportsServerSigning()
{
  return 1;
}

uint64_t AMAuthInstallIsICE19BBGoldCertIDECDSA(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMAuthInstallLog(6, (uint64_t)"AMAuthInstallIsICE19BBGoldCertIDECDSA", (uint64_t)"GoldCertId: %X\n", a4, a5, a6, a7, a8, a1);
  BOOL v9 = a1 == 653523660 || a1 == 1559424078;
  return a1 == -2087094182 || v9;
}

uint64_t AMAuthInstallBasebandRembrandtStitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    uint64_t v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v16 = *(void *)(a1 + 48);
      switch(*(_DWORD *)(v16 + 4))
      {
        case '^':
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedPSI, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restorepsi.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedRestorePSI, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"TDSFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"LTEFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"bbcfg.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"3GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"2GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"RFFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"AudioFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Debug_info.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"RPCU.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"DPC.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"CDMA2KFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          CFStringRef v17 = @"custpack.elf";
          goto LABEL_15;
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedPSI, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restorepsi.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedRestorePSI, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"TDSFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"LTEFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          CFStringRef v17 = @"bbcfg.bin";
          goto LABEL_15;
        case 'e':
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedPSI, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restorepsi.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedRestorePSI, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"TDSFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"LTEFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"bbcfg.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"3GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"2GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"RFFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"AudioFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          CFStringRef v17 = @"Debug_info.elf";
          goto LABEL_15;
        case 'g':
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedPSI, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restorepsi.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedRestorePSI, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"LTEFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"bbcfg.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"3GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"RFFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"AudioFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Debug_info.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"GNSS_FW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          CFStringRef v17 = @"irx_coefficient.elf";
          goto LABEL_15;
        case 'h':
          if (AMAuthInstallIsICE19BBGoldCertIDECDSA(*(_DWORD *)(v16 + 8), v9, v10, v11, v12, v13, v14, v15))
          {
            AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedPSI, (uint64_t)v4, a3, a4);
            CFStringRef v18 = @"restorepsi.bin";
            CFStringRef v19 = (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedRestorePSI;
          }
          else
          {
            AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"psi_ram2.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedPSI2, (uint64_t)v4, a3, a4);
            CFStringRef v18 = @"restorepsi2.bin";
            CFStringRef v19 = (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallRembrandtCreateStitchedRestorePSI2;
          }
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, v18, v19, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"bbcfg.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"RFFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"custpack.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"TPCU.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"upc.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"legacy_rat_fw.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          CFStringRef v17 = @"ant_cfg_data.elf";
LABEL_15:
          AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, v17, (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
          uint64_t v5 = 0;
          break;
        default:
          break;
      }
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandRembrandtStitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v11, v12, v13, v14, v15, v21);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

uint64_t AMAuthInstallBasebandRembrandtMeasureFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 1;
  if (a1 && cf && a3)
  {
    uint64_t v3 = BbfwReaderOpen(cf);
    if (v3)
    {
      uint64_t v4 = 0;
      switch(*(_DWORD *)(*(void *)(a1 + 48) + 4))
      {
        case '^':
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasurePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"restorepsi.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRestorePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureEBL, (uint64_t)v3,
                                a3))
          {
            goto LABEL_72;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureSystemSoftware, (uint64_t)v3, a3))goto LABEL_74; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"TDSFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureTDS, (uint64_t)v3, a3))goto LABEL_78;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"LTEFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureLTE, (uint64_t)v3, a3))goto LABEL_76; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"bbcfg.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureBBCFG, (uint64_t)v3, a3))goto LABEL_75;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"3GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasure3GFW, (uint64_t)v3, a3))goto LABEL_79; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"2GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasure2GFW, (uint64_t)v3, a3))goto LABEL_82;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"RFFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRFFW, (uint64_t)v3, a3))goto LABEL_77; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"AudioFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureAudioFW, (uint64_t)v3, a3))goto LABEL_80;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"Debug_info.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureDebugInfo, (uint64_t)v3, a3))goto LABEL_81; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"RPCU.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRPCU, (uint64_t)v3, a3))
          }
          {
            uint64_t v4 = 15;
            uint64_t v12 = "failed to measure: RPCU.elf";
            break;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"DPC.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureDPC, (uint64_t)v3, a3))
          {
            uint64_t v4 = 15;
            uint64_t v12 = "failed to measure: DPC.elf";
            break;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"CDMA2KFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureC2K, (uint64_t)v3, a3))
          {
            uint64_t v4 = 15;
            uint64_t v12 = "failed to measure: CDMA2KFW.elf";
            break;
          }
          if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"custpack.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasurecustpack, (uint64_t)v3, a3))goto LABEL_70; {
          goto LABEL_83;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasurePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"restorepsi.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRestorePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureEBL, (uint64_t)v3,
                                a3))
          {
            goto LABEL_72;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureSystemSoftware, (uint64_t)v3, a3))goto LABEL_74; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"TDSFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureTDS, (uint64_t)v3, a3))goto LABEL_78;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"LTEFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureLTE, (uint64_t)v3, a3))goto LABEL_76; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"bbcfg.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureBBCFG, (uint64_t)v3, a3))goto LABEL_75;
          }
          goto LABEL_70;
        case 'e':
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasurePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"restorepsi.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRestorePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureEBL, (uint64_t)v3,
                                a3))
          {
            goto LABEL_72;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureSystemSoftware, (uint64_t)v3, a3))goto LABEL_74; {
          if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"TDSFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureTDS, (uint64_t)v3, a3))
          }
          {
            if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"LTEFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureLTE, (uint64_t)v3, a3))
            {
              if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"bbcfg.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureBBCFG, (uint64_t)v3, a3))goto LABEL_75; {
              if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"3GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasure3GFW, (uint64_t)v3, a3))
              }
              {
                if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"2GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasure2GFW, (uint64_t)v3, a3))
                {
                  if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"RFFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRFFW, (uint64_t)v3, a3))goto LABEL_77; {
                  if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"AudioFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureAudioFW, (uint64_t)v3, a3))
                  }
                  {
                    if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"Debug_info.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureDebugInfo, (uint64_t)v3, a3))goto LABEL_70; {
LABEL_81:
                    }
                    uint64_t v4 = 15;
                    uint64_t v12 = "failed to measure: Debug_info.elf";
                  }
                  else
                  {
LABEL_80:
                    uint64_t v4 = 15;
                    uint64_t v12 = "failed to measure: AudioFW.elf";
                  }
                }
                else
                {
LABEL_82:
                  uint64_t v4 = 15;
                  uint64_t v12 = "failed to measure: 2GFW.elf";
                }
              }
              else
              {
LABEL_79:
                uint64_t v4 = 15;
                uint64_t v12 = "failed to measure: 3GFW.elf";
              }
            }
            else
            {
LABEL_76:
              uint64_t v4 = 15;
              uint64_t v12 = "failed to measure: LTE.elf";
            }
          }
          else
          {
LABEL_78:
            uint64_t v4 = 15;
            uint64_t v12 = "failed to measure: TDS.elf";
          }
          break;
        case 'g':
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasurePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"restorepsi.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRestorePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureEBL, (uint64_t)v3,
                                a3))
          {
            goto LABEL_72;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureSystemSoftware, (uint64_t)v3, a3))goto LABEL_74; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"LTEFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureLTE, (uint64_t)v3, a3))goto LABEL_76;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"bbcfg.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureBBCFG, (uint64_t)v3, a3))goto LABEL_75; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"3GFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasure3GFW, (uint64_t)v3, a3))goto LABEL_79;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"RFFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRFFW, (uint64_t)v3, a3))goto LABEL_77; {
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"AudioFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureAudioFW, (uint64_t)v3, a3))goto LABEL_80;
          }
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"Debug_info.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureDebugInfo, (uint64_t)v3, a3))goto LABEL_81; {
          if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"GNSS_FW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureGNSSFW, (uint64_t)v3, a3))
          }
          {
            if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"irx_coefficient.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureIRXCoefficient, (uint64_t)v3, a3))goto LABEL_70; {
            uint64_t v4 = 15;
            }
            uint64_t v12 = "failed to measure: irx_coefficient.elf";
          }
          else
          {
            uint64_t v4 = 15;
            uint64_t v12 = "failed to measure: GNSS_FW.elf";
          }
          break;
        case 'h':
          if (!AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"psi_ram.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasurePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"restorepsi.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRestorePSI, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(0, a1, @"psi_ram2.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasurePSI2, (uint64_t)v3,
                                a3)
            || !AMAuthInstallBasebandMeasureFirmwareFromBbfw(0, a1, @"restorepsi2.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRestorePSI2, (uint64_t)v3, a3)|| !AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"ebl.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureEBL, (uint64_t)v3, a3))
          {
LABEL_72:
            uint64_t v4 = 15;
            goto LABEL_71;
          }
          if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"SYS_SW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureSystemSoftware, (uint64_t)v3, a3))
          {
            if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"bbcfg.bin", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureBBCFG, (uint64_t)v3, a3))
            {
              if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"RFFW.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureRFFW, (uint64_t)v3, a3))
              {
                if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"custpack.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasurecustpack, (uint64_t)v3, a3))
                {
                  if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"ant_cfg_data.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureAntCfg, (uint64_t)v3, a3))
                  {
                    if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"TPCU.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureTPCU, (uint64_t)v3, a3))
                    {
                      if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"upc.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureUPC, (uint64_t)v3, a3))
                      {
                        if (AMAuthInstallBasebandMeasureFirmwareFromBbfw(1, a1, @"legacy_rat_fw.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t))AMAuthInstallRembrandtMeasureLegacyRat, (uint64_t)v3, a3))
                        {
LABEL_70:
                          uint64_t v4 = 0;
                          goto LABEL_71;
                        }
                        uint64_t v4 = 15;
                        uint64_t v12 = "failed to measure: legacy_rat_fw.elf";
                      }
                      else
                      {
                        uint64_t v4 = 15;
                        uint64_t v12 = "failed to measure: upc.elf";
                      }
                    }
                    else
                    {
                      uint64_t v4 = 15;
                      uint64_t v12 = "failed to measure: TPCU.elf";
                    }
                  }
                  else
                  {
                    uint64_t v4 = 15;
                    uint64_t v12 = "failed to measure: ant_cfg_data.elf";
                  }
                }
                else
                {
LABEL_83:
                  uint64_t v4 = 15;
                  uint64_t v12 = "failed to measure: custpack.elf";
                }
              }
              else
              {
LABEL_77:
                uint64_t v4 = 15;
                uint64_t v12 = "failed to measure: RFFW.elf";
              }
            }
            else
            {
LABEL_75:
              uint64_t v4 = 15;
              uint64_t v12 = "failed to measure: bbcfg.bin";
            }
          }
          else
          {
LABEL_74:
            uint64_t v4 = 15;
            uint64_t v12 = "failed to measure: SYS_SW.elf";
          }
          break;
        default:
          goto LABEL_71;
      }
    }
    else
    {
      uint64_t v4 = 4;
      uint64_t v12 = "failed to open bbfw archive for reading";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandRembrandtMeasureFirmware", (uint64_t)v12, v7, v8, v9, v10, v11, v14);
  }
LABEL_71:
  BbfwReaderClose((uint64_t)v3);
  return v4;
}

uint64_t AMAuthInstallBasebandRembrandtFuseIfNecessary()
{
  return 0;
}

uint64_t AMAuthInstallBasebandRembrandtSupportsLocalSigning()
{
  return 1;
}

uint64_t AMAuthInstallBasebandRembrandtSupportsServerSigning(uint64_t a1)
{
  int v1 = *(_DWORD *)(*(void *)(a1 + 48) + 4) - 94;
  if (v1 > 0xA) {
    return 0;
  }
  else {
    return byte_10007CAF7[v1];
  }
}

uint64_t AMAuthInstallBasebandRembrandtLocalProvisionDevice()
{
  return 13;
}

uint64_t AMAuthInstallBasebandVinylStitchFirmware(void *a1, const void *a2, const void *a3, const __CFDictionary *a4, __CFDictionary *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a1[6]) {
    return 1;
  }
  CFDataRef MutableCopy = 0;
  v37[1] = a5;
  uint64_t v38 = 0;
  v37[0] = a1;
  BOOL v11 = a2 != 0;
  if (a3) {
    BOOL v11 = 0;
  }
  LOBYTE(v38) = v11;
  if (a3) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = a2;
  }
  uint64_t v13 = 1;
  if (!a5 || !a4)
  {
    CFDataRef v15 = 0;
    CFStringRef v16 = 0;
    goto LABEL_25;
  }
  CFDataRef v15 = 0;
  CFStringRef v16 = 0;
  if (v12)
  {
    uint64_t v17 = BbfwReaderStart(v12, (uint64_t (*)(uint64_t, CFStringRef, void *))sub_100019BEC, (uint64_t)v37);
    if (v17)
    {
      uint64_t v13 = v17;
      AMAuthInstallLog(3, (uint64_t)"_VinylStitchInternal", (uint64_t)"Failed to copy unperso'd Vinyl files", v18, v19, v20, v21, v22, v35);
    }
    else
    {
      if (!*(void *)(a1[6] + 160))
      {
        CFDataRef MutableCopy = 0;
        CFDataRef v15 = 0;
        CFStringRef v16 = 0;
        goto LABEL_22;
      }
      BOOL v36 = 0;
      uint64_t IsLegacyChipId = AMAuthInstallVinylIsLegacyChipId(a1, &v36);
      if (!IsLegacyChipId)
      {
        if (v36)
        {
          CFDataRef MutableCopy = 0;
          CFDataRef v15 = 0;
          CFStringRef v16 = @"vinyl";
LABEL_22:
          uint64_t v26 = sub_100019CF0(v16, @"/update/main/ticket.der", a4, @"EuiccMainTicket", a5);
          if (!v26) {
            uint64_t v26 = sub_100019CF0(v16, @"/update/gold/ticket.der", a4, @"EuiccGoldTicket", a5);
          }
          uint64_t v13 = v26;
          goto LABEL_25;
        }
        CFDataRef v24 = *(const __CFData **)(a1[6] + 152);
        if (v24)
        {
          CFDataRef MutableCopy = CFDataCreateMutableCopy(kCFAllocatorDefault, 0, v24);
          if (MutableCopy)
          {
            CFDataRef v25 = *(const __CFData **)(a1[6] + 168);
            if (!v25 || AMAuthInstallVinylCheckVinylFwLdrVerLegacy(v25))
            {
              CFStringRef v16 = (const __CFString *)_CopyHexStringFromData(kCFAllocatorDefault, MutableCopy);
              CFDataRef v15 = 0;
              if (v16) {
                goto LABEL_22;
              }
              goto LABEL_29;
            }
            BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1[6] + 168));
            CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1[6] + 168));
            CFDataAppendBytes(MutableCopy, BytePtr, Length - 1);
            CFDataGetBytePtr(MutableCopy);
            CFDataGetLength(MutableCopy);
            if (!AMSupportDigestSha256())
            {
              CFDataRef v15 = CFDataCreate(kCFAllocatorDefault, bytes, 32);
              CFStringRef v16 = (const __CFString *)_CopyHexStringFromData(kCFAllocatorDefault, v15);
              if (v16) {
                goto LABEL_22;
              }
LABEL_29:
              uint64_t v13 = 2;
              goto LABEL_25;
            }
            AMAuthInstallLog(3, (uint64_t)"_VinylStitchInternal", (uint64_t)"failed to compute digest", v30, v31, v32, v33, v34, v35);
            uint64_t v13 = 5;
          }
          else
          {
            uint64_t v13 = 2;
          }
        }
        else
        {
          CFDataRef MutableCopy = 0;
          uint64_t v13 = 8;
        }
LABEL_35:
        CFDataRef v15 = 0;
        CFStringRef v16 = 0;
        goto LABEL_25;
      }
      uint64_t v13 = IsLegacyChipId;
    }
    CFDataRef MutableCopy = 0;
    goto LABEL_35;
  }
LABEL_25:
  AMAuthInstallLog(6, (uint64_t)"_VinylStitchInternal", (uint64_t)"%d", (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v13);
  SafeRelease(MutableCopy);
  SafeRelease(v16);
  SafeRelease(v15);
  return v13;
}

uint64_t AMAuthInstallBasebandVinylCreateMeasurements(uint64_t a1, CFTypeRef cf, __CFDictionary *a3)
{
  value = 0;
  v16[0] = @"EUICCSignedProfileMain";
  v16[1] = @"vinyl/update/main/signedprofile.der";
  void v16[2] = @"EUICCSignedProfileGold";
  v16[3] = @"vinyl/update/gold/signedprofile.der";
  if (a1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 1;
    if (a3 && cf && *(void *)(a1 + 48))
    {
      uint64_t v4 = BbfwReaderOpen(cf);
      if (v4)
      {
        uint64_t v11 = 0;
        char v12 = 1;
        do
        {
          char v13 = v12;
          if (!BbfwReaderFindAndCopyFileData((uint64_t)v4, (const __CFString *)v16[2 * v11 + 1], (CFTypeRef *)&value))
          {
            CFDictionarySetValue(a3, (const void *)v16[2 * v11], value);
            SafeRelease(value);
            value = 0;
          }
          char v12 = 0;
          uint64_t v11 = 1;
        }
        while ((v13 & 1) != 0);
        uint64_t v5 = 0;
      }
      else
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandVinylCreateMeasurements", (uint64_t)"failed to open bbfw archive for reading", v6, v7, v8, v9, v10, (char)value);
        uint64_t v5 = 4;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = 1;
  }
  BbfwReaderClose((uint64_t)v4);
  SafeRelease(value);
  return v5;
}

uint64_t AMAuthInstallBasebandVinylAddMeasurementTags(uint64_t a1, CFDictionaryRef theDict)
{
  if (!a1) {
    return 1;
  }
  if (!*(void *)(a1 + 48)) {
    return 1;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"BasebandFirmware");
  if (Value)
  {
    CFTypeID TypeID = CFDictionaryGetTypeID();
    LODWORD(Value) = TypeID == CFGetTypeID(Value)
                  && CFDictionaryContainsKey((CFDictionaryRef)Value, @"EUICCSignedProfileMain") != 0;
  }
  AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBasebandVinylAddMeasurementTags", (uint64_t)"Vinyl Tags %d Measurements %d", v4, v5, v6, v7, v8, *(void *)(*(void *)(a1 + 48) + 120) != 0);
  uint64_t v11 = *(void **)(a1 + 48);
  char v12 = (const void *)v11[15];
  if (!v12 || !v11[16]) {
    return 8;
  }
  uint64_t result = 8;
  if (Value && v11[19])
  {
    CFDictionarySetValue(theDict, @"EUICCCSN", v12);
    char v14 = *(void **)(a1 + 48);
    CFDataRef v15 = (const void *)v14[16];
    if (v15)
    {
      CFDictionarySetValue(theDict, @"EUICCMainNonce", v15);
      char v14 = *(void **)(a1 + 48);
    }
    CFStringRef v16 = (const void *)v14[17];
    if (v16)
    {
      CFDictionarySetValue(theDict, @"EUICCGoldNonce", v16);
      char v14 = *(void **)(a1 + 48);
    }
    uint64_t v17 = (const void *)v14[18];
    if (v17)
    {
      CFDictionarySetValue(theDict, @"EUICCTicketVersion", v17);
      char v14 = *(void **)(a1 + 48);
    }
    uint64_t v18 = (const void *)v14[19];
    if (v18)
    {
      CFDictionarySetValue(theDict, @"EUICCCertIdentifier", v18);
      char v14 = *(void **)(a1 + 48);
    }
    uint64_t v19 = (const void *)v14[20];
    if (v19)
    {
      CFDictionarySetValue(theDict, @"EUICCChipID", v19);
      char v14 = *(void **)(a1 + 48);
    }
    uint64_t v20 = (const void *)v14[21];
    if (v20) {
      CFDictionarySetValue(theDict, @"EUICCFirmwareLoaderVersion", v20);
    }
    CFDictionarySetValue(theDict, @"@EUICCTicket", kCFBooleanTrue);
    return 0;
  }
  return result;
}

uint64_t sub_100019BEC(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  value = 0;
  if (!a1 || !*(void *)a1 || !theString || !a3 || !*(void *)(a1 + 8))
  {
    uint64_t v18 = "Null inputs";
LABEL_15:
    AMAuthInstallLog(3, (uint64_t)"_VinylBBFWReaderCB", (uint64_t)v18, a4, a5, a6, a7, a8, v19);
    uint64_t v16 = 0;
    goto LABEL_10;
  }
  if (*(unsigned char *)(a1 + 16) && !CFStringHasPrefix(theString, @"vinyl")) {
    return 1;
  }
  if (BbfwReaderFindAndCopyFileData(a3, theString, (CFTypeRef *)&value))
  {
    char v19 = (char)theString;
    uint64_t v18 = "Failed copying %@ %d";
    goto LABEL_15;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), theString, value);
  AMAuthInstallLog(3, (uint64_t)"_VinylBBFWReaderCB", (uint64_t)"Vinyl copied %@", v11, v12, v13, v14, v15, (char)theString);
  uint64_t v16 = 1;
LABEL_10:
  SafeRelease(value);
  return v16;
}

uint64_t sub_100019CF0(const __CFString *a1, const __CFString *a2, CFDictionaryRef theDict, void *key, __CFDictionary *a5)
{
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(Value))
    {
      CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
      uint64_t v11 = Mutable;
      if (Mutable)
      {
        CFStringAppend(Mutable, a1);
        CFStringAppend(v11, a2);
        CFDictionarySetValue(a5, v11, Value);
        SafeRetain(Value);
        uint64_t v12 = 0;
      }
      else
      {
        uint64_t v12 = 2;
      }
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v12 = 17;
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  SafeRelease(v11);
  SafeRelease(Value);
  return v12;
}

uint64_t AMAuthInstallBasebandVinylLocalHandleRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandVinylLocalHandleRequest", (uint64_t)"VinylLocal on device? Success!", a4, a5, a6, a7, a8, vars0);
  return 0;
}

void AMAuthInstallBundleFinalize(uint64_t a1)
{
  int v1 = *(CFTypeRef **)(a1 + 128);
  if (v1)
  {
    SafeRelease(*v1);
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 8));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 16));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 24));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 32));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 40));
    SafeFree(*(void **)(a1 + 128));
    *(void *)(a1 + 128) = 0;
  }
}

uint64_t AMAuthInstallBundleCopyNextBasebandComponentName(const void *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef v16 = 0;
  uint64_t v10 = AMAuthInstallBasebandCopyNextComponentName((uint64_t)a1, &v16, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    uint64_t v14 = v10;
    CFStringRef v13 = 0;
  }
  else
  {
    CFAllocatorRef v11 = CFGetAllocator(a1);
    CFStringRef v12 = CFStringCreateWithFormat(v11, 0, @"%s/%@", "amai", v16);
    CFStringRef v13 = v12;
    if (v12)
    {
      uint64_t v14 = 0;
      *a2 = CFRetain(v12);
    }
    else
    {
      uint64_t v14 = 2;
    }
  }
  SafeRelease(v16);
  SafeRelease(v13);
  return v14;
}

uint64_t AMAuthInstallBundleCopyPublishedVariantsArray(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  CFDictionaryRef theDict = 0;
  CFURLRef v26 = 0;
  uint64_t DictionaryFromFileURL = AMAuthInstallPlatformCopyURLWithAppendedComponent(a1, a2, @"BuildManifest.plist", 0, &v26);
  if (!DictionaryFromFileURL)
  {
    if (!AMAuthInstallSupportCreateDictionaryFromFileURL(a1, (CFTypeRef *)&theDict, v26)
      || (AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyPublishedVariantsArray", (uint64_t)"No build manifest. Checking for a different file.", v8, v9, v10, v11, v12, v24), SafeRelease(v26), CFURLRef v26 = 0, DictionaryFromFileURL = AMAuthInstallPlatformCopyURLWithAppendedComponent(a1, a2, @"BuildManifesto.plist", 0, &v26), !DictionaryFromFileURL)&& (DictionaryFromFileURL = AMAuthInstallSupportCreateDictionaryFromFileURL(a1, (CFTypeRef *)&theDict, v26),
          !DictionaryFromFileURL))
    {
      CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"BuildIdentities");
      if (Value)
      {
        uint64_t DictionaryFromFileURL = 0;
        *a3 = CFRetain(Value);
      }
      else
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyPublishedVariantsArray", (uint64_t)"the specified restore bundle contains a malformed build manifest", v14, v15, v16, v17, v18, v24);
        AMAuthInstallLog(7, (uint64_t)"AMAuthInstallBundleCopyPublishedVariantsArray", (uint64_t)"bundle: %@", v19, v20, v21, v22, v23, (char)a2);
        uint64_t DictionaryFromFileURL = 1;
      }
    }
  }
  SafeRelease(v26);
  SafeRelease(theDict);
  return DictionaryFromFileURL;
}

uint64_t AMAuthInstallBundleCopyBuildIdentityForVariant(uint64_t a1, const void *a2, CFStringRef theString1, CFTypeRef *a4)
{
  CFArrayRef v159 = 0;
  CFStringRef v158 = @"ApBoardID";
  CFStringRef v157 = @"ApChipID";
  CFStringRef v4 = @"ApSecurityDomain";
  if (!a1)
  {
    CFArrayRef v6 = 0;
    uint64_t v7 = 1;
    goto LABEL_99;
  }
  CFArrayRef v6 = 0;
  uint64_t v7 = 1;
  if (a4)
  {
    if (a2)
    {
      uint64_t v10 = *(void *)(a1 + 16);
      if (v10)
      {
        int v13 = *(_DWORD *)(v10 + 8);
        int v12 = *(_DWORD *)(v10 + 12);
        int v155 = *(_DWORD *)(v10 + 16);
        uint64_t v14 = *(void *)(v10 + 144);
        if (v14)
        {
          char v147 = v14;
          CFStringRef v157 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@,%@");
          if (v157)
          {
            uint64_t v148 = *(void *)(*(void *)(a1 + 16) + 144);
            CFStringRef v158 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@,%@");
            if (v158)
            {
              uint64_t v146 = *(void *)(*(void *)(a1 + 16) + 144);
              CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@,%@");
              if (v4) {
                goto LABEL_9;
              }
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"failed secdomKey allocation", v25, v26, v27, v28, v29, v146);
              CFArrayRef v6 = 0;
            }
            else
            {
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"failed boardKey allocation", v20, v21, v22, v23, v24, v148);
              CFArrayRef v6 = 0;
              CFStringRef v158 = 0;
            }
          }
          else
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"failed chipKey allocation", v15, v16, v17, v18, v19, v147);
            CFArrayRef v6 = 0;
            CFStringRef v157 = 0;
          }
          uint64_t v7 = 99;
          goto LABEL_99;
        }
LABEL_9:
        CFBooleanRef v30 = sub_10001A910(a1, theString1);
        CFBooleanRef v36 = v30;
        uint64_t v37 = *(void *)(a1 + 128);
        if (!v37 || !*(void *)(v37 + 32)) {
          goto LABEL_13;
        }
        int Value = CFBooleanGetValue(v30);
        uint64_t v39 = *(void *)(a1 + 128);
        if (Value)
        {
          uint64_t v40 = *(const void **)(v39 + 40);
          if (!v40)
          {
LABEL_13:
            if (theString1)
            {
              CFBooleanGetValue(v36);
              AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"searching for variant %@ (%d recovery)", v41, v42, v43, v44, v45, (char)theString1);
            }
            else
            {
              AMAuthInstallLog(4, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"variant not specified, will use first variant found for this device in build manifest", v31, v32, v33, v34, v35, v146);
            }
            CFAllocatorRef v46 = CFGetAllocator((CFTypeRef)a1);
            uint64_t v47 = AMAuthInstallBundleCopyPublishedVariantsArray(v46, a2, (CFTypeRef *)&v159);
            if (v47)
            {
              uint64_t v7 = v47;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"AMAuthInstallBundleCopyPublishedVariantsArray failed", v48, v49, v50, v51, v52, v149);
              CFArrayRef v6 = v159;
              goto LABEL_99;
            }
            CFArrayRef v6 = v159;
            if (v159)
            {
              CFTypeID v53 = CFGetTypeID(v159);
              if (v53 == CFArrayGetTypeID())
              {
                CFIndex Count = CFArrayGetCount(v6);
                uint64_t v150 = a4;
                CFStringRef theString2 = theString1;
                CFBooleanRef BOOLean = v36;
                if (!*(unsigned char *)(*(void *)(a1 + 16) + 96))
                {
                  uint64_t v60 = *(void *)(a1 + 48);
                  if (v60)
                  {
                    int v153 = *(_DWORD *)(v60 + 4);
                    int v154 = 1;
LABEL_23:
                    if (Count >= 1)
                    {
                      for (CFIndex i = 0; Count != i; ++i)
                      {
                        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, i);
                        if (!ValueAtIndex) {
                          continue;
                        }
                        CFDictionaryRef v63 = ValueAtIndex;
                        CFTypeID v64 = CFGetTypeID(ValueAtIndex);
                        if (v64 != CFDictionaryGetTypeID()
                          || !AMAuthInstallSupportCompareStringToInt32(v63, v158, v12)
                          || !AMAuthInstallSupportCompareStringToInt32(v63, v157, v13)
                          || CFDictionaryGetValue(v63, v4)
                          && !AMAuthInstallSupportCompareStringToInt32(v63, v4, v155))
                        {
                          continue;
                        }
                        if (v154
                          && !AMAuthInstallSupportCompareStringToInt32(v63, @"BbChipID", v153))
                        {
                          continue;
                        }
                        CFDictionaryRef v65 = (const __CFDictionary *)CFDictionaryGetValue(v63, @"Info");
                        if (!v65) {
                          continue;
                        }
                        CFDictionaryRef v66 = v65;
                        CFStringRef v67 = v4;
                        CFTypeID v68 = CFGetTypeID(v65);
                        BOOL v69 = v68 == CFDictionaryGetTypeID();
                        CFStringRef v4 = v67;
                        if (!v69) {
                          continue;
                        }
                        if (*(unsigned char *)(a1 + 56))
                        {
                          int v70 = CFBooleanGetValue(BOOLean);
                          CFStringRef v71 = @"Variant";
                          if (!v70)
                          {
                            CFStringRef v72 = (const __CFString *)CFDictionaryGetValue(v66, @"Variant");
                            if (v72)
                            {
                              char v73 = (char)v72;
                              if (CFStringHasPrefix(v72, @"Recovery"))
                              {
                                AMAuthInstallLog(4, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"Restore Behavior specified - skipping recovery variant: %@", v74, v75, v76, v77, v78, v73);
                                CFStringRef v4 = v67;
                                continue;
                              }
                            }
                            CFStringRef v71 = @"RestoreBehavior";
                            CFStringRef v4 = v67;
                          }
                        }
                        else
                        {
                          CFStringRef v71 = @"Variant";
                        }
                        CFStringRef v79 = (const __CFString *)CFDictionaryGetValue(v66, v71);
                        if (v79 && (!theString2 || CFEqual(v79, theString2)))
                        {
                          CFDictionaryGetValue(v66, @"Variant");
                          AMAuthInstallLog(4, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"%s: Found variant: %@", v135, v136, v137, v138, v139, (char)"AMAuthInstallBundleCopyBuildIdentityForVariant");
                          CFBooleanRef v80 = BOOLean;
LABEL_82:
                          int v104 = CFBooleanGetValue(v80);
                          uint64_t v105 = *(void *)(a1 + 128);
                          if (v104)
                          {
                            SafeRelease(*(CFTypeRef *)(v105 + 40));
                            uint64_t v106 = *(void *)(a1 + 128);
                            if (v106 && *(void *)(v106 + 24))
                            {
                              CFAllocatorRef v107 = CFGetAllocator((CFTypeRef)a1);
                              uint64_t MergedDictionary = AMAuthInstallSupportCreateMergedDictionary(v107, v63, *(const __CFDictionary **)(*(void *)(a1 + 128) + 24), (CFMutableDictionaryRef *)(*(void *)(a1 + 128) + 40));
                              if (!MergedDictionary)
                              {
                                CFDictionaryRef Copy = *(CFDictionaryRef *)(*(void *)(a1 + 128) + 40);
                                goto LABEL_88;
                              }
LABEL_116:
                              uint64_t v7 = MergedDictionary;
                              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"failed to merge build identities", v109, v110, v111, v112, v113, v149);
                              goto LABEL_99;
                            }
                            CFAllocatorRef v115 = CFGetAllocator((CFTypeRef)a1);
                            CFDictionaryRef Copy = CFDictionaryCreateCopy(v115, v63);
                            *(void *)(*(void *)(a1 + 128) + 40) = Copy;
LABEL_88:
                            CFDataRef v116 = v150;
                            if (Copy)
                            {
                              CFTypeRef v117 = CFRetain(Copy);
LABEL_98:
                              uint64_t v7 = 0;
                              *CFDataRef v116 = v117;
                              goto LABEL_99;
                            }
                          }
                          else
                          {
                            SafeRelease(*(CFTypeRef *)(v105 + 32));
                            uint64_t v123 = *(void *)(a1 + 128);
                            if (!v123)
                            {
                              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"amai->bundleParameters is NULL", v118, v119, v120, v121, v122, v149);
                              uint64_t v7 = 0;
                              goto LABEL_99;
                            }
                            uint64_t v124 = *(void *)(v123 + 16);
                            CFAllocatorRef v125 = CFGetAllocator((CFTypeRef)a1);
                            if (v124)
                            {
                              uint64_t MergedDictionary = AMAuthInstallSupportCreateMergedDictionary(v125, v63, *(const __CFDictionary **)(*(void *)(a1 + 128) + 16), (CFMutableDictionaryRef *)(*(void *)(a1 + 128) + 32));
                              if (MergedDictionary) {
                                goto LABEL_116;
                              }
                              CFDictionaryRef v126 = *(CFDictionaryRef *)(*(void *)(a1 + 128) + 32);
                            }
                            else
                            {
                              CFDictionaryRef v126 = CFDictionaryCreateCopy(v125, v63);
                              *(void *)(*(void *)(a1 + 128) + 32) = v126;
                            }
                            if (v126)
                            {
                              CFAllocatorRef v127 = CFGetAllocator((CFTypeRef)a1);
                              CFDictionaryRef ValueForKeyPathInDict = AMAuthInstallSupportGetValueForKeyPathInDict(v127, v63, @"Info.DeviceClass", v128, v129, v130, v131, v132);
                              *(void *)(*(void *)(a1 + 16) + 104) = ValueForKeyPathInDict;
                              SafeRetain(ValueForKeyPathInDict);
                              CFTypeRef v117 = CFRetain(*(CFTypeRef *)(*(void *)(a1 + 128) + 32));
                              CFDataRef v116 = v150;
                              goto LABEL_98;
                            }
                          }
                          uint64_t v7 = 2;
                          goto LABEL_99;
                        }
                      }
                    }
                    CFBooleanRef v80 = BOOLean;
                    if (CFBooleanGetValue(BOOLean))
                    {
LABEL_48:
                      if (theString2) {
                        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"variant \"%@\" isn't published for this device (chipID=0x%08X boardID=0x%X secDom=%d bbChipId=0x%08X) in build manifest", v81, v82, v83, v84, v85, (char)theString2);
                      }
                      else {
                        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"no variant published for this device (chipID=0x%08X boardID=0x%X secDom=%d bbChipId=0x%08X) in build manifest", v81, v82, v83, v84, v85, *(_DWORD *)(*(void *)(a1 + 16) + 8));
                      }
                      uint64_t v7 = 8;
                      goto LABEL_99;
                    }
                    CFDictionaryRef v86 = *(const __CFDictionary **)(a1 + 24);
                    if (v86 && (int64_t v87 = CFDictionaryGetCount(v86), v87 >= 1))
                    {
                      int64_t v88 = v87;
                      uint64_t v89 = (const void **)calloc(v87, 8uLL);
                      if (v89)
                      {
                        uint64_t v90 = (const void **)calloc(v88, 8uLL);
                        if (v90)
                        {
                          CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 24), v89, v90);
                          CFIndex v91 = CFArrayGetCount(v6);
                          if (v91 < 1)
                          {
                            CFDictionaryRef v63 = 0;
                          }
                          else
                          {
                            CFIndex v92 = v91;
                            CFStringRef v156 = v4;
                            CFIndex v93 = 0;
                            while (1)
                            {
                              CFDictionaryRef v94 = (const __CFDictionary *)CFArrayGetValueAtIndex(v6, v93);
                              if (v94)
                              {
                                CFDictionaryRef v63 = v94;
                                CFTypeID v95 = CFGetTypeID(v94);
                                if (v95 == CFDictionaryGetTypeID())
                                {
                                  int64_t v96 = 0;
                                  int v97 = 0;
                                  do
                                  {
                                    CFTypeRef v98 = CFDictionaryGetValue(v63, v89[v96]);
                                    if (v98)
                                    {
                                      CFDictionaryRef v99 = v90[v96];
                                      if (v99) {
                                        int v97 = CFEqual(v98, v99);
                                      }
                                    }
                                    if (!v97) {
                                      break;
                                    }
                                    ++v96;
                                  }
                                  while (v96 < v88);
                                  if (v97)
                                  {
                                    CFDictionaryRef v100 = (const __CFDictionary *)CFDictionaryGetValue(v63, @"Info");
                                    if (v100)
                                    {
                                      CFDictionaryRef v101 = v100;
                                      CFTypeID v102 = CFGetTypeID(v100);
                                      if (v102 == CFDictionaryGetTypeID() && !*(unsigned char *)(a1 + 56))
                                      {
                                        CFStringRef v103 = (const __CFString *)CFDictionaryGetValue(v101, @"Variant");
                                        if (v103)
                                        {
                                          if (!theString2
                                            || CFEqual(v103, theString2))
                                          {
                                            break;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              if (++v93 == v92)
                              {
                                CFDictionaryRef v63 = 0;
                                goto LABEL_73;
                              }
                            }
                            CFDictionaryGetValue(v101, @"Variant");
                            AMAuthInstallLog(4, (uint64_t)"_AMAuthInstallBundleGetMatchingSoftwareCoprocessorBuildIdentity", (uint64_t)"%s: Found variant: %@", v140, v141, v142, v143, v144, (char)"_AMAuthInstallBundleGetMatchingSoftwareCoprocessorBuildIdentity");
LABEL_73:
                            CFStringRef v4 = v156;
                          }
                          CFBooleanRef v80 = BOOLean;
                        }
                        else
                        {
                          CFDictionaryRef v63 = 0;
                        }
LABEL_81:
                        SafeFree(v89);
                        SafeFree(v90);
                        if (v63) {
                          goto LABEL_82;
                        }
                        goto LABEL_48;
                      }
                      CFDictionaryRef v63 = 0;
                    }
                    else
                    {
                      CFDictionaryRef v63 = 0;
                      uint64_t v89 = 0;
                    }
                    uint64_t v90 = 0;
                    goto LABEL_81;
                  }
                  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)"No baseband chipid reported. Will match Build Identity based on ap chipid, boardid, and secdomain only.", v54, v55, v56, v57, v58, v149);
                }
                int v154 = 0;
                int v153 = -1;
                goto LABEL_23;
              }
              uint64_t v145 = "publishedVariants is not a CFArray";
            }
            else
            {
              uint64_t v145 = "AMAuthInstallBundleCopyPublishedVariantsArray returned NULL";
            }
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyBuildIdentityForVariant", (uint64_t)v145, v48, v49, v50, v51, v52, v149);
            uint64_t v7 = 7;
            goto LABEL_99;
          }
        }
        else
        {
          uint64_t v40 = *(const void **)(v39 + 32);
        }
        CFArrayRef v6 = 0;
        uint64_t v7 = 0;
        *a4 = CFRetain(v40);
      }
    }
  }
LABEL_99:
  SafeRelease(v6);
  SafeRelease(v158);
  SafeRelease(v157);
  SafeRelease(v4);
  return v7;
}

CFBooleanRef sub_10001A910(uint64_t a1, CFStringRef theString1)
{
  CFBooleanRef v2 = kCFBooleanFalse;
  if (theString1)
  {
    CFStringRef v3 = *(const __CFString **)(a1 + 496);
    if (v3)
    {
      if (CFEqual(theString1, v3)) {
        return kCFBooleanTrue;
      }
    }
  }
  return v2;
}

uint64_t AMAuthInstallBundleCopyFullPathForBuildIdentityKey(CFDictionaryRef **a1, const void *a2, void *key, const __CFDictionary *a4, CFTypeRef *a5)
{
  CFDictionaryRef v5 = 0;
  CFURLRef v26 = 0;
  uint64_t v6 = 1;
  if (a1 && a2)
  {
    char v10 = (char)key;
    CFURLRef Value = (const __CFURL *)CFDictionaryGetValue(*a1[16], key);
    CFURLRef v26 = Value;
    if (Value)
    {
      CFDictionaryRef v5 = Value;
      CFRetain(Value);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallBundleCopyFullPathForBuildIdentityKey", (uint64_t)"using override: %@ = %@", v13, v14, v15, v16, v17, v10);
    }
    else
    {
      if (!a4)
      {
        CFDictionaryRef v5 = 0;
        goto LABEL_9;
      }
      CFDictionaryRef v5 = sub_10001AA98(a4);
      if (!v5)
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyFullPathForBuildIdentityKey", (uint64_t)"%@ key not found.", v18, v19, v20, v21, v22, v10);
        goto LABEL_9;
      }
      CFAllocatorRef v23 = CFGetAllocator(a1);
      uint64_t v24 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v23, a2, (const __CFString *)v5, 0, &v26);
      CFDictionaryRef v5 = v26;
      if (v24)
      {
        uint64_t v6 = v24;
        goto LABEL_9;
      }
    }
    uint64_t v6 = 0;
    *a5 = CFRetain(v5);
    CFDictionaryRef v5 = v26;
  }
LABEL_9:
  SafeRelease(v5);
  return v6;
}

CFDictionaryRef sub_10001AA98(const __CFDictionary *a1)
{
  CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(a1, @"Info");
  if (result)
  {
    return (const __CFDictionary *)CFDictionaryGetValue(result, @"Path");
  }
  return result;
}

void _AMAuthInstallBundleNormalizeOverridePaths(const void *a1, const __CFString *a2, CFMutableDictionaryRef *a3)
{
  CFURLRef v5 = CFURLCreateWithFileSystemPath(0, a2, kCFURLPOSIXPathStyle, 0);
  if (v5)
  {
    CFURLRef v6 = v5;
    CFDictionarySetValue(*a3, a1, v5);
    CFRelease(v6);
  }
}

void _AMAuthInstallBundleNormalizeOverrideURLs(const void *a1, CFURLRef anURL, CFMutableDictionaryRef *a3)
{
  CFStringRef v5 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
  if (v5)
  {
    CFStringRef v6 = v5;
    CFDictionarySetValue(*a3, a1, v5);
    CFRelease(v6);
  }
}

uint64_t _AMAuthInstallBundlePopulatePersonalizedBundle(uint64_t a1, const void *a2, const void *a3, int a4, const __CFDictionary *a5, CFURLRef a6, CFDictionaryRef theDict, const __CFArray *a8, CFArrayRef theArray, CFArrayRef a10, CFBooleanRef BOOLean)
{
  CFURLRef v11 = 0;
  CFMutableDictionaryRef context = 0;
  CFStringRef v369 = 0;
  CFURLRef v366 = 0;
  v367 = 0;
  uint64_t Code = 1;
  if (!a1 || !a2 || !a3 || !a5)
  {
LABEL_260:
    CFURLRef v14 = 0;
    uint64_t v15 = 0;
    CFStringRef v16 = 0;
    goto LABEL_257;
  }
  uint64_t v13 = theDict;
  CFURLRef v14 = 0;
  uint64_t v15 = 0;
  CFStringRef v16 = 0;
  if (!theDict) {
    goto LABEL_257;
  }
  CFURLRef v19 = (const __CFURL *)CFDictionaryGetValue(theDict, @"CumulativeResponse");
  if (v19)
  {
    CFURLRef v25 = v19;
    v372[0] = 0;
    if (!a6)
    {
      AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"replaced NULL response dictionary with cumulative response", v20, v21, v22, v23, v24, v340);
      a6 = v25;
      goto LABEL_14;
    }
    CFGetAllocator((CFTypeRef)a1);
    uint64_t MergedDictionary = AMSupportCreateMergedDictionary();
    if (MergedDictionary)
    {
      uint64_t Code = MergedDictionary;
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"could not create merged response dictionary", v27, v28, v29, v30, v31, v340);
      CFURLRef v11 = 0;
      CFURLRef v14 = 0;
      uint64_t v15 = 0;
      CFStringRef v16 = 0;
      goto LABEL_257;
    }
    CFDictionarySetValue(v13, @"CumulativeResponse", v372[0]);
    a6 = v372[0];
    SafeRelease(v372[0]);
    uint64_t v37 = "created merged response dictionary";
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 435))
  {
    CFDictionarySetValue(v13, @"CumulativeResponse", a6);
    uint64_t v37 = "caching response dictionary on skipped install";
LABEL_12:
    AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)v37, v32, v33, v34, v35, v36, v340);
  }
LABEL_14:
  if (CFBooleanGetValue(BOOLean))
  {
    uint64_t v13 = (__CFDictionary *)CFDictionaryGetValue(v13, @"RecoveryOS");
    if (!v13)
    {
      CFURLRef v11 = 0;
      CFURLRef v14 = 0;
      uint64_t v15 = 0;
      CFStringRef v16 = 0;
      uint64_t Code = 8;
      goto LABEL_257;
    }
  }
  uint64_t v38 = (__CFArray *)CFDictionaryGetValue(v13, @"Personalized");
  uint64_t v39 = (__CFDictionary *)CFDictionaryGetValue(v13, @"Manifest");
  CFArrayRef v40 = (const __CFArray *)CFDictionaryGetValue(v13, @"Linked");
  uint64_t v41 = CFDictionaryGetValue(v13, @"Alignment");
  CFURLRef v11 = 0;
  uint64_t Code = 8;
  v353 = v38;
  if (!v38 || !v39) {
    goto LABEL_260;
  }
  v356 = v39;
  CFURLRef v14 = 0;
  uint64_t v15 = 0;
  CFStringRef v16 = 0;
  if (!v40) {
    goto LABEL_257;
  }
  v351 = v41;
  CFDictionaryRef v363 = (const __CFDictionary *)CFDictionaryGetValue(a5, @"Manifest");
  if (!v363)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"%@ not found in buildIdentity", v42, v43, v44, v45, v46, (char)@"Manifest");
    CFURLRef v11 = 0;
    CFURLRef v14 = 0;
    uint64_t v15 = 0;
    CFStringRef v16 = 0;
    uint64_t Code = 7;
    goto LABEL_257;
  }
  v352 = v13;
  v365 = (unsigned char *)a1;
  uint64_t v15 = 0;
  CFDictionaryRef v357 = a6;
  CFStringRef v16 = 0;
  if (a8 && a6)
  {
    if (!*(unsigned char *)(a1 + 435))
    {
      CFIndex Count = CFArrayGetCount(a8);
      if (Count >= 1)
      {
        CFIndex v99 = Count;
        CFStringRef v16 = 0;
        uint64_t v15 = 0;
        CFIndex v100 = 0;
        CFIndex v355 = Count;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a8, v100);
          if (!ValueAtIndex) {
            sub_100071ED4();
          }
          CFStringRef v102 = ValueAtIndex;
          if (CFStringFind(ValueAtIndex, @"RecoveryOS", 0).location == -1) {
            CFBooleanRef v103 = kCFBooleanFalse;
          }
          else {
            CFBooleanRef v103 = kCFBooleanTrue;
          }
          int v104 = CFBooleanGetValue(v103);
          int v105 = CFBooleanGetValue(BOOLean);
          if (v104)
          {
            if (!v105) {
              goto LABEL_122;
            }
            SafeRelease(v16);
            CFAllocatorRef v106 = CFGetAllocator((CFTypeRef)a1);
            CFStringRef v16 = AMAuthInstallICreateTranslationOfRecoveryEnteryName(v106, v102);
            CFStringRef v102 = v16;
          }
          else if (v105)
          {
            goto LABEL_122;
          }
          CFDictionaryRef v107 = (const __CFDictionary *)CFDictionaryGetValue(v363, v102);
          if (v107)
          {
            CFDictionaryRef v113 = v107;
            if (CFEqual(v102, @"BasebandFirmware"))
            {
              uint64_t v133 = *(void *)(a1 + 48);
              if (v133 && *(void *)(v133 + 160))
              {
                CFTypeID v134 = CFDictionaryGetValue(a5, @"UniqueBuildID");
                if (v134)
                {
                  uint64_t v135 = v134;
                  CFAllocatorRef v136 = CFGetAllocator((CFTypeRef)a1);
                  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v136, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                  uint64_t v15 = Mutable;
                  if (!Mutable) {
                    goto LABEL_268;
                  }
                  CFDictionarySetValue(Mutable, @"UniqueBuildID", v135);
                }
                uint64_t v138 = *(void *)(a1 + 16);
                if (*(void *)(v138 + 120) || *(void *)(v138 + 128))
                {
                  uint64_t v139 = CFDictionaryGetValue(a5, @"ProductMarketingVersion");
                  if (v139)
                  {
                    uint64_t v140 = v139;
                    if (!v15)
                    {
                      CFAllocatorRef v141 = CFGetAllocator((CFTypeRef)a1);
                      uint64_t v15 = CFDictionaryCreateMutable(v141, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                      if (!v15)
                      {
LABEL_268:
                        CFURLRef v11 = 0;
                        CFURLRef v14 = 0;
                        goto LABEL_269;
                      }
                    }
                    CFDictionarySetValue(v15, @"ProductMarketingVersion", v140);
                  }
                }
              }
              uint64_t Code = sub_10001C400((CFDictionaryRef **)a1, v113, a6, v363, a2, a3, v353, v15);
              goto LABEL_120;
            }
            CFURLRef v371 = 0;
            v372[0] = 0;
            if (!v102)
            {
              CFDictionaryRef v151 = 0;
              uint64_t Code = 1;
              goto LABEL_119;
            }
            CFAllocatorRef v114 = CFGetAllocator((CFTypeRef)a1);
            CFDictionaryRef ValueForKeyWithFormat = AMAuthInstallSupportGetValueForKeyWithFormat(v114, v113, @"%@.%@", v115, v116, v117, v118, v119, (char)@"Info");
            if (ValueForKeyWithFormat && !CFBooleanGetValue(ValueForKeyWithFormat))
            {
              AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"entry \"%@\" does not require personalization; skipping it",
                v121,
                v122,
                v123,
                v124,
                v125,
                (char)v102);
              if (CFDictionaryContainsKey(a6, v102)) {
                CFDictionarySetValue(v356, v102, v113);
              }
              uint64_t Code = 0;
LABEL_118:
              CFDictionaryRef v151 = 0;
              goto LABEL_119;
            }
            int v126 = CFBooleanGetValue(BOOLean);
            uint64_t v127 = sub_100022A08((CFDictionaryRef **)a1, v102, v113, a2, a3, 1, v126, &v371);
            if (v127)
            {
              uint64_t Code = v127;
              AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"failed to copy bundle URLs for %@", v128, v129, v130, v131, v132, (char)v102);
              goto LABEL_118;
            }
            CFStringRef v362 = v16;
            CFURLRef v142 = (const __CFURL *)CFDictionaryGetValue(v371, @"SourceURL");
            CFURLRef v143 = (const __CFURL *)CFDictionaryGetValue(v371, @"DestURL");
            uint64_t v144 = (void *)CFDictionaryGetValue(v371, @"RelativeSrcPath");
            CFStringRef v145 = (const __CFString *)CFDictionaryGetValue(v371, @"RelativeDestPath");
            CFURLRef v348 = v142;
            if (v142 || v143 || v144 || v145)
            {
              CFStringRef theString = v145;
              if (CFDictionaryContainsKey(v356, v102))
              {
                AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"entry \"%@\" has been previously personalized; skipping it",
                  v146,
                  v147,
                  v148,
                  v149,
                  v150,
                  (char)v102);
                uint64_t Code = 0;
                goto LABEL_113;
              }
              v346 = v144;
              CFURLRef v347 = v143;
              DirectoryForURL = AMAuthInstallPlatformMakeDirectoryForURL(v143);
              if (DirectoryForURL)
              {
                uint64_t Code = (uint64_t)DirectoryForURL;
                char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, (int)DirectoryForURL);
                AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"failed to create directory: %@", v217, v218, v219, v220, v221, LocalizedStatusString);
LABEL_113:
                CFDictionaryRef v151 = 0;
                goto LABEL_114;
              }
              CFAllocatorRef v153 = CFGetAllocator((CFTypeRef)a1);
              uint64_t Code = 2;
              DeepCFDictionaryRef Copy = (const __CFDictionary *)CFPropertyListCreateDeepCopy(v153, v113, 2uLL);
              CFDictionaryRef v151 = DeepCopy;
              if (!DeepCopy) {
                goto LABEL_114;
              }
              CFDictionaryRef v155 = (const __CFDictionary *)CFDictionaryGetValue(DeepCopy, @"Info");
              if (v155)
              {
                CFDictionaryRef v161 = v155;
                CFStringRef v167 = (const __CFString *)CFDictionaryGetValue(v155, @"Path");
                if (v167 && CFDictionaryContainsKey(v356, v167))
                {
                  AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"entry \"%@\" has been previously personalized as part of \"%@\"; skipping it",
                    v162,
                    v163,
                    v164,
                    v165,
                    v166,
                    (char)v102);
                  uint64_t Code = 0;
                  goto LABEL_114;
                }
                CFStringRef pathComponent = v167;
                CFDictionaryRef value = v151;
                int v344 = _CFDictionaryGetBoolean(v161, @"IsFTAB", 0, v162, v163, v164, v165, v166);
                CFAllocatorRef v168 = CFGetAllocator((CFTypeRef)a1);
                uint64_t PrependedFilePath = AMAuthInstallSupportCreatePrependedFilePath(v168, (uint64_t)v102, theString, v372);
                if (PrependedFilePath)
                {
                  uint64_t Code = PrependedFilePath;
                  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"%s: unable to prepend entry name to path", v170, v171, v172, v173, v174, (char)"_AMAuthInstallBundleInstallPersonalizedEntry");
                  goto LABEL_165;
                }
                CFDictionarySetValue(v161, @"PersonalizedPath", v372[0]);
                v175 = CFDictionaryGetValue(a6, v102);
                if (v175)
                {
                  v183 = v175;
                  CFDictionaryRef v184 = v161;
                  CFTypeID TypeID = CFDictionaryGetTypeID();
                  BOOL v186 = TypeID == CFGetTypeID(v183);
                  CFDictionaryRef v161 = v184;
                  if (v186)
                  {
                    if (CFDictionaryContainsKey((CFDictionaryRef)v183, @"Blob"))
                    {
                      uint64_t Code = AMAuthInstallApImg3PersonalizeWithEntryName((void *)a1, v348, v347, v102, v113, a6);
                      if (!Code)
                      {
                        CFDictionaryRef v151 = value;
                        CFDictionarySetValue(v356, v102, value);
                        sub_10001F2F0(v40, v346);
                        goto LABEL_114;
                      }
                      char v341 = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, Code);
                      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"failed to personalize img3 object: %@", v222, v223, v224, v225, v226, v341);
LABEL_165:
                      CFStringRef v16 = v362;
LABEL_166:
                      CFDictionaryRef v151 = value;
LABEL_119:
                      SafeRelease(v372[0]);
                      SafeRelease(v151);
                      SafeRelease(v371);
                      SafeRelease(0);
                      SafeRelease(0);
LABEL_120:
                      if (Code)
                      {
                        AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, Code);
                        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"failed to install \"%@\" in personalized bundle: %@", v317, v318, v319, v320, v321, (char)v102);
                        CFURLRef v11 = 0;
                        CFURLRef v14 = 0;
                        goto LABEL_257;
                      }
                      CFIndex v99 = v355;
                      goto LABEL_122;
                    }
                  }
                }
                if (!AMAuthInstallApIsImg4(a1, v176, v177, v178, v179, v180, v181, v182)
                  || !CFDictionaryGetValue(a6, *(const void **)(a1 + 88))
                  || !v344)
                {
                  if (!AMAuthInstallApIsImg4(a1, v187, v188, v189, v190, v191, v192, v193)
                    || !CFDictionaryGetValue(a6, *(const void **)(a1 + 88))
                    || v344)
                  {
                    char v370 = 0;
                    uint64_t v214 = AMAuthInstallSupportFileURLExists(v347, &v370);
                    CFStringRef v16 = v362;
                    if (v214)
                    {
                      uint64_t Code = v214;
                      goto LABEL_165;
                    }
                    CFDictionaryRef v151 = value;
                    if (!v370)
                    {
                      uint64_t v215 = AMAuthInstallBundleInstallFile((unsigned char *)a1, v347, v348);
                      if (v215)
                      {
                        uint64_t Code = v215;
                        char v342 = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v215);
                        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"failed to create link: %@", v228, v229, v230, v231, v232, v342);
                        goto LABEL_165;
                      }
                      CFArrayAppendValue(v40, v346);
                    }
                    uint64_t Code = 0;
                    goto LABEL_119;
                  }
                  CFStringRef TypeForEntryName = (const __CFString *)CFDictionaryGetValue(v161, @"Img4PayloadType");
                  uint64_t v208 = AMAuthInstallApImg4StitchTicketData((const void **)a1, TypeForEntryName, v348, v347, a6);
                  CFStringRef v16 = v362;
                  if (v208)
                  {
                    uint64_t Code = v208;
                    v227 = "failed to stitch ticket data to file";
                  }
                  else
                  {
                    if (!TypeForEntryName) {
                      CFStringRef TypeForEntryName = AMAuthInstallApImg4GetTypeForEntryName(v102);
                    }
                    uint64_t Code = AMAuthInstallApImg4StitchRestoreInfoWithAMAI(TypeForEntryName, v347, a6, 0, a1);
                    if (!Code)
                    {
                      v205 = v356;
                      CFStringRef v206 = v102;
                      CFDictionaryRef v151 = value;
                      goto LABEL_151;
                    }
                    char v340 = (char)v347;
                    v227 = "failed to stitch restore info to %@";
                  }
                  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)v227, v209, v210, v211, v212, v213, v340);
                  goto LABEL_166;
                }
                CFURLRef v194 = CFURLCreateCopyAppendingPathComponent(kCFAllocatorDefault, (CFURLRef)a3, pathComponent, 0);
                CFDictionaryRef v151 = value;
                if (v194)
                {
                  uint64_t Code = AMAuthInstallApFtabStitchTicketData((const void **)a1, (uint64_t)v348, v194, a6);
                  CFStringRef v16 = v362;
                  if (Code)
                  {
                    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"%s: Failed to stitch ticket to FTAB file.", v200, v201, v202, v203, v204, (char)"_AMAuthInstallBundleInstallPersonalizedEntry");
                    goto LABEL_119;
                  }
                  v205 = v356;
                  CFStringRef v206 = pathComponent;
LABEL_151:
                  CFDictionarySetValue(v205, v206, v151);
                  sub_10001F2F0(v40, v346);
                  goto LABEL_119;
                }
                AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"dstFtabUrl is NULL", v195, v196, v197, v198, v199, v340);
                uint64_t Code = 2;
LABEL_114:
                CFStringRef v16 = v362;
                goto LABEL_119;
              }
              AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedEntry", (uint64_t)"%s: no personalized entry for %@", v156, v157, v158, v159, v160, (char)"_AMAuthInstallBundleInstallPersonalizedEntry");
            }
            else
            {
              CFDictionaryRef v151 = 0;
            }
            uint64_t Code = 8;
            goto LABEL_114;
          }
          AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"no entry in manifest found for \"%@\"", v108, v109, v110, v111, v112, (char)v102);
LABEL_122:
          if (v99 == ++v100) {
            goto LABEL_24;
          }
        }
      }
    }
    uint64_t v15 = 0;
    CFStringRef v16 = 0;
  }
LABEL_24:
  v354 = v15;
  CFStringRef v361 = v16;
  if (!theArray)
  {
    uint64_t v47 = a1;
    goto LABEL_51;
  }
  uint64_t v47 = a1;
  if (*(unsigned char *)(a1 + 435) || (CFIndex v48 = CFArrayGetCount(theArray), v48 < 1))
  {
LABEL_51:
    v374.CFIndex length = CFArrayGetCount(a8);
    v374.CFIndex location = 0;
    CFURLRef v11 = 0;
    CFURLRef v14 = 0;
    if (CFArrayContainsValue(a8, v374, @"BasebandFirmware")) {
      goto LABEL_54;
    }
    if (*(unsigned char *)(v47 + 435)
      || (LOBYTE(v372[0]) = 0,
          CFAllocatorRef v290 = CFGetAllocator((CFTypeRef)v47),
          (CFDictionaryRef v296 = AMAuthInstallSupportGetValueForKeyWithFormat(v290, a5, @"%@.%@.%@.%@", v291, v292, v293, v294, v295, (char)@"Manifest")) == 0))
    {
      CFURLRef v11 = 0;
      CFURLRef v14 = 0;
      goto LABEL_54;
    }
    CFStringRef v297 = (const __CFString *)v296;
    v298 = CFDictionaryGetValue(**(CFDictionaryRef **)(v47 + 128), @"BasebandFirmware");
    if (v298)
    {
      CFURLRef v11 = (const __CFURL *)CFRetain(v298);
    }
    else
    {
      CFAllocatorRef v311 = CFGetAllocator((CFTypeRef)v47);
      CFURLRef v11 = CFURLCreateCopyAppendingPathComponent(v311, (CFURLRef)a2, v297, 0);
      if (!v11)
      {
        CFURLRef v14 = 0;
        goto LABEL_272;
      }
    }
    CFAllocatorRef v312 = CFGetAllocator((CFTypeRef)v47);
    uint64_t v313 = AMAuthInstallSupportCreatePrependedFilePath(v312, @"BasebandFirmware", v297, &v369);
    if (v313)
    {
      uint64_t Code = v313;
      goto LABEL_254;
    }
    CFAllocatorRef v314 = CFGetAllocator((CFTypeRef)v47);
    CFURLRef v315 = CFURLCreateCopyAppendingPathComponent(v314, (CFURLRef)a3, v369, 0);
    CFURLRef v14 = v315;
    if (v315)
    {
      uint64_t SoftLink = AMAuthInstallSupportFileURLExists(v315, v372);
      if (SoftLink
        || !LOBYTE(v372[0])
        && ((uint64_t SoftLink = AMAuthInstallSupportFileURLExists(v11, v372), SoftLink)
         || LOBYTE(v372[0]) && (uint64_t SoftLink = AMAuthInstallPlatformCreateSoftLink(v14, v11), SoftLink)))
      {
        uint64_t Code = SoftLink;
        goto LABEL_255;
      }
LABEL_54:
      uint64_t v15 = v354;
      if (a10)
      {
        CFIndex v88 = CFArrayGetCount(a10);
        if (v88 >= 1)
        {
          CFIndex v89 = v88;
          CFIndex v90 = 0;
          while (1)
          {
            CFStringRef v91 = (const __CFString *)CFArrayGetValueAtIndex(a10, v90);
            if (!v91) {
              sub_100071F00();
            }
            CFStringRef v92 = v91;
            v375.CFIndex length = CFArrayGetCount(v40);
            v375.CFIndex location = 0;
            if (!CFArrayContainsValue(v40, v375, v92))
            {
              CFURLRef v371 = 0;
              v372[0] = 0;
              v376.CFIndex length = CFArrayGetCount(v40);
              v376.CFIndex location = 0;
              if (CFArrayContainsValue(v40, v376, v92))
              {
                uint64_t Code = 0;
              }
              else
              {
                CFAllocatorRef v93 = CFGetAllocator((CFTypeRef)v47);
                uint64_t Code = AMAuthInstallPlatformCopyURLWithAppendedComponent(v93, a2, v92, 0, v372);
                if (!Code)
                {
                  CFAllocatorRef v94 = CFGetAllocator((CFTypeRef)v47);
                  uint64_t Code = AMAuthInstallPlatformCopyURLWithAppendedComponent(v94, a3, v92, 0, &v371);
                  if (!Code)
                  {
                    uint64_t Code = (uint64_t)AMAuthInstallPlatformMakeDirectoryForURL(v371);
                    if (!Code)
                    {
                      uint64_t Code = AMAuthInstallBundleInstallFile((unsigned char *)v47, v371, v372[0]);
                      if (!Code) {
                        CFArrayAppendValue(v40, v92);
                      }
                    }
                  }
                }
              }
              SafeRelease(v372[0]);
              SafeRelease(v371);
              if (Code) {
                break;
              }
            }
            if (v89 == ++v90) {
              goto LABEL_68;
            }
          }
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"failed to install link in personalized bundle: %@", v83, v84, v85, v86, v87, (char)v92);
          goto LABEL_256;
        }
      }
LABEL_68:
      CFStringRef v16 = v361;
      if (v357 && !*(unsigned char *)(v47 + 32))
      {
        int IsImg4 = AMAuthInstallApIsImg4(v47, v81, v82, v83, v84, v85, v86, v87);
        CFStringRef v96 = IsImg4 ? @"amai/apimg4ticket.der" : @"amai/apticket.der";
        if (IsImg4) {
          int v97 = *(unsigned char *)(*(void *)(v47 + 16) + 116) ? &kAMAuthInstallTagX86Img4Ticket : (__CFString **)(v47 + 88);
        }
        else {
          int v97 = &kAMAuthInstallTagApTicket;
        }
        v233 = *v97;
        v377.CFIndex length = CFArrayGetCount(v353);
        v377.CFIndex location = 0;
        if (!CFArrayContainsValue(v353, v377, v96))
        {
          CFDataRef v286 = (const __CFData *)CFDictionaryGetValue(v357, v233);
          if (v286)
          {
            CFDataRef v287 = v286;
            CFAllocatorRef v288 = CFGetAllocator((CFTypeRef)v47);
            uint64_t v289 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v288, a3, v96, 0, &v366);
            if (v289)
            {
              uint64_t Code = v289;
              v245 = "failed to create an AP ticket URL";
              goto LABEL_234;
            }
            CFAllocatorRef v299 = CFGetAllocator((CFTypeRef)v47);
            uint64_t v300 = AMAuthInstallSupportWriteDataToFileURL(v299, v287, v366, 1);
            if (v300)
            {
              uint64_t Code = v300;
              AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"failed to write the AP ticket", v301, v302, v303, v304, v305, v340);
              AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"%@", v306, v307, v308, v309, v310, (char)v366);
              goto LABEL_257;
            }
            CFArrayAppendValue(v353, v96);
          }
        }
      }
      if (!(*(unsigned int (**)(uint64_t, const void *, const __CFDictionary *, __CFError **))(v47 + 448))(v47, a3, v357, &v367))
      {
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"failed to write updater manifests: %@", v234, v235, v236, v237, v238, (char)v367);
        if (v367) {
          uint64_t Code = CFErrorGetCode(v367);
        }
        else {
          uint64_t Code = 4;
        }
        goto LABEL_257;
      }
      if (v351)
      {
LABEL_178:
        if (CFDictionaryGetCount(**(CFDictionaryRef **)(v47 + 128)) >= 1)
        {
          CFAllocatorRef v239 = CFGetAllocator((CFTypeRef)v47);
          CFMutableDictionaryRef context = CFDictionaryCreateMutable(v239, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (!context)
          {
LABEL_269:
            uint64_t Code = 2;
            goto LABEL_257;
          }
          CFDictionaryApplyFunction(**(CFDictionaryRef **)(v47 + 128), (CFDictionaryApplierFunction)_AMAuthInstallBundleNormalizeOverrideURLs, &context);
          CFDictionarySetValue(v352, @"Overrides", context);
        }
        uint64_t Code = AMAuthInstallBundleWriteReceipt((void *)v47, a3, v352, BOOLean);
        if (!Code) {
          goto LABEL_257;
        }
        char v340 = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)v47, Code);
        v245 = "failed to write receipt: %@";
LABEL_234:
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)v245, v240, v241, v242, v243, v244, v340);
        goto LABEL_257;
      }
      v372[0] = 0;
      CFAllocatorRef v246 = CFGetAllocator((CFTypeRef)v47);
      CFMutableDictionaryRef v248 = CFDictionaryCreateMutable(v246, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (!v248)
      {
        CFTypeRef v285 = 0;
        CFStringRef v258 = 0;
        uint64_t Code = 2;
LABEL_232:
        SafeRelease(v248);
        SafeRelease(v258);
        SafeRelease(v372[0]);
        if (Code)
        {
          char v340 = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)v47, Code);
          v245 = "_AMAuthInstallCreateAlignmentDictionary failed: %@";
          goto LABEL_234;
        }
        CFDictionarySetValue(v352, @"Alignment", v285);
        CFRelease(v285);
        goto LABEL_178;
      }
      CFStringRef RelativePathForManifestEntry = (const __CFString *)_CreateRelativePathForManifestEntry((const void *)v47, v247, (const __CFURL *)a3, v363, @"iBSS");
      if (RelativePathForManifestEntry)
      {
        CFStringRef v251 = RelativePathForManifestEntry;
        CFStringRef v252 = @"RELEASE";
        if (CFStringFind(RelativePathForManifestEntry, @"RELEASE", 0).location != -1
          || (CFStringRef v252 = @"DEVELOPMENT", CFStringFind(v251, @"DEVELOPMENT", 0).location != -1)
          || (CFStringRef v252 = @"DEBUG", CFStringFind(v251, @"DEBUG", 0).location != -1))
        {
          CFDictionarySetValue(v248, @"DFUFileType", v252);
        }
        SafeRelease(v251);
      }
      CFTypeRef v253 = _CreateRelativePathForManifestEntry((const void *)v47, v250, (const __CFURL *)a3, v363, @"OS");
      if (v253)
      {
        v255 = v253;
        CFDictionarySetValue(v248, @"OS", v253);
        SafeRelease(v255);
      }
      CFStringRef v256 = (const __CFString *)_CreateRelativePathForManifestEntry((const void *)v47, v254, (const __CFURL *)a3, v363, @"RestoreKernelCache");
      if (v256)
      {
        CFStringRef v258 = v256;
        CFAllocatorRef v259 = CFGetAllocator((CFTypeRef)v47);
        uint64_t v260 = AMAuthInstallSupportCreatePrependedFilePath(v259, @"RestoreKernelCache", v258, v372);
        if (v260) {
          goto LABEL_267;
        }
        if (v372[0])
        {
          CFDictionarySetValue(v248, @"RestoreKernelCache", v372[0]);
          SafeRelease(v372[0]);
          v372[0] = 0;
        }
        SafeRelease(v258);
      }
      CFStringRef v266 = (const __CFString *)_CreateRelativePathForManifestEntry((const void *)v47, v257, (const __CFURL *)a3, v363, @"KernelCache");
      if (v266)
      {
        CFStringRef v258 = v266;
        CFAllocatorRef v268 = CFGetAllocator((CFTypeRef)v47);
        uint64_t v260 = AMAuthInstallSupportCreatePrependedFilePath(v268, @"KernelCache", v258, v372);
        if (v260) {
          goto LABEL_267;
        }
        if (v372[0])
        {
          CFDictionarySetValue(v248, @"KernelCache", v372[0]);
          SafeRelease(v372[0]);
          v372[0] = 0;
        }
        SafeRelease(v258);
      }
      CFTypeRef v269 = _CreateRelativePathForManifestEntry((const void *)v47, v267, (const __CFURL *)a3, v363, @"RestoreRamDisk");
      if (v269)
      {
        v271 = v269;
        CFDictionarySetValue(v248, @"RestoreRamDisk", v269);
        SafeRelease(v271);
      }
      CFTypeRef v272 = _CreateRelativePathForManifestEntry((const void *)v47, v270, (const __CFURL *)a3, v363, @"OSRamdisk");
      if (v272)
      {
        v274 = v272;
        CFDictionarySetValue(v248, @"OSRamdisk", v272);
        SafeRelease(v274);
      }
      CFStringRef v275 = (const __CFString *)_CreateRelativePathForManifestEntry((const void *)v47, v273, (const __CFURL *)a3, v363, @"RestoreDeviceTree");
      if (!v275) {
        goto LABEL_215;
      }
      CFStringRef v258 = v275;
      CFAllocatorRef v277 = CFGetAllocator((CFTypeRef)v47);
      uint64_t v260 = AMAuthInstallSupportCreatePrependedFilePath(v277, @"RestoreDeviceTree", v258, v372);
      if (!v260)
      {
        if (v372[0])
        {
          CFDictionarySetValue(v248, @"RestoreDeviceTree", v372[0]);
          CFStringRef v278 = sub_100022E50(kCFAllocatorDefault, v258);
          if (v278)
          {
            CFStringRef v279 = v278;
            CFDictionarySetValue(v248, @"AllFlash", v278);
            CFRelease(v279);
          }
          SafeRelease(v372[0]);
          v372[0] = 0;
        }
        SafeRelease(v258);
LABEL_215:
        CFStringRef v280 = (const __CFString *)_CreateRelativePathForManifestEntry((const void *)v47, v276, (const __CFURL *)a3, v363, @"DeviceTree");
        if (!v280)
        {
LABEL_220:
          CFTypeRef v283 = _CreateRelativePathForManifestEntry((const void *)v47, v281, (const __CFURL *)a3, v363, @"Diags");
          if (v283)
          {
            v284 = v283;
            CFDictionarySetValue(v248, @"Diags", v283);
            SafeRelease(v284);
          }
          CFTypeRef v285 = CFRetain(v248);
          CFStringRef v258 = 0;
          uint64_t Code = 0;
          goto LABEL_232;
        }
        CFStringRef v258 = v280;
        CFAllocatorRef v282 = CFGetAllocator((CFTypeRef)v47);
        uint64_t v260 = AMAuthInstallSupportCreatePrependedFilePath(v282, @"DeviceTree", v258, v372);
        if (!v260)
        {
          if (v372[0])
          {
            CFDictionarySetValue(v248, @"DeviceTree", v372[0]);
            SafeRelease(v372[0]);
            v372[0] = 0;
          }
          SafeRelease(v258);
          goto LABEL_220;
        }
      }
LABEL_267:
      uint64_t Code = v260;
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallCreateAlignmentDictionary", (uint64_t)"failed to prepend entry name to path", v261, v262, v263, v264, v265, v340);
      CFTypeRef v285 = 0;
      goto LABEL_232;
    }
LABEL_272:
    uint64_t Code = 2;
    goto LABEL_255;
  }
  uint64_t v49 = (void *)v48;
  CFIndex v50 = 0;
  CFStringRef v51 = @"RecoveryOS";
  CFBooleanRef v52 = kCFBooleanFalse;
  key = (void *)v48;
  while (1)
  {
    CFStringRef v53 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v50);
    if (!v53) {
      sub_100071F2C();
    }
    CFStringRef v54 = v53;
    CFBooleanRef v55 = CFStringFind(v53, v51, 0).location == -1 ? v52 : kCFBooleanTrue;
    int v56 = CFBooleanGetValue(v55);
    int v57 = CFBooleanGetValue(BOOLean);
    if (v56)
    {
      if (!v57) {
        goto LABEL_48;
      }
      SafeRelease(v361);
      CFAllocatorRef v58 = CFGetAllocator((CFTypeRef)v47);
      CFStringRef v54 = AMAuthInstallICreateTranslationOfRecoveryEnteryName(v58, v54);
      CFStringRef v361 = v54;
    }
    else if (v57)
    {
      goto LABEL_48;
    }
    CFDictionaryRef v59 = (const __CFDictionary *)CFDictionaryGetValue(v363, v54);
    if (!v59)
    {
      AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"no entry in manifest found for \"%@\"", v60, v61, v62, v63, v64, (char)v54);
      goto LABEL_48;
    }
    v372[0] = 0;
    if (!v54)
    {
      uint64_t Code = 1;
      goto LABEL_253;
    }
    CFDictionaryRef v65 = v59;
    int v66 = CFBooleanGetValue(v55);
    uint64_t v67 = sub_100022A08((CFDictionaryRef **)v47, v54, v65, a2, a3, 0, v66, v372);
    if (v67)
    {
      uint64_t Code = v67;
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallLinkedEntry", (uint64_t)"failed to copy bundle URLs for %@", v68, v69, v70, v71, v72, (char)v54);
      goto LABEL_253;
    }
    CFBooleanRef v73 = v52;
    CFStringRef v74 = v51;
    CFURLRef v75 = (const __CFURL *)CFDictionaryGetValue(v372[0], @"SourceURL");
    CFURLRef v76 = (const __CFURL *)CFDictionaryGetValue(v372[0], @"DestURL");
    uint64_t v77 = CFDictionaryGetValue(v372[0], @"RelativeSrcPath");
    uint64_t v78 = v77;
    if (!v75 && !v76 && !v77) {
      break;
    }
    v373.CFIndex length = CFArrayGetCount(v40);
    v373.CFIndex location = 0;
    if (!CFArrayContainsValue(v40, v373, v78))
    {
      CFStringRef v79 = AMAuthInstallPlatformMakeDirectoryForURL(v76);
      if (v79)
      {
        uint64_t Code = (uint64_t)v79;
        char v322 = AMAuthInstallGetLocalizedStatusString(0, (int)v79);
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallLinkedEntry", (uint64_t)"failed to create directory: %@", v323, v324, v325, v326, v327, v322);
        goto LABEL_253;
      }
      uint64_t v80 = AMAuthInstallBundleInstallFile(v365, v76, v75);
      if (v80)
      {
        uint64_t Code = v80;
        char v328 = AMAuthInstallGetLocalizedStatusString(0, v80);
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallLinkedEntry", (uint64_t)"failed to create soft link: %@", v329, v330, v331, v332, v333, v328);
        goto LABEL_253;
      }
      CFArrayAppendValue(v40, v78);
    }
    SafeRelease(v372[0]);
    uint64_t v47 = (uint64_t)v365;
    CFStringRef v51 = v74;
    CFBooleanRef v52 = v73;
    uint64_t v49 = key;
LABEL_48:
    if (v49 == (void *)++v50) {
      goto LABEL_51;
    }
  }
  uint64_t Code = 8;
LABEL_253:
  SafeRelease(v372[0]);
  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundlePopulatePersonalizedBundle", (uint64_t)"failed to install link for \"%@\" in personalized bundle", v334, v335, v336, v337, v338, (char)v54);
  CFURLRef v11 = 0;
LABEL_254:
  CFURLRef v14 = 0;
LABEL_255:
  uint64_t v15 = v354;
LABEL_256:
  CFStringRef v16 = v361;
LABEL_257:
  SafeRelease(v11);
  SafeRelease(v14);
  SafeRelease(v369);
  SafeRelease(context);
  SafeRelease(v367);
  SafeRelease(v366);
  SafeRelease(v15);
  SafeRelease(v16);
  return Code;
}

CFStringRef AMAuthInstallICreateTranslationOfRecoveryEnteryName(const __CFAllocator *a1, CFStringRef theString)
{
  CFRange v4 = CFStringFind(theString, @"RecoveryOS", 0);
  if (v4.location == -1)
  {
    return CFStringCreateCopy(a1, theString);
  }
  else
  {
    CFIndex Length = CFStringGetLength(theString);
    v6.CFIndex length = Length - CFStringGetLength(@"RecoveryOS");
    v6.CFIndex location = v4.length;
    return CFStringCreateWithSubstring(a1, theString, v6);
  }
}

uint64_t sub_10001C400(CFDictionaryRef **a1, const __CFDictionary *a2, const __CFDictionary *a3, const __CFDictionary *a4, const void *a5, const void *a6, __CFArray *a7, const __CFDictionary *a8)
{
  CFURLRef v73 = 0;
  CFStringRef v74 = 0;
  CFURLRef v72 = 0;
  CFURLRef Value = (const __CFURL *)CFDictionaryGetValue(*a1[16], @"VinylFirmware");
  CFURLRef v71 = Value;
  if (Value)
  {
    CFRetain(Value);
    AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedBasebandFirmware", (uint64_t)"using vinyl firmware override: %@ = %@", v17, v18, v19, v20, v21, (char)@"VinylFirmware");
  }
  else
  {
    CFDictionaryRef v34 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"eUICC,Main");
    CFDictionaryRef v35 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"eUICC,Gold");
    if (v34)
    {
      CFDictionaryRef v36 = v35;
      if (v35)
      {
        CFStringRef v37 = (const __CFString *)sub_10001AA98(v34);
        CFStringRef v38 = (const __CFString *)sub_10001AA98(v36);
        if (CFStringCompare(v37, v38, 0)) {
          goto LABEL_27;
        }
        if (v37 && v38)
        {
          CFAllocatorRef v44 = CFGetAllocator(a1);
          uint64_t v45 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v44, a5, v37, 0, &v71);
          if (v45) {
            goto LABEL_25;
          }
        }
        else
        {
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedBasebandFirmware", (uint64_t)"%@ OR %@ key not found, but that's okay. Moving along...", v39, v40, v41, v42, v43, (char)@"eUICC,Main");
        }
      }
    }
  }
  CFURLRef v22 = (const __CFURL *)CFDictionaryGetValue(*a1[16], @"BasebandFirmware");
  CFURLRef v73 = v22;
  if (!v22)
  {
    CFDictionaryRef v46 = sub_10001AA98(a2);
    if (v46)
    {
      CFStringRef v52 = (const __CFString *)v46;
      CFAllocatorRef v53 = CFGetAllocator(a1);
      uint64_t v45 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v53, a5, v52, 0, &v73);
      if (!v45) {
        goto LABEL_14;
      }
LABEL_25:
      uint64_t v68 = v45;
      CFStringRef v60 = 0;
      goto LABEL_20;
    }
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedBasebandFirmware", (uint64_t)"%@ key not found.", v47, v48, v49, v50, v51, (char)@"BasebandFirmware");
LABEL_27:
    CFStringRef v60 = 0;
    uint64_t v68 = 1;
    goto LABEL_20;
  }
  CFRetain(v22);
  AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedBasebandFirmware", (uint64_t)"using baseband firmware override: %@ = %@", v23, v24, v25, v26, v27, (char)@"BasebandFirmware");
  a2 = 0;
LABEL_14:
  uint64_t BasebandComponentName = AMAuthInstallBundleCopyNextBasebandComponentName(a1, (CFTypeRef *)&v74, v28, v29, v30, v31, v32, v33);
  CFStringRef v60 = v74;
  if (BasebandComponentName) {
    goto LABEL_22;
  }
  if (!v74)
  {
    AMAuthInstallLog(4, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedBasebandFirmware", (uint64_t)"server provided unneeded baseband data; ignoring it",
      v55,
      v56,
      v57,
      v58,
      v59,
      v70);
    uint64_t v68 = 0;
    goto LABEL_20;
  }
  CFAllocatorRef v61 = CFGetAllocator(a1);
  uint64_t BasebandComponentName = AMAuthInstallPlatformCopyURLWithAppendedComponent(v61, a6, v60, 0, &v72);
  if (BasebandComponentName)
  {
LABEL_22:
    uint64_t v68 = BasebandComponentName;
  }
  else
  {
    DirectoryForURL = AMAuthInstallPlatformMakeDirectoryForURL(v72);
    if (DirectoryForURL)
    {
      uint64_t v68 = (uint64_t)DirectoryForURL;
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleInstallPersonalizedBasebandFirmware", (uint64_t)"failed to create output directory", v63, v64, v65, v66, v67, v70);
    }
    else
    {
      uint64_t v68 = AMAuthInstallBasebandPersonalizeFirmwareInternal(a1, v73, v71, v72, a2, a3, a8);
      if (!v68) {
        CFArrayAppendValue(a7, v60);
      }
    }
  }
LABEL_20:
  SafeRelease(v60);
  SafeRelease(v73);
  SafeRelease(v72);
  return v68;
}

uint64_t AMAuthInstallBundleWriteReceipt(void *a1, const void *a2, const void *a3, const __CFBoolean *a4)
{
  CFErrorRef error = 0;
  CFTypeRef cf = 0;
  CFAllocatorRef v8 = CFGetAllocator(a1);
  uint64_t v9 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v8, a2, @"amai/receipt.plist", 0, (CFURLRef *)&cf);
  if (!v9)
  {
    CFAllocatorRef v13 = CFGetAllocator(a1);
    CFDataRef v11 = CFPropertyListCreateData(v13, a3, kCFPropertyListXMLFormat_v1_0, 0, &error);
    if (error)
    {
      CFStringRef v12 = CFErrorCopyDescription(error);
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleWriteReceipt", (uint64_t)"%@", v14, v15, v16, v17, v18, (char)v12);
    }
    else
    {
      if (v11)
      {
        DirectoryForURL = AMAuthInstallPlatformMakeDirectoryForURL((const __CFURL *)cf);
        if (DirectoryForURL)
        {
          uint64_t v10 = (uint64_t)DirectoryForURL;
          char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, (int)DirectoryForURL);
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleWriteReceipt", (uint64_t)"failed to create receipt directory: %@", v22, v23, v24, v25, v26, LocalizedStatusString);
          AMAuthInstallLog(7, (uint64_t)"AMAuthInstallBundleWriteReceipt", (uint64_t)"%@", v27, v28, v29, v30, v31, (char)cf);
        }
        else
        {
          CFAllocatorRef v32 = CFGetAllocator(a1);
          uint64_t v10 = AMAuthInstallSupportWriteDataToFileURL(v32, v11, (const __CFURL *)cf, 1);
          int Value = CFBooleanGetValue(a4);
          CFDictionaryRef v34 = *(void **)(a1[16] + 8);
          if (!Value)
          {
            SafeRelease(v34);
            CFTypeRef v35 = CFRetain(a3);
            CFStringRef v12 = 0;
            *(void *)(a1[16] + 8) = v35;
            goto LABEL_7;
          }
          CFDictionarySetValue((CFMutableDictionaryRef)v34, @"RecoveryOS", a3);
        }
        goto LABEL_3;
      }
      CFStringRef v12 = 0;
    }
    uint64_t v10 = 2;
    goto LABEL_7;
  }
  uint64_t v10 = v9;
  CFDataRef v11 = 0;
LABEL_3:
  CFStringRef v12 = 0;
LABEL_7:
  SafeRelease(cf);
  SafeRelease(v11);
  SafeRelease(error);
  SafeRelease(v12);
  return v10;
}

uint64_t AMAuthInstallBundleCreatePersonalizedPath(const void *a1, const __CFString *a2, const __CFURL **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return AMAuthInstallBundleCreatePersonalizedPathWithKey(a1, 0, a2, a3, a5, a6, a7, a8);
}

uint64_t AMAuthInstallBundleCreatePersonalizedPathWithKey(const void *a1, CFStringRef theString1, const __CFString *a3, const __CFURL **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFURLRef anURL = 0;
  if (!a1 || !a3 || !a4)
  {
    CFURLRef Copy = 0;
    CFURLRef v23 = 0;
    CFURLRef v15 = 0;
    uint64_t v24 = 1;
    if (!a4) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if (theString1) {
    BOOL v11 = CFEqual(theString1, @"BasebandFirmware");
  }
  else {
    BOOL v11 = 0;
  }
  int IsImg4 = AMAuthInstallApIsImg4((uint64_t)a1, (uint64_t)theString1, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  CFAllocatorRef v13 = CFGetAllocator(a1);
  if (v11 || !IsImg4)
  {
    CFURLRef Copy = (const __CFURL *)CFStringCreateCopy(v13, a3);
    uint64_t v24 = 0;
    CFURLRef v23 = 0;
    CFURLRef v15 = 0;
    goto LABEL_15;
  }
  CFURLRef Copy = CFURLCreateWithFileSystemPath(v13, a3, kCFURLPOSIXPathStyle, 0);
  CFURLRef v15 = Copy;
  if (!Copy) {
    goto LABEL_19;
  }
  CFAllocatorRef v16 = CFGetAllocator(a1);
  uint64_t v17 = AMAuthInstallApImg4CopyURLAddingExtension(v16, v15, (CFTypeRef *)&anURL);
  if (v17)
  {
    uint64_t v24 = v17;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCreatePersonalizedPathWithKey", (uint64_t)"failed to copy personalized URL", v18, v19, v20, v21, v22, v26);
    CFURLRef Copy = 0;
    CFURLRef v23 = 0;
    goto LABEL_15;
  }
  CFURLRef Copy = anURL;
  if (!anURL)
  {
LABEL_19:
    CFURLRef v23 = 0;
    goto LABEL_20;
  }
  CFURLRef Copy = (const __CFURL *)CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
  CFURLRef v23 = Copy;
  if (!Copy)
  {
LABEL_20:
    uint64_t v24 = 2;
    goto LABEL_15;
  }
  CFURLRef Copy = (const __CFURL *)CFRetain(Copy);
  uint64_t v24 = 0;
LABEL_15:
  *a4 = Copy;
LABEL_16:
  SafeRelease(v15);
  SafeRelease(0);
  SafeRelease(anURL);
  SafeRelease(v23);
  return v24;
}

uint64_t AMAuthInstallBundlePersonalizePartialWithRecoveryOS(unint64_t a1, const void *a2, const void *a3, const __CFString *a4, uint64_t a5, const __CFString *a6, const __CFArray *a7, const __CFArray *a8, const __CFArray *a9, char a10)
{
  CFDictionaryRef v329 = 0;
  CFDictionaryRef v330 = 0;
  CFDictionaryRef v327 = 0;
  CFTypeRef v328 = 0;
  CFURLRef v325 = 0;
  CFURLRef v326 = 0;
  uint64_t v324 = 0;
  CFURLRef v322 = 0;
  CFDictionaryRef value = 0;
  CFStringRef v320 = 0;
  CFDictionaryRef v321 = 0;
  if (!*(void *)(a1 + 16))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"bundle personalization requires AP parameters (even with AP personalization disabled)", (uint64_t)a4, a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8, theArray);
    CFMutableDictionaryRef MutableCopy = 0;
    uint64_t v14 = 0;
    CFDictionaryRef v15 = 0;
    CFDictionaryRef v16 = 0;
    CFArrayRef v17 = 0;
    CFDictionaryRef v18 = 0;
    CFURLRef v19 = 0;
    uint64_t v12 = 1;
    goto LABEL_126;
  }
  CFMutableDictionaryRef MutableCopy = 0;
  uint64_t v12 = 1;
  if (!a2)
  {
    uint64_t v14 = 0;
    CFDictionaryRef v15 = 0;
    CFDictionaryRef v16 = 0;
    CFArrayRef v17 = 0;
    CFDictionaryRef v18 = 0;
    CFURLRef v19 = 0;
    goto LABEL_126;
  }
  uint64_t v14 = 0;
  CFDictionaryRef v15 = 0;
  CFDictionaryRef v16 = 0;
  CFArrayRef v17 = 0;
  CFDictionaryRef v18 = 0;
  CFURLRef v19 = 0;
  if (a3)
  {
    uint64_t v21 = (const void *)a5;
    sub_10001DC54((void *)a1);
    _AMAuthInstallBundleCreateDebugDirectory((CFTypeRef *)a1, a3);
    uint64_t v22 = AMAuthInstallBundleCopyBuildIdentityForVariant(a1, a2, a4, (CFTypeRef *)&v330);
    if (v22)
    {
      uint64_t v12 = v22;
      CFMutableDictionaryRef MutableCopy = 0;
      uint64_t v14 = 0;
      CFDictionaryRef v15 = 0;
      CFDictionaryRef v16 = 0;
      CFArrayRef v17 = 0;
      CFDictionaryRef v18 = 0;
      CFURLRef v19 = 0;
      goto LABEL_126;
    }
    if (v330)
    {
      CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)a1);
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v23, 0, v330);
      CFDictionaryRef v15 = MutableCopy;
      if (!MutableCopy)
      {
        uint64_t v14 = 0;
        CFDictionaryRef v16 = 0;
        CFArrayRef v17 = 0;
        CFDictionaryRef v18 = 0;
        CFURLRef v19 = 0;
LABEL_165:
        uint64_t v12 = 2;
        goto LABEL_126;
      }
      if (!v21)
      {
        CFDictionaryRef v18 = 0;
        CFURLRef v19 = 0;
        if (a7) {
          goto LABEL_12;
        }
        goto LABEL_15;
      }
      CFAllocatorRef v24 = CFGetAllocator((CFTypeRef)a1);
      CFURLRef v19 = CFURLCreateCopyAppendingPathComponent(v24, (CFURLRef)a3, @"RecoveryOS", 1u);
      uint64_t v25 = AMAuthInstallBundleCopyBuildIdentityForVariant(a1, v21, a6, (CFTypeRef *)&v329);
      if (v25)
      {
        uint64_t v12 = v25;
        CFMutableDictionaryRef MutableCopy = 0;
        uint64_t v14 = 0;
        CFDictionaryRef v16 = 0;
        CFArrayRef v17 = 0;
        goto LABEL_176;
      }
      if (v329)
      {
        CFAllocatorRef v26 = CFGetAllocator((CFTypeRef)a1);
        CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v26, 0, v329);
        CFDictionaryRef v18 = MutableCopy;
        if (!MutableCopy)
        {
          uint64_t v14 = 0;
          CFDictionaryRef v16 = 0;
          CFArrayRef v17 = 0;
          goto LABEL_165;
        }
        _AMAuthInstallBundleCreateDebugDirectory((CFTypeRef *)a1, v19);
        if (a7)
        {
LABEL_12:
          CFAllocatorRef v27 = CFGetAllocator((CFTypeRef)a1);
          CFMutableDictionaryRef MutableCopy = CFArrayCreateMutableCopy(v27, 0, a7);
          CFArrayRef v17 = MutableCopy;
          if (!MutableCopy)
          {
            uint64_t v14 = 0;
LABEL_156:
            CFDictionaryRef v16 = v18;
            CFDictionaryRef v18 = 0;
            goto LABEL_165;
          }
          goto LABEL_16;
        }
LABEL_15:
        CFArrayRef v17 = 0;
LABEL_16:
        CFTypeRef cf = a3;
        CFAllocatorRef v28 = CFGetAllocator((CFTypeRef)a1);
        if (a9) {
          CFMutableDictionaryRef Mutable = CFArrayCreateMutableCopy(v28, 0, a9);
        }
        else {
          CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v28, 0, &kCFTypeArrayCallBacks);
        }
        uint64_t v14 = Mutable;
        if (!Mutable)
        {
          CFMutableDictionaryRef MutableCopy = v17;
          CFArrayRef v17 = 0;
          goto LABEL_156;
        }
        if (!a10 || !v17) {
          goto LABEL_25;
        }
        uint64_t v30 = sub_10001DDAC(a1, v15, v17, Mutable);
        if (!v30)
        {
          if (!v18)
          {
            uint64_t IfNecessary = AMAuthInstallBundleCopyReceiptCreateIfNecessary(a1, (const __CFURL *)a3, (CFPropertyListRef *)&v324);
            if (!IfNecessary) {
              goto LABEL_30;
            }
            goto LABEL_157;
          }
          uint64_t v30 = sub_10001DDAC(a1, v18, v17, v14);
          if (!v30)
          {
LABEL_25:
            uint64_t IfNecessary = AMAuthInstallBundleCopyReceiptCreateIfNecessary(a1, (const __CFURL *)a3, (CFPropertyListRef *)&v324);
            if (!IfNecessary)
            {
              if (v18)
              {
                uint64_t v32 = AMAuthInstallBundleCopyReceiptCreateIfNecessary(a1, v19, (CFPropertyListRef *)&value);
                if (v32)
                {
                  uint64_t v12 = v32;
                  char theArray = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v32);
                  CFAllocatorRef v288 = "failed to generate a recovery OS receipt: %@";
                  goto LABEL_174;
                }
                CFDictionarySetValue(v324, @"RecoveryOS", value);
                SafeRelease(value);
                int v307 = 1;
                goto LABEL_31;
              }
LABEL_30:
              int v307 = 0;
LABEL_31:
              uint64_t v33 = sub_10001E624((CFDictionaryRef **)a1, v17, (const __CFURL *)a2, (const __CFURL *)a3, v15, (const __CFURL *)v21, v18);
              if (v33)
              {
                uint64_t v12 = v33;
                CFAllocatorRef v288 = "failed to create build identity with overrides";
                goto LABEL_174;
              }
              v316 = v21;
              if (!*(void *)(a1 + 48)) {
                goto LABEL_77;
              }
              v332[0] = 0;
              CFAllocatorRef v39 = CFGetAllocator((CFTypeRef)a1);
              CFArrayRef v47 = _CFArrayCreateWithObjects(v39, v40, v41, v42, v43, v44, v45, v46, @"BbProvisioningManifestKeyHash");
              CFURLRef v310 = v19;
              CFDictionaryRef v308 = v18;
              if (!v47)
              {
                uint64_t v12 = 2;
                goto LABEL_57;
              }
              uint64_t v48 = AMAuthInstallBundleCopyBuildIdentityForVariant(a1, a2, a4, v332);
              if (v48)
              {
                uint64_t v12 = v48;
                goto LABEL_57;
              }
              CFIndex Count = CFArrayGetCount(v47);
              if (Count < 1)
              {
                uint64_t v12 = 0;
                goto LABEL_56;
              }
              CFIndex v50 = Count;
              CFIndex v51 = 0;
              while (1)
              {
                uint64_t v331 = 0;
                CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v47, v51);
                if (!ValueAtIndex)
                {
LABEL_145:
                  uint64_t v12 = 14;
                  goto LABEL_54;
                }
                CFStringRef v53 = ValueAtIndex;
                CFDataRef v54 = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 216), ValueAtIndex);
                if (v54)
                {
                  CFDataRef v60 = v54;
                  AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleSetBasebandKeyHashes", (uint64_t)"setting (from PR2 document/Override): %@ = %@", v55, v56, v57, v58, v59, (char)v53);
                  if (AMAuthInstallBasebandSetKeyHashInternal(a1, v53, v60)) {
                    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleSetBasebandKeyHashes", (uint64_t)"Failed setting (from PR2 document/Override) %@ = %@", v61, v62, v63, v64, v65, (char)v53);
                  }
                }
                else
                {
                  uint64_t v66 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 208), v53);
                  if (v66)
                  {
                    CFURLRef v72 = v66;
                    CFURLRef v73 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 200), v53);
                    if (v73 && !CFEqual(v73, v72))
                    {
                      AMAuthInstallLog(4, (uint64_t)"_AMAuthInstallBundleSetBasebandKeyHashes", (uint64_t)"key hash mismatch, triggering bbfw re-personalization", v74, v75, v76, v77, v78, theArray);
                      *(unsigned char *)(a1 + 224) = 1;
                    }
                    AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleSetBasebandKeyHashes", (uint64_t)"setting (from hash baseband returned): %@ = %@", v74, v75, v76, v77, v78, (char)v53);
                    if (AMAuthInstallBasebandSetKeyHashInternal(a1, v53, (CFDataRef)v72)) {
                      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleSetBasebandKeyHashes", (uint64_t)"Failed setting (from hash baseband returned) %@ = %@", v79, v80, v81, v82, v83, (char)v53);
                    }
                  }
                  else
                  {
                    CFComparisonResult TagForKeyHashName = AMAuthInstallBasebandGetTagForKeyHashName(a1, v53, &v331, v67, v68, v69, v70, v71);
                    if (TagForKeyHashName)
                    {
                      uint64_t v12 = TagForKeyHashName;
LABEL_54:
                      CFURLRef v19 = v310;
                      CFDictionaryRef v18 = v308;
LABEL_56:
                      uint64_t v21 = v316;
LABEL_57:
                      SafeRelease(v47);
                      SafeRelease(v332[0]);
                      if (v12) {
                        goto LABEL_175;
                      }
                      v332[0] = 0;
                      int v97 = AMAuthInstallBundleCopyBuildIdentityForVariant(a1, a2, a4, v332);
                      if (!v97)
                      {
                        CFBooleanRef v103 = CFDictionaryGetValue((CFDictionaryRef)v332[0], @"BbFactoryDebugEnable");
                        if (!v103
                          || (int v104 = v103,
                              CFURLRef v105 = v19,
                              CFTypeID TypeID = CFBooleanGetTypeID(),
                              BOOL v107 = TypeID == CFGetTypeID(v104),
                              CFURLRef v19 = v105,
                              uint64_t v21 = v316,
                              !v107))
                        {
LABEL_67:
                          SafeRelease(v332[0]);
                          if (*(unsigned char *)(a1 + 224))
                          {
                            if (!v324)
                            {
                              CFURLRef v267 = v19;
                              CFDictionaryRef v264 = v18;
                              CFStringRef v275 = v17;
                              uint64_t v12 = 1;
                              goto LABEL_147;
                            }
                            CFArrayRef v110 = (const __CFArray *)CFDictionaryGetValue(v324, @"Personalized");
                            if (!v110)
                            {
                              CFURLRef v267 = v19;
                              CFDictionaryRef v264 = v18;
                              CFStringRef v275 = v17;
                              AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleRemovePersonalizedBbfw", (uint64_t)"failed to find personalized array", v111, v112, v113, v114, v115, theArray);
                              uint64_t v12 = 14;
                              goto LABEL_147;
                            }
                            CFArrayRef v116 = v110;
                            CFIndex v117 = CFArrayGetCount(v110);
                            if (v117 >= 1)
                            {
                              CFIndex v118 = v117;
                              CFIndex v119 = 0;
                              while (1)
                              {
                                CFStringRef v120 = (const __CFString *)CFArrayGetValueAtIndex(v116, v119);
                                if (!v120) {
                                  break;
                                }
                                char v126 = (char)v120;
                                if (CFStringHasSuffix(v120, @".bbfw"))
                                {
                                  AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleRemovePersonalizedBbfw", (uint64_t)"removing personalizedEntry %@", v127, v128, v129, v130, v131, v126);
                                  CFArrayRemoveValueAtIndex(v116, v119--);
                                  --v118;
                                }
                                if (++v119 >= v118) {
                                  goto LABEL_76;
                                }
                              }
                              CFStringRef v275 = v17;
                              AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleRemovePersonalizedBbfw", (uint64_t)"failed to find personalized entry %d", v121, v122, v123, v124, v125, v119);
                              uint64_t v12 = 14;
                              CFDictionaryRef v264 = v308;
                              CFURLRef v267 = v310;
LABEL_147:
                              char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v12);
                              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"failed to remove bbfw: %@", v277, v278, v279, v280, v281, LocalizedStatusString);
LABEL_148:
                              CFArrayRef v17 = 0;
                              CFDictionaryRef v18 = 0;
                              CFMutableDictionaryRef MutableCopy = v275;
LABEL_143:
                              CFDictionaryRef v16 = v264;
                              CFURLRef v19 = v267;
                              goto LABEL_126;
                            }
LABEL_76:
                            *(unsigned char *)(a1 + 224) = 0;
                            CFDictionaryRef v18 = v308;
                            CFURLRef v19 = v310;
                            uint64_t v21 = v316;
                          }
LABEL_77:
                          if (!v17)
                          {
                            CFArrayRef v313 = 0;
                            goto LABEL_111;
                          }
                          v333.CFIndex length = CFArrayGetCount(v17);
                          v333.CFIndex location = 0;
                          if (!CFArrayContainsValue(v17, v333, @"BasebandFirmware")
                            || (LOBYTE(v332[0]) = 0,
                                LOBYTE(v331) = 0,
                                int v132 = *(_DWORD *)(a1 + 304),
                                AMAuthInstallBasebandIsFused(a1, v332))
                            || (!LOBYTE(v332[0])
                              ? (BOOL v140 = AMAuthInstallBasebandPersonalizationRequired(a1, v133, v134, v135, v136, v137, v138, v139) != 0): (BOOL v140 = 0), AMAuthInstallBasebandLocalSigningEnabled(a1, &v331, v134, v135, v136, v137, v138, v139)|| !v140 && !(_BYTE)v331 && !v132))
                          {
LABEL_100:
                            CFArrayRef v313 = 0;
                            goto LABEL_101;
                          }
                          CFURLRef v311 = v19;
                          int v141 = *(_DWORD *)(a1 + 304);
                          CFArrayRef v142 = (const __CFArray *)CFDictionaryGetValue(v324, @"Personalized");
                          if (v142)
                          {
                            CFArrayRef v148 = v142;
                            CFDictionaryRef v149 = (const __CFDictionary *)CFDictionaryGetValue(v15, @"Manifest");
                            if (v149)
                            {
                              CFDictionaryRef v314 = v149;
                              CFDictionaryRef v155 = (const __CFDictionary *)CFDictionaryGetValue(v149, @"BasebandFirmware");
                              if ((unint64_t)v155 | (unint64_t)CFDictionaryGetValue(**(CFDictionaryRef **)(a1 + 128), @"BasebandFirmware"))
                              {
                                sub_10001F2F0(v17, @"BasebandFirmware");
                                uint64_t BasebandComponentName = AMAuthInstallBundleCopyNextBasebandComponentName((const void *)a1, (CFTypeRef *)&v320, v161, v162, v163, v164, v165, v166);
                                if (BasebandComponentName) {
                                  goto LABEL_184;
                                }
                                CFStringRef v173 = v320;
                                if (!v320)
                                {
                                  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"nextBbfwComponentStr is NULL", v168, v169, v170, v171, v172, theArray);
                                  CFMutableDictionaryRef MutableCopy = v17;
                                  CFArrayRef v17 = 0;
                                  CFDictionaryRef v16 = v18;
                                  CFDictionaryRef v18 = 0;
                                  uint64_t v12 = 14;
                                  goto LABEL_193;
                                }
                                v334.CFIndex length = CFArrayGetCount(v148);
                                v334.CFIndex location = 0;
                                if (CFArrayContainsValue(v148, v334, v173))
                                {
                                  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"entry \"%@\" has been previously personalized; skipping it",
                                    v174,
                                    v175,
                                    v176,
                                    v177,
                                    v178,
                                    (char)v173);
                                  if (v141)
                                  {
                                    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"inserting provisioning info (if any) into existing bbfw for \"%@\"", v179, v180, v181, v182, v183, (char)v173);
                                    CFAllocatorRef v184 = CFGetAllocator((CFTypeRef)a1);
                                    uint64_t BasebandComponentName = AMAuthInstallPlatformCopyURLWithAppendedComponent(v184, cf, v173, 0, &v322);
                                    uint64_t v21 = v316;
                                    if (!BasebandComponentName)
                                    {
                                      if (v322)
                                      {
                                        CFIndex v190 = AMAuthInstallBasebandCopyFirmware((const void *)a1, v322, v322);
                                        if (!v190)
                                        {
                                          uint64_t v196 = AMAuthInstallBasebandCopyAllComponents((const void *)a1, v322, (CFTypeRef *)&v321);
                                          CFURLRef v19 = v311;
                                          if (v196)
                                          {
                                            uint64_t v12 = v196;
                                            CFAllocatorRef v288 = "AMAuthInstallBasebandCopyAllComponents failed";
                                          }
                                          else
                                          {
                                            CFIndex v197 = AMAuthInstallBasebandWriteFilesToBbfw(a1, v322, v321);
                                            if (!v197) {
                                              goto LABEL_100;
                                            }
                                            uint64_t v12 = v197;
                                            CFAllocatorRef v288 = "AMAuthInstallBasebandWriteFilesToBbfw failed";
                                          }
LABEL_174:
                                          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)v288, v34, v35, v36, v37, v38, theArray);
LABEL_175:
                                          CFMutableDictionaryRef MutableCopy = v17;
                                          CFArrayRef v17 = 0;
                                          CFDictionaryRef v16 = v18;
LABEL_176:
                                          CFDictionaryRef v18 = 0;
                                          goto LABEL_126;
                                        }
                                        uint64_t v12 = v190;
                                        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"AMAuthInstallBasebandCopyFirmware failed", v191, v192, v193, v194, v195, theArray);
LABEL_192:
                                        CFMutableDictionaryRef MutableCopy = v17;
                                        CFArrayRef v17 = 0;
                                        CFDictionaryRef v16 = v18;
                                        CFDictionaryRef v18 = 0;
                                      }
                                      else
                                      {
                                        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"bbfwURL AMAuthInstallPlatformCopyURLWithAppendedComponent failed", v185, v186, v187, v188, v189, theArray);
                                        CFMutableDictionaryRef MutableCopy = v17;
                                        CFArrayRef v17 = 0;
                                        CFDictionaryRef v16 = v18;
                                        CFDictionaryRef v18 = 0;
                                        uint64_t v12 = 2;
                                      }
LABEL_193:
                                      CFURLRef v19 = v311;
                                      goto LABEL_126;
                                    }
LABEL_184:
                                    uint64_t v12 = BasebandComponentName;
                                    goto LABEL_192;
                                  }
                                  CFArrayRef v313 = 0;
                                  CFURLRef v19 = v311;
                                  uint64_t v21 = v316;
LABEL_101:
                                  CFIndex v198 = sub_10001F354(a1, v17, v15, v324, a2, v18, &v328, &v327);
                                  if (v198)
                                  {
                                    uint64_t v12 = v198;
                                  }
                                  else
                                  {
                                    unint64_t v199 = (unint64_t)CFDictionaryGetValue(v324, @"CumulativeResponse");
                                    if (v199 | (unint64_t)v328)
                                    {
                                      if (!v328)
                                      {
                                        CFURLRef v326 = (const __CFURL *)CFRetain((CFTypeRef)v199);
                                        AMAuthInstallLog(7, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"This is an install/stitch-only request.", v209, v210, v211, v212, v213, theArray);
                                        goto LABEL_111;
                                      }
                                      uint64_t PersonalizedResponse = AMAuthInstallApCreatePersonalizedResponse(a1, (CFDictionaryRef)v328, (CFTypeRef *)&v326);
                                      if (!PersonalizedResponse)
                                      {
                                        int v206 = v307;
                                        if (!v327) {
                                          int v206 = 0;
                                        }
                                        if (v206 == 1)
                                        {
                                          uint64_t v207 = AMAuthInstallApCreatePersonalizedResponse(a1, v327, (CFTypeRef *)&v325);
                                          if (v207)
                                          {
                                            uint64_t v12 = v207;
                                            uint64_t v208 = "failed to create ap ticket for recovery OS";
                                            goto LABEL_180;
                                          }
                                        }
LABEL_111:
                                        CFDictionaryRef v214 = (const __CFDictionary *)CFDictionaryGetValue(v324, @"Updaters");
                                        if (!v214)
                                        {
                                          CFDictionaryRef v234 = v15;
                                          CFArrayRef v235 = v14;
                                          CFDictionaryRef v226 = 0;
                                          CFBooleanRef v227 = kCFBooleanFalse;
                                          goto LABEL_119;
                                        }
                                        CFDictionaryRef v215 = v214;
                                        CFURLRef v216 = v19;
                                        CFIndex v217 = CFDictionaryGetCount(v214);
                                        uint64_t v218 = (const void **)malloc(8 * v217);
                                        if (v218)
                                        {
                                          uint64_t v219 = v218;
                                          *(void *)uint64_t v305 = v17;
                                          uint64_t v220 = v14;
                                          CFDictionaryRef v221 = v18;
                                          CFDictionaryRef v222 = v15;
                                          CFDictionaryGetKeysAndValues(v215, v218, 0);
                                          if (v217 >= 1)
                                          {
                                            uint64_t v223 = v219;
                                            do
                                            {
                                              uint64_t v224 = *v223++;
                                              uint64_t v225 = (__CFDictionary *)CFDictionaryGetValue(v215, v224);
                                              CFDictionaryRemoveValue(v225, @"RequestTags");
                                              --v217;
                                            }
                                            while (v217);
                                          }
                                          CFDictionaryRef v226 = (const __CFDictionary *)v219;
                                          CFBooleanRef v227 = kCFBooleanFalse;
                                          uint64_t v228 = AMAuthInstallBundleWriteReceipt((void *)a1, cf, v324, kCFBooleanFalse);
                                          CFURLRef v19 = v216;
                                          if (v228)
                                          {
                                            uint64_t v12 = v228;
                                            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"AMAuthInstallBundleWriteReceipt returned %d", v229, v230, v231, v232, v233, v228);
                                            CFDictionaryRef v15 = v222;
                                            CFDictionaryRef v16 = v221;
                                            uint64_t v295 = v220;
                                            CFMutableDictionaryRef MutableCopy = *(CFMutableDictionaryRef *)v305;
                                            CFArrayRef v17 = v313;
                                            CFDictionaryRef v18 = v226;
                                            uint64_t v14 = v295;
                                            goto LABEL_126;
                                          }
                                          CFDictionaryRef v234 = v222;
                                          CFDictionaryRef v18 = v221;
                                          CFArrayRef v235 = v220;
                                          CFArrayRef v17 = *(const __CFArray **)v305;
                                          uint64_t v21 = v316;
LABEL_119:
                                          CFBooleanRef BOOLean = v227;
                                          CFArrayRef v236 = v235;
                                          CFDictionaryRef v15 = v234;
                                          uint64_t v237 = _AMAuthInstallBundlePopulatePersonalizedBundle(a1, a2, cf, (int)a4, v234, v326, v324, v17, a8, v235, BOOLean);
                                          if (v237)
                                          {
                                            uint64_t v12 = v237;
                                            char v289 = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v237);
                                            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"failed to personalize bundle", v290, v291, v292, v293, v294, v289);
                                          }
                                          else
                                          {
                                            if (v327)
                                            {
                                              uint64_t v238 = v21;
                                              CFURLRef v239 = v19;
                                              CFURLRef v240 = v19;
                                              CFDictionaryRef v241 = v18;
                                              uint64_t v242 = v17;
                                              uint64_t v12 = _AMAuthInstallBundlePopulatePersonalizedBundle(a1, v238, v240, (int)a6, v18, v325, v324, v17, a8, v236, kCFBooleanTrue);
                                              if (v12)
                                              {
                                                char v296 = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v12);
                                                AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"failed to personalize recovery OS bundle", v297, v298, v299, v300, v301, v296);
                                              }
                                              CFArrayRef v17 = v313;
                                              CFMutableDictionaryRef MutableCopy = v242;
                                              CFDictionaryRef v18 = v226;
                                              CFDictionaryRef v16 = v241;
                                              uint64_t v14 = v236;
                                              CFURLRef v19 = v239;
                                              goto LABEL_126;
                                            }
                                            uint64_t v12 = 0;
                                          }
                                          CFMutableDictionaryRef MutableCopy = v17;
                                          CFArrayRef v17 = v313;
                                          CFDictionaryRef v16 = v18;
                                          CFDictionaryRef v18 = v226;
                                          uint64_t v14 = v236;
                                          goto LABEL_126;
                                        }
                                        CFDictionaryRef v16 = v18;
                                        CFDictionaryRef v18 = 0;
                                        uint64_t v12 = 2;
                                        CFURLRef v19 = v216;
LABEL_183:
                                        CFMutableDictionaryRef MutableCopy = v17;
                                        CFArrayRef v17 = v313;
                                        goto LABEL_126;
                                      }
                                      uint64_t v12 = PersonalizedResponse;
                                      uint64_t v208 = "failed to create ap ticket";
LABEL_180:
                                      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)v208, v201, v202, v203, v204, v205, theArray);
                                    }
                                    else
                                    {
                                      uint64_t v12 = 0;
                                    }
                                  }
                                  CFDictionaryRef v16 = v18;
                                  CFDictionaryRef v18 = 0;
                                  goto LABEL_183;
                                }
                                uint64_t v309 = v14;
                                AMAuthInstallLog(7, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"performing separate baseband firmware personalization of %@", v174, v175, v176, v177, v178, (char)v173);
                                v245 = CFDictionaryGetValue(v15, @"UniqueBuildID");
                                *(void *)uint64_t v306 = v17;
                                if (!v245)
                                {
                                  AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"this build lacks UniqueBuildID", v246, v247, v248, v249, v250, theArray);
                                  CFArrayRef v17 = 0;
                                  uint64_t v254 = cf;
                                  goto LABEL_132;
                                }
                                CFStringRef v251 = v245;
                                CFAllocatorRef v252 = CFGetAllocator((CFTypeRef)a1);
                                CFTypeRef v253 = CFDictionaryCreateMutable(v252, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                                uint64_t v254 = cf;
                                if (v253)
                                {
                                  CFArrayRef v17 = v253;
                                  CFDictionarySetValue(v253, @"UniqueBuildID", v251);
LABEL_132:
                                  uint64_t v255 = *(void *)(a1 + 16);
                                  if (*(void *)(v255 + 120) || *(void *)(v255 + 128))
                                  {
                                    CFStringRef v256 = CFDictionaryGetValue(v15, @"ProductMarketingVersion");
                                    if (v256)
                                    {
                                      uint64_t v262 = v256;
                                      if (v17
                                        || (CFAllocatorRef v263 = CFGetAllocator((CFTypeRef)a1),
                                            (CFArrayRef v17 = CFDictionaryCreateMutable(v263, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks)) != 0))
                                      {
                                        CFDictionarySetValue(v17, @"ProductMarketingVersion", v262);
                                        goto LABEL_139;
                                      }
LABEL_198:
                                      CFDictionaryRef v16 = v18;
                                      CFDictionaryRef v18 = 0;
                                      uint64_t v12 = 2;
                                      uint64_t v14 = v309;
                                      CFURLRef v19 = v311;
                                      CFMutableDictionaryRef MutableCopy = *(CFMutableDictionaryRef *)v306;
                                      goto LABEL_126;
                                    }
                                    AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"this build lacks ProductMarketingVersion", v257, v258, v259, v260, v261, theArray);
                                  }
LABEL_139:
                                  CFDictionaryRef v264 = v18;
                                  CFDictionaryRef v265 = v314;
                                  CFArrayRef v313 = v17;
                                  uint64_t v266 = sub_10001C400((CFDictionaryRef **)a1, v155, 0, v265, a2, v254, v148, v17);
                                  uint64_t v14 = v309;
                                  CFURLRef v267 = v311;
                                  if (v266)
                                  {
                                    uint64_t v12 = v266;
                                  }
                                  else
                                  {
                                    uint64_t v268 = AMAuthInstallBundleWriteReceipt((void *)a1, v254, v324, kCFBooleanFalse);
                                    uint64_t v21 = v316;
                                    if (!v268)
                                    {
                                      CFArrayRef v17 = *(const __CFArray **)v306;
                                      CFURLRef v19 = v311;
                                      goto LABEL_101;
                                    }
                                    uint64_t v12 = v268;
                                    char v269 = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v268);
                                    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"failed to write receipt: %@", v270, v271, v272, v273, v274, v269);
                                  }
                                  CFDictionaryRef v18 = 0;
                                  CFMutableDictionaryRef MutableCopy = *(CFMutableDictionaryRef *)v306;
                                  goto LABEL_143;
                                }
                                CFArrayRef v17 = 0;
                                goto LABEL_198;
                              }
                              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"'%@' not found in manifestDict", v156, v157, v158, v159, v160, (char)@"BasebandFirmware");
                            }
                            else
                            {
                              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"'%@' not found in buildIdentity", v150, v151, v152, v153, v154, (char)@"Manifest");
                            }
                          }
                          else
                          {
                            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"'%@' not found in receiptDict", v143, v144, v145, v146, v147, (char)@"Personalized");
                          }
                          CFMutableDictionaryRef MutableCopy = v17;
                          CFArrayRef v17 = 0;
                          CFDictionaryRef v16 = v18;
                          CFDictionaryRef v18 = 0;
                          uint64_t v12 = 8;
                          goto LABEL_193;
                        }
                        if (CFBooleanGetValue((CFBooleanRef)v104) == 1)
                        {
                          AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleSetBasebandFactoryDebugEnable", (uint64_t)"setting (from build manifest): %@ = %@", v98, v99, v100, v101, v102, (char)@"BbFactoryDebugEnable");
                          if (!AMAuthInstallSetBbRequestEntry((const void *)a1, @"BbFactoryDebugEnable", kCFBooleanTrue))goto LABEL_67; {
                          CFArrayRef theArraya = (CFArrayRef)@"BbFactoryDebugEnable";
                          }
                          v108 = "Failed setting (from build manifest) %@ : CFErrorRef error = %d";
LABEL_169:
                          uint64_t v109 = 3;
                        }
                        else
                        {
                          CFArrayRef theArraya = (CFArrayRef)@"BbFactoryDebugEnable";
                          uint64_t v108 = "%@ (from build manifest) is not true. Not setting it";
                          uint64_t v109 = 6;
                        }
                        AMAuthInstallLog(v109, (uint64_t)"_AMAuthInstallBundleSetBasebandFactoryDebugEnable", (uint64_t)v108, v98, v99, v100, v101, v102, (char)theArraya);
                        goto LABEL_67;
                      }
                      LOBYTE(theArraya) = v97;
                      v108 = "Failed to read build identity : CFErrorRef error = %d";
                      goto LABEL_169;
                    }
                    if (!v331) {
                      goto LABEL_145;
                    }
                    CFDataRef v85 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v332[0], v331);
                    if (v85)
                    {
                      CFDataRef v91 = v85;
                      AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleSetBasebandKeyHashes", (uint64_t)"setting (from build manifest): %@ = %@", v86, v87, v88, v89, v90, (char)v53);
                      if (AMAuthInstallBasebandSetKeyHashInternal(a1, v53, v91)) {
                        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleSetBasebandKeyHashes", (uint64_t)"Failed setting (from build manifest) %@ = %@", v92, v93, v94, v95, v96, (char)v53);
                      }
                    }
                  }
                }
                if (v50 == ++v51)
                {
                  uint64_t v12 = 0;
                  goto LABEL_54;
                }
              }
            }
LABEL_157:
            uint64_t v12 = IfNecessary;
            CFURLRef v267 = v19;
            CFDictionaryRef v264 = v18;
            CFStringRef v275 = v17;
            char v282 = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, IfNecessary);
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizePartialWithRecoveryOS", (uint64_t)"failed to generate a receipt: %@", v283, v284, v285, v286, v287, v282);
            goto LABEL_148;
          }
        }
        uint64_t v12 = v30;
        goto LABEL_175;
      }
      CFMutableDictionaryRef MutableCopy = 0;
      uint64_t v14 = 0;
      CFDictionaryRef v16 = 0;
      CFArrayRef v17 = 0;
      CFDictionaryRef v18 = 0;
    }
    else
    {
      CFMutableDictionaryRef MutableCopy = 0;
      uint64_t v14 = 0;
      CFDictionaryRef v15 = 0;
      CFDictionaryRef v16 = 0;
      CFArrayRef v17 = 0;
      CFDictionaryRef v18 = 0;
      CFURLRef v19 = 0;
    }
    uint64_t v12 = 14;
  }
LABEL_126:
  CFDictionaryRef v243 = v16;
  SafeRelease(MutableCopy);
  SafeRelease(v14);
  SafeRelease(v330);
  SafeRelease(v15);
  SafeRelease(v328);
  SafeRelease(v326);
  SafeRelease(v324);
  SafeRelease(v17);
  SafeRelease(v322);
  SafeRelease(v321);
  SafeRelease(v320);
  SafeFree(v18);
  SafeRelease(v19);
  SafeRelease(v329);
  SafeRelease(v243);
  return v12;
}

CFStringRef sub_10001DC54(void *a1)
{
  if (AMAuthInstallPreferencesGetBooleanValue(0, @"BAAForceEnable", 0)) {
    AMAuthInstallEnableManagedRequest(a1, 0, v2, v3, v4, v5, v6, v7);
  }
  CFStringRef result = AMAuthInstallPreferencesGetBooleanValue(0, @"AlternateUpdateBAAForceEnable", 0);
  if (result)
  {
    return (const __CFString *)AMAuthInstallEnableAlternateUpdateRequest(a1, 0, v9, v10, v11, v12, v13, v14);
  }
  return result;
}

char *_AMAuthInstallBundleCreateDebugDirectory(CFTypeRef *a1, const void *a2)
{
  uint64_t v4 = (CFURLRef *)(a1 + 42);
  SafeRelease(a1[42]);
  CFAllocatorRef v5 = CFGetAllocator(a1);
  uint64_t v6 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v5, a2, @"amai/debug", 1u, v4);
  if (v6)
  {
    uint64_t v7 = v6;
    char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v6);
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCreateDebugDirectory", (uint64_t)"failed to create debug directory within bundle: %@", v9, v10, v11, v12, v13, LocalizedStatusString);
    AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleCreateDebugDirectory", (uint64_t)"bundle: %@", v14, v15, v16, v17, v18, (char)a2);
    return (char *)v7;
  }
  else
  {
    CFURLRef v20 = *v4;
    return AMAuthInstallPlatformMakeDirectoryForURL(v20);
  }
}

uint64_t sub_10001DDAC(uint64_t a1, CFDictionaryRef theDict, const __CFArray *a3, __CFArray *a4)
{
  CFBooleanRef BOOLean = kCFBooleanFalse;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"Info");
  if (Value)
  {
    CFStringRef v8 = (const __CFString *)CFDictionaryGetValue(Value, @"Variant");
    if (v8)
    {
      CFStringRef v9 = *(const __CFString **)(a1 + 496);
      if (v9)
      {
        CFComparisonResult v10 = CFStringCompare(v8, v9, 0);
        CFBooleanRef v11 = kCFBooleanFalse;
        if (v10 == kCFCompareEqualTo) {
          CFBooleanRef v11 = kCFBooleanTrue;
        }
        CFBooleanRef BOOLean = v11;
      }
    }
  }
  CFDictionaryRef v12 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"Manifest");
  if (v12)
  {
    CFDictionaryRef v13 = v12;
    CFIndex Count = CFDictionaryGetCount(v12);
    uint64_t v15 = (const void **)malloc(8 * Count);
    uint64_t v16 = (const void **)malloc(8 * Count);
    CFDictionaryGetKeysAndValues(v13, v15, v16);
    if (Count >= 1)
    {
      uint64_t v78 = a4;
      CFStringRef v17 = 0;
      uint64_t v18 = 0;
      CFStringRef v19 = 0;
      while (1)
      {
        CFStringRef v20 = (const __CFString *)v15[v18];
        uint64_t v21 = v16[v18];
        CFTypeID v22 = CFGetTypeID(v21);
        if (v22 != CFDictionaryGetTypeID())
        {
          AMAuthInstallLog(3, (uint64_t)"_AMRAuthInstallBundleAppendFirmwareEntriesToArrays", (uint64_t)"Unexpected manifest entry structure - should be dictionary.\n", v23, v24, v25, v26, v27, v77);
          uint64_t v75 = 99;
          goto LABEL_31;
        }
        CFAllocatorRef v28 = CFDictionaryGetValue((CFDictionaryRef)v21, @"Info");
        if (v28)
        {
          uint64_t v34 = v28;
          int v35 = _CFDictionaryGetBoolean(v28, @"IsFirmwarePayload", 0, v29, v30, v31, v32, v33);
          int v41 = _CFDictionaryGetBoolean(v34, @"IsSecondaryFirmwarePayload", 0, v36, v37, v38, v39, v40) | v35;
          int v47 = _CFDictionaryGetBoolean(v34, @"IsFUDFirmware", 0, v42, v43, v44, v45, v46);
          int v53 = v41 | v47 | _CFDictionaryGetBoolean(v34, @"IsLoadedByiBoot", 0, v48, v49, v50, v51, v52);
          int v59 = _CFDictionaryGetBoolean(v34, @"IsEarlyAccessFirmware", 0, v54, v55, v56, v57, v58);
          int v65 = v59 | _CFDictionaryGetBoolean(v34, @"IsiBootEANFirmware", 0, v60, v61, v62, v63, v64);
          if (v53 | v65 | _CFDictionaryGetBoolean(v34, @"IsiBootNonEssentialFirmware", 0, v66, v67, v68, v69, v70))
          {
            SafeRelease(v19);
            if (CFBooleanGetValue(BOOLean))
            {
              char v77 = (char)v20;
              CFStringRef Copy = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"RecoveryOS%@");
            }
            else
            {
              CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v20);
            }
            CFStringRef v19 = Copy;
            v81.CFIndex length = CFArrayGetCount(a3);
            v81.CFIndex location = 0;
            if (CFArrayContainsValue(a3, v81, v19))
            {
              if (v17) {
                goto LABEL_26;
              }
            }
            else
            {
              CFArrayAppendValue(a3, v19);
              if (v17) {
                goto LABEL_26;
              }
            }
            CFStringRef v72 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v34, @"Path");
            if (v72)
            {
              CFStringRef v73 = sub_100022E50(kCFAllocatorDefault, v72);
              if (!v73)
              {
                CFStringRef v17 = 0;
LABEL_33:
                uint64_t v75 = 2;
                goto LABEL_31;
              }
              CFStringRef v74 = v73;
              char v77 = (char)v73;
              CFStringRef v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/manifest");
              CFRelease(v74);
              if (!v17) {
                goto LABEL_33;
              }
              if (v78) {
                CFArrayAppendValue(v78, v17);
              }
            }
            else
            {
              CFStringRef v17 = 0;
            }
          }
        }
LABEL_26:
        if (Count == ++v18) {
          goto LABEL_30;
        }
      }
    }
    CFStringRef v19 = 0;
    CFStringRef v17 = 0;
LABEL_30:
    uint64_t v75 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    CFStringRef v19 = 0;
    CFStringRef v17 = 0;
    uint64_t v75 = 7;
  }
LABEL_31:
  SafeFree(v15);
  SafeFree(v16);
  SafeRelease(v17);
  SafeRelease(v19);
  return v75;
}

uint64_t AMAuthInstallBundleCopyReceiptCreateIfNecessary(uint64_t a1, const __CFURL *a2, CFPropertyListRef *a3)
{
  CFURLRef v65 = 0;
  CFPropertyListRef propertyList = 0;
  BOOL v64 = 0;
  CFDictionaryRef context = 0;
  CFMutableDictionaryRef v63 = 0;
  AMAuthInstallLockLock(*(os_unfair_lock_s **)(a1 + 360));
  CFMutableDictionaryRef Mutable = 0;
  uint64_t v7 = 1;
  if (!a3 || !a2)
  {
    CFDictionaryRef v8 = 0;
    CFMutableArrayRef v9 = 0;
    CFMutableDictionaryRef v10 = 0;
    goto LABEL_18;
  }
  CFDictionaryRef v8 = 0;
  CFMutableArrayRef v9 = 0;
  CFMutableDictionaryRef v10 = 0;
  if (*(void *)(a1 + 128))
  {
    CFStringRef v11 = CFURLGetString(a2);
    CFIndex location = CFStringFind(v11, @"RecoveryOS", 0).location;
    CFDictionaryRef v13 = &kCFBooleanTrue;
    if (location == -1) {
      CFDictionaryRef v13 = &kCFBooleanFalse;
    }
    CFBooleanRef v14 = *v13;
    if (*(void *)(*(void *)(a1 + 128) + 8))
    {
      int Value = CFBooleanGetValue(v14);
      uint64_t v16 = *(void *)(a1 + 128);
      CFDictionaryRef v17 = *(const __CFDictionary **)(v16 + 8);
      if (Value)
      {
        CFDictionaryRef v18 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v16 + 8), @"RecoveryOS");
        if (!v18) {
          goto LABEL_14;
        }
        CFDictionaryRef v17 = v18;
      }
      CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(v17, @"Manifest");
      if (v17 && v19 && CFDictionaryGetCount(v19) >= 1)
      {
        CFAllocatorRef v20 = CFGetAllocator((CFTypeRef)a1);
        DeepCFStringRef Copy = CFPropertyListCreateDeepCopy(v20, v17, 2uLL);
        CFMutableDictionaryRef Mutable = 0;
        CFDictionaryRef v8 = 0;
        CFMutableArrayRef v9 = 0;
        CFMutableDictionaryRef v10 = 0;
        *a3 = DeepCopy;
        uint64_t v7 = 2 * (DeepCopy == 0);
        goto LABEL_18;
      }
    }
LABEL_14:
    CFAllocatorRef v22 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v23 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v22, a2, @"amai/receipt.plist", 0, &v65);
    if (v23)
    {
      uint64_t v7 = v23;
LABEL_16:
      CFMutableDictionaryRef Mutable = 0;
LABEL_17:
      CFDictionaryRef v8 = 0;
      CFMutableArrayRef v9 = 0;
      CFMutableDictionaryRef v10 = 0;
      goto LABEL_18;
    }
    uint64_t v25 = AMAuthInstallPlatformFileURLExists(v65, &v64);
    if (v25)
    {
      uint64_t v7 = v25;
      char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v25);
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyReceiptCreateIfNecessary", (uint64_t)"AMAuthInstallPlatformFileURLExists failed: %@", v50, v51, v52, v53, v54, LocalizedStatusString);
      goto LABEL_16;
    }
    BOOL v26 = v64;
    CFAllocatorRef v27 = CFGetAllocator((CFTypeRef)a1);
    if (v26)
    {
      uint64_t v28 = AMAuthInstallSupportCreateDictionaryFromFileURL(v27, &propertyList, v65);
      if (v28)
      {
        uint64_t v7 = v28;
        char v55 = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v28);
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyReceiptCreateIfNecessary", (uint64_t)"failed to read receipt: %@", v56, v57, v58, v59, v60, v55);
        goto LABEL_16;
      }
      CFAllocatorRef v29 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v7 = 2;
      CFDictionaryRef v30 = (const __CFDictionary *)CFPropertyListCreateDeepCopy(v29, propertyList, 2uLL);
      CFMutableDictionaryRef Mutable = v30;
      if (!v30) {
        goto LABEL_17;
      }
      CFDictionaryRef v8 = (const __CFDictionary *)CFDictionaryGetValue(v30, @"Overrides");
      if (v8)
      {
        CFAllocatorRef v31 = CFGetAllocator((CFTypeRef)a1);
        CFDictionaryRef context = CFDictionaryCreateMutable(v31, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (context)
        {
          CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)_AMAuthInstallBundleNormalizeOverridePaths, &context);
          if (CFDictionaryGetCount(**(CFDictionaryRef **)(a1 + 128)) >= 1)
          {
            CFAllocatorRef v32 = CFGetAllocator((CFTypeRef)a1);
            uint64_t v33 = AMAuthInstallSupportCreateMergedDictionary(v32, **(const __CFDictionary ***)(a1 + 128), context, &v63);
            if (v33)
            {
              uint64_t v7 = v33;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyReceiptCreateIfNecessary", (uint64_t)"failed to merge override dictionaries", v34, v35, v36, v37, v38, v61);
              goto LABEL_17;
            }
          }
          SafeRelease(**(CFTypeRef **)(a1 + 128));
          CFMutableDictionaryRef v39 = v63;
          CFAllocatorRef v40 = CFGetAllocator((CFTypeRef)a1);
          p_CFDictionaryRef context = &v63;
          if (!v39) {
            p_CFDictionaryRef context = &context;
          }
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v40, 0, *p_context);
          CFDictionaryRef v8 = 0;
          **(void **)(a1 + 128) = MutableCopy;
          if (!MutableCopy)
          {
            uint64_t v7 = 2;
            CFMutableArrayRef v9 = 0;
            CFMutableDictionaryRef v10 = 0;
            goto LABEL_18;
          }
          CFMutableArrayRef v9 = 0;
          CFMutableDictionaryRef v10 = 0;
          goto LABEL_37;
        }
        goto LABEL_44;
      }
      CFMutableArrayRef v9 = 0;
      CFMutableDictionaryRef v10 = 0;
    }
    else
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v27, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (!Mutable)
      {
LABEL_44:
        CFDictionaryRef v8 = 0;
        goto LABEL_45;
      }
      CFAllocatorRef v43 = CFGetAllocator((CFTypeRef)a1);
      CFDictionaryRef v8 = CFArrayCreateMutable(v43, 0, &kCFTypeArrayCallBacks);
      if (!v8)
      {
LABEL_45:
        CFMutableArrayRef v9 = 0;
        goto LABEL_46;
      }
      CFAllocatorRef v44 = CFGetAllocator((CFTypeRef)a1);
      CFMutableArrayRef v9 = CFArrayCreateMutable(v44, 0, &kCFTypeArrayCallBacks);
      if (!v9)
      {
LABEL_46:
        CFMutableDictionaryRef v10 = 0;
        goto LABEL_47;
      }
      CFAllocatorRef v45 = CFGetAllocator((CFTypeRef)a1);
      CFMutableDictionaryRef v10 = CFDictionaryCreateMutable(v45, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (!v10)
      {
LABEL_47:
        uint64_t v7 = 2;
        goto LABEL_18;
      }
      CFDictionarySetValue(Mutable, @"Personalized", v8);
      CFDictionarySetValue(Mutable, @"Linked", v9);
      CFDictionarySetValue(Mutable, @"Manifest", v10);
    }
LABEL_37:
    CFAllocatorRef v46 = CFGetAllocator((CFTypeRef)a1);
    *a3 = CFPropertyListCreateDeepCopy(v46, Mutable, 2uLL);
    int v47 = CFBooleanGetValue(v14);
    uint64_t v48 = *(__CFDictionary **)(*(void *)(a1 + 128) + 8);
    if (v47)
    {
      if (v48) {
        CFDictionaryReplaceValue(v48, @"RecoveryOS", Mutable);
      }
      uint64_t v7 = 0;
    }
    else
    {
      if (v48)
      {
        CFRelease(v48);
        *(void *)(*(void *)(a1 + 128) + 8) = 0;
      }
      uint64_t v7 = 0;
      *(void *)(*(void *)(a1 + 128) + 8) = CFRetain(Mutable);
    }
  }
LABEL_18:
  AMAuthInstallLockUnlock(*(os_unfair_lock_s **)(a1 + 360));
  SafeRelease(v65);
  SafeRelease(0);
  SafeRelease(Mutable);
  SafeRelease(v8);
  SafeRelease(v9);
  SafeRelease(propertyList);
  SafeRelease(v10);
  SafeRelease(v63);
  SafeRelease(context);
  return v7;
}

uint64_t sub_10001E624(CFDictionaryRef **cf, const __CFArray *a2, const __CFURL *a3, const __CFURL *a4, const __CFDictionary *a5, const __CFURL *a6, const __CFDictionary *a7)
{
  CFMutableDictionaryRef MutableCopy = 0;
  CFMutableDictionaryRef v160 = 0;
  CFTypeRef v161 = 0;
  CFStringRef v159 = 0;
  uint64_t v9 = 1;
  if (!cf || !a2 || !a3)
  {
    CFDictionaryRef v12 = 0;
    CFDictionaryRef v13 = 0;
    CFTypeRef v14 = 0;
    CFMutableDictionaryRef v15 = 0;
    CFMutableDictionaryRef v16 = 0;
    CFURLRef v17 = 0;
    CFStringRef v18 = 0;
    goto LABEL_119;
  }
  CFDictionaryRef v12 = 0;
  CFDictionaryRef v13 = 0;
  CFTypeRef v14 = 0;
  CFMutableDictionaryRef v15 = 0;
  CFMutableDictionaryRef v16 = 0;
  CFURLRef v17 = 0;
  CFStringRef v18 = 0;
  if (a5)
  {
    CFAllocatorRef v20 = CFGetAllocator(cf);
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v20, 0, *cf[16]);
    CFDictionaryRef v13 = MutableCopy;
    if (!MutableCopy)
    {
      CFDictionaryRef v12 = 0;
      CFTypeRef v14 = 0;
      CFMutableDictionaryRef v15 = 0;
      goto LABEL_142;
    }
    CFDictionaryRef theDict = (const __CFDictionary *)CFDictionaryGetValue(a5, @"Manifest");
    if (!theDict)
    {
LABEL_9:
      CFDictionaryRef v12 = 0;
      CFMutableDictionaryRef MutableCopy = v13;
      CFDictionaryRef v13 = 0;
      CFTypeRef v14 = 0;
      CFMutableDictionaryRef v15 = 0;
      CFMutableDictionaryRef v16 = 0;
      CFURLRef v17 = 0;
      CFStringRef v18 = 0;
      uint64_t v9 = 8;
      goto LABEL_119;
    }
    if (a7)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a7, @"Manifest");
      if (!Value) {
        goto LABEL_9;
      }
    }
    else
    {
      CFDictionaryRef Value = 0;
    }
    CFAllocatorRef v21 = CFGetAllocator(cf);
    CFMutableDictionaryRef v15 = CFDictionaryCreateMutableCopy(v21, 0, theDict);
    if (!v15)
    {
LABEL_14:
      CFDictionaryRef v12 = 0;
      CFMutableDictionaryRef MutableCopy = v13;
      CFDictionaryRef v13 = 0;
      CFTypeRef v14 = 0;
LABEL_142:
      CFMutableDictionaryRef v16 = 0;
      CFURLRef v17 = 0;
      CFStringRef v18 = 0;
      uint64_t v9 = 2;
      goto LABEL_119;
    }
    uint64_t v143 = a5;
    if (a7)
    {
      CFAllocatorRef v22 = CFGetAllocator(cf);
      CFMutableDictionaryRef v23 = CFDictionaryCreateMutableCopy(v22, 0, Value);
      CFArrayRef v24 = a2;
      if (!v23) {
        goto LABEL_14;
      }
    }
    else
    {
      CFMutableDictionaryRef v23 = 0;
      CFArrayRef v24 = a2;
    }
    CFURLRef v144 = a3;
    CFArrayRef v142 = a7;
    CFMutableDictionaryRef v147 = v23;
    CFMutableDictionaryRef v151 = v15;
    CFArrayRef v148 = v13;
    if (CFArrayGetCount(v24) < 1)
    {
LABEL_90:
      if (CFDictionaryGetCount(v13) < 1) {
        goto LABEL_116;
      }
      v163[0] = 0;
      CFIndex Count = CFDictionaryGetCount(v13);
      keys = (void **)malloc(8 * Count);
      if (keys)
      {
        PathComponent = (__CFString *)malloc(8 * Count);
        if (PathComponent)
        {
          CFDictionaryGetKeysAndValues(v13, (const void **)keys, (const void **)&PathComponent->isa);
          CFDictionaryRef theDicta = (CFDictionaryRef)PathComponent;
          if (Count < 1)
          {
LABEL_114:
            uint64_t v9 = 0;
            CFMutableDictionaryRef Mutable = 0;
            PathComponent = 0;
            CFURLRef v136 = 0;
            goto LABEL_115;
          }
          uint64_t v127 = 0;
          while (1)
          {
            CFStringRef v128 = (const __CFString *)keys[v127];
            CFURLRef v158 = (const __CFURL *)*((void *)&PathComponent->isa + v127);
            char v162 = 0;
            v164.CFIndex length = CFArrayGetCount(v24);
            v164.CFIndex location = 0;
            if (CFArrayContainsValue(v24, v164, v128))
            {
              v163[0] = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (!v163[0])
              {
                CFMutableDictionaryRef Mutable = 0;
LABEL_129:
                PathComponent = 0;
LABEL_130:
                CFURLRef v156 = 0;
                uint64_t v9 = 2;
                goto LABEL_132;
              }
              if (CFStringCompare(v128, @"BasebandFirmware", 0)) {
                CFDictionaryAddValue(v163[0], @"Trusted", kCFBooleanFalse);
              }
              uint64_t v129 = cf[2];
              if (*((unsigned char *)v129 + 20)) {
                CFBooleanRef v130 = kCFBooleanTrue;
              }
              else {
                CFBooleanRef v130 = kCFBooleanFalse;
              }
              if (*((unsigned char *)v129 + 72)) {
                CFBooleanRef v131 = kCFBooleanTrue;
              }
              else {
                CFBooleanRef v131 = kCFBooleanFalse;
              }
              CFDictionaryAddValue(v163[0], @"EPRO", v130);
              CFDictionaryAddValue(v163[0], @"ESEC", v131);
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (!Mutable) {
                goto LABEL_129;
              }
              PathComponent = (__CFString *)CFURLCopyLastPathComponent(v158);
              if (!PathComponent)
              {
                CFURLRef v156 = 0;
                uint64_t v9 = 3;
LABEL_132:
                CFURLRef v136 = v156;
LABEL_115:
                SafeRelease(v163[0]);
                SafeRelease(Mutable);
                SafeRelease(PathComponent);
                SafeFree(keys);
                SafeFree(theDicta);
                SafeRelease(v136);
                CFMutableDictionaryRef MutableCopy = v148;
                if (!v9)
                {
LABEL_116:
                  CFMutableDictionaryRef v15 = v151;
                  CFDictionarySetValue(v143, @"Manifest", v151);
                  CFMutableDictionaryRef v16 = v147;
                  if (v142) {
                    CFDictionarySetValue(v142, @"Manifest", v147);
                  }
                  uint64_t v9 = 0;
                  CFDictionaryRef v12 = 0;
                  CFDictionaryRef v13 = 0;
                  CFTypeRef v14 = 0;
                  CFURLRef v17 = 0;
                  CFStringRef v18 = 0;
                  CFMutableDictionaryRef MutableCopy = v148;
                  goto LABEL_119;
                }
                CFDictionaryRef v12 = 0;
LABEL_124:
                CFDictionaryRef v13 = 0;
                CFTypeRef v14 = 0;
LABEL_135:
                CFURLRef v17 = 0;
                CFStringRef v18 = 0;
LABEL_136:
                CFMutableDictionaryRef v15 = v151;
                CFMutableDictionaryRef v16 = v147;
                goto LABEL_119;
              }
              CFAllocatorRef v133 = CFGetAllocator(cf);
              CFURLRef v134 = CFURLCreateCopyAppendingPathComponent(v133, a4, PathComponent, 0);
              if (!v134) {
                goto LABEL_130;
              }
              CFURLRef v156 = v134;
              uint64_t SoftLink = AMAuthInstallSupportFileURLExists(v134, &v162);
              if (SoftLink
                || !v162 && (uint64_t SoftLink = AMAuthInstallPlatformCreateSoftLink(v156, v158), SoftLink)
                || (CFDictionaryAddValue(Mutable, @"Path", PathComponent),
                    CFDictionaryAddValue(v163[0], @"Info", Mutable),
                    uint64_t SoftLink = _AMAuthInstallBundleApplyMeasurements((uint64_t)cf, v128, v158, 0, v163),
                    SoftLink))
              {
                uint64_t v9 = SoftLink;
                goto LABEL_132;
              }
              CFDictionarySetValue(v151, v128, v163[0]);
              SafeRelease(PathComponent);
              SafeRelease(Mutable);
              SafeRelease(v163[0]);
              SafeRelease(v156);
              v163[0] = 0;
              CFArrayRef v24 = a2;
              PathComponent = (__CFString *)theDicta;
            }
            if (Count == ++v127) {
              goto LABEL_114;
            }
          }
        }
        CFMutableDictionaryRef Mutable = 0;
      }
      else
      {
        CFMutableDictionaryRef Mutable = 0;
        PathComponent = 0;
      }
      CFDictionaryRef theDicta = 0;
      CFURLRef v136 = 0;
      uint64_t v9 = 2;
      goto LABEL_115;
    }
    CFIndex v25 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v24, v25);
      if (!ValueAtIndex)
      {
        CFDictionaryRef v12 = 0;
        CFMutableDictionaryRef MutableCopy = v13;
        CFDictionaryRef v13 = 0;
        CFTypeRef v14 = 0;
        CFURLRef v17 = 0;
        CFStringRef v18 = 0;
        uint64_t v9 = 1;
        goto LABEL_136;
      }
      CFStringRef v27 = ValueAtIndex;
      if (CFStringFind(ValueAtIndex, @"RecoveryOS", 0).location == -1) {
        CFBooleanRef v28 = kCFBooleanFalse;
      }
      else {
        CFBooleanRef v28 = kCFBooleanTrue;
      }
      int v29 = CFBooleanGetValue(v28);
      CFAllocatorRef v30 = CFGetAllocator(cf);
      if (Value && v29)
      {
        CFStringRef v36 = AMAuthInstallICreateTranslationOfRecoveryEnteryName(v30, v27);
        CFAllocatorRef v37 = CFGetAllocator(cf);
        CFDictionaryRef ValueForKeyPathInDict = AMAuthInstallSupportGetValueForKeyPathInDict(v37, Value, v36, v38, v39, v40, v41, v42);
        if (ValueForKeyPathInDict) {
          goto LABEL_27;
        }
      }
      else
      {
        CFDictionaryRef ValueForKeyPathInDict = AMAuthInstallSupportGetValueForKeyPathInDict(v30, theDict, v27, v31, v32, v33, v34, v35);
        CFStringRef v36 = 0;
        if (ValueForKeyPathInDict)
        {
LABEL_27:
          CFStringRef v155 = v36;
          CFComparisonResult v44 = CFStringCompare(v27, @"BasebandFirmware", 0);
          CFAllocatorRef v45 = CFGetAllocator(cf);
          CFAllocatorRef v46 = CFDictionaryCreateMutableCopy(v45, 0, ValueForKeyPathInDict);
          CFMutableDictionaryRef v160 = v46;
          if (!v46)
          {
            CFDictionaryRef v12 = 0;
            CFMutableDictionaryRef MutableCopy = v13;
            CFDictionaryRef v13 = 0;
            CFTypeRef v14 = 0;
            CFURLRef v17 = 0;
            CFStringRef v18 = 0;
            uint64_t v9 = 2;
            goto LABEL_136;
          }
          CFIndex v47 = _AMAuthInstallBundleSetObjectPropertyOverrides(cf, v27, v46);
          if (v47)
          {
            uint64_t v9 = v47;
            AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyOverrideBuildIdentity", (uint64_t)"failed to set %@ property overrides", v48, v49, v50, v51, v52, (char)v27);
            CFDictionaryRef v12 = 0;
            CFMutableDictionaryRef MutableCopy = v13;
            goto LABEL_124;
          }
          CFAllocatorRef v53 = CFGetAllocator(cf);
          CFStringRef ValueForKeyWithFormat = (const __CFString *)AMAuthInstallSupportGetValueForKeyWithFormat(v53, ValueForKeyPathInDict, @"%@.%@", v54, v55, v56, v57, v58, (char)@"Info");
          CFURLRef v60 = (const __CFURL *)CFDictionaryGetValue(v13, v27);
          if (v60)
          {
            CFDictionaryRef v12 = (const __CFDictionary *)CFDictionaryGetValue(v160, @"Info");
            if (!v12)
            {
              CFDictionaryRef v13 = 0;
              CFTypeRef v14 = 0;
              CFURLRef v17 = 0;
              CFStringRef v18 = 0;
              uint64_t v9 = 7;
              goto LABEL_133;
            }
            CFAllocatorRef v61 = CFGetAllocator(cf);
            CFDictionaryRef v13 = CFDictionaryCreateMutableCopy(v61, 0, v12);
            if (!v13)
            {
              CFDictionaryRef v12 = 0;
              CFTypeRef v14 = 0;
              CFURLRef v17 = 0;
              CFStringRef v18 = 0;
              uint64_t v9 = 2;
              goto LABEL_133;
            }
            CFStringRef v62 = CFURLCopyLastPathComponent(v60);
            CFDictionaryRef v12 = (const __CFDictionary *)v62;
            if (!v62)
            {
              CFTypeRef v14 = 0;
              CFURLRef v17 = 0;
              CFStringRef v18 = 0;
              uint64_t v9 = 3;
              goto LABEL_133;
            }
            if (ValueForKeyWithFormat)
            {
              CFAllocatorRef v63 = CFGetAllocator(cf);
              uint64_t v64 = AMAuthInstallSupportCopyStringReplacingLastComponent(v63, ValueForKeyWithFormat, @"/", v12, &v161);
              if (v64)
              {
                uint64_t v9 = v64;
                CFTypeRef v14 = 0;
                CFURLRef v17 = 0;
                CFStringRef v18 = 0;
LABEL_133:
                CFMutableDictionaryRef MutableCopy = v148;
                goto LABEL_136;
              }
            }
            else
            {
              CFTypeRef v161 = CFRetain(v62);
            }
            SafeRelease(v12);
            CFDictionarySetValue(v13, @"Path", v161);
            SafeRelease(v161);
            CFDictionarySetValue(v160, @"Info", v13);
            SafeRelease(v13);
            if (v44)
            {
              CFAllocatorRef v65 = CFGetAllocator(cf);
              CFMutableDataRef v66 = CFDataCreateMutable(v65, 0);
              CFDictionarySetValue(v160, @"Digest", v66);
              CFRelease(v66);
            }
            CFTypeRef v161 = 0;
            CFDictionaryRef v13 = v148;
            CFDictionaryRemoveValue(v148, v27);
          }
          uint64_t v67 = cf[16];
          if (v67 && v67[1])
          {
            if (CFBooleanGetValue(v28))
            {
              CFDictionaryRef v68 = (const __CFDictionary *)CFDictionaryGetValue(cf[16][1], @"RecoveryOSOS");
              if (v68)
              {
                CFAllocatorRef v69 = CFGetAllocator(cf);
                CFDictionaryRef v75 = AMAuthInstallSupportGetValueForKeyWithFormat(v69, v68, @"%@.%@.%@", v70, v71, v72, v73, v74, (char)@"Manifest");
                goto LABEL_47;
              }
            }
            else
            {
              CFAllocatorRef v76 = CFGetAllocator(cf);
              CFDictionaryRef v75 = AMAuthInstallSupportGetValueForKeyWithFormat(v76, cf[16][1], @"%@.%@.%@", v77, v78, v79, v80, v81, (char)@"Manifest");
LABEL_47:
              CFDictionaryRef v68 = v75;
            }
          }
          else
          {
            CFDictionaryRef v68 = 0;
          }
          if (CFBooleanGetValue(v28)) {
            CFStringRef v82 = @"RecoveryOSOS";
          }
          else {
            CFStringRef v82 = @"OS";
          }
          CFComparisonResult v83 = CFStringCompare(v82, v27, 0);
          if (v68)
          {
            int v91 = 0;
            if (v60) {
              goto LABEL_62;
            }
LABEL_61:
            if (v91) {
              goto LABEL_62;
            }
LABEL_85:
            AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleCopyOverrideBuildIdentity", (uint64_t)"Inserting %@ to Manifest to personalize later", v86, v87, v88, v89, v90, (char)v27);
            if (CFBooleanGetValue(v28))
            {
              CFStringRef v125 = v155;
              CFDictionarySetValue(v147, v155, v160);
              CFArrayRef v24 = a2;
            }
            else
            {
              CFDictionarySetValue(v151, v27, v160);
              CFArrayRef v24 = a2;
              CFStringRef v125 = v155;
            }
            SafeRelease(v160);
            CFMutableDictionaryRef v160 = 0;
            SafeRelease(v125);
            goto LABEL_89;
          }
          if ((unint64_t)v60 | v83) {
            BOOL v92 = *((unsigned char *)cf + 434) == 0;
          }
          else {
            BOOL v92 = 0;
          }
          int v91 = v92;
          if (!v60) {
            goto LABEL_61;
          }
LABEL_62:
          if (v60)
          {
            int IsImg4 = AMAuthInstallApIsImg4((uint64_t)cf, v84, v85, v86, v87, v88, v89, v90);
            if (v44 == kCFCompareEqualTo || IsImg4) {
              goto LABEL_70;
            }
            LOBYTE(v163[0]) = 0;
            if (_AMAuthInstallBundleImageHasBuildString(v27))
            {
              CFAllocatorRef v94 = CFGetAllocator(cf);
              uint64_t v95 = AMAuthInstallApImg3CopyBuildString(v94, v60, &v159);
              if (v95)
              {
                uint64_t v9 = v95;
                AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyOverrideBuildIdentity", (uint64_t)"failed to copy image build string %@", v96, v97, v98, v99, v100, (char)v27);
                goto LABEL_140;
              }
              CFDictionarySetValue(v160, @"BuildString", v159);
              SafeRelease(v159);
              CFStringRef v159 = 0;
            }
            CFAllocatorRef v101 = CFGetAllocator(cf);
            uint64_t IsFinalized = AMAuthInstallApImg3IsFinalized(v101, v60, (BOOL *)v163);
            if (IsFinalized)
            {
              uint64_t v9 = IsFinalized;
              AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyOverrideBuildIdentity", (uint64_t)"failed to check %@ alignment", v103, v104, v105, v106, v107, (char)v27);
LABEL_140:
              CFTypeRef v14 = 0;
              CFURLRef v115 = 0;
              CFStringRef v140 = 0;
              goto LABEL_148;
            }
            if (LOBYTE(v163[0])) {
              goto LABEL_70;
            }
            CFStringRef v112 = CFURLCopyLastPathComponent(v60);
            if (!v112)
            {
              CFTypeRef v14 = 0;
              CFURLRef v115 = 0;
              CFStringRef v140 = 0;
              goto LABEL_145;
            }
            CFStringRef v113 = v112;
            CFAllocatorRef v114 = CFGetAllocator(cf);
            CFURLRef v115 = CFURLCreateCopyAppendingPathComponent(v114, a4, v113, 0);
            if (!v115)
            {
              CFStringRef v140 = v113;
              CFTypeRef v14 = 0;
LABEL_145:
              uint64_t v9 = 2;
LABEL_148:
              CFMutableDictionaryRef v15 = v151;
              CFMutableDictionaryRef v16 = v147;
              CFMutableDictionaryRef MutableCopy = v148;
              CFDictionaryRef v12 = 0;
              CFDictionaryRef v13 = 0;
              CFStringRef v18 = v140;
              CFURLRef v17 = v115;
              break;
            }
            CFAllocatorRef v116 = CFGetAllocator(cf);
            uint64_t v117 = AMAuthInstallApImg3Finalize(v116, v60, v115);
            if (v117)
            {
              uint64_t v9 = v117;
              CFStringRef v140 = v113;
              AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyOverrideBuildIdentity", (uint64_t)"failed to finalize image3 override", v118, v119, v120, v121, v122, v141);
              CFTypeRef v14 = 0;
              goto LABEL_148;
            }
            CFTypeRef v14 = CFRetain(v115);
            uint64_t v123 = (__CFDictionary *)CFDictionaryGetValue(v160, @"Info");
            if (!v123)
            {
              CFStringRef v140 = v113;
              uint64_t v9 = 8;
              goto LABEL_148;
            }
            CFDictionarySetValue(v123, @"Path", v113);
            CFDictionarySetValue(*cf[16], v27, v14);
            SafeRelease(v113);
            SafeRelease(v115);
            if (!v14)
            {
LABEL_70:
              uint64_t v108 = (void *)CFRetain(v60);
              goto LABEL_82;
            }
          }
          else
          {
            if (!ValueForKeyWithFormat) {
              goto LABEL_85;
            }
            int v109 = CFBooleanGetValue(v28);
            CFAllocatorRef v110 = CFGetAllocator(cf);
            if (v109) {
              CFURLRef v111 = a6;
            }
            else {
              CFURLRef v111 = v144;
            }
            uint64_t v108 = CFURLCreateCopyAppendingPathComponent(v110, v111, ValueForKeyWithFormat, 0);
LABEL_82:
            CFTypeRef v14 = v108;
            if (!v108) {
              goto LABEL_85;
            }
          }
          uint64_t v124 = _AMAuthInstallBundleApplyMeasurements((uint64_t)cf, v27, v14, v160, &v160);
          if (v124)
          {
            uint64_t v9 = v124;
            CFDictionaryRef v12 = 0;
            CFMutableDictionaryRef MutableCopy = v13;
            CFDictionaryRef v13 = 0;
            goto LABEL_135;
          }
          CFRelease(v14);
          goto LABEL_85;
        }
      }
LABEL_89:
      if (++v25 >= CFArrayGetCount(v24)) {
        goto LABEL_90;
      }
    }
  }
LABEL_119:
  CFURLRef v137 = v17;
  CFStringRef v138 = v18;
  SafeRelease(MutableCopy);
  SafeRelease(v12);
  SafeRelease(v161);
  SafeRelease(v160);
  SafeRelease(v13);
  SafeRelease(v14);
  SafeRelease(v15);
  SafeRelease(v137);
  SafeRelease(v138);
  SafeRelease(v159);
  SafeRelease(v16);
  return v9;
}

void sub_10001F2F0(const __CFArray *a1, const void *a2)
{
  v6.CFIndex length = CFArrayGetCount(a1);
  v6.CFIndex location = 0;
  FirstIndexOfCFDictionaryRef Value = CFArrayGetFirstIndexOfValue(a1, v6, a2);
  if ((FirstIndexOfValue & 0x8000000000000000) == 0)
  {
    CFArrayRemoveValueAtIndex(a1, FirstIndexOfValue);
  }
}

CFIndex sub_10001F354(uint64_t a1, const __CFArray *a2, CFDictionaryRef theDict, const __CFDictionary *a4, const void *a5, const __CFDictionary *a6, void *a7, void *a8)
{
  CFMutableDictionaryRef v8 = 0;
  v203[0] = 0;
  uint64_t v201 = 0;
  uint64_t v202 = 0;
  CFIndex Code = 1;
  if (!a4 || !a1 || !theDict)
  {
    CFDictionaryRef v12 = 0;
    CFDictionaryRef v13 = 0;
    goto LABEL_126;
  }
  CFDictionaryRef v12 = 0;
  CFDictionaryRef v13 = 0;
  if (a7)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"Manifest");
    if (!Value)
    {
LABEL_8:
      CFMutableDictionaryRef v8 = 0;
      CFDictionaryRef v12 = 0;
      CFDictionaryRef v13 = 0;
      CFIndex Code = 7;
      goto LABEL_126;
    }
    CFArrayRef v197 = a2;
    CFMutableDictionaryRef v15 = a6;
    if (a6)
    {
      CFDictionaryRef v16 = a4;
      CFDictionaryRef v196 = (const __CFDictionary *)CFDictionaryGetValue(a6, @"Manifest");
      if (!v196) {
        goto LABEL_8;
      }
    }
    else
    {
      CFDictionaryRef v196 = 0;
      CFDictionaryRef v16 = a4;
    }
    CFArrayRef theArray = (const __CFArray *)CFDictionaryGetValue(v16, @"Personalized");
    if (theArray)
    {
      CFDictionaryRef v12 = (const __CFDictionary *)CFDictionaryGetValue(v16, @"Manifest");
      if (v12)
      {
        CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)a1);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v17, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFMutableDictionaryRef v8 = Mutable;
        if (Mutable)
        {
          uint64_t v192 = Mutable;
          if (!a6)
          {
            CFArrayRef v181 = 0;
            CFDictionaryRef v185 = 0;
            CFArrayRef v28 = v197;
            goto LABEL_21;
          }
          CFAllocatorRef v26 = CFGetAllocator((CFTypeRef)a1);
          CFMutableDictionaryRef v27 = CFDictionaryCreateMutable(v26, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v27)
          {
            CFMutableDictionaryRef v15 = v27;
            if (!CFDictionaryGetValue(v16, @"RecoveryOS")
              || (CFArrayRef v28 = v197, (v181 = (CFArrayRef)CFDictionaryGetValue(v16, @"Personalized")) == 0)
              || (CFDictionaryRef v185 = (const __CFDictionary *)CFDictionaryGetValue(v16, @"Manifest")) == 0)
            {
              CFDictionaryRef v13 = 0;
              CFIndex Code = 8;
LABEL_125:
              CFDictionaryRef v12 = v15;
              goto LABEL_126;
            }
LABEL_21:
            if (AMAuthInstallApIsImg4(a1, v19, v20, v21, v22, v23, v24, v25)) {
              CFStringRef v29 = @"amai/apimg4ticket.der";
            }
            else {
              CFStringRef v29 = @"amai/apticket.der";
            }
            v204.CFIndex length = CFArrayGetCount(theArray);
            v204.CFIndex location = 0;
            CFDictionaryRef v182 = v12;
            uint64_t v180 = a7;
            if (CFArrayContainsValue(theArray, v204, v29)) {
              BOOL v30 = 0;
            }
            else {
              BOOL v30 = *(void *)(*(void *)(a1 + 16) + 24) || *(unsigned char *)(a1 + 433);
            }
            v205.CFIndex length = CFArrayGetCount(theArray);
            v205.CFIndex location = 0;
            CFArrayContainsValue(theArray, v205, v29);
            AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"ticketPath %@ , withApTicket is %s,  (!%s &&(%s || %s))", v31, v32, v33, v34, v35, (char)v29);
            int v189 = v30;
            int v186 = !v30;
            *(unsigned char *)(a1 + 32) = !v30;
            if (v28)
            {
              CFIndex Count = CFArrayGetCount(v28);
              if (Count >= 1)
              {
                CFAllocatorRef v184 = 0;
                CFDictionaryRef v199 = 0;
                CFIndex v36 = 0;
                CFBooleanRef v37 = kCFBooleanFalse;
                uint64_t v195 = v15;
                while (1)
                {
                  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v28, v36);
                  CFComparisonResult v39 = CFStringCompare(ValueAtIndex, @"BasebandFirmware", 0);
                  CFBooleanRef v40 = v37;
                  if (ValueAtIndex)
                  {
                    if (CFStringFind(ValueAtIndex, @"RecoveryOS", 0).location == -1) {
                      CFBooleanRef v40 = v37;
                    }
                    else {
                      CFBooleanRef v40 = kCFBooleanTrue;
                    }
                  }
                  if (CFBooleanGetValue(v40))
                  {
                    CFAllocatorRef v41 = CFGetAllocator((CFTypeRef)a1);
                    CFStringRef v42 = AMAuthInstallICreateTranslationOfRecoveryEnteryName(v41, ValueAtIndex);
                    CFDictionaryRef v48 = (const __CFDictionary *)CFDictionaryGetValue(v196, v42);
                    if (v48) {
                      goto LABEL_38;
                    }
                  }
                  else
                  {
                    CFDictionaryRef v48 = (const __CFDictionary *)CFDictionaryGetValue(Value, ValueAtIndex);
                    CFStringRef v42 = 0;
                    if (v48)
                    {
LABEL_38:
                      CFDictionaryRef v49 = (const __CFDictionary *)CFDictionaryGetValue(v48, @"Info");
                      if (!v49)
                      {
                        CFMutableDictionaryRef v15 = v195;
                        CFArrayRef v28 = v197;
                        goto LABEL_90;
                      }
                      CFDictionaryRef v50 = v49;
                      CFBooleanRef v51 = v37;
                      CFTypeRef v200 = 0;
                      SafeRelease(v199);
                      CFAllocatorRef v52 = CFGetAllocator((CFTypeRef)a1);
                      CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v52, 0, v48);
                      CFDictionaryRef v199 = MutableCopy;
                      if (!MutableCopy)
                      {
                        CFIndex Code = 2;
                        goto LABEL_128;
                      }
                      uint64_t v54 = AMAuthInstallBundleProcessRulesWithEntryDict(a1, MutableCopy);
                      if (v54)
                      {
                        CFIndex Code = v54;
                        uint64_t v177 = "failed to process image rules";
LABEL_132:
                        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)v177, v55, v56, v57, v58, v59, v178);
                        goto LABEL_128;
                      }
                      CFBooleanRef v60 = (const __CFBoolean *)CFDictionaryGetValue(v50, @"Personalize");
                      if (v60 && !CFBooleanGetValue(v60))
                      {
                        if (!CFBooleanGetValue(v40))
                        {
                          uint64_t v90 = CFDictionaryGetValue(v182, ValueAtIndex);
                          char v96 = v189 ^ 1;
                          if (v90) {
                            char v96 = 1;
                          }
                          if (v96)
                          {
                            AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"skipping \"%@\" entry", v91, v92, v93, v94, v95, (char)ValueAtIndex);
                          }
                          else
                          {
                            CFAllocatorRef v97 = CFGetAllocator((CFTypeRef)a1);
                            CFDataRef v98 = CFDataCreate(v97, 0, 0);
                            CFDictionaryAddValue(v199, @"Digest", v98);
                            CFDictionarySetValue(v192, ValueAtIndex, v199);
                            CFDataRef v99 = v98;
                            CFBooleanRef v37 = v51;
                            CFRelease(v99);
                            AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"personalizing \"%@\"", v100, v101, v102, v103, v104, (char)ValueAtIndex);
                          }
                          goto LABEL_94;
                        }
                        uint64_t v73 = CFDictionaryGetValue(v185, v42);
                        char v79 = v189 ^ 1;
                        if (v73) {
                          char v79 = 1;
                        }
                        uint64_t v80 = "skipping \"%@\" entry";
                        if ((v79 & 1) == 0)
                        {
                          CFAllocatorRef v81 = CFGetAllocator((CFTypeRef)a1);
                          CFDataRef cf = CFDataCreate(v81, 0, 0);
                          CFDictionaryAddValue(v199, @"Digest", cf);
                          CFDictionarySetValue(v195, v42, v199);
                          CFRelease(cf);
                          uint64_t v80 = "personalizing \"%@\"";
                        }
                        AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)v80, v74, v75, v76, v77, v78, (char)v42);
                        if (v39 == kCFCompareEqualTo) {
                          goto LABEL_56;
                        }
LABEL_44:
                        if (!CFDictionaryContainsKey(v199, @"PartialDigest"))
                        {
                          if ((v189 & 1) == 0)
                          {
                            AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"not personalizing \"%@\"", v67, v68, v69, v70, v71, (char)ValueAtIndex);
LABEL_94:
                            CFMutableDictionaryRef v15 = v195;
                            CFArrayRef v28 = v197;
                            goto LABEL_91;
                          }
                          CFTypeRef v72 = 0;
LABEL_63:
                          CFArrayRef v28 = v197;
LABEL_80:
                          SafeRelease(v72);
                          if (CFDictionaryGetValue(v199, @"Digest")) {
                            AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"personalizing \"%@\" uint64_t Digest = \"%@\"", v107, v108, v109, v110, v111, (char)ValueAtIndex);
                          }
                          CFBooleanRef v37 = v51;
                          if (v39 == kCFCompareEqualTo)
                          {
                            int v112 = CFBooleanGetValue(v40);
                            CFIndex Code = 1;
                            if (!a5 || v112 == 1) {
                              goto LABEL_128;
                            }
                            uint64_t v113 = AMAuthInstallBundleCopyFullPathForBuildIdentityKey((CFDictionaryRef **)a1, a5, @"BasebandFirmware", v48, (CFTypeRef *)&v202);
                            if (v113)
                            {
                              CFIndex Code = v113;
                              uint64_t v177 = "failed to find baseband firmware path";
                              goto LABEL_132;
                            }
                            CFAllocatorRef v184 = v202;
                            CFBooleanRef v37 = v51;
                            if (!v202)
                            {
                              CFIndex Code = 14;
                              uint64_t v177 = "failed to create bbfwURL";
                              goto LABEL_132;
                            }
                          }
                          if (CFBooleanGetValue(v40))
                          {
                            CFMutableDictionaryRef v15 = v195;
                            CFDictionarySetValue(v195, v42, v199);
                          }
                          else
                          {
                            CFDictionarySetValue(v192, ValueAtIndex, v199);
                            CFMutableDictionaryRef v15 = v195;
                          }
LABEL_90:
                          SafeRelease(v42);
                          goto LABEL_91;
                        }
                        CFTypeRef v72 = CFDictionaryGetValue(v50, @"Path");
                        CFTypeRef v200 = v72;
                        SafeRetain(v72);
                        if (!v72) {
                          goto LABEL_63;
                        }
                      }
                      else
                      {
                        if (v39) {
                          goto LABEL_44;
                        }
LABEL_56:
                        uint64_t v82 = AMAuthInstallBundleCopyNextBasebandComponentName((const void *)a1, &v200, v61, v62, v63, v64, v65, v66);
                        if (v82)
                        {
                          CFIndex Code = v82;
LABEL_128:
                          CFMutableDictionaryRef v8 = v192;
                          CFDictionaryRef v13 = v199;
                          CFDictionaryRef v12 = v195;
                          goto LABEL_126;
                        }
                        CFTypeRef v72 = v200;
                        if (!v200) {
                          goto LABEL_63;
                        }
                      }
                      if (CFBooleanGetValue(v40))
                      {
                        if (!CFDictionaryContainsKey(v185, v42))
                        {
                          CFArrayRef v88 = v181;
LABEL_75:
                          v206.CFIndex length = CFArrayGetCount(v88);
                          v206.CFIndex location = 0;
                          int v105 = CFArrayContainsValue(v88, v206, v72);
                          char v106 = v186;
                          if (v39 == kCFCompareEqualTo) {
                            char v106 = 1;
                          }
                          CFArrayRef v28 = v197;
                          if (!v105 || (v106 & 1) == 0) {
                            goto LABEL_80;
                          }
LABEL_79:
                          AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"entry \"%@\" has been previously personalized; skipping it",
                            v83,
                            v84,
                            v85,
                            v86,
                            v87,
                            (char)ValueAtIndex);
                          SafeRelease(v72);
                          CFBooleanRef v37 = v51;
                          CFMutableDictionaryRef v15 = v195;
                          goto LABEL_91;
                        }
                      }
                      else if (!CFDictionaryContainsKey(v182, ValueAtIndex))
                      {
                        CFArrayRef v88 = theArray;
                        goto LABEL_75;
                      }
                      int v89 = v186;
                      if (v39 == kCFCompareEqualTo) {
                        int v89 = 1;
                      }
                      CFArrayRef v28 = v197;
                      if (v89 != 1) {
                        goto LABEL_80;
                      }
                      goto LABEL_79;
                    }
                  }
                  AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"entry \"%@\" not part of manifest, skipping", v43, v44, v45, v46, v47, (char)ValueAtIndex);
LABEL_91:
                  if (Count == ++v36) {
                    goto LABEL_96;
                  }
                }
              }
            }
            CFAllocatorRef v184 = 0;
            CFDictionaryRef v199 = 0;
LABEL_96:
            CFMutableDictionaryRef v8 = v192;
            if (v15 && CFDictionaryGetCount(v15))
            {
              sub_100022F20((void *)a1, a6, v15, v114, v115, v116, v117, v118);
              uint64_t v123 = AMAuthInstallApServerRequestAddRequiredTagsWithRecoveryOS((void *)a1, v15, v189, 1, v119, v120, v121, v122);
              if (v123)
              {
                CFIndex Code = v123;
                goto LABEL_124;
              }
              if (!(*(unsigned int (**)(uint64_t, __CFDictionary *, const __CFDictionary *, __CFError **))(a1 + 440))(a1, v192, a4, &v201))
              {
                AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"failed to add updater tags %@", v124, v125, v126, v127, v128, (char)v201);
                CFIndex Code = CFErrorGetCode(v201);
                goto LABEL_124;
              }
              CFAllocatorRef v129 = CFGetAllocator((CFTypeRef)a1);
              CFIndex Code = 2;
              DeepCFStringRef Copy = CFPropertyListCreateDeepCopy(v129, v15, 2uLL);
              *a8 = DeepCopy;
              if (!DeepCopy) {
                goto LABEL_124;
              }
            }
            CFIndex v131 = CFDictionaryGetCount(v192);
            sub_100022F20((void *)a1, theDict, v192, v132, v133, v134, v135, v136);
            uint64_t v142 = AMAuthInstallApServerRequestAddRequiredTags((void *)a1, v192, v189, v137, v138, v139, v140, v141);
            if (!v142)
            {
              uint64_t v142 = AMAuthInstallBasebandSupportsServerSigning(a1, v203, v143, v144, v145, v146, v147, v148);
              if (!v142)
              {
                if (v203[0])
                {
                  if (AMAuthInstallBasebandPersonalizationEnabled(a1))
                  {
                    if (v184)
                    {
                      uint64_t v154 = AMAuthInstallBasebandServerRequestAddRequiredTags(a1, v192, v184, v149, v150, v151, v152, v153);
                      if (v154)
                      {
                        CFIndex Code = v154;
                        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"%s: missing required baseband parameters", v155, v156, v157, v158, v159, (char)"_AMAuthInstallBundleCreateServerRequestDictionary");
LABEL_108:
                        CFMutableDictionaryRef v8 = v192;
LABEL_124:
                        CFDictionaryRef v13 = v199;
                        goto LABEL_125;
                      }
                    }
                  }
                }
                uint64_t v160 = *(void *)(a1 + 48);
                if (!v160
                  || !*(void *)(v160 + 160)
                  || (LOBYTE(v200) = 1, AMAuthInstallVinylIsLegacyChipId((CFTypeRef)a1, (BOOL *)&v200))
                  || (_BYTE)v200
                  || !CFDictionaryGetValue(v192, @"eUICC,Gold")
                  && !CFDictionaryGetValue(v192, @"eUICC,Main")
                  || (uint64_t v142 = AMAuthInstallVinylServerRequestAddRequiredTags(a1, v192, 0), !v142))
                {
                  CFIndex v161 = CFDictionaryGetCount(v192);
                  if ((*(unsigned int (**)(uint64_t, __CFDictionary *, const __CFDictionary *, __CFError **))(a1 + 440))(a1, v192, a4, &v201))
                  {
                    CFDictionaryRef v12 = v15;
                    CFIndex v167 = CFDictionaryGetCount(v192);
                    if (v131 || v167 != v161)
                    {
                      CFAllocatorRef v173 = CFGetAllocator((CFTypeRef)a1);
                      CFMutableDictionaryRef v8 = v192;
                      CFPropertyListRef v174 = CFPropertyListCreateDeepCopy(v173, v192, 2uLL);
                      *uint64_t v180 = v174;
                      CFIndex Code = 2 * (v174 == 0);
                    }
                    else
                    {
                      AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"nothing to be done", v168, v169, v170, v171, v172, v178);
                      CFIndex Code = 0;
                      CFMutableDictionaryRef v8 = v192;
                    }
                    CFDictionaryRef v13 = v199;
                    goto LABEL_126;
                  }
                  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCreateServerRequestDictionary", (uint64_t)"failed to add updater tags %@", v162, v163, v164, v165, v166, (char)v201);
                  CFIndex Code = CFErrorGetCode(v201);
                  CFMutableDictionaryRef v8 = v192;
                  goto LABEL_124;
                }
              }
            }
            CFIndex Code = v142;
            goto LABEL_108;
          }
        }
        CFDictionaryRef v12 = 0;
        CFDictionaryRef v13 = 0;
        CFIndex Code = 2;
        goto LABEL_126;
      }
      CFMutableDictionaryRef v8 = 0;
    }
    else
    {
      CFMutableDictionaryRef v8 = 0;
      CFDictionaryRef v12 = 0;
    }
    CFDictionaryRef v13 = 0;
    CFIndex Code = 8;
  }
LABEL_126:
  CFDictionaryRef v175 = v13;
  SafeRelease(v202);
  SafeRelease(v8);
  SafeRelease(v12);
  SafeRelease(v175);
  SafeRelease(v201);
  return Code;
}

uint64_t sub_10001FEA0(CFTypeRef cf, const void *a2, const __CFString *a3, const void *a4, const __CFString *a5, __CFArray **a6)
{
  CFTypeRef cfa = 0;
  uint64_t result = 1;
  if (cf && a2 && a6)
  {
    CFAllocatorRef v13 = CFGetAllocator(cf);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v13, 0, &kCFTypeArrayCallBacks);
    if (!Mutable) {
      return 2;
    }
    CFMutableDictionaryRef v15 = Mutable;
    BOOL v16 = sub_100020A1C(cf, a2, a3);
    if (a4) {
      BOOL v17 = sub_100020A1C(cf, a4, a5);
    }
    else {
      BOOL v17 = 0;
    }
    if (*((void *)cf + 6))
    {
      int v18 = AMAuthInstallBasebandPersonalizationEnabled((uint64_t)cf);
      BOOL v19 = v18 != 0;
      if (!AMAuthInstallApPersonalizationEnabled((uint64_t)cf))
      {
        if (v18)
        {
          AMAuthInstallLog(5, (uint64_t)"_AMAuthInstallGeneratePersonalizationEntries", (uint64_t)"personalizing baseband only", v20, v21, v22, v23, v24, v33);
          CFStringRef v25 = @"BasebandFirmware";
LABEL_25:
          CFArrayAppendValue(v15, v25);
LABEL_27:
          uint64_t result = 0;
          *a6 = v15;
          return result;
        }
LABEL_26:
        AMAuthInstallLog(5, (uint64_t)"_AMAuthInstallGeneratePersonalizationEntries", (uint64_t)"nothing to personalize", v20, v21, v22, v23, v24, v33);
        goto LABEL_27;
      }
    }
    else
    {
      if (!AMAuthInstallApPersonalizationEnabled((uint64_t)cf)) {
        goto LABEL_26;
      }
      BOOL v19 = 0;
    }
    CFArrayAppendValue(v15, @"RestoreLogo");
    CFArrayAppendValue(v15, @"RestoreDeviceTree");
    CFArrayAppendValue(v15, @"RestoreKernelCache");
    CFArrayAppendValue(v15, @"RestoreRamDisk");
    CFArrayAppendValue(v15, @"OSRamdisk");
    CFArrayAppendValue(v15, @"iBEC");
    CFArrayAppendValue(v15, @"iBSS");
    CFArrayAppendValue(v15, @"KernelCache");
    CFArrayAppendValue(v15, @"ftap");
    CFArrayAppendValue(v15, @"rfta");
    CFArrayAppendValue(v15, @"ftsp");
    CFArrayAppendValue(v15, @"rfts");
    CFArrayAppendValue(v15, @"Ap,SystemVolumeCanonicalMetadata");
    CFArrayAppendValue(v15, @"x86,SystemVolumeCanonicalMetadata");
    CFArrayAppendValue(v15, @"BaseSystemVolume");
    CFArrayAppendValue(v15, @"x86,BaseSystemVolume");
    CFArrayAppendValue(v15, @"SystemVolume");
    CFArrayAppendValue(v15, @"x86,SystemVolume");
    CFArrayAppendValue(v15, @"Ap,BaseSystemTrustCache");
    if (AMAuthInstallApIsImg4((uint64_t)cf, v26, v27, v28, v29, v30, v31, v32))
    {
      CFArrayAppendValue(v15, @"Diags");
      CFArrayAppendValue(v15, @"CFELoader");
      CFArrayAppendValue(v15, @"RBM");
      CFArrayAppendValue(v15, @"PHLEET");
      CFArrayAppendValue(v15, @"PERTOS");
      CFArrayAppendValue(v15, @"PEHammer");
      CFArrayAppendValue(v15, @"Alamo");
    }
    if (v19)
    {
      CFArrayAppendValue(v15, @"BasebandFirmware");
      if (*(void *)(*((void *)cf + 6) + 160))
      {
        char v34 = 1;
        if (!AMAuthInstallVinylIsLegacyChipId(cf, (BOOL *)&v34) && !v34)
        {
          CFArrayAppendValue(v15, @"eUICC,Main");
          CFArrayAppendValue(v15, @"eUICC,Gold");
        }
      }
    }
    if (v16) {
      CFArrayAppendValue(v15, @"OS");
    }
    if (!v17) {
      goto LABEL_27;
    }
    CFArrayAppendValue(v15, @"RecoveryOSOS");
    CFArrayAppendValue(v15, @"RecoveryOSAppleLogo");
    CFArrayAppendValue(v15, @"RecoveryOSDeviceTree");
    CFArrayAppendValue(v15, @"RecoveryOSKernelCache");
    CFArrayAppendValue(v15, @"RecoveryOSRamDisk");
    CFArrayAppendValue(v15, @"RecoveryOSiBEC");
    CFArrayAppendValue(v15, @"RecoveryOSiBSS");
    CFArrayAppendValue(v15, @"RecoveryOSStaticTrustCache");
    CFArrayAppendValue(v15, @"RecoveryOSiBootData");
    CFArrayAppendValue(v15, @"RecoveryOSDiags");
    CFArrayAppendValue(v15, @"RecoveryOSAp,SystemVolumeCanonicalMetadata");
    CFArrayAppendValue(v15, @"RecoveryOSSystemVolume");
    CFArrayAppendValue(v15, @"RecoveryOSBaseSystemVolume");
    CFStringRef v25 = @"RecoveryOSAp,BaseSystemTrustCache";
    goto LABEL_25;
  }
  return result;
}

uint64_t AMAuthInstallBundleShouldPersonalizeOSImage(uint64_t a1, const void *a2, const __CFString *a3)
{
  if (a1
    && a2
    && (CFDictionaryRef ManifestEntry = AMAuthInstallBundleGetManifestEntry(a1, @"Manifest", a3, a2)) != 0
    && (CFDictionaryRef v4 = (const __CFDictionary *)CFDictionaryGetValue(ManifestEntry, @"OS")) != 0
    && (CFDictionaryRef v5 = (const __CFDictionary *)CFDictionaryGetValue(v4, @"Info")) != 0
    && (CFBooleanRef v6 = (const __CFBoolean *)CFDictionaryGetValue(v5, @"Personalize")) != 0)
  {
    uint64_t Value = CFBooleanGetValue(v6);
    CFAllocatorRef v13 = "Yes";
    if (!Value) {
      CFAllocatorRef v13 = "No";
    }
    AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBundleShouldPersonalizeOSImage", (uint64_t)"Personalize OS image = %s", v7, v8, v9, v10, v11, (char)v13);
  }
  else
  {
    AMSupportCreateErrorInternal();
    return 0;
  }
  return Value;
}

CFDictionaryRef AMAuthInstallBundleGetManifestEntry(uint64_t a1, const __CFString *a2, const __CFString *a3, const void *a4)
{
  CFDictionaryRef ValueForKeyPathInDict = (const __CFDictionary *)a1;
  *(void *)CFAllocatorRef v13 = 0;
  if (!a1) {
    goto LABEL_7;
  }
  if (!a2 || !a3 || !a4 || AMAuthInstallBundleCopyBuildIdentityForVariant(a1, a4, a3, (CFTypeRef *)v13))
  {
    AMSupportCreateErrorInternal();
    CFDictionaryRef ValueForKeyPathInDict = 0;
    goto LABEL_8;
  }
  CFAllocatorRef v6 = CFGetAllocator(ValueForKeyPathInDict);
  CFDictionaryRef ValueForKeyPathInDict = AMAuthInstallSupportGetValueForKeyPathInDict(v6, *(const __CFDictionary **)v13, a2, v7, v8, v9, v10, v11);
  if (!ValueForKeyPathInDict) {
LABEL_7:
  }
    AMSupportCreateErrorInternal();
LABEL_8:
  SafeRelease(*(CFTypeRef *)v13);
  return ValueForKeyPathInDict;
}

uint64_t AMAuthInstallBundlePersonalizeWithRecoveryOS(void *a1, const void *a2, const void *a3, const __CFString *a4, const void *a5, const __CFString *a6)
{
  CFIndex v36 = 0;
  if (a1)
  {
    uint64_t v12 = sub_10001FEA0(a1, a2, a4, a5, a6, &v36);
    if (v12)
    {
      uint64_t v33 = v12;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizeWithRecoveryOS", (uint64_t)"failed to generate personalization entries", v13, v14, v15, v16, v17, v35);
      CFMutableArrayRef Mutable = 0;
      uint64_t v22 = 0;
    }
    else
    {
      BOOL v18 = sub_100020A1C(a1, a2, a4);
      if (a5) {
        sub_100020A1C(a1, a5, a6);
      }
      CFAllocatorRef v19 = CFGetAllocator(a1);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v19, 0, &kCFTypeArrayCallBacks);
      CFAllocatorRef v21 = CFGetAllocator(a1);
      uint64_t v22 = CFArrayCreateMutable(v21, 0, &kCFTypeArrayCallBacks);
      if (a1[6]) {
        AMAuthInstallBasebandPersonalizationEnabled((uint64_t)a1);
      }
      if (AMAuthInstallApPersonalizationEnabled((uint64_t)a1))
      {
        CFArrayAppendValue(Mutable, @"OS");
        if (!AMAuthInstallApIsImg4((uint64_t)a1, v23, v24, v25, v26, v27, v28, v29)) {
          CFArrayAppendValue(Mutable, @"Diags");
        }
        char v30 = 1;
        CFStringRef v31 = @"Restore.plist";
        CFStringRef v32 = @"BuildManifest.plist";
      }
      else
      {
        CFArrayAppendValue(Mutable, @"RestoreRamDisk");
        CFArrayAppendValue(Mutable, @"OSRamdisk");
        CFArrayAppendValue(Mutable, @"KernelCache");
        if (!v18) {
          CFArrayAppendValue(Mutable, @"OS");
        }
        CFArrayAppendValue(v22, @"BuildManifest.plist");
        CFArrayAppendValue(v22, @"Restore.plist");
        char v30 = 0;
        CFStringRef v31 = @"Firmware/all_flash";
        CFStringRef v32 = @"Firmware/dfu";
      }
      CFArrayAppendValue(v22, v32);
      CFArrayAppendValue(v22, v31);
      CFArrayAppendValue(v22, @"Firmware/device_map.txt");
      CFArrayAppendValue(v22, @"Firmware/device_map.plist");
      CFArrayAppendValue(v22, @"Firmware/SE");
      if (a5 && !AMAuthInstallBundleShouldPersonalizeOSImage((uint64_t)a1, a5, a6)) {
        CFArrayAppendValue(Mutable, @"RecoveryOSOS");
      }
      uint64_t v33 = 2;
      if (Mutable && v22) {
        uint64_t v33 = AMAuthInstallBundlePersonalizePartialWithRecoveryOS((unint64_t)a1, a2, a3, a4, (uint64_t)a5, a6, v36, Mutable, v22, v30);
      }
    }
  }
  else
  {
    CFMutableArrayRef Mutable = 0;
    uint64_t v22 = 0;
    uint64_t v33 = 1;
  }
  SafeRelease(v36);
  SafeRelease(Mutable);
  SafeRelease(v22);
  SafeRelease(0);
  return v33;
}

BOOL sub_100020A1C(const void *a1, const void *a2, const __CFString *a3)
{
  CFTypeRef cf = 0;
  if (!a1)
  {
    AMSupportCreateErrorInternal();
    return 0;
  }
  if (a2)
  {
    int v4 = AMAuthInstallBundleCopyBuildIdentityForVariant((uint64_t)a1, a2, a3, &cf);
    if (!v4)
    {
      CFGetAllocator(a1);
      uint64_t ValueForKeyPathInDict = AMSupportGetValueForKeyPathInDict();
      BOOL v10 = ValueForKeyPathInDict != 0;
      uint64_t v17 = "No";
      if (ValueForKeyPathInDict) {
        uint64_t v17 = "Yes";
      }
      AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundleShouldPersonalizeOS", (uint64_t)"Personalize OS = %s", v12, v13, v14, v15, v16, (char)v17);
      goto LABEL_9;
    }
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleShouldPersonalizeOS", (uint64_t)"failed to copy build variant %d", v5, v6, v7, v8, v9, v4);
  }
  AMSupportCreateErrorInternal();
  BOOL v10 = 0;
LABEL_9:
  if (cf) {
    CFRelease(cf);
  }
  return v10;
}

uint64_t AMAuthInstallBundleCopyURLForKey(CFDictionaryRef **a1, const __CFString *a2, CFStringRef theString1, const __CFURL *a4, void *a5)
{
  CFStringRef v5 = 0;
  CFStringRef pathComponent = 0;
  char v74 = 0;
  *(void *)CFTypeRef v72 = 0;
  *(void *)uint64_t v73 = 0;
  uint64_t v6 = 1;
  if (!a1 || !a2 || !a4)
  {
    CFStringRef v9 = 0;
    CFStringRef v10 = 0;
    CFURLRef v11 = 0;
    CFURLRef v12 = 0;
    uint64_t v13 = 0;
    goto LABEL_18;
  }
  CFStringRef v9 = 0;
  CFStringRef v10 = 0;
  CFURLRef v11 = 0;
  CFURLRef v12 = 0;
  uint64_t v13 = 0;
  if (a5)
  {
    CFBooleanRef v16 = sub_10001A910((uint64_t)a1, theString1);
    uint64_t IfNecessary = AMAuthInstallBundleCopyReceiptCreateIfNecessary((uint64_t)a1, a4, (CFPropertyListRef *)v73);
    if (IfNecessary)
    {
      uint64_t v6 = IfNecessary;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyURLForKey", (uint64_t)"failed to create receipt dict", v18, v19, v20, v21, v22, v70);
      CFStringRef v5 = 0;
      CFStringRef v9 = 0;
      CFStringRef v10 = 0;
      CFURLRef v11 = 0;
      CFURLRef v12 = 0;
      uint64_t v13 = 0;
      goto LABEL_18;
    }
    int Value = CFBooleanGetValue(v16);
    CFAllocatorRef v24 = CFGetAllocator(a1);
    if (Value) {
      CFStringRef Copy = AMAuthInstallICreateTranslationOfRecoveryEnteryName(v24, a2);
    }
    else {
      CFStringRef Copy = CFStringCreateCopy(v24, a2);
    }
    uint64_t v26 = (uint64_t)Copy;
    CFAllocatorRef v27 = CFGetAllocator(a1);
    CFStringRef v5 = CFStringCreateWithFormat(v27, 0, @"%@.%@.%@.");
    if (v5)
    {
      CFAllocatorRef v28 = CFGetAllocator(a1);
      CFDictionaryRef MutableCopy = CFStringCreateMutableCopy(v28, 0, v5);
      CFStringRef v9 = MutableCopy;
      if (MutableCopy)
      {
        CFStringAppend(MutableCopy, @"PersonalizedPath");
        CFAllocatorRef v30 = CFGetAllocator(a1);
        CFDictionaryRef ValueForKeyPathInDict = AMAuthInstallSupportGetValueForKeyPathInDict(v30, *(const __CFDictionary **)v73, v9, v31, v32, v33, v34, v35);
        if (ValueForKeyPathInDict)
        {
          CFStringRef v37 = (const __CFString *)ValueForKeyPathInDict;
          uint64_t v13 = (const void *)v26;
          CFStringRef v10 = 0;
          CFURLRef v12 = 0;
LABEL_13:
          CFAllocatorRef v38 = CFGetAllocator(a1);
          CFURLRef v39 = CFURLCreateCopyAppendingPathComponent(v38, a4, v37, 0);
          CFURLRef v11 = v39;
          if (v39)
          {
            CFTypeRef v40 = CFRetain(v39);
            uint64_t v6 = 0;
LABEL_17:
            *a5 = v40;
            goto LABEL_18;
          }
LABEL_32:
          uint64_t v6 = 2;
          goto LABEL_18;
        }
        CFAllocatorRef v41 = CFDictionaryGetValue(*a1[16], a2);
        if (v41)
        {
          CFTypeRef v40 = CFRetain(v41);
          uint64_t v6 = 0;
          CFStringRef v10 = 0;
          CFURLRef v11 = 0;
          uint64_t v13 = (const void *)v26;
          CFURLRef v12 = 0;
          goto LABEL_17;
        }
        uint64_t v43 = AMAuthInstallBundleCopyBuildIdentityForVariant((uint64_t)a1, a4, theString1, (CFTypeRef *)v72);
        if (v43)
        {
          uint64_t v6 = v43;
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyURLForKey", (uint64_t)"failed to copy variant", v44, v45, v46, v47, v48, (char)@"Manifest");
          CFStringRef v10 = 0;
          CFURLRef v11 = 0;
          uint64_t v13 = (const void *)v26;
          goto LABEL_36;
        }
        CFAllocatorRef v49 = CFGetAllocator(a1);
        CFDictionaryRef v50 = CFStringCreateMutableCopy(v49, 0, v5);
        if (v50)
        {
          CFStringRef v51 = v50;
          CFStringAppend(v50, @"Path");
          CFAllocatorRef v52 = CFGetAllocator(a1);
          CFStringRef v10 = v51;
          CFDictionaryRef v58 = AMAuthInstallSupportGetValueForKeyPathInDict(v52, *(const __CFDictionary **)v72, v51, v53, v54, v55, v56, v57);
          if (!v58)
          {
            CFURLRef v11 = 0;
            uint64_t v13 = (const void *)v26;
            CFURLRef v12 = 0;
            uint64_t v6 = 8;
            goto LABEL_18;
          }
          CFStringRef v59 = (const __CFString *)v58;
          CFAllocatorRef v60 = CFGetAllocator(a1);
          uint64_t v13 = (const void *)v26;
          uint64_t v61 = AMAuthInstallSupportCreatePrependedFilePath(v60, v26, v59, &pathComponent);
          if (!v61)
          {
            CFAllocatorRef v67 = CFGetAllocator(a1);
            CFURLRef v68 = CFURLCreateCopyAppendingPathComponent(v67, a4, pathComponent, 0);
            CFURLRef v12 = v68;
            if (!v68)
            {
              CFURLRef v11 = 0;
              goto LABEL_32;
            }
            uint64_t v69 = AMAuthInstallSupportFileURLExists(v68, &v74);
            if (v69)
            {
              uint64_t v6 = v69;
              CFURLRef v11 = 0;
              goto LABEL_18;
            }
            if (v74) {
              CFStringRef v37 = pathComponent;
            }
            else {
              CFStringRef v37 = v59;
            }
            goto LABEL_13;
          }
          uint64_t v6 = v61;
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyURLForKey", (uint64_t)"failed to prepend entry name to path", v62, v63, v64, v65, v66, (char)@"Manifest");
          CFURLRef v11 = 0;
LABEL_36:
          CFURLRef v12 = 0;
          goto LABEL_18;
        }
      }
    }
    else
    {
      CFStringRef v9 = 0;
    }
    CFStringRef v10 = 0;
    CFURLRef v11 = 0;
    uint64_t v13 = (const void *)v26;
    CFURLRef v12 = 0;
    goto LABEL_32;
  }
LABEL_18:
  SafeRelease(pathComponent);
  SafeRelease(*(CFTypeRef *)v73);
  SafeRelease(v13);
  SafeRelease(v5);
  SafeRelease(v9);
  SafeRelease(v10);
  SafeRelease(*(CFTypeRef *)v72);
  SafeRelease(v11);
  SafeRelease(v12);
  return v6;
}

uint64_t AMAuthInstallBundlePersonalizeRestoreLocalPolicy(const void *a1, const void *a2, const void *a3, CFTypeRef *a4)
{
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFTypeRef cf = 0;
  CFTypeRef v22 = 0;
  CFDictionaryRef theDict = 0;
  CFURLRef v20 = 0;
  CFDictionaryRef v18 = 0;
  uint64_t ServerRequest = AMAuthInstallPlatformCopyURLWithAppendedComponent(v8, a2, @"amai/LocalPolicy.restore.img4", 0, &v20);
  if (ServerRequest
    || (uint64_t ServerRequest = sub_1000210AC(a1, a2, a3, &v22), ServerRequest)
    || (uint64_t ServerRequest = AMAuthInstallRestoreLocalPolicyCreateServerRequest((uint64_t)a1, v22, (CFTypeRef *)&theDict),
        ServerRequest)
    || (uint64_t ServerRequest = AMAuthInstallApCreatePersonalizedResponse((uint64_t)a1, theDict, (CFTypeRef *)&v18),
        ServerRequest)
    || (uint64_t ServerRequest = AMAuthInstallLocalPolicyStitchTicketData(a1, v18, &cf), ServerRequest))
  {
    uint64_t v16 = ServerRequest;
  }
  else
  {
    uint64_t v10 = AMAuthInstallSupportWriteDataToFileURL(v8, (const __CFData *)cf, v20, 1);
    if (v10)
    {
      uint64_t v16 = v10;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundlePersonalizeRestoreLocalPolicy", (uint64_t)"failed to write local policy to %@", v11, v12, v13, v14, v15, (char)v20);
    }
    else
    {
      uint64_t v16 = 0;
      if (a4) {
        *a4 = CFRetain(cf);
      }
    }
  }
  SafeRelease(v18);
  SafeRelease(theDict);
  SafeRelease(v20);
  SafeRelease(cf);
  SafeRelease(v22);
  SafeRelease(0);
  return v16;
}

CFStringRef AMAuthInstallBundleGetRestoreLocalPolicyComponentPath()
{
  return @"amai/LocalPolicy.restore.img4";
}

uint64_t sub_1000210AC(const void *a1, const void *a2, CFTypeRef cf, CFTypeRef *a4)
{
  if (!a4) {
    return 1;
  }
  if (cf)
  {
    uint64_t v5 = 0;
    *a4 = CFRetain(cf);
  }
  else
  {
    CFAllocatorRef v15 = CFGetAllocator(a1);
    CFURLRef v26 = 0;
    CFTypeRef v27 = 0;
    if (a1 && AMAuthInstallApIsImg4((uint64_t)a1, v8, v9, v10, v11, v12, v13, v14)) {
      CFStringRef v16 = @"amai/apimg4ticket.der";
    }
    else {
      CFStringRef v16 = @"amai/apticket.der";
    }
    uint64_t v17 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v15, a2, v16, 0, &v26);
    if (v17)
    {
      uint64_t v5 = v17;
      CFAllocatorRef v24 = 0;
    }
    else
    {
      uint64_t Digest = (const void *)AMAuthInstallApCreateDigest((uint64_t)v26, 4096, 384);
      CFAllocatorRef v24 = Digest;
      if (Digest)
      {
        uint64_t v5 = 0;
        *a4 = CFRetain(Digest);
      }
      else
      {
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleLocalPolicyCopyDefaultNSIH", (uint64_t)"failed to compute NSIH for %@: %@", v19, v20, v21, v22, v23, (char)v26);
        uint64_t v5 = 4;
      }
    }
    SafeRelease(v26);
    SafeRelease(v24);
    SafeRelease(v27);
  }
  return v5;
}

CFTypeRef _CreateRelativePathForManifestEntry(const void *a1, uint64_t a2, const __CFURL *a3, const __CFDictionary *a4, uint64_t a5)
{
  CFTypeRef v5 = 0;
  CFDictionaryRef v29 = 0;
  if (a1)
  {
    if (a3)
    {
      char v6 = a5;
      if (a5)
      {
        if (AMAuthInstallBundleCopyReceiptCreateIfNecessary((uint64_t)a1, a3, (CFPropertyListRef *)&v29))
        {
          AMAuthInstallLog(3, (uint64_t)"_CreateRelativePathForManifestEntry", (uint64_t)"failed to create receipt dict", v9, v10, v11, v12, v13, v28);
        }
        else
        {
          CFAllocatorRef v14 = CFGetAllocator(a1);
          CFDictionaryRef ValueForKeyWithFormat = AMAuthInstallSupportGetValueForKeyWithFormat(v14, v29, @"%@.%@.%@.%@", v15, v16, v17, v18, v19, (char)@"Manifest");
          if (ValueForKeyWithFormat
            || (CFAllocatorRef v21 = CFGetAllocator(a1),
                (CFDictionaryRef ValueForKeyWithFormat = AMAuthInstallSupportGetValueForKeyWithFormat(v21, a4, @"%@.%@.%@", v22, v23, v24, v25, v26, v6)) != 0))
          {
            CFTypeRef v5 = CFRetain(ValueForKeyWithFormat);
            goto LABEL_8;
          }
        }
        CFTypeRef v5 = 0;
      }
    }
  }
LABEL_8:
  SafeRelease(v29);
  return v5;
}

uint64_t AMAuthInstallBundleSetVariantSpecifiesRestoreBehavior(uint64_t a1, char a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 56) = a2;
  return result;
}

CFStringRef AMAuthInstallBundleGetReceiptComponent()
{
  return @"amai/receipt.plist";
}

CFStringRef AMAuthInstallBundleGetApTicketComponentPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && AMAuthInstallApIsImg4(a1, a2, a3, a4, a5, a6, a7, a8)) {
    return @"amai/apimg4ticket.der";
  }
  else {
    return @"amai/apticket.der";
  }
}

uint64_t AMAuthInstallBundleOverrideEntry(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    if (a3)
    {
      AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBundleOverrideEntry", (uint64_t)"overriding entry: %@", a4, a5, a6, a7, a8, (char)a2);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallBundleOverrideEntry", (uint64_t)"override path: %@", v12, v13, v14, v15, v16, (char)a3);
      CFDictionarySetValue(**(CFMutableDictionaryRef **)(a1 + 128), a2, a3);
      return 0;
    }
  }
  return result;
}

uint64_t AMAuthInstallBundleOverrideBuildManifest(void *a1, const __CFURL *a2)
{
  uint64_t v2 = 1;
  if (a1 && a2)
  {
    CFAllocatorRef v5 = CFGetAllocator(a1);
    uint64_t DictionaryFromFileURL = AMAuthInstallSupportCreateDictionaryFromFileURL(v5, (CFTypeRef *)(a1[16] + 16), a2);
    if (DictionaryFromFileURL)
    {
      uint64_t v2 = DictionaryFromFileURL;
      uint64_t v12 = "failed to read build identity override file";
    }
    else
    {
      if (*(void *)(a1[16] + 16)) {
        return 0;
      }
      uint64_t v2 = 14;
      uint64_t v12 = "failed to create build identity override";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleOverrideBuildManifest", (uint64_t)v12, v7, v8, v9, v10, v11, v14);
  }
  return v2;
}

uint64_t AMAuthInstallBundleOverrideRecoveryOSBuildManifest(void *a1, const __CFURL *a2)
{
  uint64_t v2 = 1;
  if (a1 && a2)
  {
    CFAllocatorRef v5 = CFGetAllocator(a1);
    uint64_t DictionaryFromFileURL = AMAuthInstallSupportCreateDictionaryFromFileURL(v5, (CFTypeRef *)(a1[16] + 24), a2);
    if (DictionaryFromFileURL)
    {
      uint64_t v2 = DictionaryFromFileURL;
      uint64_t v12 = "failed to read recoveryOS build identity override file";
    }
    else
    {
      if (*(void *)(a1[16] + 24)) {
        return 0;
      }
      uint64_t v2 = 14;
      uint64_t v12 = "failed to create recoveryOS build identity override";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleOverrideRecoveryOSBuildManifest", (uint64_t)v12, v7, v8, v9, v10, v11, v14);
  }
  return v2;
}

CFStringRef _AMAuthInstallBundleImageHasBuildString(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    if (CFStringCompare(result, @"iBSS", 0) && CFStringCompare(v1, @"iBEC", 0)) {
      return (const __CFString *)(CFEqual(v1, @"LLB"));
    }
    else {
      return (const __CFString *)1;
    }
  }
  return result;
}

uint64_t _AMAuthInstallBundleApplyMeasurements(uint64_t a1, CFStringRef theString1, const void *a3, const __CFDictionary *a4, CFMutableDictionaryRef *a5)
{
  CFMutableDictionaryRef theDict = 0;
  uint64_t v76 = theString1;
  if (!a1)
  {
    char v6 = 0;
    uint64_t v10 = 0;
    uint64_t Code = 1;
    goto LABEL_39;
  }
  char v6 = 0;
  uint64_t Code = 1;
  if (!theString1 || (uint64_t v8 = a3) == 0)
  {
    uint64_t v10 = 0;
    goto LABEL_39;
  }
  uint64_t v10 = 0;
  if (!a5) {
    goto LABEL_39;
  }
  if (CFEqual(theString1, @"BasebandFirmware"))
  {
    int Value = CFDictionaryGetValue(**(CFDictionaryRef **)(a1 + 128), @"VinylFirmware");
    if (Value) {
      AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleApplyMeasurements", (uint64_t)"using vinyl firmware override: %@ = %@", v33, v34, v35, v36, v37, (char)@"VinylFirmware");
    }
    uint64_t Measurements = AMAuthInstallBasebandCreateMeasurements((void *)a1, v8, Value, (CFTypeRef *)&theDict);
    if (Measurements)
    {
      uint64_t Code = Measurements;
      goto LABEL_38;
    }
    uint64_t v42 = *(void *)(a1 + 48);
    if (v42 && *(_DWORD *)(v42 + 4) == 104)
    {
      if (AMAuthInstallIsICE19BBGoldCertIDECDSA(*(_DWORD *)(v42 + 8), v40, v41, v28, v29, v30, v31, v32))
      {
        CFStringRef v43 = @"PSI2-PartialDigest";
        CFDictionaryRemoveValue(theDict, @"PSI2-PartialDigest");
        uint64_t v44 = theDict;
        uint64_t v45 = &kAMAuthInstallTagBbRestorePsi2PartialDigest;
      }
      else
      {
        CFStringRef v43 = @"PSI-PartialDigest";
        CFDictionaryRemoveValue(theDict, @"PSI-PartialDigest");
        uint64_t v44 = theDict;
        uint64_t v45 = &kAMAuthInstallTagBbRestorePsiPartialDigest;
      }
      uint64_t v47 = *v45;
      CFDictionaryRemoveValue(v44, *v45);
      CFDictionaryRemoveValue(*a5, v43);
      CFDictionaryRemoveValue(*a5, v47);
    }
    a4 = 0;
    goto LABEL_25;
  }
  if (CFEqual(theString1, @"eUICC,Main")
    || CFEqual(theString1, @"eUICC,Gold"))
  {
    CFAllocatorRef v21 = CFDictionaryGetValue(**(CFDictionaryRef **)(a1 + 128), @"VinylFirmware");
    if (v21)
    {
      CFTypeRef v27 = v21;
      AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleApplyMeasurements", (uint64_t)"using vinyl firmware override: %@ = %@", v22, v23, v24, v25, v26, (char)@"VinylFirmware");
      uint64_t v8 = v27;
    }
    uint64_t Code = AMAuthInstallVinylCreateMeasurements((CFTypeRef)a1, v8, &theDict, &v76);
    a4 = 0;
    char v6 = 0;
    uint64_t v10 = 0;
    if (Code) {
      goto LABEL_39;
    }
    goto LABEL_25;
  }
  CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)a1);
  CFStringRef ValueForKeyWithFormat = (const __CFString *)AMAuthInstallSupportGetValueForKeyWithFormat(v13, a4, @"%@.%@", v14, v15, v16, v17, v18, (char)@"Info");
  if (AMAuthInstallApImg4ValidImage((const __CFURL *)v8))
  {
    int v46 = *(_DWORD *)(*(void *)(a1 + 16) + 112);
    goto LABEL_47;
  }
  CFAllocatorRef v53 = CFGetAllocator((CFTypeRef)a1);
  CFDictionaryRef v59 = AMAuthInstallSupportGetValueForKeyWithFormat(v53, a4, @"%@.%@", v54, v55, v56, v57, v58, (char)@"Info");
  if (!v59 || (v60 = (const __CFString *)v59, CFTypeID TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(v60)))
  {
    int v46 = 256;
    goto LABEL_47;
  }
  int v62 = *(unsigned __int8 *)(*(void *)(a1 + 16) + 96);
  if (CFStringCompare(v60, @"sha1", 0))
  {
    if (CFStringCompare(v60, @"sha2-256", 0))
    {
      if (CFStringCompare(v60, @"sha2-384", 0))
      {
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleApplyMeasurements", (uint64_t)"digest type in the build manifest is not supported", v63, v64, v65, v66, v67, v74);
        char v6 = 0;
        uint64_t v10 = 0;
        uint64_t Code = 7;
        goto LABEL_39;
      }
      int v46 = 384;
    }
    else
    {
      int v46 = 256;
    }
  }
  else
  {
    int v46 = 1;
  }
  if (v62)
  {
LABEL_47:
    CFIndex MeasurementsWithTag = AMAuthInstallApCreateMeasurementsWithTag((void *)a1, (const __CFURL *)v8, ValueForKeyWithFormat, v46, 0, 0, (CFTypeRef *)&theDict);
    if (MeasurementsWithTag)
    {
      uint64_t Code = MeasurementsWithTag;
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleApplyMeasurements", (uint64_t)"failed to measure %@", v28, v29, v30, v31, v32, (char)theString1);
      goto LABEL_38;
    }
LABEL_25:
    uint64_t v48 = theDict;
    if (!theDict)
    {
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleApplyMeasurements", (uint64_t)"failed find measurementsDict for entry %@", v28, v29, v30, v31, v32, (char)v76);
      char v6 = 0;
      uint64_t v10 = 0;
      uint64_t Code = 8;
      goto LABEL_39;
    }
    goto LABEL_26;
  }
  uint64_t v48 = AMAuthInstallApMeasureBinary((uint64_t)v8, 0x100000, v46);
  CFMutableDictionaryRef theDict = v48;
  if (!v48)
  {
    uint64_t Code = CFErrorGetCode(0);
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleApplyMeasurements", (uint64_t)"failed to measure %@ with error: %@", v69, v70, v71, v72, v73, (char)theString1);
    char v6 = 0;
    uint64_t v10 = 0;
    goto LABEL_39;
  }
LABEL_26:
  int64_t Count = CFDictionaryGetCount(v48);
  if (Count < 1)
  {
    uint64_t Code = 0;
LABEL_38:
    char v6 = 0;
    uint64_t v10 = 0;
    goto LABEL_39;
  }
  size_t v50 = Count;
  char v6 = (const void **)calloc(8uLL, Count);
  uint64_t v10 = (const void **)calloc(8uLL, v50);
  CFDictionaryGetKeysAndValues(theDict, v6, v10);
  for (uint64_t i = 0; i != v50; ++i)
  {
    if (!a4
      || CFDictionaryContainsKey(a4, v6[i])
      || CFEqual((CFStringRef)v6[i], @"MemoryMap")
      || CFEqual((CFStringRef)v6[i], @"RawDataDigest"))
    {
      CFDictionarySetValue(*a5, v6[i], v10[i]);
    }
  }
  uint64_t Code = 0;
LABEL_39:
  SafeRelease(theDict);
  SafeFree(v6);
  SafeFree(v10);
  SafeRelease(0);
  return Code;
}

CFIndex _AMAuthInstallBundleSetObjectPropertyOverrides(void *a1, const void *a2, __CFDictionary *a3)
{
  CFMutableDictionaryRef v15 = a3;
  CFIndex result = 1;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        CFIndex result = a1[53];
        if (result)
        {
          CFIndex result = (CFIndex)CFDictionaryGetValue((CFDictionaryRef)result, @"ObjectRequestEntries");
          if (result)
          {
            CFIndex result = (CFIndex)CFDictionaryGetValue((CFDictionaryRef)result, a2);
            if (result)
            {
              CFDictionaryRef v6 = (const __CFDictionary *)result;
              int v7 = CFGetAllocator(a1);
              CFIndex result = AMAuthInstallSupportApplyDictionaryOverrides(v7, v6, &v15, 0);
              if (result)
              {
                char v14 = (char)a2;
                CFIndex v13 = result;
                AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleSetObjectPropertyOverrides", (uint64_t)"failed to set override object properties for %@", v8, v9, v10, v11, v12, v14);
                return v13;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t AMAuthInstallBundleAllowLinks(uint64_t a1, int a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 432) = a2 == 0;
  return result;
}

uint64_t AMAuthInstallBundleInstallFile(unsigned char *a1, const __CFURL *a2, CFURLRef url)
{
  uint64_t SoftLink = 1;
  if (a2 && a1 && url)
  {
    if (a1[432])
    {
      char v18 = 0;
      uint64_t v7 = AMAuthInstallSupportFileURLExists(url, &v18);
      if (v7)
      {
        uint64_t SoftLink = v7;
        uint64_t v16 = "AMAuthInstallSupportFileURLExists failed.";
      }
      else
      {
        if (v18 != 1) {
          return 0;
        }
        CFAllocatorRef v13 = CFGetAllocator(a1);
        uint64_t v14 = AMAuthInstallSupportCopyFile((uint64_t)v13, url, a2);
        if (!v14) {
          return 0;
        }
        uint64_t SoftLink = v14;
        uint64_t v16 = "AMAuthInstallSupportCopyFile failed.";
      }
    }
    else
    {
      uint64_t SoftLink = AMAuthInstallPlatformCreateSoftLink(a2, url);
      if (!SoftLink) {
        return SoftLink;
      }
      uint64_t v16 = "AMAuthInstallPlatformCreateSoftLink failed.";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleInstallFile", (uint64_t)v16, v8, v9, v10, v11, v12, v17);
  }
  return SoftLink;
}

uint64_t AMAuthInstallBundleRequestTicketWithoutNonce(uint64_t a1, char a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 433) = a2;
  return result;
}

uint64_t _AMAuthInstallBundleGetValueForReservedKey(uint64_t a1, CFStringRef theString1, CFBooleanRef *a3)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 1;
  if (a3 && theString1 && *(void *)(a1 + 16))
  {
    if (CFStringCompare(theString1, @"ApRawProductionMode", 0))
    {
      if (CFStringCompare(theString1, @"ApRawSecurityMode", 0))
      {
        if (CFStringCompare(theString1, @"ApInRomDFU", 0))
        {
          if (CFStringCompare(theString1, @"ApCurrentSecurityMode", 0))
          {
            if (CFStringCompare(theString1, @"ApCurrentProductionMode", 0))
            {
              if (CFStringCompare(theString1, @"ApRequiresImage4", 0))
              {
                if (CFStringCompare(theString1, @"ApDemotionPolicyOverride", 0)) {
                  return 8;
                }
                CFBooleanRef v16 = *(CFBooleanRef *)(*(void *)(a1 + 16) + 88);
                goto LABEL_22;
              }
              int IsImg4 = AMAuthInstallApIsImg4(a1, v7, v8, v9, v10, v11, v12, v13);
              CFMutableDictionaryRef v15 = &kCFBooleanTrue;
              if (!IsImg4) {
                CFMutableDictionaryRef v15 = &kCFBooleanFalse;
              }
LABEL_21:
              CFBooleanRef v16 = *v15;
LABEL_22:
              uint64_t result = 0;
              *a3 = v16;
              return result;
            }
            int v14 = *(unsigned __int8 *)(*(void *)(a1 + 16) + 81);
          }
          else
          {
            int v14 = *(unsigned __int8 *)(*(void *)(a1 + 16) + 82);
          }
        }
        else
        {
          int v14 = *(unsigned __int8 *)(*(void *)(a1 + 16) + 80);
        }
      }
      else
      {
        int v14 = *(unsigned __int8 *)(*(void *)(a1 + 16) + 72);
      }
    }
    else
    {
      int v14 = *(unsigned __int8 *)(*(void *)(a1 + 16) + 20);
    }
    if (v14) {
      CFMutableDictionaryRef v15 = &kCFBooleanTrue;
    }
    else {
      CFMutableDictionaryRef v15 = &kCFBooleanFalse;
    }
    goto LABEL_21;
  }
  return result;
}

CFBooleanRef _AMAuthInstallBundleGetDefaultResult(const __CFString *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFBooleanGetTypeID())
  {
    uint64_t v3 = &kCFBooleanFalse;
    if (kCFBooleanFalse == (const CFBooleanRef)a1) {
LABEL_13:
    }
      uint64_t v3 = &kCFBooleanTrue;
  }
  else
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFStringGetTypeID())
    {
      if (CFEqual(a1, &stru_10009EF88)) {
        goto LABEL_13;
      }
    }
    else
    {
      CFTypeID v5 = CFGetTypeID(a1);
      if (v5 == CFNumberGetTypeID())
      {
        int valuePtr = 0;
        CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &valuePtr);
        if (!valuePtr) {
          goto LABEL_13;
        }
      }
      else
      {
        CFTypeID v6 = CFGetTypeID(a1);
        if (v6 == CFDataGetTypeID() && !CFDataGetLength((CFDataRef)a1)) {
          goto LABEL_13;
        }
      }
    }
    uint64_t v3 = &kCFBooleanFalse;
  }
  return *v3;
}

uint64_t _AMAuthInstallBundleGetValueForCondition(uint64_t a1, const __CFString *a2, const __CFString *a3, CFBooleanRef *a4)
{
  CFTypeRef cf = 0;
  uint64_t result = 1;
  if (a1 && a2 && a4)
  {
    if (_AMAuthInstallBundleGetValueForReservedKey(a1, a2, (CFBooleanRef *)&cf))
    {
      CFBooleanRef DefaultResult = _AMAuthInstallBundleGetDefaultResult(a3);
LABEL_16:
      uint64_t result = 0;
      *a4 = DefaultResult;
      return result;
    }
    CFTypeID v9 = CFGetTypeID(cf);
    if (v9 == CFBooleanGetTypeID())
    {
      uint64_t v10 = &kCFBooleanTrue;
      if (cf != a3) {
        uint64_t v10 = &kCFBooleanFalse;
      }
    }
    else
    {
      CFTypeID v11 = CFGetTypeID(cf);
      if (v11 != CFStringGetTypeID())
      {
        CFBooleanRef DefaultResult = 0;
        goto LABEL_16;
      }
      if (CFStringCompare((CFStringRef)cf, a3, 0)) {
        uint64_t v10 = &kCFBooleanFalse;
      }
      else {
        uint64_t v10 = &kCFBooleanTrue;
      }
    }
    CFBooleanRef DefaultResult = *v10;
    goto LABEL_16;
  }
  return result;
}

uint64_t _AMAuthInstallBundleGetValueForAction(uint64_t a1, uint64_t a2, const __CFString *cf, const __CFString **a4)
{
  CFStringRef v9 = 0;
  uint64_t result = 1;
  if (a1 && a2 && a4)
  {
    CFStringRef v7 = cf;
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == CFStringGetTypeID()
      && !_AMAuthInstallBundleGetValueForReservedKey(a1, v7, (CFBooleanRef *)&v9))
    {
      CFStringRef v7 = v9;
    }
    uint64_t result = 0;
    *a4 = v7;
  }
  return result;
}

uint64_t _AMAuthInstallBundleCheckCondition(uint64_t a1, CFDictionaryRef theDict, char *a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 1;
  if (!a1 || !theDict)
  {
    CFStringRef v7 = 0;
    goto LABEL_16;
  }
  CFStringRef v7 = 0;
  if (a3)
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    uint64_t v3 = (const void **)malloc(8 * Count);
    if (v3)
    {
      CFStringRef v7 = (const void **)malloc(8 * Count);
      if (v7)
      {
        CFDictionaryGetKeysAndValues(theDict, v3, v7);
        if (Count < 1)
        {
          char v11 = 1;
LABEL_12:
          uint64_t v4 = 0;
          if (Count) {
            char v14 = v11;
          }
          else {
            char v14 = 1;
          }
          *a3 = v14;
        }
        else
        {
          uint64_t v10 = 0;
          char v11 = 1;
          while (1)
          {
            CFStringRef v12 = (const __CFString *)v3[v10];
            CFStringRef v13 = (const __CFString *)v7[v10];
            CFBooleanRef BOOLean = 0;
            if (_AMAuthInstallBundleGetValueForCondition(a1, v12, v13, &BOOLean)) {
              break;
            }
            v11 &= CFBooleanGetValue(BOOLean);
            if (Count == ++v10) {
              goto LABEL_12;
            }
          }
          uint64_t v4 = 1;
        }
        goto LABEL_16;
      }
    }
    else
    {
      CFStringRef v7 = 0;
    }
    uint64_t v4 = 2;
  }
LABEL_16:
  SafeFree(v3);
  SafeFree(v7);
  return v4;
}

uint64_t _AMAuthInstallBundleApplyActions(uint64_t a1, CFDictionaryRef theDict, __CFDictionary *a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 1;
  if (!a1 || !theDict)
  {
    CFStringRef v7 = 0;
    goto LABEL_11;
  }
  CFStringRef v7 = 0;
  if (a3)
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    uint64_t v3 = (const void **)malloc(8 * Count);
    if (v3)
    {
      CFStringRef v7 = (const void **)malloc(8 * Count);
      if (v7)
      {
        CFDictionaryGetKeysAndValues(theDict, v3, v7);
        if (Count < 1)
        {
LABEL_10:
          uint64_t v4 = 0;
        }
        else
        {
          uint64_t v10 = 0;
          while (1)
          {
            char v11 = v3[v10];
            CFStringRef v12 = (const __CFString *)v7[v10];
            CFDictionaryRef value = 0;
            if (_AMAuthInstallBundleGetValueForAction(a1, (uint64_t)v11, v12, (const __CFString **)&value)) {
              break;
            }
            CFDictionarySetValue(a3, v11, value);
            if (Count == ++v10) {
              goto LABEL_10;
            }
          }
          uint64_t v4 = 1;
        }
        goto LABEL_11;
      }
    }
    else
    {
      CFStringRef v7 = 0;
    }
    uint64_t v4 = 2;
  }
LABEL_11:
  SafeFree(v3);
  SafeFree(v7);
  return v4;
}

uint64_t AMAuthInstallBundleProcessRulesWithEntryDict(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t result = 1;
  if (a1 && theDict)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"Info");
    if (Value)
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(Value, @"RestoreRequestRules");
      if (result)
      {
        return AMAuthInstallBundleProcessRules(a1, (CFArrayRef)result, theDict);
      }
    }
    else
    {
      return 7;
    }
  }
  return result;
}

uint64_t AMAuthInstallBundleProcessRules(uint64_t a1, CFArrayRef theArray, __CFDictionary *a3)
{
  uint64_t v3 = 1;
  if (a1 && theArray && a3)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      CFIndex v8 = Count;
      CFIndex v9 = 0;
      uint64_t v10 = "failed to check conditions";
      while (1)
      {
        char v24 = 0;
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v9);
        if (!ValueAtIndex) {
          return 7;
        }
        CFDictionaryRef v12 = ValueAtIndex;
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, @"Conditions");
        if (Value)
        {
          uint64_t v14 = _AMAuthInstallBundleCheckCondition(a1, Value, &v24);
          if (v14)
          {
            uint64_t v3 = v14;
            goto LABEL_18;
          }
        }
        if (v24)
        {
          CFDictionaryRef v20 = (const __CFDictionary *)CFDictionaryGetValue(v12, @"Actions");
          if (v20)
          {
            uint64_t v21 = _AMAuthInstallBundleApplyActions(a1, v20, a3);
            if (v21) {
              break;
            }
          }
        }
        if (v8 == ++v9) {
          return 0;
        }
      }
      uint64_t v3 = v21;
      uint64_t v10 = "failed to apply actions";
LABEL_18:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleProcessRules", (uint64_t)v10, v15, v16, v17, v18, v19, v23);
    }
  }
  return v3;
}

uint64_t AMAuthInstallBundleCopyPersonalizedURLsMatchingType(void *a1, const void *a2, const __CFString *a3, __CFString *a4, CFTypeRef *a5)
{
  CFDictionaryRef value = 0;
  CFTypeID v5 = 0;
  CFPropertyListRef v55 = 0;
  CFDictionaryRef theDict = 0;
  uint64_t v6 = 1;
  if (!a4 || !a1 || !a2)
  {
    uint64_t v10 = 0;
    CFMutableDictionaryRef v11 = 0;
    goto LABEL_19;
  }
  uint64_t v10 = 0;
  CFMutableDictionaryRef v11 = 0;
  if (a5)
  {
    uint64_t v13 = AMAuthInstallBundleCopyBuildIdentityForVariant((uint64_t)a1, a2, a3, (CFTypeRef *)&theDict);
    if (v13)
    {
      uint64_t v6 = v13;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType", (uint64_t)"%s: failed to copy build identity", v14, v15, v16, v17, v18, (char)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType");
    }
    else
    {
      uint64_t v19 = AMAuthInstallBundleCopyReceiptCreateIfNecessary((uint64_t)a1, (const __CFURL *)a2, &v55);
      if (!v19)
      {
        CFDictionaryRef v25 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"Manifest");
        if (!v25)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType", (uint64_t)"%s: failed to get manifest entries", v26, v27, v28, v29, v30, (char)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType");
          CFTypeID v5 = 0;
          uint64_t v10 = 0;
          CFMutableDictionaryRef v11 = 0;
          uint64_t v6 = 8;
          goto LABEL_19;
        }
        CFDictionaryRef v31 = v25;
        CFAllocatorRef v32 = CFGetAllocator(a1);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v32, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (!Mutable)
        {
          CFTypeID v5 = 0;
          uint64_t v10 = 0;
          CFMutableDictionaryRef v11 = 0;
          uint64_t v6 = 2;
          goto LABEL_19;
        }
        CFStringRef v51 = a5;
        CFMutableDictionaryRef v52 = Mutable;
        CFIndex Count = CFDictionaryGetCount(v31);
        CFTypeID v5 = (const void **)malloc(8 * Count);
        uint64_t v10 = (const void **)malloc(8 * Count);
        CFDictionaryGetKeysAndValues(v31, v5, v10);
        if (Count < 1)
        {
LABEL_18:
          CFMutableDictionaryRef v11 = v52;
          uint64_t v6 = 0;
          *CFStringRef v51 = CFRetain(v52);
          goto LABEL_19;
        }
        uint64_t v35 = 0;
        while (1)
        {
          CFStringRef v36 = (const __CFString *)v5[v35];
          CFDictionaryRef v37 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v10[v35], @"Info");
          if (!v37)
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType", (uint64_t)"%s: failed to get info dict", v38, v39, v40, v41, v42, (char)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType");
            uint64_t v6 = 8;
            goto LABEL_22;
          }
          CFDictionaryRef v43 = v37;
          if (CFDictionaryGetValue(v37, a4) == kCFBooleanTrue
            || a4 == @"IsFirmwarePayload"
            && CFDictionaryGetValue(v43, @"IsSecondaryFirmwarePayload") == kCFBooleanTrue)
          {
            uint64_t v44 = AMAuthInstallBundleCopyURLForKey((CFDictionaryRef **)a1, v36, a3, (const __CFURL *)a2, &value);
            if (v44)
            {
              uint64_t v6 = v44;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType", (uint64_t)"failed to copy url for %@", v45, v46, v47, v48, v49, (char)v36);
LABEL_22:
              CFMutableDictionaryRef v11 = v52;
              goto LABEL_19;
            }
            CFDictionarySetValue(v52, v36, value);
            SafeRelease(value);
            CFDictionaryRef value = 0;
          }
          if (Count == ++v35) {
            goto LABEL_18;
          }
        }
      }
      uint64_t v6 = v19;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType", (uint64_t)"%s: failed to copy receipt", v20, v21, v22, v23, v24, (char)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType");
    }
    CFTypeID v5 = 0;
    uint64_t v10 = 0;
    CFMutableDictionaryRef v11 = 0;
  }
LABEL_19:
  SafeRelease(theDict);
  SafeRelease(v55);
  SafeFree(v5);
  SafeFree(v10);
  SafeRelease(value);
  SafeRelease(v11);
  return v6;
}

const void **AMAuthInstallBundleCopyPersonalizediBootFirmwareURLs(void *a1, const void *a2, const __CFString *a3, CFMutableDictionaryRef *a4)
{
  CFMutableDictionaryRef v19 = 0;
  CFDictionaryRef theDict = 0;
  uint64_t v8 = AMAuthInstallBundleCopyPersonalizedURLsMatchingType(a1, a2, a3, @"IsLoadedByiBoot", (CFTypeRef *)&v19);
  if (v8
    || (uint64_t v8 = AMAuthInstallBundleCopyPersonalizedURLsMatchingType(a1, a2, a3, @"IsLoadedByiBootStage1", (CFTypeRef *)&theDict), v8))
  {
    uint64_t v14 = (const void **)v8;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBundleCopyPersonalizediBootFirmwareURLs", (uint64_t)"AMAuthInstallBundleCopyPersonalizedURLsMatchingType failed %d", v9, v10, v11, v12, v13, v8);
  }
  else
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    uint64_t v14 = (const void **)malloc(8 * Count);
    CFDictionaryGetKeysAndValues(theDict, v14, 0);
    if (Count >= 1)
    {
      uint64_t v16 = v14;
      do
      {
        uint64_t v17 = *v16++;
        CFDictionaryRemoveValue(v19, v17);
        --Count;
      }
      while (Count);
      goto LABEL_9;
    }
    if (v14)
    {
LABEL_9:
      free(v14);
      uint64_t v14 = 0;
    }
  }
  *a4 = v19;
  return v14;
}

uint64_t AMAuthInstallBundleCopyPersonalizediBootEANFirmwareURLs(void *a1, const void *a2, const __CFString *a3, CFTypeRef *a4)
{
  return AMAuthInstallBundleCopyPersonalizedURLsMatchingType(a1, a2, a3, @"IsiBootEANFirmware", a4);
}

uint64_t AMAuthInstallBundleFDRSupported(uint64_t a1, const void *a2, const __CFString *a3, char *a4)
{
  CFTypeRef v22 = 0;
  if (a1)
  {
    uint64_t v5 = 1;
    if (a4)
    {
      if (a3)
      {
        if (a2)
        {
          uint64_t v7 = *(void *)(a1 + 128);
          if (v7)
          {
            CFDictionaryRef v8 = *(const __CFDictionary **)(v7 + 32);
            if (!v8)
            {
              uint64_t v9 = AMAuthInstallBundleCopyBuildIdentityForVariant(a1, a2, a3, &v22);
              if (v9)
              {
                uint64_t v5 = v9;
                goto LABEL_17;
              }
              CFDictionaryRef v8 = *(const __CFDictionary **)(*(void *)(a1 + 128) + 32);
            }
            CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v8, @"Info");
            if (Value && (CFBooleanRef v11 = (const __CFBoolean *)CFDictionaryGetValue(Value, @"FDRSupport")) != 0)
            {
              CFBooleanRef v12 = v11;
              CFTypeID v13 = CFGetTypeID(v11);
              if (v13 == CFBooleanGetTypeID() && CFBooleanGetValue(v12))
              {
                AMAuthInstallLog(6, (uint64_t)"AMAuthInstallBundleFDRSupported", (uint64_t)"FDR is supported for this device", v14, v15, v16, v17, v18, v21);
                char v19 = 1;
              }
              else
              {
                char v19 = 0;
              }
              uint64_t v5 = 0;
              *a4 = v19;
            }
            else
            {
              uint64_t v5 = 8;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
LABEL_17:
  SafeRelease(v22);
  return v5;
}

uint64_t sub_100022A08(CFDictionaryRef **a1, const void *a2, CFDictionaryRef theDict, const void *a4, const void *a5, int a6, int a7, void *a8)
{
  CFStringRef v8 = 0;
  CFURLRef anURL = 0;
  CFDictionaryRef value = 0;
  CFStringRef filePath = 0;
  CFStringRef v82 = 0;
  uint64_t v80 = 0;
  uint64_t v9 = 1;
  if (!a1 || !a2 || !a4 || !a5)
  {
    CFURLRef v14 = 0;
    uint64_t v15 = 0;
    goto LABEL_28;
  }
  CFURLRef v14 = 0;
  uint64_t v15 = 0;
  if (a8)
  {
    uint64_t v17 = a1[16];
    if (!v17 || !*v17) {
      goto LABEL_35;
    }
    CFDictionaryRef v20 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"Info");
    if (v20)
    {
      char v79 = a8;
      CFStringRef v26 = (const __CFString *)CFDictionaryGetValue(v20, @"Path");
      if (v26)
      {
        CFStringRef v32 = v26;
        if (a7)
        {
          CFAllocatorRef v33 = CFGetAllocator(a1);
          CFStringRef v34 = CFStringCreateWithFormat(v33, 0, @"RecoveryOS%@", a2);
          uint64_t v35 = (void *)CFDictionaryGetValue(*a1[16], v34);
          SafeRelease(v34);
        }
        else
        {
          uint64_t v35 = (void *)CFDictionaryGetValue(*a1[16], a2);
        }
        CFDictionaryRef value = v35;
        if (v35)
        {
          CFRetain(v35);
          AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallBundleCopyEntryURLs", (uint64_t)"using override: %@ = %@", v36, v37, v38, v39, v40, (char)a2);
        }
        else
        {
          CFAllocatorRef v41 = CFGetAllocator(a1);
          uint64_t v42 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v41, a4, v32, 0, (CFURLRef *)&value);
          if (v42) {
            goto LABEL_30;
          }
        }
        CFAllocatorRef v43 = CFGetAllocator(a1);
        uint64_t v44 = AMAuthInstallSupportCreatePrependedFilePath(v43, (uint64_t)a2, v32, &v82);
        if (v44)
        {
          uint64_t v9 = v44;
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyEntryURLs", (uint64_t)"could not prepend entryName to destination path : %@", v45, v46, v47, v48, v49, (char)v32);
          goto LABEL_35;
        }
        CFAllocatorRef v50 = CFGetAllocator(a1);
        uint64_t v42 = AMAuthInstallPlatformCopyURLWithAppendedComponent(v50, a5, v82, 0, &anURL);
        if (!v42)
        {
          if (!a6)
          {
            CFStringRef v8 = 0;
            CFURLRef v14 = 0;
            goto LABEL_25;
          }
          CFStringRef v8 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
          if (!v8)
          {
            AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyEntryURLs", (uint64_t)"could not copy path from %@", v55, v56, v57, v58, v59, (char)anURL);
            CFURLRef v14 = 0;
            goto LABEL_40;
          }
          uint64_t PersonalizedPathWithKey = AMAuthInstallBundleCreatePersonalizedPathWithKey(a1, 0, v8, (const __CFURL **)&filePath, v56, v57, v58, v59);
          if (!PersonalizedPathWithKey)
          {
            if (!filePath)
            {
              CFURLRef v14 = 0;
              uint64_t v15 = 0;
              uint64_t v9 = 14;
              goto LABEL_28;
            }
            CFAllocatorRef v61 = CFGetAllocator(a1);
            CFURLRef v14 = CFURLCreateWithFileSystemPath(v61, filePath, kCFURLPOSIXPathStyle, 0);
            if (v14)
            {
              SafeRelease(anURL);
              CFURLRef anURL = (CFURLRef)CFRetain(v14);
LABEL_25:
              uint64_t v62 = AMAuthInstallBundleCreatePersonalizedPathWithKey(a1, 0, v32, (const __CFURL **)&v80, v51, v52, v53, v54);
              if (!v62)
              {
                CFAllocatorRef v63 = CFGetAllocator(a1);
                CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v63, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                uint64_t v15 = Mutable;
                if (Mutable)
                {
                  CFDictionarySetValue(Mutable, @"SourceURL", value);
                  CFDictionarySetValue(v15, @"DestURL", anURL);
                  CFDictionarySetValue(v15, @"RelativeSrcPath", v32);
                  CFDictionarySetValue(v15, @"RelativeDestPath", v80);
                  CFTypeRef v65 = CFRetain(v15);
                  *char v79 = v65;
                  uint64_t v9 = 2 * (v65 == 0);
                  goto LABEL_28;
                }
LABEL_41:
                uint64_t v9 = 2;
                goto LABEL_28;
              }
              uint64_t v9 = v62;
LABEL_37:
              uint64_t v15 = 0;
              goto LABEL_28;
            }
LABEL_40:
            uint64_t v15 = 0;
            goto LABEL_41;
          }
          uint64_t v9 = PersonalizedPathWithKey;
          char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString(0, PersonalizedPathWithKey);
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyEntryURLs", (uint64_t)"failed to construct working URL: %@", v74, v75, v76, v77, v78, LocalizedStatusString);
LABEL_36:
          CFURLRef v14 = 0;
          goto LABEL_37;
        }
LABEL_30:
        uint64_t v9 = v42;
        char v67 = AMAuthInstallGetLocalizedStatusString(0, v42);
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyEntryURLs", (uint64_t)"failed to construct working URL: %@", v68, v69, v70, v71, v72, v67);
LABEL_35:
        CFStringRef v8 = 0;
        goto LABEL_36;
      }
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyEntryURLs", (uint64_t)"build manifest lacks relative path for \"%@\"", v27, v28, v29, v30, v31, (char)a2);
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundleCopyEntryURLs", (uint64_t)"build manifest lacks info for \"%@\"", v21, v22, v23, v24, v25, (char)a2);
    }
    CFStringRef v8 = 0;
    CFURLRef v14 = 0;
    uint64_t v15 = 0;
    uint64_t v9 = 7;
  }
LABEL_28:
  SafeRelease(value);
  SafeRelease(anURL);
  SafeRelease(v8);
  SafeRelease(filePath);
  SafeRelease(v14);
  SafeRelease(v80);
  SafeRelease(v15);
  SafeRelease(v82);
  return v9;
}

CFStringRef sub_100022E50(const __CFAllocator *a1, CFStringRef theString)
{
  if (!CFStringGetCString(theString, buffer, 256, 0x8000100u)) {
    return 0;
  }
  size_t v3 = strlen(buffer);
  if (v3)
  {
    do
    {
      size_t v4 = v3 - 1;
      BOOL v5 = buffer[v3 - 1] == 47 || v3 == 1;
      --v3;
    }
    while (!v5);
  }
  else
  {
    size_t v4 = 0;
  }
  buffer[v4] = 0;
  return CFStringCreateWithCString(a1, buffer, 0x8000100u);
}

uint64_t sub_100022F20(void *a1, CFDictionaryRef theDict, __CFDictionary *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v31 = "amai is NULL";
    goto LABEL_30;
  }
  uint64_t v9 = a1[2];
  if (v9)
  {
    if (theDict)
    {
      long long v66 = 0u;
      long long v67 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v53 = 0u;
      uint64_t v68 = 0;
      long long v52 = 0u;
      long long v51 = 0u;
      long long v50 = 0u;
      long long v49 = 0u;
      long long v48 = 0u;
      long long v47 = 0u;
      long long v46 = 0u;
      long long v45 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      CFStringRef v36 = @"UniqueBuildID";
      if (*(void *)(v9 + 120) || *(void *)(v9 + 128))
      {
        *(void *)&long long v37 = @"ProductMarketingVersion";
        unsigned int v12 = 2;
      }
      else
      {
        unsigned int v12 = 1;
      }
      CFTypeID v13 = (const void **)&v36;
      *(&v36 + v12) = @"Ap,InternalUseOnlyUnit";
      *(&v36 + v12 + 1) = @"Ap,EngineeringUseOnlyUnit";
      *(&v36 + v12 + 2) = @"Ap,InternalUseOnlySW";
      *(&v36 + v12 + 3) = @"Ap,RestoreSecurityOverrides0";
      *(&v36 + (v12 | 4)) = @"Ap,RestoreSecurityOverrides1";
      *(&v36 + v12 + 5) = @"Ap,RestoreSecurityOverrides2";
      *(&v36 + v12 + 6) = @"Ap,RestoreSecurityOverrides3";
      *(&v36 + v12 + 7) = @"Ap,OSLongVersion";
      *(&v36 + (v12 | 8)) = @"x86,OSLongVersion";
      *(&v36 + v12 + 9) = @"PearlCertificationRootPub";
      *(&v36 + v12 + 10) = @"Ap,OSEnvironment";
      *(&v36 + v12 + 11) = @"AllowNeRDBoot";
      *(&v36 + v12 + 13) = @"Ap,CurrentOSSecurityVersion";
      *(&v36 + v12 + 14) = @"Ap,MinimumOSSecurityVersion";
      *(&v36 + v12 + 15) = @"Ap,EphemeralDataMode";
      *(&v36 + (v12 | 0x10)) = @"Ap,EnableGroundhog";
      *(&v36 + v12 + 17) = @"Ap,TargetType";
      *(&v36 + v12 + 18) = @"Ap,ProductType";
      *(&v36 + v12 + 19) = @"Ap,SoftwareUpdateDeviceID";
      *(&v36 + (v12 | 0x14)) = @"Ap,SDKPlatform";
      *(&v36 + v12 + 21) = @"Ap,Target";
      *(&v36 + v12 + 22) = @"Ap,OSReleaseType";
      *(&v36 + v12 + 23) = @"Ap,UniqueTagList";
      *(&v36 + (v12 | 0x18)) = @"Ap,ProductMarketingVersion";
      uint64_t v14 = v12 + 25;
      *(&v36 + (v12 | 0xC)) = @"NeRDEpoch";
      do
      {
        uint64_t v15 = *v13;
        CFDictionaryRef Value = CFDictionaryGetValue(theDict, *v13);
        if (Value)
        {
          CFDictionaryAddValue(a3, v15, Value);
          AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallBundlePopulateManifestProperties", (uint64_t)"Copying manifest property %@ into request", v17, v18, v19, v20, v21, (char)v15);
        }
        ++v13;
        --v14;
      }
      while (v14);
      uint64_t v22 = CFDictionaryGetValue(theDict, @"Info");
      if (_CFDictionaryGetBoolean(v22, @"RequiresUIDMode", 0, v23, v24, v25, v26, v27))
      {
        if (*(void *)(a1[2] + 168)) {
          CFBooleanRef v28 = *(CFBooleanRef *)(a1[2] + 168);
        }
        else {
          CFBooleanRef v28 = kCFBooleanFalse;
        }
        CFDictionarySetValue(a3, @"UID_MODE", v28);
      }
      if (!CFDictionaryContainsKey(theDict, @"NeRDEpoch")) {
        goto LABEL_19;
      }
      CFAllocatorRef v29 = CFGetAllocator(a1);
      CFMutableDataRef Mutable = CFDataCreateMutable(v29, 0);
      if (Mutable)
      {
        CFDictionarySetValue(a3, @"PermitNeRDPivot", Mutable);
LABEL_19:
        uint64_t v31 = "Finished copying manifest entitlements.";
        uint64_t v32 = 6;
LABEL_20:
        AMAuthInstallLog(v32, (uint64_t)"_AMAuthInstallBundlePopulateManifestProperties", (uint64_t)v31, a4, a5, a6, a7, a8, v35);
        goto LABEL_21;
      }
      uint64_t v31 = "zeroData is NULL";
LABEL_30:
      uint64_t v32 = 3;
      goto LABEL_20;
    }
    CFStringRef v34 = "buildIdentity is NULL";
  }
  else
  {
    CFStringRef v34 = "amai->apParameters is NULL";
  }
  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallBundlePopulateManifestProperties", (uint64_t)v34, a4, a5, a6, a7, a8, v35);
LABEL_21:
  return AMSupportSafeRelease();
}

uint64_t AMAuthInstallCopyRsaKeyDataForKey()
{
  return 13;
}

uint64_t AMAuthInstallCryptoRegisterKeysFromPEMBuffer()
{
  return 13;
}

uint64_t AMAuthInstallCryptoRegisterKeysFromECCBuffer()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignature()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignature_SHA256()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignature_SHA384()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignatureWithSHA256()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateEcdsaSignatureWithSHA384()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateDigestForKey_SHA256()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateDigestForOnlyKeySha384()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateDigestForDataType(const __CFAllocator *a1, const __CFData *a2, CFTypeRef *a3, int a4)
{
  switch(a4)
  {
    case 384:
      return AMAuthInstallCryptoCreateDigestForData_SHA384(a1, a2, a3);
    case 256:
      return AMAuthInstallCryptoCreateDigestForData_SHA256(a1, a2, a3);
    case 1:
      return AMAuthInstallCryptoCreateDigestForData(a1, a2, a3);
  }
  return 1;
}

uint64_t AMAuthInstallCryptoCreateDigestForData(const __CFAllocator *a1, const __CFData *a2, CFTypeRef *a3)
{
  memset(&v12, 0, sizeof(v12));
  CFMutableDataRef Mutable = CFDataCreateMutable(a1, 20);
  uint64_t v6 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, 20);
    CC_SHA1_Init(&v12);
    BytePtr = CFDataGetBytePtr(a2);
    CC_LONG Length = CFDataGetLength(a2);
    CC_SHA1_Update(&v12, BytePtr, Length);
    MutableBytePtr = CFDataGetMutableBytePtr(v6);
    CC_SHA1_Final(MutableBytePtr, &v12);
    uint64_t v10 = 0;
    *a3 = CFRetain(v6);
  }
  else
  {
    uint64_t v10 = 2;
  }
  SafeRelease(v6);
  return v10;
}

uint64_t AMAuthInstallCryptoCreateDigestForData_SHA256(const __CFAllocator *a1, const __CFData *a2, CFTypeRef *a3)
{
  size_t v3 = 0;
  uint64_t v4 = 1;
  if (a2 && a3)
  {
    CFMutableDataRef Mutable = CFDataCreateMutable(a1, 32);
    size_t v3 = Mutable;
    if (Mutable)
    {
      CFDataSetLength(Mutable, 32);
      BytePtr = CFDataGetBytePtr(a2);
      CC_LONG Length = CFDataGetLength(a2);
      MutableBytePtr = CFDataGetMutableBytePtr(v3);
      CC_SHA256(BytePtr, Length, MutableBytePtr);
      uint64_t v4 = 0;
      *a3 = CFRetain(v3);
    }
    else
    {
      uint64_t v4 = 2;
    }
  }
  SafeRelease(v3);
  return v4;
}

uint64_t AMAuthInstallCryptoCreateDigestForData_SHA384(const __CFAllocator *a1, const __CFData *a2, CFTypeRef *a3)
{
  size_t v3 = 0;
  uint64_t v4 = 1;
  if (a2 && a3)
  {
    CFMutableDataRef Mutable = CFDataCreateMutable(a1, 48);
    size_t v3 = Mutable;
    if (Mutable)
    {
      CFDataSetLength(Mutable, 48);
      BytePtr = CFDataGetBytePtr(a2);
      CC_LONG Length = CFDataGetLength(a2);
      MutableBytePtr = CFDataGetMutableBytePtr(v3);
      CC_SHA384(BytePtr, Length, MutableBytePtr);
      uint64_t v4 = 0;
      *a3 = CFRetain(v3);
    }
    else
    {
      uint64_t v4 = 2;
    }
  }
  SafeRelease(v3);
  return v4;
}

uint64_t AMAuthInstallCryptoCreateSubjectPublicKeyInfoForKey()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateSubjectPublicKeyInfoForKeyFromHash()
{
  return 13;
}

uint64_t AMAuthInstallCryptoGetCertData()
{
  return 13;
}

uint64_t AMAuthInstallCryptoRegisterCertFromPEMBuffer()
{
  return 13;
}

uint64_t AMAuthInstallCryptoRegisterKeys()
{
  return 13;
}

uint64_t _AMAuthInstallFusingProgramCreateRequest(CFAllocatorRef allocator, const __CFURL *a2, CFDataRef XMLData, const __CFDictionary *cf, CFTypeRef *a5)
{
  if (cf)
  {
    CFDictionaryRef v9 = cf;
    CFRetain(cf);
  }
  else
  {
    CFDictionaryRef v9 = CFDictionaryCreate(allocator, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!v9)
    {
      CFBooleanRef v11 = 0;
LABEL_13:
      XMLData = 0;
      goto LABEL_14;
    }
  }
  if (!XMLData)
  {
    CFBooleanRef v11 = 0;
    Request = 0;
    CFStringRef v14 = 0;
    uint64_t v15 = 1;
    goto LABEL_9;
  }
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFBooleanRef v11 = Mutable;
  if (!Mutable) {
    goto LABEL_13;
  }
  CFDictionarySetValue(Mutable, @"Action", XMLData);
  CFDictionarySetValue(v11, @"Parameters", v9);
  XMLData = CFPropertyListCreateXMLData(allocator, v11);
  if (!XMLData)
  {
LABEL_14:
    Request = 0;
    CFStringRef v14 = 0;
    uint64_t v15 = 2;
    goto LABEL_9;
  }
  Request = CFHTTPMessageCreateRequest(allocator, @"POST", a2, kCFHTTPVersion1_1);
  if (Request)
  {
    CFIndex Length = CFDataGetLength(XMLData);
    CFStringRef v14 = CFStringCreateWithFormat(allocator, 0, @"%lu", Length);
    CFHTTPMessageSetHeaderFieldValue(Request, @"Content-Type", @"text/xml; charset=\"utf-8\"");
    CFHTTPMessageSetHeaderFieldValue(Request, @"Content-Length", v14);
    CFHTTPMessageSetBody(Request, XMLData);
    uint64_t v15 = 0;
    *a5 = CFRetain(Request);
  }
  else
  {
    uint64_t v15 = 0;
    CFStringRef v14 = 0;
  }
LABEL_9:
  SafeRelease(v11);
  SafeRelease(XMLData);
  SafeRelease(Request);
  SafeRelease(v9);
  SafeRelease(v14);
  SafeRelease(0);
  return v15;
}

uint64_t _AMAuthInstallFusingProgramCopyResponseParameters(const __CFAllocator *a1, const __CFData *a2, void *a3, CFTypeRef *a4, CFTypeRef *a5)
{
  CFStringRef errorString = 0;
  CFDictionaryRef v10 = (const __CFDictionary *)CFPropertyListCreateFromXMLData(a1, a2, 0, &errorString);
  CFDictionaryRef v16 = v10;
  if (errorString)
  {
    uint64_t v17 = 3;
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallFusingProgramCopyResponseParameters", (uint64_t)"CFPropertyListCreateFromXMLData() error: %@", v11, v12, v13, v14, v15, (char)errorString);
    CFTypeRef cf = 0;
    URLForTempDirectoryRoot = (const void *)AMAuthInstallSupportGetURLForTempDirectoryRoot();
    AMAuthInstallSupportCopyURLWithAppendedComponent(a1, URLForTempDirectoryRoot, @"badresponse.bin", 0, (CFURLRef *)&cf);
    AMAuthInstallSupportWriteDataToFileURL(a1, a2, (const __CFURL *)cf, 1);
    SafeRelease(cf);
    CFRelease(errorString);
    CFStringRef errorString = 0;
  }
  else if (v10)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v10, @"Status");
    if (Value)
    {
      CFNumberRef v20 = Value;
      uint64_t v21 = CFDictionaryGetValue(v16, @"Message");
      uint64_t v22 = CFDictionaryGetValue(v16, @"Data");
      if (CFNumberGetValue(v20, kCFNumberIntType, a3))
      {
        *a4 = SafeRetain(v21);
        uint64_t v17 = 0;
        *a5 = SafeRetain(v22);
      }
      else
      {
        uint64_t v17 = 3;
      }
    }
    else
    {
      uint64_t v17 = 17;
    }
  }
  else
  {
    char Length = CFDataGetLength(a2);
    uint64_t v17 = 3;
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallFusingProgramCopyResponseParameters", (uint64_t)"can't parse response (%u bytes of apparent garbage)", v25, v26, v27, v28, v29, Length);
  }
  SafeRelease(v16);
  SafeRelease(errorString);
  return v17;
}

uint64_t AMAuthInstallFusingProgramRequestInternal(const __CFAllocator *a1, const __CFURL *a2, const void *a3, CFTypeRef *a4, const __CFDictionary *a5)
{
  CFTypeRef v5 = 0;
  CFTypeRef v59 = 0;
  uint64_t valuePtr = 0;
  CFTypeRef v57 = 0;
  CFTypeRef v58 = 0;
  uint64_t v6 = 1;
  CFStringRef errorString = 0;
  if (!a2 || !a3)
  {
    CFTypeRef v9 = 0;
    CFDictionaryRef v10 = 0;
    CFDataRef v11 = 0;
    goto LABEL_20;
  }
  CFTypeRef v9 = 0;
  CFDictionaryRef v10 = 0;
  CFDataRef v11 = 0;
  if (a4)
  {
    CFMutableDataRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryRef v10 = Mutable;
    if (Mutable)
    {
      CFDictionarySetValue(Mutable, @"ProfileSpecifier", a3);
      uint64_t v16 = _AMAuthInstallFusingProgramCreateRequest(a1, a2, (CFDataRef)@"GetFusingProgram", v10, &v59);
      if (v16)
      {
        uint64_t v6 = v16;
        CFTypeRef v5 = 0;
        CFDataRef v11 = 0;
        CFTypeRef v9 = v59;
        goto LABEL_20;
      }
      AMAuthInstallLog(6, (uint64_t)"AMAuthInstallFusingProgramRequestInternal", (uint64_t)"requesting fusing program from %@", v17, v18, v19, v20, v21, (char)a2);
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a3, @"ChipID");
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
      AMAuthInstallLog(6, (uint64_t)"AMAuthInstallFusingProgramRequestInternal", (uint64_t)"Chiup ID: %u", v23, v24, v25, v26, v27, valuePtr);
      CFDataRef v11 = CFDataCreateMutable(a1, 0);
      CFTypeRef v9 = v59;
      if (v11)
      {
        char v33 = AMAuthInstallHttpMessageSendSync(v59, v11, a5, v28, v29, v30, v31, v32);
        if ((int)valuePtr > 1700064)
        {
          if (valuePtr == 1700065 || valuePtr == 2814177) {
            goto LABEL_15;
          }
          int v34 = 2089185;
        }
        else
        {
          if (valuePtr == 938209 || valuePtr == 1327329) {
            goto LABEL_15;
          }
          int v34 = 1515745;
        }
        if (valuePtr != v34)
        {
          uint64_t v54 = _AMAuthInstallFusingProgramCopyResponseParameters(a1, v11, (char *)&valuePtr + 4, &v58, &v57);
          if (v54)
          {
            uint64_t v6 = v54;
            CFTypeRef v5 = v58;
            goto LABEL_20;
          }
          if (HIDWORD(valuePtr))
          {
            CFTypeRef v5 = v58;
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallFusingProgramRequestInternal", (uint64_t)"server error: %@ (%d)", v36, v37, v38, v39, v40, (char)v58);
            uint64_t v6 = 99;
            goto LABEL_20;
          }
          CFTypeRef v41 = v57;
          CFTypeRef v5 = v58;
          goto LABEL_17;
        }
LABEL_15:
        CFPropertyListRef v35 = CFPropertyListCreateFromXMLData(a1, v11, 0, &errorString);
        CFTypeRef v57 = v35;
        if (errorString)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallFusingProgramRequestInternal", (uint64_t)"Failed to get fusing response data from CFPropertyListCreateFromXMLData() error: %@", v36, v37, v38, v39, v40, (char)errorString);
          CFTypeRef v5 = 0;
          goto LABEL_32;
        }
        CFTypeRef v41 = v35;
        CFTypeRef v5 = 0;
LABEL_17:
        AMAuthInstallLog(6, (uint64_t)"AMAuthInstallFusingProgramRequestInternal", (uint64_t)"httpStatus=%u, status=%d, message=%@", v36, v37, v38, v39, v40, v33);
        if (v41)
        {
          CFTypeID v47 = CFGetTypeID(v41);
          if (v47 == CFDictionaryGetTypeID())
          {
            AMAuthInstallLog(6, (uint64_t)"AMAuthInstallFusingProgramRequestInternal", (uint64_t)"data=%@", v48, v49, v50, v51, v52, (char)v41);
            uint64_t v6 = 0;
            *a4 = CFRetain(v41);
          }
          else
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallFusingProgramRequestInternal", (uint64_t)"fusing program type mismatch", v48, v49, v50, v51, v52, v55);
            uint64_t v6 = 17;
          }
          goto LABEL_20;
        }
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallFusingProgramRequestInternal", (uint64_t)"server failed to provide a fusing program", v42, v43, v44, v45, v46, v55);
LABEL_32:
        uint64_t v6 = 14;
        goto LABEL_20;
      }
      CFTypeRef v5 = 0;
    }
    else
    {
      CFTypeRef v5 = 0;
      CFTypeRef v9 = 0;
      CFDataRef v11 = 0;
    }
    uint64_t v6 = 2;
  }
LABEL_20:
  SafeRelease(v10);
  SafeRelease(v9);
  SafeRelease(v11);
  SafeRelease(v5);
  SafeRelease(v57);
  return v6;
}

CFTypeRef AMAuthInstallFusingCreateProfileName(__CFString *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v8 = cf;
  v27.CFIndex location = 0;
  v27.CFIndex length = 0;
  *(_OWORD *)values = *(_OWORD *)off_10009DA88;
  if (!cf)
  {
    CFDictionaryRef v10 = 0;
LABEL_43:
    CFArrayRef v15 = 0;
    goto LABEL_44;
  }
  if (!cf[5].info)
  {
    uint64_t v26 = "no fusing profile specified";
LABEL_41:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallFusingCreateProfileName", (uint64_t)v26, a4, a5, a6, a7, a8, v27.location);
    CFDictionaryRef v10 = 0;
LABEL_42:
    CFStringRef v8 = 0;
    goto LABEL_43;
  }
  CFDataRef data = cf->data;
  if (!data)
  {
    uint64_t v26 = "ap parameters are not set";
    goto LABEL_41;
  }
  CFDictionaryRef v10 = 0;
  int v11 = *((_DWORD *)cf[1].data + 1);
  if (v11 <= 1700064)
  {
    if (v11 <= 938208)
    {
      BOOL v12 = v11 == 241889;
      int v13 = 520417;
    }
    else
    {
      BOOL v12 = v11 == 938209 || v11 == 1327329;
      int v13 = 1515745;
    }
  }
  else if (v11 > 8343776)
  {
    BOOL v12 = v11 == 8343777 || v11 == 9781473;
    int v13 = 9572577;
  }
  else
  {
    BOOL v12 = v11 == 1700065 || v11 == 2089185;
    int v13 = 2814177;
  }
  BOOL v14 = v12 || v11 == v13;
  CFArrayRef v15 = 0;
  if (!v14) {
    goto LABEL_34;
  }
  if (!*((void *)data + 13))
  {
    AMAuthInstallLog(4, (uint64_t)"AMAuthInstallFusingCreateProfileName", (uint64_t)"hardware model is not set, fusing profile name will not be updated.", a4, a5, a6, a7, a8, v27.location);
    CFDictionaryRef v10 = 0;
    CFArrayRef v15 = 0;
    goto LABEL_34;
  }
  CFAllocatorRef v16 = CFGetAllocator(cf);
  CFDictionaryRef MutableCopy = CFStringCreateMutableCopy(v16, 0, *((CFStringRef *)v8->data + 13));
  CFDictionaryRef v10 = MutableCopy;
  if (!MutableCopy) {
    goto LABEL_42;
  }
  CFStringLowercase(MutableCopy, 0);
  CFAllocatorRef v18 = CFGetAllocator(v8);
  CFArrayRef v19 = CFArrayCreate(v18, (const void **)values, 2, &kCFTypeArrayCallBacks);
  CFArrayRef v15 = v19;
  if (!v19)
  {
    CFStringRef v8 = 0;
    goto LABEL_44;
  }
  if (CFArrayGetCount(v19) >= 1)
  {
    CFIndex v20 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v15, v20);
      v29.CFIndex length = CFStringGetLength(v10);
      v29.CFIndex location = 0;
      if (CFStringFindWithOptions(v10, ValueAtIndex, v29, 4uLL, &v27)) {
        break;
      }
      if (++v20 >= CFArrayGetCount(v15)) {
        goto LABEL_34;
      }
    }
    CFStringDelete(v10, v27);
    CFAllocatorRef v24 = CFGetAllocator(v8);
    uint64_t v25 = CFStringCreateMutableCopy(v24, 0, (CFStringRef)v8[5].info);
    CFStringRef v8 = v25;
    if (v25)
    {
      CFStringAppend(v25, @"-");
      CFStringAppend(v8, v10);
      CFTypeRef v22 = CFRetain(v8);
      goto LABEL_35;
    }
LABEL_44:
    CFTypeRef v22 = 0;
    goto LABEL_35;
  }
LABEL_34:
  CFTypeRef v22 = CFRetain((CFTypeRef)v8[5].info);
  CFStringRef v8 = 0;
LABEL_35:
  SafeRelease(v10);
  SafeRelease(v8);
  SafeRelease(v15);
  return v22;
}

uint64_t AMAuthInstallFusingProgramRequest(void *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t valuePtr = 0;
  int v43 = 0;
  if (!cf) {
    goto LABEL_28;
  }
  if (!*((void *)cf + 20))
  {
    CFTypeRef v41 = "no fusing server specified";
LABEL_27:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallFusingProgramRequest", (uint64_t)v41, a4, a5, a6, a7, a8, v42);
LABEL_28:
    CFMutableDataRef Mutable = 0;
    CFNumberRef v19 = 0;
    CFNumberRef v20 = 0;
    CFNumberRef v21 = 0;
    CFTypeRef ProfileName = 0;
    uint64_t v17 = 1;
    goto LABEL_24;
  }
  if (!*((void *)cf + 21))
  {
    CFTypeRef v41 = "no fusing profile specified";
    goto LABEL_27;
  }
  CFTypeRef v9 = (int *)*((void *)cf + 6);
  int v10 = *v9;
  LODWORD(valuePtr) = v9[1];
  HIDWORD(valuePtr) = v10;
  int v43 = v9[24];
  CFTypeRef ProfileName = AMAuthInstallFusingCreateProfileName((__CFString *)cf, a2, a3, a4, a5, a6, a7, a8);
  if (!ProfileName)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallFusingProgramRequest", (uint64_t)"failed to create fusing profile name", v11, v12, v13, v14, v15, v42);
    CFMutableDataRef Mutable = 0;
    CFNumberRef v19 = 0;
    CFNumberRef v20 = 0;
    CFNumberRef v21 = 0;
LABEL_36:
    uint64_t v17 = 99;
    goto LABEL_24;
  }
  if (*((void *)cf + 22))
  {
    AMAuthInstallLog(6, (uint64_t)"AMAuthInstallFusingProgramRequest", (uint64_t)"fusing program already exists", v11, v12, v13, v14, v15, v42);
    uint64_t v17 = 0;
    CFMutableDataRef Mutable = 0;
    CFNumberRef v19 = 0;
    CFNumberRef v20 = 0;
    CFNumberRef v21 = 0;
    CFTypeRef ProfileName = 0;
    goto LABEL_24;
  }
  CFAllocatorRef v22 = CFGetAllocator(cf);
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(v22, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFNumberRef v19 = 0;
    goto LABEL_31;
  }
  CFAllocatorRef v23 = CFGetAllocator(cf);
  CFNumberRef v19 = CFNumberCreate(v23, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  if (!v19)
  {
LABEL_31:
    CFNumberRef v20 = 0;
    goto LABEL_32;
  }
  CFAllocatorRef v24 = CFGetAllocator(cf);
  CFNumberRef v20 = CFNumberCreate(v24, kCFNumberSInt32Type, &valuePtr);
  if (!v20)
  {
LABEL_32:
    CFNumberRef v21 = 0;
    goto LABEL_33;
  }
  CFAllocatorRef v25 = CFGetAllocator(cf);
  CFNumberRef v21 = CFNumberCreate(v25, kCFNumberSInt32Type, &v43);
  if (!v21)
  {
LABEL_33:
    CFTypeRef ProfileName = 0;
    uint64_t v17 = 2;
    goto LABEL_24;
  }
  CFDictionarySetValue(Mutable, @"VendorID", v19);
  CFDictionarySetValue(Mutable, @"ChipID", v20);
  CFDictionarySetValue(Mutable, @"ProfileName", ProfileName);
  CFDictionarySetValue(Mutable, @"FusingStatus", v21);
  CFTypeRef ProfileName = 0;
  if ((int)valuePtr > 1700064)
  {
    if (valuePtr == 1700065 || valuePtr == 2814177) {
      goto LABEL_19;
    }
    int v31 = 2089185;
  }
  else
  {
    if (valuePtr == 938209 || valuePtr == 1327329) {
      goto LABEL_19;
    }
    int v31 = 1515745;
  }
  if (valuePtr != v31) {
    goto LABEL_22;
  }
LABEL_19:
  if (!*((void *)cf + 24))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallFusingProgramRequest", (uint64_t)"Failed to get fusing server root CA!", v26, v27, v28, v29, v30, v42);
    CFTypeRef ProfileName = 0;
    goto LABEL_36;
  }
  CFAllocatorRef v32 = CFGetAllocator(cf);
  char v33 = CFDictionaryCreateMutable(v32, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFTypeRef ProfileName = v33;
  if (!v33)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallFusingProgramRequest", (uint64_t)"Failed to create option Dictionary for SSL connection!", v34, v35, v36, v37, v38, v42);
    goto LABEL_36;
  }
  CFDictionarySetValue(v33, kAMSupportHttpOptionTrustedServerCAs, *((const void **)cf + 24));
LABEL_22:
  CFAllocatorRef v39 = CFGetAllocator(cf);
  uint64_t v17 = AMAuthInstallFusingProgramRequestInternal(v39, *((const __CFURL **)cf + 20), Mutable, (CFTypeRef *)cf + 22, (const __CFDictionary *)ProfileName);
  if (!v17) {
    AMAuthInstallDebugWriteObject((char *)cf, *((CFTypeRef *)cf + 22), @"fusingprogram", 2);
  }
LABEL_24:
  SafeRelease(Mutable);
  SafeRelease(v19);
  SafeRelease(v20);
  SafeRelease(v21);
  SafeRelease(ProfileName);
  return v17;
}

uint64_t AMAuthInstallHttpUriEscapeString(const __CFAllocator *a1, CFStringRef theString, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!theString)
  {
    CFNumberRef v20 = "value == NULL";
LABEL_10:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpUriEscapeString", (uint64_t)v20, a4, a5, a6, a7, a8, v21);
    CFMutableStringRef MutableCopy = 0;
    uint64_t v18 = 1;
    goto LABEL_7;
  }
  if (!a3)
  {
    CFNumberRef v20 = "outEscapedValue == NULL";
    goto LABEL_10;
  }
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(a1, 0, theString);
  if (MutableCopy)
  {
    for (uint64_t i = 0; i != 66; i += 2)
    {
      CFStringRef v16 = off_10009DA98[i];
      CFStringRef v17 = off_10009DA98[i + 1];
      v22.CFIndex length = CFStringGetLength(MutableCopy);
      v22.CFIndex location = 0;
      CFStringFindAndReplace(MutableCopy, v16, v17, v22, 0);
    }
    uint64_t v18 = 0;
    *a3 = CFRetain(MutableCopy);
  }
  else
  {
    uint64_t v18 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpUriEscapeString", (uint64_t)"escapedValue == NULL", v9, v10, v11, v12, v13, v21);
  }
LABEL_7:
  SafeRelease(MutableCopy);
  return v18;
}

uint64_t AMAuthInstallHttpCreatePostBody(const __CFAllocator *a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  CFDataRef v3 = 0;
  uint64_t v4 = 1;
  if (!a2)
  {
    CFMutableStringRef Mutable = 0;
    uint64_t v7 = 0;
    CFStringRef v8 = 0;
    uint64_t v9 = 0;
    goto LABEL_17;
  }
  CFMutableStringRef Mutable = 0;
  uint64_t v7 = 0;
  CFStringRef v8 = 0;
  uint64_t v9 = 0;
  if (a3)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(a1, 0);
    if (Mutable)
    {
      CFIndex Count = CFDictionaryGetCount(a2);
      uint64_t v7 = (const void **)malloc(8 * Count);
      uint64_t v13 = (const void **)malloc(8 * Count);
      CFStringRef v8 = v13;
      if (v7)
      {
        if (v13)
        {
          CFDictionaryGetKeysAndValues(a2, v7, v13);
          if (Count >= 1)
          {
            CFIndex v24 = 0;
            while (1)
            {
              CFStringRef v25 = (const __CFString *)v7[v24];
              if (!v25)
              {
                uint64_t v44 = "invalid requestDictKeysBuffer array";
                goto LABEL_20;
              }
              if (!v8[v24]) {
                break;
              }
              CFStringAppend(Mutable, v25);
              CFStringAppend(Mutable, @"=");
              CFStringAppend(Mutable, (CFStringRef)v8[v24]);
              if (v24 < Count - 1) {
                CFStringAppend(Mutable, @"&");
              }
              if (Count == ++v24) {
                goto LABEL_13;
              }
            }
            uint64_t v44 = "invalid requestDictValuesBuffer array";
LABEL_20:
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreatePostBody", (uint64_t)v44, v19, v20, v21, v22, v23, v46);
            CFDataRef v3 = 0;
            uint64_t v9 = 0;
            uint64_t v4 = 14;
            goto LABEL_17;
          }
LABEL_13:
          AMAuthInstallLog(7, (uint64_t)"AMAuthInstallHttpCreatePostBody", (uint64_t)"postString=%@", v19, v20, v21, v22, v23, (char)Mutable);
          CFIndex Length = CFStringGetLength(Mutable);
          uint64_t v9 = (char *)malloc(Length + 1);
          if (v9)
          {
            if (!CFStringGetCString(Mutable, v9, Length + 1, 0x8000100u))
            {
              uint64_t v4 = 3;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreatePostBody", (uint64_t)"conversion of postString to c-string failed", v32, v33, v34, v35, v36, v47);
              CFDataRef v3 = 0;
              goto LABEL_17;
            }
            CFDataRef v37 = CFDataCreate(a1, (const UInt8 *)v9, Length);
            CFDataRef v3 = v37;
            if (v37)
            {
              uint64_t v4 = 0;
              *a3 = CFRetain(v37);
              goto LABEL_17;
            }
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreatePostBody", (uint64_t)"postData allocation failed", v38, v39, v40, v41, v42, v47);
          }
          else
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreatePostBody", (uint64_t)"tmpStringBuffer allocation failure", v27, v28, v29, v30, v31, v47);
            CFDataRef v3 = 0;
          }
LABEL_30:
          uint64_t v4 = 2;
          goto LABEL_17;
        }
        uint64_t v45 = "requestDictValuesBuffer allocation failed";
      }
      else
      {
        uint64_t v45 = "requestDictKeysBuffer allocation failed";
      }
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreatePostBody", (uint64_t)v45, v14, v15, v16, v17, v18, v46);
      CFDataRef v3 = 0;
    }
    else
    {
      CFDataRef v3 = 0;
      uint64_t v7 = 0;
      CFStringRef v8 = 0;
    }
    uint64_t v9 = 0;
    goto LABEL_30;
  }
LABEL_17:
  SafeRelease(Mutable);
  SafeRelease(v3);
  SafeFree(v7);
  SafeFree(v8);
  SafeFree(v9);
  return v4;
}

uint64_t AMAuthInstallHttpSetUriEscapedValue(const __CFAllocator *a1, __CFDictionary *a2, const void *a3, CFStringRef theString, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef value = 0;
  uint64_t v8 = 1;
  if (a2 && a3 && theString)
  {
    uint64_t v11 = AMAuthInstallHttpUriEscapeString(a1, theString, (CFTypeRef *)&value, (uint64_t)theString, a5, a6, a7, a8);
    if (v11)
    {
      uint64_t v8 = v11;
      uint64_t v18 = "AMAuthInstallHttpUriEscapeString failed";
    }
    else
    {
      if (value)
      {
        CFDictionarySetValue(a2, a3, value);
        uint64_t v8 = 0;
        goto LABEL_7;
      }
      uint64_t v18 = "escapedValue is NULL";
      uint64_t v8 = 3;
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpSetUriEscapedValue", (uint64_t)v18, v12, v13, v14, v15, v16, v19);
  }
LABEL_7:
  SafeRelease(value);
  return v8;
}

uint64_t AMAuthInstallHttpCreatePostRequest(const __CFAllocator *a1, const __CFURL *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  Request = 0;
  CFDataRef theData = 0;
  uint64_t v5 = 1;
  if (!a2 || !a3)
  {
    CFStringRef v7 = 0;
    goto LABEL_8;
  }
  CFStringRef v7 = 0;
  if (a4)
  {
    uint64_t PostBody = AMAuthInstallHttpCreatePostBody(a1, a3, (CFTypeRef *)&theData);
    if (PostBody)
    {
      uint64_t v5 = PostBody;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreatePostRequest", (uint64_t)"AMAuthInstallHttpCreatePostBody failed", v11, v12, v13, v14, v15, v18);
      Request = 0;
    }
    else
    {
      if (!theData)
      {
        Request = 0;
        CFStringRef v7 = 0;
        uint64_t v5 = 2;
        goto LABEL_8;
      }
      Request = CFHTTPMessageCreateRequest(a1, @"POST", a2, kCFHTTPVersion1_1);
      if (Request)
      {
        CFIndex Length = CFDataGetLength(theData);
        CFStringRef v7 = CFStringCreateWithFormat(a1, 0, @"%ld", Length);
        CFHTTPMessageSetHeaderFieldValue(Request, @"Content-Type", @"text/xml; charset=\"utf-8\"");
        CFHTTPMessageSetHeaderFieldValue(Request, @"Content-Length", v7);
        CFHTTPMessageSetBody(Request, theData);
        uint64_t v5 = 0;
        *a4 = CFRetain(Request);
        goto LABEL_8;
      }
      uint64_t v5 = 0;
    }
    CFStringRef v7 = 0;
  }
LABEL_8:
  SafeRelease(theData);
  SafeRelease(Request);
  SafeRelease(v7);
  SafeRelease(0);
  return v5;
}

uint64_t AMAuthInstallHttpSetBase64EncodedValue(const __CFAllocator *a1, __CFDictionary *a2, const void *a3, CFDataRef theData, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef theString = 0;
  uint64_t v8 = 1;
  if (a2 && a3 && theData)
  {
    uint64_t v12 = AMAuthInstallSupportBase64Encode(a1, theData, (CFTypeRef *)&theString, (uint64_t)theData, a5, a6, a7, a8);
    if (v12)
    {
      uint64_t v8 = v12;
      char v19 = "Base64Encode failed";
    }
    else
    {
      CFStringRef v13 = theString;
      if (theString)
      {
        uint64_t v8 = AMAuthInstallHttpSetUriEscapedValue(a1, a2, a3, theString, v14, v15, v16, v17);
        goto LABEL_7;
      }
      char v19 = "encodedValue is NULL";
      uint64_t v8 = 3;
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpSetBase64EncodedValue", (uint64_t)v19, (uint64_t)v13, v14, v15, v16, v17, v20);
  }
LABEL_7:
  SafeRelease(theString);
  return v8;
}

uint64_t AMAuthInstallHttpMessageSendSync(const void *a1, const __CFData *a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallHttpMessageSendSync", (uint64_t)"httpRequest=%@", a4, a5, a6, a7, a8, (char)a1);
  unsigned int v23 = 10002;
  CFDataRef theData = 0;
  CFAllocatorRef v11 = CFGetAllocator(a1);
  int v12 = AMAuthInstallHttpMessageSendSyncNew(v11, (int)a1, (int)&theData, (int)&v23, a3, 60.0);
  if (v12)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpMessageSendSync", (uint64_t)"AMAuthInstallHttpMessageSendSyncNew() failed: %d", v13, v14, v15, v16, v17, v12);
  }
  else if (a2)
  {
    CFIndex Length = CFDataGetLength(a2);
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex v20 = CFDataGetLength(theData);
    v24.CFIndex location = 0;
    v24.CFIndex length = Length;
    CFDataReplaceBytes(a2, v24, BytePtr, v20);
  }
  return v23;
}

uint64_t AMAuthInstallHttpMessageSendSyncNew(CFAllocatorRef allocator, int a2, int a3, int a4, CFDictionaryRef theDict, double a6)
{
  double valuePtr = a6;
  if (theDict)
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(allocator, Count, theDict);
    if (CFDictionaryContainsKey(MutableCopy, kAMSupportHttpOptionSocksProxySettings)) {
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"Options dictionary contains proxy information. Will attempt to use a proxy.", v10, v11, v12, v13, v14, v33);
    }
    if (CFDictionaryContainsKey(MutableCopy, kAMSupportHttpOptionTrustedServerCAs)) {
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"Options dictionary contains trusted server CAs. Will authenticate SSL against CAs.", v15, v16, v17, v18, v19, v33);
    }
  }
  else
  {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  if (!MutableCopy)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"CFDictionaryCreateMutable failed to allocate", v15, v16, v17, v18, v19, v33);
LABEL_13:
    uint64_t v32 = 2;
    goto LABEL_10;
  }
  CFNumberRef v25 = CFNumberCreate(allocator, kCFNumberDoubleType, &valuePtr);
  if (!v25)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"timeout failed to allocate", v20, v21, v22, v23, v24, v33);
    goto LABEL_13;
  }
  CFDictionarySetValue(MutableCopy, kAMSupportHttpOptionTimeout, v25);
  AMSupportHttpSendSync();
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"HTTP request provided no response data", v27, v28, v29, v30, v31, v33);
  uint64_t v32 = 16;
LABEL_10:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v32;
}

uint64_t AMAuthInstallHttpRequestManagedBaaCertificate(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0;
  uint64_t BaaCertificateData = AMAuthInstallHttpCreateBaaCertificateData(a1, 0, a2, (uint64_t)&cf, a5, a6, a7, a8);
  if (!BaaCertificateData)
  {
    CFTypeRef v10 = cf;
    if (cf)
    {
      if (*(void *)(a1[2] + 120))
      {
        CFRelease(*(CFTypeRef *)(a1[2] + 120));
        *(void *)(a1[2] + 120) = 0;
        CFTypeRef v10 = cf;
      }
      *(void *)(a1[2] + 120) = CFRetain(v10);
    }
  }
  return BaaCertificateData;
}

uint64_t AMAuthInstallHttpCreateBaaCertificateData(void *a1, const __CFDictionary *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDataRef theData = 0;
  uint64_t v91 = 0;
  int v89 = -1;
  CFIndex v87 = 0;
  CFArrayRef v88 = 0;
  if (!a1)
  {
    uint64_t v76 = "amai is NULL";
LABEL_44:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)v76, a4, a5, a6, a7, a8, v79);
    uint64_t v11 = 0;
    id v12 = 0;
    uint64_t v13 = 0;
    CFURLRef v14 = 0;
    uint64_t v15 = 1;
    goto LABEL_40;
  }
  uint64_t v9 = a1[2];
  if (!v9)
  {
    uint64_t v76 = "amai->apParameters is NULL";
    goto LABEL_44;
  }
  uint64_t v10 = *(void *)(v9 + 48);
  if (!v10)
  {
    uint64_t v76 = "amai->apParameters->sepNonce is required for BAA request.";
    goto LABEL_44;
  }
  if (!&_DeviceIdentityCreateClientCertificateRequest)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)"DeviceIdentityCreateClientCertificateRequest is not available", a4, a5, a6, a7, a8, v79);
    uint64_t v11 = 0;
    id v12 = 0;
    uint64_t v13 = 0;
    CFURLRef v14 = 0;
    uint64_t v15 = 13;
    goto LABEL_40;
  }
  v94[0] = kMAOptionsBAANonce;
  v94[1] = kMAOptionsBAASCRTAttestation;
  v95[0] = v10;
  v95[1] = &off_1000AE898;
  v94[2] = kMAOptionsBAAOIDSToInclude;
  v93[0] = kMAOptionsBAAOIDNonce;
  v93[1] = kMAOptionsBAAOIDDeviceIdentifiers;
  v93[2] = kMAOptionsBAAOIDKeyUsageProperties;
  v93[3] = kMAOptionsBAAOIDDeviceOSInformation;
  uint64_t v19 = +[NSArray arrayWithObjects:v93 count:4];
  v95[2] = v19;
  uint64_t v13 = +[NSDictionary dictionaryWithObjects:v95 forKeys:v94 count:3];

  id v86 = 0;
  id v12 = (id)DeviceIdentityCreateClientCertificateRequest();
  id v20 = 0;
  uint64_t v11 = v20;
  if (v20)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)"Error creating baa request : %@", v21, v22, v23, v24, v25, (char)v20);
    if (a3) {
      *a3 = v11;
    }
    uint64_t v15 = 6;
  }
  else
  {
    uint64_t v15 = 1;
  }
  if (!v91)
  {
    uint64_t v77 = "refKey is NULL";
LABEL_47:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)v77, v21, v22, v23, v24, v25, v79);
    CFURLRef v14 = 0;
    goto LABEL_40;
  }
  if (!v12)
  {
    uint64_t v77 = "request is NULL";
    goto LABEL_47;
  }
  if (a2)
  {
    CFNumberRef Value = CFDictionaryGetValue(a2, @"userAgentStringOverride");
    if (Value)
    {
      uint64_t v27 = Value;
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        [v12 setValue:v27 forHTTPHeaderField:@"User-Agent"];
      }
    }
  }
  if (AMAuthInstallPreferencesCopyStringValue(0, @"BAAOverrideURL"))
  {
    CFGetAllocator(a1);
    CFURLRef URLFromString = (const __CFURL *)AMSupportCreateURLFromString();
  }
  else
  {
    CFURLRef URLFromString = (const __CFURL *)[v12 URL];
  }
  CFURLRef v14 = URLFromString;
  if (!URLFromString)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)"serverURL is NULL", v29, v30, v31, v32, v33, v79);
    goto LABEL_40;
  }
  CFHTTPMessageRef Request = CFHTTPMessageCreateRequest(0, (CFStringRef)[v12 HTTPMethod], URLFromString, kCFHTTPVersion1_1);
  if (!Request)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)"message is NULL", v35, v36, v37, v38, v39, v79);
    CFURLRef v14 = 0;
LABEL_60:
    uint64_t v15 = 2;
    goto LABEL_40;
  }
  uint64_t v40 = Request;
  uint64_t v80 = (void *)a4;
  CFAllocatorRef v81 = v11;
  uint64_t v41 = v13;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  CFURLRef v14 = (const __CFURL *)[v12 allHTTPHeaderFields];
  id v42 = [(__CFURL *)v14 countByEnumeratingWithState:&v82 objects:v92 count:16];
  if (v42)
  {
    id v43 = v42;
    uint64_t v44 = *(void *)v83;
    do
    {
      for (uint64_t i = 0; i != v43; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v83 != v44) {
          objc_enumerationMutation(v14);
        }
        CFStringRef v46 = *(const __CFString **)(*((void *)&v82 + 1) + 8 * i);
        char v47 = (__CFString *)[(__CFURL *)v14 objectForKeyedSubscript:v46];
        CFHTTPMessageSetHeaderFieldValue(v40, v46, v47);
      }
      id v43 = [(__CFURL *)v14 countByEnumeratingWithState:&v82 objects:v92 count:16];
    }
    while (v43);
  }

  id v48 = [v12 HTTPBody];
  if (v48) {
    CFHTTPMessageSetBody(v40, (CFDataRef)[v12 HTTPBody]);
  }
  CFAllocatorRef v49 = CFGetAllocator(a1);
  uint64_t v50 = AMAuthInstallHttpMessageSendSyncNew(v49, (int)v40, (int)&theData, (int)&v89, 0, 60.0);
  if (v50)
  {
    uint64_t v15 = v50;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)"AMAuthInstallHttpMessageSendSyncNew returned %d", v51, v52, v53, v54, v55, v50);
    uint64_t v13 = v41;
LABEL_52:
    uint64_t v11 = v81;
    goto LABEL_40;
  }
  uint64_t v13 = v41;
  if (!theData)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)"responseData is NULL", v51, v52, v53, v54, v55, v79);
    uint64_t v15 = 16;
    goto LABEL_52;
  }
  uint64_t v11 = v81;
  if (v89 != 200)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)"httpStatus is %d", v51, v52, v53, v54, v55, v89);
    uint64_t v15 = 16;
    goto LABEL_40;
  }
  BytePtr = CFDataGetBytePtr(theData);
  size_t Length = CFDataGetLength(theData);
  int v62 = AMAuthInstallSupportCreateDecodedPEM((uint64_t)BytePtr, Length, &v88, (size_t *)&v87, v58, v59, v60, v61);
  if (v62)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)"AMAuthInstallSupportCreateDecodedPEM returned %d", v63, v64, v65, v66, v67, v62);
LABEL_58:
    uint64_t v15 = 6;
    goto LABEL_40;
  }
  if (!v88)
  {
    uint64_t v78 = "decodedDER is NULL";
LABEL_57:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)v78, v63, v64, v65, v66, v67, v79);
    goto LABEL_58;
  }
  if (!v87)
  {
    uint64_t v78 = "decodedLength is 0";
    goto LABEL_57;
  }
  CFAllocatorRef v68 = CFGetAllocator(a1);
  CFDataRef v69 = CFDataCreate(v68, v88, v87);
  if (!v69)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpCreateBaaCertificateData", (uint64_t)"leafData is NULL", v70, v71, v72, v73, v74, v79);
    goto LABEL_60;
  }
  uint64_t v15 = 0;
  if (v80) {
    *uint64_t v80 = v69;
  }
LABEL_40:
  AMSupportSafeFree();

  return v15;
}

uint64_t AMAuthInstallHttpRequestAlternateUpdateBaaCertificate(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0;
  uint64_t BaaCertificateData = AMAuthInstallHttpCreateBaaCertificateData(a1, (const __CFDictionary *)&off_1000AE870, a2, (uint64_t)&cf, a5, a6, a7, a8);
  CFTypeRef v10 = cf;
  if (BaaCertificateData) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = cf == 0;
  }
  if (!v11)
  {
    if (*(void *)(a1[2] + 128))
    {
      CFRelease(*(CFTypeRef *)(a1[2] + 128));
      *(void *)(a1[2] + 128) = 0;
      CFTypeRef v10 = cf;
    }
    *(void *)(a1[2] + 128) = CFRetain(v10);
  }
  return BaaCertificateData;
}

uint64_t AMAuthInstallLockCreate()
{
  pthread_once(&stru_1000B8358, (void (*)(void))sub_100025564);
  uint64_t result = _CFRuntimeCreateInstance();
  if (result) {
    *(_DWORD *)(result + 16) = 0;
  }
  return result;
}

void AMAuthInstallLockLock(os_unfair_lock_s *a1)
{
}

void AMAuthInstallLockUnlock(os_unfair_lock_s *a1)
{
}

uint64_t sub_100025564()
{
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1000B8C78 = result;
  return result;
}

uint64_t AMAuthInstallRestoreLocalPolicyCreateServerRequest(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  CFMutableDictionaryRef theDict = 0;
  if (sub_10002563C((uint64_t **)a1, a2, (CFTypeRef *)&theDict)
    || (uint64_t v5 = *(const void **)(*(void *)(a1 + 16) + 24)) == 0)
  {
    uint64_t v6 = 1;
  }
  else
  {
    CFDictionarySetValue(theDict, @"ApNonce", v5);
    CFDictionarySetValue(theDict, @"Ap,LocalBoot", kCFBooleanFalse);
    uint64_t v6 = 0;
    if (a3) {
      *a3 = CFRetain(theDict);
    }
  }
  SafeRelease(theDict);
  return v6;
}

uint64_t sub_10002563C(uint64_t **a1, const void *a2, CFTypeRef *a3)
{
  if (a1 && (CFAllocatorRef v6 = CFGetAllocator(a1), a1[2]))
  {
    CFAllocatorRef v14 = v6;
    int IsImg4 = AMAuthInstallApIsImg4((uint64_t)a1, v7, v8, v9, v10, v11, v12, v13);
    CFMutableStringRef Mutable = 0;
    uint64_t v17 = 1;
    CFDataRef v18 = 0;
    uint64_t v19 = 0;
    if (a2 && IsImg4)
    {
      if (CFDataGetLength((CFDataRef)a2) == 48)
      {
        CFMutableStringRef Mutable = CFDictionaryCreateMutable(v14, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFDataRef v18 = CFDataCreate(v14, byte_10007CB18, 48);
        CFDictionarySetValue(Mutable, @"Digest", v18);
        CFDictionarySetValue(Mutable, @"Trusted", kCFBooleanTrue);
        uint64_t v19 = CFDictionaryCreateMutable(v14, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFDictionarySetValue(v19, @"@ApImg4Ticket", kCFBooleanTrue);
        _CFDictionarySetInteger32(v19, @"ApChipID", *((_DWORD *)a1[2] + 2));
        _CFDictionarySetInteger32(v19, @"ApBoardID", *((_DWORD *)a1[2] + 3));
        _CFDictionarySetInteger64(v19, @"ApECID", *a1[2]);
        _CFDictionarySetBoolean(v19, @"ApProductionMode", *((unsigned __int8 *)a1[2] + 20));
        _CFDictionarySetInteger32(v19, @"ApSecurityDomain", *((_DWORD *)a1[2] + 4));
        _CFDictionarySetBoolean(v19, @"ApSecurityMode", *((unsigned __int8 *)a1[2] + 72));
        CFDictionarySetValue(v19, @"Ap,LocalPolicy", Mutable);
        CFDictionarySetValue(v19, @"Ap,NextStageIM4MHash", a2);
        uint64_t v17 = 0;
        if (a3) {
          *a3 = CFRetain(v19);
        }
      }
      else
      {
        CFMutableStringRef Mutable = 0;
        CFDataRef v18 = 0;
        uint64_t v19 = 0;
      }
    }
  }
  else
  {
    CFMutableStringRef Mutable = 0;
    CFDataRef v18 = 0;
    uint64_t v19 = 0;
    uint64_t v17 = 1;
  }
  SafeRelease(v19);
  SafeRelease(v18);
  SafeRelease(Mutable);
  return v17;
}

uint64_t AMAuthInstallLocalPolicyStitchTicketData(const void *a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  if (!a1) {
    goto LABEL_8;
  }
  CFAllocatorRef v5 = CFGetAllocator(a1);
  if (!a2)
  {
LABEL_9:
    CFDataRef v15 = 0;
    uint64_t v16 = 1;
    goto LABEL_10;
  }
  CFAllocatorRef v6 = v5;
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a2, @"ApImg4Ticket");
  if (!Value)
  {
LABEL_8:
    a2 = 0;
    goto LABEL_9;
  }
  CFDataRef v8 = Value;
  a2 = CFDataCreate(v6, byte_10007CB02, 22);
  if (a2)
  {
    CFDataRef StitchTicket = AMAuthInstallApImg4CreateStitchTicket(v6, a2, v8);
    CFDataRef v15 = StitchTicket;
    if (StitchTicket)
    {
      uint64_t v16 = 0;
      if (a3) {
        *a3 = CFRetain(StitchTicket);
      }
    }
    else
    {
      uint64_t v16 = 3;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallLocalPolicyStitchTicketData", (uint64_t)"failed to stitch local policy object", v10, v11, v12, v13, v14, v18);
    }
  }
  else
  {
    CFDataRef v15 = 0;
    uint64_t v16 = 2;
  }
LABEL_10:
  SafeRelease(v15);
  SafeRelease(a2);
  return v16;
}

void (*AMAuthInstallLogSetHandler(void (*result)(int a1, uint64_t a2)))(int a1, uint64_t a2)
{
  if (result) {
    CFStringRef v1 = result;
  }
  else {
    CFStringRef v1 = sub_1000259BC;
  }
  off_1000B8368 = (uint64_t (*)(void, void))v1;
  return result;
}

void sub_1000259BC(int a1, uint64_t a2)
{
  if (qword_1000B8C88 != -1) {
    dispatch_once(&qword_1000B8C88, &stru_10009DD28);
  }
  if (a1 <= 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1000B8C80, OS_LOG_TYPE_FAULT)) {
      sub_100071F58();
    }
    return;
  }
  if (a1 == 3)
  {
    if (os_log_type_enabled((os_log_t)qword_1000B8C80, OS_LOG_TYPE_ERROR)) {
      sub_100071FCC();
    }
    return;
  }
  if (a1 <= 5)
  {
    uint64_t v4 = qword_1000B8C80;
    if (!os_log_type_enabled((os_log_t)qword_1000B8C80, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v9 = 136446210;
    uint64_t v10 = a2;
    CFAllocatorRef v5 = v4;
    os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v5, v6, "%{public}s", (uint8_t *)&v9, 0xCu);
    return;
  }
  if (a1 == 6)
  {
    uint64_t v7 = qword_1000B8C80;
    if (!os_log_type_enabled((os_log_t)qword_1000B8C80, OS_LOG_TYPE_INFO)) {
      return;
    }
    int v9 = 136446210;
    uint64_t v10 = a2;
    CFAllocatorRef v5 = v7;
    os_log_type_t v6 = OS_LOG_TYPE_INFO;
    goto LABEL_15;
  }
  BOOL v8 = os_log_type_enabled((os_log_t)qword_1000B8C80, OS_LOG_TYPE_DEBUG);
  if (a1 > 7)
  {
    if (v8) {
      sub_1000720B4();
    }
  }
  else if (v8)
  {
    sub_100072040();
  }
}

void AMAuthInstallLog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = __chkstk_darwin();
  uint64_t v12 = v11;
  uint64_t v13 = v9;
  uint64_t v14 = "";
  if (v10) {
    uint64_t v14 = v10;
  }
  unsigned int v15 = snprintf(__str, 0x1000uLL, "%s: ", v14);
  CFStringRef v16 = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault, v12, 0x8000100u, kCFAllocatorNull);
  if (!v16)
  {
    CFStringRef v18 = 0;
    goto LABEL_9;
  }
  CFStringRef v17 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, v16, &a9);
  CFStringRef v18 = v17;
  if (!v17)
  {
LABEL_9:
    uint64_t v26 = 0;
    uint64_t v25 = 0;
    goto LABEL_14;
  }
  uint64_t v19 = v15;
  unsigned int v20 = 4096 - v15;
  unsigned int Length = CFStringGetLength(v17);
  unsigned int v22 = Length;
  if (4096 - v15 < Length && (uint64_t v23 = (char *)malloc(v15 + Length + 1)) != 0)
  {
    uint64_t v24 = v23;
    unsigned int v20 = v22 + 1;
    memcpy(v23, __str, v15);
    uint64_t v25 = v24;
  }
  else
  {
    uint64_t v25 = 0;
    uint64_t v24 = __str;
  }
  if (CFStringGetCString(v18, &v24[v19], v20, 0x8000100u)) {
    uint64_t v26 = v24;
  }
  else {
    uint64_t v26 = 0;
  }
LABEL_14:
  if (v26) {
    uint64_t v27 = v26;
  }
  else {
    uint64_t v27 = "failed to format log message";
  }
  off_1000B8368(v13, v27);
  SafeRelease(v16);
  SafeRelease(v18);
  SafeFree(v25);
}

uint64_t AMAuthInstallDebugWriteObject(char *cf, CFTypeRef a2, uint64_t a3, int a4)
{
  CFTypeRef cfa = 0;
  if (!cf) {
    goto LABEL_19;
  }
  if ((*((_DWORD *)cf + 86) & a4) == 0)
  {
    uint64_t v14 = 0;
LABEL_12:
    CFDataRef Data = 0;
    goto LABEL_20;
  }
  if (!*((void *)cf + 42))
  {
    CFAllocatorRef v21 = CFGetAllocator(cf);
    uint64_t v22 = AMAuthInstallSupportCopyURLToNewTempDirectory(v21, "amai-debug.XXXXXX", cf + 336);
    if (v22)
    {
      uint64_t v14 = v22;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallDebugWriteObject", (uint64_t)"failed to create debug output directory", v23, v24, v25, v26, v27, v42);
      goto LABEL_12;
    }
  }
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 == CFDataGetTypeID())
  {
    CFDataRef Data = (const __CFData *)CFRetain(a2);
    uint64_t v9 = "";
    if (Data) {
      goto LABEL_6;
    }
LABEL_16:
    uint64_t v14 = 0;
    goto LABEL_20;
  }
  CFTypeID v28 = CFGetTypeID(a2);
  if (v28 != CFDictionaryGetTypeID())
  {
    CFTypeID v29 = CFGetTypeID(a2);
    if (v29 != CFArrayGetTypeID())
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallDebugWriteObject", (uint64_t)"can't prepare data for output to file", v30, v31, v32, v33, v34, v42);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallDebugWriteObject", (uint64_t)"%@", v36, v37, v38, v39, v40, (char)a2);
LABEL_19:
      CFDataRef Data = 0;
      uint64_t v14 = 1;
      goto LABEL_20;
    }
  }
  CFAllocatorRef v35 = CFGetAllocator(cf);
  CFDataRef Data = CFPropertyListCreateData(v35, a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  uint64_t v9 = ".plist";
  if (!Data) {
    goto LABEL_16;
  }
LABEL_6:
  CFAllocatorRef v10 = CFGetAllocator(cf);
  CFStringRef v11 = CFStringCreateWithFormat(v10, 0, @"%@%s", a3, v9);
  if (v11)
  {
    CFStringRef v12 = v11;
    CFAllocatorRef v13 = CFGetAllocator(cf);
    uint64_t v14 = AMAuthInstallSupportCopyURLWithAppendedComponent(v13, *((const void **)cf + 42), v12, 0, (CFURLRef *)&cfa);
    CFRelease(v12);
    if (!v14)
    {
      CFAllocatorRef v15 = CFGetAllocator(cf);
      uint64_t v14 = AMAuthInstallSupportWriteDataToFileURL(v15, Data, (const __CFURL *)cfa, 0);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallDebugWriteObject", (uint64_t)"debug object written: %@", v16, v17, v18, v19, v20, (char)cfa);
    }
  }
  else
  {
    uint64_t v14 = 2;
  }
LABEL_20:
  SafeRelease(Data);
  SafeRelease(cfa);
  return v14;
}

void AMAuthInstallLogDumpMemory(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  uint64_t v9 = (unsigned __int8 *)a4;
  AMAuthInstallLog(a1, a2, (uint64_t)"[%s: %u bytes]", a4, a5, a6, a7, a8, a3);
  if (v8 >= 1)
  {
    int v16 = 0;
    unsigned int v17 = 0;
    unsigned int v18 = v8 + 1;
    do
    {
      int v19 = *v9++;
      int v20 = snprintf(&v22[v17], 64 - v17, "%02x ", v19);
      if (++v16 > 0xF || v18 == 2)
      {
        AMAuthInstallLog(a1, (uint64_t)"", (uint64_t)"%s", v11, v12, v13, v14, v15, (char)v22);
        unsigned int v17 = 0;
        int v16 = 0;
      }
      else
      {
        v17 += v20;
      }
      --v18;
    }
    while (v18 > 1);
  }
  AMAuthInstallLog(a1, (uint64_t)"", (uint64_t)"-----------------------------------------------", v11, v12, v13, v14, v15, v21);
}

void sub_1000260A8(id a1)
{
  qword_1000B8C80 = (uint64_t)os_log_create("com.apple.libauthinstall", "AMAuthInstallLog");
}

uint64_t AMAuthInstallMonetMeasureDbl(const void *a1, CFDataRef theData, __CFDictionary *a3)
{
  BytePtr = (char *)CFDataGetBytePtr(theData);
  CFTypeID v7 = CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  if (Length <= 3)
  {
    AMAuthInstallLog(7, (uint64_t)"_FindSblHeaderInFileData", (uint64_t)"foundMagic=%d", v9, v10, v11, v12, v13, 0);
LABEL_3:
    int v19 = "_FindSblHeaderInFileData";
    int v20 = "this file lacks sufficient magic";
    goto LABEL_4;
  }
  char v22 = 0;
  uint64_t v23 = 0;
  unsigned int v24 = Length >> 2;
  uint64_t v25 = v7 - 4;
  do
  {
    if (*((_DWORD *)v25 + 1) == 1943474228)
    {
      ++v22;
      uint64_t v23 = v25;
      if (*((_DWORD *)v25 + 2) != 2097890138)
      {
        AMAuthInstallLog(7, (uint64_t)"_FindSblHeaderInFileData", (uint64_t)"found SBL header", v9, v10, v11, v12, v13, v31);
        AMAuthInstallLog(7, (uint64_t)"_FindSblHeaderInFileData", (uint64_t)"foundMagic=%d", v26, v27, v28, v29, v30, v22);
        uint64_t v23 = v25;
        goto LABEL_12;
      }
    }
    v25 += 4;
    --v24;
  }
  while (v24);
  AMAuthInstallLog(7, (uint64_t)"_FindSblHeaderInFileData", (uint64_t)"foundMagic=%d", v9, v10, v11, v12, v13, v22);
  if (!v23) {
    goto LABEL_3;
  }
LABEL_12:
  uint64_t v16 = *((unsigned int *)v23 + 5);
  if (v23 + 80 != (const UInt8 *)&BytePtr[v16])
  {
    int v19 = "AMAuthInstallMonetMeasureDbl";
    int v20 = "junk following sbl header";
LABEL_4:
    AMAuthInstallLog(3, (uint64_t)v19, (uint64_t)v20, v14, v15, v16, v17, v18, v32);
    return 10;
  }
  AMAuthInstallMonetSetVersionAndPartialDigest(a1, a3, BytePtr, theData, v23, v16, *((_DWORD *)v23 + 8), @"DBL-Version", @"DBL-PartialDigest");
  return 0;
}

uint64_t AMAuthInstallMonetSetVersionAndPartialDigest(const void *a1, __CFDictionary *a2, char *a3, CFDataRef theData, const void *a5, int a6, int a7, const void *a8, const void *a9)
{
  memset(v50, 0, sizeof(v50));
  uint64_t v16 = &a3[a6];
  int v17 = *((_DWORD *)v16 + 2);
  int valuePtr = *((_DWORD *)v16 + 1);
  char Length = CFDataGetLength(theData);
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetSetVersionAndPartialDigest", (uint64_t)"fileSize=0x%x, srcOffset=0x%x, codeSize=0x%x", v19, v20, v21, v22, v23, Length);
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetSetVersionAndPartialDigest", (uint64_t)"version=0x%x, personalizationOffset=0x%x", v24, v25, v26, v27, v28, valuePtr);
  *(_DWORD *)bytes = a7 - v17;
  int v49 = v17 + 80;
  *(_DWORD *)&v50[20] = v17 + a6;
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetSetVersionAndPartialDigest", (uint64_t)"reservationLength=0x%x, codeBytesHashed=0x%x (%s), downloadBytesHashed=0x%x (%s)", v29, v30, v31, v32, v33, a7 - v17);
  char v34 = CFDataGetLength(theData);
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetSetVersionAndPartialDigest", (uint64_t)"personalization area=0x%x", v35, v36, v37, v38, v39, v34 - (a6 + a7));
  if ((((v17 + 80) | (v17 + a6)) & 0x3F) == 0)
  {
    sub_100016080(a5, v17 + 80, (int8x16_t *)v50);
    sub_100016080(a3, *(CC_LONG *)&v50[20], (int8x16_t *)&v50[24]);
    CFAllocatorRef v43 = CFGetAllocator(a1);
    CFDataRef v41 = CFDataCreate(v43, bytes, 52);
    if (v41)
    {
      CFAllocatorRef v44 = CFGetAllocator(a1);
      CFNumberRef v40 = CFNumberCreate(v44, kCFNumberSInt32Type, &valuePtr);
      if (v40)
      {
        CFDictionarySetValue(a2, a8, v40);
        CFDictionarySetValue(a2, a9, v41);
        uint64_t v42 = 0;
        goto LABEL_6;
      }
    }
    else
    {
      CFNumberRef v40 = 0;
    }
    uint64_t v42 = 2;
    goto LABEL_6;
  }
  CFNumberRef v40 = 0;
  CFDataRef v41 = 0;
  uint64_t v42 = 10;
LABEL_6:
  SafeRelease(v40);
  SafeRelease(v41);
  return v42;
}

uint64_t AMAuthInstallMonetStitchDbl(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, @"DBL-Blob");
}

uint64_t AMAuthInstallMonetStitchEBootLoader(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4, const void *a5)
{
  CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-Original", a5);
  char v46 = (char)a5;
  CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-Personalized");
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a3, @"BasebandFirmware");
  if (!Value)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallMonetStitchFirstStage", (uint64_t)"response lacks %@", v13, v14, v15, v16, v17, (char)@"BasebandFirmware");
LABEL_9:
    uint64_t v44 = 8;
LABEL_12:
    SafeRelease(0);
    goto LABEL_6;
  }
  CFDataRef v18 = (const __CFData *)CFDictionaryGetValue(Value, a5);
  if (!v18)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallMonetStitchFirstStage", (uint64_t)"response lacks %@", v19, v20, v21, v22, v23, (char)a5);
    goto LABEL_9;
  }
  CFDataRef v24 = v18;
  CFIndex Length = CFDataGetLength(v18);
  if (Length >= CFDataGetLength(a2))
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallMonetStitchFirstStage", (uint64_t)"stitch data is larger than file", v26, v27, v28, v29, v30, v46);
    uint64_t v44 = 1;
    goto LABEL_12;
  }
  CFAllocatorRef v31 = CFGetAllocator(a1);
  CFDictionaryRef MutableCopy = CFDataCreateMutableCopy(v31, 0, a2);
  if (!MutableCopy)
  {
    uint64_t v44 = 2;
    goto LABEL_12;
  }
  CFDataRef v33 = MutableCopy;
  MutableBytePtr = CFDataGetMutableBytePtr(MutableCopy);
  CFIndex v35 = CFDataGetLength(v33);
  uint64_t v36 = &MutableBytePtr[v35 - CFDataGetLength(v24)];
  CFDataGetLength(v24);
  CFDataGetLength(v33);
  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallMonetStitchFirstStage", (uint64_t)"Stitch Debug: \n StitchAddress: 0x%x \n 64-Byte-Aligned: %s \n 128-Byte-Aligned: %s\n Len(stitchData)=%d Len(newFileData) = %d", v37, v38, v39, v40, v41, (char)v36);
  BytePtr = CFDataGetBytePtr(v24);
  size_t v43 = CFDataGetLength(v24);
  memcpy(v36, BytePtr, v43);
  *a4 = CFRetain(v33);
  SafeRelease(v33);
  AMAuthInstallDebugWriteObject((char *)a1, a2, (uint64_t)v10, 1);
  AMAuthInstallDebugWriteObject((char *)a1, *a4, (uint64_t)v11, 1);
  uint64_t v44 = 0;
LABEL_6:
  SafeRelease(v10);
  SafeRelease(v11);
  return v44;
}

uint64_t AMAuthInstallMonetMeasureEBootLoader(const void *a1, CFDataRef theData, __CFDictionary *a3, const void *a4, const void *a5)
{
  *(void *)bytes = 0;
  int8x16_t v40 = 0uLL;
  int v41 = 0;
  int valuePtr = 0;
  if ((unint64_t)CFDataGetLength(theData) >= 0x28)
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFDataRef v11 = (CFDataRef)BytePtr;
    CFMutableDictionaryRef theDict = a3;
    if (!BytePtr)
    {
      CFNumberRef v32 = 0;
      goto LABEL_6;
    }
    if (*((_DWORD *)BytePtr + 4) <= CFDataGetLength(theData))
    {
      int Length = CFDataGetLength(theData);
      int v13 = *((_DWORD *)v11 + 5);
      unsigned int v14 = Length - *((_DWORD *)v11 + 4);
      uint64_t v15 = (char *)v11 + v14;
      int valuePtr = *((_DWORD *)v15 + 1);
      int v16 = *((_DWORD *)v15 + 2);
      CFDataGetLength(theData);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetMeasureEBootLoader", (uint64_t)"%@: fileSize=0x%x, srcOffset=0x%x, codeSize=0x%x", v17, v18, v19, v20, v21, (char)a5);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetMeasureEBootLoader", (uint64_t)"%@: version=0x%x, personalizationOffset=0x%x", v22, v23, v24, v25, v26, (char)a4);
      *(_DWORD *)bytes = v13 - v16;
      *(_DWORD *)&UInt8 bytes[4] = v16 + v14;
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetMeasureEBootLoader", (uint64_t)"%@: reservationLength=0x%x, codeBytesHashed=0x%x (%s)", v27, v28, v29, v30, v31, (char)a5);
      if (((v16 + v14) & 0x3F) == 0)
      {
        sub_100016080(v11, v16 + v14, &v40);
        CFAllocatorRef v34 = CFGetAllocator(a1);
        CFDataRef v11 = CFDataCreate(v34, bytes, 28);
        if (v11)
        {
          CFAllocatorRef v35 = CFGetAllocator(a1);
          CFNumberRef v32 = CFNumberCreate(v35, kCFNumberSInt32Type, &valuePtr);
          if (v32)
          {
            CFDictionarySetValue(theDict, a4, v32);
            CFDictionarySetValue(theDict, a5, v11);
            uint64_t v33 = 0;
            goto LABEL_10;
          }
        }
        else
        {
          CFNumberRef v32 = 0;
        }
        uint64_t v33 = 2;
        goto LABEL_10;
      }
    }
  }
  CFNumberRef v32 = 0;
  CFDataRef v11 = 0;
LABEL_6:
  uint64_t v33 = 10;
LABEL_10:
  SafeRelease(v32);
  SafeRelease(v11);
  return v33;
}

uint64_t AMAuthInstallMonetMeasureEDbl(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureEBootLoader(a1, a2, a3, @"eDBL-Version", @"eDBL-PartialDigest");
}

uint64_t AMAuthInstallMonetMeasureRestoreDbl(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureEBootLoader(a1, a2, a3, @"RestoreDBL-Version", @"RestoreDBL-PartialDigest");
}

uint64_t AMAuthInstallMonetMeasureENandprog(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureEBootLoader(a1, a2, a3, @"ENANDPRG-Version", @"ENANDPRG-PartialDigest");
}

uint64_t AMAuthInstallMonetStitchEDbl(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, @"eDBL-Blob");
}

uint64_t AMAuthInstallMonetStitchRestoreDbl(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, @"RestoreDBL-Blob");
}

uint64_t AMAuthInstallMonetStitchENandprog(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, @"ENANDPRG-Blob");
}

uint64_t AMAuthInstallMonetStitchSbl1(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  int v4 = *(_DWORD *)(a1[6] + 4);
  CFAllocatorRef v5 = &kAMAuthInstallTagBbSbl1HTDStitch;
  if (v4 <= 1515744)
  {
    if (v4 <= 938208)
    {
      if (v4 != 241889 && v4 != 520417) {
        goto LABEL_22;
      }
      return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, *v5);
    }
    BOOL v7 = v4 == 938209;
    int v8 = 1327329;
    goto LABEL_15;
  }
  if (v4 <= 2089184)
  {
    BOOL v7 = v4 == 1515745;
    int v8 = 1700065;
LABEL_15:
    if (!v7 && v4 != v8) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }
  if (v4 == 2089185)
  {
LABEL_20:
    CFAllocatorRef v5 = &kAMAuthInstallTagBbSbl1HTBStitch;
    return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, *v5);
  }
  if (v4 != 9781473)
  {
    if (v4 != 2814177)
    {
LABEL_22:
      CFAllocatorRef v5 = &kAMAuthInstallTagBbSbl1Stitch;
      return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, *v5);
    }
    goto LABEL_20;
  }
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, *v5);
}

uint64_t AMAuthInstallMonetStitchMisc(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, @"Misc-HashTableBody-Blob");
}

uint64_t AMAuthInstallMonetStitchRestoreSbl1(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  int v4 = *(_DWORD *)(a1[6] + 4);
  CFAllocatorRef v5 = &kAMAuthInstallTagBbRestoreSbl1HTDStitch;
  if (v4 <= 1515744)
  {
    if (v4 <= 938208)
    {
      if (v4 != 241889 && v4 != 520417) {
        goto LABEL_22;
      }
      return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, *v5);
    }
    BOOL v7 = v4 == 938209;
    int v8 = 1327329;
    goto LABEL_15;
  }
  if (v4 <= 2089184)
  {
    BOOL v7 = v4 == 1515745;
    int v8 = 1700065;
LABEL_15:
    if (!v7 && v4 != v8) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }
  if (v4 == 2089185)
  {
LABEL_20:
    CFAllocatorRef v5 = &kAMAuthInstallTagBbRestoreSbl1HTBStitch;
    return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, *v5);
  }
  if (v4 != 9781473)
  {
    if (v4 != 2814177)
    {
LABEL_22:
      CFAllocatorRef v5 = &kAMAuthInstallTagBbRestoreSbl1Stitch;
      return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, *v5);
    }
    goto LABEL_20;
  }
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, *v5);
}

uint64_t AMAuthInstallMonetMeasureOsbl(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureBootImage(a1, a2, a3, @"OSBL-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureBootImage(void *a1, const __CFData *a2, __CFDictionary *a3, const void *a4)
{
  CFDictionaryRef value = 0;
  if (!a1)
  {
    os_log_type_t v6 = 0;
    uint64_t v7 = 1;
    goto LABEL_25;
  }
  os_log_type_t v6 = 0;
  uint64_t v7 = 1;
  if (a4)
  {
    if (a3)
    {
      if (a2)
      {
        uint64_t v9 = a1[6];
        if (v9)
        {
          int v10 = *(_DWORD *)(v9 + 4);
          if (v10 <= 1700064)
          {
            if (v10 > 938208)
            {
              BOOL v11 = v10 == 938209 || v10 == 1327329;
              int v12 = 1515745;
LABEL_17:
              if (!v11 && v10 != v12) {
                goto LABEL_36;
              }
              goto LABEL_22;
            }
            if (v10 != 241889)
            {
              if (v10 != 520417)
              {
LABEL_36:
                CFAllocatorRef v19 = CFGetAllocator(a1);
                DigestForCFDataRef Data = AMAuthInstallCryptoCreateDigestForData(v19, a2, (CFTypeRef *)&value);
                goto LABEL_38;
              }
LABEL_22:
              CFAllocatorRef v14 = CFGetAllocator(a1);
              DigestForCFDataRef Data = AMAuthInstallCryptoCreateDigestForData_SHA384(v14, a2, (CFTypeRef *)&value);
              os_log_type_t v6 = value;
              if (!DigestForData)
              {
                if (!value)
                {
LABEL_40:
                  uint64_t v7 = 2;
                  goto LABEL_25;
                }
                goto LABEL_24;
              }
LABEL_42:
              uint64_t v7 = DigestForData;
              goto LABEL_25;
            }
          }
          else
          {
            if (v10 <= 8343776)
            {
              BOOL v11 = v10 == 1700065 || v10 == 2089185;
              int v12 = 2814177;
              goto LABEL_17;
            }
            if (v10 != 8343777 && v10 != 9781473 && v10 != 9572577) {
              goto LABEL_36;
            }
          }
          CFAllocatorRef v20 = CFGetAllocator(a1);
          DigestForCFDataRef Data = AMAuthInstallCryptoCreateDigestForData_SHA256(v20, a2, (CFTypeRef *)&value);
LABEL_38:
          os_log_type_t v6 = value;
          if (!DigestForData)
          {
            if (!value) {
              goto LABEL_40;
            }
LABEL_24:
            CFDictionarySetValue(a3, a4, v6);
            uint64_t v7 = 0;
            os_log_type_t v6 = value;
            goto LABEL_25;
          }
          goto LABEL_42;
        }
      }
    }
  }
LABEL_25:
  SafeRelease(v6);
  return v7;
}

uint64_t AMAuthInstallMonetMeasureElf(void *a1, CFDataRef theData, __CFDictionary *a3, const void *a4, const void *a5)
{
  if ((unint64_t)CFDataGetLength(theData) > 0x33
    && (uint64_t v15 = CFDataGetBytePtr(theData), *(_DWORD *)v15 == 1179403647))
  {
    int v16 = *((unsigned __int16 *)v15 + 22);
    if (*((_WORD *)v15 + 22))
    {
      uint64_t v17 = 0;
      unsigned int v18 = 0;
      CFAllocatorRef v19 = &v15[*((unsigned int *)v15 + 7)];
      do
      {
        if (*((_DWORD *)v19 + 3) > v18 && (*((_DWORD *)v19 + 6) & 0x7000000) != 0x5000000)
        {
          unsigned int v18 = *((_DWORD *)v19 + 3);
          uint64_t v17 = v19;
        }
        v19 += 32;
        --v16;
      }
      while (v16);
      if (v17)
      {
        CFAllocatorRef v20 = CFGetAllocator(a1);
        CFMutableStringRef Mutable = CFDataCreateMutable(v20, 0);
        if (Mutable)
        {
          CFAllocatorRef v22 = CFGetAllocator(a1);
          uint64_t v23 = CFDataCreateMutable(v22, 0);
          if (v23)
          {
            int v24 = *(_DWORD *)(a1[6] + 4);
            if (v24 <= 1700064)
            {
              if (v24 > 938208)
              {
                if (v24 == 938209 || v24 == 1327329) {
                  goto LABEL_30;
                }
                int v25 = 1515745;
                goto LABEL_29;
              }
              if (v24 != 241889)
              {
                int v25 = 520417;
                goto LABEL_29;
              }
            }
            else
            {
              if (v24 <= 8343776)
              {
                if (v24 == 1700065 || v24 == 2089185) {
                  goto LABEL_30;
                }
                int v25 = 2814177;
LABEL_29:
                if (v24 == v25)
                {
LABEL_30:
                  CFDataSetLength(Mutable, 48);
                  uint64_t v28 = &CFDataGetBytePtr(theData)[*((unsigned int *)v17 + 1)];
                  CC_LONG v29 = *((_DWORD *)v17 + 4);
                  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
                  CC_SHA384(v28, v29, MutableBytePtr);
                  CFDataSetLength(v23, 48);
                  BytePtr = CFDataGetBytePtr(theData);
                  CC_LONG Length = CFDataGetLength(theData);
                  uint64_t v33 = CFDataGetMutableBytePtr(v23);
                  CC_SHA384(BytePtr, Length, v33);
LABEL_32:
                  CFDictionarySetValue(a3, a5, v23);
                  CFDictionarySetValue(a3, a4, Mutable);
                  uint64_t v27 = 0;
                  goto LABEL_33;
                }
LABEL_34:
                CFDataSetLength(Mutable, 20);
                int v41 = &CFDataGetBytePtr(theData)[*((unsigned int *)v17 + 1)];
                CC_LONG v42 = *((_DWORD *)v17 + 4);
                size_t v43 = CFDataGetMutableBytePtr(Mutable);
                CC_SHA1(v41, v42, v43);
                CFDataSetLength(v23, 20);
                uint64_t v44 = CFDataGetBytePtr(theData);
                CC_LONG v45 = CFDataGetLength(theData);
                char v46 = CFDataGetMutableBytePtr(v23);
                CC_SHA1(v44, v45, v46);
                goto LABEL_32;
              }
              if (v24 != 8343777 && v24 != 9781473 && v24 != 9572577) {
                goto LABEL_34;
              }
            }
            CFDataSetLength(Mutable, 32);
            CFAllocatorRef v34 = &CFDataGetBytePtr(theData)[*((unsigned int *)v17 + 1)];
            CC_LONG v35 = *((_DWORD *)v17 + 4);
            uint64_t v36 = CFDataGetMutableBytePtr(Mutable);
            CC_SHA256(v34, v35, v36);
            CFDataSetLength(v23, 32);
            uint64_t v37 = CFDataGetBytePtr(theData);
            CC_LONG v38 = CFDataGetLength(theData);
            uint64_t v39 = CFDataGetMutableBytePtr(v23);
            CC_SHA256(v37, v38, v39);
            goto LABEL_32;
          }
        }
        else
        {
          uint64_t v23 = 0;
        }
        uint64_t v27 = 2;
        goto LABEL_33;
      }
    }
    uint64_t v26 = "file lacks a hash section";
  }
  else
  {
    uint64_t v26 = "invalid file format";
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetMeasureElf", (uint64_t)v26, v10, v11, v12, v13, v14, v47);
  CFMutableStringRef Mutable = 0;
  uint64_t v23 = 0;
  uint64_t v27 = 10;
LABEL_33:
  SafeRelease(v23);
  SafeRelease(Mutable);
  return v27;
}

uint64_t AMAuthInstallMonetMeasureMav20ElfMBN(const void *a1, CFDataRef theData, __CFDictionary *a3, void *a4, void *a5, const void *a6)
{
  uint64_t v68 = 0;
  long long v66 = 0u;
  long long v67 = 0u;
  *(_OWORD *)bytes = 0u;
  long long v65 = 0u;
  if ((unint64_t)CFDataGetLength(theData) <= 0x33
    || (BytePtr = CFDataGetBytePtr(theData), *(_DWORD *)BytePtr != 1179403647))
  {
    uint64_t v59 = "invalid file format";
    goto LABEL_21;
  }
  unsigned int v18 = BytePtr;
  int v19 = *((unsigned __int16 *)BytePtr + 22);
  if (!*((_WORD *)BytePtr + 22)) {
    goto LABEL_20;
  }
  unsigned int v20 = 0;
  uint64_t v21 = 0;
  CFAllocatorRef v22 = &BytePtr[*((unsigned int *)BytePtr + 7)];
  do
  {
    if (*((_DWORD *)v22 + 3) > v20 && (*((_DWORD *)v22 + 6) & 0x7000000) != 0x5000000)
    {
      uint64_t v21 = v22;
      unsigned int v20 = *((_DWORD *)v22 + 3);
    }
    v22 += 32;
    --v19;
  }
  while (v19);
  if (!v21)
  {
LABEL_20:
    uint64_t v59 = "file lacks a hash section";
LABEL_21:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetMeasureMav20ElfMBN", (uint64_t)v59, v12, v13, v14, v15, v16, v61);
    CC_LONG v38 = 0;
    CFDataRef v57 = 0;
    uint64_t v50 = 0;
    uint64_t v58 = 10;
    goto LABEL_22;
  }
  CFIndex v23 = (*((_DWORD *)v21 + 4) + *((_DWORD *)v21 + 1));
  if (CFDataGetLength(theData) < v23)
  {
    uint64_t v59 = "Hash segment larger than file";
    goto LABEL_21;
  }
  CFDataGetBytePtr(theData);
  int v24 = CFDataGetBytePtr(theData);
  uint64_t v25 = *((unsigned int *)v21 + 1);
  uint64_t v26 = &v24[v25];
  CFIndex v27 = (*(_DWORD *)&v24[v25 + 20] + v25);
  if (CFDataGetLength(theData) < v27)
  {
    uint64_t v59 = "MBN code_size overflows file";
    goto LABEL_21;
  }
  CFIndex v28 = (*((_DWORD *)v26 + 4) + *((_DWORD *)v21 + 1));
  if (CFDataGetLength(theData) < v28)
  {
    uint64_t v59 = "MBN image_size overflows file";
    goto LABEL_21;
  }
  CFIndex v29 = (*((_DWORD *)v26 + 9) + *((_DWORD *)v21 + 1));
  if (CFDataGetLength(theData) < v29)
  {
    uint64_t v59 = "MBN cert_chain_size overflows file";
    goto LABEL_21;
  }
  CFIndex v30 = (*((_DWORD *)v26 + 7) + *((_DWORD *)v21 + 1));
  if (CFDataGetLength(theData) < v30)
  {
    uint64_t v59 = "MBN signature_size overflows file";
    goto LABEL_21;
  }
  if ((*((_DWORD *)v26 + 7) + *((_DWORD *)v26 + 5) + *((_DWORD *)v26 + 9)) + 168 != *((_DWORD *)v21 + 4))
  {
    uint64_t v59 = "MBN segment    components != size of ELF segment.";
    goto LABEL_21;
  }
  CFAllocatorRef v31 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFDataCreateMutable(v31, 0);
  CC_LONG v38 = Mutable;
  if (!Mutable)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetMeasureMav20ElfMBN", (uint64_t)"Failed to create hashSectionDigestData", v33, v34, v35, v36, v37, v61);
    CFDataRef v57 = 0;
    uint64_t v50 = 0;
LABEL_33:
    uint64_t v58 = 2;
    goto LABEL_22;
  }
  int v62 = a5;
  key = a4;
  CFDataSetLength(Mutable, 48);
  CFDataGetBytePtr(theData);
  CFDataGetMutableBytePtr(v38);
  uint64_t v39 = *((unsigned int *)v21 + 1);
  int8x16_t v40 = CFDataGetBytePtr(theData);
  CFAllocatorRef v41 = CFGetAllocator(a1);
  CFDataRef v42 = CFDataCreate(v41, v26, 168);
  CFDictionarySetValue(a3, a6, v42);
  CFAllocatorRef v43 = CFGetAllocator(a1);
  uint64_t v44 = CFDataCreateMutable(v43, 0);
  uint64_t v50 = v44;
  if (!v44)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetMeasureMav20ElfMBN", (uint64_t)"Failed to create hashTableContents", v45, v46, v47, v48, v49, (char)v62);
    CFDataRef v57 = 0;
    goto LABEL_33;
  }
  CFDataAppendBytes(v44, &v40[v39 + 168], *((unsigned int *)v26 + 5));
  CFDataSetLength(v50, *((unsigned int *)v26 + 5));
  CFDictionarySetValue(a3, key, v50);
  *(_DWORD *)&UInt8 bytes[4] = *((_DWORD *)v21 + 1);
  *(_DWORD *)bytes = CFDataGetLength(theData) - *(_DWORD *)&bytes[4];
  sub_1000275C8(v18, *(CC_LONG *)&bytes[4], (uint64_t)&bytes[8]);
  CFAllocatorRef v51 = CFGetAllocator(a1);
  CFDataRef v57 = CFDataCreate(v51, bytes, 72);
  if (!v57)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetMeasureMav20ElfMBN", (uint64_t)"Failed to create partialDigestData", v52, v53, v54, v55, v56, (char)v62);
    goto LABEL_33;
  }
  CFDictionarySetValue(a3, v62, v57);
  uint64_t v58 = 0;
LABEL_22:
  SafeRelease(v50);
  SafeRelease(v38);
  SafeRelease(v57);
  return v58;
}

int8x16_t sub_1000275C8(const void *a1, CC_LONG a2, uint64_t a3)
{
  memset(&v8, 0, sizeof(v8));
  CC_SHA384_Init(&v8);
  CC_SHA384_Update(&v8, a1, a2);
  for (uint64_t i = 0; i != 8; i += 2)
  {
    int8x16_t result = vrev64q_s8(*(int8x16_t *)&v8.hash[i]);
    *(int8x16_t *)(a3 + i * 8) = result;
  }
  return result;
}

uint64_t AMAuthInstallMonetMeasureElfMBN(void *a1, CFDataRef theData, __CFDictionary *a3, void *a4, const void *a5)
{
  uint64_t v62 = 0;
  *(_OWORD *)bytes = 0u;
  long long v61 = 0u;
  uint64_t v59 = 0;
  memset(v58, 0, sizeof(v58));
  if ((unint64_t)CFDataGetLength(theData) > 0x33
    && (uint64_t v15 = CFDataGetBytePtr(theData), *(_DWORD *)v15 == 1179403647))
  {
    uint64_t v16 = v15;
    int v17 = *((unsigned __int16 *)v15 + 22);
    if (!*((_WORD *)v15 + 22)) {
      goto LABEL_19;
    }
    unsigned int v18 = 0;
    unsigned int v19 = 0;
    unsigned int v20 = &v15[*((unsigned int *)v15 + 7)];
    do
    {
      if (*((_DWORD *)v20 + 3) > v19 && (*((_DWORD *)v20 + 6) & 0x7000000) != 0x5000000)
      {
        unsigned int v19 = *((_DWORD *)v20 + 3);
        unsigned int v18 = v20;
      }
      v20 += 32;
      --v17;
    }
    while (v17);
    if (v18)
    {
      CFIndex v21 = (*((_DWORD *)v18 + 4) + *((_DWORD *)v18 + 1));
      if (CFDataGetLength(theData) < v21)
      {
        uint64_t v44 = "Hash segment larger than file";
      }
      else
      {
        BytePtr = CFDataGetBytePtr(theData);
        uint64_t v23 = *((unsigned int *)v18 + 1);
        int v24 = &BytePtr[v23];
        CFIndex v25 = (*(_DWORD *)&BytePtr[v23 + 20] + v23);
        if (CFDataGetLength(theData) < v25)
        {
          uint64_t v44 = "MBN code_size overflows file";
        }
        else
        {
          CFIndex v26 = (*((_DWORD *)v24 + 4) + *((_DWORD *)v18 + 1));
          if (CFDataGetLength(theData) < v26)
          {
            uint64_t v44 = "MBN image_size overflows file";
          }
          else
          {
            CFIndex v27 = (*((_DWORD *)v24 + 9) + *((_DWORD *)v18 + 1));
            if (CFDataGetLength(theData) < v27)
            {
              uint64_t v44 = "MBN cert_chain_size overflows file";
            }
            else
            {
              CFIndex v28 = (*((_DWORD *)v24 + 7) + *((_DWORD *)v18 + 1));
              if (CFDataGetLength(theData) < v28)
              {
                uint64_t v44 = "MBN signature_size overflows file";
              }
              else
              {
                if ((*((_DWORD *)v24 + 7) + *((_DWORD *)v24 + 5) + *((_DWORD *)v24 + 9)) + 40 == *((_DWORD *)v18 + 4))
                {
                  CFAllocatorRef v29 = CFGetAllocator(a1);
                  CFMutableStringRef Mutable = CFDataCreateMutable(v29, 0);
                  uint64_t v36 = Mutable;
                  if (Mutable)
                  {
                    key = a4;
                    uint64_t v37 = a5;
                    if (*(_DWORD *)(a1[6] + 4) == 520417)
                    {
                      CFDataSetLength(Mutable, 48);
                      CC_LONG v38 = &CFDataGetBytePtr(theData)[*((unsigned int *)v18 + 1)];
                      CC_LONG v39 = *((_DWORD *)v24 + 5) + 40;
                      MutableBytePtr = CFDataGetMutableBytePtr(v36);
                      CC_SHA384(v38, v39, MutableBytePtr);
                      DWORD1(v58[0]) = *((_DWORD *)v18 + 1) + *((_DWORD *)v24 + 5) + 40;
                      LODWORD(v58[0]) = CFDataGetLength(theData) - DWORD1(v58[0]);
                      sub_1000275C8(v16, DWORD1(v58[0]), (uint64_t)v58 + 8);
                      CFAllocatorRef v41 = CFGetAllocator(a1);
                      CFDataRef v42 = (UInt8 *)v58;
                      CFIndex v43 = 72;
                    }
                    else
                    {
                      CFDataSetLength(Mutable, 32);
                      uint64_t v47 = &CFDataGetBytePtr(theData)[*((unsigned int *)v18 + 1)];
                      CC_LONG v48 = *((_DWORD *)v24 + 5) + 40;
                      uint64_t v49 = CFDataGetMutableBytePtr(v36);
                      CC_SHA256(v47, v48, v49);
                      *(_DWORD *)&UInt8 bytes[4] = *((_DWORD *)v18 + 1) + *((_DWORD *)v24 + 5) + 40;
                      *(_DWORD *)bytes = CFDataGetLength(theData) - *(_DWORD *)&bytes[4];
                      sub_100027AB0(v16, *(CC_LONG *)&bytes[4], (uint64_t)&bytes[8]);
                      CFAllocatorRef v41 = CFGetAllocator(a1);
                      CFDataRef v42 = bytes;
                      CFIndex v43 = 40;
                    }
                    CFDataRef v45 = CFDataCreate(v41, v42, v43);
                    if (v45)
                    {
                      CFDictionarySetValue(a3, key, v36);
                      CFDictionarySetValue(a3, v37, v45);
                      uint64_t v46 = 0;
                      goto LABEL_24;
                    }
                    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetMeasureElfMBN", (uint64_t)"Failed to create partialDigestData", v50, v51, v52, v53, v54, v56);
                  }
                  else
                  {
                    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetMeasureElfMBN", (uint64_t)"Failed to create hashSectionDigestData", v31, v32, v33, v34, v35, v56);
                    CFDataRef v45 = 0;
                  }
                  uint64_t v46 = 2;
                  goto LABEL_24;
                }
                uint64_t v44 = "MBN segment components != size of ELF segment.";
              }
            }
          }
        }
      }
    }
    else
    {
LABEL_19:
      uint64_t v44 = "file lacks a hash section";
    }
  }
  else
  {
    uint64_t v44 = "invalid file format";
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetMeasureElfMBN", (uint64_t)v44, v10, v11, v12, v13, v14, v56);
  uint64_t v36 = 0;
  CFDataRef v45 = 0;
  uint64_t v46 = 10;
LABEL_24:
  SafeRelease(v36);
  SafeRelease(v45);
  return v46;
}

int8x16_t sub_100027AB0(const void *a1, CC_LONG a2, uint64_t a3)
{
  memset(&v8, 0, sizeof(v8));
  CC_SHA256_Init(&v8);
  CC_SHA256_Update(&v8, a1, a2);
  for (uint64_t i = 0; i != 8; i += 4)
  {
    int8x16_t result = vrev32q_s8(*(int8x16_t *)&v8.hash[i]);
    *(int8x16_t *)(a3 + i * 4) = result;
  }
  return result;
}

uint64_t AMAuthInstallMonetMeasureAmss(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"AMSS-HashTableDigest", @"AMSS-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureApps(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"APPS-HashTableDigest", @"APPS-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureDsp1(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"DSP1-HashTableDigest", @"DSP1-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureQdsp6(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"QDSP6SW-HashTableDigest", @"QDSP6SW-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureRpmElf(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"RPM-HashTableDigest", @"RPM-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureDsp2(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"DSP2-HashTableDigest", @"DSP2-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureDsp3(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"DSP3-HashTableDigest", @"DSP3-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureTz(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"TZ-HashTableDigest", @"TZ-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureMba(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"MBA-HashTableDigest", @"MBA-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureWdtElf(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElf(a1, a2, a3, @"WDT-HashTableDigest", @"WDT-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureSbl1(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureBootSbl(a1, a2, a3, @"SBL1-Version", @"SBL1-PartialDigest");
}

uint64_t AMAuthInstallMonetMeasureBootSbl(void *a1, CFDataRef theData, __CFDictionary *a3, const void *a4, const void *a5)
{
  BytePtr = CFDataGetBytePtr(theData);
  uint64_t v11 = CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  if (Length <= 3)
  {
    AMAuthInstallLog(7, (uint64_t)"_FindSbl1HeaderInFileData", (uint64_t)"foundMagic=%d", v13, v14, v15, v16, v17, 0);
LABEL_3:
    uint64_t v23 = "_FindSbl1HeaderInFileData";
    int v24 = "this file lacks sufficient magic";
    goto LABEL_4;
  }
  char v26 = 0;
  CFIndex v27 = 0;
  unsigned int v28 = Length >> 2;
  CFAllocatorRef v29 = v11 - 4;
  do
  {
    if (*((_DWORD *)v29 + 1) == 1943474228)
    {
      ++v26;
      CFIndex v27 = v29;
      if (*((_DWORD *)v29 + 2) != 2097890138)
      {
        AMAuthInstallLog(7, (uint64_t)"_FindSbl1HeaderInFileData", (uint64_t)"found SBL header", v13, v14, v15, v16, v17, v35);
        AMAuthInstallLog(7, (uint64_t)"_FindSbl1HeaderInFileData", (uint64_t)"foundMagic=%d", v30, v31, v32, v33, v34, v26);
        CFIndex v27 = v29;
        goto LABEL_13;
      }
    }
    v29 += 4;
    --v28;
  }
  while (v28);
  AMAuthInstallLog(7, (uint64_t)"_FindSbl1HeaderInFileData", (uint64_t)"foundMagic=%d", v13, v14, v15, v16, v17, v26);
  if (!v27) {
    goto LABEL_3;
  }
LABEL_13:
  if ((unint64_t)CFDataGetLength(theData) < 0x50
    || *((_DWORD *)v27 + 7) > CFDataGetLength(theData))
  {
    return 10;
  }
  uint64_t v20 = *((unsigned int *)v27 + 5);
  if (v27 + 80 != &BytePtr[v20])
  {
    uint64_t v23 = "AMAuthInstallMonetMeasureBootSbl";
    int v24 = "junk following sbl1 header";
LABEL_4:
    AMAuthInstallLog(3, (uint64_t)v23, (uint64_t)v24, v18, v19, v20, v21, v22, v36);
    return 10;
  }
  return AMAuthInstallMonetSetVersionAndPartialDigestForSBL(a1, a3, (uint64_t)BytePtr, theData, v27, v20, *((_DWORD *)v27 + 8), a4, a5);
}

uint64_t AMAuthInstallMonetMeasureRestoreSbl1(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureBootSbl(a1, a2, a3, @"RestoreSBL1-Version", @"RestoreSBL1-PartialDigest");
}

uint64_t AMAuthInstallMonetMeasureSbl1Elf(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElfMBN(a1, a2, a3, @"SBL1-HashTableDigest", @"SBL1-PartialDigest");
}

uint64_t AMAuthInstallMonetMeasureRestoreSbl1Elf(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureElfMBN(a1, a2, a3, @"RestoreSBL1-HashTableDigest", @"RestoreSBL1-PartialDigest");
}

uint64_t AMAuthInstallMonetMeasureMav20Sbl1Elf(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureMav20ElfMBN(a1, a2, a3, @"SBL1-HashTableBody", @"SBL1-PartialDigest", @"SBL1-HashTableHeaderDefault");
}

uint64_t AMAuthInstallMonetMeasureMav20MiscElf(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureMav20ElfMBN(a1, a2, a3, @"Misc-HashTableBody", @"Misc-PartialDigest", @"Misc-HashTableHeaderDefault");
}

uint64_t AMAuthInstallMonetMeasureMav20RestoreSbl1Elf(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureMav20ElfMBN(a1, a2, a3, @"RestoreSBL1-HashTableBody", @"RestoreSBL1-PartialDigest", @"RestoreSBL1-HashTableHeaderDefault");
}

uint64_t AMAuthInstallMonetSetVersionAndPartialDigestForSBL(void *a1, __CFDictionary *a2, uint64_t a3, CFDataRef theData, const void *a5, unsigned int a6, int a7, const void *a8, const void *a9)
{
  uint64_t v53 = 0;
  int v55 = 0;
  int8x16_t v54 = 0uLL;
  uint64_t v52 = 0;
  *(_OWORD *)bytes = 0u;
  long long v51 = 0u;
  uint64_t v49 = 0;
  memset(v48, 0, sizeof(v48));
  int v13 = *(_DWORD *)(a1[6] + 4);
  int v14 = 128;
  if (v13 <= 1515744)
  {
    BOOL v15 = v13 == 520417 || v13 == 938209;
    int v16 = 1327329;
  }
  else if (v13 > 2089184)
  {
    BOOL v15 = v13 == 2089185;
    int v16 = 2814177;
  }
  else
  {
    BOOL v15 = v13 == 1515745;
    int v16 = 1700065;
  }
  if (!v15 && v13 != v16) {
    int v14 = 64;
  }
  CFNumberRef v18 = 0;
  int valuePtr = 0;
  uint64_t v19 = 1;
  if (!a2 || !a3 || !theData || !a5 || !a8)
  {
    CFDataRef v20 = 0;
    goto LABEL_43;
  }
  CFDataRef v20 = 0;
  if (a9)
  {
    uint64_t v21 = a3 + a6;
    int v22 = *(_DWORD *)(v21 + 8);
    int valuePtr = *(_DWORD *)(v21 + 4);
    char Length = CFDataGetLength(theData);
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetSetVersionAndPartialDigestForSBL", (uint64_t)"fileSize=0x%x, srcOffset=0x%x, codeSize=0x%x", v24, v25, v26, v27, v28, Length);
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetSetVersionAndPartialDigestForSBL", (uint64_t)"version=0x%x, personalizationOffset=0x%x", v29, v30, v31, v32, v33, valuePtr);
    LODWORD(v53) = a7 - v22;
    HIDWORD(v53) = v22 + 80;
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallMonetSetVersionAndPartialDigestForSBL", (uint64_t)"reservationLength=0x%x, codeBytesHashed=0x%x (%s) byte_multiple=%d", v34, v35, v36, v37, v38, a7 - v22);
    if (((v22 + 80) & (v14 - 1)) != 0)
    {
      CFNumberRef v18 = 0;
      CFDataRef v20 = 0;
      uint64_t v19 = 10;
      goto LABEL_43;
    }
    int v39 = *(_DWORD *)(a1[6] + 4);
    if (v39 <= 1700064)
    {
      if (v39 > 938208)
      {
        if (v39 == 938209 || v39 == 1327329) {
          goto LABEL_38;
        }
        int v40 = 1515745;
        goto LABEL_37;
      }
      if (v39 != 241889)
      {
        int v40 = 520417;
        goto LABEL_37;
      }
    }
    else
    {
      if (v39 <= 8343776)
      {
        if (v39 == 1700065 || v39 == 2089185) {
          goto LABEL_38;
        }
        int v40 = 2814177;
LABEL_37:
        if (v39 == v40)
        {
LABEL_38:
          *(_DWORD *)bytes = a7 - v22;
          *(_DWORD *)&UInt8 bytes[4] = v22 + 80;
          sub_1000275C8(a5, 0, (uint64_t)v48 + 8);
          CFAllocatorRef v41 = CFGetAllocator(a1);
          CFDataRef v42 = (UInt8 *)v48;
          CFIndex v43 = 72;
          goto LABEL_40;
        }
        goto LABEL_44;
      }
      if (v39 != 8343777 && v39 != 9781473 && v39 != 9572577)
      {
LABEL_44:
        sub_100016080(a5, v22 + 80, &v54);
        CFAllocatorRef v41 = CFGetAllocator(a1);
        CFDataRef v42 = (UInt8 *)&v53;
        CFIndex v43 = 28;
LABEL_40:
        CFDataRef v20 = CFDataCreate(v41, v42, v43);
        if (v20)
        {
          CFAllocatorRef v44 = CFGetAllocator(a1);
          CFNumberRef v18 = CFNumberCreate(v44, kCFNumberSInt32Type, &valuePtr);
          if (v18)
          {
            CFDictionarySetValue(a2, a8, v18);
            CFDictionarySetValue(a2, a9, v20);
            uint64_t v19 = 0;
            goto LABEL_43;
          }
        }
        else
        {
          CFNumberRef v18 = 0;
        }
        uint64_t v19 = 2;
        goto LABEL_43;
      }
    }
    *(_DWORD *)bytes = a7 - v22;
    *(_DWORD *)&UInt8 bytes[4] = v22 + 80;
    sub_100027AB0(a5, v22 + 80, (uint64_t)&bytes[8]);
    CFAllocatorRef v41 = CFGetAllocator(a1);
    CFDataRef v42 = bytes;
    CFIndex v43 = 40;
    goto LABEL_40;
  }
LABEL_43:
  SafeRelease(v18);
  SafeRelease(v20);
  return v19;
}

uint64_t AMAuthInstallMonetMeasureSbl2(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureBootImage(a1, a2, a3, @"SBL2-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureAcdb(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureBootImage(a1, a2, a3, @"ACDB-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureWdt(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureBootImage(a1, a2, a3, @"WDT-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureBBCFG(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureBootImage(a1, a2, a3, @"BBCFG-DownloadDigest");
}

uint64_t AMAuthInstallMonetMeasureRPM(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallMonetMeasureBootImage(a1, a2, a3, @"RPM-DownloadDigest");
}

uint64_t AMAuthInstallMonetStitchCopyIfPersonalized(uint64_t a1, CFTypeRef cf, uint64_t a3, void *a4)
{
  if (!a1) {
    return 1;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  if (!v4) {
    return 1;
  }
  if (!*(void *)(v4 + 24)) {
    return 0;
  }
  CFTypeRef v6 = CFRetain(cf);
  uint64_t result = 0;
  *a4 = v6;
  return result;
}

uint64_t AMAuthInstallMonetMeasurePartitionTable(const void *a1, const __CFData *a2, __CFDictionary *a3)
{
  memset(&v13, 0, sizeof(v13));
  CFAllocatorRef v5 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFDataCreateMutable(v5, 20);
  uint64_t v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, 20);
    CC_SHA1_Init(&v13);
    BytePtr = CFDataGetBytePtr(a2);
    CC_LONG Length = CFDataGetLength(a2);
    CC_SHA1_Update(&v13, BytePtr, Length);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    CC_SHA1_Final(MutableBytePtr, &v13);
    CFDictionarySetValue(a3, @"PartitionTable-Digest", v7);
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = 2;
  }
  SafeRelease(v7);
  return v11;
}

uint64_t AMAuthInstallMonetStitchPartitionTable(uint64_t a1, CFTypeRef cf, uint64_t a3, void *a4)
{
  if (!a1) {
    return 1;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  if (!v4) {
    return 1;
  }
  if (!*(void *)(v4 + 24)) {
    return 0;
  }
  CFTypeRef v6 = CFRetain(cf);
  uint64_t result = 0;
  *a4 = v6;
  return result;
}

uint64_t AMAuthInstallMonetFuseIfNecessary(uint64_t a1, const void *a2, __CFDictionary *a3)
{
  uint64_t v3 = a1;
  char v55 = 0;
  CFErrorRef error = 0;
  CFDictionaryRef theDict = 0;
  if (!a1)
  {
    uint64_t v36 = 0;
    goto LABEL_26;
  }
  if (!*(void *)(a1 + 48))
  {
LABEL_25:
    uint64_t v36 = 0;
    uint64_t v3 = 0;
LABEL_26:
    CFDataRef v25 = 0;
    uint64_t v35 = 1;
    goto LABEL_36;
  }
  uint64_t IsFused = AMAuthInstallBasebandIsFused(a1, &v55);
  if (IsFused)
  {
LABEL_37:
    uint64_t v35 = IsFused;
    goto LABEL_35;
  }
  if (v55 && *(_DWORD *)(*(void *)(v3 + 48) + 96) != 2)
  {
    if (*(void *)(v3 + 176))
    {
      CFAllocatorRef v19 = CFGetAllocator((CFTypeRef)v3);
      CFDataRef v25 = CFPropertyListCreateData(v19, *(CFPropertyListRef *)(v3 + 176), kCFPropertyListXMLFormat_v1_0, 0, &error);
      if (v25)
      {
        CFDictionarySetValue(a3, @"fusingprogram.plist", v25);
LABEL_22:
        uint64_t v35 = 0;
LABEL_23:
        uint64_t v36 = 0;
        uint64_t v3 = 0;
        goto LABEL_36;
      }
      long long v51 = "failed to convert fusing program to xml";
LABEL_41:
      uint64_t v35 = 3;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetFuseIfNecessary", (uint64_t)v51, v20, v21, v22, v23, v24, v52);
      goto LABEL_23;
    }
    uint64_t v35 = 0;
LABEL_35:
    uint64_t v36 = 0;
    uint64_t v3 = 0;
    CFDataRef v25 = 0;
    goto LABEL_36;
  }
  if (*(void *)(v3 + 424))
  {
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)v3);
    CFBooleanRef ValueForKeyWithFormat = AMAuthInstallSupportGetValueForKeyWithFormat(v12, *(const __CFDictionary **)(v3 + 424), @"%@.%@", v13, v14, v15, v16, v17, (char)@"BbRequestEntries");
    if (!ValueForKeyWithFormat) {
      goto LABEL_24;
    }
  }
  else
  {
    CFBooleanRef ValueForKeyWithFormat = kCFBooleanFalse;
    if (!kCFBooleanFalse)
    {
LABEL_24:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetFuseIfNecessary", (uint64_t)"baseband fusing is being attempted but the Factory Debug entitlement was not requested. Please enable Factory Debug to fuse.", v7, v8, v9, v10, v11, v52);
      goto LABEL_25;
    }
  }
  if (!CFBooleanGetValue(ValueForKeyWithFormat)) {
    goto LABEL_24;
  }
  if (!*(unsigned char *)(v3 + 185))
  {
    if (*(unsigned char *)(v3 + 184))
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetFuseIfNecessary", (uint64_t)"fusing program request prohibited", v7, v8, v9, v10, v11, v52);
      goto LABEL_46;
    }
    uint64_t IsFused = AMAuthInstallFusingProgramRequest((void *)v3, v26, v27, v7, v8, v9, v10, v11);
    if (IsFused) {
      goto LABEL_37;
    }
  }
  if (!*(void *)(v3 + 176))
  {
LABEL_46:
    uint64_t v36 = 0;
    uint64_t v3 = 0;
    CFDataRef v25 = 0;
    uint64_t v35 = 14;
    goto LABEL_36;
  }
  CFAllocatorRef v28 = CFGetAllocator((CFTypeRef)v3);
  CFDataRef v25 = CFPropertyListCreateData(v28, *(CFPropertyListRef *)(v3 + 176), kCFPropertyListXMLFormat_v1_0, 0, &error);
  if (!v25)
  {
    char v52 = (char)error;
    long long v51 = "failed to convert fusing program to xml %@";
    goto LABEL_41;
  }
  CFDictionarySetValue(a3, @"fusingprogram.plist", v25);
  SafeRelease(error);
  uint64_t v34 = *(void *)(v3 + 48);
  if (*(void *)(v34 + 24) && *(void *)(v34 + 16))
  {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallMonetFuseIfNecessary", (uint64_t)"baseband appears to be unfused and booted; will provide fusing program and fully personalized stack",
      v29,
      v30,
      v31,
      v32,
      v33,
      v52);
    goto LABEL_22;
  }
  CFAllocatorRef v37 = CFGetAllocator((CFTypeRef)v3);
  uint64_t DictionaryFromURL = BbfwCreateDictionaryFromURL(v37, a2, (CFTypeRef *)&theDict);
  if (DictionaryFromURL)
  {
    uint64_t v35 = DictionaryFromURL;
    goto LABEL_23;
  }
  CFIndex Count = CFDictionaryGetCount(theDict);
  uint64_t v36 = (const void **)malloc(8 * Count);
  if (!v36)
  {
    uint64_t v3 = 0;
    goto LABEL_44;
  }
  uint64_t v3 = (uint64_t)malloc(8 * Count);
  if (!v3)
  {
LABEL_44:
    uint64_t v35 = 2;
    goto LABEL_36;
  }
  CFDictionaryGetKeysAndValues(theDict, v36, (const void **)v3);
  if (Count >= 1)
  {
    CFDataRef v45 = v36;
    uint64_t v46 = (const void **)v3;
    do
    {
      CC_LONG v48 = *v45++;
      uint64_t v47 = v48;
      uint64_t v49 = *v46++;
      CFDictionarySetValue(a3, v47, v49);
      --Count;
    }
    while (Count);
  }
  AMAuthInstallLog(5, (uint64_t)"AMAuthInstallMonetFuseIfNecessary", (uint64_t)"baseband appears to be unfused and unbootable; will provide fusing program and unpersonalized stack",
    v40,
    v41,
    v42,
    v43,
    v44,
    v52);
  uint64_t v35 = 0;
LABEL_36:
  SafeRelease(v25);
  SafeRelease(theDict);
  SafeRelease(0);
  SafeFree(v36);
  SafeFree((void *)v3);
  SafeRelease(error);
  return v35;
}

uint64_t AMAuthInstallMonetCopyNextComponentName(uint64_t a1, void *a2)
{
  char v8 = 0;
  if (!a1 || !*(void *)(a1 + 48)) {
    return 1;
  }
  uint64_t result = AMAuthInstallBasebandIsFused(a1, &v8);
  if (!result)
  {
    if (v8) {
      CFStringRef v5 = @"boot.bbfw";
    }
    else {
      CFStringRef v5 = @"preflash.bbfw";
    }
    if (*(void *)(*(void *)(a1 + 48) + 24)) {
      CFStringRef v6 = @"stack.bbfw";
    }
    else {
      CFStringRef v6 = v5;
    }
    CFTypeRef v7 = CFRetain(v6);
    uint64_t result = 0;
    *a2 = v7;
  }
  return result;
}

uint64_t AMAuthInstallMonetCreateReversedMEID(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3)
{
  CFIndex Length = CFDataGetLength(theData);
  CFDataRef v7 = 0;
  uint64_t v8 = 1;
  if (theData && Length == 7)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 6;
    do
      bytes[v10--] = CFDataGetBytePtr(theData)[v9++];
    while (v9 != 7);
    CFDataRef v11 = CFDataCreate(a1, bytes, 7);
    CFDataRef v7 = v11;
    if (v11)
    {
      uint64_t v8 = 0;
      *a3 = CFRetain(v11);
    }
    else
    {
      uint64_t v8 = 2;
    }
  }
  SafeRelease(v7);
  return v8;
}

uint64_t AMAuthInstallMonetCreateMEIDFromString(int a1, CFStringRef theString, CFTypeRef *a3)
{
  CFStringRef v4 = theString;
  CFTypeRef cf = 0;
  if (CFStringGetLength(theString) == 15)
  {
    v15.CFIndex length = CFStringGetLength(v4) - 1;
    v15.CFIndex location = 0;
    CFStringRef v5 = CFStringCreateWithSubstring(kCFAllocatorDefault, v4, v15);
    CFStringRef v4 = v5;
  }
  else
  {
    CFStringRef v5 = 0;
  }
  uint64_t v6 = AMAuthInstallSupportCopyDataFromHexString((int)kCFAllocatorDefault, v4, (uint64_t *)&cf);
  if (v6)
  {
    uint64_t v12 = v6;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetCreateMEIDFromString", (uint64_t)"failed to convert meid (%@) to data", v7, v8, v9, v10, v11, (char)v4);
  }
  else if (cf)
  {
    uint64_t v12 = 0;
    *a3 = CFRetain(cf);
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetCreateMEIDFromString", (uint64_t)"meid (%@) tempData is NULL", v7, v8, v9, v10, v11, (char)v4);
    uint64_t v12 = 14;
  }
  SafeRelease(v5);
  SafeRelease(cf);
  return v12;
}

uint64_t AMAuthInstallMonetCreateReversedMEIDFromString(int a1, const __CFString *a2, CFTypeRef *a3)
{
  char v4 = (char)a2;
  CFDataRef theData = 0;
  CFDataRef v27 = 0;
  uint64_t MEIDFromString = AMAuthInstallMonetCreateMEIDFromString(a1, a2, (CFTypeRef *)&v27);
  if (MEIDFromString)
  {
    uint64_t v24 = MEIDFromString;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetCreateReversedMEIDFromString", (uint64_t)"failed to convert meid (%@) to data", v6, v7, v8, v9, v10, v4);
    CFDataRef v18 = 0;
    CFDataRef v11 = v27;
    goto LABEL_6;
  }
  CFDataRef v11 = v27;
  if (!v27)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetCreateReversedMEIDFromString", (uint64_t)"meid (%@) tempData is NULL", v6, v7, v8, v9, v10, v4);
    CFDataRef v18 = 0;
LABEL_11:
    uint64_t v24 = 14;
    goto LABEL_6;
  }
  uint64_t ReversedMEID = AMAuthInstallMonetCreateReversedMEID(kCFAllocatorDefault, v27, (CFTypeRef *)&theData);
  if (ReversedMEID)
  {
    uint64_t v24 = ReversedMEID;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetCreateReversedMEIDFromString", (uint64_t)"failed to reverse meid (%@)", v13, v14, v15, v16, v17, v4);
    CFDataRef v18 = theData;
    goto LABEL_6;
  }
  CFDataRef v18 = theData;
  if (!theData)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallMonetCreateReversedMEIDFromString", (uint64_t)"meid (%@) reversedData is NULL", v13, v14, v15, v16, v17, v4);
    goto LABEL_11;
  }
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(v18);
  AMAuthInstallLogDumpMemory(7, (uint64_t)"AMAuthInstallMonetCreateReversedMEIDFromString", (char)"reversed meid", (uint64_t)BytePtr, Length, v21, v22, v23);
  uint64_t v24 = 0;
  *a3 = CFRetain(v18);
LABEL_6:
  SafeRelease(0);
  SafeRelease(v11);
  SafeRelease(v18);
  return v24;
}

uint64_t AMAuthInstallMonetLocalHandleRequest()
{
  return 13;
}

uint64_t AMAuthInstallMaverickLocalCreateRootTicket()
{
  return 13;
}

uint64_t AMAuthInstallMonetLocalProvisionDevice()
{
  return 13;
}

uint64_t AMAuthInstallMonetLocalSetProvisioningManifestInfo()
{
  return 13;
}

uint64_t AMAuthInstallMonetLocalSupportsLocalSigning()
{
  return 1;
}

uint64_t AMAuthInstallMonetLocalProvisionV2Device()
{
  return 13;
}

uint64_t AMAuthInstallPlatformCreateSoftLink(const __CFURL *a1, CFURLRef url)
{
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024)
    || !CFURLGetFileSystemRepresentation(a1, 1u, v16, 1024))
  {
    return 3;
  }
  uint64_t result = symlink((const char *)buffer, (const char *)v16);
  if (result)
  {
    char v4 = __error();
    char v5 = strerror(*v4);
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformCreateSoftLink", (uint64_t)"failed to create link: %s", v6, v7, v8, v9, v10, v5);
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformCreateSoftLink", (uint64_t)"source path: %s; dest path: %s",
      v11,
      v12,
      v13,
      v14,
      v15,
      (char)buffer);
    return 4;
  }
  return result;
}

char *AMAuthInstallPlatformMakeDirectoryForURL(const __CFURL *a1)
{
  strcpy(__delim, "/");
  bzero(__str, 0x400uLL);
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024)) {
    return (char *)3;
  }
  size_t v2 = strlen((const char *)buffer);
  if (!CFURLHasDirectoryPath(a1))
  {
    if (v2)
    {
      do
      {
        size_t v3 = v2 - 1;
        BOOL v4 = __delim[v2 + 1] == 47 || v2 == 1;
        --v2;
      }
      while (!v4);
    }
    else
    {
      size_t v3 = 0;
    }
    buffer[v3] = 0;
  }
  __stringp = (char *)buffer;
  uint64_t result = strsep(&__stringp, __delim);
  if (result)
  {
    uint64_t v6 = "Could not stat (%s)";
    while (1)
    {
      memset(&v19, 0, sizeof(v19));
      if (*result)
      {
        snprintf(__str, 0x400uLL, "%s%c%s", __str, 47, result);
        if (stat(__str, &v19) == -1)
        {
          if (*__error() != 2) {
            goto LABEL_23;
          }
          if (mkdir(__str, 0x1EDu) == -1 && *__error() != 17) {
            break;
          }
        }
      }
      uint64_t result = strsep(&__stringp, __delim);
      if (!result) {
        return result;
      }
    }
    uint64_t v6 = "Could not mkdir (%s)";
LABEL_23:
    uint64_t v7 = __error();
    char v8 = strerror(*v7);
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformMakeDirectoryForURL", (uint64_t)v6, v9, v10, v11, v12, v13, v8);
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformMakeDirectoryForURL", (uint64_t)"%s", v14, v15, v16, v17, v18, (char)__str);
    return (char *)4;
  }
  return result;
}

uint64_t AMAuthInstallPlatformRemoveDirectory(const __CFURL *a1)
{
  char v1 = (char)a1;
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024)) {
    return 3;
  }
  int v17 = 0;
  size_t v2 = &v17;
  uint64_t v3 = sub_100029034((const char *)buffer, &v17);
  if (v3)
  {
    uint64_t v4 = v3;
  }
  else
  {
    if (!rmdir((const char *)buffer)) {
      return 0;
    }
    uint64_t v4 = 4;
    size_t v2 = __error();
  }
  char v5 = strerror(*v2);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformRemoveDirectory", (uint64_t)"failed to remove directory: %s", v6, v7, v8, v9, v10, v5);
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformRemoveDirectory", (uint64_t)"url=%@, path=%s", v11, v12, v13, v14, v15, v1);
  return v4;
}

uint64_t sub_100029034(const char *a1, int *a2)
{
  uint64_t v4 = opendir(a1);
  if (!v4) {
    goto LABEL_13;
  }
  char v5 = v4;
  for (uint64_t i = readdir(v4); i; uint64_t i = readdir(v5))
  {
    d_name = i->d_name;
    if (strncmp(i->d_name, ".", 0x400uLL))
    {
      if (strncmp(d_name, "..", 0x400uLL))
      {
        snprintf(__str, 0x400uLL, "%s%c%s", a1, 47, d_name);
        memset(&v9, 0, sizeof(v9));
        if (!lstat(__str, &v9))
        {
          if ((v9.st_mode & 0x4000) != 0)
          {
            if (sub_100029034(__str, a2)) {
              return 4;
            }
            if (rmdir(__str)) {
              goto LABEL_13;
            }
          }
          else if (unlink(__str))
          {
            goto LABEL_13;
          }
        }
      }
    }
  }
  uint64_t result = closedir(v5);
  if (result)
  {
LABEL_13:
    *a2 = *__error();
    return 4;
  }
  return result;
}

uint64_t AMAuthInstallPlatformRemoveFile(const __CFURL *a1)
{
  char v1 = (char)a1;
  if (!CFURLGetFileSystemRepresentation(a1, 1u, (UInt8 *)buffer, 1024)) {
    return 3;
  }
  uint64_t result = remove(buffer, v2);
  if (result)
  {
    uint64_t v4 = __error();
    char v5 = strerror(*v4);
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformRemoveFile", (uint64_t)"failed to file: %s", v6, v7, v8, v9, v10, v5);
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformRemoveFile", (uint64_t)"url=%@, path=%s", v11, v12, v13, v14, v15, v1);
    return 4;
  }
  return result;
}

uint64_t AMAuthInstallPlatformCopyURLToNewTempDirectory(const __CFAllocator *a1, const char *a2, CFURLRef *a3)
{
  uint64_t result = 1;
  if (a2 && a3)
  {
    char v6 = (char)a2;
    snprintf(__str, 0x400uLL, "/tmp/%s", a2);
    if (mkdtemp(__str))
    {
      size_t v7 = strlen(__str);
      CFURLRef v8 = CFURLCreateFromFileSystemRepresentation(a1, (const UInt8 *)__str, v7, 1u);
      if (v8)
      {
        CFURLRef v9 = v8;
        uint64_t result = 0;
        *a3 = v9;
      }
      else
      {
        unlink(__str);
        return 2;
      }
    }
    else
    {
      uint64_t v10 = __error();
      char v11 = strerror(*v10);
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformCopyURLToNewTempDirectory", (uint64_t)"failed to create tmp dir: %s", v12, v13, v14, v15, v16, v11);
      AMAuthInstallLog(8, (uint64_t)"AMAuthInstallPlatformCopyURLToNewTempDirectory", (uint64_t)"tmp dir template: %s", v17, v18, v19, v20, v21, v6);
      return 4;
    }
  }
  return result;
}

uint64_t AMAuthInstallPlatformWriteBufferToNativeFilePath(char *a1, int a2, char *a3)
{
  int v6 = open(a3, 1537, 420);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    if (a2 < 1)
    {
LABEL_6:
      close(v7);
      return 0;
    }
    int v8 = 0;
    int v9 = a2;
    while (1)
    {
      int v10 = write(v7, a1, v9);
      if (v10 <= 0) {
        break;
      }
      a1 += v10;
      v9 -= v10;
      v8 += v10;
      if (v8 >= a2) {
        goto LABEL_6;
      }
    }
    close(v7);
    unlink(a3);
  }
  uint64_t v12 = __error();
  char v13 = strerror(*v12);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformWriteBufferToNativeFilePath", (uint64_t)"failed to open file for writing: %s", v14, v15, v16, v17, v18, v13);
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformWriteBufferToNativeFilePath", (uint64_t)"path: %s", v19, v20, v21, v22, v23, (char)a3);
  return 4;
}

uint64_t AMAuthInstallPlatformWriteDataToFileURL(const __CFData *a1, CFURLRef url)
{
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024)) {
    return 3;
  }
  BytePtr = (char *)CFDataGetBytePtr(a1);
  int Length = CFDataGetLength(a1);
  return AMAuthInstallPlatformWriteBufferToNativeFilePath(BytePtr, Length, (char *)buffer);
}

uint64_t AMAuthInstallPlatformCopyURLWithAppendedComponent(const __CFAllocator *a1, CFTypeRef cf, const __CFString *a3, Boolean a4, CFURLRef *a5)
{
  if (!cf) {
    return 1;
  }
  CFTypeID v10 = CFGetTypeID(cf);
  CFTypeID v11 = CFURLGetTypeID();
  uint64_t result = 1;
  if (a5 && a3 && v10 == v11)
  {
    CFURLRef v13 = CFURLCreateCopyAppendingPathComponent(a1, (CFURLRef)cf, a3, a4);
    if (v13)
    {
      CFURLRef v14 = v13;
      uint64_t result = 0;
      *a5 = v14;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t AMAuthInstallPlatformFileURLExists(const __CFURL *a1, BOOL *a2)
{
  uint64_t v2 = 1;
  if (a1 && a2)
  {
    memset(&v6, 0, sizeof(v6));
    if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    {
      int v4 = stat((const char *)buffer, &v6);
      uint64_t v2 = 0;
      *a2 = v4 == 0;
    }
    else
    {
      return 3;
    }
  }
  return v2;
}

uint64_t AMAuthInstallPlatformCreateBufferFromNativeFilePath(void *a1, off_t *a2, char *a3)
{
  char v3 = (char)a3;
  memset(&v55, 0, sizeof(v55));
  int v6 = open(a3, 0, 0);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    if (fstat(v6, &v55) < 0)
    {
      uint64_t v24 = __error();
      char v25 = strerror(*v24);
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformCreateBufferFromNativeFilePath", (uint64_t)"fstat failed: %s", v26, v27, v28, v29, v30, v25);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformCreateBufferFromNativeFilePath", (uint64_t)"%s", v31, v32, v33, v34, v35, v3);
    }
    else
    {
      off_t st_size = v55.st_size;
      int v9 = malloc(v55.st_size);
      if (!v9)
      {
        uint64_t v36 = __error();
        strerror(*v36);
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformCreateBufferFromNativeFilePath", (uint64_t)"malloc(%d) failed: %s", v37, v38, v39, v40, v41, st_size);
        uint64_t v11 = 2;
        goto LABEL_11;
      }
      CFTypeID v10 = v9;
      if (read(v7, v9, st_size) == st_size)
      {
        uint64_t v11 = 0;
        *a1 = v10;
        *a2 = st_size;
LABEL_11:
        close(v7);
        return v11;
      }
      uint64_t v42 = __error();
      char v43 = strerror(*v42);
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformCreateBufferFromNativeFilePath", (uint64_t)"read failed: %s", v44, v45, v46, v47, v48, v43);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformCreateBufferFromNativeFilePath", (uint64_t)"%s", v49, v50, v51, v52, v53, v3);
      free(v10);
    }
    uint64_t v11 = 4;
    goto LABEL_11;
  }
  uint64_t v12 = __error();
  char v13 = strerror(*v12);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformCreateBufferFromNativeFilePath", (uint64_t)"open failed: %s", v14, v15, v16, v17, v18, v13);
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformCreateBufferFromNativeFilePath", (uint64_t)"%s", v19, v20, v21, v22, v23, v3);
  return 4;
}

uint64_t AMAuthInstallPlatformCreateDataFromFileURL(const __CFAllocator *a1, CFTypeRef *a2, const __CFURL *a3)
{
  bzero(buffer, 0x400uLL);
  CFAllocatorRef v6 = AMAuthInstallSupportCopyAllocator();
  if (CFURLGetFileSystemRepresentation(a3, 1u, buffer, 1024))
  {
    off_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v7 = AMAuthInstallPlatformCreateBufferFromNativeFilePath(&v14, &v13, (char *)buffer);
    if (v7)
    {
      uint64_t v11 = v7;
      CFDataRef v10 = 0;
    }
    else
    {
      int v8 = v14;
      CFDataRef v9 = CFDataCreateWithBytesNoCopy(a1, v14, v13, v6);
      CFDataRef v10 = v9;
      if (v9)
      {
        uint64_t v11 = 0;
        *a2 = CFRetain(v9);
      }
      else
      {
        free(v8);
        uint64_t v11 = 2;
      }
    }
  }
  else
  {
    CFDataRef v10 = 0;
    uint64_t v11 = 3;
  }
  SafeRelease(v6);
  SafeRelease(v10);
  return v11;
}

FILE *AMAuthInstallPlatformOpenFileStreamWithURL(const __CFURL *a1, const char *a2)
{
  char v3 = (char)a1;
  if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024)) {
    return fopen((const char *)buffer, a2);
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformOpenFileStreamWithURL", (uint64_t)"failed to convert url to file system representation", v4, v5, v6, v7, v8, v15);
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformOpenFileStreamWithURL", (uint64_t)"%@", v10, v11, v12, v13, v14, v3);
  return 0;
}

uint64_t AMAuthInstallPlatformGetURLForTempDirectoryRoot()
{
  return qword_1000B8C90;
}

CFStringRef sub_100029A6C()
{
  qword_1000B8C90 = (uint64_t)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, @"/tmp", kCFURLPOSIXPathStyle, 1u);
  if (!qword_1000B8C90) {
    sub_100072128();
  }
  size_t v1 = 32;
  CFStringRef result = (const __CFString *)sysctlbyname("kern.osversion", v3, &v1, 0, 0);
  if (!result)
  {
    size_t v1 = 32;
    if (!sysctlbyname("hw.product", v2, &v1, 0, 0)
      || (CFStringRef result = (const __CFString *)sysctlbyname("hw.machine", v2, &v1, 0, 0), !result))
    {
      CFStringRef result = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"mac/%s/%s", v3, v2);
      if (result) {
        goto LABEL_6;
      }
    }
  }
  if (!qword_1000B8C98)
  {
    CFStringRef result = @"???";
LABEL_6:
    qword_1000B8C98 = (uint64_t)result;
  }
  return result;
}

uint64_t AMAuthInstallPlatformGetPlatformInfoString()
{
  return qword_1000B8C98;
}

CFStringRef AMAuthInstallPlatformGetSimplePlatformInfoString()
{
  return @"iOS";
}

uint64_t AMAuthInstallProvisioningCopyResponse(const __CFAllocator *a1, CFDataRef theData, void *a3, CFTypeRef *a4)
{
  CFDataRef theDataa = 0;
  long long v169 = 0u;
  memset(v170, 0, sizeof(v170));
  *(_OWORD *)buffer = 0u;
  long long v168 = 0u;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  CFStringRef v10 = CFStringCreateWithBytes(a1, BytePtr, Length, 0x8000100u, 0);
  CFStringRef v16 = v10;
  if (!v10)
  {
    CFMutableDictionaryRef Mutable = 0;
    CFArrayRef v24 = 0;
    CFNumberRef NumberFromString = 0;
    uint64_t v152 = 0;
    uint64_t v159 = 3;
    goto LABEL_52;
  }
  AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"Response:%@", v11, v12, v13, v14, v15, (char)v10);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFArrayRef v24 = 0;
    goto LABEL_65;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v16, @"&");
  CFArrayRef v24 = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings)
  {
    CFIndex v161 = "responseParts is NULL";
    goto LABEL_62;
  }
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  if (!Count)
  {
    CFIndex v161 = "arrayCount is 0";
    goto LABEL_62;
  }
  CFIndex v26 = Count;
  uint64_t v163 = a4;
  CFStringRef v164 = v16;
  CFDictionaryRef theDict = Mutable;
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != v26; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v24, i);
      CFIndex location = CFStringFind(ValueAtIndex, @"=", 0).location;
      if (location == -1)
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"could not split parameter: %@", v30, v31, v32, v33, v34, (char)ValueAtIndex);
      }
      else
      {
        CFIndex v35 = location;
        CFArrayRef v36 = v24;
        CFIndex v37 = location + 1;
        CFIndex v38 = CFStringGetLength(ValueAtIndex) + ~location;
        v172.CFIndex location = 0;
        v172.CFIndex length = v35;
        CFStringRef v39 = CFStringCreateWithSubstring(a1, ValueAtIndex, v172);
        v173.CFIndex location = v37;
        v173.CFIndex length = v38;
        CFStringRef v40 = CFStringCreateWithSubstring(a1, ValueAtIndex, v173);
        CFStringRef v46 = v40;
        if (v39 && v40) {
          CFDictionarySetValue(theDict, v39, v40);
        }
        else {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"failed to create key(%@) or value (%@)", v41, v42, v43, v44, v45, (char)v39);
        }
        SafeRelease(v39);
        SafeRelease(v46);
        CFArrayRef v24 = v36;
      }
    }
  }
  CFMutableDictionaryRef Mutable = theDict;
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"MEID");
  if (Value) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"MEID:%@", v48, v49, v50, v51, v52, (char)Value);
  }
  uint64_t v53 = CFDictionaryGetValue(theDict, @"IMEI");
  CFStringRef v16 = v164;
  if (v53) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"IMEI:%@", v54, v55, v56, v57, v58, (char)v53);
  }
  uint64_t v59 = CFDictionaryGetValue(theDict, @"IMEI2");
  if (v59) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"IMEI2:%@", v60, v61, v62, v63, v64, (char)v59);
  }
  long long v65 = CFDictionaryGetValue(theDict, @"EID");
  if (v65) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"EID:%@", v66, v67, v68, v69, v70, (char)v65);
  }
  uint64_t v71 = CFDictionaryGetValue(theDict, @"WIFI_MAC");
  if (v71) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"WIFI_MAC:%@", v72, v73, v74, v75, v76, (char)v71);
  }
  uint64_t v77 = CFDictionaryGetValue(theDict, @"BT_MAC");
  if (v77) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"BT_MAC:%@", v78, v79, v80, v81, v82, (char)v77);
  }
  long long v83 = CFDictionaryGetValue(theDict, @"USB_ETHER_MAC");
  if (v83) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"USB_ETHER_MAC:%@", v84, v85, v86, v87, v88, (char)v83);
  }
  int v89 = CFDictionaryGetValue(theDict, @"WIFI_MAC2");
  if (v89) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"WIFI_MAC2:%@", v90, v91, v92, v93, v94, (char)v89);
  }
  uint64_t v95 = CFDictionaryGetValue(theDict, @"BT_MAC2");
  if (v95) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"BT_MAC2:%@", v96, v97, v98, v99, v100, (char)v95);
  }
  uint64_t v101 = CFDictionaryGetValue(theDict, @"ETH_MAC");
  if (v101) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"ETH_MAC:%@", v102, v103, v104, v105, v106, (char)v101);
  }
  uint64_t v107 = CFDictionaryGetValue(theDict, @"ETHER_MAC2");
  if (v107) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"ETHER_MAC2:%@", v108, v109, v110, v111, v112, (char)v107);
  }
  uint64_t v113 = CFDictionaryGetValue(theDict, @"T_MAC");
  if (v113) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"T_MAC:%@", v114, v115, v116, v117, v118, (char)v113);
  }
  uint64_t v119 = CFDictionaryGetValue(theDict, @"ETHER_MAC3");
  if (v119) {
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"ETHER_MAC3:%@", v120, v121, v122, v123, v124, (char)v119);
  }
  CFStringRef v125 = (const __CFString *)CFDictionaryGetValue(theDict, @"B64_SECDATA");
  if (v125)
  {
    uint64_t v131 = AMAuthInstallSupportBase64Decode(kCFAllocatorDefault, v125, (CFTypeRef *)&theDataa, v126, v127, v128, v129, v130);
    if (v131)
    {
      uint64_t v159 = v131;
      CFIndex v161 = "AMAuthInstallSupportBase64Decode failed";
LABEL_63:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)v161, v19, v20, v21, v22, v23, v162);
      CFNumberRef NumberFromString = 0;
      uint64_t v152 = 0;
      goto LABEL_52;
    }
    if (theDataa)
    {
      if ((unint64_t)CFDataGetLength(theDataa) > 0x4B)
      {
        v171.CFIndex location = 0;
        v171.CFIndex length = 76;
        CFDataGetBytes(theDataa, v171, buffer);
        if (!v170[6]) {
          goto LABEL_49;
        }
        uint64_t v132 = CFDataGetBytePtr(theDataa);
        CFDataRef v133 = CFDataCreate(a1, v132 + 76, v170[6]);
        if (v133)
        {
          CFDataRef v139 = v133;
          CFDictionarySetValue(theDict, @"MANIFESTDATA", v133);
          AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"Found secure manifest in response: '%@'", v140, v141, v142, v143, v144, (char)v139);
          CFRelease(v139);
          goto LABEL_49;
        }
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"tempData is NULL", v134, v135, v136, v137, v138, v162);
LABEL_65:
        CFNumberRef NumberFromString = 0;
        uint64_t v152 = 0;
        uint64_t v159 = 2;
        goto LABEL_52;
      }
      CFIndex v161 = "decodedData is too small";
    }
    else
    {
      CFIndex v161 = "decodedData is NULL";
    }
LABEL_62:
    uint64_t v159 = 3;
    goto LABEL_63;
  }
  AMAuthInstallLog(6, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"B64_SECDATA not found in response", v126, v127, v128, v129, v130, v162);
LABEL_49:
  CFStringRef v145 = (const __CFString *)CFDictionaryGetValue(theDict, @"STATUS");
  if (v145)
  {
    CFStringRef v151 = v145;
    uint64_t v152 = CFNumberFormatterCreate(a1, 0, kCFNumberFormatterNoStyle);
    CFNumberRef NumberFromString = CFNumberFormatterCreateNumberFromString(a1, v152, v151, 0, 1uLL);
    if (CFNumberGetValue(NumberFromString, kCFNumberSInt32Type, a3))
    {
      uint64_t v159 = 0;
      *uint64_t v163 = CFRetain(theDict);
    }
    else
    {
      uint64_t v159 = 3;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"failed to convert statusNumber", v154, v155, v156, v157, v158, v162);
    }
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningCopyResponse", (uint64_t)"statusString is NULL", v146, v147, v148, v149, v150, v162);
    CFNumberRef NumberFromString = 0;
    uint64_t v152 = 0;
    uint64_t v159 = 17;
  }
LABEL_52:
  SafeRelease(v16);
  SafeRelease(Mutable);
  SafeRelease(theDataa);
  SafeRelease(0);
  SafeRelease(v24);
  SafeRelease(NumberFromString);
  SafeRelease(v152);
  return v159;
}

uint64_t AMAuthInstallProvisioningPopulateRequestDict(uint64_t cf, __CFDictionary *a2, const __CFString *a3)
{
  CFDataRef v3 = 0;
  CFDataRef theData = 0;
  uint64_t v4 = 1;
  if (!a2 || !cf)
  {
    CFStringRef v7 = 0;
    CFMutableDictionaryRef Mutable = 0;
    CFDataRef v9 = 0;
    CFStringRef v10 = 0;
    goto LABEL_125;
  }
  CFStringRef v7 = 0;
  CFMutableDictionaryRef Mutable = 0;
  CFDataRef v9 = 0;
  CFStringRef v10 = 0;
  if (a3)
  {
    if (*(void *)(cf + 320))
    {
      CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)cf);
      uint64_t v17 = AMAuthInstallHttpSetUriEscapedValue(v12, a2, @"COMMAND_CODE", a3, v13, v14, v15, v16);
      if (v17) {
        goto LABEL_131;
      }
      if (CFEqual(a3, @"100")) {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(cf + 320), @"PINECRESTID");
      }
      CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)cf);
      uint64_t v17 = AMAuthInstallHttpSetUriEscapedValue(v23, a2, @"TICKET_VERSION", @"2", v24, v25, v26, v27);
      if (v17)
      {
LABEL_131:
        uint64_t v4 = v17;
        uint64_t v324 = "setting COMMAND_CODE failed";
      }
      else
      {
        uint64_t v28 = *(void *)(cf + 48);
        if (!v28)
        {
          CFDataRef v3 = 0;
LABEL_45:
          if (!*(void *)(cf + 96)
            || (CFAllocatorRef v107 = CFGetAllocator((CFTypeRef)cf),
                uint64_t v112 = AMAuthInstallHttpSetUriEscapedValue(v107, a2, @"CLIENT_ID", *(CFStringRef *)(cf + 96), v108, v109, v110, v111), !v112))
          {
            CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(cf + 320));
            CFDataRef v9 = (const void **)malloc(8 * Count);
            uint64_t v114 = (const void **)malloc(8 * Count);
            CFStringRef v10 = v114;
            CFStringRef v7 = 0;
            uint64_t v4 = 2;
            if (!v9 || !v114)
            {
              CFMutableDictionaryRef Mutable = 0;
              goto LABEL_125;
            }
            CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(cf + 320), v9, v114);
            if (Count >= 1)
            {
              uint64_t v120 = 0;
              while (v9[v120])
              {
                uint64_t v121 = v10[v120];
                if (!v121)
                {
                  uint64_t v323 = "invalid provisioningInfoValuesBuffer array";
                  goto LABEL_128;
                }
                CFTypeID v122 = CFGetTypeID(v121);
                CFTypeID TypeID = CFDataGetTypeID();
                CFAllocatorRef v124 = CFGetAllocator((CFTypeRef)cf);
                uint64_t v129 = v9[v120];
                CFDataRef v130 = (const __CFData *)v10[v120];
                if (v122 == TypeID) {
                  uint64_t v131 = AMAuthInstallHttpSetBase64EncodedValue(v124, a2, v129, v130, v125, v126, v127, v128);
                }
                else {
                  uint64_t v131 = AMAuthInstallHttpSetUriEscapedValue(v124, a2, v129, (CFStringRef)v130, v125, v126, v127, v128);
                }
                uint64_t v4 = v131;
                if (v131)
                {
                  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"setting %@ failed", v115, v116, v117, v118, v119, (char)v9[v120]);
                  CFStringRef v7 = 0;
                  CFMutableDictionaryRef Mutable = 0;
                  goto LABEL_125;
                }
                if (Count == ++v120) {
                  goto LABEL_58;
                }
              }
              uint64_t v323 = "invalid provisioningInfoKeysBuffer array";
LABEL_128:
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)v323, v115, v116, v117, v118, v119, v326);
              CFStringRef v7 = 0;
              CFMutableDictionaryRef Mutable = 0;
              uint64_t v4 = 99;
              goto LABEL_125;
            }
LABEL_58:
            CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            CFArrayAppendValue(Mutable, @"1.2.0");
            CFStringRef LibraryVersionString = AMAuthInstallSupportGetLibraryVersionString();
            if (CFStringGetLength(LibraryVersionString)) {
              CFStringRef v133 = LibraryVersionString;
            }
            else {
              CFStringRef v133 = @"libauthinstall-???";
            }
            CFArrayAppendValue(Mutable, v133);
            CFStringRef v7 = CFStringCreateByCombiningStrings(kCFAllocatorDefault, Mutable, @"-");
            CFAllocatorRef v134 = CFGetAllocator((CFTypeRef)cf);
            uint64_t v139 = AMAuthInstallHttpSetUriEscapedValue(v134, a2, @"VERSION", v7, v135, v136, v137, v138);
            if (v139)
            {
              uint64_t v4 = v139;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"setting VERSION (%@) failed", v140, v141, v142, v143, v144, (char)v7);
              goto LABEL_125;
            }
            CFDictionaryRef v145 = *(const __CFDictionary **)(cf + 312);
            if (!v145) {
              goto LABEL_120;
            }
            CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v145, @"MEID");
            if (Value)
            {
              CFStringRef v147 = Value;
              CFTypeRef cfa = 0;
              if (AMAuthInstallMonetCreateReversedMEIDFromString((int)kCFAllocatorDefault, Value, &cfa)
                || !cfa)
              {
                AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"failed to reverse meid, adding original string to response", v148, v149, v150, v151, v152, v326);
                SafeRelease(cfa);
                CFAllocatorRef v161 = CFGetAllocator((CFTypeRef)cf);
                AMAuthInstallHttpSetUriEscapedValue(v161, a2, @"MEID", v147, v162, v163, v164, v165);
              }
              else
              {
                CFAllocatorRef v153 = CFGetAllocator((CFTypeRef)cf);
                AMAuthInstallHttpSetBase64EncodedValue(v153, a2, @"B64_MEID", (CFDataRef)cfa, v154, v155, v156, v157);
                CFRelease(cfa);
                uint64_t v158 = *(void *)(cf + 48);
                if (v158)
                {
                  uint64_t v159 = *(void *)(v158 + 32) != 0;
LABEL_73:
                  CFStringRef v166 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"IMEI");
                  if (v166)
                  {
                    CFStringRef v167 = v166;
                    CFTypeRef cfa = 0;
                    if (AMAuthInstallMonetCreateReversedMEIDFromString((int)kCFAllocatorDefault, v166, &cfa)|| !cfa)
                    {
                      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"failed to reverse imei, adding original string to response", v168, v169, v170, v171, v172, v326);
                      SafeRelease(cfa);
                      CFAllocatorRef v179 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetUriEscapedValue(v179, a2, @"IMEI", v167, v180, v181, v182, v183);
                    }
                    else
                    {
                      CFAllocatorRef v173 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetBase64EncodedValue(v173, a2, @"B64_IMEI", (CFDataRef)cfa, v174, v175, v176, v177);
                      CFRelease(cfa);
                      uint64_t v178 = *(void *)(cf + 48);
                      if (v178)
                      {
                        if (*(void *)(v178 + 40)) {
                          uint64_t v159 = v159 | 0x100;
                        }
                        else {
                          uint64_t v159 = v159;
                        }
                      }
                    }
                  }
                  else
                  {
                    CFDictionaryRemoveValue(a2, @"B64_IMEI");
                    CFDictionaryRemoveValue(a2, @"IMEI");
                  }
                  CFStringRef v184 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"IMEI2");
                  if (v184)
                  {
                    CFStringRef v185 = v184;
                    CFTypeRef cfa = 0;
                    if (AMAuthInstallMonetCreateReversedMEIDFromString((int)kCFAllocatorDefault, v184, &cfa)|| !cfa)
                    {
                      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"failed to reverse imei2, adding original string to response", v186, v187, v188, v189, v190, v326);
                      SafeRelease(cfa);
                      CFAllocatorRef v197 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetUriEscapedValue(v197, a2, @"IMEI2", v185, v198, v199, v200, v201);
                    }
                    else
                    {
                      CFAllocatorRef v191 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetBase64EncodedValue(v191, a2, @"B64_IMEI2", (CFDataRef)cfa, v192, v193, v194, v195);
                      CFRelease(cfa);
                      uint64_t v196 = *(void *)(cf + 48);
                      if (v196)
                      {
                        if (*(void *)(v196 + 48)) {
                          uint64_t v159 = v159 | 0x200;
                        }
                        else {
                          uint64_t v159 = v159;
                        }
                      }
                    }
                  }
                  else
                  {
                    CFDictionaryRemoveValue(a2, @"B64_IMEI2");
                    CFDictionaryRemoveValue(a2, @"IMEI2");
                  }
                  CFStringRef v202 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"WIFI_MAC");
                  if (v202)
                  {
                    CFStringRef v203 = v202;
                    CFAllocatorRef v204 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v204, a2, @"WIFI_MAC", v203, v205, v206, v207, v208);
                  }
                  CFStringRef v209 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"BT_MAC");
                  if (v209)
                  {
                    CFStringRef v210 = v209;
                    CFAllocatorRef v211 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v211, a2, @"BT_MAC", v210, v212, v213, v214, v215);
                  }
                  CFStringRef v216 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"USB_ETHER_MAC");
                  if (v216)
                  {
                    CFStringRef v217 = v216;
                    CFAllocatorRef v218 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v218, a2, @"USB_ETHER_MAC", v217, v219, v220, v221, v222);
                  }
                  CFStringRef v223 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"WIFI_MAC2");
                  if (v223)
                  {
                    CFStringRef v224 = v223;
                    CFAllocatorRef v225 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v225, a2, @"WIFI_MAC2", v224, v226, v227, v228, v229);
                  }
                  CFStringRef v230 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"BT_MAC2");
                  if (v230)
                  {
                    CFStringRef v231 = v230;
                    CFAllocatorRef v232 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v232, a2, @"BT_MAC2", v231, v233, v234, v235, v236);
                  }
                  CFStringRef v237 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"ETH_MAC");
                  if (v237)
                  {
                    CFStringRef v238 = v237;
                    CFAllocatorRef v239 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v239, a2, @"ETH_MAC", v238, v240, v241, v242, v243);
                  }
                  CFStringRef v244 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"ETHER_MAC2");
                  if (v244)
                  {
                    CFStringRef v245 = v244;
                    CFAllocatorRef v246 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v246, a2, @"ETHER_MAC2", v245, v247, v248, v249, v250);
                  }
                  CFStringRef v251 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"T_MAC");
                  if (v251)
                  {
                    CFStringRef v252 = v251;
                    CFAllocatorRef v253 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v253, a2, @"T_MAC", v252, v254, v255, v256, v257);
                  }
                  CFStringRef v258 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"ETHER_MAC3");
                  if (v258)
                  {
                    CFStringRef v259 = v258;
                    CFAllocatorRef v260 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v260, a2, @"ETHER_MAC3", v259, v261, v262, v263, v264);
                  }
                  CFDictionaryRef v265 = CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"PAICHUSUO");
                  if (v265)
                  {
                    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"PAICHUSUO:%@", v266, v267, v268, v269, v270, (char)v265);
                    CFStringRef v271 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"SN");
                    if (v271)
                    {
                      CFStringRef v277 = v271;
                      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"PAICHUSUO SN:%@", v272, v273, v274, v275, v276, (char)v271);
                      CFAllocatorRef v278 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetUriEscapedValue(v278, a2, @"SN", v277, v279, v280, v281, v282);
                    }
                    CFStringRef v283 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"RGN");
                    if (v283)
                    {
                      CFStringRef v289 = v283;
                      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"PAICHUSUO RGN:%@", v284, v285, v286, v287, v288, (char)v283);
                      CFAllocatorRef v290 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetUriEscapedValue(v290, a2, @"RGN", v289, v291, v292, v293, v294);
                    }
                    CFStringRef v295 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"MPN");
                    if (v295)
                    {
                      CFStringRef v301 = v295;
                      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"PAICHUSUO MPN:%@", v296, v297, v298, v299, v300, (char)v295);
                      CFAllocatorRef v302 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetUriEscapedValue(v302, a2, @"MPN", v301, v303, v304, v305, v306);
                    }
                    CFStringRef v307 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(cf + 312), @"MLB");
                    if (v307)
                    {
                      CFStringRef v313 = v307;
                      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"PAICHUSUO MLB:%@", v308, v309, v310, v311, v312, (char)v307);
                      CFAllocatorRef v314 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetUriEscapedValue(v314, a2, @"MLB", v313, v315, v316, v317, v318);
                    }
                  }
                  CFAllocatorRef v319 = CFGetAllocator((CFTypeRef)cf);
                  CFStringRef v320 = CFStringCreateWithFormat(v319, 0, @"0x%X", v159);
                  if (!v320)
                  {
                    uint64_t v4 = 2;
                    goto LABEL_125;
                  }
                  CFStringRef v321 = v320;
                  CFDictionarySetValue(a2, @"STATUS1", v320);
                  CFRelease(v321);
LABEL_120:
                  uint64_t v4 = 0;
                  goto LABEL_125;
                }
              }
            }
            else
            {
              CFDictionaryRemoveValue(a2, @"B64_MEID");
              CFDictionaryRemoveValue(a2, @"MEID");
            }
            uint64_t v159 = 0;
            goto LABEL_73;
          }
          uint64_t v4 = v112;
          CFURLRef v325 = "setting CLIENT_ID failed";
          goto LABEL_142;
        }
        if (*(void *)(v28 + 16)
          && (CFAllocatorRef v29 = CFGetAllocator((CFTypeRef)cf),
              uint64_t v34 = AMAuthInstallHttpSetBase64EncodedValue(v29, a2, @"B64_BB_SNUM", *(CFDataRef *)(*(void *)(cf + 48) + 16), v30, v31, v32, v33), v34))
        {
          uint64_t v4 = v34;
          uint64_t v324 = "setting B64_BB_SNUM failed";
        }
        else
        {
          if (*(void *)(cf + 312)) {
            goto LABEL_18;
          }
          if (*(void *)(*(void *)(cf + 48) + 72))
          {
            CFAllocatorRef v35 = CFGetAllocator((CFTypeRef)cf);
            uint64_t v40 = AMAuthInstallHttpSetBase64EncodedValue(v35, a2, @"B64_SESS_KEY", *(CFDataRef *)(*(void *)(cf + 48) + 72), v36, v37, v38, v39);
            if (v40)
            {
              uint64_t v4 = v40;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)"setting B64_SESS_KEY failed, '%@'", v18, v19, v20, v21, v22, *(void *)(*(void *)(cf + 48) + 72));
              goto LABEL_133;
            }
          }
          uint64_t KeyHash = AMAuthInstallBasebandGetKeyHash(cf, @"BbProvisioningManifestKeyHash", &theData, v18, v19, v20, v21, v22);
          if (KeyHash)
          {
            uint64_t v4 = KeyHash;
            uint64_t v324 = "AMAuthInstallBasebandGetKeyHash failed";
          }
          else
          {
            if (!theData
              || (CFAllocatorRef v42 = CFGetAllocator((CFTypeRef)cf),
                  uint64_t v47 = AMAuthInstallHttpSetBase64EncodedValue(v42, a2, @"B64_SKEY_HASH", theData, v43, v44, v45, v46), !v47))
            {
LABEL_18:
              CFAllocatorRef v48 = CFGetAllocator((CFTypeRef)cf);
              CFDataRef v3 = CFDataCreate(v48, (const UInt8 *)(*(void *)(cf + 48) + 4), 4);
              if (v3)
              {
                CFAllocatorRef v54 = CFGetAllocator((CFTypeRef)cf);
                uint64_t v59 = AMAuthInstallHttpSetBase64EncodedValue(v54, a2, @"B64_BB_CHIPID", v3, v55, v56, v57, v58);
                if (v59)
                {
                  uint64_t v4 = v59;
                  CFURLRef v325 = "setting B64_BB_CHIPID failed";
                }
                else
                {
                  uint64_t v60 = *(void **)(cf + 48);
                  if (v60[8])
                  {
                    CFAllocatorRef v61 = CFGetAllocator((CFTypeRef)cf);
                    AMAuthInstallHttpSetUriEscapedValue(v61, a2, @"ICCID", *(CFStringRef *)(*(void *)(cf + 48) + 64), v62, v63, v64, v65);
                    uint64_t v60 = *(void **)(cf + 48);
                  }
                  if (v60[13])
                  {
                    CFAllocatorRef v66 = CFGetAllocator((CFTypeRef)cf);
                    uint64_t v71 = AMAuthInstallHttpSetUriEscapedValue(v66, a2, @"BB_CARRIERID", *(CFStringRef *)(*(void *)(cf + 48) + 104), v67, v68, v69, v70);
                    if (v71)
                    {
                      uint64_t v4 = v71;
                      CFURLRef v325 = "setting BB_CARRIERID failed";
                      goto LABEL_142;
                    }
                    uint64_t v60 = *(void **)(cf + 48);
                  }
                  if (!v60[14]) {
                    goto LABEL_28;
                  }
                  CFAllocatorRef v72 = CFGetAllocator((CFTypeRef)cf);
                  uint64_t v77 = AMAuthInstallHttpSetBase64EncodedValue(v72, a2, @"MANIFESTDATA", *(CFDataRef *)(*(void *)(cf + 48) + 112), v73, v74, v75, v76);
                  if (!v77)
                  {
                    uint64_t v60 = *(void **)(cf + 48);
LABEL_28:
                    CFStringRef v78 = (const __CFString *)v60[4];
                    if (v78)
                    {
                      CFTypeRef cfa = 0;
                      uint64_t v4 = AMAuthInstallMonetCreateReversedMEIDFromString((int)kCFAllocatorDefault, v78, &cfa);
                      if (v4 || !cfa)
                      {
                        uint64_t v160 = "failed to reverse meid";
                        goto LABEL_123;
                      }
                      CFAllocatorRef v84 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetBase64EncodedValue(v84, a2, @"B64_MEID", (CFDataRef)cfa, v85, v86, v87, v88);
                      CFRelease(cfa);
                      uint64_t v60 = *(void **)(cf + 48);
                    }
                    CFStringRef v89 = (const __CFString *)v60[5];
                    if (v89)
                    {
                      CFTypeRef cfa = 0;
                      uint64_t v4 = AMAuthInstallMonetCreateReversedMEIDFromString((int)kCFAllocatorDefault, v89, &cfa);
                      if (v4 || !cfa)
                      {
                        uint64_t v160 = "failed to reverse imei";
                        goto LABEL_123;
                      }
                      CFAllocatorRef v90 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetBase64EncodedValue(v90, a2, @"B64_IMEI", (CFDataRef)cfa, v91, v92, v93, v94);
                      CFRelease(cfa);
                      uint64_t v60 = *(void **)(cf + 48);
                    }
                    CFStringRef v95 = (const __CFString *)v60[6];
                    if (!v95)
                    {
LABEL_40:
                      CFStringRef v101 = (const __CFString *)v60[7];
                      if (!v101) {
                        goto LABEL_45;
                      }
                      CFTypeRef cfa = 0;
                      uint64_t v4 = AMAuthInstallSupportCopyDataFromHexString((int)kCFAllocatorDefault, v101, (uint64_t *)&cfa);
                      if (!v4 && cfa)
                      {
                        CFAllocatorRef v102 = CFGetAllocator((CFTypeRef)cf);
                        AMAuthInstallHttpSetBase64EncodedValue(v102, a2, @"B64_EID", (CFDataRef)cfa, v103, v104, v105, v106);
                        CFRelease(cfa);
                        goto LABEL_45;
                      }
                      uint64_t v160 = "failed to create euiccEID data";
                      goto LABEL_123;
                    }
                    CFTypeRef cfa = 0;
                    uint64_t v4 = AMAuthInstallMonetCreateReversedMEIDFromString((int)kCFAllocatorDefault, v95, &cfa);
                    if (!v4 && cfa)
                    {
                      CFAllocatorRef v96 = CFGetAllocator((CFTypeRef)cf);
                      AMAuthInstallHttpSetBase64EncodedValue(v96, a2, @"B64_IMEI2", (CFDataRef)cfa, v97, v98, v99, v100);
                      CFRelease(cfa);
                      uint64_t v60 = *(void **)(cf + 48);
                      goto LABEL_40;
                    }
                    uint64_t v160 = "failed to reverse imei2";
LABEL_123:
                    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)v160, v79, v80, v81, v82, v83, v326);
                    SafeRelease(cfa);
LABEL_124:
                    CFStringRef v7 = 0;
                    CFMutableDictionaryRef Mutable = 0;
                    CFDataRef v9 = 0;
                    CFStringRef v10 = 0;
                    goto LABEL_125;
                  }
                  uint64_t v4 = v77;
                  CFURLRef v325 = "setting MANIFESTDATA failed";
                }
              }
              else
              {
                CFURLRef v325 = "chipID failed to convert to data";
                uint64_t v4 = 3;
              }
LABEL_142:
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)v325, v49, v50, v51, v52, v53, v326);
              goto LABEL_124;
            }
            uint64_t v4 = v47;
            uint64_t v324 = "setting B64_SKEY_HASH failed";
          }
        }
      }
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict", (uint64_t)v324, v18, v19, v20, v21, v22, v326);
    }
LABEL_133:
    CFDataRef v3 = 0;
    goto LABEL_124;
  }
LABEL_125:
  SafeFree(v9);
  SafeFree(v10);
  SafeRelease(v3);
  SafeRelease(v7);
  SafeRelease(Mutable);
  return v4;
}

uint64_t AMAuthInstallProvisioningServerSendSyncRequest(const __CFAllocator *a1, const __CFURL *a2, const __CFDictionary *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDataRef theData = 0;
  *(void *)CFAllocatorRef v35 = 0;
  uint64_t v32 = 0;
  CFTypeRef v33 = 0;
  uint64_t v8 = 1;
  if (a3 && a4)
  {
    if (!a2)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningServerSendSyncRequest", (uint64_t)"provisioning server url is NULL", (uint64_t)a4, a5, a6, a7, a8, v30);
      goto LABEL_11;
    }
    PostCFHTTPMessageRef Request = AMAuthInstallHttpCreatePostRequest(a1, a2, a3, (CFTypeRef *)v35);
    if (!PostRequest)
    {
      PostCFHTTPMessageRef Request = AMAuthInstallHttpMessageSendSyncNew(a1, v35[0], (int)&theData, (int)&v32 + 4, 0, 15.0);
      if (!PostRequest)
      {
        if (!theData)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningServerSendSyncRequest", (uint64_t)"no response data (httpStatus=%u)", v12, v13, v14, v15, v16, SBYTE4(v32));
          goto LABEL_17;
        }
        PostCFHTTPMessageRef Request = AMAuthInstallProvisioningCopyResponse(a1, theData, &v32, &v33);
        if (!PostRequest)
        {
          AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningServerSendSyncRequest", (uint64_t)"httpStatus=%u, status=%d", v17, v18, v19, v20, v21, SBYTE4(v32));
          if (v32)
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningServerSendSyncRequest", (uint64_t)"server error: %d", v22, v23, v24, v25, v26, v32);
            uint64_t v8 = 24;
            goto LABEL_11;
          }
          CFTypeRef v27 = v33;
          if (v33)
          {
            AMAuthInstallLog(6, (uint64_t)"AMAuthInstallProvisioningServerSendSyncRequest", (uint64_t)"data=%@", v22, v23, v24, v25, v26, (char)v33);
            CFTypeRef v28 = CFRetain(v27);
            uint64_t v8 = 0;
            *a4 = v28;
            goto LABEL_11;
          }
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningServerSendSyncRequest", (uint64_t)"server failed to provide response data", v22, v23, v24, v25, v26, v31);
LABEL_17:
          uint64_t v8 = 17;
          goto LABEL_11;
        }
      }
    }
    uint64_t v8 = PostRequest;
  }
LABEL_11:
  SafeRelease(0);
  SafeRelease(*(CFTypeRef *)v35);
  SafeRelease(theData);
  SafeRelease(v33);
  return v8;
}

uint64_t AMAuthInstallProvisioningSendAck(uint64_t cf, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef theDict = 0;
  if (!cf)
  {
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v12 = 1;
    goto LABEL_13;
  }
  if (*(void *)(cf + 312))
  {
    CFStringRef v10 = @"200";
  }
  else
  {
    if (*(_DWORD *)(cf + 304) == 8)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningSendAck", (uint64_t)"Provisioning failed, ack already sent.", a4, a5, a6, a7, a8, v36);
      CFMutableDictionaryRef Mutable = 0;
      uint64_t v12 = 19;
      goto LABEL_13;
    }
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningSendAck", (uint64_t)"No provisioning info to ack, sending ping.", a4, a5, a6, a7, a8, v36);
    CFStringRef v10 = @"1";
  }
  CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)cf);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v13, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v14 = AMAuthInstallProvisioningPopulateRequestDict(cf, Mutable, v10);
    if (v14)
    {
      uint64_t v12 = v14;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningSendAck", (uint64_t)"AMAuthInstallProvisioningPopulateRequestDict failed status=%d", v15, v16, v17, v18, v19, v14);
    }
    else
    {
      CFAllocatorRef v20 = CFGetAllocator((CFTypeRef)cf);
      char Value = a2;
      CFStringRef v21 = CFStringCreateWithFormat(v20, 0, @"0x%X");
      CFDictionarySetValue(Mutable, @"STATUS", v21);
      CFRelease(v21);
      CFAllocatorRef v22 = CFGetAllocator((CFTypeRef)cf);
      uint64_t v27 = AMAuthInstallProvisioningServerSendSyncRequest(v22, *(const __CFURL **)(cf + 296), Mutable, &theDict, v23, v24, v25, v26);
      if (v27)
      {
        uint64_t v12 = v27;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningSendAck", (uint64_t)"AMAuthInstallProvisioningServerSendSyncRequest failed status=%d", v28, v29, v30, v31, v32, v27);
      }
      else
      {
        if (theDict)
        {
          char Value = CFDictionaryGetValue(theDict, @"STATUS");
          CFTypeRef v33 = "Server returned STATUS=%@";
          uint64_t v34 = 6;
        }
        else
        {
          CFTypeRef v33 = "responseDict is NULL";
          uint64_t v34 = 3;
        }
        AMAuthInstallLog(v34, (uint64_t)"AMAuthInstallProvisioningSendAck", (uint64_t)v33, v28, v29, v30, v31, v32, Value);
        uint64_t v12 = 0;
      }
    }
  }
  else
  {
    uint64_t v12 = 2;
  }
LABEL_13:
  SafeRelease(Mutable);
  SafeRelease(theDict);
  return v12;
}

uint64_t AMAuthInstallProvisioningSendRequest(uint64_t a1, const __CFString *a2, CFTypeRef *a3)
{
  CFMutableDictionaryRef Mutable = 0;
  uint64_t v4 = 1;
  if (a1 && a2 && a3)
  {
    CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v8, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Mutable)
    {
      uint64_t v4 = 2;
      goto LABEL_9;
    }
    uint64_t v9 = AMAuthInstallProvisioningPopulateRequestDict(a1, Mutable, a2);
    if (v9)
    {
      uint64_t v4 = v9;
      CFAllocatorRef v22 = "AMAuthInstallProvisioningPopulateRequestDict failed";
    }
    else
    {
      CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v20 = AMAuthInstallProvisioningServerSendSyncRequest(v15, *(const __CFURL **)(a1 + 296), Mutable, a3, v16, v17, v18, v19);
      if (!v20)
      {
        if (*a3)
        {
          SafeRelease(*(CFTypeRef *)(a1 + 312));
          uint64_t v4 = 0;
          *(void *)(a1 + 312) = CFRetain(*a3);
        }
        else
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningSendRequest", (uint64_t)"*outResponseDict is NULL", v10, v11, v12, v13, v14, v23);
          uint64_t v4 = 0;
        }
        goto LABEL_9;
      }
      uint64_t v4 = v20;
      CFAllocatorRef v22 = "AMAuthInstallProvisioningServerSendSyncRequest failed";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningSendRequest", (uint64_t)v22, v10, v11, v12, v13, v14, v23);
  }
LABEL_9:
  SafeRelease(Mutable);
  return v4;
}

uint64_t AMAuthInstallProvisioningRequestInfoPlist(void *a1, CFDataRef *a2)
{
  CFDictionaryRef theDict = 0;
  if (!a1)
  {
    CFDataRef v3 = 0;
    uint64_t v4 = 1;
    goto LABEL_23;
  }
  CFDataRef v3 = 0;
  uint64_t v4 = 1;
  if (a2 && a1[6])
  {
    uint64_t v6 = (const void *)a1[39];
    if (v6)
    {
      CFDictionaryRef v7 = (const __CFDictionary *)CFRetain(v6);
      CFDictionaryRef theDict = v7;
      uint64_t v4 = 99;
      if (v7)
      {
LABEL_6:
        unint64_t Value = (unint64_t)CFDictionaryGetValue(v7, @"MEID");
        unint64_t v14 = (unint64_t)CFDictionaryGetValue(theDict, @"IMEI");
        if (!(Value | v14))
        {
          CFDataRef v3 = 0;
          uint64_t v4 = 17;
          uint64_t v17 = "both imei and meid are NULL, provisioning failed.";
          goto LABEL_29;
        }
        CFAllocatorRef v15 = (const void *)v14;
        if (*(void *)(a1[6] + 48))
        {
          uint64_t v16 = CFDictionaryGetValue(theDict, @"IMEI2");
          if (!v16)
          {
            CFDataRef v3 = 0;
            uint64_t v4 = 17;
            uint64_t v17 = "imei2 is NULL. provisioning failed.";
LABEL_29:
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningRequestInfoPlist", (uint64_t)v17, v8, v9, v10, v11, v12, v23);
            goto LABEL_23;
          }
        }
        else
        {
          uint64_t v16 = 0;
        }
        CFAllocatorRef v18 = CFGetAllocator(a1);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v18, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFDataRef v3 = Mutable;
        if (Mutable)
        {
          if (Value) {
            CFDictionarySetValue(Mutable, @"MEID", (const void *)Value);
          }
          if (v15) {
            CFDictionarySetValue(v3, @"IMEI", v15);
          }
          if (v16) {
            CFDictionarySetValue(v3, @"IMEI2", v16);
          }
          CFAllocatorRef v20 = CFGetAllocator(a1);
          XMLCFDataRef Data = CFPropertyListCreateXMLData(v20, v3);
          *a2 = XMLData;
          if (!XMLData)
          {
            uint64_t v4 = 3;
            uint64_t v17 = "CFPropertyListCreateXMLData failed.";
            goto LABEL_29;
          }
          uint64_t v4 = 0;
        }
        else
        {
          uint64_t v4 = 2;
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v4 = AMAuthInstallProvisioningSendRequest((uint64_t)a1, @"100", (CFTypeRef *)&theDict);
      if (v4)
      {
        CFDataRef v3 = 0;
        uint64_t v17 = "AMAuthInstallProvisioningSendRequest failed";
        goto LABEL_29;
      }
      CFDictionaryRef v7 = theDict;
      if (theDict) {
        goto LABEL_6;
      }
    }
    CFDataRef v3 = 0;
    uint64_t v17 = "responseDict is NULL";
    goto LABEL_29;
  }
LABEL_23:
  SafeRelease(0);
  SafeRelease(theDict);
  SafeRelease(v3);
  return v4;
}

uint64_t AMAuthInstallProvisioningRequestManifest(uint64_t a1, void *a2)
{
  CFTypeRef v14 = 0;
  uint64_t v2 = 1;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 312))
    {
      CFTypeRef v4 = CFRetain(*(CFTypeRef *)(a1 + 312));
      CFTypeRef v14 = v4;
      uint64_t v2 = 99;
      if (v4)
      {
LABEL_5:
        unint64_t Value = CFDictionaryGetValue((CFDictionaryRef)v4, @"MANIFESTDATA");
        *a2 = Value;
        if (Value)
        {
          CFRetain(Value);
          uint64_t v2 = 0;
          goto LABEL_7;
        }
        uint64_t v12 = "*manifestData is NULL";
LABEL_13:
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningRequestManifest", (uint64_t)v12, v5, v6, v7, v8, v9, v13);
        goto LABEL_7;
      }
    }
    else
    {
      uint64_t v2 = AMAuthInstallProvisioningSendRequest(a1, @"100", &v14);
      if (v2)
      {
        uint64_t v12 = "AMAuthInstallProvisioningSendRequest failed";
        goto LABEL_13;
      }
      CFTypeRef v4 = v14;
      if (v14) {
        goto LABEL_5;
      }
    }
    uint64_t v12 = "responseDict is NULL";
    goto LABEL_13;
  }
LABEL_7:
  SafeRelease(v14);
  return v2;
}

uint64_t _AMAuthInstallSupportsECProvision(uint64_t a1)
{
  uint64_t result = 0;
  int v3 = *(_DWORD *)(*(void *)(a1 + 48) + 4);
  if (v3 <= 241888)
  {
    unsigned int v6 = v3 - 96;
    BOOL v7 = v6 > 7;
    int v8 = (1 << v6) & 0xA1;
    if (v7 || v8 == 0) {
      return 1;
    }
  }
  else
  {
    if (v3 > 9572576)
    {
      BOOL v4 = v3 == 9572577;
      int v5 = 9781473;
    }
    else
    {
      BOOL v4 = v3 == 241889;
      int v5 = 8343777;
    }
    if (!v4 && v3 != v5) {
      return 1;
    }
  }
  return result;
}

uint64_t AMAuthInstallProvisioningProvisionIfNecessary(uint64_t a1, __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v82 = 0;
  CFDictionaryRef value = 0;
  uint64_t v81 = 0;
  if (!a1)
  {
    uint64_t v55 = 1;
    goto LABEL_64;
  }
  unsigned int SubjectPublicKeyInfoForKey = 1;
  if (!a2) {
    goto LABEL_61;
  }
  uint64_t v11 = *(void *)(a1 + 48);
  if (!v11) {
    goto LABEL_61;
  }
  unsigned int v12 = *(_DWORD *)(a1 + 304);
  if (v12 > 0xB)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"Unexpected provisioning state = %d", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 304));
    unsigned int SubjectPublicKeyInfoForKey = 99;
    goto LABEL_61;
  }
  int v13 = 1 << v12;
  if ((v13 & 0xF81) != 0)
  {
LABEL_60:
    unsigned int SubjectPublicKeyInfoForKey = 0;
    goto LABEL_61;
  }
  if ((v13 & 0x26) == 0)
  {
    if (!*(void *)(v11 + 72))
    {
      *(_DWORD *)(a1 + 304) = 8;
      uint64_t v41 = "encryptedSessionKey is NULL";
      goto LABEL_66;
    }
    int v39 = *(_DWORD *)(v11 + 4);
    if (v39 <= 1515744)
    {
      if (v39 > 520416)
      {
        if (v39 != 520417 && v39 != 938209)
        {
          int v40 = 1327329;
          goto LABEL_55;
        }
      }
      else if (v39 != 94 && v39 != 104)
      {
        int v40 = 241889;
        goto LABEL_55;
      }
    }
    else if (v39 <= 2814176)
    {
      if (v39 != 1515745 && v39 != 1700065)
      {
        int v40 = 2089185;
        goto LABEL_55;
      }
    }
    else if (v39 > 9572576)
    {
      if (v39 != 9572577)
      {
        int v40 = 9781473;
        goto LABEL_55;
      }
    }
    else if (v39 != 2814177)
    {
      int v40 = 8343777;
LABEL_55:
      if (v39 != v40
        && !*(unsigned char *)(a1 + 328)
        && (*(void *)(v11 + 32) || *(void *)(v11 + 40) || *(void *)(v11 + 48)))
      {
        AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"Performing local re-lock", a4, a5, a6, a7, a8, v78);
        unsigned int v74 = AMAuthInstallBasebandLocalProvisionDevice(a1, (uint64_t)&v81, v68, v69, v70, v71, v72, v73);
        if (v74)
        {
          unsigned int SubjectPublicKeyInfoForKey = v74;
          *(_DWORD *)(a1 + 304) = 8;
          uint64_t v76 = "AMAuthInstallMonetLocalProvisionDevice failed";
          goto LABEL_85;
        }
        if (v81)
        {
          *(_DWORD *)(a1 + 304) = 6;
          goto LABEL_59;
        }
        *(_DWORD *)(a1 + 304) = 8;
        goto LABEL_100;
      }
    }
    if (*(_DWORD *)(v11 + 96) == 3)
    {
      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"Requesting manifest from server (%@)", a4, a5, a6, a7, a8, *(void *)(a1 + 296));
      unsigned int v54 = AMAuthInstallProvisioningRequestManifest(a1, &v81);
      *(_DWORD *)(a1 + 304) = 4;
      if (v54)
      {
        unsigned int SubjectPublicKeyInfoForKey = v54;
        uint64_t v76 = "AMAuthInstallProvisioningRequestManifest failed";
        goto LABEL_85;
      }
      if (v81)
      {
LABEL_59:
        CFDictionaryRemoveAllValues(a2);
        CFDictionarySetValue(a2, @"provisioning/manifest.bin", v81);
        goto LABEL_60;
      }
LABEL_100:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"manifestData is NULL", v22, v23, v24, v25, v26, v78);
      unsigned int SubjectPublicKeyInfoForKey = 14;
      goto LABEL_61;
    }
    uint64_t v41 = "Cannot provision unfused boards";
LABEL_66:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)v41, a4, a5, a6, a7, a8, v78);
    unsigned int SubjectPublicKeyInfoForKey = 19;
    goto LABEL_61;
  }
  CFBooleanRef v14 = *(const __CFBoolean **)(v11 + 88);
  if (v14 && CFBooleanGetValue(v14) == 1)
  {
    if (*(unsigned char *)(a1 + 328) || *(unsigned char *)(a1 + 329))
    {
      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"Existing provisioning manifest found. Force provisioning is enabled; provisioning anyway.",
        v16,
        v17,
        v18,
        v19,
        v20,
        v78);
      goto LABEL_12;
    }
    unsigned int v75 = AMAuthInstallProvisioningSendAck(a1, 0, v15, v16, v17, v18, v19, v20);
    if (v75 != 24)
    {
      unsigned int SubjectPublicKeyInfoForKey = v75;
      if (!v75)
      {
        *(_DWORD *)(a1 + 304) = 7;
        uint64_t v76 = "Existing provisioning manifest found. Not attempting to provision.";
        uint64_t v77 = 5;
LABEL_86:
        AMAuthInstallLog(v77, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)v76, v22, v23, v24, v25, v26, v78);
        goto LABEL_61;
      }
      uint64_t v76 = "Provisioning server failed to respond, cannot provision.";
LABEL_85:
      uint64_t v77 = 3;
      goto LABEL_86;
    }
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"provisioning ack failed, enabling force provisioning.", v22, v23, v24, v25, v26, v78);
    *(unsigned char *)(a1 + 328) = 1;
  }
LABEL_12:
  CFBooleanRef v21 = *(const __CFBoolean **)(*(void *)(a1 + 48) + 80);
  if (!v21)
  {
    CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
    if (!Mutable)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"emptyData is NULL", v43, v44, v45, v46, v47, v78);
      unsigned int SubjectPublicKeyInfoForKey = 2;
      goto LABEL_61;
    }
    CFMutableDataRef v48 = Mutable;
    CFDictionarySetValue(a2, @"provisioning/", Mutable);
    CFRelease(v48);
    uint64_t v49 = "Baseband not reporting manifest status, not attempting to provision yet.";
    goto LABEL_51;
  }
  if (CFBooleanGetValue(v21) != 1)
  {
    uint64_t v50 = *(void **)(a1 + 48);
    if (v50[4] || v50[5] || v50[6])
    {
      if (!*(unsigned char *)(a1 + 328))
      {
        *(_DWORD *)(a1 + 304) = 7;
        uint64_t v49 = "Device already has MEID and/or IMEI and/or IMEI2. Bringup provisioning complete. Not attempting to provision.";
        goto LABEL_51;
      }
      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"Device already has MEID and/or IMEI and/or IMEI2. Force provisioning is enabled requesting new values.", v22, v23, v24, v25, v26, v78);
    }
    unsigned int v51 = AMAuthInstallProvisioningRequestInfoPlist((void *)a1, (CFDataRef *)&value);
    *(_DWORD *)(a1 + 304) = 5;
    if (v51)
    {
      unsigned int SubjectPublicKeyInfoForKey = v51;
      uint64_t v76 = "AMAuthInstallProvisioningRequestInfoPlist failed";
      goto LABEL_85;
    }
    if (!value)
    {
      uint64_t v49 = "info.plist is NULL";
      uint64_t v53 = 3;
      goto LABEL_52;
    }
    CFDictionarySetValue(a2, @"provisioning/info.plist", value);
    uint64_t v49 = "Bringup baseband found, doing single stage provisioning";
LABEL_51:
    uint64_t v53 = 5;
LABEL_52:
    AMAuthInstallLog(v53, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)v49, v22, v23, v24, v25, v26, v78);
    goto LABEL_60;
  }
  uint64_t v80 = 0;
  unsigned int v27 = AMAuthInstallCryptoRegisterKeys();
  if (!v27)
  {
    if (!*(unsigned char *)(a1 + 328))
    {
      uint64_t v52 = *(void **)(a1 + 48);
      if (v52[4] || v52[5] || v52[6])
      {
        AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"Local re-locking enabled. Forcing use of P1 provisioning key.", v28, v29, v30, v31, v32, v78);
        unsigned int SubjectPublicKeyInfoForKey = AMAuthInstallCryptoCreateSubjectPublicKeyInfoForKey();
LABEL_70:
        uint64_t v38 = v82;
        goto LABEL_71;
      }
    }
    if (_AMAuthInstallSupportsECProvision(a1))
    {
      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"ECDH Server based provisioning enabled. Creating empty puk.pem file for BBUpdater", v33, v34, v35, v36, v37, v78);
      *(_DWORD *)bytes = -272716322;
      uint64_t v38 = CFDataCreate(kCFAllocatorDefault, bytes, 4);
      unsigned int SubjectPublicKeyInfoForKey = 0;
      uint64_t v82 = v38;
LABEL_71:
      if (v38)
      {
        CFDictionarySetValue(a2, @"provisioning/puk.pem", v38);
        AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"Mature baseband found, doing two stage provisioning", v63, v64, v65, v66, v67, v78);
        unsigned int SubjectPublicKeyInfoForKey = 0;
        *(_DWORD *)(a1 + 304) = 2;
        goto LABEL_61;
      }
      uint64_t v76 = "Public key is NULL";
      goto LABEL_92;
    }
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallProvisioningProvisionIfNecessary", (uint64_t)"LEGACY Server based provisioning enabled. Reading provisioning key from settings.", v33, v34, v35, v36, v37, v78);
    unsigned int KeyHash = AMAuthInstallBasebandGetKeyHash(a1, @"BbProvisioningManifestKeyHash", &v80, v57, v58, v59, v60, v61);
    if (KeyHash)
    {
      unsigned int SubjectPublicKeyInfoForKey = KeyHash;
      uint64_t v76 = "AMAuthInstallBasebandGetKeyHash failed";
    }
    else if (v80)
    {
      unsigned int SubjectPublicKeyInfoForKey = AMAuthInstallCryptoCreateSubjectPublicKeyInfoForKeyFromHash();
      if (!SubjectPublicKeyInfoForKey) {
        goto LABEL_70;
      }
      uint64_t v76 = "AMAuthInstallCryptoCreateSubjectPublicKeyInfoForKey failed";
    }
    else
    {
      unsigned int SubjectPublicKeyInfoForKey = 0;
      uint64_t v76 = "keyHashData is NULL";
    }
LABEL_92:
    *(_DWORD *)(a1 + 304) = 8;
    goto LABEL_85;
  }
  unsigned int SubjectPublicKeyInfoForKey = v27;
LABEL_61:
  if (*(_DWORD *)(a1 + 304) == 8) {
    uint64_t v55 = 19;
  }
  else {
    uint64_t v55 = SubjectPublicKeyInfoForKey;
  }
LABEL_64:
  SafeRelease(0);
  SafeRelease(value);
  SafeRelease(v82);
  SafeRelease(v81);
  return v55;
}

uint64_t AMAuthInstallRembrandtCreateStitchedPSI(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, @"PSI-Blob");
}

uint64_t AMAuthInstallRembrandtCreateStitchedRestorePSI(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, @"RestorePSI-Blob");
}

uint64_t AMAuthInstallRembrandtCreateStitchedPSI2(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, @"PSI2-Blob");
}

uint64_t AMAuthInstallRembrandtCreateStitchedRestorePSI2(void *a1, const __CFData *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  return AMAuthInstallMonetStitchEBootLoader(a1, a2, a3, a4, @"RestorePSI2-Blob");
}

uint64_t AMAuthInstallRembrandtMeasureBootImage(void *a1, const __CFData *a2, __CFDictionary *a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef value = 0;
  if (!a1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 1;
    goto LABEL_14;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 1;
  if (a4)
  {
    if (a3)
    {
      if (a2)
      {
        uint64_t v13 = a1[6];
        if (v13)
        {
          unsigned int v14 = *(_DWORD *)(v13 + 4) - 94;
          if (v14 <= 0xA)
          {
            int v15 = 1 << v14;
            if ((v15 & 0x284) != 0)
            {
              CFAllocatorRef v16 = CFGetAllocator(a1);
              uint64_t DigestForData_SHA256 = AMAuthInstallCryptoCreateDigestForData_SHA256(v16, a2, (CFTypeRef *)&value);
              goto LABEL_11;
            }
            if ((v15 & 0x401) != 0)
            {
              CFAllocatorRef v18 = CFGetAllocator(a1);
              uint64_t DigestForData_SHA256 = AMAuthInstallCryptoCreateDigestForData_SHA384(v18, a2, (CFTypeRef *)&value);
LABEL_11:
              uint64_t v11 = DigestForData_SHA256;
              uint64_t v10 = value;
              if (!DigestForData_SHA256)
              {
                if (value)
                {
                  CFDictionarySetValue(a3, a4, value);
                  uint64_t v11 = 0;
                  uint64_t v10 = value;
                }
                else
                {
                  uint64_t v11 = 2;
                }
              }
              goto LABEL_14;
            }
          }
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtMeasureBootImage", (uint64_t)"Unknown chipid", (uint64_t)a4, a5, a6, a7, a8, v20);
          uint64_t v10 = 0;
          uint64_t v11 = 99;
        }
      }
    }
  }
LABEL_14:
  SafeRelease(v10);
  return v11;
}

uint64_t AMAuthInstallRembrandtMeasureElf(void *a1, CFDataRef theData, __CFDictionary *a3, const void *a4, const void *a5)
{
  memset(&c, 0, sizeof(c));
  memset(&v44, 0, sizeof(v44));
  if ((unint64_t)CFDataGetLength(theData) <= 0x33
    || (BytePtr = CFDataGetBytePtr(theData), *(_DWORD *)BytePtr != 1179403647))
  {
    uint64_t v43 = "invalid file format";
LABEL_16:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtMeasureElf", (uint64_t)v43, v10, v11, v12, v13, v14, v44.count[0]);
    CFMutableDataRef Mutable = 0;
    uint64_t v30 = 0;
    uint64_t v41 = 10;
    goto LABEL_13;
  }
  CFAllocatorRef v16 = (unsigned __int16 *)BytePtr;
  uint64_t v17 = (unsigned int *)&BytePtr[*((unsigned int *)BytePtr + 7)];
  if ((v17[6] & 0x7000000) == 0x4000000)
  {
    uint64_t v43 = "file lacks a hash section";
    goto LABEL_16;
  }
  CFAllocatorRef v18 = &CFDataGetBytePtr(theData)[v17[1]];
  AMAuthInstallLogDumpMemory(7, (uint64_t)"AMAuthInstallRembrandtMeasureElf", (char)"hash section", (uint64_t)v18, v17[4], v19, v20, v21);
  CFAllocatorRef v22 = CFGetAllocator(a1);
  CFMutableDataRef Mutable = CFDataCreateMutable(v22, 0);
  if (!Mutable)
  {
    uint64_t v30 = 0;
    goto LABEL_18;
  }
  CFAllocatorRef v24 = CFGetAllocator(a1);
  uint64_t v30 = CFDataCreateMutable(v24, 0);
  if (!v30)
  {
LABEL_18:
    uint64_t v41 = 2;
    goto LABEL_13;
  }
  unsigned int v31 = *(_DWORD *)(a1[6] + 4) - 94;
  if (v31 > 0xA) {
    goto LABEL_11;
  }
  int v32 = 1 << v31;
  if ((v32 & 0x284) == 0)
  {
    if ((v32 & 0x401) != 0)
    {
      CFDataSetLength(Mutable, 48);
      CC_SHA384_Init(&v44);
      CC_SHA384_Update(&v44, v16, v16[20]);
      CC_SHA384_Update(&v44, v17, v16[21] * v16[22]);
      CC_SHA384_Update(&v44, v18, v17[4]);
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      CC_SHA384_Final(MutableBytePtr, &v44);
      CFDataSetLength(v30, 48);
      uint64_t v38 = CFDataGetBytePtr(theData);
      CC_LONG Length = CFDataGetLength(theData);
      int v40 = CFDataGetMutableBytePtr(v30);
      CC_SHA384(v38, Length, v40);
      goto LABEL_12;
    }
LABEL_11:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtMeasureElf", (uint64_t)"Unknown chipid", v25, v26, v27, v28, v29, v44.count[0]);
    goto LABEL_12;
  }
  CFDataSetLength(Mutable, 32);
  CC_SHA256_Init(&c);
  CC_SHA256_Update(&c, v16, v16[20]);
  CC_SHA256_Update(&c, v17, v16[21] * v16[22]);
  CC_SHA256_Update(&c, v18, v17[4]);
  uint64_t v33 = CFDataGetMutableBytePtr(Mutable);
  CC_SHA256_Final(v33, &c);
  CFDataSetLength(v30, 32);
  uint64_t v34 = CFDataGetBytePtr(theData);
  CC_LONG v35 = CFDataGetLength(theData);
  uint64_t v36 = CFDataGetMutableBytePtr(v30);
  CC_SHA256(v34, v35, v36);
LABEL_12:
  CFDictionarySetValue(a3, a5, v30);
  CFDictionarySetValue(a3, a4, Mutable);
  uint64_t v41 = 0;
LABEL_13:
  SafeRelease(v30);
  SafeRelease(Mutable);
  return v41;
}

uint64_t AMAuthInstallRembrandtMeasureBootPSI(void *a1, CFDataRef theData, __CFDictionary *a3, const void *a4, const __CFString *a5)
{
  CFNumberRef v5 = 0;
  int valuePtr = 0;
  uint64_t v62 = 0;
  long long bytes = 0u;
  long long v61 = 0u;
  uint64_t v59 = 0;
  memset(v58, 0, sizeof(v58));
  uint64_t v6 = 1;
  if (!a1 || !theData)
  {
    CFDataRef v9 = 0;
    goto LABEL_35;
  }
  CFDataRef v9 = 0;
  if (a3)
  {
    BytePtr = (unsigned int *)CFDataGetBytePtr(theData);
    uint64_t v14 = BytePtr[4];
    unint64_t v15 = BytePtr[5];
    unint64_t v17 = BytePtr[9];
    unint64_t v16 = BytePtr[10];
    unint64_t Length = CFDataGetLength(theData);
    int v24 = *(_DWORD *)(a1[6] + 4);
    if (v24 == 96)
    {
      if (Length <= v15)
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtMeasureBootPSI", (uint64_t)"gpuk_offset %d >= sizeToMeasure %lld", v19, v20, v21, v22, v23, v15);
LABEL_43:
        uint64_t v6 = 0;
        CFNumberRef v5 = 0;
        CFDataRef v9 = 0;
        goto LABEL_35;
      }
    }
    else if (Length <= v17)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtMeasureBootPSI", (uint64_t)"gpuk2_offset %d >= sizeToMeasure %lld", v19, v20, v21, v22, v23, v17);
      goto LABEL_43;
    }
    if (Length <= v16)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtMeasureBootPSI", (uint64_t)"signature_offset %d >= sizeToMeasure %lld", v19, v20, v21, v22, v23, v16);
      goto LABEL_43;
    }
    if (Length != v14)
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtMeasureBootPSI", (uint64_t)"size %d != sizeToMeasure %lld", v19, v20, v21, v22, v23, v14);
      goto LABEL_43;
    }
    BOOL v25 = v24 == 104 || v24 == 94;
    if (v25) {
      int v26 = 36;
    }
    else {
      int v26 = 52;
    }
    if (v25) {
      int v27 = 127;
    }
    else {
      int v27 = 63;
    }
    if (v25) {
      int v28 = -92;
    }
    else {
      int v28 = -76;
    }
    unsigned int v29 = v24 - 94;
    if (v29 <= 0xA)
    {
      CC_LONG v30 = v16 + v28 - ((v16 + v26) & v27);
      int v31 = 1 << v29;
      if ((v31 & 0x284) != 0) {
        goto LABEL_31;
      }
      if ((v31 & 0x401) != 0)
      {
        if (CFStringCompare(@"PSI2-PartialDigest", a5, 0)
          && CFStringCompare(@"RestorePSI2-PartialDigest", a5, 0))
        {
          AMAuthInstallLog(6, (uint64_t)"AMAuthInstallRembrandtMeasureBootPSI", (uint64_t)"Using SHA384 to hash %@", v32, v33, v34, v35, v36, (char)a4);
          uint64_t v37 = CFDataGetBytePtr(theData);
          memset(&c, 0, sizeof(c));
          CC_SHA384_Init(&c);
          CC_SHA384_Update(&c, v37, v30);
          for (unint64_t i = 0; i != 64; i += 16)
            *(int8x16_t *)&v58[i / 4 + 2] = vrev64q_s8(*(int8x16_t *)&c.hash[i / 8]);
          v58[0] = v16 - v30;
          v58[1] = v30;
          CFAllocatorRef v39 = CFGetAllocator(a1);
          p_long long bytes = (const UInt8 *)v58;
          CFIndex v41 = 72;
LABEL_32:
          CFDataRef v9 = CFDataCreate(v39, p_bytes, v41);
          if (v9)
          {
            CFDictionarySetValue(a3, a5, v9);
            int valuePtr = *((_DWORD *)CFDataGetBytePtr(theData) + 1024);
            AMAuthInstallLog(6, (uint64_t)"AMAuthInstallRembrandtMeasureBootPSI", (uint64_t)"%@: version=0x%x", v48, v49, v50, v51, v52, (char)a4);
            CFAllocatorRef v53 = CFGetAllocator(a1);
            CFNumberRef v5 = CFNumberCreate(v53, kCFNumberSInt32Type, &valuePtr);
            if (v5)
            {
              CFDictionarySetValue(a3, a4, v5);
              uint64_t v6 = 0;
              goto LABEL_35;
            }
LABEL_38:
            uint64_t v6 = 2;
            goto LABEL_35;
          }
LABEL_37:
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtMeasureBootPSI", (uint64_t)"%s CFDataCreate failed", v43, v44, v45, v46, v47, (char)"AMAuthInstallRembrandtMeasureBootPSI");
          CFNumberRef v5 = 0;
          CFDataRef v9 = 0;
          goto LABEL_38;
        }
        AMAuthInstallLog(6, (uint64_t)"AMAuthInstallRembrandtMeasureBootPSI", (uint64_t)"Using SHA256 to hash %@", v32, v33, v34, v35, v36, (char)a4);
LABEL_31:
        CFAllocatorRef v42 = CFDataGetBytePtr(theData);
        sub_100027AB0(v42, v30, (uint64_t)&bytes + 8);
        LODWORD(bytes) = v16 - v30;
        DWORD1(bytes) = v30;
        CFAllocatorRef v39 = CFGetAllocator(a1);
        p_long long bytes = (const UInt8 *)&bytes;
        CFIndex v41 = 40;
        goto LABEL_32;
      }
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtMeasureBootPSI", (uint64_t)"Unknown chipid", v19, v20, v21, v22, v23, v55);
    goto LABEL_37;
  }
LABEL_35:
  SafeRelease(v9);
  SafeRelease(v5);
  return v6;
}

uint64_t AMAuthInstallRembrandtMeasurePSI(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureBootPSI(a1, a2, a3, @"PSI-Version", @"PSI-PartialDigest");
}

uint64_t AMAuthInstallRembrandtMeasureRestorePSI(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureBootPSI(a1, a2, a3, @"RestorePSI-Version", @"RestorePSI-PartialDigest");
}

uint64_t AMAuthInstallRembrandtMeasurePSI2(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureBootPSI(a1, a2, a3, @"PSI-Version", @"PSI2-PartialDigest");
}

uint64_t AMAuthInstallRembrandtMeasureRestorePSI2(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureBootPSI(a1, a2, a3, @"RestorePSI-Version", @"RestorePSI2-PartialDigest");
}

uint64_t AMAuthInstallRembrandtMeasureEBL(void *a1, const __CFData *a2, __CFDictionary *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return AMAuthInstallRembrandtMeasureBootImage(a1, a2, a3, @"EBL-DownloadDigest", a5, a6, a7, a8);
}

uint64_t AMAuthInstallRembrandtMeasureSystemSoftware(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"SystemSW-HashTableDigest", @"SystemSW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureTDS(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"TDSFW-HashTableDigest", @"TDSFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureLTE(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"LTEFW-HashTableDigest", @"LTEFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureBBCFG(void *a1, const __CFData *a2, __CFDictionary *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return AMAuthInstallRembrandtMeasureBootImage(a1, a2, a3, @"BBCFG-DownloadDigest", a5, a6, a7, a8);
}

uint64_t AMAuthInstallRembrandtMeasure3GFW(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"3GFW-HashTableDigest", @"3GFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasure2GFW(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"2GFW-HashTableDigest", @"2GFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureRFFW(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"RFFW-HashTableDigest", @"RFFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureAntCfg(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"AntCFG-HashTableDigest", @"AntCFG-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureTPCU(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"TPCU-HashTableDigest", @"TPCU-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureUPC(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"UPC-HashTableDigest", @"UPC-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureLegacyRat(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"LegacyRATFW-HashTableDigest", @"LegacyRATFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureAudioFW(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"AudioFW-HashTableDigest", @"AudioFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureDebugInfo(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"DebugFW-HashTableDigest", @"DebugFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureRPCU(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"RPCU-HashTableDigest", @"RPCU-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureDPC(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"DPC-HashTableDigest", @"DPC-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureC2K(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"CDMA2KFW-HashTableDigest", @"CDMA2KFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasurecustpack(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"Custpack-HashTableDigest", @"Custpack-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureGNSSFW(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"GNSSFW-HashTableDigest", @"GNSSFW-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtMeasureIRXCoefficient(void *a1, const __CFData *a2, __CFDictionary *a3)
{
  return AMAuthInstallRembrandtMeasureElf(a1, a2, a3, @"IRXCoefficient-HashTableDigest", @"IRXCoefficient-DownloadDigest");
}

uint64_t AMAuthInstallRembrandtCopyNextComponentName(uint64_t a1, CFTypeRef *a2)
{
  *a2 = CFRetain(@"boot.bbfw");
  return 0;
}

uint64_t AMAuthInstallRembrandtLocalCreateSigningResponse(void *a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  int valuePtr = 0;
  CFStringRef v101 = 0;
  CFDictionaryRef value = 0;
  uint64_t v99 = 0;
  uint64_t v100 = 0;
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(v6, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtLocalCreateSigningResponse", (uint64_t)"Failed to allocate responseDict", v9, v10, v11, v12, v13, v97);
    CFTypeRef v71 = 0;
    CFMutableDictionaryRef v39 = 0;
    CFDictionaryRef v36 = 0;
LABEL_61:
    uint64_t v34 = 2;
    goto LABEL_50;
  }
  uint64_t v15 = AMAuthInstallRembrandtLocalRegisterKeys((uint64_t)a1, v7, v8, v9, v10, v11, v12, v13);
  if (v15)
  {
    uint64_t v34 = v15;
    CFTypeRef v71 = 0;
    CFMutableDictionaryRef v39 = 0;
    CFDictionaryRef v36 = 0;
    goto LABEL_50;
  }
  unint64_t v16 = CFDictionaryGetValue(a2, @"BbSNUM");
  if (!v16 || (uint64_t v22 = v16, TypeID = CFDataGetTypeID(), TypeID != CFGetTypeID(v22)))
  {
    CFAllocatorRef v84 = "bad or missing SNUM";
    goto LABEL_38;
  }
  int v24 = CFDictionaryGetValue(a2, @"BbChipID");
  if (!v24 || (BOOL v25 = v24, v26 = CFNumberGetTypeID(), v26 != CFGetTypeID(v25)))
  {
    CFAllocatorRef v84 = "bad or missing chipid";
    goto LABEL_38;
  }
  if (!CFNumberGetValue((CFNumberRef)v25, kCFNumberSInt32Type, &valuePtr))
  {
    CFAllocatorRef v84 = "failed to read chipid";
LABEL_38:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtLocalCreateSigningResponse", (uint64_t)v84, v17, v18, v19, v20, v21, v97);
    CFTypeRef v71 = 0;
    CFMutableDictionaryRef v39 = 0;
    CFDictionaryRef v36 = 0;
LABEL_39:
    uint64_t v34 = 1;
    goto LABEL_50;
  }
  int v27 = CFDictionaryGetValue(a2, @"BbGoldCertId");
  if (!v27 || (int v28 = v27, v29 = CFNumberGetTypeID(), v29 != CFGetTypeID(v28)))
  {
    CFAllocatorRef v84 = "bad or missing certid";
    goto LABEL_38;
  }
  CC_LONG v30 = CFDictionaryGetValue(a2, @"BasebandFirmware");
  if (!v30 || (v31 = v30, CFTypeID v32 = CFDictionaryGetTypeID(), v32 != CFGetTypeID(v31)))
  {
    CFAllocatorRef v84 = "bad or missing baseband firmware dict";
    goto LABEL_38;
  }
  CFAllocatorRef v33 = CFGetAllocator(a1);
  uint64_t v34 = 2;
  DeepCFStringRef Copy = (const __CFDictionary *)CFPropertyListCreateDeepCopy(v33, a2, 2uLL);
  CFDictionaryRef v36 = DeepCopy;
  if (!DeepCopy)
  {
    CFTypeRef v71 = 0;
    CFMutableDictionaryRef v39 = 0;
    goto LABEL_50;
  }
  uint64_t v37 = (__CFDictionary *)CFDictionaryGetValue(DeepCopy, @"BasebandFirmware");
  CFAllocatorRef v38 = CFGetAllocator(a1);
  CFMutableDictionaryRef v39 = CFDictionaryCreateMutable(v38, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v39)
  {
    CFTypeRef v71 = 0;
    goto LABEL_61;
  }
  CFDictionaryRef theDict = v37;
  CFDictionarySetValue(Mutable, @"BasebandFirmware", v39);
  int v40 = CFDictionaryGetValue((CFDictionaryRef)v31, @"PSI-PartialDigest");
  if (v40)
  {
    CFTypeID v41 = CFDataGetTypeID();
    if (v41 != CFGetTypeID(v40)) {
      goto LABEL_53;
    }
    uint64_t v47 = sub_10002D42C(a1, (const __CFData *)v40, (CFTypeRef *)&value, v42, v43, v44, v45, v46);
    if (v47) {
      goto LABEL_54;
    }
    CFDictionarySetValue(v39, @"PSI-Blob", value);
  }
  uint64_t v48 = CFDictionaryGetValue((CFDictionaryRef)v31, @"RestorePSI-PartialDigest");
  if (!v48) {
    goto LABEL_22;
  }
  uint64_t v49 = v48;
  CFTypeID v50 = CFDataGetTypeID();
  if (v50 != CFGetTypeID(v49))
  {
LABEL_53:
    CFTypeRef v71 = 0;
    goto LABEL_39;
  }
  uint64_t v47 = sub_10002D42C(a1, (const __CFData *)v49, (CFTypeRef *)&v101, v51, v52, v53, v54, v55);
  if (v47) {
    goto LABEL_54;
  }
  CFDictionarySetValue(v39, @"RestorePSI-Blob", v101);
LABEL_22:
  CFDataRef v61 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v31, @"PSI2-PartialDigest");
  if (v40)
  {
    CFTypeID v62 = CFDataGetTypeID();
    if (v62 != CFGetTypeID(v40)) {
      goto LABEL_53;
    }
  }
  if (!v61) {
    goto LABEL_27;
  }
  uint64_t v47 = sub_10002D42C(a1, v61, (CFTypeRef *)&v100, v56, v57, v58, v59, v60);
  if (v47)
  {
LABEL_54:
    uint64_t v34 = v47;
    CFTypeRef v71 = 0;
    goto LABEL_50;
  }
  CFDictionarySetValue(v39, @"PSI2-Blob", v100);
LABEL_27:
  uint64_t v63 = CFDictionaryGetValue((CFDictionaryRef)v31, @"RestorePSI2-PartialDigest");
  if (!v63) {
    goto LABEL_31;
  }
  uint64_t v64 = v63;
  CFTypeID v65 = CFDataGetTypeID();
  if (v65 != CFGetTypeID(v64)) {
    goto LABEL_53;
  }
  uint64_t v47 = sub_10002D42C(a1, (const __CFData *)v64, (CFTypeRef *)&v99, v66, v67, v68, v69, v70);
  if (v47) {
    goto LABEL_54;
  }
  CFDictionarySetValue(v39, @"RestorePSI2-Blob", v99);
LABEL_31:
  CFTypeRef v71 = 0;
  unsigned int v72 = *(_DWORD *)(a1[6] + 4) - 94;
  if (v72 <= 0xA)
  {
    int v73 = 1 << v72;
    if ((v73 & 0x284) != 0)
    {
      CFDataRef v74 = (const __CFData *)value;
      memset(&c, 0, 104);
      CFAllocatorRef v75 = CFGetAllocator(a1);
      uint64_t v76 = CFDataCreateMutable(v75, 32);
      uint64_t v77 = v76;
      if (v76)
      {
        CFDataSetLength(v76, 32);
        BytePtr = CFDataGetBytePtr((CFDataRef)v40);
        unsigned int v79 = *((_DWORD *)BytePtr + 1);
        CC_SHA256_Init((CC_SHA256_CTX *)&c);
        for (uint64_t i = 8; i != 40; i += 4)
          *(_DWORD *)((char *)c.count + i) = bswap32(*(_DWORD *)&BytePtr[i]);
        c.count[0] = v79;
        uint64_t v81 = CFDataGetBytePtr(v74);
        CC_LONG Length = CFDataGetLength(v74);
        CC_SHA256_Update((CC_SHA256_CTX *)&c, v81, Length);
        MutableBytePtr = CFDataGetMutableBytePtr(v77);
        CC_SHA256_Final(MutableBytePtr, (CC_SHA256_CTX *)&c);
        CFTypeRef v71 = CFRetain(v77);
        uint64_t v34 = 0;
        goto LABEL_45;
      }
      goto LABEL_62;
    }
    if ((v73 & 0x401) != 0)
    {
      CFDataRef v85 = (const __CFData *)value;
      memset(&c, 0, sizeof(c));
      CFAllocatorRef v86 = CFGetAllocator(a1);
      uint64_t v87 = CFDataCreateMutable(v86, 48);
      uint64_t v77 = v87;
      if (v87)
      {
        CFDataSetLength(v87, 48);
        uint64_t v88 = CFDataGetBytePtr((CFDataRef)v40);
        CFStringRef v89 = v88 + 8;
        CC_LONG64 v90 = *((unsigned int *)v88 + 1);
        CC_SHA384_Init(&c);
        for (uint64_t j = 0; j != 8; ++j)
          c.hash[j] = bswap64(*(void *)&v89[j * 8]);
        c.count[0] = v90;
        c.count[1] = 0;
        uint64_t v92 = CFDataGetBytePtr(v85);
        CC_LONG v93 = CFDataGetLength(v85);
        CC_SHA384_Update(&c, v92, v93);
        uint64_t v94 = CFDataGetMutableBytePtr(v77);
        CC_SHA384_Final(v94, &c);
        CFTypeRef v71 = CFRetain(v77);
        uint64_t v34 = 0;
LABEL_45:
        SafeRelease(v77);
        CFDictionarySetValue(theDict, @"PSI-DownloadDigest", v71);
        if (!v77) {
          goto LABEL_50;
        }
        goto LABEL_46;
      }
LABEL_62:
      CFTypeRef v71 = 0;
      uint64_t v34 = 2;
      goto LABEL_45;
    }
  }
LABEL_46:
  if (CFDictionaryContainsKey(a2, @"@BBTicket"))
  {
    uint64_t RootTicket = AMAuthInstallMaverickLocalCreateRootTicket();
    if (RootTicket)
    {
      uint64_t v34 = RootTicket;
      goto LABEL_50;
    }
    CFDictionarySetValue(Mutable, @"BBTicket", 0);
  }
  *a3 = CFRetain(Mutable);
  AMAuthInstallDebugWriteObject((char *)a1, a2, @"tss-request-bb-local", 2);
  AMAuthInstallDebugWriteObject((char *)a1, Mutable, @"tss-response-bb-local", 2);
  uint64_t v34 = 0;
LABEL_50:
  SafeRelease(v39);
  SafeRelease(value);
  SafeRelease(v101);
  SafeRelease(v100);
  SafeRelease(v99);
  SafeRelease(0);
  SafeRelease(v36);
  SafeRelease(Mutable);
  SafeRelease(v71);
  SafeRelease(0);
  return v34;
}

uint64_t AMAuthInstallRembrandtLocalRegisterKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(*(_DWORD *)(*(void *)(a1 + 48) + 4))
  {
    case '^':
    case 'h':
      AMAuthInstallCryptoRegisterKeysFromECCBuffer();
      AMAuthInstallCryptoRegisterKeysFromECCBuffer();
      AMAuthInstallCryptoRegisterKeysFromECCBuffer();
      AMAuthInstallCryptoRegisterKeysFromECCBuffer();
      AMAuthInstallCryptoRegisterKeysFromECCBuffer();
      AMAuthInstallCryptoRegisterKeysFromECCBuffer();
      goto LABEL_5;
    case 'e':
    case 'g':
      AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
      AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
LABEL_5:
      AMAuthInstallLog(6, (uint64_t)"AMAuthInstallRembrandtLocalRegisterKeys", (uint64_t)"rembrandt local signing keys available", v8, v9, v10, v11, v12, v14);
      uint64_t result = 0;
      break;
    default:
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtLocalRegisterKeys", (uint64_t)"unknown chipID", a4, a5, a6, a7, a8, v14);
      uint64_t result = 99;
      break;
  }
  return result;
}

uint64_t sub_10002D42C(void *cf, const __CFData *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(&c, 0, sizeof(c));
  memset(&v125, 0, sizeof(v125));
  CFDataRef v124 = 0;
  int v123 = 0;
  unsigned int v11 = *(_DWORD *)(cf[6] + 4) - 94;
  if (v11 <= 0xA)
  {
    int v12 = 1 << v11;
    if ((v12 & 0x284) != 0)
    {
      int v13 = 256;
      goto LABEL_6;
    }
    if ((v12 & 0x401) != 0)
    {
      int v13 = 104;
LABEL_6:
      int v123 = v13;
      if (a3) {
        goto LABEL_7;
      }
      goto LABEL_17;
    }
  }
  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"invalid chipid", a4, a5, a6, a7, a8, v121);
  if (!cf[6])
  {
    CFAllocatorRef v38 = "amai->bbParameters is NULL";
    goto LABEL_54;
  }
  int v13 = 0;
  if (!a3)
  {
LABEL_17:
    CFAllocatorRef v38 = "outPsiStitchDataData is NULL";
LABEL_54:
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)v38, a4, a5, a6, a7, a8, v121);
    uint64_t v22 = 0;
    CFDictionaryRef MutableCopy = 0;
    CFMutableDataRef Mutable = 0;
    goto LABEL_60;
  }
LABEL_7:
  CFAllocatorRef v14 = CFGetAllocator(cf);
  CFMutableDataRef Mutable = CFDataCreateMutable(v14, 0);
  if (!Mutable)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"stitchData is NULL", v15, v16, v17, v18, v19, v121);
    uint64_t v22 = 0;
    goto LABEL_52;
  }
  CFDataRef theData = 0;
  unsigned int v21 = *(_DWORD *)(cf[6] + 4) - 94;
  if (v21 < 0xB && ((0x685u >> v21) & 1) != 0)
  {
    uint64_t v25 = sub_10002DCB0((uint64_t)cf, (uint64_t)off_10009DD48[v21], (uint64_t)&theData, v15, v16, v17, v18, v19);
    if (v25)
    {
      uint64_t v24 = v25;
      uint64_t v22 = 0;
      CFDictionaryRef MutableCopy = 0;
      goto LABEL_46;
    }
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    CFDataAppendBytes(Mutable, BytePtr, Length);
    bytes[0] = xmmword_10007CDE7;
    bytes[1] = algn_10007CDF7;
    CFDataAppendBytes(Mutable, (const UInt8 *)bytes, 32);
    unsigned int v33 = *(_DWORD *)(cf[6] + 4) - 94;
    if (v33 <= 0xA)
    {
      int v34 = 1 << v33;
      if ((v34 & 0x284) != 0)
      {
        uint64_t v35 = CFDataGetBytePtr(a2);
        CFDictionaryRef v36 = v35;
        uint64_t v37 = 0;
LABEL_20:
        unsigned int v39 = *(_DWORD *)v35;
LABEL_21:
        uint64_t v40 = v39;
        CFIndex v41 = CFDataGetLength(Mutable);
        if (CFDataGetLength(Mutable) + 12 > v39)
        {
          CFDataGetLength(Mutable);
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"masteredReservationLength %d < CFDataGetLength(stitchData) %lld + snumLength %d", v104, v105, v106, v107, v108, v39);
          uint64_t v22 = 0;
          goto LABEL_58;
        }
        uint64_t v42 = v39 - v41 - 12;
        if (v40 - v41 == 12)
        {
          uint64_t v22 = 0;
          goto LABEL_26;
        }
        uint64_t v43 = (UInt8 *)malloc(v40 - v41 - 12);
        uint64_t v22 = v43;
        if (v43)
        {
          memset(v43, 255, v42);
          CFDataAppendBytes(Mutable, v22, v42);
LABEL_26:
          uint64_t v49 = CFDataGetBytePtr(*(CFDataRef *)(cf[6] + 16));
          CFIndex v50 = CFDataGetLength(*(CFDataRef *)(cf[6] + 16));
          CFDataAppendBytes(Mutable, v49, v50);
          CFIndex v51 = CFDataGetLength(*(CFDataRef *)(cf[6] + 16));
          uint64_t v57 = cf[6];
          if (v51 != 12)
          {
            char v109 = CFDataGetLength(*(CFDataRef *)(v57 + 16));
            AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"CFDataGetLength(amai->bbParameters->snum) %lld != snumLength %d", v110, v111, v112, v113, v114, v109);
            goto LABEL_58;
          }
          unsigned int v58 = *(_DWORD *)(v57 + 4) - 94;
          if (v58 > 0xA) {
            goto LABEL_38;
          }
          int v59 = 1 << v58;
          if ((v59 & 0x284) != 0)
          {
            CC_LONG v60 = *((_DWORD *)v36 + 1);
            CC_SHA256_Init(&c);
            for (uint64_t i = 2; i != 10; ++i)
              c.count[i] = bswap32(*(_DWORD *)&v36[i * 4]);
            c.count[0] = v60;
            c.count[1] = 0;
            CFTypeID v62 = CFDataGetBytePtr(Mutable);
            CC_LONG v63 = CFDataGetLength(Mutable);
            CC_SHA256_Update(&c, v62, v63);
            CC_SHA256_Final(md, &c);
            AMAuthInstallCryptoCreateRsaSignatureWithSHA256();
            if (CFDataGetLength(v124) != v13)
            {
              char v69 = CFDataGetLength(v124);
              AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"CFDataGetLength(signatureData) %lld != signatureLength %d", v70, v71, v72, v73, v74, v69);
LABEL_58:
              CFDictionaryRef MutableCopy = 0;
              goto LABEL_60;
            }
            goto LABEL_39;
          }
          if ((v59 & 0x401) != 0)
          {
            CFAllocatorRef v75 = v37 + 8;
            CC_LONG64 v76 = *((unsigned int *)v37 + 1);
            CC_SHA384_Init(&v125);
            for (uint64_t j = 0; j != 8; ++j)
              v125.hash[j] = bswap64(*(void *)&v75[j * 8]);
            v125.count[0] = v76;
            v125.count[1] = 0;
            char v78 = CFDataGetBytePtr(Mutable);
            CC_LONG v79 = CFDataGetLength(Mutable);
            CC_SHA384_Update(&v125, v78, v79);
            LOBYTE(v78) = *CFDataGetBytePtr(Mutable);
            CFDataGetLength(Mutable);
            AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"STITCH ptr 0x%x STITCH data 0x%x", v80, v81, v82, v83, v84, (char)v78);
            CC_SHA384_Final(md, &v125);
            AMAuthInstallCryptoCreateEcdsaSignatureWithSHA384();
          }
          else
          {
LABEL_38:
            AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"invalid chipid", v52, v53, v54, v55, v56, v121);
          }
LABEL_39:
          if (!v124)
          {
            AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"amai is NULL", v64, v65, v66, v67, v68, v121);
            goto LABEL_58;
          }
          CFIndex v85 = 0;
          CFDictionaryRef MutableCopy = 0;
          switch(*(_DWORD *)(cf[6] + 4))
          {
            case '^':
            case 'h':
              CFAllocatorRef v86 = CFDataGetBytePtr(v124);
              CFIndex v87 = CFDataGetLength(v124);
              CFDataAppendBytes(Mutable, v86, v87);
              CFDataAppendBytes(Mutable, byte_10007D9AD, 463);
              CFDataAppendBytes(Mutable, byte_10007DB7C, 450);
              LODWORD(v86) = CFDataGetLength(Mutable);
              CFDataIncreaseLength(Mutable, 5231);
              MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
              memset(&MutableBytePtr[v86], 255, 0x146FuLL);
              CFIndex v89 = CFDataGetLength(v124);
              CFDictionaryRef MutableCopy = 0;
              uint64_t v90 = 6144;
              goto LABEL_43;
              CFAllocatorRef v95 = CFGetAllocator(cf);
              CFDictionaryRef MutableCopy = CFDataCreateMutableCopy(v95, 0, v124);
              CFAllocatorRef v96 = CFDataGetMutableBytePtr(MutableCopy);
              CFIndex v97 = CFDataGetLength(MutableCopy);
              if ((v97 & 0xFFFFFFFE) != 0)
              {
                uint64_t v98 = v97 >> 1;
                CFIndex v99 = v97 - 1;
                uint64_t v100 = v96;
                do
                {
                  UInt8 v101 = v96[v99];
                  v96[v99] = *v100;
                  *v100++ = v101;
                  --v99;
                  --v98;
                }
                while (v98);
              }
              CFAllocatorRef v102 = CFDataGetBytePtr(MutableCopy);
              CFIndex v103 = CFDataGetLength(MutableCopy);
              CFDataAppendBytes(Mutable, v102, v103);
              CFDataAppendBytes(Mutable, byte_10007CE07, 540);
              CFDataAppendBytes(Mutable, byte_10007D023, 796);
              CFIndex v85 = v40 + CFDataGetLength(MutableCopy) + 1336;
              break;
            case 'e':
            case 'g':
              uint64_t v91 = CFDataGetBytePtr(v124);
              CFIndex v92 = CFDataGetLength(v124);
              CFDataAppendBytes(Mutable, v91, v92);
              CFDataAppendBytes(Mutable, byte_10007D33F, 818);
              CFDataAppendBytes(Mutable, byte_10007D671, 828);
              LODWORD(v91) = CFDataGetLength(Mutable);
              CFDataIncreaseLength(Mutable, 4490);
              CC_LONG v93 = CFDataGetMutableBytePtr(Mutable);
              memset(&v93[v91], 255, 0x118AuLL);
              CFIndex v89 = CFDataGetLength(v124);
              CFDictionaryRef MutableCopy = 0;
              uint64_t v90 = 6136;
LABEL_43:
              CFIndex v85 = v40 + v90 + v89;
              break;
            default:
              break;
          }
          if (v85 == CFDataGetLength(Mutable))
          {
            uint64_t v24 = 0;
            *a3 = CFRetain(Mutable);
            goto LABEL_46;
          }
          char v115 = CFDataGetLength(Mutable);
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"stitchData is %lld, expected size is %d", v116, v117, v118, v119, v120, v115);
LABEL_60:
          uint64_t v24 = 1;
          goto LABEL_46;
        }
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"paddingBytes is NULL", v44, v45, v46, v47, v48, v121);
LABEL_52:
        CFDictionaryRef MutableCopy = 0;
        uint64_t v24 = 2;
        goto LABEL_46;
      }
      if ((v34 & 0x401) != 0)
      {
        uint64_t v35 = CFDataGetBytePtr(a2);
        uint64_t v37 = v35;
        CFDictionaryRef v36 = 0;
        goto LABEL_20;
      }
    }
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"invalid chipid", v28, v29, v30, v31, v32, v121);
    unsigned int v39 = 0;
    CFDictionaryRef v36 = 0;
    uint64_t v37 = 0;
    goto LABEL_21;
  }
  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallRembrandtLocalCreatePSIStitchData", (uint64_t)"invalid chipid", v15, v16, v17, v18, v19, v121);
  uint64_t v22 = 0;
  CFDictionaryRef MutableCopy = 0;
  uint64_t v24 = 99;
LABEL_46:
  SafeRelease(Mutable);
  SafeRelease(v124);
  SafeRelease(MutableCopy);
  SafeFree(v22);
  return v24;
}

uint64_t sub_10002DCB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1;
  if (!a1 || !a2 || !a3) {
    return v8;
  }
  unsigned int v9 = *(_DWORD *)(*(void *)(a1 + 48) + 4) - 94;
  if (v9 > 0xA) {
    goto LABEL_13;
  }
  int v10 = 1 << v9;
  if ((v10 & 0x284) != 0)
  {
    return AMAuthInstallCryptoCreateDigestForKey_SHA256();
  }
  if ((v10 & 0x401) == 0)
  {
LABEL_13:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRembrandtLocalCreateDigestForKey", (uint64_t)"Unknown chipid", a4, a5, a6, a7, a8, vars0);
    return 99;
  }
  return AMAuthInstallCryptoCreateDigestForOnlyKeySha384();
}

uint64_t AMAuthInstallRequestSendSyncWithHeader(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  CFTypeRef v133 = 0;
  CFTypeRef cf = 0;
  uint64_t v132 = 0;
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v9 = 2;
  DeepCFStringRef Copy = (__CFDictionary *)CFPropertyListCreateDeepCopy(v8, a2, 2uLL);
  CFMutableDictionaryRef theDict = DeepCopy;
  if (!DeepCopy) {
    goto LABEL_28;
  }
  uint64_t v16 = *(const void **)(a1 + 64);
  if (v16) {
    CFDictionarySetValue(DeepCopy, @"@Locality", v16);
  }
  uint64_t v17 = (const void **)(a1 + 120);
  CFDataRef v18 = *(const __CFData **)(a1 + 120);
  CFDataRef v19 = v18;
  if (!v18)
  {
    if (!*(void *)(a1 + 104))
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"SSO function returned NULL and no SSO token was provided, SSO disabled.", v11, v12, v13, v14, v15, v126);
      goto LABEL_15;
    }
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"using SSO.", v11, v12, v13, v14, v15, v126);
    CFDataRef v19 = (const __CFData *)*v17;
    if (!*v17)
    {
      uint64_t v25 = *(uint64_t (**)(uint64_t, CFAllocatorRef, uint64_t, uint64_t *))(a1 + 104);
      CFAllocatorRef v26 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v27 = v25(a1, v26, a1 + 120, &v132);
      if (v27)
      {
        uint64_t v9 = v27;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"failed to create sso data %@", v28, v29, v30, v31, v32, v132);
        goto LABEL_13;
      }
      CFDataRef v19 = (const __CFData *)*v17;
      if (!*v17)
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"SSO failed to authenticate.", v28, v29, v30, v31, v32, v126);
        CFDataRef Data = 0;
        uint64_t v34 = 0;
        uint64_t v9 = 22;
        goto LABEL_29;
      }
    }
  }
  AMAuthInstallCryptoCreateDigestForData(kCFAllocatorDefault, v19, &cf);
  if (cf)
  {
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"AuthUserId Hash: %@", v20, v21, v22, v23, v24, (char)cf);
    CFRelease(cf);
  }
  CFDictionarySetValue(theDict, @"AuthUserId", *v17);
  if (!v18)
  {
    SafeRelease(*v17);
    *uint64_t v17 = 0;
  }
LABEL_15:
  uint64_t v35 = *(void *)(a1 + 16);
  if (!v35) {
    goto LABEL_21;
  }
  if (*(void *)(v35 + 144))
  {
    uint64_t context = a1;
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
    if (MutableCopy)
    {
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_10002E38C, &context);
      SafeRelease(theDict);
      CFMutableDictionaryRef theDict = MutableCopy;
      uint64_t v35 = *(void *)(a1 + 16);
      if (!v35) {
        goto LABEL_21;
      }
      goto LABEL_19;
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"fullrequest copy allocation failure", v36, v37, v38, v39, v40, v126);
    uint64_t v9 = 0;
LABEL_13:
    CFDataRef Data = 0;
    uint64_t v34 = 0;
    goto LABEL_29;
  }
LABEL_19:
  CFDictionaryRef v41 = *(const __CFDictionary **)(v35 + 136);
  if (v41) {
    CFDictionaryApplyFunction(v41, (CFDictionaryApplierFunction)sub_10002E52C, theDict);
  }
LABEL_21:
  uint64_t v42 = theDict;
  Simpleuint64_t PlatformInfoString = AMAuthInstallPlatformGetSimplePlatformInfoString();
  CFDictionarySetValue(v42, @"@HostPlatformInfo", SimplePlatformInfoString);
  uint64_t v44 = theDict;
  CFStringRef LibraryVersionString = AMAuthInstallSupportGetLibraryVersionString();
  CFDictionarySetValue(v44, @"@VersionInfo", LibraryVersionString);
  uint64_t v46 = *(void *)(a1 + 16);
  if (!v46 || !*(unsigned char *)(v46 + 116)) {
    CFDictionarySetValue(theDict, @"@BBTicket", kCFBooleanTrue);
  }
  uint64_t v47 = *(const void **)(a1 + 96);
  if (v47) {
    CFDictionarySetValue(theDict, @"@UUID", v47);
  }
  uint64_t v48 = AMAuthInstallVinylRemoveFirmwareLoaderVersionTag((const void *)a1, &theDict);
  if (v48)
  {
    uint64_t v9 = v48;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"AMAuthInstallVinylRemoveFirmwareLoaderVersionTag %d", v49, v50, v51, v52, v53, v48);
LABEL_28:
    CFDataRef Data = 0;
    uint64_t v34 = 0;
    goto LABEL_29;
  }
  uint64_t v9 = 2;
  AMAuthInstallDebugWriteObject((char *)a1, theDict, @"tss-request", 2);
  session = tss_create_session(&stru_10009EF88, *(const void **)(a1 + 72));
  uint64_t v34 = (uint64_t)session;
  if (!session)
  {
    CFDataRef Data = 0;
    goto LABEL_29;
  }
  CFRelease((CFTypeRef)session[3]);
  *(void *)(v34 + 24) = CFRetain(theDict);
  *(_DWORD *)(v34 + 16) = *(_DWORD *)(a1 + 80);
  *(void *)(v34 + 80) = *(void *)(a1 + 488);
  *(void *)(v34 + 88) = *(void *)(a1 + 512);
  *(void *)(v34 + 32) = a3;
  unsigned int v70 = tss_submit(v34, v63, v64, v65, v66, v67, v68, v69);
  int v76 = v70;
  if (!v70)
  {
    uint64_t v9 = 0;
    goto LABEL_52;
  }
  if (v70 <= 0x2710)
  {
    uint64_t v77 = *(const void **)(v34 + 72);
    if (v77)
    {
      uint64_t v9 = v70 + 3100;
      LODWORD(context) = v70 + 3100;
      if (v70 < 0x384)
      {
        CFAllocatorRef v78 = CFGetAllocator((CFTypeRef)a1);
        CFNumberRef v84 = CFNumberCreate(v78, kCFNumberIntType, &context);
        if (v84)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 352), v84, v77);
          AMAuthInstallLog(7, (uint64_t)"kAMAuthInstallRequestCacheLocalizedTssError", (uint64_t)"cached server error text: (%d) %@", v85, v86, v87, v88, v89, context);
        }
        else
        {
          AMAuthInstallLog(3, (uint64_t)"kAMAuthInstallRequestCacheLocalizedTssError", (uint64_t)"failed to cache server error text: (%d) %@", v79, v80, v81, v82, v83, context);
        }
        SafeRelease(v84);
        goto LABEL_51;
      }
      AMAuthInstallLog(3, (uint64_t)"kAMAuthInstallRequestCacheLocalizedTssError", (uint64_t)"tss error code out of bounds (%d)", v71, v72, v73, v74, v75, v70 + 28);
    }
  }
  SafeRelease(0);
  if (v76 > 9999)
  {
    if ((v76 - 10000) > 0xC) {
      uint64_t v9 = 14;
    }
    else {
      uint64_t v9 = dword_10007DD40[v76 - 10000];
    }
  }
  else
  {
    uint64_t v9 = (v76 + 3100);
  }
LABEL_51:
  char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v9);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"failed tss submission: %@", v91, v92, v93, v94, v95, LocalizedStatusString);
LABEL_52:
  CFAllocatorRef v96 = CFGetAllocator((CFTypeRef)a1);
  CFDataRef Data = CFPropertyListCreateData(v96, theDict, kCFPropertyListXMLFormat_v1_0, 0, 0);
  if (Data)
  {
    CFAllocatorRef v97 = CFGetAllocator((CFTypeRef)a1);
    int v103 = AMAuthInstallSupportBase64Encode(v97, Data, &v133, v98, v99, v100, v101, v102);
    if (v76)
    {
      if (!v103)
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"failed tss request:<<<<<<<<<<\n%@", v104, v105, v106, v107, v108, (char)v133);
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"failed tss request:>>>>>>>>>>", v109, v110, v111, v112, v113, v127);
      }
    }
    else
    {
      if (!v103)
      {
        AMAuthInstallLog(8, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"successful tss request:<<<<<<<<<<\n%@", v104, v105, v106, v107, v108, (char)v133);
        AMAuthInstallLog(8, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"successful tss request:>>>>>>>>>>", v114, v115, v116, v117, v118, v128);
      }
      unint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v34 + 40), @"@ServerVersion");
      CFStringRef v125 = @"unavailable";
      if (Value) {
        LOBYTE(v125) = (_BYTE)Value;
      }
      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"received tss response (server version: %@)", v120, v121, v122, v123, v124, (char)v125);
      AMAuthInstallDebugWriteObject((char *)a1, *(CFTypeRef *)(v34 + 40), @"tss-response", 2);
      uint64_t v9 = 0;
      if (a4) {
        *a4 = CFRetain(*(CFTypeRef *)(v34 + 40));
      }
    }
  }
LABEL_29:
  SafeRelease(0);
  SafeRelease(0);
  SafeRelease(theDict);
  SafeRelease(0);
  SafeRelease(Data);
  SafeRelease(v133);
  SafeRelease(0);
  if (v34) {
    tss_close_session((void *)v34, v54, v55, v56, v57, v58, v59, v60);
  }
  return v9;
}

void sub_10002E38C(const __CFString *a1, const void *a2, CFMutableDictionaryRef *a3)
{
  CFDictionaryRef MutableCopy = (__CFString *)kCFAllocatorDefault;
  CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@,", *(void *)(*((void *)*a3 + 2) + 144));
  uint64_t v18 = *((void *)*a3 + 11);
  CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"@%@");
  if (v13 && (CFDictionaryRef MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, a1)) != 0)
  {
    if (CFStringHasPrefix(a1, @"Ap,"))
    {
      uint64_t v14 = MutableCopy;
      v15.CFIndex location = 0;
      v15.CFIndex length = 3;
LABEL_7:
      CFStringReplace(v14, v15, v7);
      uint64_t v16 = a3[1];
      CFStringRef v17 = MutableCopy;
LABEL_8:
      CFDictionarySetValue(v16, v17, a2);
      CFDictionaryRemoveValue(a3[1], a1);
      goto LABEL_9;
    }
    if (CFStringHasPrefix(a1, @"Ap"))
    {
      uint64_t v14 = MutableCopy;
      v15.CFIndex location = 0;
      v15.CFIndex length = 2;
      goto LABEL_7;
    }
    if (CFEqual(a1, @"@ApImg4Ticket"))
    {
      uint64_t v16 = a3[1];
      CFStringRef v17 = v13;
      goto LABEL_8;
    }
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"_ApplyTagPrefix", (uint64_t)"Failed allocation", v8, v9, v10, v11, v12, v18);
  }
LABEL_9:
  SafeRelease(v7);
  SafeRelease(v13);
  SafeRelease(MutableCopy);
}

void sub_10002E52C(void *key, const void *a2, CFDictionaryRef theDict)
{
  if (CFDictionaryContainsKey(theDict, key))
  {
    unint64_t Value = CFDictionaryGetValue(theDict, key);
    CFDictionarySetValue(theDict, a2, Value);
    CFDictionaryRemoveValue(theDict, key);
  }
}

uint64_t AMAuthInstallRequestSendSync(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  return AMAuthInstallRequestSendSyncWithHeader(a1, a2, 0, a3);
}

uint64_t AMAuthInstallSsoInitialize()
{
  if (qword_1000B8CB0) {
    goto LABEL_5;
  }
  uint64_t v0 = dlopen("/usr/lib/libSoftwareUpdateSSO.dylib", 1);
  qword_1000B8CB0 = (uint64_t)v0;
  if (v0)
  {
    off_1000B8CC0 = dlsym(v0, "copyPersonalizationSSOToken");
    if (off_1000B8CC0)
    {
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallSsoInitialize", (uint64_t)"SoftwareUpdateSSO dylib found", v6, v7, v8, v9, v10, v24);
LABEL_5:
      uint64_t v11 = 0;
      goto LABEL_6;
    }
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoSUSSOInit", (uint64_t)"copyPersonalizationSSOToken symbol not found", v6, v7, v8, v9, v10, v24);
    dlclose((void *)qword_1000B8CB0);
    qword_1000B8CB0 = 0;
    uint64_t v11 = 8;
  }
  else
  {
    uint64_t v11 = 4;
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSsoInitialize", (uint64_t)"SoftwareUpdateSSO dylib not found", v1, v2, v3, v4, v5, v24);
LABEL_6:
  if (!qword_1000B8CA0)
  {
    uint64_t v12 = dlopen("/usr/lib/libacmobileshim.dylib", 1);
    qword_1000B8CA0 = (uint64_t)v12;
    if (v12)
    {
      off_1000B8CB8 = dlsym(v12, "ACMobileShimCopyTicket");
      if (off_1000B8CB8)
      {
        AMAuthInstallLog(7, (uint64_t)"AMAuthInstallSsoInitialize", (uint64_t)"ACMobileShim dylib found", v18, v19, v20, v21, v22, v24);
        return 0;
      }
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoACMobileInit", (uint64_t)"ACMobileShimGetTicket symbol not found", v18, v19, v20, v21, v22, v24);
      dlclose((void *)qword_1000B8CA0);
      qword_1000B8CA0 = 0;
      uint64_t v11 = 8;
    }
    else
    {
      uint64_t v11 = 4;
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSsoInitialize", (uint64_t)"ACMobileShim dylib not found", v13, v14, v15, v16, v17, v24);
  }
  return v11;
}

uint64_t sub_10002E724(uint64_t a1, const __CFAllocator *a2, CFDataRef *a3)
{
  SInt32 error = 0;
  CFOptionFlags responseFlags = 0;
  CFErrorRef err = 0;
  if (!a3)
  {
    uint64_t v24 = 1;
LABEL_64:
    AMSupportCreateErrorInternal();
    CFDictionaryRef v23 = 0;
    uint64_t v25 = 0;
    goto LABEL_44;
  }
  BOOL v5 = a1 && *(unsigned char *)(a1 + 112) || byte_1000B8CA8 != 0;
  uint64_t valuePtr = 0;
  p_uint64_t valuePtr = &valuePtr;
  uint64_t v110 = 0x2000000000;
  uint64_t v111 = 0;
  uint64_t v104 = 0;
  uint64_t v105 = &v104;
  uint64_t v106 = 0x2000000000;
  uint64_t v107 = 0;
  uint64_t v100 = 0;
  uint64_t v101 = &v100;
  uint64_t v102 = 0x2000000000;
  char v103 = 0;
  if (off_1000B8CC0)
  {
    CFMutableDataRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v7 = Mutable;
    if (v5) {
      uint64_t v8 = (const void **)&kCFBooleanTrue;
    }
    else {
      uint64_t v8 = (const void **)&kCFBooleanFalse;
    }
    CFDictionaryAddValue(Mutable, @"stealthMode", *v8);
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = _NSConcreteStackBlock;
    block[1] = (const void *)1107296256;
    block[2] = sub_10002FAEC;
    block[3] = &unk_10009DDA0;
    block[4] = &valuePtr;
    block[5] = &v104;
    block[6] = &v100;
    block[7] = v7;
    dispatch_async(global_queue, block);
    while (!*((unsigned char *)v101 + 24))
      CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0, 1u);
    if (v105[3] || (CFDictionaryRef v10 = (const __CFDictionary *)p_valuePtr[3]) == 0)
    {
      char v17 = 99;
      AMSupportCreateErrorInternal();
      LOBYTE(Value) = 0;
    }
    else
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v10, @"ssodata");
      if (Value)
      {
        AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallSsoCopyTicketUsingSUSSO", (uint64_t)"_AMAuthInstallSsoCopyTicketUsingSUSSO successfully acquired ssoData", v11, v12, v13, v14, v15, v91);
        char v17 = 0;
        *a3 = CFDataCreateCopy(kCFAllocatorDefault, Value);
        LOBYTE(Value) = 1;
      }
      else
      {
        char v17 = 99;
        AMSupportCreateErrorInternal();
      }
    }
  }
  else
  {
    char v17 = 8;
    AMSupportCreateErrorInternal();
    LOBYTE(Value) = 0;
    uint64_t v7 = 0;
  }
  SafeRelease(v7);
  SafeRelease((CFTypeRef)p_valuePtr[3]);
  SafeRelease((CFTypeRef)v105[3]);
  _Block_object_dispose(&v100, 8);
  _Block_object_dispose(&v104, 8);
  _Block_object_dispose(&valuePtr, 8);
  if (Value)
  {
    CFDictionaryRef v23 = 0;
    uint64_t v24 = 0;
LABEL_18:
    uint64_t v25 = 0;
    goto LABEL_44;
  }
  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"failed to get a ticket using SUSSO, status:%d, error:%@", v18, v19, v20, v21, v22, v17);
  if (v5)
  {
    uint64_t v24 = 21;
    goto LABEL_64;
  }
  if (!off_1000B8CB8)
  {
    uint64_t v24 = 8;
    goto LABEL_64;
  }
  LODWORD(valuePtr) = 0;
  LODWORD(v104) = 1;
  LODWORD(v100) = 0;
  block[0] = 0;
  CFNumberRef v26 = CFNumberCreate(a2, kCFNumberIntType, &valuePtr);
  uint64_t v94 = a3;
  if (!v26)
  {
    CFDictionaryRef v95 = 0;
    uint64_t v31 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    CFNumberRef v27 = 0;
LABEL_78:
    CFNumberRef v41 = 0;
    uint64_t v24 = 2;
    goto LABEL_35;
  }
  CFNumberRef v27 = CFNumberCreate(a2, kCFNumberIntType, &v104);
  if (!v27)
  {
    CFDictionaryRef v95 = 0;
    uint64_t v31 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    uint64_t v28 = 0;
LABEL_69:
    uint64_t v29 = 0;
    goto LABEL_78;
  }
  uint64_t v28 = CFArrayCreateMutable(a2, 0, &kCFTypeArrayCallBacks);
  if (!v28)
  {
    CFDictionaryRef v95 = 0;
    uint64_t v31 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    goto LABEL_69;
  }
  uint64_t v29 = CFArrayCreateMutable(a2, 0, &kCFTypeArrayCallBacks);
  if (!v29)
  {
    CFDictionaryRef v95 = 0;
    uint64_t v31 = 0;
LABEL_73:
    uint64_t v39 = 0;
    goto LABEL_77;
  }
  CFArrayAppendValue(v28, v26);
  CFArrayAppendValue(v28, v26);
  CFArrayAppendValue(v29, v27);
  CFArrayAppendValue(v29, v27);
  uint64_t v30 = CFArrayCreateMutable(a2, 0, &kCFTypeArrayCallBacks);
  uint64_t v31 = v30;
  if (!v30)
  {
    CFDictionaryRef v95 = 0;
    goto LABEL_73;
  }
  CFArrayAppendValue(v30, @"Username");
  CFArrayAppendValue(v31, @"Password");
  uint64_t v32 = sub_10002F478(block, 0);
  if ((v32 & 7) != 0)
  {
    uint64_t v24 = v32;
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateUserNotificationSettings", (uint64_t)"failed to retrieve credentials from the keychain", v33, v34, v35, v36, v37, v92);
    CFDictionaryRef v95 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    CFNumberRef v41 = 0;
    goto LABEL_35;
  }
  if (block[0])
  {
    uint64_t v38 = CFArrayCreateMutable(a2, 0, &kCFTypeArrayCallBacks);
    uint64_t v39 = v38;
    if (v38)
    {
      CFArrayAppendValue(v38, block[0]);
      goto LABEL_31;
    }
    CFDictionaryRef v95 = 0;
LABEL_77:
    uint64_t v40 = 0;
    goto LABEL_78;
  }
  uint64_t v39 = 0;
LABEL_31:
  uint64_t v40 = CFDictionaryCreateMutable(a2, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v40)
  {
    CFDictionaryRef v95 = 0;
    goto LABEL_78;
  }
  CFNumberRef v41 = CFNumberCreate(a2, kCFNumberIntType, &v100);
  CFDictionaryAddValue(v40, kCFUserNotificationAlertHeaderKey, @"AppleConnect");
  CFDictionaryAddValue(v40, kCFUserNotificationTextFieldTitlesKey, v31);
  CFDictionaryAddValue(v40, kCFUserNotificationDefaultButtonTitleKey, @"OK");
  CFDictionaryAddValue(v40, kCFUserNotificationAlternateButtonTitleKey, @"Cancel");
  CFDictionaryAddValue(v40, @"SBUserNotificationBehavesSuperModally", kCFBooleanTrue);
  CFDictionaryAddValue(v40, @"SBUserNotificationTextAutocapitalizationType", v28);
  CFDictionaryAddValue(v40, @"SBUserNotificationTextAutocorrectionType", v29);
  CFDictionaryAddValue(v40, @"SBUserNotificationDontDismissOnUnlock", kCFBooleanTrue);
  CFDictionaryAddValue(v40, @"DismissOnLock", kCFBooleanFalse);
  CFDictionaryAddValue(v40, kCFUserNotificationKeyboardTypesKey, v41);
  CFDictionaryAddValue(v40, kCFUserNotificationAlertTopMostKey, kCFBooleanTrue);
  CFDictionaryAddValue(v40, @"SBUserNotificationDisplayActionButtonOnLockScreen", kCFBooleanTrue);
  if (v39) {
    CFDictionaryAddValue(v40, kCFUserNotificationTextFieldValuesKey, v39);
  }
  CFDictionaryRef v95 = (const __CFDictionary *)CFRetain(v40);
  uint64_t v24 = 0;
LABEL_35:
  SafeRelease(0);
  SafeRelease(v31);
  SafeRelease(v39);
  SafeRelease(v40);
  SafeRelease(block[0]);
  SafeRelease(v28);
  SafeRelease(v29);
  SafeRelease(v26);
  SafeRelease(v27);
  SafeRelease(v41);
  CFDictionaryRef v23 = v95;
  if (v24 || !v95)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"%s failed", v42, v43, v44, v45, v46, (char)"_AMAuthInstallSsoCreateServiceTicket");
    AMSupportCreateErrorInternal();
    goto LABEL_18;
  }
  AMAuthInstallLog(5, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"%s: Creating user notification", v42, v43, v44, v45, v46, (char)"_AMAuthInstallSsoCreateServiceTicket");
  uint64_t v47 = CFUserNotificationCreate(a2, 0.0, 0x20000uLL, &error, v95);
  uint64_t v25 = v47;
  if (!v47)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"failed to create CFUserNotification", v48, v49, v50, v51, v52, v93);
    uint64_t v24 = 2;
    goto LABEL_43;
  }
  SInt32 error = CFUserNotificationReceiveResponse(v47, 300.0, &responseFlags);
  if (error)
  {
    CFUserNotificationCancel(v25);
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"failed to receive CFUserNotification response %d", v58, v59, v60, v61, v62, error);
LABEL_40:
    uint64_t v24 = 8;
LABEL_43:
    AMSupportCreateErrorInternal();
    goto LABEL_44;
  }
  responseFlags &= 3u;
  if (responseFlags == 1)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"user canceled AppleConnect login.", v53, v54, v55, v56, v57, v93);
    uint64_t v24 = 21;
    goto LABEL_43;
  }
  CFDictionaryRef ResponseDictionary = CFUserNotificationGetResponseDictionary(v25);
  if (!ResponseDictionary)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"failed to get CFUserNotification response dictionary", v65, v66, v67, v68, v69, v93);
    goto LABEL_40;
  }
  CFArrayRef v70 = (const __CFArray *)CFDictionaryGetValue(ResponseDictionary, kCFUserNotificationTextFieldValuesKey);
  if (!v70 || (CFArrayRef v76 = v70, CFArrayGetCount(v70) < 0))
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"failed to get CFUserNotification textField values", v71, v72, v73, v74, v75, v93);
    goto LABEL_40;
  }
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v76, 0);
  CFStringRef v78 = (const __CFString *)CFArrayGetValueAtIndex(v76, 1);
  if (!ValueAtIndex || (CFStringRef v84 = v78, CFStringGetLength(ValueAtIndex) < 1) || !v84 || CFStringGetLength(v84) <= 0)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"failed to get username and password values", v79, v80, v81, v82, v83, v93);
    uint64_t v24 = 1;
    goto LABEL_43;
  }
  uint64_t v85 = sub_10002F83C(ValueAtIndex);
  if (v85)
  {
    uint64_t v24 = v85;
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCreateServiceTicket", (uint64_t)"failed to save username in keychain", v86, v87, v88, v89, v90, v93);
    goto LABEL_43;
  }
  uint64_t v24 = off_1000B8CB8(ValueAtIndex, v84, v94, &err);
  if (v24 && err)
  {
    CFErrorGetCode(err);
    goto LABEL_43;
  }
LABEL_44:
  SafeRelease(v25);
  SafeRelease(v23);
  return v24;
}

uint64_t AMAuthInstallSsoEnable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  if (qword_1000B8CA0)
  {
    uint64_t result = 0;
    *(void *)(a1 + 104) = sub_10002E724;
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSsoEnable", (uint64_t)"ACMobile dylib not loaded", a4, a5, a6, a7, a8, vars0);
    return 99;
  }
  return result;
}

uint64_t AMAuthInstallSsoSetStealthMode(uint64_t a1, char a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 112) = a2;
  return result;
}

uint64_t AMAuthInstallSsoSetAppleConnectInfo(void *a1, const __CFString *cf, const void *a3)
{
  CFMutableDataRef Mutable = 0;
  uint64_t v4 = 1;
  if (a1)
  {
    if (cf)
    {
      CFTypeID v8 = CFGetTypeID(cf);
      CFTypeID TypeID = CFStringGetTypeID();
      CFMutableDataRef Mutable = 0;
      if (a3)
      {
        if (v8 == TypeID)
        {
          CFTypeID v10 = CFGetTypeID(a3);
          if (v10 == CFDataGetTypeID())
          {
            CFAllocatorRef v11 = CFGetAllocator(a1);
            CFMutableDataRef Mutable = CFDataCreateMutable(v11, 0);
            if (Mutable)
            {
              CFIndex Length = CFStringGetLength(cf);
              CFDataSetLength(Mutable, Length + 1);
              MutableBytePtr = (char *)CFDataGetMutableBytePtr(Mutable);
              CFIndex v14 = CFDataGetLength(Mutable);
              if (CFStringGetCString(cf, MutableBytePtr, v14, 0x8000100u))
              {
                BytePtr = CFDataGetBytePtr((CFDataRef)a3);
                CFIndex v16 = CFDataGetLength((CFDataRef)a3);
                CFDataAppendBytes(Mutable, BytePtr, v16);
                uint64_t v4 = 0;
                a1[15] = CFRetain(Mutable);
              }
              else
              {
                uint64_t v4 = 3;
              }
            }
            else
            {
              uint64_t v4 = 2;
            }
          }
          else
          {
            CFMutableDataRef Mutable = 0;
          }
        }
      }
    }
  }
  SafeRelease(Mutable);
  return v4;
}

uint64_t AMAuthInstallSsoSetToken(uint64_t a1, CFTypeRef cf)
{
  uint64_t result = 1;
  if (a1 && cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFDataGetTypeID())
    {
      uint64_t v6 = *(const void **)(a1 + 120);
      if (v6) {
        CFRelease(v6);
      }
      CFTypeRef v7 = CFRetain(cf);
      uint64_t result = 0;
      *(void *)(a1 + 120) = v7;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_10002F478(void *a1, CFStringRef *a2)
{
  CFTypeRef result = 0;
  if (!a1)
  {
    CFTypeID v5 = 0;
    CFDataRef v6 = 0;
LABEL_25:
    uint64_t v35 = 1;
    goto LABEL_20;
  }
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFTypeID v5 = Mutable;
  if (!Mutable)
  {
    CFDataRef v6 = 0;
    goto LABEL_23;
  }
  CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
  CFDataRef v6 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)"APPLECONNECT.APPLE.COM", 22, kCFAllocatorNull);
  if (!v6)
  {
LABEL_23:
    uint64_t v35 = 2;
    goto LABEL_20;
  }
  CFDictionarySetValue(v5, kSecAttrGeneric, v6);
  CFDictionarySetValue(v5, kSecAttrService, @"com.apple.MobileSoftwareUpdate");
  CFDictionarySetValue(v5, kSecMatchLimit, kSecMatchLimitOne);
  CFDictionarySetValue(v5, kSecReturnAttributes, kCFBooleanTrue);
  OSStatus v7 = SecItemCopyMatching(v5, &result);
  if (v7 == -25300)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCopyCredentialsFromKeychain", (uint64_t)"Credentials not found", v8, v9, v10, v11, v12, v43);
    uint64_t v35 = 8;
    goto LABEL_20;
  }
  if (v7)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCopyCredentialsFromKeychain", (uint64_t)"unexpected error: %d", v8, v9, v10, v11, v12, v7);
    uint64_t v35 = 14;
    goto LABEL_20;
  }
  if (!result)
  {
    SafeRelease(0);
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCopyCredentialsFromKeychain", (uint64_t)"Username not found", v38, v39, v40, v41, v42, v43);
    goto LABEL_25;
  }
  CFDataRef Value = CFDictionaryGetValue((CFDictionaryRef)result, kSecAttrAccount);
  *a1 = Value;
  CFRetain(Value);
  SafeRelease(0);
  if (!a2) {
    goto LABEL_19;
  }
  CFTypeRef v45 = 0;
  if (result)
  {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)result);
    uint64_t v20 = MutableCopy;
    if (MutableCopy)
    {
      CFDictionarySetValue(MutableCopy, kSecReturnData, kCFBooleanTrue);
      CFDictionarySetValue(v20, kSecClass, kSecClassGenericPassword);
      OSStatus v21 = SecItemCopyMatching(v20, &v45);
      if (v21 == -25300)
      {
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCopyPasswordFromKeychain", (uint64_t)"password not found in keychain response", v22, v23, v24, v25, v26, v43);
        char v36 = 0;
        uint64_t v35 = 8;
      }
      else if (v21)
      {
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCopyPasswordFromKeychain", (uint64_t)"unexpected error: %d", v22, v23, v24, v25, v26, v21);
        char v36 = 0;
        uint64_t v35 = 14;
      }
      else
      {
        CFDictionaryRemoveValue(v20, kSecReturnData);
        BytePtr = CFDataGetBytePtr((CFDataRef)v45);
        CFIndex Length = CFDataGetLength((CFDataRef)v45);
        CFStringRef v29 = CFStringCreateWithBytes(kCFAllocatorDefault, BytePtr, Length, 0x8000100u, 0);
        *a2 = v29;
        if (v29)
        {
          uint64_t v35 = 0;
          char v36 = 1;
        }
        else
        {
          uint64_t v35 = 3;
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCopyPasswordFromKeychain", (uint64_t)"Failed to convert password", v30, v31, v32, v33, v34, v43);
          char v36 = 0;
        }
      }
    }
    else
    {
      char v36 = 0;
      uint64_t v35 = 2;
    }
  }
  else
  {
    char v36 = 0;
    uint64_t v20 = 0;
    uint64_t v35 = 1;
  }
  SafeRelease(v45);
  SafeRelease(v20);
  if ((v36 & 1) == 0)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoCopyCredentialsFromKeychain", (uint64_t)"Password not found", v14, v15, v16, v17, v18, v43);
  }
  else
  {
LABEL_19:
    AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallSsoCopyCredentialsFromKeychain", (uint64_t)"Found Credentials for username=%@ ", v14, v15, v16, v17, v18, *a1);
    uint64_t v35 = 0;
  }
LABEL_20:
  SafeRelease(v5);
  SafeRelease(result);
  SafeRelease(v6);
  return v35;
}

uint64_t sub_10002F83C(const void *a1)
{
  CFTypeRef result = 0;
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v3 = Mutable;
  if (!Mutable)
  {
    CFDictionaryRef MutableCopy = 0;
    CFDataRef v4 = 0;
LABEL_11:
    CFTypeID v5 = 0;
    uint64_t v12 = 2;
    goto LABEL_8;
  }
  CFDictionarySetValue(Mutable, kSecClass, kSecClassGenericPassword);
  CFDataRef v4 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)"APPLECONNECT.APPLE.COM", 22, kCFAllocatorNull);
  if (!v4)
  {
    CFDictionaryRef MutableCopy = 0;
    goto LABEL_11;
  }
  CFDictionarySetValue(v3, kSecAttrGeneric, v4);
  CFDictionarySetValue(v3, kSecAttrService, @"com.apple.MobileSoftwareUpdate");
  CFDictionarySetValue(v3, kSecMatchLimit, kSecMatchLimitOne);
  CFDictionarySetValue(v3, kSecReturnAttributes, kCFBooleanTrue);
  CFTypeID v5 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(v5, kSecAttrAccount, a1);
  CFDictionarySetValue(v5, kSecAttrService, @"com.apple.MobileSoftwareUpdate");
  if (!SecItemCopyMatching(v3, &result))
  {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)result);
    CFDictionarySetValue(MutableCopy, kSecClass, kSecClassGenericPassword);
    OSStatus v14 = SecItemUpdate(MutableCopy, v5);
    if (!v14)
    {
      uint64_t v12 = 0;
      goto LABEL_8;
    }
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoSaveCredentialsInKeychain", (uint64_t)"SecItemUpdate ret=%d", v15, v16, v17, v18, v19, v14);
LABEL_14:
    uint64_t v12 = 14;
    goto LABEL_8;
  }
  CFDictionarySetValue(v5, kSecClass, kSecClassGenericPassword);
  CFDictionarySetValue(v5, kSecAttrGeneric, v4);
  OSStatus v6 = SecItemAdd(v5, 0);
  if (v6)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallSsoSaveCredentialsInKeychain", (uint64_t)"SecItemAdd ret=%d", v7, v8, v9, v10, v11, v6);
    CFDictionaryRef MutableCopy = 0;
    goto LABEL_14;
  }
  uint64_t v12 = 0;
  CFDictionaryRef MutableCopy = 0;
LABEL_8:
  SafeRelease(result);
  SafeRelease(MutableCopy);
  SafeRelease(0);
  SafeRelease(v3);
  SafeRelease(0);
  SafeRelease(v4);
  SafeRelease(v5);
  return v12;
}

CFTypeRef sub_10002FAEC(void *a1)
{
  *(void *)(*(void *)(a1[4] + 8) + 24) = off_1000B8CC0(a1[7], *(void *)(a1[5] + 8) + 24);
  SafeRetain(*(CFTypeRef *)(*(void *)(a1[4] + 8) + 24));
  CFTypeRef result = SafeRetain(*(CFTypeRef *)(*(void *)(a1[5] + 8) + 24));
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
  return result;
}

void sub_10002FB64(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 8);
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 8);
  CFDataRef v4 = *(const void **)(a2 + 48);
  _Block_object_assign((void *)(a1 + 48), v4, 8);
}

void sub_10002FBC4(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 48), 8);
  _Block_object_dispose(*(const void **)(a1 + 40), 8);
  uint64_t v2 = *(const void **)(a1 + 32);
  _Block_object_dispose(v2, 8);
}

void SafeRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t AMAuthInstallSupportCreateDictionaryFromFileURL(const __CFAllocator *a1, CFTypeRef *a2, const __CFURL *a3)
{
  uint64_t v3 = 0;
  CFErrorRef error = 0;
  CFDataRef data = 0;
  uint64_t v4 = 1;
  if (a2 && a3)
  {
    uint64_t DataFromFileURL = AMAuthInstallPlatformCreateDataFromFileURL(a1, (CFTypeRef *)&data, a3);
    if (DataFromFileURL)
    {
      uint64_t v4 = DataFromFileURL;
      uint64_t v3 = 0;
    }
    else
    {
      if (!data)
      {
        uint64_t v3 = 0;
        uint64_t v4 = 14;
        goto LABEL_10;
      }
      CFPropertyListRef v8 = CFPropertyListCreateWithData(a1, data, 0, 0, &error);
      uint64_t v3 = v8;
      if (v8)
      {
        uint64_t v4 = 0;
        *a2 = CFRetain(v8);
      }
      else
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCreateDictionaryFromFileURL", (uint64_t)"failed to create property list: %@", v9, v10, v11, v12, v13, (char)error);
        uint64_t v4 = 2;
      }
    }
  }
  if (data) {
    CFRelease(data);
  }
LABEL_10:
  if (error) {
    CFRelease(error);
  }
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

CFTypeRef SafeRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void SafeFree(void *a1)
{
  if (a1) {
    free(a1);
  }
}

void _CFDictionarySetInteger64(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  if (!v5) {
    sub_100072154();
  }
  CFNumberRef v6 = v5;
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v6);
}

void _CFDictionarySetInteger32(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v5) {
    sub_100072180();
  }
  CFNumberRef v6 = v5;
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v6);
}

void AMAuthInstallSupportDictionarySetBoolean(__CFDictionary *a1, const void *a2, int a3)
{
  uint64_t v3 = (const void **)&kCFBooleanTrue;
  if (!a3) {
    uint64_t v3 = (const void **)&kCFBooleanFalse;
  }
  CFDictionarySetValue(a1, a2, *v3);
}

void _CFDictionarySetBoolean(__CFDictionary *a1, const void *a2, int a3)
{
  uint64_t v3 = (const void **)&kCFBooleanTrue;
  if (!a3) {
    uint64_t v3 = (const void **)&kCFBooleanFalse;
  }
  CFDictionarySetValue(a1, a2, *v3);
}

uint64_t _CFDictionaryGetBoolean(const void *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v16 = "dict is NULL";
LABEL_13:
    AMAuthInstallLog(3, (uint64_t)"_CFDictionaryGetBoolean", (uint64_t)v16, a4, a5, a6, a7, a8, v17);
    return a3;
  }
  if (!a2)
  {
    uint64_t v16 = "key is NULL";
    goto LABEL_13;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a1))
  {
    uint64_t v16 = "dict is not CFDictionary";
    goto LABEL_13;
  }
  CFDataRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, a2);
  if (!Value) {
    return a3;
  }
  uint64_t v13 = Value;
  CFTypeID v14 = CFBooleanGetTypeID();
  if (v14 != CFGetTypeID(v13))
  {
    uint64_t v16 = "dict value is not CFBoolean";
    goto LABEL_13;
  }
  return CFBooleanGetValue((CFBooleanRef)v13);
}

CFArrayRef _CFArrayCreateWithObjects(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFIndex v9 = 0;
  uint64_t v13 = (void **)&a9;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)values = 0u;
  long long v15 = 0u;
  while (1)
  {
    uint64_t v10 = v13++;
    uint64_t v11 = *v10;
    if (!v11) {
      break;
    }
    values[v9++] = v11;
    if (v9 == 32) {
      return 0;
    }
  }
  return CFArrayCreate(a1, (const void **)values, v9, &kCFTypeArrayCallBacks);
}

const char *_CopyHexStringFromData(const __CFAllocator *a1, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  CFTypeRef result = (const char *)calloc(1uLL, (2 * Length) | 1);
  if (result)
  {
    uint64_t v7 = (char *)result;
    if (Length)
    {
      uint64_t v8 = 0;
      do
      {
        unsigned int v9 = *BytePtr++;
        result[v8] = a0123456789abcd[(unint64_t)v9 >> 4];
        result[(v8 + 1)] = a0123456789abcd[v9 & 0xF];
        v8 += 2;
      }
      while (2 * Length != v8);
    }
    CFStringRef v10 = CFStringCreateWithCString(a1, result, 0x8000100u);
    free(v7);
    return (const char *)v10;
  }
  return result;
}

uint64_t _CFStringToUInt32(const __CFString *a1, _DWORD *a2)
{
  uint64_t result = CFStringGetCString(a1, buffer, 32, 0x600u);
  if (result)
  {
    *__error() = 0;
    *a2 = strtoul(buffer, 0, 0);
    return *__error() == 0;
  }
  return result;
}

CFPropertyListRef AMAuthInstallPreferencesCopyStringValue(const __CFString *a1, const __CFString *a2)
{
  if (!a1)
  {
    CFPropertyListRef v4 = 0;
    if (!a2) {
      goto LABEL_8;
    }
LABEL_6:
    if (!v4) {
      CFPropertyListRef v4 = CFPreferencesCopyAppValue(a2, @"com.apple.libauthinstall");
    }
LABEL_8:
    if (!v4) {
      return v4;
    }
    goto LABEL_9;
  }
  CFPropertyListRef v4 = CFPreferencesCopyAppValue(a1, kCFPreferencesCurrentApplication);
  if (!v4)
  {
    CFPropertyListRef v4 = CFPreferencesCopyAppValue(a1, @"com.apple.libauthinstall");
    if (!a2) {
      goto LABEL_8;
    }
    goto LABEL_6;
  }
LABEL_9:
  CFTypeID v5 = CFGetTypeID(v4);
  if (v5 != CFStringGetTypeID())
  {
    CFRelease(v4);
    return 0;
  }
  return v4;
}

CFStringRef AMAuthInstallPreferencesGetBooleanValue(const __CFString *result, const __CFString *a2, Boolean *a3)
{
  Boolean keyExistsAndHasValidFormat = 0;
  if (result)
  {
    CFStringRef v5 = result;
    uint64_t result = (const __CFString *)CFPreferencesGetAppBooleanValue(result, kCFPreferencesCurrentApplication, &keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat) {
      goto LABEL_8;
    }
    uint64_t result = (const __CFString *)CFPreferencesGetAppBooleanValue(v5, @"com.apple.libauthinstall", &keyExistsAndHasValidFormat);
    BOOL v6 = keyExistsAndHasValidFormat == 0;
    if (!a2) {
      goto LABEL_8;
    }
  }
  else
  {
    BOOL v6 = 1;
    if (!a2) {
      goto LABEL_8;
    }
  }
  if (v6) {
    uint64_t result = (const __CFString *)CFPreferencesGetAppBooleanValue(a2, @"com.apple.libauthinstall", &keyExistsAndHasValidFormat);
  }
LABEL_8:
  if (a3) {
    *a3 = keyExistsAndHasValidFormat;
  }
  return result;
}

CFAllocatorRef AMAuthInstallSupportCopyAllocator()
{
  v1.reallocate = 0;
  memset(&v1, 0, 40);
  v1.allocate = (CFAllocatorAllocateCallBack)j__malloc;
  v1.deallocate = (CFAllocatorDeallocateCallBack)j__free;
  v1.preferredSize = 0;
  return CFAllocatorCreate(kCFAllocatorDefault, &v1);
}

uint64_t AMAuthInstallSupportRemoveFile(const __CFURL *a1)
{
  BOOL v3 = 0;
  uint64_t result = AMAuthInstallPlatformFileURLExists(a1, &v3);
  if (!result)
  {
    if (!v3) {
      return 0;
    }
    uint64_t result = AMAuthInstallPlatformRemoveFile(a1);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t AMAuthInstallSupportCopyURLWithAppendedComponent(const __CFAllocator *a1, const void *a2, const __CFString *a3, Boolean a4, CFURLRef *a5)
{
  if (a2 && a3 && a5) {
    return AMAuthInstallPlatformCopyURLWithAppendedComponent(a1, a2, a3, a4, a5);
  }
  else {
    return 1;
  }
}

uint64_t AMAuthInstallSupportCreateDataFromFileURL(const __CFAllocator *a1, CFTypeRef *a2, CFTypeRef cf)
{
  CFTypeRef cfa = 0;
  uint64_t DataFromFileURL = 1;
  if (a2 && cf)
  {
    uint64_t v6 = AMAuthInstallSupportCopyPreserveFileURL(a1, cf, &cfa, 0);
    if (v6)
    {
      uint64_t DataFromFileURL = v6;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCreateDataFromFileURL", (uint64_t)"AMAuthInstallSupportCopyPreserveFileURL failed.", v7, v8, v9, v10, v11, v13);
    }
    else
    {
      uint64_t DataFromFileURL = AMAuthInstallPlatformCreateDataFromFileURL(a1, a2, (const __CFURL *)cfa);
    }
    if (cfa) {
      CFRelease(cfa);
    }
  }
  return DataFromFileURL;
}

uint64_t AMAuthInstallSupportCopyPreserveFileURL(const __CFAllocator *a1, CFTypeRef cf, CFTypeRef *a3, int a4)
{
  uint64_t v4 = 1;
  char v20 = 1;
  if (cf && a3)
  {
    CFURLRef v7 = (const __CFURL *)CFRetain(cf);
    CFTypeRef v8 = CFRetain(cf);
    CFStringRef v9 = 0;
    CFMutableStringRef Mutable = 0;
    CFStringRef v11 = 0;
    uint64_t v12 = 1;
    while (1)
    {
      uint64_t v13 = AMAuthInstallPlatformFileURLExists(v7, (BOOL *)&v20);
      if (v13)
      {
        uint64_t v4 = v13;
        goto LABEL_25;
      }
      if (!v20) {
        goto LABEL_21;
      }
      if (v11) {
        CFRelease(v11);
      }
      CFStringRef v11 = CFStringCreateWithFormat(a1, 0, @"~%d", v12);
      if (!v11) {
        goto LABEL_38;
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (v9) {
        CFRelease(v9);
      }
      CFMutableStringRef Mutable = CFStringCreateMutable(a1, 0);
      if (!Mutable) {
        break;
      }
      CFStringRef v9 = CFURLCopyFileSystemPath((CFURLRef)cf, kCFURLPOSIXPathStyle);
      if (!v9) {
        goto LABEL_38;
      }
      CFStringAppend(Mutable, v9);
      CFStringAppend(Mutable, v11);
      if (v8) {
        CFRelease(v8);
      }
      CFTypeRef v8 = CFRetain(v7);
      CFRelease(v7);
      CFURLRef v14 = CFURLCreateWithFileSystemPath(a1, Mutable, kCFURLPOSIXPathStyle, 0);
      if (!v14)
      {
        uint64_t v4 = 2;
LABEL_28:
        CFRelease(v11);
        goto LABEL_29;
      }
      CFURLRef v7 = v14;
      if (v20)
      {
        BOOL v15 = v12 > 0x1E;
        uint64_t v12 = (v12 + 1);
        if (!v15) {
          continue;
        }
      }
LABEL_21:
      if (a4) {
        CFURLRef v16 = v7;
      }
      else {
        CFURLRef v16 = (const __CFURL *)v8;
      }
      uint64_t v4 = 0;
      *a3 = CFRetain(v16);
      goto LABEL_25;
    }
    CFStringRef v9 = 0;
LABEL_38:
    uint64_t v4 = 2;
LABEL_25:
    if (v7) {
      CFRelease(v7);
    }
    if (v11) {
      goto LABEL_28;
    }
LABEL_29:
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v9) {
      CFRelease(v9);
    }
    if (v8) {
      CFRelease(v8);
    }
  }
  return v4;
}

uint64_t AMAuthInstallSupportCopyDataFromHexString(int a1, CFStringRef theString, uint64_t *a3)
{
  uint64_t v3 = 1;
  if (theString)
  {
    if (a3)
    {
      uint64_t v3 = 3;
      if (CFStringGetCString(theString, buffer, 512, 0x8000100u))
      {
        uint64_t v5 = AMSupportCopyDataFromAsciiEncodedHex();
        *a3 = v5;
        if (v5) {
          return 0;
        }
        else {
          return 3;
        }
      }
    }
  }
  return v3;
}

CFStringRef AMAuthInstallSupportGetLibraryVersionString()
{
  return @"libauthinstall_device-1033.60.13";
}

uint64_t AMAuthInstallSupportBase64Encode(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!theData)
  {
    long long v29 = "value == NULL";
LABEL_11:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Encode", (uint64_t)v29, a4, a5, a6, a7, a8, v31);
    return 1;
  }
  if (!CFDataGetLength(theData))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Encode", (uint64_t)"value length == 0: '%@'", a4, a5, a6, a7, a8, (char)theData);
    return 1;
  }
  if (!a3)
  {
    long long v29 = "outEncodedValue == NULL";
    goto LABEL_11;
  }
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  uint64_t v13 = b64encode(BytePtr, Length);
  if (v13)
  {
    long long v19 = (UInt8 *)v13;
    int v20 = strlen(v13);
    if (v20)
    {
      CFStringRef v26 = CFStringCreateWithBytes(a1, v19, v20, 0x8000100u, 0);
      if (v26)
      {
        CFStringRef v27 = v26;
        *a3 = CFRetain(v26);
        free(v19);
        CFRelease(v27);
        return 0;
      }
      uint64_t v30 = "encodedValue == NULL: '%@'";
    }
    else
    {
      uint64_t v30 = "encodedLength == 0: '%@'";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Encode", (uint64_t)v30, v21, v22, v23, v24, v25, (char)theData);
    free(v19);
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Encode", (uint64_t)"encodedBuffer == NULL: '%@'", v14, v15, v16, v17, v18, (char)theData);
  }
  return 99;
}

uint64_t AMAuthInstallSupportBase64Decode(const __CFAllocator *a1, CFStringRef theString, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!theString)
  {
    uint64_t v39 = "value == NULL";
LABEL_13:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Decode", (uint64_t)v39, a4, a5, a6, a7, a8, v40);
    return 1;
  }
  if (!CFStringGetLength(theString))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Decode", (uint64_t)"value length == 0: '%@'", a4, a5, a6, a7, a8, (char)theString);
    return 1;
  }
  if (!a3)
  {
    uint64_t v39 = "outDecodedValue == NULL";
    goto LABEL_13;
  }
  size_t v11 = (int)(CFStringGetLength(theString) + 1);
  uint64_t v12 = (char *)malloc(v11);
  if (!v12)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Decode", (uint64_t)"failed to allocate buffer", v13, v14, v15, v16, v17, (char)theString);
    return 2;
  }
  uint64_t v18 = v12;
  if (!CFStringGetCString(theString, v12, v11, 0x8000100u))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Decode", (uint64_t)"failed to convert value to c-string", v19, v20, v21, v22, v23, (char)theString);
LABEL_19:
    uint64_t v37 = 2;
    goto LABEL_20;
  }
  int v24 = b64decode(v18, v11);
  if (v24 <= 0)
  {
    char v41 = (char)theString;
    uint64_t v37 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Decode", (uint64_t)"b64decode of value '%@' failed with error code %d.", v25, v26, v27, v28, v29, v41);
LABEL_20:
    free(v18);
    return v37;
  }
  CFDataRef v30 = CFDataCreate(a1, (const UInt8 *)v18, v24);
  if (!v30)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Decode", (uint64_t)"decodedData is NULL", v31, v32, v33, v34, v35, (char)theString);
    goto LABEL_19;
  }
  CFDataRef v36 = v30;
  *a3 = CFRetain(v30);
  free(v18);
  CFRelease(v36);
  return 0;
}

uint64_t AMAuthInstallSupportCreateDecodedPEM(uint64_t a1, size_t __size, void *a3, size_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v32 = "pemBuffer == NULL";
LABEL_34:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCreateDecodedPEM", (uint64_t)v32, (uint64_t)a4, a5, a6, a7, a8, v34);
    uint64_t v18 = 0;
    uint64_t v30 = 1;
    goto LABEL_29;
  }
  if (!__size)
  {
    uint64_t v32 = "pemBufferLength == 0";
    goto LABEL_34;
  }
  if (!a3)
  {
    uint64_t v32 = "outData == NULL";
    goto LABEL_34;
  }
  if (!a4)
  {
    uint64_t v32 = "outDataLength == NULL";
    goto LABEL_34;
  }
  uint64_t v12 = (char *)calloc(1uLL, __size);
  uint64_t v18 = v12;
  if (!v12)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCreateDecodedPEM", (uint64_t)"base64Buffer == NULL", v13, v14, v15, v16, v17, v34);
    uint64_t v30 = 2;
    goto LABEL_29;
  }
  uint64_t v19 = 0;
  size_t v20 = 0;
  unint64_t v21 = 0;
  uint64_t v22 = 1;
LABEL_7:
  char v23 = 0;
  uint64_t v24 = v22;
  while (1)
  {
    uint64_t v22 = v24;
    if (v20 >= __size || v21 > 1 || (v24 & 1) == 0) {
      break;
    }
    unsigned int v25 = *(unsigned __int8 *)(a1 + v20);
    if (v25 == 10 || v25 == 13)
    {
      v21 += v23 & 1;
      goto LABEL_21;
    }
    if (v25 == 45 || (v23 & 1) != 0)
    {
      ++v20;
      char v23 = 1;
    }
    else
    {
      if (v25 - 48 < 0xA || (v25 & 0xFFFFFFDF) - 65 < 0x1A)
      {
LABEL_25:
        ++v20;
        v12[v19++] = v25;
        goto LABEL_7;
      }
LABEL_21:
      char v23 = 0;
      uint64_t v24 = 0;
      if (v25 <= 0x3D)
      {
        uint64_t v24 = 0;
        if (((1 << v25) & 0x2000880100002600) != 0) {
          goto LABEL_25;
        }
      }
    }
  }
  if ((v24 & 1) == 0)
  {
    char v34 = v20;
    uint64_t v33 = "Input PEM has non-base64 chars at byte %d";
LABEL_38:
    uint64_t v30 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCreateDecodedPEM", (uint64_t)v33, v13, v14, v15, v16, v17, v34);
    goto LABEL_29;
  }
  size_t v27 = (int)b64decode(v12, v19);
  uint64_t v28 = calloc(1uLL, v27);
  if (!v28)
  {
    uint64_t v33 = "decodedCopy == NULL";
    goto LABEL_38;
  }
  uint64_t v29 = v28;
  memcpy(v28, v18, v27);
  uint64_t v30 = 0;
  *a4 = v27;
  *a3 = v29;
LABEL_29:
  free(v18);
  return v30;
}

uint64_t AMAuthInstallSupportWriteDataToFileURL(const __CFAllocator *a1, const __CFData *a2, const __CFURL *cf, int a4)
{
  CFTypeRef cfa = 0;
  uint64_t v4 = 1;
  if (!a2 || !cf) {
    return v4;
  }
  if (a4)
  {
    uint64_t v7 = AMAuthInstallSupportRemoveFile(cf);
    if (v7)
    {
LABEL_12:
      uint64_t v4 = v7;
      goto LABEL_13;
    }
    CFURLRef v8 = 0;
LABEL_8:
    if (v8) {
      CFURLRef v15 = v8;
    }
    else {
      CFURLRef v15 = cf;
    }
    uint64_t v7 = AMAuthInstallPlatformWriteDataToFileURL(a2, v15);
    goto LABEL_12;
  }
  uint64_t v9 = AMAuthInstallSupportCopyPreserveFileURL(a1, cf, &cfa, 1);
  if (!v9)
  {
    CFURLRef v8 = (const __CFURL *)cfa;
    goto LABEL_8;
  }
  uint64_t v4 = v9;
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportWriteDataToFileURL", (uint64_t)"AMAuthInstallSupportCopyPreserveFileURL failed.", v10, v11, v12, v13, v14, v17);
LABEL_13:
  if (cfa) {
    CFRelease(cfa);
  }
  return v4;
}

CFIndex AMAuthInstallSupportApplyDictionaryOverrides(int a1, CFDictionaryRef theDict, CFMutableDictionaryRef *a3, const __CFString *a4)
{
  CFIndex Count = 1;
  if (theDict && a3 && *a3)
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    CFURLRef v8 = (const void **)malloc(8 * Count);
    uint64_t v9 = (const void **)malloc(8 * Count);
    uint64_t v10 = v9;
    if (v8 && v9)
    {
      CFDictionaryGetKeysAndValues(theDict, v8, v9);
      if (Count < 1)
      {
        CFIndex Count = 0;
        goto LABEL_17;
      }
      uint64_t v16 = "invalid overridesKey";
      char v17 = (CFStringRef *)v8;
      uint64_t v18 = v10;
      while (1)
      {
        CFStringRef v19 = *v17;
        if (!*v17)
        {
LABEL_22:
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportApplyDictionaryOverrides", (uint64_t)v16, v11, v12, v13, v14, v15, v22);
          CFIndex Count = 99;
          goto LABEL_17;
        }
        size_t v20 = *v18;
        if (!*v18)
        {
          uint64_t v16 = "invalid overridesValue";
          goto LABEL_22;
        }
        if (!a4) {
          goto LABEL_13;
        }
        if (CFStringFind(*v17, a4, 0).location != -1) {
          break;
        }
LABEL_14:
        ++v18;
        ++v17;
        if (!--Count) {
          goto LABEL_17;
        }
      }
      CFStringRef v19 = *v17;
      size_t v20 = *v18;
LABEL_13:
      CFDictionarySetValue(*a3, v19, v20);
      goto LABEL_14;
    }
    CFIndex Count = 2;
    if (v8) {
LABEL_17:
    }
      free(v8);
    if (v10) {
      free(v10);
    }
  }
  return Count;
}

CFDictionaryRef AMAuthInstallSupportGetValueForKeyPathInDict(const __CFAllocator *a1, const __CFDictionary *a2, CFStringRef theString, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef Value = a2;
  if (!a2)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportGetValueForKeyPathInDict", (uint64_t)"dict is NULL", a4, a5, a6, a7, a8, v22);
    return Value;
  }
  if (!theString)
  {
    unint64_t v21 = "keyPath is NULL";
LABEL_15:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportGetValueForKeyPathInDict", (uint64_t)v21, a4, a5, a6, a7, a8, v22);
    return 0;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, theString, @".");
  if (!ArrayBySeparatingStrings)
  {
    unint64_t v21 = "keys is NULL";
    goto LABEL_15;
  }
  CFArrayRef v10 = ArrayBySeparatingStrings;
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  if (Count >= 1)
  {
    CFIndex v12 = Count;
    CFIndex v13 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v10, v13);
      if (!ValueAtIndex) {
        break;
      }
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, ValueAtIndex);
      if (Value)
      {
        if (v12 != ++v13) {
          continue;
        }
      }
      goto LABEL_9;
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportGetValueForKeyPathInDict", (uint64_t)"key is NULL", v15, v16, v17, v18, v19, v22);
    CFDictionaryRef Value = 0;
  }
LABEL_9:
  CFRelease(v10);
  return Value;
}

CFDictionaryRef AMAuthInstallSupportGetValueForKeyWithFormat(const __CFAllocator *a1, const __CFDictionary *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!a3) {
    return 0;
  }
  CFStringRef v11 = CFStringCreateWithFormatAndArguments(a1, 0, a3, &a9);
  if (!v11) {
    return 0;
  }
  CFStringRef v17 = v11;
  CFDictionaryRef ValueForKeyPathInDict = AMAuthInstallSupportGetValueForKeyPathInDict(a1, a2, v11, v12, v13, v14, v15, v16);
  CFRelease(v17);
  return ValueForKeyPathInDict;
}

uint64_t AMAuthInstallSupportCopyFile(uint64_t a1, const void *a2, const __CFURL *a3)
{
  CFTypeRef cf = 0;
  uint64_t v3 = 1;
  if (!a2 || !a3) {
    return v3;
  }
  DirectoryForURL = AMAuthInstallPlatformMakeDirectoryForURL(a3);
  if (DirectoryForURL)
  {
    uint64_t v3 = (uint64_t)DirectoryForURL;
    uint64_t v14 = "AMAuthInstallSupportMakeDirectory failed.";
  }
  else
  {
    uint64_t v12 = AMAuthInstallSupportCreateDataFromFileURL(kCFAllocatorDefault, &cf, a2);
    if (v12)
    {
      uint64_t v3 = v12;
      uint64_t v14 = "AMAuthInstallSupportCreateDataFromFileURL failed.";
    }
    else
    {
      uint64_t v3 = AMAuthInstallSupportWriteDataToFileURL(kCFAllocatorDefault, (const __CFData *)cf, a3, 1);
      if (!v3) {
        goto LABEL_6;
      }
      uint64_t v14 = "AMAuthInstallSupportWriteDataToFileURL failed.";
    }
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCopyFile", (uint64_t)v14, v7, v8, v9, v10, v11, v15);
LABEL_6:
  if (cf) {
    CFRelease(cf);
  }
  return v3;
}

CFURLRef AMAuthInstallSupportCreateURLFromString(const __CFAllocator *a1, const __CFString *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCreateURLFromString", (uint64_t)"%s: theString is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallSupportCreateURLFromString");
    return 0;
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 == CFURLGetTypeID())
  {
    AMAuthInstallLog(4, (uint64_t)"AMAuthInstallSupportCreateURLFromString", (uint64_t)"%s: CFURLRef passed, retaining copy", v11, v12, v13, v14, v15, (char)"AMAuthInstallSupportCreateURLFromString");
    return (CFURLRef)CFRetain(cf);
  }
  CFTypeID v17 = CFGetTypeID(cf);
  if (v17 != CFStringGetTypeID())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCreateURLFromString", (uint64_t)"%s: invalid string", v18, v19, v20, v21, v22, (char)"AMAuthInstallSupportCreateURLFromString");
    return 0;
  }
  if (CFStringFind(cf, @"://", 0).location == -1)
  {
    return CFURLCreateWithFileSystemPath(a1, cf, kCFURLPOSIXPathStyle, 0);
  }
  else
  {
    return CFURLCreateWithString(a1, cf, 0);
  }
}

uint64_t AMAuthInstallSupportCopyStringReplacingLastComponent(const __CFAllocator *a1, const __CFString *a2, const __CFString *a3, const void *a4, CFTypeRef *a5)
{
  uint64_t v5 = 1;
  if (a2 && a4 && a5)
  {
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, a2, a3);
    if (!ArrayBySeparatingStrings) {
      return 3;
    }
    CFArrayRef v11 = ArrayBySeparatingStrings;
    CFArrayRef MutableCopy = CFArrayCreateMutableCopy(a1, 0, ArrayBySeparatingStrings);
    if (!MutableCopy)
    {
      uint64_t v5 = 3;
      CFStringRef v16 = (CFStringRef)v11;
LABEL_9:
      CFRelease(v16);
      return v5;
    }
    uint64_t v13 = MutableCopy;
    CFIndex Count = CFArrayGetCount(MutableCopy);
    CFArraySetValueAtIndex(v13, Count - 1, a4);
    CFStringRef v15 = CFStringCreateByCombiningStrings(a1, v13, a3);
    CFStringRef v16 = v15;
    if (v15)
    {
      uint64_t v5 = 0;
      *a5 = CFRetain(v15);
    }
    else
    {
      uint64_t v5 = 3;
    }
    CFRelease(v11);
    CFRelease(v13);
    if (v16) {
      goto LABEL_9;
    }
  }
  return v5;
}

uint64_t AMAuthInstallSupportCreateMergedDictionary(const __CFAllocator *a1, const __CFDictionary *a2, const __CFDictionary *a3, CFMutableDictionaryRef *a4)
{
  CFDictionaryRef theDict = 0;
  uint64_t v4 = 1;
  if (!a2 || !a3 || !a4) {
    return v4;
  }
  CFIndex Count = CFDictionaryGetCount(a3);
  CFTypeID v10 = (const void **)malloc(8 * Count);
  if (!v10) {
    return 2;
  }
  CFArrayRef v11 = v10;
  uint64_t v12 = (const void **)malloc(8 * Count);
  if (!v12)
  {
    free(v11);
    return 2;
  }
  uint64_t v13 = v12;
  CFDictionaryGetKeysAndValues(a3, v11, v12);
  if (Count < 1)
  {
    CFDictionaryRef v22 = 0;
    uint64_t v4 = 0;
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_31;
  }
  uint64_t v24 = v13;
  unsigned int v25 = v11;
  while (1)
  {
    uint64_t v14 = *v11;
    if (!*a4) {
      *a4 = CFDictionaryCreateMutableCopy(a1, 0, a2);
    }
    CFTypeID v15 = CFGetTypeID(*v13);
    if (v15 == CFDictionaryGetTypeID()) {
      break;
    }
    CFDictionaryRef v19 = theDict;
    CFMutableDictionaryRef MutableCopy = *a4;
    if (theDict)
    {
      if (MutableCopy)
      {
        CFRelease(MutableCopy);
        CFDictionaryRef v19 = theDict;
      }
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(a1, 0, v19);
      *a4 = MutableCopy;
    }
    if (!MutableCopy)
    {
      CFMutableDictionaryRef Mutable = 0;
LABEL_37:
      uint64_t v4 = 2;
      goto LABEL_29;
    }
    CFDictionarySetValue(MutableCopy, v14, *v13);
    CFMutableDictionaryRef Mutable = 0;
LABEL_23:
    if (theDict)
    {
      CFRelease(theDict);
      CFDictionaryRef theDict = 0;
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    ++v13;
    ++v11;
    if (!--Count)
    {
      uint64_t v4 = 0;
      CFMutableDictionaryRef Mutable = 0;
      goto LABEL_29;
    }
  }
  CFDictionaryRef Value = (__CFDictionary *)CFDictionaryGetValue(a2, v14);
  if (Value)
  {
    CFMutableDictionaryRef Mutable = Value;
    CFRetain(Value);
    CFTypeID v18 = CFGetTypeID(Mutable);
    if (v18 != CFDictionaryGetTypeID())
    {
      uint64_t v4 = 7;
      goto LABEL_29;
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Mutable) {
      goto LABEL_37;
    }
  }
  uint64_t v21 = AMAuthInstallSupportCreateMergedDictionary(a1, Mutable, *v13, &theDict);
  if (!v21)
  {
    CFDictionarySetValue(*a4, v14, theDict);
    goto LABEL_23;
  }
  uint64_t v4 = v21;
LABEL_29:
  CFArrayRef v11 = v25;
  CFDictionaryRef v22 = theDict;
  uint64_t v13 = v24;
LABEL_31:
  free(v11);
  free(v13);
  if (v22) {
    CFRelease(v22);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v4;
}

CFStringRef AMAuthInstallSupportCompareStringToInt32(const __CFDictionary *a1, const void *a2, int a3)
{
  *__error() = 0;
  if (!a1)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCompareStringToInt32", (uint64_t)"%s: bad parameter: dict is null", v6, v7, v8, v9, v10, (char)"AMAuthInstallSupportCompareStringToInt32");
    return 0;
  }
  if (!a2)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportCompareStringToInt32", (uint64_t)"%s: bad parameter: key is null", v6, v7, v8, v9, v10, (char)"AMAuthInstallSupportCompareStringToInt32");
    return 0;
  }
  CFStringRef result = (const __CFString *)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    CFStringRef result = (const __CFString *)CFStringGetCString(result, buffer, 32, 0x8000100u);
    if (result)
    {
      if (strtol(buffer, 0, 16) == a3) {
        return (const __CFString *)(*__error() == 0);
      }
      return 0;
    }
  }
  return result;
}

uint64_t AMAuthInstallSupportCreatePrependedFilePath(const __CFAllocator *a1, uint64_t a2, CFStringRef theString, void *a4)
{
  uint64_t v4 = 1;
  if (!a1 || !a2 || !theString || !a4) {
    return v4;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, theString, @"/");
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, Count - 1);
  if (ValueAtIndex)
  {
    CFStringRef v11 = CFStringCreateWithFormat(a1, 0, @"%@_%@", a2, ValueAtIndex);
    CFStringRef v12 = v11;
    if (v11)
    {
      if (Count > 1)
      {
        CFArraySetValueAtIndex(ArrayBySeparatingStrings, Count - 1, v11);
        uint64_t v13 = (void *)CFStringCreateByCombiningStrings(a1, ArrayBySeparatingStrings, @"/");
      }
      else
      {
        uint64_t v13 = (void *)CFRetain(v11);
      }
      uint64_t v4 = 0;
      *a4 = v13;
      if (!ArrayBySeparatingStrings) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  else
  {
    CFStringRef v12 = 0;
  }
  uint64_t v4 = 2;
  if (ArrayBySeparatingStrings) {
LABEL_11:
  }
    CFRelease(ArrayBySeparatingStrings);
LABEL_12:
  if (v12) {
    CFRelease(v12);
  }
  return v4;
}

uint64_t AMAuthInstallSupportCopyTagAndFileURL(const __CFAllocator *a1, CFURLRef anURL, CFTypeRef *a3, CFTypeRef *a4)
{
  if (!anURL) {
    return 2;
  }
  CFStringRef v8 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
  if (!v8) {
    return 2;
  }
  CFStringRef v9 = v8;
  if (CFStringFind(v8, @"=", 0).location != -1)
  {
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v9, @"=");
    if (!ArrayBySeparatingStrings)
    {
      uint64_t v18 = 2;
      goto LABEL_15;
    }
    CFArrayRef v11 = ArrayBySeparatingStrings;
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
    if (ValueAtIndex && (uint64_t v13 = ValueAtIndex, (v14 = (const __CFString *)CFArrayGetValueAtIndex(v11, 1)) != 0))
    {
      CFURLRef v15 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v14, kCFURLPOSIXPathStyle, 0);
      if (v15)
      {
        CFStringRef v16 = (const __CFString *)v15;
        if (!a3) {
          goto LABEL_10;
        }
        goto LABEL_9;
      }
      uint64_t v17 = 2;
    }
    else
    {
      uint64_t v17 = 8;
    }
    CFRelease(v9);
    CFStringRef v16 = 0;
LABEL_13:
    CFRelease(v11);
    uint64_t v18 = v17;
    goto LABEL_14;
  }
  CFStringRef v16 = (const __CFString *)CFRetain(anURL);
  uint64_t v13 = 0;
  CFArrayRef v11 = 0;
  if (a3) {
LABEL_9:
  }
    *a3 = CFRetain(v13);
LABEL_10:
  if (a4) {
    *a4 = CFRetain(v16);
  }
  CFRelease(v9);
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  if (v11) {
    goto LABEL_13;
  }
LABEL_14:
  CFStringRef v9 = v16;
  if (v16) {
LABEL_15:
  }
    CFRelease(v9);
  return v18;
}

BOOL AMAuthInstallVinylCheckVinylFwLdrVerLegacy(const __CFData *a1)
{
  if (!a1) {
    return 1;
  }
  v3.CFIndex location = 0;
  v3.CFIndex length = 2;
  CFDataGetBytes(a1, v3, buffer);
  return (buffer[1] | ((buffer[0] & 0x7F) << 8)) < 0x301u;
}

uint64_t AMAuthInstallVinylIsLegacyChipId(CFTypeRef cf, BOOL *a2)
{
  if (cf && (uint64_t v3 = *((void *)cf + 6)) != 0 && *(void *)(v3 + 160))
  {
    CFAllocatorRef v5 = CFGetAllocator(cf);
    CFNumberRef v6 = CFNumberCreate(v5, kCFNumberSInt8Type, &kAMAuthInstallVinylLegacyChipIdCutoff);
    if (v6)
    {
      CFComparisonResult v7 = CFNumberCompare(*(CFNumberRef *)(*((void *)cf + 6) + 160), v6, 0);
      uint64_t v8 = 0;
      *a2 = v7 == kCFCompareLessThan;
    }
    else
    {
      uint64_t v8 = 2;
    }
  }
  else
  {
    CFNumberRef v6 = 0;
    uint64_t v8 = 1;
  }
  SafeRelease(v6);
  return v8;
}

uint64_t AMAuthInstallVinylCreateMeasurements(CFTypeRef cf, const void *a2, CFDictionaryRef *a3, const void **a4)
{
  BOOL v39 = 0;
  if (!cf)
  {
    CFDictionaryRef v5 = 0;
    uint64_t v6 = 1;
    goto LABEL_28;
  }
  CFDictionaryRef v5 = 0;
  uint64_t v6 = 1;
  if (a3 && a2 && *((void *)cf + 6))
  {
    uint64_t IsLegacyChipId = AMAuthInstallVinylIsLegacyChipId(cf, &v39);
    if (IsLegacyChipId)
    {
      uint64_t v6 = IsLegacyChipId;
      CFDictionaryRef v5 = 0;
      goto LABEL_28;
    }
    CFDictionaryRef v11 = *a3;
    CFAllocatorRef v12 = CFGetAllocator(cf);
    if (v11) {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v12, 0, *a3);
    }
    else {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(v12, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    CFDictionaryRef v5 = MutableCopy;
    if (!MutableCopy)
    {
      uint64_t v6 = 2;
      goto LABEL_28;
    }
    if (v39)
    {
      uint64_t Measurements = AMAuthInstallBasebandVinylCreateMeasurements((uint64_t)cf, a2, MutableCopy);
      if (!Measurements) {
        goto LABEL_24;
      }
      uint64_t v6 = Measurements;
      goto LABEL_28;
    }
    uint64_t v38 = a4;
    uint64_t v15 = 0;
    CFDataRef theData = 0;
    v41[6] = *(_OWORD *)off_10009E518;
    v41[7] = *(_OWORD *)&off_10009E528;
    memset(&v41[8], 0, 32);
    v41[2] = off_10009E4D8;
    memset(&v41[3], 0, 32);
    v41[5] = *(_OWORD *)off_10009E508;
    char v16 = 1;
    v41[0] = *(_OWORD *)&off_10009E4B8;
    v41[1] = *(_OWORD *)&off_10009E4C8;
    while (1)
    {
      char v17 = v16;
      uint64_t v18 = (const void **)&v41[5 * v15];
      if (sub_1000327C8(cf, a2, (uint64_t)(v18 + 2), &theData)) {
        BOOL v19 = 1;
      }
      else {
        BOOL v19 = theData == 0;
      }
      if (!v19)
      {
        BytePtr = CFDataGetBytePtr(theData);
        CFIndex Length = CFDataGetLength(theData);
        AMAuthInstallLogDumpMemory(7, (uint64_t)"_AMAuthInstallVinylCreateMeasurementsInternal", (char)"eUICC IM4P", (uint64_t)BytePtr, Length, v22, v23, v24);
        CFDataGetBytePtr(theData);
        CFDataGetLength(theData);
        if (AMSupportDigestSha256())
        {
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylCreateMeasurementsInternal", (uint64_t)"failed to compute digest", v25, v26, v27, v28, v29, (char)v38);
LABEL_23:
          SafeRelease(theData);
          a4 = v38;
LABEL_24:
          CFDictionaryRef Value = v5;
          if (a4 && (CFDictionaryRef Value = CFDictionaryGetValue(v5, *a4)) == 0)
          {
            uint64_t v6 = 0;
          }
          else
          {
            uint64_t v6 = 0;
            *a3 = (CFDictionaryRef)CFRetain(Value);
          }
          break;
        }
        SafeRelease(theData);
        CFDataRef theData = 0;
        CFAllocatorRef v30 = CFGetAllocator(cf);
        CFDataRef v31 = CFDataCreate(v30, bytes, 32);
        if (!v31) {
          goto LABEL_23;
        }
        CFDataRef v32 = v31;
        CFAllocatorRef v33 = CFGetAllocator(cf);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v33, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (!Mutable) {
          goto LABEL_23;
        }
        uint64_t v35 = Mutable;
        CFDictionarySetValue(Mutable, *((const void **)&v41[5 * v15] + 1), v32);
        CFDictionarySetValue(v5, *v18, v35);
        SafeRelease(v32);
        SafeRelease(v35);
      }
      char v16 = 0;
      uint64_t v15 = 1;
      if ((v17 & 1) == 0) {
        goto LABEL_23;
      }
    }
  }
LABEL_28:
  SafeRelease(0);
  SafeRelease(v5);
  return v6;
}

uint64_t AMAuthInstallVinylServerRequestAddRequiredTags(uint64_t a1, CFDictionaryRef theDict, const __CFDictionary *a3)
{
  if (!a1) {
    return 1;
  }
  uint64_t v4 = *(void **)(a1 + 48);
  if (!v4 || !v4[15] || !v4[20] || !v4[16] || !v4[17] || !v4[18]) {
    return 1;
  }
  uint64_t result = 1;
  if (theDict && v4[19])
  {
    CFDictionaryRef Value = (__CFDictionary *)CFDictionaryGetValue(theDict, @"eUICC,Gold");
    CFStringRef v9 = (__CFDictionary *)CFDictionaryGetValue(theDict, @"eUICC,Main");
    if ((unint64_t)Value | (unint64_t)v9)
    {
      uint64_t v15 = v9;
      CFDictionarySetValue(theDict, @"eUICC,EID", *(const void **)(*(void *)(a1 + 48) + 120));
      CFDictionarySetValue(theDict, @"eUICC,ChipID", *(const void **)(*(void *)(a1 + 48) + 160));
      if (Value) {
        CFDictionarySetValue(Value, @"Nonce", *(const void **)(*(void *)(a1 + 48) + 136));
      }
      if (v15) {
        CFDictionarySetValue(v15, @"Nonce", *(const void **)(*(void *)(a1 + 48) + 128));
      }
      CFDictionarySetValue(theDict, @"@eUICC,Ticket", kCFBooleanTrue);
      CFDictionarySetValue(theDict, @"eUICC,RootKeyIdentifier", *(const void **)(*(void *)(a1 + 48) + 152));
      if (a3)
      {
        char v16 = CFDictionaryGetValue(a3, @"UniqueBuildID");
        if (v16) {
          CFDictionarySetValue(theDict, @"UniqueBuildID", v16);
        }
      }
      uint64_t v17 = *(void *)(a1 + 16);
      if (v17) {
        _CFDictionarySetBoolean(theDict, @"eUICC,ApProductionMode", *(unsigned __int8 *)(v17 + 20));
      }
      return 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallVinylServerRequestAddRequiredTags", (uint64_t)"Neither main nor gold vinyl fw found!", v10, v11, v12, v13, v14, v18);
      return 8;
    }
  }
  return result;
}

uint64_t AMAuthInstallVinylPersonalizeFirmware(void *cf, const void *a2, const void *a3, CFDictionaryRef *a4, const __CFDictionary *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v114 = 0;
  BOOL v113 = 0;
  if (!cf || (uint64_t v9 = cf[6]) == 0)
  {
    uint64_t v20 = 1;
    goto LABEL_73;
  }
  if (!*(void *)(v9 + 160))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallVinylPersonalizeFirmware", (uint64_t)"No eUICC ChipID specified. Not personalizing VinylFirmware at this time.", (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v105);
    uint64_t v20 = 0;
    goto LABEL_73;
  }
  uint64_t IsLegacyChipId = AMAuthInstallVinylCreateMeasurements(cf, a2, &v114, 0);
  if (IsLegacyChipId || (uint64_t IsLegacyChipId = AMAuthInstallVinylIsLegacyChipId(cf, &v113), IsLegacyChipId))
  {
    uint64_t v20 = IsLegacyChipId;
    goto LABEL_73;
  }
  CFDictionaryRef v19 = v114;
  if (v113)
  {
    uint64_t v20 = 1;
    if (!a4 || !v114) {
      goto LABEL_21;
    }
    if (!*a4)
    {
      uint64_t v20 = 14;
      goto LABEL_21;
    }
    if (!a3)
    {
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylPersonalizeLegacyFirmwareInternal", (uint64_t)"No dstURL provided. Running in restore environment?", v14, v15, v16, v17, v18, v105);
      uint64_t v20 = 0;
      goto LABEL_21;
    }
    uint64_t v21 = BbfwWriterCreate(a3);
    if (v21)
    {
      uint64_t v27 = (uint64_t)v21;
      uint64_t v28 = BbfwReaderOpen(a2);
      if (v28)
      {
        uint64_t v29 = (uint64_t)v28;
        CFDictionaryRef Value = CFDictionaryGetValue(*a4, @"EuiccMainTicket");
        if (Value)
        {
          CFDataRef v31 = Value;
          CFTypeID TypeID = CFDataGetTypeID();
          if (TypeID != CFGetTypeID(v31)) {
            goto LABEL_86;
          }
          if (BbfwWriterAddFile(v27, @"vinyl/update/main/ticket.der", (const __CFData *)v31)) {
            goto LABEL_87;
          }
        }
        CFDataRef v33 = (const __CFData *)CFDictionaryGetValue(*a4, @"EuiccGoldTicket");
        if (!v33)
        {
LABEL_19:
          uint64_t v20 = 0;
LABEL_20:
          BbfwWriterFinalize(v27);
          BbfwReaderClose(v29);
LABEL_21:
          SafeRelease(0);
          SafeRelease(0);
          CFDictionaryRef v36 = 0;
          goto LABEL_72;
        }
        CFDataRef v34 = v33;
        CFTypeID v35 = CFDataGetTypeID();
        if (v35 == CFGetTypeID(v34))
        {
          if (!BbfwWriterAddFile(v27, @"vinyl/update/gold/ticket.der", v34)) {
            goto LABEL_19;
          }
LABEL_87:
          uint64_t v20 = 4;
          goto LABEL_20;
        }
LABEL_86:
        uint64_t v20 = 17;
        goto LABEL_20;
      }
      BbfwWriterFinalize(v27);
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylPersonalizeLegacyFirmwareInternal", (uint64_t)"failed to create output file", v22, v23, v24, v25, v26, v105);
    }
    uint64_t v20 = 4;
    goto LABEL_21;
  }
  CFDataRef StitchTicket = 0;
  theDict[0] = 0;
  v116[0] = @"euig";
  v116[1] = @"update/gold/profile.bin";
  v116[2] = @"update/gold/info.plist";
  long long v117 = 0u;
  long long v118 = 0u;
  uint64_t v119 = 0;
  CFStringRef v120 = @"vinyl/update/gold/ticket.der";
  CFTypeRef v122 = 0;
  v123[0] = 0;
  CFStringRef v121 = @"EuiccGoldTicket";
  v123[1] = @"euim";
  v123[2] = @"update/main/profile.bin";
  v123[3] = @"update/main/info.plist";
  long long v124 = 0u;
  long long v125 = 0u;
  uint64_t v126 = 0;
  CFStringRef v127 = @"vinyl/update/main/ticket.der";
  CFTypeRef v129 = 0;
  CFTypeRef v130 = 0;
  uint64_t v20 = 1;
  CFStringRef v128 = @"EuiccMainTicket";
  if (!a4 || !a2)
  {
    CFDictionaryRef v38 = 0;
    goto LABEL_82;
  }
  CFDictionaryRef v38 = 0;
  if (!v114)
  {
LABEL_82:
    CFDictionaryRef v111 = v38;
    SafeRelease(StitchTicket);
    goto LABEL_71;
  }
  if (*a4 && CFDictionaryGetValue(*a4, @"eUICC,Ticket"))
  {
    BOOL v39 = a3;
    CFDictionaryRef v40 = *a4;
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylPersonalizeFirmwareInternal", (uint64_t)"Vinyl server signing is enabled...", v14, v15, v16, v17, v18, v105);
    uint64_t v41 = AMAuthInstallVinylServerRequestAddRequiredTags((uint64_t)cf, v19, a5);
    if (v41)
    {
      uint64_t v20 = v41;
      if (v41 == 8)
      {
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylPersonalizeFirmwareInternal", (uint64_t)"Nothing to sign, skipping..", v42, v43, v44, v45, v46, v106);
        uint64_t v20 = 0;
      }
      goto LABEL_85;
    }
    uint64_t v47 = AMAuthInstallRequestSendSync((uint64_t)cf, v19, (CFTypeRef *)theDict);
    if (v47)
    {
      uint64_t v20 = v47;
      goto LABEL_85;
    }
    CFDictionaryRef v40 = theDict[0];
    if (!theDict[0])
    {
      uint64_t v20 = 14;
      goto LABEL_85;
    }
    BOOL v39 = a3;
  }
  CFDataRef v48 = (const __CFData *)CFDictionaryGetValue(v40, @"eUICC,Ticket");
  CFDataRef v49 = v48;
  if (!v48)
  {
    uint64_t v20 = 17;
LABEL_85:
    SafeRelease(0);
    CFDictionaryRef v111 = 0;
    goto LABEL_71;
  }
  CFTypeID v50 = CFGetTypeID(v48);
  if (v50 != CFDataGetTypeID())
  {
    CFDataRef StitchTicket = 0;
    CFDictionaryRef v38 = 0;
    uint64_t v20 = 17;
    goto LABEL_82;
  }
  uint64_t v107 = (CFTypeRef *)a4;
  BytePtr = CFDataGetBytePtr(v49);
  CFDataRef v109 = v49;
  CFIndex Length = CFDataGetLength(v49);
  AMAuthInstallLogDumpMemory(8, (uint64_t)"_AMAuthInstallVinylPersonalizeFirmwareInternal", (char)"EUICC,Ticket:", (uint64_t)BytePtr, Length, v53, v54, v55);
  uint64_t v56 = 0;
  int v112 = 0;
  CFDictionaryRef v111 = 0;
  uint64_t v108 = 0;
  CFDataRef StitchTicket = 0;
  char v57 = 1;
  uint64_t v58 = a2;
  uint64_t v59 = v39;
  do
  {
    char v60 = v57;
    uint64_t v61 = cf[6];
    uint64_t v62 = &v116[12 * v56];
    v62[4] = *(void *)(v61 + 152);
    v62[5] = *(void *)(v61 + 168);
    uint64_t v63 = BbfwReaderStart(v58, (uint64_t (*)(uint64_t, CFStringRef, void *))sub_100032CF4, (uint64_t)v62);
    if (v63
      || (uint64_t v63 = BbfwReaderStart(v58, (uint64_t (*)(uint64_t, CFStringRef, void *))sub_100032E38, (uint64_t)v62), v63))
    {
      uint64_t v20 = v63;
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylPersonalizeFirmwareInternal", (uint64_t)"failed to read zip file", v64, v65, v66, v67, v68, (char)v107);
LABEL_77:
      uint64_t v96 = (uint64_t)v108;
      goto LABEL_69;
    }
    v62[4] = 0;
    v62[5] = 0;
    if (!v62[3]) {
      goto LABEL_56;
    }
    uint64_t v69 = sub_1000327C8(cf, v58, (uint64_t)v62, (CFDataRef *)&v123[12 * v56 - 1]);
    if (v69)
    {
      uint64_t v20 = v69;
      goto LABEL_77;
    }
    CFAllocatorRef v70 = CFGetAllocator(cf);
    CFDataRef StitchTicket = AMAuthInstallApImg4CreateStitchTicket(v70, (const __CFData *)v123[12 * v56 - 1], v109);
    if (!StitchTicket)
    {
      uint64_t v20 = 3;
      goto LABEL_77;
    }
    CFDataRef v71 = (const __CFData *)v62[3];
    uint64_t v72 = &v123[12 * v56];
    memset((char *)&theDict[1] + 4, 0, 12);
    CFAllocatorRef v73 = CFGetAllocator(cf);
    CFIndex v74 = CFDataGetLength(StitchTicket);
    CFIndex v75 = CFDataGetLength(v71);
    CFMutableDictionaryRef MutableCopy = CFDataCreateMutableCopy(v73, v75 + v74, StitchTicket);
    if (MutableCopy)
    {
      uint64_t v77 = CFDataGetBytePtr(v71);
      CFIndex v78 = CFDataGetLength(v71);
      CFDataAppendBytes(MutableCopy, v77, v78);
      if (DEREncoderCreate())
      {
        CFDataGetBytePtr(MutableCopy);
        CFDataGetLength(MutableCopy);
        DEREncoderAddData();
        if (DEREncoderCreateEncodedBuffer())
        {
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylStitchImg4Vad", (uint64_t)"failed to encode img4/vad sequence", v79, v80, v81, v82, v83, (char)v107);
LABEL_44:
          uint64_t v20 = 0;
          int v86 = 1;
          goto LABEL_45;
        }
        CFAllocatorRef v84 = CFGetAllocator(cf);
        CFDataRef v85 = CFDataCreate(v84, (const UInt8 *)theDict[2], HIDWORD(theDict[1]));
        *uint64_t v72 = v85;
        if (v85) {
          goto LABEL_44;
        }
      }
      int v86 = 0;
    }
    else
    {
      int v86 = 0;
    }
    uint64_t v20 = 2;
LABEL_45:
    DEREncoderDestroy();
    SafeFree(theDict[2]);
    SafeRelease(MutableCopy);
    if (!v86) {
      goto LABEL_77;
    }
    int v87 = v112;
    if (v112)
    {
      CFMutableDictionaryRef Mutable = v111;
    }
    else
    {
      if (v59)
      {
        uint64_t v108 = BbfwWriterCreate(v59);
        if (!v108)
        {
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylPersonalizeFirmwareInternal", (uint64_t)"failed to create output file", v89, v90, v91, v92, v93, (char)v107);
          uint64_t v20 = 4;
          CFDictionaryRef v38 = v111;
          goto LABEL_82;
        }
      }
      CFAllocatorRef v94 = CFGetAllocator(cf);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v94, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      int v87 = 0;
    }
    int v112 = v87 + 1;
    CFDictionaryRef v111 = Mutable;
    CFDictionaryAddValue(Mutable, (&v121)[12 * v56], *v72);
    if (v59)
    {
      CFDictionaryRef v95 = v59;
      uint64_t v96 = (uint64_t)v108;
      if (BbfwWriterAddFile((uint64_t)v108, (&v120)[12 * v56], (const __CFData *)*v72))
      {
        uint64_t v20 = 4;
        goto LABEL_69;
      }
      uint64_t v58 = a2;
      uint64_t v59 = v95;
    }
    else
    {
      uint64_t v58 = a2;
    }
LABEL_56:
    char v57 = 0;
    uint64_t v56 = 1;
  }
  while ((v60 & 1) != 0);
  if (!v112)
  {
    CFAllocatorRef v97 = CFDataGetBytePtr(*(CFDataRef *)(cf[6] + 152));
    CFIndex v98 = CFDataGetLength(*(CFDataRef *)(cf[6] + 152));
    AMAuthInstallLogDumpMemory(3, (uint64_t)"_AMAuthInstallVinylPersonalizeFirmwareInternal", (char)"Error finding profile matching certId", (uint64_t)v97, v98, v99, v100, v101);
  }
  uint64_t v96 = (uint64_t)v108;
  if (v111)
  {
    SafeRelease(*v107);
    CFAllocatorRef v102 = CFGetAllocator(cf);
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v102, v111);
    *uint64_t v107 = Copy;
    if (Copy) {
      uint64_t v20 = 0;
    }
    else {
      uint64_t v20 = 2;
    }
  }
  else
  {
    CFDictionaryRef v111 = 0;
    uint64_t v20 = 0;
  }
LABEL_69:
  SafeRelease(StitchTicket);
  if (v96) {
    BbfwWriterFinalize(v96);
  }
LABEL_71:
  SafeRelease((CFTypeRef)v117);
  SafeRelease(v122);
  SafeRelease(v123[0]);
  SafeRelease((CFTypeRef)v124);
  SafeRelease(v129);
  SafeRelease(v130);
  SafeRelease(theDict[0]);
  CFDictionaryRef v36 = v111;
LABEL_72:
  SafeRelease(v36);
LABEL_73:
  SafeRelease(v114);
  return v20;
}

uint64_t AMAuthInstallVinylRemoveFirmwareLoaderVersionTag(const void *a1, CFDictionaryRef *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 1;
  if (a1 && a2)
  {
    if (*a2)
    {
      CFAllocatorRef v5 = CFGetAllocator(a1);
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v5, 0, *a2);
      uint64_t v2 = MutableCopy;
      if (MutableCopy)
      {
        CFDictionaryRemoveValue(MutableCopy, @"EUICCFirmwareLoaderVersion");
        SafeRelease(*a2);
        uint64_t v3 = 0;
        *a2 = (CFDictionaryRef)CFRetain(v2);
      }
      else
      {
        uint64_t v3 = 2;
      }
    }
    else
    {
      uint64_t v2 = 0;
    }
  }
  SafeRelease(v2);
  return v3;
}

uint64_t sub_1000327C8(const void *a1, const void *a2, uint64_t a3, CFDataRef *a4)
{
  memset(&buffer[5], 0, 12);
  CFAllocatorRef v7 = AMAuthInstallSupportCopyAllocator();
  uint64_t v8 = 0;
  uint64_t Payload = 1;
  if (!a1 || !a2 || !a3)
  {
    uint64_t v10 = 0;
    goto LABEL_24;
  }
  uint64_t v10 = 0;
  if (a4)
  {
    CFAllocatorRef v11 = CFGetAllocator(a1);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v11, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      CFAllocatorRef v13 = CFGetAllocator(a1);
      CFMutableArrayRef v14 = CFArrayCreateMutable(v13, 0, &kCFTypeArrayCallBacks);
      CFArrayRef v15 = v14;
      if (v14)
      {
        values[0] = Mutable;
        values[1] = v14;
        CFAllocatorRef v16 = CFGetAllocator(a1);
        uint64_t Payload = 2;
        CFArrayRef v17 = CFArrayCreate(v16, (const void **)values, 2, &kCFTypeArrayCallBacks);
        *(void *)(a3 + 48) = v17;
        if (v17)
        {
          uint64_t v18 = BbfwReaderStart(a2, (uint64_t (*)(uint64_t, CFStringRef, void *))sub_100032CF4, a3);
          if (!v18)
          {
            if (!*(void *)(a3 + 56))
            {
              uint64_t v47 = "Failed to build vinyl info.plist dictionary";
              uint64_t v48 = 3;
              goto LABEL_39;
            }
            uint64_t v18 = BbfwReaderStart(a2, (uint64_t (*)(uint64_t, CFStringRef, void *))sub_100032E38, a3);
            if (!v18)
            {
              CFIndex Count = CFArrayGetCount(Mutable);
              if (Count <= 0)
              {
                CFStringRef v50 = *(CFStringRef *)a3;
                uint64_t v47 = "No sources found for %@";
              }
              else
              {
                CFIndex v25 = Count;
                if (Count == CFArrayGetCount(v15))
                {
                  CFAllocatorRef v51 = v7;
                  uint64_t v10 = (const void **)malloc(8 * v25);
                  uint64_t v8 = (const void **)malloc(8 * v25);
                  v56.CFIndex location = 0;
                  v56.CFIndex length = v25;
                  CFArrayGetValues(Mutable, v56, v10);
                  v57.CFIndex location = 0;
                  v57.CFIndex length = v25;
                  CFArrayGetValues(v15, v57, v8);
                  DEREncoderCreate();
                  DEREncoderCreate();
                  uint64_t v26 = 0;
                  while (1)
                  {
                    DEREncoderCreate();
                    CFDataGetBytePtr((CFDataRef)v10[v26]);
                    CFDataGetLength((CFDataRef)v10[v26]);
                    if (DEREncoderAddData()) {
                      break;
                    }
                    CFDataGetBytePtr((CFDataRef)v8[v26]);
                    CFDataGetLength((CFDataRef)v8[v26]);
                    if (DEREncoderAddData())
                    {
                      uint64_t v46 = "failed to add VAD";
                      goto LABEL_28;
                    }
                    if (DEREncoderAddSequenceFromEncoder())
                    {
                      uint64_t v46 = "failed to add certId-VAD sequence";
                      goto LABEL_28;
                    }
                    DEREncoderDestroy();
                    if (v25 == ++v26)
                    {
                      CFAllocatorRef v7 = v51;
                      if (DEREncoderAddSequenceFromEncoder())
                      {
                        uint64_t Payload = 3;
                        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylCreateIm4p", (uint64_t)"failed to add top-level sequence", v32, v33, v34, v35, v36, (char)v50);
                      }
                      else
                      {
                        DEREncoderDestroy();
                        if (DEREncoderCreateEncodedBuffer())
                        {
                          CFDataRef v49 = "failed to encode DER buffer";
                          uint64_t Payload = 3;
                          goto LABEL_44;
                        }
                        CFAllocatorRef v42 = CFGetAllocator(a1);
                        CFDataRef v43 = CFDataCreateWithBytesNoCopy(v42, *(const UInt8 **)&buffer[9], *(unsigned int *)&buffer[5], v51);
                        if (!v43) {
                          goto LABEL_42;
                        }
                        CFDataRef v44 = v43;
                        if (CFStringGetCString(*(CFStringRef *)a3, buffer, 5, 0x8000100u)
                          && CFStringGetCString(@"1.0", v53, 5, 0x8000100u))
                        {
                          uint64_t Payload = AMAuthInstallApImg4CreatePayload(buffer, v53, v44, 0, 0, a4);
                          if (!Payload) {
                            goto LABEL_24;
                          }
                          CFDataRef v49 = "failed to create im4p";
LABEL_44:
                          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylCreateIm4p", (uint64_t)v49, v37, v38, v39, v40, v41, (char)v50);
                        }
                        else
                        {
                          uint64_t Payload = 3;
                        }
                      }
                      goto LABEL_24;
                    }
                  }
                  uint64_t v46 = "failed to add certId";
LABEL_28:
                  uint64_t Payload = 3;
                  AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylCreateIm4p", (uint64_t)v46, v27, v28, v29, v30, v31, (char)v50);
                  CFAllocatorRef v7 = v51;
                  goto LABEL_24;
                }
                uint64_t v47 = "Count of certID != hashVad";
              }
              uint64_t v48 = 4;
LABEL_39:
              AMAuthInstallLog(v48, (uint64_t)"_AMAuthInstallVinylCreateIm4p", (uint64_t)v47, v19, v20, v21, v22, v23, (char)v50);
              uint64_t v8 = 0;
              uint64_t v10 = 0;
              uint64_t Payload = 0;
              goto LABEL_24;
            }
          }
          uint64_t Payload = v18;
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallVinylCreateIm4p", (uint64_t)"failed to read zip file", v19, v20, v21, v22, v23, (char)v50);
        }
        uint64_t v8 = 0;
        uint64_t v10 = 0;
        goto LABEL_24;
      }
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = 0;
    }
    uint64_t v10 = 0;
LABEL_42:
    uint64_t Payload = 2;
  }
LABEL_24:
  SafeFree(v10);
  SafeFree(v8);
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  SafeRelease(*(CFTypeRef *)(a3 + 48));
  SafeRelease(*(CFTypeRef *)(a3 + 56));
  SafeRelease(v7);
  SafeFree(*(void **)&buffer[9]);
  return Payload;
}

BOOL sub_100032CF4(uint64_t a1, CFStringRef theString, uint64_t a3)
{
  CFDataRef data = 0;
  CFStringRef v4 = *(const __CFString **)(a1 + 16);
  if (!v4 || !CFStringHasSuffix(theString, v4))
  {
    CFDataRef v17 = 0;
    int v16 = 0;
    CFStringRef v7 = 0;
    CFPropertyListRef v14 = 0;
    goto LABEL_11;
  }
  CFErrorRef v19 = 0;
  CFStringRef v7 = sub_1000332D8(theString);
  if (!v7)
  {
    CFPropertyListRef v14 = 0;
LABEL_13:
    int v16 = 2;
    goto LABEL_9;
  }
  int v8 = BbfwReaderFindAndCopyFileData(a3, theString, (CFTypeRef *)&data);
  if (v8)
  {
    int v16 = v8;
    AMAuthInstallLog(3, (uint64_t)"__AMAuthInstallVinylFwReaderInfoPlistCallback", (uint64_t)"failed to find and/or copy data", v9, v10, v11, v12, v13, (char)v19);
    CFPropertyListRef v14 = 0;
    goto LABEL_9;
  }
  CFPropertyListRef v14 = CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, 0, &v19);
  if (!v14) {
    goto LABEL_13;
  }
  CFMutableArrayRef Mutable = *(__CFDictionary **)(a1 + 56);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *(void *)(a1 + 56) = Mutable;
    if (!Mutable) {
      goto LABEL_13;
    }
  }
  CFDictionaryAddValue(Mutable, v7, v14);
  int v16 = 0;
LABEL_9:
  CFDataRef v17 = data;
LABEL_11:
  SafeRelease(v17);
  SafeRelease(v7);
  SafeRelease(v14);
  return v16 == 0;
}

BOOL sub_100032E38(uint64_t a1, CFStringRef theString, uint64_t a3)
{
  CFDataRef v3 = 0;
  CFTypeRef cf1 = 0;
  CFDataRef theData = 0;
  int v4 = 1;
  if (!a1 || !theString)
  {
    CFArrayRef v7 = 0;
    CFStringRef v8 = 0;
    CFArrayRef MutableCopy = 0;
    goto LABEL_43;
  }
  CFArrayRef v7 = 0;
  CFStringRef v8 = 0;
  CFArrayRef MutableCopy = 0;
  if (!a3) {
    goto LABEL_43;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, theString, @"/");
  CFArrayRef v7 = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings)
  {
    CFDataRef v3 = 0;
    CFStringRef v8 = 0;
LABEL_47:
    CFArrayRef MutableCopy = 0;
    goto LABEL_56;
  }
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
  int v13 = AMAuthInstallSupportCopyDataFromHexString(0, ValueAtIndex, (uint64_t *)&cf1);
  if (v13)
  {
    int v4 = v13;
    goto LABEL_28;
  }
  CFStringRef v14 = *(const __CFString **)(a1 + 8);
  if (!v14 || !CFStringHasSuffix(theString, v14))
  {
    int v4 = 0;
LABEL_28:
    CFDataRef v3 = 0;
    CFStringRef v8 = 0;
    CFArrayRef MutableCopy = 0;
    goto LABEL_43;
  }
  CFStringRef v8 = sub_1000332D8(theString);
  if (!v8 || (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), v8)) == 0)
  {
    CFDataRef v3 = 0;
    goto LABEL_47;
  }
  CFArrayRef v16 = (const __CFArray *)CFDictionaryGetValue(Value, @"com.apple.EmbeddedSoftwareRestore.eUICC.bootloaderVersionsSupported");
  CFArrayRef MutableCopy = v16;
  if (!v16) {
    goto LABEL_55;
  }
  if (CFArrayGetCount(v16) >= 1 && (CFStringRef v17 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 0)) != 0)
  {
    CFArrayRef v18 = CFStringCreateArrayBySeparatingStrings(0, v17, @".");
    if (CFArrayGetCount(v18) == 2)
    {
      CFStringRef v19 = (const __CFString *)CFArrayGetValueAtIndex(v18, 0);
      IntCFDictionaryRef Value = CFStringGetIntValue(v19);
      CFStringRef v21 = (const __CFString *)CFArrayGetValueAtIndex(v18, 1);
      BOOL v22 = (((unsigned __int16)CFStringGetIntValue(v21) | (unsigned __int16)(IntValue << 8)) & 0x7FFFu) < 0x301;
      goto LABEL_15;
    }
  }
  else
  {
    CFArrayRef v18 = 0;
  }
  BOOL v22 = 1;
LABEL_15:
  SafeRelease(v18);
  uint64_t v23 = *(const void **)(a1 + 32);
  if (!v23)
  {
    CFDataRef v3 = 0;
    CFArrayRef MutableCopy = 0;
    goto LABEL_34;
  }
  CFDataRef v24 = *(const __CFData **)(a1 + 40);
  if (!v24)
  {
LABEL_25:
    CFDataRef v3 = 0;
    CFArrayRef MutableCopy = 0;
    if (!CFEqual(cf1, v23)) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  if (v22 && CFArrayGetCount(MutableCopy) >= 1)
  {
    CFStringRef v25 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 0);
    if (v25)
    {
      CFArrayRef v26 = CFStringCreateArrayBySeparatingStrings(0, v25, @".");
      if (CFArrayGetCount(v26) == 2)
      {
        BytePtr = CFDataGetBytePtr(v24);
        if (BytePtr)
        {
          uint64_t v28 = BytePtr;
          int v29 = *BytePtr;
          CFStringRef v30 = (const __CFString *)CFArrayGetValueAtIndex(v26, 0);
          if (CFStringGetIntValue(v30) == v29)
          {
            int v31 = v28[1];
            CFStringRef v32 = (const __CFString *)CFArrayGetValueAtIndex(v26, 1);
            if (CFStringGetIntValue(v32) == v31)
            {
              uint64_t v23 = *(const void **)(a1 + 32);
              goto LABEL_25;
            }
          }
        }
      }
    }
  }
  CFArrayRef MutableCopy = CFDataCreateMutableCopy(kCFAllocatorDefault, 0, *(CFDataRef *)(a1 + 32));
  if (!MutableCopy)
  {
LABEL_55:
    CFDataRef v3 = 0;
    goto LABEL_56;
  }
  uint64_t v33 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  CFDataAppendBytes(MutableCopy, v33, Length - 1);
  CFDataGetBytePtr(MutableCopy);
  CFDataGetLength(MutableCopy);
  if (AMSupportDigestSha256())
  {
    AMAuthInstallLog(3, (uint64_t)"__AMAuthInstallVinylFwReaderCallback", (uint64_t)"failed to compute digest", v35, v36, v37, v38, v39, v51);
    goto LABEL_55;
  }
  SafeRelease(0);
  CFDataRef v3 = CFDataCreate(0, bytes, 32);
  if (!CFEqual(cf1, v3)) {
    goto LABEL_34;
  }
LABEL_33:
  if (BbfwReaderFindAndCopyFileData(a3, theString, (CFTypeRef *)(a1 + 24))) {
    goto LABEL_51;
  }
LABEL_34:
  CFArrayRef v45 = *(const __CFArray **)(a1 + 48);
  if (!v45)
  {
LABEL_42:
    int v4 = 0;
    goto LABEL_43;
  }
  uint64_t v46 = (__CFArray *)CFArrayGetValueAtIndex(v45, 0);
  int v4 = 1;
  uint64_t v47 = (__CFArray *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), 1);
  if (v46)
  {
    uint64_t v48 = v47;
    if (v47)
    {
      if (!cf1) {
        goto LABEL_56;
      }
      CFArrayAppendValue(v46, cf1);
      if (!BbfwReaderFindAndCopyFileData(a3, theString, (CFTypeRef *)&theData))
      {
        CFDataGetBytePtr(theData);
        CFDataGetLength(theData);
        if (!AMSupportDigestSha256())
        {
          SafeRelease(v3);
          CFDataRef v3 = CFDataCreate(0, bytes, 32);
          if (v3)
          {
            CFArrayAppendValue(v48, v3);
            goto LABEL_42;
          }
LABEL_56:
          int v4 = 1;
          goto LABEL_43;
        }
        CFStringRef v50 = "failed to compute digest";
LABEL_53:
        AMAuthInstallLog(3, (uint64_t)"__AMAuthInstallVinylFwReaderCallback", (uint64_t)v50, v40, v41, v42, v43, v44, v51);
        goto LABEL_56;
      }
LABEL_51:
      CFStringRef v50 = "failed to find and/or copy data";
      goto LABEL_53;
    }
  }
LABEL_43:
  SafeRelease(theData);
  SafeRelease(cf1);
  SafeRelease(v3);
  SafeRelease(v7);
  SafeRelease(MutableCopy);
  SafeRelease(v8);
  return v4 == 0;
}

CFStringRef sub_1000332D8(CFStringRef filePath)
{
  if (!filePath)
  {
    CFStringRef Copy = 0;
    CFURLRef v1 = 0;
LABEL_8:
    CFURLRef v3 = 0;
    goto LABEL_5;
  }
  CFURLRef v1 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, filePath, kCFURLPOSIXPathStyle, 0);
  if (!v1)
  {
    CFStringRef Copy = 0;
    goto LABEL_8;
  }
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(kCFAllocatorDefault, v1);
  CFURLRef v3 = PathComponent;
  if (PathComponent)
  {
    CFStringRef v4 = CFURLGetString(PathComponent);
    CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v4);
  }
  else
  {
    CFStringRef Copy = 0;
  }
LABEL_5:
  SafeRelease(v1);
  SafeRelease(v3);
  return Copy;
}

uint64_t AMAuthInstallBasebandMAV22StitchFirmware(uint64_t a1, CFTypeRef cf, uint64_t a3, __CFDictionary *a4)
{
  CFStringRef v4 = 0;
  uint64_t v5 = 1;
  if (a1 && cf && a3 && a4)
  {
    CFStringRef v4 = BbfwReaderOpen(cf);
    if (v4)
    {
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"acdb.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"aop.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"apdp.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"apps.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"bbcfg.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"devcfg.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"hyp.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"qdsp6sw.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"sec.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"restoresbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchRestoreSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"sbl1.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchSbl1, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"multi_image.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchMisc, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"multi_image_qti.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"tz.mbn", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"Info.plist", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallBasebandStitchCopyFile, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"xbl_cfg.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"uefi.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      AMAuthInstallBasebandStitchFirmwareFromBbfw(a1, @"xbl_support.elf", (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, void **))AMAuthInstallMonetStitchCopyIfPersonalized, (uint64_t)v4, a3, a4);
      uint64_t v5 = 0;
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandMAV22StitchFirmware", (uint64_t)"failed to open bbfw archive for reading", v9, v10, v11, v12, v13, v15);
      uint64_t v5 = 4;
    }
  }
  BbfwReaderClose((uint64_t)v4);
  return v5;
}

void *BbfwReaderOpen(CFTypeRef cf)
{
  CFURLRef url = 0;
  if (AMAuthInstallSupportCopyPreserveFileURL(kCFAllocatorDefault, cf, (CFTypeRef *)&url, 0))
  {
    AMAuthInstallLog(3, (uint64_t)"BbfwReaderOpen", (uint64_t)"%s: failed to get new URL", v1, v2, v3, v4, v5, (char)"BbfwReaderOpen");
    goto LABEL_5;
  }
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024))
  {
LABEL_5:
    uint64_t v11 = 0;
    goto LABEL_6;
  }
  uint64_t v11 = amai_unzOpen((uint64_t)buffer);
  if (!v11)
  {
    AMAuthInstallLog(3, (uint64_t)"BbfwReaderOpen", (uint64_t)"failed to open bbfw archive for reading", v6, v7, v8, v9, v10, v18);
    AMAuthInstallLog(7, (uint64_t)"BbfwReaderOpen", (uint64_t)"Bbfw url: %@", v12, v13, v14, v15, v16, (char)url);
    goto LABEL_5;
  }
LABEL_6:
  SafeRelease(url);
  return v11;
}

uint64_t BbfwReaderClose(uint64_t a1)
{
  if (a1) {
    amai_unzClose(a1);
  }
  return 0;
}

uint64_t BbfwReaderFindFile(uint64_t a1, CFStringRef theString)
{
  if (CFStringGetCString(theString, buffer, 1024, 0x8000100u)) {
    return 4 * (amai_unzLocateFile(a1, buffer, 0) != 0);
  }
  else {
    return 99;
  }
}

uint64_t BbfwReaderFindAndCopyFileData(uint64_t a1, const __CFString *a2, CFTypeRef *a3)
{
  char v4 = (char)a2;
  CFTypeRef cf = 0;
  uint64_t File = BbfwReaderFindFile(a1, a2);
  if (File)
  {
    uint64_t v7 = File;
    AMAuthInstallGetLocalizedStatusString(0, File);
    AMAuthInstallLog(7, (uint64_t)"BbfwReaderFindAndCopyFileData", (uint64_t)"failed to find bbfw item \"%@\": %@", v8, v9, v10, v11, v12, v4);
    CFTypeRef v13 = 0;
  }
  else
  {
    uint64_t v14 = BbfwReaderCopyFileData(a1, &cf);
    if (v14)
    {
      uint64_t v7 = v14;
      AMAuthInstallGetLocalizedStatusString(0, v14);
      AMAuthInstallLog(3, (uint64_t)"BbfwReaderFindAndCopyFileData", (uint64_t)"failed to extract bbfw item \"%@\": %@", v20, v21, v22, v23, v24, v4);
      CFTypeRef v13 = cf;
    }
    else
    {
      CFTypeRef v13 = cf;
      if (cf)
      {
        uint64_t v7 = 0;
        *a3 = CFRetain(cf);
      }
      else
      {
        AMAuthInstallLog(3, (uint64_t)"BbfwReaderFindAndCopyFileData", (uint64_t)"failed to extract bbfw item \"%@\": fileData is NULL", v15, v16, v17, v18, v19, v4);
        uint64_t v7 = 0;
      }
    }
  }
  SafeRelease(v13);
  return v7;
}

uint64_t BbfwReaderCopyFileData(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)__size = 0u;
  memset(v11, 0, sizeof(v11));
  CFAllocatorRef v4 = AMAuthInstallSupportCopyAllocator();
  if (amai_unzGetCurrentFileInfo(a1, (uint64_t)v11, (uint64_t)v18, 0x400uLL, 0, 0, 0, 0))
  {
    uint64_t v5 = 0;
    goto LABEL_10;
  }
  uint64_t v5 = (UInt8 *)malloc(__size[1]);
  if (!v5)
  {
    CFDataRef v8 = 0;
    goto LABEL_12;
  }
  if (amai_unzOpenCurrentFile(a1)) {
    goto LABEL_10;
  }
  Currentuint64_t File = amai_unzReadCurrentFile(a1, (uint64_t)v5, __size[1]);
  if (__size[1] != CurrentFile)
  {
    CFDataRef v8 = 0;
    uint64_t v9 = 4;
    goto LABEL_8;
  }
  if (amai_unzCloseCurrentFile(a1))
  {
LABEL_10:
    CFDataRef v8 = 0;
    uint64_t v9 = 15;
    goto LABEL_8;
  }
  CFDataRef v7 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v5, __size[1], v4);
  CFDataRef v8 = v7;
  if (!v7)
  {
LABEL_12:
    uint64_t v9 = 2;
    goto LABEL_8;
  }
  uint64_t v9 = 0;
  uint64_t v5 = 0;
  *a2 = CFRetain(v7);
LABEL_8:
  SafeRelease(v8);
  SafeRelease(v4);
  SafeFree(v5);
  return v9;
}

uint64_t BbfwReaderStart(const void *a1, uint64_t (*a2)(uint64_t, CFStringRef, void *), uint64_t a3)
{
  uint64_t v5 = BbfwReaderOpen(a1);
  if (!v5)
  {
    AMAuthInstallLog(3, (uint64_t)"BbfwReaderStart", (uint64_t)"failed to open bbfw archive for reading", v6, v7, v8, v9, v10, v17[0]);
    return 4;
  }
  uint64_t v11 = v5;
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  while (1)
  {
    if (amai_unzGetCurrentFileInfo((uint64_t)v11, (uint64_t)v17, (uint64_t)cStr, 0x400uLL, 0, 0, 0, 0))
    {
      uint64_t v15 = 15;
      goto LABEL_9;
    }
    if (cStr[0]) {
      break;
    }
LABEL_7:
    if (amai_unzGoToNextFile(v11))
    {
LABEL_8:
      uint64_t v15 = 0;
      goto LABEL_9;
    }
  }
  CFStringRef v12 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
  if (v12)
  {
    CFStringRef v13 = v12;
    int v14 = a2(a3, v12, v11);
    CFRelease(v13);
    if (!v14) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  uint64_t v15 = 3;
LABEL_9:
  amai_unzClose((uint64_t)v11);
  return v15;
}

uint64_t BbfwCreateDictionaryFromURL(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v6 = BbfwReaderStart(a2, (uint64_t (*)(uint64_t, CFStringRef, void *))sub_100033CB0, (uint64_t)Mutable);
    if (!v6) {
      *a3 = CFRetain(Mutable);
    }
  }
  else
  {
    uint64_t v6 = 2;
  }
  SafeRelease(Mutable);
  return v6;
}

BOOL sub_100033CB0(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFDictionaryRef value = 0;
  int v5 = BbfwReaderCopyFileData(a3, (CFTypeRef *)&value);
  uint64_t v6 = value;
  if (!v5) {
    CFDictionarySetValue(a1, a2, value);
  }
  SafeRelease(v6);
  return v5 == 0;
}

void *BbfwWriterCreate(CFTypeRef cf)
{
  CFURLRef url = 0;
  if (AMAuthInstallSupportCopyPreserveFileURL(kCFAllocatorDefault, cf, (CFTypeRef *)&url, 1))
  {
    AMAuthInstallLog(3, (uint64_t)"BbfwWriterCreate", (uint64_t)"%s: failed to get new URL", v1, v2, v3, v4, v5, (char)"BbfwWriterCreate");
    goto LABEL_5;
  }
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024))
  {
LABEL_5:
    uint64_t v11 = 0;
    goto LABEL_6;
  }
  uint64_t v11 = amai_zipOpen();
  if (!v11)
  {
    AMAuthInstallLog(3, (uint64_t)"BbfwWriterCreate", (uint64_t)"failed to open bbfw archive for writing", v6, v7, v8, v9, v10, v18);
    AMAuthInstallLog(7, (uint64_t)"BbfwWriterCreate", (uint64_t)"Bbfw url: %@", v12, v13, v14, v15, v16, (char)url);
    goto LABEL_5;
  }
LABEL_6:
  SafeRelease(url);
  return v11;
}

uint64_t BbfwWriterAddFile(uint64_t a1, CFStringRef theString, const __CFData *a3)
{
  char v4 = (char)theString;
  if (!CFStringGetCString(theString, buffer, 1024, 0x8000100u))
  {
    int v29 = "Failed to convert bb filename to cstring";
    uint64_t v27 = 3;
LABEL_13:
    AMAuthInstallLog(3, (uint64_t)"BbfwWriterAddFile", (uint64_t)v29, v6, v7, v8, v9, v10, (char)v40);
    return v27;
  }
  uint64_t v11 = amai_zipOpenNewFileInZip(a1, buffer, 0, 0, 0, 0, 0, "", 8, -1);
  if (v11)
  {
    uint64_t v27 = sub_100034024(v11, 5000);
    AMAuthInstallLog(3, (uint64_t)"BbfwWriterAddFile", (uint64_t)"Failed to open file in zip: %s", v30, v31, v32, v33, v34, (char)buffer);
    return v27;
  }
  BytePtr = CFDataGetBytePtr(a3);
  if (!BytePtr)
  {
    AMAuthInstallLog(3, (uint64_t)"BbfwWriterAddFile", (uint64_t)"FileData byte pointer is NULL: %s", v13, v14, v15, v16, v17, (char)buffer);
    return 4;
  }
  char v18 = BytePtr;
  uInt Length = CFDataGetLength(a3);
  uint64_t v20 = amai_zipWriteInFileInZip(a1, v18, Length);
  if (v20)
  {
    uint64_t v27 = sub_100034024(v20, 5001);
    __error();
    AMAuthInstallLog(3, (uint64_t)"BbfwWriterAddFile", (uint64_t)"Failed to write file in zip %s with error: %d %d", v35, v36, v37, v38, v39, (char)buffer);
    return v27;
  }
  uint64_t v21 = amai_zipCloseFileInZip(a1);
  if (v21)
  {
    uint64_t v27 = sub_100034024(v21, 5002);
    __error();
    uint64_t v40 = buffer;
    int v29 = "Failed to close file in zip %s with error: %d %d";
    goto LABEL_13;
  }
  AMAuthInstallLog(7, (uint64_t)"BbfwWriterAddFile", (uint64_t)"Added bbfw file : %@", v22, v23, v24, v25, v26, v4);
  return 0;
}

uint64_t sub_100034024(uint64_t result, uint64_t a2)
{
  if ((int)result <= -7)
  {
    switch(result)
    {
      case 0xFFFFFF98:
        return 5005;
      case 0xFFFFFF99:
        return 5004;
      case 0xFFFFFF9A:
        return 5003;
      default:
        return a2;
    }
  }
  else
  {
    switch((int)result)
    {
      case -6:
        uint64_t result = 5010;
        break;
      case -5:
        uint64_t result = 5009;
        break;
      case -4:
        uint64_t result = 5008;
        break;
      case -3:
        uint64_t result = 5007;
        break;
      case -2:
        uint64_t result = 5006;
        break;
      case -1:
        int v2 = *__error();
        if ((v2 - 199) <= 0xFFFFFF39) {
          return 5003;
        }
        uint64_t result = (v2 + 5100);
        break;
      case 0:
        return result;
      default:
        return a2;
    }
  }
  return result;
}

uint64_t BbfwWriterFinalize(uint64_t a1)
{
  return amai_zipClose(a1, "");
}

uint64_t DERDecoderInitialize(uint64_t a1, unsigned __int8 *a2, unsigned int *a3, unsigned int a4)
{
  if (!a1) {
    sub_1000721AC();
  }
  if (!a2) {
    sub_1000721D8();
  }
  if (!a3) {
    sub_100072204();
  }
  unsigned int v8 = *a3;
  if (*a3)
  {
LABEL_5:
    if (v8 > a4) {
      return 2;
    }
    uint64_t result = 0;
    *a3 = v8;
    *(void *)a1 = a2;
    *(_DWORD *)(a1 + 8) = v8;
    return result;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  int v13 = 0;
  uint64_t result = sub_100034208(a2, a4, (unsigned int *)&v15, (int *)&v14 + 1, (int *)&v14, &v13);
  if (!result)
  {
    int v10 = a4 - v13;
    uint64_t result = sub_1000342FC(&a2[v13], a4 - v13, (int *)&v15 + 1, &v13);
    if (!result)
    {
      unsigned int v11 = v13 - v10 + a4;
      unsigned int v8 = v11 + HIDWORD(v15);
      if (v11 + HIDWORD(v15) < HIDWORD(v15) || v8 < v11) {
        return 6;
      }
      goto LABEL_5;
    }
  }
  return result;
}

uint64_t sub_100034208(unsigned __int8 *a1, int a2, unsigned int *a3, int *a4, int *a5, _DWORD *a6)
{
  if (!a1) {
    sub_100072230();
  }
  if (!a3) {
    sub_10007225C();
  }
  if (!a4) {
    sub_100072288();
  }
  if (!a5) {
    sub_1000722B4();
  }
  if (!a6) {
    sub_1000722E0();
  }
  if (!a2) {
    return 3;
  }
  unsigned int v6 = *a1;
  *a3 = v6 >> 6;
  unsigned int v7 = *a1;
  if ((~v6 & 0x1F) == 0)
  {
    int v8 = 0;
    unsigned int v9 = 0;
    int v10 = 0;
    *a5 = (v7 >> 5) & 1;
    int v11 = a2 - 1;
    uint64_t v12 = (char *)(a1 + 1);
    while (v11)
    {
      char v13 = *v12;
      int v14 = *v12 & 0x7F | (v8 << 7);
      v10 |= v14 != 0;
      if (v10)
      {
        v9 += 7;
        if (v9 > 0x20) {
          return 6;
        }
      }
      --v11;
      ++v12;
      int v8 = v14;
      if ((v13 & 0x80000000) == 0)
      {
        *a4 = v14;
        goto LABEL_16;
      }
    }
    return 3;
  }
  *a4 = v7 & 0x1F;
  *a5 = (*a1 >> 5) & 1;
  int v11 = a2 - 1;
LABEL_16:
  uint64_t result = 0;
  *a6 = a2 - v11;
  return result;
}

uint64_t sub_1000342FC(unsigned __int8 *a1, int a2, int *a3, _DWORD *a4)
{
  if (!a1) {
    sub_10007230C();
  }
  if (!a3) {
    sub_100072338();
  }
  if (!a4) {
    sub_100072364();
  }
  if (!a2) {
    return 4;
  }
  int v4 = *a1;
  unsigned int v5 = a2 - 1;
  if (((char)*a1 & 0x80000000) == 0)
  {
LABEL_6:
    uint64_t result = 0;
    *a3 = v4;
    *a4 = a2 - v5;
    return result;
  }
  unsigned int v7 = v4 & 0x7F;
  BOOL v8 = v5 >= v7;
  v5 -= v7;
  if (!v8) {
    return 4;
  }
  if ((v4 & 0x7F) == 0)
  {
    int v4 = 0;
    goto LABEL_6;
  }
  int v9 = 0;
  unsigned int v10 = 0;
  int v4 = 0;
  int v11 = a1 + 1;
  while (1)
  {
    int v12 = *v11++;
    int v4 = v12 | (v4 << 8);
    v9 |= v4 != 0;
    if (v9)
    {
      v10 += 8;
      if (v10 > 0x20) {
        return 6;
      }
    }
    if (!--v7) {
      goto LABEL_6;
    }
  }
}

uint64_t DERDecoderGetDataWithTag(uint64_t a1, unsigned int a2, unsigned int a3, int a4, void *a5, _DWORD *a6, int *a7)
{
  if (!a1) {
    sub_100072390();
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  *(void *)((char *)&v13 + 4) = __PAIR64__(a3, a2);
  HIDWORD(v14) = a4;
  if (a7) {
    int v10 = *a7;
  }
  else {
    int v10 = 0;
  }
  DWORD1(v12) = v10;
  uint64_t result = sub_100034464(a1, (uint64_t (*)(unsigned __int8 **, uint64_t))sub_10003459C, (uint64_t)&v12);
  if (!result)
  {
    if (!(void)v14) {
      sub_1000723BC();
    }
    if (a5) {
      *a5 = v14;
    }
    if (a6) {
      *a6 = DWORD2(v14);
    }
    if (a7) {
      *a7 = v12;
    }
  }
  return result;
}

uint64_t sub_100034464(uint64_t a1, uint64_t (*a2)(unsigned __int8 **, uint64_t), uint64_t a3)
{
  if (!a1) {
    sub_1000723E8();
  }
  int v3 = *(_DWORD *)(a1 + 8);
  if (!v3) {
    return 1;
  }
  unsigned int v6 = *(unsigned __int8 **)a1;
  while (1)
  {
    int v12 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v13 = v6;
    uint64_t result = sub_100034208(v6, v3, (unsigned int *)&v14 + 1, (int *)&v14 + 2, (int *)&v15 + 3, &v12);
    if (result) {
      break;
    }
    if (!v12) {
      sub_100072414();
    }
    int v8 = v3 - v12;
    int v9 = &v6[v12];
    uint64_t result = sub_1000342FC(v9, v8, (int *)&v15 + 2, &v12);
    if (result) {
      break;
    }
    if (!v12) {
      sub_100072440();
    }
    unsigned int v10 = v8 - v12;
    if (v10 < DWORD2(v15)) {
      return 2;
    }
    int v11 = &v9[v12];
    *(void *)&long long v15 = v11;
    LODWORD(v14) = DWORD2(v15) + v11 - v13;
    uint64_t result = a2(&v13, a3);
    if (result != 1) {
      return result;
    }
    unsigned int v6 = &v11[DWORD2(v15)];
    int v3 = v10 - DWORD2(v15);
    if (v10 == DWORD2(v15)) {
      return 1;
    }
  }
  return result;
}

uint64_t sub_10003459C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 20)
    && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 24)
    && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a2 + 44)
    && *(_DWORD *)a2 >= *(_DWORD *)(a2 + 4))
  {
    uint64_t v2 = 0;
    *(void *)(a2 + 32) = *(void *)(a1 + 24);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 32);
    *(void *)(a2 + 8) = *(void *)a1;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 8);
  }
  else
  {
    ++*(_DWORD *)a2;
    return 1;
  }
  return v2;
}

uint64_t DERDecoderGetEncodingWithTag(uint64_t a1, unsigned int a2, unsigned int a3, int a4, void *a5, _DWORD *a6, int *a7)
{
  if (!a1) {
    sub_10007246C();
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  *(void *)((char *)&v13 + 4) = __PAIR64__(a3, a2);
  HIDWORD(v14) = a4;
  if (a7) {
    int v10 = *a7;
  }
  else {
    int v10 = 0;
  }
  DWORD1(v12) = v10;
  uint64_t result = sub_100034464(a1, (uint64_t (*)(unsigned __int8 **, uint64_t))sub_10003459C, (uint64_t)&v12);
  if (!result)
  {
    if (!*((void *)&v12 + 1)) {
      sub_100072498();
    }
    if (a5) {
      *a5 = *((void *)&v12 + 1);
    }
    if (a6) {
      *a6 = v13;
    }
    if (a7) {
      *a7 = v12;
    }
  }
  return result;
}

uint64_t Img4EncodeIMG4Tag(uint64_t a1)
{
  if (a1)
  {
    if (DEREncoderCreate())
    {
      uint64_t EncodedBuffer = DEREncoderAddData();
      if (!EncodedBuffer) {
        uint64_t EncodedBuffer = DEREncoderCreateEncodedBuffer();
      }
      uint64_t v2 = EncodedBuffer;
    }
    else
    {
      uint64_t v2 = 2;
    }
  }
  else
  {
    uint64_t v2 = 1;
  }
  DEREncoderDestroy();
  return v2;
}

uint64_t Img4EncodeImg4Header(unsigned int a1, void *a2, _DWORD *a3)
{
  return sub_100034778(0, 16, a1, a2, a3);
}

uint64_t sub_100034778(char a1, char a2, unsigned int a3, void *a4, _DWORD *a5)
{
  uint64_t v5 = 1;
  if (a4 && a5)
  {
    int v11 = malloc(0x10uLL);
    if (v11)
    {
      *int v11 = a2 | (a1 << 6) | 0x20;
      if (a3 > 0x7F)
      {
        uint64_t v13 = 0;
        uint64_t v17 = 0;
        do
        {
          *((unsigned char *)&v17 + v13++) = a3;
          BOOL v14 = a3 > 0xFF;
          a3 >>= 8;
        }
        while (v14);
        LODWORD(v12) = v11 + 1;
        if (v13 <= 0xE)
        {
          v11[1] = v13 | 0x80;
          long long v12 = v11 + 2;
          if (v13)
          {
            do
              *v12++ = *((unsigned char *)&v17 + --v13);
            while (v13);
          }
        }
      }
      else
      {
        v11[1] = a3;
        LODWORD(v12) = v11 + 2;
      }
      int v15 = v12 - (v11 + 1);
      if (v15)
      {
        uint64_t v5 = 0;
        *a5 = v15 + 1;
        *a4 = v11;
      }
      else
      {
        free(v11);
        return 3;
      }
    }
    else
    {
      return 2;
    }
  }
  return v5;
}

uint64_t Img4EncodeManifestHeader(unsigned int a1, void *a2, _DWORD *a3)
{
  return sub_100034778(2, 0, a1, a2, a3);
}

uint64_t FlsParserCreate(const __CFAllocator *a1)
{
  pthread_once(&stru_1000B8380, (void (*)(void))sub_100034978);
  uint64_t result = (uint64_t)CFArrayCreateMutable(a1, 0, &kCFTypeArrayCallBacks);
  if (result)
  {
    int v3 = (const void *)result;
    int v4 = (PRGSequencer *)operator new(0xCC8uLL);
    PRGSequencer::PRGSequencer(v4);
    uint64_t result = _CFRuntimeCreateInstance();
    if (result)
    {
      *(void *)(result + 16) = v3;
      *(void *)(result + 24) = v4;
    }
    else
    {
      CFRelease(v3);
      PRGSequencer::~PRGSequencer(v4);
      operator delete(v5);
      return 0;
    }
  }
  return result;
}

uint64_t sub_100034978()
{
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1000B8CC8 = result;
  return result;
}

uint64_t FlsParserReadFromData(uint64_t a1, CFDataRef theData)
{
  int v3 = *(PRGSequencer **)(a1 + 24);
  BytePtr = (const char *)CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  PRGSequencer::ReadBuffer(v3, BytePtr, Length, 7, 0x20004u, 0);
  return 0;
}

uint64_t FlsParserCopyRamPsi(PRGSequencer **a1, CFDataRef *a2)
{
  CFDataRef v13 = 0;
  if (sub_100034A8C(a1, 1, (CFTypeRef *)&v13, 0) && (uint64_t v4 = sub_100034BAC(a1, 18, a2), v4))
  {
    uint64_t v10 = v4;
    AMAuthInstallLog(3, (uint64_t)"FlsParserCopyRamPsi", (uint64_t)"failed to copy RamPSI", v5, v6, v7, v8, v9, v12);
  }
  else
  {
    uint64_t v10 = 0;
    *a2 = v13;
  }
  return v10;
}

uint64_t sub_100034A8C(PRGSequencer **a1, int a2, CFTypeRef *a3, CFTypeRef *a4)
{
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v7 = sub_1000350F0((uint64_t)a1, a2, &v15, &v14);
  if (v7) {
    return v7;
  }
  if (a3)
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    ElementCFDataRef Data = (const UInt8 *)PRGSequencer::GetElementData(a1[3], *(_DWORD *)(v15 + 32));
    CFDataRef v10 = CFDataCreate(v8, ElementData, *(unsigned int *)(v15 + 28));
    if (!v10) {
      return 2;
    }
  }
  else
  {
    CFDataRef v10 = 0;
  }
  if (a4)
  {
    CFAllocatorRef v11 = CFGetAllocator(a1);
    CFDataRef v12 = CFDataCreate(v11, (const UInt8 *)(v14 + 524), 1536);
    if (!v12)
    {
      uint64_t v7 = 2;
      if (!v10) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
  }
  else
  {
    CFDataRef v12 = 0;
  }
  if (a3) {
    *a3 = CFRetain(v10);
  }
  if (a4)
  {
    uint64_t v7 = 0;
    *a4 = CFRetain(v12);
    if (!v10) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v7 = 0;
  if (v10) {
LABEL_15:
  }
    CFRelease(v10);
LABEL_16:
  if (v12) {
    CFRelease(v12);
  }
  return v7;
}

uint64_t sub_100034BAC(PRGSequencer **a1, int a2, CFDataRef *a3)
{
  ElementStructure = PRGSequencer::FindElementStructure(a1[3], a2, 0);
  if (ElementStructure)
  {
    CFAllocatorRef v11 = ElementStructure;
    ElementCFDataRef Data = (const UInt8 *)PRGSequencer::GetElementData(a1[3], ElementStructure[6]);
    CFAllocatorRef v13 = CFGetAllocator(a1);
    CFDataRef v14 = CFDataCreate(v13, ElementData, v11[5]);
    if (v14)
    {
      CFDataRef v15 = v14;
      uint64_t result = 0;
      *a3 = v15;
    }
    else
    {
      return 2;
    }
  }
  else
  {
    AMAuthInstallLog(6, (uint64_t)"_FlsParserCopyInjectedItem", (uint64_t)"not found in this file", v6, v7, v8, v9, v10, v17);
    return 1;
  }
  return result;
}

uint64_t FlsParserReplaceEbl(uint64_t a1, const __CFData *a2)
{
  ElementStructure = PRGSequencer::FindElementStructure(*(PRGSequencer **)(a1 + 24), 19, 0);
  if (ElementStructure)
  {
    PRGSequencer::RemoveElement(*(void ***)(a1 + 24), ElementStructure);
    return sub_100034CD0(a1, 19, a2);
  }
  else
  {
    return sub_100034D90(a1, 3, a2);
  }
}

uint64_t sub_100034CD0(uint64_t a1, int a2, const __CFData *a3)
{
  if (!a1) {
    return 1;
  }
  uint64_t Element = PRGSequencer::CreateElement(*(PRGSequencer **)(a1 + 24), a2);
  if (Element)
  {
    uint64_t v7 = (char *)Element;
    uint64_t v8 = *(PRGSequencer **)(a1 + 24);
    BytePtr = CFDataGetBytePtr(a3);
    int v10 = PRGSequencer::RegisterElementData(v8, BytePtr);
    if (v10 != -1)
    {
      int v11 = v10;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a3);
      *(_DWORD *)uint64_t v7 = a2;
      *(void *)(v7 + 4) = 32;
      int Length = CFDataGetLength(a3);
      uint64_t result = 0;
      *((_DWORD *)v7 + 5) = Length;
      *((_DWORD *)v7 + 6) = v11;
      return result;
    }
    PRGSequencer::RemoveElement(*(void ***)(a1 + 24), v7);
  }
  return 2;
}

uint64_t sub_100034D90(uint64_t a1, int a2, const __CFData *a3)
{
  uint64_t v11 = 0;
  if (sub_1000350F0(a1, a2, &v11, 0)) {
    return 1;
  }
  uint64_t v6 = *(PRGSequencer **)(a1 + 24);
  BytePtr = CFDataGetBytePtr(a3);
  int v8 = PRGSequencer::RegisterElementData(v6, BytePtr);
  if (v8 == -1) {
    return 2;
  }
  int v9 = v8;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a3);
  *(_DWORD *)(v11 + 32) = v9;
  int Length = CFDataGetLength(a3);
  uint64_t result = 0;
  *(_DWORD *)(v11 + 28) = Length;
  return result;
}

uint64_t FlsParserCopyEbl(PRGSequencer **a1, void *a2)
{
  CFTypeRef v13 = 0;
  if (sub_100034A8C(a1, 3, &v13, 0) && (uint64_t v4 = sub_100034BAC(a1, 19, (CFDataRef *)&v13), v4))
  {
    uint64_t v10 = v4;
    AMAuthInstallLog(3, (uint64_t)"FlsParserCopyEbl", (uint64_t)"failed to copy EBL", v5, v6, v7, v8, v9, v12);
  }
  else
  {
    uint64_t v10 = 0;
    *a2 = v13;
  }
  return v10;
}

uint64_t FlsParserCopyFlashPsi(PRGSequencer **a1, CFTypeRef *a2, CFTypeRef *a3)
{
  return sub_100034A8C(a1, 2, a2, a3);
}

uint64_t FlsParserReplaceFlashPsi(uint64_t a1, const __CFData *a2)
{
  return sub_100034D90(a1, 2, a2);
}

uint64_t FlsParserCopyModemStack(PRGSequencer **a1, CFTypeRef *a2, CFTypeRef *a3)
{
  return sub_100034A8C(a1, 4, a2, a3);
}

uint64_t FlsParserReplaceRamPsi(uint64_t a1, const __CFData *a2)
{
  ElementStructure = PRGSequencer::FindElementStructure(*(PRGSequencer **)(a1 + 24), 18, 0);
  if (ElementStructure)
  {
    PRGSequencer::RemoveElement(*(void ***)(a1 + 24), ElementStructure);
    return sub_100034CD0(a1, 18, a2);
  }
  else
  {
    return sub_100034D90(a1, 1, a2);
  }
}

uint64_t FlsParserCopyAsData(PRGSequencer **a1, CFTypeRef *a2)
{
  memset(length, 0, sizeof(length));
  CFAllocatorRef v4 = AMAuthInstallSupportCopyAllocator();
  PRGSequencer::WriteToBuffer(a1[3], (char **)&length[1], length);
  if (*(void *)&length[1]
    && (CFAllocatorRef v5 = CFGetAllocator(a1),
        (CFDataRef v6 = CFDataCreateWithBytesNoCopy(v5, *(const UInt8 **)&length[1], length[0], v4)) != 0))
  {
    CFDataRef v7 = v6;
    *a2 = CFRetain(v6);
    CFRelease(v7);
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 2;
  }
  SafeRelease(v4);
  return v8;
}

void sub_100035018(uint64_t a1)
{
  if (!a1) {
    sub_1000724C4();
  }
  uint64_t v2 = *(PRGSequencer **)(a1 + 24);
  if (v2)
  {
    PRGSequencer::~PRGSequencer(v2);
    operator delete(v3);
  }
  CFRelease(*(CFTypeRef *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
}

CFStringRef sub_10003505C(const void *a1, const __CFDictionary *a2)
{
  if (!a1) {
    sub_1000724F0();
  }
  CFAllocatorRef v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<FlsParser %p>", a1);
}

CFStringRef sub_1000350A8(const void *a1)
{
  if (!a1) {
    sub_10007251C();
  }
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<FlsParser %p>", a1);
}

uint64_t sub_1000350F0(uint64_t a1, int a2, void *a3, void *a4)
{
  ElementStructure = PRGSequencer::FindElementStructure(*(PRGSequencer **)(a1 + 24), 16, 0);
  if (!ElementStructure)
  {
    char v17 = "no toc found in this file";
    goto LABEL_8;
  }
  uint64_t v14 = ElementStructure[3];
  ElementCFDataRef Data = PRGSequencer::GetElementData(*(PRGSequencer **)(a1 + 24), ElementStructure[4]);
  if (!v14)
  {
LABEL_6:
    char v17 = "not found in this file";
    goto LABEL_8;
  }
  uint64_t v16 = (_DWORD *)(ElementData + 4);
  while (*v16 != a2)
  {
    v16 += 36;
    if (!--v14) {
      goto LABEL_6;
    }
  }
  int v19 = *(v16 - 1);
  if (a3)
  {
    uint64_t v20 = PRGSequencer::FindElementStructure(*(PRGSequencer **)(a1 + 24), 12, *(v16 - 1));
    if (!v20)
    {
      char v17 = "missing download data";
      goto LABEL_8;
    }
    *a3 = v20;
  }
  if (a4)
  {
    uint64_t v21 = PRGSequencer::FindElementStructure(*(PRGSequencer **)(a1 + 24), 15, v19);
    if (v21)
    {
      uint64_t v22 = v21;
      uint64_t result = 0;
      *a4 = v22;
      return result;
    }
    char v17 = "missing security pack";
LABEL_8:
    AMAuthInstallLog(3, (uint64_t)"_FlsParserFindDownloadItem", (uint64_t)v17, v9, v10, v11, v12, v13, v23);
    return 1;
  }
  return 0;
}

void IFWD_MemoryStream::IFWD_MemoryStream(IFWD_MemoryStream *this)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)this = 0;
  *((void *)this + 2) = 0;
}

void IFWD_MemoryStream::Clear(IFWD_MemoryStream *this)
{
  CFAllocatorRef v2 = *(void **)this;
  if (v2)
  {
    operator delete[](v2);
    *(void *)this = 0;
    *((void *)this + 2) = 0;
    *((_DWORD *)this + 2) = 0;
  }
}

void IFWD_MemoryStream::~IFWD_MemoryStream(IFWD_MemoryStream *this)
{
  CFAllocatorRef v2 = *(void **)this;
  if (v2)
  {
    operator delete[](v2);
    *(void *)this = 0;
    *((void *)this + 2) = 0;
    *((_DWORD *)this + 2) = 0;
  }
}

void IFWD_MemoryStream::SetSize(IFWD_MemoryStream *this, int a2)
{
  if (a2 <= 0)
  {
    uint64_t v9 = *(void **)this;
    if (*(void *)this)
    {
      operator delete[](v9);
      *(void *)this = 0;
      *((void *)this + 2) = 0;
      *((_DWORD *)this + 2) = 0;
    }
  }
  else
  {
    int v4 = *((_DWORD *)this + 2);
    if (a2 != v4)
    {
      CFAllocatorRef v5 = (char *)operator new[]((a2 + 1));
      CFDataRef v6 = v5;
      CFDataRef v7 = *(void **)this;
      if (*(void *)this)
      {
        int v8 = a2;
        if (a2 > v4)
        {
          bzero(&v5[v4], a2 - v4);
          int v8 = v4;
        }
        memcpy(v6, v7, v8);
        operator delete[](v7);
      }
      else
      {
        bzero(v5, a2);
      }
      *((_DWORD *)this + 2) = a2;
      *(void *)this = v6;
      *((void *)this + 2) = v6;
    }
  }
}

void image3Discard(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2)
    {
      if (*(void *)v2)
      {
        if ((*(unsigned char *)(v2 + 10) & 4) != 0)
        {
          image3Free(*(void **)v2);
          uint64_t v2 = *a1;
        }
      }
      image3Free((void *)v2);
      *a1 = 0;
    }
  }
}

uint64_t image3Finalize(uint64_t a1, char **a2, void *a3, int a4, uint64_t a5)
{
  unint64_t v23 = 0;
  int8x16_t v24 = 0uLL;
  int v25 = 0;
  size_t __n = 0;
  __srCC_SHA256_CTX c = 0;
  size_t v18 = 0;
  int v19 = 0;
  if (!a4) {
    goto LABEL_12;
  }
  uint64_t result = image3AdvanceCursorWithZeroPad((char **)a1, (56 - *(_DWORD *)(a1 + 24)) & 0x3F);
  if (!result)
  {
    uint64_t v10 = *(char **)a1;
    unsigned int v11 = *(_DWORD *)(a1 + 24);
    *((_DWORD *)v10 + 3) = v11 + a5;
    uint64_t v12 = v10 + 12;
    CC_LONG v13 = v11 + 8;
    if (a5)
    {
      unint64_t v23 = __PAIR64__(v11, a5);
      uint64_t v14 = &v23;
      image3SHA1Partial(v12, v13, &v24);
      uint64_t v15 = 28;
    }
    else
    {
      uint64_t v14 = (unint64_t *)v22;
      image3SHA1Generate(v12, v13, v22);
      uint64_t v15 = 20;
    }
    uint64_t result = image3PKISignHash((uint64_t)v14, v15, &__src, &__n, &v19, &v18);
    if (!result)
    {
      if (!__n || (uint64_t result = image3SetTagStructure((char **)a1, 1397248840, __src, __n, 0), !result))
      {
        if (!v18 || (uint64_t result = image3SetTagStructure((char **)a1, 1128616532, v19, v18, 0), !result))
        {
          *(_DWORD *)(a1 + 8) |= 0x20000u;
LABEL_12:
          uint64_t result = 0;
          uint64_t v16 = *(char **)a1;
          *((_DWORD *)v16 + 2) = *(_DWORD *)(a1 + 24);
          uint64_t v17 = (*(_DWORD *)(a1 + 24) + 20);
          *((_DWORD *)v16 + 1) = v17;
          *a2 = v16;
          *a3 = v17;
        }
      }
    }
  }
  return result;
}

uint64_t image3AdvanceCursorWithZeroPad(char **a1, int a2)
{
  if ((*((unsigned char *)a1 + 10) & 2) != 0) {
    return 30;
  }
  uint64_t v4 = *((int *)a1 + 6);
  uint64_t v3 = *((int *)a1 + 7);
  LODWORD(v5) = v4 + a2;
  *((_DWORD *)a1 + 6) = v4 + a2;
  CFDataRef v6 = *a1;
  if (v3 != -1)
  {
    *(_DWORD *)&v6[v3 + 24] = v5 - v3;
    LODWORD(v5) = *((_DWORD *)a1 + 6);
  }
  uint64_t v5 = (int)v5;
  unint64_t v7 = (int)v5 + 20;
  if (v7 <= (unint64_t)a1[2]) {
    goto LABEL_7;
  }
  CFDataRef v6 = (char *)realloc(v6, (int)v5 + 20);
  if (v6)
  {
    *a1 = v6;
    a1[2] = (char *)v7;
    uint64_t v5 = *((int *)a1 + 6);
LABEL_7:
    bzero(&v6[v4 + 20], v5 - v4);
    uint64_t result = 0;
    *((_DWORD *)*a1 + 2) = *((_DWORD *)a1 + 6);
    return result;
  }
  return 12;
}

uint64_t image3SetTagStructure(char **a1, int a2, void *__src, size_t __n, int a5)
{
  if ((*((unsigned char *)a1 + 10) & 2) != 0) {
    return 30;
  }
  if (a5)
  {
    uint64_t v9 = *((int *)a1 + 7);
    int v10 = (a5 + *((_DWORD *)a1 + 6) / a5 * a5 - *((_DWORD *)a1 + 6)) % a5 + *((_DWORD *)a1 + 6);
    *((_DWORD *)a1 + 6) = v10;
    unsigned int v11 = *a1;
    if (v9 != -1) {
      *(_DWORD *)&v11[v9 + 24] = v10 - v9;
    }
  }
  else
  {
    unsigned int v11 = *a1;
  }
  if ((__n & 0xF) != 0) {
    size_t v13 = 16 - (__n & 0xF);
  }
  else {
    size_t v13 = 0;
  }
  uint64_t v14 = *((int *)a1 + 6);
  size_t v15 = __n + v13 + v14 + 32;
  if (v15 > (unint64_t)a1[2])
  {
    unsigned int v11 = (char *)realloc(v11, __n + v13 + v14 + 32);
    if (!v11) {
      return 12;
    }
    *a1 = v11;
    a1[2] = (char *)v15;
    uint64_t v14 = *((int *)a1 + 6);
  }
  uint64_t v16 = &v11[v14];
  if (((v13 + __n) & 3) != 0) {
    int v17 = ((v13 + __n) & 0xFFFFFFFC) + 16;
  }
  else {
    int v17 = v13 + __n + 12;
  }
  *((_DWORD *)v16 + 5) = a2;
  *((_DWORD *)v16 + 6) = v17;
  *((_DWORD *)v16 + 7) = __n;
  memcpy(v16 + 32, __src, __n);
  bzero(&v16[__n + 32], v13);
  uint64_t result = 0;
  int v18 = *((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 7) = v18;
  int v19 = *((_DWORD *)v16 + 6) + v18;
  *((_DWORD *)a1 + 6) = v19;
  *((_DWORD *)*a1 + 2) = v19;
  return result;
}

uint64_t image3InstantiateFromBuffer(void *a1, _DWORD *a2, unint64_t a3, char a4)
{
  if (a3 < 0x14) {
    return 22;
  }
  if (*a2 != 1231906611) {
    return 22;
  }
  unint64_t v6 = a2[2];
  if (a3 - 20 < v6 || a2[3] > v6 || v6 + 20 > a2[1]) {
    return 22;
  }
  int v10 = image3Malloc(0x28uLL);
  if (!v10) {
    return 12;
  }
  unsigned int v11 = v10;
  *((_DWORD *)v10 + 2) = 1;
  v10[4] = 0;
  if (a2[3])
  {
    *((_DWORD *)v10 + 2) = 131073;
    if ((a4 & 1) == 0)
    {
      *int v10 = a2;
      void v10[2] = a3;
LABEL_21:
      uint64_t result = 0;
      *a1 = v11;
      return result;
    }
    goto LABEL_19;
  }
  *((_DWORD *)v10 + 6) = a2[2];
  *((_DWORD *)v10 + 7) = -1;
  unsigned int v12 = a2[2];
  if (!v12)
  {
LABEL_19:
    size_t v16 = a2[2] + 20;
    v11[2] = v16;
    int v17 = image3Malloc(v16);
    *unsigned int v11 = v17;
    if (v17)
    {
      memcpy(v17, a2, v11[2]);
      *((_DWORD *)v11 + 2) |= 0x40000u;
      goto LABEL_21;
    }
    image3Free(v11);
    return 12;
  }
  unsigned int v13 = 0;
  while (1)
  {
    unsigned int v14 = v13;
    unsigned int v15 = *(_DWORD *)((char *)a2 + v13 + 24);
    v13 += v15;
    if (v13 > v12 || v15 <= 0xB) {
      break;
    }
    if (v13 == v12)
    {
      *((_DWORD *)v10 + 7) = v14;
      goto LABEL_19;
    }
  }
  image3Free(v10);
  return 22;
}

uint64_t image3GetTagStruct(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  uint64_t v5 = *(unsigned int *)(*(void *)a1 + 8);
  if (!v5) {
    return 2;
  }
  unint64_t v6 = (_DWORD *)(*(void *)a1 + 20);
  unint64_t v7 = (unint64_t)v6 + v5;
  while (1)
  {
    int v8 = v6 + 3;
    if ((unint64_t)(v6 + 3) > v7) {
      return 22;
    }
    uint64_t v9 = v6[2];
    if ((unint64_t)v8 + v9 > v7) {
      return 22;
    }
    if (a2 == -1 || *v6 == a2) {
      break;
    }
LABEL_9:
    unint64_t v10 = v6[1];
    if (v9 + 12 > v10) {
      return 22;
    }
    unint64_t v6 = (_DWORD *)((char *)v6 + v10);
    if ((unint64_t)v6 >= v7) {
      return 2;
    }
  }
  if (a5)
  {
    --a5;
    goto LABEL_9;
  }
  if (a4)
  {
    if (*a4 && *a4 != v9) {
      return 22;
    }
    *a4 = v9;
  }
  uint64_t result = 0;
  *a3 = v8;
  return result;
}

uint64_t image3GetTagSignedNumber(uint64_t a1, int a2, void *a3, int a4)
{
  uint64_t v7 = 0;
  int v8 = 0;
  uint64_t result = image3GetTagStruct(a1, a2, &v8, &v7, a4);
  if (!result)
  {
    if (v7 == 8)
    {
      uint64_t v6 = *(void *)v8;
      goto LABEL_6;
    }
    if (v7 == 4)
    {
      uint64_t v6 = *v8;
LABEL_6:
      uint64_t result = 0;
      *a3 = v6;
      return result;
    }
    return 22;
  }
  return result;
}

uint64_t image3GetTagString(uint64_t a1, int a2, void *a3, int a4)
{
  unint64_t v10 = 0;
  unsigned int v11 = 0;
  uint64_t result = image3GetTagStruct(a1, a2, &v11, &v10, a4);
  if (!result)
  {
    if (v10 >= 8 && (uint64_t v6 = v11, v7 = *v11, v10 >= v7 + 4))
    {
      int v8 = image3Malloc(v7 + 1);
      if (v8)
      {
        uint64_t v9 = v8;
        memcpy(v8, v6 + 1, v7);
        uint64_t result = 0;
        v9[v7] = 0;
        *a3 = v9;
      }
      else
      {
        return 12;
      }
    }
    else
    {
      return 22;
    }
  }
  return result;
}

uint64_t PRGH_GetLongFromLong(uint64_t result)
{
  unsigned int v1 = bswap32(result);
  if (mach_endian == 2) {
    return v1;
  }
  else {
    return result;
  }
}

uint64_t PRGH_GetEndian(char *a1)
{
  if (*(_DWORD *)a1 == 1000) {
    return 1;
  }
  else {
    return 2 * (*(_DWORD *)a1 == -402456576);
  }
}

uint64_t PRGH_FileCheck(char *a1)
{
  int v1 = *(_DWORD *)a1;
  int v2 = 2 * (*(_DWORD *)a1 == -402456576);
  if (*(_DWORD *)a1 == 1000) {
    int v2 = 1;
  }
  mach_endian = v2;
  unsigned int v3 = *(_DWORD *)a1;
  unsigned int v4 = bswap32(*(_DWORD *)a1);
  if (v1 == -402456576) {
    unsigned int v3 = v4;
  }
  if (v3 != 1000) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = bswap32(*((_DWORD *)a1 + 1));
  unsigned int v6 = v1 == -402456576 ? v5 : *((_DWORD *)a1 + 1);
  if (v6 != 40) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = *((_DWORD *)a1 + 2);
  unsigned int v8 = bswap32(v7);
  if (v1 == -402456576) {
    unsigned int v7 = v8;
  }
  if (v7) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v11 = *((_DWORD *)a1 + 3);
  unsigned int v12 = bswap32(v11);
  if (v1 == -402456576) {
    unsigned int v11 = v12;
  }
  uint64_t v9 = 0xFFFFFFFFLL;
  if ((_BYTE)v11 && (v11 & 0xFE) <= 5)
  {
    unsigned int v13 = *((_DWORD *)a1 + 4);
    unsigned int v14 = bswap32(v13);
    if (v1 == -402456576) {
      unsigned int v13 = v14;
    }
    if (v13 == 1765222897) {
      return v11;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return v9;
}

uint64_t PRGH_VersionCheck(char *a1, int a2, unsigned int a3)
{
  unsigned int v11 = 0;
  if (!PRGH_GetElementIndex(a1, a2, 0, &v11)) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = &a1[v11];
  unsigned int v6 = *((_DWORD *)v5 + 1);
  unsigned int v7 = bswap32(v6);
  if (mach_endian == 2) {
    unsigned int v6 = v7;
  }
  if (v6 != 20) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v8 = *((_DWORD *)v5 + 3);
  unsigned int v9 = bswap32(v8);
  if (mach_endian == 2) {
    uint64_t result = v9;
  }
  else {
    uint64_t result = v8;
  }
  if (result <= a3 && HIWORD(a3) <= WORD1(result)) {
    return 0;
  }
  return result;
}

uint64_t PRGH_GetElementIndex(char *a1, int a2, int a3, unsigned int *a4)
{
  unsigned int v4 = 0;
  *a4 = -1;
  unsigned int v5 = (unsigned int *)a1;
  while (1)
  {
    unsigned int v6 = *v5;
    unsigned int v7 = bswap32(*v5);
    if (mach_endian == 2) {
      unsigned int v6 = v7;
    }
    if (v6 == a2)
    {
      unsigned int v8 = v5[2];
      unsigned int v9 = bswap32(v8);
      if (mach_endian == 2) {
        unsigned int v8 = v9;
      }
      if (v8 == a3) {
        break;
      }
    }
    unsigned int v10 = v5[1];
    if (v10)
    {
      unsigned int v11 = bswap32(v10);
      if (mach_endian == 2) {
        unsigned int v10 = v11;
      }
      v4 += v10;
      unsigned int v5 = (unsigned int *)&a1[v4];
      if (v6 != 2) {
        continue;
      }
    }
    return 0;
  }
  *a4 = v4;
  return 1;
}

BOOL PRGH_GetNextElementIndex(char *a1, unsigned int *a2)
{
  uint64_t v2 = (int)*a2;
  *a2 = -1;
  unsigned int v3 = *(_DWORD *)&a1[v2];
  unsigned int v4 = bswap32(v3);
  if (mach_endian == 2) {
    unsigned int v3 = v4;
  }
  if (v3 != 2)
  {
    unsigned int v5 = *(_DWORD *)&a1[v2 + 4];
    unsigned int v6 = bswap32(v5);
    if (mach_endian == 2) {
      unsigned int v5 = v6;
    }
    *a2 = v5 + v2;
  }
  return v3 != 2;
}

uint64_t PRGH_WriteElement(IFWD_MemoryStream *a1, unsigned int a2, unsigned int a3, char *a4, unsigned int a5, const void *a6)
{
  unsigned int v11 = a5 + 12;
  uint64_t v12 = *((int *)a1 + 2);
  unsigned int v13 = v12 + a5 + 12;
  IFWD_MemoryStream::SetSize(a1, v13);
  size_t v16 = (unsigned char *)(*((void *)a1 + 2) + v12);
  int v17 = mach_endian;
  if (mach_endian == 2)
  {
    CalledByWrite = 1;
    PRGH_SwapElementEndian((int8x16_t *)(a4 - 12), a2, (uint64_t)a6, v14, v15);
    CalledByWrite = 0;
    int v17 = mach_endian;
  }
  int v18 = 0;
  size_t v19 = a5;
  unsigned int v20 = bswap32(v13);
  if (v17 != 2) {
    unsigned int v20 = v13;
  }
  unsigned int v21 = 0;
  switch(a2)
  {
    case 0xCu:
      *((_DWORD *)a4 + 5) = 0;
      unint64_t v23 = a4 + 16;
      uint64_t v22 = a4 + 24;
      goto LABEL_9;
    case 0x10u:
      unsigned int v40 = *(_DWORD *)a4;
      unsigned int v41 = bswap32(*(_DWORD *)a4);
      if (v17 == 2) {
        unsigned int v40 = v41;
      }
      unsigned int v25 = 144 * v40;
      *((_DWORD *)a4 + 1) = 0;
      *((_DWORD *)a4 + 2) = v20;
      int v18 = 1;
      goto LABEL_13;
    case 0x12u:
    case 0x13u:
      *((_DWORD *)a4 + 3) = 0;
      unint64_t v23 = a4 + 8;
      uint64_t v22 = a4 + 16;
      goto LABEL_9;
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
      *((_DWORD *)a4 + 1) = 0;
      uint64_t v22 = a4 + 8;
      unint64_t v23 = a4;
LABEL_9:
      unsigned int v21 = *(_DWORD *)v23;
      *(_DWORD *)uint64_t v22 = v20;
      int v18 = 1;
      break;
    default:
      break;
  }
  unsigned int v24 = bswap32(v21);
  if (v17 == 2) {
    unsigned int v25 = v24;
  }
  else {
    unsigned int v25 = v21;
  }
LABEL_13:
  unsigned int v26 = a2 >> 8;
  unsigned int v27 = HIBYTE(a2);
  BOOL v28 = v17 == 2;
  if (v17 == 2) {
    char v29 = a2;
  }
  else {
    char v29 = HIBYTE(a2);
  }
  if (v28) {
    char v30 = BYTE2(a2);
  }
  else {
    char v30 = BYTE1(a2);
  }
  if (!v28) {
    LOBYTE(v27) = a2;
  }
  *size_t v16 = v27;
  v16[1] = v30;
  if (!v28) {
    LOBYTE(v26) = BYTE2(a2);
  }
  void v16[2] = v26;
  v16[3] = v29;
  if (v18)
  {
    char v31 = v25 + v11;
    unsigned int v32 = (v25 + v11) >> 8;
    if (mach_endian == 2) {
      char v33 = (v25 + v11) >> 24;
    }
    else {
      char v33 = v25 + v11;
    }
    if (mach_endian == 2) {
      char v34 = (v25 + v11) >> 16;
    }
    else {
      char v34 = (unsigned __int16)(v25 + v11) >> 8;
    }
    if (mach_endian != 2)
    {
      LOBYTE(v32) = (v25 + v11) >> 16;
      char v31 = (v25 + v11) >> 24;
    }
  }
  else
  {
    unsigned int v32 = v11 >> 8;
    if (mach_endian == 2) {
      char v33 = HIBYTE(v11);
    }
    else {
      char v33 = v11;
    }
    if (mach_endian == 2) {
      char v34 = BYTE2(v11);
    }
    else {
      char v34 = BYTE1(v11);
    }
    if (mach_endian == 2)
    {
      char v31 = v11;
    }
    else
    {
      LOBYTE(v32) = BYTE2(v11);
      char v31 = HIBYTE(v11);
    }
  }
  void v16[4] = v33;
  v16[5] = v34;
  v16[6] = v32;
  v16[7] = v31;
  unsigned int v35 = a3 >> 8;
  if (mach_endian == 2) {
    char v36 = a3;
  }
  else {
    char v36 = HIBYTE(a3);
  }
  if (mach_endian == 2) {
    char v37 = BYTE1(a3);
  }
  else {
    char v37 = BYTE2(a3);
  }
  if (mach_endian == 2)
  {
    LOBYTE(v35) = BYTE2(a3);
    char v38 = HIBYTE(a3);
  }
  else
  {
    char v38 = a3;
  }
  v16[8] = v38;
  v16[9] = v35;
  v16[10] = v37;
  v16[11] = v36;
  memcpy(v16 + 12, a4, v19);
  if (v18)
  {
    IFWD_MemoryStream::SetSize(a1, *((_DWORD *)a1 + 2) + v25);
    memcpy((void *)(*((void *)a1 + 2) + v12 + (int)v11), a6, v25);
  }
  return 0;
}

uint64_t PRGH_SwapElementEndian(int8x16_t *a1, int a2, uint64_t a3, uint8x8_t a4, uint8x8_t a5)
{
  switch(a2)
  {
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 26:
    case 27:
    case 28:
    case 30:
      for (uint64_t i = 0; i != 5; ++i)
      {
        a4.i32[0] = a1->i32[i];
        int16x8_t v6 = (int16x8_t)vmovl_u8(a4);
        *(int16x4_t *)v6.i8 = vrev64_s16(*(int16x4_t *)v6.i8);
        a4 = (uint8x8_t)vmovn_s16(v6);
        a1->i32[i] = a4.i32[0];
      }
      return 0;
    case 11:
      swap_MemoryMapElementStructType_endian((uint64_t)a1, a4);
      return 0;
    case 12:
      swap_DownloadDataElementStructType_endian((uint64_t)a1, a4);
      return 0;
    case 13:
      swap_HardwareElementStructType_endian((uint64_t)a1, a4);
      return 0;
    case 14:
      for (uint64_t j = 0; j != 287; ++j)
      {
        a4.i32[0] = a1->i32[j];
        int16x8_t v11 = (int16x8_t)vmovl_u8(a4);
        *(int16x4_t *)v11.i8 = vrev64_s16(*(int16x4_t *)v11.i8);
        a4 = (uint8x8_t)vmovn_s16(v11);
        a1->i32[j] = a4.i32[0];
      }
      return 0;
    case 15:
      swap_SecurityElementStructType_endian(a1, a4);
      return 0;
    case 16:
      swap_TocElementStructType_endian((uint64_t)a1, a3, a4, a5);
      return 0;
    case 17:
      for (uint64_t k = 0; k != 7; ++k)
      {
        a4.i32[0] = a1->i32[k];
        int16x8_t v13 = (int16x8_t)vmovl_u8(a4);
        *(int16x4_t *)v13.i8 = vrev64_s16(*(int16x4_t *)v13.i8);
        a4 = (uint8x8_t)vmovn_s16(v13);
        a1->i32[k] = a4.i32[0];
      }
      return 0;
    case 18:
    case 19:
      swap_InjectionElementStructType_endian((uint64_t)a1, a4);
      return 0;
    case 20:
    case 21:
    case 22:
      swap_VersionDataElementStructType_endian((uint64_t)a1, a4);
      return 0;
    case 23:
    case 24:
    case 25:
      swap_StorageDataElementStructType_endian((uint64_t)a1, a4);
      return 0;
    case 29:
      swap_IndirectDownloadDataElementStructType_endian((uint64_t)a1, a4);
      return 0;
    default:
      if (a2 != 1000) {
        return 1;
      }
      for (uint64_t m = 0; m != 10; ++m)
      {
        a4.i32[0] = a1->i32[m];
        int16x8_t v9 = (int16x8_t)vmovl_u8(a4);
        *(int16x4_t *)v9.i8 = vrev64_s16(*(int16x4_t *)v9.i8);
        a4 = (uint8x8_t)vmovn_s16(v9);
        a1->i32[m] = a4.i32[0];
      }
      return 0;
  }
}

uint64_t swap_VersionDataElementStructType_endian(uint64_t a1, uint8x8_t a2)
{
  for (uint64_t i = 0; i != 12; i += 4)
  {
    a2.i32[0] = *(_DWORD *)(a1 + i);
    int16x8_t v3 = (int16x8_t)vmovl_u8(a2);
    *(int16x4_t *)v3.i8 = vrev64_s16(*(int16x4_t *)v3.i8);
    a2 = (uint8x8_t)vmovn_s16(v3);
    *(_DWORD *)(a1 + i) = a2.i32[0];
  }
  a2.i32[0] = *(_DWORD *)(a1 + 12);
  int16x8_t v4 = (int16x8_t)vmovl_u8(a2);
  *(int16x4_t *)v4.i8 = vrev64_s16(*(int16x4_t *)v4.i8);
  *(int8x8_t *)v4.i8 = vmovn_s16(v4);
  *(_DWORD *)(a1 + 12) = v4.i32[0];
  v4.i32[0] = *(_DWORD *)(a1 + 20);
  int16x8_t v5 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v4.i8);
  *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
  *(_DWORD *)(a1 + 20) = vmovn_s16(v5).u32[0];
  return 1;
}

uint64_t swap_StorageDataElementStructType_endian(uint64_t a1, uint8x8_t a2)
{
  for (uint64_t i = 0; i != 12; i += 4)
  {
    a2.i32[0] = *(_DWORD *)(a1 + i);
    int16x8_t v3 = (int16x8_t)vmovl_u8(a2);
    *(int16x4_t *)v3.i8 = vrev64_s16(*(int16x4_t *)v3.i8);
    a2 = (uint8x8_t)vmovn_s16(v3);
    *(_DWORD *)(a1 + i) = a2.i32[0];
  }
  a2.i32[0] = *(_DWORD *)(a1 + 12);
  int16x8_t v4 = (int16x8_t)vmovl_u8(a2);
  *(int16x4_t *)v4.i8 = vrev64_s16(*(int16x4_t *)v4.i8);
  *(int8x8_t *)v4.i8 = vmovn_s16(v4);
  *(_DWORD *)(a1 + 12) = v4.i32[0];
  v4.i32[0] = *(_DWORD *)(a1 + 20);
  int16x8_t v5 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v4.i8);
  *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
  *(_DWORD *)(a1 + 20) = vmovn_s16(v5).u32[0];
  return 1;
}

uint64_t swap_InjectionElementStructType_endian(uint64_t a1, uint8x8_t a2)
{
  for (uint64_t i = 0; i != 12; i += 4)
  {
    a2.i32[0] = *(_DWORD *)(a1 + i);
    int16x8_t v3 = (int16x8_t)vmovl_u8(a2);
    *(int16x4_t *)v3.i8 = vrev64_s16(*(int16x4_t *)v3.i8);
    a2 = (uint8x8_t)vmovn_s16(v3);
    *(_DWORD *)(a1 + i) = a2.i32[0];
  }
  unsigned int v4 = *(_DWORD *)(a1 + 12);
  if (CalledByWrite)
  {
    *(_DWORD *)(a1 + 12) = v4 << 16;
    int v5 = *(_DWORD *)(a1 + 16) << 24;
  }
  else
  {
    *(_DWORD *)(a1 + 12) = HIWORD(v4);
    int v5 = *(unsigned __int8 *)(a1 + 19);
  }
  *(_DWORD *)(a1 + 16) = v5;
  a2.i32[0] = *(_DWORD *)(a1 + 20);
  int16x8_t v6 = (int16x8_t)vmovl_u8(a2);
  *(int16x4_t *)v6.i8 = vrev64_s16(*(int16x4_t *)v6.i8);
  *(int8x8_t *)v6.i8 = vmovn_s16(v6);
  *(_DWORD *)(a1 + 20) = v6.i32[0];
  v6.i32[0] = *(_DWORD *)(a1 + 28);
  int16x8_t v7 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v6.i8);
  *(int16x4_t *)v7.i8 = vrev64_s16(*(int16x4_t *)v7.i8);
  *(_DWORD *)(a1 + 28) = vmovn_s16(v7).u32[0];
  return 1;
}

uint64_t swap_DownloadDataElementStructType_endian(uint64_t a1, uint8x8_t a2)
{
  for (uint64_t i = 0; i != 12; i += 4)
  {
    a2.i32[0] = *(_DWORD *)(a1 + i);
    int16x8_t v3 = (int16x8_t)vmovl_u8(a2);
    *(int16x4_t *)v3.i8 = vrev64_s16(*(int16x4_t *)v3.i8);
    a2 = (uint8x8_t)vmovn_s16(v3);
    *(_DWORD *)(a1 + i) = a2.i32[0];
  }
  uint8x8_t v4 = (uint8x8_t)vrev32_s8(*(int8x8_t *)(a1 + 12));
  *(uint8x8_t *)(a1 + 12) = v4;
  v4.i32[0] = *(_DWORD *)(a1 + 20);
  int16x8_t v5 = (int16x8_t)vmovl_u8(v4);
  *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
  uint8x8_t v6 = (uint8x8_t)vmovn_s16(v5);
  *(_DWORD *)(a1 + 20) = v6.i32[0];
  if (CalledByWrite) {
    int v7 = *(_DWORD *)(a1 + 24) << 16;
  }
  else {
    int v7 = (unint64_t)*(unsigned int *)(a1 + 24) >> 16;
  }
  *(_DWORD *)(a1 + 24) = v7;
  v6.i32[0] = *(_DWORD *)(a1 + 28);
  int16x8_t v8 = (int16x8_t)vmovl_u8(v6);
  *(int16x4_t *)v8.i8 = vrev64_s16(*(int16x4_t *)v8.i8);
  *(int8x8_t *)v8.i8 = vmovn_s16(v8);
  *(_DWORD *)(a1 + 28) = v8.i32[0];
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  int16x8_t v9 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v8.i8);
  *(int16x4_t *)v9.i8 = vrev64_s16(*(int16x4_t *)v9.i8);
  *(_DWORD *)(a1 + 36) = vmovn_s16(v9).u32[0];
  return 1;
}

uint64_t swap_IndirectDownloadDataElementStructType_endian(uint64_t a1, uint8x8_t a2)
{
  for (uint64_t i = 0; i != 12; i += 4)
  {
    a2.i32[0] = *(_DWORD *)(a1 + i);
    int16x8_t v3 = (int16x8_t)vmovl_u8(a2);
    *(int16x4_t *)v3.i8 = vrev64_s16(*(int16x4_t *)v3.i8);
    a2 = (uint8x8_t)vmovn_s16(v3);
    *(_DWORD *)(a1 + i) = a2.i32[0];
  }
  uint8x8_t v4 = (uint8x8_t)vrev32_s8(*(int8x8_t *)(a1 + 12));
  *(uint8x8_t *)(a1 + 12) = v4;
  v4.i32[0] = *(_DWORD *)(a1 + 20);
  int16x8_t v5 = (int16x8_t)vmovl_u8(v4);
  *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
  *(int8x8_t *)v5.i8 = vmovn_s16(v5);
  *(_DWORD *)(a1 + 20) = v5.i32[0];
  *(_DWORD *)(a1 + 24) <<= 16;
  v5.i32[0] = *(_DWORD *)(a1 + 28);
  int16x8_t v6 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v5.i8);
  *(int16x4_t *)v6.i8 = vrev64_s16(*(int16x4_t *)v6.i8);
  *(int8x8_t *)v6.i8 = vmovn_s16(v6);
  *(_DWORD *)(a1 + 28) = v6.i32[0];
  v6.i32[0] = *(_DWORD *)(a1 + 36);
  int16x8_t v7 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v6.i8);
  *(int16x4_t *)v7.i8 = vrev64_s16(*(int16x4_t *)v7.i8);
  *(_DWORD *)(a1 + 36) = vmovn_s16(v7).u32[0];
  return 1;
}

uint64_t swap_HardwareElementStructType_endian(uint64_t a1, uint8x8_t a2)
{
  for (uint64_t i = 0; i != 12; i += 4)
  {
    a2.i32[0] = *(_DWORD *)(a1 + i);
    int16x8_t v3 = (int16x8_t)vmovl_u8(a2);
    *(int16x4_t *)v3.i8 = vrev64_s16(*(int16x4_t *)v3.i8);
    a2 = (uint8x8_t)vmovn_s16(v3);
    *(_DWORD *)(a1 + i) = a2.i32[0];
  }
  *(int8x16_t *)(a1 + 12) = vrev32q_s8(*(int8x16_t *)(a1 + 12));
  *(int8x8_t *)(a1 + 28) = vrev32_s8(*(int8x8_t *)(a1 + 28));
  unsigned int v4 = *(_DWORD *)(a1 + 12);
  BOOL v5 = v4 > 8;
  int v6 = (1 << v4) & 0x193;
  if (!v5 && v6 != 0)
  {
    for (uint64_t j = 0; j != 64; j += 32)
    {
      int16x8_t v9 = (char *)(a1 + 36 + j);
      int8x16x2_t v13 = vld2q_s8(v9);
      int8x16_t v10 = v13.val[0];
      vst2q_s8(v9, *(int8x16x2_t *)((char *)&v13 + 16));
    }
  }
  int16x8_t v11 = (char *)(a1 + 36);
  int8x16x4_t v14 = vld4q_s8(v11);
  v15.val[0] = v14.val[3];
  v15.val[1] = v14.val[2];
  v15.val[2] = v14.val[1];
  v15.val[3] = v14.val[0];
  vst4q_s8(v11, v15);
  return 1;
}

uint64_t swap_SecurityElementStructType_endian(int8x16_t *a1, uint8x8_t a2)
{
  for (uint64_t i = 0; i != 3; ++i)
  {
    a2.i32[0] = a1->i32[i];
    int16x8_t v3 = (int16x8_t)vmovl_u8(a2);
    *(int16x4_t *)v3.i8 = vrev64_s16(*(int16x4_t *)v3.i8);
    a2 = (uint8x8_t)vmovn_s16(v3);
    a1->i32[i] = a2.i32[0];
  }
  uint64_t v4 = 0;
  a2.i32[0] = a1[32].i32[3];
  int16x8_t v5 = (int16x8_t)vmovl_u8(a2);
  *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
  a1[32].i32[3] = vmovn_s16(v5).u32[0];
  int16x8_t v6 = (int16x8_t)vrev32q_s8(a1[46]);
  a1[46] = (int8x16_t)v6;
  int16x8_t v7 = a1 + 47;
  do
  {
    v6.i32[0] = v7->i32[v4];
    int16x8_t v6 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v6.i8);
    *(int16x4_t *)v6.i8 = vrev64_s16(*(int16x4_t *)v6.i8);
    *(int8x8_t *)v6.i8 = vmovn_s16(v6);
    v7->i32[v4++] = v6.i32[0];
  }
  while (v4 != 5);
  uint64_t v8 = 0;
  int16x8_t v9 = &a1[48].i8[4];
  do
  {
    v6.i32[0] = *(_DWORD *)&v9[v8];
    int16x8_t v6 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v6.i8);
    *(int16x4_t *)v6.i8 = vrev64_s16(*(int16x4_t *)v6.i8);
    *(int8x8_t *)v6.i8 = vmovn_s16(v6);
    *(_DWORD *)&v9[v8] = v6.i32[0];
    v8 += 4;
  }
  while (v8 != 20);
  for (uint64_t j = 0; j != 64; j += 4)
  {
    int16x8_t v11 = &a1[j + 49].i8[8];
    int8x16x4_t v21 = vld4q_s8(v11);
    v23.val[0] = v21.val[3];
    v23.val[1] = v21.val[2];
    v23.val[2] = v21.val[1];
    v23.val[3] = v21.val[0];
    vst4q_s8(v11, v23);
  }
  uint64_t v12 = 0;
  int8x16x2_t v13 = &a1[113].i8[8];
  do
  {
    int v14 = *(_DWORD *)&v13[v12];
    int16x8_t v15 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v21.val[0].i8);
    *(int16x4_t *)v15.i8 = vrev64_s16(*(int16x4_t *)v15.i8);
    *(int8x8_t *)v21.val[0].i8 = vmovn_s16(v15);
    *(_DWORD *)&v13[v12] = v15.i32[0];
    v12 += 4;
  }
  while (v12 != 112);
  uint64_t v16 = 0;
  __int32 v17 = a1[120].i32[2];
  int16x8_t v18 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v21.val[0].i8);
  *(int16x4_t *)v18.i8 = vrev64_s16(*(int16x4_t *)v18.i8);
  a1[120].i32[2] = vmovn_s16(v18).u32[0];
  do
  {
    size_t v19 = &a1[v16 + 120].i8[12];
    int8x16x4_t v22 = vld4q_s8(v19);
    v24.val[0] = v22.val[3];
    v24.val[1] = v22.val[2];
    v24.val[2] = v22.val[1];
    v24.val[3] = v22.val[0];
    vst4q_s8(v19, v24);
    v16 += 4;
  }
  while (v16 != 8);
  return 1;
}

uint64_t swap_MemoryMapElementStructType_endian(uint64_t a1, uint8x8_t a2)
{
  for (uint64_t i = 0; i != 12; i += 4)
  {
    a2.i32[0] = *(_DWORD *)(a1 + i);
    int16x8_t v3 = (int16x8_t)vmovl_u8(a2);
    *(int16x4_t *)v3.i8 = vrev64_s16(*(int16x4_t *)v3.i8);
    a2 = (uint8x8_t)vmovn_s16(v3);
    *(_DWORD *)(a1 + i) = a2.i32[0];
  }
  *(int8x16_t *)(a1 + 1612) = vrev32q_s8(*(int8x16_t *)(a1 + 1612));
  uint8x8_t v4 = (uint8x8_t)vrev32_s8(*(int8x8_t *)(a1 + 1628));
  *(uint8x8_t *)(a1 + 1628) = v4;
  v4.i32[0] = *(_DWORD *)(a1 + 1636);
  int16x8_t v5 = (int16x8_t)vmovl_u8(v4);
  *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
  *(_DWORD *)(a1 + 1636) = vmovn_s16(v5).u32[0];
  for (uint64_t j = 12; j != 1612; j += 32)
    *(int8x16_t *)(a1 + j) = vrev32q_s8(*(int8x16_t *)(a1 + j));
  return 1;
}

uint64_t swap_TocElementStructType_endian(uint64_t a1, uint64_t a2, uint8x8_t a3, uint8x8_t a4)
{
  for (uint64_t i = 0; i != 12; i += 4)
  {
    a3.i32[0] = *(_DWORD *)(a1 + i);
    int16x8_t v5 = (int16x8_t)vmovl_u8(a3);
    *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
    a3 = (uint8x8_t)vmovn_s16(v5);
    *(_DWORD *)(a1 + i) = a3.i32[0];
  }
  a3.i32[0] = *(_DWORD *)(a1 + 12);
  int16x8_t v6 = (int16x8_t)vmovl_u8(a3);
  *(int16x4_t *)v6.i8 = vrev64_s16(*(int16x4_t *)v6.i8);
  uint8x8_t v7 = (uint8x8_t)vmovn_s16(v6);
  *(_DWORD *)(a1 + 12) = v7.i32[0];
  unsigned int v8 = bswap32(v7.u32[0]);
  if (mach_endian == 2) {
    unsigned int v9 = v8;
  }
  else {
    unsigned int v9 = v7.i32[0];
  }
  if (CalledByWrite) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = v7.u32[0];
  }
  if (v10)
  {
    int16x8_t v11 = (__int32 *)(a2 + 12);
    do
    {
      uint8x8_t v12 = (uint8x8_t)vrev32_s8(*(int8x8_t *)(v11 - 3));
      *(uint8x8_t *)(v11 - 3) = v12;
      v12.i32[0] = *(v11 - 1);
      a4.i32[0] = *v11;
      int16x8_t v13 = (int16x8_t)vmovl_u8(v12);
      *(int16x4_t *)v13.i8 = vrev64_s16(*(int16x4_t *)v13.i8);
      v7.i32[0] = vmovn_s16(v13).u32[0];
      int16x8_t v14 = (int16x8_t)vmovl_u8(a4);
      *(int16x4_t *)v14.i8 = vrev64_s16(*(int16x4_t *)v14.i8);
      a4 = (uint8x8_t)vmovn_s16(v14);
      v7.i32[1] = a4.i32[0];
      *(uint8x8_t *)(v11 - 1) = v7;
      v11 += 36;
      --v10;
    }
    while (v10);
  }
  v7.i32[0] = *(_DWORD *)(a1 + 20);
  int16x8_t v15 = (int16x8_t)vmovl_u8(v7);
  *(int16x4_t *)v15.i8 = vrev64_s16(*(int16x4_t *)v15.i8);
  *(_DWORD *)(a1 + 20) = vmovn_s16(v15).u32[0];
  return 1;
}

BOOL PRGSequencer::AddToGlobalStruct(PRGSequencer *this, char *a2)
{
  int v2 = *((_DWORD *)this + 812);
  if (v2 <= 199)
  {
    int LongFromLong = PRGH_GetLongFromLong(*(unsigned int *)a2);
    PRGSequencer::AllocateAndCopy(this, a2, LongFromLong);
  }
  return v2 < 200;
}

uint64_t PRGSequencer::AllocateAndCopy(PRGSequencer *this, char *a2, int a3)
{
  uint64_t v3 = *((int *)this + 812);
  if ((int)v3 > 199) {
    return 0;
  }
  switch(a3)
  {
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 26:
    case 27:
    case 28:
    case 30:
      unsigned int v8 = 20;
      size_t v9 = 20;
      goto LABEL_15;
    case 11:
      unsigned int v8 = 1640;
      size_t v9 = 1640;
      goto LABEL_15;
    case 12:
    case 29:
      unsigned int v8 = 40;
      size_t v9 = 40;
      goto LABEL_15;
    case 13:
      unsigned int v8 = 184;
      size_t v9 = 184;
      goto LABEL_15;
    case 14:
      unsigned int v8 = 1148;
      size_t v9 = 1148;
      goto LABEL_15;
    case 15:
      unsigned int v8 = 2060;
      size_t v9 = 2060;
      goto LABEL_15;
    case 16:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      unsigned int v8 = 24;
      size_t v9 = 24;
      goto LABEL_15;
    case 17:
      unsigned int v8 = 28;
      size_t v9 = 28;
      goto LABEL_15;
    case 18:
    case 19:
      unsigned int v8 = 32;
      size_t v9 = 32;
LABEL_15:
      uint64_t v10 = (PRGSequencer *)malloc(v9);
      int16x8_t v11 = v10;
      break;
    default:
      if (a3 != 1000) {
        return 0;
      }
      unsigned int v8 = 40;
      uint64_t v10 = (PRGSequencer *)malloc(0x28uLL);
      int16x8_t v11 = v10;
      break;
  }
  *((void *)this + v3 + 6) = v11;
  if (a2)
  {
    memcpy(v11, a2, v8);
    unsigned int v12 = PRGSequencer::TamperDataAfterRead(this, a3, a2);
    if (*((_DWORD *)this + 814) == 2)
    {
      if ((v12 & 0x80000000) != 0 || *((_DWORD *)this + 813) <= (signed int)v12) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = *((void *)this + v12 + 206);
      }
      PRGH_SwapElementEndian(*((int8x16_t **)this + *((int *)this + 812) + 6), a3, v15, v13, v14);
    }
  }
  else
  {
    PRGSequencer::InitializeElement(v10, (char *)v11, a3, v8);
    *int16x8_t v11 = a3;
    v11[1] = v8;
  }
  uint64_t v16 = (void (*)(void))*((void *)this + 2);
  int v17 = *((_DWORD *)this + 812);
  if (v16)
  {
    v16(*((void *)this + v17 + 6));
    int v17 = *((_DWORD *)this + 812);
  }
  *((_DWORD *)this + 812) = v17 + 1;
  return 1;
}

uint64_t PRGSequencer::TamperDataAfterRead(PRGSequencer *this, int a2, char *a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  switch(a2)
  {
    case 12:
      uint64_t v3 = *((unsigned int *)this + 813);
      if ((int)v3 > 199)
      {
        uint64_t v3 = 0xFFFFFFFFLL;
      }
      else
      {
        *((void *)this + (int)v3 + 206) = a3 + 40;
        *((_DWORD *)this + 813) = v3 + 1;
      }
      *(_DWORD *)(*((void *)this + *((int *)this + 812) + 6) + 32) = v3;
      break;
    case 16:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      uint64_t v3 = *((unsigned int *)this + 813);
      if ((int)v3 > 199)
      {
        uint64_t v3 = 0xFFFFFFFFLL;
      }
      else
      {
        *((void *)this + (int)v3 + 206) = a3 + 24;
        *((_DWORD *)this + 813) = v3 + 1;
      }
      *(_DWORD *)(*((void *)this + *((int *)this + 812) + 6) + 16) = v3;
      break;
    case 18:
    case 19:
      uint64_t v3 = *((unsigned int *)this + 813);
      if ((int)v3 > 199)
      {
        uint64_t v3 = 0xFFFFFFFFLL;
      }
      else
      {
        *((void *)this + (int)v3 + 206) = a3 + 32;
        *((_DWORD *)this + 813) = v3 + 1;
      }
      *(_DWORD *)(*((void *)this + *((int *)this + 812) + 6) + 24) = v3;
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t PRGSequencer::GetElementData(PRGSequencer *this, unsigned int a2)
{
  if (*((_DWORD *)this + 813) <= (signed int)a2) {
    return 0;
  }
  else {
    return *((void *)this + a2 + 206);
  }
}

void PRGSequencer::InitializeElement(PRGSequencer *this, char *a2, int a3, int a4)
{
  bzero(a2, a4);
  int32x2_t v6 = (int32x2_t)0x2000200020002;
  switch(a3)
  {
    case 3:
      goto LABEL_6;
    case 4:
    case 5:
      int32x2_t v6 = vdup_n_s32(0x20003u);
      goto LABEL_6;
    case 6:
    case 7:
    case 8:
    case 26:
    case 27:
    case 28:
    case 30:
      int32x2_t v6 = (int32x2_t)0x20000;
      goto LABEL_6;
    case 9:
      int32x2_t v6 = (int32x2_t)0x40000;
      goto LABEL_6;
    case 10:
      int32x2_t v6 = (int32x2_t)0x10000;
LABEL_6:
      *(int32x2_t *)(a2 + 12) = v6;
      break;
    case 11:
      for (uint64_t i = 12; i != 1612; i += 32)
        *(_DWORD *)&a2[i] = -1;
      break;
    default:
      return;
  }
}

uint64_t PRGSequencer::RegisterElementData(PRGSequencer *this, const void *a2)
{
  uint64_t result = *((unsigned int *)this + 813);
  if ((int)result > 199) {
    return 0xFFFFFFFFLL;
  }
  *((void *)this + (int)result + 206) = a2;
  *((_DWORD *)this + 813) = result + 1;
  return result;
}

_DWORD *PRGSequencer::FindElementStructure(PRGSequencer *this, int a2, int a3)
{
  int v3 = *((_DWORD *)this + 812);
  BOOL v4 = __OFSUB__(v3, 1);
  int v5 = v3 - 1;
  if (v5 < 0 != v4) {
    return 0;
  }
  if (v5 >= 0xC7) {
    int v5 = 199;
  }
  uint64_t v6 = (v5 + 1);
  for (uint64_t i = (_DWORD **)((char *)this + 48); ; ++i)
  {
    uint64_t result = *i;
    if (*i)
    {
      if (*result == a2 && result[2] == a3) {
        break;
      }
    }
    if (!--v6) {
      return 0;
    }
  }
  return result;
}

uint64_t PRGSequencer::WriteElementToFile(PRGSequencer *this, IFWD_MemoryStream *a2, unsigned int a3, unsigned int a4, char *a5)
{
  int v5 = 0;
  unsigned int v6 = 28;
  switch(a3)
  {
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 9u:
    case 0xAu:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Eu:
      int v5 = 0;
      unsigned int v6 = 8;
      goto LABEL_22;
    case 0xBu:
      int v5 = 0;
      unsigned int v6 = 1628;
      goto LABEL_22;
    case 0xCu:
      uint64_t v10 = *((unsigned int *)a5 + 8);
      if (*((_DWORD *)this + 813) <= (int)v10) {
        int v5 = 0;
      }
      else {
        int v5 = (const void *)*((void *)this + v10 + 206);
      }
      unsigned int v6 = 28;
      goto LABEL_22;
    case 0xDu:
      int v5 = 0;
      unsigned int v6 = 172;
      goto LABEL_22;
    case 0xEu:
      int v5 = 0;
      unsigned int v6 = 1136;
      goto LABEL_22;
    case 0xFu:
      int v5 = 0;
      unsigned int v6 = 2048;
      goto LABEL_22;
    case 0x10u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
      uint64_t v7 = *((unsigned int *)a5 + 4);
      if (*((_DWORD *)this + 813) <= (int)v7) {
        int v5 = 0;
      }
      else {
        int v5 = (const void *)*((void *)this + v7 + 206);
      }
      unsigned int v6 = 12;
      goto LABEL_22;
    case 0x11u:
      int v5 = 0;
      unsigned int v6 = 16;
      goto LABEL_22;
    case 0x12u:
    case 0x13u:
      uint64_t v9 = *((unsigned int *)a5 + 6);
      if (*((_DWORD *)this + 813) <= (int)v9) {
        int v5 = 0;
      }
      else {
        int v5 = (const void *)*((void *)this + v9 + 206);
      }
      unsigned int v6 = 32;
      goto LABEL_22;
    case 0x1Du:
      goto LABEL_22;
    default:
      if (a3 != 1000) {
        return 0;
      }
LABEL_22:
      PRGH_WriteElement(a2, a3, a4, a5 + 12, v6, v5);
      return 1;
  }
}

void PRGSequencer::PRGSequencer(PRGSequencer *this)
{
  int v2 = (IFWD_MemoryStream *)operator new(0x18uLL);
  IFWD_MemoryStream::IFWD_MemoryStream(v2);
  *(void *)this = v3;
  *(void *)((char *)this + 3260) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 10) = 0;
  bzero((char *)this + 48, 0xC88uLL);
}

void PRGSequencer::~PRGSequencer(IFWD_MemoryStream **this)
{
  PRGSequencer::CleanUp(this);
  if (*this)
  {
    IFWD_MemoryStream::~IFWD_MemoryStream(*this);
    operator delete(v2);
    *this = 0;
  }
}

void PRGSequencer::CleanUp(IFWD_MemoryStream **this)
{
  IFWD_MemoryStream::Clear(*this);
  int v2 = *((_DWORD *)this + 812);
  if (v2 >= 1)
  {
    uint64_t v3 = 0;
    BOOL v4 = (char *)(this + 6);
    do
    {
      int v5 = *(void **)&v4[8 * v3];
      if (v5)
      {
        free(v5);
        int v2 = *((_DWORD *)this + 812);
      }
      *(void *)&v4[8 * v3++] = 0;
    }
    while (v3 < v2);
  }
  *((_DWORD *)this + 812) = 0;
  this[3] = 0;
  this[4] = 0;
  *((_DWORD *)this + 10) = 0;
}

uint64_t PRGSequencer::ReadBuffer(PRGSequencer *this, const char *a2, unsigned int a3, int a4, unsigned int a5, void (*a6)(void *))
{
  IFWD_MemoryStream::Clear(*(IFWD_MemoryStream **)this);
  unsigned int v12 = operator new[](a3 + 1);
  uint8x8_t v13 = *(IFWD_MemoryStream **)this;
  *(void *)uint8x8_t v13 = v12;
  *((void *)v13 + 2) = v12;
  memcpy(v12, a2, a3);
  *((_DWORD *)v13 + 2) = a3;
  *((_DWORD *)this + 814) = PRGH_GetEndian((char *)v12);
  int v14 = PRGH_FileCheck(*(char **)(*(void *)this + 16));
  if (v14 == -1) {
    return 0xFFFFFFFFLL;
  }
  *((_DWORD *)this + 815) = a4;
  *((_DWORD *)this + 817) = v14;
  if (v14 == 5)
  {
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v16 = PRGH_VersionCheck(*(char **)(*(void *)this + 16), a4, a5);
    uint64_t v15 = v16;
    if (v16 && (*((_DWORD *)this + 815) != 5 || HIWORD(a5) <= WORD1(v16) || *((_DWORD *)this + 817) != 1)) {
      return v15;
    }
  }
  unsigned int v21 = 0;
  *((void *)this + 2) = a6;
  int v17 = *(char **)(*(void *)this + 16);
  if (PRGH_GetElementIndex(v17, 1000, 0, &v21))
  {
    int16x8_t v18 = &v17[v21];
    int v19 = *((_DWORD *)v18 + 9);
    *(_OWORD *)((char *)this + 24) = *(_OWORD *)(v18 + 20);
    *((_DWORD *)this + 10) = v19;
    PRGSequencer::AddToGlobalStruct(this, v18);
    while (PRGH_GetNextElementIndex(v17, &v21))
      PRGSequencer::AddToGlobalStruct(this, &v17[v21]);
  }
  return v15;
}

uint64_t PRGSequencer::WriteToBuffer(PRGSequencer *this, char **a2, unsigned int *a3)
{
  unsigned int v6 = (IFWD_MemoryStream *)operator new(0x18uLL);
  IFWD_MemoryStream::IFWD_MemoryStream(v6);
  *((void *)this + 1) = v7;
  IFWD_MemoryStream::Clear(v7);
  int v8 = *((_DWORD *)this + 812);
  if (v8 >= 1)
  {
    for (unint64_t i = 0; (uint64_t)i < v8; ++i)
    {
      uint64_t v10 = (unsigned int *)*((void *)this + i + 6);
      if (v10)
      {
        unsigned int v11 = *v10;
        if ((*v10 & 0xFFFFFFFA) != 0x12 && (v11 > 0x1D || ((1 << v11) & 0x23319000) == 0))
        {
          PRGSequencer::WriteElementToFile(this, *((IFWD_MemoryStream **)this + 1), v11, v10[2], (char *)v10);
          int v8 = *((_DWORD *)this + 812);
        }
      }
      if (i > 0xC6) {
        break;
      }
    }
  }
  if (*((_DWORD *)this + 815) != 5 && v8 >= 1)
  {
    unint64_t v14 = 0;
    do
    {
      uint64_t v15 = (unsigned int *)*((void *)this + v14 + 6);
      if (v15)
      {
        unsigned int v16 = *v15;
        if ((*v15 & 0xFFFFFFFA) == 0x12 || (v16 <= 0x1D ? (BOOL v17 = ((1 << v16) & 0x23319000) == 0) : (BOOL v17 = 1), !v17))
        {
          PRGSequencer::WriteElementToFile(this, *((IFWD_MemoryStream **)this + 1), v16, v15[2], (char *)v15);
          int v8 = *((_DWORD *)this + 812);
        }
      }
      if (v14 > 0xC6) {
        break;
      }
      ++v14;
    }
    while ((uint64_t)v14 < v8);
  }
  PRGH_WriteElement(*((IFWD_MemoryStream **)this + 1), 2u, 0, 0, 0, 0);
  int16x8_t v18 = (char *)malloc(*(int *)(*((void *)this + 1) + 8));
  *a2 = v18;
  uint64_t v19 = *((void *)this + 1);
  if (v18)
  {
    memcpy(v18, *(const void **)(v19 + 16), *(int *)(v19 + 8));
    uint64_t v20 = 0;
    *a3 = *(_DWORD *)(v19 + 8);
LABEL_29:
    IFWD_MemoryStream::~IFWD_MemoryStream((IFWD_MemoryStream *)v19);
    operator delete(v21);
    *((void *)this + 1) = 0;
    return v20;
  }
  uint64_t v20 = 5;
  if (v19) {
    goto LABEL_29;
  }
  return v20;
}

uint64_t PRGSequencer::CreateElement(PRGSequencer *this, int a2)
{
  int v3 = PRGSequencer::AllocateAndCopy(this, 0, a2);
  uint64_t result = 0;
  if (v3) {
    return *((void *)this + *((int *)this + 812) + 5);
  }
  return result;
}

BOOL PRGSequencer::RemoveElement(void **this, void *a2)
{
  unint64_t v2 = *((unsigned int *)this + 812);
  if ((int)v2 < 1) {
    return 0;
  }
  int v3 = this + 6;
  if (this[6] == a2)
  {
    BOOL v8 = 1;
    if (a2) {
LABEL_17:
    }
      free(a2);
  }
  else
  {
    unint64_t v4 = 0;
    unint64_t v5 = (v2 - 1);
    if (v5 >= 0xC7) {
      unint64_t v5 = 199;
    }
    do
    {
      if (v5 == v4) {
        return v4 < 0xC7 && v4 + 1 < v2;
      }
      unsigned int v6 = (void *)v3[1];
      ++v3;
      ++v4;
    }
    while (v6 != a2);
    BOOL v8 = v4 - 1 < 0xC7 && v4 < v2;
    if (a2) {
      goto LABEL_17;
    }
  }
  void *v3 = 0;
  return v8;
}

unint64_t b64_ntop(unsigned __int8 *a1, unint64_t a2, unsigned char *a3, unint64_t a4)
{
  *a3 = 0;
  if (a2 >= 3)
  {
    unint64_t v5 = 0;
    while (1)
    {
      unint64_t result = v5 + 4;
      if (v5 + 4 > a4) {
        goto LABEL_16;
      }
      unint64_t v7 = a1[2];
      unint64_t v8 = a1[1];
      unsigned int v9 = *a1;
      a1 += 3;
      a2 -= 3;
      uint64_t v10 = &a3[v5];
      *uint64_t v10 = aAbcdefghijklmn[(unint64_t)v9 >> 2];
      v10[1] = aAbcdefghijklmn[(v8 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v9 & 3))];
      void v10[2] = aAbcdefghijklmn[(v7 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v8 & 0xF))];
      v10[3] = aAbcdefghijklmn[v7 & 0x3F];
      unint64_t v5 = result;
      if (a2 <= 2)
      {
        if (a2) {
          goto LABEL_8;
        }
        goto LABEL_14;
      }
    }
  }
  unint64_t result = 0;
  if (a2)
  {
LABEL_8:
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    unsigned __int8 v18 = 0;
    __int16 v17 = 0;
    do
    {
      *((unsigned char *)&v17 + v12) = a1[v11++];
      uint64_t v12 = v11;
    }
    while (a2 > v11);
    if (result + 4 > a4) {
      goto LABEL_16;
    }
    char v13 = HIBYTE(v17);
    unint64_t v14 = ((unint64_t)HIBYTE(v17) >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v17 & 3));
    a3[result] = aAbcdefghijklmn[(unint64_t)v17 >> 2];
    unint64_t v15 = v18;
    a3[result | 1] = aAbcdefghijklmn[v14];
    char v16 = 61;
    if (a2 != 1) {
      char v16 = aAbcdefghijklmn[(v15 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v13 & 0xF))];
    }
    a3[result | 2] = v16;
    a3[result | 3] = 61;
    result += 4;
  }
LABEL_14:
  if (result < a4)
  {
    a3[result] = 0;
    return result;
  }
LABEL_16:
  a3[a4 - 1] = 0;
  *a3 = 0;
  return 0xFFFFFFFFLL;
}

unsigned char *b64encode(unsigned __int8 *a1, unsigned int a2)
{
  unint64_t v2 = 0;
  if (a1 && (int)a2 >= 1)
  {
    unsigned int v5 = a2 / 3;
    if (a2 != 3 * (a2 / 3)) {
      ++v5;
    }
    size_t v6 = (4 * v5) | 1;
    unint64_t v2 = malloc(v6);
    if (v2) {
      b64_ntop(a1, a2, v2, v6);
    }
  }
  return v2;
}

uint64_t b64decode(char *__s, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    int64_t v3 = strlen(__s);
  }
  else {
    int64_t v3 = a2;
  }
  unint64_t v4 = __s;
  if (v3 >= 1)
  {
    int v5 = 0;
    uint64_t v6 = 0;
    unint64_t v7 = __s;
    unint64_t v4 = __s;
    do
    {
      uint64_t v8 = *v7;
      if (v8 == 10 || v8 == 13)
      {
        uint64_t v10 = 0;
        int v5 = 0;
      }
      else
      {
        uint64_t v10 = dword_10007DDD8[v8];
        if (v10 == -1)
        {
          uint64_t v10 = v6;
        }
        else
        {
          switch(v5)
          {
            case 0:
              int v5 = 1;
              break;
            case 1:
              *v4++ = (4 * v6) | (v10 >> 4) & 3;
              int v5 = 2;
              break;
            case 2:
              *v4++ = (16 * v6) | (v10 >> 2) & 0xF;
              int v5 = 3;
              break;
            case 3:
              int v5 = 0;
              *v4++ = v10 | ((_BYTE)v6 << 6);
              break;
            default:
              break;
          }
        }
      }
      ++v7;
      uint64_t v6 = v10;
    }
    while (v7 < &__s[v3]);
  }
  char *v4 = 0;
  return (v4 - __s);
}

CFStringRef tss_lookup_error(int a1)
{
  int v1 = off_1000B83A0;
  if (off_1000B83A0)
  {
    if (tss_err_map == a1) {
      return CFStringCreateWithCString(kCFAllocatorDefault, v1, 0x8000100u);
    }
    for (unint64_t i = (const char **)&off_1000B83B0; ; i += 2)
    {
      int v1 = *i;
      if (!*i) {
        break;
      }
      int v3 = *((_DWORD *)i - 2);
      if (v3 == a1) {
        return CFStringCreateWithCString(kCFAllocatorDefault, v1, 0x8000100u);
      }
    }
  }
  return @"Unknown";
}

uint64_t tss_strip_img3_signature(_DWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 10004;
  }
  if (*a1 != 1231906611)
  {
    AMAuthInstallLog(3, (uint64_t)"tss_strip_img3_signature", (uint64_t)"bad magic 0x%08x expecting 0x%08x", a4, a5, a6, a7, a8, *a1);
    return 10004;
  }
  unsigned int v10 = a1[2];
  unsigned int v9 = a1[3];
  if (v9 > v10)
  {
    AMAuthInstallLog(3, (uint64_t)"tss_strip_img3_signature", (uint64_t)"signed length %u too large for buffer length %u", a4, a5, a6, a7, a8, a1[3]);
    return 10004;
  }
  uint64_t result = 0;
  if (v9)
  {
    *a2 += v9 - v10;
    a1[2] = a1[3];
    a1[1] = *a2;
  }
  return result;
}

uint64_t tss_image_is_img3(_DWORD *a1)
{
  uint64_t result = 10004;
  if (a1)
  {
    if (*a1 == 1231906611) {
      return 0;
    }
    else {
      return 10004;
    }
  }
  return result;
}

uint64_t tss_image_is_finalized(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 10004;
  }
  if (*a1 == 1231906611)
  {
    if (a1[3]) {
      return 0;
    }
    else {
      return 10003;
    }
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"tss_image_is_finalized", (uint64_t)"bad magic 0x%08x expecting 0x%08x", a4, a5, a6, a7, a8, *a1);
    return 10004;
  }
}

uint64_t tss_get_partial_hash(_DWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v48 = a2;
  uint64_t v50 = 0;
  memset(v49, 0, sizeof(v49));
  uint64_t v47 = 0;
  int v46 = 0;
  if (a1 && a2 >= 1)
  {
    int v10 = a3;
    uint64_t v16 = tss_strip_img3_signature(a1, &v48, a3, a4, a5, a6, a7, a8);
    if (v16) {
      AMAuthInstallLog(3, (uint64_t)"tss_get_partial_hash", (uint64_t)"failed to strip img3 header", v11, v12, v13, v14, v15, v45);
    }
    uint64_t v17 = (int)a1[2];
    if (((v17 + 8) & 0x3F) != 0)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_get_partial_hash", (uint64_t)"ih_buffer_len(%d) + 8 is not a multiple of %d", v11, v12, v13, v14, v15, a1[2]);
      unsigned __int8 v18 = 0;
      uint64_t v16 = 10004;
    }
    else
    {
      uint64_t v20 = malloc(v17 + 8);
      unsigned __int8 v18 = v20;
      if (v20)
      {
        bzero(v20, v17 + 8);
        a1[3] = v17 + v10;
        memcpy(v18, a1 + 3, v17 + 8);
        int v26 = SHA1Reset((uint64_t)v49);
        if (v26)
        {
          AMAuthInstallLog(3, (uint64_t)"tss_get_partial_hash", (uint64_t)"SHA1Reset failed=%d", v27, v28, v29, v30, v31, v26);
        }
        else
        {
          int v32 = SHA1Input((uint64_t)v49, (char *)v18, (int)v17 + 8);
          if (v32)
          {
            AMAuthInstallLog(3, (uint64_t)"tss_get_partial_hash", (uint64_t)"SHA1Input failed=%d", v33, v34, v35, v36, v37, v32);
          }
          else
          {
            int v38 = SHA1ResultPartial((uint64_t)v49, (uint64_t)&v51, &v47, &v46);
            if (v38)
            {
              AMAuthInstallLog(3, (uint64_t)"tss_get_partial_hash", (uint64_t)"SHA1ResultPartial failed=%d", v39, v40, v41, v42, v43, v38);
            }
            else
            {
              if (!v16)
              {
                *(_DWORD *)a4 = v10;
                *(_DWORD *)(a4 + 4) = v17;
                *(_OWORD *)(a4 + 8) = v51;
                *(_DWORD *)(a4 + 24) = v52;
                goto LABEL_21;
              }
              AMAuthInstallLog(3, (uint64_t)"tss_get_partial_hash", (uint64_t)"tss_sha1_hash failed=%d", v39, v40, v41, v42, v43, v16);
            }
          }
        }
        uint64_t v16 = 10007;
      }
      else
      {
        AMAuthInstallLog(3, (uint64_t)"tss_get_partial_hash", (uint64_t)"out of memory", v21, v22, v23, v24, v25, v45);
        uint64_t v16 = 10006;
      }
    }
LABEL_21:
    uint64_t v19 = v18;
    a1[3] = v17;
    unsigned __int8 v18 = v47;
    goto LABEL_22;
  }
  AMAuthInstallLog(3, (uint64_t)"tss_get_partial_hash", (uint64_t)"invalid img3: (%p), size %d", a4, a5, a6, a7, a8, (char)a1);
  unsigned __int8 v18 = 0;
  uint64_t v16 = 10004;
  if (a1)
  {
    LODWORD(v17) = 0;
    goto LABEL_21;
  }
  uint64_t v19 = 0;
LABEL_22:
  free(v18);
  free(v19);
  return v16;
}

uint64_t tss_get_hash(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v37 = a2;
  if (a1)
  {
    uint64_t v39 = 0;
    memset(v38, 0, sizeof(v38));
    uint64_t v15 = tss_strip_img3_signature((_DWORD *)a1, &v37, a3, a4, a5, a6, a7, a8);
    if (v15) {
      AMAuthInstallLog(3, (uint64_t)"tss_get_hash", (uint64_t)"failed to strip img3 header", v10, v11, v12, v13, v14, v36);
    }
    if (v37 > 11)
    {
      int v16 = *(_DWORD *)(a1 + 8);
      if (v37 >= v16 + 20)
      {
        int v18 = SHA1Reset((uint64_t)v38);
        if (v18)
        {
          AMAuthInstallLog(3, (uint64_t)"tss_get_hash", (uint64_t)"SHA1Reset failed=%d", v19, v20, v21, v22, v23, v18);
        }
        else
        {
          int v24 = SHA1Input((uint64_t)v38, (char *)(a1 + 12), v16 + 8);
          if (v24)
          {
            AMAuthInstallLog(3, (uint64_t)"tss_get_hash", (uint64_t)"SHA1Input failed=%d", v25, v26, v27, v28, v29, v24);
          }
          else
          {
            int v30 = SHA1Result((uint64_t)v38, a3);
            if (!v30) {
              return v15;
            }
            AMAuthInstallLog(3, (uint64_t)"tss_get_hash", (uint64_t)"SHA1Result failed=%d", v31, v32, v33, v34, v35, v30);
          }
        }
        return 10007;
      }
    }
    AMAuthInstallLog(3, (uint64_t)"tss_get_hash", (uint64_t)"invalid image3 length=%d", v10, v11, v12, v13, v14, v37);
  }
  return 10004;
}

uint64_t tss_stitch_img3(_DWORD *a1, int a2, _DWORD *a3, const void *a4, uint64_t a5, void *a6, _DWORD *a7, uint64_t a8)
{
  int v34 = a2;
  if (!a1 || a2 <= 0)
  {
    AMAuthInstallLog(3, (uint64_t)"tss_stitch_img3", (uint64_t)"invalid img3: (%p), size %d", (uint64_t)a4, a5, (uint64_t)a6, (uint64_t)a7, a8, (char)a1);
    return 10004;
  }
  unsigned int v9 = a5;
  if (!a4 || (int)a5 <= 0)
  {
    LOBYTE(v33) = (_BYTE)a4;
    uint64_t v29 = "invalid tatsu data: (%p), size %d";
LABEL_15:
    AMAuthInstallLog(3, (uint64_t)"tss_stitch_img3", (uint64_t)v29, (uint64_t)a4, a5, (uint64_t)a6, (uint64_t)a7, a8, v33);
    return 10004;
  }
  uint64_t v12 = 10008;
  if (a6 && a7)
  {
    uint64_t v12 = tss_strip_img3_signature(a1, &v34, (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)a6, (uint64_t)a7, a8);
    if (v12) {
      AMAuthInstallLog(3, (uint64_t)"tss_stitch_img3", (uint64_t)"failed to strip img3 header", v15, v16, v17, v18, v19, v33);
    }
    size_t v20 = v34;
    size_t v21 = v34 + (uint64_t)(int)v9;
    *a7 = v21;
    uint64_t v22 = malloc(v21);
    *a6 = v22;
    if (!v22)
    {
      *a7 = 0;
      AMAuthInstallLog(3, (uint64_t)"tss_stitch_img3", (uint64_t)"out of memory", v23, v24, v25, v26, v27, v33);
      return 10006;
    }
    uint64_t v28 = v22;
    bzero(v22, v21);
    memcpy(v28, a1, v20);
    if (*a3 >= (signed int)v9)
    {
      LOBYTE(v33) = v9;
      uint64_t v29 = "invalid img3 (tatsublob_len %d <= mastered_reservation_len %d";
    }
    else if (((a3[1] + 8) & 0x3F) != 0)
    {
      int v33 = a3[1] + 8;
      uint64_t v29 = "mastered_signed_len(%d) + 8 is not a multiple of %d";
    }
    else
    {
      unsigned int v31 = a1[2] + v9;
      if (v31 == v21 - 20)
      {
        int v32 = *a3 + a1[3];
        if (v32 <= (int)(v31 + 8))
        {
          v28[1] = a1[1] + v9;
          void v28[2] = v31;
          v28[3] = v32;
          memcpy((char *)v28 + v20, a4, v9);
          return v12;
        }
      }
      uint64_t v29 = "invalid img3";
    }
    goto LABEL_15;
  }
  return v12;
}

FILE *(**amai_fill_fopen_filefunc(FILE *(**result)(int a1, char *__filename, char a3)))(int a1, char *__filename, char a3)
{
  *uint64_t result = sub_100037DC8;
  result[1] = (FILE *(*)(int, char *, char))sub_100037E2C;
  result[2] = (FILE *(*)(int, char *, char))sub_100037E44;
  result[3] = (FILE *(*)(int, char *, char))sub_100037E5C;
  result[4] = (FILE *(*)(int, char *, char))sub_100037E64;
  result[5] = (FILE *(*)(int, char *, char))sub_100037EA0;
  result[6] = (FILE *(*)(int, char *, char))sub_100037EA8;
  result[7] = 0;
  return result;
}

FILE *sub_100037DC8(int a1, char *__filename, char a3)
{
  int v3 = a3 & 3;
  unint64_t v4 = "r+b";
  int v5 = "wb";
  if ((a3 & 8) == 0) {
    int v5 = 0;
  }
  if ((a3 & 4) != 0) {
    LOBYTE(v6) = 1;
  }
  else {
    int v6 = (a3 & 8) >> 3;
  }
  if ((a3 & 4) == 0) {
    unint64_t v4 = v5;
  }
  if (v3 == 1) {
    char v7 = 1;
  }
  else {
    char v7 = v6;
  }
  if (v3 == 1) {
    uint64_t v8 = "rb";
  }
  else {
    uint64_t v8 = v4;
  }
  if (__filename && (v7 & 1) != 0) {
    return fopen(__filename, v8);
  }
  else {
    return 0;
  }
}

size_t sub_100037E2C(int a1, FILE *__stream, void *__ptr, size_t __nitems)
{
  return fread(__ptr, 1uLL, __nitems, __stream);
}

size_t sub_100037E44(int a1, FILE *__stream, void *__ptr, size_t __nitems)
{
  return fwrite(__ptr, 1uLL, __nitems, __stream);
}

uint64_t sub_100037E5C(int a1, FILE *a2)
{
  return ftell(a2);
}

uint64_t sub_100037E64(int a1, FILE *a2, uint64_t a3, unsigned int a4)
{
  if (a4 > 2) {
    return -1;
  }
  fseek(a2, a3, a4);
  return 0;
}

uint64_t sub_100037EA0(int a1, FILE *a2)
{
  return fclose(a2);
}

uint64_t sub_100037EA8(int a1, FILE *a2)
{
  return ferror(a2);
}

void *tss_create_session(const void *a1, const void *a2)
{
  unint64_t v4 = malloc(0x60uLL);
  uint64_t v10 = v4;
  if (!v4) {
    goto LABEL_7;
  }
  v4[4] = 0u;
  v4[5] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  if (!a2)
  {
    uint64_t v13 = "signingServerURL is NULL";
    goto LABEL_10;
  }
  CFTypeID v11 = CFGetTypeID(a2);
  if (v11 != CFURLGetTypeID())
  {
    uint64_t v13 = "signingServerURL is malformed";
    goto LABEL_10;
  }
  v10[1] = CFRetain(a2);
  *((_WORD *)v10 + 10) = 256;
  if (a1) {
    CFRetain(a1);
  }
  *uint64_t v10 = a1;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v10[3] = Mutable;
  if (!Mutable)
  {
LABEL_7:
    uint64_t v13 = "out of memory";
LABEL_10:
    AMAuthInstallLog(3, (uint64_t)"tss_create_session", (uint64_t)v13, v5, v6, v7, v8, v9, v15);
    free(v10);
    return 0;
  }
  return v10;
}

uint64_t tss_close_session(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = tss_reset_session((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v9) {
    free(a1);
  }
  return v9;
}

uint64_t tss_reset_session(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v9 = *(const void **)a1;
    if (v9) {
      CFRelease(v9);
    }
    uint64_t v10 = *(const void **)(a1 + 24);
    if (v10) {
      CFRelease(v10);
    }
    CFTypeID v11 = *(const void **)(a1 + 40);
    if (v11) {
      CFRelease(v11);
    }
    uint64_t v12 = *(const void **)(a1 + 8);
    if (v12) {
      CFRelease(v12);
    }
    uint64_t v13 = *(const void **)(a1 + 72);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(a1 + 72) = 0;
    }
    uint64_t v14 = *(void **)(a1 + 56);
    if (v14) {
      free(v14);
    }
    uint64_t result = 0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"tss_reset_session", (uint64_t)"NULL session", a4, a5, a6, a7, a8, v16);
    return 10009;
  }
  return result;
}

uint64_t SHA1Reset(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_WORD *)(a1 + 28) = 0;
  *(_OWORD *)a1 = xmmword_10007E1E0;
  *(void *)(a1 + 16) = 3285377520;
  *(void *)(a1 + 96) = 0;
  return result;
}

uint64_t SHA1Result(uint64_t a1, uint64_t a2)
{
  return SHA1ResultPartial(a1, a2, 0, 0);
}

uint64_t SHA1ResultPartial(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    BOOL v8 = !a3 || a4 == 0;
    BOOL v9 = !v8;
    uint64_t result = *(unsigned int *)(a1 + 100);
    if (!result)
    {
      if (*(_DWORD *)(a1 + 96)) {
        char v10 = 1;
      }
      else {
        char v10 = v9;
      }
      if (v10)
      {
        if (!v9) {
          return 1;
        }
        size_t v11 = *(__int16 *)(a1 + 28);
        *a4 = v11;
        if ((int)v11 >= 1)
        {
          uint64_t v12 = malloc(v11);
          *a3 = v12;
          memcpy(v12, (const void *)(a1 + 30), (unsigned __int16)v11);
        }
      }
      else
      {
        SHA1PadMessage(a1);
        *(_OWORD *)(a1 + 78) = 0u;
        *(_OWORD *)(a1 + 62) = 0u;
        *(_OWORD *)(a1 + 46) = 0u;
        *(_OWORD *)(a1 + 30) = 0u;
        *(_DWORD *)(a1 + 20) = 0;
        *(_DWORD *)(a1 + 24) = 0;
        *(_DWORD *)(a1 + 96) = 1;
      }
      int v13 = 0;
      for (uint64_t i = 0; i != 20; ++i)
      {
        *(unsigned char *)(a2 + i) = *(_DWORD *)(a1 + (i & 0xFFFFFFFC)) >> (~(_BYTE)v13 & 0x18);
        v13 += 8;
      }
      return 0;
    }
  }
  return result;
}

int *SHA1PadMessage(uint64_t a1)
{
  int v2 = *(__int16 *)(a1 + 28);
  uint64_t v3 = *(unsigned __int16 *)(a1 + 28);
  LOWORD(v4) = v2 + 1;
  ++*(_WORD *)(a1 + 28);
  if (v2 < 56)
  {
    *(unsigned char *)(a1 + (__int16)v3 + 30) = 0x80;
    int v6 = *(__int16 *)(a1 + 28);
    if (v6 <= 55)
    {
      do
      {
        *(_WORD *)(a1 + 28) = v6 + 1;
        *(unsigned char *)(a1 + (__int16)v6 + 30) = 0;
        int v6 = *(__int16 *)(a1 + 28);
      }
      while (v6 < 56);
    }
  }
  else
  {
    *(unsigned char *)(a1 + v3 + 30) = 0x80;
    if ((__int16)v4 <= 63)
    {
      do
      {
        *(_WORD *)(a1 + 28) = v4 + 1;
        *(unsigned char *)(a1 + (__int16)v4 + 30) = 0;
        int v4 = *(__int16 *)(a1 + 28);
      }
      while (v4 < 64);
    }
    SHA1ProcessMessageBlock((int *)a1);
    int v5 = *(__int16 *)(a1 + 28);
    if (v5 <= 55)
    {
      do
      {
        *(_WORD *)(a1 + 28) = v5 + 1;
        *(unsigned char *)(a1 + (__int16)v5 + 30) = 0;
        int v5 = *(__int16 *)(a1 + 28);
      }
      while (v5 < 56);
    }
  }
  unsigned int v7 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 86) = bswap32(*(_DWORD *)(a1 + 24));
  *(_DWORD *)(a1 + 90) = bswap32(v7);
  return SHA1ProcessMessageBlock((int *)a1);
}

uint64_t SHA1Input(uint64_t a1, char *a2, int a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t result = 1;
  if (a1)
  {
    int v5 = a2;
    if (a2)
    {
      if (*(_DWORD *)(a1 + 96))
      {
        uint64_t result = 3;
        *(_DWORD *)(a1 + 100) = 3;
      }
      else
      {
        uint64_t result = *(unsigned int *)(a1 + 100);
        if (!result)
        {
          int v6 = a3;
          while (!*(_DWORD *)(a1 + 100))
          {
            char v7 = *v5;
            uint64_t v8 = *(__int16 *)(a1 + 28);
            *(_WORD *)(a1 + 28) = v8 + 1;
            *(unsigned char *)(a1 + v8 + 30) = v7;
            int v9 = *(_DWORD *)(a1 + 20) + 8;
            *(_DWORD *)(a1 + 20) = v9;
            if (!v9)
            {
              int v10 = *(_DWORD *)(a1 + 24);
              *(_DWORD *)(a1 + 24) = v10 + 1;
              if (v10 == -1) {
                *(_DWORD *)(a1 + 100) = 1;
              }
            }
            if (*(_WORD *)(a1 + 28) == 64) {
              SHA1ProcessMessageBlock((int *)a1);
            }
            uint64_t result = 0;
            ++v5;
            if (!--v6) {
              return result;
            }
          }
          return 0;
        }
      }
    }
  }
  return result;
}

int *SHA1ProcessMessageBlock(int *result)
{
  uint64_t v1 = 0;
  int v2 = (char *)result + 30;
  int8x16x4_t v51 = vld4q_s8(v2);
  uint16x8_t v3 = vmovl_u8(*(uint8x8_t *)v51.val[0].i8);
  uint16x8_t v4 = vmovl_high_u8((uint8x16_t)v51.val[0]);
  _Q16 = vmovl_u8(*(uint8x8_t *)v51.val[1].i8);
  _Q17 = vmovl_high_u8((uint8x16_t)v51.val[1]);
  __asm
  {
    SHLL2           V18.4S, V17.8H, #0x10
    SHLL2           V19.4S, V16.8H, #0x10
  }
  uint16x8_t v13 = vmovl_high_u8((uint8x16_t)v51.val[2]);
  uint16x8_t v14 = vmovl_u8(*(uint8x8_t *)v51.val[2].i8);
  int8x16_t v15 = vorrq_s8(vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v14.i8, 8uLL), (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q16.i8, 0x10uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v3.i8), 0x18uLL));
  uint16x8_t v16 = vmovl_high_u8((uint8x16_t)v51.val[3]);
  v51.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v51.val[3].i8);
  v50[3] = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_high_n_u16(v13, 8uLL), _Q18), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v4), 0x18uLL)), (int8x16_t)vmovl_high_u16(v16));
  CFIndex v50[2] = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v13.i8, 8uLL), (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q17.i8, 0x10uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v4.i8), 0x18uLL)), (int8x16_t)vmovl_u16(*(uint16x4_t *)v16.i8));
  v50[1] = vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_high_n_u16(v14, 8uLL), _Q19), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v3), 0x18uLL)), (int8x16_t)vmovl_high_u16((uint16x8_t)v51.val[0]));
  v50[0] = vorrq_s8(v15, (int8x16_t)vmovl_u16(*(uint16x4_t *)v51.val[0].i8));
  do
  {
    HIDWORD(v17) = *(_DWORD *)((char *)&v50[2] + v1) ^ *(_DWORD *)((char *)&v50[3] + v1 + 4) ^ *(_DWORD *)((char *)v50 + v1 + 8) ^ *(_DWORD *)((char *)v50 + v1);
    LODWORD(v17) = HIDWORD(v17);
    *(_DWORD *)((char *)&v50[4] + v1) = v17 >> 31;
    v1 += 4;
  }
  while (v1 != 256);
  uint64_t v18 = 0;
  int v19 = result[1];
  int v21 = result[3];
  int v20 = result[4];
  int v22 = v20;
  int v23 = result[2];
  int v24 = v21;
  int v25 = v23;
  int v26 = v19;
  int v27 = *result;
  do
  {
    int v28 = v27;
    int v29 = v25;
    int v30 = v24;
    HIDWORD(v31) = v27;
    LODWORD(v31) = v27;
    int v32 = (v31 >> 27) + (v25 & v26) + (v24 & ~v26) + v22 + 1518500249;
    HIDWORD(v31) = v26;
    LODWORD(v31) = v26;
    int v25 = v31 >> 2;
    int v27 = v32 + *(_DWORD *)((char *)v50 + v18);
    v18 += 4;
    int v22 = v24;
    int v24 = v29;
    int v26 = v28;
  }
  while (v18 != 80);
  uint64_t v33 = 80;
  do
  {
    int v34 = v27;
    int v35 = v25;
    int v36 = v29;
    HIDWORD(v37) = v27;
    LODWORD(v37) = v27;
    int v38 = (v37 >> 27) + (v25 ^ v28 ^ v29) + v30 + 1859775393;
    HIDWORD(v37) = v28;
    LODWORD(v37) = v28;
    int v25 = v37 >> 2;
    int v27 = v38 + *(_DWORD *)((char *)v50 + v33);
    v33 += 4;
    int v30 = v29;
    int v29 = v35;
    int v28 = v34;
  }
  while (v33 != 160);
  do
  {
    int v39 = v27;
    int v40 = v25;
    HIDWORD(v41) = v27;
    LODWORD(v41) = v27;
    int v42 = v35;
    int v43 = (v41 >> 27) + v36 + ((v35 | v40) & v34 | v35 & v40) - 1894007588;
    HIDWORD(v41) = v34;
    LODWORD(v41) = v34;
    int v25 = v41 >> 2;
    int v27 = v43 + *(_DWORD *)((char *)v50 + v33);
    v33 += 4;
    int v36 = v35;
    int v35 = v40;
    int v34 = v39;
  }
  while (v33 != 240);
  uint64_t v44 = 240;
  do
  {
    int v45 = v27;
    int v46 = v25;
    int v47 = v40;
    HIDWORD(v48) = v27;
    LODWORD(v48) = v27;
    int v49 = (v48 >> 27) + (v25 ^ v39 ^ v40) + v42 - 899497514;
    HIDWORD(v48) = v39;
    LODWORD(v48) = v39;
    int v25 = v48 >> 2;
    int v27 = v49 + *(_DWORD *)((char *)v50 + v44);
    v44 += 4;
    int v42 = v40;
    int v40 = v46;
    int v39 = v45;
  }
  while (v44 != 320);
  *result += v27;
  result[1] = v45 + v19;
  result[2] = v25 + v23;
  result[3] = v46 + v21;
  result[4] = v47 + v20;
  *((_WORD *)result + 14) = 0;
  return result;
}

uint64_t tss_submit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    AMAuthInstallLog(3, (uint64_t)"tss_submit", (uint64_t)"NULL session", a4, a5, a6, a7, a8, v19);
    return 10009;
  }
  if (!*(void *)(a1 + 24))
  {
    AMAuthInstallLog(3, (uint64_t)"tss_submit", (uint64_t)"NULL request in session", a4, a5, a6, a7, a8, v19);
    uint64_t v15 = 10008;
    CFStringRef v16 = (const __CFString *)a1;
    int v17 = 10008;
LABEL_10:
    sub_100038774(v16, v17);
    return v15;
  }
  if (!*(void *)(a1 + 48))
  {
    sub_1000387BC();
    return *(unsigned int *)(a1 + 64);
  }
  int v9 = (pthread_t *)malloc(8uLL);
  *(void *)(a1 + 56) = v9;
  if (!v9)
  {
    AMAuthInstallLog(3, (uint64_t)"tss_submit_non_block", (uint64_t)"out of memory", v10, v11, v12, v13, v14, v19);
    uint64_t v15 = 10006;
    CFStringRef v16 = (const __CFString *)a1;
    int v17 = 10006;
    goto LABEL_10;
  }
  pthread_create(v9, 0, (void *(__cdecl *)(void *))sub_1000387BC, (void *)a1);
  return 0;
}

CFStringRef sub_100038774(const __CFString *result, int a2)
{
  if (result)
  {
    CFStringRef v3 = result;
    LODWORD(result[2].isa) = a2;
    info = (const void *)result[2].info;
    if (info) {
      CFRelease(info);
    }
    uint64_t result = tss_lookup_error(a2);
    v3[2].info = (uint64_t)result;
  }
  return result;
}

uint64_t sub_1000387BC()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v6 = v0;
  if (v0)
  {
    if (*(_DWORD *)(v0 + 16) <= 1u) {
      unsigned int v7 = 1;
    }
    else {
      unsigned int v7 = *(_DWORD *)(v0 + 16);
    }
  }
  else
  {
    unsigned int v7 = 1;
  }
  unsigned int v8 = 0;
  CFAllocatorRef v9 = kCFAllocatorDefault;
  key = (void *)_kCFSystemVersionBuildVersionKey;
  do
  {
    AMAuthInstallLog(6, (uint64_t)"tss_submit_job_with_retry", (uint64_t)"TSS Connection attempt %d of %d.  (Will retry if TSS_ERR_SERVER_NOT_REACHABLE.)", v1, v2, v3, v4, v5, ++v8);
    CFErrorRef error = 0;
    bzero(v209, 0x19000uLL);
    if (!*(void *)(v6 + 8))
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"no server URL", v10, v11, v12, v13, v14, v173);
      int v71 = 10008;
LABEL_25:
      sub_100038774((const __CFString *)v6, v71);
      CFURLRef v28 = 0;
      CFHTTPMessageRef Request = 0;
      CFStringRef v72 = 0;
      CFStringRef v35 = 0;
      CFDictionaryRef v73 = 0;
      uint64_t v50 = 0;
      *(_DWORD *)(v6 + 64) = v71;
      goto LABEL_36;
    }
    CFDataRef v15 = CFPropertyListCreateData(v9, *(CFPropertyListRef *)(v6 + 24), kCFPropertyListXMLFormat_v1_0, 0, &error);
    if (!v15)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFPropertyListCreateXMLData failed %@", v16, v17, v18, v19, v20, (char)error);
      int v71 = 10036;
      goto LABEL_25;
    }
    CFDataRef v21 = v15;
    char Length = CFDataGetLength(v15);
    CFURLRef v28 = CFURLCreateWithString(v9, @"TSS/controller?action=2", *(CFURLRef *)(v6 + 8));
    if (!v28)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFURLCreateCopyAppendingPathComponent() failed", v23, v24, v25, v26, v27, v173);
      int v74 = 10041;
      sub_100038774((const __CFString *)v6, 10041);
      CFHTTPMessageRef Request = 0;
LABEL_28:
      CFStringRef v72 = 0;
      CFStringRef v35 = 0;
      uint64_t v50 = 0;
LABEL_35:
      *(_DWORD *)(v6 + 64) = v74;
      CFRelease(v21);
      CFDictionaryRef v73 = 0;
      goto LABEL_36;
    }
    CFHTTPMessageRef Request = CFHTTPMessageCreateRequest(v9, @"POST", v28, kCFHTTPVersion1_1);
    if (!Request)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFHTTPMessageCreateRequest failed", v29, v30, v31, v32, v33, v173);
      int v74 = 10041;
      sub_100038774((const __CFString *)v6, 10041);
      goto LABEL_28;
    }
    char v174 = Length;
    CFStringRef v35 = CFStringCreateWithFormat(v9, 0, @"%d");
    CFHTTPMessageSetHeaderFieldValue(Request, @"Proxy-Connection", @"Keep-Alive");
    CFHTTPMessageSetHeaderFieldValue(Request, @"Pragma", @"no-cache");
    CFHTTPMessageSetHeaderFieldValue(Request, @"Content-Type", @"text/xml; charset=\"utf-8\"");
    CFHTTPMessageSetHeaderFieldValue(Request, @"Content-Length", v35);
    CFDictionaryRef v36 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (v36)
    {
      CFDictionaryRef v42 = v36;
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v36, key);
      CFHTTPMessageSetHeaderFieldValue(Request, @"X-OS-Version", Value);
      CFRelease(v42);
    }
    if (*(void *)(v6 + 32))
    {
      AMAuthInstallLog(7, (uint64_t)"tss_submit_job", (uint64_t)"Attempting to add additional entries to HTTP header", v37, v38, v39, v40, v41, v174);
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(v6 + 32), (CFDictionaryApplierFunction)sub_1000392CC, Request);
      AMAuthInstallLog(7, (uint64_t)"tss_submit_job", (uint64_t)"Done adding additional fields to HTTP header", v44, v45, v46, v47, v48, v175);
    }
    CFHTTPMessageSetBody(Request, v21);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v9, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v50 = Mutable;
    int8x16x4_t v51 = *(const void **)(v6 + 80);
    if (v51)
    {
      CFDictionaryAddValue(Mutable, @"SocksProxySettings", v51);
      AMAuthInstallLog(7, (uint64_t)"tss_submit_job", (uint64_t)"Found a SOCKS proxy setting. Will attempt to use it.", v52, v53, v54, v55, v56, v174);
    }
    CFRange v57 = *(const void **)(v6 + 88);
    if (v57)
    {
      CFDictionaryAddValue(v50, @"TrustedServerCAs", v57);
      AMAuthInstallLog(7, (uint64_t)"tss_submit_job", (uint64_t)"Found a trusted server CA. Will attempt to use it.", v58, v59, v60, v61, v62, v174);
    }
    theData[0] = 0;
    CFStringRef v63 = CFURLCopyScheme(*(CFURLRef *)(v6 + 8));
    if (!v63)
    {
      CFAllocatorRef v70 = "Invalid scheme in url";
      goto LABEL_32;
    }
    CFStringRef v69 = v63;
    *(_DWORD *)__s = 10000;
    if (CFStringCompare(v63, @"https", 1uLL) && CFStringCompare(v69, @"http", 1uLL))
    {
      CFRelease(v69);
      CFAllocatorRef v70 = "unsupported URL scheme";
LABEL_32:
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)v70, v64, v65, v66, v67, v68, v174);
      int v74 = 10008;
      CFStringRef v80 = (const __CFString *)v6;
      int v81 = 10008;
      goto LABEL_33;
    }
    CFRelease(v69);
    if (AMAuthInstallHttpMessageSendSyncNew(v9, (int)Request, (int)theData, (int)__s, v50, 300.0))
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"failed to send http request", v75, v76, v77, v78, v79, v174);
      int v74 = 10002;
      CFStringRef v80 = (const __CFString *)v6;
      int v81 = 10002;
LABEL_33:
      sub_100038774(v80, v81);
LABEL_34:
      CFStringRef v72 = @"Content-Length";
      goto LABEL_35;
    }
    int v74 = *(_DWORD *)__s;
    if (*(_DWORD *)__s != 200)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"SendHttpRequest failed %d", v75, v76, v77, v78, v79, __s[0]);
      if (*(_DWORD *)__s == -1) {
        int v74 = 10002;
      }
      CFStringRef v88 = (const __CFString *)v6;
      int v89 = v74;
      goto LABEL_62;
    }
    if ((unint64_t)CFDataGetLength(theData[0]) > 0x19000)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"Response too large", v83, v84, v85, v86, v87, v174);
      int v74 = 10052;
      CFStringRef v88 = (const __CFString *)v6;
      int v89 = 10052;
LABEL_62:
      sub_100038774(v88, v89);
      CFRelease(theData[0]);
      goto LABEL_34;
    }
    CFDataGetBytePtr(theData[0]);
    CFDataGetLength(theData[0]);
    __memcpy_chk();
    int v90 = CFDataGetLength(theData[0]);
    CFRelease(theData[0]);
    int v96 = v90;
    *(void *)uint64_t v207 = 0;
    *(_OWORD *)__s = 0u;
    long long v192 = 0u;
    long long v193 = 0u;
    long long v194 = 0u;
    long long v195 = 0u;
    long long v196 = 0u;
    long long v197 = 0u;
    long long v198 = 0u;
    long long v199 = 0u;
    long long v200 = 0u;
    long long v201 = 0u;
    long long v202 = 0u;
    long long v203 = 0u;
    long long v204 = 0u;
    long long v205 = 0u;
    long long v206 = 0u;
    int v180 = v90;
    if (v90 < 1)
    {
      int v100 = 0;
      CFStringRef v184 = 0;
      CFTypeRef cf = 0;
      uint64_t v183 = 0;
      goto LABEL_101;
    }
    CFAllocatorRef v97 = 0;
    CFIndex v98 = 0;
    uint64_t v99 = 0;
    int v100 = 0;
    uint64_t v101 = v209;
    do
    {
      if (v99)
      {
        if (v98) {
          goto LABEL_67;
        }
      }
      else if (v100 + 7 >= v96)
      {
        uint64_t v99 = 0;
        if (v98) {
          goto LABEL_67;
        }
      }
      else
      {
        uint64_t v181 = v97;
        CFStringRef v185 = v98;
        if (!strncmp(v101, "STATUS", 6uLL))
        {
          uint64_t v102 = 0;
          uint64_t v99 = v101 + 7;
          CFAllocatorRef v97 = v181;
          do
          {
            int v103 = v101[v102 + 7];
            if (v103 == 38) {
              break;
            }
            v207[v102++] = v103;
          }
          while (v102 != 8);
          v207[7] = 0;
          int v96 = v180;
        }
        else
        {
          uint64_t v99 = 0;
          int v96 = v180;
          CFAllocatorRef v97 = v181;
        }
        CFIndex v98 = v185;
        if (v185)
        {
LABEL_67:
          if (v97) {
            goto LABEL_98;
          }
          goto LABEL_68;
        }
      }
      if (v100 + 8 >= v96)
      {
        CFIndex v98 = 0;
        if (v97) {
          goto LABEL_98;
        }
      }
      else
      {
        CFTypeRef cfa = v99;
        uint64_t v182 = v97;
        if (!strncmp(v101, "MESSAGE", 7uLL))
        {
          uint64_t v104 = 0;
          CFIndex v98 = v101 + 8;
          CFAllocatorRef v97 = v182;
          uint64_t v99 = cfa;
          do
          {
            int v105 = v101[v104 + 8];
            if (v105 == 10) {
              break;
            }
            if (v105 == 38) {
              break;
            }
            __s[v104++] = v105;
          }
          while (v104 != 256);
          HIBYTE(v206) = 0;
          int v96 = v180;
          if (v182) {
            goto LABEL_98;
          }
        }
        else
        {
          CFIndex v98 = 0;
          int v96 = v180;
          CFAllocatorRef v97 = v182;
          uint64_t v99 = cfa;
          if (v182) {
            goto LABEL_98;
          }
        }
      }
LABEL_68:
      if (v100 + 15 >= v96)
      {
        CFAllocatorRef v97 = 0;
      }
      else
      {
        CFStringRef v184 = v98;
        CFTypeRef cf = v99;
        if (!strncmp(v101, "REQUEST_STRING", 0xEuLL))
        {
          CFAllocatorRef v97 = v101 + 15;
          uint64_t v99 = cf;
          if (cf)
          {
            int v96 = v180;
            CFIndex v98 = v184;
            if (v184)
            {
              uint64_t v183 = v101 + 15;
              goto LABEL_101;
            }
          }
          else
          {
            int v96 = v180;
            CFIndex v98 = v184;
          }
        }
        else
        {
          CFAllocatorRef v97 = 0;
          int v96 = v180;
          CFIndex v98 = v184;
          uint64_t v99 = cf;
        }
      }
LABEL_98:
      ++v101;
      ++v100;
    }
    while (v100 != v96);
    uint64_t v183 = v97;
    CFStringRef v184 = v98;
    int v100 = v96;
    CFTypeRef cf = v99;
LABEL_101:
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"----Begin request", v91, v92, v93, v94, v95, v174);
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"%@", v106, v107, v108, v109, v110, *(void *)(v6 + 24));
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"----End request", v111, v112, v113, v114, v115, v176);
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"----Begin response", v116, v117, v118, v119, v120, v177);
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"%s", v121, v122, v123, v124, v125, (char)v209);
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"----End response", v126, v127, v128, v129, v130, v178);
    if (!cf || !v184)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"invalid response", v131, v132, v133, v134, v135, v179);
      int v142 = 10052;
      CFStringRef v151 = (const __CFString *)v6;
      int v152 = 10052;
      goto LABEL_109;
    }
    int v136 = atoi(v207);
    if (!v136)
    {
      if (v183)
      {
        __memcpy_chk();
        CFDataRef v153 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)theData, v180 - v100 - 15);
        if (v153)
        {
          CFDataRef v159 = v153;
          if (error) {
            CFRelease(error);
          }
          CFDataRef cfb = v159;
          CFDictionaryRef v73 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v159, 0, 0, &error);
          if (v73)
          {
            CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v73);
            *(void *)(v6 + 40) = Copy;
            if (Copy)
            {
              int v171 = 0;
LABEL_124:
              *(_DWORD *)(v6 + 64) = v171;
              CFRelease(v21);
              CFRelease(cfb);
              goto LABEL_111;
            }
            AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFDictionaryCreateCopy failed", v166, v167, v168, v169, v170, v179);
            int v171 = 10056;
          }
          else
          {
            AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFPropertyListCreateFromXMLData failed (%@)", v160, v161, v162, v163, v164, (char)error);
            int v171 = 10055;
          }
          sub_100038774((const __CFString *)v6, v171);
          goto LABEL_124;
        }
        AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFDataCreate failed", v154, v155, v156, v157, v158, v179);
        int v142 = 10054;
        CFStringRef v151 = (const __CFString *)v6;
        int v152 = 10054;
      }
      else
      {
        AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"no data in response", v137, v138, v139, v140, v141, v179);
        int v142 = 10053;
        CFStringRef v151 = (const __CFString *)v6;
        int v152 = 10053;
      }
LABEL_109:
      sub_100038774(v151, v152);
      goto LABEL_110;
    }
    int v142 = v136;
    AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"error from server=%d (%s)", v137, v138, v139, v140, v141, v136);
    uint64_t v143 = *(const void **)(v6 + 72);
    if (v143) {
      CFRelease(v143);
    }
    size_t v144 = strlen(__s);
    CFStringRef v145 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)__s, v144, 0x8000100u, 0);
    *(void *)(v6 + 72) = v145;
    if (!v145) {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"Server message failed to convert: %d", v146, v147, v148, v149, v150, v142);
    }
LABEL_110:
    *(_DWORD *)(v6 + 64) = v142;
    CFRelease(v21);
    CFDictionaryRef v73 = 0;
LABEL_111:
    CFStringRef v72 = @"Content-Length";
LABEL_36:
    if (error) {
      CFRelease(error);
    }
    if (v28) {
      CFRelease(v28);
    }
    if (Request) {
      CFRelease(Request);
    }
    if (v72) {
      CFRelease(v72);
    }
    if (v35) {
      CFRelease(v35);
    }
    CFAllocatorRef v9 = kCFAllocatorDefault;
    if (v73) {
      CFRelease(v73);
    }
    if (v50) {
      CFRelease(v50);
    }
    uint64_t v82 = *(void (**)(uint64_t))(v6 + 48);
    if (v82) {
      v82(v6);
    }
  }
  while (v6 && v8 < v7 && *(_DWORD *)(v6 + 64) == 10002);
  return 0;
}

void sub_1000392CC(const __CFString *a1, const __CFString *a2, __CFHTTPMessage *a3)
{
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  long long v12 = 0u;
  CFStringGetCString(a1, buffer, 511, 0x8000100u);
  CFStringGetCString(a2, v11, 511, 0x8000100u);
  AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallUpdateHTTPHeaderWithEntry", (uint64_t)"Appending {%s : %s} to http header", v6, v7, v8, v9, v10, (char)buffer);
  CFHTTPMessageSetHeaderFieldValue(a3, a1, a2);
}

uint64_t amai_unzStringFileNameCompare(const char *a1, const char *a2, int a3)
{
  if (a3 == 1) {
    return strcmp(a1, a2);
  }
  while (1)
  {
    int v5 = *(unsigned __int8 *)a1++;
    int v4 = v5;
    int v7 = *(unsigned __int8 *)a2++;
    int v6 = v7;
    if ((v4 - 97) < 0x1A) {
      LOBYTE(v4) = v4 - 32;
    }
    if ((v6 - 97) < 0x1A) {
      LOBYTE(v6) = v6 - 32;
    }
    if (!(_BYTE)v4) {
      break;
    }
    if (!(_BYTE)v6) {
      return 1;
    }
    if ((char)v4 < (char)v6) {
      return 0xFFFFFFFFLL;
    }
    if ((char)v4 > (char)v6) {
      return 1;
    }
  }
  if ((_BYTE)v6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

void *amai_unzOpen2(uint64_t a1, _OWORD *a2)
{
  memset(__src, 0, 336);
  if (a2)
  {
    long long v3 = a2[1];
    __src[0] = *a2;
    __src[1] = v3;
    long long v4 = a2[3];
    __src[2] = a2[2];
    __src[3] = v4;
    uint64_t v5 = (*(uint64_t (**)(void, uint64_t, uint64_t))&__src[0])(*((void *)&v4 + 1), a1, 5);
  }
  else
  {
    amai_fill_fopen_filefunc((FILE *(**)(int, char *, char))__src);
    uint64_t v5 = (*(uint64_t (**)(void, uint64_t, uint64_t))&__src[0])(*((void *)&__src[3] + 1), a1, 5);
  }
  int v6 = (void *)v5;
  *(void *)&__src[4] = v5;
  if (v5)
  {
    if (!(*(uint64_t (**)(void, uint64_t, void, uint64_t))&__src[2])(*((void *)&__src[3] + 1), v5, 0, 2))
    {
      unint64_t v7 = (*((uint64_t (**)(void, void *))&__src[1] + 1))(*((void *)&__src[3] + 1), v6);
      unint64_t v8 = v7;
      unint64_t v9 = v7 >= 0xFFFF ? 0xFFFFLL : v7;
      uint64_t v10 = (char *)malloc(0x404uLL);
      if (v10)
      {
        uint64_t v11 = v10;
        if (v9 >= 5)
        {
          long long v12 = v10 + 1;
          uint64_t v13 = 4;
          do
          {
            unint64_t v14 = v13 + 1024;
            unint64_t v15 = v13 + 1024 >= v9 ? v9 : v13 + 1024;
            unint64_t v16 = v15 >= 0x404 ? 1028 : v15;
            if ((*(uint64_t (**)(void, void *, unint64_t, void))&__src[2])(*((void *)&__src[3] + 1), v6, v8 - v15, 0)|| (*((uint64_t (**)(void, void *, unsigned char *, unint64_t))&__src[0] + 1))(*((void *)&__src[3] + 1), v6, v11, v16) != v16)
            {
              break;
            }
            if (v16 >= 4)
            {
              uint64_t v17 = (v16 - 4);
              while (v11[v17] != 80 || v12[v17] != 75 || v12[v17 + 1] != 5 || v12[v17 + 2] != 6)
              {
                if (v17-- <= 0) {
                  goto LABEL_28;
                }
              }
              if (v8 - v15 + v17)
              {
                free(v11);
                unint64_t v19 = v13 + 1024;
                if (v8 < v13 + 1024) {
                  unint64_t v19 = v8;
                }
                if (v19 >= 0xFFFF) {
                  unint64_t v19 = 0xFFFFLL;
                }
                unint64_t v20 = v8 - v19 + v17;
                int v35 = 1;
                goto LABEL_38;
              }
            }
LABEL_28:
            uint64_t v13 = v15;
          }
          while (v9 > v14);
        }
        free(v11);
      }
    }
    unint64_t v20 = 0;
    int v35 = 0;
LABEL_38:
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v36 = 0;
    uint64_t v31 = (*(uint64_t (**)(void, void, unint64_t, void))&__src[2])(*((void *)&__src[3] + 1), *(void *)&__src[4], v20, 0);
    int v32 = sub_100039814((uint64_t)__src, *(uint64_t *)&__src[4], &v39);
    int v33 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], &v38);
    int v34 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], &v37);
    int v21 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], (void *)&__src[4] + 1);
    int v22 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], &v36);
    uint64_t v24 = v36;
    uint64_t v23 = v37;
    uint64_t v25 = v38;
    uint64_t v26 = *((void *)&__src[4] + 1);
    int v27 = sub_100039814((uint64_t)__src, *(uint64_t *)&__src[4], (uint64_t *)&__src[8]);
    int v28 = sub_100039814((uint64_t)__src, *(uint64_t *)&__src[4], (uint64_t *)&__src[8] + 1);
    int v29 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], &__src[5]);
    if (v20 < *(void *)&__src[8] + *((void *)&__src[8] + 1)
      || v29
      || v28
      || v27
      || v24 != v26
      || v23
      || v25
      || !v35
      || v22
      || v21
      || v34
      || v33
      || v32
      || v31)
    {
      (*((void (**)(void, void))&__src[2] + 1))(*((void *)&__src[3] + 1), *(void *)&__src[4]);
      return 0;
    }
    else
    {
      *((void *)&__src[5] + 1) = v20 - (*(void *)&__src[8] + *((void *)&__src[8] + 1));
      *((void *)&__src[7] + 1) = v20;
      *(void *)&__src[18] = 0;
      DWORD2(__src[18]) = 0;
      int v6 = malloc(0x150uLL);
      memcpy(v6, __src, 0x150uLL);
      amai_unzGoToFirstFile(v6);
    }
  }
  return v6;
}

uint64_t sub_100039814(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v11 = 0;
  if (sub_10003AA9C(a1, a2, &v11)
    || (uint64_t v6 = v11, sub_10003AA9C(a1, a2, &v11))
    || (uint64_t v7 = v11, sub_10003AA9C(a1, a2, &v11)))
  {
    uint64_t v8 = 0;
    uint64_t result = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v10 = v6 + (v7 << 8) + ((uint64_t)v11 << 16);
    uint64_t result = sub_10003AA9C(a1, a2, &v11);
    uint64_t v8 = v10 + ((uint64_t)v11 << 24);
    if (result) {
      uint64_t v8 = 0;
    }
  }
  *a3 = v8;
  return result;
}

uint64_t sub_1000398D0(uint64_t a1, uint64_t a2, void *a3)
{
  int v9 = 0;
  if (sub_10003AA9C(a1, a2, &v9))
  {
    uint64_t v6 = 0;
    uint64_t result = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = v9;
    uint64_t result = sub_10003AA9C(a1, a2, &v9);
    uint64_t v6 = v8 + ((uint64_t)v9 << 8);
    if (result) {
      uint64_t v6 = 0;
    }
  }
  *a3 = v6;
  return result;
}

uint64_t amai_unzGoToFirstFile(void *a1)
{
  if (!a1) {
    return 4294967194;
  }
  uint64_t v2 = a1[17];
  a1[12] = 0;
  a1[13] = v2;
  uint64_t result = sub_100039AF0((uint64_t)a1, (uint64_t)(a1 + 18), a1 + 35, 0, 0, 0, 0, 0, 0);
  a1[14] = result == 0;
  return result;
}

void *amai_unzOpen(uint64_t a1)
{
  return amai_unzOpen2(a1, 0);
}

uint64_t amai_unzClose(uint64_t a1)
{
  if (!a1) {
    return 4294967194;
  }
  if (*(void *)(a1 + 288)) {
    amai_unzCloseCurrentFile(a1);
  }
  (*(void (**)(void, void))(a1 + 40))(*(void *)(a1 + 56), *(void *)(a1 + 64));
  free((void *)a1);
  return 0;
}

uint64_t amai_unzCloseCurrentFile(uint64_t a1)
{
  if (!a1) {
    return 4294967194;
  }
  uint64_t v2 = *(void *)(a1 + 288);
  if (!v2) {
    return 4294967194;
  }
  if (*(void *)(v2 + 184) || *(_DWORD *)(v2 + 280))
  {
    uint64_t v3 = 0;
  }
  else if (*(void *)(v2 + 160) == *(void *)(v2 + 168))
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = 4294967191;
  }
  if (*(void *)v2) {
    free(*(void **)v2);
  }
  *(void *)uint64_t v2 = 0;
  if (*(void *)(v2 + 128)) {
    inflateEnd((z_streamp)(v2 + 8));
  }
  free((void *)v2);
  *(void *)(a1 + 288) = 0;
  return v3;
}

uint64_t amai_unzGetCurrentFileInfo(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8)
{
  return sub_100039AF0(a1, a2, 0, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_100039AF0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8, unint64_t a9)
{
  if (!a1) {
    return 4294967194;
  }
  if ((*(uint64_t (**)(void, void, void, void))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 88) + *(void *)(a1 + 104), 0)|| (uint64_t v54 = 0, sub_100039814(a1, *(void *)(a1 + 64), &v54)))
  {
    int v10 = -1;
  }
  else if (v54 == 33639248)
  {
    int v10 = 0;
  }
  else
  {
    int v10 = -103;
  }
  unsigned int v50 = v10;
  uint64_t v64 = 0;
  long long v62 = 0u;
  int8x16_t v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  uint64_t v55 = 0;
  int v49 = sub_1000398D0(a1, *(void *)(a1 + 64), &v56);
  int v48 = sub_1000398D0(a1, *(void *)(a1 + 64), (void *)&v56 + 1);
  int v47 = sub_1000398D0(a1, *(void *)(a1 + 64), &v57);
  int v46 = sub_1000398D0(a1, *(void *)(a1 + 64), (void *)&v57 + 1);
  int v45 = sub_100039814(a1, *(void *)(a1 + 64), (uint64_t *)&v58);
  LODWORD(v64) = ((v58 >> 21) & 0xF) - 1;
  HIDWORD(v64) = (v58 >> 25) + 1980;
  v11.i32[0] = v58;
  int8x16_t v12 = (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v58), (uint32x4_t)xmmword_10007E210);
  v12.i32[0] = vshlq_u32(v11, (uint32x4_t)xmmword_10007E200).u32[0];
  int8x16_t v63 = vandq_s8(v12, (int8x16_t)xmmword_10007E220);
  int v13 = sub_100039814(a1, *(void *)(a1 + 64), (uint64_t *)&v58 + 1);
  int v14 = sub_100039814(a1, *(void *)(a1 + 64), (uint64_t *)&v59);
  int v15 = sub_100039814(a1, *(void *)(a1 + 64), (uint64_t *)&v59 + 1);
  int v16 = sub_1000398D0(a1, *(void *)(a1 + 64), &v60);
  int v17 = sub_1000398D0(a1, *(void *)(a1 + 64), (void *)&v60 + 1);
  int v18 = sub_1000398D0(a1, *(void *)(a1 + 64), &v61);
  int v19 = sub_1000398D0(a1, *(void *)(a1 + 64), (void *)&v61 + 1);
  int v20 = sub_1000398D0(a1, *(void *)(a1 + 64), &v62);
  int v21 = sub_100039814(a1, *(void *)(a1 + 64), (uint64_t *)&v62 + 1);
  if (sub_100039814(a1, *(void *)(a1 + 64), &v55) | v21 | v20 | v19 | v18 | v17 | v16 | v15 | v14 | v13 | v45 | v46 | v47 | v48 | v49) {
    uint64_t v22 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v22 = v50;
  }
  unint64_t v23 = v60;
  if (a4)
  {
    unint64_t v25 = a7;
    uint64_t v24 = a6;
    if (v22)
    {
      uint64_t v28 = a2;
      int v27 = a3;
      uint64_t v29 = a8;
    }
    else
    {
      unint64_t v26 = a5;
      if ((unint64_t)v60 < a5)
      {
        *(unsigned char *)(a4 + v60) = 0;
        unint64_t v26 = v23;
      }
      uint64_t v22 = 0;
      if (a5)
      {
        uint64_t v28 = a2;
        int v27 = a3;
        uint64_t v29 = a8;
        if (v23)
        {
          if ((*(uint64_t (**)(void, void))(a1 + 8))(*(void *)(a1 + 56), *(void *)(a1 + 64)) == v26) {
            uint64_t v22 = 0;
          }
          else {
            uint64_t v22 = 0xFFFFFFFFLL;
          }
        }
      }
      else
      {
        uint64_t v28 = a2;
        int v27 = a3;
        uint64_t v29 = a8;
      }
      v23 -= v26;
    }
  }
  else
  {
    uint64_t v28 = a2;
    int v27 = a3;
    uint64_t v29 = a8;
    unint64_t v25 = a7;
    uint64_t v24 = a6;
  }
  uint64_t v30 = *((void *)&v60 + 1);
  if (!v24 || v22)
  {
    unint64_t v33 = *((void *)&v60 + 1) + v23;
    if (!v29) {
      goto LABEL_60;
    }
    goto LABEL_46;
  }
  if (*((void *)&v60 + 1) >= v25) {
    unint64_t v31 = v25;
  }
  else {
    unint64_t v31 = *((void *)&v60 + 1);
  }
  if (!v23)
  {
    uint64_t v22 = 0;
    if (!v25) {
      goto LABEL_45;
    }
    goto LABEL_41;
  }
  uint64_t v32 = (*(uint64_t (**)(void, void, unint64_t, uint64_t))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), v23, 1);
  if (v32) {
    uint64_t v22 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v22 = 0;
  }
  if (!v32) {
    unint64_t v23 = 0;
  }
  if (v25)
  {
LABEL_41:
    if (v30)
    {
      if ((*(uint64_t (**)(void, void, uint64_t, unint64_t))(a1 + 8))(*(void *)(a1 + 56), *(void *)(a1 + 64), v24, v31) == v31)uint64_t v22 = v22; {
      else
      }
        uint64_t v22 = 0xFFFFFFFFLL;
    }
  }
LABEL_45:
  unint64_t v33 = v30 - v31 + v23;
  if (!v29) {
    goto LABEL_60;
  }
LABEL_46:
  if (!v22)
  {
    unint64_t v34 = v61;
    unint64_t v35 = a9;
    if ((unint64_t)v61 < a9)
    {
      *(unsigned char *)(v29 + v61) = 0;
      unint64_t v35 = v34;
    }
    if (v33)
    {
      if ((*(uint64_t (**)(void, void, unint64_t, uint64_t))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), v33, 1))
      {
        uint64_t v22 = 0xFFFFFFFFLL;
      }
      else
      {
        uint64_t v22 = 0;
      }
      if (!a9) {
        goto LABEL_60;
      }
LABEL_56:
      if (v34)
      {
        if ((*(uint64_t (**)(void, void, uint64_t, unint64_t))(a1 + 8))(*(void *)(a1 + 56), *(void *)(a1 + 64), v29, v35) == v35)uint64_t v22 = v22; {
        else
        }
          uint64_t v22 = 0xFFFFFFFFLL;
      }
      goto LABEL_60;
    }
    uint64_t v22 = 0;
    if (a9) {
      goto LABEL_56;
    }
  }
LABEL_60:
  if (v28 && !v22)
  {
    int8x16_t v36 = v63;
    *(_OWORD *)(v28 + 96) = v62;
    *(int8x16_t *)(v28 + 112) = v36;
    *(void *)(v28 + 128) = v64;
    long long v37 = v59;
    *(_OWORD *)(v28 + 32) = v58;
    *(_OWORD *)(v28 + 48) = v37;
    long long v38 = v61;
    *(_OWORD *)(v28 + 64) = v60;
    *(_OWORD *)(v28 + 80) = v38;
    long long v39 = v57;
    *(_OWORD *)uint64_t v28 = v56;
    *(_OWORD *)(v28 + 16) = v39;
  }
  if (v27 && !v22) {
    *int v27 = v55;
  }
  return v22;
}

uint64_t amai_unzGoToNextFile(void *a1)
{
  if (!a1) {
    return 4294967194;
  }
  if (!a1[14]) {
    return 4294967196;
  }
  uint64_t v2 = a1[9];
  uint64_t v3 = a1[12] + 1;
  if (v2 != 0xFFFF && v3 == v2) {
    return 4294967196;
  }
  uint64_t v5 = a1[26] + a1[27] + a1[28] + a1[13] + 46;
  a1[12] = v3;
  a1[13] = v5;
  uint64_t result = sub_100039AF0((uint64_t)a1, (uint64_t)(a1 + 18), a1 + 35, 0, 0, 0, 0, 0, 0);
  a1[14] = result == 0;
  return result;
}

uint64_t amai_unzLocateFile(uint64_t a1, char *__s, int a3)
{
  if (!a1 || strlen(__s) > 0xFF) {
    return 4294967194;
  }
  if (!*(void *)(a1 + 112)) {
    return 4294967196;
  }
  uint64_t v7 = *(void *)(a1 + 96);
  uint64_t v8 = *(void *)(a1 + 104);
  long long v17 = *(_OWORD *)(a1 + 240);
  long long v18 = *(_OWORD *)(a1 + 256);
  uint64_t v9 = *(void *)(a1 + 280);
  uint64_t v19 = *(void *)(a1 + 272);
  long long v13 = *(_OWORD *)(a1 + 176);
  long long v14 = *(_OWORD *)(a1 + 192);
  long long v15 = *(_OWORD *)(a1 + 208);
  long long v16 = *(_OWORD *)(a1 + 224);
  long long v11 = *(_OWORD *)(a1 + 144);
  long long v12 = *(_OWORD *)(a1 + 160);
  uint64_t v10 = *(void *)(a1 + 136);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = v10;
  uint64_t result = sub_100039AF0(a1, a1 + 144, (void *)(a1 + 280), 0, 0, 0, 0, 0, 0);
  for (*(void *)(a1 + 112) = result == 0; !result; uint64_t result = amai_unzGoToNextFile((void *)a1))
  {
    uint64_t result = sub_100039AF0(a1, 0, 0, (uint64_t)v20, 0x100uLL, 0, 0, 0, 0);
    if (result) {
      break;
    }
    uint64_t result = amai_unzStringFileNameCompare(v20, __s, a3);
    if (!result) {
      return result;
    }
  }
  *(void *)(a1 + 96) = v7;
  *(void *)(a1 + 104) = v8;
  *(_OWORD *)(a1 + 240) = v17;
  *(_OWORD *)(a1 + 256) = v18;
  *(void *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 160) = v12;
  *(void *)(a1 + 280) = v9;
  return result;
}

uint64_t amai_unzOpenCurrentFile3(uint64_t a1, _DWORD *a2, int *a3, int a4, unsigned char *a5)
{
  if (!a1 || !*(void *)(a1 + 112)) {
    return 4294967194;
  }
  if (*(void *)(a1 + 288)) {
    amai_unzCloseCurrentFile(a1);
  }
  if ((*(uint64_t (**)(void, void, void, void))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 88) + *(void *)(a1 + 280), 0))
  {
    return 4294967193;
  }
  uint64_t v50 = 0;
  v51[0] = 0;
  uint64_t v49 = 0;
  int v10 = sub_100039814(a1, *(void *)(a1 + 64), v51);
  uint64_t v11 = v51[0];
  int v12 = sub_1000398D0(a1, *(void *)(a1 + 64), &v50);
  int v13 = sub_1000398D0(a1, *(void *)(a1 + 64), &v49);
  if (sub_1000398D0(a1, *(void *)(a1 + 64), &v50))
  {
    int v14 = -1;
  }
  else
  {
    if (v11 == 67324752) {
      int v18 = 0;
    }
    else {
      int v18 = -103;
    }
    int v19 = v13 | v12 | v10;
    if (v19) {
      int v14 = -1;
    }
    else {
      int v14 = v18;
    }
    if (!v19 && v11 == 67324752)
    {
      int v14 = -103;
      if (v50 == *(void *)(a1 + 168))
      {
        if ((v50 & 0xFFFFFFFFFFFFFFF7) != 0) {
          int v14 = -103;
        }
        else {
          int v14 = 0;
        }
      }
    }
  }
  int v15 = sub_100039814(a1, *(void *)(a1 + 64), &v50);
  if (sub_100039814(a1, *(void *)(a1 + 64), &v50))
  {
    int v16 = -1;
  }
  else
  {
    if (v15) {
      int v16 = -1;
    }
    else {
      int v16 = v14;
    }
    if (!v16)
    {
      if (v50 == *(void *)(a1 + 184))
      {
        int v16 = 0;
      }
      else if ((v49 & 8) != 0)
      {
        int v16 = 0;
      }
      else
      {
        int v16 = -103;
      }
    }
  }
  if (sub_100039814(a1, *(void *)(a1 + 64), &v50))
  {
    int v16 = -1;
  }
  else if (!v16)
  {
    if (v50 == *(void *)(a1 + 192))
    {
      int v16 = 0;
    }
    else if ((v49 & 8) != 0)
    {
      int v16 = 0;
    }
    else
    {
      int v16 = -103;
    }
  }
  if (sub_100039814(a1, *(void *)(a1 + 64), &v50))
  {
    int v16 = -1;
  }
  else if (!v16)
  {
    if (v50 == *(void *)(a1 + 200))
    {
      int v16 = 0;
    }
    else if ((v49 & 8) != 0)
    {
      int v16 = 0;
    }
    else
    {
      int v16 = -103;
    }
  }
  uint64_t v48 = 0;
  if (sub_1000398D0(a1, *(void *)(a1 + 64), &v48))
  {
    int v16 = -1;
    uint64_t v20 = v48;
  }
  else
  {
    uint64_t v20 = v48;
    if (!v16)
    {
      if (v48 == *(void *)(a1 + 208)) {
        int v16 = 0;
      }
      else {
        int v16 = -103;
      }
    }
  }
  uint64_t v47 = 0;
  if (sub_1000398D0(a1, *(void *)(a1 + 64), &v47) || v16) {
    return 4294967193;
  }
  uint64_t v22 = *(void *)(a1 + 280);
  int v23 = v47;
  uint64_t v24 = (char *)malloc(0x120uLL);
  if (!v24) {
    return 4294967192;
  }
  unint64_t v25 = v24;
  unint64_t v26 = malloc(0x4000uLL);
  *(void *)unint64_t v25 = v26;
  *((void *)v25 + 17) = v20 + v22 + 30;
  *((_DWORD *)v25 + 36) = v23;
  *((void *)v25 + 19) = 0;
  *((_DWORD *)v25 + 70) = a4;
  if (!v26)
  {
    free(v25);
    return 4294967192;
  }
  *((void *)v25 + 16) = 0;
  if (a2) {
    *a2 = *(void *)(a1 + 168);
  }
  if (a3)
  {
    *a3 = 6;
    uint64_t v27 = *(void *)(a1 + 160) & 6;
    switch(v27)
    {
      case 2:
        int v28 = 9;
        break;
      case 6:
        int v28 = 1;
        break;
      case 4:
        int v28 = 2;
        break;
      default:
        goto LABEL_71;
    }
    *a3 = v28;
  }
LABEL_71:
  uint64_t v29 = *(void *)(a1 + 184);
  *((void *)v25 + 20) = 0;
  *((void *)v25 + 21) = v29;
  uint64_t v30 = *(void *)(a1 + 168);
  *((void *)v25 + 32) = *(void *)(a1 + 64);
  *((void *)v25 + 33) = v30;
  long long v31 = *(_OWORD *)(a1 + 16);
  *((_OWORD *)v25 + 12) = *(_OWORD *)a1;
  *((_OWORD *)v25 + 13) = v31;
  long long v32 = *(_OWORD *)(a1 + 48);
  *((_OWORD *)v25 + 14) = *(_OWORD *)(a1 + 32);
  *((_OWORD *)v25 + 15) = v32;
  *((void *)v25 + 34) = *(void *)(a1 + 88);
  *((void *)v25 + 6) = 0;
  if (!a4 && v30 == 8)
  {
    *((void *)v25 + 1) = 0;
    *((_DWORD *)v25 + 4) = 0;
    *((void *)v25 + 10) = 0;
    *((void *)v25 + 11) = 0;
    *((void *)v25 + 9) = 0;
    uint64_t v33 = inflateInit2_((z_streamp)(v25 + 8), -15, "1.2.12", 112);
    if (v33)
    {
      uint64_t v17 = v33;
      free(v25);
      return v17;
    }
    *((void *)v25 + 16) = 1;
    uint64_t v22 = *(void *)(a1 + 280);
  }
  *((_OWORD *)v25 + 11) = *(_OWORD *)(a1 + 192);
  *((void *)v25 + 15) = v22 + (v23 + v20) + 30;
  *((_DWORD *)v25 + 4) = 0;
  *(void *)(a1 + 288) = v25;
  if (!a5) {
    return 0;
  }
  unint64_t v34 = 878082192;
  crc_table = get_crc_table();
  *(_OWORD *)(a1 + 304) = xmmword_10007E230;
  *(void *)(a1 + 320) = 878082192;
  *(void *)(a1 + 328) = crc_table;
  int v36 = *a5;
  if (*a5)
  {
    long long v37 = a5 + 1;
    unint64_t v38 = 305419896;
    uint64_t v39 = 591751049;
    do
    {
      unint64_t v38 = crc_table[v36 ^ v38] ^ (v38 >> 8);
      uint64_t v39 = 134775813 * (v39 + v38) + 1;
      *(void *)(a1 + 304) = v38;
      *(void *)(a1 + 312) = v39;
      unint64_t v34 = crc_table[(v34 ^ BYTE3(v39))] ^ (v34 >> 8);
      *(void *)(a1 + 320) = v34;
      int v40 = *v37++;
      int v36 = v40;
    }
    while (v40);
  }
  if ((*(uint64_t (**)(void, void, void, void))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(*(void *)(a1 + 288) + 272) + *(void *)(*(void *)(a1 + 288) + 120), 0)|| (unint64_t)(*(uint64_t (**)(void, void, uint64_t *, uint64_t))(a1 + 8))(*(void *)(a1 + 56), *(void *)(a1 + 64), v51, 12) < 0xC)
  {
    return 4294967192;
  }
  uint64_t v41 = 0;
  unint64_t v43 = *(void *)(a1 + 320);
  uint64_t v42 = *(void *)(a1 + 328);
  unint64_t v44 = *(void *)(a1 + 304);
  uint64_t v45 = *(void *)(a1 + 312);
  do
  {
    char v46 = *((unsigned char *)v51 + v41) ^ ((unsigned __int16)((v43 & 0xFFFD ^ 3) * (v43 | 2)) >> 8);
    *((unsigned char *)v51 + v41) = v46;
    unint64_t v44 = *(void *)(v42 + 8 * (v46 ^ v44)) ^ (v44 >> 8);
    uint64_t v45 = 134775813 * (v45 + v44) + 1;
    *(void *)(a1 + 304) = v44;
    *(void *)(a1 + 312) = v45;
    unint64_t v43 = *(void *)(v42 + 8 * (v43 ^ BYTE3(v45))) ^ (v43 >> 8);
    *(void *)(a1 + 320) = v43;
    ++v41;
  }
  while (v41 != 12);
  uint64_t v17 = 0;
  *(void *)(*(void *)(a1 + 288) + 120) += 12;
  *(_DWORD *)(a1 + 296) = 1;
  return v17;
}

uint64_t amai_unzOpenCurrentFile(uint64_t a1)
{
  return amai_unzOpenCurrentFile3(a1, 0, 0, 0, 0);
}

uint64_t amai_unzReadCurrentFile(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!a1) {
    return 4294967194;
  }
  uint64_t v4 = *(void *)(a1 + 288);
  if (!v4) {
    return 4294967194;
  }
  if (!*(void *)v4) {
    return 4294967196;
  }
  if (!a3) {
    return 0;
  }
  *(void *)(v4 + 32) = a2;
  *(_DWORD *)(v4 + 40) = a3;
  unint64_t v5 = a3;
  unint64_t v6 = *(void *)(v4 + 184);
  if (v6 < a3 && !*(_DWORD *)(v4 + 280))
  {
    *(_DWORD *)(v4 + 40) = v6;
    a3 = v6;
  }
  uint64_t v7 = *(void *)(v4 + 176);
  uint64_t v8 = *(unsigned int *)(v4 + 16);
  if (v7 + v8 < v5 && *(_DWORD *)(v4 + 280))
  {
    a3 = v8 + v7;
    *(_DWORD *)(v4 + 40) = v8 + v7;
  }
  if (!a3) {
    return 0;
  }
  uint64_t v9 = 0;
  while (1)
  {
    while (1)
    {
      LODWORD(v10) = *(_DWORD *)(v4 + 16);
      if (!v10)
      {
        unint64_t v11 = *(void *)(v4 + 176);
        if (v11)
        {
          if (v11 >= 0x4000) {
            uint64_t v10 = 0x4000;
          }
          else {
            uint64_t v10 = *(void *)(v4 + 176);
          }
          if ((*(uint64_t (**)(void, void, void, void))(v4 + 224))(*(void *)(v4 + 248), *(void *)(v4 + 256), *(void *)(v4 + 272) + *(void *)(v4 + 120), 0)|| (*(uint64_t (**)(void, void, void, uint64_t))(v4 + 200))(*(void *)(v4 + 248), *(void *)(v4 + 256), *(void *)v4, v10) != v10)
          {
            return 0xFFFFFFFFLL;
          }
          if (*(_DWORD *)(a1 + 296))
          {
            uint64_t v12 = 0;
            do
            {
              uint64_t v13 = *(void *)(a1 + 328);
              unsigned int v14 = *(unsigned __int8 *)(*(void *)v4 + v12) ^ (((*(_DWORD *)(a1 + 320) & 0xFFFD ^ 3)
                                                                * (*(_DWORD *)(a1 + 320) | 2u)) >> 8);
              *(unsigned char *)(*(void *)v4 + v12) ^= (unsigned __int16)((*(_WORD *)(a1 + 320) & 0xFFFD ^ 3)
                                                                  * (*(_WORD *)(a1 + 320) | 2)) >> 8;
              uint64_t v15 = *(void *)(v13 + 8 * (v14 ^ *(void *)(a1 + 304))) ^ (*(void *)(a1 + 304) >> 8);
              uint64_t v16 = 134775813 * (*(void *)(a1 + 312) + v15) + 1;
              *(void *)(a1 + 304) = v15;
              *(void *)(a1 + 312) = v16;
              *(void *)(a1 + 320) = *(void *)(v13 + 8 * (*(void *)(a1 + 320) ^ BYTE3(v16))) ^ (*(void *)(a1 + 320) >> 8);
              *(unsigned char *)(*(void *)v4 + v12++) = v14;
            }
            while (v10 != v12);
          }
          *(void *)(v4 + 120) += v10;
          *(void *)(v4 + 176) -= v10;
          *(void *)(v4 + 8) = *(void *)v4;
          *(_DWORD *)(v4 + 16) = v10;
        }
        else
        {
          LODWORD(v10) = 0;
        }
      }
      if (*(void *)(v4 + 264) && !*(_DWORD *)(v4 + 280)) {
        break;
      }
      if (v10 || *(void *)(v4 + 176))
      {
        unsigned int v17 = *(_DWORD *)(v4 + 40);
        uint64_t v10 = v17 >= v10 ? v10 : v17;
        if (v10)
        {
          for (uint64_t i = 0; i != v10; ++i)
            *(unsigned char *)(*(void *)(v4 + 32) + i) = *(unsigned char *)(*(void *)(v4 + 8) + i);
          uint64_t v19 = v10;
        }
        else
        {
          uint64_t v19 = 0;
        }
        *(void *)(v4 + 160) = crc32(*(void *)(v4 + 160), *(const Bytef **)(v4 + 32), v10);
        *(void *)(v4 + 184) -= v19;
        *(_DWORD *)(v4 + 16) -= v10;
        int v20 = *(_DWORD *)(v4 + 40) - v10;
        *(_DWORD *)(v4 + 40) = v20;
        *(void *)(v4 + 32) += v19;
        *(void *)(v4 + 8) += v19;
        uint64_t v9 = (v10 + v9);
        *(void *)(v4 + 48) += v19;
        if (v20) {
          continue;
        }
      }
      return v9;
    }
    uint64_t v21 = *(void *)(v4 + 48);
    uint64_t v22 = *(const Bytef **)(v4 + 32);
    unsigned int v23 = inflate((z_streamp)(v4 + 8), 2);
    if ((v23 & 0x80000000) == 0 && *(void *)(v4 + 56))
    {
      uint64_t v26 = *(void *)(v4 + 48);
      uint64_t v27 = v26 - v21;
      *(void *)(v4 + 160) = crc32(*(void *)(v4 + 160), v22, (int)v26 - (int)v21);
      *(void *)(v4 + 184) -= v27;
      return 4294967293;
    }
    uint64_t v24 = *(void *)(v4 + 48) - v21;
    *(void *)(v4 + 160) = crc32(*(void *)(v4 + 160), v22, v24);
    *(void *)(v4 + 184) -= v24;
    uint64_t v9 = (v9 + v24);
    if (v23) {
      break;
    }
    if (!*(_DWORD *)(v4 + 40)) {
      return v9;
    }
  }
  if (v23 == 1) {
    return v9;
  }
  else {
    return v23;
  }
}

uint64_t sub_10003AA9C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned __int8 v7 = 0;
  if ((*(unsigned int (**)(void, uint64_t, unsigned __int8 *, uint64_t))(a1 + 8))(*(void *)(a1 + 56), a2, &v7, 1) == 1)
  {
    uint64_t result = 0;
    *a3 = v7;
  }
  else if ((*(unsigned int (**)(void, uint64_t))(a1 + 48))(*(void *)(a1 + 56), a2))
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 0;
  }
  return result;
}

void *amai_zipOpen2()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v3 = v2;
  int v5 = v4;
  uint64_t v6 = v0;
  memset(__src, 0, 512);
  if (v1)
  {
    long long v7 = v1[1];
    __src[0] = *v1;
    __src[1] = v7;
    long long v8 = v1[3];
    __src[2] = v1[2];
    __src[3] = v8;
  }
  else
  {
    amai_fill_fopen_filefunc((FILE *(**)(int, char *, char))__src);
  }
  if (v5) {
    uint64_t v9 = 7;
  }
  else {
    uint64_t v9 = 11;
  }
  uint64_t v10 = (*(uint64_t (**)(void, uint64_t, uint64_t))&__src[0])(*((void *)&__src[3] + 1), v6, v9);
  *(void *)&__src[4] = v10;
  if (!v10) {
    return 0;
  }
  *(void *)&__src[1044] = (*((uint64_t (**)(void, uint64_t))&__src[1] + 1))(*((void *)&__src[3] + 1), v10);
  LODWORD(__src[13]) = 0;
  unint64_t v11 = malloc(0x4160uLL);
  *(_OWORD *)((char *)&__src[4] + 8) = 0u;
  DWORD2(__src[5]) = 0;
  *(_OWORD *)((char *)&__src[1044] + 8) = 0u;
  if (!v11)
  {
    (*((void (**)(void, void))&__src[2] + 1))(*((void *)&__src[3] + 1), *(void *)&__src[4]);
    return v11;
  }
  *((void *)&__src[1045] + 1) = 0;
  if (v5 == 2)
  {
    uint64_t v48 = v3;
    uint64_t v63 = 0;
    unint64_t v64 = 0;
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    uint64_t v58 = 0;
    uint64_t v59 = 0;
    uint64_t v57 = 0;
    uint64_t v12 = *(void *)&__src[4];
    if (!(*(uint64_t (**)(void, void, void, uint64_t))&__src[2])(*((void *)&__src[3] + 1), *(void *)&__src[4], 0, 2))
    {
      unint64_t v13 = (*((uint64_t (**)(void, uint64_t))&__src[1] + 1))(*((void *)&__src[3] + 1), v12);
      unint64_t v55 = v13;
      if (v13 >= 0xFFFF) {
        unint64_t v14 = 0xFFFFLL;
      }
      else {
        unint64_t v14 = v13;
      }
      uint64_t v15 = (char *)malloc(0x404uLL);
      uint64_t v16 = v15;
      if (!v15) {
        goto LABEL_50;
      }
      if (v14 >= 5)
      {
        unsigned int v17 = v15 + 1;
        uint64_t v18 = 4;
        do
        {
          unint64_t v19 = v18 + 1024;
          unint64_t v20 = v18 + 1024 >= v14 ? v14 : v18 + 1024;
          unint64_t v21 = v20 >= 0x404 ? 1028 : v20;
          if ((*(uint64_t (**)(void, uint64_t, unint64_t, void))&__src[2])(*((void *)&__src[3] + 1), v12, v55 - v20, 0)|| (*((uint64_t (**)(void, uint64_t, unsigned char *, unint64_t))&__src[0] + 1))(*((void *)&__src[3] + 1), v12, v16, v21) != v21)
          {
            break;
          }
          if (v21 >= 4)
          {
            uint64_t v22 = (v21 - 4);
            while (v16[v22] != 80 || v17[v22] != 75 || v17[v22 + 1] != 5 || v17[v22 + 2] != 6)
            {
              if (v22-- <= 0) {
                goto LABEL_33;
              }
            }
            if (v55 - v20 + v22)
            {
              free(v16);
              unint64_t v24 = v18 + 1024;
              if (v55 < v18 + 1024) {
                unint64_t v24 = v55;
              }
              if (v24 >= 0xFFFF) {
                unint64_t v24 = 0xFFFFLL;
              }
              uint64_t v16 = (unsigned char *)(v55 - v24 + v22);
              int v54 = 1;
              goto LABEL_51;
            }
          }
LABEL_33:
          uint64_t v18 = v20;
        }
        while (v14 > v19);
      }
      free(v16);
    }
    uint64_t v16 = 0;
LABEL_50:
    int v54 = 0;
LABEL_51:
    uint64_t v49 = (*(uint64_t (**)(void, void, unsigned char *, void))&__src[2])(*((void *)&__src[3] + 1), *(void *)&__src[4], v16, 0);
    int v50 = sub_100039814((uint64_t)__src, *(uint64_t *)&__src[4], &v62);
    int v51 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], &v61);
    int v52 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], &v60);
    int v53 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], &v59);
    int v26 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], &v58);
    uint64_t v27 = v59;
    uint64_t v56 = v58;
    uint64_t v29 = v60;
    uint64_t v28 = v61;
    int v30 = sub_100039814((uint64_t)__src, *(uint64_t *)&__src[4], (uint64_t *)&v64);
    int v31 = sub_100039814((uint64_t)__src, *(uint64_t *)&__src[4], &v63);
    int v32 = sub_1000398D0((uint64_t)__src, *(uint64_t *)&__src[4], &v57);
    uint64_t v34 = v63;
    unint64_t v33 = v64;
    BOOL v35 = (unint64_t)v16 >= v64 + v63;
    int v36 = &v16[-v64 - v63];
    if (!v35 || v32 || v31 || v30 || v56 != v27 || v29 || v28 || !v54 || v26 || v53 || v52 || v51 || v50 || v49)
    {
      (*((void (**)(void, void))&__src[2] + 1))(*((void *)&__src[3] + 1), *(void *)&__src[4]);
LABEL_82:
      free(v11);
      return 0;
    }
    uint64_t v37 = v57;
    if (v57)
    {
      unint64_t v38 = malloc(v57 + 1);
      *((void *)&__src[1045] + 1) = v38;
      if (v38)
      {
        uint64_t v39 = (*((uint64_t (**)(void, void, void *, uint64_t))&__src[0] + 1))(*((void *)&__src[3] + 1), *(void *)&__src[4], v38, v37);
        *(unsigned char *)(*((void *)&__src[1045] + 1) + v39) = 0;
      }
    }
    *((void *)&__src[1044] + 1) = v36;
    int v40 = (char *)malloc(0xFF0uLL);
    uint64_t v41 = v36;
    uint64_t v42 = &v36[v34];
    uint64_t v43 = (*(uint64_t (**)(void, void, char *, void))&__src[2])(*((void *)&__src[3] + 1), *(void *)&__src[4], &v36[v34], 0);
    if (v43) {
      int v44 = -1;
    }
    else {
      int v44 = 0;
    }
    if (v33 && !v43)
    {
      while (1)
      {
        unint64_t v45 = v33 >= 0xFF0 ? 4080 : v33;
        if ((*((uint64_t (**)(void, void, char *, unint64_t))&__src[0] + 1))(*((void *)&__src[3] + 1), *(void *)&__src[4], v40, v45) != v45)break; {
        int v46 = sub_10003B098((void *)&__src[4] + 1, v40, v45);
        }
        int v44 = v46;
        v33 -= v45;
        if (!v33 || v46) {
          goto LABEL_86;
        }
      }
      int v44 = -1;
    }
LABEL_86:
    if (v40) {
      free(v40);
    }
    *(void *)&__src[1044] = v41;
    *(void *)&__src[1045] = v56;
    if ((*(uint64_t (**)(void, void, char *, void))&__src[2])(*((void *)&__src[3] + 1), *(void *)&__src[4], v42, 0))
    {
      int v25 = -1;
    }
    else
    {
      int v25 = v44;
    }
    uint64_t v3 = v48;
    if (!v48) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  int v25 = 0;
  if (v3) {
LABEL_43:
  }
    void *v3 = *((void *)&__src[1045] + 1);
LABEL_44:
  if (v25)
  {
    if (*((void *)&__src[1045] + 1)) {
      free(*((void **)&__src[1045] + 1));
    }
    goto LABEL_82;
  }
  memcpy(v11, __src, 0x4160uLL);
  return v11;
}

uint64_t sub_10003B098(void *a1, char *a2, unint64_t a3)
{
  if (!a1) {
    return 4294967192;
  }
  unint64_t v3 = a3;
  uint64_t v6 = (void *)a1[1];
  if (v6)
  {
    if (!a3) {
      return 0;
    }
  }
  else
  {
    long long v8 = (char *)malloc(0x1010uLL);
    if (!v8)
    {
      *a1 = 0;
      a1[1] = 0;
      return 4294967192;
    }
    uint64_t v6 = v8;
    *(void *)long long v8 = 0;
    *(_OWORD *)(v8 + 8) = xmmword_10007E240;
    *a1 = v8;
    a1[1] = v8;
    if (!v3) {
      return 0;
    }
  }
  unint64_t v9 = v6[1];
  while (v9)
  {
    uint64_t v10 = v6[2];
LABEL_13:
    if (v9 >= v3) {
      unsigned int v12 = v3;
    }
    else {
      unsigned int v12 = v9;
    }
    if (v12)
    {
      unint64_t v13 = (char *)v6 + v10 + 32;
      uint64_t v14 = v12;
      uint64_t v15 = a2;
      do
      {
        char v16 = *v15++;
        *v13++ = v16;
        --v14;
      }
      while (v14);
      unint64_t v9 = v6[1];
      uint64_t v10 = v6[2];
    }
    v9 -= v12;
    v6[1] = v9;
    unint64_t v6[2] = v10 + v12;
    a2 += v12;
    v3 -= v12;
    if (!v3) {
      return 0;
    }
  }
  unint64_t v11 = (char *)malloc(0x1010uLL);
  if (v11)
  {
    uint64_t v10 = 0;
    *(void *)unint64_t v11 = 0;
    *(_OWORD *)(v11 + 8) = xmmword_10007E240;
    void *v6 = v11;
    unint64_t v9 = 4080;
    uint64_t v6 = v11;
    a1[1] = v11;
    goto LABEL_13;
  }
  void *v6 = 0;
  return 4294967192;
}

void *amai_zipOpen()
{
  return amai_zipOpen2();
}

uint64_t amai_zipOpenNewFileInZip3(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, unsigned int a5, char *a6, unsigned int a7, char *__s, int a9, int a10, int a11, int a12, int a13, int a14, unsigned char *a15, uint64_t a16)
{
  uint64_t result = 4294967194;
  if (!a1) {
    return result;
  }
  if ((a9 & 0xFFFFFFF7) != 0) {
    return result;
  }
  if (*(_DWORD *)(a1 + 88) == 1)
  {
    uint64_t result = amai_zipCloseFileInZipRaw(a1, 0, 0);
    if (result) {
      return result;
    }
  }
  unsigned int v95 = a5;
  if (a2) {
    int v25 = a2;
  }
  else {
    int v25 = "-";
  }
  uint64_t v94 = a4;
  if (__s) {
    unsigned int v26 = strlen(__s);
  }
  else {
    unsigned int v26 = 0;
  }
  unsigned int v27 = strlen(v25);
  if (a3)
  {
    unint64_t v28 = *(void *)(a3 + 24);
    if (!v28)
    {
      uint64_t v29 = *(unsigned int *)(a3 + 20);
      uint64_t v30 = v29 - 80;
      if (v29 <= 0x50) {
        uint64_t v30 = *(unsigned int *)(a3 + 20);
      }
      if (v29 <= 0x7BC) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = v29 - 1980;
      }
      unint64_t v28 = ((32 * *(_DWORD *)(a3 + 4) + (*(_DWORD *)a3 >> 1))
           + ((unint64_t)*(unsigned int *)(a3 + 8) << 11)) | (((unint64_t)(*(_DWORD *)(a3 + 12) + 32 * *(_DWORD *)(a3 + 16) + 32) << 16)
                                                                   + (v31 << 25));
    }
  }
  else
  {
    unint64_t v28 = 0;
  }
  *(void *)(a1 + 16640) = v28;
  uint64_t v32 = 2 * ((a10 & 0xFFFFFFFE) == 8);
  *(void *)(a1 + 240) = v32;
  if (a10 == 1)
  {
    uint64_t v32 = 6;
  }
  else
  {
    if (a10 != 2) {
      goto LABEL_25;
    }
    v32 |= 4uLL;
  }
  *(void *)(a1 + 240) = v32;
LABEL_25:
  if (a15) {
    *(void *)(a1 + 240) = v32 | 1;
  }
  *(void *)(a1 + 16648) = 0;
  *(_DWORD *)(a1 + 16656) = 0;
  *(void *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 248) = a9;
  *(_DWORD *)(a1 + 252) = a11;
  uint64_t v33 = (*(uint64_t (**)(void, void))(a1 + 24))(*(void *)(a1 + 56), *(void *)(a1 + 64));
  *(void *)(a1 + 216) = v33;
  size_t v34 = a7 + v26 + v27 + 46;
  *(void *)(a1 + 232) = v34;
  BOOL v35 = malloc(v34);
  *(void *)(a1 + 224) = v35;
  *BOOL v35 = 33639248;
  v35[1] = 1310720;
  unint64_t v36 = *(void *)(a1 + 240);
  *((_WORD *)v35 + 4) = v36;
  if (v36 >= 0x10000) {
    *((_WORD *)v35 + 4) = -1;
  }
  unsigned int v37 = *(_DWORD *)(a1 + 248);
  *((_WORD *)v35 + 5) = v37;
  if (v37 >= 0x10000) {
    *((_WORD *)v35 + 5) = -1;
  }
  uint64_t v38 = 0;
  uint64_t v39 = v35 + 3;
  unint64_t v40 = *(void *)(a1 + 16640);
  do
  {
    unint64_t v41 = v40;
    *((unsigned char *)v39 + v38) = v40;
    v40 >>= 8;
    ++v38;
  }
  while (v38 != 4);
  if (v41 >= 0x100) {
    *uint64_t v39 = -1;
  }
  *((void *)v35 + 2) = 0;
  v35[6] = 0;
  *((_WORD *)v35 + 14) = v27;
  if (v27 >= 0x10000uLL) {
    *((_WORD *)v35 + 14) = -1;
  }
  *((_WORD *)v35 + 15) = a7;
  if (a7 >= 0x10000) {
    *((_WORD *)v35 + 15) = -1;
  }
  *((_WORD *)v35 + 16) = v26;
  if (v26 >= 0x10000) {
    *((_WORD *)v35 + 16) = -1;
  }
  *((_WORD *)v35 + 17) = 0;
  uint64_t v42 = v26;
  if (a3)
  {
    unint64_t v43 = *(void *)(a3 + 32);
    *((_WORD *)v35 + 18) = v43;
    if (v43 >= 0x10000) {
      *((_WORD *)v35 + 18) = -1;
    }
    uint64_t v44 = 0;
    unint64_t v45 = (_DWORD *)((char *)v35 + 38);
    unint64_t v46 = *(void *)(a3 + 40);
    do
    {
      unint64_t v47 = v46;
      *((unsigned char *)v45 + v44) = v46;
      v46 >>= 8;
      ++v44;
    }
    while (v44 != 4);
    if (v47 >= 0x100) {
      *unint64_t v45 = -1;
    }
  }
  else
  {
    *((_WORD *)v35 + 18) = 0;
    *(_DWORD *)((char *)v35 + 38) = 0;
  }
  uint64_t v48 = 0;
  uint64_t v49 = (_DWORD *)((char *)v35 + 42);
  unint64_t v50 = v33 - *(void *)(a1 + 16712);
  do
  {
    unint64_t v51 = v50;
    *((unsigned char *)v49 + v48) = v50;
    v50 >>= 8;
    ++v48;
  }
  while (v48 != 4);
  if (v51 >= 0x100) {
    *uint64_t v49 = -1;
  }
  if (v27)
  {
    for (uint64_t i = 0; i != v27; ++i)
      *(unsigned char *)(*(void *)(a1 + 224) + i + 46) = v25[i];
  }
  if (a7)
  {
    uint64_t v53 = v27 + 46;
    uint64_t v54 = a7;
    do
    {
      char v55 = *a6++;
      *(unsigned char *)(*(void *)(a1 + 224) + v53++) = v55;
      --v54;
    }
    while (v54);
  }
  if (v26)
  {
    unint64_t v56 = a7 + (unint64_t)v27 + 46;
    do
    {
      char v57 = *__s++;
      *(unsigned char *)(*(void *)(a1 + 224) + v56++) = v57;
      --v42;
    }
    while (v42);
  }
  if (!*(void *)(a1 + 224)) {
    return 4294967192;
  }
  v96[0] = 67324752;
  if ((*(uint64_t (**)(void, void, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v96, 4) != 4)goto LABEL_91; {
  LOWORD(v96[0]) = 20;
  }
  if ((*(uint64_t (**)(void, void, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v96, 2) != 2)goto LABEL_91; {
  uint64_t v58 = *(void *)(a1 + 64);
  }
  unint64_t v59 = *(void *)(a1 + 240);
  LOWORD(v96[0]) = v59;
  if (v59 >= 0x10000) {
    LOWORD(v96[0]) = -1;
  }
  if ((*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v58, v96, 2) != 2) {
    goto LABEL_91;
  }
  uint64_t v60 = *(void *)(a1 + 64);
  unsigned int v61 = *(_DWORD *)(a1 + 248);
  LOWORD(v96[0]) = v61;
  if (v61 >= 0x10000) {
    LOWORD(v96[0]) = -1;
  }
  if ((*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v60, v96, 2) != 2) {
    goto LABEL_91;
  }
  uint64_t v62 = 0;
  uint64_t v63 = *(void *)(a1 + 64);
  unint64_t v64 = *(void *)(a1 + 16640);
  do
  {
    unint64_t v65 = v64;
    *((unsigned char *)v96 + v62) = v64;
    v64 >>= 8;
    ++v62;
  }
  while (v62 != 4);
  if (v65 >= 0x100) {
    v96[0] = -1;
  }
  if ((*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v63, v96, 4) != 4) {
    goto LABEL_91;
  }
  v96[0] = 0;
  if ((*(uint64_t (**)(void, void, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v96, 4) != 4)goto LABEL_91; {
  v96[0] = 0;
  }
  if ((*(uint64_t (**)(void, void, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v96, 4) != 4)goto LABEL_91; {
  v96[0] = 0;
  }
  if ((*(uint64_t (**)(void, void, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v96, 4) != 4)goto LABEL_91; {
  uint64_t v66 = *(void *)(a1 + 64);
  }
  LOWORD(v96[0]) = v27;
  if (v27 >= 0x10000uLL) {
    LOWORD(v96[0]) = -1;
  }
  if ((*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v66, v96, 2) != 2) {
    goto LABEL_91;
  }
  uint64_t v67 = *(void *)(a1 + 64);
  LOWORD(v96[0]) = v95;
  if (v95 >= 0x10000) {
    LOWORD(v96[0]) = -1;
  }
  uint64_t v68 = (*(uint64_t (**)(void, uint64_t, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v67, v96, 2);
  BOOL v69 = v68 != 2;
  if (v68 == 2 && v27) {
    BOOL v69 = (*(uint64_t (**)(void, void, const char *, void))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v25, v27) != v27;
  }
  unsigned int v70 = v95;
  if (v95 && !v69)
  {
    if ((*(uint64_t (**)(void, void, uint64_t, void))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v94, v95) == v70)
    {
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 128) = 0x4000;
      *(void *)(a1 + 112) = 0;
      *(void *)(a1 + 120) = a1 + 256;
      *(void *)(a1 + 136) = 0;
      long long v71 = (_DWORD *)(a1 + 16656);
      long long v72 = a15;
      goto LABEL_97;
    }
LABEL_91:
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 128) = 0x4000;
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 120) = a1 + 256;
    uint64_t result = 0xFFFFFFFFLL;
    *(void *)(a1 + 136) = 0;
    long long v71 = (_DWORD *)(a1 + 16656);
    goto LABEL_92;
  }
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 128) = 0x4000;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = a1 + 256;
  *(void *)(a1 + 136) = 0;
  long long v71 = (_DWORD *)(a1 + 16656);
  long long v72 = a15;
  if (v69)
  {
    uint64_t result = 0xFFFFFFFFLL;
    goto LABEL_92;
  }
LABEL_97:
  if (*(_DWORD *)(a1 + 248) != 8 || *(_DWORD *)(a1 + 252)) {
    goto LABEL_99;
  }
  if (a12 < 0) {
    int v93 = a12;
  }
  else {
    int v93 = -a12;
  }
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  uint64_t result = deflateInit2_((z_streamp)(a1 + 96), a10, 8, v93, a13, a14, "1.2.12", 112);
  if (result)
  {
LABEL_92:
    v71[10] = 0;
    return result;
  }
  *(_DWORD *)(a1 + 208) = 1;
  long long v72 = a15;
LABEL_99:
  v71[10] = 0;
  if (!v72) {
    goto LABEL_107;
  }
  *long long v71 = 1;
  crc_table = get_crc_table();
  *(void *)(a1 + 16688) = crc_table;
  if (!dword_1000B8CD0++)
  {
    int v75 = time(0);
    srand(v75 ^ 0xBB40E64E);
  }
  sub_10003C46C(a15, a1 + 16664, (uint64_t)crc_table);
  for (uint64_t j = 0; j != 10; v99[j++] = ((unsigned __int16)((v78 & 0xFFFD ^ 3) * (v78 | 2)) >> 8) ^ (v77 >> 7))
  {
    unsigned int v77 = rand();
    unint64_t v78 = *(void *)(a1 + 16680);
    z_crc_t v79 = crc_table[(*(void *)(a1 + 16664) ^ (v77 >> 7))] ^ (*(void *)(a1 + 16664) >> 8);
    *(void *)(a1 + 16664) = v79;
    uint64_t v80 = 134775813 * (*(void *)(a1 + 16672) + v79) + 1;
    *(void *)(a1 + 16672) = v80;
    *(void *)(a1 + 16680) = crc_table[(v78 ^ BYTE3(v80))] ^ (v78 >> 8);
  }
  sub_10003C46C(a15, a1 + 16664, (uint64_t)crc_table);
  uint64_t v81 = 0;
  z_crc_t v82 = *(void *)(a1 + 16680);
  z_crc_t v83 = *(void *)(a1 + 16664);
  uint64_t v84 = *(void *)(a1 + 16672);
  do
  {
    __int16 v85 = (v82 & 0xFFFD ^ 3) * (v82 | 2);
    char v86 = v99[v81];
    z_crc_t v83 = crc_table[(v86 ^ v83)] ^ (v83 >> 8);
    *(void *)(a1 + 16664) = v83;
    uint64_t v84 = 134775813 * (v84 + v83) + 1;
    *(void *)(a1 + 16672) = v84;
    z_crc_t v82 = crc_table[(v82 ^ BYTE3(v84))] ^ (v82 >> 8);
    *(void *)(a1 + 16680) = v82;
    *((unsigned char *)v96 + v81++) = v86 ^ HIBYTE(v85);
  }
  while (v81 != 10);
  int v87 = ((v82 & 0xFFFFFFFD ^ 3) * (v82 | 2)) >> 8;
  z_crc_t v88 = crc_table[(v83 ^ BYTE2(a16))] ^ (v83 >> 8);
  *(void *)(a1 + 16664) = v88;
  uint64_t v89 = 134775813 * (v84 + v88) + 1;
  *(void *)(a1 + 16672) = v89;
  z_crc_t v90 = crc_table[(v82 ^ BYTE3(v89))] ^ (v82 >> 8);
  *(void *)(a1 + 16680) = v90;
  char v97 = v87 ^ BYTE2(a16);
  z_crc_t v91 = crc_table[v88 ^ BYTE3(a16)] ^ (v88 >> 8);
  *(void *)(a1 + 16664) = v91;
  uint64_t v92 = 134775813 * (v89 + v91) + 1;
  *(void *)(a1 + 16672) = v92;
  *(void *)(a1 + 16680) = crc_table[(v90 ^ BYTE3(v92))] ^ (v90 >> 8);
  char v98 = ((unsigned __int16)((v90 & 0xFFFD ^ 3) * (v90 | 2)) >> 8) ^ BYTE3(a16);
  *(_DWORD *)(a1 + 16696) = 12;
  if ((*(uint64_t (**)(void, void, _DWORD *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v96, 12) != 12)return 0xFFFFFFFFLL; {
LABEL_107:
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 88) = 1;
  return result;
}

uint64_t amai_zipCloseFileInZip(uint64_t a1)
{
  return amai_zipCloseFileInZipRaw(a1, 0, 0);
}

uint64_t amai_zipOpenNewFileInZip(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, unsigned int a5, char *a6, unsigned int a7, char *a8, int a9, int a10)
{
  return amai_zipOpenNewFileInZip3(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, 0, -15, 8, 0, 0, 0);
}

uint64_t amai_zipWriteInFileInZip(uint64_t a1, const Bytef *a2, uInt a3)
{
  if (!a1) {
    return 4294967194;
  }
  if (!*(_DWORD *)(a1 + 88)) {
    return 4294967194;
  }
  *(void *)(a1 + 96) = a2;
  *(_DWORD *)(a1 + 104) = a3;
  *(void *)(a1 + 16648) = crc32(*(void *)(a1 + 16648), a2, a3);
  while (*(_DWORD *)(a1 + 104))
  {
    unsigned int v4 = *(_DWORD *)(a1 + 128);
    if (v4
      || (uint64_t result = sub_10003BCC0(a1),
          unsigned int v4 = 0x4000,
          *(_DWORD *)(a1 + 128) = 0x4000,
          *(void *)(a1 + 120) = a1 + 256,
          result != -1))
    {
      if (*(_DWORD *)(a1 + 248) == 8 && !*(_DWORD *)(a1 + 252))
      {
        int v11 = *(_DWORD *)(a1 + 136);
        uint64_t result = deflate((z_streamp)(a1 + 96), 0);
        LODWORD(v7) = *(_DWORD *)(a1 + 136) - v11;
      }
      else
      {
        unsigned int v6 = *(_DWORD *)(a1 + 104);
        uint64_t v7 = v6 >= v4 ? v4 : v6;
        if (v7)
        {
          for (uint64_t i = 0; i != v7; ++i)
            *(unsigned char *)(*(void *)(a1 + 120) + i) = *(unsigned char *)(*(void *)(a1 + 96) + i);
          unsigned int v6 = *(_DWORD *)(a1 + 104);
          unsigned int v4 = *(_DWORD *)(a1 + 128);
          uint64_t v9 = v7;
        }
        else
        {
          uint64_t v9 = 0;
        }
        uint64_t result = 0;
        *(_DWORD *)(a1 + 104) = v6 - v7;
        *(_DWORD *)(a1 + 128) = v4 - v7;
        *(void *)(a1 + 96) += v9;
        uint64_t v10 = *(void *)(a1 + 120) + v9;
        *(void *)(a1 + 112) += v9;
        *(void *)(a1 + 120) = v10;
        *(void *)(a1 + 136) += v9;
      }
      *(_DWORD *)(a1 + 212) += v7;
      if (!result) {
        continue;
      }
    }
    return result;
  }
  return 0;
}

uint64_t sub_10003BCC0(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 212);
  if (*(_DWORD *)(a1 + 16656) && v2)
  {
    unint64_t v3 = (unsigned char *)(a1 + 256);
    uint64_t v4 = *(unsigned int *)(a1 + 212);
    do
    {
      unint64_t v5 = *(void *)(a1 + 16680);
      uint64_t v6 = *(void *)(a1 + 16688);
      uint64_t v7 = *(void *)(v6 + 8 * (*v3 ^ *(void *)(a1 + 16664))) ^ (*(void *)(a1 + 16664) >> 8);
      *(void *)(a1 + 16664) = v7;
      uint64_t v8 = 134775813 * (*(void *)(a1 + 16672) + v7) + 1;
      *(void *)(a1 + 16672) = v8;
      *(void *)(a1 + 16680) = *(void *)(v6 + 8 * (v5 ^ BYTE3(v8))) ^ (v5 >> 8);
      *v3++ ^= (unsigned __int16)((v5 & 0xFFFD ^ 3) * (v5 | 2)) >> 8;
      --v4;
    }
    while (v4);
  }
  if ((*(uint64_t (**)(void, void, uint64_t, void))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), a1 + 256, v2) == *(_DWORD *)(a1 + 212))uint64_t result = 0; {
  else
  }
    uint64_t result = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 212) = 0;
  return result;
}

uint64_t amai_zipCloseFileInZipRaw(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (!a1 || !*(_DWORD *)(a1 + 88)) {
    return 4294967194;
  }
  uint64_t v6 = 0;
  *(_DWORD *)(a1 + 104) = 0;
  if (*(_DWORD *)(a1 + 248) == 8)
  {
    if (*(_DWORD *)(a1 + 252))
    {
      uint64_t v6 = 0;
    }
    else
    {
      do
      {
        if (!*(_DWORD *)(a1 + 128))
        {
          int v33 = sub_10003BCC0(a1);
          *(_DWORD *)(a1 + 128) = 0x4000;
          *(void *)(a1 + 120) = a1 + 256;
          if (v33 == -1)
          {
            uint64_t v6 = 0xFFFFFFFFLL;
            goto LABEL_10;
          }
        }
        int v34 = *(_DWORD *)(a1 + 136);
        unsigned int v35 = deflate((z_streamp)(a1 + 96), 4);
        *(_DWORD *)(a1 + 212) += *(_DWORD *)(a1 + 136) - v34;
      }
      while (!v35);
      if (v35 == 1) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = v35;
      }
      if (v6) {
        goto LABEL_10;
      }
    }
  }
  if (*(_DWORD *)(a1 + 212))
  {
    if (sub_10003BCC0(a1) == -1) {
      uint64_t v6 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v6 = 0;
    }
  }
LABEL_10:
  if (*(_DWORD *)(a1 + 248) == 8 && !(*(_DWORD *)(a1 + 252) | v6))
  {
    uint64_t v6 = deflateEnd((z_streamp)(a1 + 96));
    *(_DWORD *)(a1 + 208) = 0;
  }
  if (!*(_DWORD *)(a1 + 252))
  {
    a3 = *(void *)(a1 + 16648);
    a2 = *(void *)(a1 + 112);
  }
  uint64_t v7 = 0;
  uint64_t v8 = *(void *)(a1 + 136);
  uint64_t v9 = *(int *)(a1 + 16696);
  uint64_t v10 = (_DWORD *)(*(void *)(a1 + 224) + 16);
  unint64_t v11 = a3;
  do
  {
    unint64_t v12 = v11;
    *((unsigned char *)v10 + v7) = v11;
    v11 >>= 8;
    ++v7;
  }
  while (v7 != 4);
  unint64_t v13 = v8 + v9;
  if (v12 >= 0x100) {
    *uint64_t v10 = -1;
  }
  uint64_t v14 = 0;
  uint64_t v15 = (_DWORD *)(*(void *)(a1 + 224) + 20);
  unint64_t v16 = v8 + v9;
  do
  {
    unint64_t v17 = v16;
    *((unsigned char *)v15 + v14) = v16;
    v16 >>= 8;
    ++v14;
  }
  while (v14 != 4);
  if (v17 >= 0x100) {
    *uint64_t v15 = -1;
  }
  if (*(_DWORD *)(a1 + 184) == 1) {
    *(_WORD *)(*(void *)(a1 + 224) + 36) = 1;
  }
  uint64_t v18 = 0;
  unint64_t v19 = (_DWORD *)(*(void *)(a1 + 224) + 24);
  unint64_t v20 = a2;
  do
  {
    unint64_t v21 = v20;
    *((unsigned char *)v19 + v18) = v20;
    v20 >>= 8;
    ++v18;
  }
  while (v18 != 4);
  if (v21 >= 0x100) {
    *unint64_t v19 = -1;
  }
  if (v6)
  {
    free(*(void **)(a1 + 224));
  }
  else
  {
    uint64_t v6 = sub_10003B098((void *)(a1 + 72), *(char **)(a1 + 224), *(void *)(a1 + 232));
    free(*(void **)(a1 + 224));
    if (!v6)
    {
      uint64_t v22 = (*(uint64_t (**)(void, void))(a1 + 24))(*(void *)(a1 + 56), *(void *)(a1 + 64));
      if ((*(uint64_t (**)(void, void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 216) + 14, 0))
      {
        goto LABEL_59;
      }
      uint64_t v23 = 0;
      uint64_t v24 = *(void *)(a1 + 64);
      do
      {
        unint64_t v25 = a3;
        *((unsigned char *)&v37 + v23) = a3;
        a3 >>= 8;
        ++v23;
      }
      while (v23 != 4);
      if (v25 >= 0x100) {
        int v37 = -1;
      }
      if ((*(uint64_t (**)(void, uint64_t, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v24, &v37, 4) != 4) {
        goto LABEL_59;
      }
      uint64_t v26 = 0;
      uint64_t v27 = *(void *)(a1 + 64);
      do
      {
        unint64_t v28 = v13;
        *((unsigned char *)&v38 + v26) = v13;
        v13 >>= 8;
        ++v26;
      }
      while (v26 != 4);
      if (v28 >= 0x100) {
        int v38 = -1;
      }
      if ((*(uint64_t (**)(void, uint64_t, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v27, &v38, 4) == 4)
      {
        uint64_t v29 = 0;
        uint64_t v30 = *(void *)(a1 + 64);
        do
        {
          unint64_t v31 = a2;
          *((unsigned char *)&v39 + v29) = a2;
          a2 >>= 8;
          ++v29;
        }
        while (v29 != 4);
        if (v31 >= 0x100) {
          int v39 = -1;
        }
        if ((*(uint64_t (**)(void, uint64_t, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v30, &v39, 4) == 4)unsigned int v32 = 0; {
        else
        }
          unsigned int v32 = -1;
      }
      else
      {
LABEL_59:
        unsigned int v32 = -1;
      }
      if ((*(uint64_t (**)(void, void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), v22, 0))
      {
        uint64_t v6 = 0xFFFFFFFFLL;
      }
      else
      {
        uint64_t v6 = v32;
      }
    }
  }
  ++*(void *)(a1 + 16720);
  *(_DWORD *)(a1 + 88) = 0;
  return v6;
}

uint64_t amai_zipClose(uint64_t a1, const char *a2)
{
  if (!a1) {
    return 4294967194;
  }
  unsigned int v2 = a2;
  if (*(_DWORD *)(a1 + 88) != 1)
  {
    unsigned int v4 = 0;
    if (!a2) {
      goto LABEL_7;
    }
LABEL_8:
    unsigned int v6 = strlen(v2);
    goto LABEL_9;
  }
  unsigned int v4 = amai_zipCloseFileInZipRaw(a1, 0, 0);
  if (v2) {
    goto LABEL_8;
  }
LABEL_7:
  unsigned int v2 = *(const char **)(a1 + 16728);
  if (v2) {
    goto LABEL_8;
  }
  unsigned int v6 = 0;
LABEL_9:
  uint64_t v7 = (*(uint64_t (**)(void, void))(a1 + 24))(*(void *)(a1 + 56), *(void *)(a1 + 64));
  if (!v4)
  {
    uint64_t v9 = *(void **)(a1 + 72);
    if (v9)
    {
      unint64_t v8 = 0;
      unsigned int v4 = 0;
      do
      {
        uint64_t v10 = v9[2];
        if (v4)
        {
          unsigned int v4 = -1;
        }
        else if (v10)
        {
          uint64_t v11 = (*(uint64_t (**)(void, void, void *))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v9 + 4);
          uint64_t v10 = v9[2];
          if (v11 == v10) {
            unsigned int v4 = 0;
          }
          else {
            unsigned int v4 = -1;
          }
        }
        else
        {
          unsigned int v4 = 0;
        }
        v8 += v10;
        uint64_t v9 = (void *)*v9;
      }
      while (v9);
      goto LABEL_21;
    }
    unsigned int v4 = 0;
  }
  unint64_t v8 = 0;
LABEL_21:
  unint64_t v12 = *(void **)(a1 + 72);
  if (v12)
  {
    do
    {
      unint64_t v13 = (void *)*v12;
      free(v12);
      unint64_t v12 = v13;
    }
    while (v13);
  }
  if (!v4)
  {
    int v31 = 101010256;
    if ((*(uint64_t (**)(void, void, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), &v31, 4) != 4)goto LABEL_53; {
    LOWORD(v31) = 0;
    }
    if ((*(uint64_t (**)(void, void, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), &v31, 2) != 2)goto LABEL_53; {
    LOWORD(v31) = 0;
    }
    if ((*(uint64_t (**)(void, void, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), &v31, 2) != 2)goto LABEL_53; {
    uint64_t v14 = *(void *)(a1 + 64);
    }
    unint64_t v15 = *(void *)(a1 + 16720);
    LOWORD(v31) = v15;
    if (v15 >= 0x10000) {
      LOWORD(v31) = -1;
    }
    if ((*(uint64_t (**)(void, uint64_t, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v14, &v31, 2) != 2) {
      goto LABEL_53;
    }
    uint64_t v16 = *(void *)(a1 + 64);
    unint64_t v17 = *(void *)(a1 + 16720);
    LOWORD(v31) = v17;
    if (v17 >= 0x10000) {
      LOWORD(v31) = -1;
    }
    if ((*(uint64_t (**)(void, uint64_t, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v16, &v31, 2) != 2) {
      goto LABEL_53;
    }
    uint64_t v18 = 0;
    uint64_t v19 = *(void *)(a1 + 64);
    do
    {
      unint64_t v20 = v8;
      *((unsigned char *)&v31 + v18) = v8;
      v8 >>= 8;
      ++v18;
    }
    while (v18 != 4);
    if (v20 >= 0x100) {
      int v31 = -1;
    }
    if ((*(uint64_t (**)(void, uint64_t, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v19, &v31, 4) != 4) {
      goto LABEL_53;
    }
    uint64_t v21 = 0;
    uint64_t v22 = *(void *)(a1 + 64);
    unint64_t v23 = v7 - *(void *)(a1 + 16712);
    do
    {
      unint64_t v24 = v23;
      *((unsigned char *)&v31 + v21) = v23;
      v23 >>= 8;
      ++v21;
    }
    while (v21 != 4);
    if (v24 >= 0x100) {
      int v31 = -1;
    }
    if ((*(uint64_t (**)(void, uint64_t, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v22, &v31, 4) == 4)
    {
      uint64_t v25 = *(void *)(a1 + 64);
      LOWORD(v31) = v6;
      if (v6 >= 0x10000) {
        LOWORD(v31) = -1;
      }
      uint64_t v26 = (*(uint64_t (**)(void, uint64_t, int *, uint64_t))(a1 + 16))(*(void *)(a1 + 56), v25, &v31, 2);
      if (v26 == 2) {
        unsigned int v4 = 0;
      }
      else {
        unsigned int v4 = -1;
      }
      if (v26 == 2 && v6)
      {
        if ((*(uint64_t (**)(void, void, const char *, void))(a1 + 16))(*(void *)(a1 + 56), *(void *)(a1 + 64), v2, v6) == v6)unsigned int v4 = 0; {
        else
        }
          unsigned int v4 = -1;
      }
    }
    else
    {
LABEL_53:
      unsigned int v4 = -1;
    }
  }
  int v27 = (*(uint64_t (**)(void, void))(a1 + 40))(*(void *)(a1 + 56), *(void *)(a1 + 64));
  if (v4) {
    unsigned int v28 = v4;
  }
  else {
    unsigned int v28 = -1;
  }
  if (v27) {
    uint64_t v5 = v28;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v29 = *(void **)(a1 + 16728);
  if (v29) {
    free(v29);
  }
  free((void *)a1);
  return v5;
}

unsigned char *sub_10003C46C(unsigned char *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 878082192;
  *(_OWORD *)a2 = xmmword_10007E230;
  *(void *)(a2 + 16) = 878082192;
  int v4 = *result;
  if (*result)
  {
    uint64_t v5 = result + 1;
    unint64_t v6 = 305419896;
    uint64_t v7 = 591751049;
    do
    {
      unint64_t v6 = *(void *)(a3 + 8 * (v4 ^ v6)) ^ (v6 >> 8);
      uint64_t v7 = 134775813 * (v7 + v6) + 1;
      *(void *)a2 = v6;
      *(void *)(a2 + 8) = v7;
      unint64_t v3 = *(void *)(a3 + 8 * (v3 ^ BYTE3(v7))) ^ (v3 >> 8);
      *(void *)(a2 + 16) = v3;
      int v8 = *v5++;
      int v4 = v8;
    }
    while (v8);
  }
  return result;
}

uint64_t _AMPortDFUModeDeviceCreate(uint64_t a1, uint64_t a2, int a3)
{
  pthread_once(&stru_1000B8828, (void (*)(void))sub_10003C580);
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v6 = _AMDFUModeDeviceCreate((uint64_t)kCFAllocatorDefault, a2, a3);
    if (v6) {
      *(void *)(Instance + 48) = v6;
    }
    else {
      return 0;
    }
  }
  return Instance;
}

uint64_t sub_10003C580()
{
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1000B8CD8 = result;
  return result;
}

void sub_10003C5A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMRLog(7, @"%s: %p", a3, a4, a5, a6, a7, a8, (char)"_AMPortDFUModeDeviceFinalize");
  uint64_t v9 = *(const void **)(a1 + 48);
  if (v9)
  {
    CFRelease(v9);
  }
}

CFStringRef sub_10003C614(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<Port DFU device %p>", a1);
}

CFStringRef sub_10003C658(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<AMPortDFUModeDevice %p>", a1);
}

long long *sub_10003C698()
{
  return &xmmword_1000B8CE0;
}

uint64_t _AMRestoreErrorForErrno(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = 16;
  if (a1 > 0x3D) {
    goto LABEL_8;
  }
  if (((1 << a1) & 0x2060000001800020) != 0)
  {
    a2 = 43;
LABEL_4:
    AMRLog(7, @"untranslated errno=%d", a3, a4, a5, a6, a7, a8, a1);
    return a2;
  }
  if (a1 == 12) {
    return 18;
  }
  if (a1 != 13)
  {
LABEL_8:
    if (a1 == 1) {
      return v9;
    }
    if (a1 == 2) {
      return 17;
    }
    goto LABEL_4;
  }
  return v9;
}

void AMRLog(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void AMRLogWithFilePath(uint64_t a1, uint64_t a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (dword_1000B8850 >= (int)a1)
  {
    Boolean keyExistsAndHasValidFormat = 0;
    CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
    CFStringAppendFormatAndArguments(Mutable, 0, a3, &a9);
    AppBooleanCFStringRef Value = CFPreferencesGetAppBooleanValue(@"LogFilePaths", kCFPreferencesCurrentApplication, &keyExistsAndHasValidFormat);
    if (dword_1000B8D1C || keyExistsAndHasValidFormat && AppBooleanValue) {
      CFStringAppendFormat(Mutable, 0, @" File:'%@'", a2);
    }
    AMRLog(a1, @"%@", v14, v15, v16, v17, v18, v19, (char)Mutable);
    CFRelease(Mutable);
  }
}

uint64_t _AMRestoreGetNumberOFDeviceIDsToMatch()
{
  return qword_1000B8838;
}

char *_AMRestoreGetDeviceIDToMatch(unsigned int a1)
{
  if (qword_1000B8838 <= (unint64_t)a1) {
    return 0;
  }
  else {
    return (char *)off_1000B8840 + 12 * a1;
  }
}

uint64_t parseNumTokenValue(const char *a1, _DWORD *a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  *__error() = 0;
  *a2 = strtol(a1, 0, 16);
  if (*__error()) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t parseNum64TokenValue(const char *a1, unint64_t *a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  *__error() = 0;
  *a2 = strtoull(a1, 0, 16);
  if (*__error()) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t parseStringTokenValue(uint64_t a1, CFStringRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (*(unsigned char *)a1 == 91 && (uint64_t v10 = a1 + 1, (v11 = strchr((char *)(a1 + 1), 93)) != 0))
  {
    CFStringRef v12 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)(a1 + 1), (CFIndex)&v11[-v10], 0x8000100u, 0);
    uint64_t result = 0;
    *a2 = v12;
  }
  else
  {
    AMRLog(3, @"string value '%s' not formatted correctly", a3, a4, a5, a6, a7, a8, a1);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t parseKeyValueIntoDeviceInfo(char *__s2, const char *a2, uint64_t a3)
{
  if (!strcmp("CPID", __s2))
  {
    unint64_t v13 = a2;
    uint64_t v14 = (_DWORD *)a3;
LABEL_18:
    return parseNumTokenValue(v13, v14);
  }
  if (!strcmp("BDID", __s2))
  {
    uint64_t v14 = (_DWORD *)(a3 + 4);
LABEL_17:
    unint64_t v13 = a2;
    goto LABEL_18;
  }
  if (!strcmp("SCEP", __s2))
  {
    uint64_t v14 = (_DWORD *)(a3 + 8);
    goto LABEL_17;
  }
  if (!strcmp("SRNM", __s2))
  {
    uint64_t v15 = (CFStringRef *)(a3 + 24);
    goto LABEL_25;
  }
  if (strcmp("IBFL", __s2))
  {
    if (strcmp("IMEI", __s2))
    {
      if (!strcmp("IBEC", __s2))
      {
        uint64_t v14 = (_DWORD *)(a3 + 12);
      }
      else
      {
        if (!strcmp("ECID", __s2))
        {
          return parseNum64TokenValue(a2, (unint64_t *)(a3 + 72));
        }
        if (!strcmp("CPFM", __s2))
        {
          int v22 = 0;
          uint64_t result = parseNumTokenValue(a2, &v22);
          char v17 = v22;
          *(unsigned char *)(a3 + 88) = (v22 & 2) != 0;
          *(unsigned char *)(a3 + 89) = v17 & 1;
          *(unsigned char *)(a3 + 90) = (v17 & 4) != 0;
          return result;
        }
        if (strcmp("SDOM", __s2))
        {
          if (!strcmp("SIKA", __s2))
          {
            uint64_t v18 = *(const void **)(a3 + 96);
            if (v18) {
              CFRelease(v18);
            }
            int valuePtr = 0;
            unsigned int v19 = parseNumTokenValue(a2, &valuePtr);
            CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
            *(void *)(a3 + 96) = v20;
            if (v20) {
              return v19;
            }
            else {
              return 18;
            }
          }
          else
          {
            if (strcmp("epochs", __s2)) {
              return 0;
            }
            strlen(a2);
            uint64_t result = AMSupportCopyDataFromAsciiEncodedHex();
            *(void *)(a3 + 64) = result;
            if (result)
            {
              if (CFDataGetLength((CFDataRef)result) == 8) {
                return 0;
              }
              CFRelease(*(CFTypeRef *)(a3 + 64));
              *(void *)(a3 + 64) = 0;
              return 0xFFFFFFFFLL;
            }
          }
          return result;
        }
        uint64_t v14 = (_DWORD *)(a3 + 84);
      }
      goto LABEL_17;
    }
    uint64_t v15 = (CFStringRef *)(a3 + 40);
LABEL_25:
    return parseStringTokenValue((uint64_t)a2, v15, v6, v7, v8, v9, v10, v11);
  }
  uint64_t result = parseNumTokenValue(a2, (_DWORD *)(a3 + 16));
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *(int16x4_t *)v16.i8 = vdup_n_s16(*(unsigned __int8 *)(a3 + 16));
  *(unsigned char *)(a3 + 95) = 1;
  *(int8x8_t *)v16.i8 = vand_s8(*(int8x8_t *)v16.i8, (int8x8_t)0x20000400080010);
  *(_DWORD *)(a3 + 91) = vmovn_s16(v16).u32[0];
  return result;
}

uint64_t _legacy_AMRestoreGetDeviceMapEntryForHardware(const __CFDictionary *a1, _DWORD *a2, char *a3)
{
  CFStringRef Value = CFDictionaryGetValue(a1, @"FirmwareDirectory");
  if (sub_10003CDBC((uint64_t)Value, a2, (uint64_t)a3)) {
    return 1;
  }
  uint64_t v8 = CFDictionaryGetValue(a1, @"RestoreBundlePath");
  if (v8)
  {
    CFStringRef v15 = sub_10003D1C8((uint64_t)v8);
    if (v15)
    {
      CFStringRef v16 = v15;
      int v17 = sub_10003D274((const __CFArray *)v15, a2, a3);
      CFRelease(v16);
      if (v17) {
        return 1;
      }
    }
  }
  AMRLog(4, @"unable to find device map entry for 0x%08x 0x%08x 0x%08x", v9, v10, v11, v12, v13, v14, *a2);
  return 0;
}

uint64_t sub_10003CDBC(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  if (a1)
  {
    CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%cdevice_map.txt", a1, 47);
    bzero(buffer, 0x400uLL);
    CFStringGetFileSystemRepresentation(v5, buffer, 1024);
    int v6 = open(buffer, 0, 0);
    if (v6 == -1)
    {
      uint64_t v11 = __error();
      char v12 = strerror(*v11);
      AMRLogWithFilePath(3, (uint64_t)v5, @"unable to open device_map.txt: %s", v13, v14, v15, v16, v17, v12);
      CFRelease(v5);
      goto LABEL_60;
    }
    int v7 = v6;
    memset(&v45, 0, sizeof(v45));
    if (fstat(v6, &v45) != -1)
    {
      off_t st_size = v45.st_size;
      uint64_t v9 = (char *)malloc_type_malloc(v45.st_size + 1, 0x448EBDB2uLL);
      if (!v9) {
        goto LABEL_11;
      }
      if (read(v7, v9, st_size) == st_size)
      {
        v9[st_size] = 0;
        goto LABEL_11;
      }
      uint64_t v18 = __error();
      char v19 = strerror(*v18);
      AMRLogWithFilePath(3, (uint64_t)v5, @"unable to read device_map.txt: %s", v20, v21, v22, v23, v24, v19);
      free(v9);
    }
    uint64_t v9 = 0;
LABEL_11:
    close(v7);
    CFRelease(v5);
    if (v9)
    {
      uint64_t v44 = v9;
      while (1)
      {
        if (!*v9)
        {
LABEL_58:
          uint64_t v10 = 0;
          goto LABEL_59;
        }
        *(void *)(a3 + 160) = 0;
        *(_OWORD *)(a3 + 128) = 0u;
        *(_OWORD *)(a3 + 144) = 0u;
        *(_OWORD *)(a3 + 96) = 0u;
        *(_OWORD *)(a3 + 112) = 0u;
        *(_OWORD *)(a3 + 64) = 0u;
        *(_OWORD *)(a3 + 80) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
        *(_OWORD *)(a3 + 48) = 0u;
        *(_OWORD *)a3 = 0u;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_DWORD *)(a3 + 84) = 1;
        if (*v9 == 48)
        {
          *(_WORD *)buffer = 0;
          LOWORD(v45.st_dev) = 0;
          unsigned __int16 v46 = 0;
          if (sscanf(v9, "%hx %hx %hx %15s", buffer, &v45, &v46, a3 + 104) == 4)
          {
            unsigned int v25 = v46;
          }
          else
          {
            unsigned int v25 = 0;
            *(_WORD *)buffer = 0;
            LOWORD(v45.st_dev) = 0;
            unsigned __int16 v46 = 0;
          }
          uint64_t v38 = 0;
          *(_DWORD *)a3 = 35072;
          *(_DWORD *)(a3 + 8) = v25;
          unsigned int v39 = v25 >> 8;
          while ((unsigned __int16)word_10007E2E8[v38] != v39)
          {
            v38 += 2;
            if (v38 == 12)
            {
              int v40 = 0xFFFF;
              goto LABEL_50;
            }
          }
          int v40 = (unsigned __int16)word_10007E2E8[v38 + 1];
LABEL_50:
          *(_DWORD *)(a3 + 4) = v40;
          unint64_t v41 = strchr(v9, 10);
          uint64_t v9 = v41 ? v41 + 1 : 0;
          int v37 = 35072;
        }
        else
        {
          uint64_t v26 = a2;
          do
          {
            do
            {
              int v27 = v9;
              unsigned int v29 = *v9++;
              unsigned int v28 = v29;
            }
            while (v29 == 32);
            uint64_t v30 = 0;
            int v31 = 0;
            while (v28 > 0x20 || ((1 << v28) & 0x100000401) == 0)
            {
              if (v31) {
                BOOL v32 = 0;
              }
              else {
                BOOL v32 = v28 == 58;
              }
              if (v32) {
                int v31 = &v27[v30];
              }
              unsigned int v28 = v27[++v30];
            }
            if (v31)
            {
              char v33 = *v31;
              *int v31 = 0;
              parseKeyValueIntoDeviceInfo(v27, v31 + 1, a3);
              *int v31 = v33;
            }
            else if (v30)
            {
              if (v28 != 10 && v28)
              {
                strlcpy((char *)(a3 + 136), v27, 0x20uLL);
                *(unsigned char *)(a3 + v30 + 136) = 0;
              }
              else
              {
                __strlcpy_chk();
                *(unsigned char *)(a3 + v30 + 104) = 0;
              }
            }
            uint64_t v9 = &v27[v30];
            int v34 = v27[v30];
          }
          while (v34 != 10 && v34 != 0);
          uint64_t v36 = (uint64_t)(v27[v30] ? v27 + 1 : v27);
          uint64_t v9 = (char *)(v36 + v30);
          int v37 = *(_DWORD *)a3;
          a2 = v26;
        }
        if (v37 == *a2 && *(_DWORD *)(a3 + 4) == a2[1] && *(_DWORD *)(a3 + 84) == a2[21]) {
          break;
        }
        if (!v9) {
          goto LABEL_58;
        }
      }
      uint64_t v10 = 1;
LABEL_59:
      uint64_t v42 = v44;
      goto LABEL_61;
    }
LABEL_60:
    uint64_t v42 = 0;
    uint64_t v10 = 0;
LABEL_61:
    free(v42);
    return v10;
  }
  return 0;
}

CFStringRef sub_10003D1C8(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  CFStringRef v1 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%cRestore.plist", a1, 47);
  CFStringRef v8 = v1;
  if (v1)
  {
    int v9 = _AMRestoreCreateCFDictionaryWithContentsOfFile(v1, &theDict, v2, v3, v4, v5, v6, v7);
    CFRelease(v8);
    if (v9)
    {
      return 0;
    }
    else
    {
      CFDictionaryRef v10 = theDict;
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"DeviceMap");
      CFStringRef v8 = Value;
      if (Value) {
        CFRetain(Value);
      }
      CFRelease(v10);
    }
  }
  return v8;
}

uint64_t sub_10003D274(const __CFArray *a1, _DWORD *a2, char *a3)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v7 = Count;
  CFIndex v8 = 0;
  unsigned int v25 = a3 + 84;
  int v9 = (int *)(a3 + 4);
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v8);
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *((_OWORD *)a3 + 3) = 0u;
    *((_OWORD *)a3 + 4) = 0u;
    *((_OWORD *)a3 + 5) = 0u;
    *((void *)a3 + 12) = 0;
    *((_DWORD *)a3 + 21) = 1;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"DeviceReleaseNumber");
    if (Value)
    {
      unsigned __int16 valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberSInt16Type, &valuePtr);
      uint64_t v12 = 0;
      unsigned int v13 = valuePtr;
      *(_DWORD *)a3 = 35072;
      *((_DWORD *)a3 + 2) = v13;
      unsigned int v14 = v13 >> 8;
      while ((unsigned __int16)word_10007E2E8[v12] != v14)
      {
        v12 += 2;
        if (v12 == 12)
        {
          int v15 = 0xFFFF;
          goto LABEL_17;
        }
      }
      int v15 = (unsigned __int16)word_10007E2E8[v12 + 1];
LABEL_17:
      int *v9 = v15;
    }
    else
    {
      CFNumberRef v16 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"CPID");
      if (v16) {
        CFNumberGetValue(v16, kCFNumberSInt32Type, a3);
      }
      CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"BDID");
      if (v17) {
        CFNumberGetValue(v17, kCFNumberSInt32Type, a3 + 4);
      }
      CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"SDOM");
      if (v18) {
        CFNumberGetValue(v18, kCFNumberSInt32Type, v25);
      }
      CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"SCEP");
      if (v19) {
        CFNumberGetValue(v19, kCFNumberSInt32Type, a3 + 8);
      }
    }
    if (*(_DWORD *)a3 == *a2 && *v9 == a2[1] && *v25 == a2[21]) {
      break;
    }
    if (++v8 == v7) {
      return 0;
    }
  }
  CFStringRef v21 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"BoardConfig");
  uint64_t v22 = a3 + 104;
  if (v21) {
    CFStringGetCString(v21, v22, 32, 0x8000100u);
  }
  else {
    *uint64_t v22 = 0;
  }
  CFStringRef v23 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"Platform");
  uint64_t v24 = a3 + 136;
  if (v23) {
    CFStringGetCString(v23, v24, 32, 0x8000100u);
  }
  else {
    *uint64_t v24 = 0;
  }
  return 1;
}

uint64_t _AMRestoreGetDeviceMapEntryForHardware(const __CFDictionary *a1, _DWORD *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0;
  if (AMRestoreOptionsAreLegacy(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8))
  {
    return _legacy_AMRestoreGetDeviceMapEntryForHardware(a1, a2, a3);
  }
  if (AMRAuthInstallCopyPathToFirmware(a1, (CFStringRef *)&cf))
  {
    AMRLog(3, @"Failed to get path to Firmware directory", v12, v13, v14, v15, v16, v17, v29);
  }
  else
  {
    if (sub_10003CDBC((uint64_t)cf, a2, (uint64_t)a3)
      || (CFNumberRef Value = CFDictionaryGetValue(a1, @"RestoreBundlePath")) != 0
      && (CFStringRef v26 = sub_10003D1C8((uint64_t)Value)) != 0
      && (CFStringRef v27 = v26, v28 = sub_10003D274((const __CFArray *)v26, a2, a3), CFRelease(v27), v28))
    {
      uint64_t v18 = 1;
      goto LABEL_10;
    }
    AMRLog(4, @"unable to find device map entry for 0x%08x 0x%08x 0x%08x", v20, v21, v22, v23, v24, v25, *a2);
  }
  uint64_t v18 = 0;
LABEL_10:
  if (cf) {
    CFRelease(cf);
  }
  return v18;
}

uint64_t AMRestoreOptionsAreLegacy(const __CFDictionary *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1, @"IsLegacy");
    if (Value)
    {
      return CFBooleanGetValue(Value);
    }
    else
    {
      return !CFDictionaryGetValue(a1, @"AuthInstallRestoreBehavior")
          && CFDictionaryGetValue(a1, @"AuthInstallVariant") == 0;
    }
  }
  else
  {
    AMRLog(3, @"Can't check for legacy options on NULL dictionary", a3, a4, a5, a6, a7, a8, v11);
    return 1;
  }
}

CFStringRef AMRestoreGetTransformedDFUType(const __CFString *a1)
{
  if (CFEqual(a1, @"Production")) {
    return @"RELEASE";
  }
  if (CFEqual(a1, @"Development")) {
    return @"DEVELOPMENT";
  }
  if (CFStringCompare(a1, @"Debug", 0)) {
    return a1;
  }
  return @"DEBUG";
}

CFStringRef AMRestoreGetTransformedFirmwareTypeValue(const __CFString *a1)
{
  if (CFEqual(a1, @"Production")) {
    return @"production";
  }
  if (CFEqual(a1, @"Development")) {
    return @"firmwaredevelopment";
  }
  if (CFEqual(a1, @"Factory - SA")) {
    return @"factorysa";
  }
  if (CFEqual(a1, @"Factory - FA")) {
    return @"factoryfa";
  }
  if (CFStringCompare(a1, @"Debug", 0)) {
    return a1;
  }
  return @"debug";
}

uint64_t _AMRestoreCopyDeviceMapPlistEntryForHardware(const __CFDictionary *a1, int *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2 && a3)
  {
    uint64_t v61 = 0;
    memset(v60, 0, sizeof(v60));
    int DeviceMapEntryForHardware = _AMRestoreGetDeviceMapEntryForHardware(a1, a2, (char *)v60, a4, a5, a6, a7, a8);
    int v18 = *a2;
    if (DeviceMapEntryForHardware)
    {
      AMRLog(7, @"found device map entry for 0x%08x 0x%08x 0x%08x. boardConfig=%s platform=%s", v12, v13, v14, v15, v16, v17, v18);
      CFStringRef v19 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v60[6] + 8, 0x8000100u);
      if (v19)
      {
        CFStringRef v26 = v19;
        CFBooleanRef Value = CFDictionaryGetValue(a1, @"FirmwareDirectory");
        if (!Value)
        {
          AMRLog(4, @"%s: firmwareDirectory not in options", v28, v29, v30, v31, v32, v33, (char)"_AMRestoreCopyDeviceMapPlistEntryForHardware");
          uint64_t v56 = 0;
LABEL_23:
          CFRelease(v26);
          return v56;
        }
        CFDictionaryRef theDict = 0;
        char v58 = (char)Value;
        CFStringRef v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%cdevice_map.plist");
        int v41 = _AMRestoreCreateCFDictionaryWithContentsOfFile(v34, &theDict, v35, v36, v37, v38, v39, v40);
        CFDictionaryRef v47 = theDict;
        if (v41 || !theDict)
        {
          AMRLogWithFilePath(3, (uint64_t)v34, @"device_map.plist file not found", v42, v43, v44, v45, v46, v58);
          uint64_t v55 = 0;
          uint64_t v56 = 0;
          if (!v47)
          {
LABEL_21:
            if (v34) {
              CFRelease(v34);
            }
            goto LABEL_23;
          }
        }
        else
        {
          uint64_t v48 = CFDictionaryGetValue(theDict, v26);
          if (v48)
          {
            *a3 = CFRetain(v48);
            uint64_t v55 = 1;
          }
          else
          {
            AMRLog(4, @"boardConfigDict is NULL", v49, v50, v51, v52, v53, v54, v58);
            uint64_t v55 = 0;
          }
        }
        CFRelease(v47);
        uint64_t v56 = v55;
        goto LABEL_21;
      }
      AMRLog(4, @"%s: unable to create c-string", v20, v21, v22, v23, v24, v25, (char)"_AMRestoreCopyDeviceMapPlistEntryForHardware");
    }
    else
    {
      AMRLog(4, @"unable to find device map entry for 0x%08x 0x%08x 0x%08x", v12, v13, v14, v15, v16, v17, v18);
    }
  }
  else
  {
    AMRLog(4, @"%s: bad paramater", (uint64_t)a3, a4, a5, a6, a7, a8, (char)"_AMRestoreCopyDeviceMapPlistEntryForHardware");
  }
  return 0;
}

uint64_t AMRestoreDeviceIsBootstrapOnly(const __CFDictionary *a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef theDict = 0;
  if (a1 && a2)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1, @"ApBootstrapOnly");
    if (!Value || (CFBooleanRef v16 = Value, v17 = CFGetTypeID(Value), v17 != CFBooleanGetTypeID()))
    {
      CFBooleanRef v16 = kCFBooleanFalse;
      int v18 = _AMRestoreCopyDeviceMapPlistEntryForHardware(a1, a2, (CFTypeRef *)&theDict, v11, v12, v13, v14, v15);
      CFDictionaryRef v19 = theDict;
      if (v18 && theDict)
      {
        CFBooleanRef v20 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ApBootstrapOnly");
        if (v20) {
          CFBooleanRef v16 = v20;
        }
        CFDictionaryRef v19 = theDict;
      }
      if (v19) {
        CFRelease(v19);
      }
    }
  }
  else
  {
    CFBooleanRef v16 = kCFBooleanFalse;
    AMRLog(4, @"%s: bad paramater", a3, a4, a5, a6, a7, a8, (char)"AMRestoreDeviceIsBootstrapOnly");
  }
  return CFBooleanGetValue(v16);
}

CFArrayRef _AMRestoreCopyManifestForNORImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    CFStringRef v13 = @"Can't copy manifest since NOR image path is null";
LABEL_8:
    AMRLog(3, v13, a3, a4, a5, a6, a7, a8, v15);
    return 0;
  }
  CFDataRef data = 0;
  char v15 = a1;
  CFStringRef v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%cmanifest");
  if (!v8)
  {
    CFStringRef v13 = @"Invalid manifest file path";
    goto LABEL_8;
  }
  CFStringRef v9 = v8;
  _AMRestoreCreateCFDataWithContentsOfFile(v8, &data);
  CFRelease(v9);
  CFDataRef v10 = data;
  if (!data) {
    return 0;
  }
  CFStringRef v11 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, data, 0x8000100u);
  CFRelease(v10);
  if (!v11) {
    return 0;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, v11, @"\n");
  CFRelease(v11);
  return ArrayBySeparatingStrings;
}

uint64_t _AMRestoreCreateCFDataWithContentsOfFile(const __CFString *a1, CFDataRef *a2)
{
  bzero(buffer, 0x400uLL);
  if (!a1)
  {
    AMRLog(3, @"Can't create CFData from file path since path was null: %s", v4, v5, v6, v7, v8, v9, (char)"_AMRestoreCreateCFDataWithContentsOfFile");
    CFStringRef v13 = 0;
    int v11 = -1;
    uint64_t v21 = 1;
LABEL_26:
    AMRLog(8, @"%s failed to load %s: %d", v22, v23, v24, v25, v26, v27, (char)"_AMRestoreCreateCFDataWithContentsOfFile");
    goto LABEL_27;
  }
  CFStringGetFileSystemRepresentation(a1, buffer, 1024);
  *a2 = 0;
  int v10 = open(buffer, 0);
  int v11 = v10;
  if (v10 == -1)
  {
    uint64_t v28 = __error();
    uint64_t v21 = _AMRestoreErrorForErrno(*v28, 12, v29, v30, v31, v32, v33, v34);
    uint64_t v35 = __error();
    char v36 = strerror(*v35);
    AMRLogWithFilePath(3, (uint64_t)a1, @"open failed: %s", v37, v38, v39, v40, v41, v36);
    if (v21 != 17)
    {
LABEL_13:
      CFStringRef v13 = 0;
      goto LABEL_16;
    }
    memset(&v94, 0, sizeof(v94));
    if (lstat(buffer, &v94))
    {
      CFStringRef v48 = @"Looks like the file we were expecting was deleted out from under us.";
    }
    else if ((~v94.st_mode & 0xA000) != 0)
    {
      CFStringRef v48 = @"lstat(2) says the file exists, even though open(2) failed to find it. Mabye a race condition?";
    }
    else
    {
      bzero(v95, 0x400uLL);
      if (readlink(buffer, v95, 0x400uLL) != -1)
      {
        AMRLog(7, @"The file actually exists but is a symlink to %s, which is not there.", v42, v43, v44, v45, v46, v47, (char)v95);
        uint64_t v21 = 62;
LABEL_25:
        CFStringRef v13 = 0;
        int v11 = -1;
        goto LABEL_26;
      }
      char v92 = -1;
      CFStringRef v48 = @"The file is actually a symlink but appears to be corrupted. readlink(2) returned %zd.";
    }
    AMRLog(7, v48, v42, v43, v44, v45, v46, v47, v92);
    uint64_t v21 = 17;
    goto LABEL_25;
  }
  memset(&v93, 0, sizeof(v93));
  if (fstat(v10, &v93) == -1)
  {
    uint64_t v49 = __error();
    uint64_t v21 = _AMRestoreErrorForErrno(*v49, 11, v50, v51, v52, v53, v54, v55);
    uint64_t v56 = __error();
    char v57 = strerror(*v56);
    AMRLogWithFilePath(3, (uint64_t)a1, @"fstat failed: %s", v58, v59, v60, v61, v62, v57);
    goto LABEL_13;
  }
  off_t st_size = v93.st_size;
  CFStringRef v13 = (UInt8 *)malloc_type_malloc(v93.st_size, 0x40CDC84BuLL);
  if (v13)
  {
    if (read(v11, v13, st_size) == st_size)
    {
      CFDataRef v14 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v13, st_size, kCFAllocatorMalloc);
      *a2 = v14;
      if (v14)
      {
        uint64_t v21 = 0;
LABEL_28:
        close(v11);
        goto LABEL_29;
      }
      AMRLog(3, @"unable to create CFData", v15, v16, v17, v18, v19, v20, 0);
      uint64_t v21 = 18;
      goto LABEL_26;
    }
    unsigned int v77 = __error();
    uint64_t v21 = _AMRestoreErrorForErrno(*v77, 13, v78, v79, v80, v81, v82, v83);
    uint64_t v84 = __error();
    char v85 = strerror(*v84);
    AMRLogWithFilePath(3, (uint64_t)a1, @"read failed: %s", v86, v87, v88, v89, v90, v85);
  }
  else
  {
    uint64_t v63 = __error();
    uint64_t v21 = _AMRestoreErrorForErrno(*v63, 18, v64, v65, v66, v67, v68, v69);
    unsigned int v70 = __error();
    strerror(*v70);
    AMRLog(3, @"malloc(%zu) failed: %s", v71, v72, v73, v74, v75, v76, st_size);
  }
LABEL_16:
  if (v21) {
    goto LABEL_26;
  }
LABEL_27:
  if (v11 != -1) {
    goto LABEL_28;
  }
LABEL_29:
  if (v13 && !*a2) {
    free(v13);
  }
  return v21;
}

uint64_t _AMRestoreCreateCFDictionaryWithContentsOfFile(const __CFString *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    CFDataRef data = 0;
    uint64_t v10 = _AMRestoreCreateCFDataWithContentsOfFile(a1, &data);
    if (v10)
    {
      uint64_t v16 = v10;
      AMRLogWithFilePath(3, (uint64_t)a1, @"unable to create data from file: %d", v11, v12, v13, v14, v15, v10);
    }
    else
    {
      CFErrorRef error = 0;
      CFDataRef v17 = data;
      CFPropertyListRef v18 = CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, 0, &error);
      *a2 = v18;
      if (v18) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = 19;
      }
      if (error)
      {
        AMRLog(3, @"%s: CFPropertyListCreateFromXMLData: %@", v19, v20, v21, v22, v23, v24, (char)"_AMRestoreCreateCFDictionaryWithContentsOfFile");
        CFRelease(error);
      }
      if (v17) {
        CFRelease(v17);
      }
    }
  }
  else
  {
    AMRLog(3, @"Can't load dictionary since file path is NULL", a3, a4, a5, a6, a7, a8, v26);
    return 1;
  }
  return v16;
}

char *_AMRestoreCopyDeviceInfo(uint64_t a1)
{
  if (!a1) {
    sub_100072548();
  }
  uint64_t v2 = (char *)malloc_type_calloc(1uLL, 0x68uLL, 0x1060040AF2A6198uLL);
  *(_OWORD *)uint64_t v2 = *(_OWORD *)a1;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3) {
    *((void *)v2 + 3) = CFRetain(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4) {
    *((void *)v2 + 5) = CFRetain(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 48);
  if (v5) {
    *((void *)v2 + 6) = CFRetain(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 56);
  if (v6) {
    *((void *)v2 + 7) = CFRetain(v6);
  }
  uint64_t v7 = *(const void **)(a1 + 64);
  if (v7) {
    *((void *)v2 + 8) = CFRetain(v7);
  }
  *((void *)v2 + 9) = *(void *)(a1 + 72);
  *((void *)v2 + 10) = *(void *)(a1 + 80);
  v2[88] = *(unsigned char *)(a1 + 88);
  *(_WORD *)(v2 + 89) = *(_WORD *)(a1 + 89);
  v2[95] = *(unsigned char *)(a1 + 95);
  *((void *)v2 + 12) = *(void *)(a1 + 96);
  return v2;
}

void _AMRestoreDestroyDeviceInfo(void *a1)
{
  if (!a1) {
    sub_100072574();
  }
  uint64_t v2 = (const void *)a1[3];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[4];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[6];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)a1[7];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[8];
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)a1[12];
  if (v8)
  {
    CFRelease(v8);
  }
}

uint64_t copyKeyValuePairsFromIBootString(const __CFString *a1, __CFDictionary **a2)
{
  if (!a1)
  {
    uint64_t result = 1;
LABEL_15:
    *a2 = 0;
    return result;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    uint64_t result = 18;
    goto LABEL_15;
  }
  uint64_t v5 = Mutable;
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, a1, @" ");
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    for (CFIndex i = 0; i != v8; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, i);
      if (CFStringGetLength(ValueAtIndex))
      {
        CFIndex location = CFStringFind(ValueAtIndex, @":", 0).location;
        if (location == -1)
        {
          AMRLog(4, @"token '%@' has unexpected format", v12, v13, v14, v15, v16, v17, (char)ValueAtIndex);
        }
        else
        {
          CFIndex v18 = location;
          v22.CFIndex location = 0;
          v22.CFIndex length = location;
          CFStringRef v19 = CFStringCreateWithSubstring(kCFAllocatorDefault, ValueAtIndex, v22);
          ++v18;
          v23.CFIndex length = CFStringGetLength(ValueAtIndex) - v18;
          v23.CFIndex location = v18;
          CFStringRef v20 = CFStringCreateWithSubstring(kCFAllocatorDefault, ValueAtIndex, v23);
          CFDictionarySetValue(v5, v19, v20);
          CFRelease(v19);
          CFRelease(v20);
        }
      }
    }
  }
  *a2 = v5;
  if (ArrayBySeparatingStrings) {
    CFRelease(ArrayBySeparatingStrings);
  }
  return 0;
}

void loadDeviceInfo(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  long long v12 = 0u;
  CFStringGetCString(a1, buffer, 256, 0x8000100u);
  CFStringGetCString(a2, v11, 256, 0x8000100u);
  if (parseKeyValueIntoDeviceInfo(buffer, v11, a3)) {
    AMRLog(3, @"unable to parse '%s'->'%s'", v5, v6, v7, v8, v9, v10, (char)buffer);
  }
}

uint64_t parseSerialNumberInfo(const __CFString *a1, _DWORD *a2, char a3, int a4)
{
  CFTypeRef cf = 0;
  int v5 = (a3 + 2) & 3;
  if (!a4) {
    int v5 = 1;
  }
  a2[20] = 448;
  a2[21] = v5;
  uint64_t v6 = copyKeyValuePairsFromIBootString(a1, (__CFDictionary **)&cf);
  CFTypeRef v7 = cf;
  if (!v6)
  {
    CFDictionaryApplyFunction((CFDictionaryRef)cf, (CFDictionaryApplierFunction)loadDeviceInfo, a2);
    if (!v7) {
      return v6;
    }
    goto LABEL_5;
  }
  if (cf) {
LABEL_5:
  }
    CFRelease(v7);
  return v6;
}

uint64_t _AMRestorePIDStoresInfoInSerialNumber(int a1)
{
  uint64_t result = 1;
  if (a1 <= 4736)
  {
    if ((a1 - 4646) < 4) {
      return result;
    }
    return 0;
  }
  if ((a1 - 61460) >= 2 && a1 != 4737 && a1 != 5770) {
    return 0;
  }
  return result;
}

uint64_t _AMRUSBDeviceGetFirmwareInfo(void *a1, uint64_t a2, int a3)
{
  *(void *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int ProductID = _AMRUSBDeviceGetProductID(a1);
  char v7 = ProductID;
  if (_AMRestorePIDStoresInfoInSerialNumber(ProductID))
  {
    CFStringRef v8 = (const __CFString *)_AMRUSBDeviceCopySerialNumber(a1);
    if (!v8)
    {
      AMRLog(3, @"unable to get device serial number", v9, v10, v11, v12, v13, v14, v28);
      return 0xFFFFFFFFLL;
    }
    CFStringRef v15 = v8;
    uint64_t v16 = parseSerialNumberInfo(v8, (_DWORD *)a2, v7, a3);
    if (v16) {
      goto LABEL_14;
    }
  }
  else
  {
    unsigned int DeviceReleaseNumber = _AMRUSBDeviceGetDeviceReleaseNumber(a1);
    uint64_t v18 = 0;
    *(_DWORD *)a2 = 35072;
    *(_DWORD *)(a2 + 8) = DeviceReleaseNumber;
    while ((unsigned __int16)word_10007E2E8[v18] != DeviceReleaseNumber >> 8)
    {
      v18 += 2;
      if (v18 == 12)
      {
        int v19 = 0xFFFF;
        goto LABEL_11;
      }
    }
    int v19 = (unsigned __int16)word_10007E2E8[v18 + 1];
LABEL_11:
    CFStringRef v15 = 0;
    *(_DWORD *)(a2 + 4) = v19;
  }
  uint64_t v20 = _AMRUSBDeviceCopyProductString(a1);
  *(void *)(a2 + 32) = v20;
  if (!v20)
  {
    AMRLog(3, @"unable to get device proudct string", v21, v22, v23, v24, v25, v26, v28);
    uint64_t v16 = 0xFFFFFFFFLL;
    if (!v15) {
      return v16;
    }
    goto LABEL_14;
  }
  uint64_t v16 = 0;
  if (v15) {
LABEL_14:
  }
    CFRelease(v15);
  return v16;
}

uint64_t _AMRUSBDeviceAddNonceWithInfo(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef v37 = 0;
  CFTypeRef cf = 0;
  if (!a2)
  {
    CFStringRef v19 = @"device info must be provided to query nonce";
    goto LABEL_12;
  }
  uint64_t v11 = (uint64_t *)(a2 + 56);
  uint64_t v10 = *(const void **)(a2 + 56);
  if (v10)
  {
    CFRelease(v10);
    *uint64_t v11 = 0;
  }
  uint64_t v13 = (CFTypeRef *)(a2 + 48);
  uint64_t v12 = *(const void **)(a2 + 48);
  if (v12)
  {
    CFRelease(v12);
    *uint64_t v13 = 0;
  }
  if (_AMRUSBDeviceCopyNonceWithTag(a1, a2, @"NONC", &cf, a5, a6, a7, a8)
    || (char v20 = (char)cf,
        uint64_t v21 = AMAuthInstallSupportCopyDataFromHexString((int)kCFAllocatorDefault, (CFStringRef)cf, (uint64_t *)(a2 + 48)),
        !v21))
  {
    if (!*(unsigned char *)(a2 + 95)
      || (*(unsigned char *)(a2 + 16) & 4) == 0
      || _AMRUSBDeviceCopyNonceWithTag(a1, a2, @"SNON", &v37, v14, v15, v16, v17))
    {
      goto LABEL_10;
    }
    char v27 = (char)v37;
    if (v37)
    {
      uint64_t v28 = AMAuthInstallSupportCopyDataFromHexString((int)kCFAllocatorDefault, (CFStringRef)v37, v11);
      if (v28)
      {
        uint64_t v35 = v28;
        AMRLog(3, @"unparsable sep nonce: %@", v29, v30, v31, v32, v33, v34, v27);
        if (*v11)
        {
          CFRelease((CFTypeRef)*v11);
          *uint64_t v11 = 0;
        }
        uint64_t v25 = v35;
        goto LABEL_17;
      }
LABEL_10:
      uint64_t v18 = 0;
      goto LABEL_18;
    }
    CFStringRef v19 = @"sep nonce is NULL";
LABEL_12:
    AMRLog(3, v19, a3, a4, a5, a6, a7, a8, v36);
    uint64_t v18 = 1;
    goto LABEL_18;
  }
  uint64_t v24 = v21;
  AMRLog(3, @"unparsable ap nonce: %@", v22, v23, v14, v15, v16, v17, v20);
  if (*v13)
  {
    CFRelease(*v13);
    *uint64_t v13 = 0;
  }
  uint64_t v25 = v24;
LABEL_17:
  uint64_t v18 = AMAuthInstallToRestoreError(v25);
LABEL_18:
  if (cf) {
    CFRelease(cf);
  }
  if (v37) {
    CFRelease(v37);
  }
  return v18;
}

uint64_t _AMRUSBDeviceCopyNonceWithTag(void *a1, uint64_t a2, const void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a4 = 0;
  if (a2)
  {
    if (*(unsigned char *)(a2 + 95)) {
      BOOL v8 = (*(_DWORD *)(a2 + 16) & 6) == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8)
    {
      AMRLog(7, @"device software does not support nonce generation", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v36);
      return 48;
    }
    else
    {
      memset(v39, 0, sizeof(v39));
      uint64_t v12 = _AMRUSBDeviceSendDeviceRequest(a1, 1033, 1, 0, 0, 6, 769, 256, (uint64_t)v39);
      uint64_t v9 = v12;
      if (!v12)
      {
        CFDictionaryRef theDict = 0;
        if (BYTE1(v39[0]) == 3)
        {
          CFStringRef v19 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)v39 + 2, LOBYTE(v39[0]) - 2, 0x100u, 0);
          if (v19)
          {
            CFStringRef v26 = v19;
            uint64_t v9 = copyKeyValuePairsFromIBootString(v19, &theDict);
            if (!v9)
            {
              CFDictionaryRef v27 = theDict;
              CFBooleanRef Value = CFDictionaryGetValue(theDict, a3);
              *a4 = Value;
              if (Value)
              {
                CFRetain(Value);
                uint64_t v9 = 0;
              }
              else
              {
                AMRLog(7, @"%@ tag not found", v29, v30, v31, v32, v33, v34, (char)a3);
                uint64_t v9 = 6;
              }
              CFRelease(v27);
            }
            CFRelease(v26);
          }
          else
          {
            AMRLog(3, @"nonce conversion failure", v20, v21, v22, v23, v24, v25, v37);
            return 31;
          }
        }
        else
        {
          AMRLog(3, @"nonce string descriptor has unexpected type %d", v13, v14, v15, v16, v17, v18, SBYTE1(v39[0]));
          return 59;
        }
      }
    }
  }
  else
  {
    AMRLog(3, @"device info must be provided to query nonce", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v36);
    return 1;
  }
  return v9;
}

uint64_t _AMRUSBDeviceCopyNonce(void *a1, void *a2)
{
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  uint64_t FirmwareInfo = _AMRUSBDeviceGetFirmwareInfo(a1, (uint64_t)v15, 0);
  if (FirmwareInfo)
  {
    uint64_t v11 = FirmwareInfo;
    CFStringRef v12 = @"unable to get firmware info from device";
    uint64_t v13 = 3;
LABEL_5:
    AMRLog(v13, v12, v5, v6, v7, v8, v9, v10, v15[0]);
    return v11;
  }
  uint64_t v11 = _AMRUSBDeviceCopyNonceWithTag(a1, (uint64_t)v15, @"NONC", a2, v7, v8, v9, v10);
  if (v11)
  {
    CFStringRef v12 = @"Could not query ap nonce from device";
    uint64_t v13 = 7;
    goto LABEL_5;
  }
  return v11;
}

uint64_t _AMRUSBDeviceCopySEPNonce(void *a1, void *a2)
{
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  uint64_t FirmwareInfo = _AMRUSBDeviceGetFirmwareInfo(a1, (uint64_t)v15, 0);
  if (FirmwareInfo)
  {
    uint64_t v11 = FirmwareInfo;
    CFStringRef v12 = @"unable to get firmware info from device";
    uint64_t v13 = 3;
LABEL_5:
    AMRLog(v13, v12, v5, v6, v7, v8, v9, v10, v15[0]);
    return v11;
  }
  uint64_t v11 = _AMRUSBDeviceCopyNonceWithTag(a1, (uint64_t)v15, @"SNON", a2, v7, v8, v9, v10);
  if (v11)
  {
    CFStringRef v12 = @"Could not query sep nonce from device";
    uint64_t v13 = 7;
    goto LABEL_5;
  }
  return v11;
}

uint64_t AMRestoreCaptureSubsystemLogs()
{
  byte_1000B8D20 = 1;
  AMSupportLogSetHandler();
  AMAuthInstallLogSetHandler((void (*)(int, uint64_t))_AMAuthInstallLogHandler);
  return AMFDRLogSetHandler((uint64_t)_AMAuthInstallLogHandler);
}

uint64_t AMRestoreCaptureSubsystemLogsIfNeeded()
{
  if ((byte_1000B8D20 & 1) == 0) {
    return AMRestoreCaptureSubsystemLogs();
  }
  return result;
}

void sub_10003EBAC(uint64_t a1, char *cStr, CFTypeRef cf)
{
  if (dword_1000B8850 < (int)a1) {
    return;
  }
  uint64_t v4 = a1;
  if (off_1000B8D28)
  {
    if (cf) {
      uint64_t v5 = (void *)CFRetain(cf);
    }
    else {
      uint64_t v5 = (void *)CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
    }
    uint64_t v6 = v5;
    off_1000B8D28(v5, v4);
    CFRelease(v6);
  }
  if (dword_1000B8848 == -1)
  {
    if ((int)v4 >= 7) {
      LODWORD(v4) = 7;
    }
    goto LABEL_18;
  }
  __s = cStr;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  *(_OWORD *)__str = 0u;
  long long v30 = 0u;
  long double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v8 = (__CFCalendar *)qword_1000B8D38;
  if (!qword_1000B8D38)
  {
    uint64_t v8 = CFCalendarCopyCurrent();
    qword_1000B8D38 = (uint64_t)v8;
  }
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v26 = 0;
  CFCalendarDecomposeAbsoluteTime(v8, Current, "yMdHms", (char *)&v28 + 4, &v28, (char *)&v27 + 4, &v27, (char *)&v26 + 4, &v26);
  int v10 = v28;
  int v9 = HIDWORD(v28);
  int v12 = v27;
  int v11 = HIDWORD(v27);
  int v13 = v26;
  int v14 = HIDWORD(v26);
  int v15 = (int)modf(Current, &__y);
  uint64_t v16 = getprogname();
  pid_t v17 = getpid();
  uint64_t v18 = pthread_self();
  mach_port_t v19 = pthread_mach_thread_np(v18);
  int v20 = snprintf(__str, 0x100uLL, "%04d-%02d-%02d %02d:%02d:%02d.%03d %s[%d:%x]: ", v9, v10, v11, v12, v14, v13, v15, v16, v17, v19);
  if (v20) {
    write(dword_1000B8848, __str, v20);
  }
  size_t v21 = strlen(__s);
  write(dword_1000B8848, __s, v21);
  write(dword_1000B8848, "\n", 1uLL);
  if ((int)v4 >= 7) {
    LODWORD(v4) = 7;
  }
  if (dword_1000B8848 == -1)
  {
LABEL_18:
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    *(_OWORD *)__str = 0u;
    long long v30 = 0u;
    uint64_t v22 = pthread_self();
    mach_port_t v23 = pthread_mach_thread_np(v22);
    if (snprintf(__str, 0x100uLL, "tid:%x", v23) < 0 || dword_1000B8D18) {
      syslog(v4, "%s");
    }
    else {
      syslog(v4, "%s - %s");
    }
  }
}

void AMRLogv(uint64_t a1, CFStringRef format, va_list arguments)
{
  if (dword_1000B8850 >= (int)a1)
  {
    CFStringRef v4 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, arguments);
    if (v4)
    {
      CFStringRef v5 = v4;
      bzero(buffer, 0x400uLL);
      uint64_t v6 = buffer;
      if (!CFStringGetCString(v5, buffer, 1024, 0x8000100u))
      {
        CFIndex Length = CFStringGetLength(v5);
        CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        int v9 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0xF7F19868uLL);
        if (v9)
        {
          uint64_t v6 = v9;
          CFStringGetCString(v5, v9, MaximumSizeForEncoding, 0x8000100u);
        }
        else
        {
          uint64_t v6 = buffer;
        }
      }
      sub_10003EBAC(a1, v6, v5);
      CFRelease(v5);
      if (v6 != buffer) {
        free(v6);
      }
    }
  }
}

uint64_t AMRestoreCreatePathsForBundle(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const __CFDictionary **a6, void *a7, void *a8)
{
  CFDictionaryRef theDict = 0;
  CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%cRestore.plist", a1, 47);
  if (!v16) {
    return 18;
  }
  CFStringRef v23 = v16;
  long long v44 = a7;
  uint64_t v24 = a8;
  uint64_t v25 = _AMRestoreCreateCFDictionaryWithContentsOfFile(v16, &theDict, v17, v18, v19, v20, v21, v22);
  CFRelease(v23);
  if (!v25)
  {
    CFDictionaryRef v26 = theDict;
    uint64_t v27 = v24;
    if (!a6) {
      goto LABEL_20;
    }
    if (!a4)
    {
      CFDictionaryRef v33 = 0;
      goto LABEL_19;
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"KernelCachesByPlatform");
    CFDictionaryRef v29 = v26;
    CFDictionaryRef v30 = Value;
    CFDictionaryRef v43 = v29;
    CFDictionaryRef v31 = (const __CFDictionary *)CFDictionaryGetValue(v29, @"KernelCachesByTarget");
    if (v31)
    {
      if (a3)
      {
        CFStringRef v32 = a3;
        goto LABEL_13;
      }
    }
    else
    {
      if (!v30)
      {
        CFDictionaryRef v26 = v43;
        CFDictionaryRef v33 = (const __CFDictionary *)CFDictionaryGetValue(v43, @"RestoreKernelCaches");
        uint64_t v27 = v24;
        if (v33)
        {
LABEL_14:
          CFDictionaryRef v34 = v33;
          CFStringRef v35 = @"Release";
          if (CFEqual(a4, @"Release")
            || (CFStringRef v35 = @"Development",
                CFComparisonResult v36 = CFStringCompare(a4, @"Development", 0),
                CFDictionaryRef v33 = 0,
                v36 == kCFCompareEqualTo))
          {
            CFDictionaryRef v33 = (const __CFDictionary *)CFDictionaryGetValue(v34, v35);
            if (v33) {
              CFDictionaryRef v33 = (const __CFDictionary *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%c%@", a1, 47, v33);
            }
          }
        }
LABEL_19:
        *a6 = v33;
LABEL_20:
        if (!v44)
        {
LABEL_33:
          if (v27)
          {
            long long v41 = (void *)CFDictionaryGetValue(v26, @"FirmwareDirectory");
            if (v41) {
              long long v41 = (void *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%c%@", a1, 47, v41);
            }
            *uint64_t v27 = v41;
          }
          CFRelease(v26);
          return 0;
        }
        if (!a5
          || ((CFDictionaryRef v37 = (const __CFDictionary *)CFDictionaryGetValue(v26, @"RamDisksByPlatform")) == 0
            ? (v38 = @"RestoreRamDisks", CFDictionaryRef v37 = v26)
            : (const __CFDictionary *)(CFStringRef v38 = a2),
              (CFDictionaryRef v39 = (const __CFDictionary *)CFDictionaryGetValue(v37, v38)) == 0))
        {
          long long v40 = 0;
LABEL_32:
          *long long v44 = v40;
          goto LABEL_33;
        }
        if (CFEqual(a5, @"UserOrInternal"))
        {
          long long v40 = (void *)CFDictionaryGetValue(v39, @"User");
          if (v40)
          {
LABEL_31:
            long long v40 = (void *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%c%@", a1, 47, v40);
            goto LABEL_32;
          }
          a5 = @"Internal";
        }
        long long v40 = (void *)CFDictionaryGetValue(v39, a5);
        if (!v40) {
          goto LABEL_32;
        }
        goto LABEL_31;
      }
      if (a2)
      {
        CFDictionaryRef v31 = v30;
        CFStringRef v32 = a2;
LABEL_13:
        CFDictionaryRef v33 = (const __CFDictionary *)CFDictionaryGetValue(v31, v32);
        uint64_t v27 = v24;
        CFDictionaryRef v26 = v43;
        if (v33) {
          goto LABEL_14;
        }
        goto LABEL_19;
      }
    }
    CFDictionaryRef v33 = 0;
    uint64_t v27 = v24;
    CFDictionaryRef v26 = v43;
    goto LABEL_19;
  }
  return v25;
}

uint64_t _thr_AMRestoreRegisterForNotifications(_DWORD *a1)
{
  uint64_t result = _AMRestoreInitializeNotifications((uint64_t)&xmmword_1000B8CE0);
  *a1 = result;
  if (!result) {
    byte_1000B8D30 = 1;
  }
  return result;
}

void function_does_nothing(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t AMRestoreRegisterForDeviceNotifications(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int context = 0;
  _AMRestoreLoadAndCacheIOUSBLibBundle();
  pthread_mutex_lock(&stru_1000B8858);
  *(void *)&xmmword_1000B8CE0 = a1;
  *((void *)&xmmword_1000B8CE0 + 1) = a2;
  *(void *)&xmmword_1000B8CF0 = a3;
  *((void *)&xmmword_1000B8CF0 + 1) = a4;
  qword_1000B8D00 = a5;
  qword_1000B8D10 = a6;
  int v12 = dispatch_queue_create("com.apple.purplerestore.device_notificaion", 0);
  qword_1000B8D08 = (uint64_t)v12;
  if ((byte_1000B8D30 & 1) == 0)
  {
    dispatch_sync_f(v12, &context, (dispatch_function_t)_thr_AMRestoreRegisterForNotifications);
    dispatch_sync_f((dispatch_queue_t)qword_1000B8D08, 0, (dispatch_function_t)function_does_nothing);
  }
  pthread_mutex_unlock(&stru_1000B8858);
  return context;
}

uint64_t AMRestoreUnregisterForDeviceNotifications()
{
  pthread_mutex_lock(&stru_1000B8858);
  if (byte_1000B8D30 == 1)
  {
    uint64_t v0 = _AMRestoreUninitializeNotifications();
    if (!v0)
    {
      dispatch_sync_f((dispatch_queue_t)qword_1000B8D08, 0, (dispatch_function_t)function_does_nothing);
      dispatch_release((dispatch_object_t)qword_1000B8D08);
      qword_1000B8D10 = 0;
      xmmword_1000B8CF0 = 0u;
      *(_OWORD *)&qword_1000B8D00 = 0u;
      xmmword_1000B8CE0 = 0u;
      byte_1000B8D30 = 0;
    }
  }
  else
  {
    uint64_t v0 = 0;
  }
  pthread_mutex_unlock(&stru_1000B8858);
  return v0;
}

CFMutableStringRef _AMRestoreCopyTargetForBoardConfig(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, a1);
  CFStringLowercase(MutableCopy, 0);
  if (CFStringHasSuffix(MutableCopy, @"ap") == 1)
  {
    v5.CFIndex location = Length - 2;
    CFStringRef v4 = MutableCopy;
    v5.CFIndex length = 2;
  }
  else
  {
    if (CFStringHasSuffix(MutableCopy, @"dev") != 1)
    {
      AMRLog(4, @"unable to convert '%@' to target", v6, v7, v8, v9, v10, v11, (char)a1);
      return MutableCopy;
    }
    v5.CFIndex location = Length - 3;
    CFStringRef v4 = MutableCopy;
    v5.CFIndex length = 3;
  }
  CFStringDelete(v4, v5);
  return MutableCopy;
}

BOOL _AMRUSBDeviceGetIBFL(void *a1, _DWORD *a2)
{
  uint64_t v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  int FirmwareInfo = _AMRUSBDeviceGetFirmwareInfo(a1, (uint64_t)&v13, 0);
  if (FirmwareInfo) {
    AMRLog(3, @"unable to get firmware info from device: %d", v4, v5, v6, v7, v8, v9, FirmwareInfo);
  }
  int v10 = HIBYTE(v18);
  if (HIBYTE(v18)) {
    *a2 = v14;
  }
  BOOL v11 = v10 != 0;
  _AMRestoreDestroyDeviceInfo(&v13);
  return v11;
}

uint64_t AMRestoreOptionsApplyMacOSChangesIfNeeded(const __CFDictionary *a1)
{
  CFBooleanRef Value = (CFBooleanRef)CFDictionaryGetValue(a1, @"MacOSVariantPresent");
  if (Value) {
    BOOL v3 = Value == kCFBooleanTrue;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3) {
    return 0;
  }
  CFBooleanRef v4 = Value;
  CFBooleanRef v5 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"MacOSSwapPerformed");
  CFBooleanRef v12 = kCFBooleanFalse;
  if (v5)
  {
    if (v5 != kCFBooleanFalse) {
      return 0;
    }
  }
  AMRLog(6, @"Performing MacOS restore changes.", v6, v7, v8, v9, v10, v11, v123);
  CFDictionaryRef v13 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"BundleOverrides");
  if (!v13) {
    goto LABEL_23;
  }
  CFDictionaryRef v14 = v13;
  for (uint64_t i = 0; i != 152; i += 8)
  {
    long long v16 = *(__CFString **)((char *)&off_10009E618 + i);
    long long v17 = CFDictionaryGetValue(v14, v16);
    long long v18 = *(__CFString **)((char *)&off_10009E6B0 + i);
    uint64_t v19 = CFDictionaryGetValue(v14, v18);
    uint64_t v20 = v19;
    if (!v17)
    {
      if (!v19) {
        continue;
      }
      CFRetain(v19);
      CFDictionaryRemoveValue(v14, v18);
      AMRLog(6, @"Removed %@ from overides.%@.", v27, v28, v29, v30, v31, v32, (char)v20);
      goto LABEL_15;
    }
    CFRetain(v17);
    if (v20)
    {
      CFRetain(v20);
      CFDictionarySetValue(v14, v18, v17);
      AMRLog(6, @"Added %@ to overides.%@ from overrides.%@.", v21, v22, v23, v24, v25, v26, (char)v17);
LABEL_15:
      CFDictionarySetValue(v14, v16, v20);
      AMRLog(6, @"Added %@ to overides.%@ from overrides.%@.", v33, v34, v35, v36, v37, v38, (char)v20);
      if (v17) {
        CFRelease(v17);
      }
      long long v17 = v20;
      goto LABEL_19;
    }
    CFDictionarySetValue(v14, v18, v17);
    AMRLog(6, @"Added %@ to overides.%@ from overrides.%@.", v39, v40, v41, v42, v43, v44, (char)v17);
    CFDictionaryRemoveValue(v14, v16);
    AMRLog(6, @"Removed %@ from overides.%@.", v45, v46, v47, v48, v49, v50, (char)v17);
LABEL_19:
    CFRelease(v17);
  }
  uint64_t v51 = CFDictionaryGetValue(v14, @"RecoveryOSBundlePath");
  CFBooleanRef v12 = kCFBooleanFalse;
  if (v51)
  {
    uint64_t v52 = v51;
    uint64_t v53 = CFDictionaryGetValue(a1, @"RestoreBundlePath");
    CFRetain(v52);
    CFRetain(v53);
    CFDictionarySetValue(v14, @"RecoveryOSBundlePath", v53);
    CFDictionarySetValue(a1, @"RestoreBundlePath", v52);
    CFRelease(v52);
    CFRelease(v53);
    AMRLog(6, @"Swaped paths --> to %@ = %@ and %@ = %@.", v54, v55, v56, v57, v58, v59, (char)@"RecoveryOSBundlePath");
  }
LABEL_23:
  uint64_t v60 = CFDictionaryGetValue(a1, @"RootToInstall");
  CFArrayRef v61 = (const __CFArray *)CFDictionaryGetValue(a1, @"OverlayRootsToInstall");
  CFArrayRef v62 = (const __CFArray *)CFDictionaryGetValue(a1, @"RecoveryOSOverlayRootsToInstall");
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v64 = Mutable;
  if (v60) {
    CFArrayAppendValue(Mutable, v60);
  }
  if (v61 && CFArrayGetCount(v61) >= 1)
  {
    v124.CFIndex length = CFArrayGetCount(v61);
    v124.CFIndex location = 0;
    CFArrayAppendArray(v64, v61, v124);
  }
  CFDictionaryRemoveValue(a1, @"RootToInstall");
  CFDictionaryRemoveValue(a1, @"OverlayRootsToInstall");
  CFDictionaryRemoveValue(a1, @"RecoveryOSOverlayRootsToInstall");
  if (v62 && CFArrayGetCount(v62) >= 1)
  {
    uint64_t v71 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v62, 0);
    CFDictionaryAddValue(a1, @"RootToInstall", ValueAtIndex);
    CFArrayGetValueAtIndex(v62, 0);
    AMRLog(6, @"Added to %@ = %@.", v73, v74, v75, v76, v77, v78, (char)@"RootToInstall");
    v125.CFIndex length = CFArrayGetCount(v62) - 1;
    v125.CFIndex location = 1;
    CFArrayAppendArray(v71, v62, v125);
    if (CFArrayGetCount(v71) < 1)
    {
      AMRLog(6, @"No %@ to insert.", v79, v80, v81, v82, v83, v84, (char)@"OverlayRootsToInstall");
    }
    else
    {
      CFDictionarySetValue(a1, @"OverlayRootsToInstall", v71);
      CFArrayGetCount(v71);
      AMRLog(6, @"Updated %@ with %ld overlay roots.", v85, v86, v87, v88, v89, v90, (char)@"OverlayRootsToInstall");
    }
    CFRelease(v71);
  }
  else
  {
    AMRLog(6, @"No %@ added.", v65, v66, v67, v68, v69, v70, (char)@"RootToInstall");
    AMRLog(6, @"No %@ added.", v91, v92, v93, v94, v95, v96, (char)@"OverlayRootsToInstall");
  }
  if (CFArrayGetCount(v64) < 1)
  {
    AMRLog(6, @"No %@ added.", v97, v98, v99, v100, v101, v102, (char)@"RecoveryOSOverlayRootsToInstall");
  }
  else
  {
    CFDictionarySetValue(a1, @"RecoveryOSOverlayRootsToInstall", v64);
    CFArrayGetCount(v64);
    AMRLog(6, @"Updated %@ with %ld overlay roots.", v103, v104, v105, v106, v107, v108, (char)@"RecoveryOSOverlayRootsToInstall");
  }
  CFRelease(v64);
  CFBooleanRef v109 = (CFBooleanRef)CFDictionaryGetValue(a1, @"RecoveryOSOnly");
  if (v109 && v109 == v4)
  {
    CFDictionarySetValue(a1, @"InstallRecoveryOS", v12);
    AMRLog(6, @"Setting %@ to false.", v110, v111, v112, v113, v114, v115, (char)@"InstallRecoveryOS");
  }
  CFDictionarySetValue(a1, @"RecoveryOSUnpack", v4);
  CFDictionarySetValue(a1, @"MacOSSwapPerformed", v4);
  AMRLog(6, @"Setting %@ to true.", v116, v117, v118, v119, v120, v121, (char)@"MacOSSwapPerformed");
  return 0;
}

void sub_10003FB10(id a1, NSError *a2)
{
}

uint64_t sub_10003FD20(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = *(NSObject **)(v2 + 40);
  if (v3)
  {
    dispatch_release(v3);
    *(void *)(*(void *)(a1 + 32) + 40) = 0;
    uint64_t v2 = *(void *)(a1 + 32);
  }
  uint64_t result = *(unsigned int *)(v2 + 36);
  if (result)
  {
    uint64_t result = IOObjectRelease(result);
    *(_DWORD *)(*(void *)(a1 + 32) + 36) = 0;
  }
  return result;
}

void sub_1000406A8(id a1)
{
  _notificationQueue = (uint64_t)dispatch_queue_create("com.apple.MobileDevice.USBCloseNotification.queue", 0);
  CFStringRef v1 = IONotificationPortCreate(kIOMainPortDefault);
  _closeNotificationPort = (uint64_t)v1;
  uint64_t v2 = _notificationQueue;
  IONotificationPortSetDispatchQueue(v1, v2);
}

uint64_t _AMRUSBDeviceOpen(void *a1)
{
  uint64_t v4 = 0;
  CFBooleanRef v5 = &v4;
  uint64_t v6 = 0x2020000000;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000407C4;
  v3[3] = &unk_10009E7F8;
  void v3[4] = &v4;
  [a1 openDeviceWithReply:v3];
  uint64_t v1 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1000407AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000407C4(uint64_t a1, int a2, void *a3)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  if (a2)
  {
    [a3 code];
    [a3 userInfo];
    AMRLog(3, @"%s: AMRUSBDevice error (%ld): %@", v4, v5, v6, v7, v8, v9, (char)"_AMRUSBDeviceOpen_block_invoke");
  }
}

uint64_t _AMRUSBDeviceSendDeviceRequest(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, __int16 a8, uint64_t a9)
{
  return _AMRUSBDeviceSendDeviceRequestTO(a1, a2, a3, a4, a5, a6, a7, a8, a9, 5000);
}

uint64_t _AMRUSBDeviceSendDeviceRequestTO(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, __int16 a8, uint64_t a9, uint64_t a10)
{
  uint64_t v16 = 0;
  long long v17 = &v16;
  uint64_t v18 = 0x2020000000;
  int v19 = 0;
  v15[0] = 0;
  v15[1] = v15;
  void v15[2] = 0x2020000000;
  v15[3] = a9;
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  int v13[2] = sub_1000409C4;
  _OWORD v13[3] = &unk_10009E820;
  v13[4] = &v16;
  v13[5] = v15;
  __int16 v14 = a8;
  LOWORD(v12) = a8;
  [a1 sendDeviceRequestTO:a2 direction:a3 requestType:a4 recipient:a5 request:a6 value:a7 length:v12 data:+[NSData dataWithBytes:length:](NSData noDataTO:"dataWithBytes:length:") completionTO:a10 withReply:v13];
  uint64_t v10 = *((unsigned int *)v17 + 6);
  _Block_object_dispose(v15, 8);
  _Block_object_dispose(&v16, 8);
  return v10;
}

void sub_1000409A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

id sub_1000409C4(uint64_t a1, int a2, void *a3, void *a4)
{
  if (a4)
  {
    [a4 code];
    [a4 userInfo];
    AMRLog(3, @"%s: AMRUSBDevice error (%ld): %@", v8, v9, v10, v11, v12, v13, (char)"_AMRUSBDeviceSendDeviceRequestTO_block_invoke");
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  uint64_t v14 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v15 = *(unsigned __int16 *)(a1 + 48);
  return [a3 getBytes:v14 length:v15];
}

uint64_t _AMRUSBDeviceGetInterface(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x3052000000;
  uint64_t v9 = sub_100040B58;
  uint64_t v10 = sub_100040B68;
  uint64_t v11 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100040B74;
  v5[3] = &unk_10009E848;
  v5[4] = a1;
  v5[5] = &v6;
  [a1 interfaceWithClass:a2 subclass:a3 withReply:v5];
  uint64_t v3 = v7[5];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_100040B40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100040B58(uint64_t a1, uint64_t a2)
{
}

void sub_100040B68(uint64_t a1)
{
}

void sub_100040B74(uint64_t a1, void *a2, void *a3)
{
  if (a2)
  {
    id v3 = a2;
    if ([*(id *)(a1 + 32) conformsToProtocol:&OBJC_PROTOCOL___NSXPCProxyCreating]) {
      id v3 = [v3 synchronousRemoteObjectProxyWithErrorHandler:AMRUSBInterfaceErrorHandler];
    }
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = v3;
    uint64_t v5 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    id v6 = v5;
  }
  else
  {
    [a3 code];
    [a3 userInfo];
    AMRLog(3, @"%s: AMRUSBDevice error (%ld): %@", v8, v9, v10, v11, v12, v13, (char)"_AMRUSBDeviceGetInterface_block_invoke");
  }
}

uint64_t _AMRUSBDeviceGetProductID(void *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100040D08;
  v3[3] = &unk_10009E870;
  void v3[4] = &v4;
  [a1 getProductIDWithReply:v3];
  uint64_t v1 = *((unsigned __int16 *)v5 + 12);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100040CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100040D08(uint64_t a1, int a2, void *a3)
{
  if (!a2)
  {
    [a3 code];
    [a3 userInfo];
    AMRLog(3, @"%s: AMRUSBDevice error (%ld): %@", v6, v7, v8, v9, v10, v11, (char)"_AMRUSBDeviceGetProductID_block_invoke");
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
}

uint64_t _AMRUSBDeviceGetDeviceReleaseNumber(void *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100040E40;
  v3[3] = &unk_10009E870;
  void v3[4] = &v4;
  [a1 getDeviceReleaseNumberWithReply:v3];
  uint64_t v1 = *((unsigned __int16 *)v5 + 12);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100040E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100040E40(uint64_t a1, int a2, void *a3)
{
  if (!a2)
  {
    [a3 code];
    [a3 userInfo];
    AMRLog(3, @"%s: AMRUSBDevice error (%ld): %@", v6, v7, v8, v9, v10, v11, (char)"_AMRUSBDeviceGetDeviceReleaseNumber_block_invoke");
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
}

uint64_t _AMRUSBDeviceCopySerialNumber(void *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100040F78;
  v3[3] = &unk_10009E898;
  void v3[4] = &v4;
  [a1 copySerialNumberWithReply:v3];
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100040F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100040F78(uint64_t a1, CFStringRef theString, void *a3)
{
  if (a3)
  {
    [a3 code];
    [a3 userInfo];
    AMRLog(3, @"%s: AMRUSBDevice error (%ld): %@", v6, v7, v8, v9, v10, v11, (char)"_AMRUSBDeviceCopySerialNumber_block_invoke");
  }
  if (theString) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFStringCreateCopy(kCFAllocatorDefault, theString);
  }
}

uint64_t _AMRUSBDeviceCopyProductString(void *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000410C8;
  v3[3] = &unk_10009E898;
  void v3[4] = &v4;
  [a1 copyProductStringWithReply:v3];
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1000410B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000410C8(uint64_t a1, CFStringRef theString, void *a3)
{
  if (a3)
  {
    [a3 code];
    [a3 userInfo];
    AMRLog(3, @"%s: AMRUSBDevice error (%ld): %@", v6, v7, v8, v9, v10, v11, (char)"_AMRUSBDeviceCopyProductString_block_invoke");
  }
  if (theString) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFStringCreateCopy(kCFAllocatorDefault, theString);
  }
}

uint64_t _AMRUSBDeviceReEnumerate(void *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100041218;
  v3[3] = &unk_10009E7F8;
  void v3[4] = &v4;
  [a1 reEnumerateWithReply:v3];
  uint64_t v1 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100041200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100041218(uint64_t a1, int a2, void *a3)
{
  if (a2)
  {
    [a3 code];
    [a3 userInfo];
    AMRLog(3, @"%s: AMRUSBDevice error (%ld): %@", v6, v7, v8, v9, v10, v11, (char)"_AMRUSBDeviceReEnumerate_block_invoke");
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
}

void _AMRUSBDeviceClose(void *a1)
{
  [a1 closeDevice];
  [a1 freeDevice];
}

uint64_t _AMRUSBInterfaceOpen(void *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100041390;
  v3[3] = &unk_10009E7F8;
  void v3[4] = &v4;
  [a1 openInterfaceWithReply:v3];
  uint64_t v1 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100041378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100041390(uint64_t a1, int a2, void *a3)
{
  if (a2)
  {
    [a3 code];
    [a3 userInfo];
    AMRLog(3, @"%s: AMRUSBInterface error (%ld): %@", v6, v7, v8, v9, v10, v11, (char)"_AMRUSBInterfaceOpen_block_invoke");
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
}

uint64_t _AMRUSBInterfaceGetFileTransferPipe(void *a1, unsigned char *a2, _WORD *a3)
{
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2020000000;
  int v19 = -536870212;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2020000000;
  __int16 v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100041544;
  v7[3] = &unk_10009E8C0;
  v7[4] = &v16;
  v7[5] = &v12;
  v7[6] = &v8;
  [a1 getFileTransferPipeWithReply:v7];
  *a2 = *((unsigned char *)v13 + 24);
  *a3 = *((_WORD *)v9 + 12);
  uint64_t v5 = *((unsigned int *)v17 + 6);
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  return v5;
}

void sub_100041514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_100041544(void *a1, int a2, char a3, __int16 a4, void *a5)
{
  if (a2)
  {
    [a5 code];
    [a5 userInfo];
    AMRLog(3, @"%s: AMRUSBInterface error (%ld): %@", v10, v11, v12, v13, v14, v15, (char)"_AMRUSBInterfaceGetFileTransferPipe_block_invoke");
  }
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = a2;
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = a3;
  *(_WORD *)(*(void *)(a1[6] + 8) + 24) = a4;
}

uint64_t _AMRUSBInterfaceGetPipes(void *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4, unsigned char *a5, unsigned char *a6)
{
  uint64_t v29 = 0;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x2020000000;
  char v32 = -1;
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2020000000;
  char v28 = -1;
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2020000000;
  char v24 = -1;
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000;
  char v20 = -1;
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  char v16 = -1;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1000417AC;
  unint64_t v12[3] = &unk_10009E8E8;
  v12[4] = &v29;
  v12[5] = &v25;
  v12[6] = &v21;
  v12[7] = &v17;
  v12[8] = &v13;
  [a1 getPipesWithReply:v12];
  *a2 = *((unsigned char *)v30 + 24);
  *a3 = *((unsigned char *)v26 + 24);
  *a4 = *((unsigned char *)v22 + 24);
  *a5 = *((unsigned char *)v18 + 24);
  *a6 = *((unsigned char *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  return 3758097084;
}

void sub_100041764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 112), 8);
  _Block_object_dispose((const void *)(v27 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000417AC(void *a1, int a2, char a3, char a4, char a5, char a6, char a7, void *a8)
{
  if (a2)
  {
    [a8 code];
    [a8 userInfo];
    AMRLog(3, @"%s: AMRUSBInterface error (%ld): %@", v15, v16, v17, v18, v19, v20, (char)"_AMRUSBInterfaceGetPipes_block_invoke");
  }
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = a3;
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = a4;
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = a5;
  *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = a6;
  *(unsigned char *)(*(void *)(a1[8] + 8) + 24) = a7;
}

uint64_t _AMRUSBInterfaceGetDFUInformation(void *a1, _WORD *a2, unsigned char *a3, unsigned char *a4)
{
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2020000000;
  int v25 = -536870212;
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2020000000;
  __int16 v21 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000;
  char v17 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2020000000;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_1000419F0;
  v9[3] = &unk_10009E910;
  v9[4] = &v22;
  v9[5] = &v18;
  v9[6] = &v14;
  v9[7] = &v10;
  [a1 getDFUInformationWithReply:v9];
  *a2 = *((_WORD *)v19 + 12);
  *a3 = *((unsigned char *)v15 + 24);
  *a4 = *((unsigned char *)v11 + 24);
  uint64_t v7 = *((unsigned int *)v23 + 6);
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  return v7;
}

void sub_1000419B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000419F0(void *a1, int a2, __int16 a3, char a4, char a5, void *a6)
{
  if (a2)
  {
    [a6 code];
    [a6 userInfo];
    AMRLog(3, @"%s: AMRUSBInterface error (%ld): %@", v12, v13, v14, v15, v16, v17, (char)"_AMRUSBInterfaceGetDFUInformation_block_invoke");
  }
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = a2;
  *(_WORD *)(*(void *)(a1[5] + 8) + 24) = a3;
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = a4;
  *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = a5;
}

uint64_t _AMRUSBInterfaceWritePipe(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  int v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  unint64_t v6[2] = sub_100041B98;
  v6[3] = &unk_10009E7F8;
  v6[4] = &v7;
  objc_msgSend(a1, "writePipe:data:length:withReply:", a2, +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:"), a4, v6);
  uint64_t v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_100041B80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100041B98(uint64_t a1, int a2, void *a3)
{
  if (a2)
  {
    [a3 code];
    [a3 userInfo];
    AMRLog(3, @"%s: AMRUSBInterface error (%ld): %@", v6, v7, v8, v9, v10, v11, (char)"_AMRUSBInterfaceWritePipe_block_invoke");
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
}

uint64_t _AMRUSBInterfaceReadPipe(void *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  int v16 = -536870212;
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  int v12 = 0;
  uint64_t v5 = *a4;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100041D1C;
  unint64_t v8[3] = &unk_10009E938;
  v8[5] = &v9;
  v8[6] = a3;
  v8[4] = &v13;
  [a1 readPipe:a2 length:v5 withReply:v8];
  *a4 = *((_DWORD *)v10 + 6);
  uint64_t v6 = *((unsigned int *)v14 + 6);
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v13, 8);
  return v6;
}

void sub_100041CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

id sub_100041D1C(void *a1, int a2, void *a3, unsigned int a4, void *a5)
{
  if (a2)
  {
    [a5 code];
    [a5 userInfo];
    AMRLog(3, @"%s: AMRUSBInterface error (%ld): %@", v10, v11, v12, v13, v14, v15, (char)"_AMRUSBInterfaceReadPipe_block_invoke");
  }
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = a2;
  id result = [a3 getBytes:a1[6] length:a4];
  *(_DWORD *)(*(void *)(a1[5] + 8) + 24) = a4;
  return result;
}

void _AMRUSBInterfaceClose(void *a1)
{
  [a1 closeInterface];
}

uint64_t _AMRestoreUninitializeNotifications()
{
  if (_notificationPort)
  {
    IONotificationPortDestroy((IONotificationPortRef)_notificationPort);
    _notificationPort = 0;
  }
  if (_locationIDToDevice)
  {
    CFRelease((CFTypeRef)_locationIDToDevice);
    _locationIDToDevice = 0;
  }
  if (!qword_1000B8D50) {
    qword_1000B8D50 = 0;
  }
  if (!qword_1000B8D58) {
    qword_1000B8D58 = 0;
  }
  return 0;
}

uint64_t _AMRestoreInitializeNotifications(uint64_t a1)
{
  kern_return_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  kern_return_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v38;

  _loadAndCacheIOUSBLibBundle();
  int NumberOFDeviceIDsToMatch = _AMRestoreGetNumberOFDeviceIDsToMatch();
  int v2 = NumberOFDeviceIDsToMatch;
  p_info = FTABFile.info;
  if (!qword_1000B8D50) {
    qword_1000B8D50 = (uint64_t)malloc_type_calloc(NumberOFDeviceIDsToMatch, 4uLL, 0x100004052888210uLL);
  }
  if (!qword_1000B8D58) {
    qword_1000B8D58 = (uint64_t)malloc_type_calloc(v2, 4uLL, 0x100004052888210uLL);
  }
  uint64_t v4 = &_notificationPort;
  if (!_notificationPort)
  {
    _notificationPort = (uint64_t)IONotificationPortCreate(kIOMasterPortDefault);
    IONotificationPortSetDispatchQueue((IONotificationPortRef)_notificationPort, *(dispatch_queue_t *)(a1 + 40));
  }
  if (!_locationIDToDevice) {
    _locationIDToDevice = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  if (_shouldMatchIOUSBHostFamily()) {
    uint64_t v5 = "IOUSBHostDevice";
  }
  else {
    uint64_t v5 = "IOUSBDevice";
  }
  CFMutableDictionaryRef v6 = IOServiceMatching(v5);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  if (v2 >= 1)
  {
    uint64_t v8 = 0;
    unsigned int v9 = 0;
    while (1)
    {
      DeviceIDToMatch = _AMRestoreGetDeviceIDToMatch(v9);
      uint64_t v11 = (IONotificationPortRef *)v4;
      CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, DeviceIDToMatch);
      uint64_t v13 = p_info;
      CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, DeviceIDToMatch + 2);
      CFDictionarySetValue(v7, @"idVendor", v12);
      CFDictionarySetValue(v7, @"idProduct", v14);
      CFNumberRef v15 = v12;
      uint64_t v4 = (uint64_t *)v11;
      CFRelease(v15);
      CFNumberRef v16 = v14;
      p_info = v13;
      CFRelease(v16);
      CFRetain(v7);
      uint64_t v17 = IOServiceAddMatchingNotification(*v11, "IOServiceFirstMatch", v7, (IOServiceMatchingCallback)sub_10004215C, DeviceIDToMatch, (io_iterator_t *)((char *)&v13[426]->flags + v8));
      if (v17)
      {
        AMRLog(3, @"unable to set up device connected notification: 0x%x", v18, v19, v20, v21, v22, v23, v17);
        goto LABEL_23;
      }
      CFRetain(v7);
      uint64_t v24 = IOServiceAddMatchingNotification(*v11, "IOServiceTerminate", v7, (IOServiceMatchingCallback)sub_1000421A0, DeviceIDToMatch, (io_iterator_t *)(qword_1000B8D58 + v8));
      if (v24) {
        break;
      }
      sub_1000421E4((uint64_t)DeviceIDToMatch, *(uint32_t *)((char *)&v13[426]->flags + v8), a1);
      sub_10004247C((uint64_t)DeviceIDToMatch, *(_DWORD *)(qword_1000B8D58 + v8), a1);
      ++v9;
      v8 += 4;
      if (4 * v2 == v8) {
        goto LABEL_18;
      }
    }
    AMRLog(3, @"unable to set up device disconnected notification: 0x%x", v25, v26, v27, v28, v29, v30, v24);
LABEL_23:
    CFRelease(v7);
    return 0xFFFFFFFFLL;
  }
LABEL_18:
  CFRelease(v7);
  if (!_loadAndCacheIOUSBLibBundle()) {
    AMRLog(3, @"Failed to load any IOUSBLib.bundle. Bravely continuing.", v31, v32, v33, v34, v35, v36, v38);
  }
  return 0;
}

uint64_t sub_10004215C(uint64_t a1, io_iterator_t a2)
{
  uint64_t v4 = sub_10003C698();
  return sub_1000421E4(a1, a2, (uint64_t)v4);
}

uint64_t sub_1000421A0(uint64_t a1, io_iterator_t a2)
{
  uint64_t v4 = sub_10003C698();
  return sub_10004247C(a1, a2, (uint64_t)v4);
}

uint64_t sub_1000421E4(uint64_t a1, io_iterator_t iterator, uint64_t a3)
{
  kern_return_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFStringRef v23;
  CFNumberRef CFProperty;
  CFNumberRef v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  AMRLocalUSBDevice *v33;
  int v34;
  CFStringRef v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(uint64_t, void);
  const void *v44;
  void (**v45)(const void *, void);
  void (*v46)(uint64_t, void);
  char v47;
  uint64_t entryID;
  int valuePtr;
  mach_timespec_t waitTime;

  uint64_t result = IOIteratorNext(iterator);
  if (result)
  {
    uint64_t v7 = result;
    CFStringRef v8 = @"locationID";
    while (1)
    {
      entryID = 0;
      IORegistryEntryGetRegistryEntryID(v7, &entryID);
      AMRLog(7, @"device connected (isDFU = %d), registryID %#llx", v9, v10, v11, v12, v13, v14, *(unsigned char *)(a1 + 4));
      IOObjectRetain(v7);
      waitTime = (mach_timespec_t)5;
      CFNumberRef v15 = IOServiceWaitQuiet(v7, &waitTime);
      if (v15) {
        break;
      }
      CFProperty = (const __CFNumber *)IORegistryEntryCreateCFProperty(v7, v8, 0, 0);
      if (!CFProperty)
      {
        uint64_t v22 = 5;
        uint64_t v23 = @"a device with no location id was connected!";
        goto LABEL_5;
      }
      int v25 = CFProperty;
      if (!dword_1000B8D48
        || (unsigned __int16 valuePtr = 0, CFNumberGetValue(CFProperty, kCFNumberIntType, &valuePtr), dword_1000B8D48 == valuePtr))
      {
        if (!CFDictionaryGetValue((CFDictionaryRef)_locationIDToDevice, v25))
        {
          uint64_t v33 = sub_100042604(v7, v26, v27, v28, v29, v30, v31, v32);
          if (!v33)
          {
            CFRelease(v25);
            uint64_t v43 = *(void (**)(uint64_t, void))(a3 + 32);
            if (v43) {
              v43(2007, *(void *)(a3 + 48));
            }
            goto LABEL_6;
          }
          uint64_t v34 = *(_DWORD *)(a1 + 8);
          if (*(unsigned char *)(a1 + 4))
          {
            uint64_t v35 = v8;
            if (v34 == 2) {
              uint64_t v36 = _AMPortDFUModeDeviceCreate((uint64_t)kCFAllocatorDefault, (uint64_t)v33, 2);
            }
            else {
              uint64_t v36 = _AMDFUModeDeviceCreate((uint64_t)kCFAllocatorDefault, (uint64_t)v33, v34);
            }
            uint64_t v44 = (const void *)v36;
            uint64_t v45 = (void (**)(const void *, void))a3;
            if (v36)
            {
LABEL_26:
              (*v45)(v44, *(void *)(a3 + 48));
              CFDictionarySetValue((CFMutableDictionaryRef)_locationIDToDevice, v25, v44);
              CFRelease(v44);
LABEL_27:
              CFStringRef v8 = v35;
              CFRelease(v25);
              goto LABEL_6;
            }
          }
          else
          {
            uint64_t v35 = v8;
            uint64_t v44 = (const void *)_AMRecoveryModeDeviceCreate((uint64_t)kCFAllocatorDefault, v33);
            uint64_t v45 = (void (**)(const void *, void))(a3 + 8);
            if (v44) {
              goto LABEL_26;
            }
          }
          uint64_t v46 = *(void (**)(uint64_t, void))(a3 + 32);
          if (v46) {
            v46(18, *(void *)(a3 + 48));
          }
          else {
            AMRLog(3, @"an erorr occurred handling a connected device: 0x%x", v37, v38, v39, v40, v41, v42, 18);
          }
          goto LABEL_27;
        }
        AMRLog(5, @"a device with a duplicate location id was connected!", v27, v28, v29, v30, v31, v32, v47);
      }
      CFRelease(v25);
LABEL_6:
      IOObjectRelease(v7);
      IOObjectRelease(v7);
      uint64_t result = IOIteratorNext(iterator);
      uint64_t v7 = result;
      if (!result) {
        return result;
      }
    }
    uint64_t v47 = v15;
    uint64_t v22 = 3;
    uint64_t v23 = @"device did not go quiet after waiting: 0x%x";
LABEL_5:
    AMRLog(v22, v23, v16, v17, v18, v19, v20, v21, v47);
    goto LABEL_6;
  }
  return result;
}

uint64_t sub_10004247C(uint64_t a1, io_iterator_t iterator, uint64_t a3)
{
  uint64_t result = IOIteratorNext(iterator);
  if (result)
  {
    io_registry_entry_t v7 = result;
    do
    {
      uint64_t entryID = 0;
      IORegistryEntryGetRegistryEntryID(v7, &entryID);
      AMRLog(7, @"device disconnected (isDFU = %d), registryID %#llx", v8, v9, v10, v11, v12, v13, *(unsigned char *)(a1 + 4));
      CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v7, @"locationID", 0, 0);
      if (CFProperty && (__int16 v21 = CFProperty, v22 = CFGetTypeID(CFProperty), v22 == CFNumberGetTypeID()))
      {
        if (!dword_1000B8D48
          || (int valuePtr = 0, CFNumberGetValue((CFNumberRef)v21, kCFNumberIntType, &valuePtr), dword_1000B8D48 == valuePtr))
        {
          if (CFDictionaryGetValue((CFDictionaryRef)_locationIDToDevice, v21))
          {
            uint64_t v29 = 16;
            if (!*(unsigned char *)(a1 + 4)) {
              uint64_t v29 = 24;
            }
            (*(void (**)(void))(a3 + v29))();
            CFDictionaryRemoveValue((CFMutableDictionaryRef)_locationIDToDevice, v21);
          }
          else
          {
            AMRLog(5, @"an unknown device was disconnected!", v23, v24, v25, v26, v27, v28, v30);
          }
        }
        CFRelease(v21);
      }
      else
      {
        AMRLog(5, @"Tried to create a location ID for a disconnecting device but failed.", v15, v16, v17, v18, v19, v20, v30);
      }
      IOObjectRelease(v7);
      uint64_t result = IOIteratorNext(iterator);
      io_registry_entry_t v7 = result;
    }
    while (result);
  }
  return result;
}

AMRLocalUSBDevice *sub_100042604(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    char v8 = a1;
    uint64_t result = [[AMRLocalUSBDevice alloc] initWithService:a1];
    if (result) {
      return result;
    }
    AMRLog(3, @"Failed to create USB device with service %d", v10, v11, v12, v13, v14, v15, v8);
  }
  else
  {
    AMRLog(3, @"Tried to create a USB device with a null USB service.", a3, a4, a5, a6, a7, a8, v16);
  }
  return 0;
}

uint64_t _AMDFUModeDeviceCreate(uint64_t a1, uint64_t a2, int a3)
{
  pthread_once(&stru_1000B8A20, (void (*)(void))sub_1000426F0);
  uint64_t result = _CFRuntimeCreateInstance();
  if (result)
  {
    *(_WORD *)(result + 152) = 0;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(_DWORD *)(result + 32) = 0;
    *(void *)(result + 144) = a2;
    *(_DWORD *)(result + 156) = a3;
    *(_DWORD *)(result + 160) = 0;
    *(void *)(result + 168) = 0;
    *(unsigned char *)(result + 164) = 0;
  }
  return result;
}

uint64_t sub_1000426F0()
{
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1000B8D60 = result;
  return result;
}

void _AMDFUModeDeviceProgress(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMRLog(7, @"%@: operation %d progress %d", a3, a4, a5, a6, a7, a8, a1);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 16);
  if (v11) {
    v11(a1, a2, a3, *(void *)(a1 + 24));
  }
  *(_DWORD *)(a1 + 32) = a2;
  *(_DWORD *)(a1 + 36) = a3;
}

uint64_t _loadFirmwareInfoDFU(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 152)) {
    return 0;
  }
  uint64_t FirmwareInfo = _AMRUSBDeviceGetFirmwareInfo(*(void **)(a1 + 144), a1 + 40, 1);
  uint64_t v1 = FirmwareInfo;
  if (FirmwareInfo) {
    AMRLog(3, @"unable to get firmware info from device: %d", v4, v5, v6, v7, v8, v9, FirmwareInfo);
  }
  else {
    *(unsigned char *)(a1 + 152) = 1;
  }
  return v1;
}

uint64_t AMDFUModeDeviceIsBootstrapOnly(uint64_t a1, const __CFDictionary *a2)
{
  if (_loadFirmwareInfoDFU(a1))
  {
    AMRLog(3, @"unable to get firmware info from device", v4, v5, v6, v7, v8, v9, v11);
    return 0;
  }
  else
  {
    return AMRestoreDeviceIsBootstrapOnly(a2, (int *)(a1 + 40), v4, v5, v6, v7, v8, v9);
  }
}

uint64_t AMDFUModeDeviceGetECID(uint64_t a1)
{
  if (_loadFirmwareInfoDFU(a1)) {
    AMRLog(3, @"unable to get firmware info from device", v2, v3, v4, v5, v6, v7, v9);
  }
  return *(void *)(a1 + 112);
}

uint64_t AMDFUModeDeviceGetChipID(uint64_t a1)
{
  if (_loadFirmwareInfoDFU(a1)) {
    return 0;
  }
  else {
    return *(unsigned int *)(a1 + 40);
  }
}

uint64_t AMDFUModeDeviceGetProductionMode(uint64_t a1)
{
  if (_loadFirmwareInfoDFU(a1)) {
    return 0;
  }
  else {
    return *(unsigned __int8 *)(a1 + 128);
  }
}

uint64_t AMDFUModeDeviceGetBoardID(uint64_t a1)
{
  if (!_loadFirmwareInfoDFU(a1)) {
    return *(unsigned int *)(a1 + 44);
  }
  AMRLog(3, @"unable to get firmware info from device", v2, v3, v4, v5, v6, v7, v9);
  return 0xFFFFFFFFLL;
}

void _AMRestoreDFUPropertyOverrideApplier(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

uint64_t _AMRestoreAPOverrideApplier(const void *a1, const void *a2, const void *a3)
{
  return AMAuthInstallSetApRequestEntry(a3, a1, a2);
}

CFDataRef _createDFUDataFromFile(const __CFString *a1, const __CFData *a2)
{
  bzero(buffer, 0x400uLL);
  CFStringGetFileSystemRepresentation(a1, buffer, 1024);
  int v4 = open(buffer, 0, 0);
  if (v4 == -1)
  {
    char v9 = __error();
    char v10 = strerror(*v9);
    AMRLogWithFilePath(3, (uint64_t)a1, @"unable to open DFU file: %s", v11, v12, v13, v14, v15, v10);
    return 0;
  }
  int v5 = v4;
  memset(&v29, 0, sizeof(v29));
  if (fstat(v4, &v29) == -1)
  {
    uint64_t v17 = 0;
  }
  else
  {
    if (a2)
    {
      CFIndex Length = CFDataGetLength(a2);
      size_t v7 = Length;
      if ((Length & 0x3F) != 0) {
        size_t v8 = 64 - (Length & 0x3F);
      }
      else {
        size_t v8 = 0;
      }
    }
    else
    {
      size_t v7 = 0;
      size_t v8 = 0;
    }
    size_t v18 = v8 + v7;
    off_t v19 = v29.st_size + v8 + v7 + 16;
    uint64_t v17 = (char *)malloc_type_malloc(v19, 0xEB499B6CuLL);
    if (v17)
    {
      if (a2)
      {
        BytePtr = CFDataGetBytePtr(a2);
        memcpy(v17, BytePtr, v7);
        memset(&v17[v7], 255, v8);
      }
      ssize_t v21 = read(v5, &v17[v7 + v8], v29.st_size);
      if (v21 == v29.st_size)
      {
        CFTypeID v22 = &v17[v7 + v8 + v21];
        *(void *)CFTypeID v22 = 0x10005ACFFFFFFFFLL;
        *((_DWORD *)v22 + 2) = 272909909;
        size_t v23 = v29.st_size + v18;
        if (v29.st_size + v18)
        {
          unsigned int v24 = -1;
          uint64_t v25 = v17;
          do
          {
            char v26 = *v25++;
            unsigned int v24 = dword_10007E330[(v26 ^ v24)] ^ (v24 >> 8);
            --v23;
          }
          while (v23);
        }
        else
        {
          unsigned int v24 = -1;
        }
        for (uint64_t i = 0; i != 12; ++i)
          unsigned int v24 = dword_10007E330[(v22[i] ^ v24)] ^ (v24 >> 8);
        *((_DWORD *)v22 + 3) = v24;
        CFDataRef v16 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)v17, v19, kCFAllocatorMalloc);
        goto LABEL_19;
      }
    }
  }
  CFDataRef v16 = 0;
LABEL_19:
  close(v5);
  if (v17 && !v16) {
    free(v17);
  }
  return v16;
}

uint64_t AMRestorePerformDFURestore(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4)
{
  CFDataRef v177 = 0;
  AMRestoreCaptureSubsystemLogsIfNeeded();
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a2);
  if (!MutableCopy)
  {
    AMRLog(3, @"unable to create mutable copy of options", v9, v10, v11, v12, v13, v14, v169);
LABEL_196:
    AMRLog(6, @"%@: DFU succeeded", v26, v27, v28, v29, v30, v31, a1);
    return 0;
  }
  CFDictionaryRef v15 = MutableCopy;
  if (!*(void *)(a1 + 168))
  {
    _AMDFUModeDeviceProgress(a1, 45, 0xFFFFFFFFLL, v10, v11, v12, v13, v14);
    value[0] = 0;
    uint64_t v42 = AMDFUModeDeviceCopyAuthInstallPreflightOptions(a1, v15, (CFTypeRef *)value);
    if (v42)
    {
      uint64_t v25 = v42;
LABEL_193:
      CFRelease(v15);
      goto LABEL_194;
    }
    CFRelease(v15);
    CFDictionaryRef v15 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)value[0]);
    CFRelease(value[0]);
  }
  CFStringRef v23 = (const __CFString *)CFDictionaryGetValue(v15, @"PersonalizedRestoreBundlePath");
  if (v23)
  {
    if (AMRestoreOptionsAreLegacy(v15, v16, v17, v18, v19, v20, v21, v22))
    {
      uint64_t v24 = AMRAuthInstallAlignOptionsToPersonalizedBundle(v15, v23, 1);
      if (v24)
      {
        uint64_t v25 = v24;
        AMRLog(3, @"failed to align options with personalized bundle", v17, v18, v19, v20, v21, v22, v169);
        goto LABEL_187;
      }
    }
  }
  if (AMRestoreOptionsAreLegacy(v15, v16, v17, v18, v19, v20, v21, v22))
  {
    if (v15)
    {
      uint64_t v39 = CFDictionaryGetValue(v15, @"RestoreBundlePath");
      if (v39)
      {
        value[0] = 0;
        int PathsForBundle = AMRestoreCreatePathsForBundle((uint64_t)v39, 0, 0, 0, 0, 0, 0, value);
        uint64_t v33 = value[0];
        if (!PathsForBundle && value[0] != 0)
        {
          CFDictionaryAddValue(v15, @"FirmwareDirectory", value[0]);
          CFRelease(value[0]);
        }
      }
    }
    else
    {
      AMRLog(3, @"Cannot resolve bundle path options without options", (uint64_t)v33, v34, v35, v36, v37, v38, v169);
    }
  }
  CFTypeRef v178 = 0;
  CFStringRef v179 = 0;
  if (AMRestoreOptionsAreLegacy(v15, v32, (uint64_t)v33, v34, v35, v36, v37, v38))
  {
    CFStringRef v49 = (const __CFString *)CFDictionaryGetValue(v15, @"DFUFile");
    if (v49)
    {
      CFStringRef v56 = v49;
      uint64_t v57 = CFDictionaryGetValue(v15, @"OnlyPersonalizeDFUFile");
      if (v57 && CFEqual(v57, kCFBooleanTrue))
      {
        bzero(value, 0x400uLL);
        CFTypeRef v185 = 0;
        CFTypeRef cf = 0;
        CFTypeRef v183 = 0;
        CFTypeRef v184 = 0;
        CFTypeRef v182 = 0;
        int v181 = 0;
        CFTypeRef v180 = 0;
        CFURLRef v58 = (const __CFURL *)AMAuthInstallCreate(kCFAllocatorDefault);
        if (!v58)
        {
          CFStringRef v60 = 0;
          CFURLRef PathComponent = 0;
LABEL_129:
          if (v185) {
            CFRelease(v185);
          }
          if (v184) {
            CFRelease(v184);
          }
          if (v183) {
            CFRelease(v183);
          }
          if (v182) {
            CFRelease(v182);
          }
          if (v180) {
            CFRelease(v180);
          }
          if (!PathComponent) {
            goto LABEL_164;
          }
          char v123 = PathComponent;
          goto LABEL_163;
        }
        CFURLRef v59 = v58;
        if (AMRAuthInstallConfigureUsingOptions(v58, v15, 0, 0))
        {
          CFStringRef v60 = 0;
          CFURLRef v61 = v59;
          CFMutableDictionaryRef Mutable = 0;
          CFURLRef PathComponent = 0;
LABEL_125:
          CFRelease(v61);
          if (cf) {
            CFRelease(cf);
          }
          if (Mutable) {
            CFRelease(Mutable);
          }
          goto LABEL_129;
        }
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (!Mutable) {
          goto LABEL_124;
        }
        uint64_t ECID = AMDFUModeDeviceGetECID(a1);
        AMAuthInstallSupportDictionarySetInteger64(Mutable, @"ECID", ECID);
        if (_loadFirmwareInfoDFU(a1)) {
          uint64_t v80 = 0;
        }
        else {
          uint64_t v80 = *(unsigned int *)(a1 + 40);
        }
        AMAuthInstallSupportDictionarySetInteger32(Mutable, @"ApChipID", v80);
        uint64_t BoardID = AMDFUModeDeviceGetBoardID(a1);
        AMAuthInstallSupportDictionarySetInteger32(Mutable, @"ApBoardID", BoardID);
        if (_loadFirmwareInfoDFU(a1)) {
          uint64_t v98 = 0;
        }
        else {
          uint64_t v98 = *(unsigned int *)(a1 + 124);
        }
        AMAuthInstallSupportDictionarySetInteger32(Mutable, @"ApSecurityDomain", v98);
        if (_loadFirmwareInfoDFU(a1)) {
          int v99 = 0;
        }
        else {
          int v99 = *(unsigned __int8 *)(a1 + 128);
        }
        AMAuthInstallSupportDictionarySetBoolean(Mutable, @"ApProductionMode", v99);
        if (_loadFirmwareInfoDFU(a1)) {
          int v100 = 0;
        }
        else {
          int v100 = *(unsigned __int8 *)(a1 + 129);
        }
        AMAuthInstallSupportDictionarySetBoolean(Mutable, @"ApSecurityMode", v100);
        if (_loadFirmwareInfoDFU(a1)) {
          int v101 = 0;
        }
        else {
          int v101 = *(unsigned __int8 *)(a1 + 132);
        }
        AMAuthInstallSupportDictionarySetBoolean(Mutable, @"ApEffectiveSecurityMode", v101);
        if (_loadFirmwareInfoDFU(a1)) {
          int v102 = 0;
        }
        else {
          int v102 = *(unsigned __int8 *)(a1 + 131);
        }
        AMAuthInstallSupportDictionarySetBoolean(Mutable, @"ApEffectiveProductionMode", v102);
        AMAuthInstallSupportDictionarySetBoolean(Mutable, @"ApInRomDFU", 1);
        uint64_t v103 = *(const void **)(a1 + 136);
        if (v103) {
          CFDictionarySetValue(Mutable, @"ApSikaFuse", v103);
        }
        if (*(unsigned char *)(a1 + 130)) {
          AMAuthInstallSupportDictionarySetBoolean(Mutable, @"UIDMode", 1);
        }
        CFBooleanRef v104 = (const __CFBoolean *)CFDictionaryGetValue(v15, @"RequiresUIDMode");
        if (v104 && CFBooleanGetValue(v104) == 1) {
          CFDictionarySetValue(Mutable, @"RequiresUIDMode", kCFBooleanTrue);
        }
        uint64_t v105 = CFDictionaryGetValue(v15, @"UIDMode");
        if (v105)
        {
          uint64_t v106 = v105;
          CFTypeID TypeID = CFBooleanGetTypeID();
          if (TypeID == CFGetTypeID(v106)) {
            CFDictionarySetValue(Mutable, @"UIDMode", v106);
          }
        }
        BOOL IBFL = _AMRUSBDeviceGetIBFL(*(void **)(a1 + 144), &v181);
        int v109 = *(_DWORD *)&IBFL & ((v181 & 4) >> 2);
        if (v109 == 1)
        {
          CFBooleanRef v110 = (const __CFBoolean *)CFDictionaryGetValue(v15, @"AuthInstallAllowMixAndMatch");
          if (v110 && CFBooleanGetValue(v110) == 1) {
            CFDictionaryAddValue(Mutable, @"ApAllowMixAndMatch", kCFBooleanTrue);
          }
          CFDictionarySetValue(Mutable, @"ApSupportsImg4", kCFBooleanTrue);
          if ((v181 & 0x20) != 0) {
            CFDictionarySetValue(Mutable, @"ApImg4DigestType", @"sha2-384");
          }
          uint64_t v111 = CFDictionaryGetValue(v15, @"SkipNoncesForAPSEP");
          if (!v111
            || (uint64_t v112 = v111, v113 = CFBooleanGetTypeID(), v113 != CFGetTypeID(v112))
            || CFBooleanGetValue((CFBooleanRef)v112) != 1)
          {
            if (!_AMRUSBDeviceCopyNonce(*(void **)(a1 + 144), &v185))
            {
              int v114 = CFGetAllocator(v59);
              if (!AMAuthInstallSupportCopyDataFromHexString(v114, (CFStringRef)v185, (uint64_t *)&v184))
              {
                if (v184) {
                  CFDictionarySetValue(Mutable, @"ApNonce", v184);
                }
              }
            }
            if (!_AMRUSBDeviceCopySEPNonce(*(void **)(a1 + 144), &v183))
            {
              int v115 = CFGetAllocator(v59);
              if (!AMAuthInstallSupportCopyDataFromHexString(v115, (CFStringRef)v183, (uint64_t *)&v182))
              {
                if (v182) {
                  CFDictionarySetValue(Mutable, @"SepNonce", v182);
                }
              }
            }
          }
        }
        uint64_t v116 = CFDictionaryGetValue(v15, @"AuthInstallDemotionPolicyOverride");
        if (v116) {
          CFDictionarySetValue(Mutable, @"DemotionPolicy", v116);
        }
        if (AMAuthInstallApSetParameters((uint64_t)v59, Mutable)
          || AMRAuthInstallSetFDRTrustObjectHash((int)v59, v15))
        {
LABEL_124:
          CFStringRef v60 = 0;
          CFURLRef PathComponent = 0;
          CFURLRef v61 = v59;
          goto LABEL_125;
        }
        if (AMRAuthInstallEnablePersonalization((uint64_t)v59, v15))
        {
          AMRLog(3, @"%s: AMRAuthInstallEnablePersonalization failed", v117, v118, v119, v120, v121, v122, (char)"_copyPersonalizedFileForDFUDevice");
          goto LABEL_124;
        }
        CFURLRef v160 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v56, kCFURLPOSIXPathStyle, 0);
        if (!v160) {
          goto LABEL_124;
        }
        CFURLRef v61 = v160;
        CFURLRef PathComponent = (__CFString *)CFURLCopyLastPathComponent(v160);
        if (!PathComponent)
        {
          CFStringRef v60 = 0;
          uint64_t v163 = (__CFString *)v59;
          goto LABEL_227;
        }
        LOBYTE(v169) = (_BYTE)PathComponent;
        AMDFUModeDeviceGetECID(a1);
        char v175 = PathComponent;
        CFURLRef PathComponent = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@_%llx.personalized");
        char v174 = PathComponent;
        if (!PathComponent) {
          goto LABEL_225;
        }
        URLForTempDirectoryRoot = (const void *)AMAuthInstallSupportGetURLForTempDirectoryRoot();
        if (AMAuthInstallSupportCopyURLWithAppendedComponent(kCFAllocatorDefault, URLForTempDirectoryRoot, PathComponent, 0, (CFURLRef *)&cf)|| (CFDataRef v162 = (const __CFData *)CFDictionaryGetValue(v15, @"RequestRestoreRulesDeviceMap"), AMAuthInstallApCreateImagePropertiesWithDeviceMap(v59, v61, v162, (CFDictionaryRef *)&v180)))
        {
          CFStringRef v60 = 0;
          CFURLRef PathComponent = 0;
          goto LABEL_226;
        }
        CFURLRef PathComponent = (__CFString *)CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)v180);
        if (!PathComponent) {
          goto LABEL_225;
        }
        CFDictionaryRef v164 = (const __CFDictionary *)CFDictionaryGetValue(v15, @"RequestOverrides");
        if (v164)
        {
          CFDictionaryRef v165 = v164;
          CFTypeID v172 = CFGetTypeID(v164);
          if (v172 == CFDictionaryGetTypeID()) {
            CFDictionaryApplyFunction(v165, (CFDictionaryApplierFunction)_AMRestoreDFUPropertyOverrideApplier, PathComponent);
          }
        }
        uint64_t v166 = CFDictionaryGetValue(v15, @"ImageTrusted");
        if (v166)
        {
          uint64_t v167 = v166;
          CFTypeID v173 = CFGetTypeID(v166);
          if (v173 == CFBooleanGetTypeID()) {
            CFDictionarySetValue((CFMutableDictionaryRef)PathComponent, @"Trusted", v167);
          }
        }
        CFDictionaryRef v168 = (const __CFDictionary *)CFDictionaryGetValue(v15, @"ApRequestEntries");
        if (v168) {
          CFDictionaryApplyFunction(v168, (CFDictionaryApplierFunction)_AMRestoreAPOverrideApplier, v59);
        }
        if (v109)
        {
          if (AMAuthInstallApImg4PersonalizeFile((uint64_t)v59, v61, (const __CFURL *)cf, PathComponent)) {
            goto LABEL_225;
          }
        }
        else if (AMAuthInstallApImg3PersonalizeFile(v59, v61, (const __CFURL *)cf, PathComponent))
        {
          goto LABEL_225;
        }
        if (CFURLGetFileSystemRepresentation((CFURLRef)cf, 1u, (UInt8 *)value, 1024))
        {
          CFStringRef v60 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)value, 0x8000100u);
          goto LABEL_226;
        }
LABEL_225:
        CFStringRef v60 = 0;
LABEL_226:
        CFRelease(v59);
        CFRelease(v175);
        uint64_t v163 = v174;
        if (!v174) {
          goto LABEL_125;
        }
LABEL_227:
        CFRelease(v163);
        goto LABEL_125;
      }
      CFAllocatorRef v65 = kCFAllocatorDefault;
      CFStringRef v66 = v56;
      goto LABEL_31;
    }
    int v68 = *(_DWORD *)(a1 + 156);
    if (v68 == 1)
    {
      uint64_t v71 = CFDictionaryGetValue(v15, @"FirmwareDirectory");
      if (!v71) {
        goto LABEL_54;
      }
      uint64_t v72 = v71;
      CFStringRef v73 = (const __CFString *)CFDictionaryGetValue(v15, @"DFUFileType");
      uint64_t v74 = v73 ? (__CFString *)v73 : @"RELEASE";
      LOBYTE(v169) = _AMRUSBDeviceGetProductID(*(void **)(a1 + 144));
      CFStringRef v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"x%hX");
      if (!v75) {
        goto LABEL_54;
      }
      CFStringRef v76 = v75;
      LOBYTE(v169) = (_BYTE)v72;
      CFStringRef v60 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/dfu/WTF.%@.%@.dfu");
      if (!v60
        || (bzero(value, 0x400uLL),
            CFStringGetFileSystemRepresentation(v60, (char *)value, 1024),
            access((const char *)value, 0) != -1))
      {
LABEL_162:
        char v123 = (__CFString *)v76;
LABEL_163:
        CFRelease(v123);
        goto LABEL_164;
      }
      CFRelease(v60);
      CFStringRef v77 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/dfu/FIRMWARE.%@.%@.dfu", v72, v76, v74);
    }
    else
    {
      if (v68)
      {
        int v169 = *(_DWORD *)(a1 + 156);
        CFStringRef v78 = @"don't know how to find DFU file for device type %d";
LABEL_53:
        AMRLog(3, v78, v50, v51, v52, v53, v54, v55, v169);
        goto LABEL_54;
      }
      CFStringRef v69 = (const __CFString *)CFDictionaryGetValue(v15, @"DFUFile");
      if (v69)
      {
        CFStringRef v66 = v69;
        CFAllocatorRef v65 = kCFAllocatorDefault;
LABEL_31:
        CFStringRef Copy = CFStringCreateCopy(v65, v66);
LABEL_32:
        CFStringRef v60 = Copy;
LABEL_164:
        CFStringRef v70 = 0;
        CFStringRef v179 = v60;
        goto LABEL_165;
      }
      uint64_t v87 = CFDictionaryGetValue(v15, @"FirmwareDirectory");
      if (!v87)
      {
LABEL_54:
        CFStringRef v60 = 0;
        goto LABEL_164;
      }
      uint64_t v88 = v87;
      if (_AMRUSBDeviceGetProductID(*(void **)(a1 + 144)) == 4642
        && _AMRUSBDeviceGetDeviceReleaseNumber(*(void **)(a1 + 144)) == 1)
      {
        LOBYTE(v169) = (_BYTE)v88;
        CFStringRef Copy = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/dfu/WTF.s5l8900xall.RELEASE.dfu");
        goto LABEL_32;
      }
      if (_loadFirmwareInfoDFU(a1))
      {
        CFStringRef v78 = @"unable to get firmware info from device";
        goto LABEL_53;
      }
      if (*(unsigned char *)(a1 + 128) == 1) {
        AMRLog(4, @"%@: production fused device", v50, v51, v52, v53, v54, v55, a1);
      }
      CFStringRef v126 = (const __CFString *)CFDictionaryGetValue(v15, @"BoardConfig");
      if (v126)
      {
        CFStringRef v76 = v126;
        CFRetain(v126);
      }
      else
      {
        uint64_t v194 = 0;
        memset(v193, 0, sizeof(v193));
        long long v191 = 0u;
        long long v192 = 0u;
        long long v190 = 0u;
        long long v188 = 0u;
        long long v189 = 0u;
        *(_OWORD *)CFDictionaryRef value = 0u;
        if (_AMRestoreGetDeviceMapEntryForHardware(v15, (_DWORD *)(a1 + 40), (char *)value, v127, v128, v129, v130, v131) != 1)goto LABEL_54; {
        CFStringRef v76 = CFStringCreateWithCString(kCFAllocatorDefault, &v193[8], 0x8000100u);
        }
        if (!v76) {
          goto LABEL_54;
        }
      }
      CFStringRef v132 = (const __CFString *)CFDictionaryGetValue(v15, @"DFUFileType");
      if (v132) {
        CFStringRef v133 = v132;
      }
      else {
        CFStringRef v133 = @"DEVELOPMENT";
      }
      if (*(_DWORD *)(a1 + 52) || (*(unsigned char *)(a1 + 56) & 1) != 0) {
        CFStringRef v134 = @"iBEC";
      }
      else {
        CFStringRef v134 = @"iBSS";
      }
      value[0] = 0;
      if (!AMRAuthInstallCreatePathFromBundle(*(void **)(a1 + 168), v15, v134, (CFStringRef *)value))
      {
        CFStringRef v60 = (const __CFString *)value[0];
        goto LABEL_162;
      }
      CFStringRef v77 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/dfu/%@.%@.%@.dfu", v88, v134, v76, v133);
    }
    CFStringRef v60 = v77;
    goto LABEL_162;
  }
  if (!v15)
  {
    CFStringRef v64 = @"Can't get DFU file for NULL options";
    goto LABEL_42;
  }
  if (_loadFirmwareInfoDFU(a1))
  {
    CFStringRef v64 = @"Failed to get firmware info from device for DFU file selection";
LABEL_42:
    AMRLog(3, v64, v43, v44, v45, v46, v47, v48, v169);
LABEL_43:
    CFStringRef v70 = 0;
    goto LABEL_165;
  }
  if (*(unsigned char *)(a1 + 128)) {
    AMRLog(4, @"%@: production fused device", v43, v44, v45, v46, v47, v48, a1);
  }
  if (AMRAuthInstallCopyPathToFirmware(v15, (CFStringRef *)&v178))
  {
    CFStringRef v64 = @"Failed to get firmware directory to locate WTF file.";
    goto LABEL_42;
  }
  int v81 = *(_DWORD *)(a1 + 156);
  if (v81 != 1)
  {
    if (v81) {
      goto LABEL_43;
    }
    if (_AMRUSBDeviceGetProductID(*(void **)(a1 + 144)) != 4642
      || _AMRUSBDeviceGetDeviceReleaseNumber(*(void **)(a1 + 144)) != 1)
    {
      if (*(_DWORD *)(a1 + 52) || (*(unsigned char *)(a1 + 56) & 1) != 0) {
        CFRange v124 = kAMAuthInstallBuildIdentityApiBECKey;
      }
      else {
        CFRange v124 = kAMAuthInstallBuildIdentityApiBSSKey;
      }
      CFStringRef v125 = *v124;
      if (AMRAuthInstallCopyFileSystemPathForKey(*(void **)(a1 + 168), v15, *v124, &v179, v82, v83, v84, v85))AMRLog(3, @"Failed to locate DFU file for type %@", v43, v44, v45, v46, v47, v48, (char)v125); {
      goto LABEL_43;
      }
    }
    LOBYTE(v169) = (_BYTE)v178;
    CFStringRef v86 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/dfu/WTF.s5l8900xall.RELEASE.dfu");
    CFStringRef v70 = 0;
LABEL_74:
    CFStringRef v179 = v86;
    goto LABEL_165;
  }
  char ProductID = _AMRUSBDeviceGetProductID(*(void **)(a1 + 144));
  CFStringRef v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"x%hX");
  if (!v70)
  {
    AMRLog(3, @"Failed to create product ID strign for traditional iPod", v89, v90, v91, v92, v93, v94, ProductID);
    goto LABEL_165;
  }
  LOBYTE(v169) = (_BYTE)v178;
  CFStringRef v95 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/dfu/WTF.%@.RELEASE.dfu");
  CFStringRef v179 = v95;
  if (v95)
  {
    CFStringRef v96 = v95;
    bzero(value, 0x400uLL);
    CFStringGetFileSystemRepresentation(v96, (char *)value, 1024);
    if (access((const char *)value, 0) == -1)
    {
      CFRelease(v96);
      LOBYTE(v169) = (_BYTE)v178;
      CFStringRef v86 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/dfu/FIRMWARE.%@.RELEASE.dfu");
      goto LABEL_74;
    }
  }
LABEL_165:
  if (v178) {
    CFRelease(v178);
  }
  if (v70) {
    CFRelease(v70);
  }
  CFStringRef v135 = v179;
  if (!v179)
  {
    AMRLog(3, @"_copyPathToDFUFile failed", v43, v44, v45, v46, v47, v48, v169);
    uint64_t v25 = 1;
    goto LABEL_187;
  }
  int v176 = 0;
  if (_AMRUSBDeviceGetIBFL(*(void **)(a1 + 144), &v176) && (v176 & 2) != 0) {
    AMRAuthInstallCopyTicketData(*(const void **)(a1 + 168), v15, (CFTypeRef *)&v177);
  }
  AMRLog(8, @"using DFU file: %@", v136, v137, v138, v139, v140, v141, (char)v135);
  if (*(unsigned char *)(a1 + 153)) {
    goto LABEL_174;
  }
  uint64_t v150 = _AMRUSBDeviceOpen(*(void **)(a1 + 144));
  if (!v150)
  {
    *(unsigned char *)(a1 + 153) = 1;
LABEL_174:
    DFUDataFromuint64_t File = _createDFUDataFromFile(v135, v177);
    if (DFUDataFromFile)
    {
      CFDataRef v143 = DFUDataFromFile;
      uint64_t v25 = AMRPerformDFUDataDownload(*(void **)(a1 + 144), DFUDataFromFile, (void (*)(unint64_t, uint64_t))sub_10004442C, a1);
      CFRelease(v143);
      if (*(unsigned char *)(a1 + 164))
      {
        AMRLog(3, @"The user requested cancel restore", v144, v145, v146, v147, v148, v149, v171);
        uint64_t v25 = 99;
      }
    }
    else
    {
      uint64_t v25 = 11;
    }
    goto LABEL_181;
  }
  uint64_t v25 = v150;
  AMRLog(3, @"unable to open DFU device: %d", v151, v152, v153, v154, v155, v156, v150);
LABEL_181:
  uint64_t v157 = CFDictionaryGetValue(v15, @"OnlyPersonalizeDFUFile");
  if (v157)
  {
    if (CFEqual(v157, kCFBooleanTrue) == 1 && CFDictionaryGetValue(v15, @"PreserveBundle") == kCFBooleanFalse)
    {
      bzero(value, 0x400uLL);
      if (CFStringGetCString(v135, (char *)value, 1024, 0x8000100u) == 1) {
        unlink((const char *)value);
      }
    }
  }
  CFRelease(v135);
LABEL_187:
  if (v23) {
    BOOL v158 = v25 == 0;
  }
  else {
    BOOL v158 = 1;
  }
  if (!v158) {
    AMRAuthInstallDeletePersonalizedBundle(v23, v15);
  }
  if (v15) {
    goto LABEL_193;
  }
LABEL_194:
  if (!v25) {
    goto LABEL_196;
  }
  AMRLog(3, @"%@: DFU failed (uint64_t result = %d)", v26, v27, v28, v29, v30, v31, a1);
  return v25;
}

uint64_t AMDFUModeDeviceCopyAuthInstallPreflightOptions(uint64_t a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  AMRestoreCaptureSubsystemLogsIfNeeded();
  if (a1 && a2 && a3)
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a2);
    if (MutableCopy)
    {
      CFDictionaryRef v19 = MutableCopy;
      if (*(void *)(a1 + 168))
      {
        AMRLog(7, @"authinstall has already been configured for this device", v13, v14, v15, v16, v17, v18, v143);
        goto LABEL_7;
      }
      int FirmwareInfoDFU = _loadFirmwareInfoDFU(a1);
      if (FirmwareInfoDFU) {
        AMRLog(3, @"unable to get firmware info from device: %d", v30, v31, v32, v33, v34, v35, FirmwareInfoDFU);
      }
      int v36 = _AMRUSBDeviceAddNonceWithInfo(*(void **)(a1 + 144), a1 + 40, v30, v31, v32, v33, v34, v35);
      if (v36) {
        AMRLog(3, @"unable to get nonce info from device: %d", v37, v38, v39, v40, v41, v42, v36);
      }
      CFAllocatorRef v43 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v44 = AMAuthInstallCreate(v43);
      if (v44)
      {
        uint64_t v51 = (CFDictionaryRef *)v44;
        CFAllocatorRef v52 = CFGetAllocator((CFTypeRef)a1);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v52, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          CFStringRef v60 = Mutable;
          AMAuthInstallSupportDictionarySetInteger64(Mutable, @"ECID", *(void *)(a1 + 112));
          AMAuthInstallSupportDictionarySetInteger32(v60, @"ApChipID", *(unsigned int *)(a1 + 40));
          AMAuthInstallSupportDictionarySetInteger32(v60, @"ApBoardID", *(unsigned int *)(a1 + 44));
          AMAuthInstallSupportDictionarySetInteger32(v60, @"ApSecurityDomain", *(unsigned int *)(a1 + 124));
          CFURLRef v61 = *(const void **)(a1 + 136);
          if (v61) {
            CFDictionarySetValue(v60, @"ApSikaFuse", v61);
          }
          if (*(unsigned char *)(a1 + 130)) {
            AMAuthInstallSupportDictionarySetBoolean(v60, @"UIDMode", 1);
          }
          AMAuthInstallSupportDictionarySetBoolean(v60, @"ApProductionMode", *(unsigned __int8 *)(a1 + 128));
          if (_loadFirmwareInfoDFU(a1)) {
            int v62 = 0;
          }
          else {
            int v62 = *(unsigned __int8 *)(a1 + 129);
          }
          AMAuthInstallSupportDictionarySetBoolean(v60, @"ApSecurityMode", v62);
          if (_loadFirmwareInfoDFU(a1)) {
            int v63 = 0;
          }
          else {
            int v63 = *(unsigned __int8 *)(a1 + 132);
          }
          AMAuthInstallSupportDictionarySetBoolean(v60, @"ApEffectiveSecurityMode", v63);
          if (_loadFirmwareInfoDFU(a1)) {
            int v64 = 0;
          }
          else {
            int v64 = *(unsigned __int8 *)(a1 + 131);
          }
          AMAuthInstallSupportDictionarySetBoolean(v60, @"ApEffectiveProductionMode", v64);
          AMAuthInstallSupportDictionarySetBoolean(v60, @"ApInRomDFU", 1);
          CFBooleanRef Value = CFDictionaryGetValue(v19, @"SkipNoncesForAPSEP");
          BOOL v68 = Value
             && (v66 = Value, CFTypeID TypeID = CFBooleanGetTypeID(), TypeID == CFGetTypeID(v66))
             && CFBooleanGetValue((CFBooleanRef)v66) == 1;
          CFBooleanRef v69 = (const __CFBoolean *)CFDictionaryGetValue(v19, @"AuthInstallRequestTicketWithoutNonce");
          if (v69 && (CFBooleanRef v70 = v69, v71 = CFBooleanGetTypeID(), v71 == CFGetTypeID(v70)))
          {
            char v72 = CFBooleanGetValue(v70) == 1 || v68;
            if (v72)
            {
LABEL_49:
              if (!v68)
              {
                uint64_t v74 = *(const void **)(a1 + 96);
                if (v74) {
                  CFDictionarySetValue(v60, @"SepNonce", v74);
                }
              }
LABEL_52:
              int v144 = 0;
              if (_AMRUSBDeviceGetIBFL(*(void **)(a1 + 144), &v144) && (v144 & 4) != 0)
              {
                CFDictionarySetValue(v60, @"ApSupportsImg4", kCFBooleanTrue);
                if ((v144 & 0x20) != 0) {
                  CFDictionarySetValue(v60, @"ApImg4DigestType", @"sha2-384");
                }
              }
              CFStringRef v75 = CFDictionaryGetValue(v19, @"UserLocale");
              uint64_t v76 = AMAuthInstallSetLocale((uint64_t)v51, v75);
              if (v76)
              {
                uint64_t v28 = AMAuthInstallToRestoreError(v76);
LABEL_95:
                CFRelease(v60);
LABEL_96:
                if (!v28)
                {
LABEL_7:
                  uint64_t v20 = CFDictionaryGetValue(v19, @"OnlyPersonalizeDFUFile");
                  if (v20 && CFEqual(v20, kCFBooleanTrue)
                    || (uint64_t v21 = sub_10004C12C(*(__CFString **)(a1 + 168), v19, (*(_DWORD *)(a1 + 56) >> 6) & 1),
                        !v21))
                  {
                    uint64_t v28 = 0;
                    *a3 = CFRetain(v19);
                  }
                  else
                  {
                    uint64_t v28 = v21;
                    AMRLog(3, @"%s: failed to personalize bundle", v22, v23, v24, v25, v26, v27, (char)"AMDFUModeDeviceCopyAuthInstallPreflightOptions");
                  }
                  goto LABEL_98;
                }
LABEL_97:
                AMRLog(3, @"%s: failed to configure authinstall", v45, v46, v47, v48, v49, v50, (char)"AMDFUModeDeviceCopyAuthInstallPreflightOptions");
LABEL_98:
                CFRelease(v19);
                return v28;
              }
              CFStringRef v77 = CFDictionaryGetValue(v19, @"AuthInstallAllowMixAndMatch");
              if (v77)
              {
                CFStringRef v78 = v77;
                CFTypeID v79 = CFBooleanGetTypeID();
                if (v79 == CFGetTypeID(v78) && CFBooleanGetValue((CFBooleanRef)v78) == 1) {
                  CFDictionaryAddValue(v60, @"ApAllowMixAndMatch", kCFBooleanTrue);
                }
              }
              uint64_t v80 = CFDictionaryGetValue(v19, @"AuthInstallDemotionPolicyOverride");
              if (v80) {
                CFDictionarySetValue(v60, @"DemotionPolicy", v80);
              }
              int v81 = CFDictionaryGetValue(v19, @"RequiresUIDMode");
              if (v81)
              {
                uint64_t v82 = v81;
                CFTypeID v83 = CFBooleanGetTypeID();
                if (v83 == CFGetTypeID(v82) && CFBooleanGetValue((CFBooleanRef)v82) == 1) {
                  CFDictionarySetValue(v60, @"RequiresUIDMode", kCFBooleanTrue);
                }
              }
              uint64_t v84 = CFDictionaryGetValue(v19, @"UIDMode");
              if (v84)
              {
                uint64_t v85 = v84;
                CFTypeID v86 = CFBooleanGetTypeID();
                if (v86 == CFGetTypeID(v85)) {
                  CFDictionarySetValue(v60, @"UIDMode", v85);
                }
              }
              uint64_t v87 = AMAuthInstallApSetParameters((uint64_t)v51, v60);
              if (v87)
              {
                uint64_t v88 = v87;
                char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString(v51, v87);
                AMRLog(3, @"Failed to set ap parameters: %@", v90, v91, v92, v93, v94, v95, LocalizedStatusString);
                uint64_t v28 = AMAuthInstallToRestoreError(v88);
                CFRelease(v51);
                goto LABEL_95;
              }
              CFStringRef v96 = (const __CFString *)CFDictionaryGetValue(v19, @"BuildIdentityOverride");
              if (v96)
              {
                CFTypeID v97 = CFStringGetTypeID();
                if (v97 == CFGetTypeID(v96))
                {
                  CFAllocatorRef v98 = CFGetAllocator(v51);
                  CFURLRef URLFromString = AMAuthInstallSupportCreateURLFromString(v98, v96, v99, v100, v101, v102, v103, v104);
                  if (!URLFromString)
                  {
                    CFRelease(v51);
                    uint64_t v28 = 18;
                    goto LABEL_95;
                  }
                  CFStringRef v96 = (const __CFString *)URLFromString;
                  uint64_t v106 = AMAuthInstallBundleOverrideBuildManifest(v51, URLFromString);
                  if (v106)
                  {
                    uint64_t v107 = v106;
                    char v108 = AMAuthInstallGetLocalizedStatusString(v51, v106);
                    AMRLog(3, @"Failed to build manifest override: %@", v109, v110, v111, v112, v113, v114, v108);
                    uint64_t v28 = AMAuthInstallToRestoreError(v107);
                    CFRelease(v51);
                    CFRelease(v60);
                    CFURLRef v115 = 0;
LABEL_93:
                    CFRelease(v96);
LABEL_94:
                    CFStringRef v60 = v115;
                    if (!v115) {
                      goto LABEL_96;
                    }
                    goto LABEL_95;
                  }
                }
                else
                {
                  CFStringRef v96 = 0;
                }
              }
              CFStringRef v116 = (const __CFString *)CFDictionaryGetValue(v19, @"RecoveryOSBuildIdentityOverride");
              if (v116 && (CFStringRef v117 = v116, v118 = CFStringGetTypeID(), v118 == CFGetTypeID(v117)))
              {
                CFAllocatorRef v119 = CFGetAllocator(v51);
                CFURLRef v115 = AMAuthInstallSupportCreateURLFromString(v119, v117, v120, v121, v122, v123, v124, v125);
                if (!v115)
                {
                  CFRelease(v51);
                  uint64_t v28 = 18;
                  goto LABEL_92;
                }
                uint64_t v126 = AMAuthInstallBundleOverrideRecoveryOSBuildManifest(v51, v115);
                if (v126)
                {
                  uint64_t v127 = v126;
                  char v128 = AMAuthInstallGetLocalizedStatusString(v51, v126);
                  AMRLog(3, @"Failed to override recoveryOS build manifest: %@", v129, v130, v131, v132, v133, v134, v128);
                  uint64_t v28 = AMAuthInstallToRestoreError(v127);
                  CFRelease(v51);
                  goto LABEL_92;
                }
              }
              else
              {
                CFURLRef v115 = 0;
              }
              uint64_t v135 = AMRAuthInstallSetFDRTrustObjectHash((int)v51, v19);
              if (v135)
              {
                uint64_t v28 = v135;
              }
              else
              {
                uint64_t v28 = AMRAuthInstallEnablePersonalization((uint64_t)v51, v19);
                if (v28) {
                  AMRLog(3, @"%s: AMRAuthInstallEnablePersonalization failed", v136, v137, v138, v139, v140, v141, (char)"_AMDFUModeDeviceConfigureAuthInstall");
                }
                else {
                  *(void *)(a1 + 168) = v51;
                }
              }
LABEL_92:
              CFRelease(v60);
              if (!v96) {
                goto LABEL_94;
              }
              goto LABEL_93;
            }
          }
          else if (v68)
          {
            goto LABEL_52;
          }
          CFStringRef v73 = *(const void **)(a1 + 88);
          if (v73) {
            CFDictionarySetValue(v60, @"ApNonce", v73);
          }
          goto LABEL_49;
        }
        AMRLog(3, @"Failed to create ap parameters dict", v54, v55, v56, v57, v58, v59, v143);
        CFRelease(v51);
      }
      uint64_t v28 = 18;
      goto LABEL_97;
    }
    AMRLog(3, @"%s: failed to copy options", v13, v14, v15, v16, v17, v18, (char)"AMDFUModeDeviceCopyAuthInstallPreflightOptions");
    return 18;
  }
  else
  {
    AMRLog(3, @"%s: bad argument - undefined arguments passed to function, caller passed NULL", v6, v7, v8, v9, v10, v11, (char)"AMDFUModeDeviceCopyAuthInstallPreflightOptions");
    return 1;
  }
}

void sub_10004442C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10004443C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMRLog(7, @"%s: %p", a3, a4, a5, a6, a7, a8, (char)"_AMDFUModeDeviceFinalize");
  uint64_t v9 = *(void **)(a1 + 144);
  if (v9)
  {
    _AMRUSBDeviceClose(v9);
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v10 = *(const void **)(a1 + 168);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 168) = 0;
  }
  if (*(unsigned char *)(a1 + 152) == 1)
  {
    _AMRestoreDestroyDeviceInfo((void *)(a1 + 40));
  }
}

CFStringRef sub_1000444D0(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<DFU Device %p>", a1);
}

CFStringRef sub_100044514(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<AMDFUModeDevice %p>", a1);
}

uint64_t _AMRestoreErrorForIOReturn(uint64_t a1, uint64_t a2)
{
  int v3 = a1;
  if ((int)a1 <= -536870187)
  {
    if ((int)a1 > -536870196)
    {
      if (a1 == -536870195)
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v5[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "USB device not open", (uint8_t *)v5, 2u);
        }
        return 2001;
      }
      if (a1 == -536870194)
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v5[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "USB not readable", (uint8_t *)v5, 2u);
        }
        return 2014;
      }
    }
    else
    {
      if (a1 == -536870208)
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v5[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "USB device not found", (uint8_t *)v5, 2u);
        }
        return 2015;
      }
      if (a1 == -536870203)
      {
        if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v5[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Exclusive access to USB device", (uint8_t *)v5, 2u);
        }
        return 2012;
      }
    }
LABEL_32:
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109376;
      v5[1] = v3;
      __int16 v6 = 1024;
      int v7 = a2;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "unhandled error 0x%x returned as %d", (uint8_t *)v5, 0xEu);
    }
    return a2;
  }
  if ((int)a1 > -536854450)
  {
    switch(a1)
    {
      case 0xE000404F:
        return 2008;
      case 0xE000405D:
        return 2011;
      case 0:
        return a1;
    }
    goto LABEL_32;
  }
  if (a1 != -536870186)
  {
    if (a1 == -536870163) {
      return 2006;
    }
    goto LABEL_32;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "USB Timeout", (uint8_t *)v5, 2u);
  }
  return 2013;
}

NSError *createAndLogUSBErrorv(int a1, uint64_t a2, uint64_t a3)
{
  id v4 = [objc_alloc((Class)NSString) initWithFormat:a2 arguments:a3];
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
  }
  CFStringRef v6 = @"Error message";
  id v7 = v4;
  return +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", @"AMRestoreErrorDomain", a1, +[NSDictionary dictionaryWithObjects:&v7 forKeys:&v6 count:1]);
}

NSError *createAndLogUSBError(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return createAndLogUSBErrorv(a1, a2, (uint64_t)&a9);
}

uint64_t _shouldMatchIOUSBHostFamily()
{
  return 1;
}

BOOL _loadAndCacheIOUSBLibBundle()
{
  if (qword_1000B8D68 != -1) {
    dispatch_once(&qword_1000B8D68, &stru_10009E9B8);
  }
  return qword_1000B8D70 != 0;
}

void sub_1000449DC(id a1)
{
  CFURLRef v1 = CFURLCreateWithFileSystemPath(0, @"/System/Library/Extensions/IOUSBHostFamily.kext/Contents/PlugIns/IOUSBLib.bundle", kCFURLPOSIXPathStyle, 1u);
  CFAllocatorRef v2 = CFBundleCreate(0, v1);
  int v3 = v2;
  if (v2)
  {
    CFErrorRef error = 0;
    int v4 = CFBundleLoadExecutableAndReturnError(v2, &error);
    BOOL v5 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
    if (v4)
    {
      if (v5)
      {
        *(_DWORD *)buf = 138412290;
        CFStringRef v9 = @"/System/Library/Extensions/IOUSBHostFamily.kext/Contents/PlugIns/IOUSBLib.bundle";
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "loaded bundle at %@", buf, 0xCu);
      }
    }
    else
    {
      if (v5)
      {
        *(_DWORD *)buf = 138412546;
        CFStringRef v9 = @"/System/Library/Extensions/IOUSBHostFamily.kext/Contents/PlugIns/IOUSBLib.bundle";
        __int16 v10 = 2112;
        CFErrorRef v11 = error;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "failed to load bundle at %@: %@", buf, 0x16u);
      }
      CFRelease(error);
    }
    PlugIn = CFBundleGetPlugIn(v3);
    if (PlugIn)
    {
      CFPlugInSetLoadOnDemand(PlugIn, 0);
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        CFStringRef v9 = @"/System/Library/Extensions/IOUSBHostFamily.kext/Contents/PlugIns/IOUSBLib.bundle";
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "disabled plugin unloading for %@", buf, 0xCu);
      }
    }
  }
  CFRelease(v1);
  qword_1000B8D70 = (uint64_t)v3;
}

uint64_t _getDeviceInterfaceForService(io_service_t a1)
{
  CFUUIDRef v2 = CFUUIDGetConstantUUIDWithBytes(0, 0x9Du, 0xC7u, 0xB7u, 0x80u, 0x9Eu, 0xC0u, 0x11u, 0xD4u, 0xA5u, 0x4Fu, 0, 0xAu, 0x27u, 5u, 0x28u, 0x61u);
  CFUUIDRef v3 = CFUUIDGetConstantUUIDWithBytes(0, 0xFEu, 0x2Fu, 0xD5u, 0x2Fu, 0x3Bu, 0x5Au, 0x47u, 0x3Bu, 0x97u, 0x7Bu, 0xADu, 0x99u, 0, 0x1Eu, 0xB3u, 0xEDu);
  return sub_100044C64(a1, (uint64_t)"device", v2, v3);
}

uint64_t sub_100044C64(io_service_t a1, uint64_t a2, const __CFUUID *a3, const __CFUUID *a4)
{
  kern_return_t v9;
  kern_return_t v10;
  const char *v11;
  uint8_t *v12;
  uint32_t v13;
  IOCFPlugInInterface **v14;
  HRESULT (__cdecl *QueryInterface)(void *, REFIID, LPVOID *);
  CFUUIDBytes v16;
  int v17;
  uint64_t entryID;
  IOCFPlugInInterface **theInterface;
  SInt32 theScore;
  unsigned char buf[12];
  __int16 v23;
  kern_return_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  _DWORD *v28;
  __int16 v29;
  io_service_t v30;
  _DWORD __dst[130];

  if (qword_1000B8D68 == -1)
  {
    if (!a1) {
      return 0;
    }
  }
  else
  {
    dispatch_once(&qword_1000B8D68, &stru_10009E9B8);
    if (!a1) {
      return 0;
    }
  }
  theScore = 0;
  theInterface = 0;
  CFUUIDRef v8 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  CFStringRef v9 = IOCreatePlugInInterfaceForService(a1, a3, v8, &theInterface, &theScore);
  if (v9)
  {
    __int16 v10 = v9;
    memcpy(__dst, "<unknown>", 0x200uLL);
    uint64_t entryID = 0;
    IORegistryEntryGetPath(a1, "IOService", (char *)__dst);
    IORegistryEntryGetRegistryEntryID(a1, &entryID);
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = a2;
      uint64_t v23 = 1024;
      uint64_t v24 = v10;
      uint64_t v25 = 2048;
      uint64_t v26 = entryID;
      uint64_t v27 = 2080;
      uint64_t v28 = __dst;
      uint64_t v29 = 1024;
      uint64_t v30 = a1;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "error getting plugin interface for %s: 0x%x, registryID %#llx (%s), service %u", buf, 0x2Cu);
    }
    if (v10 != -536870210 || !os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = -536870210;
    CFErrorRef v11 = "error code 0x%x (kIOReturnNoResources) may indicate that the host is running MacOS < 13.0, where root permissi"
          "on is required to communicate with Port DFU devices.";
    uint64_t v12 = buf;
    uint64_t v13 = 8;
    goto LABEL_15;
  }
  uint64_t v14 = theInterface;
  if (!theInterface)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      __dst[0] = 136315138;
      *(void *)&__dst[1] = a2;
      CFErrorRef v11 = "plugin interface for %s is NULL";
      uint64_t v12 = (uint8_t *)__dst;
      uint64_t v13 = 12;
      goto LABEL_15;
    }
    return 0;
  }
  *(void *)buf = 0;
  QueryInterface = (*theInterface)->QueryInterface;
  uint64_t v16 = CFUUIDGetUUIDBytes(a4);
  uint64_t v17 = ((uint64_t (*)(IOCFPlugInInterface **, void, void, unsigned char *))QueryInterface)(v14, *(void *)&v16.byte0, *(void *)&v16.byte8, buf);
  IODestroyPlugInInterface(theInterface);
  if (v17)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      __dst[0] = 136315394;
      *(void *)&__dst[1] = a2;
      LOWORD(__dst[3]) = 1024;
      *(_DWORD *)((char *)&__dst[3] + 2) = v17;
      CFErrorRef v11 = "error querying %s interface: 0x%x";
      uint64_t v12 = (uint8_t *)__dst;
      uint64_t v13 = 18;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v11, v12, v13);
      return 0;
    }
    return 0;
  }
  return *(void *)buf;
}

uint64_t _getInterfaceInterfaceForService(io_service_t a1)
{
  CFUUIDRef v2 = CFUUIDGetConstantUUIDWithBytes(0, 0x2Du, 0x97u, 0x86u, 0xC6u, 0x9Eu, 0xF3u, 0x11u, 0xD4u, 0xADu, 0x51u, 0, 0xAu, 0x27u, 5u, 0x28u, 0x61u);
  CFUUIDRef v3 = CFUUIDGetConstantUUIDWithBytes(0, 0x64u, 0xBAu, 0xBDu, 0xD2u, 0xFu, 0x6Bu, 0x4Bu, 0x4Fu, 0x8Eu, 0x3Eu, 0xDCu, 0x36u, 4u, 0x69u, 0x87u, 0xADu);
  return sub_100044C64(a1, (uint64_t)"interface", v2, v3);
}

uint64_t _AMRecoveryModeDeviceCreate(uint64_t a1, void *a2)
{
  pthread_once(&stru_1000B8A30, (void (*)(void))sub_100045838);
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v4 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = 0;
    *(void *)(Instance + 24) = 0;
    *(_DWORD *)(Instance + 32) = 0;
    *(void *)(Instance + 64) = 0;
    *(void *)(Instance + 72) = 0;
    *(void *)(Instance + 77) = 0;
    *(void *)(Instance + 40) = a2;
    *(void *)(Instance + 48) = 0;
    *(_DWORD *)(Instance + 57) = -1;
    *(unsigned char *)(Instance + 61) = -1;
    *(unsigned char *)(Instance + 56) = _AMRUSBDeviceGetProductID(a2) == 4737;
    *(unsigned char *)(v4 + 192) = 0;
    *(void *)(v4 + 200) = 0;
    *(void *)(v4 + 208) = 0;
    *(_DWORD *)(v4 + 216) = 0;
  }
  return v4;
}

uint64_t sub_100045838()
{
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1000B8D78 = result;
  return result;
}

uint64_t AMRecoveryModeDeviceIsBootstrapOnly(uint64_t a1, const __CFDictionary *a2)
{
  if (*(unsigned char *)(a1 + 84) || !sub_1000458E0(a1))
  {
    uint64_t v4 = (int *)_AMRestoreCopyDeviceInfo(a1 + 88);
    if (v4)
    {
      CFErrorRef v11 = v4;
      uint64_t IsBootstrapOnly = AMRestoreDeviceIsBootstrapOnly(a2, v4, v5, v6, v7, v8, v9, v10);
      free(v11);
      return IsBootstrapOnly;
    }
    AMRLog(3, @"unable to get firmware info from device", v5, v6, v7, v8, v9, v10, v14);
  }
  return 0;
}

uint64_t sub_1000458E0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 84)) {
    return 0;
  }
  if (*(void *)(a1 + 48) || (uint64_t v10 = sub_100045D20(a1), !v10))
  {
    uint64_t FirmwareInfo = _AMRUSBDeviceGetFirmwareInfo(*(void **)(a1 + 40), a1 + 88, 0);
    uint64_t v1 = FirmwareInfo;
    if (FirmwareInfo) {
      AMRLog(3, @"unable to get firmware info from device: %d", v4, v5, v6, v7, v8, v9, FirmwareInfo);
    }
    else {
      *(unsigned char *)(a1 + 84) = 1;
    }
  }
  else
  {
    uint64_t v1 = v10;
    AMRLog(3, @"unable to open device interface: %d", v11, v12, v13, v14, v15, v16, v10);
  }
  return v1;
}

uint64_t AMRecoveryModeDeviceGetChipID(uint64_t a1)
{
  int v2 = sub_1000458E0(a1);
  if (!v2) {
    return *(unsigned int *)(a1 + 88);
  }
  AMRLog(3, @"unable to get firmware info from device: %d", v3, v4, v5, v6, v7, v8, v2);
  return 0;
}

uint64_t AMRecoveryModeDeviceGetBoardID(uint64_t a1)
{
  int v2 = sub_1000458E0(a1);
  if (!v2) {
    return *(unsigned int *)(a1 + 92);
  }
  AMRLog(3, @"unable to get firmware info from device: %d", v3, v4, v5, v6, v7, v8, v2);
  return 0xFFFFFFFFLL;
}

uint64_t AMRecoveryModeDeviceGetProductionMode(uint64_t a1)
{
  int v2 = sub_1000458E0(a1);
  if (!v2) {
    return *(unsigned __int8 *)(a1 + 176);
  }
  AMRLog(3, @"unable to get firmware info from device: %d", v3, v4, v5, v6, v7, v8, v2);
  return 0;
}

uint64_t _writeCombinedBootImageBuf(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100045A8C(a3, 0, a1, a2);
}

uint64_t sub_100045A8C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void **)(a1 + 48);
  if (!v8)
  {
    uint64_t result = sub_100045D20(a1);
    if (result) {
      return result;
    }
    uint64_t v8 = *(void **)(a1 + 48);
  }
  uint64_t v9 = 60;
  if (a2) {
    uint64_t v9 = 61;
  }
  uint64_t v10 = *(unsigned __int8 *)(a1 + v9);
  return _AMRUSBInterfaceWritePipe(v8, v10, a3, a4);
}

uint64_t AMRecoveryModeDeviceSetAutoBoot(uint64_t a1, int a2)
{
  sub_1000458E0(a1);
  double v4 = 60.0;
  if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
    double v4 = 300.0;
  }
  if (a2 == 1) {
    CFStringRef v5 = @"setenv auto-boot true";
  }
  else {
    CFStringRef v5 = @"setenv auto-boot false";
  }
  uint64_t v6 = sub_1000489F0(a1, v5, 0, v4);
  if (!v6)
  {
    sub_1000458E0(a1);
    double v7 = 60.0;
    if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
      double v7 = 300.0;
    }
    uint64_t v6 = sub_1000489F0(a1, @"saveenv", 0, v7);
    if (v6 == 21)
    {
      CFStringRef theString = 0;
      sub_100045E7C(a1, @"?", &theString);
      CFStringRef v8 = theString;
      if (theString)
      {
        long long v26 = 0u;
        long long v27 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        *(_OWORD *)buffer = 0u;
        long long v21 = 0u;
        CFStringGetCString(theString, buffer, 128, 0x8000100u);
        int v9 = strtol(buffer, 0, 16);
        if (v9 == -1)
        {
          uint64_t v6 = 102;
          CFStringRef v16 = @"NVRAM is full and could not perform save";
        }
        else
        {
          if (v9 != -2)
          {
            uint64_t v6 = 21;
            goto LABEL_18;
          }
          uint64_t v6 = 103;
          CFStringRef v16 = @"Error writing to NVRAM";
        }
        AMRLog(3, v16, v10, v11, v12, v13, v14, v15, v18);
LABEL_18:
        CFRelease(v8);
        return v6;
      }
      return 21;
    }
  }
  return v6;
}

uint64_t sub_100045CB0(uint64_t a1, const __CFString *a2, int a3)
{
  sub_1000458E0(a1);
  double v6 = 60.0;
  if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
    double v6 = 300.0;
  }
  return sub_1000489F0(a1, a2, a3, v6);
}

uint64_t sub_100045D20(uint64_t a1)
{
  uint64_t Pipes = _AMRUSBDeviceOpen(*(void **)(a1 + 40));
  if (!Pipes)
  {
    Interface = (void *)_AMRUSBDeviceGetInterface(*(void **)(a1 + 40), 0xFFFFLL, 0xFFFFLL);
    *(void *)(a1 + 48) = Interface;
    if (Interface)
    {
      uint64_t Pipes = _AMRUSBInterfaceOpen(Interface);
      if (!Pipes)
      {
        double v6 = *(void **)(a1 + 48);
        if (*(unsigned char *)(a1 + 56))
        {
          int FileTransferPipe = _AMRUSBInterfaceGetFileTransferPipe(v6, (unsigned char *)(a1 + 60), (_WORD *)(a1 + 62));
          if (!FileTransferPipe) {
            return 0;
          }
          AMRLog(4, @"_AMRUSBInterfaceGetFileTransferPipe returned %d", v8, v9, v10, v11, v12, v13, FileTransferPipe);
          uint64_t Pipes = 0;
          *(unsigned char *)(a1 + 60) = -1;
          return Pipes;
        }
        uint64_t Pipes = _AMRUSBInterfaceGetPipes(v6, (unsigned char *)(a1 + 57), (unsigned char *)(a1 + 58), (unsigned char *)(a1 + 59), (unsigned char *)(a1 + 61), (unsigned char *)(a1 + 60));
        if (!Pipes) {
          return Pipes;
        }
      }
    }
    else
    {
      uint64_t Pipes = 2002;
    }
  }
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3)
  {
    _AMRUSBInterfaceClose(v3);
    *(void *)(a1 + 48) = 0;
  }
  return Pipes;
}

uint64_t sub_100045E10(uint64_t a1, const __CFString *a2)
{
  uint64_t v4 = sub_1000472DC(a1);
  AMRLog(7, @"Max file size is: %d", v5, v6, v7, v8, v9, v10, v4);
  return sub_100048E0C(a1, a2, v4, v11, v12, v13, v14, v15);
}

uint64_t sub_100045E7C(uint64_t a1, uint64_t a2, CFStringRef *a3)
{
  *a3 = 0;
  if (*(unsigned char *)(a1 + 56) != 1) {
    return 4;
  }
  CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"getenv %@", a2);
  sub_1000458E0(a1);
  double v6 = 60.0;
  if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
    double v6 = 300.0;
  }
  uint64_t v7 = sub_100048BF8(a1, v5, 0, v6);
  if (!v7)
  {
    bzero(cStr, 0x400uLL);
    uint64_t v7 = sub_100049238(a1, (uint64_t)cStr);
    if (!v7) {
      *a3 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
    }
  }
  CFRelease(v5);
  return v7;
}

uint64_t AMRecoveryModeDeviceConfigureAuthInstall(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef theString = 0;
  if (*(void *)(a1 + 200))
  {
    AMRLog(7, @"authinstall has already been configured for this device", a3, a4, a5, a6, a7, a8, v137);
    return 0;
  }
  if (*(unsigned char *)(a1 + 84) || (uint64_t v8 = sub_1000458E0(a1), !v8))
  {
    uint64_t v11 = _AMRUSBDeviceAddNonceWithInfo(*(void **)(a1 + 40), a1 + 88, a3, a4, a5, a6, a7, a8);
    if (v11)
    {
      uint64_t v8 = v11;
      AMRLog(3, @"unable to get nonce info from device: %d", v12, v13, v14, v15, v16, v17, v11);
      return v8;
    }
    CFAllocatorRef v18 = CFGetAllocator((CFTypeRef)a1);
    uint64_t v19 = AMAuthInstallCreate(v18);
    if (v19)
    {
      uint64_t v20 = (void *)v19;
      CFAllocatorRef v21 = CFGetAllocator((CFTypeRef)a1);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v21, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        uint64_t v29 = Mutable;
        AMAuthInstallSupportDictionarySetInteger64(Mutable, @"ECID", *(void *)(a1 + 160));
        AMAuthInstallSupportDictionarySetInteger32(v29, @"ApChipID", *(unsigned int *)(a1 + 88));
        AMAuthInstallSupportDictionarySetInteger32(v29, @"ApBoardID", *(unsigned int *)(a1 + 92));
        AMAuthInstallSupportDictionarySetInteger32(v29, @"ApSecurityDomain", *(unsigned int *)(a1 + 172));
        uint64_t v30 = *(const void **)(a1 + 184);
        if (v30) {
          CFDictionarySetValue(v29, @"ApSikaFuse", v30);
        }
        AMAuthInstallSupportDictionarySetBoolean(v29, @"ApProductionMode", *(unsigned __int8 *)(a1 + 176));
        AMAuthInstallSupportDictionarySetBoolean(v29, @"ApSecurityMode", *(unsigned __int8 *)(a1 + 177));
        CFBooleanRef Value = CFDictionaryGetValue(a2, @"AuthInstallRequestTicketWithoutNonce");
        BOOL v34 = Value
           && (uint64_t v32 = Value, TypeID = CFBooleanGetTypeID(), TypeID == CFGetTypeID(v32))
           && CFBooleanGetValue((CFBooleanRef)v32) == 1;
        uint64_t v35 = CFDictionaryGetValue(a2, @"SkipNoncesForAPSEP");
        if (v35)
        {
          CFTypeID v36 = CFBooleanGetTypeID();
          LODWORD(v35) = v36 == CFGetTypeID(v35) && CFBooleanGetValue((CFBooleanRef)v35) == 1;
        }
        if (((v34 | v35) & 1) == 0)
        {
          uint64_t v37 = *(const void **)(a1 + 136);
          if (v37) {
            CFDictionarySetValue(v29, @"ApNonce", v37);
          }
        }
        if ((v35 & 1) == 0)
        {
          uint64_t v38 = *(const void **)(a1 + 144);
          if (v38) {
            CFDictionarySetValue(v29, @"SepNonce", v38);
          }
        }
        CFBooleanRef v39 = kCFBooleanFalse;
        if (*(unsigned char *)(a1 + 183))
        {
          int v40 = *(_DWORD *)(a1 + 104);
          if ((v40 & 4) != 0)
          {
            CFDictionarySetValue(v29, @"ApSupportsImg4", kCFBooleanTrue);
            int v40 = *(_DWORD *)(a1 + 104);
          }
          if ((v40 & 0x20) != 0)
          {
            CFDictionarySetValue(v29, @"ApImg4DigestType", @"sha2-384");
            int v40 = *(_DWORD *)(a1 + 104);
          }
          if ((v40 & 8) != 0) {
            CFBooleanRef v41 = kCFBooleanTrue;
          }
          else {
            CFBooleanRef v41 = kCFBooleanFalse;
          }
          if ((v40 & 0x10) != 0) {
            CFBooleanRef v39 = kCFBooleanTrue;
          }
        }
        else
        {
          CFBooleanRef v41 = kCFBooleanFalse;
        }
        CFDictionaryAddValue(v29, @"ApEffectiveSecurityMode", v41);
        CFDictionaryAddValue(v29, @"ApEffectiveProductionMode", v39);
        uint64_t v42 = CFDictionaryGetValue(a2, @"AuthInstallAllowMixAndMatch");
        if (v42)
        {
          CFAllocatorRef v43 = v42;
          CFTypeID v44 = CFBooleanGetTypeID();
          if (v44 == CFGetTypeID(v43) && CFBooleanGetValue((CFBooleanRef)v43) == 1) {
            CFDictionaryAddValue(v29, @"ApAllowMixAndMatch", kCFBooleanTrue);
          }
        }
        uint64_t v45 = CFDictionaryGetValue(a2, @"AuthInstallDemotionPolicyOverride");
        if (v45) {
          CFDictionarySetValue(v29, @"DemotionPolicy", v45);
        }
        uint64_t v46 = AMAuthInstallApSetParameters((uint64_t)v20, v29);
        if (v46)
        {
          uint64_t v53 = v46;
          AMRLog(3, @"Failed to set ap parameters", v47, v48, v49, v50, v51, v52, v137);
          uint64_t v8 = AMAuthInstallToRestoreError(v53);
LABEL_48:
          CFRelease(v20);
          uint64_t v54 = v29;
          goto LABEL_88;
        }
        CFStringRef v55 = (const __CFString *)CFDictionaryGetValue(a2, @"BuildIdentityOverride");
        if (v55)
        {
          CFTypeID v56 = CFStringGetTypeID();
          if (v56 == CFGetTypeID(v55))
          {
            CFAllocatorRef v57 = CFGetAllocator(v20);
            CFURLRef URLFromString = AMAuthInstallSupportCreateURLFromString(v57, v55, v58, v59, v60, v61, v62, v63);
            if (!URLFromString)
            {
              uint64_t v8 = 18;
              goto LABEL_48;
            }
            CFStringRef v55 = (const __CFString *)URLFromString;
            uint64_t v65 = AMAuthInstallBundleOverrideBuildManifest(v20, URLFromString);
            if (v65)
            {
              uint64_t v72 = v65;
              AMRLog(3, @"Failed to build manifest override", v66, v67, v68, v69, v70, v71, v137);
              uint64_t v8 = AMAuthInstallToRestoreError(v72);
              CFRelease(v20);
              CFRelease(v29);
              CFStringRef v73 = 0;
              goto LABEL_85;
            }
          }
          else
          {
            CFStringRef v55 = 0;
          }
        }
        CFStringRef v73 = (const __CFString *)CFDictionaryGetValue(a2, @"RecoveryOSBuildIdentityOverride");
        if (v73)
        {
          CFTypeID v74 = CFStringGetTypeID();
          if (v74 == CFGetTypeID(v73))
          {
            CFAllocatorRef v75 = CFGetAllocator(v20);
            CFStringRef v73 = (const __CFString *)AMAuthInstallSupportCreateURLFromString(v75, v73, v76, v77, v78, v79, v80, v81);
            if (!v73)
            {
              CFRelease(v20);
              uint64_t v8 = 18;
              goto LABEL_84;
            }
            uint64_t v82 = AMAuthInstallBundleOverrideRecoveryOSBuildManifest(v20, (const __CFURL *)v73);
            if (v82)
            {
              uint64_t v83 = v82;
              char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)v20, v82);
              AMRLog(3, @"Failed to override recoveryOS build manifest: %@", v85, v86, v87, v88, v89, v90, LocalizedStatusString);
              uint64_t v8 = AMAuthInstallToRestoreError(v83);
              CFRelease(v20);
              goto LABEL_84;
            }
          }
          else
          {
            CFStringRef v73 = 0;
          }
        }
        uint64_t v91 = AMRAuthInstallSetFDRTrustObjectHash((int)v20, a2);
        if (v91)
        {
          uint64_t v8 = v91;
        }
        else
        {
          uint64_t v92 = AMRAuthInstallEnablePersonalization((uint64_t)v20, a2);
          if (v92)
          {
            uint64_t v8 = v92;
            AMRLog(3, @"%s: AMRAuthInstallEnablePersonalization failed", v93, v94, v95, v96, v97, v98, (char)"AMRecoveryModeDeviceConfigureAuthInstall");
          }
          else
          {
            CFStringRef v99 = AMRAuthInstallCopyVariant(v20, a2);
            CFTypeRef cf = 0;
            if (v99)
            {
              CFStringRef v106 = v99;
              if (AMRAuthInstallCopyBuildIdentity(v20, a2, v99, &cf) || !cf)
              {
                AMRLog(3, @"Failed to read build identity.", v107, v108, v109, v110, v111, v112, v137);
              }
              else
              {
                if (AMAuthInstallSupportGetValueForKeyPathInDict(kCFAllocatorDefault, (const __CFDictionary *)cf, @"Info.RequiresNonceSlot", v108, v109, v110, v111, v112) == kCFBooleanTrue)
                {
                  LODWORD(valuePtr[0]) = 0;
                  int v139 = 2;
                  CFNumberRef v120 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
                  CFNumberRef v121 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v139);
                  CFDictionarySetValue(v29, @"ApNonceSlotID", v120);
                  CFDictionarySetValue(v29, @"SepNonceSlotID", v121);
                  CFRelease(v121);
                  CFRelease(v120);
                  CFStringRef v119 = @"Device will use nonce slots";
                }
                else
                {
                  CFStringRef v119 = @"Device will not use nonce slots";
                }
                AMRLog(6, v119, v113, v114, v115, v116, v117, v118, v137);
                CFRelease(cf);
              }
              CFRelease(v106);
            }
            else
            {
              AMRLog(3, @"Failed to read build variant.", v100, v101, v102, v103, v104, v105, v137);
            }
            if (sub_100045E7C(a1, @"anid", &theString))
            {
              AMRLog(6, @"No anid set, will not set anid in IM4R", v122, v123, v124, v125, v126, v127, v138);
            }
            else
            {
              valuePtr[0] = 0;
              valuePtr[1] = 0;
              CFStringRef v128 = theString;
              if (CFStringGetCString(theString, (char *)valuePtr, 16, 0x8000100u))
              {
                uint64_t v135 = strtol((const char *)valuePtr, 0, 16);
                AMAuthInstallSupportDictionarySetInteger32(v29, @"ApNonceSlotID", v135);
              }
              else
              {
                AMRLog(6, @"Invalid anid set, will not set anid in IM4R", v129, v130, v131, v132, v133, v134, v138);
              }
              CFRelease(v128);
              CFStringRef theString = 0;
            }
            uint64_t v8 = 0;
            *(void *)(a1 + 200) = v20;
          }
        }
LABEL_84:
        CFRelease(v29);
        if (!v55)
        {
LABEL_86:
          if (!v73) {
            return v8;
          }
          uint64_t v54 = v73;
LABEL_88:
          CFRelease(v54);
          return v8;
        }
LABEL_85:
        CFRelease(v55);
        goto LABEL_86;
      }
      AMRLog(3, @"Failed to create ap paramters dict", v23, v24, v25, v26, v27, v28, v137);
      CFRelease(v20);
    }
    return 18;
  }
  return v8;
}

uint64_t AMRestorePerformRecoveryModeRestore(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v199 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v197 = 0;
  CFTypeRef v198 = 0;
  CFTypeRef v196 = 0;
  AMRestoreCaptureSubsystemLogsIfNeeded();
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  if (*(void *)(a1 + 48) || (uint64_t v54 = sub_100045D20(a1), !v54))
  {
    *(void *)buffer = 0;
    sub_100045E7C(a1, @"build-version", (CFStringRef *)buffer);
    uint64_t v14 = *(const void **)buffer;
    if (*(void *)buffer)
    {
      AMRLog(7, @"iBoot build-version = %@", v8, v9, v10, v11, v12, v13, buffer[0]);
      CFRelease(v14);
    }
    sub_100045E7C(a1, @"build-style", (CFStringRef *)buffer);
    CFAllocatorRef v21 = *(const void **)buffer;
    if (*(void *)buffer)
    {
      AMRLog(7, @"iBoot build-style = %@", v15, v16, v17, v18, v19, v20, buffer[0]);
      CFRelease(v21);
    }
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a2);
    if (!MutableCopy)
    {
      AMRLog(3, @"unable to create mutable copy of options", v23, v24, v25, v26, v27, v28, v194);
      CFStringRef v55 = 0;
      uint64_t v47 = 0;
      goto LABEL_16;
    }
    CFMutableDictionaryRef v29 = MutableCopy;
    if (!*(unsigned char *)(a1 + 56))
    {
      *(_DWORD *)&buffer[8] = 0;
      *(void *)buffer = 0;
      LODWORD(theString) = 12;
      sub_10004726C(a1, 3, v23, v24, v25, v26, v27, v28);
      uint64_t v92 = sub_100048D14(a1, 0, 0, 0, &theString, (uint64_t)buffer);
      if (v92)
      {
LABEL_29:
        uint64_t v47 = v92;
        CFStringRef v55 = 0;
        CFTypeRef v56 = 0;
        goto LABEL_67;
      }
      if (buffer[0])
      {
        CFStringRef v55 = 0;
        CFTypeRef v56 = 0;
        uint64_t v47 = 0xFFFFFFFFLL;
LABEL_67:
        CFRelease(v29);
        goto LABEL_68;
      }
    }
    sub_10004726C(a1, 4, v23, v24, v25, v26, v27, v28);
    sub_1000472DC(a1);
    if (*(void *)(a1 + 200))
    {
LABEL_9:
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v29, @"PersonalizedRestoreBundlePath");
      if (Value)
      {
        if (AMRestoreOptionsAreLegacy(v29, v36, v37, v38, v39, v40, v41, v42))
        {
          uint64_t v44 = AMRAuthInstallAlignOptionsToPersonalizedBundle(v29, Value, 1);
          if (v44)
          {
            uint64_t v47 = v44;
            AMRLog(3, @"failed to align options with personalized bundle", v45, v46, v39, v40, v41, v42, v194);
LABEL_59:
            CFTypeRef v56 = 0;
            CFMutableStringRef v100 = 0;
LABEL_60:
            CFStringRef v55 = 0;
LABEL_61:
            if (Value && v47) {
              AMRAuthInstallDeletePersonalizedBundle(Value, v29);
            }
            if (v100) {
              CFRelease(v100);
            }
            if (!v29) {
              goto LABEL_68;
            }
            goto LABEL_67;
          }
        }
      }
      sub_100047500(a1, v29, 0, 0, v39, v40, v41, v42);
      if (!v29)
      {
        AMRLog(3, @"_resolveBundlePathOptions(true) for recovery mode failed", v57, v58, v59, v60, v61, v62, v194);
        return 1;
      }
      int IsBootstrapOnly = AMRestoreDeviceIsBootstrapOnly(v29, (int *)(a1 + 88), v57, v58, v59, v60, v61, v62);
      if (!IsBootstrapOnly)
      {
        CFStringRef theString = 0;
        sub_100045E7C(a1, @"radio-error", &theString);
        CFStringRef v70 = theString;
        if (theString)
        {
          long long v209 = 0u;
          long long v210 = 0u;
          long long v208 = 0u;
          long long v206 = 0u;
          long long v207 = 0u;
          long long v204 = 0u;
          long long v205 = 0u;
          *(_OWORD *)buffer = 0u;
          CFStringGetCString(theString, buffer, 128, 0x8000100u);
          int v71 = strtol(buffer, 0, 0);
          int v78 = v71;
          if (v71)
          {
            AMRLog(4, @"radio-CFErrorRef error = %d", v72, v73, v74, v75, v76, v77, v71);
            CFStringRef v201 = 0;
            sub_100045E7C(a1, @"radio-error-string", &v201);
            CFStringRef v85 = v201;
            if (v201)
            {
              AMRLog(4, @"radio-error-string = '%@'", v79, v80, v81, v82, v83, v84, (char)v201);
              CFRelease(v85);
            }
            if ((v78 & 0xFFFFFF00) == 0x200)
            {
              AMRLog(3, @"fatal recovery mode radio error", v79, v80, v81, v82, v83, v84, v194);
              CFRelease(v70);
              AMRLog(3, @"radio errors detected; stopping", v86, v87, v88, v89, v90, v91, v195);
              return 23;
            }
          }
          CFRelease(v70);
        }
        else
        {
          AMRLog(7, @"radio-error not set", v64, v65, v66, v67, v68, v69, v194);
        }
      }
      if (!*(unsigned char *)(a1 + 84))
      {
        uint64_t v94 = sub_1000458E0(a1);
        if (v94)
        {
          uint64_t v47 = v94;
          goto LABEL_59;
        }
      }
      uint64_t v212 = 0;
      memset(v211, 0, sizeof(v211));
      long long v209 = 0u;
      long long v210 = 0u;
      long long v208 = 0u;
      long long v206 = 0u;
      long long v207 = 0u;
      long long v204 = 0u;
      long long v205 = 0u;
      *(_OWORD *)buffer = 0u;
      if (_AMRestoreGetDeviceMapEntryForHardware(v29, (_DWORD *)(a1 + 88), buffer, v49, v50, v51, v52, v53) != 1)
      {
        uint64_t v47 = 5;
        goto LABEL_59;
      }
      if (*(unsigned char *)(a1 + 183)) {
        int v93 = (*(unsigned __int8 *)(a1 + 104) >> 2) & 1;
      }
      else {
        int v93 = 0;
      }
      if (*(unsigned char *)(a1 + 176) == 1) {
        AMRLog(4, @"%@: production fused device", v48, v49, v50, v51, v52, v53, a1);
      }
      uint64_t v95 = CFDictionaryGetValue(v29, @"BoardConfig");
      *(void *)(a1 + 64) = v95;
      if (v95) {
        CFRetain(v95);
      }
      else {
        *(void *)(a1 + 64) = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v209 + 8, 0x8000100u);
      }
      *(void *)(a1 + 72) = CFStringCreateWithCString(kCFAllocatorDefault, &v211[8], 0x8000100u);
      unsigned int v96 = *(_DWORD *)(a1 + 96);
      if (*(_DWORD *)&buffer[8] >= v96) {
        int v97 = 1;
      }
      else {
        int v97 = v93;
      }
      if (v97 != 1)
      {
        uint64_t v47 = 20;
        goto LABEL_59;
      }
      if (*(unsigned char *)(a1 + 183) != 1 || (*(unsigned char *)(a1 + 104) & 1) == 0)
      {
        if (*(_DWORD *)&buffer[8] <= v96)
        {
          CFStringRef v99 = 0;
          char v98 = 1;
LABEL_88:
          CFMutableStringRef v100 = _AMRestoreCopyTargetForBoardConfig(*(const __CFString **)(a1 + 64));
          sub_100047500(a1, v29, *(void *)(a1 + 72), (uint64_t)v100, v102, v103, v104, v105);
          int v106 = *(_DWORD *)(a1 + 104);
          CFAllocatorRef v107 = CFGetAllocator((CFTypeRef)a1);
          if (AMAuthInstallApPersonalizationEnabled(*(void *)(a1 + 200))
            && (CFStringRef v108 = (const __CFString *)CFDictionaryGetValue(v29, @"PersonalizedRestoreBundlePath")) != 0
            || (CFStringRef v108 = (const __CFString *)CFDictionaryGetValue(v29, @"RestoreBundlePath")) != 0)
          {
            CFURLRef v115 = CFURLCreateWithFileSystemPath(v107, v108, kCFURLPOSIXPathStyle, 1u);
            if (v115)
            {
              CFURLRef v116 = v115;
              CFTypeRef v56 = CFRetain(v115);
              CFRelease(v116);
              goto LABEL_96;
            }
            CFStringRef v117 = @"failed to create url for personalized restore bundle";
          }
          else
          {
            CFStringRef v117 = @"device requires a personalized restore bundle";
          }
          AMRLog(3, v117, v109, v110, v111, v112, v113, v114, v194);
          CFTypeRef v56 = 0;
LABEL_96:
          if ((v106 & 0x40) == 0
            || (CFStringRef RestoreLocalPolicyComponentPath = AMAuthInstallBundleGetRestoreLocalPolicyComponentPath(),
                uint64_t v119 = sub_1000492A4((uint64_t *)a1, v56, RestoreLocalPolicyComponentPath, @"lpolrestore", (char)"local policy"), !v119))
          {
            if ((v106 & 2) == 0
              || (uint64_t v119 = sub_100047760((uint64_t *)a1, v56, v48, v49, v50, v51, v52, v53), !v119))
            {
              if (IsBootstrapOnly) {
                char v120 = 1;
              }
              else {
                char v120 = v98;
              }
              if (v120)
              {
                CFStringRef v121 = (const __CFString *)CFDictionaryGetValue(v29, @"BootImageFile");
                if (v121)
                {
                  CFStringRef v128 = v121;
                  CFStringRef v129 = (const __CFString *)CFDictionaryGetValue(v29, @"RestoreKernelCacheFile");
                  if (v129)
                  {
                    if (AMAuthInstallBundleCreatePersonalizedPath(*(const void **)(a1 + 200), v129, (const __CFURL **)&v198, v123, v124, v125, v126, v127))
                    {
                      AMRLog(3, @"failed to get personalized kernel cache path", v130, v131, v132, v133, v134, v135, v194);
                      CFStringRef v55 = 0;
                      uint64_t v47 = 31;
                      goto LABEL_61;
                    }
                    CFStringRef v55 = sub_100047DCC(a1, v29, v130, v131, v132, v133, v134, v135);
                    if (v55)
                    {
                      if (!sub_100047FE0(a1, v29, v144, v145, v146, v147, v148, v149)
                        || (sub_100048028(a1, v29, (CFStringRef *)&cf, v150, v151, v152, v153, v154) & 1) != 0)
                      {
                        if (sub_1000477B8(a1) == 2) {
                          uint64_t v155 = sub_1000480A8((void **)a1, v29, &v197);
                        }
                        else {
                          uint64_t v155 = sub_1000481C0((void **)a1, v29, (CFMutableDictionaryRef *)&v197);
                        }
                        uint64_t v47 = v155;
                        if (v155)
                        {
                          AMRLog(3, @"_AMRestoreCopyiBootFirmwareURLs returned %d", v156, v157, v158, v159, v160, v161, v155);
                          goto LABEL_61;
                        }
                        if (v197) {
                          BOOL v163 = CFDictionaryContainsKey((CFDictionaryRef)v197, @"RestoreDCP") != 0;
                        }
                        else {
                          BOOL v163 = 0;
                        }
                        if (!sub_1000482B0(a1, v29, v156, v157, v158, v159, v160, v161)
                          || v163
                          || (uint64_t v170 = sub_1000482D4(a1, v29, v164, v165, v166, v167, v168, v169), !v170))
                        {
                          CFArrayRef v171 = (const __CFArray *)CFDictionaryGetValue(v29, @"AdditionalBootImages");
                          if (!v171) {
                            AMRLog(3, @"No additional boot images found", v48, v49, v50, v51, v52, v53, v194);
                          }
                          if (*(unsigned char *)(a1 + 192))
                          {
                            CFStringRef v172 = @"A user cancel restore was requested";
LABEL_140:
                            AMRLog(3, v172, v48, v49, v50, v51, v52, v53, v194);
                            uint64_t v47 = 99;
                            goto LABEL_61;
                          }
                          if (IsBootstrapOnly)
                          {
                            CFStringRef v173 = (const __CFString *)CFDictionaryGetValue(v29, @"WriteBootImgToDisk");
                            if (v173)
                            {
                              CFStringRef v174 = v173;
                              CFTypeID v175 = CFGetTypeID(v173);
                              if (v175 == CFBooleanGetTypeID() && v174 == (const __CFString *)kCFBooleanTrue)
                              {
                                CFStringRef v176 = @"/tmp/bootImg";
                              }
                              else
                              {
                                CFTypeID v192 = CFGetTypeID(v174);
                                if (v192 == CFStringGetTypeID()) {
                                  CFStringRef v176 = v174;
                                }
                                else {
                                  CFStringRef v176 = 0;
                                }
                              }
                            }
                            else
                            {
                              CFStringRef v176 = 0;
                            }
                            uint64_t v170 = sub_1000484B4(a1, v128, v55, (const __CFString *)v198, v171, v176);
                            if (!v170) {
                              uint64_t v170 = sub_100048590(a1, v29, v48, v49, v50, v51, v52, v53);
                            }
                          }
                          else
                          {
                            uint64_t v170 = sub_10004794C(a1, v29, (const __CFDictionary *)v197);
                            if (!v170)
                            {
                              CFBooleanRef v177 = (const __CFBoolean *)CFDictionaryGetValue(v29, @"PreventRestoresIfNVRAMSet");
                              if (v177)
                              {
                                CFBooleanRef v178 = v177;
                                CFTypeID v179 = CFGetTypeID(v177);
                                if (v179 == CFBooleanGetTypeID() && CFBooleanGetValue(v178) == 1)
                                {
                                  AMRLog(3, @"Checking for uncollected factory logs on device....", v180, v181, v182, v183, v184, v185, v194);
                                  sub_100045E7C(a1, @"prevent-restores", (CFStringRef *)&v199);
                                  if (v199)
                                  {
                                    AMRLog(3, @"Device has uncollected factory logs, aborting restore...", v186, v187, v188, v189, v190, v191, v194);
                                    uint64_t v47 = 25;
                                    goto LABEL_61;
                                  }
                                }
                              }
                              uint64_t v170 = sub_100048618(a1, v29, v128);
                              if (!v170)
                              {
                                uint64_t v170 = sub_1000487C8(a1, v55, v48, v49, v50, v51, v52, v53);
                                if (!v170)
                                {
                                  if (!cf
                                    || (uint64_t v170 = sub_100048854(a1, (const __CFString *)cf, v48, v49, v50, v51, v52, v53),
                                        !v170))
                                  {
                                    sub_10004726C(a1, 7, v48, v49, v50, v51, v52, v53);
                                    uint64_t v170 = sub_100045E10(a1, (const __CFString *)v198);
                                    if (!v170)
                                    {
                                      if (*(unsigned char *)(a1 + 192))
                                      {
                                        CFStringRef v172 = @"A user cancel restore was requested, stoping before device boot.";
                                        goto LABEL_140;
                                      }
                                      uint64_t v170 = sub_100048908(a1, v193, v48, v49, v50, v51, v52, v53);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        uint64_t v47 = v170;
                        goto LABEL_61;
                      }
                      CFStringRef v162 = @"No suitable SEP firmware found";
                    }
                    else
                    {
                      CFStringRef v162 = @"No suitable device tree found";
                    }
                    AMRLog(3, v162, v144, v145, v146, v147, v148, v149, v194);
LABEL_114:
                    uint64_t v47 = 1;
                    goto LABEL_61;
                  }
                  CFStringRef v143 = @"No kernel cache specified";
                }
                else
                {
                  CFStringRef v143 = @"No boot image specified";
                }
                AMRLog(3, v143, v122, v123, v124, v125, v126, v127, v194);
                CFStringRef v55 = 0;
                goto LABEL_114;
              }
              if (sub_1000477B8(a1) != 1) {
                goto LABEL_117;
              }
              uint64_t v136 = sub_100047854((void **)a1, v29, &v196);
              if (v136)
              {
                uint64_t v47 = v136;
                AMRLog(3, @"Couldn't retrieve iBootStage1 firmware images", v137, v138, v139, v140, v141, v142, v194);
                goto LABEL_60;
              }
              if (CFDictionaryGetCount((CFDictionaryRef)v196) < 1
                || (uint64_t v119 = sub_10004794C(a1, v29, (const __CFDictionary *)v196), !v119))
              {
LABEL_117:
                uint64_t v119 = sub_100047C20(a1, v29, v99, v49, v50, v51, v52, v53);
              }
            }
          }
          uint64_t v47 = v119;
          goto LABEL_60;
        }
        if (_AMRUSBDeviceGetProductID(*(void **)(a1 + 40)) == 4736
          && *(_DWORD *)(a1 + 96) <= 3u
          && *(_DWORD *)&buffer[8] > 3u)
        {
          char v98 = 0;
          CFStringRef v99 = @"WTF";
          goto LABEL_88;
        }
      }
      char v98 = 0;
      CFStringRef v99 = @"iBEC";
      goto LABEL_88;
    }
    sub_10004726C(a1, 45, v30, v31, v32, v33, v34, v35);
    *(void *)buffer = 0;
    uint64_t v92 = AMRecoveryModeDeviceCopyAuthInstallPreflightOptions(a1, v29, (CFTypeRef *)buffer);
    if (!v92)
    {
      CFRelease(v29);
      CFMutableDictionaryRef v29 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *(CFDictionaryRef *)buffer);
      CFRelease(*(CFTypeRef *)buffer);
      goto LABEL_9;
    }
    goto LABEL_29;
  }
  uint64_t v47 = v54;
  CFStringRef v55 = 0;
LABEL_16:
  CFTypeRef v56 = 0;
LABEL_68:
  if (cf) {
    CFRelease(cf);
  }
  if (v55) {
    CFRelease(v55);
  }
  if (v198) {
    CFRelease(v198);
  }
  if (v197) {
    CFRelease(v197);
  }
  if (v196) {
    CFRelease(v196);
  }
  if (v199) {
    CFRelease(v199);
  }
  if (v56) {
    CFRelease(v56);
  }
  if (v47) {
    AMRLog(3, @"%@: Recovery mode failed (uint64_t result = %d)", v48, v49, v50, v51, v52, v53, a1);
  }
  else {
    AMRLog(6, @"%@: Recovery mode succeeded", v48, v49, v50, v51, v52, v53, a1);
  }
  return v47;
}

void sub_10004726C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMRLog(7, @"%@: operation %d progress %d", a3, a4, a5, a6, a7, a8, a1);
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 16);
  if (v10) {
    v10(a1, a2, 0xFFFFFFFFLL, *(void *)(a1 + 24));
  }
  *(_DWORD *)(a1 + 32) = a2;
  *(_DWORD *)(a1 + 36) = -1;
}

uint64_t sub_1000472DC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56) != 1) {
    return 0;
  }
  sub_1000458E0(a1);
  double v2 = 60.0;
  if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
    double v2 = 300.0;
  }
  if (!sub_1000489F0(a1, @"getenv ramdisk-size", 0, v2))
  {
    bzero(__str, 0x400uLL);
    if (!sub_100049238(a1, (uint64_t)__str)) {
      return strtol(__str, 0, 16);
    }
  }
  uint64_t v9 = 0x10000000;
  AMRLog(7, @"Unable to query iBoot ramdisk-size. Libusbrestore error : %d", v3, v4, v5, v6, v7, v8, 0);
  return v9;
}

uint64_t AMRecoveryModeDeviceCopyAuthInstallPreflightOptions(uint64_t a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  AMRestoreCaptureSubsystemLogsIfNeeded();
  if (a1 && a2 && a3)
  {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a2);
    if (MutableCopy)
    {
      CFDictionaryRef v19 = MutableCopy;
      uint64_t v20 = AMRecoveryModeDeviceConfigureAuthInstall(a1, MutableCopy, v13, v14, v15, v16, v17, v18);
      if (v20)
      {
        uint64_t v27 = v20;
        AMRLog(3, @"%s: failed to configure authinstall", v21, v22, v23, v24, v25, v26, (char)"AMRecoveryModeDeviceCopyAuthInstallPreflightOptions");
      }
      else
      {
        uint64_t v27 = sub_10004C12C(*(__CFString **)(a1 + 200), v19, (*(_DWORD *)(a1 + 104) >> 6) & 1);
        if (v27) {
          AMRLog(3, @"%s: failed to personalize bundle", v28, v29, v30, v31, v32, v33, (char)"AMRecoveryModeDeviceCopyAuthInstallPreflightOptions");
        }
        else {
          *a3 = CFRetain(v19);
        }
      }
      CFRelease(v19);
    }
    else
    {
      AMRLog(3, @"%s: failed to copy options", v13, v14, v15, v16, v17, v18, (char)"AMRecoveryModeDeviceCopyAuthInstallPreflightOptions");
      return 18;
    }
  }
  else
  {
    AMRLog(3, @"%s: bad argument - undefined arguments passed to function, caller passed NULL", v6, v7, v8, v9, v10, v11, (char)"AMRecoveryModeDeviceCopyAuthInstallPreflightOptions");
    return 1;
  }
  return v27;
}

void sub_100047500(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef v44 = 0;
  CFTypeRef cf = 0;
  if (!a1)
  {
    CFStringRef v32 = @"Cannot resolve bundle path options without device reference";
LABEL_9:
    AMRLog(3, v32, a3, a4, a5, a6, a7, a8, v43);
    goto LABEL_10;
  }
  if (!a2)
  {
    CFStringRef v32 = @"Cannot resolve bundle path options without options";
    goto LABEL_9;
  }
  int IsBootstrapOnly = AMRestoreDeviceIsBootstrapOnly(a2, (int *)(a1 + 88), a3, a4, a5, a6, a7, a8);
  if (AMRestoreOptionsAreLegacy(a2, v13, v14, v15, v16, v17, v18, v19))
  {
    uint64_t v24 = CFDictionaryGetValue(a2, @"RestoreBundlePath");
    if (v24)
    {
      uint64_t v25 = v24;
      CFTypeRef v47 = 0;
      CFDictionaryRef value = 0;
      CFTypeRef v46 = 0;
      if (a3 | a4)
      {
        CFStringRef v42 = (const __CFString *)CFDictionaryGetValue(a2, @"KernelCacheType");
        CFStringRef v29 = (const __CFString *)CFDictionaryGetValue(a2, @"BootImageType");
        p_CFDictionaryRef value = &value;
        uint64_t v31 = &v47;
        uint64_t v24 = v25;
        CFStringRef v26 = (const __CFString *)a3;
        CFStringRef v27 = (const __CFString *)a4;
        CFStringRef v28 = v42;
      }
      else
      {
        CFStringRef v26 = 0;
        CFStringRef v27 = 0;
        CFStringRef v28 = 0;
        CFStringRef v29 = 0;
        p_CFDictionaryRef value = 0;
        uint64_t v31 = 0;
      }
      if (!AMRestoreCreatePathsForBundle((uint64_t)v24, v26, v27, v28, v29, (const __CFDictionary **)p_value, v31, &v46))
      {
        if (value)
        {
          CFDictionaryAddValue(a2, @"RestoreKernelCacheFile", value);
          CFRelease(value);
        }
        if (v47)
        {
          CFDictionaryAddValue(a2, @"BootImageFile", v47);
          CFRelease(v47);
        }
        if (v46)
        {
          CFDictionaryAddValue(a2, @"FirmwareDirectory", v46);
          CFRelease(v46);
        }
      }
    }
    goto LABEL_10;
  }
  uint64_t v33 = *(void **)(a1 + 200);
  if (IsBootstrapOnly)
  {
LABEL_18:
    if (AMRAuthInstallCopyFileSystemPathForKey(v33, a2, @"KernelCache", (CFStringRef *)&cf, v20, v21, v22, v23))goto LABEL_20; {
    goto LABEL_19;
    }
  }
  if (AMRAuthInstallCopyFileSystemPathForKey(v33, a2, @"RestoreKernelCache", (CFStringRef *)&cf, v20, v21, v22, v23))
  {
    uint64_t v33 = *(void **)(a1 + 200);
    goto LABEL_18;
  }
LABEL_19:
  CFDictionarySetValue(a2, @"RestoreKernelCacheFile", cf);
LABEL_20:
  CFStringRef v34 = (const __CFString *)CFDictionaryGetValue(a2, @"BootImageTagOverride");
  if (v34)
  {
    CFStringRef v41 = v34;
    AMRLog(5, @"Sending custom image tag to memboot: %@\n", v35, v36, v37, v38, v39, v40, (char)v34);
  }
  else
  {
    CFStringRef v41 = @"RestoreRamDisk";
  }
  if (!AMRAuthInstallCopyFileSystemPathForKey(*(void **)(a1 + 200), a2, v41, (CFStringRef *)&v44, v37, v38, v39, v40))CFDictionarySetValue(a2, @"BootImageFile", v44); {
LABEL_10:
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v44) {
    CFRelease(v44);
  }
}

uint64_t sub_100047760(uint64_t *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef ApTicketComponentPath = AMAuthInstallBundleGetApTicketComponentPath(a1[25], (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  return sub_1000492A4(a1, a2, ApTicketComponentPath, @"ticket", (char)"ap ticket");
}

uint64_t sub_1000477B8(uint64_t a1)
{
  CFTypeRef cf1 = 0;
  int v1 = sub_100045E7C(a1, @"boot-stage", (CFStringRef *)&cf1);
  CFTypeRef v2 = cf1;
  if (v1)
  {
    uint64_t v3 = 0;
    if (!cf1) {
      return v3;
    }
    goto LABEL_8;
  }
  if (CFEqual(cf1, @"1") == 1)
  {
    uint64_t v3 = 1;
    if (!v2) {
      return v3;
    }
    goto LABEL_8;
  }
  uint64_t v3 = 2 * (CFEqual(v2, @"2") == 1);
  if (v2) {
LABEL_8:
  }
    CFRelease(v2);
  return v3;
}

uint64_t sub_100047854(void **a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"RestoreBundlePath");
  CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(theDict, @"AuthInstallVariant");
  uint64_t v8 = 1;
  if (a3 && Value)
  {
    CFStringRef v9 = v7;
    CFAllocatorRef v10 = CFGetAllocator(a1);
    CFURLRef v11 = CFURLCreateWithFileSystemPath(v10, Value, kCFURLPOSIXPathStyle, 1u);
    if (v11)
    {
      CFURLRef v18 = v11;
      int v19 = AMAuthInstallBundleCopyPersonalizedURLsMatchingType(a1[25], v11, v9, @"IsLoadedByiBootStage1", a3);
      if (v19)
      {
        AMRLog(3, @"_AMRestoreCopyiBootStage1FirmwareURLs returned %d", v20, v21, v22, v23, v24, v25, v19);
        uint64_t v8 = 6;
      }
      else
      {
        uint64_t v8 = 0;
      }
      CFRelease(v18);
    }
    else
    {
      AMRLog(3, @"failed to create url for restore bundle", v12, v13, v14, v15, v16, v17, v27);
      return 18;
    }
  }
  return v8;
}

uint64_t sub_10004794C(uint64_t a1, CFDictionaryRef theDict, const __CFDictionary *a3)
{
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"DisableiBootFirmware");
  if (Value)
  {
    CFBooleanRef v7 = Value;
    CFTypeID TypeID = CFBooleanGetTypeID();
    if (TypeID == CFGetTypeID(v7))
    {
      if (CFBooleanGetValue(v7))
      {
        AMRLog(3, @"_sendiBootFirmwareToDevice disabled by configuration", v9, v10, v11, v12, v13, v14, v57);
        return 0;
      }
    }
  }
  CFIndex Count = CFDictionaryGetCount(a3);
  uint64_t v59 = 0;
  int IsBootstrapOnly = AMRestoreDeviceIsBootstrapOnly(theDict, (int *)(a1 + 88), v17, v18, v19, v20, v21, v22);
  uint64_t v24 = sub_10004946C(a1, a3, @"RestoreANS", &v59, Count, theDict);
  if (v24)
  {
LABEL_6:
    uint64_t v15 = v24;
    AMRLog(3, @"_sendiBootFirmwareToDevice failed with %d", v25, v26, v27, v28, v29, v30, v24);
    return v15;
  }
  if (IsBootstrapOnly || (uint64_t v15 = AMRecoveryModeDeviceSetAutoBoot(a1, 0), !v15))
  {
    uint64_t v15 = sub_100049540(a1, theDict, v25, v26, v27, v28, v29, v30);
    if (!v15)
    {
      uint64_t v24 = sub_10004946C(a1, a3, @"iBootData", &v59, Count, theDict);
      if (v24) {
        goto LABEL_6;
      }
      int v31 = CFDictionaryContainsKey(a3, @"RestoreDCP");
      uint64_t v24 = sub_10004946C(a1, a3, @"RestoreDCP", &v59, Count, theDict);
      if (v24) {
        goto LABEL_6;
      }
      if (v31)
      {
        uint64_t v33 = sub_1000482D4(a1, theDict, v25, v26, v27, v28, v29, v30);
        if (v33)
        {
          uint64_t v15 = v33;
          AMRLog(3, @"_AMRestorePushBootLogo failed with %d", v34, v35, v36, v37, v38, v39, v33);
          return v15;
        }
      }
      CFIndex v40 = CFDictionaryGetCount(a3);
      CFStringRef v41 = (const void **)malloc_type_malloc(8 * v40, 0x80040B8603338uLL);
      CFStringRef v42 = (const void **)malloc_type_malloc(8 * v40, 0x80040B8603338uLL);
      char v43 = v42;
      if (v41 && v42)
      {
        CFDictionaryGetKeysAndValues(a3, v41, v42);
        uint64_t v50 = v40 & ~(v40 >> 63);
        uint64_t v51 = v59 + 1;
        uint64_t v52 = (const __CFURL **)v43;
        uint64_t v58 = v41;
        while (v50)
        {
          uint64_t v54 = *v41++;
          char v53 = (char)v54;
          CFURLRef v55 = *v52++;
          AMRLog(6, @"Sending %@ to device. (%ld of %ld)", v44, v45, v46, v47, v48, v49, v53);
          uint64_t v56 = sub_1000499E4(a1, v55, theDict);
          --v50;
          ++v51;
          if (v56)
          {
            uint64_t v15 = v56;
            AMRLog(3, @"_sendiBootFirmwareToDevice failed with %d", v44, v45, v46, v47, v48, v49, v56);
            goto LABEL_26;
          }
        }
        uint64_t v15 = 0;
LABEL_26:
        CFStringRef v41 = v58;
      }
      else
      {
        uint64_t v15 = 18;
        if (!v41)
        {
LABEL_28:
          if (v43) {
            free(v43);
          }
          return v15;
        }
      }
      free(v41);
      goto LABEL_28;
    }
  }
  return v15;
}

uint64_t sub_100047C20(uint64_t a1, const __CFDictionary *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v40 = 0;
  int v11 = AMRestoreOptionsAreLegacy(a2, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  AMRLog(7, @"bootstrapping restore with %@", v12, v13, v14, v15, v16, v17, (char)a3);
  if (v11)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"DFUFileType");
    uint64_t v19 = CFDictionaryGetValue(a2, @"FirmwareDirectory");
    CFStringRef v41 = 0;
    if (AMRAuthInstallCreatePathFromBundle(*(void **)(a1 + 200), a2, a3, &v41))
    {
      CFStringRef v20 = @"DEVELOPMENT";
      if (Value) {
        CFStringRef v20 = Value;
      }
      CFStringRef v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%cdfu%c%@.%@.%@.dfu", v19, 47, 47, a3, *(void *)(a1 + 64), v20);
    }
    else
    {
      CFStringRef v21 = v41;
    }
  }
  else
  {
    int v22 = AMRAuthInstallCreatePathFromBundle(*(void **)(a1 + 200), a2, a3, &v40);
    CFStringRef v21 = v40;
    if (v22) {
      BOOL v29 = 1;
    }
    else {
      BOOL v29 = v40 == 0;
    }
    if (v29)
    {
      AMRLog(3, @"Failed to find bootstrap file", v23, v24, v25, v26, v27, v28, v39);
      return 11;
    }
  }
  uint64_t v30 = sub_100045E10(a1, v21);
  if (!v30)
  {
    sub_10004726C(a1, 31, v31, v32, v33, v34, v35, v36);
    usleep(0xF4240u);
    sub_1000458E0(a1);
    double v37 = 60.0;
    if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
      double v37 = 300.0;
    }
    uint64_t v30 = sub_1000489F0(a1, @"go", 1, v37);
  }
  CFRelease(v21);
  return v30;
}

CFStringRef sub_100047DCC(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v47 = 0;
  if (AMRestoreOptionsAreLegacy(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"DeviceTreeFile");
    if (Value) {
      return CFStringCreateCopy(kCFAllocatorDefault, Value);
    }
    CFStringRef v28 = (const __CFString *)CFDictionaryGetValue(a2, @"NORImagePath");
    if (v28)
    {
      CFStringRef v29 = v28;
      CFRetain(v28);
    }
    else
    {
      double v37 = CFDictionaryGetValue(a2, @"FirmwareDirectory");
      uint64_t v38 = CFDictionaryGetValue(a2, @"NORImageType");
      CFStringRef v17 = 0;
      if (!v37 || !v38) {
        return v17;
      }
      CFStringRef v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%call_flash%call_flash.%@.%@", v37, 47, 47, *(void *)(a1 + 64), v38);
    }
    CFArrayRef v39 = _AMRestoreCopyManifestForNORImage((uint64_t)v29, v30, v31, v32, v33, v34, v35, v36);
    if (v39)
    {
      CFArrayRef v40 = v39;
      CFIndex Count = CFArrayGetCount(v39);
      if (Count < 1)
      {
LABEL_18:
        CFStringRef v17 = 0;
      }
      else
      {
        CFIndex v42 = Count;
        CFIndex v43 = 0;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v40, v43);
          if (CFStringHasPrefix(ValueAtIndex, @"DeviceTree.") == 1) {
            break;
          }
          if (v42 == ++v43) {
            goto LABEL_18;
          }
        }
        CFStringRef v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%c%@", v29, 47, ValueAtIndex);
      }
      CFRelease(v40);
    }
    else
    {
      CFStringRef v17 = 0;
    }
    CFRelease(v29);
    return v17;
  }
  if (AMRestoreDeviceIsBootstrapOnly(a2, (int *)(a1 + 88), v10, v11, v12, v13, v14, v15)
    || AMRAuthInstallCopyFileSystemPathForKey(*(void **)(a1 + 200), a2, @"RestoreDeviceTree", &v47, v18, v19, v20, v21))
  {
    if (AMRAuthInstallCopyFileSystemPathForKey(*(void **)(a1 + 200), a2, @"DeviceTree", &v47, v18, v19, v20, v21))AMRLog(3, @"Failed to find device tree", v22, v23, v24, v25, v26, v27, v46); {
  }
    }
  return v47;
}

uint64_t sub_100047FE0(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0;
  int v8 = sub_100048028(a1, a2, (CFStringRef *)&cf, a4, a5, a6, a7, a8);
  uint64_t result = 0;
  if (v8)
  {
    if (cf)
    {
      CFRelease(cf);
      return 1;
    }
  }
  return result;
}

uint64_t sub_100048028(uint64_t a1, const __CFDictionary *a2, CFStringRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a3 = 0;
  if (AMRestoreOptionsAreLegacy(a2, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8)
    || (AMRAuthInstallCopyFileSystemPathForKey(*(void **)(a1 + 200), a2, @"RestoreSEP", a3, v11, v12, v13, v14) & 0xFFFFFFF7) == 0)
  {
    return 1;
  }
  AMRLog(3, @"Failed to locate restore SEP firmware", v16, v17, v18, v19, v20, v21, v22);
  return 0;
}

uint64_t sub_1000480A8(void **a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  CFTypeRef v27 = 0;
  int v6 = sub_1000481C0(a1, a2, (CFMutableDictionaryRef *)&cf);
  if (v6)
  {
    AMRLog(3, @"_AMRestoreCopyiBootFirmwareURLs failed %d", v7, v8, v9, v10, v11, v12, v6);
LABEL_5:
    uint64_t v20 = 0;
    uint64_t v21 = 6;
    goto LABEL_6;
  }
  int v13 = sub_100047854(a1, a2, &v27);
  if (v13)
  {
    AMRLog(3, @"_AMRestoreCopyiBootStage1FirmwareURLs failed %d", v14, v15, v16, v17, v18, v19, v13);
    goto LABEL_5;
  }
  CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v27);
  uint64_t v20 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  CFDictionaryGetKeysAndValues((CFDictionaryRef)v27, v20, 0);
  if (Count >= 1)
  {
    uint64_t v24 = v20;
    do
    {
      uint64_t v25 = *v24++;
      CFDictionaryRemoveValue((CFMutableDictionaryRef)cf, v25);
      --Count;
    }
    while (Count);
  }
  uint64_t v21 = 0;
  *a3 = cf;
  CFTypeRef cf = 0;
LABEL_6:
  free(v20);
  if (cf) {
    CFRelease(cf);
  }
  if (v27) {
    CFRelease(v27);
  }
  return v21;
}

uint64_t sub_1000481C0(void **a1, CFDictionaryRef theDict, CFMutableDictionaryRef *a3)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"RestoreBundlePath");
  CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(theDict, @"AuthInstallVariant");
  uint64_t v8 = 1;
  if (a3 && Value)
  {
    CFStringRef v9 = v7;
    CFAllocatorRef v10 = CFGetAllocator(a1);
    CFURLRef v11 = CFURLCreateWithFileSystemPath(v10, Value, kCFURLPOSIXPathStyle, 1u);
    if (v11)
    {
      CFURLRef v18 = v11;
      unsigned int v19 = AMAuthInstallBundleCopyPersonalizediBootFirmwareURLs(a1[25], v11, v9, a3);
      if (v19)
      {
        AMRLog(3, @"AMAuthInstallBundleCopyPersonalizediBootFirmwareURLs returned %d", v20, v21, v22, v23, v24, v25, v19);
        uint64_t v8 = 6;
      }
      else
      {
        uint64_t v8 = 0;
      }
      CFRelease(v18);
    }
    else
    {
      AMRLog(3, @"failed to create url for restore bundle", v12, v13, v14, v15, v16, v17, v27);
      return 18;
    }
  }
  return v8;
}

CFStringRef sub_1000482B0(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef result = sub_100049B1C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    CFRelease(result);
    return (CFStringRef)1;
  }
  return result;
}

uint64_t sub_1000482D4(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10004726C(a1, 43, a3, a4, a5, a6, a7, a8);
  CFStringRef v16 = sub_100049B1C(a1, a2, v10, v11, v12, v13, v14, v15);
  if (v16)
  {
    CFStringRef v17 = v16;
    uint64_t v18 = sub_100045E10(a1, v16);
    if (v18 == 17)
    {
      AMRLog(7, @"No boot graphic found", v19, v20, v21, v22, v23, v24, v40);
    }
    else
    {
      uint64_t v25 = v18;
      if (v18)
      {
LABEL_8:
        CFStringRef v28 = v17;
LABEL_18:
        CFRelease(v28);
        return v25;
      }
      sub_1000458E0(a1);
      double v26 = 60.0;
      if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
        double v26 = 300.0;
      }
      uint64_t v27 = sub_1000489F0(a1, @"setpicture 4", 0, v26);
      if (v27)
      {
        uint64_t v25 = v27;
        goto LABEL_8;
      }
      usleep(0xF4240u);
    }
    CFRelease(v17);
    __int16 valuePtr = 0;
    unsigned __int8 v41 = 0;
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a2, @"BackgroundColor");
    if (Value)
    {
      CFArrayRef v30 = Value;
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(Value, 0);
      CFNumberGetValue(ValueAtIndex, kCFNumberCharType, (char *)&valuePtr + 1);
      CFNumberRef v32 = (const __CFNumber *)CFArrayGetValueAtIndex(v30, 1);
      CFNumberGetValue(v32, kCFNumberCharType, &valuePtr);
      CFNumberRef v33 = (const __CFNumber *)CFArrayGetValueAtIndex(v30, 2);
      CFNumberGetValue(v33, kCFNumberCharType, &v41);
      uint64_t v34 = HIBYTE(valuePtr);
      uint64_t v35 = valuePtr;
      uint64_t v36 = v41;
    }
    else
    {
      uint64_t v36 = 0;
      uint64_t v35 = 0;
      uint64_t v34 = 0;
      __int16 valuePtr = 0;
      unsigned __int8 v41 = 0;
    }
    CFStringRef v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"bgcolor %d %d %d", v34, v35, v36);
    sub_1000458E0(a1);
    double v38 = 60.0;
    if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
      double v38 = 300.0;
    }
    uint64_t v25 = sub_1000489F0(a1, v37, 0, v38);
    CFStringRef v28 = v37;
    goto LABEL_18;
  }
  return 1;
}

uint64_t sub_1000484B4(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFArray *a5, const __CFString *a6)
{
  if (!*(unsigned char *)(a1 + 56) || *(unsigned __int8 *)(a1 + 60) == 255) {
    return 5;
  }
  uint64_t result = _AMRUSBDeviceSendDeviceRequest(*(void **)(a1 + 40), 0, 0, 2, 1, 0, 0, 0, 0);
  if (!result)
  {
    if (*(unsigned char *)(a1 + 183)) {
      int v13 = (*(unsigned __int8 *)(a1 + 104) >> 2) & 1;
    }
    else {
      int v13 = 0;
    }
    return _writeCombinedBootImage(a2, a3, a4, a5, 0x8000uLL, (uint64_t (*)(char *, size_t, uint64_t))_writeCombinedBootImageBuf, a6, v13, a1);
  }
  return result;
}

uint64_t sub_100048590(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_100049540(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!result)
  {
    sub_10004726C(a1, 9, v10, v11, v12, v13, v14, v15);
    sub_1000458E0(a1);
    double v16 = 60.0;
    if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
      double v16 = 300.0;
    }
    return sub_1000489F0(a1, @"memboot", 1, v16);
  }
  return result;
}

uint64_t sub_100048618(uint64_t a1, const __CFDictionary *a2, const __CFString *a3)
{
  uint64_t v6 = sub_1000472DC(a1);
  sub_10004726C(a1, 5, v7, v8, v9, v10, v11, v12);
  uint64_t v24 = sub_100048E0C(a1, a3, v6, v13, v14, v15, v16, v17);
  if (v24) {
    return v24;
  }
  useconds_t valuePtr = 1000000;
  CFStringRef str = 0;
  int IsBootstrapOnly = AMRestoreDeviceIsBootstrapOnly(a2, (int *)(a1 + 88), v18, v19, v20, v21, v22, v23);
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"RamdiskDelay");
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  }
  else
  {
    if (IsBootstrapOnly)
    {
      LODWORD(v27) = 0;
      goto LABEL_7;
    }
    sub_100045E7C(a1, @"ramdisk-delay", &str);
    CFStringRef v27 = str;
    if (!str) {
      goto LABEL_7;
    }
    IntCFNumberRef Value = CFStringGetIntValue(str);
    char v40 = IntValue;
    useconds_t valuePtr = IntValue;
    CFRelease(v27);
    AMRLog(7, @"ramdisk-delay = %d", v41, v42, v43, v44, v45, v46, v40);
  }
  LODWORD(v27) = 1;
LABEL_7:
  sub_1000458E0(a1);
  if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
    double v28 = 300.0;
  }
  else {
    double v28 = 60.0;
  }
  CFNumberRef v29 = (const __CFNumber *)CFDictionaryGetValue(a2, @"FPGAValidateRamdiskTimeout");
  if (v29)
  {
    CFNumberRef v30 = v29;
    CFTypeID v31 = CFGetTypeID(v29);
    if (v31 != CFNumberGetTypeID())
    {
      AMRLog(3, @"FPGAValidateRamdiskTimeout expects an integer!", v32, v33, v34, v35, v36, v37, v47);
      return 1;
    }
    double v28 = sub_100048978(a1, v30);
  }
  uint64_t v24 = sub_1000489F0(a1, @"ramdisk", (int)v27, v28);
  if (!v24) {
    usleep(valuePtr);
  }
  return v24;
}

uint64_t sub_1000487C8(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10004726C(a1, 6, a3, a4, a5, a6, a7, a8);
  uint64_t result = sub_100045E10(a1, a2);
  if (!result)
  {
    sub_1000458E0(a1);
    double v11 = 60.0;
    if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
      double v11 = 300.0;
    }
    uint64_t result = sub_1000489F0(a1, @"devicetree", 0, v11);
    if (!result)
    {
      usleep(0xF4240u);
      return 0;
    }
  }
  return result;
}

uint64_t sub_100048854(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10004726C(a1, 6, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = sub_100045E10(a1, a2);
  uint64_t v17 = v10;
  if (v10)
  {
    AMRLog(3, @"_sendRestoreSEPToDevice failed with %d", v11, v12, v13, v14, v15, v16, v10);
  }
  else
  {
    sub_1000458E0(a1);
    double v18 = 60.0;
    if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
      double v18 = 300.0;
    }
    int v19 = sub_1000489F0(a1, @"rsepfirmware", 0, v18);
    if (v19) {
      AMRLog(6, @"rsepfirmware command failed with %d", v20, v21, v22, v23, v24, v25, v19);
    }
  }
  return v17;
}

uint64_t sub_100048908(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10004726C(a1, 9, a3, a4, a5, a6, a7, a8);
  sub_1000458E0(a1);
  double v9 = 60.0;
  if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
    double v9 = 300.0;
  }
  return sub_1000489F0(a1, @"bootx", 1, v9);
}

double sub_100048978(uint64_t a1, const __CFNumber *a2)
{
  sub_1000458E0(a1);
  unsigned int v4 = *(_DWORD *)(a1 + 92) & 0xFFFFFFF0;
  if (a2 && v4 == 240)
  {
    double valuePtr = 0.0;
    CFNumberGetValue(a2, kCFNumberDoubleType, &valuePtr);
    return valuePtr;
  }
  else
  {
    double result = 60.0;
    if (v4 == 240) {
      return 300.0;
    }
  }
  return result;
}

uint64_t sub_1000489F0(uint64_t a1, const __CFString *a2, int a3, double a4)
{
  sub_1000458E0(a1);
  int v14 = *(_DWORD *)(a1 + 92);
  uint64_t v15 = *(const void **)(a1 + 208);
  if (v15)
  {
    CFRelease(v15);
    *(void *)(a1 + 208) = 0;
    *(_DWORD *)(a1 + 216) = 0;
  }
  if (a2) {
    *(void *)(a1 + 208) = CFStringCreateCopy(kCFAllocatorDefault, a2);
  }
  if (*(unsigned char *)(a1 + 56) == 1)
  {
    uint64_t result = sub_100048BF8(a1, a2, a3, a4);
  }
  else
  {
    if (a4 != 300.0 && (v14 & 0xFFFFFFF0) == 0xF0) {
      AMRLog(4, @"Sending commands by pipe with timeouts isn't supported! If a timeout was supplied, it'll be ignored.", v8, v9, v10, v11, v12, v13, v21);
    }
    bzero(buffer, 0x400uLL);
    CFStringGetCString(a2, buffer, 1024, 0x8000100u);
    unint64_t v17 = __strlcat_chk();
    if (v17 <= 0x3FF)
    {
      unint64_t v18 = (v17 + 15) & 0xFFFFFFFFFFFFFFF0;
      if (v18 <= v17)
      {
        if (!v18)
        {
LABEL_23:
          uint64_t result = 0;
          goto LABEL_28;
        }
      }
      else
      {
        bzero(&buffer[v17], v18 - v17);
      }
      int v19 = buffer;
      while (1)
      {
        int v25 = 0;
        uint64_t v24 = 0;
        int v23 = 12;
        uint64_t v22 = v18;
        LODWORD(result) = sub_100048D14(a1, 3, 8, (uint64_t)&v22, &v23, (uint64_t)&v24);
        if (result || !v23) {
          break;
        }
        if (v24 != 8)
        {
          uint64_t result = 7;
          goto LABEL_28;
        }
        uint64_t v20 = HIDWORD(v24);
        if (HIDWORD(v24))
        {
          uint64_t result = sub_100045A8C(a1, 1, (uint64_t)v19, HIDWORD(v24));
          if (result) {
            goto LABEL_28;
          }
          v18 -= v20;
          v19 += v20;
        }
        if (!v18) {
          goto LABEL_23;
        }
      }
      if (result) {
        uint64_t result = result;
      }
      else {
        uint64_t result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      uint64_t result = 1;
    }
  }
LABEL_28:
  *(_DWORD *)(a1 + 216) = result;
  return result;
}

uint64_t sub_100048BF8(uint64_t a1, const __CFString *a2, int a3, double a4)
{
  bzero(buffer, 0x400uLL);
  CFStringGetCString(a2, buffer, 1024, 0x8000100u);
  __int16 v8 = strlen(buffer);
  LODWORD(v17) = (a4 * 1000.0);
  HIDWORD(v17) = v17;
  uint64_t result = _AMRUSBDeviceSendDeviceRequestTO(*(void **)(a1 + 40), 0, 0, 2, 0, a3 != 0, 0, v8 + 1, (uint64_t)buffer, v17);
  if (result)
  {
    unsigned int v16 = result;
    AMRLog(3, @"command device request for '%@' failed: %d", v10, v11, v12, v13, v14, v15, (char)a2);
    if (v16 == 2008) {
      return 21;
    }
    else {
      return v16;
    }
  }
  return result;
}

uint64_t sub_100048D14(uint64_t a1, char a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v15 = 0;
  v13[0] = a2;
  __int16 v14 = 4660;
  v13[1] = a3;
  if (a3) {
    __memcpy_chk();
  }
  uint64_t v10 = *(void **)(a1 + 48);
  if (!v10)
  {
    uint64_t result = sub_100045D20(a1);
    if (result) {
      return result;
    }
    uint64_t v10 = *(void **)(a1 + 48);
  }
  uint64_t result = _AMRUSBInterfaceWritePipe(v10, *(unsigned __int8 *)(a1 + 58), (uint64_t)v13, a3 + 4);
  if (!result)
  {
    uint64_t v12 = *(void **)(a1 + 48);
    if (v12) {
      return _AMRUSBInterfaceReadPipe(v12, *(unsigned __int8 *)(a1 + 57), a6, a5);
    }
    uint64_t result = sub_100045D20(a1);
    if (!result)
    {
      uint64_t v12 = *(void **)(a1 + 48);
      return _AMRUSBInterfaceReadPipe(v12, *(unsigned __int8 *)(a1 + 57), a6, a5);
    }
  }
  return result;
}

uint64_t sub_100048E0C(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  AMRLog(7, @"sending file: %@", a3, a4, a5, a6, a7, a8, (char)a2);
  if (*(unsigned char *)(a1 + 56) != 1)
  {
    uint64_t v11 = a1;
    CFStringRef v12 = a2;
    int v13 = 1;
    goto LABEL_5;
  }
  if (*(unsigned __int8 *)(a1 + 60) != 255)
  {
    uint64_t v11 = a1;
    CFStringRef v12 = a2;
    int v13 = 0;
LABEL_5:
    return sub_100048ED4(v11, v12, v13, v8);
  }
  uint64_t v15 = *(void **)(a1 + 40);
  return AMRPerformDFUFileDownload(v15, a2, 0, 0);
}

uint64_t sub_100048ED4(uint64_t a1, const __CFString *a2, int a3, unsigned int a4)
{
  bzero(buffer, 0x400uLL);
  CFStringGetFileSystemRepresentation(a2, buffer, 1024);
  char v55 = 0;
  int v8 = open(buffer, 0);
  if (v8 == -1)
  {
    CFStringRef v22 = @"Failed to open file";
LABEL_7:
    AMRLogWithFilePath(3, (uint64_t)a2, v22, v9, v10, v11, v12, v13, 0);
    int v23 = __error();
    return _AMRestoreErrorForErrno(*v23, 11, v24, v25, v26, v27, v28, v29);
  }
  int v14 = v8;
  memset(&v56, 0, sizeof(v56));
  if (fstat(v8, &v56) == -1)
  {
    close(v14);
    CFStringRef v22 = @"Failed to stat file";
    goto LABEL_7;
  }
  if (v56.st_size > a4)
  {
    close(v14);
    AMRLog(3, @"iBoot does not support file of this size. File Size: %lld iBoot max size: %d", v15, v16, v17, v18, v19, v20, v56.st_size);
    return 1;
  }
  if (a3)
  {
    int v61 = 0;
    uint64_t v60 = 0;
    int v58 = 12;
    v57[0] = v56.st_size;
    v57[1] = 150994944;
    uint64_t v31 = sub_100048D14(a1, 5, 8, (uint64_t)v57, &v58, (uint64_t)&v60);
    if (v31)
    {
      uint64_t v21 = v31;
LABEL_16:
      close(v14);
      return v21;
    }
    if (!v58)
    {
      AMRLog(3, @"reply length to file transfer control packet was 0", v32, v33, v34, v35, v36, v37, 0);
      uint64_t v21 = 10;
      goto LABEL_16;
    }
    int64_t v38 = HIDWORD(v60);
  }
  else
  {
    uint64_t v21 = _AMRUSBDeviceSendDeviceRequest(*(void **)(a1 + 40), 0, 0, 2, 1, 0, 0, 0, 0);
    int64_t v38 = 0x8000;
    if (v21) {
      goto LABEL_16;
    }
  }
  CFArrayRef v39 = malloc_type_malloc(v38, 0x6C74E559uLL);
  off_t st_size = v56.st_size;
  if (v56.st_size < 1)
  {
LABEL_26:
    uint64_t v46 = 0;
  }
  else
  {
    while (1)
    {
      if (st_size >= v38) {
        size_t v41 = v38;
      }
      else {
        size_t v41 = st_size;
      }
      ssize_t v42 = read(v14, v39, v41);
      if (v42 == -1)
      {
        uint64_t v46 = 13;
        goto LABEL_29;
      }
      ssize_t v43 = v42;
      uint64_t v44 = sub_100045A8C(a1, 0, (uint64_t)v39, v42);
      if (v44) {
        break;
      }
      BOOL v45 = st_size <= v43;
      st_size -= v43;
      if (v45) {
        goto LABEL_26;
      }
    }
    uint64_t v46 = v44;
  }
LABEL_29:
  close(v14);
  free(v39);
  if (v46
    || !*(_WORD *)(a1 + 62)
    || v56.st_size % *(unsigned __int16 *)(a1 + 62)
    || (AMRLog(7, @"sending ZLP to terminate transfer", v47, v48, v49, v50, v51, v52, v55),
        uint64_t v21 = sub_100045A8C(a1, 0, 0, 0),
        !v21))
  {
    uint64_t v21 = v46;
    if (a3 == 1 && !st_size)
    {
      CFStringRef v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"setenv filesize %lld", v56.st_size);
      sub_1000458E0(a1);
      double v54 = 60.0;
      if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
        double v54 = 300.0;
      }
      uint64_t v21 = sub_1000489F0(a1, v53, 0, v54);
      CFRelease(v53);
    }
  }
  return v21;
}

uint64_t sub_100049238(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = _AMRUSBDeviceSendDeviceRequest(*(void **)(a1 + 40), 0, 1, 2, 0, 0, 0, 1024, a2);
  uint64_t v9 = v2;
  if (v2) {
    AMRLog(3, @"get command output device request failed: %d", v3, v4, v5, v6, v7, v8, v2);
  }
  return v9;
}

uint64_t sub_1000492A4(uint64_t *a1, const void *a2, const __CFString *a3, const __CFString *a4, char a5)
{
  CFAllocatorRef v10 = CFGetAllocator(a1);
  uint64_t v11 = AMAuthInstallApPersonalizationEnabled(a1[25]);
  uint64_t v12 = v11;
  CFTypeRef cf = 0;
  char v50 = 0;
  if (!a2)
  {
    CFStringRef PathFromURL = 0;
    uint64_t v12 = v11 != 0;
    goto LABEL_10;
  }
  uint64_t v13 = AMAuthInstallSupportCopyURLWithAppendedComponent(v10, a2, a3, 0, (CFURLRef *)&cf);
  if (v13)
  {
    uint64_t v20 = v13;
    AMRLog(3, @"failed to create url for %s", v14, v15, v16, v17, v18, v19, a5);
LABEL_7:
    if (v12) {
      uint64_t v12 = AMAuthInstallToRestoreError(v20);
    }
    CFStringRef PathFromURL = 0;
    goto LABEL_10;
  }
  uint64_t v22 = AMAuthInstallSupportFileURLExists(cf, &v50);
  if (v22)
  {
    uint64_t v20 = v22;
    AMRLog(3, @"failed to stat %s", v23, v24, v25, v26, v27, v28, a5);
    goto LABEL_7;
  }
  if (v50)
  {
    CFAllocatorRef v30 = CFGetAllocator((CFTypeRef)a1[25]);
    CFStringRef PathFromURL = AMRestoreCreatePathFromURL(v30, (const __CFURL *)cf);
    if (PathFromURL)
    {
      uint64_t v37 = sub_100045E10((uint64_t)a1, PathFromURL);
      if (v37)
      {
        uint64_t v12 = v37;
        AMRLog(3, @"failed to send %s (%d)", v38, v39, v40, v41, v42, v43, a5);
      }
      else
      {
        uint64_t v12 = sub_100045CB0((uint64_t)a1, a4, 0);
        if (v12) {
          AMRLog(3, @"device rejected %s (%d)", v44, v45, v46, v47, v48, v49, a5);
        }
      }
    }
    else
    {
      AMRLog(3, @"failed to create path string for %s", v31, v32, v33, v34, v35, v36, a5);
      uint64_t v12 = 18;
    }
  }
  else
  {
    AMRLog(6, @"no %s found", v23, v24, v25, v26, v27, v28, a5);
    CFStringRef PathFromURL = 0;
    if (v12) {
      uint64_t v12 = 11;
    }
    else {
      uint64_t v12 = 0;
    }
  }
LABEL_10:
  if (cf) {
    CFRelease(cf);
  }
  if (PathFromURL) {
    CFRelease(PathFromURL);
  }
  return v12;
}

uint64_t sub_10004946C(uint64_t a1, CFDictionaryRef theDict, void *key, void *a4, uint64_t a5, const __CFDictionary *a6)
{
  if (!CFDictionaryContainsKey(theDict, key)) {
    return 0;
  }
  ++*a4;
  AMRLog(6, @"Sending %@ to device. (%ld of %ld)", v11, v12, v13, v14, v15, v16, (char)key);
  CFURLRef Value = (const __CFURL *)CFDictionaryGetValue(theDict, key);
  uint64_t v18 = sub_1000499E4(a1, Value, a6);
  uint64_t v25 = v18;
  if (v18) {
    AMRLog(3, @"_pushFWToiBoot failed with %d", v19, v20, v21, v22, v23, v24, v18);
  }
  else {
    CFDictionaryRemoveValue(theDict, key);
  }
  return v25;
}

uint64_t sub_100049540(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10004726C(a1, 8, a3, a4, a5, a6, a7, a8);
  int IsBootstrapOnly = AMRestoreDeviceIsBootstrapOnly(a2, (int *)(a1 + 88), v10, v11, v12, v13, v14, v15);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"RestoreBootArgs");
  if (IsBootstrapOnly) {
    BOOL v18 = 0;
  }
  else {
    BOOL v18 = Value == 0;
  }
  if (v18) {
    CFStringRef v19 = @"rd=md0 nand-enable-reformat=1 -progress -restore";
  }
  else {
    CFStringRef v19 = Value;
  }
  if (v19)
  {
    char v88 = (char)v19;
    CFStringRef v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"setenvnp boot-args %@");
    sub_1000458E0(a1);
    double v21 = 60.0;
    if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
      double v21 = 300.0;
    }
    int v22 = sub_1000489F0(a1, v20, 0, v21);
    if (v22)
    {
      char v23 = v22;
      CFRelease(v20);
      AMRLog(4, @"setenvnp command failed with error %d. Could be an old iBoot. Trying plain setenv.", v24, v25, v26, v27, v28, v29, v23);
      char v88 = (char)v19;
      CFStringRef v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"setenv boot-args %@");
      sub_1000458E0(a1);
      double v30 = 60.0;
      if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
        double v30 = 300.0;
      }
      uint64_t v31 = sub_1000489F0(a1, v20, 0, v30);
    }
    else
    {
      uint64_t v31 = 0;
    }
    CFRelease(v20);
  }
  else
  {
    uint64_t v31 = 0;
  }
  CFBooleanRef v32 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"PersistRestoreNVRAMVariables");
  uint64_t v33 = CFDictionaryGetValue(a2, @"RestoreNVRAMVariables");
  if (!v33)
  {
    CFStringRef v75 = @"No readable value found in kAMRestoreOptionsRestoreNVRAMVariables";
    uint64_t v76 = 6;
    goto LABEL_48;
  }
  uint64_t v40 = v33;
  if (v32 == kCFBooleanTrue) {
    CFStringRef v41 = @"setenv";
  }
  else {
    CFStringRef v41 = @"setenvnp";
  }
  CFTypeID v42 = CFGetTypeID(v33);
  if (v42 != CFArrayGetTypeID())
  {
    CFTypeID v77 = CFGetTypeID(v40);
    if (v77 == CFStringGetTypeID())
    {
      CFStringRef v78 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@ %@", v41, v40);
      sub_1000458E0(a1);
      double v79 = 60.0;
      if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
        double v79 = 300.0;
      }
      uint64_t v31 = sub_1000489F0(a1, v78, 0, v79);
      if (v31) {
        AMRLog(4, @"%@ command %@ failed with error %d.", v80, v81, v82, v83, v84, v85, (char)v41);
      }
      CFRelease(v78);
      goto LABEL_49;
    }
    char v88 = CFGetTypeID(0);
    CFStringRef v75 = @"Unrecognized argument type (%lu) in RestoreNVRAMVariables, only support CFArray and CFString.";
    uint64_t v76 = 4;
LABEL_48:
    AMRLog(v76, v75, v34, v35, v36, v37, v38, v39, v88);
    goto LABEL_49;
  }
  if (CFArrayGetCount((CFArrayRef)v40) >= 1)
  {
    for (CFIndex i = 0; CFArrayGetCount((CFArrayRef)v40) > i; ++i)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v40, i);
      CFTypeID v45 = CFGetTypeID(ValueAtIndex);
      if (v45 == CFArrayGetTypeID())
      {
        CFArrayRef v46 = (const __CFArray *)CFArrayGetValueAtIndex((CFArrayRef)v40, i);
        if (v46)
        {
          uint64_t v59 = CFStringCreateByCombiningStrings(kCFAllocatorDefault, v46, @" ");
          if (v59) {
            goto LABEL_30;
          }
        }
        else
        {
          AMRLog(4, @"Couldn't get NVRAM string array in index %d.", v47, v48, v49, v50, v51, v52, i);
        }
      }
      else if (v45 == CFStringGetTypeID())
      {
        uint64_t v59 = CFArrayGetValueAtIndex((CFArrayRef)v40, i);
        CFRetain(v59);
        if (v59)
        {
LABEL_30:
          CFStringRef v66 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@ %@", v41, v59, v89);
          sub_1000458E0(a1);
          double v67 = 60.0;
          if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
            double v67 = 300.0;
          }
          uint64_t v68 = sub_1000489F0(a1, v66, 0, v67);
          uint64_t v31 = v68;
          if (v68)
          {
            uint64_t v89 = v68;
            AMRLog(4, @"%@ command %@ failed with error %d.", v69, v70, v71, v72, v73, v74, (char)v41);
          }
          CFRelease(v66);
          CFRelease(v59);
          continue;
        }
      }
      else
      {
        AMRLog(4, @"Unknown arg type in kAMRestoreOptionsRestoreNVRAMVariables %lu", v60, v61, v62, v63, v64, v65, v45);
      }
      AMRLog(4, @"No executable command at RestoreNVRAMVariables array index %d.", v53, v54, v55, v56, v57, v58, i);
    }
  }
LABEL_49:
  if (v31 || v32 != kCFBooleanTrue) {
    return v31;
  }
  sub_1000458E0(a1);
  double v86 = 60.0;
  if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
    double v86 = 300.0;
  }
  return sub_1000489F0(a1, @"saveenv", 0, v86);
}

uint64_t sub_1000499E4(uint64_t a1, CFURLRef anURL, const __CFDictionary *a3)
{
  if (!anURL) {
    return 1;
  }
  CFStringRef v5 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
  if (!v5) {
    return 18;
  }
  CFStringRef v6 = v5;
  uint64_t v13 = sub_100045E10(a1, v5);
  if (!v13)
  {
    sub_1000458E0(a1);
    if ((*(_DWORD *)(a1 + 92) & 0xFFFFFFF0) == 0xF0) {
      double v15 = 300.0;
    }
    else {
      double v15 = 60.0;
    }
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, @"FPGAValidateFirmwareTimeout");
    if (Value)
    {
      CFNumberRef v17 = Value;
      CFTypeID v18 = CFGetTypeID(Value);
      if (v18 != CFNumberGetTypeID())
      {
        AMRLog(3, @"FPGAValidateFirmwareTimeout expects an integer!", v19, v20, v21, v22, v23, v24, v25);
        uint64_t v13 = 1;
        goto LABEL_5;
      }
      double v15 = sub_100048978(a1, v17);
    }
    uint64_t v13 = sub_1000489F0(a1, @"firmware", 0, v15);
    if (!v13) {
      goto LABEL_5;
    }
  }
  AMRLog(3, @"_sendiBootFirmwareToDevice failed with %d", v7, v8, v9, v10, v11, v12, v13);
LABEL_5:
  CFRelease(v6);
  return v13;
}

CFStringRef sub_100049B1C(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v42 = 0;
  if (AMRestoreOptionsAreLegacy(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
  {
    CFStringRef v43 = 0;
    int v14 = AMRAuthInstallCreatePathFromBundle(*(void **)(a1 + 200), a2, @"RestoreLogo", &v43);
    CFStringRef v15 = v43;
    if (v14) {
      BOOL v16 = 1;
    }
    else {
      BOOL v16 = v43 == 0;
    }
    if (!v16) {
      return v15;
    }
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"NORImagePath");
    if (Value)
    {
      CFStringRef v18 = Value;
      CFRetain(Value);
    }
    else
    {
      CFBooleanRef v32 = CFDictionaryGetValue(a2, @"FirmwareDirectory");
      uint64_t v33 = CFDictionaryGetValue(a2, @"NORImageType");
      CFStringRef v15 = 0;
      if (!v32 || !v33) {
        return v15;
      }
      CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%call_flash%call_flash.%@.%@", v32, 47, 47, *(void *)(a1 + 64), v33);
    }
    CFArrayRef v34 = _AMRestoreCopyManifestForNORImage((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25);
    if (v34)
    {
      CFArrayRef v35 = v34;
      CFIndex Count = CFArrayGetCount(v34);
      if (Count >= 1)
      {
        CFIndex v37 = Count;
        CFIndex v38 = 0;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v35, v38);
          if (CFStringHasPrefix(ValueAtIndex, @"applelogo") == 1
            || CFStringHasPrefix(ValueAtIndex, @"skankwerklogo") == 1)
          {
            break;
          }
          if (v37 == ++v38) {
            goto LABEL_22;
          }
        }
        CFStringRef v43 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%c%@", v18, 47, ValueAtIndex);
      }
LABEL_22:
      CFRelease(v35);
    }
    CFRelease(v18);
    return v43;
  }
  if (AMRAuthInstallCopyFileSystemPathForKey(*(void **)(a1 + 200), a2, @"RestoreLogo", &v42, v10, v11, v12, v13))AMRLog(3, @"Failed to locate boot graphic", v26, v27, v28, v29, v30, v31, v41); {
  return v42;
  }
}

void sub_100049D18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMRLog(7, @"%s: %p", a3, a4, a5, a6, a7, a8, (char)"_AMRecoveryModeDeviceFinalize");
  uint64_t v9 = *(void **)(a1 + 48);
  if (v9)
  {
    _AMRUSBInterfaceClose(v9);
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v10 = *(void **)(a1 + 40);
  if (v10)
  {
    _AMRUSBDeviceClose(v10);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t v11 = *(const void **)(a1 + 64);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v12 = *(const void **)(a1 + 72);
  if (v12)
  {
    CFRelease(v12);
    *(void *)(a1 + 72) = 0;
  }
  if (*(unsigned char *)(a1 + 84) == 1) {
    _AMRestoreDestroyDeviceInfo((void *)(a1 + 88));
  }
  uint64_t v13 = *(const void **)(a1 + 200);
  if (v13)
  {
    CFRelease(v13);
    *(void *)(a1 + 200) = 0;
  }
  int v14 = *(const void **)(a1 + 208);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 208) = 0;
    *(_DWORD *)(a1 + 216) = 0;
  }
}

CFStringRef sub_100049DD4(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<Recovery Mode Device %p>", a1);
}

CFStringRef sub_100049E18(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<AMRecoveryModeDevice %p>", a1);
}

uint64_t AMRPerformDFUDataDownload(void *a1, const __CFData *a2, void (*a3)(unint64_t, uint64_t), uint64_t a4)
{
  unsigned __int16 v53 = 0;
  __int16 v52 = 0;
  Interface = (void *)_AMRUSBDeviceGetInterface(a1, 254, 1);
  if (!Interface) {
    return 2002;
  }
  uint64_t v9 = Interface;
  uint64_t v10 = _AMRUSBInterfaceOpen(Interface);
  if (v10)
  {
    uint64_t DFUInformation = v10;
    AMRLog(3, @"unable to open USB interface: 0x%x", v11, v12, v13, v14, v15, v16, v10);
    return DFUInformation;
  }
  uint64_t DFUInformation = _AMRUSBInterfaceGetDFUInformation(v9, &v53, (unsigned char *)&v52 + 1, &v52);
  _AMRUSBInterfaceClose(v9);
  if (DFUInformation)
  {
    AMRLog(3, @"unable to get DFU information from interface: %d", v18, v19, v20, v21, v22, v23, DFUInformation);
    return DFUInformation;
  }
  uint64_t v24 = v52;
  char v54 = 0;
  if (sub_10004A4AC(a1, v52, &v54)) {
    return 2005;
  }
  if (v54 != 2)
  {
    if (v54 == 10)
    {
      AMRLog(7, @"Issuing CLEARSTATUS request", v25, v26, v27, v28, v29, v30, v51);
      if (_AMRUSBDeviceSendDeviceRequest(a1, v24, 0, 1, 1, 4, 0, 0, 0)) {
        return 2005;
      }
    }
    else if (sub_10004A20C(a1, v24, v25, v26, v27, v28, v29, v30))
    {
      return 2005;
    }
    if (sub_10004A4AC(a1, v24, &v54) || v54 != 2) {
      return 2005;
    }
  }
  unint64_t Length = CFDataGetLength(a2);
  BytePtr = CFDataGetBytePtr(a2);
  if (Length)
  {
    uint64_t v36 = (uint64_t)BytePtr;
    unsigned __int16 v37 = 0;
    unint64_t v38 = Length;
    while (1)
    {
      if (a3) {
        a3(100 * ((int)Length - (int)v38) / Length, a4);
      }
      uint64_t v39 = v38 >= v53 ? v53 : v38;
      if (sub_10004A0D4(a1, v52, v37, v36, v39, 5, v34, v35)) {
        goto LABEL_35;
      }
      ++v37;
      v36 += v39;
      v38 -= v39;
      if (!v38) {
        goto LABEL_28;
      }
    }
  }
  unsigned __int16 v37 = 0;
LABEL_28:
  int v44 = sub_10004A0D4(a1, v52, v37, 0, 0, 7, v34, v35);
  if (v44)
  {
    if (v44 != 2006)
    {
      AMRLog(3, @"sending DFU ZLP returned 0x%x", v45, v46, v47, v48, v49, v50, v44);
LABEL_35:
      sub_10004A20C(a1, v52, v40, v41, v42, v43, v34, v35);
      return 2005;
    }
    AMRLog(5, @"device not responding during DFU ZLP", v45, v46, v47, v48, v49, v50, v51);
  }
  if ((v52 & 0x400) == 0) {
    _AMRUSBDeviceReEnumerate(a1);
  }
  return 0;
}

uint64_t sub_10004A0D4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a6;
  __int16 v9 = a5;
  AMRLog(7, @"Issuing DNLOAD request", a3, a4, a5, a6, a7, a8, v28);
  uint64_t result = _AMRUSBDeviceSendDeviceRequest(a1, a2, 0, 1, 1, 1, a3, v9, a4);
  if (!result)
  {
    int v15 = 0;
    __int16 v30 = 0;
    int v29 = 0;
    while (1)
    {
      if (v15) {
        usleep(1000 * v15);
      }
      uint64_t result = _AMRUSBDeviceSendDeviceRequest(a1, a2, 1, 1, 1, 3, 0, 6, (uint64_t)&v29);
      if (result) {
        break;
      }
      AMRLog(7, @"Issued GETSTATUS request: state = %d status = %d", v16, v17, v18, v19, v20, v21, v30);
      if ((_BYTE)v29)
      {
        AMRLog(3, @"GETSTATUS status is %d", v22, v23, v24, v25, v26, v27, v29);
        return 0xFFFFFFFFLL;
      }
      int v15 = *(unsigned __int16 *)((char *)&v29 + 1) | (HIBYTE(v29) << 16);
      if (v30 == v8) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10004A20C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  AMRLog(7, @"Issuing ABORT request", a3, a4, a5, a6, a7, a8, v11);
  return _AMRUSBDeviceSendDeviceRequest(a1, a2, 0, 1, 1, 6, 0, 0, 0);
}

uint64_t AMRPerformDFUFileDownload(void *a1, const __CFString *a2, void (*a3)(unint64_t, uint64_t), uint64_t a4)
{
  bzero(buffer, 0x400uLL);
  CFStringGetFileSystemRepresentation(a2, buffer, 1024);
  memset(&v62, 0, sizeof(v62));
  int v8 = open(buffer, 0);
  if (v8 != -1)
  {
    int v9 = v8;
    if (fstat(v8, &v62) == -1)
    {
      uint64_t v33 = __error();
      char v34 = strerror(*v33);
      AMRLogWithFilePath(3, (uint64_t)a2, @"unable to fstat DFU file: %s", v35, v36, v37, v38, v39, v34);
      uint64_t v40 = __error();
      uint64_t v18 = _AMRestoreErrorForErrno(*v40, 11, v41, v42, v43, v44, v45, v46);
    }
    else
    {
      uint64_t v10 = (UInt8 *)mmap(0, v62.st_size, 1, 2, v9, 0);
      if (v10 == (UInt8 *)-1)
      {
        uint64_t v47 = __error();
        char v48 = strerror(*v47);
        AMRLogWithFilePath(3, (uint64_t)a2, @"unable to mmap DFU file: %s", v49, v50, v51, v52, v53, v48);
        char v54 = __error();
        uint64_t v18 = _AMRestoreErrorForErrno(*v54, 11, v55, v56, v57, v58, v59, v60);
        goto LABEL_11;
      }
      CFDataRef v11 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v10, v62.st_size, kCFAllocatorNull);
      if (v11)
      {
        CFDataRef v17 = v11;
        uint64_t v18 = AMRPerformDFUDataDownload(a1, v11, a3, a4);
        CFRelease(v17);
        if (!v10) {
          goto LABEL_12;
        }
        goto LABEL_11;
      }
      AMRLogWithFilePath(3, (uint64_t)a2, @"unable to create data from DFU file", v12, v13, v14, v15, v16, 0);
      uint64_t v18 = 18;
      if (v10) {
LABEL_11:
      }
        munmap(v10, v62.st_size);
    }
LABEL_12:
    close(v9);
    return v18;
  }
  uint64_t v19 = __error();
  char v20 = strerror(*v19);
  AMRLogWithFilePath(3, (uint64_t)a2, @"unable to open DFU file: %s", v21, v22, v23, v24, v25, v20);
  uint64_t v26 = __error();
  return _AMRestoreErrorForErrno(*v26, 12, v27, v28, v29, v30, v31, v32);
}

uint64_t sub_10004A4AC(void *a1, uint64_t a2, char *a3)
{
  uint64_t v4 = _AMRUSBDeviceSendDeviceRequest(a1, a2, 1, 1, 1, 5, 0, 1, (uint64_t)a3);
  uint64_t v11 = v4;
  if (v4)
  {
    *a3 = 10;
    AMRLog(3, @"Issued GETSTATE request: returned 0x%x", v5, v6, v7, v8, v9, v10, v4);
  }
  else
  {
    AMRLog(7, @"Issued GETSTATE request: state = 0x%x", v5, v6, v7, v8, v9, v10, *a3);
  }
  return v11;
}

void _AMAuthInstallLogHandler(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t AMAuthInstallToRestoreError(uint64_t result)
{
  if ((result - 3100) >= 0x384)
  {
    if (result > 0x16) {
      return 0xFFFFFFFFLL;
    }
    else {
      return dword_10007E958[(int)result];
    }
  }
  return result;
}

uint64_t AMRestoreCreatePathFromURLWithAppendedComponent(const __CFAllocator *a1, const void *a2, const __CFString *a3, Boolean a4, CFTypeRef *a5)
{
  bzero(buffer, 0x400uLL);
  CFTypeRef cf = 0;
  uint64_t v10 = AMAuthInstallSupportCopyURLWithAppendedComponent(a1, a2, a3, a4, (CFURLRef *)&cf);
  if (v10)
  {
    uint64_t v11 = AMAuthInstallToRestoreError(v10);
  }
  else if (CFURLGetFileSystemRepresentation((CFURLRef)cf, 1u, buffer, 1024))
  {
    CFStringRef v13 = CFStringCreateWithCString(a1, (const char *)buffer, 0x8000100u);
    if (v13)
    {
      CFStringRef v14 = v13;
      *a5 = CFRetain(v13);
      CFRelease(v14);
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v11 = 18;
    }
  }
  else
  {
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

uint64_t _AMRAuthInstallApplyBundleOverride(CFTypeRef cf, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (uint64_t)cf;
  if (!cf)
  {
    AMRLog(3, @"Can't override bundle value with NULL key", a3, a4, a5, a6, a7, a8, v34);
    return v8;
  }
  CFTypeID v11 = CFGetTypeID(cf);
  if (v11 != CFStringGetTypeID())
  {
    CFStringRef v32 = @"Can't override bundle value with non CFType key";
LABEL_15:
    AMRLog(3, v32, v12, v13, v14, v15, v16, v17, v34);
    return 0;
  }
  if (!a2)
  {
    CFStringRef v32 = @"Can't override bundle value with NULL value";
    goto LABEL_15;
  }
  CFTypeID v18 = CFGetTypeID(a2);
  if (v18 != CFStringGetTypeID())
  {
    CFStringRef v32 = @"Can't override bundle value with non CFType value";
    goto LABEL_15;
  }
  if (!a3)
  {
    CFStringRef v32 = @"Can't override bundle value without amai ref";
    goto LABEL_15;
  }
  CFURLRef URLFromString = AMAuthInstallSupportCreateURLFromString(kCFAllocatorDefault, a2, v12, v13, v14, v15, v16, v17);
  if (!URLFromString)
  {
    CFStringRef v32 = @"Failed to create override URL from URL string";
    goto LABEL_15;
  }
  CFURLRef v20 = URLFromString;
  AMRLogWithFilePath(6, (uint64_t)a2, @"Applying bundle file override for key:%@", v13, v14, v15, v16, v17, v8);
  if (AMAuthInstallBundleOverrideEntry(a3, (const void *)v8, v20, v21, v22, v23, v24, v25))
  {
    AMRLog(3, @"Failed to set bundle override for key:%@", v26, v27, v28, v29, v30, v31, v8);
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 1;
  }
  CFRelease(v20);
  return v8;
}

uint64_t _AMRAuthInstallAlignOptionsToPersonalizedBundle(__CFDictionary *a1, const void *a2, int a3)
{
  CFTypeRef cf = 0;
  values = 0;
  CFTypeRef v64 = 0;
  CFStringRef ReceiptComponent = AMAuthInstallBundleGetReceiptComponent();
  uint64_t v7 = AMAuthInstallSupportCopyURLWithAppendedComponent(kCFAllocatorDefault, a2, ReceiptComponent, 0, (CFURLRef *)&cf);
  if (v7) {
    goto LABEL_4;
  }
  uint64_t v8 = AMAuthInstallSupportCreateDictionaryFromFileURL(kCFAllocatorDefault, &v64, (const __CFURL *)cf);
  if (v8)
  {
    uint64_t v9 = v8;
    CFStringRef v10 = CFURLCopyPath((CFURLRef)a2);
    AMRLogWithFilePath(3, (uint64_t)v10, @"failed to open personalization receipt", v11, v12, v13, v14, v15, v61);
    CFRelease(v10);
    uint64_t v7 = v9;
LABEL_4:
    uint64_t PathFromURLWithAppendedComponent = AMAuthInstallToRestoreError(v7);
LABEL_5:
    CFURLRef v17 = 0;
    CFStringRef v18 = 0;
LABEL_6:
    CFStringRef v19 = 0;
    CFStringRef v20 = 0;
    goto LABEL_7;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v64, @"Alignment");
  if (!Value)
  {
    AMRLog(3, @"bundle is missing alignment info", v23, v24, v25, v26, v27, v28, v61);
    CFURLRef v17 = 0;
    CFStringRef v18 = 0;
    CFStringRef v19 = 0;
    CFStringRef v20 = 0;
    uint64_t PathFromURLWithAppendedComponent = 1;
    goto LABEL_7;
  }
  CFDictionaryRef v29 = Value;
  uint64_t v30 = CFDictionaryGetValue(Value, @"DFUFileType");
  if (v30) {
    CFDictionarySetValue(a1, @"DFUFileType", v30);
  }
  if (CFDictionaryGetValue(a1, @"SystemImageType") || CFDictionaryGetValue(a1, @"SystemImage"))
  {
    CFStringRef v31 = (const __CFString *)CFDictionaryGetValue(v29, @"OS");
    if (v31)
    {
      keys = 0;
      uint64_t PathFromURLWithAppendedComponent = AMRestoreCreatePathFromURLWithAppendedComponent(kCFAllocatorDefault, a2, v31, 0, (CFTypeRef *)&values);
      if (PathFromURLWithAppendedComponent) {
        goto LABEL_5;
      }
      keys = @"ImageFile";
      CFDictionaryRef v32 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFRelease(values);
      values = 0;
      if (!v32)
      {
        uint64_t PathFromURLWithAppendedComponent = 18;
        goto LABEL_5;
      }
      CFDictionaryAddValue(a1, @"SystemImage", v32);
      CFRelease(v32);
    }
  }
  CFStringRef v33 = (const __CFString *)CFDictionaryGetValue(v29, @"KernelCache");
  if (v33)
  {
    CFStringRef v19 = v33;
    CFStringRef v34 = (const __CFString *)CFDictionaryGetValue(a1, @"KernelCacheFile");
    if (v34)
    {
      CFURLRef URLFromString = AMAuthInstallSupportCreateURLFromString(kCFAllocatorDefault, v34, v35, v36, v37, v38, v39, v40);
      CFURLRef v17 = URLFromString;
      if (!URLFromString)
      {
        CFStringRef v18 = 0;
        CFStringRef v19 = 0;
        goto LABEL_71;
      }
      CFStringRef PathComponent = CFURLCopyLastPathComponent(URLFromString);
      CFStringRef v19 = PathComponent;
      if (!PathComponent)
      {
        CFStringRef v18 = 0;
        goto LABEL_71;
      }
      CFStringRef v18 = PathComponent;
    }
    else
    {
      CFURLRef v17 = 0;
      CFStringRef v18 = 0;
    }
    uint64_t v43 = AMRestoreCreatePathFromURLWithAppendedComponent(kCFAllocatorDefault, a2, v19, 0, (CFTypeRef *)&values);
    if (v43)
    {
      uint64_t PathFromURLWithAppendedComponent = v43;
      goto LABEL_6;
    }
    CFDictionarySetValue(a1, @"KernelCacheFile", values);
    CFRelease(values);
    values = 0;
  }
  else
  {
    CFURLRef v17 = 0;
    CFStringRef v18 = 0;
  }
  CFStringRef v44 = (const __CFString *)CFDictionaryGetValue(v29, @"RestoreKernelCache");
  if (!v44)
  {
    CFStringRef v19 = 0;
    CFStringRef v20 = 0;
    goto LABEL_51;
  }
  CFStringRef v45 = v44;
  CFStringRef v46 = (const __CFString *)CFDictionaryGetValue(a1, @"RestoreKernelCacheFile");
  if (!v46)
  {
    CFStringRef v19 = 0;
    CFStringRef v20 = 0;
    goto LABEL_49;
  }
  CFURLRef v53 = AMAuthInstallSupportCreateURLFromString(kCFAllocatorDefault, v46, v47, v48, v49, v50, v51, v52);
  CFStringRef v19 = (const __CFString *)v53;
  if (!v53 || (CFStringRef v54 = CFURLCopyLastPathComponent(v53)) == 0)
  {
LABEL_71:
    CFStringRef v20 = 0;
    uint64_t PathFromURLWithAppendedComponent = 31;
    goto LABEL_7;
  }
  CFStringRef v45 = v54;
  CFStringRef v20 = v54;
LABEL_49:
  uint64_t v55 = AMRestoreCreatePathFromURLWithAppendedComponent(kCFAllocatorDefault, a2, v45, 0, (CFTypeRef *)&values);
  if (v55) {
    goto LABEL_69;
  }
  CFDictionarySetValue(a1, @"RestoreKernelCacheFile", values);
  CFRelease(values);
  values = 0;
LABEL_51:
  CFStringRef v56 = (const __CFString *)CFDictionaryGetValue(v29, @"RestoreRamDisk");
  if (v56)
  {
    uint64_t v55 = AMRestoreCreatePathFromURLWithAppendedComponent(kCFAllocatorDefault, a2, v56, 0, (CFTypeRef *)&values);
    if (v55) {
      goto LABEL_69;
    }
    CFDictionarySetValue(a1, @"BootImageFile", values);
    CFRelease(values);
    values = 0;
  }
  int v62 = CFDictionaryContainsKey(a1, @"FirmwareDirectory");
  if (a3) {
    CFStringRef v57 = @"RestoreDeviceTree";
  }
  else {
    CFStringRef v57 = @"DeviceTree";
  }
  CFStringRef v58 = (const __CFString *)CFDictionaryGetValue(v29, v57);
  if (v58)
  {
    uint64_t v55 = AMRestoreCreatePathFromURLWithAppendedComponent(kCFAllocatorDefault, a2, v58, 0, (CFTypeRef *)&values);
    if (v55) {
      goto LABEL_69;
    }
    if (!v62) {
      CFDictionarySetValue(a1, @"DeviceTreeFile", values);
    }
    CFRelease(values);
    values = 0;
  }
  CFStringRef v59 = (const __CFString *)CFDictionaryGetValue(v29, @"AllFlash");
  if (v59)
  {
    uint64_t v55 = AMRestoreCreatePathFromURLWithAppendedComponent(kCFAllocatorDefault, a2, v59, 1u, (CFTypeRef *)&values);
    if (!v55)
    {
      if (!v62) {
        CFDictionarySetValue(a1, @"NORImagePath", values);
      }
      CFRelease(values);
      values = 0;
      goto LABEL_67;
    }
LABEL_69:
    uint64_t PathFromURLWithAppendedComponent = v55;
    goto LABEL_7;
  }
LABEL_67:
  CFStringRef v60 = (const __CFString *)CFDictionaryGetValue(v29, @"Diags");
  if (v60)
  {
    uint64_t v55 = AMRestoreCreatePathFromURLWithAppendedComponent(kCFAllocatorDefault, a2, v60, 1u, (CFTypeRef *)&values);
    if (v55) {
      goto LABEL_69;
    }
    CFDictionarySetValue(a1, @"DiagToInstall", values);
    CFRelease(values);
    values = 0;
  }
  CFDictionaryRemoveValue(a1, @"DFUFile");
  CFDictionaryRemoveValue(a1, @"BoardConfig");
  CFDictionaryRemoveValue(a1, @"SystemImageType");
  CFDictionaryRemoveValue(a1, @"KernelCacheType");
  CFDictionaryRemoveValue(a1, @"BootImageType");
  if (!v62) {
    CFDictionaryRemoveValue(a1, @"NORImageType");
  }
  uint64_t PathFromURLWithAppendedComponent = 0;
LABEL_7:
  if (cf) {
    CFRelease(cf);
  }
  if (v64) {
    CFRelease(v64);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (v20) {
    CFRelease(v20);
  }
  return PathFromURLWithAppendedComponent;
}

uint64_t AMRAuthInstallAlignOptionsToPersonalizedBundle(__CFDictionary *a1, const __CFString *a2, int a3)
{
  CFURLRef v5 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, a2, kCFURLPOSIXPathStyle, 1u);
  if (!v5) {
    return 18;
  }
  CFURLRef v6 = v5;
  uint64_t v7 = _AMRAuthInstallAlignOptionsToPersonalizedBundle(a1, v5, a3);
  CFRelease(v6);
  return v7;
}

uint64_t AMRAuthInstallDeletePersonalizedBundle(const __CFString *a1, const __CFDictionary *a2)
{
  pthread_once(&stru_1000B8A80, (void (*)(void))sub_10004EB64);
  AMRLog(7, @"%s", v4, v5, v6, v7, v8, v9, (char)"AMRAuthInstallDeletePersonalizedBundle");
  if (sub_10004AF68(a2, 0, @"AuthInstallPreservePersonalizedBundles"))
  {
    char v34 = 0;
    CFURLRef v15 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, a1, kCFURLPOSIXPathStyle, 1u);
    if (v15)
    {
      CFURLRef v16 = v15;
      uint64_t v17 = AMAuthInstallSupportFileURLExists(v15, &v34);
      if (v17)
      {
        uint64_t v28 = v17;
      }
      else if (v34)
      {
        uint64_t v28 = AMAuthInstallSupportRemoveDirectory(v16);
        if (v28)
        {
          CFStringRef v29 = @"failed to remove personalized bundle";
          uint64_t v30 = 3;
        }
        else
        {
          CFStringRef v29 = @"removed personalized bundle";
          uint64_t v30 = 8;
        }
        AMRLogWithFilePath(v30, (uint64_t)a1, v29, v23, v24, v25, v26, v27, v33);
      }
      else
      {
        AMRLogWithFilePath(7, (uint64_t)a1, @"personalized bundle does not exist, skipping removal", v18, v19, v20, v21, v22, v33);
        uint64_t v28 = 0;
      }
      uint64_t v31 = AMAuthInstallToRestoreError(v28);
      CFRelease(v16);
    }
    else
    {
      return 18;
    }
  }
  else
  {
    AMRLogWithFilePath(6, (uint64_t)a1, @"preserved personalized bundle: %@", v10, v11, v12, v13, v14, 0);
    return 0;
  }
  return v31;
}

CFBooleanRef sub_10004AF68(const __CFDictionary *a1, __CFDictionary *a2, const __CFString *a3)
{
  CFTypeID TypeID = CFBooleanGetTypeID();
  CFBooleanRef result = (const __CFBoolean *)sub_10004EBBC(a1, a2, a3, TypeID);
  if (result)
  {
    CFBooleanRef v8 = result;
    uint64_t Value = CFBooleanGetValue(result);
    CFRelease(v8);
    return (const __CFBoolean *)Value;
  }
  return result;
}

uint64_t AMRAuthInstallEnablePersonalization(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t result = 1;
  if (!a1 || !theDict) {
    return result;
  }
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"UpdateBaseband");
  if (CFDictionaryContainsKey(theDict, @"AuthInstallVariant")) {
    BOOL v12 = 0;
  }
  else {
    BOOL v12 = CFDictionaryContainsKey(theDict, @"AuthInstallRestoreBehavior") == 0;
  }
  BOOL v13 = 1;
  if (!v12 && Value) {
    BOOL v13 = CFBooleanGetValue(Value) == 0;
  }
  if (v12)
  {
    AMRLog(6, @"Ap personalization disabled.", v6, v7, v8, v9, v10, v11, v50);
    uint64_t v14 = AMAuthInstallApEnablePersonalization(a1, 0);
  }
  else
  {
    uint64_t v14 = AMAuthInstallApEnablePersonalization(a1, 1);
    CFURLRef v15 = CFDictionaryGetValue(theDict, @"AuthInstallForceServerSigning");
    if (v15)
    {
      CFURLRef v16 = v15;
      CFTypeID TypeID = CFBooleanGetTypeID();
      if (TypeID == CFGetTypeID(v16) && CFBooleanGetValue((CFBooleanRef)v16) == 1) {
        AMAuthInstallApImg4ForceServerSigning(a1);
      }
    }
  }
  if (v14)
  {
    CFStringRef v42 = @"%s: AMAuthInstallApEnablePersonalization failed";
LABEL_38:
    uint64_t v43 = AMAuthInstallToRestoreError(v14);
    AMRLog(3, v42, v44, v45, v46, v47, v48, v49, (char)"AMRAuthInstallEnablePersonalization");
    return v43;
  }
  CFBooleanRef v18 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"AuthInstallRequestTicketWithoutNonce");
  v21 = v18 && (CFBooleanRef v19 = v18, v20 = CFGetTypeID(v18), v20 == CFBooleanGetTypeID()) && CFBooleanGetValue(v19) == 1;
  CFBooleanRef v22 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"SkipNoncesForAPSEP");
  BOOL v31 = v22 && (v29 = v22, v30 = CFGetTypeID(v22), v30 == CFBooleanGetTypeID()) && CFBooleanGetValue(v29) == 1;
  if (v31 || v21)
  {
    uint64_t v32 = AMAuthInstallBundleRequestTicketWithoutNonce(a1, 1);
    if (v32)
    {
      uint64_t v14 = v32;
      CFStringRef v42 = @"%s: AMAuthInstallBundleRequestTicketWithoutNonce failed";
      goto LABEL_38;
    }
  }
  if (v13)
  {
    AMRLog(6, @"Baseband personalization is disabled", v23, v24, v25, v26, v27, v28, v50);
    char v33 = 0;
  }
  else
  {
    char v33 = 1;
  }
  uint64_t v34 = AMAuthInstallBasebandEnablePersonalization(a1, v33);
  if (v34)
  {
    uint64_t v14 = v34;
    CFStringRef v42 = @"%s: AMAuthInstallBasebandEnablePersonalization failed";
    goto LABEL_38;
  }
  if (CFDictionaryGetValue(theDict, @"AuthInstallLocalPolicyHactivate") != kCFBooleanTrue) {
    return 0;
  }
  uint64_t result = AMAuthInstallApEnableLocalPolicyHactivation(a1, v35, v36, v37, v38, v39, v40, v41);
  if (result)
  {
    uint64_t v14 = result;
    CFStringRef v42 = @"%s: AMAuthInstallApEnableLocalPolicyHactivation failed";
    goto LABEL_38;
  }
  return result;
}

uint64_t AMRAuthInstallAddUUID(const void *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    CFStringRef v31 = @"amai is NULL";
LABEL_10:
    AMRLog(3, v31, a3, a4, a5, a6, a7, a8, v32);
    return 1;
  }
  if (!a2)
  {
    CFStringRef v31 = @"options is NULL";
    goto LABEL_10;
  }
  CFStringRef v33 = 0;
  CFAllocatorRef v10 = CFGetAllocator(a1);
  uint64_t UUIDString = AMRAuthInstallGetUUIDString(v10, a2, &v33, v11, v12, v13, v14, v15);
  if (UUIDString)
  {
    uint64_t v29 = UUIDString;
    AMRLog(3, @"AMRAuthInstallGetUUIDString failed", v17, v18, v19, v20, v21, v22, v32);
  }
  else if (v33)
  {
    uint64_t v29 = AMAuthInstallSetUUID((uint64_t)a1, v33);
    if (v29)
    {
      AMRLog(3, @"failed to add uuid", v23, v24, v25, v26, v27, v28, v32);
      return AMAuthInstallToRestoreError(v29);
    }
  }
  else
  {
    AMRLog(3, @"uuidString is NULL", v17, v18, v19, v20, v21, v22, v32);
    return 3014;
  }
  return v29;
}

void sub_10004B33C(const __CFDictionary *a1, CFStringRef key, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (key)
    {
      CFTypeRef v8 = sub_10004EBBC(a1, a1, key, a3);
      if (v8)
      {
        CFRelease(v8);
      }
    }
    else
    {
      AMRLog(6, @"%s: optionToOverride is NULL", 0, a3, a5, a6, a7, a8, (char)"_AMRAuthInstallApplyCFPreferencesOverride");
    }
  }
  else
  {
    AMRLog(6, @"%s: options is NULL", a3, a4, a5, a6, a7, a8, (char)"_AMRAuthInstallApplyCFPreferencesOverride");
  }
}

uint64_t AMRAuthInstallSetFDRTrustObjectHash_0(const void *a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = 1;
  CFStringRef v10 = @"bad parameter";
  if (a1 && theDict)
  {
    CFBooleanRef Value = CFDictionaryGetValue(theDict, @"CertifySEP");
    BOOL v21 = Value
       && (uint64_t v19 = Value, TypeID = CFBooleanGetTypeID(), TypeID == CFGetTypeID(v19))
       && CFBooleanGetValue((CFBooleanRef)v19) == 1;
    BOOL v22 = sub_10004D7E0(a1, theDict, v13, v14, v15, v16, v17, v18);
    uint64_t v9 = 0xFFFFFFFFLL;
    CFStringRef v10 = @"AMRAuthInstallCopyTrustObjectOverride failed";
    if (!v22 && !v21) {
      return 0;
    }
  }
  AMRLog(3, v10, a3, a4, a5, a6, a7, a8, v24);
  return v9;
}

CFStringRef AMRestoreCreatePathFromURL(const __CFAllocator *a1, const __CFURL *a2)
{
  bzero(buffer, 0x400uLL);
  if (CFURLGetFileSystemRepresentation(a2, 1u, buffer, 1024)) {
    return CFStringCreateWithCString(a1, (const char *)buffer, 0x8000100u);
  }
  else {
    return 0;
  }
}

uint64_t sub_10004B520(const __CFDictionary *a1, __CFDictionary *a2, CFTypeRef *a3, CFTypeRef *a4)
{
  CFTypeID TypeID = CFStringGetTypeID();
  CFStringRef v9 = (const __CFString *)sub_10004EBBC(a1, a2, @"AuthInstallSigningServerURL", TypeID);
  if (v9)
  {
    CFStringRef v10 = v9;
    CFAllocatorRef v11 = kCFAllocatorDefault;
  }
  else
  {
    __int16 valuePtr = 443;
    if (a1)
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"AuthInstallSigningServerHost");
      CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(a1, @"AuthInstallSigningServerPort");
    }
    else
    {
      CFStringRef Value = 0;
      CFNumberRef v13 = 0;
    }
    CFStringRef v14 = @"gs.apple.com";
    if ((unint64_t)Value | (unint64_t)v13)
    {
      uint64_t v15 = 80;
      __int16 valuePtr = 80;
      if (Value) {
        CFStringRef v14 = Value;
      }
      if (v13)
      {
        CFNumberGetValue(v13, kCFNumberShortType, &valuePtr);
        uint64_t v15 = valuePtr;
      }
      CFStringRef v16 = @"http";
    }
    else
    {
      CFStringRef v16 = @"https";
      uint64_t v15 = 443;
    }
    CFAllocatorRef v11 = kCFAllocatorDefault;
    CFStringRef v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@://%@:%u", v16, v14, v15);
    if (!v17) {
      return 18;
    }
    CFStringRef v10 = v17;
  }
  CFURLRef v18 = CFURLCreateWithString(v11, v10, 0);
  if (v18)
  {
    uint64_t v19 = v18;
    if (a3) {
      *a3 = CFRetain(v10);
    }
    if (a4) {
      *a4 = CFRetain(v19);
    }
    CFRelease(v10);
    uint64_t v20 = 0;
  }
  else
  {
    uint64_t v20 = 18;
    uint64_t v19 = v10;
  }
  CFRelease(v19);
  return v20;
}

uint64_t AMRAuthInstallCopyBuildIdentity(const void *a1, CFDictionaryRef theDict, const __CFString *a3, CFTypeRef *a4)
{
  uint64_t v4 = 1;
  if (a1 && theDict && a4)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"RestoreBundlePath");
    if (!Value)
    {
      AMRLog(3, @"kAMRestoreOptionsRestoreBundlePath not found in options dictionary", v9, v10, v11, v12, v13, v14, v34);
      return v4;
    }
    CFStringRef v15 = Value;
    CFAllocatorRef v16 = CFGetAllocator(a1);
    CFURLRef v17 = CFURLCreateWithFileSystemPath(v16, v15, kCFURLPOSIXPathStyle, 1u);
    if (!v17)
    {
      AMRLog(3, @"failed to create bundleURL from '%@'", v18, v19, v20, v21, v22, v23, (char)v15);
      return 18;
    }
    CFURLRef v24 = v17;
    uint64_t v25 = AMAuthInstallBundleCopyBuildIdentityForVariant((uint64_t)a1, v17, a3, a4);
    if (v25)
    {
      uint64_t v4 = AMAuthInstallToRestoreError(v25);
      CFStringRef v33 = @"AMAuthInstallBundleCopyBuildIdentityForVariant failed";
    }
    else
    {
      if (*a4)
      {
        uint64_t v4 = 0;
LABEL_9:
        CFRelease(v24);
        return v4;
      }
      uint64_t v4 = 3014;
      CFStringRef v33 = @"AMAuthInstallBundleCopyBuildIdentityForVariant failed to create buildIdentity";
    }
    AMRLog(3, v33, v26, v27, v28, v29, v30, v31, v34);
    goto LABEL_9;
  }
  return v4;
}

CFStringRef AMRAuthInstallCopyVariant(const void *a1, CFDictionaryRef theDict)
{
  CFStringRef v2 = 0;
  CFTypeRef cf = 0;
  if (!a1 || !theDict) {
    return v2;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"AuthInstallVariant");
  if (Value)
  {
    CFStringRef v2 = Value;
    AMRLog(6, @"requested variant: %@", v6, v7, v8, v9, v10, v11, (char)Value);
LABEL_7:
    CFRetain(v2);
    return v2;
  }
  CFStringRef v12 = (const __CFString *)CFDictionaryGetValue(theDict, @"AuthInstallRestoreBehavior");
  if (v12)
  {
    CFStringRef v2 = v12;
    AMAuthInstallBundleSetVariantSpecifiesRestoreBehavior((uint64_t)a1, 1);
    AMRLog(6, @"requested restore behavior: %@", v13, v14, v15, v16, v17, v18, (char)v2);
    goto LABEL_7;
  }
  CFStringRef v2 = (const __CFString *)CFDictionaryGetValue(theDict, @"RestoreBundlePath");
  if (!v2)
  {
    AMRLog(3, @"kAMRestoreOptionsRestoreBundlePath not found in options dictionary", v20, v21, v22, v23, v24, v25, v49);
    return v2;
  }
  CFAllocatorRef v26 = CFGetAllocator(a1);
  CFURLRef v27 = CFURLCreateWithFileSystemPath(v26, v2, kCFURLPOSIXPathStyle, 1u);
  if (!v27)
  {
    AMRLog(3, @"failed to create bundleURL from '%@'", v28, v29, v30, v31, v32, v33, (char)v2);
    return 0;
  }
  CFURLRef v34 = v27;
  CFStringRef v2 = @"Internal Development";
  if (AMRAuthInstallCopyBuildIdentity(a1, theDict, @"Internal Development", &cf)
    && (CFStringRef v2 = @"Factory - Software Download",
        AMRAuthInstallCopyBuildIdentity(a1, theDict, @"Factory - Software Download", &cf))
    && (CFStringRef v2 = 0, AMRAuthInstallCopyBuildIdentity(a1, theDict, 0, &cf)))
  {
    AMRLog(3, @"AMRAuthInstallCopyBuildIdentity failed", v35, v36, v37, v38, v39, v40, v49);
    CFStringRef v2 = 0;
  }
  else
  {
    if (!cf)
    {
      CFStringRef v48 = @"AMRAuthInstallCopyBuildIdentity failed to create buildIdentity";
      goto LABEL_17;
    }
    CFAllocatorRef v41 = CFGetAllocator(a1);
    CFDictionaryRef ValueForKeyPathInDict = AMAuthInstallSupportGetValueForKeyPathInDict(v41, (const __CFDictionary *)cf, @"Info.Variant", v42, v43, v44, v45, v46);
    CFStringRef v2 = (const __CFString *)ValueForKeyPathInDict;
    if (!ValueForKeyPathInDict)
    {
      CFStringRef v48 = @"no variant found in BuildManifest.plist";
LABEL_17:
      AMRLog(3, v48, v35, v36, v37, v38, v39, v40, v49);
      goto LABEL_18;
    }
    CFRetain(ValueForKeyPathInDict);
  }
LABEL_18:
  CFRelease(v34);
  if (cf) {
    CFRelease(cf);
  }
  return v2;
}

const void *AMRAuthInstallCopyRecoveryOSVariant(const void *a1, CFDictionaryRef theDict)
{
  CFDictionaryRef ValueForKeyPathInDict = 0;
  CFTypeRef cf = 0;
  if (!a1 || !theDict) {
    return ValueForKeyPathInDict;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"AuthInstallVariant");
  if (!Value)
  {
    CFDictionaryRef ValueForKeyPathInDict = CFDictionaryGetValue(theDict, @"AuthInstallRecoveryOSVariant");
    if (!ValueForKeyPathInDict)
    {
      CFStringRef v30 = @"Failed to create recovery OS variant , no recovery variant in options nor restore variant.";
      goto LABEL_28;
    }
    goto LABEL_8;
  }
  AMRAuthInstallCopyBuildIdentity(a1, theDict, Value, &cf);
  CFDictionaryRef ValueForKeyPathInDict = CFDictionaryGetValue(theDict, @"AuthInstallRecoveryOSVariant");
  if (ValueForKeyPathInDict)
  {
LABEL_8:
    AMRLog(6, @"requested recovery OS variant: %@", v6, v7, v8, v9, v10, v11, (char)ValueForKeyPathInDict);
    goto LABEL_9;
  }
  if (!cf)
  {
LABEL_31:
    CFStringRef v28 = @"AMRAuthInstallCopyBuildIdentity failed to create buildIdentity.";
    goto LABEL_32;
  }
  CFAllocatorRef v12 = CFGetAllocator(a1);
  CFDictionaryRef ValueForKeyPathInDict = AMAuthInstallSupportGetValueForKeyPathInDict(v12, (const __CFDictionary *)cf, @"Info.RecoveryVariant", v13, v14, v15, v16, v17);
LABEL_9:
  CFBooleanRef v18 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"MacOSVariantPresent");
  if (v18 && v18 == kCFBooleanTrue)
  {
    CFStringRef v19 = @"MacOS variant present, using MacOS restore path";
LABEL_20:
    AMRLog(6, v19, v6, v7, v8, v9, v10, v11, (char)v31);
    goto LABEL_21;
  }
  if (!Value)
  {
    uint64_t v31 = "AMRAuthInstallCopyRecoveryOSVariant";
    CFStringRef v19 = @"%s: Couldn't find variant in restoreOptions ,continue to check if recoveryOS variant present.";
    goto LABEL_20;
  }
  if (!cf) {
    goto LABEL_31;
  }
  CFAllocatorRef v20 = CFGetAllocator(a1);
  CFDictionaryRef v26 = AMAuthInstallSupportGetValueForKeyPathInDict(v20, (const __CFDictionary *)cf, @"Info.MacOSVariant", v21, v22, v23, v24, v25);
  if (!v26)
  {
LABEL_21:
    if (ValueForKeyPathInDict)
    {
LABEL_22:
      if (!AMAuthInstallSetRecoveryOSVariant((uint64_t)a1, ValueForKeyPathInDict))
      {
        CFRetain(ValueForKeyPathInDict);
        goto LABEL_24;
      }
      CFStringRef v28 = @"AMAuthInstallSetRecoveryOSVariant failed to set  recovery OS variant.";
      goto LABEL_32;
    }
    CFStringRef v30 = @"no recovery OS variant found in BuildManifest.plist";
LABEL_28:
    AMRLog(3, v30, v6, v7, v8, v9, v10, v11, (char)v31);
    goto LABEL_24;
  }
  if (!ValueForKeyPathInDict)
  {
    CFDictionaryRef v27 = v26;
    AMRLog(6, @"%s: Found MacOSVariant - setting as recovery variant: %@", v6, v7, v8, v9, v10, v11, (char)"AMRAuthInstallCopyRecoveryOSVariant");
    CFDictionaryRef ValueForKeyPathInDict = v27;
  }
  if (!AMAuthInstallSetMacOSVariantIsPresent((uint64_t)a1, 1)) {
    goto LABEL_22;
  }
  CFStringRef v28 = @"AMAuthInstallSetMacOSVariantIsPresent failed to set Mac OS variantlibusbrestore/AMRAuthInstall.c is present.";
LABEL_32:
  AMRLog(3, v28, v6, v7, v8, v9, v10, v11, (char)v31);
  CFDictionaryRef ValueForKeyPathInDict = 0;
LABEL_24:
  if (cf) {
    CFRelease(cf);
  }
  return ValueForKeyPathInDict;
}

uint64_t AMRAuthInstallCopyPersonalizedBundleSupportRecoveryOSURL(const __CFDictionary *a1, CFBooleanRef BOOLean, CFURLRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    CFStringRef v21 = @"Can't copy URL to personalized bundle from NULL dictionary";
LABEL_11:
    AMRLog(3, v21, (uint64_t)a3, a4, a5, a6, a7, a8, v22);
    return 1;
  }
  if (CFBooleanGetValue(BOOLean)) {
    CFStringRef v10 = @"PersonalizedRecoveryOSBundlePath";
  }
  else {
    CFStringRef v10 = @"PersonalizedRestoreBundlePath";
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, v10);
  if (!Value)
  {
    CFStringRef v21 = @"No personalized bundle URL in options";
    goto LABEL_11;
  }
  CFURLRef URLFromString = AMAuthInstallSupportCreateURLFromString(kCFAllocatorDefault, Value, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (URLFromString)
  {
    CFURLRef v19 = URLFromString;
    if (a3)
    {
      uint64_t result = 0;
      *a3 = v19;
    }
    else
    {
      CFRelease(URLFromString);
      return 0;
    }
  }
  else
  {
    AMRLog(3, @"Failed to allocate bundle URL", v13, v14, v15, v16, v17, v18, v22);
    return 31;
  }
  return result;
}

uint64_t AMRAuthInstallCopyURLForKeyInBundle(void *a1, const __CFDictionary *a2, const __CFString *a3, CFBooleanRef BOOLean, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0;
  if (!a1)
  {
    AMRLog(3, @"Can't copy URL without amai ref", (uint64_t)a3, (uint64_t)BOOLean, (uint64_t)a5, a6, a7, a8, v24);
    return 1;
  }
  if (a2)
  {
    if (a3)
    {
      if (a5)
      {
        uint64_t v13 = AMRAuthInstallCopyPersonalizedBundleSupportRecoveryOSURL(a2, BOOLean, (CFURLRef *)&cf, (uint64_t)BOOLean, (uint64_t)a5, a6, a7, a8);
        if (!v13)
        {
          if (CFBooleanGetValue(BOOLean)) {
            CFStringRef v14 = (const __CFString *)AMRAuthInstallCopyRecoveryOSVariant(a1, a2);
          }
          else {
            CFStringRef v14 = AMRAuthInstallCopyVariant(a1, a2);
          }
          CFStringRef v23 = v14;
          if (v14)
          {
            if (AMAuthInstallBundleCopyURLForKey((CFDictionaryRef **)a1, a3, v14, (const __CFURL *)cf, a5))uint64_t v13 = 3002; {
            else
            }
              uint64_t v13 = 0;
            CFRelease(v23);
          }
          else
          {
            AMRLog(3, @"Can't copy URL for bundle resource without variant", v15, v16, v17, v18, v19, v20, v24);
            uint64_t v13 = 3002;
          }
        }
        goto LABEL_13;
      }
      CFStringRef v21 = @"Can't copy URL without out ref";
    }
    else
    {
      CFStringRef v21 = @"Can't copy URL with NULL key";
    }
  }
  else
  {
    CFStringRef v21 = @"Can't copy URL with NULL options";
  }
  AMRLog(3, v21, (uint64_t)a3, (uint64_t)BOOLean, (uint64_t)a5, a6, a7, a8, v24);
  uint64_t v13 = 1;
LABEL_13:
  if (cf) {
    CFRelease(cf);
  }
  return v13;
}

uint64_t AMRAuthInstallCopyFileSystemPathForKey(void *a1, const __CFDictionary *a2, const __CFString *a3, CFStringRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return AMRAuthInstallCopyFileSystemPathForKeyInBundle(a1, a2, a3, kCFBooleanFalse, a4, a6, a7, a8);
}

uint64_t AMRAuthInstallCopyFileSystemPathForKeyInBundle(void *a1, const __CFDictionary *a2, const __CFString *a3, const __CFBoolean *a4, CFStringRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFURLRef anURL = 0;
  if (!a5) {
    return 1;
  }
  char v9 = (char)a3;
  uint64_t v10 = AMRAuthInstallCopyURLForKeyInBundle(a1, a2, a3, a4, &anURL, a6, a7, a8);
  if (v10)
  {
    uint64_t v17 = v10;
    AMRLog(3, @"Failed to get URL for key: %@", v11, v12, v13, v14, v15, v16, v9);
  }
  else
  {
    CFStringRef v18 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
    if (v18)
    {
      uint64_t v17 = 0;
      *a5 = v18;
    }
    else
    {
      AMRLog(3, @"Failed to convert URL to filesytem path", v19, v20, v21, v22, v23, v24, v26);
      uint64_t v17 = 31;
    }
  }
  if (anURL) {
    CFRelease(anURL);
  }
  return v17;
}

uint64_t AMRAuthInstallSetBundleOverridesFromOptions(void *a1, const __CFDictionary *a2)
{
  int v4 = AMRestoreOptionsApplyMacOSChangesIfNeeded(a2);
  if (v4)
  {
    char v78 = v4;
    CFStringRef v11 = @"failed to apply MacOS restoreOption changes with status %d";
LABEL_3:
    uint64_t v12 = 3;
    AMRLog(3, v11, v5, v6, v7, v8, v9, v10, v78);
    goto LABEL_31;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"BundleOverrides");
  if (Value)
  {
    CFDictionaryRef v21 = Value;
    CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)_AMRAuthInstallApplyBundleOverride, a1);
    uint64_t v22 = CFDictionaryGetValue(v21, @"RecoveryOSBundlePath");
    if (v22) {
      CFDictionarySetValue(a2, @"RecoveryOSSourceBundlePath", v22);
    }
    uint64_t v12 = 0;
    goto LABEL_31;
  }
  if (!AMRestoreOptionsAreLegacy(a2, v14, v15, v16, v17, v18, v19, v20))
  {
    CFStringRef v23 = 0;
    CFURLRef v55 = 0;
    CFURLRef v48 = 0;
LABEL_24:
    uint64_t v12 = 0;
    goto LABEL_25;
  }
  CFStringRef v23 = (const __CFString *)CFDictionaryGetValue(a2, @"BootImageFile");
  if (v23)
  {
    CFAllocatorRef v24 = CFGetAllocator(a1);
    CFURLRef URLFromString = AMAuthInstallSupportCreateURLFromString(v24, v23, v25, v26, v27, v28, v29, v30);
    if (!URLFromString)
    {
      char v78 = 0;
      CFStringRef v11 = @"failed to convert customRamDiskFileURL %@";
      goto LABEL_3;
    }
    CFStringRef v23 = (const __CFString *)URLFromString;
    uint64_t v32 = AMAuthInstallBundleOverrideEntry((uint64_t)a1, @"RestoreRamDisk", URLFromString, v6, v7, v8, v9, v10);
    if (v32)
    {
      uint64_t v12 = v32;
      CFURLRef v48 = 0;
      CFURLRef v55 = 0;
      goto LABEL_26;
    }
  }
  CFStringRef v33 = (const __CFString *)CFDictionaryGetValue(a2, @"RestoreKernelCacheFile");
  if (v33)
  {
    CFStringRef v34 = v33;
    CFAllocatorRef v35 = CFGetAllocator(a1);
    CFURLRef v48 = AMAuthInstallSupportCreateURLFromString(v35, v34, v36, v37, v38, v39, v40, v41);
    if (!v48)
    {
      uint64_t v12 = 3;
      AMRLog(3, @"failed to convert customRestoreKernelCacheFileURL %@", v42, v43, v44, v45, v46, v47, 0);
      goto LABEL_35;
    }
    CFDictionarySetValue(a2, @"RestoreKernelCacheFile", v34);
    uint64_t v54 = AMAuthInstallBundleOverrideEntry((uint64_t)a1, @"RestoreKernelCache", v48, v49, v50, v51, v52, v53);
    if (v54)
    {
      uint64_t v12 = v54;
LABEL_35:
      CFURLRef v55 = 0;
      goto LABEL_25;
    }
  }
  else
  {
    CFURLRef v48 = 0;
  }
  CFStringRef v56 = (const __CFString *)CFDictionaryGetValue(a2, @"KernelCacheFile");
  if (!v56)
  {
    CFURLRef v55 = 0;
    goto LABEL_24;
  }
  CFStringRef v57 = v56;
  CFAllocatorRef v58 = CFGetAllocator(a1);
  CFURLRef v55 = AMAuthInstallSupportCreateURLFromString(v58, v57, v59, v60, v61, v62, v63, v64);
  if (v55)
  {
    CFDictionarySetValue(a2, @"KernelCacheFile", v57);
    uint64_t v76 = AMAuthInstallBundleOverrideEntry((uint64_t)a1, @"KernelCache", v55, v71, v72, v73, v74, v75);
    if (v76)
    {
      uint64_t v12 = v76;
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  uint64_t v12 = 3;
  AMRLog(3, @"failed to convert customKernelCacheFileURL %@", v65, v66, v67, v68, v69, v70, 0);
LABEL_25:
  if (v23) {
LABEL_26:
  }
    CFRelease(v23);
  if (v55) {
    CFRelease(v55);
  }
  if (v48) {
    CFRelease(v48);
  }
LABEL_31:
  return AMAuthInstallToRestoreError(v12);
}

uint64_t sub_10004C12C(__CFString *a1, const __CFDictionary *a2, int a3)
{
  CFTypeRef v340 = 0;
  CFTypeRef v341 = 0;
  CFTypeRef v339 = 0;
  char v338 = 0;
  CFTypeRef v337 = 0;
  pthread_once(&stru_1000B8A80, (void (*)(void))sub_10004EB64);
  if (!a1)
  {
    AMRLog(6, @"%s: amai is NULL", v6, v7, v8, v9, v10, v11, (char)"_AMRAuthInstallPersonalizeBundleInternal");
    CFStringRef PathFromURL = 0;
    CFURLRef cf = 0;
    CFURLRef v31 = 0;
    CFURLRef v39 = 0;
    CFStringRef Value = 0;
LABEL_138:
    uint64_t v38 = 0;
    CFURLRef v37 = 0;
    CFStringRef v36 = 0;
    uint64_t v35 = 1;
    goto LABEL_19;
  }
  if (!a2)
  {
    CFStringRef PathFromURL = 0;
    CFURLRef cf = 0;
    CFURLRef v31 = 0;
    CFURLRef v39 = 0;
    CFStringRef Value = 0;
    a1 = 0;
    goto LABEL_138;
  }
  if (!AMAuthInstallApPersonalizationEnabled((uint64_t)a1)
    && !AMAuthInstallBasebandPersonalizationEnabled((uint64_t)a1))
  {
    AMRLog(6, @"%s: AP and Baseband personalization disabled.", v12, v13, v14, v15, v16, v17, (char)"_AMRAuthInstallPersonalizeBundleInternal");
    CFStringRef PathFromURL = 0;
    CFURLRef cf = 0;
    CFURLRef v31 = 0;
    CFURLRef v39 = 0;
    CFStringRef Value = 0;
    a1 = 0;
    uint64_t v38 = 0;
    CFURLRef v37 = 0;
    CFStringRef v36 = 0;
    uint64_t v35 = 0;
    goto LABEL_19;
  }
  CFStringRef v335 = AMRAuthInstallCopyVariant(a1, a2);
  AMRLog(6, @"requested variant: %@", v18, v19, v20, v21, v22, v23, (char)v335);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"SourceRestoreBundlePath");
  if (!Value)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"RestoreBundlePath");
    if (!Value)
    {
      AMRLog(3, @"no restore bundle specified", v25, v26, v27, v28, v29, v30, v327);
      CFStringRef PathFromURL = 0;
      CFURLRef cf = 0;
      CFURLRef v31 = 0;
      CFURLRef v39 = 0;
      uint64_t v38 = 0;
      CFURLRef v37 = 0;
      CFStringRef v36 = 0;
      uint64_t v35 = 1;
      goto LABEL_18;
    }
  }
  CFURLRef v31 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, Value, kCFURLPOSIXPathStyle, 1u);
  if (!v31)
  {
    CFStringRef PathFromURL = 0;
    CFURLRef cf = 0;
    goto LABEL_13;
  }
  CFStringRef v32 = (const __CFString *)CFDictionaryGetValue(a2, @"PersonalizedRestoreBundlePath");
  CFURLRef cf = v31;
  if (!v32)
  {
    if (AMAuthInstallSupportCopyURLToNewTempDirectory(kCFAllocatorDefault, "PersonalizedRestoreBundle.XXXXXXXXXX", &v341))
    {
      AMRLog(3, @"failed to create a personalized bundle directory", v40, v41, v42, v43, v44, v45, v327);
      CFStringRef PathFromURL = 0;
      CFURLRef v31 = 0;
      CFURLRef v39 = 0;
      CFStringRef Value = 0;
      uint64_t v38 = 0;
      CFURLRef v37 = 0;
      CFStringRef v36 = 0;
      uint64_t v35 = 11;
      goto LABEL_18;
    }
    CFAllocatorRef v67 = CFGetAllocator(a1);
    CFStringRef PathFromURL = AMRestoreCreatePathFromURL(v67, (const __CFURL *)v341);
    if (PathFromURL)
    {
      CFDictionarySetValue(a2, @"PersonalizedRestoreBundlePath", PathFromURL);
      goto LABEL_10;
    }
    CFURLRef v31 = 0;
LABEL_13:
    CFURLRef v39 = 0;
    CFStringRef Value = 0;
    uint64_t v38 = 0;
    CFURLRef v37 = 0;
    CFStringRef v36 = 0;
    uint64_t v35 = 18;
LABEL_18:
    a1 = (__CFString *)v335;
    goto LABEL_19;
  }
  CFStringRef PathFromURL = v32;
  CFRetain(v32);
  CFTypeRef v341 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, PathFromURL, kCFURLPOSIXPathStyle, 1u);
  if (!v341)
  {
    CFStringRef v36 = 0;
    CFURLRef v37 = 0;
    uint64_t v38 = 0;
    CFStringRef Value = 0;
    CFURLRef v39 = 0;
    CFURLRef v31 = 0;
    uint64_t v35 = 18;
    goto LABEL_47;
  }
LABEL_10:
  CFDictionarySetValue(a2, @"SourceRestoreBundlePath", Value);
  uint64_t v34 = AMRAuthInstallConfigureUsingOptions(a1, a2, a2, &v338);
  if (v34)
  {
    uint64_t v35 = v34;
    CFStringRef v36 = 0;
    CFURLRef v37 = 0;
    uint64_t v38 = 0;
    CFStringRef Value = 0;
    CFURLRef v39 = 0;
    CFURLRef v31 = 0;
LABEL_47:
    a1 = (__CFString *)v335;
LABEL_48:
    AMRAuthInstallDeletePersonalizedBundle(PathFromURL, a2);
    goto LABEL_49;
  }
  CFStringRef v48 = (const __CFString *)CFDictionaryGetValue(a2, @"RequestedEntitlements");
  if (v48)
  {
    CFStringRef v49 = v48;
    bzero(buffer, 0x400uLL);
    CFAllocatorRef v50 = CFGetAllocator(a1);
    CFURLRef url = CFURLCreateWithString(v50, v49, 0);
    if (url)
    {
      if (CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024))
      {
        CFAllocatorRef v51 = CFGetAllocator(a1);
        CFStringRef v52 = CFStringCreateWithFileSystemRepresentation(v51, (const char *)buffer);
        if (v52)
        {
          CFStringRef v59 = v52;
          uint64_t v60 = _AMRestoreCreateCFDictionaryWithContentsOfFile(v52, &v340, v53, v54, v55, v56, v57, v58);
          if (v60)
          {
            uint64_t v35 = v60;
            AMRLog(3, @"Could not create entitlements dictionary from %@", v61, v62, v63, v64, v65, v66, (char)v59);
            CFStringRef v36 = 0;
            CFURLRef v37 = 0;
            uint64_t v38 = 0;
            CFURLRef v39 = 0;
            CFURLRef v31 = 0;
            goto LABEL_121;
          }
          CFRelease(v59);
        }
      }
    }
    CFDictionaryApplyFunction((CFDictionaryRef)v340, (CFDictionaryApplierFunction)AMAuthInstallApplyRequestEntries, a1);
  }
  else
  {
    CFURLRef url = 0;
  }
  if (AMSupportCFDictionaryGetBoolean())
  {
LABEL_62:
    AMAuthInstallSetApRequestEntry(a1, @"Ap,EngineeringUseOnlyUnit", kCFBooleanTrue);
  }
  else
  {
    uint64_t v93 = 1;
    while (v93 != 10)
    {
      ++v93;
      if (AMSupportCFDictionaryGetBoolean())
      {
        if ((unint64_t)(v93 - 2) <= 8) {
          goto LABEL_62;
        }
        break;
      }
    }
  }
  CFBooleanRef v68 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"RequestDisablePlatformOnlyCode");
  if (v68)
  {
    CFBooleanRef v69 = v68;
    CFTypeID v70 = CFGetTypeID(v68);
    if (v70 == CFBooleanGetTypeID() && CFBooleanGetValue(v69) == 1) {
      AMAuthInstallSetApRequestEntry(a1, @"Ap,DisablePlatformOnlyCode", kCFBooleanTrue);
    }
  }
  CFBooleanRef v71 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"RequestFactoryPrereleaseGlobalTrust");
  if (v71)
  {
    CFBooleanRef v72 = v71;
    CFTypeID v73 = CFGetTypeID(v71);
    if (v73 == CFBooleanGetTypeID() && CFBooleanGetValue(v72) == 1) {
      AMAuthInstallSetApRequestEntry(a1, @"Ap,FactoryPrereleaseGlobalTrust", kCFBooleanTrue);
    }
  }
  CFBooleanRef v74 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"RequestInternalUseOnlyUnit");
  if (v74)
  {
    CFBooleanRef v75 = v74;
    CFTypeID v76 = CFGetTypeID(v74);
    if (v76 == CFBooleanGetTypeID() && CFBooleanGetValue(v75) == 1) {
      AMAuthInstallSetApRequestEntry(a1, @"Ap,InternalUseOnlyUnit", kCFBooleanTrue);
    }
  }
  CFTypeID v77 = CFDictionaryGetValue(a2, @"RequestRestoreSecurityOverrides0");
  if (v77)
  {
    char v78 = v77;
    CFTypeID v79 = CFGetTypeID(v77);
    if (v79 == CFNumberGetTypeID()) {
      AMAuthInstallSetApRequestEntry(a1, @"Ap,RestoreSecurityOverrides0", v78);
    }
  }
  CFBooleanRef v80 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"BasebandEnableCalibration");
  if (v80)
  {
    CFBooleanRef v81 = v80;
    CFTypeID v82 = CFGetTypeID(v80);
    if (v82 == CFBooleanGetTypeID() && CFBooleanGetValue(v81) == 1)
    {
      uint64_t v83 = AMAuthInstallSetBbRequestEntry(a1, @"BbCalibrationEnable", kCFBooleanTrue);
      if (v83)
      {
        uint64_t v84 = v83;
        CFURLRef v31 = 0;
LABEL_87:
        CFURLRef v39 = 0;
        uint64_t v38 = 0;
LABEL_88:
        CFURLRef v37 = 0;
        CFStringRef v36 = 0;
LABEL_89:
        CFStringRef Value = (const __CFString *)url;
        a1 = (__CFString *)v335;
        uint64_t v35 = AMAuthInstallToRestoreError(v84);
        goto LABEL_90;
      }
    }
  }
  CFStringRef v85 = (const __CFString *)CFDictionaryGetValue(a2, @"FusingServerURL");
  if (v85)
  {
    CFURLRef v37 = CFURLCreateWithString(kCFAllocatorDefault, v85, 0);
    if (!v37)
    {
      CFStringRef v36 = 0;
      uint64_t v38 = 0;
      CFURLRef v39 = 0;
      CFURLRef v31 = 0;
LABEL_120:
      uint64_t v35 = 18;
      goto LABEL_121;
    }
    uint64_t v92 = AMAuthInstallSetFusingServerURL((uint64_t)a1, v37, v86, v87, v88, v89, v90, v91);
    if (v92)
    {
LABEL_86:
      uint64_t v84 = v92;
      CFURLRef v31 = v37;
      goto LABEL_87;
    }
  }
  else
  {
    CFURLRef v37 = 0;
  }
  CFBooleanRef v94 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"BasebandEnableActivationBypass");
  if (v94)
  {
    CFBooleanRef v101 = v94;
    CFTypeID v102 = CFGetTypeID(v94);
    if (v102 == CFBooleanGetTypeID() && CFBooleanGetValue(v101) == 1)
    {
      uint64_t v92 = AMAuthInstallSetBbRequestEntry(a1, @"BbActivationBypassEnable", kCFBooleanTrue);
      if (v92) {
        goto LABEL_86;
      }
    }
  }
  if (AMRAuthInstallAddUUID(a1, a2, v95, v96, v97, v98, v99, v100)) {
    AMRLog(3, @"failed to add uuid, device will not print uuid", v103, v104, v105, v106, v107, v108, v327);
  }
  AMAuthInstallSetDebugFlags((uint64_t)a1, 2);
  CFStringRef v109 = (const __CFString *)CFDictionaryGetValue(a2, @"BasebandProvisioningKeyID");
  if (v109)
  {
    *(void *)buffer = 0;
    uint64_t v35 = 31;
    if (AMAuthInstallSupportCopyDataFromHexString((int)kCFAllocatorDefault, v109, (uint64_t *)buffer)
      || !*(void *)buffer)
    {
      goto LABEL_117;
    }
    int v110 = AMAuthInstallBasebandSetKeyHash((uint64_t)a1, @"BbProvisioningManifestKeyHash", *(CFDataRef *)buffer);
    CFRelease(*(CFTypeRef *)buffer);
    if (v110) {
      goto LABEL_116;
    }
  }
  CFStringRef v111 = (const __CFString *)CFDictionaryGetValue(a2, @"BasebandActivationKeyID");
  if (v111)
  {
    *(void *)buffer = 0;
    uint64_t v35 = 31;
    if (AMAuthInstallSupportCopyDataFromHexString((int)kCFAllocatorDefault, v111, (uint64_t *)buffer)
      || !*(void *)buffer)
    {
      goto LABEL_117;
    }
    int v112 = AMAuthInstallBasebandSetKeyHash((uint64_t)a1, @"BbActivationManifestKeyHash", *(CFDataRef *)buffer);
    CFRelease(*(CFTypeRef *)buffer);
    if (v112) {
      goto LABEL_116;
    }
  }
  CFStringRef v113 = (const __CFString *)CFDictionaryGetValue(a2, @"BasebandCalibrationKeyID");
  if (v113)
  {
    *(void *)buffer = 0;
    uint64_t v35 = 31;
    if (AMAuthInstallSupportCopyDataFromHexString((int)kCFAllocatorDefault, v113, (uint64_t *)buffer)
      || !*(void *)buffer)
    {
      goto LABEL_117;
    }
    int v114 = AMAuthInstallBasebandSetKeyHash((uint64_t)a1, @"BbCalibrationManifestKeyHash", *(CFDataRef *)buffer);
    CFRelease(*(CFTypeRef *)buffer);
    if (v114) {
      goto LABEL_116;
    }
  }
  CFURLRef v115 = CFDictionaryGetValue(a2, @"UserLocale");
  uint64_t v92 = AMAuthInstallSetLocale((uint64_t)a1, v115);
  if (v92) {
    goto LABEL_86;
  }
  CFStringRef v116 = (const __CFString *)CFDictionaryGetValue(a2, @"BasebandFactoryActivationKeyID");
  if (v116)
  {
    *(void *)buffer = 0;
    uint64_t v35 = 31;
    if (AMAuthInstallSupportCopyDataFromHexString((int)kCFAllocatorDefault, v116, (uint64_t *)buffer)
      || !*(void *)buffer)
    {
      goto LABEL_117;
    }
    int v117 = AMAuthInstallBasebandSetKeyHash((uint64_t)a1, @"BbFactoryActivationManifestKeyHash", *(CFDataRef *)buffer);
    CFRelease(*(CFTypeRef *)buffer);
    if (v117)
    {
LABEL_116:
      uint64_t v35 = 1;
LABEL_117:
      CFURLRef v31 = v37;
      CFStringRef v36 = 0;
      CFURLRef v37 = 0;
      uint64_t v38 = 0;
      CFURLRef v39 = 0;
LABEL_121:
      CFStringRef Value = (const __CFString *)url;
      a1 = (__CFString *)v335;
      goto LABEL_48;
    }
  }
  CFBooleanRef v118 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"BasebandJtagEnable");
  if (v118)
  {
    CFBooleanRef v119 = v118;
    CFTypeID v120 = CFGetTypeID(v118);
    if (v120 == CFBooleanGetTypeID() && CFBooleanGetValue(v119) == 1)
    {
      uint64_t v92 = AMAuthInstallSetBbRequestEntry(a1, @"BbJtagEnable", kCFBooleanTrue);
      if (v92) {
        goto LABEL_86;
      }
    }
  }
  if (sub_10004AF68(a2, 0, @"BasebandEnableFactoryDebug"))
  {
    uint64_t v92 = AMAuthInstallSetBbRequestEntry(a1, @"BbFactoryDebugEnable", kCFBooleanTrue);
    if (v92) {
      goto LABEL_86;
    }
  }
  uint64_t v127 = CFDictionaryGetValue(a2, @"CertifySEP");
  if (v127)
  {
    CFTypeID TypeID = CFBooleanGetTypeID();
    LODWORD(v127) = TypeID == CFGetTypeID(v127) && CFBooleanGetValue((CFBooleanRef)v127) == 1;
  }
  if (sub_10004D7E0(a1, a2, v121, v122, v123, v124, v125, v126) || v127)
  {
    CFBooleanRef v129 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"FDRSkipSealing");
    if (v129)
    {
      CFBooleanRef v130 = v129;
      CFTypeID v131 = CFGetTypeID(v129);
      if (v131 == CFBooleanGetTypeID() && CFBooleanGetValue(v130) == 1)
      {
        uint64_t v92 = AMAuthInstallSetFDRRequestEntry(a1, @"FDRAllowUnsealed", kCFBooleanTrue);
        if (v92) {
          goto LABEL_86;
        }
      }
    }
    CFBooleanRef v132 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"FDRAllowUnsealedData");
    if (v132)
    {
      CFBooleanRef v133 = v132;
      CFTypeID v134 = CFGetTypeID(v132);
      if (v134 == CFBooleanGetTypeID() && CFBooleanGetValue(v133) == 1)
      {
        uint64_t v92 = AMAuthInstallSetFDRRequestEntry(a1, @"FDRAllowUnsealed", kCFBooleanTrue);
        if (v92) {
          goto LABEL_86;
        }
      }
    }
    CFBooleanRef v135 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"FDRAllowIncompleteData");
    if (v135)
    {
      CFBooleanRef v136 = v135;
      CFTypeID v137 = CFGetTypeID(v135);
      if (v137 == CFBooleanGetTypeID() && CFBooleanGetValue(v136) == 1)
      {
        uint64_t v92 = AMAuthInstallSetFDRRequestEntry(a1, @"FDRAllowIncomplete", kCFBooleanTrue);
        if (v92) {
          goto LABEL_86;
        }
      }
    }
    CFTypeID v138 = CFStringGetTypeID();
    sub_10004B33C(a2, @"FDRCAURL", v138, v139, v140, v141, v142, v143);
    CFTypeID v144 = CFStringGetTypeID();
    sub_10004B33C(a2, @"FDRDataStoreURL", v144, v145, v146, v147, v148, v149);
    CFTypeID v150 = CFStringGetTypeID();
    sub_10004B33C(a2, @"FDRSealingURL", v150, v151, v152, v153, v154, v155);
    CFTypeID v156 = CFStringGetTypeID();
    sub_10004B33C(a2, @"FDRTrustObjectURL", v156, v157, v158, v159, v160, v161);
    CFTypeID v162 = CFStringGetTypeID();
    sub_10004B33C(a2, @"FDRTrustObjectFile", v162, v163, v164, v165, v166, v167);
    CFTypeID v168 = CFBooleanGetTypeID();
    sub_10004B33C(a2, @"FDRSkipSealing", v168, v169, v170, v171, v172, v173);
    CFTypeID v174 = CFBooleanGetTypeID();
    sub_10004B33C(a2, @"FDRForceSealing", v174, v175, v176, v177, v178, v179);
    CFTypeID v180 = CFBooleanGetTypeID();
    sub_10004B33C(a2, @"FDRAllowUnsealedData", v180, v181, v182, v183, v184, v185);
    CFTypeID v186 = CFBooleanGetTypeID();
    sub_10004B33C(a2, @"FDRAllowIncompleteData", v186, v187, v188, v189, v190, v191);
    CFTypeID v192 = CFBooleanGetTypeID();
    sub_10004B33C(a2, @"FDRDisableSSLValidation", v192, v193, v194, v195, v196, v197);
    CFTypeID v198 = CFBooleanGetTypeID();
    sub_10004B33C(a2, @"FDRSkipDataPreservation", v198, v199, v200, v201, v202, v203);
  }
  CFDictionaryRef v204 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"ApRequestEntries");
  if (v204) {
    CFDictionaryApplyFunction(v204, (CFDictionaryApplierFunction)sub_10004D8FC, a1);
  }
  CFDictionaryRef v205 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"BbRequestEntries");
  if (v205) {
    CFDictionaryApplyFunction(v205, (CFDictionaryApplierFunction)sub_10004D910, a1);
  }
  CFDictionaryRef v206 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"ObjectRequestEntries");
  CFURLRef v31 = v37;
  if (v206) {
    CFDictionaryRef v207 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"RestoreSEP");
  }
  else {
    CFDictionaryRef v207 = 0;
  }
  CFBooleanRef v208 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"FDREnableShenanigansDeprecated");
  if (!v208 || (CFBooleanRef v209 = v208, v210 = CFGetTypeID(v208), v210 != CFBooleanGetTypeID()) || CFBooleanGetValue(v209) == 1)
  {
    if (v338 == 1)
    {
      if (v339)
      {
        CFRelease(v339);
        CFTypeRef v339 = 0;
      }
      if (!AMAuthInstallApCopyParameters((const void **)&a1->isa, &v339))
      {
        CFAllocatorRef v278 = CFDictionaryGetValue((CFDictionaryRef)v339, @"SepNonce");
        CFBooleanRef v279 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v339, @"ApProductionMode");
        if (v278)
        {
          CFBooleanRef v280 = v279;
          if (v279)
          {
            CFTypeID v281 = CFGetTypeID(v279);
            if (v281 == CFBooleanGetTypeID() && !CFBooleanGetValue(v280))
            {
              AMRLog(5, @"Requesting EnableSEPIdentityCreation entitlement for Shenanigans for development SoC with SEP", v282, v283, v284, v285, v286, v287, v327);
              if (v207) {
                CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v207);
              }
              else {
                CFDictionaryRef MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              }
              uint64_t v38 = MutableCopy;
              if (MutableCopy)
              {
                CFDictionaryAddValue(MutableCopy, @"EnableSEPIdentityCreation", kCFBooleanTrue);
                if (v206) {
                  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v206);
                }
                else {
                  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                }
                CFDictionaryRef v326 = Mutable;
                if (Mutable)
                {
                  CFDictionaryAddValue(Mutable, @"RestoreSEP", v38);
                  CFDictionaryApplyFunction(v326, (CFDictionaryApplierFunction)sub_10004D924, a1);
                  CFRelease(v326);
                  goto LABEL_172;
                }
                CFStringRef v325 = @"failed to create requestEntriesMutable";
              }
              else
              {
                CFStringRef v325 = @"failed to create rsepEntitlementsMutable";
              }
              AMRLog(3, v325, v289, v290, v291, v292, v293, v294, v327);
LABEL_251:
              CFStringRef v36 = 0;
              CFURLRef v37 = 0;
              CFURLRef v39 = 0;
              goto LABEL_120;
            }
          }
        }
      }
    }
  }
  if (v206) {
    CFDictionaryApplyFunction(v206, (CFDictionaryApplierFunction)sub_10004D924, a1);
  }
  uint64_t v38 = 0;
LABEL_172:
  CFBooleanRef ValueForKeyPathInDict = (const __CFBoolean *)AMSupportGetValueForKeyPathInDict();
  CFBooleanRef v212 = (const __CFBoolean *)AMSupportGetValueForKeyPathInDict();
  if (v212 == kCFBooleanTrue && ValueForKeyPathInDict == kCFBooleanTrue)
  {
    AMRLog(3, @"ERROR: Cannot set both Enable/DisableSSMAChecks in BoraOptions", v213, v214, v215, v216, v217, v218, v327);
    CFStringRef v36 = 0;
    CFURLRef v37 = 0;
    CFURLRef v39 = 0;
    goto LABEL_199;
  }
  if (ValueForKeyPathInDict == kCFBooleanTrue)
  {
    AMRLog(6, @"Adding SEP:DisableStrongSSMAChecks entitlement based on BoraOptions.", v213, v214, v215, v216, v217, v218, v327);
    goto LABEL_187;
  }
  if (v212 != kCFBooleanTrue)
  {
    *(void *)buffer = 0;
    AMRAuthInstallCopyBuildIdentity(a1, a2, v335, (CFTypeRef *)buffer);
    if (*(void *)buffer)
    {
      CFStringRef v219 = (const __CFString *)AMSupportGetValueForKeyPathInDict();
      if (!v219 || !CFStringHasSuffix(v219, @"dev")) {
        goto LABEL_181;
      }
      CFBooleanRef v226 = sub_10004D998((const __CFBoolean *)a1, a2, v220, v221, v222, v223, v224, v225);
      if (!v226)
      {
        CFStringRef v36 = 0;
        CFURLRef v37 = 0;
        CFURLRef v39 = 0;
        uint64_t v35 = 0xFFFFFFFFLL;
        goto LABEL_121;
      }
      if (v226 == kCFBooleanTrue)
      {
        AMRLog(6, @"Automatically adding SEP:DisableStrongSSMAChecks entitlement for a dev board.", v227, v228, v229, v230, v231, v232, v327);
        char v233 = 0;
      }
      else
      {
LABEL_181:
        char v233 = 1;
      }
      if (*(void *)buffer) {
        CFRelease(*(CFTypeRef *)buffer);
      }
      if ((v233 & 1) == 0)
      {
LABEL_187:
        uint64_t v234 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v234)
        {
          uint64_t v235 = v234;
          CFDictionaryAddValue(v234, @"DisableStrongSSMAChecks", kCFBooleanTrue);
          AMAuthInstallSetObjectRequestEntry(a1, @"SEP", v235);
          AMSupportSafeRelease();
          goto LABEL_189;
        }
        goto LABEL_251;
      }
    }
  }
LABEL_189:
  CFStringRef v236 = (const __CFString *)CFDictionaryGetValue(a2, @"BasebandFirmware");
  if (v236)
  {
    CFStringRef v242 = v236;
    AMRLogWithFilePath(5, (uint64_t)v236, @"custom baseband firmware specified", v237, v238, v239, v240, v241, v327);
    CFURLRef v39 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v242, kCFURLPOSIXPathStyle, 0);
    if (!v39)
    {
      CFStringRef v36 = 0;
      CFURLRef v37 = 0;
      uint64_t v35 = 31;
      goto LABEL_121;
    }
    uint64_t v248 = AMAuthInstallBundleOverrideEntry((uint64_t)a1, @"BasebandFirmware", v39, v243, v244, v245, v246, v247);
    if (v248)
    {
LABEL_192:
      uint64_t v84 = v248;
      goto LABEL_88;
    }
  }
  else
  {
    CFURLRef v39 = 0;
  }
  uint64_t v249 = CFDictionaryGetValue(a2, @"BasebandAntennaType");
  if (v249 && AMAuthInstallBasebandSetAntennaType((uint64_t)a1, v249)
    || (uint64_t v250 = CFDictionaryGetValue(a2, @"BasebandBehavior")) != 0
    && AMAuthInstallBasebandSetBehavior((uint64_t)a1, v250))
  {
    CFStringRef v36 = 0;
    CFURLRef v37 = 0;
LABEL_199:
    uint64_t v35 = 1;
    goto LABEL_121;
  }
  uint64_t v251 = AMRAuthInstallSetBundleOverridesFromOptions(a1, a2);
  if (!v251)
  {
    CFBooleanRef v252 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"RelaxedImageVerification");
    if (v252)
    {
      if (CFBooleanGetValue(v252) == 1)
      {
        uint64_t v248 = AMAuthInstallApEnableRelaxedImageVerification((uint64_t)a1, 1);
        if (v248) {
          goto LABEL_192;
        }
      }
    }
    CFAllocatorRef v253 = CFDictionaryGetValue(a2, @"AuthInstallDisableSymlinks");
    if (v253)
    {
      uint64_t v254 = v253;
      CFTypeID v255 = CFBooleanGetTypeID();
      if (v255 == CFGetTypeID(v254) && CFBooleanGetValue((CFBooleanRef)v254) == 1)
      {
        uint64_t v256 = AMAuthInstallBundleAllowLinks((uint64_t)a1, 0);
        if (v256)
        {
          uint64_t v84 = v256;
          AMRLog(3, @"AMAuthInstallBundleAllowLinks failed", v257, v258, v259, v260, v261, v262, v327);
          goto LABEL_88;
        }
      }
    }
    int v331 = a3;
    CFBooleanRef v263 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"InstallRecoveryOS");
    if (!v263 || CFBooleanGetValue(v263))
    {
      CFStringRef v332 = (const __CFString *)AMRAuthInstallCopyRecoveryOSVariant(a1, a2);
      if (v332)
      {
        CFAllocatorRef v270 = CFGetAllocator(a1);
        CFStringRef v36 = CFStringCreateWithFormat(v270, 0, @"%@/RecoveryOS");
        CFDictionarySetValue(a2, @"PersonalizedRecoveryOSBundlePath", v36);
        CFStringRef v271 = (const __CFString *)CFDictionaryGetValue(a2, @"RecoveryOSSourceBundlePath");
        if (!v271)
        {
          AMRLog(3, @"no recovery OS bundle specified", v272, v273, v274, v275, v276, v277, (char)PathFromURL);
          CFURLRef v37 = 0;
          uint64_t v35 = 8;
          goto LABEL_121;
        }
        CFURLRef v37 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v271, kCFURLPOSIXPathStyle, 1u);
        if (!v37) {
          goto LABEL_120;
        }
        goto LABEL_223;
      }
      AMRLog(4, @"Couldn't find recovery OS variant , continue without recovery OS install", v264, v265, v266, v267, v268, v269, v327);
      CFDictionarySetValue(a2, @"InstallRecoveryOS", kCFBooleanFalse);
    }
    CFStringRef v332 = 0;
    CFURLRef v37 = 0;
    CFStringRef v36 = 0;
LABEL_223:
    uint64_t v295 = sub_10004DBA4(a1, cf, v335, a2);
    if (v295)
    {
      uint64_t v84 = v295;
      goto LABEL_89;
    }
    AMRLog(7, @"personalizing: %@", v296, v297, v298, v299, v300, v301, (char)a1);
    uint64_t v84 = AMAuthInstallBundlePersonalizeWithRecoveryOS(a1, cf, v341, v335, v37, v332);
    CFStringRef allocator = @"restore bundle";
    if (!v84 && v331)
    {
      uint64_t v84 = AMAuthInstallBundlePersonalizeRestoreLocalPolicy(a1, v341, 0, 0);
      CFStringRef allocator = @"local policy";
    }
    if (v84)
    {
      sub_10004DEB4((CFDictionaryRef *)a1, v84);
      AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v84);
      AMRLog(3, @"failed to personalize the %@: %@", v302, v303, v304, v305, v306, v307, (char)allocator);
      if (v84 == 4)
      {
        AMRLogWithFilePath(3, (uint64_t)Value, @"Source path", v308, v309, v310, v311, v312, v329);
        AMRLogWithFilePath(3, (uint64_t)PathFromURL, @"Destination path", v313, v314, v315, v316, v317, v330);
      }
      goto LABEL_89;
    }
    if (!AMAuthInstallBundleCopyPersonalizediBootEANFirmwareURLs(a1, v341, v335, &v337)
      && v337
      && !CFDictionaryGetCount((CFDictionaryRef)v337))
    {
      CFDictionarySetValue(a2, @"iBootEANNuke", kCFBooleanTrue);
      AMRLog(6, @"Setting kAMRestoreOptionsiBootEANNuke.", v318, v319, v320, v321, v322, v323, v328);
    }
    CFDictionarySetValue(a2, @"RestoreBundlePath", PathFromURL);
    if (v36) {
      CFDictionarySetValue(a2, @"RecoveryOSBundlePath", v36);
    }
    uint64_t v35 = 0;
    CFStringRef Value = (const __CFString *)url;
    a1 = (__CFString *)v335;
LABEL_19:
    BOOL v46 = PathFromURL != 0;
    if (!v36) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  uint64_t v35 = v251;
  CFURLRef v37 = 0;
  CFStringRef v36 = 0;
  CFStringRef Value = (const __CFString *)url;
  a1 = (__CFString *)v335;
LABEL_90:
  if (v35) {
    goto LABEL_48;
  }
LABEL_49:
  BOOL v46 = 1;
  if (v36) {
LABEL_20:
  }
    CFRelease(v36);
LABEL_21:
  if (v37) {
    CFRelease(v37);
  }
  if (v46) {
    CFRelease(PathFromURL);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v341) {
    CFRelease(v341);
  }
  if (v31) {
    CFRelease(v31);
  }
  if (v39) {
    CFRelease(v39);
  }
  if (v340) {
    CFRelease(v340);
  }
  if (v339) {
    CFRelease(v339);
  }
  if (Value) {
    CFRelease(Value);
  }
  if (a1) {
    CFRelease(a1);
  }
  if (v38) {
    CFRelease(v38);
  }
  if (v337) {
    CFRelease(v337);
  }
  return v35;
}

uint64_t AMRAuthInstallConfigureUsingOptions(void *a1, const __CFDictionary *a2, __CFDictionary *a3, char *a4)
{
  CFTypeRef cf = 0;
  uint64_t v8 = sub_10004B520(a2, a3, 0, &cf);
  if (!v8)
  {
    uint64_t v9 = AMAuthInstallSetSigningServerURL((uint64_t)a1, cf);
    if (!v9)
    {
      unsigned int v10 = sub_10004AF68(a2, a3, @"AuthInstallEnableSso");
      char v11 = v10;
      if (v10)
      {
        uint64_t v12 = AMRAuthInstallSsoEnable((uint64_t)a1);
        if (v12) {
          goto LABEL_22;
        }
      }
      if (!sub_10004AF68(a2, a3, @"AuthInstallEnableSsoStealthMode")
        || (uint64_t v13 = AMAuthInstallSsoSetStealthMode((uint64_t)a1, 1), !v13))
      {
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"AppleConnectUser");
        uint64_t v15 = CFDictionaryGetValue(a2, @"AppleConnectData");
        if (!v15)
        {
LABEL_13:
          if (!sub_10004AF68(a2, a3, @"SkipNoncesForAPSEP")
            || (uint64_t v13 = AMAuthInstallBundleRequestTicketWithoutNonce((uint64_t)a1, 1), !v13))
          {
            sub_10004AF68(a2, a3, @"ImageDecryptionKeysEnableSso");
            sub_10004AF68(a2, a3, @"FDREnableSso");
            uint64_t v16 = 0;
            goto LABEL_16;
          }
          goto LABEL_21;
        }
        if (Value)
        {
          uint64_t v13 = AMAuthInstallSsoSetAppleConnectInfo(a1, Value, v15);
          if (v13) {
            goto LABEL_21;
          }
          goto LABEL_12;
        }
        uint64_t v13 = AMAuthInstallSsoSetToken((uint64_t)a1, v15);
        if (!v13)
        {
LABEL_12:
          char v11 = 1;
          goto LABEL_13;
        }
      }
LABEL_21:
      uint64_t v12 = AMAuthInstallToRestoreError(v13);
LABEL_22:
      uint64_t v16 = v12;
      goto LABEL_16;
    }
    uint64_t v8 = AMAuthInstallToRestoreError(v9);
  }
  uint64_t v16 = v8;
  char v11 = 0;
LABEL_16:
  if (cf) {
    CFRelease(cf);
  }
  if (a4) {
    *a4 = v11;
  }
  return v16;
}

BOOL sub_10004D7E0(const void *a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v31 = 0;
  if (!a1 || !theDict)
  {
    CFStringRef v28 = @"bad parameter";
LABEL_13:
    AMRLog(3, v28, a3, a4, a5, a6, a7, a8, v30);
    return v31 != 0;
  }
  CFStringRef v10 = AMRAuthInstallCopyVariant(a1, theDict);
  if (!v10)
  {
    CFStringRef v28 = @"failed to copy variant";
    goto LABEL_13;
  }
  CFStringRef v11 = v10;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"SourceRestoreBundlePath");
  if (!Value)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"RestoreBundlePath");
    if (!Value)
    {
      AMRLog(3, @"failed to get restore bundle path", v13, v14, v15, v16, v17, v18, v30);
      uint64_t v27 = v11;
      goto LABEL_10;
    }
  }
  CFAllocatorRef v19 = CFGetAllocator(a1);
  CFURLRef v20 = CFURLCreateWithFileSystemPath(v19, Value, kCFURLPOSIXPathStyle, 1u);
  if (AMAuthInstallBundleFDRSupported((uint64_t)a1, v20, v11, &v31)) {
    AMRLog(4, @"failed to find key FDRSupport in variant", v21, v22, v23, v24, v25, v26, v30);
  }
  CFRelease(v11);
  if (v20)
  {
    uint64_t v27 = v20;
LABEL_10:
    CFRelease(v27);
  }
  return v31 != 0;
}

uint64_t sub_10004D8FC(const void *a1, const void *a2, const void *a3)
{
  return AMAuthInstallSetApRequestEntry(a3, a1, a2);
}

uint64_t sub_10004D910(const void *a1, const void *a2, const void *a3)
{
  return AMAuthInstallSetBbRequestEntry(a3, a1, a2);
}

CFTypeID sub_10004D924(const void *a1, CFTypeRef cf, const void *a3)
{
  CFTypeID v6 = CFGetTypeID(cf);
  CFTypeID result = CFDictionaryGetTypeID();
  if (v6 == result)
  {
    return AMAuthInstallSetObjectRequestEntry(a3, a1, cf);
  }
  return result;
}

CFBooleanRef sub_10004D998(const __CFBoolean *a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFBooleanRef v8 = a1;
  CFDictionaryRef theDicta = 0;
  CFURLRef v50 = 0;
  if (!a1)
  {
    AMRLog(3, @"amai is NULL", a3, a4, a5, a6, a7, a8, v48);
    goto LABEL_16;
  }
  if (!theDict)
  {
    CFStringRef v47 = @"options is NULL";
LABEL_23:
    AMRLog(3, v47, a3, a4, a5, a6, a7, a8, v48);
    CFBooleanRef v8 = 0;
    goto LABEL_16;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"RestoreBundlePath");
  if (!Value)
  {
    CFStringRef v47 = @"kAMRestoreOptionsRestoreBundlePath not found in options dictionary";
    goto LABEL_23;
  }
  CFStringRef v10 = Value;
  CFAllocatorRef v11 = CFGetAllocator(v8);
  if (!CFURLCreateWithFileSystemPath(v11, v10, kCFURLPOSIXPathStyle, 1u))
  {
    AMRLog(3, @"failed to create bundleURL from '%@'", v12, v13, v14, v15, v16, v17, (char)v10);
    goto LABEL_19;
  }
  CFGetAllocator(v8);
  int v18 = AMSupportCopyURLWithAppendedComponent();
  if (v18)
  {
    AMRLog(3, @"AMAuthInstallPlatformCopyURLWithAppendedComponent failed %d", v19, v20, v21, v22, v23, v24, v18);
    goto LABEL_19;
  }
  CFAllocatorRef v25 = CFGetAllocator(v8);
  int DictionaryFromFileURL = AMAuthInstallSupportCreateDictionaryFromFileURL(v25, (CFTypeRef *)&theDicta, v50);
  if (DictionaryFromFileURL)
  {
    AMRLog(3, @"AMAuthInstallSupportCreateDictionaryFromFileURL failed %d", v27, v28, v29, v30, v31, v32, DictionaryFromFileURL);
    goto LABEL_19;
  }
  CFStringRef v33 = CFDictionaryGetValue(theDicta, @"SupportedProductTypes");
  CFTypeID v34 = CFGetTypeID(v33);
  if (v34 != CFArrayGetTypeID())
  {
    CFStringRef v46 = @"SupportedProductTypes not a CFArray";
LABEL_18:
    AMRLog(3, v46, v35, v36, v37, v38, v39, v40, v48);
LABEL_19:
    CFBooleanRef v8 = 0;
    goto LABEL_16;
  }
  if (CFArrayGetCount((CFArrayRef)v33) >= 1)
  {
    CFIndex v41 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v33, v41);
      CFTypeID v43 = CFGetTypeID(ValueAtIndex);
      if (v43 != CFStringGetTypeID()) {
        break;
      }
      if (CFStringHasPrefix(ValueAtIndex, @"RealityDevice"))
      {
        uint64_t v44 = &kCFBooleanTrue;
        goto LABEL_15;
      }
      if (++v41 >= CFArrayGetCount((CFArrayRef)v33)) {
        goto LABEL_13;
      }
    }
    CFStringRef v46 = @"productType not a CFString";
    goto LABEL_18;
  }
LABEL_13:
  uint64_t v44 = &kCFBooleanFalse;
LABEL_15:
  CFBooleanRef v8 = *v44;
LABEL_16:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v8;
}

uint64_t sub_10004DBA4(const void *a1, const void *a2, const __CFString *a3, const __CFDictionary *a4)
{
  CFTypeRef cf = 0;
  uint64_t v7 = (CFDictionaryRef *)AMRLazyArchiveOpenFromOptions(a4);
  if (!v7) {
    return 0;
  }
  CFBooleanRef v8 = v7;
  uint64_t v9 = AMAuthInstallBundleCopyBuildIdentityForVariant((uint64_t)a1, a2, a3, &cf);
  if (!v9)
  {
    if (!cf)
    {
      AMRLog(3, @"AMAuthInstallBundleCopyBuildIdentityForVariant returned NULL", v10, v11, v12, v13, v14, v15, v62);
      uint64_t v16 = 2;
      goto LABEL_4;
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, @"Manifest");
    if (!Value)
    {
      AMRLog(3, @"build identity has no manifest", v20, v21, v22, v23, v24, v25, v62);
      uint64_t v16 = 1;
      goto LABEL_4;
    }
    CFDictionaryRef v26 = Value;
    CFIndex Count = CFDictionaryGetCount(Value);
    uint64_t v28 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    uint64_t v29 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    CFDictionaryGetKeysAndValues(v26, v28, v29);
    if (Count < 1)
    {
      AMRLazyArchiveClose((uint64_t)v8);
      uint64_t v61 = 0;
      CFURLRef v30 = 0;
      uint64_t v16 = 0;
      CFURLRef v17 = 0;
      if (!v28) {
        goto LABEL_33;
      }
    }
    else
    {
      CFURLRef v30 = 0;
      uint64_t v64 = v28;
      uint64_t v65 = v29;
      while (1)
      {
        CFStringRef v31 = (const __CFString *)*v28;
        if (!CFEqual(*v28, @"BaseSystem"))
        {
          CFDictionaryRef v32 = (const __CFDictionary *)*v29;
          CFAllocatorRef v33 = CFGetAllocator(a1);
          CFDictionaryRef ValueForKeyWithFormat = AMAuthInstallSupportGetValueForKeyWithFormat(v33, v32, @"%@.%@", v34, v35, v36, v37, v38, (char)@"Info");
          if (ValueForKeyWithFormat)
          {
            CFStringRef v40 = (const __CFString *)ValueForKeyWithFormat;
            if (v30) {
              CFRelease(v30);
            }
            CFAllocatorRef v41 = CFGetAllocator(a1);
            CFURLRef v30 = CFURLCreateCopyAppendingPathComponent(v41, (CFURLRef)a2, v40, 0);
            if (!v30)
            {
              AMRLog(3, @"CFURLCreateCopyAppendingPathComponent failed", v42, v43, v44, v45, v46, v47, v63);
              uint64_t v61 = 1;
              goto LABEL_28;
            }
            if (AMRLazyArchiveContainsURL(v8, v30))
            {
              char v66 = 0;
              uint64_t v48 = AMAuthInstallSupportFileURLExists(v30, &v66);
              if (v48)
              {
                uint64_t v61 = v48;
                AMRLog(3, @"AMAuthInstallSupportFileURLExists failed (err: %d)", v49, v50, v51, v52, v53, v54, v48);
                goto LABEL_28;
              }
              if (!v66
                && (!CFStringHasSuffix(v31, @"OS")
                 || (AMRLazyArchiveURLSupportsRandomAccess(v8, v30) & 1) == 0)
                && (AMRLazyArchiveExtractToURL(v8, v30) & 1) == 0)
              {
                break;
              }
            }
          }
        }
        ++v29;
        ++v28;
        if (!--Count)
        {
          uint64_t v61 = 0;
          goto LABEL_28;
        }
      }
      AMRLog(3, @"failed to extract %@ (%@)", v55, v56, v57, v58, v59, v60, (char)v31);
      uint64_t v61 = 4;
LABEL_28:
      AMRLazyArchiveClose((uint64_t)v8);
      uint64_t v28 = v64;
      uint64_t v29 = v65;
    }
    free(v28);
    uint64_t v16 = v61;
    CFURLRef v17 = v30;
LABEL_33:
    if (v29) {
      free(v29);
    }
    goto LABEL_5;
  }
  uint64_t v16 = v9;
  AMRLog(3, @"AMAuthInstallBundleCopyBuildIdentityForVariant failed (err: %d)", v10, v11, v12, v13, v14, v15, v9);
LABEL_4:
  AMRLazyArchiveClose((uint64_t)v8);
  CFURLRef v17 = 0;
LABEL_5:
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0;
  }
  if (v17) {
    CFRelease(v17);
  }
  return v16;
}

void sub_10004DEB4(CFDictionaryRef *a1, int a2)
{
  int valuePtr = a2;
  if ((a2 - 4000) >= 0xFFFFFC7C && !pthread_mutex_lock(&stru_1000B8A40))
  {
    CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v3)
    {
      CFNumberRef v4 = v3;
      CFStringRef LocalizedStatusString = AMAuthInstallGetLocalizedStatusString(a1, valuePtr);
      if (LocalizedStatusString) {
        CFDictionarySetValue((CFMutableDictionaryRef)qword_1000B8D80, v4, LocalizedStatusString);
      }
      pthread_mutex_unlock(&stru_1000B8A40);
      CFRelease(v4);
    }
    else
    {
      pthread_mutex_unlock(&stru_1000B8A40);
    }
  }
}

uint64_t AMRAuthInstallGetUUIDString(const __CFAllocator *a1, CFDictionaryRef theDict, CFStringRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3)
  {
    CFStringRef v37 = @"outUUIDString is NULL";
LABEL_14:
    AMRLog(3, v37, (uint64_t)a3, a4, a5, a6, a7, a8, v38);
    return 1;
  }
  if (!theDict)
  {
    CFStringRef v37 = @"options is NULL";
    goto LABEL_14;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"UUID");
  if (Value)
  {
    CFStringRef v12 = Value;
    CFRetain(Value);
    *a3 = v12;
    CFRelease(v12);
    return 0;
  }
  else
  {
    CFUUIDRef v14 = CFUUIDCreate(a1);
    if (v14)
    {
      CFUUIDRef v21 = v14;
      CFStringRef v22 = CFUUIDCreateString(a1, v14);
      if (v22)
      {
        CFStringRef v29 = v22;
        CFDictionaryAddValue(theDict, @"UUID", v22);
        AMRLog(5, @"*** UUID %@ ***", v30, v31, v32, v33, v34, v35, (char)v29);
        *a3 = v29;
        CFRelease(v29);
        uint64_t v13 = 0;
      }
      else
      {
        AMRLog(3, @"failed to create uuid string", v23, v24, v25, v26, v27, v28, v38);
        uint64_t v13 = 18;
      }
      CFRelease(v21);
    }
    else
    {
      AMRLog(3, @"failed to create uuid", v15, v16, v17, v18, v19, v20, v38);
      return 18;
    }
  }
  return v13;
}

uint64_t AMRAuthInstallSsoEnable(uint64_t a1)
{
  pthread_once(&stru_1000B8A80, (void (*)(void))sub_10004EB64);
  uint64_t v9 = AMAuthInstallSsoEnable(a1, v2, v3, v4, v5, v6, v7, v8);
  uint64_t v10 = AMAuthInstallToRestoreError(v9);
  uint64_t v17 = v10;
  if (v10) {
    AMRLog(3, @"Unable to enable AppleConnect authentication (%d). Make sure that AppleConnect.app is installed.", v11, v12, v13, v14, v15, v16, v10);
  }
  return v17;
}

BOOL AMRAuthInstallCopyTicketURL(uint64_t a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  char v30 = 0;
  CFTypeRef cf = 0;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"RestoreBundlePath");
  if (!Value)
  {
    CFStringRef v26 = @"device requires a personalized ap ticket";
LABEL_7:
    AMRLog(3, v26, v6, v7, v8, v9, v10, v11, (char)cf);
    return a1 != 0;
  }
  CFURLRef v12 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, Value, kCFURLPOSIXPathStyle, 1u);
  if (!v12)
  {
    CFStringRef v26 = @"failed to create url for restore bundle";
    goto LABEL_7;
  }
  CFURLRef v14 = v12;
  CFStringRef ApTicketComponentPath = AMAuthInstallBundleGetApTicketComponentPath(a1, v13, v6, v7, v8, v9, v10, v11);
  CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v17 = AMAuthInstallSupportCopyURLWithAppendedComponent(v16, v14, ApTicketComponentPath, 0, (CFURLRef *)&cf);
  if (v17)
  {
    uint64_t v24 = v17;
    CFStringRef v25 = @"failed to create url for apticket";
    goto LABEL_10;
  }
  uint64_t v27 = AMAuthInstallSupportFileURLExists(cf, &v30);
  if (v27)
  {
    uint64_t v24 = v27;
    CFStringRef v25 = @"failed to stat apticket";
LABEL_10:
    AMRLog(3, v25, v18, v19, v20, v21, v22, v23, (char)cf);
    if (a1) {
      a1 = AMAuthInstallToRestoreError(v24);
    }
    goto LABEL_12;
  }
  if (v30)
  {
    a1 = 0;
    *a3 = CFRetain(cf);
  }
  else
  {
    AMRLog(6, @"no ap ticket found", v18, v19, v20, v21, v22, v23, (char)cf);
    if (a1) {
      a1 = 11;
    }
    else {
      a1 = 0;
    }
  }
LABEL_12:
  CFRelease(v14);
  if (cf) {
    CFRelease(cf);
  }
  return a1;
}

uint64_t AMRAuthInstallCopyTicketData(const void *a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  CFTypeRef v16 = 0;
  uint64_t v5 = AMRAuthInstallCopyTicketURL((uint64_t)a1, a2, &v16);
  CFTypeRef v6 = v16;
  if (v5 || !v16)
  {
    if (!v16) {
      return v5;
    }
  }
  else
  {
    CFAllocatorRef v7 = CFGetAllocator(a1);
    uint64_t v5 = AMAuthInstallSupportCreateDataFromFileURL(v7, &cf, v6);
    if (v5)
    {
      AMRLog(3, @"failed to read apticket", v8, v9, v10, v11, v12, v13, (char)cf);
      if (a1) {
        uint64_t v5 = AMAuthInstallToRestoreError(v5);
      }
      else {
        uint64_t v5 = 0;
      }
    }
    else
    {
      *a3 = CFRetain(cf);
    }
  }
  CFRelease(v6);
  if (cf) {
    CFRelease(cf);
  }
  return v5;
}

uint64_t AMRAuthInstallCreatePathFromBundle(void *a1, CFDictionaryRef theDict, const __CFString *a3, CFStringRef *a4)
{
  CFURLRef anURL = 0;
  if (a1 && theDict && a4)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"RestoreBundlePath");
    if (Value)
    {
      CFStringRef v9 = Value;
      CFAllocatorRef v10 = CFGetAllocator(a1);
      CFURLRef v11 = CFURLCreateWithFileSystemPath(v10, v9, kCFURLPOSIXPathStyle, 1u);
      if (v11)
      {
        CFURLRef v18 = v11;
        CFStringRef v19 = AMRAuthInstallCopyVariant(a1, theDict);
        if (v19)
        {
          uint64_t v20 = AMAuthInstallBundleCopyURLForKey((CFDictionaryRef **)a1, a3, v19, v18, &anURL);
          if (v20)
          {
            uint64_t v27 = v20;
            AMRLog(3, @"failed to get url for key %@", v21, v22, v23, v24, v25, v26, (char)a3);
          }
          else
          {
            CFStringRef v30 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
            *a4 = v30;
            if (v30)
            {
              uint64_t v31 = 0;
LABEL_23:
              CFRelease(v18);
              if (anURL) {
                CFRelease(anURL);
              }
              if (v19) {
                CFRelease(v19);
              }
              return v31;
            }
            uint64_t v27 = 2;
          }
        }
        else
        {
          uint64_t v27 = 8;
        }
        *a4 = 0;
        uint64_t v31 = AMAuthInstallToRestoreError(v27);
        goto LABEL_23;
      }
      AMRLog(3, @"bundleURL allocation failed", v12, v13, v14, v15, v16, v17, v32);
      uint64_t v28 = 2;
    }
    else
    {
      uint64_t v28 = 8;
    }
    *a4 = 0;
  }
  else
  {
    if (a4) {
      *a4 = 0;
    }
    uint64_t v28 = 1;
  }
  return AMAuthInstallToRestoreError(v28);
}

uint64_t AMRAuthInstallCreateOptionsForBootstrapDevice(const __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8, CFTypeRef *a9)
{
  CFTypeRef v119 = 0;
  CFTypeRef v120 = 0;
  if (!a1)
  {
    AMRLog(3, @"bundlePath is NULL", a3, a4, (uint64_t)a5, a6, a7, a8, v115);
    return 1;
  }
  CFURLRef anURL = 0;
  if (a9)
  {
    uint64_t v17 = AMAuthInstallCreate(kCFAllocatorDefault);
    if (v17)
    {
      CFTypeRef cf = (void *)v17;
      CFURLRef v117 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, a1, kCFURLPOSIXPathStyle, 0);
      if (v117)
      {
        CFStringRef theString1 = a2;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFStringRef v37 = Mutable;
        if (Mutable)
        {
          AMAuthInstallSupportDictionarySetInteger64(Mutable, @"ECID", 0);
          AMAuthInstallSupportDictionarySetInteger32(v37, @"ApChipID", a3);
          AMAuthInstallSupportDictionarySetInteger32(v37, @"ApBoardID", a4);
          AMAuthInstallSupportDictionarySetInteger32(v37, @"ApSecurityDomain", 1);
          AMAuthInstallSupportDictionarySetBoolean(v37, @"ApProductionMode", 1);
          uint64_t v38 = AMAuthInstallApSetParameters((uint64_t)cf, v37);
          if (v38)
          {
            uint64_t v45 = v38;
            AMRLog(3, @"Failed to set AP parameters", v39, v40, v41, v42, v43, v44, v115);
LABEL_18:
            uint64_t v46 = 0;
            goto LABEL_19;
          }
          uint64_t v48 = AMAuthInstallBundleCopyBuildIdentityForVariant((uint64_t)cf, v117, theString1, &v120);
          if (v48)
          {
            uint64_t v49 = v48;
            AMRLog(3, @"AMAuthInstallBundleCopyBuildIdentityForVariant failed (err: %d)", v31, v32, v33, v34, v35, v36, v48);
            uint64_t v45 = AMAuthInstallToRestoreError(v49);
            goto LABEL_18;
          }
          if (v120)
          {
            uint64_t v52 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            uint64_t v46 = v52;
            if (v52)
            {
              CFDictionarySetValue(v52, @"ApBootstrapOnly", kCFBooleanTrue);
              CFDictionarySetValue(v46, @"RestoreBundlePath", a1);
              if (a5) {
                CFDictionarySetValue(v46, @"RestoreBootArgs", a5);
              }
              uint64_t v59 = AMRestoreCreatePathsForBundle((uint64_t)a1, 0, 0, 0, 0, 0, 0, &v119);
              if (v59)
              {
                uint64_t v61 = v59;
                AMRLog(3, @"failed to create path to firmware directory (err: %d)", v60, v54, v55, v56, v57, v58, v59);
                uint64_t v45 = AMAuthInstallToRestoreError(v61);
LABEL_19:
                CFURLRef v50 = v117;
LABEL_20:
                CFRelease(cf);
                if (v120) {
                  CFRelease(v120);
                }
                if (v50) {
                  CFRelease(v50);
                }
                goto LABEL_24;
              }
              CFTypeRef v53 = v119;
              if (v119)
              {
                CFDictionarySetValue(v46, @"FirmwareDirectory", v119);
                CFStringRef ValueForKeyPathInDict = (const __CFString *)AMAuthInstallSupportGetValueForKeyPathInDict(kCFAllocatorDefault, (const __CFDictionary *)v120, @"Info.VariantContents.DFU", v63, v64, v65, v66, v67);
                if (ValueForKeyPathInDict)
                {
                  CFStringRef TransformedDFUType = AMRestoreGetTransformedDFUType(ValueForKeyPathInDict);
                  if (TransformedDFUType)
                  {
                    CFDictionarySetValue(v46, @"DFUFileType", TransformedDFUType);
                    CFDictionaryRef v81 = AMAuthInstallSupportGetValueForKeyPathInDict(kCFAllocatorDefault, (const __CFDictionary *)v120, @"Info.VariantContents.RestoreKernelCache", v76, v77, v78, v79, v80);
                    if (v81)
                    {
                      CFDictionarySetValue(v46, @"KernelCacheType", v81);
                      CFStringRef v87 = (const __CFString *)AMAuthInstallSupportGetValueForKeyPathInDict(kCFAllocatorDefault, (const __CFDictionary *)v120, @"Info.VariantContents.Firmware", v82, v83, v84, v85, v86);
                      if (v87)
                      {
                        TransformedFirmwareTypeCFStringRef Value = AMRestoreGetTransformedFirmwareTypeValue(v87);
                        if (TransformedFirmwareTypeValue)
                        {
                          CFDictionarySetValue(v46, @"NORImageType", TransformedFirmwareTypeValue);
                          uint64_t v89 = 0;
                          v122[0] = a7;
                          v122[1] = @"RestoreRamDisk";
                          v122[2] = @"BootImageFile";
                          v122[3] = a8;
                          v122[4] = @"RestoreKernelCache";
                          v122[5] = @"RestoreKernelCacheFile";
                          v122[6] = a6;
                          v122[7] = @"RestoreDeviceTree";
                          v122[8] = @"DeviceTreeFile";
                          while (1)
                          {
                            uint64_t v90 = (const void *)v122[v89];
                            if (v90)
                            {
                              CFDictionarySetValue(v46, (const void *)v122[v89 + 2], v90);
                            }
                            else
                            {
                              CFStringRef v91 = (const __CFString *)v122[v89 + 1];
                              if (CFEqual(v91, @"RestoreRamDisk"))
                              {
                                CFStringRef Value = CFDictionaryGetValue(v46, @"BootImageTagOverride");
                                if (Value) {
                                  AMRLog(5, @"Sending custom image tag to memboot: %@\n", v93, v94, v95, v96, v97, v98, (char)Value);
                                }
                              }
                              uint64_t v99 = AMAuthInstallBundleCopyURLForKey((CFDictionaryRef **)cf, v91, theString1, v117, &anURL);
                              if (v99)
                              {
                                uint64_t v114 = v99;
                                CFURLRef v50 = v117;
                                AMRLog(3, @"Could not determine URL for key %@ in bundle %@", v100, v101, v102, v103, v104, v105, (char)v91);
                                uint64_t v45 = AMAuthInstallToRestoreError(v114);
                                goto LABEL_20;
                              }
                              CFStringRef v106 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
                              CFRelease(anURL);
                              if (!v106)
                              {
                                AMRLog(3, @"Could not convert URL %@ to path", v107, v108, v109, v110, v111, v112, (char)anURL);
                                uint64_t v45 = 31;
                                goto LABEL_19;
                              }
                              CFDictionarySetValue(v46, (const void *)v122[v89 + 2], v106);
                              CFRelease(v106);
                            }
                            v89 += 3;
                            if (v89 == 9)
                            {
                              uint64_t v45 = 0;
                              *a9 = CFRetain(v46);
                              goto LABEL_19;
                            }
                          }
                        }
                        CFStringRef v113 = @"Firmware type failed to transform";
                      }
                      else
                      {
                        CFStringRef v113 = @"Firmware type not found in BuildManifest.plist";
                      }
                    }
                    else
                    {
                      CFStringRef v113 = @"RestoreKernelCache type not found in BuildManifest.plist";
                    }
                  }
                  else
                  {
                    CFStringRef v113 = @"DFU type failed to transform";
                  }
                }
                else
                {
                  CFStringRef v113 = @"DFU type not found in BuildManifest.plist";
                }
                AMRLog(3, v113, v69, v70, v71, v72, v73, v74, v115);
                uint64_t v45 = 3002;
                goto LABEL_19;
              }
              CFStringRef v62 = @"firmwarePath is NULL";
            }
            else
            {
              CFStringRef v62 = @"options allocation failed";
            }
            AMRLog(3, v62, (uint64_t)v53, v54, v55, v56, v57, v58, v115);
LABEL_15:
            uint64_t v45 = 18;
            goto LABEL_19;
          }
          CFStringRef v47 = @"AMAuthInstallBundleCopyBuildIdentityForVariant returned NULL";
        }
        else
        {
          CFStringRef v47 = @"apOptions allocation failed";
        }
        AMRLog(3, v47, v31, v32, v33, v34, v35, v36, v115);
      }
      else
      {
        AMRLog(3, @"buildManifestURL allocation failed", v24, v25, v26, v27, v28, v29, v115);
        CFStringRef v37 = 0;
      }
      uint64_t v46 = 0;
      goto LABEL_15;
    }
    AMRLog(3, @"AMAuthInstallCreate failed", v18, v19, v20, v21, v22, v23, v115);
    CFStringRef v37 = 0;
    uint64_t v46 = 0;
    uint64_t v45 = 18;
  }
  else
  {
    AMRLog(3, @"outOptions is NULL", a3, a4, (uint64_t)a5, a6, a7, a8, v115);
    CFStringRef v37 = 0;
    uint64_t v46 = 0;
    uint64_t v45 = 1;
  }
LABEL_24:
  if (v119) {
    CFRelease(v119);
  }
  if (v46) {
    CFRelease(v46);
  }
  if (v37) {
    CFRelease(v37);
  }
  return v45;
}

uint64_t AMRAuthInstallCopyPathToFirmware(const __CFDictionary *a1, CFStringRef *a2)
{
  CFStringRef Value = CFDictionaryGetValue(a1, @"PersonalizedRestoreBundlePath");
  if (!Value) {
    return 1;
  }
  CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%cFirmware", Value, 47);
  if (!v4) {
    return 18;
  }
  CFStringRef v5 = v4;
  if (a2)
  {
    uint64_t result = 0;
    *a2 = v5;
  }
  else
  {
    CFRelease(v4);
    return 0;
  }
  return result;
}

uint64_t sub_10004EB64()
{
  qword_1000B8D80 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  AMRestoreCaptureSubsystemLogsIfNeeded();
  return AMAuthInstallSsoInitialize();
}

CFTypeRef sub_10004EBBC(const __CFDictionary *a1, __CFDictionary *a2, CFStringRef key, uint64_t a4)
{
  if (a1 && (Value = CFDictionaryGetValue(a1, key)) != 0 && (uint64_t v8 = Value, CFGetTypeID(Value) == a4))
  {
    if (a2) {
      AMRLog(6, @"Not using preferences value for %@. Found %@ in options.", v9, v10, v11, v12, v13, v14, (char)key);
    }
    return CFRetain(v8);
  }
  else
  {
    CFPropertyListRef v16 = CFPreferencesCopyAppValue(key, kCFPreferencesCurrentApplication);
    uint64_t v17 = v16;
    if (v16)
    {
      if (CFGetTypeID(v16) == a4)
      {
        if (a2)
        {
          AMRLog(6, @"Setting preferences value for %@ to %@", v18, v19, v20, v21, v22, v23, (char)key);
          CFDictionarySetValue(a2, key, v17);
        }
      }
      else
      {
        AMRLog(3, @"Mistyped preferences value for %@ (expected %lu)", v18, v19, v20, v21, v22, v23, (char)key);
        CFRelease(v17);
        return 0;
      }
    }
    return v17;
  }
}

uint64_t _writeCombinedBootImage(const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFArray *a4, size_t a5, uint64_t (*a6)(char *, size_t, uint64_t), const __CFString *a7, int a8, uint64_t a9)
{
  bzero(v148, 0x400uLL);
  bzero(buffer, 0x400uLL);
  memset(&v146, 0, sizeof(v146));
  if (a7 && CFStringGetCString(a7, (char *)buffer, 1024, 0x8000100u))
  {
    remove(buffer, v17);
    uint64_t v18 = fopen((const char *)buffer, "ab");
    if (!v18)
    {
      uint64_t v80 = __error();
      return _AMRestoreErrorForErrno(*v80, 11, v81, v82, v83, v84, v85, v86);
    }
    uint64_t v19 = v18;
    int v20 = 1;
  }
  else
  {
    uint64_t v19 = 0;
    int v20 = 0;
  }
  __size_t size = 0;
  CFStringGetFileSystemRepresentation(a1, v148, 1024);
  if (stat(v148, &v146) == -1)
  {
    CFStringRef v70 = @"Failed to stat boot image file";
    uint64_t v71 = (uint64_t)a1;
    goto LABEL_57;
  }
  if (v146.st_size <= 0) {
    off_t v27 = -(-v146.st_size & 0x3F);
  }
  else {
    off_t v27 = v146.st_size & 0x3F;
  }
  if (v27) {
    off_t v28 = 64 - v27;
  }
  else {
    off_t v28 = 0;
  }
  off_t v29 = v28 + v146.st_size;
  if (a8) {
    off_t st_size = v146.st_size;
  }
  else {
    off_t st_size = v29;
  }
  AMRLog(7, @"ramdisuint64_t k = %lld bytes (padded to %zu)", v21, v22, v23, v24, v25, v26, v146.st_size);
  CFStringGetFileSystemRepresentation(a2, v148, 1024);
  if (stat(v148, &v146) == -1)
  {
    CFStringRef v70 = @"Failed to stat device tree file";
    uint64_t v71 = (uint64_t)a2;
LABEL_57:
    AMRLogWithFilePath(3, v71, v70, v22, v23, v24, v25, v26, v139);
    uint64_t v72 = __error();
    uint64_t v79 = _AMRestoreErrorForErrno(*v72, 11, v73, v74, v75, v76, v77, v78);
    if ((v20 & 1) == 0) {
      return v79;
    }
    goto LABEL_58;
  }
  int v144 = v20;
  if (v146.st_size <= 0) {
    off_t v32 = -(-v146.st_size & 0x3F);
  }
  else {
    off_t v32 = v146.st_size & 0x3F;
  }
  if (v32) {
    off_t v33 = 64 - v32;
  }
  else {
    off_t v33 = 0;
  }
  off_t v34 = v33 + v146.st_size;
  if (a8) {
    off_t v35 = v146.st_size;
  }
  else {
    off_t v35 = v34;
  }
  AMRLog(7, @"devicetree = %lld bytes (padded to %zu)", v31, v22, v23, v24, v25, v26, v146.st_size);
  CFStringGetFileSystemRepresentation(a3, v148, 1024);
  if (stat(v148, &v146) == -1)
  {
    AMRLogWithFilePath(3, (uint64_t)a3, @"Failed to stat kernel cache file", v37, v38, v39, v40, v41, v140);
    CFStringRef v87 = __error();
    uint64_t v79 = _AMRestoreErrorForErrno(*v87, 11, v88, v89, v90, v91, v92, v93);
    if ((v144 & 1) == 0) {
      return v79;
    }
LABEL_58:
    CFBooleanRef v68 = 0;
    goto LABEL_80;
  }
  __streauint64_t m = v19;
  size_t size = a5;
  off_t v42 = v146.st_size;
  if (!a8)
  {
    if (v146.st_size <= 0) {
      off_t v43 = -(-v146.st_size & 0x3F);
    }
    else {
      off_t v43 = v146.st_size & 0x3F;
    }
    if (v43) {
      off_t v44 = 64 - v43;
    }
    else {
      off_t v44 = 0;
    }
    off_t v42 = v44 + v146.st_size;
  }
  unint64_t v45 = v35 + st_size + v42;
  AMRLog(7, @"K$ = %lld bytes (padded to %zu)", v36, v37, v38, v39, v40, v41, v146.st_size);
  uint64_t v141 = a6;
  if (!a4 || CFArrayGetCount(a4) < 1 || (CFIndex v52 = CFArrayGetCount(a4), v52 < 1))
  {
LABEL_52:
    AMRLog(6, @"memboot combined image = %zu bytes", v46, v47, v48, v49, v50, v51, v45);
    uint64_t v67 = (char *)malloc_type_malloc(size, 0x58D7EA5AuLL);
    CFBooleanRef v68 = v67;
    if (v67)
    {
      uint64_t v19 = __stream;
      if (a8)
      {
        size_t v69 = 0;
      }
      else
      {
        *((_OWORD *)v67 + 2) = 0u;
        *((_OWORD *)v67 + 3) = 0u;
        *(_OWORD *)uint64_t v67 = xmmword_10007E9C0;
        *((_OWORD *)v67 + 1) = 0u;
        *((void *)v67 + 3) = 0;
        *((_DWORD *)v67 + 4) = (v45 >> 6) + (((v45 & 0x3F) != 0) << 6);
        *((_DWORD *)v67 + 5) = 0;
        if ((byte_1000B8D88 & 1) == 0)
        {
          for (unint64_t i = 0; i != 256; ++i)
          {
            int v96 = 8;
            unint64_t v97 = i;
            do
            {
              if (v97) {
                unint64_t v97 = (v97 >> 1) ^ 0xEDB88320;
              }
              else {
                v97 >>= 1;
              }
              --v96;
            }
            while (v96);
            qword_1000B8D90[i] = v97;
          }
          byte_1000B8D88 = 1;
        }
        uint64_t v98 = 0;
        unint64_t v99 = 0xFFFFFFFFLL;
        do
          unint64_t v99 = qword_1000B8D90[(v67[v98++] ^ v99)] ^ (v99 >> 8);
        while (v98 != 48);
        *((_DWORD *)v67 + 12) = ~v99;
        size_t v69 = 64;
      }
      uint64_t v100 = sub_10004F424(a1, size, v67, v69, v67, (int64_t *)&__size, v141, v144, __stream, a8, a9);
      int v94 = v144;
      uint64_t v79 = v100;
      if (v100
        || (uint64_t v101 = sub_10004F424(a3, size, v68, __size, v68, (int64_t *)&__size, v141, v144, __stream, a8, a9),
            int v94 = v144,
            uint64_t v79 = v101,
            v101)
        || (uint64_t v102 = sub_10004F424(a2, size, v68, __size, v68, (int64_t *)&__size, v141, v144, __stream, a8, a9),
            int v94 = v144,
            uint64_t v79 = v102,
            v102))
      {
LABEL_79:
        if (!v94) {
          goto LABEL_81;
        }
        goto LABEL_80;
      }
      if (a4)
      {
        if (CFArrayGetCount(a4) >= 1)
        {
          CFIndex Count = CFArrayGetCount(a4);
          if (Count >= 1)
          {
            CFIndex v112 = Count;
            CFIndex v113 = 0;
            while (1)
            {
              CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a4, v113);
              if (ValueAtIndex)
              {
                CFStringRef v115 = ValueAtIndex;
                CFTypeID v116 = CFGetTypeID(ValueAtIndex);
                if (v116 == CFStringGetTypeID())
                {
                  uint64_t v117 = sub_10004F424(v115, size, v68, __size, v68, (int64_t *)&__size, v141, v144, __stream, a8, a9);
                  if (v117) {
                    break;
                  }
                }
              }
              if (v112 == ++v113) {
                goto LABEL_95;
              }
            }
            uint64_t v79 = v117;
            goto LABEL_63;
          }
        }
      }
LABEL_95:
      size_t v118 = __size;
      if (!__size) {
        goto LABEL_102;
      }
      if (v144 && fwrite(v68, __size, 1uLL, __stream) != 1)
      {
        AMRLog(3, @"remainder write to disk failed: %d\n", v119, v120, v121, v122, v123, v124, 0);
        uint64_t v79 = 0;
LABEL_86:
        uint64_t v19 = __stream;
        goto LABEL_80;
      }
      uint64_t v125 = v141(v68, v118, a9);
      if (v125)
      {
        uint64_t v79 = v125;
        AMRLog(3, @"remainder write failed: %d\n", v126, v127, v128, v129, v130, v131, v125);
        goto LABEL_104;
      }
      if ((v118 & 0x1FF) != 0)
      {
        uint64_t v79 = 0;
      }
      else
      {
LABEL_102:
        uint64_t v132 = v141(0, 0, a9);
        uint64_t v79 = v132;
        if (v132)
        {
          AMRLog(3, @"Zero byte packet write failed: %d\n", v133, v134, v135, v136, v137, v138, v132);
LABEL_104:
          uint64_t v19 = __stream;
          if ((v144 & 1) == 0)
          {
LABEL_81:
            if (v68) {
              free(v68);
            }
            return v79;
          }
LABEL_80:
          fclose(v19);
          goto LABEL_81;
        }
      }
    }
    else
    {
      uint64_t v79 = 18;
    }
LABEL_63:
    uint64_t v19 = __stream;
    int v94 = v144;
    goto LABEL_79;
  }
  CFIndex v53 = v52;
  CFIndex v54 = 0;
  while (1)
  {
    CFStringRef v55 = (const __CFString *)CFArrayGetValueAtIndex(a4, v54);
    if (v55)
    {
      CFStringRef v56 = v55;
      CFTypeID v57 = CFGetTypeID(v55);
      if (v57 == CFStringGetTypeID()) {
        break;
      }
    }
LABEL_51:
    if (v53 == ++v54) {
      goto LABEL_52;
    }
  }
  CFStringGetFileSystemRepresentation(v56, v148, 1024);
  if (stat(v148, &v146) != -1)
  {
    off_t v64 = v146.st_size;
    if (!a8)
    {
      if (v146.st_size <= 0) {
        off_t v65 = -(-v146.st_size & 0x3F);
      }
      else {
        off_t v65 = v146.st_size & 0x3F;
      }
      if (v65) {
        off_t v66 = 64 - v65;
      }
      else {
        off_t v66 = 0;
      }
      off_t v64 = v66 + v146.st_size;
    }
    v45 += v64;
    AMRLog(7, @"%s = %lld bytes (padded to %zu)", v58, v59, v60, v61, v62, v63, (char)v148);
    goto LABEL_51;
  }
  AMRLogWithFilePath(3, (uint64_t)a3, @"Failed to stat additional image file \"%s\"", v59, v60, v61, v62, v63, (char)v148);
  uint64_t v104 = __error();
  uint64_t v79 = _AMRestoreErrorForErrno(*v104, 11, v105, v106, v107, v108, v109, v110);
  if (v144)
  {
    CFBooleanRef v68 = 0;
    goto LABEL_86;
  }
  return v79;
}

uint64_t sub_10004F424(const __CFString *a1, size_t a2, char *a3, size_t a4, char *a5, int64_t *a6, uint64_t (*a7)(char *, size_t, uint64_t), int a8, FILE *a9, char a10, uint64_t a11)
{
  if (!a2) {
    return 1;
  }
  bzero(buffer, 0x400uLL);
  memset(&v90, 0, sizeof(v90));
  CFStringGetFileSystemRepresentation(a1, buffer, 1024);
  uint64_t v19 = open(buffer, 0);
  if (v19 == -1)
  {
    AMRLogWithFilePath(3, (uint64_t)a1, @"Failed to open file", v20, v21, v22, v23, v24, 0);
    uint64_t v71 = __error();
    return _AMRestoreErrorForErrno(*v71, 11, v72, v73, v74, v75, v76, v77);
  }
  uint64_t v25 = v19;
  if (fstat(v19, &v90) == -1)
  {
    AMRLogWithFilePath(3, (uint64_t)a1, @"Failed to stat file", v26, v27, v28, v29, v30, 0);
    uint64_t v78 = __error();
    uint64_t v70 = _AMRestoreErrorForErrno(*v78, 11, v79, v80, v81, v82, v83, v84);
    goto LABEL_54;
  }
  __dst = a5;
  uint64_t v31 = (char *)malloc_type_malloc(a2, 0xDF0E8760uLL);
  if (a4 > a2)
  {
    while (!a8 || fwrite(a3, a2, 1uLL, a9) == 1)
    {
      uint64_t v37 = a7(a3, a2, a11);
      if (v37)
      {
        uint64_t v70 = v37;
        AMRLogWithFilePath(3, (uint64_t)a1, @"Error writing prefix buffer: %d bytes\n", v38, v39, v40, v41, v42, a2);
        if (!v31) {
          goto LABEL_54;
        }
        goto LABEL_53;
      }
      a4 -= a2;
      a3 += a2;
      if (a4 < a2) {
        goto LABEL_9;
      }
    }
    AMRLogWithFilePath(3, (uint64_t)a1, @"Error writing prefix buffer to host: %d bytes\n", v32, v33, v34, v35, v36, a2);
LABEL_49:
    uint64_t v70 = 0;
    if (!v31) {
      goto LABEL_54;
    }
LABEL_53:
    free(v31);
    goto LABEL_54;
  }
LABEL_9:
  CFStringRef v87 = a6;
  if (a4) {
    memcpy(v31, a3, a4);
  }
  unint64_t st_size = v90.st_size;
  off_t v44 = &v31[a4];
  if ((v90.st_size & 0x3F) != 0 && a10 == 0) {
    size_t v46 = 64 - (v90.st_size & 0x3F);
  }
  else {
    size_t v46 = 0;
  }
  __ptr = v31;
  if (!v90.st_size)
  {
LABEL_37:
    int64_t *v87 = 0;
    uint64_t v31 = __ptr;
    int64_t v69 = v44 - __ptr;
    if (v44 != __ptr)
    {
      memcpy(__dst, __ptr, v44 - __ptr);
      int64_t *v87 = v69;
    }
    if (v46)
    {
      bzero(&__dst[v69], v46);
      uint64_t v70 = 0;
      *v87 += v46;
      if (!__ptr) {
        goto LABEL_54;
      }
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  uint64_t v86 = (uint64_t)a1;
  uint64_t v47 = &v31[a2];
  while (1)
  {
    if (st_size >= v47 - v44) {
      size_t v48 = v47 - v44;
    }
    else {
      size_t v48 = st_size;
    }
    uint64_t v49 = v25;
    ssize_t v50 = read(v25, v44, v48);
    if (v50 == -1)
    {
      AMRLogWithFilePath(3, v86, @"Error reading from file: %d bytes attempted\n", v51, v52, v53, v54, v55, v48);
      uint64_t v70 = 13;
      goto LABEL_52;
    }
    ssize_t v56 = v50;
    if (!a10 && st_size == v90.st_size) {
      *((_DWORD *)v44 + 1) = st_size + v46;
    }
    v44 += v50;
    if (v44 < v47 && &v44[v46] >= v47)
    {
      bzero(v44, v47 - v44);
      v46 -= v47 - v44;
      off_t v44 = v47;
    }
    if (v44 != v47) {
      goto LABEL_36;
    }
    off_t v44 = __ptr;
    if (a8)
    {
      if (fwrite(__ptr, a2, 1uLL, a9) != 1) {
        break;
      }
    }
    uint64_t v63 = a7(__ptr, a2, a11);
    if (v63)
    {
      uint64_t v70 = v63;
      AMRLogWithFilePath(3, v86, @"Error writing buffer: %d bytes\n", v64, v65, v66, v67, v68, a2);
LABEL_52:
      LODWORD(v25) = v49;
      uint64_t v31 = __ptr;
      if (!__ptr) {
        goto LABEL_54;
      }
      goto LABEL_53;
    }
LABEL_36:
    st_size -= v56;
    uint64_t v25 = v49;
    if (!st_size) {
      goto LABEL_37;
    }
  }
  AMRLogWithFilePath(3, v86, @"Error writing buffer to disk: %d bytes\n", v58, v59, v60, v61, v62, a2);
  uint64_t v70 = 0;
  LODWORD(v25) = v49;
  uint64_t v31 = __ptr;
  if (__ptr) {
    goto LABEL_53;
  }
LABEL_54:
  close(v25);
  return v70;
}

BOOL sub_10004F824(CFMutableDictionaryRef *a1, const void *a2, const void *a3)
{
  if (pthread_mutex_lock(&stru_1000B8AA0)) {
    return 0;
  }
  CFDictionaryRef Mutable = *a1;
  if (!*a1)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
    *a1 = Mutable;
  }
  int v8 = CFDictionaryContainsKey(Mutable, a2);
  BOOL v6 = v8 == 0;
  if (!v8) {
    CFDictionarySetValue(*a1, a2, a3);
  }
  pthread_mutex_unlock(&stru_1000B8AA0);
  return v6;
}

CFStringRef sub_10004F8CC(const char *a1, int a2)
{
  size_t v4 = strlen(a1);
  if (!v4) {
    return 0;
  }
  size_t v5 = v4;
  if ((a2 & 1) != 0 || (CFStringRef v6 = 0, v7 = a1[v4 - 1], v7 != 47) && v7 != 92)
  {
    int v8 = *(unsigned __int8 *)a1;
    BOOL v10 = v8 == 47 || v8 == 92;
    if (v4 != 1 || !v10)
    {
      CFDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      uint64_t v12 = Mutable;
      if (v8 == 92 || v8 == 47) {
        CFArrayAppendValue(Mutable, &stru_10009EF88);
      }
      uint64_t v13 = strdup(a1);
      uint64_t v14 = 0;
      uint64_t v15 = v13;
      do
      {
        int v16 = v13[v14];
        if (v16 == 92 || v16 == 47)
        {
          v13[v14] = 0;
          CFStringRef v17 = CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, v15);
          if (!v17) {
            goto LABEL_32;
          }
          CFStringRef v18 = v17;
          if (CFStringGetLength(v17) >= 1) {
            CFArrayAppendValue(v12, v18);
          }
          CFRelease(v18);
          uint64_t v15 = &v13[v14 + 1];
        }
        ++v14;
      }
      while (v5 != v14);
      CFStringRef v19 = CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, v15);
      if (v19)
      {
        CFStringRef v20 = v19;
        CFArrayAppendValue(v12, v19);
        if (a2 && CFStringGetLength(v20)) {
          CFArrayAppendValue(v12, &stru_10009EF88);
        }
        CFStringRef v6 = CFStringCreateByCombiningStrings(kCFAllocatorDefault, v12, @"/");
        CFRelease(v20);
        if (!v12)
        {
LABEL_34:
          free(v13);
          return v6;
        }
      }
      else
      {
LABEL_32:
        CFStringRef v6 = 0;
        if (!v12) {
          goto LABEL_34;
        }
      }
      CFRelease(v12);
      goto LABEL_34;
    }
    return @"/";
  }
  return v6;
}

uint64_t AMRLazyExtractorAddFile(const __CFDictionary *a1, const char *a2, uint64_t a3, void *a4, void *a5)
{
  uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"__ExtractionRoot__");
  if (result)
  {
    uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"__ArchiveFiles__");
    if (result)
    {
      uint64_t v11 = (__CFDictionary *)result;
      uint64_t result = (uint64_t)sub_10004F8CC(a2, 0);
      if (result)
      {
        uint64_t v12 = (void *)result;
        uint64_t valuePtr = a3;
        CFNumberRef v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
        *(_OWORD *)keys = off_10009EA88;
        long long v18 = off_10009EA98;
        values[0] = a4;
        values[1] = a5;
        values[2] = v12;
        values[3] = v13;
        CFDictionaryRef v14 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFDictionarySetValue(v11, v12, v14);
        CFRelease(v12);
        if (v13) {
          CFRelease(v13);
        }
        if (v14) {
          CFRelease(v14);
        }
        return 1;
      }
    }
  }
  return result;
}

void *AMRLazyExtractorOpenArchive(const __CFDictionary *a1)
{
  if (!a1) {
    return 0;
  }
  CFDictionaryRef v2 = (const __CFDictionary *)qword_1000B9590;
  CFStringRef Value = CFDictionaryGetValue(a1, @"__ArchiveScheme__");
  size_t v4 = (uint64_t (**)(void))sub_1000505CC(v2, Value);
  if (!v4) {
    return 0;
  }
  size_t v5 = v4;
  CFStringRef v6 = (uint64_t (*)(const void *))*v4;
  int v7 = CFDictionaryGetValue(a1, @"__ArchiveArgs__");
  uint64_t v8 = v6(v7);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = v8;
  BOOL v10 = malloc_type_calloc(1uLL, 0x20uLL, 0x10600401723F8EDuLL);
  *BOOL v10 = CFRetain(a1);
  v10[1] = v9;
  void v10[2] = v5;
  *((unsigned char *)v10 + 24) = 0;
  return v10;
}

uint64_t AMRLazyArchiveClose(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24)) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 8))(*(void *)(a1 + 8));
  if (result)
  {
    CFRelease(*(CFTypeRef *)a1);
    free((void *)a1);
    return 1;
  }
  return result;
}

BOOL AMRLazyArchiveContainsURL(CFDictionaryRef *a1, const __CFURL *a2)
{
  return sub_10004FD0C(a1, a2) != 0;
}

CFStringRef sub_10004FD0C(CFDictionaryRef *a1, CFURLRef anURL)
{
  CFStringRef result = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
  if (result)
  {
    CFStringRef v4 = result;
    CFDictionaryRef v5 = sub_100050410(a1, result);
    CFRelease(v4);
    return (const __CFString *)v5;
  }
  return result;
}

CFDictionaryRef AMRLazyArchiveURLSupportsRandomAccess(CFDictionaryRef *a1, const __CFURL *a2)
{
  CFStringRef v2 = sub_10004FD0C(a1, a2);
  CFDictionaryRef result = sub_10004FD88((const __CFDictionary *)v2);
  if (result) {
    return (const __CFDictionary *)(*((void *)result + 3) != 0);
  }
  return result;
}

CFDictionaryRef sub_10004FD88(const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v1 = (const __CFDictionary *)qword_1000B9598;
    CFStringRef Value = CFDictionaryGetValue(result, @"__FileScheme__");
    return (const __CFDictionary *)sub_1000505CC(v1, Value);
  }
  return result;
}

uint64_t AMRLazyArchiveExtractToPath(CFDictionaryRef *a1, const __CFString *a2)
{
  bzero(buffer, 0x400uLL);
  bzero(v15, 0x400uLL);
  if (!CFStringGetFileSystemRepresentation(a2, buffer, 1024)) {
    return 0;
  }
  CFStringRef v4 = AMRLazyArchiveOpenFile((uint64_t)a1, a2, 0);
  if (!v4) {
    return 0;
  }
  CFDictionaryRef v5 = v4;
  if (CFStringGetFileSystemRepresentation((CFStringRef)v4[4], v15, 1024)
    && (uint64_t v6 = v5[5], (v7 = fopen(buffer, "wb")) != 0))
  {
    uint64_t v8 = v7;
    uint64_t v9 = malloc_type_calloc(1uLL, 0x20000uLL, 0xC839496EuLL);
    if (!v9)
    {
LABEL_13:
      AMRLazyFileClose(v5);
      fclose(v8);
      uint64_t v12 = 0;
      goto LABEL_16;
    }
    unint64_t v10 = v6;
    while (v10)
    {
      if (v10 >= 0x20000) {
        size_t v11 = 0x20000;
      }
      else {
        size_t v11 = v10;
      }
      if (AMRLazyFileRead(v5, (uint64_t)v9, v11))
      {
        v10 -= v11;
        if (fwrite(v9, 1uLL, v11, v8) == v11) {
          continue;
        }
      }
      goto LABEL_13;
    }
    fclose(v8);
    CFStringRef Value = (__CFDictionary *)CFDictionaryGetValue(*a1, @"__ArchiveFiles__");
    CFDictionaryRemoveValue(Value, (const void *)v5[4]);
    uint64_t v12 = AMRLazyExtractorAddFileFromPathRange(*a1, v15, buffer, v6, 0);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v12 = 0;
  }
  AMRLazyFileClose(v5);
LABEL_16:
  if (v9) {
    free(v9);
  }
  return v12;
}

void *AMRLazyArchiveOpenFile(uint64_t a1, const __CFString *a2, char a3)
{
  if (*(unsigned char *)(a1 + 24)) {
    return 0;
  }
  CFDictionaryRef v6 = sub_100050410((CFDictionaryRef *)a1, a2);
  if (!v6) {
    return 0;
  }
  CFDictionaryRef v7 = v6;
  CFDictionaryRef v8 = (const __CFDictionary *)qword_1000B9598;
  CFStringRef Value = CFDictionaryGetValue(v6, @"__FileScheme__");
  unint64_t v10 = (uint64_t (**)(uint64_t, const void *))sub_1000505CC(v8, Value);
  if (!v10) {
    return 0;
  }
  size_t v11 = v10;
  if ((a3 & 1) != 0 && !v10[3])
  {
    if (!AMRLazyArchiveExtractToPath(a1, a2)) {
      return 0;
    }
    CFDictionaryRef v12 = sub_100050410((CFDictionaryRef *)a1, a2);
    if (!v12) {
      return 0;
    }
    CFDictionaryRef v7 = v12;
    CFDictionaryRef v13 = (const __CFDictionary *)qword_1000B9598;
    CFDictionaryRef v14 = CFDictionaryGetValue(v12, @"__FileScheme__");
    uint64_t v15 = (uint64_t (**)(uint64_t, const void *))sub_1000505CC(v13, v14);
    if (!v15) {
      return 0;
    }
    size_t v11 = v15;
    if (!v15[3]) {
      return 0;
    }
  }
  int v16 = *v11;
  uint64_t v17 = *(void *)(a1 + 8);
  long long v18 = CFDictionaryGetValue(v7, @"__FileArgs__");
  uint64_t v19 = v16(v17, v18);
  if (!v19) {
    return 0;
  }
  uint64_t v20 = v19;
  uint64_t v21 = malloc_type_calloc(1uLL, 0x40uLL, 0x10600400D5AF1C1uLL);
  uint64_t v22 = *(void *)(a1 + 8);
  *uint64_t v21 = a1;
  v21[1] = v22;
  v21[2] = v20;
  v21[3] = v11;
  uint64_t v23 = CFDictionaryGetValue(v7, @"__FileSubPath__");
  v21[4] = CFRetain(v23);
  uint64_t valuePtr = 0;
  CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(v7, @"__FileSize__");
  CFNumberGetValue(v24, kCFNumberSInt64Type, &valuePtr);
  v21[5] = valuePtr;
  v21[6] = 0;
  *((unsigned char *)v21 + 56) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  return v21;
}

uint64_t AMRLazyFileRead(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 1;
  }
  unint64_t v4 = a1[6] + a3;
  if (v4 > a1[5]) {
    return 0;
  }
  uint64_t v5 = a1[3];
  CFDictionaryRef v6 = *(uint64_t (**)(void, void, uint64_t, uint64_t))(v5 + 16);
  if (v6)
  {
    if ((v6(a1[1], a1[2], a2, a3) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t))(v5 + 24))(a1[1], a1[2], a2, a3);
    if (!result) {
      return result;
    }
  }
  a1[6] = v4;
  return 1;
}

uint64_t AMRLazyExtractorAddFileFromPathRange(const __CFDictionary *a1, const char *a2, const char *a3, uint64_t a4, unint64_t a5)
{
  pthread_once(&stru_1000B8A90, (void (*)(void))sub_1000505B0);
  memset(&v16, 0, sizeof(v16));
  if (stat(a3, &v16)) {
    return 0;
  }
  uint64_t v10 = 0;
  if (v16.st_size < a5 || a5 + a4 > v16.st_size) {
    return v10;
  }
  CFStringRef v11 = CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, a3);
  if (!v11) {
    return 0;
  }
  CFStringRef v12 = v11;
  unint64_t valuePtr = a5;
  CFNumberRef v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  *(_OWORD *)keys = off_10009EAA8;
  values[0] = (void *)v12;
  values[1] = v13;
  CFDictionaryRef v14 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v10 = AMRLazyExtractorAddFile(a1, a2, a4, @"__DiskFileScheme__", v14);
  CFRelease(v12);
  if (v13) {
    CFRelease(v13);
  }
  if (v14) {
    CFRelease(v14);
  }
  return v10;
}

uint64_t AMRLazyFileClose(uint64_t *a1)
{
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[3] + 8))(a1[1], a1[2]);
  if (v2)
  {
    if (*a1) {
      *(unsigned char *)(*a1 + 24) = 0;
    }
    uint64_t v3 = (const void *)a1[4];
    if (v3)
    {
      CFRelease(v3);
      a1[4] = 0;
    }
    if (*((unsigned char *)a1 + 56)) {
      AMRLazyArchiveClose(*a1);
    }
    free(a1);
  }
  return v2;
}

CFStringRef AMRLazyArchiveExtractToURL(CFDictionaryRef *a1, CFURLRef anURL)
{
  CFStringRef result = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
  if (result)
  {
    CFStringRef v4 = result;
    uint64_t v5 = AMRLazyArchiveExtractToPath(a1, result);
    CFRelease(v4);
    return (const __CFString *)v5;
  }
  return result;
}

CFDictionaryRef sub_100050410(CFDictionaryRef *a1, const __CFString *a2)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*a1, @"__ExtractionRoot__");
  if (!Value) {
    return 0;
  }
  CFStringRef v5 = Value;
  CFDictionaryRef v6 = (const __CFDictionary *)CFDictionaryGetValue(*a1, @"__ArchiveFiles__");
  if (v6)
  {
    CFIndex Length = CFStringGetLength(v5);
    bzero(buffer, 0x400uLL);
    if (!CFStringGetFileSystemRepresentation(a2, buffer, 1024)) {
      return 0;
    }
    CFStringRef v8 = sub_10004F8CC(buffer, 0);
    if (!v8) {
      return 0;
    }
    CFStringRef v9 = v8;
    if (CFStringHasPrefix(v8, v5))
    {
      v15.CFIndex length = CFStringGetLength(v9) - Length;
      v15.CFIndex location = Length;
      CFStringRef PathComponent = CFStringCreateWithSubstring(kCFAllocatorDefault, v9, v15);
    }
    else
    {
      CFURLRef v11 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v9, kCFURLPOSIXPathStyle, 0);
      if (!v11)
      {
        CFRelease(v9);
        return 0;
      }
      CFStringRef PathComponent = CFURLCopyLastPathComponent(v11);
    }
    CFStringRef v12 = PathComponent;
    CFRelease(v9);
    if (v12)
    {
      CFDictionaryRef v6 = (const __CFDictionary *)CFDictionaryGetValue(v6, v12);
      CFRelease(v12);
      return v6;
    }
    return 0;
  }
  return v6;
}

void *AMRLazyArchiveOpenFromOptions(const __CFDictionary *a1)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"__Extractor__");
  return AMRLazyExtractorOpenArchive(Value);
}

BOOL sub_1000505B0()
{
  return sub_10004F824((CFMutableDictionaryRef *)&qword_1000B9598, @"__DiskFileScheme__", &off_10009EAB8);
}

const void *sub_1000505CC(const __CFDictionary *a1, const void *a2)
{
  CFDictionaryRef Value = a2;
  if (a2)
  {
    if (pthread_mutex_lock(&stru_1000B8AA0))
    {
      return 0;
    }
    else
    {
      if (a1) {
        CFDictionaryRef Value = CFDictionaryGetValue(a1, Value);
      }
      else {
        CFDictionaryRef Value = 0;
      }
      pthread_mutex_unlock(&stru_1000B8AA0);
    }
  }
  return Value;
}

void *sub_100050638(int a1, CFDictionaryRef theDict)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"__DiskFilePath__");
  bzero(buffer, 0x400uLL);
  if (!CFStringGetFileSystemRepresentation(Value, buffer, 1024)) {
    return 0;
  }
  int v4 = open(buffer, 0);
  if (v4 == -1) {
    return 0;
  }
  int v5 = v4;
  CFDictionaryRef v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x1000040F7F8B94BuLL);
  *(_DWORD *)CFDictionaryRef v6 = v5;
  uint64_t v9 = 0;
  CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"__DiskFileOffset__");
  CFNumberGetValue(v7, kCFNumberSInt64Type, &v9);
  v6[1] = v9;
  return v6;
}

BOOL sub_100050738(uint64_t a1, int *a2)
{
  int v3 = close(*a2);
  if (v3) {
    *a2 = -1;
  }
  else {
    free(a2);
  }
  return v3 == 0;
}

BOOL sub_100050784(int a1, uint64_t a2, void *__buf, size_t __nbyte, uint64_t a5)
{
  return pread(*(_DWORD *)a2, __buf, __nbyte, *(void *)(a2 + 8) + a5) == __nbyte;
}

uint64_t uarpSuperBinaryHeaderEndianSwap(unsigned int *a1, _DWORD *a2)
{
  *a2 = uarpHtonl(*a1);
  a2[1] = uarpHtonl(a1[1]);
  a2[2] = uarpHtonl(a1[2]);
  a2[3] = uarpHtonl(a1[3]);
  a2[4] = uarpHtonl(a1[4]);
  a2[5] = uarpHtonl(a1[5]);
  a2[6] = uarpHtonl(a1[6]);
  a2[7] = uarpHtonl(a1[7]);
  a2[8] = uarpHtonl(a1[8]);
  a2[9] = uarpHtonl(a1[9]);
  uint64_t result = uarpHtonl(a1[10]);
  a2[10] = result;
  return result;
}

uint64_t uarpPayloadHeaderEndianSwap(unsigned int *a1, _DWORD *a2)
{
  *a2 = uarpHtonl(*a1);
  a2[2] = uarpHtonl(a1[2]);
  a2[3] = uarpHtonl(a1[3]);
  a2[4] = uarpHtonl(a1[4]);
  a2[5] = uarpHtonl(a1[5]);
  a2[6] = uarpHtonl(a1[6]);
  a2[7] = uarpHtonl(a1[7]);
  a2[8] = uarpHtonl(a1[8]);
  uint64_t result = uarpHtonl(a1[9]);
  a2[9] = result;
  return result;
}

uint64_t uarpPayloadTagPack(unsigned int *a1)
{
  return *a1;
}

unint64_t uarpHtonll(unint64_t a1)
{
  return bswap64(a1);
}

unint64_t uarpNtohll(unint64_t a1)
{
  return bswap64(a1);
}

uint64_t uarpHtonl(unsigned int a1)
{
  return bswap32(a1);
}

uint64_t uarpNtohl(unsigned int a1)
{
  return bswap32(a1);
}

uint64_t uarpHtons(unsigned int a1)
{
  return __rev16(a1);
}

uint64_t uarpNtohs(unsigned int a1)
{
  return __rev16(a1);
}

BOOL sub_1000511E4(NSError *self, SEL a2)
{
  int v3 = [(NSError *)self domain];
  if ([v3 isEqualToString:NSPOSIXErrorDomain]) {
    BOOL v4 = (id)[(NSError *)self code] == (id)17;
  }
  else {
    BOOL v4 = 0;
  }

  return v4;
}

id UARPPersonalizationTSSRequestWithSigningServer(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  int v5 = sub_10005160C();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
    sub_100051CA4();
  }

  id v6 = sub_100051660(v3, v4, 0);
  CFNumberRef v7 = sub_10005160C();
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  if (v6)
  {
    if (v8) {
      sub_100051C70();
    }

    id v9 = v6;
  }
  else
  {
    if (v8) {
      sub_100051C3C();
    }
  }
  return v6;
}

id sub_10005160C()
{
  if (qword_1000B95A0 != -1) {
    dispatch_once(&qword_1000B95A0, &stru_10009EB30);
  }
  uint64_t v0 = (void *)qword_1000B95A8;
  return v0;
}

id sub_100051660(void *a1, void *a2, int a3)
{
  CFDictionaryRef v5 = a1;
  id v6 = a2;
  CFNumberRef v7 = sub_10005160C();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    CFTypeRef v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "UARP: TSS request to signing server %{public}@", buf, 0xCu);
  }

  AMAuthInstallLogSetHandler((void (*)(int, uint64_t))sub_100051B30);
  uint64_t v8 = AMAuthInstallCreate(kCFAllocatorDefault);
  if (!v8)
  {
    CFNumberRef v13 = sub_10005160C();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100051D0C();
    }

    goto LABEL_11;
  }
  id v9 = (const void *)v8;
  int v10 = AMAuthInstallSetSigningServerURL(v8, v6);
  CFURLRef v11 = sub_10005160C();
  CFStringRef v12 = v11;
  if (v10)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_100051DB8();
    }

    CFRelease(v9);
LABEL_11:
    CFDictionaryRef v14 = 0;
    goto LABEL_32;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    if (a3) {
      CFStringRef v15 = @" <AppleConnect>";
    }
    else {
      CFStringRef v15 = @" ";
    }
    *(_DWORD *)buf = 138543618;
    CFTypeRef v25 = v6;
    __int16 v26 = 2114;
    CFStringRef v27 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "UARP: TSS Request %{public}@%{public}@ is ", buf, 0x16u);
  }

  stat v16 = sub_10005160C();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    CFTypeRef v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "UARP: %{public}@", buf, 0xCu);
  }

  CFTypeRef v23 = 0;
  int v17 = AMAuthInstallApCreatePersonalizedResponse((uint64_t)v9, v5, &v23);
  long long v18 = sub_10005160C();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    if (a3) {
      CFStringRef v19 = @" <AppleConnect>";
    }
    else {
      CFStringRef v19 = @" ";
    }
    *(_DWORD *)buf = 138543618;
    CFTypeRef v25 = v6;
    __int16 v26 = 2114;
    CFStringRef v27 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "UARP: TSS Response %{public}@%{public}@ is ", buf, 0x16u);
  }

  uint64_t v20 = sub_10005160C();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    CFTypeRef v25 = v23;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "UARP: %{public}@", buf, 0xCu);
  }

  if (v17)
  {
    uint64_t v21 = sub_10005160C();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      sub_100051D40(v17, v21);
    }

    CFDictionaryRef v14 = 0;
  }
  else
  {
    CFDictionaryRef v14 = (void *)v23;
  }
  CFRelease(v9);
LABEL_32:

  return v14;
}

id UARPPersonalizationTSSRequestWithSigningServerSSO(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  CFDictionaryRef v5 = sub_10005160C();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
    sub_100051E20();
  }

  id v6 = sub_100051660(v3, v4, 1);
  if (!v6)
  {
    CFNumberRef v7 = sub_10005160C();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100051DEC();
    }
  }
  return v6;
}

void sub_100051AE8(id a1)
{
  os_log_t v1 = os_log_create("com.apple.accessoryupdater.uarp", "personalization");
  uint64_t v2 = (void *)qword_1000B95A8;
  qword_1000B95A8 = (uint64_t)v1;
}

void sub_100051B30(uint64_t a1, uint64_t a2)
{
  id v3 = sub_10005160C();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    int v4 = 136446210;
    uint64_t v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "UARP: Personalization Message >> %{public}s", (uint8_t *)&v4, 0xCu);
  }
}

void sub_100051BDC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_100051C1C(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void sub_100051C3C()
{
  sub_100051BF8();
  sub_100051BDC((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request failed customer path / auth listed", v2, v3, v4, v5, v6);
}

void sub_100051C70()
{
  sub_100051BF8();
  sub_100051BDC((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request passed customer path / auth listed", v2, v3, v4, v5, v6);
}

void sub_100051CA4()
{
  sub_100051C04();
  sub_100051C1C((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request to server %{public}@ with options %{public}@");
}

void sub_100051D0C()
{
  sub_100051BF8();
  sub_100051BDC((void *)&_mh_execute_header, v0, v1, "UARP: Failed to create authinstall reference", v2, v3, v4, v5, v6);
}

void sub_100051D40(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "UARP: Failed personalization response, CFErrorRef error = %u", (uint8_t *)v2, 8u);
}

void sub_100051DB8()
{
  sub_100051BF8();
  sub_100051BDC((void *)&_mh_execute_header, v0, v1, "UARP: Failed to set signing server", v2, v3, v4, v5, v6);
}

void sub_100051DEC()
{
  sub_100051BF8();
  sub_100051BDC((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request failed sso modes", v2, v3, v4, v5, v6);
}

void sub_100051E20()
{
  sub_100051C04();
  sub_100051C1C((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request to server %{public}@ with SSO and options %{public}@");
}

void sub_100051F40(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005306C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100054584(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100058CC4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 8));
  [WeakRetained superbinary:*(void *)(a1 + 32) logString:*(void *)(a1 + 40)];
}

id sub_100058D10(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)(a2 + 32);
  uint64_t v4 = *(void **)(a2 + 40);
  return v4;
}

void sub_100058D4C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
}

void sub_10005C384(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005EB54(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005F57C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_10005F93C(NSFileHandle *self, SEL a2, const void *a3, unint64_t a4)
{
  uint64_t v5 = +[NSData dataWithBytes:a3 length:a4];
  LOBYTE(self) = [(NSFileHandle *)self uarpWriteData:v5 error:0];

  return (char)self;
}

void sub_10006130C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_100061348(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_100061374(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x20u);
}

void sub_1000613A8()
{
  int v2 = 136315650;
  sub_10006132C();
  sub_100061374((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
}

void sub_10006141C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100061494(unsigned __int8 *a1, NSObject *a2)
{
  int v2 = *a1;
  int v3 = a1[1];
  int v4 = a1[2];
  int v5 = a1[3];
  int v6 = 136316162;
  CFNumberRef v7 = "-[FTABFileBackDeploy parseFileData]";
  __int16 v8 = 1024;
  int v9 = v2;
  __int16 v10 = 1024;
  int v11 = v3;
  __int16 v12 = 1024;
  int v13 = v4;
  __int16 v14 = 1024;
  int v15 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: File tag parse error (%02x %02x %02x %02x)", (uint8_t *)&v6, 0x24u);
}

void sub_100061548()
{
  sub_100061394();
  sub_100061364();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x18u);
}

void sub_1000615CC()
{
  v1[0] = 136315650;
  sub_100061394();
  __int16 v2 = 2048;
  uint64_t v3 = 16;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: Error parsing file offset list (offset=%u, length=%lu)", (uint8_t *)v1, 0x1Cu);
}

void sub_10006165C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000616D4()
{
  sub_100061364();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x3Cu);
}

void sub_1000617B4()
{
  int v2 = 136315650;
  sub_10006132C();
  sub_100061374((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
}

void sub_100061828()
{
  sub_1000260D8();
  sub_100061364();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
}

void sub_1000618A4(void *a1)
{
  id v1 = [a1 path];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Unable to create file at %@", v4, v5, v6, v7, v8);
}

void sub_100061930(void *a1)
{
  id v1 = [a1 path];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Unable to delete file at %@", v4, v5, v6, v7, v8);
}

void sub_1000619BC(void *a1)
{
  id v1 = [a1 tag];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Failed to write '%@'", v4, v5, v6, v7, v8);
}

void sub_100061A48(os_log_t log)
{
  *(_WORD *)id v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to write manifest", v1, 2u);
}

void sub_100061A8C(void *a1)
{
  id v1 = [a1 tag];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Failed to write '%@' header", v4, v5, v6, v7, v8);
}

void sub_100061B18(os_log_t log)
{
  *(_WORD *)id v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to write FTAB header", v1, 2u);
}

void sub_100061B5C(void *a1)
{
  id v1 = [a1 absoluteString];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Failed to open file handle for writing to '%@'", v4, v5, v6, v7, v8);
}

void sub_100061BE8()
{
  sub_1000260D8();
  sub_100061348((void *)&_mh_execute_header, v0, v1, "Unable to locate subfile with tag '%@'", v2, v3, v4, v5, v6);
}

void sub_100063ACC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100064018(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100064444(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000648C8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100064CF4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100065E04(id a1)
{
  uint64_t v1 = objc_opt_new();
  id v2 = +[UARPTLVPersonalizationRequiredBackDeploy metaDataTableEntry];
  [v1 addObject:v2];

  id v3 = +[UARPTLVPersonalizationPayloadTagBackDeploy metaDataTableEntry];
  [v1 addObject:v3];

  id v4 = +[UARPTLVPersonalizationSuperBinaryAssetIDBackDeploy metaDataTableEntry];
  [v1 addObject:v4];

  id v5 = +[UARPTLVPersonalizationManifestPrefixBackDeploy metaDataTableEntry];
  [v1 addObject:v5];

  id v6 = +[UARPTLVPersonalizationBoardIDBackDeploy metaDataTableEntry];
  [v1 addObject:v6];

  id v7 = +[UARPTLVPersonalizationChipIDBackDeploy metaDataTableEntry];
  [v1 addObject:v7];

  id v8 = +[UARPTLVPersonalizationECIDBackDeploy metaDataTableEntry];
  [v1 addObject:v8];

  id v9 = +[UARPTLVPersonalizationECIDDataBackDeploy metaDataTableEntry];
  [v1 addObject:v9];

  id v10 = +[UARPTLVPersonalizationNonceBackDeploy metaDataTableEntry];
  [v1 addObject:v10];

  id v11 = +[UARPTLVPersonalizationNonceHashBackDeploy metaDataTableEntry];
  [v1 addObject:v11];

  id v12 = +[UARPTLVPersonalizationSecurityDomainBackDeploy metaDataTableEntry];
  [v1 addObject:v12];

  id v13 = +[UARPTLVPersonalizationSecurityModeBackDeploy metaDataTableEntry];
  [v1 addObject:v13];

  id v14 = +[UARPTLVPersonalizationProductionModeBackDeploy metaDataTableEntry];
  [v1 addObject:v14];

  id v15 = +[UARPTLVPersonalizationChipEpochBackDeploy metaDataTableEntry];
  [v1 addObject:v15];

  id v16 = +[UARPTLVPersonalizationEnableMixMatchBackDeploy metaDataTableEntry];
  [v1 addObject:v16];

  id v17 = +[UARPTLVPersonalizationSuperBinaryPayloadIndexBackDeploy metaDataTableEntry];
  [v1 addObject:v17];

  id v18 = +[UARPTLVPersonalizationChipRevisionBackDeploy metaDataTableEntry];
  [v1 addObject:v18];

  id v19 = +[UARPTLVPersonalizationFTABSubfileTagBackDeploy metaDataTableEntry];
  [v1 addObject:v19];

  id v20 = +[UARPTLVPersonalizationFTABSubfileLongnameBackDeploy metaDataTableEntry];
  [v1 addObject:v20];

  id v21 = +[UARPTLVPersonalizationFTABSubfileDigestBackDeploy metaDataTableEntry];
  [v1 addObject:v21];

  id v22 = +[UARPTLVPersonalizationFTABSubfileHashAlgorithmBackDeploy metaDataTableEntry];
  [v1 addObject:v22];

  id v23 = +[UARPTLVPersonalizationFTABSubfileESECBackDeploy metaDataTableEntry];
  [v1 addObject:v23];

  id v24 = +[UARPTLVPersonalizationFTABSubfileEPROBackDeploy metaDataTableEntry];
  [v1 addObject:v24];

  id v25 = +[UARPTLVPersonalizationFTABSubfileTrustedBackDeploy metaDataTableEntry];
  [v1 addObject:v25];

  id v26 = +[UARPTLVPersonalizationSoCLiveNonceBackDeploy metaDataTableEntry];
  [v1 addObject:v26];

  id v27 = +[UARPTLVPersonalizationPrefixNeedsLogicalUnitNumberBackDeploy metaDataTableEntry];
  [v1 addObject:v27];

  id v28 = +[UARPTLVPersonalizationSuffixNeedsLogicalUnitNumberBackDeploy metaDataTableEntry];
  [v1 addObject:v28];

  id v29 = +[UARPTLVPersonalizationLogicalUnitNumberBackDeploy metaDataTableEntry];
  [v1 addObject:v29];

  id v30 = +[UARPTLVPersonalizationTicketNeedsLogicalUnitNumberBackDeploy metaDataTableEntry];
  [v1 addObject:v30];

  id v31 = +[UARPTLVHostPersonalizationRequiredBackDeploy metaDataTableEntry];
  [v1 addObject:v31];

  id v32 = +[UARPTLVRequiredPersonalizationOptionBackDeploy metaDataTableEntry];
  [v1 addObject:v32];

  id v33 = +[UARPTLVPersonalizationFTABPayloadBackDeploy metaDataTableEntry];
  [v1 addObject:v33];

  id v34 = +[UARPTLVPersonalizedManifestBackDeploy metaDataTableEntry];
  [v1 addObject:v34];

  id v35 = +[UARPTLVPersonalizationLifeBackDeploy metaDataTableEntry];
  [v1 addObject:v35];

  id v36 = +[UARPTLVPersonalizationProvisioningBackDeploy metaDataTableEntry];
  [v1 addObject:v36];

  id v37 = +[UARPTLVPersonalizationManifestEpochBackDeploy metaDataTableEntry];
  [v1 addObject:v37];

  id v38 = +[UARPTLVPersonalizationManifestSuffixBackDeploy metaDataTableEntry];
  [v1 addObject:v38];

  uint64_t v39 = +[NSArray arrayWithArray:v1];
  uint64_t v40 = (void *)qword_1000B95B0;
  qword_1000B95B0 = (uint64_t)v39;
}

double sub_100068DE0()
{
  uint64_t v0 = dlopen("/usr/lib/libFDR.dylib", 261);
  if (!v0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069A64();
    }
    goto LABEL_161;
  }
  uint64_t v1 = v0;
  *(void *)&xmmword_1000B95C0 = dlsym(v0, "AMFDRCreateWithOptions");
  if (!(void)xmmword_1000B95C0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069AE8();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B95C0 + 1) = dlsym(v1, "AMFDRCreatePermissionsString");
  if (!*((void *)&xmmword_1000B95C0 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069B70();
    }
    goto LABEL_161;
  }
  qword_1000B95D0 = (uint64_t)dlsym(v1, "AMFDRCreateInstanceString");
  if (!qword_1000B95D0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069BF8();
    }
    goto LABEL_161;
  }
  qword_1000B95D8 = (uint64_t)dlsym(v1, "AMFDRSetOption");
  if (!qword_1000B95D8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069C80();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B95E0 = dlsym(v1, "AMFDRSetSealingMap");
  if (!(void)xmmword_1000B95E0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069D08();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B95E0 + 1) = dlsym(v1, "AMFDRGetSealingMap");
  if (!*((void *)&xmmword_1000B95E0 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069D90();
    }
    goto LABEL_161;
  }
  qword_1000B95F0 = (uint64_t)dlsym(v1, "AMFDRSetRecoveryVerifier");
  if (!qword_1000B95F0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069E18();
    }
    goto LABEL_161;
  }
  qword_1000B95F8 = (uint64_t)dlsym(v1, "AMFDRGetOptions");
  if (!qword_1000B95F8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069EA0();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B9600 = dlsym(v1, "AMFDRGetInfo");
  if (!(void)xmmword_1000B9600)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069F28();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B9600 + 1) = dlsym(v1, "AMFDRGetCert");
  if (!*((void *)&xmmword_1000B9600 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_100069FB0();
    }
    goto LABEL_161;
  }
  qword_1000B9610 = (uint64_t)dlsym(v1, "AMFDRGetTrustError");
  if (!qword_1000B9610)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A038();
    }
    goto LABEL_161;
  }
  qword_1000B9618 = (uint64_t)dlsym(v1, "AMFDRCopyClientId");
  if (!qword_1000B9618)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A0C0();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B9620 = dlsym(v1, "AMFDRCopyUnderlyingDictionary");
  if (!(void)xmmword_1000B9620)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A148();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B9620 + 1) = dlsym(v1, "AMFDRLogSetHandler");
  if (!*((void *)&xmmword_1000B9620 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A1D0();
    }
    goto LABEL_161;
  }
  qword_1000B9630 = (uint64_t)dlsym(v1, "AMFDRPerformManifestCheck");
  if (!qword_1000B9630)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A258();
    }
    goto LABEL_161;
  }
  qword_1000B9638 = (uint64_t)dlsym(v1, "AMFDRAppendPermissionsString");
  if (!qword_1000B9638)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A2E0();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B9640 = dlsym(v1, "AMFDRDataCopyDigest");
  if (!(void)xmmword_1000B9640)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A368();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B9640 + 1) = dlsym(v1, "AMFDRDataPresent");
  if (!*((void *)&xmmword_1000B9640 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A3F0();
    }
    goto LABEL_161;
  }
  qword_1000B9650 = (uint64_t)dlsym(v1, "AMFDRDataCopy");
  if (!qword_1000B9650)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A478();
    }
    goto LABEL_161;
  }
  qword_1000B9658 = (uint64_t)dlsym(v1, "AMFDRDataMultiCopy");
  if (!qword_1000B9658)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A500();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B9660 = dlsym(v1, "AMFDRDataPut");
  if (!(void)xmmword_1000B9660)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A588();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B9660 + 1) = dlsym(v1, "AMFDRDataMultiPut");
  if (!*((void *)&xmmword_1000B9660 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A610();
    }
    goto LABEL_161;
  }
  qword_1000B9670 = (uint64_t)dlsym(v1, "AMFDRDataPrefetch");
  if (!qword_1000B9670)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A698();
    }
    goto LABEL_161;
  }
  qword_1000B9678 = (uint64_t)dlsym(v1, "AMFDRDataExport");
  if (!qword_1000B9678)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A720();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B9680 = dlsym(v1, "AMFDRDataMultiExport");
  if (!(void)xmmword_1000B9680)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A7A8();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B9680 + 1) = dlsym(v1, "AMFDRDataDelete");
  if (!*((void *)&xmmword_1000B9680 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A830();
    }
    goto LABEL_161;
  }
  qword_1000B9690 = (uint64_t)dlsym(v1, "AMFDRDataMultiDelete");
  if (!qword_1000B9690)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A8B8();
    }
    goto LABEL_161;
  }
  qword_1000B9698 = (uint64_t)dlsym(v1, "AMFDRDataCopyTrustObject");
  if (!qword_1000B9698)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A940();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B96A0 = dlsym(v1, "AMFDRDataCopySslRoots");
  if (!(void)xmmword_1000B96A0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006A9C8();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B96A0 + 1) = dlsym(v1, "AMFDRDataIterate");
  if (!*((void *)&xmmword_1000B96A0 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006AA50();
    }
    goto LABEL_161;
  }
  qword_1000B96B0 = (uint64_t)dlsym(v1, "AMFDRDataRecover");
  if (!qword_1000B96B0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006AAD8();
    }
    goto LABEL_161;
  }
  qword_1000B96B8 = (uint64_t)dlsym(v1, "AMFDRDataLocalCreateFullKey");
  if (!qword_1000B96B8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006AB60();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B96C0 = dlsym(v1, "AMFDRSealingMapCreateRecoveryPermissions");
  if (!(void)xmmword_1000B96C0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006ABE8();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B96C0 + 1) = dlsym(v1, "AMFDRSealingMapRecoverCurrentDevice");
  if (!*((void *)&xmmword_1000B96C0 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006AC70();
    }
    goto LABEL_161;
  }
  qword_1000B96D0 = (uint64_t)dlsym(v1, "AMFDRSealingMapGetEntry");
  if (!qword_1000B96D0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006ACF8();
    }
    goto LABEL_161;
  }
  qword_1000B96D8 = (uint64_t)dlsym(v1, "AMFDRSealingMapGetEntriesForDevice");
  if (!qword_1000B96D8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006AD80();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B96E0 = dlsym(v1, "AMFDRSealingMapCopyInstanceWithIdentifiers");
  if (!(void)xmmword_1000B96E0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006AE08();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B96E0 + 1) = dlsym(v1, "AMFDRSealingMapCopyRequiredIdentifiers");
  if (!*((void *)&xmmword_1000B96E0 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006AE90();
    }
    goto LABEL_161;
  }
  qword_1000B96F0 = (uint64_t)dlsym(v1, "AMFDRSealingMapCopyLocalData");
  if (!qword_1000B96F0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006AF18();
    }
    goto LABEL_161;
  }
  qword_1000B96F8 = (uint64_t)dlsym(v1, "AMFDRSealingMapCopyLocalDataForClass");
  if (!qword_1000B96F8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006AFA0();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B9700 = dlsym(v1, "AMFDRSealingMapCopyLocalMinimalManifestForInstance");
  if (!(void)xmmword_1000B9700)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B028();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B9700 + 1) = dlsym(v1, "AMFDRSealingMapVerifySealing");
  if (!*((void *)&xmmword_1000B9700 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B0B0();
    }
    goto LABEL_161;
  }
  qword_1000B9710 = (uint64_t)dlsym(v1, "AMFDRSealingMapCreateAndPopulateSealedData");
  if (!qword_1000B9710)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B138();
    }
    goto LABEL_161;
  }
  qword_1000B9718 = (uint64_t)dlsym(v1, "AMFDRSealingMapVerifyAndCommitSealedData");
  if (!qword_1000B9718)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B1C0();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B9720 = dlsym(v1, "AMFDRSealedDataCreateSealingRequest");
  if (!(void)xmmword_1000B9720)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B248();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B9720 + 1) = dlsym(v1, "AMFDRSealedDataCreate");
  if (!*((void *)&xmmword_1000B9720 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B2D0();
    }
    goto LABEL_161;
  }
  qword_1000B9730 = (uint64_t)dlsym(v1, "AMFDRSealedDataPopulate");
  if (!qword_1000B9730)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B358();
    }
    goto LABEL_161;
  }
  qword_1000B9738 = (uint64_t)dlsym(v1, "AMFDRCopyDisposableKeys");
  if (!qword_1000B9738)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B3E0();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_1000B9740 = dlsym(v1, "AMFDRCopyDeviceKeys");
  if (!(void)xmmword_1000B9740)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B468();
    }
    goto LABEL_161;
  }
  qword_1000B9750 = (uint64_t)dlsym(v1, "AMFDRDataPutForSysCfgKey");
  if (!qword_1000B9750)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B4F0();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_1000B9740 + 1) = dlsym(v1, "AMFDRCreateLocalPending");
  if (!*((void *)&xmmword_1000B9740 + 1))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B578();
    }
    goto LABEL_161;
  }
  qword_1000B9758 = (uint64_t)dlsym(v1, "AMFDRSealingMapSetMGCopyAnswer");
  if (!qword_1000B9758)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      sub_10006B600();
    }
LABEL_161:
    double result = 0.0;
    xmmword_1000B9740 = 0u;
    *(_OWORD *)&qword_1000B9750 = 0u;
    xmmword_1000B9720 = 0u;
    *(_OWORD *)&qword_1000B9730 = 0u;
    xmmword_1000B9700 = 0u;
    *(_OWORD *)&qword_1000B9710 = 0u;
    xmmword_1000B96E0 = 0u;
    *(_OWORD *)&qword_1000B96F0 = 0u;
    xmmword_1000B96C0 = 0u;
    *(_OWORD *)&qword_1000B96D0 = 0u;
    xmmword_1000B96A0 = 0u;
    *(_OWORD *)&qword_1000B96B0 = 0u;
    xmmword_1000B9680 = 0u;
    *(_OWORD *)&qword_1000B9690 = 0u;
    xmmword_1000B9660 = 0u;
    *(_OWORD *)&qword_1000B9670 = 0u;
    xmmword_1000B9640 = 0u;
    *(_OWORD *)&qword_1000B9650 = 0u;
    xmmword_1000B9620 = 0u;
    *(_OWORD *)&qword_1000B9630 = 0u;
    xmmword_1000B9600 = 0u;
    *(_OWORD *)&qword_1000B9610 = 0u;
    xmmword_1000B95E0 = 0u;
    *(_OWORD *)&qword_1000B95F0 = 0u;
    xmmword_1000B95C0 = 0u;
    *(_OWORD *)&qword_1000B95D0 = 0u;
  }
  return result;
}

uint64_t AMFDRLogSetHandler(uint64_t a1)
{
  uint64_t result = pthread_once(&stru_1000B8BA0, (void (*)(void))sub_100068DE0);
  id v3 = (uint64_t (*)(uint64_t))*((void *)&xmmword_1000B9620 + 1);
  if (*((void *)&xmmword_1000B9620 + 1))
  {
    return v3(a1);
  }
  return result;
}

void sub_100069A38(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void sub_100069A64()
{
  dlerror();
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load %s: %s\n", v1, v2, v3, v4, 2u);
}

void sub_100069AE8()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_100069B70()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_100069BF8()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_100069C80()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_100069D08()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_100069D90()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_100069E18()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_100069EA0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_100069F28()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_100069FB0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A038()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A0C0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A148()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A1D0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A258()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A2E0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A368()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A3F0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A478()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A500()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A588()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A610()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A698()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A720()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A7A8()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A830()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A8B8()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A940()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006A9C8()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006AA50()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006AAD8()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006AB60()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006ABE8()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006AC70()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006ACF8()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006AD80()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006AE08()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006AE90()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006AF18()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006AFA0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B028()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B0B0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B138()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B1C0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B248()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B2D0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B358()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B3E0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B468()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B4F0()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B578()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void sub_10006B600()
{
  sub_100069A54();
  sub_100069A38((void *)&_mh_execute_header, &_os_log_default, v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

id FormatHex(uint64_t a1, unint64_t a2, int a3)
{
  id v6 = +[NSMutableString stringWithCapacity:0];
  id v7 = v6;
  char v43 = 0;
  uint64_t v42 = 0;
  if (a3) {
    CFStringRef v8 = @"00000000  ";
  }
  else {
    CFStringRef v8 = @"0000  ";
  }
  [v6 appendFormat:v8];
  if (a2)
  {
    unint64_t v9 = 0;
    id v10 = "%s %s\n%04x  ";
    if (a3) {
      id v10 = "%s %s\n%08x  ";
    }
    __format = (char *)v10;
    do
    {
      if (v9)
      {
        unint64_t v11 = v9 & 0xF;
        if ((v9 & 0xF) == 0)
        {
          char v41 = 0;
          uint64_t v40 = *(void *)(v9 + a1 - 16);
          do
          {
            int v12 = *((char *)&v40 + v11);
            if (v12 < 32 || v12 == 127 || *((unsigned char *)&v40 + v11) == 32) {
              *((unsigned char *)&v40 + v11) = 46;
            }
            ++v11;
          }
          while (v11 != 8);
          uint64_t v13 = 0;
          char v39 = 0;
          uint64_t v38 = *(void *)(v9 + a1 - 8);
          do
          {
            int v14 = *((char *)&v38 + v13);
            if (v14 < 32 || v14 == 127 || *((unsigned char *)&v38 + v13) == 32) {
              *((unsigned char *)&v38 + v13) = 46;
            }
            ++v13;
          }
          while (v13 != 8);
          snprintf(__str, 0x20uLL, __format, &v40, &v38, v9);
          objc_msgSend(v7, "appendFormat:", @"%s", __str);
        }
      }
      if (v9 + 8 >= a2)
      {
        objc_msgSend(v7, "appendFormat:", @"%02x ", *(unsigned __int8 *)(a1 + v9++));
      }
      else
      {
        uint64_t v15 = *(unsigned __int8 *)(a1 + v9);
        uint64_t v16 = *(unsigned __int8 *)(a1 + v9 + 1);
        if ((((_BYTE)v9 + 8) & 0xF) != 0) {
          snprintf(__str, 0x20uLL, "%02x %02x %02x %02x %02x %02x %02x %02x  ", v15, v16);
        }
        else {
          snprintf(__str, 0x20uLL, "%02x %02x %02x %02x %02x %02x %02x %02x    ", v15, v16);
        }
        objc_msgSend(v7, "appendFormat:", @"%s", __str);
        v9 += 8;
      }
    }
    while (v9 < a2);
    uint64_t v17 = 16;
    if ((a2 & 0xF) != 0) {
      uint64_t v17 = a2 & 0xF;
    }
    if (a2 <= 0xF) {
      unint64_t v18 = a2;
    }
    else {
      unint64_t v18 = v17;
    }
    if (a2 >= 0x10 && (a2 & 0xF) == 0)
    {
      [v7 appendString:@"   "];
      uint64_t v19 = 0;
      uint64_t v42 = *(void *)(v9 + a1 - 16);
      do
      {
        int v20 = *((char *)&v42 + v19);
        if (v20 < 32 || v20 == 127 || *((unsigned char *)&v42 + v19) == 32) {
          *((unsigned char *)&v42 + v19) = 46;
        }
        ++v19;
      }
      while (v19 != 8);
      id v21 = +[NSString stringWithUTF8String:&v42];
      [v7 appendString:v21];

      [v7 appendString:@" "];
      uint64_t v22 = 0;
      uint64_t v42 = *(void *)(v9 + a1 - 8);
      do
      {
        int v23 = *((char *)&v42 + v22);
        if (v23 < 32 || v23 == 127 || *((unsigned char *)&v42 + v22) == 32) {
          *((unsigned char *)&v42 + v22) = 46;
        }
        ++v22;
      }
      while (v22 != 8);
LABEL_77:
      id v34 = +[NSString stringWithUTF8String:&v42];
      [v7 appendString:v34];

      goto LABEL_78;
    }
  }
  else
  {
    unint64_t v18 = 0;
    unint64_t v9 = 0;
  }
  uint64_t v24 = 3;
  if (v18 < 9) {
    uint64_t v24 = 4;
  }
  unint64_t v25 = 3 * (16 - v18) + v24;
  do
  {
    [v7 appendString:@" "];
    --v25;
  }
  while (v25);
  unint64_t v26 = v18 - 8;
  if (v18 >= 8)
  {
    uint64_t v29 = 0;
    uint64_t v42 = *(void *)(a1 + v9 - v18);
    do
    {
      int v30 = *((char *)&v42 + v29);
      if (v30 < 32 || v30 == 127 || *((unsigned char *)&v42 + v29) == 32) {
        *((unsigned char *)&v42 + v29) = 46;
      }
      ++v29;
    }
    while (v29 != 8);
  }
  else
  {
    __memcpy_chk();
    *((unsigned char *)&v42 + v18) = 0;
    if (v18)
    {
      uint64_t v27 = 0;
      do
      {
        int v28 = *((char *)&v42 + v27);
        if (v28 < 32 || v28 == 127 || *((unsigned char *)&v42 + v27) == 32) {
          *((unsigned char *)&v42 + v27) = 46;
        }
        ++v27;
      }
      while (v27 < v18);
    }
    unint64_t v26 = 0;
  }
  id v31 = +[NSString stringWithUTF8String:&v42];
  [v7 appendString:v31];

  if (v26)
  {
    [v7 appendString:@" "];
    __memcpy_chk();
    uint64_t v32 = 0;
    *((unsigned char *)&v42 + v26) = 0;
    do
    {
      int v33 = *((char *)&v42 + v32);
      if (v33 < 32 || v33 == 127 || *((unsigned char *)&v42 + v32) == 32) {
        *((unsigned char *)&v42 + v32) = 46;
      }
      ++v32;
    }
    while (v26 > v32);
    goto LABEL_77;
  }
LABEL_78:
  return v7;
}

void sub_10006DE78()
{
  int v2 = 136315650;
  sub_10006132C();
  sub_100061374((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
}

void sub_10006DEEC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006DF64(unsigned __int8 *a1, NSObject *a2)
{
  int v2 = *a1;
  int v3 = a1[1];
  int v4 = a1[2];
  int v5 = a1[3];
  int v6 = 136316162;
  id v7 = "-[FTABFile parseFileData]";
  __int16 v8 = 1024;
  int v9 = v2;
  __int16 v10 = 1024;
  int v11 = v3;
  __int16 v12 = 1024;
  int v13 = v4;
  __int16 v14 = 1024;
  int v15 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: File tag parse error (%02x %02x %02x %02x)", (uint8_t *)&v6, 0x24u);
}

void sub_10006E018()
{
  sub_100061394();
  sub_100061364();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x18u);
}

void sub_10006E09C()
{
  v1[0] = 136315650;
  sub_100061394();
  __int16 v2 = 2048;
  uint64_t v3 = 16;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: Error parsing file offset list (offset=%u, length=%lu)", (uint8_t *)v1, 0x1Cu);
}

void sub_10006E12C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006E1A4()
{
  sub_100061364();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x3Cu);
}

void sub_10006E284()
{
  int v2 = 136315650;
  sub_10006132C();
  sub_100061374((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
}

void sub_10006E2F8(void *a1)
{
  os_log_t v1 = [a1 path];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Unable to create file at %@", v4, v5, v6, v7, v8);
}

void sub_10006E37C(void *a1)
{
  os_log_t v1 = [a1 path];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Unable to delete file at %@", v4, v5, v6, v7, v8);
}

void sub_10006E400(void *a1)
{
  os_log_t v1 = [a1 tag];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Failed to write '%@'", v4, v5, v6, v7, v8);
}

void sub_10006E484(void *a1)
{
  os_log_t v1 = [a1 tag];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Failed to write '%@' header", v4, v5, v6, v7, v8);
}

void sub_10006E508(void *a1)
{
  os_log_t v1 = [a1 absoluteString];
  sub_1000260D8();
  sub_10006130C((void *)&_mh_execute_header, v2, v3, "Failed to open file handle for writing to '%@'", v4, v5, v6, v7, v8);
}

uint64_t lzvn_decode_buffer(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2)
  {
    if (a3 <= a3 + a4 - 8) {
      __asm { BR              X17 }
    }
    __asm { BTI             j }
    return 0;
  }
  else
  {
    __asm { BTI             j }
    return 0;
  }
}

int32x4_t **lz4_encode_2gb(int32x4_t **result, uint64_t a2, char **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int32x4_t v7 = vdupq_n_s32(0xFFFFFFFF);
  uint8_t v8 = *result;
  int v9 = *a3;
  uint64_t v10 = (uint64_t)(*result)[-8].i64 + a2;
  if (v10 < (uint64_t)*result) {
    goto LABEL_92;
  }
  uint64_t v11 = (uint64_t)&v9[a5 - 128];
  if (v11 >= (uint64_t)v9)
  {
    do
    {
      __int16 v12 = v9;
      int v13 = &v9[-a4];
      while (1)
      {
        unint64_t v14 = *v12;
        int v15 = (int *)(a6 + 8 * ((-1640531535 * *v12) >> 20));
        int v16 = *v15;
        int v17 = v15[1];
        *int v15 = (int)v13;
        v15[1] = v14;
        unint64_t v18 = v14 >> 8;
        uint64_t v19 = (int *)(a6 + 8 * ((-1640531535 * (v14 >> 8)) >> 20));
        int v20 = *v19;
        int v21 = v19[1];
        *uint64_t v19 = v13 + 1;
        v19[1] = v14 >> 8;
        if (v14 == v17)
        {
          uint64_t v22 = (v13 - v16);
          if (v22 < 0x10000 && v22 != 0) {
            break;
          }
        }
        __int16 v12 = (void *)((char *)v12 + 1);
        uint64_t v24 = v13 + 1;
        unint64_t v25 = v14 >> 16;
        unint64_t v26 = (int *)(a6 + 8 * ((-1640531535 * v25) >> 20));
        int v27 = *v26;
        int v28 = v26[1];
        *unint64_t v26 = v24 + 1;
        v26[1] = v25;
        if (v18 == v21)
        {
          uint64_t v22 = (v24 - v20);
          if (v22 < 0x10000 && v24 != v20) {
            break;
          }
        }
        __int16 v12 = (void *)((char *)v12 + 1);
        int v30 = v24 + 1;
        unint64_t v31 = v25 >> 8;
        uint64_t v32 = (int *)(a6 + 8 * ((-1640531535 * (v25 >> 8)) >> 20));
        int v33 = *v32;
        int v34 = v32[1];
        *uint64_t v32 = v30 + 1;
        v32[1] = v25 >> 8;
        if (v25 == v28)
        {
          uint64_t v22 = (v30 - v27);
          if (v22 < 0x10000 && v30 != v27) {
            break;
          }
        }
        __int16 v12 = (void *)((char *)v12 + 1);
        id v36 = v30 + 1;
        unint64_t v37 = v25 >> 16;
        uint64_t v38 = (int *)(a6 + 8 * ((-1640531535 * v37) >> 20));
        int v39 = *v38;
        int v40 = v38[1];
        *uint64_t v38 = v36 + 1;
        v38[1] = v37;
        if (v31 == v34)
        {
          uint64_t v22 = (v36 - v33);
          if (v22 < 0x10000 && v36 != v33) {
            break;
          }
        }
        __int16 v12 = (void *)((char *)v12 + 1);
        uint64_t v42 = v36 + 1;
        if (v37 == v40)
        {
          uint64_t v22 = (v42 - v39);
          if (v22 < 0x10000 && v42 != v39) {
            break;
          }
        }
        __int16 v12 = (void *)((char *)v12 + 1);
        int v13 = v42 + 1;
        if ((unint64_t)v12 >= v11) {
          goto LABEL_74;
        }
      }
      off_t v44 = (char *)v12 + 4;
      unint64_t v45 = (void *)((char *)v12 - v22 + 4);
      while (1)
      {
        uint64_t v47 = *(void *)v44;
        v44 += 8;
        uint64_t v46 = v47;
        uint64_t v49 = *v45++;
        uint64_t v48 = v49;
        if (v46 != v49) {
          break;
        }
        if ((unint64_t)v44 >= v11) {
          goto LABEL_38;
        }
      }
      off_t v44 = &v44[(__clz(__rbit64(v46 ^ v48)) >> 3) - 8];
LABEL_38:
      ssize_t v50 = (char *)v12 - v22;
      while (1)
      {
        BOOL v51 = (uint64_t)v12 <= (uint64_t)v9 || (uint64_t)v50 <= a4;
        if (v51) {
          break;
        }
        int v53 = *((unsigned __int8 *)v12 - 1);
        __int16 v12 = (void *)((char *)v12 - 1);
        int v52 = v53;
        int v54 = *--v50;
        if (v52 != v54)
        {
          __int16 v12 = (void *)((char *)v12 + 1);
          break;
        }
      }
      unint64_t v55 = v44 - (char *)v12 - 4;
      uint64_t v56 = (char *)v12 - v9;
      unint64_t v57 = (char *)v12 - v9 + 3;
      unint64_t v58 = v10 - (void)v8 - v57;
      if (v10 - (uint64_t)v8 < v57) {
        goto LABEL_92;
      }
      __int8 v59 = (v55 & 0xF) + 16 * v56;
      uint64_t v60 = (int32x4_t *)&v8->i8[1];
      if ((unint64_t)v56 >= 0xF)
      {
        v59 |= 0xF0u;
        unint64_t v61 = v56 - 15;
        BOOL v62 = v58-- != 0;
        if (!v62) {
          goto LABEL_92;
        }
        if (v61 >= 0xFF)
        {
          unint64_t v63 = v61 / 0xFFuLL;
          BOOL v62 = v58 >= v63;
          v58 -= v63;
          if (!v62) {
            goto LABEL_92;
          }
          LOBYTE(v61) = v61 + v63;
          do
          {
            *v60++ = v7;
            BOOL v51 = v63 > 0x10;
            v63 -= 16;
          }
          while (v51);
          uint64_t v60 = (int32x4_t *)((char *)v60 + v63);
        }
        v60->i8[0] = v61;
        uint64_t v60 = (int32x4_t *)((char *)v60 + 1);
      }
      do
      {
        int32x4_t v64 = *(int32x4_t *)v9;
        v9 += 16;
        *v60++ = v64;
        BOOL v51 = v56 <= 16;
        v56 -= 16;
      }
      while (!v51);
      uint64_t v65 = (__int16 *)((char *)v60->i16 + v56);
      _WORD *v65 = v22;
      uint64_t v66 = (int32x4_t *)(v65 + 1);
      if (v55 >= 0xF)
      {
        v59 |= 0xFu;
        unint64_t v67 = v44 - (char *)v12 - 19;
        BOOL v62 = v58 != 0;
        unint64_t v68 = v58 - 1;
        if (!v62) {
          goto LABEL_92;
        }
        if (v67 >= 0xFF)
        {
          unint64_t v69 = v67 / 0xFFuLL;
          if (v68 < v69) {
            goto LABEL_92;
          }
          LOBYTE(v67) = v67 + v69;
          do
          {
            *v66++ = v7;
            BOOL v51 = v69 > 0x10;
            v69 -= 16;
          }
          while (v51);
          uint64_t v66 = (int32x4_t *)((char *)v66 + v69);
        }
        v66->i8[0] = v67;
        uint64_t v66 = (int32x4_t *)((char *)v66 + 1);
      }
      v8->i8[0] = v59;
      uint8_t v8 = v66;
      int v9 = v44;
    }
    while ((uint64_t)v44 < v11 && (uint64_t)v66 < v10);
  }
LABEL_74:
  if (a7) {
    goto LABEL_92;
  }
  uint64_t v71 = (char *)(v11 + 128);
  uint64_t v72 = v71 - v9;
  if (v71 == v9) {
    goto LABEL_92;
  }
  uint64_t v73 = v10 + 128 - (void)v8 - 1;
  BOOL v51 = v73 <= v72;
  uint64_t v74 = v73 - v72;
  if (v51) {
    goto LABEL_92;
  }
  if (v72 < 15)
  {
    v8->i8[0] = 16 * v72;
    uint8_t v8 = (int32x4_t *)((char *)v8 + 1);
    do
    {
LABEL_91:
      __int8 v81 = *v9++;
      v8->i8[0] = v81;
      uint8_t v8 = (int32x4_t *)((char *)v8 + 1);
    }
    while (v9 < v71);
    goto LABEL_92;
  }
  uint64_t v75 = v74 - 1;
  if (v75 >= 0)
  {
    v8->i8[0] = -16;
    uint64_t v76 = (int32x4_t *)&v8->i8[1];
    unsigned int v77 = v72 - 15;
    if ((unint64_t)(v72 - 15) >= 0xFF)
    {
      int64_t v78 = v77 / 0xFFuLL;
      if (v75 - v78 < 0)
      {
        uint8_t v8 = (int32x4_t *)((char *)v76 - 1);
        goto LABEL_92;
      }
      LOBYTE(v77) = v77 + v78;
      do
      {
        *v76++ = v7;
        BOOL v51 = v78 <= 16;
        v78 -= 16;
      }
      while (!v51);
      uint64_t v76 = (int32x4_t *)((char *)v76 + v78);
    }
    v76->i8[0] = v77;
    uint8_t v8 = (int32x4_t *)&v76->i8[1];
    uint64_t v79 = (unint64_t)v72 >> 4;
    if (!((unint64_t)v72 >> 4)) {
      goto LABEL_91;
    }
    do
    {
      int32x4_t v80 = *(int32x4_t *)v9;
      v9 += 16;
      *v8++ = v80;
      BOOL v51 = v79-- <= 1;
    }
    while (!v51);
    if (v9 < v71) {
      goto LABEL_91;
    }
  }
LABEL_92:
  *uint64_t result = v8;
  *a3 = v9;
  return result;
}

uint64_t lz4_decode_asm(int8x16_t **a1, unint64_t a2, unint64_t a3, unsigned __int8 **a4, unint64_t a5)
{
  uint64_t v5 = *a4;
  uint64_t v6 = *a1;
  while (1)
  {
    int32x4_t v7 = v6;
    uint8_t v8 = v5;
    if ((unint64_t)v5 >= a5 || (unint64_t)v6 >= a3) {
      break;
    }
    unsigned int v10 = *v5;
    int v9 = v5 + 1;
    unint64_t v11 = (unint64_t)v10 >> 4;
    unint64_t v12 = (v10 & 0xF) + 4;
    if (v11 > 0xE)
    {
      while ((unint64_t)v9 < a5)
      {
        unsigned int v13 = *(unsigned __int8 *)v9;
        int v9 = (_OWORD *)((char *)v9 + 1);
        v11 += v13;
        if (v13 != 255)
        {
          unint64_t v14 = (int8x16_t *)v9;
          int v15 = v6;
          int v16 = (unsigned __int16 *)((char *)v9 + v11);
          int v17 = (int8x16_t *)((char *)v6 + v11);
          if ((unint64_t)v16 < a5 && (unint64_t)v17 < a3)
          {
            int8x16_t v19 = *v14;
            int8x16_t v20 = v14[1];
            unint64_t v18 = v14 + 2;
            *int v15 = v19;
            v15[1] = v20;
            int v21 = v15 + 2;
            do
            {
              int8x16_t v22 = *v18;
              int8x16_t v23 = v18[1];
              v18 += 2;
              *int v21 = v22;
              v21[1] = v23;
              v21 += 2;
            }
            while (v17 > v21);
            goto LABEL_13;
          }
          goto LABEL_36;
        }
      }
      break;
    }
    int8x16_t *v6 = *(int8x16_t *)v9;
    int v16 = (unsigned __int16 *)((char *)v9 + v11);
    int v17 = (int8x16_t *)((char *)v6 + v11);
LABEL_13:
    if ((unint64_t)v16 >= a5) {
      break;
    }
    unsigned int v25 = *v16;
    uint64_t v5 = (unsigned __int8 *)(v16 + 1);
    unint64_t v24 = v25;
    if (!v25 || (unint64_t v26 = (int8x16_t *)((char *)v17 - v24), (unint64_t)v17 - v24 < a2))
    {
      uint64_t v47 = -1;
      goto LABEL_37;
    }
    int v27 = v17;
    uint64_t v6 = (int8x16_t *)((char *)v17 + v12);
    if (v12 == 19)
    {
      while ((unint64_t)v5 < a5)
      {
        unsigned int v28 = *v5++;
        uint64_t v6 = (int8x16_t *)((char *)v6 + v28);
        if (v28 != 255)
        {
          if ((unint64_t)v6 >= a3) {
            goto LABEL_36;
          }
          goto LABEL_24;
        }
      }
      break;
    }
    if (v12 > 0x10)
    {
LABEL_24:
      if (v24 > 0x1F)
      {
        int8x16_t v36 = *v26;
        id v35 = v26 + 1;
        *int v27 = v36;
        unint64_t v37 = v27 + 1;
        do
        {
          int8x16_t v38 = *v35;
          int8x16_t v39 = v35[1];
          v35 += 2;
          *unint64_t v37 = v38;
          v37[1] = v39;
          v37 += 2;
        }
        while (v6 > v37);
      }
      else if (v24 > 0xF)
      {
        int8x16_t v41 = *v26;
        int v40 = v26 + 1;
        *int v27 = v41;
        uint64_t v42 = v27 + 1;
        do
        {
          int8x16_t v44 = *v40;
          char v43 = v40 + 1;
          *uint64_t v42 = v44;
          unint64_t v45 = v42 + 1;
          int8x16_t v46 = *v43;
          int v40 = v43 + 1;
          *unint64_t v45 = v46;
          uint64_t v42 = v45 + 1;
        }
        while (v6 > v42);
      }
      else
      {
        uint64_t v29 = (int8x16_t *)&qword_1000714C0[4 * v24];
        int8x16_t v30 = vqtbl1q_s8(*v26, *v29);
        int8x16_t v31 = vqtbl1q_s8(*v26, v29[1]);
        uint64_t v32 = *((unsigned __int8 *)qword_1000716C0 + v24);
        *int v27 = v30;
        v27[1] = v31;
        int v33 = (int8x16_t *)((char *)v27 + v32);
        do
        {
          *int v33 = v30;
          v33[1] = v31;
          int v34 = (int8x16_t *)((char *)v33 + v32);
          *int v34 = v30;
          v34[1] = v31;
          int v33 = (int8x16_t *)((char *)v34 + v32);
        }
        while (v6 > v33);
      }
    }
    else if (v24 <= 0xF)
    {
      *int v27 = vqtbl1q_s8(*v26, *(int8x16_t *)&qword_1000714C0[4 * v24]);
    }
    else
    {
      *int v27 = *v26;
    }
  }
LABEL_36:
  uint64_t v47 = 0;
LABEL_37:
  *a4 = v8;
  *a1 = v7;
  return v47;
}

uint64_t lzfse_decode_lmd(uint64_t a1)
{
  os_log_t v1 = *(void **)(a1 + 24);
  uint64_t v2 = (uint64_t *)(*(void *)a1 + *(int *)(a1 + 120));
  uint64_t v3 = *(void *)(a1 + 104);
  uint64_t v4 = *(unsigned int *)(a1 + 112);
  uint64_t v5 = *(unsigned int *)(a1 + 72);
  unint64_t v6 = *(unsigned int *)(a1 + 88);
  unint64_t v7 = *(unsigned int *)(a1 + 92);
  unint64_t v8 = *(unsigned int *)(a1 + 96);
  unint64_t v9 = *(unsigned __int16 *)(a1 + 124);
  unint64_t v10 = *(unsigned __int16 *)(a1 + 126);
  unint64_t v11 = *(unsigned __int16 *)(a1 + 128);
  uint64_t v12 = *(void *)(a1 + 40) - (void)v1 - 32;
  unsigned int v13 = *(char **)(a1 + 80);
  if (v6 | v7) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 72))
  {
    while (1)
    {
      uint64_t v2 = (uint64_t *)((char *)v2 - ((unint64_t)(63 - v4) >> 3));
      if ((unint64_t)v2 < *(void *)(a1 + 8)) {
        return -3;
      }
      uint64_t v3 = *v2;
      unint64_t v14 = (unsigned __int8 *)(a1 + 136 + 8 * v9);
      uint64_t v15 = *v14;
      uint64_t v16 = v4 + ((63 - v4) & 0xFFFFFFFFFFFFFFF8) - v15;
      unint64_t v17 = (unint64_t)*v2 >> v16;
      unint64_t v18 = v17 & ~(-1 << v15);
      LOBYTE(v15) = v14[1];
      unint64_t v9 = (v18 >> v15) + *((unsigned __int16 *)v14 + 1);
      unint64_t v6 = (v17 & ~(-1 << v15)) + *((unsigned int *)v14 + 1);
      int8x16_t v19 = (unsigned __int8 *)(a1 + 648 + 8 * v10);
      uint64_t v20 = *v19;
      uint64_t v21 = v16 - v20;
      unint64_t v22 = (unint64_t)*v2 >> v21;
      unint64_t v23 = v22 & ~(-1 << v20);
      LOBYTE(v20) = v19[1];
      unint64_t v10 = (v23 >> v20) + *((unsigned __int16 *)v19 + 1);
      unint64_t v7 = (v22 & ~(-1 << v20)) + *((unsigned int *)v19 + 1);
      unint64_t v24 = (unsigned __int8 *)(a1 + 1160 + 8 * v11);
      uint64_t v25 = *v24;
      uint64_t v4 = v21 - v25;
      unint64_t v26 = (unint64_t)*v2 >> v4;
      unint64_t v27 = v26 & ~(-1 << v25);
      LOBYTE(v25) = v24[1];
      unint64_t v11 = (v27 >> v25) + *((unsigned __int16 *)v24 + 1);
      uint64_t v28 = (v26 & ~(-1 << v25)) + *((unsigned int *)v24 + 1);
      if (v28) {
        unint64_t v8 = v28;
      }
      --v5;
LABEL_7:
      if (v8 > (unint64_t)v1 + v6 - *(void *)(a1 + 32)
        || a1 + *(unsigned int *)(a1 + 7304) + 7308 < (uint64_t)&v13[v6])
      {
        return -3;
      }
      BOOL v29 = v12 < (uint64_t)(v6 + v7);
      v12 -= v6 + v7;
      if (v29)
      {
        uint64_t v40 = v12 + v6 + v7 + 32;
        if (v6)
        {
          do
          {
            BOOL v41 = v40-- != 0;
            if (!v41) {
              goto LABEL_30;
            }
            char v42 = *v13++;
            *(unsigned char *)os_log_t v1 = v42;
            os_log_t v1 = (void *)((char *)v1 + 1);
          }
          while (--v6);
        }
        if (v7)
        {
          char v43 = (char *)v1 - v8;
          while (1)
          {
            BOOL v41 = v40-- != 0;
            if (!v41) {
              break;
            }
            char v44 = *v43++;
            *(unsigned char *)os_log_t v1 = v44;
            os_log_t v1 = (void *)((char *)v1 + 1);
            if (!--v7) {
              goto LABEL_28;
            }
          }
LABEL_30:
          *(void *)(a1 + 24) = v1;
          *(void *)(a1 + 120) = (char *)v2 - *(void *)a1;
          *(void *)(a1 + 104) = v3;
          *(_DWORD *)(a1 + 112) = v4;
          *(_DWORD *)(a1 + 72) = v5;
          *(_DWORD *)(a1 + 88) = v6;
          *(_DWORD *)(a1 + 92) = v7;
          *(_DWORD *)(a1 + 96) = v8;
          *(_WORD *)(a1 + 124) = v9;
          *(_WORD *)(a1 + 126) = v10;
          *(_WORD *)(a1 + 128) = v11;
          *(void *)(a1 + 80) = v13;
          return -2;
        }
LABEL_28:
        uint64_t v12 = v40 - 32;
        if (!v5) {
          goto LABEL_29;
        }
      }
      else
      {
        do
        {
          uint64_t v30 = *(void *)v13;
          uint64_t v31 = *((void *)v13 + 1);
          v13 += 16;
          *os_log_t v1 = v30;
          v1[1] = v31;
          v1 += 2;
          BOOL v29 = v6 > 0x10;
          v6 -= 16;
        }
        while (v29);
        uint64_t v32 = (int8x16_t *)((char *)v1 + v6);
        v13 += v6;
        int v33 = (int8x16_t *)((char *)v32 - v8);
        if (v8 < 0x10)
        {
          int8x16_t v36 = (int8x16_t *)((char *)&unk_10007EA20 + 32 * v8);
          unint64_t v37 = byte_10007EC20[v8];
          int8x16_t v38 = vqtbl1q_s8(*v33, *v36);
          int8x16_t v39 = vqtbl1q_s8(*v33, v36[1]);
          do
          {
            *uint64_t v32 = v38;
            v32[1] = v39;
            uint64_t v32 = (int8x16_t *)((char *)v32 + v37);
            BOOL v29 = v7 > v37;
            v7 -= v37;
          }
          while (v29);
          os_log_t v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5) {
            goto LABEL_29;
          }
        }
        else
        {
          do
          {
            uint64_t v34 = v33->i64[0];
            uint64_t v35 = v33->i64[1];
            ++v33;
            v32->i64[0] = v34;
            v32->i64[1] = v35;
            ++v32;
            BOOL v29 = v7 > 0x10;
            v7 -= 16;
          }
          while (v29);
          os_log_t v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5) {
            goto LABEL_29;
          }
        }
      }
    }
  }
  else
  {
LABEL_29:
    *(void *)(a1 + 24) = v1;
    return 0;
  }
}

uint64_t lzfse_decode_literals(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, void **a5, unint64_t a6, double a7)
{
  uint64_t v7 = LOWORD(a7);
  uint64_t v8 = WORD1(a7);
  uint64_t v9 = WORD2(a7);
  uint64_t v10 = HIWORD(a7);
  unint64_t v12 = *(void *)a4;
  int v13 = *(_DWORD *)(a4 + 8);
  unint64_t v14 = *a5;
  while (1)
  {
    unsigned int v15 = *(_DWORD *)(a2 + 4 * v7);
    unsigned int v16 = *(_DWORD *)(a2 + 4 * v8);
    unsigned int v17 = *(_DWORD *)(a2 + 4 * v9);
    unsigned int v18 = *(_DWORD *)(a2 + 4 * v10);
    *a1++ = (v16 & 0xFF00)
          + ((unsigned __int16)(v15 & 0xFF00) >> 8)
          + (((v18 & 0xFF00) + ((unsigned __int16)(v17 & 0xFF00) >> 8)) << 16);
    unint64_t v19 = (63 - v13) & 0xFFFFFFF8;
    if (((63 - v13) & 0xFFFFFFF8) != 0) {
      break;
    }
LABEL_5:
    uint64_t v20 = v13 - v15;
    uint64_t v21 = v20 - v16;
    unint64_t v22 = v12 >> (v13 - v15);
    unint64_t v23 = v12 & qword_100071AA0[v20];
    uint64_t v24 = v21 - v17;
    uint64_t v7 = v22 + HIWORD(v15);
    unint64_t v25 = v23 >> (v20 - v16);
    unint64_t v26 = v23 & qword_100071AA0[v21];
    int v13 = v24 - v18;
    uint64_t v8 = v25 + HIWORD(v16);
    unint64_t v27 = v26 >> (v21 - v17);
    unint64_t v28 = v26 & qword_100071AA0[v24];
    uint64_t v9 = v27 + HIWORD(v17);
    unint64_t v29 = v28 >> (v24 - v18);
    unint64_t v12 = v28 & qword_100071AA0[v13];
    uint64_t v10 = v29 + HIWORD(v18);
    BOOL v30 = a3 <= 4;
    a3 -= 4;
    if (v30)
    {
      *(void *)a4 = v12;
      *(_DWORD *)(a4 + 8) = v13;
      *a5 = v14;
      return 0;
    }
  }
  unint64_t v14 = (void *)((char *)v14 - (v19 >> 3));
  if ((unint64_t)v14 >= a6)
  {
    v13 += v19;
    unint64_t v12 = (v12 << v19) | *v14 & qword_100071AA0[v19];
    goto LABEL_5;
  }
  return -3;
}

void sub_100071CA8()
{
  __assert_rtn("_AMAuthInstallFinalize", "AMAuthInstall.c", 686, "type != NULL");
}

void sub_100071CD4()
{
  __assert_rtn("_AMAuthInstallCopyFormattingDescription", "AMAuthInstall.c", 741, "type != NULL");
}

void sub_100071D00(uint64_t a1)
{
  uint64_t v2 = __error();
  char v3 = strerror(*v2);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4Stitch", a1, v4, v5, v6, v7, v8, v3);
  perror("error:");
}

void sub_100071D58()
{
  uint64_t v0 = __error();
  char v1 = strerror(*v0);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4Stitch", (uint64_t)"failed to write img4 string to dst file: %s", v2, v3, v4, v5, v6, v1);
  perror("error:");
}

void sub_100071DA8()
{
  uint64_t v0 = __error();
  char v1 = strerror(*v0);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4Stitch", (uint64_t)"failed to write header to dst file: %s", v2, v3, v4, v5, v6, v1);
  perror("error:");
}

void sub_100071DF8()
{
  __assert_rtn("_AMAuthInstallApImg4CreateDefaultRestoreInfo", "AMAuthInstallApImg4.c", 1376, "item->objectTag != NULL");
}

void sub_100071E24()
{
  __assert_rtn("_AMAuthInstallApImg4CreateDefaultRestoreInfo", "AMAuthInstallApImg4.c", 1382, "defaultTag->tag != NULL");
}

void sub_100071E50()
{
  __assert_rtn("_AMAuthInstallApImg4CreateDefaultRestoreInfo", "AMAuthInstallApImg4.c", 1383, "defaultTag->copyValue != NULL");
}

void sub_100071E7C()
{
  __assert_rtn("_AMAuthInstallCopyPsiMeasurementAndVersion", "AMAuthInstallBasebandICE3.c", 135, "outPartialHash != NULL");
}

void sub_100071EA8()
{
  __assert_rtn("_AMAuthInstallCopyPsiMeasurementAndVersion", "AMAuthInstallBasebandICE3.c", 136, "outVersionStr != NULL");
}

void sub_100071ED4()
{
  __assert_rtn("_AMAuthInstallBundlePopulatePersonalizedBundle", "AMAuthInstallBundle.c", 2394, "entryName != NULL");
}

void sub_100071F00()
{
  __assert_rtn("_AMAuthInstallBundlePopulatePersonalizedBundle", "AMAuthInstallBundle.c", 2544, "relativePath != NULL");
}

void sub_100071F2C()
{
  __assert_rtn("_AMAuthInstallBundlePopulatePersonalizedBundle", "AMAuthInstallBundle.c", 2465, "entryName != NULL");
}

void sub_100071F58()
{
  sub_1000260D8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "%{public}s", v1, 0xCu);
}

void sub_100071FCC()
{
  sub_1000260D8();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s", v1, 0xCu);
}

void sub_100072040()
{
  sub_1000260D8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%{public}s", v1, 0xCu);
}

void sub_1000720B4()
{
  sub_1000260D8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%s", v1, 0xCu);
}

void sub_100072128()
{
  __assert_rtn("_AMAuthInstallPlatformTempDirURLInitialize", "AMAuthInstallPlatform.c", 714, "_tempDirURL != NULL");
}

void sub_100072154()
{
  __assert_rtn("_CFDictionarySetInteger64", "AMAuthInstallSupport.c", 222, "num != NULL");
}

void sub_100072180()
{
  __assert_rtn("_CFDictionarySetInteger32", "AMAuthInstallSupport.c", 233, "num != NULL");
}

void sub_1000721AC()
{
  __assert_rtn("DERDecoderInitialize", "DERDecoder.c", 348, "decoder != NULL");
}

void sub_1000721D8()
{
  __assert_rtn("DERDecoderInitialize", "DERDecoder.c", 349, "buffer != NULL");
}

void sub_100072204()
{
  __assert_rtn("DERDecoderInitialize", "DERDecoder.c", 350, "ioBufferLength != NULL");
}

void sub_100072230()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 62, "buffer != NULL");
}

void sub_10007225C()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 63, "outTagClass != NULL");
}

void sub_100072288()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 64, "outTag != NULL");
}

void sub_1000722B4()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 65, "outIsConstructed != NULL");
}

void sub_1000722E0()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 66, "outConsumed != NULL");
}

void sub_10007230C()
{
  __assert_rtn("_DERDecodeLength", "DERDecoder.c", 146, "buffer != NULL");
}

void sub_100072338()
{
  __assert_rtn("_DERDecodeLength", "DERDecoder.c", 147, "outLength != NULL");
}

void sub_100072364()
{
  __assert_rtn("_DERDecodeLength", "DERDecoder.c", 148, "outConsumed != NULL");
}

void sub_100072390()
{
  __assert_rtn("DERDecoderGetDataWithTag", "DERDecoder.c", 418, "decoder != NULL");
}

void sub_1000723BC()
{
  __assert_rtn("DERDecoderGetDataWithTag", "DERDecoder.c", 434, "callbackData.foundItem.data != NULL");
}

void sub_1000723E8()
{
  __assert_rtn("_DERDecoderTraverseAllItems", "DERDecoder.c", 223, "decoder != NULL");
}

void sub_100072414()
{
}

void sub_100072440()
{
}

void sub_10007246C()
{
  __assert_rtn("DERDecoderGetEncodingWithTag", "DERDecoder.c", 468, "decoder != NULL");
}

void sub_100072498()
{
  __assert_rtn("DERDecoderGetEncodingWithTag", "DERDecoder.c", 484, "callbackData.foundItem.buffer != NULL");
}

void sub_1000724C4()
{
  __assert_rtn("_FlsParserFinalize", "FlsParser.cpp", 125, "type != NULL");
}

void sub_1000724F0()
{
  __assert_rtn("_FlsParserCopyFormattingDescription", "FlsParser.cpp", 143, "type != NULL");
}

void sub_10007251C()
{
  __assert_rtn("_FlsParserCopyDebugDescription", "FlsParser.cpp", 159, "type != NULL");
}

void sub_100072548()
{
  __assert_rtn("_AMRestoreCopyDeviceInfo", "AMRestore.c", 2141, "srcInfo != NULL");
}

void sub_100072574()
{
  __assert_rtn("_AMRestoreDestroyDeviceInfo", "AMRestore.c", 2186, "info != NULL");
}

uint64_t AMSupportCFDictionaryGetBoolean()
{
  return _AMSupportCFDictionaryGetBoolean();
}

uint64_t AMSupportCopyDataFromAsciiEncodedHex()
{
  return _AMSupportCopyDataFromAsciiEncodedHex();
}

uint64_t AMSupportCopyURLWithAppendedComponent()
{
  return _AMSupportCopyURLWithAppendedComponent();
}

uint64_t AMSupportCreateDataFromFileURL()
{
  return _AMSupportCreateDataFromFileURL();
}

uint64_t AMSupportCreateErrorInternal()
{
  return _AMSupportCreateErrorInternal();
}

uint64_t AMSupportCreateMergedDictionary()
{
  return _AMSupportCreateMergedDictionary();
}

uint64_t AMSupportCreateURLFromString()
{
  return _AMSupportCreateURLFromString();
}

uint64_t AMSupportDigestSha256()
{
  return _AMSupportDigestSha256();
}

uint64_t AMSupportFileURLExists()
{
  return _AMSupportFileURLExists();
}

uint64_t AMSupportGetValueForKeyPathInDict()
{
  return _AMSupportGetValueForKeyPathInDict();
}

uint64_t AMSupportHttpSendSync()
{
  return _AMSupportHttpSendSync();
}

uint64_t AMSupportLogInternal()
{
  return _AMSupportLogInternal();
}

uint64_t AMSupportLogSetHandler()
{
  return _AMSupportLogSetHandler();
}

uint64_t AMSupportSafeFree()
{
  return _AMSupportSafeFree();
}

uint64_t AMSupportSafeRelease()
{
  return _AMSupportSafeRelease();
}

uint64_t AMSupportSafeRetain()
{
  return _AMSupportSafeRetain();
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA1(data, len, md);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return _CC_SHA1_Final(md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return _CC_SHA1_Init(c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA1_Update(c, data, len);
}

unsigned __int8 *__cdecl CC_SHA256(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA256(data, len, md);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return _CC_SHA256_Final(md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return _CC_SHA256_Init(c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA256_Update(c, data, len);
}

unsigned __int8 *__cdecl CC_SHA384(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA384(data, len, md);
}

int CC_SHA384_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return _CC_SHA384_Final(md, c);
}

int CC_SHA384_Init(CC_SHA512_CTX *c)
{
  return _CC_SHA384_Init(c);
}

int CC_SHA384_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA384_Update(c, data, len);
}

int CC_SHA512_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return _CC_SHA512_Final(md, c);
}

int CC_SHA512_Init(CC_SHA512_CTX *c)
{
  return _CC_SHA512_Init(c);
}

int CC_SHA512_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA512_Update(c, data, len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  return _CFAllocatorCreate(allocator, context);
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  return _CFAllocatorGetDefault();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayContainsValue(theArray, range, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreate(allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return _CFArrayCreateMutableCopy(allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayGetFirstIndexOfValue(theArray, range, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return _CFArrayGetTypeID();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return _CFBooleanGetTypeID();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return _CFBundleCreate(allocator, bundleURL);
}

CFPlugInRef CFBundleGetPlugIn(CFBundleRef bundle)
{
  return _CFBundleGetPlugIn(bundle);
}

Boolean CFBundleLoadExecutableAndReturnError(CFBundleRef bundle, CFErrorRef *error)
{
  return _CFBundleLoadExecutableAndReturnError(bundle, error);
}

CFCalendarRef CFCalendarCopyCurrent(void)
{
  return _CFCalendarCopyCurrent();
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  uint64_t v3 = va_arg(va, const char *);
  return _CFCalendarDecomposeAbsoluteTime(calendar, at, v3);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return _CFDataCreateCopy(allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return _CFDataCreateMutable(allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return _CFDataCreateMutableCopy(allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return _CFDataCreateWithBytesNoCopy(allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return _CFDataGetMutableBytePtr(theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return _CFDataGetTypeID();
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryContainsKey(theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateCopy(allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateMutableCopy(allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return _CFDictionaryGetCount(theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return _CFEqual(cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return _CFErrorCopyDescription(err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return _CFErrorCreate(allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return _CFErrorGetCode(err);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return _CFGetAllocator(cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  return _CFHTTPMessageCreateRequest(alloc, requestMethod, url, httpVersion);
}

void CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData)
{
}

void CFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef value)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return _CFNotificationCenterGetDarwinNotifyCenter();
}

void CFNotificationCenterPostNotificationWithOptions(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, CFOptionFlags options)
{
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return _CFNumberCompare(number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  return _CFNumberFormatterCreate(allocator, locale, style);
}

CFNumberRef CFNumberFormatterCreateNumberFromString(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFOptionFlags options)
{
  return _CFNumberFormatterCreateNumberFromString(allocator, formatter, string, rangep, options);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return _CFNumberGetType(number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return _CFNumberGetTypeID();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

void CFPlugInSetLoadOnDemand(CFPlugInRef plugIn, Boolean flag)
{
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return _CFPreferencesCopyAppValue(key, applicationID);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppBooleanValue(key, applicationID, keyExistsAndHasValidFormat);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return _CFPropertyListCreateData(allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  return _CFPropertyListCreateDeepCopy(allocator, propertyList, mutabilityOption);
}

CFPropertyListRef CFPropertyListCreateFromXMLData(CFAllocatorRef allocator, CFDataRef xmlData, CFOptionFlags mutabilityOption, CFStringRef *errorString)
{
  return _CFPropertyListCreateFromXMLData(allocator, xmlData, mutabilityOption, errorString);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return _CFPropertyListCreateWithData(allocator, data, options, format, error);
}

CFDataRef CFPropertyListCreateXMLData(CFAllocatorRef allocator, CFPropertyListRef propertyList)
{
  return _CFPropertyListCreateXMLData(allocator, propertyList);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return _CFRunLoopRunInMode(mode, seconds, returnAfterSourceHandled);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

void CFStringAppendFormatAndArguments(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return _CFStringCreateArrayBySeparatingStrings(alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return _CFStringCreateByCombiningStrings(alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return _CFStringCreateCopy(alloc, theString);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return _CFStringCreateFromExternalRepresentation(alloc, data, encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return _CFStringCreateMutable(alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return _CFStringCreateMutableCopy(alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return _CFStringCreateWithBytes(alloc, bytes, numBytes, encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return _CFStringCreateWithCStringNoCopy(alloc, cStr, encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  return _CFStringCreateWithFileSystemRepresentation(alloc, buffer);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return _CFStringCreateWithFormat(alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return _CFStringCreateWithFormatAndArguments(alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return _CFStringCreateWithSubstring(alloc, str, range);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFRange v5 = _CFStringFind(theString, stringToFind, compareOptions);
  CFIndex length = v5.length;
  CFIndex location = v5.location;
  result.CFIndex length = length;
  result.CFIndex location = location;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return _CFStringFindAndReplace(theString, stringToFind, replacementString, rangeToSearch, compareOptions);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return _CFStringFindWithOptions(theString, stringToFind, rangeToSearch, searchOptions, result);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return _CFStringGetCharacterAtIndex(theString, idx);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return _CFStringGetFileSystemRepresentation(string, buffer, maxBufLen);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return _CFStringGetIntValue(str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return _CFStringGetLength(theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return _CFStringGetMaximumSizeForEncoding(length, encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return _CFStringHasPrefix(theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return _CFStringHasSuffix(theString, suffix);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

void CFStringPad(CFMutableStringRef theString, CFStringRef padString, CFIndex length, CFIndex indexIntoPad)
{
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return _CFURLCopyFileSystemPath(anURL, pathStyle);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return _CFURLCopyLastPathComponent(url);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return _CFURLCopyPath(anURL);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return _CFURLCopyPathExtension(url);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return _CFURLCopyScheme(anURL);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return _CFURLCreateCopyAppendingPathComponent(allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyAppendingPathExtension(CFAllocatorRef allocator, CFURLRef url, CFStringRef extension)
{
  return _CFURLCreateCopyAppendingPathExtension(allocator, url, extension);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return _CFURLCreateCopyDeletingLastPathComponent(allocator, url);
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  return _CFURLCreateCopyDeletingPathExtension(allocator, url);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return _CFURLCreateFromFileSystemRepresentation(allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return _CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return _CFURLCreateWithString(allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return _CFURLGetFileSystemRepresentation(url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return _CFURLGetString(anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return _CFURLGetTypeID();
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  return _CFURLHasDirectoryPath(anURL);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return _CFUUIDCreate(alloc);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return _CFUUIDCreateString(alloc, uuid);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return _CFUUIDGetConstantUUIDWithBytes(alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  CFUUIDBytes v3 = _CFUUIDGetUUIDBytes(uuid);
  uint64_t v2 = *(void *)&v3.byte8;
  uint64_t v1 = *(void *)&v3.byte0;
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  return _CFUserNotificationCancel(userNotification);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return _CFUserNotificationCreate(allocator, timeout, flags, error, dictionary);
}

SInt32 CFUserNotificationDisplayAlert(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle, CFStringRef alternateButtonTitle, CFStringRef otherButtonTitle, CFOptionFlags *responseFlags)
{
  return _CFUserNotificationDisplayAlert(timeout, flags, iconURL, soundURL, localizationURL, alertHeader, alertMessage, defaultButtonTitle, alternateButtonTitle, otherButtonTitle, responseFlags);
}

CFDictionaryRef CFUserNotificationGetResponseDictionary(CFUserNotificationRef userNotification)
{
  return _CFUserNotificationGetResponseDictionary(userNotification);
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  return _CFUserNotificationReceiveResponse(userNotification, timeout, responseFlags);
}

uint64_t DEREncoderAddData()
{
  return _DEREncoderAddData();
}

uint64_t DEREncoderAddDataFromEncoderNoCopy()
{
  return _DEREncoderAddDataFromEncoderNoCopy();
}

uint64_t DEREncoderAddDataNoCopy()
{
  return _DEREncoderAddDataNoCopy();
}

uint64_t DEREncoderAddPrivateFromEncoder()
{
  return _DEREncoderAddPrivateFromEncoder();
}

uint64_t DEREncoderAddSequenceFromEncoder()
{
  return _DEREncoderAddSequenceFromEncoder();
}

uint64_t DEREncoderAddSetFromEncoder()
{
  return _DEREncoderAddSetFromEncoder();
}

uint64_t DEREncoderAddUInt32()
{
  return _DEREncoderAddUInt32();
}

uint64_t DEREncoderAddUInt64()
{
  return _DEREncoderAddUInt64();
}

uint64_t DEREncoderCreate()
{
  return _DEREncoderCreate();
}

uint64_t DEREncoderCreateEncodedBuffer()
{
  return _DEREncoderCreateEncodedBuffer();
}

uint64_t DEREncoderDestroy()
{
  return _DEREncoderDestroy();
}

uint64_t DeviceIdentityCreateClientCertificateRequest()
{
  return _DeviceIdentityCreateClientCertificateRequest();
}

kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
{
  return _IOCreatePlugInInterfaceForService(service, pluginType, interfaceType, theInterface, theScore);
}

kern_return_t IODestroyPlugInInterface(IOCFPlugInInterface **interface)
{
  return _IODestroyPlugInInterface(interface);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return _IOIteratorNext(iterator);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return _IONotificationPortCreate(mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return _IOObjectRelease(object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return _IOObjectRetain(object);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperty(entry, key, allocator, options);
}

kern_return_t IORegistryEntryGetPath(io_registry_entry_t entry, const io_name_t plane, io_string_t path)
{
  return _IORegistryEntryGetPath(entry, plane, path);
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  return _IORegistryEntryGetRegistryEntryID(entry, entryID);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return _IOServiceAddInterestNotification(notifyPort, service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return _IOServiceAddMatchingNotification(notifyPort, notificationType, matching, callback, refCon, notification);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return _IOServiceMatching(name);
}

kern_return_t IOServiceWaitQuiet(io_service_t service, mach_timespec_t *waitTime)
{
  return _IOServiceWaitQuiet(service, waitTime);
}

uint64_t MAStringForMAAssetState()
{
  return _MAStringForMAAssetState();
}

uint64_t MGCopyAnswer()
{
  return _MGCopyAnswer();
}

void NSLog(NSString *format, ...)
{
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return _NSStringFromClass(aClass);
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithName(CFAllocatorRef allocator, const char *nodename)
{
  return _SCNetworkReachabilityCreateWithName(allocator, nodename);
}

Boolean SCNetworkReachabilityGetFlags(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags *flags)
{
  return _SCNetworkReachabilityGetFlags(target, flags);
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  return _SecItemAdd(attributes, result);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return _SecItemCopyMatching(query, result);
}

OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate)
{
  return _SecItemUpdate(query, attributesToUpdate);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFCopySystemVersionDictionary()
{
  return __CFCopySystemVersionDictionary();
}

uint64_t _CFRuntimeCreateInstance()
{
  return __CFRuntimeCreateInstance();
}

uint64_t _CFRuntimeRegisterClass()
{
  return __CFRuntimeRegisterClass();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void operator delete[](void *__p)
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void *__cdecl operator new[](size_t __sz)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int *__error(void)
{
  return ___error();
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

uint64_t __strlcat_chk()
{
  return ___strlcat_chk();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

int access(const char *a1, int a2)
{
  return _access(a1, a2);
}

int atoi(const char *a1)
{
  return _atoi(a1);
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return _calloc(__count, __size);
}

int close(int a1)
{
  return _close(a1);
}

int closedir(DIR *a1)
{
  return _closedir(a1);
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return _crc32(crc, buf, len);
}

int deflate(z_streamp strm, int flush)
{
  return _deflate(strm, flush);
}

int deflateEnd(z_streamp strm)
{
  return _deflateEnd(strm);
}

int deflateInit2_(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return _deflateInit2_(strm, level, method, windowBits, memLevel, strategy, version, stream_size);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return _dispatch_semaphore_create(value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return _dispatch_semaphore_signal(dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return _dispatch_semaphore_wait(dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

int dlclose(void *__handle)
{
  return _dlclose(__handle);
}

char *dlerror(void)
{
  return _dlerror();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return _dlopen(__path, __mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int feof(FILE *a1)
{
  return _feof(a1);
}

int ferror(FILE *a1)
{
  return _ferror(a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fread(__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return _fseek(a1, a2, a3);
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

uint64_t ftell(FILE *a1)
{
  return _ftell(a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

const z_crc_t *get_crc_table(void)
{
  return _get_crc_table();
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

pid_t getpid(void)
{
  return _getpid();
}

const char *getprogname(void)
{
  return _getprogname();
}

int inflate(z_streamp strm, int flush)
{
  return _inflate(strm, flush);
}

int inflateEnd(z_streamp strm)
{
  return _inflateEnd(strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return _inflateInit2_(strm, windowBits, version, stream_size);
}

int lstat(const char *a1, stat *a2)
{
  return _lstat(a1, a2);
}

void *__cdecl malloc(size_t __size)
{
  return _malloc(__size);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return _mkdir(a1, a2);
}

char *__cdecl mkdtemp(char *a1)
{
  return _mkdtemp(a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return _mmap(a1, a2, a3, a4, a5, a6);
}

long double modf(long double __x, long double *__y)
{
  return _modf(__x, __y);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

id objc_autoreleaseReturnValue(id a1)
{
  return _objc_autoreleaseReturnValue(a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return _objc_claimAutoreleasedReturnValue();
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_loadWeakRetained(id *location)
{
  return _objc_loadWeakRetained(location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return _objc_msgSendSuper2(a1, a2);
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t objc_opt_new()
{
  return _objc_opt_new();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

id objc_retainAutorelease(id a1)
{
  return _a1;
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return _a1;
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return _a1;
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return _objc_storeWeak(location, obj);
}

int objc_sync_enter(id obj)
{
  return _objc_sync_enter(obj);
}

int objc_sync_exit(id obj)
{
  return _objc_sync_exit(obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return _objc_unsafeClaimAutoreleasedReturnValue(a1);
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return _opendir(a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

void perror(const char *a1)
{
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return _pread(__fd, __buf, __nbyte, a4);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return _pthread_mach_thread_np(a1);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return _pthread_once(a1, a2);
}

pthread_t pthread_self(void)
{
  return _pthread_self();
}

int rand(void)
{
  return _rand();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return _readdir(a1);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return _readlink(a1, a2, a3);
}

void *__cdecl realloc(void *__ptr, size_t __size)
{
  return _realloc(__ptr, __size);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return _remove(__p, __ec);
}

void rewind(FILE *a1)
{
}

int rmdir(const char *a1)
{
  return _rmdir(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

void srand(unsigned int a1)
{
}

int sscanf(const char *a1, const char *a2, ...)
{
  return _sscanf(a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return _strchr(__s, __c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return _strndup(__s1, __n);
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  return _strsep(__stringp, __delim);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return _strtoull(__str, __endptr, __base);
}

int symlink(const char *a1, const char *a2)
{
  return _symlink(a1, a2);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
}

time_t time(time_t *a1)
{
  return _time(a1);
}

int unlink(const char *a1)
{
  return _unlink(a1);
}

int usleep(useconds_t a1)
{
  return _usleep(a1);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return _write(__fd, __buf, __nbyte);
}

id objc_msgSend_HTTPBody(void *a1, const char *a2, ...)
{
  return [a1 HTTPBody];
}

id objc_msgSend_HTTPMethod(void *a1, const char *a2, ...)
{
  return [a1 HTTPMethod];
}

id objc_msgSend_URL(void *a1, const char *a2, ...)
{
  return [a1 URL];
}

id objc_msgSend_URLByDeletingLastPathComponent(void *a1, const char *a2, ...)
{
  return [a1 URLByDeletingLastPathComponent];
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend__componentNameSuffix(void *a1, const char *a2, ...)
{
  return [a1 _componentNameSuffix];
}

id objc_msgSend__propertyNameSuffix(void *a1, const char *a2, ...)
{
  return [a1 _propertyNameSuffix];
}

id objc_msgSend_absoluteString(void *a1, const char *a2, ...)
{
  return [a1 absoluteString];
}

id objc_msgSend_allHTTPHeaderFields(void *a1, const char *a2, ...)
{
  return [a1 allHTTPHeaderFields];
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return [a1 array];
}

id objc_msgSend_asDictionary(void *a1, const char *a2, ...)
{
  return [a1 asDictionary];
}

id objc_msgSend_attributes(void *a1, const char *a2, ...)
{
  return [a1 attributes];
}

id objc_msgSend_boardID(void *a1, const char *a2, ...)
{
  return [a1 boardID];
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return [a1 BOOLValue];
}

id objc_msgSend_bootArgs(void *a1, const char *a2, ...)
{
  return [a1 bootArgs];
}

id objc_msgSend_bootNonce(void *a1, const char *a2, ...)
{
  return [a1 bootNonce];
}

id objc_msgSend_buildVersion(void *a1, const char *a2, ...)
{
  return [a1 buildVersion];
}

id objc_msgSend_bundlePath(void *a1, const char *a2, ...)
{
  return [a1 bundlePath];
}

id objc_msgSend_byteString(void *a1, const char *a2, ...)
{
  return [a1 byteString];
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return [a1 bytes];
}

id objc_msgSend_char1(void *a1, const char *a2, ...)
{
  return [a1 char1];
}

id objc_msgSend_char2(void *a1, const char *a2, ...)
{
  return [a1 char2];
}

id objc_msgSend_char3(void *a1, const char *a2, ...)
{
  return [a1 char3];
}

id objc_msgSend_char4(void *a1, const char *a2, ...)
{
  return [a1 char4];
}

id objc_msgSend_chipID(void *a1, const char *a2, ...)
{
  return [a1 chipID];
}

id objc_msgSend_cleanupAssets(void *a1, const char *a2, ...)
{
  return [a1 cleanupAssets];
}

id objc_msgSend_closeDevice(void *a1, const char *a2, ...)
{
  return [a1 closeDevice];
}

id objc_msgSend_closeInterface(void *a1, const char *a2, ...)
{
  return [a1 closeInterface];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_configureDataWriteDestination(void *a1, const char *a2, ...)
{
  return [a1 configureDataWriteDestination];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return [a1 data];
}

id objc_msgSend_dataLength(void *a1, const char *a2, ...)
{
  return [a1 dataLength];
}

id objc_msgSend_dataPointer(void *a1, const char *a2, ...)
{
  return [a1 dataPointer];
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return [a1 date];
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return [a1 defaultManager];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_digest(void *a1, const char *a2, ...)
{
  return [a1 digest];
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return [a1 domain];
}

id objc_msgSend_dumpString(void *a1, const char *a2, ...)
{
  return [a1 dumpString];
}

id objc_msgSend_ecID(void *a1, const char *a2, ...)
{
  return [a1 ecID];
}

id objc_msgSend_expandSuperBinary(void *a1, const char *a2, ...)
{
  return [a1 expandSuperBinary];
}

id objc_msgSend_expandTLVs(void *a1, const char *a2, ...)
{
  return [a1 expandTLVs];
}

id objc_msgSend_findLocalAsset(void *a1, const char *a2, ...)
{
  return [a1 findLocalAsset];
}

id objc_msgSend_findRemoteAsset(void *a1, const char *a2, ...)
{
  return [a1 findRemoteAsset];
}

id objc_msgSend_firmwareAsset(void *a1, const char *a2, ...)
{
  return [a1 firmwareAsset];
}

id objc_msgSend_freeDevice(void *a1, const char *a2, ...)
{
  return [a1 freeDevice];
}

id objc_msgSend_generatePersonalizedSuperBinary(void *a1, const char *a2, ...)
{
  return [a1 generatePersonalizedSuperBinary];
}

id objc_msgSend_generateRequestDictionary(void *a1, const char *a2, ...)
{
  return [a1 generateRequestDictionary];
}

id objc_msgSend_generateTLV(void *a1, const char *a2, ...)
{
  return [a1 generateTLV];
}

id objc_msgSend_generation(void *a1, const char *a2, ...)
{
  return [a1 generation];
}

id objc_msgSend_getLocalUrl(void *a1, const char *a2, ...)
{
  return [a1 getLocalUrl];
}

id objc_msgSend_getUpdateRequired(void *a1, const char *a2, ...)
{
  return [a1 getUpdateRequired];
}

id objc_msgSend_hasNetworkAccess(void *a1, const char *a2, ...)
{
  return [a1 hasNetworkAccess];
}

id objc_msgSend_initFile(void *a1, const char *a2, ...)
{
  return [a1 initFile];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_integerValue(void *a1, const char *a2, ...)
{
  return [a1 integerValue];
}

id objc_msgSend_isFileExistsError(void *a1, const char *a2, ...)
{
  return [a1 isFileExistsError];
}

id objc_msgSend_isRequired(void *a1, const char *a2, ...)
{
  return [a1 isRequired];
}

id objc_msgSend_lastPathComponent(void *a1, const char *a2, ...)
{
  return [a1 lastPathComponent];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_life(void *a1, const char *a2, ...)
{
  return [a1 life];
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return [a1 longLongValue];
}

id objc_msgSend_longname(void *a1, const char *a2, ...)
{
  return [a1 longname];
}

id objc_msgSend_magic(void *a1, const char *a2, ...)
{
  return [a1 magic];
}

id objc_msgSend_mainBundle(void *a1, const char *a2, ...)
{
  return [a1 mainBundle];
}

id objc_msgSend_majorVersion(void *a1, const char *a2, ...)
{
  return [a1 majorVersion];
}

id objc_msgSend_manifest(void *a1, const char *a2, ...)
{
  return [a1 manifest];
}

id objc_msgSend_manifestEpoch(void *a1, const char *a2, ...)
{
  return [a1 manifestEpoch];
}

id objc_msgSend_manifestSuffix(void *a1, const char *a2, ...)
{
  return [a1 manifestSuffix];
}

id objc_msgSend_measurements(void *a1, const char *a2, ...)
{
  return [a1 measurements];
}

id objc_msgSend_metaDataTable(void *a1, const char *a2, ...)
{
  return [a1 metaDataTable];
}

id objc_msgSend_metaDataTableEntry(void *a1, const char *a2, ...)
{
  return [a1 metaDataTableEntry];
}

id objc_msgSend_minorVersion(void *a1, const char *a2, ...)
{
  return [a1 minorVersion];
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return [a1 mutableCopy];
}

id objc_msgSend_needsHostPersonalization(void *a1, const char *a2, ...)
{
  return [a1 needsHostPersonalization];
}

id objc_msgSend_nonce(void *a1, const char *a2, ...)
{
  return [a1 nonce];
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return [a1 path];
}

id objc_msgSend_payloadData(void *a1, const char *a2, ...)
{
  return [a1 payloadData];
}

id objc_msgSend_personalizedData(void *a1, const char *a2, ...)
{
  return [a1 personalizedData];
}

id objc_msgSend_personalizedMetaData(void *a1, const char *a2, ...)
{
  return [a1 personalizedMetaData];
}

id objc_msgSend_prefixNeedsLogicalUnitNumber(void *a1, const char *a2, ...)
{
  return [a1 prefixNeedsLogicalUnitNumber];
}

id objc_msgSend_printDeviceWithExclusiveAccess(void *a1, const char *a2, ...)
{
  return [a1 printDeviceWithExclusiveAccess];
}

id objc_msgSend_processTLVsForPersonalization(void *a1, const char *a2, ...)
{
  return [a1 processTLVsForPersonalization];
}

id objc_msgSend_productionMode(void *a1, const char *a2, ...)
{
  return [a1 productionMode];
}

id objc_msgSend_provisioning(void *a1, const char *a2, ...)
{
  return [a1 provisioning];
}

id objc_msgSend_releaseVersion(void *a1, const char *a2, ...)
{
  return [a1 releaseVersion];
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return [a1 removeAllObjects];
}

id objc_msgSend_requiredTSSOptions(void *a1, const char *a2, ...)
{
  return [a1 requiredTSSOptions];
}

id objc_msgSend_results(void *a1, const char *a2, ...)
{
  return [a1 results];
}

id objc_msgSend_securityDomain(void *a1, const char *a2, ...)
{
  return [a1 securityDomain];
}

id objc_msgSend_securityMode(void *a1, const char *a2, ...)
{
  return [a1 securityMode];
}

id objc_msgSend_startService(void *a1, const char *a2, ...)
{
  return [a1 startService];
}

id objc_msgSend_state(void *a1, const char *a2, ...)
{
  return [a1 state];
}

id objc_msgSend_string(void *a1, const char *a2, ...)
{
  return [a1 string];
}

id objc_msgSend_stringByExpandingTildeInPath(void *a1, const char *a2, ...)
{
  return [a1 stringByExpandingTildeInPath];
}

id objc_msgSend_stringValue(void *a1, const char *a2, ...)
{
  return [a1 stringValue];
}

id objc_msgSend_subfiles(void *a1, const char *a2, ...)
{
  return [a1 subfiles];
}

id objc_msgSend_suffixNeedsLogicalUnitNumber(void *a1, const char *a2, ...)
{
  return [a1 suffixNeedsLogicalUnitNumber];
}

id objc_msgSend_tag(void *a1, const char *a2, ...)
{
  return [a1 tag];
}

id objc_msgSend_ticketName(void *a1, const char *a2, ...)
{
  return [a1 ticketName];
}

id objc_msgSend_ticketNeedsLogicalUnitNumber(void *a1, const char *a2, ...)
{
  return [a1 ticketNeedsLogicalUnitNumber];
}

id objc_msgSend_ticketPrefix(void *a1, const char *a2, ...)
{
  return [a1 ticketPrefix];
}

id objc_msgSend_timeIntervalSinceReferenceDate(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSinceReferenceDate];
}

id objc_msgSend_tlvType(void *a1, const char *a2, ...)
{
  return [a1 tlvType];
}

id objc_msgSend_tlvValue(void *a1, const char *a2, ...)
{
  return [a1 tlvValue];
}

id objc_msgSend_tlvs(void *a1, const char *a2, ...)
{
  return [a1 tlvs];
}

id objc_msgSend_trusted(void *a1, const char *a2, ...)
{
  return [a1 trusted];
}

id objc_msgSend_tssOption(void *a1, const char *a2, ...)
{
  return [a1 tssOption];
}

id objc_msgSend_tssRequest(void *a1, const char *a2, ...)
{
  return [a1 tssRequest];
}

id objc_msgSend_unsignedCharValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedCharValue];
}

id objc_msgSend_unsignedIntValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntValue];
}

id objc_msgSend_unsignedIntegerValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntegerValue];
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongLongValue];
}

id objc_msgSend_unsignedLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongValue];
}

id objc_msgSend_unsignedShortValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedShortValue];
}

id objc_msgSend_url(void *a1, const char *a2, ...)
{
  return [a1 url];
}

id objc_msgSend_userInfo(void *a1, const char *a2, ...)
{
  return [a1 userInfo];
}

id objc_msgSend_valid(void *a1, const char *a2, ...)
{
  return [a1 valid];
}

id objc_msgSend_variant(void *a1, const char *a2, ...)
{
  return [a1 variant];
}

id objc_msgSend_version(void *a1, const char *a2, ...)
{
  return [a1 version];
}

id objc_msgSend_wasLocal(void *a1, const char *a2, ...)
{
  return [a1 wasLocal];
}

id objc_msgSend_wasPurgeable(void *a1, const char *a2, ...)
{
  return [a1 wasPurgeable];
}

id objc_msgSend_writeToData(void *a1, const char *a2, ...)
{
  return [a1 writeToData];
}

id objc_msgSend_writeToDestination(void *a1, const char *a2, ...)
{
  return [a1 writeToDestination];
}

id objc_msgSend_writeToURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToURL:error:");
}